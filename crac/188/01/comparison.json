{"files":[{"patch":"@@ -39,1 +39,1 @@\n-        default: 'linux-x64, linux-x86-hs, linux-x64-variants, linux-cross-compile, alpine-linux-x64, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n+        default: 'linux-x64, linux-x64-variants, linux-cross-compile, alpine-linux-x64, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n@@ -65,1 +65,0 @@\n-      linux-x86-hs: ${{ steps.include.outputs.linux-x86-hs }}\n@@ -148,1 +147,0 @@\n-          echo \"linux-x86-hs=$(check_platform linux-x86-hs linux x86)\" >> $GITHUB_OUTPUT\n@@ -173,18 +171,0 @@\n-  build-linux-x86-hs:\n-    name: linux-x86-hs\n-    needs: prepare\n-    uses: .\/.github\/workflows\/build-linux.yml\n-    with:\n-      platform: linux-x86\n-      make-target: 'hotspot'\n-      gcc-major-version: '10'\n-      gcc-package-suffix: '-multilib'\n-      apt-architecture: 'i386'\n-      # Some multilib libraries do not have proper inter-dependencies, so we have to\n-      # install their dependencies manually.\n-      apt-extra-packages: 'libfreetype-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libffi-dev:i386'\n-      extra-conf-options: '--with-target-bits=32 --enable-fallback-linker --enable-libffi-bundling'\n-      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n-      make-arguments: ${{ github.event.inputs.make-arguments }}\n-    if: needs.prepare.outputs.linux-x86-hs == 'true'\n-\n","filename":".github\/workflows\/main.yml","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -332,2 +332,2 @@\n-<p>Note: The Windows 32-bit x86 port is deprecated and may be removed in\n-a future release.<\/p>\n+<p>Note: The 32-bit x86 port is deprecated and may be removed in a\n+future release.<\/p>\n@@ -396,2 +396,1 @@\n-be able to build the JDK. (Note: The Windows 32-bit x86 port is\n-deprecated and may be removed in a future release.)<\/p>\n+be able to build the JDK.<\/p>\n","filename":"doc\/building.html","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -137,2 +137,1 @@\n-Note: The Windows 32-bit x86 port is deprecated and may be removed in a future\n-release.\n+Note: The 32-bit x86 port is deprecated and may be removed in a future release.\n@@ -194,2 +193,1 @@\n-build the JDK. (Note: The Windows 32-bit x86 port is deprecated and may be\n-removed in a future release.)\n+build the JDK.\n","filename":"doc\/building.md","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,2 +111,1 @@\n-    --override-methods=summary \\\n-    --no-external-specs-page\n+    --override-methods=summary\n@@ -118,2 +117,1 @@\n-    -html5 -javafx --expand-requires transitive \\\n-    --no-external-specs-page\n+    -html5 -javafx --expand-requires transitive\n","filename":"make\/Docs.gmk","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -284,21 +284,0 @@\n-# Param 1 - dir to find debuginfo files in\n-FindDebuginfoFiles = \\\n-    $(wildcard $(addprefix $1\/*, $(DEBUGINFO_SUFFIXES)) \\\n-        $(addprefix $1\/*\/*, $(DEBUGINFO_SUFFIXES)) \\\n-        $(addprefix $1\/*\/*\/*, $(DEBUGINFO_SUFFIXES)))\n-\n-# Pick the correct debug info files to copy, either zipped or not.\n-ifeq ($(ZIP_EXTERNAL_DEBUG_SYMBOLS), true)\n-  DEBUGINFO_SUFFIXES += .diz\n-else\n-  DEBUGINFO_SUFFIXES := .debuginfo .pdb .map\n-  # On Macosx, if debug symbols have not been zipped, find all files inside *.dSYM\n-  # dirs.\n-  ifeq ($(call isTargetOs, macosx), true)\n-    $(call FillFindCache, \\\n-        $(SUPPORT_OUTPUTDIR)\/modules_libs $(SUPPORT_OUTPUTDIR)\/modules_cmds)\n-    FindDebuginfoFiles = \\\n-        $(if $(wildcard $1), $(call containing, .dSYM\/, $(call FindFiles, $1)))\n-  endif\n-endif\n-\n","filename":"make\/Images.gmk","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -457,0 +457,12 @@\n+$(eval $(call SetupTarget, static-launcher, \\\n+    MAKEFILE := StaticLibs, \\\n+    TARGET := static-launcher, \\\n+    DEPS := hotspot-static-libs static-libs, \\\n+))\n+\n+$(eval $(call SetupTarget, static-jdk-image, \\\n+    MAKEFILE := StaticLibs, \\\n+    TARGET := static-jdk-image, \\\n+    DEPS := static-exploded-image jdk-image, \\\n+))\n+\n@@ -1089,1 +1101,1 @@\n-  static-libs-image: hotspot-static-libs $(STATIC_LIBS_TARGETS)\n+  static-libs-image: hotspot-static-libs static-libs\n@@ -1091,1 +1103,1 @@\n-  static-libs-graal-image: $(STATIC_LIBS_TARGETS)\n+  static-libs-graal-image: static-libs\n@@ -1257,0 +1269,2 @@\n+static-exploded-image: static-launcher exploded-image\n+\n@@ -1299,1 +1313,1 @@\n-all-images: product-images test-image all-docs-images\n+all-images: product-images static-jdk-image test-image all-docs-images\n@@ -1312,1 +1326,1 @@\n-    docs-bundles all-docs-bundles test-image all-images \\\n+    docs-bundles all-docs-bundles test-image all-images static-exploded-image \\\n","filename":"make\/Main.gmk","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,17 @@\n+ifeq ($(MAKEFILE_PREFIX), Lib)\n+  # We need to keep track of what libraries are generated\/needed by this\n+  # module. This information is required when doing static linking, to know\n+  # which static library files to include. The variable $(MODULE)_INCLUDED_LIBS is\n+  # added to for each call to SetupJdkLibrary. The file module-included-libs.txt is then\n+  # read in StaticLibs.gmk.\n+  ifneq ($($(MODULE)_INCLUDED_LIBS), )\n+    LIBLIST := $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/$(MODULE)\/module-included-libs.txt\n+\n+    $(LIBLIST): $(TARGETS)\n+\t$(call MakeDir, $(@D))\n+\t$(ECHO) $($(MODULE)_INCLUDED_LIBS) > $@\n+\n+    TARGETS += $(LIBLIST)\n+  endif\n+endif\n+\n","filename":"make\/ModuleWrapper.gmk","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+default: all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n+\n+include CopyFiles.gmk\n+include Modules.gmk\n+include modules\/LauncherCommon.gmk\n+\n+################################################################################\n+#\n+# Create the static java launcher\n+#\n+################################################################################\n+\n+STATIC_JDK_IMAGE_DIR := $(IMAGES_OUTPUTDIR)\/static-jdk\n+STATIC_LAUNCHER_OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/static-native\/launcher\n+HOTSPOT_STATIC_LIB_PATH := $(HOTSPOT_OUTPUTDIR)\/*\/libjvm\/objs\/static\n+\n+ifneq ($(word 2, $(wildcard $(HOTSPOT_STATIC_LIB_PATH))), )\n+  $(error Cannot perform static linking when building more than one JVM library)\n+endif\n+\n+# Find all modules with static libraries\n+STATIC_LIB_MODULES := $(patsubst $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/%, \\\n+    %, $(wildcard $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/*))\n+\n+# Filter out known broken libraries. This is a temporary measure until\n+# proper support for these libraries can be provided.\n+ifeq ($(call isTargetOs, linux), true)\n+  # libsplashscreen has a name conflict with libawt in the function\n+  # BitmapToYXBandedRectangles, so we exclude it for now.\n+  BROKEN_STATIC_LIBS += splashscreen\n+else ifeq ($(call isTargetOs, macosx), true)\n+  # libosxsecurity has a name conflict with libosxapp in the function\n+  # JavaStringToNSString, so we exclude it for now.\n+  BROKEN_STATIC_LIBS += osxsecurity\n+else ifeq ($(call isTargetOs, windows), true)\n+  # libsplashscreen has a name conflict with libawt in the function\n+  # BitmapToYXBandedRectangles, so we exclude it for now.\n+  BROKEN_STATIC_LIBS += splashscreen\n+  # libsspi_bridge has name conflicts with sunmscapi\n+  BROKEN_STATIC_LIBS += sspi_bridge\n+  # These libs define DllMain which conflict with Hotspot\n+  BROKEN_STATIC_LIBS += awt dt_shmem dt_socket\n+  # These libs are dependent on any of the above disabled libs\n+  BROKEN_STATIC_LIBS += fontmanager jawt lcms net nio\n+endif\n+\n+$(foreach module, $(STATIC_LIB_MODULES), \\\n+    $(eval LIBS_$(module) := $(filter-out $(BROKEN_STATIC_LIBS), $(shell cat \\\n+    $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/$(module)\/module-included-libs.txt))) \\\n+)\n+\n+STATIC_LIB_FILES := $(foreach module, $(STATIC_LIB_MODULES), \\\n+    $(foreach lib, $(LIBS_$(module)), \\\n+    $(SUPPORT_OUTPUTDIR)\/native\/$(module)\/lib$(lib)\/static\/$(LIBRARY_PREFIX)$(lib)$(STATIC_LIBRARY_SUFFIX)))\n+\n+# Add Hotspot\n+STATIC_LIB_FILES += $(wildcard $(HOTSPOT_STATIC_LIB_PATH)\/$(LIBRARY_PREFIX)jvm$(STATIC_LIBRARY_SUFFIX))\n+\n+# Figure out what external libraries are required to link these static JDK\n+# libraries.\n+LIB_FLAGS_FILES := $(addsuffix .lib-flags.txt, $(STATIC_LIB_FILES))\n+\n+# Gather the lib flags from all individual libraries. There are many duplicates,\n+# so sort and just keep unique instances. On macOS, a common pattern is\n+# \"-framework FooFramework\", so we must make sure we keep the two words together.\n+EXTERNAL_LIBS := $(strip $(shell $(CAT) $(LIB_FLAGS_FILES) | \\\n+    $(SED) -e 's\/-framework \/-framework_\/g' | $(TR) ' ' '\\n' | $(SORT) -u | \\\n+    $(SED) -e 's\/-framework_\/-framework \/g'))\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  STATIC_LIBS := $(addprefix -force_load$(SPACE), $(STATIC_LIB_FILES))\n+  STANDARD_LIBS += -lstdc++\n+else ifeq ($(call isTargetOs, linux), true)\n+  STATIC_LIBS := -Wl,--export-dynamic -Wl,--whole-archive $(STATIC_LIB_FILES) -Wl,--no-whole-archive\n+  STANDARD_LIBS := -l:libstdc++.a\n+else ifeq ($(call isTargetOs, windows), true)\n+  STATIC_LIBS := $(addprefix -wholearchive:, $(STATIC_LIB_FILES))\n+else\n+  $(error Unsupported platform)\n+endif\n+\n+$(eval $(call SetupBuildLauncher, java, \\\n+    CFLAGS := -DEXPAND_CLASSPATH_WILDCARDS -DENABLE_ARG_FILES, \\\n+    EXTRA_RCFLAGS := $(JAVA_RCFLAGS), \\\n+    VERSION_INFO_RESOURCE := $(JAVA_VERSION_INFO_RESOURCE), \\\n+    OPTIMIZATION := HIGH, \\\n+    STATIC_LAUNCHER := true, \\\n+    LDFLAGS := $(LDFLAGS_STATIC_JDK), \\\n+    LIBS := $(STATIC_LIBS) $(EXTERNAL_LIBS) $(STANDARD_LIBS), \\\n+    OUTPUT_DIR := $(STATIC_LAUNCHER_OUTPUT_DIR), \\\n+    OBJECT_DIR := $(STATIC_LAUNCHER_OUTPUT_DIR), \\\n+))\n+\n+$(java): $(STATIC_LIB_FILES)\n+\n+TARGETS += $(java)\n+\n+JAVA_LAUNCHER := $(BUILD_LAUNCHER_java_TARGET)\n+\n+static-launcher: $(java)\n+\n+################################################################################\n+#\n+# Create the static-jdk image with the statically built java launcher\n+#\n+################################################################################\n+\n+# Until we get proper support in jlink for generating an image with static\n+# builds, we need to create the image ourselves. We base it on a normal\n+# dynamically linked JDK image.\n+\n+# All these files\/dirs should be copied as-is\n+JDK_IMAGE_COPY_FILES := $(addprefix $(JDK_IMAGE_DIR)\/, conf demo include jmods \\\n+    legal man\/man1\/java.1 release README)\n+\n+# We need to copy some files from lib, but not the dynamic libraries themselves\n+ALL_LIB_FILES := $(call FindFiles, $(JDK_IMAGE_DIR)\/lib)\n+\n+# Remove all dynamic libraries from the list\n+JDK_IMAGE_COPY_LIB_FILES := $(filter-out %$(SHARED_LIBRARY_SUFFIX), $(ALL_LIB_FILES))\n+# Remove all debug files from the list\n+ifeq ($(call isTargetOs, macosx), true)\n+  JDK_IMAGE_COPY_LIB_FILES := $(call not-containing, .dSYM, $(JDK_IMAGE_COPY_LIB_FILES))\n+else\n+  JDK_IMAGE_COPY_LIB_FILES := $(filter-out %.debuginfo %.pdb %.map, $(JDK_IMAGE_COPY_LIB_FILES))\n+endif\n+\n+static-jdk-info:\n+\t$(call LogWarn, Creating static-jdk image)\n+\n+$(eval $(call SetupCopyFiles, copy-from-jdk-image, \\\n+    SRC := $(JDK_IMAGE_DIR), \\\n+    DEST := $(STATIC_JDK_IMAGE_DIR), \\\n+    FILES := $(call FindFiles, $(JDK_IMAGE_COPY_FILES)) \\\n+        $(JDK_IMAGE_COPY_LIB_FILES), \\\n+))\n+\n+TARGETS += $(copy-from-jdk-image)\n+\n+$(copy-from-jdk-image): | static-jdk-info\n+\n+$(eval $(call SetupCopyFiles, copy-static-launcher, \\\n+    FILES := $(JAVA_LAUNCHER), \\\n+    DEST := $(STATIC_JDK_IMAGE_DIR)\/bin, \\\n+))\n+\n+TARGETS += $(copy-static-launcher)\n+\n+$(eval $(call SetupCopyFiles, copy-static-launcher-debuginfo, \\\n+    SRC := $(STATIC_LAUNCHER_OUTPUT_DIR), \\\n+    DEST := $(STATIC_JDK_IMAGE_DIR)\/bin, \\\n+    FILES := $(call FindDebuginfoFiles, $(STATIC_LAUNCHER_OUTPUT_DIR)), \\\n+))\n+\n+TARGETS += $(copy-static-launcher-debuginfo)\n+\n+static-jdk-image: $(copy-from-jdk-image) $(copy-static-launcher) $(copy-static-launcher-debuginfo)\n+\n+TARGETS += static-jdk-image\n+\n+all: $(TARGETS)\n+\n+.PHONY: all static-launcher static-jdk-image\n","filename":"make\/StaticLibs.gmk","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -473,1 +473,1 @@\n-  JVM_HEAP_LIMIT_64=\"1600\"\n+  JVM_HEAP_LIMIT_64=\"2048\"\n","filename":"make\/autoconf\/boot-jdk.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-  $2LDFLAGS_JDKLIB=\"$LDFLAGS_JDK_COMMON $BASIC_LDFLAGS_JDK_LIB_ONLY \\\n+  $2LDFLAGS_JDKLIB=\"$LDFLAGS_JDK_COMMON \\\n@@ -200,0 +200,3 @@\n+  $2LDFLAGS_STATIC_JDK=\"$BASIC_LDFLAGS $BASIC_LDFLAGS_JVM_ONLY \\\n+      $OS_LDFLAGS ${$2EXTRA_LDFLAGS} $REPRODUCIBLE_LDFLAGS $FILE_MACRO_LDFLAGS\"\n+\n@@ -201,1 +204,1 @@\n-      $DEBUGLEVEL_LDFLAGS $DEBUGLEVEL_LDFLAGS_JVM_ONLY $BASIC_LDFLAGS_ONLYCXX \\\n+      $DEBUGLEVEL_LDFLAGS $DEBUGLEVEL_LDFLAGS_JVM_ONLY \\\n@@ -208,0 +211,2 @@\n+  AC_SUBST($2LDFLAGS_STATIC_JDK)\n+\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -372,0 +372,1 @@\n+        LDFLAGS_STATIC_JDK=\"$LDFLAGS_STATIC_JDK $GCOV_LDFLAGS\"\n@@ -466,0 +467,1 @@\n+        LDFLAGS_STATIC_JDK=\"$LDFLAGS_STATIC_JDK $ASAN_LDFLAGS\"\n@@ -499,0 +501,1 @@\n+        LDFLAGS_STATIC_JDK=\"$LDFLAGS_STATIC_JDK $LSAN_LDFLAGS\"\n@@ -541,0 +544,1 @@\n+        LDFLAGS_STATIC_JDK=\"$LDFLAGS_STATIC_JDK $UBSAN_LDFLAGS\"\n","filename":"make\/autoconf\/jdk-options.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -669,8 +669,11 @@\n-  # if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n-  #   if test \"x$enable_deprecated_ports\" = \"xyes\"; then\n-  #     AC_MSG_WARN([The x86 port is deprecated and may be removed in a future release.])\n-  #   else\n-  #     AC_MSG_ERROR(m4_normalize([The 32-bit x86 port is deprecated and may be removed in a future release.\n-  #       Use --enable-deprecated-ports=yes to suppress this error.]))\n-  #   fi\n-  # fi\n+  # Unfortunately, variants have not been parsed yet, so we have to check the configure option\n+  # directly. Allow only the directly specified Zero variant, treat any other mix as containing\n+  # something non-Zero.\n+  if test \"x$OPENJDK_TARGET_CPU\" = xx86 && test \"x$with_jvm_variants\" != xzero; then\n+    if test \"x$enable_deprecated_ports\" = \"xyes\"; then\n+      AC_MSG_WARN([The 32-bit x86 port is deprecated and may be removed in a future release.])\n+    else\n+      AC_MSG_ERROR(m4_normalize([The 32-bit x86 port is deprecated and may be removed in a future release.\n+        Use --enable-deprecated-ports=yes to suppress this error.]))\n+    fi\n+  fi\n","filename":"make\/autoconf\/platform.m4","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -562,0 +562,3 @@\n+# LDFLAGS used to link the static jdk library\n+LDFLAGS_STATIC_JDK := @LDFLAGS_STATIC_JDK@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-      found_files=$($ECHO $(ls $1\/$file 2> \/dev\/null))\n+      found_files=$($ECHO $($LS -d $1\/$file 2> \/dev\/null))\n","filename":"make\/autoconf\/util.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,0 +310,23 @@\n+\n+# Find native debuginfo files in a directory\n+#\n+# Param 1 - dir to find debuginfo files in\n+FindDebuginfoFiles = \\\n+    $(wildcard $(addprefix $1\/*, $(DEBUGINFO_SUFFIXES)) \\\n+        $(addprefix $1\/*\/*, $(DEBUGINFO_SUFFIXES)) \\\n+        $(addprefix $1\/*\/*\/*, $(DEBUGINFO_SUFFIXES)))\n+\n+# Pick the correct debug info files to copy, either zipped or not.\n+ifeq ($(ZIP_EXTERNAL_DEBUG_SYMBOLS), true)\n+  DEBUGINFO_SUFFIXES += .diz\n+else\n+  DEBUGINFO_SUFFIXES := .debuginfo .pdb .map\n+  # On Macosx, if debug symbols have not been zipped, find all files inside *.dSYM\n+  # dirs.\n+  ifeq ($(call isTargetOs, macosx), true)\n+    $(call FillFindCache, \\\n+        $(SUPPORT_OUTPUTDIR)\/modules_libs $(SUPPORT_OUTPUTDIR)\/modules_cmds)\n+    FindDebuginfoFiles = \\\n+        $(if $(wildcard $1), $(call containing, .dSYM\/, $(call FindFiles, $1)))\n+  endif\n+endif\n","filename":"make\/common\/FileUtils.gmk","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -278,0 +278,2 @@\n+#   ONLY_EXPORTED -- if true, this library will be flagged as not\n+#     to be included for this module when building static libs\n@@ -306,0 +308,9 @@\n+  ifneq ($$(MODULE), )\n+    # Record the fact that this native library is part of the current module\n+    # (unless told otherwise). This variable stores information about all\n+    # created libraries, and is read by ModuleWrapper.\n+    ifneq ($$($1_ONLY_EXPORTED), true)\n+      $$(MODULE)_INCLUDED_LIBS += $$($1_NAME)\n+    endif\n+  endif\n+\n@@ -425,1 +436,1 @@\n-      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKEXE)) $$($1_LDFLAGS)\n+      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKEXE) $$($1_LDFLAGS))\n@@ -428,1 +439,1 @@\n-      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKLIB)) $$($1_LDFLAGS)\n+      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKLIB) $$($1_LDFLAGS))\n","filename":"make\/common\/JdkNativeCompilation.gmk","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+# STATIC_LAUNCHER   If true, will use settings for building a static launcher\n@@ -123,0 +124,9 @@\n+  ifneq ($$($1_STATIC_LAUNCHER), true)\n+      $1_JDK_LIBS := java.base:libjli\n+      $1_JDK_LIBS_windows := java.base:libjava\n+  else\n+    ifneq ($(findstring $(TOOLCHAIN_TYPE), gcc clang), )\n+      $1_LDFLAGS_FILTER_OUT := -Wl$(COMMA)--exclude-libs$(COMMA)ALL\n+    endif\n+  endif\n+\n@@ -143,2 +153,3 @@\n-      JDK_LIBS := java.base:libjli, \\\n-      JDK_LIBS_windows := java.base:libjava, \\\n+      LDFLAGS_FILTER_OUT := $$($1_LDFLAGS_FILTER_OUT), \\\n+      JDK_LIBS := $$($1_JDK_LIBS), \\\n+      JDK_LIBS_windows := $$($1_JDK_LIBS_windows), \\\n@@ -153,0 +164,1 @@\n+      OBJECT_DIR := $$($1_OBJECT_DIR), \\\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+\t$$(ECHO) $$(strip $$($1_LIBS) $$($1_EXTRA_LIBS)) > $$($1_TARGET).lib-flags.txt\n","filename":"make\/common\/native\/Link.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-\t        $$($1_LD_OBJ_ARG) $$($1_RES))\n+\t        $$($1_LD_OBJ_ARG))\n+\t$$(ECHO) $$(strip $$($1_LIBS) $$($1_EXTRA_LIBS)) > $$($1_TARGET).lib-flags.txt\n","filename":"make\/common\/native\/LinkMicrosoft.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        \"windows-x64\", \"windows-x86\", \"windows-aarch64\",\n+        \"windows-x64\", \"windows-aarch64\",\n@@ -468,9 +468,0 @@\n-        \"windows-x86\": {\n-            target_os: \"windows\",\n-            target_cpu: \"x86\",\n-            build_cpu: \"x64\",\n-            dependencies: [\"devkit\", \"gtest\"],\n-            configure_args: concat(common.configure_args_32bit,\n-                \"--enable-deprecated-ports\"),\n-        },\n-\n@@ -719,4 +710,0 @@\n-        \"windows-x86\": {\n-            platform: \"windows-x86\",\n-            jdk_suffix: \"zip\",\n-        },\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -181,0 +181,6 @@\n+  else ifeq ($(call isCompiler, clang), true)\n+    JVM_CFLAGS_FEATURES += -flto -fno-strict-aliasing\n+    ifeq ($(call isBuildOs, aix), true)\n+      JVM_CFLAGS_FEATURES += -ffat-lto-objects\n+    endif\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto -fno-strict-aliasing\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.regex.Pattern;\n@@ -1245,1 +1246,2 @@\n-                .filter(p -> !Files.isDirectory(p))\n+                .filter(p -> p.toFile().isFile())\n+                .filter(p -> p.getFileName().toString().matches(\"africa|antarctica|asia|australasia|backward|etcetera|europe|northamerica|southamerica\"))\n@@ -1276,0 +1278,5 @@\n+    \/\/\n+    \/\/ The default entries from CLDR's windowsZones.xml file can be modified\n+    \/\/ with <tzDataDir>\/tzmappings.override where mapping overrides\n+    \/\/ can be specified.\n+    private static Pattern OVERRIDE_PATTERN = Pattern.compile(\"(?<win>([^:]+:[^:]+)):(?<java>[^:]+):\");\n@@ -1278,0 +1285,14 @@\n+        var override = Path.of(tzDataDir, \"tzmappings.override\");\n+        if (override.toFile().exists()) {\n+            Files.readAllLines(override).stream()\n+                .map(String::trim)\n+                .filter(o -> !o.isBlank() && !o.startsWith(\"#\"))\n+                .forEach(o -> {\n+                    var m = OVERRIDE_PATTERN.matcher(o);\n+                    if (m.matches()) {\n+                        handlerWinZones.put(m.group(\"win\"), m.group(\"java\"));\n+                    } else {\n+                        System.out.printf(\"Unrecognized tzmappings override: %s. Ignored%n\", o);\n+                    }\n+                });\n+        }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -171,0 +171,5 @@\n+  ifneq ($(ENABLE_HEADLESS_ONLY), true)\n+    # We cannot link with both awt_headless and awt_xawt at the same time\n+    LIBAWT_HEADLESS_ONLY_EXPORTED := true\n+  endif\n+\n@@ -175,0 +180,1 @@\n+      ONLY_EXPORTED := $(LIBAWT_HEADLESS_ONLY_EXPORTED), \\\n@@ -311,0 +317,2 @@\n+  LIBAWT_LWAWT_STATIC_EXCLUDE_OBJS := systemScale.o\n+\n@@ -349,0 +357,1 @@\n+      STATIC_LIB_EXCLUDE_OBJS := $(LIBAWT_LWAWT_STATIC_EXCLUDE_OBJS), \\\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -158,0 +158,3 @@\n+    LIBJAVA_JPEG_OBJS := $(sort $(patsubst %.c,%.o, $(filter-out imageioJPEG.c, \\\n+        $(notdir $(wildcard $(TOPDIR)\/src\/java.desktop\/share\/native\/libjavajpeg\/*.c)))))\n+    LIBSPLASHSCREEN_STATIC_LIB_EXCLUDE_OBJS += $(LIBJAVA_JPEG_OBJS)\n@@ -168,0 +171,4 @@\n+    LIBZIP_SRC_PATH := $(TOPDIR)\/src\/java.base\/share\/native\/libzip\n+    LIBZIP_OBJS := $(sort $(patsubst %.c,%.o, $(notdir \\\n+        $(wildcard $(LIBZIP_SRC_PATH)\/*.c $(LIBZIP_SRC_PATH)\/zlib\/*.c))))\n+    LIBSPLASHSCREEN_STATIC_LIB_EXCLUDE_OBJS += $(LIBZIP_OBJS)\n@@ -210,0 +217,2 @@\n+  LIBSPLASHSCREEN_STATIC_LIB_EXCLUDE_OBJS += systemScale.o\n+\n@@ -260,0 +269,1 @@\n+      STATIC_LIB_EXCLUDE_OBJS := $(LIBSPLASHSCREEN_STATIC_LIB_EXCLUDE_OBJS), \\\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-COPY += .dtd .xsd .xml\n+COPY += .dtd .xsd .xml .ent .mod\n","filename":"make\/modules\/java.xml\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+      ONLY_EXPORTED := true, \\\n@@ -70,0 +71,1 @@\n+      ONLY_EXPORTED := true, \\\n","filename":"make\/modules\/jdk.accessibility\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    ONLY_EXPORTED := true, \\\n@@ -86,0 +87,1 @@\n+      ONLY_EXPORTED := true, \\\n@@ -130,0 +132,1 @@\n+      ONLY_EXPORTED := true, \\\n@@ -149,0 +152,1 @@\n+      ONLY_EXPORTED := true, \\\n@@ -167,0 +171,1 @@\n+      ONLY_EXPORTED := true, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+        --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -209,2 +209,2 @@\n-  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n-  ldr(rscratch2, Address(rthread, JavaThread::lock_id_offset()));\n+  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n+  ldr(rscratch2, Address(rthread, JavaThread::monitor_owner_id_offset()));\n@@ -472,2 +472,2 @@\n-    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n-    ldr(rscratch2, Address(rthread, JavaThread::lock_id_offset()));\n+    \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n+    ldr(rscratch2, Address(rthread, JavaThread::monitor_owner_id_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -89,0 +90,4 @@\n+\n+      if (ShenandoahCardBarrier) {\n+        post_barrier(access, access.resolved_addr(), new_value.result());\n+      }\n@@ -116,0 +121,3 @@\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(access, access.resolved_addr(), result);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,0 +35,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -80,0 +82,7 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                       Register start, Register count, Register tmp, RegSet saved_regs) {\n+  if (ShenandoahCardBarrier && is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n@@ -365,0 +374,20 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  __ lsr(obj, obj, CardTable::card_shift());\n+\n+  assert(CardTable::dirty_card_val() == 0, \"must be\");\n+\n+  __ load_byte_map_base(rscratch1);\n+\n+  if (UseCondCardMark) {\n+    Label L_already_dirty;\n+    __ ldrb(rscratch2, Address(obj, rscratch1));\n+    __ cbz(rscratch2, L_already_dirty);\n+    __ strb(zr, Address(obj, rscratch1));\n+    __ bind(L_already_dirty);\n+  } else {\n+    __ strb(zr, Address(obj, rscratch1));\n+  }\n+}\n+\n@@ -390,11 +419,1 @@\n-  if (val == noreg) {\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), noreg, noreg, noreg, noreg);\n-  } else {\n-    \/\/ Barrier needs uncompressed oop for region cross check.\n-    Register new_val = val;\n-    if (UseCompressedOops) {\n-      new_val = rscratch2;\n-      __ mov(new_val, val);\n-    }\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n-  }\n+  BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n@@ -402,0 +421,5 @@\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  bool needs_post_barrier = (val != noreg) && in_heap && ShenandoahCardBarrier;\n+  if (needs_post_barrier) {\n+    store_check(masm, tmp3);\n+  }\n@@ -584,0 +608,29 @@\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register start, Register count, Register scratch, RegSet saved_regs) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  Label L_loop, L_done;\n+  const Register end = count;\n+\n+  \/\/ Zero count? Nothing to do.\n+  __ cbz(count, L_done);\n+\n+  \/\/ end = start + count << LogBytesPerHeapOop\n+  \/\/ last element address to make inclusive\n+  __ lea(end, Address(start, count, Address::lsl(LogBytesPerHeapOop)));\n+  __ sub(end, end, BytesPerHeapOop);\n+  __ lsr(start, start, CardTable::card_shift());\n+  __ lsr(end, end, CardTable::card_shift());\n+\n+  \/\/ number of bytes to copy\n+  __ sub(count, end, start);\n+\n+  __ load_byte_map_base(scratch);\n+  __ add(start, start, scratch);\n+  __ bind(L_loop);\n+  __ strb(zr, Address(start, count));\n+  __ subs(count, count, 1);\n+  __ br(Assembler::GE, L_loop);\n+  __ bind(L_done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":64,"deletions":11,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -58,0 +59,2 @@\n+  void store_check(MacroAssembler* masm, Register obj);\n+\n@@ -62,0 +65,4 @@\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register start, Register count,\n+                                        Register scratch, RegSet saved_regs);\n+\n@@ -74,0 +81,2 @@\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5308,1 +5308,1 @@\n-    const uint64_t range_mask = (1ULL << log2i(range)) - 1;\n+    const uint64_t range_mask = right_n_bits(log2i_ceil(range));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,13 @@\n-    _initial_sve_vector_length = get_current_sve_vector_length();\n+    int vl = get_current_sve_vector_length();\n+    if (vl < 0) {\n+      warning(\"Unable to get SVE vector length on this system. \"\n+              \"Disabling SVE. Specify -XX:UseSVE=0 to shun this warning.\");\n+      FLAG_SET_DEFAULT(UseSVE, 0);\n+    } else if ((vl == 0) || ((vl % FloatRegister::sve_vl_min) != 0) || !is_power_of_2(vl)) {\n+      warning(\"Detected SVE vector length (%d) should be a power of two and a multiple of %d. \"\n+              \"Disabling SVE. Specify -XX:UseSVE=0 to shun this warning.\",\n+              vl, FloatRegister::sve_vl_min);\n+      FLAG_SET_DEFAULT(UseSVE, 0);\n+    } else {\n+      _initial_sve_vector_length = vl;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -509,0 +509,3 @@\n+    LFIWAX_OPCODE  = (31u << OPCODE_SHIFT |  855u << 1),\n+    LFIWZX_OPCODE  = (31u << OPCODE_SHIFT |  887u << 1),\n+\n@@ -516,0 +519,2 @@\n+    STFIWX_OPCODE  = (31u << OPCODE_SHIFT |  983u << 1),\n+\n@@ -558,0 +563,4 @@\n+    XVCVHPSP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 24u << 16), \/\/ XX2-FORM\n+    XVCVSPHP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 25u << 16), \/\/ XX2-FORM\n+    XSCVHPDP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 16u << 16), \/\/ XX2-FORM\n+    XSCVDPHP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 17u << 16), \/\/ XX2-FORM\n@@ -2079,0 +2088,3 @@\n+  inline void lfiwax(FloatRegister d, Register a, Register b);\n+  inline void lfiwzx(FloatRegister d, Register a, Register b);\n+\n@@ -2087,0 +2099,2 @@\n+  inline void stfiwx(FloatRegister s, Register a, Register b);\n+\n@@ -2351,0 +2365,4 @@\n+  inline void xvcvhpsp( VectorSRegister d, VectorSRegister b);\n+  inline void xvcvsphp( VectorSRegister d, VectorSRegister b);\n+  inline void xscvhpdp( VectorSRegister d, VectorSRegister b);\n+  inline void xscvdphp( VectorSRegister d, VectorSRegister b);\n@@ -2477,0 +2495,2 @@\n+  inline void lfiwax(FloatRegister d, Register b);\n+  inline void lfiwzx(FloatRegister d, Register b);\n@@ -2481,0 +2501,1 @@\n+  inline void stfiwx(FloatRegister s, Register b);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -744,0 +744,3 @@\n+inline void Assembler::lfiwax(FloatRegister d, Register a, Register b) { emit_int32( LFIWAX_OPCODE | frt(d) | ra0mem(a) |rb(b)); }\n+inline void Assembler::lfiwzx(FloatRegister d, Register a, Register b) { emit_int32( LFIWZX_OPCODE | frt(d) | ra0mem(a) |rb(b)); }\n+\n@@ -753,0 +756,2 @@\n+inline void Assembler::stfiwx(FloatRegister s, Register a, Register b) { emit_int32( STFIWX_OPCODE | frs(s) | ra0mem(a) |rb(b)); }\n+\n@@ -874,0 +879,4 @@\n+inline void Assembler::xvcvhpsp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XVCVHPSP_OPCODE | vsrt(d) | vsrb(b) ); }\n+inline void Assembler::xvcvsphp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XVCVSPHP_OPCODE | vsrt(d) | vsrb(b) ); }\n+inline void Assembler::xscvhpdp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XSCVHPDP_OPCODE | vsrt(d) | vsrb(b) ); }\n+inline void Assembler::xscvdphp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XSCVDPHP_OPCODE | vsrt(d) | vsrb(b) ); }\n@@ -1153,0 +1162,3 @@\n+inline void Assembler::lfiwax(FloatRegister d, Register b) { emit_int32( LFIWAX_OPCODE | frt(d) | rb(b)); }\n+inline void Assembler::lfiwzx(FloatRegister d, Register b) { emit_int32( LFIWZX_OPCODE | frt(d) | rb(b)); }\n+\n@@ -1159,0 +1171,2 @@\n+inline void Assembler::stfiwx(FloatRegister s, Register b) { emit_int32( STFIWX_OPCODE | frs(s) |rb(b)); }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1716,1 +1716,1 @@\n-void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {\n+void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {\n@@ -1726,0 +1726,8 @@\n+    case lir_f2hf: {\n+      __ f2hf(dest.as_register(), value.as_float_reg(), tmp.as_float_reg());\n+      break;\n+    }\n+    case lir_hf2f: {\n+      __ hf2f(dest->as_float_reg(), value.as_register());\n+      break;\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -693,0 +693,19 @@\n+    case vmIntrinsics::_floatToFloat16: {\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      LIR_Opr tmp = new_register(T_FLOAT);\n+      \/\/ f2hf treats tmp as live_in. Workaround: initialize to some value.\n+      __ move(LIR_OprFact::floatConst(-0.0), tmp); \/\/ just to satisfy LinearScan\n+      __ f2hf(value.result(), dst, tmp);\n+      break;\n+    }\n+    case vmIntrinsics::_float16ToFloat: {\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      __ hf2f(value.result(), dst, LIR_OprFact::illegalOpr);\n+      break;\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+      if (ShenandoahCardBarrier) {\n+        post_barrier(access, access.resolved_addr(), new_value.result());\n+      }\n+\n@@ -135,0 +139,4 @@\n+\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(access, access.resolved_addr(), result);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_ppc.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -79,2 +80,0 @@\n-  __ block_comment(\"arraycopy_prologue (shenandoahgc) {\");\n-\n@@ -103,0 +102,1 @@\n+  __ block_comment(\"arraycopy_prologue (shenandoahgc) {\");\n@@ -176,0 +176,10 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                       Register dst, Register count,\n+                                                       Register preserve) {\n+  if (ShenandoahCardBarrier && is_reference_type(type)) {\n+    __ block_comment(\"arraycopy_epilogue (shenandoahgc) {\");\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, preserve);\n+    __ block_comment(\"} arraycopy_epilogue (shenandoahgc)\");\n+  }\n+}\n+\n@@ -579,0 +589,19 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register base, RegisterOrConstant ind_or_offs, Register tmp) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = ctbs->card_table();\n+  assert_different_registers(base, tmp, R0);\n+\n+  if (ind_or_offs.is_constant()) {\n+    __ add_const_optimized(base, base, ind_or_offs.as_constant(), tmp);\n+  } else {\n+    __ add(base, ind_or_offs.as_register(), base);\n+  }\n+\n+  __ load_const_optimized(tmp, (address)ct->byte_map_base(), R0);\n+  __ srdi(base, base, CardTable::card_shift());\n+  __ li(R0, CardTable::dirty_card_val());\n+  __ stbx(R0, tmp, base);\n+}\n+\n@@ -597,0 +626,5 @@\n+\n+  \/\/ No need for post barrier if storing NULL\n+  if (ShenandoahCardBarrier && is_reference_type(type) && val != noreg) {\n+    store_check(masm, base, ind_or_offs, tmp1);\n+  }\n@@ -746,0 +780,34 @@\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register addr, Register count, Register preserve) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = bs->card_table();\n+  assert_different_registers(addr, count, R0);\n+\n+  Label L_skip_loop, L_store_loop;\n+\n+  __ sldi_(count, count, LogBytesPerHeapOop);\n+\n+  \/\/ Zero length? Skip.\n+  __ beq(CCR0, L_skip_loop);\n+\n+  __ addi(count, count, -BytesPerHeapOop);\n+  __ add(count, addr, count);\n+  \/\/ Use two shifts to clear out those low order two bits! (Cannot opt. into 1.)\n+  __ srdi(addr, addr, CardTable::card_shift());\n+  __ srdi(count, count, CardTable::card_shift());\n+  __ subf(count, addr, count);\n+  __ add_const_optimized(addr, addr, (address)ct->byte_map_base(), R0);\n+  __ addi(count, count, 1);\n+  __ li(R0, 0);\n+  __ mtctr(count);\n+\n+  \/\/ Byte store loop\n+  __ bind(L_store_loop);\n+  __ stb(R0, 0, addr);\n+  __ addi(addr, addr, 1);\n+  __ bdnz(L_store_loop);\n+  __ bind(L_skip_loop);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+  void store_check(MacroAssembler* masm,\n+                   Register base, RegisterOrConstant ind_or_offs,\n+                   Register tmp);\n+\n@@ -63,0 +67,4 @@\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register addr, Register count,\n+                                        Register preserve);\n+\n@@ -98,1 +106,5 @@\n-                          Register src, Register dst, Register count, Register preserve1, Register preserve2);\n+                                  Register src, Register dst, Register count,\n+                                  Register preserve1, Register preserve2);\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register dst, Register count,\n+                                  Register preserve);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2667,1 +2667,1 @@\n-  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n@@ -2670,1 +2670,1 @@\n-  ld(thread_id, in_bytes(JavaThread::lock_id_offset()), R16_thread);\n+  ld(thread_id, in_bytes(JavaThread::monitor_owner_id_offset()), R16_thread);\n@@ -2947,1 +2947,1 @@\n-    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+    \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n@@ -2949,1 +2949,1 @@\n-    ld(thread_id, in_bytes(JavaThread::lock_id_offset()), R16_thread);\n+    ld(thread_id, in_bytes(JavaThread::monitor_owner_id_offset()), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -189,0 +189,3 @@\n+  \/\/ Convert between half precision float encoded into a short and a float in a FloatRegister.\n+  void inline f2hf(Register dst, FloatRegister src, FloatRegister tmp);\n+  void inline hf2f(FloatRegister dst, Register src);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -300,0 +300,14 @@\n+inline void MacroAssembler::f2hf(Register dst, FloatRegister src, FloatRegister tmp) {\n+  \/\/ Single precision values in FloatRegisters use double precision format on PPC64.\n+  xscvdphp(tmp->to_vsr(), src->to_vsr());\n+  mffprd(dst, tmp);\n+  \/\/ Make it a proper short (sign-extended).\n+  extsh(dst, dst);\n+}\n+\n+inline void MacroAssembler::hf2f(FloatRegister dst, Register src) {\n+  mtfprd(dst, src);\n+  \/\/ Single precision values in FloatRegisters use double precision format on PPC64.\n+  xscvhpdp(dst->to_vsr(), dst->to_vsr());\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2080,0 +2080,3 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      return VM_Version::supports_float16();\n@@ -11246,0 +11249,28 @@\n+%}\n+\n+instruct convF2HF_reg_reg(iRegIdst dst, regF src, regF tmp) %{\n+  match(Set dst (ConvF2HF src));\n+  effect(TEMP tmp);\n+  ins_cost(3 * DEFAULT_COST);\n+  size(12);\n+  format %{ \"xscvdphp $tmp, $src\\t# convert to half precision\\n\\t\"\n+            \"mffprd $dst, $tmp\\t# move result from $tmp to $dst\\n\\t\"\n+            \"extsh $dst, $dst\\t# make it a proper short\"\n+  %}\n+  ins_encode %{\n+    __ f2hf($dst$$Register, $src$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct convHF2F_reg_reg(regF dst, iRegIsrc src) %{\n+  match(Set dst (ConvHF2F src));\n+  ins_cost(2 * DEFAULT_COST);\n+  size(8);\n+  format %{ \"mtfprd $dst, $src\\t# move source from $src to $dst\\n\\t\"\n+            \"xscvhpdp $dst, $dst\\t# convert from half precision\"\n+  %}\n+  ins_encode %{\n+    __ hf2f($dst$$FloatRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3454,0 +3454,18 @@\n+  address generate_floatToFloat16() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+    address start = __ function_entry();\n+    __ f2hf(R3_RET, F1_ARG1, F0);\n+    __ blr();\n+    return start;\n+  }\n+\n+  address generate_float16ToFloat() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+    address start = __ function_entry();\n+    __ hf2f(F1_RET, R3_ARG1);\n+    __ blr();\n+    return start;\n+  }\n+\n@@ -4680,0 +4698,6 @@\n+    }\n+\n+    if (VM_Version::supports_float16()) {\n+      \/\/ For results consistency both intrinsics should be enabled.\n+      StubRoutines::_hf2f = generate_float16ToFloat();\n+      StubRoutines::_f2hf = generate_floatToFloat16();\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1158,0 +1158,38 @@\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n+  if (!VM_Version::supports_float16()) return nullptr;\n+\n+  address entry = __ pc();\n+\n+  __ lfs(F1, Interpreter::stackElementSize, R15_esp);\n+  __ f2hf(R3_RET, F1, F0);\n+\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n+\n+  __ flush();\n+\n+  return entry;\n+}\n+\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n+  if (!VM_Version::supports_float16()) return nullptr;\n+\n+  address entry = __ pc();\n+\n+  \/\/ Note: Could also use:\n+  \/\/__ li(R3, Interpreter::stackElementSize);\n+  \/\/__ lfiwax(F1_RET, R15_esp, R3); \/\/ short stored as 32 bit integer\n+  \/\/__ xscvhpdp(F1_RET->to_vsr(), F1_RET->to_vsr());\n+  __ lwa(R3, Interpreter::stackElementSize, R15_esp);\n+  __ hf2f(F1_RET, R3);\n+\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n+\n+  __ flush();\n+\n+  return entry;\n+}\n+\n@@ -1968,2 +2006,0 @@\n-address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n-address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  static bool supports_float16() { return PowerArchitecturePPC64 >= 9; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3110,0 +3110,32 @@\n+\/\/ --------------  Zicond Instruction Definitions  --------------\n+\/\/ Zicond conditional operations extension\n+  private:\n+  enum CZERO_OP : unsigned int {\n+    CZERO_NEZ = 0b111,\n+    CZERO_EQZ = 0b101\n+  };\n+\n+  template <CZERO_OP OP_VALUE>\n+  void czero(Register Rd, Register Rs1, Register Rs2) {\n+    assert_cond(UseZicond);\n+    uint32_t insn = 0;\n+    patch    ((address)&insn,  6,  0, 0b0110011);  \/\/ bits:  7, name: 0x33, attr: ['OP']\n+    patch_reg((address)&insn,      7, Rd);         \/\/ bits:  5, name: 'rd'\n+    patch    ((address)&insn, 14, 12, OP_VALUE);   \/\/ bits:  3, name: 0x7, attr: ['CZERO.NEZ'] \/ 0x5, attr: ['CZERO.EQZ']}\n+    patch_reg((address)&insn,     15, Rs1);        \/\/ bits:  5, name: 'rs1', attr: ['value']\n+    patch_reg((address)&insn,     20, Rs2);        \/\/ bits:  5, name: 'rs2', attr: ['condition']\n+    patch    ((address)&insn, 31, 25, 0b0000111);  \/\/ bits:  7, name: 0x7, attr: ['CZERO']\n+    emit_int32(insn);\n+  }\n+\n+  public:\n+  \/\/ Moves zero to a register rd, if the condition rs2 is equal to zero, otherwise moves rs1 to rd.\n+  void czero_eqz(Register rd, Register rs1_value, Register rs2_condition) {\n+    czero<CZERO_EQZ>(rd, rs1_value, rs2_condition);\n+  }\n+\n+  \/\/ Moves zero to a register rd, if the condition rs2 is nonzero, otherwise moves rs1 to rd.\n+  void czero_nez(Register rd, Register rs1_value, Register rs2_condition) {\n+    czero<CZERO_NEZ>(rd, rs1_value, rs2_condition);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -873,0 +873,1 @@\n+\/\/ Consider using cmov (Zicond)\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n@@ -122,1 +122,1 @@\n-  ld(tid, Address(xthread, JavaThread::lock_id_offset()));\n+  ld(tid, Address(xthread, JavaThread::monitor_owner_id_offset()));\n@@ -403,1 +403,1 @@\n-    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+    \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n@@ -405,1 +405,1 @@\n-    ld(tid, Address(xthread, JavaThread::lock_id_offset()));\n+    ld(tid, Address(xthread, JavaThread::monitor_owner_id_offset()));\n@@ -2006,4 +2006,42 @@\n-  Label L;\n-  cmp_branch(cmpFlag ^ (1 << neg_cond_bits), op1, op2, L);\n-  mv(dst, src);\n-  bind(L);\n+  bool is_unsigned = (cmpFlag & unsigned_branch_mask) == unsigned_branch_mask;\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_eq(op1, op2, dst, src);\n+      break;\n+    case BoolTest::ne:\n+      cmov_ne(op1, op2, dst, src);\n+      break;\n+    case BoolTest::le:\n+      if (is_unsigned) {\n+        cmov_leu(op1, op2, dst, src);\n+      } else {\n+        cmov_le(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::ge:\n+      if (is_unsigned) {\n+        cmov_geu(op1, op2, dst, src);\n+      } else {\n+        cmov_ge(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::lt:\n+      if (is_unsigned) {\n+        cmov_ltu(op1, op2, dst, src);\n+      } else {\n+        cmov_lt(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::gt:\n+      if (is_unsigned) {\n+        cmov_gtu(op1, op2, dst, src);\n+      } else {\n+        cmov_gt(op1, op2, dst, src);\n+      }\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":46,"deletions":8,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-  static const int neg_cond_bits = 2;\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,0 +81,4 @@\n+\n+      if (ShenandoahCardBarrier) {\n+        post_barrier(access, access.resolved_addr(), new_value.result());\n+      }\n@@ -84,0 +88,1 @@\n+\n@@ -108,0 +113,3 @@\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(access, access.resolved_addr(), result);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -84,0 +85,7 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                       Register start, Register count, Register tmp, RegSet saved_regs) {\n+  if (ShenandoahCardBarrier && is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n@@ -385,0 +393,21 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj) {\n+  assert(ShenandoahCardBarrier, \"Did you mean to enable ShenandoahCardBarrier?\");\n+\n+  __ srli(obj, obj, CardTable::card_shift());\n+\n+  assert(CardTable::dirty_card_val() == 0, \"must be\");\n+\n+  __ load_byte_map_base(t1);\n+  __ add(t1, obj, t1);\n+\n+  if (UseCondCardMark) {\n+    Label L_already_dirty;\n+    __ lbu(t0, Address(t1));\n+    __ beqz(t0, L_already_dirty);\n+    __ sb(zr, Address(t1));\n+    __ bind(L_already_dirty);\n+  } else {\n+    __ sb(zr, Address(t1));\n+  }\n+}\n+\n@@ -410,10 +439,6 @@\n-  if (val == noreg) {\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), noreg, noreg, noreg, noreg);\n-  } else {\n-    \/\/ Barrier needs uncompressed oop for region cross check.\n-    Register new_val = val;\n-    if (UseCompressedOops) {\n-      new_val = t1;\n-      __ mv(new_val, val);\n-    }\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n+  BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n+\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  bool needs_post_barrier = (val != noreg) && in_heap && ShenandoahCardBarrier;\n+  if (needs_post_barrier) {\n+    store_check(masm, tmp3);\n@@ -527,0 +552,31 @@\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register start, Register count, Register tmp, RegSet saved_regs) {\n+  assert(ShenandoahCardBarrier, \"Did you mean to enable ShenandoahCardBarrier?\");\n+\n+  Label L_loop, L_done;\n+  const Register end = count;\n+\n+  \/\/ Zero count? Nothing to do.\n+  __ beqz(count, L_done);\n+\n+  \/\/ end = start + count << LogBytesPerHeapOop\n+  \/\/ last element address to make inclusive\n+  __ shadd(end, count, start, tmp, LogBytesPerHeapOop);\n+  __ sub(end, end, BytesPerHeapOop);\n+  __ srli(start, start, CardTable::card_shift());\n+  __ srli(end, end, CardTable::card_shift());\n+\n+  \/\/ number of bytes to copy\n+  __ sub(count, end, start);\n+\n+  __ load_byte_map_base(tmp);\n+  __ add(start, start, tmp);\n+\n+  __ bind(L_loop);\n+  __ add(tmp, start, count);\n+  __ sb(zr, Address(tmp));\n+  __ sub(count, count, 1);\n+  __ bgez(count, L_loop);\n+  __ bind(L_done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":66,"deletions":10,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+  void store_check(MacroAssembler* masm, Register obj);\n+\n@@ -64,0 +66,4 @@\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register start, Register count,\n+                                        Register tmp, RegSet saved_regs);\n+\n@@ -78,0 +84,3 @@\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-    __ cmpxchg_weak(rtmp2, zr, rtmp1,\n+    __ weak_cmpxchg(rtmp2, zr, rtmp1,\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  product(bool, UseZicond, false, DIAGNOSTIC, \"Use Zicond instructions\")         \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1131,0 +1131,141 @@\n+\/\/ cmov\n+void MacroAssembler::cmov_eq(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    xorr(t0, cmp1, cmp2);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bne(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_ne(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    xorr(t0, cmp1, cmp2);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  beq(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_le(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp2, cmp1);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bgt(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_leu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp2, cmp1);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bgtu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_ge(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp1, cmp2);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  blt(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_geu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp1, cmp2);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bltu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_lt(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp1, cmp2);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bge(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_ltu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp1, cmp2);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bgeu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_gt(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp2, cmp1);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  ble(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_gtu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp2, cmp1);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bleu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n@@ -2323,21 +2464,3 @@\n-\n-\/\/ reverse bytes in halfword in lower 16 bits and sign-extend\n-\/\/ Rd[15:0] = Rs[7:0] Rs[15:8] (sign-extend to 64 bits)\n-void MacroAssembler::revb_h_h(Register Rd, Register Rs, Register tmp) {\n-  if (UseZbb) {\n-    rev8(Rd, Rs);\n-    srai(Rd, Rd, 48);\n-    return;\n-  }\n-  assert_different_registers(Rs, tmp);\n-  assert_different_registers(Rd, tmp);\n-  srli(tmp, Rs, 8);\n-  andi(tmp, tmp, 0xFF);\n-  slli(Rd, Rs, 56);\n-  srai(Rd, Rd, 48); \/\/ sign-extend\n-  orr(Rd, Rd, tmp);\n-}\n-\n-\/\/ reverse bytes in lower word and sign-extend\n-\/\/ Rd[31:0] = Rs[7:0] Rs[15:8] Rs[23:16] Rs[31:24] (sign-extend to 64 bits)\n-void MacroAssembler::revb_w_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n+\/\/ reverse bytes in lower word, sign-extend\n+\/\/ Rd[32:0] = Rs[7:0] Rs[15:8] Rs[23:16] Rs[31:24]\n+void MacroAssembler::revbw(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n@@ -2351,88 +2474,7 @@\n-  revb_h_w_u(Rd, Rs, tmp1, tmp2);\n-  slli(tmp2, Rd, 48);\n-  srai(tmp2, tmp2, 32); \/\/ sign-extend\n-  srli(Rd, Rd, 16);\n-  orr(Rd, Rd, tmp2);\n-}\n-\n-\/\/ reverse bytes in halfword in lower 16 bits and zero-extend\n-\/\/ Rd[15:0] = Rs[7:0] Rs[15:8] (zero-extend to 64 bits)\n-void MacroAssembler::revb_h_h_u(Register Rd, Register Rs, Register tmp) {\n-  if (UseZbb) {\n-    rev8(Rd, Rs);\n-    srli(Rd, Rd, 48);\n-    return;\n-  }\n-  assert_different_registers(Rs, tmp);\n-  assert_different_registers(Rd, tmp);\n-  srli(tmp, Rs, 8);\n-  andi(tmp, tmp, 0xFF);\n-  andi(Rd, Rs, 0xFF);\n-  slli(Rd, Rd, 8);\n-  orr(Rd, Rd, tmp);\n-}\n-\n-\/\/ reverse bytes in halfwords in lower 32 bits and zero-extend\n-\/\/ Rd[31:0] = Rs[23:16] Rs[31:24] Rs[7:0] Rs[15:8] (zero-extend to 64 bits)\n-void MacroAssembler::revb_h_w_u(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n-  if (UseZbb) {\n-    rev8(Rd, Rs);\n-    rori(Rd, Rd, 32);\n-    roriw(Rd, Rd, 16);\n-    zero_extend(Rd, Rd, 32);\n-    return;\n-  }\n-  assert_different_registers(Rs, tmp1, tmp2);\n-  assert_different_registers(Rd, tmp1, tmp2);\n-  srli(tmp2, Rs, 16);\n-  revb_h_h_u(tmp2, tmp2, tmp1);\n-  revb_h_h_u(Rd, Rs, tmp1);\n-  slli(tmp2, tmp2, 16);\n-  orr(Rd, Rd, tmp2);\n-}\n-\n-\/\/ This method is only used for revb_h\n-\/\/ Rd = Rs[47:0] Rs[55:48] Rs[63:56]\n-void MacroAssembler::revb_h_helper(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n-  assert_different_registers(Rs, tmp1, tmp2);\n-  assert_different_registers(Rd, tmp1);\n-  srli(tmp1, Rs, 48);\n-  andi(tmp2, tmp1, 0xFF);\n-  slli(tmp2, tmp2, 8);\n-  srli(tmp1, tmp1, 8);\n-  orr(tmp1, tmp1, tmp2);\n-  slli(Rd, Rs, 16);\n-  orr(Rd, Rd, tmp1);\n-}\n-\n-\/\/ reverse bytes in each halfword\n-\/\/ Rd[63:0] = Rs[55:48] Rs[63:56] Rs[39:32] Rs[47:40] Rs[23:16] Rs[31:24] Rs[7:0] Rs[15:8]\n-void MacroAssembler::revb_h(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n-  if (UseZbb) {\n-    assert_different_registers(Rs, tmp1);\n-    assert_different_registers(Rd, tmp1);\n-    rev8(Rd, Rs);\n-    zero_extend(tmp1, Rd, 32);\n-    roriw(tmp1, tmp1, 16);\n-    slli(tmp1, tmp1, 32);\n-    srli(Rd, Rd, 32);\n-    roriw(Rd, Rd, 16);\n-    zero_extend(Rd, Rd, 32);\n-    orr(Rd, Rd, tmp1);\n-    return;\n-  }\n-  assert_different_registers(Rs, tmp1, tmp2);\n-  assert_different_registers(Rd, tmp1, tmp2);\n-  revb_h_helper(Rd, Rs, tmp1, tmp2);\n-  for (int i = 0; i < 3; ++i) {\n-    revb_h_helper(Rd, Rd, tmp1, tmp2);\n-  }\n-}\n-\n-\/\/ reverse bytes in each word\n-\/\/ Rd[63:0] = Rs[39:32] Rs[47:40] Rs[55:48] Rs[63:56] Rs[7:0] Rs[15:8] Rs[23:16] Rs[31:24]\n-void MacroAssembler::revb_w(Register Rd, Register Rs, Register tmp1, Register tmp2) {\n-  if (UseZbb) {\n-    rev8(Rd, Rs);\n-    rori(Rd, Rd, 32);\n-    return;\n+  andi(tmp1, Rs, 0xFF);\n+  slli(tmp1, tmp1, 8);\n+  for (int step = 8; step < 24; step += 8) {\n+    srli(tmp2, Rs, step);\n+    andi(tmp2, tmp2, 0xFF);\n+    orr(tmp1, tmp1, tmp2);\n+    slli(tmp1, tmp1, 8);\n@@ -2440,4 +2482,4 @@\n-  assert_different_registers(Rs, tmp1, tmp2);\n-  assert_different_registers(Rd, tmp1, tmp2);\n-  revb(Rd, Rs, tmp1, tmp2);\n-  ror_imm(Rd, Rd, 32);\n+  srli(Rd, Rs, 24);\n+  andi(Rd, Rd, 0xFF);\n+  orr(Rd, tmp1, Rd);\n+  sign_extend(Rd, Rd, 32);\n@@ -3537,1 +3579,1 @@\n-void MacroAssembler::cmpxchg_weak(Register addr, Register expected,\n+void MacroAssembler::weak_cmpxchg(Register addr, Register expected,\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":156,"deletions":114,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -629,0 +629,11 @@\n+  void cmov_eq(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_ne(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_le(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_leu(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_ge(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_geu(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_lt(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_ltu(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_gt(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_gtu(Register cmp1, Register cmp2, Register dst, Register src);\n+\n@@ -904,9 +915,3 @@\n-  \/\/ revb\n-  void revb_h_h(Register Rd, Register Rs, Register tmp = t0);                           \/\/ reverse bytes in halfword in lower 16 bits, sign-extend\n-  void revb_w_w(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2 = t1);      \/\/ reverse bytes in lower word, sign-extend\n-  void revb_h_h_u(Register Rd, Register Rs, Register tmp = t0);                         \/\/ reverse bytes in halfword in lower 16 bits, zero-extend\n-  void revb_h_w_u(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2 = t1);    \/\/ reverse bytes in halfwords in lower 32 bits, zero-extend\n-  void revb_h_helper(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2= t1);  \/\/ reverse bytes in upper 16 bits (48:63) and move to lower\n-  void revb_h(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2= t1);         \/\/ reverse bytes in each halfword\n-  void revb_w(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2= t1);         \/\/ reverse bytes in each word\n-  void revb(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2 = t1);          \/\/ reverse bytes in doubleword\n+  \/\/ reverse bytes\n+  void revbw(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2= t1);  \/\/ reverse bytes in lower word, sign-extend\n+  void revb(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2 = t1);  \/\/ reverse bytes in doubleword\n@@ -1144,1 +1149,1 @@\n-  void cmpxchg_weak(Register addr, Register expected,\n+  void weak_cmpxchg(Register addr, Register expected,\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5747,1 +5747,1 @@\n-    \"cmpxchg_weak $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5770,1 +5770,1 @@\n-    \"cmpxchg_weak $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5790,1 +5790,1 @@\n-    \"cmpxchg_weak $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5795,1 +5795,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n@@ -5809,1 +5809,1 @@\n-    \"cmpxchg_weak $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5814,1 +5814,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n@@ -5829,1 +5829,1 @@\n-    \"cmpxchg_weak $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5834,1 +5834,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n@@ -5849,1 +5849,1 @@\n-    \"cmpxchg_weak $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5854,1 +5854,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n@@ -5873,1 +5873,1 @@\n-    \"cmpxchg_weak_acq $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5898,1 +5898,1 @@\n-    \"cmpxchg_weak_acq $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5920,1 +5920,1 @@\n-    \"cmpxchg_weak_acq $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5925,1 +5925,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n@@ -5941,1 +5941,1 @@\n-    \"cmpxchg_weak_acq $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5946,1 +5946,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n@@ -5962,1 +5962,1 @@\n-    \"cmpxchg_weak_acq $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5967,1 +5967,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n@@ -5983,1 +5983,1 @@\n-    \"cmpxchg_weak_acq $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n@@ -5988,1 +5988,1 @@\n-    __ cmpxchg_weak(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -184,1 +184,4 @@\n-  format %{ \"revb_w_w  $dst, $src\\t#@bytes_reverse_int_b\" %}\n+  format %{\n+    \"rev8  $dst, $src\\t#@bytes_reverse_int_b\\t\\n\"\n+    \"srai  $dst, $dst, 32\\t\\n\"\n+  %}\n@@ -188,1 +191,2 @@\n-    __ revb_w_w(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ rev8(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ srai(as_Register($dst$$reg), as_Register($dst$$reg), 32);\n@@ -212,1 +216,4 @@\n-  format %{ \"revb_h_h_u  $dst, $src\\t#@bytes_reverse_unsigned_short_b\" %}\n+  format %{\n+    \"rev8  $dst, $src\\t#@bytes_reverse_unsigned_short_b\\t\\n\"\n+    \"srli  $dst, $dst, 48\\t\\n\"\n+  %}\n@@ -216,1 +223,2 @@\n-    __ revb_h_h_u(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ rev8(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ srli(as_Register($dst$$reg), as_Register($dst$$reg), 48);\n@@ -226,1 +234,4 @@\n-  format %{ \"revb_h_h  $dst, $src\\t#@bytes_reverse_short_b\" %}\n+  format %{\n+    \"rev8  $dst, $src\\t#@bytes_reverse_short_b\\t\\n\"\n+    \"srai  $dst, $dst, 48\\t\\n\"\n+  %}\n@@ -230,1 +241,2 @@\n-    __ revb_h_h(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ rev8(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ srai(as_Register($dst$$reg), as_Register($dst$$reg), 48);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -661,2 +661,6 @@\n-  __ lhu(reg, at_bcp(2));\n-  __ revb_h_h_u(reg, reg); \/\/ reverse bytes in half-word and zero-extend\n+  assert_different_registers(reg, t1);\n+  \/\/ Convert the 16-bit value into native byte-ordering and zero-extend\n+  __ lbu(reg, at_bcp(2));\n+  __ lbu(t1, at_bcp(3));\n+  __ slli(reg, reg, 8);\n+  __ orr(reg, reg, t1);\n@@ -674,2 +678,6 @@\n-  __ lhu(x11, at_bcp(2));\n-  __ revb_h_h_u(x11, x11); \/\/ reverse bytes in half-word and zero-extend\n+  \/\/ Convert the 16-bit value into native byte-ordering and zero-extend\n+  __ lbu(x11, at_bcp(2));\n+  __ lbu(t1, at_bcp(3));\n+  __ slli(x11, x11, 8);\n+  __ orr(x11, x11, t1);\n+\n@@ -689,2 +697,6 @@\n-  __ lhu(x11, at_bcp(2));\n-  __ revb_h_h_u(x11, x11); \/\/ reverse bytes in half-word and zero-extend\n+  \/\/ Convert the 16-bit value into native byte-ordering and zero-extend\n+  __ lbu(x11, at_bcp(2));\n+  __ lbu(t1, at_bcp(3));\n+  __ slli(x11, x11, 8);\n+  __ orr(x11, x11, t1);\n+\n@@ -1474,6 +1486,8 @@\n-  __ lwu(x11, at_bcp(2)); \/\/ get constant and index\n-  __ revb_h_w_u(x11, x11); \/\/ reverse bytes in half-word (32bit) and zero-extend\n-  __ zero_extend(x12, x11, 16);\n-  __ neg(x12, x12);\n-  __ slli(x11, x11, 32);\n-  __ srai(x11, x11, 48);\n+  \/\/ get constant\n+  \/\/ Convert the 16-bit value into native byte-ordering and sign-extend\n+  __ lb(x11, at_bcp(4));\n+  __ lbu(t1, at_bcp(5));\n+  __ slli(x11, x11, 8);\n+  __ orr(x11, x11, t1);\n+\n+  locals_index_wide(x12);\n@@ -1624,0 +1638,1 @@\n+    \/\/ Convert the 16-bit value into native byte-ordering and sign-extend\n@@ -1627,1 +1642,1 @@\n-    __ add(x12, x12, t1);\n+    __ orr(x12, x12, t1);\n@@ -1630,1 +1645,1 @@\n-    __ revb_w_w(x12, x12); \/\/ reverse bytes in word and sign-extend\n+    __ revbw(x12, x12);\n@@ -1895,2 +1910,2 @@\n-  __ revb_w_w(x12, x12); \/\/ reverse bytes in word (32bit) and sign-extend\n-  __ revb_w_w(x13, x13); \/\/ reverse bytes in word (32bit) and sign-extend\n+  __ revbw(x12, x12);\n+  __ revbw(x13, x13);\n@@ -1907,1 +1922,1 @@\n-  __ revb_w_w(x13, x13); \/\/ reverse bytes in word (32bit) and sign-extend\n+  __ revbw(x13, x13);\n@@ -1927,1 +1942,1 @@\n-  __ revb_w_w(x10, x10); \/\/ reverse bytes in word (32bit) and sign-extend\n+  __ revbw(x10, x10);\n@@ -1935,1 +1950,4 @@\n-  __ revb_w(x11, x11);\n+  \/\/ Convert the 32-bit npairs (number of pairs) into native byte-ordering\n+  \/\/ We can use sign-extension here because npairs must be greater than or\n+  \/\/ equal to 0 per JVM spec on 'lookupswitch' bytecode.\n+  __ revbw(x11, x11);\n@@ -1956,1 +1974,1 @@\n-  __ revb_w_w(x13, x13); \/\/ reverse bytes in word (32bit) and sign-extend\n+  __ revbw(x13, x13);\n@@ -2008,2 +2026,4 @@\n-  \/\/ Convert j into native byteordering\n-  __ revb_w(j, j);\n+  \/\/ Convert the 32-bit npairs (number of pairs) into native byte-ordering\n+  \/\/ We can use sign-extension here because npairs must be greater than or\n+  \/\/ equal to 0 per JVM spec on 'lookupswitch' bytecode.\n+  __ revbw(j, j);\n@@ -2027,1 +2047,1 @@\n-    __ revb_w_w(temp, temp); \/\/ reverse bytes in word (32bit) and sign-extend\n+    __ revbw(temp, temp);\n@@ -2050,1 +2070,1 @@\n-  __ revb_w_w(temp, temp); \/\/ reverse bytes in word (32bit) and sign-extend\n+  __ revbw(temp, temp);\n@@ -2057,1 +2077,1 @@\n-  __ revb_w_w(j, j); \/\/ reverse bytes in word (32bit) and sign-extend\n+  __ revbw(j, j);\n@@ -2070,1 +2090,1 @@\n-  __ revb_w_w(j, j); \/\/ reverse bytes in word (32bit) and sign-extend\n+  __ revbw(j, j);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":46,"deletions":26,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+  \/\/ Zicond Conditional operations\n+  \/\/\n@@ -167,0 +169,1 @@\n+  decl(ext_Zicond      , \"Zicond\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicond))      \\\n@@ -226,0 +229,1 @@\n+    RV_ENABLE_EXTENSION(UseZicond)                  \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1535,2 +1535,6 @@\n-        case lir_add: __ z_agfi(lreg, c);  break;\n-        case lir_sub: __ z_agfi(lreg, -c); break; \/\/ note: -min_jint == min_jint\n+        case lir_add:\n+                      __ add2reg_32(lreg, c);\n+                      break;\n+        case lir_sub:\n+                      __ add2reg_32(lreg, java_negate(c));\n+                      break;\n@@ -2542,1 +2546,0 @@\n-    intptr_t super_check_offset = k->is_loaded() ? k->super_check_offset() : -1L;\n@@ -2547,2 +2550,1 @@\n-                                     failure_target, nullptr,\n-                                     RegisterOrConstant(super_check_offset));\n+                                     failure_target, nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -560,1 +560,6 @@\n-      __ check_klass_subtype_slow_path(Rsubklass, Rsuperklass, Rarray_ptr, Rlength, nullptr, &miss);\n+      __ check_klass_subtype_slow_path(Rsubklass,\n+                                       Rsuperklass,\n+                                       Rarray_ptr  \/* temp_reg  *\/,\n+                                       Rlength     \/* temp2_reg *\/,\n+                                       nullptr     \/* L_success *\/,\n+                                       &miss       \/* L_failure *\/);\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-      z_lgr(r1, r2);\n+      lgr_if_needed(r1, r2);\n@@ -684,0 +684,31 @@\n+void MacroAssembler::add2reg_32(Register r1, int64_t imm, Register r2) {\n+  assert(Immediate::is_simm32(imm), \"probably an implicit conversion went wrong\");\n+\n+  if (r2 == noreg) { r2 = r1; }\n+\n+  \/\/ Handle special case imm == 0.\n+  if (imm == 0) {\n+    lr_if_needed(r1, r2);\n+    \/\/ Nothing else to do.\n+    return;\n+  }\n+\n+  if (Immediate::is_simm16(imm)) {\n+    if (r1 == r2){\n+      z_ahi(r1, imm);\n+      return;\n+    }\n+    if (VM_Version::has_DistinctOpnds()) {\n+      z_ahik(r1, r2, imm);\n+      return;\n+    }\n+    lr_if_needed(r1, r2);\n+    z_ahi(r1, imm);\n+    return;\n+  }\n+\n+  \/\/ imm is simm32\n+  lr_if_needed(r1, r2);\n+  z_afi(r1, imm);\n+}\n+\n@@ -2984,1 +3015,3 @@\n-                                                   RegisterOrConstant super_check_offset) {\n+                                                   Register   super_check_offset) {\n+  \/\/ Input registers must not overlap.\n+  assert_different_registers(sub_klass, super_klass, temp1_reg, super_check_offset);\n@@ -2986,1 +3019,0 @@\n-  const int sc_offset  = in_bytes(Klass::secondary_super_cache_offset());\n@@ -2988,4 +3020,1 @@\n-\n-  bool must_load_sco = (super_check_offset.constant_or_zero() == -1);\n-  bool need_slow_path = (must_load_sco ||\n-                         super_check_offset.constant_or_zero() == sc_offset);\n+  bool must_load_sco = ! super_check_offset->is_valid();\n@@ -2994,5 +3023,1 @@\n-  assert_different_registers(sub_klass, super_klass, temp1_reg);\n-  if (super_check_offset.is_register()) {\n-    assert_different_registers(sub_klass, super_klass,\n-                               super_check_offset.as_register());\n-  } else if (must_load_sco) {\n+  if (must_load_sco) {\n@@ -3009,3 +3034,1 @@\n-  assert(label_nulls <= 1 ||\n-         (L_slow_path == &L_fallthrough && label_nulls <= 2 && !need_slow_path),\n-         \"at most one null in the batch, usually\");\n+  assert(label_nulls <= 1 || (L_slow_path == &L_fallthrough && label_nulls <= 2), \"at most one null in the batch, usually\");\n@@ -3026,1 +3049,1 @@\n-    super_check_offset = RegisterOrConstant(Rsuper_check_offset);\n+    super_check_offset = Rsuper_check_offset;\n@@ -3028,0 +3051,1 @@\n+\n@@ -3030,0 +3054,1 @@\n+  branch_optimized(Assembler::bcondEqual, *L_success);\n@@ -3047,17 +3072,3 @@\n-  if (super_check_offset.is_register()) {\n-    branch_optimized(Assembler::bcondEqual, *L_success);\n-    z_cfi(super_check_offset.as_register(), sc_offset);\n-    if (L_failure == &L_fallthrough) {\n-      branch_optimized(Assembler::bcondEqual, *L_slow_path);\n-    } else {\n-      branch_optimized(Assembler::bcondNotEqual, *L_failure);\n-      final_jmp(*L_slow_path);\n-    }\n-  } else if (super_check_offset.as_constant() == sc_offset) {\n-    \/\/ Need a slow path; fast failure is impossible.\n-    if (L_slow_path == &L_fallthrough) {\n-      branch_optimized(Assembler::bcondEqual, *L_success);\n-    } else {\n-      branch_optimized(Assembler::bcondNotEqual, *L_slow_path);\n-      final_jmp(*L_success);\n-    }\n+  z_cfi(super_check_offset, in_bytes(Klass::secondary_super_cache_offset()));\n+  if (L_failure == &L_fallthrough) {\n+    branch_optimized(Assembler::bcondEqual, *L_slow_path);\n@@ -3065,7 +3076,2 @@\n-    \/\/ No slow path; it's a fast decision.\n-    if (L_failure == &L_fallthrough) {\n-      branch_optimized(Assembler::bcondEqual, *L_success);\n-    } else {\n-      branch_optimized(Assembler::bcondNotEqual, *L_failure);\n-      final_jmp(*L_success);\n-    }\n+    branch_optimized(Assembler::bcondNotEqual, *L_failure);\n+    final_jmp(*L_slow_path);\n@@ -3075,1 +3081,0 @@\n-#undef local_brc\n@@ -3081,6 +3086,7 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register Rsubklass,\n-                                                   Register Rsuperklass,\n-                                                   Register Rarray_ptr,  \/\/ tmp\n-                                                   Register Rlength,     \/\/ tmp\n-                                                   Label* L_success,\n-                                                   Label* L_failure) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register Rsubklass,\n+                                                          Register Rsuperklass,\n+                                                          Register Rarray_ptr,  \/\/ tmp\n+                                                          Register Rlength,     \/\/ tmp\n+                                                          Label* L_success,\n+                                                          Label* L_failure,\n+                                                          bool set_cond_codes \/* unused *\/) {\n@@ -3109,1 +3115,1 @@\n-  BLOCK_COMMENT(\"check_klass_subtype_slow_path {\");\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path_linear {\");\n@@ -3137,1 +3143,1 @@\n-  \/\/ Cache load doesn't happen here. For speed it is directly emitted by the compiler.\n+  \/\/ Cache load doesn't happen here. For speed, it is directly emitted by the compiler.\n@@ -3141,2 +3147,3 @@\n-  z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n-\n+  if (UseSecondarySupersCache) {\n+    z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+  }\n@@ -3147,1 +3154,0 @@\n-#undef local_brc\n@@ -3149,0 +3155,133 @@\n+  BLOCK_COMMENT(\"} check_klass_subtype_slow_path_linear\");\n+}\n+\n+\/\/ If Register r is invalid, remove a new register from\n+\/\/ available_regs, and add new register to regs_to_push.\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                           RegSetIterator<Register> &available_regs,\n+                                           RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs++;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+\/\/ check_klass_subtype_slow_path_table() looks for super_klass in the\n+\/\/ hash table belonging to super_klass, branching to L_success or\n+\/\/ L_failure as appropriate. This is essentially a shim which\n+\/\/ allocates registers as necessary and then calls\n+\/\/ lookup_secondary_supers_table() to do the work. Any of the temp\n+\/\/ regs may be noreg, in which case this logic will choose some\n+\/\/ registers push and pop them from the stack.\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register temp_reg,\n+                                                         Register temp2_reg,\n+                                                         Register temp3_reg,\n+                                                         Register temp4_reg,\n+                                                         Register result_reg,\n+                                                         Label* L_success,\n+                                                         Label* L_failure,\n+                                                         bool set_cond_codes) {\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path_table {\");\n+\n+  RegSet temps = RegSet::of(temp_reg, temp2_reg, temp3_reg, temp4_reg);\n+\n+  assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, temp4_reg);\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  RegSetIterator<Register> available_regs\n+  \/\/ Z_R0 will be used to hold Z_R15(Z_SP) while pushing a new frame, So don't use that here.\n+  \/\/ Z_R1 will be used to hold r_bitmap in lookup_secondary_supers_table_var, so can't be used\n+  \/\/ Z_R2, Z_R3, Z_R4 will be used in secondary_supers_verify, for the failure reporting\n+    = (RegSet::range(Z_R0, Z_R15) - temps - sub_klass - super_klass - Z_R1_scratch - Z_R0_scratch - Z_R2 - Z_R3 - Z_R4).begin();\n+\n+  RegSet pushed_regs;\n+\n+  temp_reg  = allocate_if_noreg(temp_reg,  available_regs, pushed_regs);\n+  temp2_reg = allocate_if_noreg(temp2_reg, available_regs, pushed_regs);\n+  temp3_reg = allocate_if_noreg(temp3_reg, available_regs, pushed_regs);;\n+  temp4_reg = allocate_if_noreg(temp4_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+\n+  const int frame_size = pushed_regs.size() * BytesPerWord + frame::z_abi_160_size;\n+\n+  \/\/ Push & save registers\n+  {\n+    int i = 0;\n+    save_return_pc();\n+    push_frame(frame_size);\n+\n+    for (auto it = pushed_regs.begin(); *it != noreg; i++) {\n+      z_stg(*it++, i * BytesPerWord + frame::z_abi_160_size, Z_SP);\n+    }\n+    assert(i * BytesPerWord + frame::z_abi_160_size == frame_size, \"sanity\");\n+  }\n+\n+  lookup_secondary_supers_table_var(sub_klass,\n+                                    super_klass,\n+                                    temp_reg, temp2_reg, temp3_reg, temp4_reg, result_reg);\n+\n+  \/\/ NOTE: Condition Code should not be altered before jump instruction below !!!!\n+  z_cghi(result_reg, 0);\n+\n+  {\n+    int i = 0;\n+    for (auto it = pushed_regs.begin(); *it != noreg; ++i) {\n+      z_lg(*it++, i * BytesPerWord + frame::z_abi_160_size, Z_SP);\n+    }\n+    assert(i * BytesPerWord + frame::z_abi_160_size == frame_size, \"sanity\");\n+    pop_frame();\n+    restore_return_pc();\n+  }\n+\n+  \/\/ NB! Callers may assume that, when set_cond_codes is true, this\n+  \/\/ code sets temp2_reg to a nonzero value.\n+  if (set_cond_codes) {\n+    z_lghi(temp2_reg, 1);\n+  }\n+\n+  branch_optimized(bcondNotEqual, *L_failure);\n+\n+  if(L_success != &L_fallthrough) {\n+    z_bru(*L_success);\n+  }\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} check_klass_subtype_slow_path_table\");\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path {\");\n+  if (UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_table(sub_klass,\n+                                        super_klass,\n+                                        temp_reg,\n+                                        temp2_reg,\n+                                        \/*temp3*\/noreg,\n+                                        \/*temp4*\/noreg,\n+                                        \/*result*\/noreg,\n+                                        L_success,\n+                                        L_failure,\n+                                        set_cond_codes);\n+  } else {\n+    check_klass_subtype_slow_path_linear(sub_klass,\n+                                         super_klass,\n+                                         temp_reg,\n+                                         temp2_reg,\n+                                         L_success,\n+                                         L_failure,\n+                                         set_cond_codes);\n+  }\n@@ -3209,8 +3348,8 @@\n-void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n-                                                   Register r_super_klass,\n-                                                   Register r_temp1,\n-                                                   Register r_temp2,\n-                                                   Register r_temp3,\n-                                                   Register r_temp4,\n-                                                   Register r_result,\n-                                                   u1 super_klass_slot) {\n+void MacroAssembler::lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                                         Register r_super_klass,\n+                                                         Register r_temp1,\n+                                                         Register r_temp2,\n+                                                         Register r_temp3,\n+                                                         Register r_temp4,\n+                                                         Register r_result,\n+                                                         u1 super_klass_slot) {\n@@ -3219,1 +3358,1 @@\n-  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_const {\");\n@@ -3294,1 +3433,1 @@\n-  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_const\");\n@@ -3302,0 +3441,110 @@\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table_var(Register r_sub_klass,\n+                                                       Register r_super_klass,\n+                                                       Register temp1,\n+                                                       Register temp2,\n+                                                       Register temp3,\n+                                                       Register temp4,\n+                                                       Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result, Z_R1_scratch);\n+\n+  Label L_done, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_var {\");\n+\n+  const Register\n+    r_array_index = temp3,\n+    slot          = temp4, \/\/ NOTE: \"slot\" can't be Z_R0 otherwise z_sllg and z_rllg instructions below will mess up!!!!\n+    r_bitmap      = Z_R1_scratch;\n+\n+  z_llgc(slot, Address(r_super_klass, Klass::hash_slot_offset()));\n+\n+  \/\/ Initialize r_result with 0 (indicating success). If searching fails, r_result will be loaded\n+  \/\/ with 1 (failure) at the end of this method.\n+  clear_reg(result, true \/* whole_reg *\/, false \/* set_cc *\/); \/\/ result = 0\n+\n+  z_lg(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  z_xilf(slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1)); \/\/ slot ^ 63 === 63 - slot (mod 64)\n+  z_sllg(r_array_index, r_bitmap, \/*d2 = *\/ 0, \/* b2 = *\/ slot);\n+\n+  testbit(r_array_index, Klass::SECONDARY_SUPERS_TABLE_SIZE - 1);\n+  branch_optimized(bcondAllZero, L_failure);\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2;\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  \/\/ NOTE: Z_R1_scratch is holding bitmap (look above for r_bitmap). So let's try to save it.\n+  \/\/       On the other hand, r_array_base\/temp1 is free at current moment (look at the load operation below).\n+  pop_count_long(r_array_index, r_array_index, temp1); \/\/ kills r_array_base\/temp1 on machines older than z15\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  z_lg(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+  z_sllg(r_array_index, r_array_index, LogBytesPerWord); \/\/ scale, r_array_index is loaded by popcnt above\n+\n+  z_cg(r_super_klass, Address(r_array_base, r_array_index));\n+  branch_optimized(bcondEqual, L_done); \/\/ found a match\n+\n+  \/\/ Note: this is a small hack:\n+  \/\/\n+  \/\/ The operation \"(slot ^ 63) === 63 - slot (mod 64)\" has already been performed above.\n+  \/\/ Since we lack a rotate-right instruction, we achieve the same effect by rotating left\n+  \/\/ by \"64 - slot\" positions. This produces the result equivalent to a right rotation by \"slot\" positions.\n+  \/\/\n+  \/\/ => initial slot value\n+  \/\/ => slot = 63 - slot        \/\/ done above with that z_xilf instruction\n+  \/\/ => slot = 64 - slot        \/\/ need to do for rotating right by \"slot\" positions\n+  \/\/ => slot = 64 - (63 - slot)\n+  \/\/ => slot = slot - 63 + 64\n+  \/\/ => slot = slot + 1\n+  \/\/\n+  \/\/ So instead of rotating-left by 64-slot times, we can, for now, just rotate left by slot+1 and it would be fine.\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  z_aghi(slot, 1); \/\/ slot = slot + 1\n+\n+  z_rllg(r_bitmap, r_bitmap, \/*d2=*\/ 0, \/*b2=*\/ slot);\n+  testbit(r_bitmap, 1);\n+  branch_optimized(bcondAllZero, L_failure);\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the logic we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index,\n+                                          r_bitmap, \/*temp=*\/ r_array_length, result, \/*is_stub*\/false);\n+\n+  \/\/ pass whatever we got from slow path\n+  z_bru(L_done);\n+\n+  bind(L_failure);\n+  z_lghi(result, 1); \/\/ load 1 to represent failure\n+\n+  bind(L_done);\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_var\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n@@ -3309,0 +3558,1 @@\n+                                                             Register r_temp,\n@@ -3310,2 +3560,2 @@\n-                                                             Register r_temp1) {\n-  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, r_result, r_temp1);\n+                                                             bool is_stub) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, r_result, r_temp);\n@@ -3314,1 +3564,1 @@\n-    r_array_length = r_temp1,\n+    r_array_length = r_temp,\n@@ -3317,1 +3567,3 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  if(is_stub) {\n+    LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  }\n@@ -3346,2 +3598,4 @@\n-    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n-    \/\/ eventually terminates.\n+    \/\/ As long as the bitmap is not completely full,\n+    \/\/ array_length == popcount(bitmap). The array_length check above\n+    \/\/ guarantees there are 0s in the bitmap, so the loop eventually\n+    \/\/ terminates.\n@@ -3420,2 +3674,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n@@ -3576,1 +3828,1 @@\n-  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n@@ -3580,1 +3832,1 @@\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::lock_id_offset()));\n+  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n@@ -3655,1 +3907,1 @@\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::lock_id_offset()));\n+  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n@@ -6359,1 +6611,1 @@\n-    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+    \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n@@ -6363,1 +6615,1 @@\n-    z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::lock_id_offset()));\n+    z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":327,"deletions":75,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -159,1 +159,3 @@\n-  void add2reg(Register r1, int64_t imm, Register r2 = noreg);\n+  void add2reg   (Register r1, int64_t imm, Register r2 = noreg);\n+  void add2reg_32(Register r1, int64_t imm, Register r2 = noreg);\n+\n@@ -697,1 +699,1 @@\n-                                     RegisterOrConstant super_check_offset = RegisterOrConstant(-1));\n+                                     Register super_check_offset = noreg);\n@@ -709,1 +711,28 @@\n-                                     Label* L_failure);\n+                                     Label* L_failure,\n+                                     bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Register temp2_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure,\n+                                            bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register temp_reg,\n+                                           Register temp2_reg,\n+                                           Register temp3_reg,\n+                                           Register temp4_reg,\n+                                           Register result_reg,\n+                                           Label* L_success,\n+                                           Label* L_failure,\n+                                           bool set_cond_codes = false);\n+\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n@@ -713,8 +742,17 @@\n-  void lookup_secondary_supers_table(Register r_sub_klass,\n-                                     Register r_super_klass,\n-                                     Register r_temp1,\n-                                     Register r_temp2,\n-                                     Register r_temp3,\n-                                     Register r_temp4,\n-                                     Register r_result,\n-                                     u1 super_klass_slot);\n+  \/\/ Secondary subtype checking\n+  void lookup_secondary_supers_table_var(Register sub_klass,\n+                                         Register r_super_klass,\n+                                         Register temp1,\n+                                         Register temp2,\n+                                         Register temp3,\n+                                         Register temp4,\n+                                         Register result);\n+\n+  void lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                           Register r_super_klass,\n+                                           Register r_temp1,\n+                                           Register r_temp2,\n+                                           Register r_temp3,\n+                                           Register r_temp4,\n+                                           Register r_result,\n+                                           u1 super_klass_slot);\n@@ -726,0 +764,1 @@\n+                                               Register r_temp,\n@@ -727,1 +766,1 @@\n-                                               Register r_temp1);\n+                                               bool is_stub);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -9982,0 +9982,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -9983,1 +9984,1 @@\n-  ins_cost(10 * DEFAULT_COST);\n+  ins_cost(20 * DEFAULT_COST); \/\/ slightly larger than the next version\n@@ -9994,0 +9995,24 @@\n+\/\/ Two versions of partialSubtypeCheck, both used when we need to\n+\/\/ search for a super class in the secondary supers array. The first\n+\/\/ is used when we don't know _a priori_ the class being searched\n+\/\/ for. The second, far more common, is used when we do know: this is\n+\/\/ used for instanceof, checkcast, and any case where C2 can determine\n+\/\/ it by constant propagation.\n+instruct partialSubtypeCheckVarSuper(rarg2RegP sub, rarg3RegP super,\n+                                     r11TempRegP result,\n+                                     rarg1RegP temp1, rarg4RegP temp2, rarg5RegP temp3, r10TempRegP temp4,\n+                                     flagsReg pcc) %{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL pcc, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+  ins_cost(10 * DEFAULT_COST); \/\/ slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register,\n+                                         $temp1$$Register, $temp2$$Register, $temp3$$Register, $temp4$$Register,\n+                                         $result$$Register);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\n@@ -10000,1 +10025,1 @@\n-  ins_cost(7 * DEFAULT_COST); \/\/ needs to be less than competing nodes\n+  ins_cost(5 * DEFAULT_COST); \/\/ smaller than the next version\n@@ -10006,3 +10031,3 @@\n-      __ lookup_secondary_supers_table($sub$$Register, $super$$Register,\n-                                                 $temp1$$Register, $temp2$$Register, $temp3$$Register,\n-                                                 $temp4$$Register, $result$$Register, super_klass_slot);\n+      __ lookup_secondary_supers_table_const($sub$$Register, $super$$Register,\n+                                             $temp1$$Register, $temp2$$Register, $temp3$$Register,\n+                                             $temp4$$Register, $result$$Register, super_klass_slot);\n@@ -10020,15 +10045,0 @@\n-instruct partialSubtypeCheck_vs_zero(flagsReg pcc, rarg2RegP sub, rarg3RegP super, immP0 zero,\n-                                     rarg1RegP index, rarg4RegP scratch1, rarg5RegP scratch2) %{\n-  match(Set pcc (CmpI (PartialSubtypeCheck sub super) zero));\n-  effect(KILL scratch1, KILL scratch2, KILL index);\n-  ins_cost(10 * DEFAULT_COST);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"CALL   PartialSubtypeCheck_vs_zero\\n\" %}\n-  ins_encode %{\n-    AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());\n-    __ load_const_optimized(Z_ARG4, stub_address);\n-    __ z_basr(Z_R14, Z_ARG4);\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -638,3 +638,3 @@\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, r_result, super_klass_index);\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                           r_array_base, r_array_length, r_array_index,\n+                                           r_bitmap, r_result, super_klass_index);\n@@ -662,1 +662,1 @@\n-                                               r_array_index, r_bitmap, r_result, r_temp1);\n+                                               r_array_index, r_bitmap, r_temp1, r_result, \/* is_stub *\/ true);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-\/\/ Information compiled from https:\/\/www.ibm.com\/support\/techdocs\/atsmastr.nsf\/WebIndex\/TD105503\n+\/\/ Information compiled from https:\/\/www.ibm.com\/support\/pages\/ibm-mainframe-life-cycle-history\n@@ -71,0 +71,1 @@\n+\/\/   z16:  2022-05\n@@ -72,5 +73,5 @@\n-static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\"  };\n-static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\" };\n-static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\" };\n-static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"tbd\" };\n-static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"tbd\",        \"tbd\",        \"tbd\",        \"tbd\" };\n+static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\",         \"G10\" };\n+static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\",       \"3931\" };\n+static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\",        \"z16\" };\n+static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"2024-12-31\", \"tbd\" };\n+static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"2023-12-31\", \"2024-12-31\", \"tbd\",        \"tbd\",        \"tbd\" };\n@@ -86,1 +87,3 @@\n-                                   \"system-z, g9-z15, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, venh2\"\n+                                   \"system-z, g9-z15, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, venh2\",\n+                                   \"system-z, g10-z16, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, venh2,\"\n+                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh\"\n@@ -340,0 +343,5 @@\n+  if (is_z16()) {\n+    model_ix = 10;\n+    ambiguity++;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-#define  LongDispFacilityMask           0x0000200000000000UL  \/\/ z900 with microcode update\n-#define  LongDispFacilityHighPerfMask   0x0000300000000000UL  \/\/ z990\n+#define  LongDispFacilityMask           0x0000200000000000UL  \/\/ z900 with microcode update, Bit: 18\n+#define  LongDispFacilityHighPerfMask   0x0000100000000000UL  \/\/ z990, Bit: 19\n@@ -67,1 +67,2 @@\n-#define  DecimalFloatingPointMask       0x0000000000300000UL  \/\/ z10\n+#define  DecimalFloatingPointMask       0x0000000000200000UL  \/\/ z10, Bit: 42\n+#define  DecimalFloatingPointHighPerfMask 0x0000000000100000UL  \/\/ z10, Bit: 43\n@@ -117,0 +118,6 @@\n+#define NNPAssistFacilityMask           0x0000000004000000UL  \/\/ z16, Neural-network-processing-assist facility, Bit: 165\n+\n+\/\/ ----------------------------------------------\n+\/\/ --- FeatureBitString Bits 193..200 (DW[3]) ---\n+\/\/ ----------------------------------------------\n+#define  BEAREnhFacilityMask            0x4000000000000000UL  \/\/ z16, BEAR-enhancement facility, Bit: 193\n@@ -182,3 +189,4 @@\n-  static bool is_z13()  { return has_CryptoExt5()             && !has_MiscInstrExt2();}\n-  static bool is_z14()  { return has_MiscInstrExt2()          && !has_MiscInstrExt3();}\n-  static bool is_z15()  { return has_MiscInstrExt3();}\n+  static bool is_z13()  { return has_CryptoExt5()             && !has_MiscInstrExt2(); }\n+  static bool is_z14()  { return has_MiscInstrExt2()          && !has_MiscInstrExt3(); }\n+  static bool is_z15()  { return has_MiscInstrExt3()          && !has_BEAR_Enh_Facility(); }\n+  static bool is_z16()  { return has_BEAR_Enh_Facility(); }\n@@ -460,0 +468,1 @@\n+  static bool has_DecimalFloatingPointHighPerf() { return  (_features[0] & DecimalFloatingPointHighPerfMask) == DecimalFloatingPointHighPerfMask; }\n@@ -491,0 +500,3 @@\n+  static bool has_BEAR_Enh_Facility()         { return  (_features[3] & BEAREnhFacilityMask)           == BEAREnhFacilityMask; }\n+  static bool has_NNP_Assist_Facility()       { return  (_features[2] & NNPAssistFacilityMask)         == NNPAssistFacilityMask; }\n+\n@@ -513,0 +525,1 @@\n+  static void set_has_DecimalFloatingPointHighPerf() { _features[0] |= DecimalFloatingPointHighPerfMask; }\n@@ -563,0 +576,2 @@\n+  static void set_has_BEAR_Enh_Facility()         { _features[3] |= BEAREnhFacilityMask;}\n+  static void set_has_NNP_Assist_Facility()       { _features[2] |= NNPAssistFacilityMask;}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2971,1 +2971,1 @@\n-  NOT_LP64(assert(VM_Version::supports_sse3(), \"\"));\n+  assert(VM_Version::supports_sse3(), \"\");\n@@ -2980,1 +2980,1 @@\n-  NOT_LP64(assert(VM_Version::supports_sse3(), \"\"));\n+  assert(VM_Version::supports_sse3(), \"\");\n@@ -4617,1 +4617,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -4823,1 +4823,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -4971,1 +4971,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5020,1 +5020,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5125,1 +5125,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5191,1 +5191,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5277,1 +5277,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5284,1 +5284,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -8715,1 +8715,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -8816,1 +8816,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -8895,1 +8895,1 @@\n-  assert(VM_Version::supports_sse2(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -12404,1 +12404,1 @@\n-  assert(VM_Version::supports_sse(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse(), \"\");)\n@@ -12412,1 +12412,1 @@\n-  assert(VM_Version::supports_sse(), \"\");\n+  NOT_LP64(assert(VM_Version::supports_sse(), \"\");)\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-  movptr(boxReg, Address(r15_thread, JavaThread::lock_id_offset()));\n+  movptr(boxReg, Address(r15_thread, JavaThread::monitor_owner_id_offset()));\n@@ -628,1 +628,1 @@\n-    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+    \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n@@ -630,1 +630,1 @@\n-    movptr(box, Address(thread, JavaThread::lock_id_offset()));\n+    movptr(box, Address(thread, JavaThread::monitor_owner_id_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -87,0 +88,4 @@\n+\n+      if (ShenandoahCardBarrier) {\n+        post_barrier(access, access.resolved_addr(), new_value.result());\n+      }\n@@ -116,0 +121,3 @@\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(access, access.resolved_addr(), result);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,0 +35,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -123,0 +125,23 @@\n+    if (ShenandoahCardBarrier) {\n+      bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+      bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+      bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+\n+      \/\/ We need to save the original element count because the array copy stub\n+      \/\/ will destroy the value and we need it for the card marking barrier.\n+#ifdef _LP64\n+      if (!checkcast) {\n+        if (!obj_int) {\n+          \/\/ Save count for barrier\n+          __ movptr(r11, count);\n+        } else if (disjoint) {\n+          \/\/ Save dst in r11 in the disjoint case\n+          __ movq(r11, dst);\n+        }\n+      }\n+#else\n+      if (disjoint) {\n+        __ mov(rdx, dst);          \/\/ save 'to'\n+      }\n+#endif\n+    }\n@@ -143,1 +168,1 @@\n-      Label done;\n+      Label L_done;\n@@ -146,1 +171,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -157,1 +182,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -177,1 +202,1 @@\n-      __ bind(done);\n+      __ bind(L_done);\n@@ -184,0 +209,30 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                       Register src, Register dst, Register count) {\n+\n+  if (ShenandoahCardBarrier && is_reference_type(type)) {\n+    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+    bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+    bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+    Register tmp = rax;\n+\n+#ifdef _LP64\n+    if (!checkcast) {\n+      if (!obj_int) {\n+        \/\/ Save count for barrier\n+        count = r11;\n+      } else if (disjoint) {\n+        \/\/ Use the saved dst in the disjoint case\n+        dst = r11;\n+      }\n+    } else {\n+      tmp = rscratch1;\n+    }\n+#else\n+    if (disjoint) {\n+      __ mov(dst, rdx); \/\/ restore 'to'\n+    }\n+#endif\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, tmp);\n+  }\n+}\n+\n@@ -558,0 +613,43 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  \/\/ Does a store check for the oop in register obj. The content of\n+  \/\/ register obj is destroyed afterwards.\n+\n+  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = ctbs->card_table();\n+\n+  __ shrptr(obj, CardTable::card_shift());\n+\n+  Address card_addr;\n+\n+  \/\/ The calculation for byte_map_base is as follows:\n+  \/\/ byte_map_base = _byte_map - (uintptr_t(low_bound) >> card_shift);\n+  \/\/ So this essentially converts an address to a displacement and it will\n+  \/\/ never need to be relocated. On 64-bit however the value may be too\n+  \/\/ large for a 32-bit displacement.\n+  intptr_t byte_map_base = (intptr_t)ct->byte_map_base();\n+  if (__ is_simm32(byte_map_base)) {\n+    card_addr = Address(noreg, obj, Address::times_1, byte_map_base);\n+  } else {\n+    \/\/ By doing it as an ExternalAddress 'byte_map_base' could be converted to a rip-relative\n+    \/\/ displacement and done in a single instruction given favorable mapping and a\n+    \/\/ smarter version of as_Address. However, 'ExternalAddress' generates a relocation\n+    \/\/ entry and that entry is not properly handled by the relocation code.\n+    AddressLiteral cardtable((address)byte_map_base, relocInfo::none);\n+    Address index(noreg, obj, Address::times_1);\n+    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n+  }\n+\n+  int dirty = CardTable::dirty_card_val();\n+  if (UseCondCardMark) {\n+    Label L_already_dirty;\n+    __ cmpb(card_addr, dirty);\n+    __ jccb(Assembler::equal, L_already_dirty);\n+    __ movb(card_addr, dirty);\n+    __ bind(L_already_dirty);\n+  } else {\n+    __ movb(card_addr, dirty);\n+  }\n+}\n+\n@@ -595,0 +693,1 @@\n+\n@@ -596,0 +695,5 @@\n+    if (val != noreg) {\n+      if (ShenandoahCardBarrier) {\n+        store_check(masm, tmp1);\n+      }\n+    }\n@@ -790,0 +894,57 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n+#define BIND(label) bind(label); BLOCK_COMMENT(#label \":\")\n+\n+#define TIMES_OOP (UseCompressedOops ? Address::times_4 : Address::times_8)\n+\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register addr, Register count,\n+                                                                     Register tmp) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = bs->card_table();\n+  intptr_t disp = (intptr_t) ct->byte_map_base();\n+\n+  Label L_loop, L_done;\n+  const Register end = count;\n+  assert_different_registers(addr, end);\n+\n+  \/\/ Zero count? Nothing to do.\n+  __ testl(count, count);\n+  __ jccb(Assembler::zero, L_done);\n+\n+#ifdef _LP64\n+  __ leaq(end, Address(addr, count, TIMES_OOP, 0));  \/\/ end == addr+count*oop_size\n+  __ subptr(end, BytesPerHeapOop); \/\/ end - 1 to make inclusive\n+  __ shrptr(addr, CardTable::card_shift());\n+  __ shrptr(end, CardTable::card_shift());\n+  __ subptr(end, addr); \/\/ end --> cards count\n+\n+  __ mov64(tmp, disp);\n+  __ addptr(addr, tmp);\n+\n+  __ BIND(L_loop);\n+  __ movb(Address(addr, count, Address::times_1), 0);\n+  __ decrement(count);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n+#else\n+  __ lea(end, Address(addr, count, Address::times_ptr, -wordSize));\n+  __ shrptr(addr, CardTable::card_shift());\n+  __ shrptr(end,  CardTable::card_shift());\n+  __ subptr(end, addr); \/\/ end --> count\n+\n+  __ BIND(L_loop);\n+  Address cardtable(addr, count, Address::times_1, disp);\n+  __ movb(cardtable, 0);\n+  __ decrement(count);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n+#endif\n+\n+  __ BIND(L_done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":165,"deletions":4,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -59,0 +60,6 @@\n+  void store_check(MacroAssembler* masm, Register obj);\n+\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register addr, Register count,\n+                                        Register tmp);\n+\n@@ -74,0 +81,2 @@\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5448,1 +5448,0 @@\n-    assert(VM_Version::supports_sse2(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4427,1 +4427,1 @@\n-  format %{ \"maxF $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n+  format %{ \"maxF $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n@@ -4434,1 +4434,1 @@\n-instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{\n+instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xtmp, rRegI rtmp, rFlagsReg cr) %{\n@@ -4437,1 +4437,1 @@\n-  effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n@@ -4439,1 +4439,1 @@\n-  format %{ \"$dst = max($a, $b)\\t# intrinsic (float)\" %}\n+  format %{ \"maxF_reduction $dst, $a, $b \\t!using $xtmp and $rtmp as TEMP\" %}\n@@ -4441,1 +4441,1 @@\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n@@ -4452,1 +4452,1 @@\n-  format %{ \"maxD $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n+  format %{ \"maxD $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n@@ -4459,1 +4459,1 @@\n-instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{\n+instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xtmp, rRegL rtmp, rFlagsReg cr) %{\n@@ -4462,1 +4462,1 @@\n-  effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n@@ -4464,1 +4464,1 @@\n-  format %{ \"$dst = max($a, $b)\\t# intrinsic (double)\" %}\n+  format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n@@ -4466,1 +4466,1 @@\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n@@ -4477,1 +4477,1 @@\n-  format %{ \"minF $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n+  format %{ \"minF $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n@@ -4484,1 +4484,1 @@\n-instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{\n+instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xtmp, rRegI rtmp, rFlagsReg cr) %{\n@@ -4487,1 +4487,1 @@\n-  effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n@@ -4489,1 +4489,1 @@\n-  format %{ \"$dst = min($a, $b)\\t# intrinsic (float)\" %}\n+  format %{ \"minF_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n@@ -4491,1 +4491,1 @@\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n@@ -4502,1 +4502,1 @@\n-    format %{ \"minD $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n+    format %{ \"minD $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n@@ -4509,1 +4509,1 @@\n-instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{\n+instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xtmp, rRegL rtmp, rFlagsReg cr) %{\n@@ -4512,1 +4512,1 @@\n-  effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n@@ -4514,1 +4514,1 @@\n-  format %{ \"$dst = min($a, $b)\\t# intrinsic (double)\" %}\n+  format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n@@ -4516,1 +4516,1 @@\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -859,3 +859,3 @@\n-  \/\/ We are told to free resources of the argument thread,\n-  \/\/ but we can only really operate on the current thread.\n-  assert(Thread::current()->osthread() == osthread,\n+  \/\/ We are told to free resources of the argument thread, but we can only really operate\n+  \/\/ on the current thread. The current thread may be already detached at this point.\n+  assert(Thread::current_or_null() == nullptr || Thread::current()->osthread() == osthread,\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  _base = (uintptr_t)os::reserve_memory(max_capacity);\n+  _base = (uintptr_t)os::reserve_memory(max_capacity, false, mtJavaHeap);\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,2 +232,0 @@\n-#elif defined(IA64)\n-static char cpu_arch[] = \"ia64\";\n@@ -768,3 +766,3 @@\n-  \/\/ We are told to free resources of the argument thread,\n-  \/\/ but we can only really operate on the current thread.\n-  assert(Thread::current()->osthread() == osthread,\n+  \/\/ We are told to free resources of the argument thread, but we can only really operate\n+  \/\/ on the current thread. The current thread may be already detached at this point.\n+  assert(Thread::current_or_null() == nullptr || Thread::current()->osthread() == osthread,\n@@ -1195,2 +1193,0 @@\n-  #elif  (defined IA64)\n-  static  Elf32_Half running_arch_code=EM_IA_64;\n@@ -1217,1 +1213,1 @@\n-         IA32, AMD64, IA64, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n+         IA32, AMD64, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode. IA64 can use\n-  \/\/ page as large as 1G.\n+  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode.\n","filename":"src\/hotspot\/os\/linux\/hugepages.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,4 +44,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"monitor\", nullptr };\n-    return p;\n-  }\n","filename":"src\/hotspot\/os\/linux\/mallocInfoDcmd.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -468,3 +468,7 @@\n-\/\/ i386: 224, ia64: 1105, amd64: 186, sparc: 143\n-  #ifdef __ia64__\n-    #define SYS_gettid 1105\n+\/\/ i386: 224, amd64: 186, sparc: 143\n+  #if defined(__i386__)\n+    #define SYS_gettid 224\n+  #elif defined(__amd64__)\n+    #define SYS_gettid 186\n+  #elif defined(__sparc__)\n+    #define SYS_gettid 143\n@@ -472,13 +476,1 @@\n-    #ifdef __i386__\n-      #define SYS_gettid 224\n-    #else\n-      #ifdef __amd64__\n-        #define SYS_gettid 186\n-      #else\n-        #ifdef __sparc__\n-          #define SYS_gettid 143\n-        #else\n-          #error define gettid for the arch\n-        #endif\n-      #endif\n-    #endif\n+    #error \"Define SYS_gettid for this architecture\"\n@@ -486,2 +478,1 @@\n-#endif\n-\n+#endif \/\/ SYS_gettid\n@@ -582,0 +573,1 @@\n+#define JVM_LIB_NAME \"libjvm.so\"\n@@ -596,6 +588,4 @@\n-    \/\/ Found the full path to libjvm.so.\n-    \/\/ Now cut the path to <java_home>\/jre if we can.\n-    pslash = strrchr(buf, '\/');\n-    if (pslash != nullptr) {\n-      *pslash = '\\0';            \/\/ Get rid of \/libjvm.so.\n-    }\n+    \/\/ Found the full path to the binary. It is normally of this structure:\n+    \/\/   <jdk_path>\/lib\/<hotspot_variant>\/libjvm.so\n+    \/\/ but can also be like this for a statically linked binary:\n+    \/\/   <jdk_path>\/bin\/<executable>\n@@ -604,1 +594,11 @@\n-      *pslash = '\\0';            \/\/ Get rid of \/{client|server|hotspot}.\n+      if (strncmp(pslash + 1, JVM_LIB_NAME, strlen(JVM_LIB_NAME)) == 0) {\n+        \/\/ Binary name is libjvm.so. Get rid of \/libjvm.so.\n+        *pslash = '\\0';\n+      }\n+\n+      \/\/ Get rid of \/<hotspot_variant>, if binary is libjvm.so,\n+      \/\/ or cut off \/<executable>, if it is a statically linked binary.\n+      pslash = strrchr(buf, '\/');\n+      if (pslash != nullptr) {\n+        *pslash = '\\0';\n+      }\n@@ -608,0 +608,2 @@\n+    \/\/ Get rid of \/lib, if binary is libjvm.so,\n+    \/\/ or cut off \/bin, if it is a statically linked binary.\n@@ -611,1 +613,1 @@\n-        *pslash = '\\0';        \/\/ Get rid of \/lib.\n+        *pslash = '\\0';\n@@ -1199,3 +1201,3 @@\n-  \/\/ We are told to free resources of the argument thread,\n-  \/\/ but we can only really operate on the current thread.\n-  assert(Thread::current()->osthread() == osthread,\n+  \/\/ We are told to free resources of the argument thread, but we can only really operate\n+  \/\/ on the current thread. The current thread may be already detached at this point.\n+  assert(Thread::current_or_null() == nullptr || Thread::current()->osthread() == osthread,\n@@ -1789,2 +1791,0 @@\n-#elif  (defined IA64)\n-  static  Elf32_Half running_arch_code=EM_IA_64;\n@@ -1823,1 +1823,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -2730,2 +2730,0 @@\n-#elif defined(IA64)\n-  strncpy(cpuinfo, \"IA64\", length);\n@@ -4595,1 +4593,1 @@\n-  char* codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+  char* codebuf = os::attempt_reserve_memory_at(hint, page_size, false, mtThread);\n@@ -4603,1 +4601,1 @@\n-    codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+    codebuf = os::attempt_reserve_memory_at(hint, page_size, false, mtThread);\n@@ -4610,2 +4608,0 @@\n-  MemTracker::record_virtual_memory_tag((address)codebuf, mtInternal);\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":34,"deletions":38,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", nullptr };\n-    return p;\n-  }\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -859,0 +859,6 @@\n+void* os::lookup_function(const char* name) {\n+  \/\/ This returns the global symbol in the main executable and its dependencies,\n+  \/\/ as well as shared objects dynamically loaded with RTLD_GLOBAL flag.\n+  return dlsym(RTLD_DEFAULT, name);\n+}\n+\n@@ -952,45 +958,0 @@\n-\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n-\/\/ which is used to find statically linked in agents.\n-\/\/ Parameters:\n-\/\/            sym_name: Symbol in library we are looking for\n-\/\/            lib_name: Name of library to look in, null for shared libs.\n-\/\/            is_absolute_path == true if lib_name is absolute path to agent\n-\/\/                                     such as \"\/a\/b\/libL.so\"\n-\/\/            == false if only the base name of the library is passed in\n-\/\/               such as \"L\"\n-char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n-                                    bool is_absolute_path) {\n-  char *agent_entry_name;\n-  size_t len;\n-  size_t name_len;\n-  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n-  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n-  const char *start;\n-\n-  if (lib_name != nullptr) {\n-    name_len = strlen(lib_name);\n-    if (is_absolute_path) {\n-      \/\/ Need to strip path, prefix and suffix\n-      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n-        lib_name = ++start;\n-      }\n-      if (strlen(lib_name) <= (prefix_len + suffix_len)) {\n-        return nullptr;\n-      }\n-      lib_name += prefix_len;\n-      name_len = strlen(lib_name) - suffix_len;\n-    }\n-  }\n-  len = (lib_name != nullptr ? name_len : 0) + strlen(sym_name) + 2;\n-  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n-  if (agent_entry_name == nullptr) {\n-    return nullptr;\n-  }\n-  strcpy(agent_entry_name, sym_name);\n-  if (lib_name != nullptr) {\n-    strcat(agent_entry_name, \"_\");\n-    strncat(agent_entry_name, lib_name, name_len);\n-  }\n-  return agent_entry_name;\n-}\n-\n@@ -2285,1 +2246,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":6,"deletions":46,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -963,4 +963,0 @@\n-#if defined(IA64) && defined(LINUX)\n-    { SIGILL,  ILL_BADIADDR, \"ILL_BADIADDR\", \"Unimplemented instruction address\" },\n-    { SIGILL,  ILL_BREAK,    \"ILL_BREAK\",    \"Application Break instruction\" },\n-#endif\n@@ -980,3 +976,0 @@\n-#endif\n-#if defined(IA64) && !defined(AIX)\n-    { SIGSEGV, SEGV_PSTKOVF, \"SEGV_PSTKOVF\", \"Paragraph stack overflow\" },\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -792,3 +792,3 @@\n-  \/\/ We are told to free resources of the argument thread,\n-  \/\/ but we can only really operate on the current thread.\n-  assert(Thread::current()->osthread() == osthread,\n+  \/\/ We are told to free resources of the argument thread, but we can only really operate\n+  \/\/ on the current thread. The current thread may be already detached at this point.\n+  assert(Thread::current_or_null() == nullptr || Thread::current()->osthread() == osthread,\n@@ -1420,0 +1420,6 @@\n+void* os::lookup_function(const char* name) {\n+  \/\/ This is needed only for static builds which are not supported on Windows\n+  ShouldNotReachHere();\n+  return nullptr; \/\/ Satisfy compiler\n+}\n+\n@@ -5909,51 +5915,0 @@\n-\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n-\/\/ which is used to find statically linked in agents.\n-\/\/ Parameters:\n-\/\/            sym_name: Symbol in library we are looking for\n-\/\/            lib_name: Name of library to look in, null for shared libs.\n-\/\/            is_absolute_path == true if lib_name is absolute path to agent\n-\/\/                                     such as \"C:\/a\/b\/L.dll\"\n-\/\/            == false if only the base name of the library is passed in\n-\/\/               such as \"L\"\n-char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n-                                    bool is_absolute_path) {\n-  char *agent_entry_name;\n-  size_t len;\n-  size_t name_len;\n-  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n-  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n-  const char *start;\n-\n-  if (lib_name != nullptr) {\n-    len = name_len = strlen(lib_name);\n-    if (is_absolute_path) {\n-      \/\/ Need to strip path, prefix and suffix\n-      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n-        lib_name = ++start;\n-      } else {\n-        \/\/ Need to check for drive prefix\n-        if ((start = strchr(lib_name, ':')) != nullptr) {\n-          lib_name = ++start;\n-        }\n-      }\n-      if (len <= (prefix_len + suffix_len)) {\n-        return nullptr;\n-      }\n-      lib_name += prefix_len;\n-      name_len = strlen(lib_name) - suffix_len;\n-    }\n-  }\n-  len = (lib_name != nullptr ? name_len : 0) + strlen(sym_name) + 2;\n-  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n-  if (agent_entry_name == nullptr) {\n-    return nullptr;\n-  }\n-\n-  strcpy(agent_entry_name, sym_name);\n-  if (lib_name != nullptr) {\n-    strcat(agent_entry_name, \"_\");\n-    strncat(agent_entry_name, lib_name, name_len);\n-  }\n-  return agent_entry_name;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":9,"deletions":54,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -504,0 +504,1 @@\n+  \/\/ needs local assembler label '1:' to avoid trouble when using linktime optimization\n@@ -526,1 +527,1 @@\n-        \"  b    SpinPause_return  \\n\" \/\/ case SpinWait::NONE  (-1)\n+        \"  b    1f                \\n\" \/\/ case SpinWait::NONE  (-1)\n@@ -529,1 +530,1 @@\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n@@ -531,1 +532,1 @@\n-        \"  b    SpinPause_return  \\n\"\n+        \"  b    1f                \\n\"\n@@ -533,1 +534,1 @@\n-        \"SpinPause_return:        \\n\"\n+        \"1:        \\n\"\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICOND)) {\n+    VM_Version::ext_Zicond.enable_feature();\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2124,1 +2124,1 @@\n-    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n+    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -402,0 +403,159 @@\n+ArchiveWorkers::ArchiveWorkers() :\n+        _end_semaphore(0),\n+        _num_workers(max_workers()),\n+        _started_workers(0),\n+        _finish_tokens(0),\n+        _state(UNUSED),\n+        _task(nullptr) {}\n+\n+ArchiveWorkers::~ArchiveWorkers() {\n+  assert(Atomic::load(&_state) != WORKING, \"Should not be working\");\n+}\n+\n+int ArchiveWorkers::max_workers() {\n+  \/\/ The pool is used for short-lived bursty tasks. We do not want to spend\n+  \/\/ too much time creating and waking up threads unnecessarily. Plus, we do\n+  \/\/ not want to overwhelm large machines. This is why we want to be very\n+  \/\/ conservative about the number of workers actually needed.\n+  return MAX2(0, log2i_graceful(os::active_processor_count()));\n+}\n+\n+bool ArchiveWorkers::is_parallel() {\n+  return _num_workers > 0;\n+}\n+\n+void ArchiveWorkers::start_worker_if_needed() {\n+  while (true) {\n+    int cur = Atomic::load(&_started_workers);\n+    if (cur >= _num_workers) {\n+      return;\n+    }\n+    if (Atomic::cmpxchg(&_started_workers, cur, cur + 1, memory_order_relaxed) == cur) {\n+      new ArchiveWorkerThread(this);\n+      return;\n+    }\n+  }\n+}\n+\n+void ArchiveWorkers::run_task(ArchiveWorkerTask* task) {\n+  assert(Atomic::load(&_state) == UNUSED, \"Should be unused yet\");\n+  assert(Atomic::load(&_task) == nullptr, \"Should not have running tasks\");\n+  Atomic::store(&_state, WORKING);\n+\n+  if (is_parallel()) {\n+    run_task_multi(task);\n+  } else {\n+    run_task_single(task);\n+  }\n+\n+  assert(Atomic::load(&_state) == WORKING, \"Should be working\");\n+  Atomic::store(&_state, SHUTDOWN);\n+}\n+\n+void ArchiveWorkers::run_task_single(ArchiveWorkerTask* task) {\n+  \/\/ Single thread needs no chunking.\n+  task->configure_max_chunks(1);\n+\n+  \/\/ Execute the task ourselves, as there are no workers.\n+  task->work(0, 1);\n+}\n+\n+void ArchiveWorkers::run_task_multi(ArchiveWorkerTask* task) {\n+  \/\/ Multiple threads can work with multiple chunks.\n+  task->configure_max_chunks(_num_workers * CHUNKS_PER_WORKER);\n+\n+  \/\/ Set up the run and publish the task. Issue one additional finish token\n+  \/\/ to cover the semaphore shutdown path, see below.\n+  Atomic::store(&_finish_tokens, _num_workers + 1);\n+  Atomic::release_store(&_task, task);\n+\n+  \/\/ Kick off pool startup by starting a single worker, and proceed\n+  \/\/ immediately to executing the task locally.\n+  start_worker_if_needed();\n+\n+  \/\/ Execute the task ourselves, while workers are catching up.\n+  \/\/ This allows us to hide parts of task handoff latency.\n+  task->run();\n+\n+  \/\/ Done executing task locally, wait for any remaining workers to complete.\n+  \/\/ Once all workers report, we can proceed to termination. To do this safely,\n+  \/\/ we need to make sure every worker has left. A spin-wait alone would suffice,\n+  \/\/ but we do not want to burn cycles on it. A semaphore alone would not be safe,\n+  \/\/ since workers can still be inside it as we proceed from wait here. So we block\n+  \/\/ on semaphore first, and then spin-wait for all workers to terminate.\n+  _end_semaphore.wait();\n+  SpinYield spin;\n+  while (Atomic::load(&_finish_tokens) != 0) {\n+    spin.wait();\n+  }\n+\n+  OrderAccess::fence();\n+\n+  assert(Atomic::load(&_finish_tokens) == 0, \"All tokens are consumed\");\n+}\n+\n+void ArchiveWorkers::run_as_worker() {\n+  assert(is_parallel(), \"Should be in parallel mode\");\n+\n+  ArchiveWorkerTask* task = Atomic::load_acquire(&_task);\n+  task->run();\n+\n+  \/\/ All work done in threads should be visible to caller.\n+  OrderAccess::fence();\n+\n+  \/\/ Signal the pool the work is complete, and we are exiting.\n+  \/\/ Worker cannot do anything else with the pool after this.\n+  if (Atomic::sub(&_finish_tokens, 1, memory_order_relaxed) == 1) {\n+    \/\/ Last worker leaving. Notify the pool it can unblock to spin-wait.\n+    \/\/ Then consume the last token and leave.\n+    _end_semaphore.signal();\n+    int last = Atomic::sub(&_finish_tokens, 1, memory_order_relaxed);\n+    assert(last == 0, \"Should be\");\n+  }\n+}\n+\n+void ArchiveWorkerTask::run() {\n+  while (true) {\n+    int chunk = Atomic::load(&_chunk);\n+    if (chunk >= _max_chunks) {\n+      return;\n+    }\n+    if (Atomic::cmpxchg(&_chunk, chunk, chunk + 1, memory_order_relaxed) == chunk) {\n+      assert(0 <= chunk && chunk < _max_chunks, \"Sanity\");\n+      work(chunk, _max_chunks);\n+    }\n+  }\n+}\n+\n+void ArchiveWorkerTask::configure_max_chunks(int max_chunks) {\n+  if (_max_chunks == 0) {\n+    _max_chunks = max_chunks;\n+  }\n+}\n+\n+ArchiveWorkerThread::ArchiveWorkerThread(ArchiveWorkers* pool) : NamedThread(), _pool(pool) {\n+  set_name(\"ArchiveWorkerThread\");\n+  if (os::create_thread(this, os::os_thread)) {\n+    os::start_thread(this);\n+  } else {\n+    vm_exit_during_initialization(\"Unable to create archive worker\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n+\n+void ArchiveWorkerThread::run() {\n+  \/\/ Avalanche startup: each worker starts two others.\n+  _pool->start_worker_if_needed();\n+  _pool->start_worker_if_needed();\n+\n+  \/\/ Set ourselves up.\n+  os::set_priority(this, NearMaxPriority);\n+\n+  \/\/ Work.\n+  _pool->run_as_worker();\n+}\n+\n+void ArchiveWorkerThread::post_run() {\n+  this->NamedThread::post_run();\n+  delete this;\n+}\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":160,"deletions":0,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/semaphore.hpp\"\n@@ -347,0 +349,70 @@\n+class ArchiveWorkers;\n+\n+\/\/ A task to be worked on by worker threads\n+class ArchiveWorkerTask : public CHeapObj<mtInternal> {\n+  friend class ArchiveWorkers;\n+private:\n+  const char* _name;\n+  int _max_chunks;\n+  volatile int _chunk;\n+\n+  void run();\n+\n+  void configure_max_chunks(int max_chunks);\n+\n+public:\n+  ArchiveWorkerTask(const char* name) :\n+      _name(name), _max_chunks(0), _chunk(0) {}\n+  const char* name() const { return _name; }\n+  virtual void work(int chunk, int max_chunks) = 0;\n+};\n+\n+class ArchiveWorkerThread : public NamedThread {\n+  friend class ArchiveWorkers;\n+private:\n+  ArchiveWorkers* const _pool;\n+\n+  void post_run() override;\n+\n+public:\n+  ArchiveWorkerThread(ArchiveWorkers* pool);\n+  const char* type_name() const override { return \"Archive Worker Thread\"; }\n+  void run() override;\n+};\n+\n+\/\/ Special archive workers. The goal for this implementation is to startup fast,\n+\/\/ distribute spiky workloads efficiently, and shutdown immediately after use.\n+\/\/ This makes the implementation quite different from the normal GC worker pool.\n+class ArchiveWorkers : public StackObj {\n+  friend class ArchiveWorkerThread;\n+private:\n+  \/\/ Target number of chunks per worker. This should be large enough to even\n+  \/\/ out work imbalance, and small enough to keep bookkeeping overheads low.\n+  static constexpr int CHUNKS_PER_WORKER = 4;\n+  static int max_workers();\n+\n+  Semaphore _end_semaphore;\n+\n+  int _num_workers;\n+  int _started_workers;\n+  int _finish_tokens;\n+\n+  typedef enum { UNUSED, WORKING, SHUTDOWN } State;\n+  volatile State _state;\n+\n+  ArchiveWorkerTask* _task;\n+\n+  void run_as_worker();\n+  void start_worker_if_needed();\n+\n+  void run_task_single(ArchiveWorkerTask* task);\n+  void run_task_multi(ArchiveWorkerTask* task);\n+\n+  bool is_parallel();\n+\n+public:\n+  ArchiveWorkers();\n+  ~ArchiveWorkers();\n+  void run_task(ArchiveWorkerTask* task);\n+};\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -253,3 +253,1 @@\n-  if (Arguments::is_internal_module_property(key) &&\n-      !Arguments::is_module_path_property(key) &&\n-      !Arguments::is_add_modules_property(key)) {\n+  if (Arguments::is_incompatible_cds_internal_module_property(key)) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,4 @@\n-\n+                                                                            \\\n+  product(bool, AOTCacheParallelRelocation, true, DIAGNOSTIC,               \\\n+          \"Use parallel relocation code to speed up startup.\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1978,0 +1978,26 @@\n+class SharedDataRelocationTask : public ArchiveWorkerTask {\n+private:\n+  BitMapView* const _rw_bm;\n+  BitMapView* const _ro_bm;\n+  SharedDataRelocator* const _rw_reloc;\n+  SharedDataRelocator* const _ro_reloc;\n+\n+public:\n+  SharedDataRelocationTask(BitMapView* rw_bm, BitMapView* ro_bm, SharedDataRelocator* rw_reloc, SharedDataRelocator* ro_reloc) :\n+                           ArchiveWorkerTask(\"Shared Data Relocation\"),\n+                           _rw_bm(rw_bm), _ro_bm(ro_bm), _rw_reloc(rw_reloc), _ro_reloc(ro_reloc) {}\n+\n+  void work(int chunk, int max_chunks) override {\n+    work_on(chunk, max_chunks, _rw_bm, _rw_reloc);\n+    work_on(chunk, max_chunks, _ro_bm, _ro_reloc);\n+  }\n+\n+  void work_on(int chunk, int max_chunks, BitMapView* bm, SharedDataRelocator* reloc) {\n+    BitMap::idx_t size  = bm->size();\n+    BitMap::idx_t start = MIN2(size, size * chunk \/ max_chunks);\n+    BitMap::idx_t end   = MIN2(size, size * (chunk + 1) \/ max_chunks);\n+    assert(end > start, \"Sanity: no empty slices\");\n+    bm->iterate(reloc, start, end);\n+  }\n+};\n+\n@@ -2016,2 +2042,9 @@\n-    rw_ptrmap.iterate(&rw_patcher);\n-    ro_ptrmap.iterate(&ro_patcher);\n+\n+    if (AOTCacheParallelRelocation) {\n+      ArchiveWorkers workers;\n+      SharedDataRelocationTask task(&rw_ptrmap, &ro_ptrmap, &rw_patcher, &ro_patcher);\n+      workers.run_task(&task);\n+    } else {\n+      rw_ptrmap.iterate(&rw_patcher);\n+      ro_ptrmap.iterate(&ro_patcher);\n+    }\n@@ -2701,2 +2734,2 @@\n-  TempNewSymbol class_name_sym = SymbolTable::new_symbol(file_name);\n-  Handle ext_class_name = java_lang_String::externalize_classname(class_name_sym, CHECK_NULL);\n+  oop class_name = java_lang_String::create_oop_from_str(file_name, THREAD);\n+  Handle h_class_name = Handle(THREAD, class_name);\n@@ -2710,1 +2743,1 @@\n-                          ext_class_name,\n+                          h_class_name,\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-  _symbol_rs = ReservedSpace(symbol_rs_size);\n+  _symbol_rs = ReservedSpace(symbol_rs_size, mtClassShared);\n@@ -426,2 +426,1 @@\n-  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n-  CDS_JAVA_HEAP_ONLY(Modules::serialize_addmods_names(soc);)\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize_archived_module_info(soc);)\n@@ -570,4 +569,1 @@\n-  \/\/ Write module name into archive\n-  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n-  \/\/ Write module names from --add-modules into archive\n-  CDS_JAVA_HEAP_ONLY(Modules::dump_addmods_names();)\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_archived_module_info());\n@@ -1017,3 +1013,1 @@\n-      if (ik->is_linked()) {\n-        ik->constants()->add_dumped_interned_strings();\n-      }\n+      ik->constants()->add_dumped_interned_strings();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -745,0 +745,7 @@\n+\n+  \/\/ Redefinition support.\n+  if (this->is_old() || root_m->is_old() || target->is_old()) {\n+    guarantee(CURRENT_THREAD_ENV->jvmti_state_changed(), \"old method not detected\");\n+    return nullptr;\n+  }\n+\n@@ -784,16 +791,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::equals\n-\/\/\n-\/\/ Returns true if the methods are the same, taking redefined methods\n-\/\/ into account.\n-bool ciMethod::equals(const ciMethod* m) const {\n-  if (this == m) return true;\n-  VM_ENTRY_MARK;\n-  Method* m1 = this->get_Method();\n-  Method* m2 = m->get_Method();\n-  if (m1->is_old()) m1 = m1->get_new_method();\n-  if (m2->is_old()) m2 = m2->get_new_method();\n-  return m1 == m2;\n-}\n-\n-\n@@ -838,0 +829,6 @@\n+    \/\/ Redefinition support.\n+    if (this->is_old() || m->is_old()) {\n+      guarantee(CURRENT_THREAD_ENV->jvmti_state_changed(), \"old method not detected\");\n+      return nullptr;\n+    }\n+\n@@ -1498,0 +1495,7 @@\n+\/\/ ciMethod::is_old\n+\/\/\n+\/\/ Return true for redefined methods\n+bool ciMethod::is_old() const {\n+  ASSERT_IN_VM;\n+  return get_Method()->is_old();\n+}\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -363,0 +363,1 @@\n+  bool is_old() const;\n@@ -368,2 +369,0 @@\n-  bool equals(const ciMethod* m) const;\n-\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -952,0 +952,6 @@\n+  if (is_vm_statically_linked()) {\n+    CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, os::lookup_function(\"JDK_Canonicalize\"));\n+    assert(CanonicalizeEntry != nullptr, \"could not lookup JDK_Canonicalize\");\n+    return;\n+  }\n+\n@@ -958,0 +964,1 @@\n+  assert(CanonicalizeEntry != nullptr, \"could not lookup JDK_Canonicalize in java library\");\n@@ -962,0 +969,12 @@\n+\n+  if (is_vm_statically_linked()) {\n+      JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, os::lookup_function(\"JIMAGE_Open\"));\n+      JImageClose = CAST_TO_FN_PTR(JImageClose_t, os::lookup_function(\"JIMAGE_Close\"));\n+      JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, os::lookup_function(\"JIMAGE_FindResource\"));\n+      JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, os::lookup_function(\"JIMAGE_GetResource\"));\n+      assert(JImageOpen != nullptr && JImageClose != nullptr &&\n+            JImageFindResource != nullptr && JImageGetResource != nullptr,\n+            \"could not lookup all jimage library functions\");\n+      return;\n+    }\n+\n@@ -976,0 +995,3 @@\n+  assert(JImageOpen != nullptr && JImageClose != nullptr &&\n+        JImageFindResource != nullptr && JImageGetResource != nullptr,\n+        \"could not lookup all jimage library functions in jimage library\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,5 +49,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,6 +61,0 @@\n-\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -565,0 +565,1 @@\n+char* Modules::_archived_native_access_flags = nullptr;\n@@ -571,1 +572,42 @@\n-  ArchivePtrMarker::mark_pointer(&_archived_main_module_name);\n+}\n+\n+void Modules::check_archived_flag_consistency(char* archived_flag, const char* runtime_flag, const char* property) {\n+  log_info(cds)(\"%s %s\", property,\n+    archived_flag != nullptr ? archived_flag : \"(null)\");\n+  bool disable = false;\n+  if (runtime_flag == nullptr) {\n+    if (archived_flag != nullptr) {\n+      log_info(cds)(\"Mismatched values for property %s: %s specified during dump time but not during runtime\", property, archived_flag);\n+      disable = true;\n+    }\n+  } else {\n+    if (archived_flag == nullptr) {\n+      log_info(cds)(\"Mismatched values for property %s: %s specified during runtime but not during dump time\", property, runtime_flag);\n+      disable = true;\n+    } else if (strcmp(runtime_flag, archived_flag) != 0) {\n+      log_info(cds)(\"Mismatched values for property %s: runtime %s dump time %s\", property, runtime_flag, archived_flag);\n+      disable = true;\n+    }\n+  }\n+\n+  if (disable) {\n+    log_info(cds)(\"Disabling optimized module handling\");\n+    CDSConfig::stop_using_optimized_module_handling();\n+  }\n+  log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+  log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+}\n+\n+void Modules::dump_archived_module_info() {\n+  \/\/ Write module name into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n+  \/\/ Write module names from --add-modules into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_addmods_names();)\n+  \/\/ Write native enable-native-access flag into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_native_access_flag());\n+}\n+\n+void Modules::serialize_archived_module_info(SerializeClosure* soc) {\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize_addmods_names(soc);)\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize_native_access_flags(soc);)\n@@ -580,15 +622,0 @@\n-    bool disable = false;\n-    if (runtime_main_module == nullptr) {\n-      if (_archived_main_module_name != nullptr) {\n-        log_info(cds)(\"Module %s specified during dump time but not during runtime\", _archived_main_module_name);\n-        disable = true;\n-      }\n-    } else {\n-      if (_archived_main_module_name == nullptr) {\n-        log_info(cds)(\"Module %s specified during runtime but not during dump time\", runtime_main_module);\n-        disable = true;\n-      } else if (strcmp(runtime_main_module, _archived_main_module_name) != 0) {\n-        log_info(cds)(\"Mismatched modules: runtime %s dump time %s\", runtime_main_module, _archived_main_module_name);\n-        disable = true;\n-      }\n-    }\n@@ -596,6 +623,1 @@\n-    if (disable) {\n-      log_info(cds)(\"Disabling optimized module handling\");\n-      CDSConfig::stop_using_optimized_module_handling();\n-    }\n-    log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+    check_archived_flag_consistency(_archived_main_module_name, runtime_main_module, \"jdk.module.main\");\n@@ -608,0 +630,21 @@\n+void Modules::dump_native_access_flag() {\n+  const char* native_access_names = get_native_access_flags_as_sorted_string();\n+  if (native_access_names != nullptr) {\n+    _archived_native_access_flags = ArchiveBuilder::current()->ro_strdup(native_access_names);\n+  }\n+}\n+\n+const char* Modules::get_native_access_flags_as_sorted_string() {\n+  return get_numbered_property_as_sorted_string(\"jdk.module.enable.native.access\");\n+}\n+\n+void Modules::serialize_native_access_flags(SerializeClosure* soc) {\n+  soc->do_ptr(&_archived_native_access_flags);\n+  if (soc->reading()) {\n+    check_archived_flag_consistency(_archived_native_access_flags, get_native_access_flags_as_sorted_string(), \"jdk.module.enable.native.access\");\n+\n+    \/\/ Don't hold onto the pointer, in case we might decide to unmap the archive.\n+    _archived_native_access_flags = nullptr;\n+  }\n+}\n+\n@@ -609,1 +652,0 @@\n-  unsigned int count = Arguments::addmods_count();\n@@ -614,1 +656,4 @@\n-  ArchivePtrMarker::mark_pointer(&_archived_addmods_names);\n+}\n+\n+const char* Modules::get_addmods_names_as_sorted_string() {\n+  return get_numbered_property_as_sorted_string(\"jdk.module.addmods\");\n@@ -620,27 +665,1 @@\n-    bool disable = false;\n-    if (_archived_addmods_names[0] != '\\0') {\n-      if (Arguments::addmods_count() == 0) {\n-        log_info(cds)(\"--add-modules module name(s) found in archive but not specified during runtime: %s\",\n-            _archived_addmods_names);\n-        disable = true;\n-      } else {\n-        const char* addmods_names = get_addmods_names_as_sorted_string();\n-        if (strcmp((const char*)_archived_addmods_names, addmods_names) != 0) {\n-          log_info(cds)(\"Mismatched --add-modules module name(s).\");\n-          log_info(cds)(\"  dump time: %s runtime: %s\", _archived_addmods_names, addmods_names);\n-          disable = true;\n-        }\n-      }\n-    } else {\n-      if (Arguments::addmods_count() > 0) {\n-        log_info(cds)(\"--add-modules module name(s) specified during runtime but not found in archive: %s\",\n-                      get_addmods_names_as_sorted_string());\n-        disable = true;\n-      }\n-    }\n-    if (disable) {\n-      log_info(cds)(\"Disabling optimized module handling\");\n-      CDSConfig::stop_using_optimized_module_handling();\n-    }\n-    log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+    check_archived_flag_consistency(_archived_addmods_names, get_addmods_names_as_sorted_string(), \"jdk.module.addmods\");\n@@ -653,1 +672,1 @@\n-const char* Modules::get_addmods_names_as_sorted_string() {\n+const char* Modules::get_numbered_property_as_sorted_string(const char* property) {\n@@ -655,1 +674,3 @@\n-  const int max_digits = 3;\n+  \/\/ theoretical string size limit for decimal int, but the following loop will end much sooner due to\n+  \/\/ OS command-line size limit.\n+  const int max_digits = 10;\n@@ -657,1 +678,1 @@\n-  size_t prop_len = strlen(\"jdk.module.addmods\") + max_digits + extra_symbols_count;\n+  size_t prop_len = strlen(property) + max_digits + extra_symbols_count;\n@@ -660,2 +681,2 @@\n-  for (unsigned int i = 0; i < Arguments::addmods_count(); i++) {\n-    jio_snprintf(prop_name, prop_len, \"jdk.module.addmods.%d\", i);\n+  for (unsigned int i = 0;; i++) {\n+    jio_snprintf(prop_name, prop_len, \"%s.%d\", property, i);\n@@ -663,0 +684,3 @@\n+    if (prop_value == nullptr) {\n+      break;\n+    }\n@@ -698,1 +722,1 @@\n-      prefix = \"\\n\";\n+      prefix = \",\";\n@@ -702,1 +726,2 @@\n-  return (const char*)os::strdup(st.as_string()); \/\/ Example: \"java.base,java.compiler\"\n+  const char* result = (const char*)os::strdup(st.as_string()); \/\/ Example: \"java.base,java.compiler\"\n+  return strcmp(result, \"\") != 0 ? result : nullptr;\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":83,"deletions":58,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,2 @@\n+  static void dump_archived_module_info() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void serialize_archived_module_info(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -64,0 +66,6 @@\n+  static void check_archived_flag_consistency(char* archived_flag, const char* runtime_flag, const char* property) NOT_CDS_JAVA_HEAP_RETURN;\n+\n+  static void dump_native_access_flag() NOT_CDS_JAVA_HEAP_RETURN;\n+  static const char* get_native_access_flags_as_sorted_string() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static void serialize_native_access_flags(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+\n@@ -65,1 +73,0 @@\n-  static void serialize_addmods_names(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -67,0 +74,1 @@\n+  static void serialize_addmods_names(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -68,0 +76,1 @@\n+  static const char* get_numbered_property_as_sorted_string(const char* property) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -71,0 +80,1 @@\n+  static char* _archived_native_access_flags;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  void *lib_handle = nullptr;\n@@ -89,8 +90,12 @@\n-  char buffer[JVM_MAXPATHLEN];\n-  char ebuf[1024];\n-  if (!os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(), \"verify\"))\n-    return nullptr; \/\/ Caller will throw VerifyError\n-\n-  void *lib_handle = os::dll_load(buffer, ebuf, sizeof(ebuf));\n-  if (lib_handle == nullptr)\n-    return nullptr; \/\/ Caller will throw VerifyError\n+  if (is_vm_statically_linked()) {\n+    lib_handle = os::get_default_process_handle();\n+  } else {\n+    char buffer[JVM_MAXPATHLEN];\n+    char ebuf[1024];\n+    if (!os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(), \"verify\"))\n+      return nullptr; \/\/ Caller will throw VerifyError\n+\n+    lib_handle = os::dll_load(buffer, ebuf, sizeof(ebuf));\n+    if (lib_handle == nullptr)\n+      return nullptr; \/\/ Caller will throw VerifyError\n+  }\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -746,1 +746,1 @@\n-  \/* Thread.dump_to_file jcmd *\/                                                                                  \\\n+  \/* jcmd Thread.dump_to_file *\/                                                                                  \\\n@@ -750,0 +750,5 @@\n+                                                                                                                  \\\n+  \/* jcmd Thread.vthread_scheduler and Thread.vthread_pollers *\/                                                  \\\n+  template(jdk_internal_vm_JcmdVThreadCommands,    \"jdk\/internal\/vm\/JcmdVThreadCommands\")                         \\\n+  template(printScheduler_name,                    \"printScheduler\")                                              \\\n+  template(printPollers_name,                      \"printPollers\")                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1451,1 +1451,1 @@\n-#if defined(X86) && !defined(ZERO)\n+#if defined(IA32) && !defined(ZERO)\n@@ -1473,1 +1473,1 @@\n-#endif \/\/ X86 && !ZERO\n+#endif \/\/ IA32 && !ZERO\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,0 +222,1 @@\n+  size_t len = strlen(name);\n@@ -223,1 +224,1 @@\n-    if (strlen(name) == 1) {\n+    if (len == 1) {\n@@ -227,1 +228,2 @@\n-    memmove(name, name + 1, strlen(name + 1) + 1);\n+    memmove(name, name + 1, len); \/\/ Include terminating nul in move.\n+    len--;\n@@ -230,1 +232,0 @@\n-  size_t len = strlen(name);\n@@ -236,1 +237,1 @@\n-  if (strlen(name) == 0) {\n+  if (len == 0) {\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-#include <cstdio>\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  ReservedSpace backing_store(bytes_to_reserve);\n+  ReservedSpace backing_store(bytes_to_reserve, mtGC);\n@@ -54,1 +54,0 @@\n-  MemTracker::record_virtual_memory_tag(backing_store.base(), mtGC);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  ReservedSpace rs(size);\n+  ReservedSpace rs(size, mtGC);\n@@ -45,2 +45,0 @@\n-  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -381,2 +381,5 @@\n-  size_t av_promo  = (size_t)_avg_promoted->padded_average();\n-  bool   res = (available >= av_promo) || (available >= max_promotion_in_bytes);\n+\n+  size_t avg_promoted  = (size_t)_avg_promoted->padded_average();\n+  size_t promotion_estimate = MIN2(avg_promoted, max_promotion_in_bytes);\n+\n+  bool res = (promotion_estimate <= available);\n@@ -385,1 +388,1 @@\n-    res? \"\":\" not\", available, res? \">=\":\"<\", av_promo, max_promotion_in_bytes);\n+    res? \"\":\" not\", available, res? \">=\":\"<\", avg_promoted, max_promotion_in_bytes);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  assert(UseG1GC || UseParallelGC || UseSerialGC,\n+  assert(UseG1GC || UseParallelGC || UseSerialGC || UseShenandoahGC,\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,5 @@\n+#if INCLUDE_SHENANDOAHGC\n+    if (ShenandoahCardBarrier) {\n+      return ShenandoahYoung;\n+    }\n+#endif\n@@ -70,0 +75,5 @@\n+#if INCLUDE_SHENANDOAHGC\n+    if (ShenandoahCardBarrier) {\n+      return ShenandoahOld;\n+    }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/gcConfiguration.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+  ShenandoahYoung,\n+  ShenandoahOld,\n@@ -59,0 +61,2 @@\n+      case ShenandoahYoung: return \"Shenandoah Young\";\n+      case ShenandoahOld: return \"Shenandoah Old\";\n","filename":"src\/hotspot\/share\/gc\/shared\/gcName.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/resourceArea.inline.hpp\"\n@@ -54,0 +55,1 @@\n+  ResourceMark rm;\n","filename":"src\/hotspot\/share\/gc\/shared\/locationPrinter.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -75,1 +77,0 @@\n-  \/\/ TODO: can we directly test if bit is set?\n@@ -193,0 +194,10 @@\n+\n+  if (ShenandoahCardBarrier && access.is_oop()) {\n+    DecoratorSet decorators = access.decorators();\n+    bool is_array = (decorators & IS_ARRAY) != 0;\n+    bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+\n+    bool precise = is_array || on_anonymous;\n+    LIR_Opr post_addr = precise ? access.resolved_addr() : access.base().opr();\n+    post_barrier(access, post_addr, value);\n+  }\n@@ -291,0 +302,59 @@\n+\n+void ShenandoahBarrierSetC1::post_barrier(LIRAccess& access, LIR_Opr addr, LIR_Opr new_val) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  DecoratorSet decorators = access.decorators();\n+  LIRGenerator* gen = access.gen();\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  if (!in_heap) {\n+    return;\n+  }\n+\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n+  CardTable* ct = ctbs->card_table();\n+  LIR_Const* card_table_base = new LIR_Const(ct->byte_map_base());\n+  if (addr->is_address()) {\n+    LIR_Address* address = addr->as_address_ptr();\n+    \/\/ ptr cannot be an object because we use this barrier for array card marks\n+    \/\/ and addr can point in the middle of an array.\n+    LIR_Opr ptr = gen->new_pointer_register();\n+    if (!address->index()->is_valid() && address->disp() == 0) {\n+      __ move(address->base(), ptr);\n+    } else {\n+      assert(address->disp() != max_jint, \"lea doesn't support patched addresses!\");\n+      __ leal(addr, ptr);\n+    }\n+    addr = ptr;\n+  }\n+  assert(addr->is_register(), \"must be a register at this point\");\n+\n+  LIR_Opr tmp = gen->new_pointer_register();\n+  if (two_operand_lir_form) {\n+    __ move(addr, tmp);\n+    __ unsigned_shift_right(tmp, CardTable::card_shift(), tmp);\n+  } else {\n+    __ unsigned_shift_right(addr, CardTable::card_shift(), tmp);\n+  }\n+\n+  LIR_Address* card_addr;\n+  if (gen->can_inline_as_constant(card_table_base)) {\n+    card_addr = new LIR_Address(tmp, card_table_base->as_jint(), T_BYTE);\n+  } else {\n+    card_addr = new LIR_Address(tmp, gen->load_constant(card_table_base), T_BYTE);\n+  }\n+\n+  LIR_Opr dirty = LIR_OprFact::intConst(CardTable::dirty_card_val());\n+  if (UseCondCardMark) {\n+    LIR_Opr cur_value = gen->new_register(T_INT);\n+    __ move(card_addr, cur_value);\n+\n+    LabelObj* L_already_dirty = new LabelObj();\n+    __ cmp(lir_cond_equal, cur_value, dirty);\n+    __ branch(lir_cond_equal, L_already_dirty->label());\n+    __ move(dirty, card_addr);\n+    __ branch_destination(L_already_dirty->label());\n+  } else {\n+    __ move(dirty, card_addr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -246,0 +246,2 @@\n+  void post_barrier(LIRAccess& access, LIR_Opr addr, LIR_Opr new_val);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n@@ -435,0 +437,84 @@\n+Node* ShenandoahBarrierSetC2::byte_map_base_node(GraphKit* kit) const {\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n+  CardTable::CardValue* card_table_base = ctbs->card_table()->byte_map_base();\n+  if (card_table_base != nullptr) {\n+    return kit->makecon(TypeRawPtr::make((address)card_table_base));\n+  } else {\n+    return kit->null();\n+  }\n+}\n+\n+void ShenandoahBarrierSetC2::post_barrier(GraphKit* kit,\n+                                          Node* ctl,\n+                                          Node* oop_store,\n+                                          Node* obj,\n+                                          Node* adr,\n+                                          uint  adr_idx,\n+                                          Node* val,\n+                                          BasicType bt,\n+                                          bool use_precise) const {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  \/\/ No store check needed if we're storing a null.\n+  if (val != nullptr && val->is_Con()) {\n+    \/\/ must be either an oop or NULL\n+    const Type* t = val->bottom_type();\n+    if (t == TypePtr::NULL_PTR || t == Type::TOP)\n+      return;\n+  }\n+\n+  if (ReduceInitialCardMarks && obj == kit->just_allocated_object(kit->control())) {\n+    \/\/ We can skip marks on a freshly-allocated object in Eden.\n+    \/\/ Keep this code in sync with new_deferred_store_barrier() in runtime.cpp.\n+    \/\/ That routine informs GC to take appropriate compensating steps,\n+    \/\/ upon a slow-path allocation, so as to make this card-mark\n+    \/\/ elision safe.\n+    return;\n+  }\n+\n+  if (!use_precise) {\n+    \/\/ All card marks for a (non-array) instance are in one place:\n+    adr = obj;\n+  }\n+  \/\/ (Else it's an array (or unknown), and we want more precise card marks.)\n+  assert(adr != nullptr, \"\");\n+\n+  IdealKit ideal(kit, true);\n+\n+  \/\/ Convert the pointer to an int prior to doing math on it\n+  Node* cast = __ CastPX(__ ctrl(), adr);\n+\n+  \/\/ Divide by card size\n+  Node* card_offset = __ URShiftX( cast, __ ConI(CardTable::card_shift()) );\n+\n+  \/\/ Combine card table base and card offset\n+  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset );\n+\n+  \/\/ Get the alias_index for raw card-mark memory\n+  int adr_type = Compile::AliasIdxRaw;\n+  Node*   zero = __ ConI(0); \/\/ Dirty card value\n+\n+  if (UseCondCardMark) {\n+    \/\/ The classic GC reference write barrier is typically implemented\n+    \/\/ as a store into the global card mark table.  Unfortunately\n+    \/\/ unconditional stores can result in false sharing and excessive\n+    \/\/ coherence traffic as well as false transactional aborts.\n+    \/\/ UseCondCardMark enables MP \"polite\" conditional card mark\n+    \/\/ stores.  In theory we could relax the load from ctrl() to\n+    \/\/ no_ctrl, but that doesn't buy much latitude.\n+    Node* card_val = __ load( __ ctrl(), card_adr, TypeInt::BYTE, T_BYTE, adr_type);\n+    __ if_then(card_val, BoolTest::ne, zero);\n+  }\n+\n+  \/\/ Smash zero into card\n+  __ store(__ ctrl(), card_adr, zero, T_BYTE, adr_type, MemNode::unordered);\n+\n+  if (UseCondCardMark) {\n+    __ end_if();\n+  }\n+\n+  \/\/ Final sync IdealKit and GraphKit.\n+  kit->final_sync(ideal);\n+}\n+\n@@ -502,0 +588,15 @@\n+\n+    Node* result = BarrierSetC2::store_at_resolved(access, val);\n+\n+    if (ShenandoahCardBarrier) {\n+      const bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+      const bool is_array = (decorators & IS_ARRAY) != 0;\n+      const bool use_precise = is_array || anonymous;\n+      post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                   adr, adr_idx, val.node(), access.type(), use_precise);\n+    }\n+    return result;\n+  } else {\n+    assert(access.is_opt_access(), \"only for optimization passes\");\n+    assert(((decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) && (decorators & C2_ARRAY_COPY) != 0, \"unexpected caller of this code\");\n+    return BarrierSetC2::store_at_resolved(access, val);\n@@ -503,1 +604,0 @@\n-  return BarrierSetC2::store_at_resolved(access, val);\n@@ -574,1 +674,1 @@\n-                                                   Node* new_val, const Type* value_type) const {\n+                                                             Node* new_val, const Type* value_type) const {\n@@ -615,0 +715,4 @@\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                   access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n+    }\n@@ -669,0 +773,4 @@\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                   access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n+    }\n@@ -682,0 +790,4 @@\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                   access.addr().node(), access.alias_idx(), val, T_OBJECT, true);\n+    }\n@@ -855,3 +967,19 @@\n-void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {\n-  if (is_shenandoah_wb_pre_call(n)) {\n-    shenandoah_eliminate_wb_pre(n, &macro->igvn());\n+void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n+  if (is_shenandoah_wb_pre_call(node)) {\n+    shenandoah_eliminate_wb_pre(node, &macro->igvn());\n+  }\n+  if (ShenandoahCardBarrier && node->Opcode() == Op_CastP2X) {\n+    Node* shift = node->unique_out();\n+    Node* addp = shift->unique_out();\n+    for (DUIterator_Last jmin, j = addp->last_outs(jmin); j >= jmin; --j) {\n+      Node* mem = addp->last_out(j);\n+      if (UseCondCardMark && mem->is_Load()) {\n+        assert(mem->Opcode() == Op_LoadB, \"unexpected code shape\");\n+        \/\/ The load is checking if the card has been written so\n+        \/\/ replace it with zero to fold the test.\n+        macro->replace_node(mem, macro->intcon(0));\n+        continue;\n+      }\n+      assert(mem->is_Store(), \"store required\");\n+      macro->replace_node(mem, mem->in(MemNode::Memory));\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":133,"deletions":5,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -70,0 +70,12 @@\n+  Node* byte_map_base_node(GraphKit* kit) const;\n+\n+  void post_barrier(GraphKit* kit,\n+                    Node* ctl,\n+                    Node* store,\n+                    Node* obj,\n+                    Node* adr,\n+                    uint adr_idx,\n+                    Node* val,\n+                    BasicType bt,\n+                    bool use_precise) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,3 @@\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -29,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n@@ -34,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -61,1 +67,2 @@\n-  _last_trigger(OTHER) { }\n+  _last_trigger(OTHER),\n+  _available(Moving_Average_Samples, ShenandoahAdaptiveDecayFactor) { }\n@@ -93,1 +100,1 @@\n-                     SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n+                     SIZE_FORMAT \"%s, Max Evacuation: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n@@ -106,1 +113,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n@@ -133,1 +140,0 @@\n-  _available.add(available);\n@@ -135,2 +141,9 @@\n-  if (_available.sd() > 0) {\n-    z_score = (available - _available.avg()) \/ _available.sd();\n+  double available_sd = _available.sd();\n+  if (available_sd > 0) {\n+    double available_avg = _available.avg();\n+    z_score = (double(available) - available_avg) \/ available_sd;\n+    log_debug(gc, ergo)(\"Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n+                        byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                        z_score,\n+                        byte_size_in_proper_unit(available_avg), proper_unit_for_byte_size(available_avg),\n+                        byte_size_in_proper_unit(available_sd), proper_unit_for_byte_size(available_sd));\n@@ -139,5 +152,1 @@\n-  log_debug(gc, ergo)(\"Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n-                      byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                      z_score,\n-                      byte_size_in_proper_unit(_available.avg()), proper_unit_for_byte_size(_available.avg()),\n-                      byte_size_in_proper_unit(_available.sd()), proper_unit_for_byte_size(_available.sd()));\n+  _available.add(double(available));\n@@ -198,0 +207,28 @@\n+\/\/  Rationale:\n+\/\/    The idea is that there is an average allocation rate and there are occasional abnormal bursts (or spikes) of\n+\/\/    allocations that exceed the average allocation rate.  What do these spikes look like?\n+\/\/\n+\/\/    1. At certain phase changes, we may discard large amounts of data and replace it with large numbers of newly\n+\/\/       allocated objects.  This \"spike\" looks more like a phase change.  We were in steady state at M bytes\/sec\n+\/\/       allocation rate and now we're in a \"reinitialization phase\" that looks like N bytes\/sec.  We need the \"spike\"\n+\/\/       accommodation to give us enough runway to recalibrate our \"average allocation rate\".\n+\/\/\n+\/\/   2. The typical workload changes.  \"Suddenly\", our typical workload of N TPS increases to N+delta TPS.  This means\n+\/\/       our average allocation rate needs to be adjusted.  Once again, we need the \"spike\" accomodation to give us\n+\/\/       enough runway to recalibrate our \"average allocation rate\".\n+\/\/\n+\/\/    3. Though there is an \"average\" allocation rate, a given workload's demand for allocation may be very bursty.  We\n+\/\/       allocate a bunch of LABs during the 5 ms that follow completion of a GC, then we perform no more allocations for\n+\/\/       the next 150 ms.  It seems we want the \"spike\" to represent the maximum divergence from average within the\n+\/\/       period of time between consecutive evaluation of the should_start_gc() service.  Here's the thinking:\n+\/\/\n+\/\/       a) Between now and the next time I ask whether should_start_gc(), we might experience a spike representing\n+\/\/          the anticipated burst of allocations.  If that would put us over budget, then we should start GC immediately.\n+\/\/       b) Between now and the anticipated depletion of allocation pool, there may be two or more bursts of allocations.\n+\/\/          If there are more than one of these bursts, we can \"approximate\" that these will be separated by spans of\n+\/\/          time with very little or no allocations so the \"average\" allocation rate should be a suitable approximation\n+\/\/          of how this will behave.\n+\/\/\n+\/\/    For cases 1 and 2, we need to \"quickly\" recalibrate the average allocation rate whenever we detect a change\n+\/\/    in operation mode.  We want some way to decide that the average rate has changed, while keeping average\n+\/\/    allocation rate computation independent.\n@@ -199,1 +236,0 @@\n-  size_t max_capacity = _space_info->max_capacity();\n@@ -201,1 +237,1 @@\n-  size_t available = _space_info->available();\n+  size_t available = _space_info->soft_available();\n@@ -204,3 +240,2 @@\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+  log_debug(gc)(\"should_start_gc? available: \" SIZE_FORMAT \", soft_max_capacity: \" SIZE_FORMAT\n+                \", allocated: \" SIZE_FORMAT, available, capacity, allocated);\n@@ -212,1 +247,1 @@\n-  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+  size_t min_threshold = min_free_threshold();\n@@ -214,2 +249,2 @@\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+    log_trigger(\"Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n@@ -220,0 +255,1 @@\n+  \/\/ Check if we need to learn a bit about the application\n@@ -224,1 +260,1 @@\n-      log_info(gc)(\"Trigger: Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n+      log_trigger(\"Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n@@ -226,1 +262,1 @@\n-                   byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),\n+                   byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n@@ -231,1 +267,0 @@\n-\n@@ -233,1 +268,1 @@\n-  \/\/   1. Some space to absorb allocation spikes\n+  \/\/   1. Some space to absorb allocation spikes (ShenandoahAllocSpikeFactor)\n@@ -243,1 +278,1 @@\n-  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n+  double avg_cycle_time = _gc_cycle_time_history->davg() + (_margin_of_error_sd * _gc_cycle_time_history->dsd());\n@@ -245,0 +280,3 @@\n+\n+  log_debug(gc)(\"average GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n+          avg_cycle_time * 1000, byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n@@ -246,1 +284,2 @@\n-    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n+    log_trigger(\"Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n+                 \" to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n@@ -251,1 +290,0 @@\n-\n@@ -257,1 +295,0 @@\n-\n@@ -264,1 +301,1 @@\n-    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n+    log_trigger(\"Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n@@ -302,0 +339,7 @@\n+size_t ShenandoahAdaptiveHeuristics::min_free_threshold() {\n+  \/\/ Note that soft_max_capacity() \/ 100 * min_free_threshold is smaller than max_capacity() \/ 100 * min_free_threshold.\n+  \/\/ We want to behave conservatively here, so use max_capacity().  By returning a larger value, we cause the GC to\n+  \/\/ trigger when the remaining amount of free shrinks below the larger threshold.\n+  return _space_info->max_capacity() \/ 100 * ShenandoahMinFreeThreshold;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":72,"deletions":28,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -29,1 +31,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n@@ -42,1 +44,0 @@\n-\n@@ -141,0 +142,6 @@\n+\n+  \/\/ A conservative minimum threshold of free space that we'll try to maintain when possible.\n+  \/\/ For example, we might trigger a concurrent gc if we are likely to drop below\n+  \/\/ this threshold, or we might consider this when dynamically resizing generations\n+  \/\/ in the generational case. Controlled by global flag ShenandoahMinFreeThreshold.\n+  size_t min_free_threshold();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n@@ -55,1 +55,1 @@\n-  log_info(gc)(\"Trigger: Start next cycle immediately\");\n+  log_trigger(\"Start next cycle immediately\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+    log_trigger(\"Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n@@ -69,3 +69,3 @@\n-    log_info(gc)(\"Trigger: Allocated since last cycle (\" SIZE_FORMAT \"%s) is larger than allocation threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(bytes_allocated),           proper_unit_for_byte_size(bytes_allocated),\n-                 byte_size_in_proper_unit(threshold_bytes_allocated), proper_unit_for_byte_size(threshold_bytes_allocated));\n+    log_trigger(\"Allocated since last cycle (\" SIZE_FORMAT \"%s) is larger than allocation threshold (\" SIZE_FORMAT \"%s)\",\n+                byte_size_in_proper_unit(bytes_allocated),           proper_unit_for_byte_size(bytes_allocated),\n+                byte_size_in_proper_unit(threshold_bytes_allocated), proper_unit_for_byte_size(threshold_bytes_allocated));\n@@ -92,1 +92,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahEvacInfo.hpp\"\n+#include \"gc\/shenandoah\/shenandoahTrace.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+\n+ShenandoahGenerationalHeuristics::ShenandoahGenerationalHeuristics(ShenandoahGeneration* generation)\n+        : ShenandoahAdaptiveHeuristics(generation), _generation(generation) {\n+}\n+\n+void ShenandoahGenerationalHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n+  assert(collection_set->is_empty(), \"Must be empty\");\n+\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+\n+  \/\/ Check all pinned regions have updated status before choosing the collection set.\n+  heap->assert_pinned_region_status();\n+\n+  \/\/ Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.\n+\n+  size_t num_regions = heap->num_regions();\n+\n+  RegionData* candidates = _region_data;\n+\n+  size_t cand_idx = 0;\n+  size_t preselected_candidates = 0;\n+\n+  size_t total_garbage = 0;\n+\n+  size_t immediate_garbage = 0;\n+  size_t immediate_regions = 0;\n+\n+  size_t free = 0;\n+  size_t free_regions = 0;\n+\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+\n+  \/\/ This counts number of humongous regions that we intend to promote in this cycle.\n+  size_t humongous_regions_promoted = 0;\n+  \/\/ This counts number of regular regions that will be promoted in place.\n+  size_t regular_regions_promoted_in_place = 0;\n+  \/\/ This counts bytes of memory used by regular regions to be promoted in place.\n+  size_t regular_regions_promoted_usage = 0;\n+  \/\/ This counts bytes of memory free in regular regions to be promoted in place.\n+  size_t regular_regions_promoted_free = 0;\n+  \/\/ This counts bytes of garbage memory in regular regions to be promoted in place.\n+  size_t regular_regions_promoted_garbage = 0;\n+\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (!_generation->contains(region)) {\n+      continue;\n+    }\n+    size_t garbage = region->garbage();\n+    total_garbage += garbage;\n+    if (region->is_empty()) {\n+      free_regions++;\n+      free += region_size_bytes;\n+    } else if (region->is_regular()) {\n+      if (!region->has_live()) {\n+        \/\/ We can recycle it right away and put it in the free set.\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n+        region->make_trash_immediate();\n+      } else {\n+        bool is_candidate;\n+        \/\/ This is our candidate for later consideration.\n+        if (collection_set->is_preselected(i)) {\n+          assert(region->age() >= tenuring_threshold, \"Preselection filter\");\n+          is_candidate = true;\n+          preselected_candidates++;\n+          \/\/ Set garbage value to maximum value to force this into the sorted collection set.\n+          garbage = region_size_bytes;\n+        } else if (region->is_young() && (region->age() >= tenuring_threshold)) {\n+          \/\/ Note that for GLOBAL GC, region may be OLD, and OLD regions do not qualify for pre-selection\n+\n+          \/\/ This region is old enough to be promoted but it was not preselected, either because its garbage is below\n+          \/\/ ShenandoahOldGarbageThreshold so it will be promoted in place, or because there is not sufficient room\n+          \/\/ in old gen to hold the evacuated copies of this region's live data.  In both cases, we choose not to\n+          \/\/ place this region into the collection set.\n+          if (region->get_top_before_promote() != nullptr) {\n+            \/\/ Region was included for promotion-in-place\n+            regular_regions_promoted_in_place++;\n+            regular_regions_promoted_usage += region->used_before_promote();\n+            regular_regions_promoted_free += region->free();\n+            regular_regions_promoted_garbage += region->garbage();\n+          }\n+          is_candidate = false;\n+        } else {\n+          is_candidate = true;\n+        }\n+        if (is_candidate) {\n+          candidates[cand_idx].set_region_and_garbage(region, garbage);\n+          cand_idx++;\n+        }\n+      }\n+    } else if (region->is_humongous_start()) {\n+      \/\/ Reclaim humongous regions here, and count them as the immediate garbage\n+#ifdef ASSERT\n+      bool reg_live = region->has_live();\n+      bool bm_live = heap->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n+      assert(reg_live == bm_live,\n+             \"Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: \" SIZE_FORMAT,\n+             BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words());\n+#endif\n+      if (!region->has_live()) {\n+        heap->trash_humongous_region_at(region);\n+\n+        \/\/ Count only the start. Continuations would be counted on \"trash\" path\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n+      } else {\n+        if (region->is_young() && region->age() >= tenuring_threshold) {\n+          oop obj = cast_to_oop(region->bottom());\n+          size_t humongous_regions = ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n+          humongous_regions_promoted += humongous_regions;\n+        }\n+      }\n+    } else if (region->is_trash()) {\n+      \/\/ Count in just trashed collection set, during coalesced CM-with-UR\n+      immediate_regions++;\n+      immediate_garbage += garbage;\n+    }\n+  }\n+  heap->old_generation()->set_expected_humongous_region_promotions(humongous_regions_promoted);\n+  heap->old_generation()->set_expected_regular_region_promotions(regular_regions_promoted_in_place);\n+  log_info(gc, ergo)(\"Planning to promote in place \" SIZE_FORMAT \" humongous regions and \" SIZE_FORMAT\n+                     \" regular regions, spanning a total of \" SIZE_FORMAT \" used bytes\",\n+                     humongous_regions_promoted, regular_regions_promoted_in_place,\n+                     humongous_regions_promoted * ShenandoahHeapRegion::region_size_bytes() +\n+                     regular_regions_promoted_usage);\n+\n+  \/\/ Step 2. Look back at garbage statistics, and decide if we want to collect anything,\n+  \/\/ given the amount of immediately reclaimable garbage. If we do, figure out the collection set.\n+\n+  assert (immediate_garbage <= total_garbage,\n+          \"Cannot have more immediate garbage than total garbage: \" SIZE_FORMAT \"%s vs \" SIZE_FORMAT \"%s\",\n+          byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),\n+          byte_size_in_proper_unit(total_garbage), proper_unit_for_byte_size(total_garbage));\n+\n+  size_t immediate_percent = (total_garbage == 0) ? 0 : (immediate_garbage * 100 \/ total_garbage);\n+\n+  bool doing_promote_in_place = (humongous_regions_promoted + regular_regions_promoted_in_place > 0);\n+  if (doing_promote_in_place || (preselected_candidates > 0) || (immediate_percent <= ShenandoahImmediateThreshold)) {\n+    \/\/ Only young collections need to prime the collection set.\n+    if (_generation->is_young()) {\n+      heap->old_generation()->heuristics()->prime_collection_set(collection_set);\n+    }\n+\n+    \/\/ Call the subclasses to add young-gen regions into the collection set.\n+    choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);\n+  }\n+\n+  if (collection_set->has_old_regions()) {\n+    heap->shenandoah_policy()->record_mixed_cycle();\n+  }\n+\n+  size_t cset_percent = (total_garbage == 0) ? 0 : (collection_set->garbage() * 100 \/ total_garbage);\n+  size_t collectable_garbage = collection_set->garbage() + immediate_garbage;\n+  size_t collectable_garbage_percent = (total_garbage == 0) ? 0 : (collectable_garbage * 100 \/ total_garbage);\n+\n+  log_info(gc, ergo)(\"Collectable Garbage: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions, \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions\",\n+\n+                     byte_size_in_proper_unit(collectable_garbage),\n+                     proper_unit_for_byte_size(collectable_garbage),\n+                     collectable_garbage_percent,\n+\n+                     byte_size_in_proper_unit(immediate_garbage),\n+                     proper_unit_for_byte_size(immediate_garbage),\n+                     immediate_percent,\n+                     immediate_regions,\n+\n+                     byte_size_in_proper_unit(collection_set->garbage()),\n+                     proper_unit_for_byte_size(collection_set->garbage()),\n+                     cset_percent,\n+                     collection_set->count());\n+\n+  if (collection_set->garbage() > 0) {\n+    size_t young_evac_bytes = collection_set->get_young_bytes_reserved_for_evacuation();\n+    size_t promote_evac_bytes = collection_set->get_young_bytes_to_be_promoted();\n+    size_t old_evac_bytes = collection_set->get_old_bytes_reserved_for_evacuation();\n+    size_t total_evac_bytes = young_evac_bytes + promote_evac_bytes + old_evac_bytes;\n+    log_info(gc, ergo)(\"Evacuation Targets: YOUNG: \" SIZE_FORMAT \"%s, \"\n+                       \"PROMOTE: \" SIZE_FORMAT \"%s, \"\n+                       \"OLD: \" SIZE_FORMAT \"%s, \"\n+                       \"TOTAL: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(young_evac_bytes), proper_unit_for_byte_size(young_evac_bytes),\n+                       byte_size_in_proper_unit(promote_evac_bytes), proper_unit_for_byte_size(promote_evac_bytes),\n+                       byte_size_in_proper_unit(old_evac_bytes), proper_unit_for_byte_size(old_evac_bytes),\n+                       byte_size_in_proper_unit(total_evac_bytes), proper_unit_for_byte_size(total_evac_bytes));\n+\n+    ShenandoahEvacuationInformation evacInfo;\n+    evacInfo.set_collection_set_regions(collection_set->count());\n+    evacInfo.set_collection_set_used_before(collection_set->used());\n+    evacInfo.set_collection_set_used_after(collection_set->live());\n+    evacInfo.set_collected_old(old_evac_bytes);\n+    evacInfo.set_collected_promoted(promote_evac_bytes);\n+    evacInfo.set_collected_young(young_evac_bytes);\n+    evacInfo.set_regions_promoted_humongous(humongous_regions_promoted);\n+    evacInfo.set_regions_promoted_regular(regular_regions_promoted_in_place);\n+    evacInfo.set_regular_promoted_garbage(regular_regions_promoted_garbage);\n+    evacInfo.set_regular_promoted_free(regular_regions_promoted_free);\n+    evacInfo.set_regions_immediate(immediate_regions);\n+    evacInfo.set_immediate_size(immediate_garbage);\n+    evacInfo.set_regions_freed(free_regions);\n+\n+    ShenandoahTracer().report_evacuation_info(&evacInfo);\n+  }\n+}\n+\n+\n+size_t ShenandoahGenerationalHeuristics::add_preselected_regions_to_collection_set(ShenandoahCollectionSet* cset,\n+                                                                                   const RegionData* data,\n+                                                                                   size_t size) const {\n+#ifdef ASSERT\n+  const uint tenuring_threshold = ShenandoahGenerationalHeap::heap()->age_census()->tenuring_threshold();\n+#endif\n+\n+  \/\/ cur_young_garbage represents the amount of memory to be reclaimed from young-gen.  In the case that live objects\n+  \/\/ are known to be promoted out of young-gen, we count this as cur_young_garbage because this memory is reclaimed\n+  \/\/ from young-gen and becomes available to serve future young-gen allocation requests.\n+  size_t cur_young_garbage = 0;\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n+    if (cset->is_preselected(r->index())) {\n+      assert(r->age() >= tenuring_threshold, \"Preselected regions must have tenure age\");\n+      \/\/ Entire region will be promoted, This region does not impact young-gen or old-gen evacuation reserve.\n+      \/\/ This region has been pre-selected and its impact on promotion reserve is already accounted for.\n+\n+      \/\/ r->used() is r->garbage() + r->get_live_data_bytes()\n+      \/\/ Since all live data in this region is being evacuated from young-gen, it is as if this memory\n+      \/\/ is garbage insofar as young-gen is concerned.  Counting this as garbage reduces the need to\n+      \/\/ reclaim highly utilized young-gen regions just for the sake of finding min_garbage to reclaim\n+      \/\/ within young-gen memory.\n+\n+      cur_young_garbage += r->garbage();\n+      cset->add_region(r);\n+    }\n+  }\n+  return cur_young_garbage;\n+}\n+\n+void ShenandoahGenerationalHeuristics::log_cset_composition(ShenandoahCollectionSet* cset) const {\n+  size_t collected_old = cset->get_old_bytes_reserved_for_evacuation();\n+  size_t collected_promoted = cset->get_young_bytes_to_be_promoted();\n+  size_t collected_young = cset->get_young_bytes_reserved_for_evacuation();\n+\n+  log_info(gc, ergo)(\n+          \"Chosen CSet evacuates young: \" SIZE_FORMAT \"%s (of which at least: \" SIZE_FORMAT \"%s are to be promoted), \"\n+          \"old: \" SIZE_FORMAT \"%s\",\n+          byte_size_in_proper_unit(collected_young), proper_unit_for_byte_size(collected_young),\n+          byte_size_in_proper_unit(collected_promoted), proper_unit_for_byte_size(collected_promoted),\n+          byte_size_in_proper_unit(collected_old), proper_unit_for_byte_size(collected_old));\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHGENERATIONALHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHGENERATIONALHEURISTICS_HPP\n+\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+\n+class ShenandoahGeneration;\n+\n+\/*\n+ * This class serves as the base class for heuristics used to trigger and\n+ * choose the collection sets for young and global collections. It leans\n+ * heavily on the existing functionality of ShenandoahAdaptiveHeuristics.\n+ *\n+ * It differs from the base class primarily in that choosing the collection\n+ * set is responsible for mixed collections and in-place promotions of tenured\n+ * regions.\n+ *\/\n+class ShenandoahGenerationalHeuristics : public ShenandoahAdaptiveHeuristics {\n+\n+public:\n+  explicit ShenandoahGenerationalHeuristics(ShenandoahGeneration* generation);\n+\n+  void choose_collection_set(ShenandoahCollectionSet* collection_set) override;\n+protected:\n+  ShenandoahGeneration* _generation;\n+\n+  size_t add_preselected_regions_to_collection_set(ShenandoahCollectionSet* cset,\n+                                                   const RegionData* data,\n+                                                   size_t size) const;\n+\n+  void log_cset_composition(ShenandoahCollectionSet* cset) const;\n+};\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHGENERATIONALHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.hpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+\n+#include \"utilities\/quickSort.hpp\"\n+\n+ShenandoahGlobalHeuristics::ShenandoahGlobalHeuristics(ShenandoahGlobalGeneration* generation)\n+        : ShenandoahGenerationalHeuristics(generation) {\n+}\n+\n+\n+void ShenandoahGlobalHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                       RegionData* data, size_t size,\n+                                                                       size_t actual_free) {\n+  \/\/ Better select garbage-first regions\n+  QuickSort::sort<RegionData>(data, (int) size, compare_by_garbage);\n+\n+  choose_global_collection_set(cset, data, size, actual_free, 0 \/* cur_young_garbage *\/);\n+\n+  log_cset_composition(cset);\n+}\n+\n+\n+void ShenandoahGlobalHeuristics::choose_global_collection_set(ShenandoahCollectionSet* cset,\n+                                                              const ShenandoahHeuristics::RegionData* data,\n+                                                              size_t size, size_t actual_free,\n+                                                              size_t cur_young_garbage) const {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t garbage_threshold = region_size_bytes * ShenandoahGarbageThreshold \/ 100;\n+  size_t ignore_threshold = region_size_bytes * ShenandoahIgnoreGarbageThreshold \/ 100;\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+\n+  size_t young_evac_reserve = heap->young_generation()->get_evacuation_reserve();\n+  size_t old_evac_reserve = heap->old_generation()->get_evacuation_reserve();\n+  size_t max_young_cset = (size_t) (young_evac_reserve \/ ShenandoahEvacWaste);\n+  size_t young_cur_cset = 0;\n+  size_t max_old_cset = (size_t) (old_evac_reserve \/ ShenandoahOldEvacWaste);\n+  size_t old_cur_cset = 0;\n+\n+  \/\/ Figure out how many unaffiliated young regions are dedicated to mutator and to evacuator.  Allow the young\n+  \/\/ collector's unaffiliated regions to be transferred to old-gen if old-gen has more easily reclaimed garbage\n+  \/\/ than young-gen.  At the end of this cycle, any excess regions remaining in old-gen will be transferred back\n+  \/\/ to young.  Do not transfer the mutator's unaffiliated regions to old-gen.  Those must remain available\n+  \/\/ to the mutator as it needs to be able to consume this memory during concurrent GC.\n+\n+  size_t unaffiliated_young_regions = heap->young_generation()->free_unaffiliated_regions();\n+  size_t unaffiliated_young_memory = unaffiliated_young_regions * region_size_bytes;\n+\n+  if (unaffiliated_young_memory > max_young_cset) {\n+    size_t unaffiliated_mutator_memory = unaffiliated_young_memory - max_young_cset;\n+    unaffiliated_young_memory -= unaffiliated_mutator_memory;\n+    unaffiliated_young_regions = unaffiliated_young_memory \/ region_size_bytes; \/\/ round down\n+    unaffiliated_young_memory = unaffiliated_young_regions * region_size_bytes;\n+  }\n+\n+  \/\/ We'll affiliate these unaffiliated regions with either old or young, depending on need.\n+  max_young_cset -= unaffiliated_young_memory;\n+\n+  \/\/ Keep track of how many regions we plan to transfer from young to old.\n+  size_t regions_transferred_to_old = 0;\n+\n+  size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_young_cset;\n+  size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+  log_info(gc, ergo)(\"Adaptive CSet Selection for GLOBAL. Max Young Evacuation: \" SIZE_FORMAT\n+                     \"%s, Max Old Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                     byte_size_in_proper_unit(max_young_cset), proper_unit_for_byte_size(max_young_cset),\n+                     byte_size_in_proper_unit(max_old_cset), proper_unit_for_byte_size(max_old_cset),\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n+    assert(!cset->is_preselected(r->index()), \"There should be no preselected regions during GLOBAL GC\");\n+    bool add_region = false;\n+    if (r->is_old() || (r->age() >= tenuring_threshold)) {\n+      size_t new_cset = old_cur_cset + r->get_live_data_bytes();\n+      if ((r->garbage() > garbage_threshold)) {\n+        while ((new_cset > max_old_cset) && (unaffiliated_young_regions > 0)) {\n+          unaffiliated_young_regions--;\n+          regions_transferred_to_old++;\n+          max_old_cset += region_size_bytes \/ ShenandoahOldEvacWaste;\n+        }\n+      }\n+      if ((new_cset <= max_old_cset) && (r->garbage() > garbage_threshold)) {\n+        add_region = true;\n+        old_cur_cset = new_cset;\n+      }\n+    } else {\n+      assert(r->is_young() && (r->age() < tenuring_threshold), \"DeMorgan's law (assuming r->is_affiliated)\");\n+      size_t new_cset = young_cur_cset + r->get_live_data_bytes();\n+      size_t region_garbage = r->garbage();\n+      size_t new_garbage = cur_young_garbage + region_garbage;\n+      bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+\n+      if (add_regardless || (r->garbage() > garbage_threshold)) {\n+        while ((new_cset > max_young_cset) && (unaffiliated_young_regions > 0)) {\n+          unaffiliated_young_regions--;\n+          max_young_cset += region_size_bytes \/ ShenandoahEvacWaste;\n+        }\n+      }\n+      if ((new_cset <= max_young_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+        add_region = true;\n+        young_cur_cset = new_cset;\n+        cur_young_garbage = new_garbage;\n+      }\n+    }\n+    if (add_region) {\n+      cset->add_region(r);\n+    }\n+  }\n+\n+  if (regions_transferred_to_old > 0) {\n+    heap->generation_sizer()->force_transfer_to_old(regions_transferred_to_old);\n+    heap->young_generation()->set_evacuation_reserve(young_evac_reserve - regions_transferred_to_old * region_size_bytes);\n+    heap->old_generation()->set_evacuation_reserve(old_evac_reserve + regions_transferred_to_old * region_size_bytes);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHGLOBALHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHGLOBALHEURISTICS_HPP\n+\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.hpp\"\n+\n+class ShenandoahGlobalGeneration;\n+\n+\/*\n+ * This is a specialization of the generational heuristics which is aware\n+ * of old and young regions and respects the configured evacuation parameters\n+ * for such regions during a global collection of a generational heap.\n+ *\/\n+class ShenandoahGlobalHeuristics : public ShenandoahGenerationalHeuristics {\n+public:\n+  ShenandoahGlobalHeuristics(ShenandoahGlobalGeneration* generation);\n+\n+  void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                             RegionData* data, size_t size,\n+                                             size_t actual_free) override;\n+\n+private:\n+  void choose_global_collection_set(ShenandoahCollectionSet* cset,\n+                                    const ShenandoahHeuristics::RegionData* data,\n+                                    size_t size, size_t actual_free,\n+                                    size_t cur_young_garbage) const;\n+};\n+\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHGLOBALHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,1 +28,0 @@\n-#include \"gc\/shenandoah\/shenandoahCollectionSet.inline.hpp\"\n@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"utilities\/quickSort.hpp\"\n@@ -37,0 +37,1 @@\n+\/\/ sort by decreasing garbage (so most garbage comes first)\n@@ -38,1 +39,1 @@\n-  if (a._garbage > b._garbage)\n+  if (a.get_garbage() > b.get_garbage()) {\n@@ -40,1 +41,1 @@\n-  else if (a._garbage < b._garbage)\n+  } else if (a.get_garbage() < b.get_garbage()) {\n@@ -42,1 +43,3 @@\n-  else return 0;\n+  } else {\n+    return 0;\n+  }\n@@ -48,0 +51,1 @@\n+  _guaranteed_gc_interval(0),\n@@ -52,1 +56,1 @@\n-  _gc_time_history(new TruncatedSeq(10, ShenandoahAdaptiveDecayFactor)),\n+  _gc_cycle_time_history(new TruncatedSeq(Moving_Average_Samples, ShenandoahAdaptiveDecayFactor)),\n@@ -59,0 +63,3 @@\n+  for (size_t i = 0; i < num_regions; i++) {\n+    _region_data[i].clear();\n+  }\n@@ -66,1 +73,1 @@\n-  assert(collection_set->count() == 0, \"Must be empty\");\n+  assert(collection_set->is_empty(), \"Must be empty\");\n@@ -108,2 +115,1 @@\n-        candidates[cand_idx]._region = region;\n-        candidates[cand_idx]._garbage = garbage;\n+        candidates[cand_idx].set_region_and_garbage(region, garbage);\n@@ -150,1 +156,0 @@\n-\n@@ -155,2 +160,2 @@\n-                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions, \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions\",\n@@ -165,0 +170,1 @@\n+                     immediate_regions,\n@@ -168,1 +174,2 @@\n-                     cset_percent);\n+                     cset_percent,\n+                     collection_set->count());\n@@ -183,1 +190,1 @@\n-    log_info(gc)(\"Trigger: %s\", GCCause::to_string(GCCause::_metadata_GC_threshold));\n+    log_trigger(\"%s\", GCCause::to_string(GCCause::_metadata_GC_threshold));\n@@ -187,1 +194,1 @@\n-  if (ShenandoahGuaranteedGCInterval > 0) {\n+  if (_guaranteed_gc_interval > 0) {\n@@ -189,3 +196,3 @@\n-    if (last_time_ms > ShenandoahGuaranteedGCInterval) {\n-      log_info(gc)(\"Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n-                   last_time_ms, ShenandoahGuaranteedGCInterval);\n+    if (last_time_ms > _guaranteed_gc_interval) {\n+      log_trigger(\"Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n+                   last_time_ms, _guaranteed_gc_interval);\n@@ -205,1 +212,1 @@\n-          \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -217,1 +224,19 @@\n-          \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+}\n+\n+void ShenandoahHeuristics::log_trigger(const char* fmt, ...) {\n+  LogTarget(Info, gc) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print_raw(\"Trigger\", 7);\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      ls.print(\" (%s)\", _space_info->name());\n+    }\n+    ls.print_raw(\": \", 2);\n+    va_list va;\n+    va_start(va, fmt);\n+    ls.vprint(fmt, va);\n+    va_end(va);\n+    ls.cr();\n+  }\n@@ -221,1 +246,1 @@\n-  _gc_time_history->add(time_since_last_gc());\n+  _gc_cycle_time_history->add(elapsed_cycle_time());\n@@ -259,1 +284,1 @@\n-double ShenandoahHeuristics::time_since_last_gc() const {\n+double ShenandoahHeuristics::elapsed_cycle_time() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":47,"deletions":22,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,2 +30,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"utilities\/numberSeq.hpp\"\n@@ -72,0 +72,6 @@\n+#ifdef ASSERT\n+  enum UnionTag {\n+    is_uninitialized, is_garbage, is_live_data\n+  };\n+#endif\n+\n@@ -73,1 +79,4 @@\n-  typedef struct {\n+  static const uint Moving_Average_Samples = 10; \/\/ Number of samples to store in moving averages\n+\n+  class RegionData {\n+    private:\n@@ -75,2 +84,48 @@\n-    size_t _garbage;\n-  } RegionData;\n+    union {\n+      size_t _garbage;          \/\/ Not used by old-gen heuristics.\n+      size_t _live_data;        \/\/ Only used for old-gen heuristics, which prioritizes retention of _live_data over garbage reclaim\n+    } _region_union;\n+#ifdef ASSERT\n+    UnionTag _union_tag;\n+#endif\n+    public:\n+\n+    inline void clear() {\n+      _region = nullptr;\n+      _region_union._garbage = 0;\n+#ifdef ASSERT\n+      _union_tag = is_uninitialized;\n+#endif\n+    }\n+\n+    inline void set_region_and_garbage(ShenandoahHeapRegion* region, size_t garbage) {\n+      _region = region;\n+      _region_union._garbage = garbage;\n+#ifdef ASSERT\n+      _union_tag = is_garbage;\n+#endif\n+    }\n+\n+    inline void set_region_and_livedata(ShenandoahHeapRegion* region, size_t live) {\n+      _region = region;\n+      _region_union._live_data = live;\n+#ifdef ASSERT\n+      _union_tag = is_live_data;\n+#endif\n+    }\n+\n+    inline ShenandoahHeapRegion* get_region() const {\n+      assert(_union_tag != is_uninitialized, \"Cannot fetch region from uninitialized RegionData\");\n+      return _region;\n+    }\n+\n+    inline size_t get_garbage() const {\n+      assert(_union_tag == is_garbage, \"Invalid union fetch\");\n+      return _region_union._garbage;\n+    }\n+\n+    inline size_t get_livedata() const {\n+      assert(_union_tag == is_live_data, \"Invalid union fetch\");\n+      return _region_union._live_data;\n+    }\n+  };\n@@ -81,0 +136,12 @@\n+  \/\/ Depending on generation mode, region data represents the results of the relevant\n+  \/\/ most recently completed marking pass:\n+  \/\/   - in GLOBAL mode, global marking pass\n+  \/\/   - in OLD mode,    old-gen marking pass\n+  \/\/   - in YOUNG mode,  young-gen marking pass\n+  \/\/\n+  \/\/ Note that there is some redundancy represented in region data because\n+  \/\/ each instance is an array large enough to hold all regions. However,\n+  \/\/ any region in young-gen is not in old-gen. And any time we are\n+  \/\/ making use of the GLOBAL data, there is no need to maintain the\n+  \/\/ YOUNG or OLD data. Consider this redundancy of data structure to\n+  \/\/ have negligible cost unless proven otherwise.\n@@ -83,0 +150,2 @@\n+  size_t _guaranteed_gc_interval;\n+\n@@ -88,1 +157,1 @@\n-  TruncatedSeq* _gc_time_history;\n+  TruncatedSeq* _gc_cycle_time_history;\n@@ -109,0 +178,4 @@\n+  void set_guaranteed_gc_interval(size_t guaranteed_gc_interval) {\n+    _guaranteed_gc_interval = guaranteed_gc_interval;\n+  }\n+\n@@ -130,0 +203,3 @@\n+\n+  \/\/ This indicates whether or not the current cycle should unload classes.\n+  \/\/ It does NOT indicate that a cycle should be started.\n@@ -137,1 +213,4 @@\n-  double time_since_last_gc() const;\n+  double elapsed_cycle_time() const;\n+\n+  \/\/ Format prefix and emit log message indicating a GC cycle hs been triggered\n+  void log_trigger(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":86,"deletions":7,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,734 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+uint ShenandoahOldHeuristics::NOT_FOUND = -1U;\n+\n+\/\/ sort by increasing live (so least live comes first)\n+int ShenandoahOldHeuristics::compare_by_live(RegionData a, RegionData b) {\n+  if (a.get_livedata() < b.get_livedata()) {\n+    return -1;\n+  } else if (a.get_livedata() > b.get_livedata()) {\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+\/\/ sort by increasing index\n+int ShenandoahOldHeuristics::compare_by_index(RegionData a, RegionData b) {\n+  if (a.get_region()->index() < b.get_region()->index()) {\n+    return -1;\n+  } else if (a.get_region()->index() > b.get_region()->index()) {\n+    return 1;\n+  } else {\n+    \/\/ quicksort may compare to self during search for pivot\n+    return 0;\n+  }\n+}\n+\n+ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahOldGeneration* generation, ShenandoahGenerationalHeap* gen_heap) :\n+  ShenandoahHeuristics(generation),\n+  _heap(gen_heap),\n+  _old_gen(generation),\n+  _first_pinned_candidate(NOT_FOUND),\n+  _last_old_collection_candidate(0),\n+  _next_old_collection_candidate(0),\n+  _last_old_region(0),\n+  _live_bytes_in_unprocessed_candidates(0),\n+  _old_generation(generation),\n+  _cannot_expand_trigger(false),\n+  _fragmentation_trigger(false),\n+  _growth_trigger(false),\n+  _fragmentation_density(0.0),\n+  _fragmentation_first_old_region(0),\n+  _fragmentation_last_old_region(0)\n+{\n+}\n+\n+bool ShenandoahOldHeuristics::prime_collection_set(ShenandoahCollectionSet* collection_set) {\n+  if (unprocessed_old_collection_candidates() == 0) {\n+    return false;\n+  }\n+\n+  if (_old_generation->is_preparing_for_mark()) {\n+    \/\/ We have unprocessed old collection candidates, but the heuristic has given up on evacuating them.\n+    \/\/ This is most likely because they were _all_ pinned at the time of the last mixed evacuation (and\n+    \/\/ this in turn is most likely because there are just one or two candidate regions remaining).\n+    log_info(gc, ergo)(\"Remaining \" UINT32_FORMAT \" old regions are being coalesced and filled\", unprocessed_old_collection_candidates());\n+    return false;\n+  }\n+\n+  _first_pinned_candidate = NOT_FOUND;\n+\n+  uint included_old_regions = 0;\n+  size_t evacuated_old_bytes = 0;\n+  size_t collected_old_bytes = 0;\n+\n+  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n+  \/\/ \"available\" to hold the results of other evacuations.  This may cause a decrease in the remaining amount\n+  \/\/ of memory that can still be evacuated.  We address this by reducing the evacuation budget by the amount\n+  \/\/ of live memory in that region and by the amount of unallocated memory in that region if the evacuation\n+  \/\/ budget is constrained by availability of free memory.\n+  const size_t old_evacuation_reserve = _old_generation->get_evacuation_reserve();\n+  const size_t old_evacuation_budget = (size_t) ((double) old_evacuation_reserve \/ ShenandoahOldEvacWaste);\n+  size_t unfragmented_available = _old_generation->free_unaffiliated_regions() * ShenandoahHeapRegion::region_size_bytes();\n+  size_t fragmented_available;\n+  size_t excess_fragmented_available;\n+\n+  if (unfragmented_available > old_evacuation_budget) {\n+    unfragmented_available = old_evacuation_budget;\n+    fragmented_available = 0;\n+    excess_fragmented_available = 0;\n+  } else {\n+    assert(_old_generation->available() >= old_evacuation_budget, \"Cannot budget more than is available\");\n+    fragmented_available = _old_generation->available() - unfragmented_available;\n+    assert(fragmented_available + unfragmented_available >= old_evacuation_budget, \"Budgets do not add up\");\n+    if (fragmented_available + unfragmented_available > old_evacuation_budget) {\n+      excess_fragmented_available = (fragmented_available + unfragmented_available) - old_evacuation_budget;\n+      fragmented_available -= excess_fragmented_available;\n+    }\n+  }\n+\n+  size_t remaining_old_evacuation_budget = old_evacuation_budget;\n+  log_debug(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s, candidates: %u\",\n+                byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget),\n+                unprocessed_old_collection_candidates());\n+\n+  size_t lost_evacuation_capacity = 0;\n+\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates().\n+  \/\/ Candidate regions are ordered according to increasing amount of live data.  If there is not sufficient room to\n+  \/\/ evacuate region N, then there is no need to even consider evacuating region N+1.\n+  while (unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n+    ShenandoahHeapRegion* r = next_old_collection_candidate();\n+    if (r == nullptr) {\n+      break;\n+    }\n+    assert(r->is_regular(), \"There should be no humongous regions in the set of mixed-evac candidates\");\n+\n+    \/\/ If region r is evacuated to fragmented memory (to free memory within a partially used region), then we need\n+    \/\/ to decrease the capacity of the fragmented memory by the scaled loss.\n+\n+    size_t live_data_for_evacuation = r->get_live_data_bytes();\n+    size_t lost_available = r->free();\n+\n+    if ((lost_available > 0) && (excess_fragmented_available > 0)) {\n+      if (lost_available < excess_fragmented_available) {\n+        excess_fragmented_available -= lost_available;\n+        lost_evacuation_capacity -= lost_available;\n+        lost_available  = 0;\n+      } else {\n+        lost_available -= excess_fragmented_available;\n+        lost_evacuation_capacity -= excess_fragmented_available;\n+        excess_fragmented_available = 0;\n+      }\n+    }\n+    size_t scaled_loss = (size_t) ((double) lost_available \/ ShenandoahOldEvacWaste);\n+    if ((lost_available > 0) && (fragmented_available > 0)) {\n+      if (scaled_loss + live_data_for_evacuation < fragmented_available) {\n+        fragmented_available -= scaled_loss;\n+        scaled_loss = 0;\n+      } else {\n+        \/\/ We will have to allocate this region's evacuation memory from unfragmented memory, so don't bother\n+        \/\/ to decrement scaled_loss\n+      }\n+    }\n+    if (scaled_loss > 0) {\n+      \/\/ We were not able to account for the lost free memory within fragmented memory, so we need to take this\n+      \/\/ allocation out of unfragmented memory.  Unfragmented memory does not need to account for loss of free.\n+      if (live_data_for_evacuation > unfragmented_available) {\n+        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        break;\n+      } else {\n+        unfragmented_available -= live_data_for_evacuation;\n+      }\n+    } else {\n+      \/\/ Since scaled_loss == 0, we have accounted for the loss of free memory, so we can allocate from either\n+      \/\/ fragmented or unfragmented available memory.  Use up the fragmented memory budget first.\n+      size_t evacuation_need = live_data_for_evacuation;\n+\n+      if (evacuation_need > fragmented_available) {\n+        evacuation_need -= fragmented_available;\n+        fragmented_available = 0;\n+      } else {\n+        fragmented_available -= evacuation_need;\n+        evacuation_need = 0;\n+      }\n+      if (evacuation_need > unfragmented_available) {\n+        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        break;\n+      } else {\n+        unfragmented_available -= evacuation_need;\n+        \/\/ dead code: evacuation_need == 0;\n+      }\n+    }\n+    collection_set->add_region(r);\n+    included_old_regions++;\n+    evacuated_old_bytes += live_data_for_evacuation;\n+    collected_old_bytes += r->garbage();\n+    consume_old_collection_candidate();\n+  }\n+\n+  if (_first_pinned_candidate != NOT_FOUND) {\n+    \/\/ Need to deal with pinned regions\n+    slide_pinned_regions_to_front();\n+  }\n+  decrease_unprocessed_old_collection_candidates_live_memory(evacuated_old_bytes);\n+  if (included_old_regions > 0) {\n+    log_info(gc, ergo)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, evacuating \" PROPERFMT \", reclaiming: \" PROPERFMT \")\",\n+                  included_old_regions, PROPERFMTARGS(evacuated_old_bytes), PROPERFMTARGS(collected_old_bytes));\n+  }\n+\n+  if (unprocessed_old_collection_candidates() == 0) {\n+    \/\/ We have added the last of our collection candidates to a mixed collection.\n+    \/\/ Any triggers that occurred during mixed evacuations may no longer be valid.  They can retrigger if appropriate.\n+    clear_triggers();\n+\n+    _old_generation->complete_mixed_evacuations();\n+  } else if (included_old_regions == 0) {\n+    \/\/ We have candidates, but none were included for evacuation - are they all pinned?\n+    \/\/ or did we just not have enough room for any of them in this collection set?\n+    \/\/ We don't want a region with a stuck pin to prevent subsequent old collections, so\n+    \/\/ if they are all pinned we transition to a state that will allow us to make these uncollected\n+    \/\/ (pinned) regions parsable.\n+    if (all_candidates_are_pinned()) {\n+      log_info(gc, ergo)(\"All candidate regions \" UINT32_FORMAT \" are pinned\", unprocessed_old_collection_candidates());\n+      _old_generation->abandon_mixed_evacuations();\n+    } else {\n+      log_info(gc, ergo)(\"No regions selected for mixed collection. \"\n+                         \"Old evacuation budget: \" PROPERFMT \", Remaining evacuation budget: \" PROPERFMT\n+                         \", Lost capacity: \" PROPERFMT\n+                         \", Next candidate: \" UINT32_FORMAT \", Last candidate: \" UINT32_FORMAT,\n+                         PROPERFMTARGS(old_evacuation_reserve),\n+                         PROPERFMTARGS(remaining_old_evacuation_budget),\n+                         PROPERFMTARGS(lost_evacuation_capacity),\n+                         _next_old_collection_candidate, _last_old_collection_candidate);\n+    }\n+  }\n+\n+  return (included_old_regions > 0);\n+}\n+\n+bool ShenandoahOldHeuristics::all_candidates_are_pinned() {\n+#ifdef ASSERT\n+  if (uint(os::random()) % 100 < ShenandoahCoalesceChance) {\n+    return true;\n+  }\n+#endif\n+\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; ++i) {\n+    ShenandoahHeapRegion* region = _region_data[i].get_region();\n+    if (!region->is_pinned()) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void ShenandoahOldHeuristics::slide_pinned_regions_to_front() {\n+  \/\/ Find the first unpinned region to the left of the next region that\n+  \/\/ will be added to the collection set. These regions will have been\n+  \/\/ added to the cset, so we can use them to hold pointers to regions\n+  \/\/ that were pinned when the cset was chosen.\n+  \/\/ [ r p r p p p r r ]\n+  \/\/     ^         ^ ^\n+  \/\/     |         | | pointer to next region to add to a mixed collection is here.\n+  \/\/     |         | first r to the left should be in the collection set now.\n+  \/\/     | first pinned region, we don't need to look past this\n+  uint write_index = NOT_FOUND;\n+  for (uint search = _next_old_collection_candidate - 1; search > _first_pinned_candidate; --search) {\n+    ShenandoahHeapRegion* region = _region_data[search].get_region();\n+    if (!region->is_pinned()) {\n+      write_index = search;\n+      assert(region->is_cset(), \"Expected unpinned region to be added to the collection set.\");\n+      break;\n+    }\n+  }\n+\n+  \/\/ If we could not find an unpinned region, it means there are no slots available\n+  \/\/ to move up the pinned regions. In this case, we just reset our next index in the\n+  \/\/ hopes that some of these regions will become unpinned before the next mixed\n+  \/\/ collection. We may want to bailout of here instead, as it should be quite\n+  \/\/ rare to have so many pinned regions and may indicate something is wrong.\n+  if (write_index == NOT_FOUND) {\n+    assert(_first_pinned_candidate != NOT_FOUND, \"Should only be here if there are pinned regions.\");\n+    _next_old_collection_candidate = _first_pinned_candidate;\n+    return;\n+  }\n+\n+  \/\/ Find pinned regions to the left and move their pointer into a slot\n+  \/\/ that was pointing at a region that has been added to the cset (or was pointing\n+  \/\/ to a pinned region that we've already moved up). We are done when the leftmost\n+  \/\/ pinned region has been slid up.\n+  \/\/ [ r p r x p p p r ]\n+  \/\/         ^       ^\n+  \/\/         |       | next region for mixed collections\n+  \/\/         | Write pointer is here. We know this region is already in the cset\n+  \/\/         | so we can clobber it with the next pinned region we find.\n+  for (int32_t search = (int32_t)write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n+    RegionData& skipped = _region_data[search];\n+    if (skipped.get_region()->is_pinned()) {\n+      RegionData& available_slot = _region_data[write_index];\n+      available_slot.set_region_and_livedata(skipped.get_region(), skipped.get_livedata());\n+      --write_index;\n+    }\n+  }\n+\n+  \/\/ Update to read from the leftmost pinned region. Plus one here because we decremented\n+  \/\/ the write index to hold the next found pinned region. We are just moving it back now\n+  \/\/ to point to the first pinned region.\n+  _next_old_collection_candidate = write_index + 1;\n+}\n+\n+void ShenandoahOldHeuristics::prepare_for_old_collections() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  const size_t num_regions = heap->num_regions();\n+  size_t cand_idx = 0;\n+  size_t immediate_garbage = 0;\n+  size_t immediate_regions = 0;\n+  size_t live_data = 0;\n+\n+  RegionData* candidates = _region_data;\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (!region->is_old()) {\n+      continue;\n+    }\n+\n+    size_t garbage = region->garbage();\n+    size_t live_bytes = region->get_live_data_bytes();\n+    live_data += live_bytes;\n+\n+    if (region->is_regular() || region->is_regular_pinned()) {\n+        \/\/ Only place regular or pinned regions with live data into the candidate set.\n+        \/\/ Pinned regions cannot be evacuated, but we are not actually choosing candidates\n+        \/\/ for the collection set here. That happens later during the next young GC cycle,\n+        \/\/ by which time, the pinned region may no longer be pinned.\n+      if (!region->has_live()) {\n+        assert(!region->is_pinned(), \"Pinned region should have live (pinned) objects.\");\n+        region->make_trash_immediate();\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n+      } else {\n+        region->begin_preemptible_coalesce_and_fill();\n+        candidates[cand_idx].set_region_and_livedata(region, live_bytes);\n+        cand_idx++;\n+      }\n+    } else if (region->is_humongous_start()) {\n+      \/\/ This will handle humongous start regions whether they are also pinned, or not.\n+      \/\/ If they are pinned, we expect them to hold live data, so they will not be\n+      \/\/ turned into immediate garbage.\n+      if (!region->has_live()) {\n+        assert(!region->is_pinned(), \"Pinned region should have live (pinned) objects.\");\n+        \/\/ The humongous object is dead, we can just return this region and the continuations\n+        \/\/ immediately to the freeset - no evacuations are necessary here. The continuations\n+        \/\/ will be made into trash by this method, so they'll be skipped by the 'is_regular'\n+        \/\/ check above, but we still need to count the start region.\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n+        size_t region_count = heap->trash_humongous_region_at(region);\n+        log_debug(gc)(\"Trashed \" SIZE_FORMAT \" regions for humongous object.\", region_count);\n+      }\n+    } else if (region->is_trash()) {\n+      \/\/ Count humongous objects made into trash here.\n+      immediate_regions++;\n+      immediate_garbage += garbage;\n+    }\n+  }\n+\n+  _old_generation->set_live_bytes_after_last_mark(live_data);\n+\n+  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first.  We sort by live-data.\n+  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n+  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n+  \/\/ in old-gen.\n+\n+  QuickSort::sort<RegionData>(candidates, cand_idx, compare_by_live);\n+\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  \/\/ The convention is to collect regions that have more than this amount of garbage.\n+  const size_t garbage_threshold = region_size_bytes * ShenandoahOldGarbageThreshold \/ 100;\n+\n+  \/\/ Enlightened interpretation: collect regions that have less than this amount of live.\n+  const size_t live_threshold = region_size_bytes - garbage_threshold;\n+\n+  _last_old_region = (uint)cand_idx;\n+  _last_old_collection_candidate = (uint)cand_idx;\n+  _next_old_collection_candidate = 0;\n+\n+  size_t unfragmented = 0;\n+  size_t candidates_garbage = 0;\n+\n+  for (size_t i = 0; i < cand_idx; i++) {\n+    size_t live = candidates[i].get_livedata();\n+    if (live > live_threshold) {\n+      \/\/ Candidates are sorted in increasing order of live data, so no regions after this will be below the threshold.\n+      _last_old_collection_candidate = (uint)i;\n+      break;\n+    }\n+    ShenandoahHeapRegion* r = candidates[i].get_region();\n+    size_t region_garbage = r->garbage();\n+    size_t region_free = r->free();\n+    candidates_garbage += region_garbage;\n+    unfragmented += region_free;\n+  }\n+\n+  \/\/ defrag_count represents regions that are placed into the old collection set in order to defragment the memory\n+  \/\/ that we try to \"reserve\" for humongous allocations.\n+  size_t defrag_count = 0;\n+  size_t total_uncollected_old_regions = _last_old_region - _last_old_collection_candidate;\n+\n+  if (cand_idx > _last_old_collection_candidate) {\n+    \/\/ Above, we have added into the set of mixed-evacuation candidates all old-gen regions for which the live memory\n+    \/\/ that they contain is below a particular old-garbage threshold.  Regions that were not selected for the collection\n+    \/\/ set hold enough live memory that it is not considered efficient (by \"garbage-first standards\") to compact these\n+    \/\/ at the current time.\n+    \/\/\n+    \/\/ However, if any of these regions that were rejected from the collection set reside within areas of memory that\n+    \/\/ might interfere with future humongous allocation requests, we will prioritize them for evacuation at this time.\n+    \/\/ Humongous allocations target the bottom of the heap.  We want old-gen regions to congregate at the top of the\n+    \/\/ heap.\n+    \/\/\n+    \/\/ Sort the regions that were initially rejected from the collection set in order of index.  This allows us to\n+    \/\/ focus our attention on the regions that have low index value (i.e. the old-gen regions at the bottom of the heap).\n+    QuickSort::sort<RegionData>(candidates + _last_old_collection_candidate, cand_idx - _last_old_collection_candidate,\n+                                compare_by_index);\n+\n+    const size_t first_unselected_old_region = candidates[_last_old_collection_candidate].get_region()->index();\n+    const size_t last_unselected_old_region = candidates[cand_idx - 1].get_region()->index();\n+    size_t span_of_uncollected_regions = 1 + last_unselected_old_region - first_unselected_old_region;\n+\n+    \/\/ Add no more than 1\/8 of the existing old-gen regions to the set of mixed evacuation candidates.\n+    const int MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS = 8;\n+    const size_t bound_on_additional_regions = cand_idx \/ MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS;\n+\n+    \/\/ The heuristic old_is_fragmented trigger may be seeking to achieve up to 75% density.  Allow ourselves to overshoot\n+    \/\/ that target (at 7\/8) so we will not have to do another defragmenting old collection right away.\n+    while ((defrag_count < bound_on_additional_regions) &&\n+           (total_uncollected_old_regions < 7 * span_of_uncollected_regions \/ 8)) {\n+      ShenandoahHeapRegion* r = candidates[_last_old_collection_candidate].get_region();\n+      assert(r->is_regular() || r->is_regular_pinned(), \"Region \" SIZE_FORMAT \" has wrong state for collection: %s\",\n+             r->index(), ShenandoahHeapRegion::region_state_to_string(r->state()));\n+      const size_t region_garbage = r->garbage();\n+      const size_t region_free = r->free();\n+      candidates_garbage += region_garbage;\n+      unfragmented += region_free;\n+      defrag_count++;\n+      _last_old_collection_candidate++;\n+\n+      \/\/ We now have one fewer uncollected regions, and our uncollected span shrinks because we have removed its first region.\n+      total_uncollected_old_regions--;\n+      span_of_uncollected_regions =\n+        1 + last_unselected_old_region - candidates[_last_old_collection_candidate].get_region()->index();\n+    }\n+  }\n+\n+  \/\/ Note that we do not coalesce and fill occupied humongous regions\n+  \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+  const size_t collectable_garbage = immediate_garbage + candidates_garbage;\n+  const size_t old_candidates = _last_old_collection_candidate;\n+  const size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n+  set_unprocessed_old_collection_candidates_live_memory(mixed_evac_live);\n+\n+  log_info(gc, ergo)(\"Old-Gen Collectable Garbage: \" PROPERFMT \" consolidated with free: \" PROPERFMT \", over \" SIZE_FORMAT \" regions\",\n+                     PROPERFMTARGS(collectable_garbage), PROPERFMTARGS(unfragmented), old_candidates);\n+  log_info(gc, ergo)(\"Old-Gen Immediate Garbage: \" PROPERFMT \" over \" SIZE_FORMAT \" regions\",\n+                     PROPERFMTARGS(immediate_garbage), immediate_regions);\n+  log_info(gc, ergo)(\"Old regions selected for defragmentation: \" SIZE_FORMAT, defrag_count);\n+  log_info(gc, ergo)(\"Old regions not selected: \" SIZE_FORMAT, total_uncollected_old_regions);\n+\n+  if (unprocessed_old_collection_candidates() > 0) {\n+    _old_generation->transition_to(ShenandoahOldGeneration::EVACUATING);\n+  } else if (has_coalesce_and_fill_candidates()) {\n+    _old_generation->transition_to(ShenandoahOldGeneration::FILLING);\n+  } else {\n+    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+  }\n+}\n+\n+size_t ShenandoahOldHeuristics::unprocessed_old_collection_candidates_live_memory() const {\n+  return _live_bytes_in_unprocessed_candidates;\n+}\n+\n+void ShenandoahOldHeuristics::set_unprocessed_old_collection_candidates_live_memory(size_t initial_live) {\n+  _live_bytes_in_unprocessed_candidates = initial_live;\n+}\n+\n+void ShenandoahOldHeuristics::decrease_unprocessed_old_collection_candidates_live_memory(size_t evacuated_live) {\n+  assert(evacuated_live <= _live_bytes_in_unprocessed_candidates, \"Cannot evacuate more than was present\");\n+  _live_bytes_in_unprocessed_candidates -= evacuated_live;\n+}\n+\n+\/\/ Used by unit test: test_shenandoahOldHeuristic.cpp\n+uint ShenandoahOldHeuristics::last_old_collection_candidate_index() const {\n+  return _last_old_collection_candidate;\n+}\n+\n+uint ShenandoahOldHeuristics::unprocessed_old_collection_candidates() const {\n+  return _last_old_collection_candidate - _next_old_collection_candidate;\n+}\n+\n+ShenandoahHeapRegion* ShenandoahOldHeuristics::next_old_collection_candidate() {\n+  while (_next_old_collection_candidate < _last_old_collection_candidate) {\n+    ShenandoahHeapRegion* next = _region_data[_next_old_collection_candidate].get_region();\n+    if (!next->is_pinned()) {\n+      return next;\n+    } else {\n+      assert(next->is_pinned(), \"sanity\");\n+      if (_first_pinned_candidate == NOT_FOUND) {\n+        _first_pinned_candidate = _next_old_collection_candidate;\n+      }\n+    }\n+\n+    _next_old_collection_candidate++;\n+  }\n+  return nullptr;\n+}\n+\n+void ShenandoahOldHeuristics::consume_old_collection_candidate() {\n+  _next_old_collection_candidate++;\n+}\n+\n+unsigned int ShenandoahOldHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n+  uint end = _last_old_region;\n+  uint index = _next_old_collection_candidate;\n+  while (index < end) {\n+    *buffer++ = _region_data[index++].get_region();\n+  }\n+  return (_last_old_region - _next_old_collection_candidate);\n+}\n+\n+void ShenandoahOldHeuristics::abandon_collection_candidates() {\n+  _last_old_collection_candidate = 0;\n+  _next_old_collection_candidate = 0;\n+  _last_old_region = 0;\n+}\n+\n+void ShenandoahOldHeuristics::record_cycle_end() {\n+  this->ShenandoahHeuristics::record_cycle_end();\n+  clear_triggers();\n+}\n+\n+void ShenandoahOldHeuristics::clear_triggers() {\n+  \/\/ Clear any triggers that were set during mixed evacuations.  Conditions may be different now that this phase has finished.\n+  _cannot_expand_trigger = false;\n+  _fragmentation_trigger = false;\n+  _growth_trigger = false;\n+}\n+\n+\/\/ This triggers old-gen collection if the number of regions \"dedicated\" to old generation is much larger than\n+\/\/ is required to represent the memory currently used within the old generation.  This trigger looks specifically\n+\/\/ at density of the old-gen spanned region.  A different mechanism triggers old-gen GC if the total number of\n+\/\/ old-gen regions (regardless of how close the regions are to one another) grows beyond an anticipated growth target.\n+void ShenandoahOldHeuristics::set_trigger_if_old_is_fragmented(size_t first_old_region, size_t last_old_region,\n+                                                               size_t old_region_count, size_t num_regions) {\n+  if (ShenandoahGenerationalHumongousReserve > 0) {\n+    \/\/ Our intent is to pack old-gen memory into the highest-numbered regions of the heap.  Count all memory\n+    \/\/ above first_old_region as the \"span\" of old generation.\n+    size_t old_region_span = (first_old_region <= last_old_region)? (num_regions - first_old_region): 0;\n+    \/\/ Given that memory at the bottom of the heap is reserved to represent humongous objects, the number of\n+    \/\/ regions that old_gen is \"allowed\" to consume is less than the total heap size.  The restriction on allowed\n+    \/\/ span is not strictly enforced.  This is a heuristic designed to reduce the likelihood that a humongous\n+    \/\/ allocation request will require a STW full GC.\n+    size_t allowed_old_gen_span = num_regions - (ShenandoahGenerationalHumongousReserve * num_regions) \/ 100;\n+\n+    size_t old_available = _old_gen->available() \/ HeapWordSize;\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t old_unaffiliated_available = _old_gen->free_unaffiliated_regions() * region_size_words;\n+    assert(old_available >= old_unaffiliated_available, \"sanity\");\n+    size_t old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_words_consumed = old_region_count * region_size_words - old_fragmented_available;\n+    size_t old_words_spanned = old_region_span * region_size_words;\n+    double old_density = ((double) old_words_consumed) \/ old_words_spanned;\n+\n+    double old_span_percent = ((double) old_region_span) \/ allowed_old_gen_span;\n+    if (old_span_percent > 0.50) {\n+      \/\/ Squaring old_span_percent in the denominator below allows more aggressive triggering when we are\n+      \/\/ above desired maximum span and less aggressive triggering when we are far below the desired maximum span.\n+      double old_span_percent_squared = old_span_percent * old_span_percent;\n+      if (old_density \/ old_span_percent_squared < 0.75) {\n+        \/\/ We trigger old defragmentation, for example, if:\n+        \/\/  old_span_percent is 110% and old_density is below 90.8%, or\n+        \/\/  old_span_percent is 100% and old_density is below 75.0%, or\n+        \/\/  old_span_percent is  90% and old_density is below 60.8%, or\n+        \/\/  old_span_percent is  80% and old_density is below 48.0%, or\n+        \/\/  old_span_percent is  70% and old_density is below 36.8%, or\n+        \/\/  old_span_percent is  60% and old_density is below 27.0%, or\n+        \/\/  old_span_percent is  50% and old_density is below 18.8%.\n+\n+        \/\/ Set the fragmentation trigger and related attributes\n+        _fragmentation_trigger = true;\n+        _fragmentation_density = old_density;\n+        _fragmentation_first_old_region = first_old_region;\n+        _fragmentation_last_old_region = last_old_region;\n+      }\n+    }\n+  }\n+}\n+\n+void ShenandoahOldHeuristics::set_trigger_if_old_is_overgrown() {\n+  size_t old_used = _old_gen->used() + _old_gen->get_humongous_waste();\n+  size_t trigger_threshold = _old_gen->usage_trigger_threshold();\n+  \/\/ Detects unsigned arithmetic underflow\n+  assert(old_used <= _heap->capacity(),\n+         \"Old used (\" SIZE_FORMAT \", \" SIZE_FORMAT\") must not be more than heap capacity (\" SIZE_FORMAT \")\",\n+         _old_gen->used(), _old_gen->get_humongous_waste(), _heap->capacity());\n+  if (old_used > trigger_threshold) {\n+    _growth_trigger = true;\n+  }\n+}\n+\n+void ShenandoahOldHeuristics::evaluate_triggers(size_t first_old_region, size_t last_old_region,\n+                                                size_t old_region_count, size_t num_regions) {\n+  set_trigger_if_old_is_fragmented(first_old_region, last_old_region, old_region_count, num_regions);\n+  set_trigger_if_old_is_overgrown();\n+}\n+\n+bool ShenandoahOldHeuristics::should_start_gc() {\n+  \/\/ Cannot start a new old-gen GC until previous one has finished.\n+  \/\/\n+  \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n+  \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations.\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (!_old_generation->can_start_gc() || heap->collection_set()->has_old_regions()) {\n+    return false;\n+  }\n+\n+  if (_cannot_expand_trigger) {\n+    const size_t old_gen_capacity = _old_generation->max_capacity();\n+    const size_t heap_capacity = heap->capacity();\n+    const double percent = percent_of(old_gen_capacity, heap_capacity);\n+    log_trigger(\"Expansion failure, current size: \" SIZE_FORMAT \"%s which is %.1f%% of total heap size\",\n+                 byte_size_in_proper_unit(old_gen_capacity), proper_unit_for_byte_size(old_gen_capacity), percent);\n+    return true;\n+  }\n+\n+  if (_fragmentation_trigger) {\n+    const size_t used = _old_generation->used();\n+    const size_t used_regions_size = _old_generation->used_regions_size();\n+\n+    \/\/ used_regions includes humongous regions\n+    const size_t used_regions = _old_generation->used_regions();\n+    assert(used_regions_size > used_regions, \"Cannot have more used than used regions\");\n+\n+    size_t first_old_region, last_old_region;\n+    double density;\n+    get_fragmentation_trigger_reason_for_log_message(density, first_old_region, last_old_region);\n+    const size_t span_of_old_regions = (last_old_region >= first_old_region)? last_old_region + 1 - first_old_region: 0;\n+    const size_t fragmented_free = used_regions_size - used;\n+\n+    log_trigger(\"Old has become fragmented: \"\n+                SIZE_FORMAT \"%s available bytes spread between range spanned from \"\n+                SIZE_FORMAT \" to \" SIZE_FORMAT \" (\" SIZE_FORMAT \"), density: %.1f%%\",\n+                byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free),\n+                first_old_region, last_old_region, span_of_old_regions, density * 100);\n+    return true;\n+  }\n+\n+  if (_growth_trigger) {\n+    \/\/ Growth may be falsely triggered during mixed evacuations, before the mixed-evacuation candidates have been\n+    \/\/ evacuated.  Before acting on a false trigger, we check to confirm the trigger condition is still satisfied.\n+    const size_t current_usage = _old_generation->used() + _old_generation->get_humongous_waste();\n+    const size_t trigger_threshold = _old_generation->usage_trigger_threshold();\n+    const size_t heap_size = heap->capacity();\n+    const size_t ignore_threshold = (ShenandoahIgnoreOldGrowthBelowPercentage * heap_size) \/ 100;\n+    size_t consecutive_young_cycles;\n+    if ((current_usage < ignore_threshold) &&\n+        ((consecutive_young_cycles = heap->shenandoah_policy()->consecutive_young_gc_count())\n+         < ShenandoahDoNotIgnoreGrowthAfterYoungCycles)) {\n+      log_debug(gc)(\"Ignoring Trigger: Old has overgrown: usage (\" SIZE_FORMAT \"%s) is below threshold (\"\n+                    SIZE_FORMAT \"%s) after \" SIZE_FORMAT \" consecutive completed young GCs\",\n+                    byte_size_in_proper_unit(current_usage), proper_unit_for_byte_size(current_usage),\n+                    byte_size_in_proper_unit(ignore_threshold), proper_unit_for_byte_size(ignore_threshold),\n+                    consecutive_young_cycles);\n+      _growth_trigger = false;\n+    } else if (current_usage > trigger_threshold) {\n+      const size_t live_at_previous_old = _old_generation->get_live_bytes_after_last_mark();\n+      const double percent_growth = percent_of(current_usage - live_at_previous_old, live_at_previous_old);\n+      log_trigger(\"Old has overgrown, live at end of previous OLD marking: \"\n+                  SIZE_FORMAT \"%s, current usage: \" SIZE_FORMAT \"%s, percent growth: %.1f%%\",\n+                  byte_size_in_proper_unit(live_at_previous_old), proper_unit_for_byte_size(live_at_previous_old),\n+                  byte_size_in_proper_unit(current_usage), proper_unit_for_byte_size(current_usage), percent_growth);\n+      return true;\n+    } else {\n+      \/\/ Mixed evacuations have decreased current_usage such that old-growth trigger is no longer relevant.\n+      _growth_trigger = false;\n+    }\n+  }\n+\n+  \/\/ Otherwise, defer to inherited heuristic for gc trigger.\n+  return this->ShenandoahHeuristics::should_start_gc();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_concurrent() {\n+  \/\/ Forget any triggers that occurred while OLD GC was ongoing.  If we really need to start another, it will retrigger.\n+  clear_triggers();\n+  this->ShenandoahHeuristics::record_success_concurrent();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_degenerated() {\n+  \/\/ Forget any triggers that occurred while OLD GC was ongoing.  If we really need to start another, it will retrigger.\n+  clear_triggers();\n+  this->ShenandoahHeuristics::record_success_degenerated();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_full() {\n+  \/\/ Forget any triggers that occurred while OLD GC was ongoing.  If we really need to start another, it will retrigger.\n+  clear_triggers();\n+  this->ShenandoahHeuristics::record_success_full();\n+}\n+\n+const char* ShenandoahOldHeuristics::name() {\n+  return \"Old\";\n+}\n+\n+bool ShenandoahOldHeuristics::is_diagnostic() {\n+  return false;\n+}\n+\n+bool ShenandoahOldHeuristics::is_experimental() {\n+  return true;\n+}\n+\n+void ShenandoahOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* set,\n+                                                                    ShenandoahHeuristics::RegionData* data,\n+                                                                    size_t data_size, size_t free) {\n+  ShouldNotReachHere();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":734,"deletions":0,"binary":false,"changes":734,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+\n+class ShenandoahCollectionSet;\n+class ShenandoahHeapRegion;\n+class ShenandoahOldGeneration;\n+\n+\/*\n+ * This heuristic is responsible for choosing a set of candidates for inclusion\n+ * in mixed collections. These candidates are chosen when marking of the old\n+ * generation is complete. Note that this list of candidates may live through\n+ * several mixed collections.\n+ *\n+ * This heuristic is also responsible for triggering old collections. It has its\n+ * own collection of triggers to decide whether to start an old collection. It does\n+ * _not_ use any of the functionality from the adaptive heuristics for triggers.\n+ * It also does not use any of the functionality from the heuristics base classes\n+ * to choose the collection set. For these reasons, it does not extend from\n+ * ShenandoahGenerationalHeuristics.\n+ *\/\n+class ShenandoahOldHeuristics : public ShenandoahHeuristics {\n+\n+private:\n+\n+  static uint NOT_FOUND;\n+\n+  ShenandoahGenerationalHeap* _heap;\n+  ShenandoahOldGeneration* _old_gen;\n+\n+  \/\/ After final marking of the old generation, this heuristic will select\n+  \/\/ a set of candidate regions to be included in subsequent mixed collections.\n+  \/\/ The regions are sorted into a `_region_data` array (declared in base\n+  \/\/ class) in decreasing order of garbage. The heuristic will give priority\n+  \/\/ to regions containing more garbage.\n+\n+  \/\/ The following members are used to keep track of which candidate regions\n+  \/\/ have yet to be added to a mixed collection. There is also some special\n+  \/\/ handling for pinned regions, described further below.\n+\n+  \/\/ Pinned regions may not be included in the collection set. Any old regions\n+  \/\/ which were pinned at the time when old regions were added to the mixed\n+  \/\/ collection will have been skipped. These regions are still contain garbage,\n+  \/\/ so we want to include them at the start of the list of candidates for the\n+  \/\/ _next_ mixed collection cycle. This variable is the index of the _first_\n+  \/\/ old region which is pinned when the mixed collection set is formed.\n+  uint _first_pinned_candidate;\n+\n+  \/\/ This is the index of the last region which is above the garbage threshold.\n+  \/\/ No regions after this will be considered for inclusion in a mixed collection\n+  \/\/ set.\n+  uint _last_old_collection_candidate;\n+\n+  \/\/ This index points to the first candidate in line to be added to the mixed\n+  \/\/ collection set. It is updated as regions are added to the collection set.\n+  uint _next_old_collection_candidate;\n+\n+  \/\/ This is the last index in the array of old regions which were active at\n+  \/\/ the end of old final mark.\n+  uint _last_old_region;\n+\n+  \/\/ How much live data must be evacuated from within the unprocessed mixed evacuation candidates?\n+  size_t _live_bytes_in_unprocessed_candidates;\n+\n+  \/\/ Keep a pointer to our generation that we can use without down casting a protected member from the base class.\n+  ShenandoahOldGeneration* _old_generation;\n+\n+  \/\/ Flags are set when promotion failure is detected (by gc thread), and cleared when\n+  \/\/ old generation collection begins (by control thread).  Flags are set and cleared at safepoints.\n+  bool _cannot_expand_trigger;\n+  bool _fragmentation_trigger;\n+  bool _growth_trigger;\n+\n+  \/\/ Motivation for a fragmentation_trigger\n+  double _fragmentation_density;\n+  size_t _fragmentation_first_old_region;\n+  size_t _fragmentation_last_old_region;\n+\n+  \/\/ Compare by live is used to prioritize compaction of old-gen regions.  With old-gen compaction, the goal is\n+  \/\/ to tightly pack long-lived objects into available regions.  In most cases, there has not been an accumulation\n+  \/\/ of garbage within old-gen regions.  The more likely opportunity will be to combine multiple sparsely populated\n+  \/\/ old-gen regions which may have been promoted in place into a smaller number of densely packed old-gen regions.\n+  \/\/ This improves subsequent allocation efficiency and reduces the likelihood of allocation failure (including\n+  \/\/ humongous allocation failure) due to fragmentation of the available old-gen allocation pool\n+  static int compare_by_live(RegionData a, RegionData b);\n+\n+  static int compare_by_index(RegionData a, RegionData b);\n+\n+  \/\/ Set the fragmentation trigger if old-gen memory has become fragmented.\n+  void set_trigger_if_old_is_fragmented(size_t first_old_region, size_t last_old_region,\n+                                        size_t old_region_count, size_t num_regions);\n+\n+  \/\/ Set the overgrowth trigger if old-gen memory has grown beyond a particular threshold.\n+  void set_trigger_if_old_is_overgrown();\n+\n+ protected:\n+  void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set, RegionData* data, size_t data_size, size_t free) override;\n+\n+public:\n+  explicit ShenandoahOldHeuristics(ShenandoahOldGeneration* generation, ShenandoahGenerationalHeap* gen_heap);\n+\n+  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n+  void prepare_for_old_collections();\n+\n+  \/\/ Return true iff the collection set is primed with at least one old-gen region.\n+  bool prime_collection_set(ShenandoahCollectionSet* set);\n+\n+  \/\/ How many old-collection candidates have not yet been processed?\n+  uint unprocessed_old_collection_candidates() const;\n+\n+  \/\/ How much live memory must be evacuated from within old-collection candidates that have not yet been processed?\n+  size_t unprocessed_old_collection_candidates_live_memory() const;\n+\n+  void set_unprocessed_old_collection_candidates_live_memory(size_t initial_live);\n+\n+  void decrease_unprocessed_old_collection_candidates_live_memory(size_t evacuated_live);\n+\n+  \/\/ How many old or hidden collection candidates have not yet been processed?\n+  uint last_old_collection_candidate_index() const;\n+\n+  \/\/ Return the next old-collection candidate in order of decreasing amounts of garbage.  (We process most-garbage regions\n+  \/\/ first.)  This does not consume the candidate.  If the candidate is selected for inclusion in a collection set, then\n+  \/\/ the candidate is consumed by invoking consume_old_collection_candidate().\n+  ShenandoahHeapRegion* next_old_collection_candidate();\n+\n+  \/\/ Adjust internal state to reflect that one fewer old-collection candidate remains to be processed.\n+  void consume_old_collection_candidate();\n+\n+  \/\/ Fill in buffer with all the old-collection regions that were identified at the end of the most recent old-gen\n+  \/\/ mark to require their unmarked objects to be coalesced and filled.  The buffer array must have at least\n+  \/\/ last_old_region_index() entries, or memory may be corrupted when this function overwrites the\n+  \/\/ end of the array.\n+  unsigned int get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n+\n+  \/\/ True if there are old regions that need to be filled.\n+  bool has_coalesce_and_fill_candidates() const { return coalesce_and_fill_candidates_count() > 0; }\n+\n+  \/\/ Return the number of old regions that need to be filled.\n+  size_t coalesce_and_fill_candidates_count() const { return _last_old_region - _next_old_collection_candidate; }\n+\n+  \/\/ If a GLOBAL gc occurs, it will collect the entire heap which invalidates any collection candidates being\n+  \/\/ held by this heuristic for supplying mixed collections.\n+  void abandon_collection_candidates();\n+\n+  void trigger_cannot_expand() { _cannot_expand_trigger = true; };\n+\n+  inline void get_fragmentation_trigger_reason_for_log_message(double &density, size_t &first_index, size_t &last_index) {\n+    density = _fragmentation_density;\n+    first_index = _fragmentation_first_old_region;\n+    last_index = _fragmentation_last_old_region;\n+  }\n+\n+  void clear_triggers();\n+\n+  \/\/ Check whether conditions merit the start of old GC.  Set appropriate trigger if so.\n+  void evaluate_triggers(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n+\n+  void record_cycle_end() override;\n+\n+  bool should_start_gc() override;\n+\n+  void record_success_concurrent() override;\n+\n+  void record_success_degenerated() override;\n+\n+  void record_success_full() override;\n+\n+  const char* name() override;\n+\n+  bool is_diagnostic() override;\n+\n+  bool is_experimental() override;\n+\n+private:\n+  void slide_pinned_regions_to_front();\n+  bool all_candidates_are_pinned();\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -71,1 +71,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  virtual const char* name() const = 0;\n@@ -41,0 +42,1 @@\n+  virtual size_t soft_available() const = 0;\n@@ -42,0 +44,1 @@\n+  virtual size_t used() const = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+    log_trigger(\"Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n@@ -69,1 +69,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+\n+#include \"utilities\/quickSort.hpp\"\n+\n+ShenandoahYoungHeuristics::ShenandoahYoungHeuristics(ShenandoahYoungGeneration* generation)\n+        : ShenandoahGenerationalHeuristics(generation) {\n+}\n+\n+\n+void ShenandoahYoungHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                                                      RegionData* data, size_t size,\n+                                                                      size_t actual_free) {\n+  \/\/ See comments in ShenandoahAdaptiveHeuristics::choose_collection_set_from_regiondata():\n+  \/\/ we do the same here, but with the following adjustments for generational mode:\n+  \/\/\n+  \/\/ In generational mode, the sort order within the data array is not strictly descending amounts\n+  \/\/ of garbage. In particular, regions that have reached tenure age will be sorted into this\n+  \/\/ array before younger regions that typically contain more garbage. This is one reason why,\n+  \/\/ for example, we continue examining regions even after rejecting a region that has\n+  \/\/ more live data than we can evacuate.\n+\n+  \/\/ Better select garbage-first regions\n+  QuickSort::sort<RegionData>(data, (int) size, compare_by_garbage);\n+\n+  size_t cur_young_garbage = add_preselected_regions_to_collection_set(cset, data, size);\n+\n+  choose_young_collection_set(cset, data, size, actual_free, cur_young_garbage);\n+\n+  log_cset_composition(cset);\n+}\n+\n+void ShenandoahYoungHeuristics::choose_young_collection_set(ShenandoahCollectionSet* cset,\n+                                                            const RegionData* data,\n+                                                            size_t size, size_t actual_free,\n+                                                            size_t cur_young_garbage) const {\n+\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+\n+  size_t capacity = heap->young_generation()->max_capacity();\n+  size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+  size_t ignore_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahIgnoreGarbageThreshold \/ 100;\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+\n+  \/\/ This is young-gen collection or a mixed evacuation.\n+  \/\/ If this is mixed evacuation, the old-gen candidate regions have already been added.\n+  size_t max_cset = (size_t) (heap->young_generation()->get_evacuation_reserve() \/ ShenandoahEvacWaste);\n+  size_t cur_cset = 0;\n+  size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+  size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+\n+  log_info(gc, ergo)(\n+          \"Adaptive CSet Selection for YOUNG. Max Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+          byte_size_in_proper_unit(max_cset), proper_unit_for_byte_size(max_cset),\n+          byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+  for (size_t idx = 0; idx < size; idx++) {\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n+    if (cset->is_preselected(r->index())) {\n+      continue;\n+    }\n+    if (r->age() < tenuring_threshold) {\n+      size_t new_cset = cur_cset + r->get_live_data_bytes();\n+      size_t region_garbage = r->garbage();\n+      size_t new_garbage = cur_young_garbage + region_garbage;\n+      bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+      assert(r->is_young(), \"Only young candidates expected in the data array\");\n+      if ((new_cset <= max_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+        cur_cset = new_cset;\n+        cur_young_garbage = new_garbage;\n+        cset->add_region(r);\n+      }\n+    }\n+    \/\/ Note that we do not add aged regions if they were not pre-selected.  The reason they were not preselected\n+    \/\/ is because there is not sufficient room in old-gen to hold their to-be-promoted live objects or because\n+    \/\/ they are to be promoted in place.\n+  }\n+}\n+\n+\n+bool ShenandoahYoungHeuristics::should_start_gc() {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahOldHeuristics* old_heuristics = old_generation->heuristics();\n+\n+  \/\/ Checks that an old cycle has run for at least ShenandoahMinimumOldTimeMs before allowing a young cycle.\n+  if (ShenandoahMinimumOldTimeMs > 0) {\n+    if (old_generation->is_preparing_for_mark() || old_generation->is_concurrent_mark_in_progress()) {\n+      size_t old_time_elapsed = size_t(old_heuristics->elapsed_cycle_time() * 1000);\n+      if (old_time_elapsed < ShenandoahMinimumOldTimeMs) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  \/\/ inherited triggers have already decided to start a cycle, so no further evaluation is required\n+  if (ShenandoahAdaptiveHeuristics::should_start_gc()) {\n+    return true;\n+  }\n+\n+  \/\/ Get through promotions and mixed evacuations as quickly as possible.  These cycles sometimes require significantly\n+  \/\/ more time than traditional young-generation cycles so start them up as soon as possible.  This is a \"mitigation\"\n+  \/\/ for the reality that old-gen and young-gen activities are not truly \"concurrent\".  If there is old-gen work to\n+  \/\/ be done, we start up the young-gen GC threads so they can do some of this old-gen work.  As implemented, promotion\n+  \/\/ gets priority over old-gen marking.\n+  size_t promo_expedite_threshold = percent_of(heap->young_generation()->max_capacity(), ShenandoahExpeditePromotionsThreshold);\n+  size_t promo_potential = old_generation->get_promotion_potential();\n+  if (promo_potential > promo_expedite_threshold) {\n+    \/\/ Detect unsigned arithmetic underflow\n+    assert(promo_potential < heap->capacity(), \"Sanity\");\n+    log_trigger(\"Expedite promotion of \" PROPERFMT, PROPERFMTARGS(promo_potential));\n+    return true;\n+  }\n+\n+  size_t mixed_candidates = old_heuristics->unprocessed_old_collection_candidates();\n+  if (mixed_candidates > ShenandoahExpediteMixedThreshold && !heap->is_concurrent_weak_root_in_progress()) {\n+    \/\/ We need to run young GC in order to open up some free heap regions so we can finish mixed evacuations.\n+    \/\/ If concurrent weak root processing is in progress, it means the old cycle has chosen mixed collection\n+    \/\/ candidates, but has not completed. There is no point in trying to start the young cycle before the old\n+    \/\/ cycle completes.\n+    log_trigger(\"Expedite mixed evacuation of \" SIZE_FORMAT \" regions\", mixed_candidates);\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ Return a conservative estimate of how much memory can be allocated before we need to start GC. The estimate is based\n+\/\/ on memory that is currently available within young generation plus all of the memory that will be added to the young\n+\/\/ generation at the end of the current cycle (as represented by young_regions_to_be_reclaimed) and on the anticipated\n+\/\/ amount of time required to perform a GC.\n+size_t ShenandoahYoungHeuristics::bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_reclaimed) {\n+  size_t capacity = _space_info->max_capacity();\n+  size_t usage = _space_info->used();\n+  size_t available = (capacity > usage)? capacity - usage: 0;\n+  size_t allocated = _space_info->bytes_allocated_since_gc_start();\n+\n+  size_t available_young_collected = ShenandoahHeap::heap()->collection_set()->get_young_available_bytes_collected();\n+  size_t anticipated_available =\n+          available + young_regions_to_be_reclaimed * ShenandoahHeapRegion::region_size_bytes() - available_young_collected;\n+  size_t spike_headroom = capacity * ShenandoahAllocSpikeFactor \/ 100;\n+  size_t penalties      = capacity * _gc_time_penalties \/ 100;\n+\n+  double rate = _allocation_rate.sample(allocated);\n+\n+  \/\/ At what value of available, would avg and spike triggers occur?\n+  \/\/  if allocation_headroom < avg_cycle_time * avg_alloc_rate, then we experience avg trigger\n+  \/\/  if allocation_headroom < avg_cycle_time * rate, then we experience spike trigger if is_spiking\n+  \/\/\n+  \/\/ allocation_headroom =\n+  \/\/     0, if penalties > available or if penalties + spike_headroom > available\n+  \/\/     available - penalties - spike_headroom, otherwise\n+  \/\/\n+  \/\/ so we trigger if available - penalties - spike_headroom < avg_cycle_time * avg_alloc_rate, which is to say\n+  \/\/                  available < avg_cycle_time * avg_alloc_rate + penalties + spike_headroom\n+  \/\/            or if available < penalties + spike_headroom\n+  \/\/\n+  \/\/ since avg_cycle_time * avg_alloc_rate > 0, the first test is sufficient to test both conditions\n+  \/\/\n+  \/\/ thus, evac_slack_avg is MIN2(0,  available - avg_cycle_time * avg_alloc_rate + penalties + spike_headroom)\n+  \/\/\n+  \/\/ similarly, evac_slack_spiking is MIN2(0, available - avg_cycle_time * rate + penalties + spike_headroom)\n+  \/\/ but evac_slack_spiking is only relevant if is_spiking, as defined below.\n+\n+  double avg_cycle_time = _gc_cycle_time_history->davg() + (_margin_of_error_sd * _gc_cycle_time_history->dsd());\n+  double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n+  size_t evac_slack_avg;\n+  if (anticipated_available > avg_cycle_time * avg_alloc_rate + penalties + spike_headroom) {\n+    evac_slack_avg = anticipated_available - (avg_cycle_time * avg_alloc_rate + penalties + spike_headroom);\n+  } else {\n+    \/\/ we have no slack because it's already time to trigger\n+    evac_slack_avg = 0;\n+  }\n+\n+  bool is_spiking = _allocation_rate.is_spiking(rate, _spike_threshold_sd);\n+  size_t evac_slack_spiking;\n+  if (is_spiking) {\n+    if (anticipated_available > avg_cycle_time * rate + penalties + spike_headroom) {\n+      evac_slack_spiking = anticipated_available - (avg_cycle_time * rate + penalties + spike_headroom);\n+    } else {\n+      \/\/ we have no slack because it's already time to trigger\n+      evac_slack_spiking = 0;\n+    }\n+  } else {\n+    evac_slack_spiking = evac_slack_avg;\n+  }\n+\n+  size_t threshold = min_free_threshold();\n+  size_t evac_min_threshold = (anticipated_available > threshold)? anticipated_available - threshold: 0;\n+  return MIN3(evac_slack_spiking, evac_slack_avg, evac_min_threshold);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHYOUNGHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHYOUNGHEURISTICS_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.hpp\"\n+\n+class ShenandoahYoungGeneration;\n+\n+\/*\n+ * This is a specialization of the generational heuristic which chooses\n+ * young regions for evacuation. This heuristic also has additional triggers\n+ * designed to expedite mixed collections and promotions.\n+ *\/\n+class ShenandoahYoungHeuristics : public ShenandoahGenerationalHeuristics {\n+public:\n+  explicit ShenandoahYoungHeuristics(ShenandoahYoungGeneration* generation);\n+\n+\n+  void choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,\n+                                             RegionData* data, size_t size,\n+                                             size_t actual_free) override;\n+\n+  bool should_start_gc() override;\n+\n+  size_t bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_reclaimed);\n+\n+private:\n+  void choose_young_collection_set(ShenandoahCollectionSet* cset,\n+                                   const RegionData* data,\n+                                   size_t size, size_t actual_free,\n+                                   size_t cur_young_garbage) const;\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHYOUNGHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+\n+void ShenandoahGenerationalMode::initialize_flags() const {\n+\n+#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64 || defined RISCV64)\n+  vm_exit_during_initialization(\"Shenandoah Generational GC is not supported on this platform.\");\n+#endif\n+\n+  \/\/ Exit if the user has asked ShenandoahCardBarrier to be disabled\n+  if (!FLAG_IS_DEFAULT(ShenandoahCardBarrier)) {\n+    SHENANDOAH_CHECK_FLAG_SET(ShenandoahCardBarrier);\n+  }\n+\n+  \/\/ Enable card-marking post-write barrier for tracking old to young pointers\n+  FLAG_SET_DEFAULT(ShenandoahCardBarrier, true);\n+\n+  if (ClassUnloading) {\n+    FLAG_SET_DEFAULT(VerifyBeforeExit, false);\n+  }\n+\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(GCTimeRatio, 70);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n+\n+  \/\/ This helps most multi-core hardware hosts, enable by default\n+  SHENANDOAH_ERGO_ENABLE_FLAG(UseCondCardMark);\n+\n+  \/\/ Final configuration checks\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahLoadRefBarrier);\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahSATBBarrier);\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahCASBarrier);\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahCloneBarrier);\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahCardBarrier);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_MODE_SHENANDOAHGENERATIONALMODE_HPP\n+#define SHARE_GC_SHENANDOAH_MODE_SHENANDOAHGENERATIONALMODE_HPP\n+\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+\n+class ShenandoahGenerationalMode : public ShenandoahMode {\n+public:\n+  virtual void initialize_flags() const;\n+  virtual const char* name()     { return \"Generational\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return true; }\n+  virtual bool is_generational() { return true; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_MODE_SHENANDOAHGENERATIONALMODE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+\n+ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahSpaceInfo* space_info) const {\n+  if (ShenandoahGCHeuristics == nullptr) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n+  }\n+\n+  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n+    return new ShenandoahAggressiveHeuristics(space_info);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n+    return new ShenandoahStaticHeuristics(space_info);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n+    return new ShenandoahAdaptiveHeuristics(space_info);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n+    return new ShenandoahCompactHeuristics(space_info);\n+  } else {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n+  }\n+\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -29,0 +31,2 @@\n+#include \"runtime\/java.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -30,0 +34,1 @@\n+class ShenandoahSpaceInfo;\n@@ -51,1 +56,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics() const = 0;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahSpaceInfo* space_info) const;\n@@ -55,0 +60,1 @@\n+  virtual bool is_generational() { return false; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -31,1 +33,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -53,0 +54,1 @@\n+  SHENANDOAH_ERGO_DISABLE_FLAG(ShenandoahCardBarrier);\n@@ -55,1 +57,3 @@\n-  \/\/ No barriers are required to run.\n+  \/\/ Passive mode does not instantiate the machinery to support the card table.\n+  \/\/ Exit if the flag has been explicitly set.\n+  SHENANDOAH_CHECK_FLAG_UNSET(ShenandoahCardBarrier);\n@@ -57,1 +61,2 @@\n-ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics() const {\n+\n+ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahSpaceInfo* space_info) const {\n@@ -61,1 +66,1 @@\n-  return new ShenandoahPassiveHeuristics(ShenandoahHeap::heap());\n+  return new ShenandoahPassiveHeuristics(space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics() const;\n-\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahSpaceInfo* space_info) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -31,1 +28,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -51,18 +47,1 @@\n-}\n-\n-ShenandoahHeuristics* ShenandoahSATBMode::initialize_heuristics() const {\n-  if (ShenandoahGCHeuristics == nullptr) {\n-    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n-  }\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-    return new ShenandoahAggressiveHeuristics(heap);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-    return new ShenandoahStaticHeuristics(heap);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-    return new ShenandoahAdaptiveHeuristics(heap);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-    return new ShenandoahCompactHeuristics(heap);\n-  }\n-  vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-  return nullptr;\n+  SHENANDOAH_CHECK_FLAG_UNSET(ShenandoahCardBarrier);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.cpp","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHAFFILIATION_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHAFFILIATION_HPP\n+\n+enum ShenandoahAffiliation {\n+  FREE,\n+  YOUNG_GENERATION,\n+  OLD_GENERATION,\n+};\n+\n+inline const char* shenandoah_affiliation_code(ShenandoahAffiliation type) {\n+  switch(type) {\n+    case FREE:\n+      return \"F\";\n+    case YOUNG_GENERATION:\n+      return \"Y\";\n+    case OLD_GENERATION:\n+      return \"O\";\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+inline const char* shenandoah_affiliation_name(ShenandoahAffiliation type) {\n+  switch (type) {\n+    case FREE:\n+      return \"FREE\";\n+    case YOUNG_GENERATION:\n+      return \"YOUNG\";\n+    case OLD_GENERATION:\n+      return \"OLD\";\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHAFFILIATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAffiliation.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+\n+ShenandoahAgeCensus::ShenandoahAgeCensus() {\n+  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Only in generational mode\");\n+  if (ShenandoahGenerationalMinTenuringAge > ShenandoahGenerationalMaxTenuringAge) {\n+    vm_exit_during_initialization(\n+      err_msg(\"ShenandoahGenerationalMinTenuringAge=\" SIZE_FORMAT\n+              \" should be no more than ShenandoahGenerationalMaxTenuringAge=\" SIZE_FORMAT,\n+              ShenandoahGenerationalMinTenuringAge, ShenandoahGenerationalMaxTenuringAge));\n+  }\n+\n+  _global_age_table = NEW_C_HEAP_ARRAY(AgeTable*, MAX_SNAPSHOTS, mtGC);\n+  CENSUS_NOISE(_global_noise = NEW_C_HEAP_ARRAY(ShenandoahNoiseStats, MAX_SNAPSHOTS, mtGC);)\n+  _tenuring_threshold = NEW_C_HEAP_ARRAY(uint, MAX_SNAPSHOTS, mtGC);\n+\n+  for (int i = 0; i < MAX_SNAPSHOTS; i++) {\n+    \/\/ Note that we don't now get perfdata from age_table\n+    _global_age_table[i] = new AgeTable(false);\n+    CENSUS_NOISE(_global_noise[i].clear();)\n+    \/\/ Sentinel value\n+    _tenuring_threshold[i] = MAX_COHORTS;\n+  }\n+  if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, max_workers, mtGC);\n+    CENSUS_NOISE(_local_noise = NEW_C_HEAP_ARRAY(ShenandoahNoiseStats, max_workers, mtGC);)\n+    for (uint i = 0; i < max_workers; i++) {\n+      _local_age_table[i] = new AgeTable(false);\n+      CENSUS_NOISE(_local_noise[i].clear();)\n+    }\n+  } else {\n+    _local_age_table = nullptr;\n+  }\n+  _epoch = MAX_SNAPSHOTS - 1;  \/\/ see update_epoch()\n+}\n+\n+CENSUS_NOISE(void ShenandoahAgeCensus::add(uint obj_age, uint region_age, uint region_youth, size_t size, uint worker_id) {)\n+NO_CENSUS_NOISE(void ShenandoahAgeCensus::add(uint obj_age, uint region_age, size_t size, uint worker_id) {)\n+  if (obj_age <= markWord::max_age) {\n+    assert(obj_age < MAX_COHORTS && region_age < MAX_COHORTS, \"Should have been tenured\");\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+    \/\/ Region ageing is stochastic and non-monotonic; this vitiates mortality\n+    \/\/ demographics in ways that might defeat our algorithms. Marking may be a\n+    \/\/ time when we might be able to correct this, but we currently do not do\n+    \/\/ this. Like skipped statistics further below, we want to track the\n+    \/\/ impact of this noise to see if this may be worthwhile. JDK-<TBD>.\n+    uint age = obj_age;\n+    if (region_age > 0) {\n+      add_aged(size, worker_id);   \/\/ this tracking is coarse for now\n+      age += region_age;\n+      if (age >= MAX_COHORTS) {\n+        age = (uint)(MAX_COHORTS - 1);  \/\/ clamp\n+        add_clamped(size, worker_id);\n+      }\n+    }\n+    if (region_youth > 0) {   \/\/ track object volume with retrograde age\n+      add_young(size, worker_id);\n+    }\n+#else   \/\/ SHENANDOAH_CENSUS_NOISE\n+    uint age = MIN2(obj_age + region_age, (uint)(MAX_COHORTS - 1));  \/\/ clamp\n+#endif  \/\/ SHENANDOAH_CENSUS_NOISE\n+    get_local_age_table(worker_id)->add(age, size);\n+  } else {\n+    \/\/ update skipped statistics\n+    CENSUS_NOISE(add_skipped(size, worker_id);)\n+  }\n+}\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+void ShenandoahAgeCensus::add_skipped(size_t size, uint worker_id) {\n+  _local_noise[worker_id].skipped += size;\n+}\n+\n+void ShenandoahAgeCensus::add_aged(size_t size, uint worker_id) {\n+  _local_noise[worker_id].aged += size;\n+}\n+\n+void ShenandoahAgeCensus::add_clamped(size_t size, uint worker_id) {\n+  _local_noise[worker_id].clamped += size;\n+}\n+\n+void ShenandoahAgeCensus::add_young(size_t size, uint worker_id) {\n+  _local_noise[worker_id].young += size;\n+}\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+\/\/ Prepare for a new census update, by clearing appropriate global slots.\n+void ShenandoahAgeCensus::prepare_for_census_update() {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  if (++_epoch >= MAX_SNAPSHOTS) {\n+    _epoch=0;\n+  }\n+  _global_age_table[_epoch]->clear();\n+  CENSUS_NOISE(_global_noise[_epoch].clear();)\n+}\n+\n+\/\/ Update the census data from appropriate sources,\n+\/\/ and compute the new tenuring threshold.\n+void ShenandoahAgeCensus::update_census(size_t age0_pop, AgeTable* pv1, AgeTable* pv2) {\n+  prepare_for_census_update();\n+  assert(_global_age_table[_epoch]->is_clear(), \"Dirty decks\");\n+  CENSUS_NOISE(assert(_global_noise[_epoch].is_clear(), \"Dirty decks\");)\n+  if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    assert(pv1 == nullptr && pv2 == nullptr, \"Error, check caller\");\n+    \/\/ Seed cohort 0 with population that may have been missed during\n+    \/\/ regular census.\n+    _global_age_table[_epoch]->add((uint)0, age0_pop);\n+\n+    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+    \/\/ Merge data from local age tables into the global age table for the epoch,\n+    \/\/ clearing the local tables.\n+    for (uint i = 0; i < max_workers; i++) {\n+      \/\/ age stats\n+      _global_age_table[_epoch]->merge(_local_age_table[i]);\n+      _local_age_table[i]->clear();   \/\/ clear for next census\n+      \/\/ Merge noise stats\n+      CENSUS_NOISE(_global_noise[_epoch].merge(_local_noise[i]);)\n+      CENSUS_NOISE(_local_noise[i].clear();)\n+    }\n+  } else {\n+    \/\/ census during evac\n+    assert(pv1 != nullptr && pv2 != nullptr, \"Error, check caller\");\n+    _global_age_table[_epoch]->merge(pv1);\n+    _global_age_table[_epoch]->merge(pv2);\n+  }\n+\n+  update_tenuring_threshold();\n+\n+  \/\/ used for checking reasonableness of census coverage, non-product\n+  \/\/ only.\n+  NOT_PRODUCT(update_total();)\n+}\n+\n+\n+\/\/ Reset the epoch for the global age tables,\n+\/\/ clearing all history.\n+void ShenandoahAgeCensus::reset_global() {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  for (uint i = 0; i < MAX_SNAPSHOTS; i++) {\n+    _global_age_table[i]->clear();\n+    CENSUS_NOISE(_global_noise[i].clear();)\n+  }\n+  _epoch = MAX_SNAPSHOTS;\n+  assert(_epoch < MAX_SNAPSHOTS, \"Error\");\n+}\n+\n+\/\/ Reset the local age tables, clearing any partial census.\n+void ShenandoahAgeCensus::reset_local() {\n+  if (!ShenandoahGenerationalAdaptiveTenuring || ShenandoahGenerationalCensusAtEvac) {\n+    assert(_local_age_table == nullptr, \"Error\");\n+    return;\n+  }\n+  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+  for (uint i = 0; i < max_workers; i++) {\n+    _local_age_table[i]->clear();\n+    CENSUS_NOISE(_local_noise[i].clear();)\n+  }\n+}\n+\n+#ifndef PRODUCT\n+\/\/ Is global census information clear?\n+bool ShenandoahAgeCensus::is_clear_global() {\n+  assert(_epoch < MAX_SNAPSHOTS, \"Out of bounds\");\n+  for (uint i = 0; i < MAX_SNAPSHOTS; i++) {\n+    bool clear = _global_age_table[i]->is_clear();\n+    CENSUS_NOISE(clear |= _global_noise[i].is_clear();)\n+    if (!clear) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Is local census information clear?\n+bool ShenandoahAgeCensus::is_clear_local() {\n+  if (!ShenandoahGenerationalAdaptiveTenuring || ShenandoahGenerationalCensusAtEvac) {\n+    assert(_local_age_table == nullptr, \"Error\");\n+    return true;\n+  }\n+  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n+  for (uint i = 0; i < max_workers; i++) {\n+    bool clear = _local_age_table[i]->is_clear();\n+    CENSUS_NOISE(clear |= _local_noise[i].is_clear();)\n+    if (!clear) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+size_t ShenandoahAgeCensus::get_all_ages(uint snap) {\n+  assert(snap < MAX_SNAPSHOTS, \"Out of bounds\");\n+  size_t pop = 0;\n+  const AgeTable* pv = _global_age_table[snap];\n+  for (uint i = 0; i < MAX_COHORTS; i++) {\n+    pop += pv->sizes[i];\n+  }\n+  return pop;\n+}\n+\n+size_t ShenandoahAgeCensus::get_skipped(uint snap) {\n+  assert(snap < MAX_SNAPSHOTS, \"Out of bounds\");\n+  return _global_noise[snap].skipped;\n+}\n+\n+void ShenandoahAgeCensus::update_total() {\n+  _counted = get_all_ages(_epoch);\n+  _skipped = get_skipped(_epoch);\n+  _total   = _counted + _skipped;\n+}\n+#endif \/\/ !PRODUCT\n+\n+void ShenandoahAgeCensus::update_tenuring_threshold() {\n+  if (!ShenandoahGenerationalAdaptiveTenuring) {\n+    _tenuring_threshold[_epoch] = InitialTenuringThreshold;\n+  } else {\n+    uint tt = compute_tenuring_threshold();\n+    assert(tt <= MAX_COHORTS, \"Out of bounds\");\n+    _tenuring_threshold[_epoch] = tt;\n+  }\n+  print();\n+  log_trace(gc, age)(\"New tenuring threshold \" UINTX_FORMAT \" (min \" UINTX_FORMAT \", max \" UINTX_FORMAT\")\",\n+    (uintx) _tenuring_threshold[_epoch], ShenandoahGenerationalMinTenuringAge, ShenandoahGenerationalMaxTenuringAge);\n+}\n+\n+\/\/ Currently Shenandoah{Min,Max}TenuringAge have a floor of 1 because we\n+\/\/ aren't set up to promote age 0 objects.\n+uint ShenandoahAgeCensus::compute_tenuring_threshold() {\n+  \/\/ Dispose of the extremal cases early so the loop below\n+  \/\/ is less fragile.\n+  if (ShenandoahGenerationalMaxTenuringAge == ShenandoahGenerationalMinTenuringAge) {\n+    return ShenandoahGenerationalMaxTenuringAge; \/\/ Any value in [1,16]\n+  }\n+  assert(ShenandoahGenerationalMinTenuringAge < ShenandoahGenerationalMaxTenuringAge, \"Error\");\n+\n+  \/\/ Starting with the oldest cohort with a non-trivial population\n+  \/\/ (as specified by ShenandoahGenerationalTenuringCohortPopulationThreshold) in the\n+  \/\/ previous epoch, and working down the cohorts by age, find the\n+  \/\/ oldest age that has a significant mortality rate (as specified by\n+  \/\/ ShenandoahGenerationalTenuringMortalityRateThreshold). We use this as\n+  \/\/ tenuring age to be used for the evacuation cycle to follow.\n+  \/\/ Results are clamped between user-specified min & max guardrails,\n+  \/\/ so we ignore any cohorts outside ShenandoahGenerational[Min,Max]Age.\n+\n+  \/\/ Current and previous epoch in ring\n+  const uint cur_epoch = _epoch;\n+  const uint prev_epoch = cur_epoch > 0  ? cur_epoch - 1 : markWord::max_age;\n+\n+  \/\/ Current and previous population vectors in ring\n+  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+  uint upper_bound = ShenandoahGenerationalMaxTenuringAge;\n+  const uint prev_tt = previous_tenuring_threshold();\n+  if (ShenandoahGenerationalCensusIgnoreOlderCohorts && prev_tt > 0) {\n+     \/\/ We stay below the computed tenuring threshold for the last cycle plus 1,\n+     \/\/ ignoring the mortality rates of any older cohorts.\n+     upper_bound = MIN2(upper_bound, prev_tt + 1);\n+  }\n+  upper_bound = MIN2(upper_bound, markWord::max_age);\n+\n+  const uint lower_bound = MAX2((uint)ShenandoahGenerationalMinTenuringAge, (uint)1);\n+\n+  uint tenuring_threshold = upper_bound;\n+  for (uint i = upper_bound; i >= lower_bound; i--) {\n+    assert(i > 0, \"Index (i-1) would underflow\/wrap\");\n+    assert(i <= markWord::max_age, \"Index i would overflow\");\n+    \/\/ Cohort of current age i\n+    const size_t cur_pop = cur_pv->sizes[i];\n+    const size_t prev_pop = prev_pv->sizes[i-1];\n+    const double mr = mortality_rate(prev_pop, cur_pop);\n+    if (prev_pop > ShenandoahGenerationalTenuringCohortPopulationThreshold &&\n+        mr > ShenandoahGenerationalTenuringMortalityRateThreshold) {\n+      \/\/ This is the oldest cohort that has high mortality.\n+      \/\/ We ignore any cohorts that had a very low population count, or\n+      \/\/ that have a lower mortality rate than we care to age in young; these\n+      \/\/ cohorts are considered eligible for tenuring when all older\n+      \/\/ cohorts are. We return the next higher age as the tenuring threshold\n+      \/\/ so that we do not prematurely promote objects of this age.\n+      assert(tenuring_threshold == i+1 || tenuring_threshold == upper_bound, \"Error\");\n+      assert(tenuring_threshold >= lower_bound && tenuring_threshold <= upper_bound, \"Error\");\n+      return tenuring_threshold;\n+    }\n+    \/\/ Remember that we passed over this cohort, looking for younger cohorts\n+    \/\/ showing high mortality. We want to tenure cohorts of this age.\n+    tenuring_threshold = i;\n+  }\n+  assert(tenuring_threshold >= lower_bound && tenuring_threshold <= upper_bound, \"Error\");\n+  return tenuring_threshold;\n+}\n+\n+\/\/ Mortality rate of a cohort, given its previous and current population\n+double ShenandoahAgeCensus::mortality_rate(size_t prev_pop, size_t cur_pop) {\n+  \/\/ The following also covers the case where both entries are 0\n+  if (prev_pop <= cur_pop) {\n+    \/\/ adjust for inaccurate censuses by finessing the\n+    \/\/ reappearance of dark matter as normal matter;\n+    \/\/ mortality rate is 0 if population remained the same\n+    \/\/ or increased.\n+    if (cur_pop > prev_pop) {\n+      log_trace(gc, age)\n+        (\" (dark matter) Cohort population \" SIZE_FORMAT_W(10) \" to \" SIZE_FORMAT_W(10),\n+        prev_pop*oopSize, cur_pop*oopSize);\n+    }\n+    return 0.0;\n+  }\n+  assert(prev_pop > 0 && prev_pop > cur_pop, \"Error\");\n+  return 1.0 - (((double)cur_pop)\/((double)prev_pop));\n+}\n+\n+void ShenandoahAgeCensus::print() {\n+  \/\/ Print the population vector for the current epoch, and\n+  \/\/ for the previous epoch, as well as the computed mortality\n+  \/\/ ratio for each extant cohort.\n+  const uint cur_epoch = _epoch;\n+  const uint prev_epoch = cur_epoch > 0 ? cur_epoch - 1: markWord::max_age;\n+\n+  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+\n+  const uint tt = tenuring_threshold();\n+\n+  size_t total= 0;\n+  for (uint i = 1; i < MAX_COHORTS; i++) {\n+    const size_t prev_pop = prev_pv->sizes[i-1];  \/\/ (i-1) OK because i >= 1\n+    const size_t cur_pop  = cur_pv->sizes[i];\n+    double mr = mortality_rate(prev_pop, cur_pop);\n+    \/\/ Suppress printing when everything is zero\n+    if (prev_pop + cur_pop > 0) {\n+      log_info(gc, age)\n+        (\" - age %3u: prev \" SIZE_FORMAT_W(10) \" bytes, curr \" SIZE_FORMAT_W(10) \" bytes, mortality %.2f \",\n+         i, prev_pop*oopSize, cur_pop*oopSize, mr);\n+    }\n+    total += cur_pop;\n+    if (i == tt) {\n+      \/\/ Underline the cohort for tenuring threshold (if < MAX_COHORTS)\n+      log_info(gc, age)(\"----------------------------------------------------------------------------\");\n+    }\n+  }\n+  CENSUS_NOISE(_global_noise[cur_epoch].print(total);)\n+}\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+void ShenandoahNoiseStats::print(size_t total) {\n+  if (total > 0) {\n+    float f_skipped = (float)skipped\/(float)total;\n+    float f_aged    = (float)aged\/(float)total;\n+    float f_clamped = (float)clamped\/(float)total;\n+    float f_young   = (float)young\/(float)total;\n+    log_info(gc, age)(\"Skipped: \" SIZE_FORMAT_W(10) \" (%.2f),  R-Aged: \" SIZE_FORMAT_W(10) \" (%.2f),  \"\n+                      \"Clamped: \" SIZE_FORMAT_W(10) \" (%.2f),  R-Young: \" SIZE_FORMAT_W(10) \" (%.2f)\",\n+                      skipped*oopSize, f_skipped, aged*oopSize, f_aged,\n+                      clamped*oopSize, f_clamped, young*oopSize, f_young);\n+  }\n+}\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHAGECENSUS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHAGECENSUS_HPP\n+\n+#include \"gc\/shared\/ageTable.hpp\"\n+\n+#ifndef PRODUCT\n+\/\/ Enable noise instrumentation\n+#define SHENANDOAH_CENSUS_NOISE 1\n+#endif  \/\/ PRODUCT\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+\n+#define CENSUS_NOISE(x) x\n+#define NO_CENSUS_NOISE(x)\n+\n+struct ShenandoahNoiseStats {\n+  size_t skipped;   \/\/ Volume of objects skipped\n+  size_t aged;      \/\/ Volume of objects from aged regions\n+  size_t clamped;   \/\/ Volume of objects whose ages were clamped\n+  size_t young;     \/\/ Volume of (rejuvenated) objects of retrograde age\n+\n+  ShenandoahNoiseStats() {\n+    clear();\n+  }\n+\n+  void clear() {\n+    skipped = 0;\n+    aged = 0;\n+    clamped = 0;\n+    young = 0;\n+  }\n+\n+#ifndef PRODUCT\n+  bool is_clear() {\n+    return (skipped + aged + clamped + young) == 0;\n+  }\n+#endif \/\/ !PRODUCT\n+\n+  void merge(ShenandoahNoiseStats& other) {\n+    skipped += other.skipped;\n+    aged    += other.aged;\n+    clamped += other.clamped;\n+    young   += other.young;\n+  }\n+\n+  void print(size_t total);\n+};\n+#else  \/\/ SHENANDOAH_CENSUS_NOISE\n+#define CENSUS_NOISE(x)\n+#define NO_CENSUS_NOISE(x) x\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+\/\/ A class for tracking a sequence of cohort population vectors (or,\n+\/\/ interchangeably, age tables) for up to C=MAX_COHORTS age cohorts, where a cohort\n+\/\/ represents the set of objects allocated during a specific inter-GC epoch.\n+\/\/ Epochs are demarcated by GC cycles, with those surviving a cycle aging by\n+\/\/ an epoch. The census tracks the historical variation of cohort demographics\n+\/\/ across N=MAX_SNAPSHOTS recent epochs. Since there are at most C age cohorts in\n+\/\/ the population, we need only track at most N=C epochal snapshots to track a\n+\/\/ maximal longitudinal demographics of every object's longitudinal cohort in\n+\/\/ the young generation. The _global_age_table is thus, currently, a C x N (row-major)\n+\/\/ matrix, with C=16, and, for now N=C=16, currently.\n+\/\/ In theory, we might decide to track even longer (N=MAX_SNAPSHOTS) demographic\n+\/\/ histories, but that isn't the case today. In particular, the current tenuring\n+\/\/ threshold algorithm uses only 2 most recent snapshots, with the remaining\n+\/\/ MAX_SNAPSHOTS-2=14 reserved for research purposes.\n+\/\/\n+\/\/ In addition, this class also maintains per worker population vectors into which\n+\/\/ census for the current minor GC is accumulated (during marking or, optionally, during\n+\/\/ evacuation). These are cleared after each marking (resectively, evacuation) cycle,\n+\/\/ once the per-worker data is consolidated into the appropriate population vector\n+\/\/ per minor collection. The _local_age_table is thus C x N, for N GC workers.\n+class ShenandoahAgeCensus: public CHeapObj<mtGC> {\n+  AgeTable** _global_age_table;      \/\/ Global age table used for adapting tenuring threshold, one per snapshot\n+  AgeTable** _local_age_table;       \/\/ Local scratch age tables to track object ages, one per worker\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+  ShenandoahNoiseStats* _global_noise; \/\/ Noise stats, one per snapshot\n+  ShenandoahNoiseStats* _local_noise;  \/\/ Local scratch table for noise stats, one per worker\n+\n+  size_t _skipped;                   \/\/ net size of objects encountered, but skipped during census,\n+                                     \/\/ because their age was indeterminate\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+#ifndef PRODUCT\n+  size_t _counted;                   \/\/ net size of objects counted in census\n+  size_t _total;                     \/\/ net size of objects encountered (counted or skipped) in census\n+#endif\n+\n+  uint _epoch;                       \/\/ Current epoch (modulo max age)\n+  uint *_tenuring_threshold;         \/\/ An array of the last N tenuring threshold values we\n+                                     \/\/ computed.\n+\n+  \/\/ Mortality rate of a cohort, given its population in\n+  \/\/ previous and current epochs\n+  double mortality_rate(size_t prev_pop, size_t cur_pop);\n+\n+  \/\/ Update to a new epoch, creating a slot for new census.\n+  void prepare_for_census_update();\n+\n+  \/\/ Update the tenuring threshold, calling\n+  \/\/ compute_tenuring_threshold() to calculate the new\n+  \/\/ value\n+  void update_tenuring_threshold();\n+\n+  \/\/ Use _global_age_table and the current _epoch to compute a new tenuring\n+  \/\/ threshold, which will be remembered until the next invocation of\n+  \/\/ compute_tenuring_threshold.\n+  uint compute_tenuring_threshold();\n+\n+  \/\/ Return the tenuring threshold computed for the previous epoch\n+  uint previous_tenuring_threshold() const {\n+    assert(_epoch < MAX_SNAPSHOTS, \"Error\");\n+    uint prev = _epoch - 1;\n+    if (prev >= MAX_SNAPSHOTS) {\n+      \/\/ _epoch is 0\n+      assert(_epoch == 0, \"Error\");\n+      prev = MAX_SNAPSHOTS - 1;\n+    }\n+    return _tenuring_threshold[prev];\n+  }\n+\n+#ifndef PRODUCT\n+  \/\/ Return the sum of size of objects of all ages recorded in the\n+  \/\/ census at snapshot indexed by snap.\n+  size_t get_all_ages(uint snap);\n+\n+  \/\/ Return the size of all objects that were encountered, but skipped,\n+  \/\/ during the census, because their age was indeterminate.\n+  size_t get_skipped(uint snap);\n+\n+  \/\/ Update the total size of objects counted or skipped at the census for\n+  \/\/ the most recent epoch.\n+  void update_total();\n+#endif \/\/ !PRODUCT\n+\n+ public:\n+  enum {\n+    MAX_COHORTS = AgeTable::table_size,    \/\/ = markWord::max_age + 1\n+    MAX_SNAPSHOTS = MAX_COHORTS            \/\/ May change in the future\n+  };\n+\n+  ShenandoahAgeCensus();\n+\n+  \/\/ Return the local age table (population vector) for worker_id.\n+  \/\/ Only used in the case of (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac)\n+  AgeTable* get_local_age_table(uint worker_id) {\n+    return (AgeTable*) _local_age_table[worker_id];\n+  }\n+\n+  \/\/ Update the local age table for worker_id by size for\n+  \/\/ given obj_age, region_age, and region_youth\n+  CENSUS_NOISE(void add(uint obj_age, uint region_age, uint region_youth, size_t size, uint worker_id);)\n+  NO_CENSUS_NOISE(void add(uint obj_age, uint region_age, size_t size, uint worker_id);)\n+\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+  \/\/ Update the local skip table for worker_id by size\n+  void add_skipped(size_t size, uint worker_id);\n+  \/\/ Update the local aged region volume table for worker_id by size\n+  void add_aged(size_t size, uint worker_id);\n+  \/\/ Update the local clamped object volume table for worker_id by size\n+  void add_clamped(size_t size, uint worker_id);\n+  \/\/ Update the local (rejuvenated) object volume (retrograde age) for worker_id by size\n+  void add_young(size_t size, uint worker_id);\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+\n+  \/\/ Update the census data, and compute the new tenuring threshold.\n+  \/\/ This method should be called at the end of each marking (or optionally\n+  \/\/ evacuation) cycle to update the tenuring threshold to be used in\n+  \/\/ the next cycle.\n+  \/\/ age0_pop is the population of Cohort 0 that may have been missed in\n+  \/\/ the regular census during the marking cycle, corresponding to objects\n+  \/\/ allocated when the concurrent marking was in progress.\n+  \/\/ Optional parameters, pv1 and pv2 are population vectors that together\n+  \/\/ provide object census data (only) for the case when\n+  \/\/ ShenandoahGenerationalCensusAtEvac. In this case, the age0_pop\n+  \/\/ is 0, because the evacuated objects have all had their ages incremented.\n+  void update_census(size_t age0_pop, AgeTable* pv1 = nullptr, AgeTable* pv2 = nullptr);\n+\n+  \/\/ Return the most recently computed tenuring threshold\n+  uint tenuring_threshold() const { return _tenuring_threshold[_epoch]; }\n+\n+  \/\/ Reset the epoch, clearing accumulated census history\n+  \/\/ Note: this isn't currently used, but reserved for planned\n+  \/\/ future usage.\n+  void reset_global();\n+\n+  \/\/ Reset any (potentially partial) census information in worker-local age tables\n+  void reset_local();\n+\n+#ifndef PRODUCT\n+  \/\/ Check whether census information is clear\n+  bool is_clear_global();\n+  bool is_clear_local();\n+\n+  \/\/ Return the net size of objects encountered (counted or skipped) in census\n+  \/\/ at most recent epoch.\n+  size_t get_total() { return _total; }\n+#endif \/\/ !PRODUCT\n+\n+  \/\/ Print the age census information\n+  void print();\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHAGECENSUS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n@@ -34,1 +36,1 @@\n-    _alloc_shared_gc,   \/\/ Allocate common, outside of GCLAB\n+    _alloc_shared_gc,   \/\/ Allocate common, outside of GCLAB\/PLAB\n@@ -37,0 +39,1 @@\n+    _alloc_plab,        \/\/ Allocate PLAB\n@@ -50,0 +53,2 @@\n+      case _alloc_plab:\n+        return \"PLAB\";\n@@ -57,0 +62,1 @@\n+  \/\/ When ShenandoahElasticTLAB is enabled, the request cannot be made smaller than _min_size.\n@@ -58,0 +64,2 @@\n+\n+  \/\/ The size of the request in words.\n@@ -59,0 +67,2 @@\n+\n+  \/\/ The allocation may be increased for padding or decreased to fit in the remaining space of a region.\n@@ -60,0 +70,8 @@\n+\n+  \/\/ For a humongous object, the _waste is the amount of free memory in the last region.\n+  \/\/ For other requests, the _waste will be non-zero if the request enountered one or more regions\n+  \/\/ with less memory than _min_size. This waste does not contribute to the used memory for\n+  \/\/ the heap, but it does contribute to the allocation rate for heuristics.\n+  size_t _waste;\n+\n+  \/\/ This is the type of the request.\n@@ -61,0 +79,7 @@\n+\n+  \/\/ This is the generation which the request is targeting.\n+  ShenandoahAffiliation const _affiliation;\n+\n+  \/\/ True if this request is trying to copy any object from young to old (promote).\n+  bool _is_promotion;\n+\n@@ -62,0 +87,1 @@\n+  \/\/ Check that this is set before being read.\n@@ -65,1 +91,1 @@\n-  ShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type) :\n+  ShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type, ShenandoahAffiliation affiliation, bool is_promotion = false) :\n@@ -67,1 +93,1 @@\n-          _actual_size(0), _alloc_type(_alloc_type)\n+          _actual_size(0), _waste(0), _alloc_type(_alloc_type), _affiliation(affiliation), _is_promotion(is_promotion)\n@@ -75,1 +101,1 @@\n-    return ShenandoahAllocRequest(min_size, requested_size, _alloc_tlab);\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_tlab, ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -79,1 +105,5 @@\n-    return ShenandoahAllocRequest(min_size, requested_size, _alloc_gclab);\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_gclab, ShenandoahAffiliation::YOUNG_GENERATION);\n+  }\n+\n+  static inline ShenandoahAllocRequest for_plab(size_t min_size, size_t requested_size) {\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_plab, ShenandoahAffiliation::OLD_GENERATION);\n@@ -82,2 +112,6 @@\n-  static inline ShenandoahAllocRequest for_shared_gc(size_t requested_size) {\n-    return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc);\n+  static inline ShenandoahAllocRequest for_shared_gc(size_t requested_size, ShenandoahAffiliation affiliation, bool is_promotion = false) {\n+    if (is_promotion) {\n+      assert(affiliation == ShenandoahAffiliation::OLD_GENERATION, \"Should only promote to old generation\");\n+      return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc, affiliation, true);\n+    }\n+    return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc, affiliation);\n@@ -87,1 +121,1 @@\n-    return ShenandoahAllocRequest(0, requested_size, _alloc_shared);\n+    return ShenandoahAllocRequest(0, requested_size, _alloc_shared, ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -90,1 +124,1 @@\n-  inline size_t size() {\n+  inline size_t size() const {\n@@ -94,1 +128,1 @@\n-  inline Type type() {\n+  inline Type type() const {\n@@ -98,1 +132,1 @@\n-  inline const char* type_string() {\n+  inline const char* type_string() const {\n@@ -102,1 +136,1 @@\n-  inline size_t min_size() {\n+  inline size_t min_size() const {\n@@ -107,1 +141,1 @@\n-  inline size_t actual_size() {\n+  inline size_t actual_size() const {\n@@ -120,1 +154,9 @@\n-  inline bool is_mutator_alloc() {\n+  inline size_t waste() const {\n+    return _waste;\n+  }\n+\n+  inline void set_waste(size_t v) {\n+    _waste = v;\n+  }\n+\n+  inline bool is_mutator_alloc() const {\n@@ -126,0 +168,1 @@\n+      case _alloc_plab:\n@@ -134,1 +177,1 @@\n-  inline bool is_gc_alloc() {\n+  inline bool is_gc_alloc() const {\n@@ -140,0 +183,1 @@\n+      case _alloc_plab:\n@@ -148,1 +192,1 @@\n-  inline bool is_lab_alloc() {\n+  inline bool is_lab_alloc() const {\n@@ -152,0 +196,1 @@\n+      case _alloc_plab:\n@@ -161,0 +206,20 @@\n+\n+  bool is_old() const {\n+    return _affiliation == OLD_GENERATION;\n+  }\n+\n+  bool is_young() const {\n+    return _affiliation == YOUNG_GENERATION;\n+  }\n+\n+  ShenandoahAffiliation affiliation() const {\n+    return _affiliation;\n+  }\n+\n+  const char* affiliation_name() const {\n+    return shenandoah_affiliation_name(_affiliation);\n+  }\n+\n+  bool is_promotion() const {\n+    return _is_promotion;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocRequest.hpp","additions":81,"deletions":16,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -53,0 +55,1 @@\n+  FLAG_SET_DEFAULT(ShenandoahCardBarrier,            false);\n@@ -72,0 +75,7 @@\n+  \/\/ We use this as the time period for tracking minimum mutator utilization (MMU).\n+  \/\/ In generational mode, the MMU is used as a signal to adjust the size of the\n+  \/\/ young generation.\n+  if (FLAG_IS_DEFAULT(GCPauseIntervalMillis)) {\n+    FLAG_SET_DEFAULT(GCPauseIntervalMillis, 5000);\n+  }\n+\n@@ -192,0 +202,2 @@\n+  CardTable::initialize_card_size();\n+\n@@ -205,1 +217,6 @@\n-  return new ShenandoahHeap(new ShenandoahCollectorPolicy());\n+  if (strcmp(ShenandoahGCMode, \"generational\") != 0) {\n+    \/\/ Not generational\n+    return new ShenandoahHeap(new ShenandoahCollectorPolicy());\n+  } else {\n+    return new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+  if (heap->mode()->is_generational() && !obj->is_forwarded()) {\n+    msg.append(\"  age: %d\\n\", obj->age());\n+  }\n@@ -427,1 +430,1 @@\n-  ShenandoahMessageBuffer msg(\"Must ba at a Shenandoah safepoint or held %s lock\", lock->name());\n+  ShenandoahMessageBuffer msg(\"Must be at a Shenandoah safepoint or held %s lock\", lock->name());\n@@ -460,1 +463,1 @@\n-  if (ShenandoahSafepoint::is_at_shenandoah_safepoint() && Thread::current()->is_VM_thread()) {\n+  if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {\n@@ -467,0 +470,45 @@\n+\n+void ShenandoahAsserts::assert_generational(const char* file, int line) {\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  ShenandoahMessageBuffer msg(\"Must be in generational mode\");\n+  report_vm_error(file, line, msg.buffer());\n+}\n+\n+void ShenandoahAsserts::assert_control_or_vm_thread_at_safepoint(bool at_safepoint, const char* file, int line) {\n+  Thread* thr = Thread::current();\n+  if (thr == ShenandoahHeap::heap()->control_thread()) {\n+    return;\n+  }\n+  if (thr->is_VM_thread()) {\n+    if (!at_safepoint) {\n+      return;\n+    } else if (SafepointSynchronize::is_at_safepoint()) {\n+      return;\n+    }\n+  }\n+\n+  ShenandoahMessageBuffer msg(\"Must be either control thread, or vm thread\");\n+  if (at_safepoint) {\n+    msg.append(\" at a safepoint\");\n+  }\n+  report_vm_error(file, line, msg.buffer());\n+}\n+\n+void ShenandoahAsserts::assert_generations_reconciled(const char* file, int line) {\n+  if (!SafepointSynchronize::is_at_safepoint()) {\n+    return;\n+  }\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* ggen = heap->gc_generation();\n+  ShenandoahGeneration* agen = heap->active_generation();\n+  if (agen == ggen) {\n+    return;\n+  }\n+\n+  ShenandoahMessageBuffer msg(\"Active(%d) & GC(%d) Generations aren't reconciled\", agen->type(), ggen->type());\n+  report_vm_error(file, line, msg.buffer());\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -75,0 +76,3 @@\n+  static void assert_control_or_vm_thread_at_safepoint(bool at_safepoint, const char* file, int line);\n+  static void assert_generational(const char* file, int line);\n+  static void assert_generations_reconciled(const char* file, int line);\n@@ -166,0 +170,15 @@\n+\n+#define shenandoah_assert_control_or_vm_thread() \\\n+                    ShenandoahAsserts::assert_control_or_vm_thread(false \/* at_safepoint *\/, __FILE__, __LINE__)\n+\n+\/\/ A stronger version of the above that checks that we are at a safepoint if the vm thread\n+#define shenandoah_assert_control_or_vm_thread_at_safepoint()                                                                                                               \\\n+                    ShenandoahAsserts::assert_control_or_vm_thread_at_safepoint(true \/* at_safepoint *\/, __FILE__, __LINE__)\n+\n+#define shenandoah_assert_generational() \\\n+                    ShenandoahAsserts::assert_generational(__FILE__, __LINE__)\n+\n+\/\/ Some limited sanity checking of the _gc_generation and _active_generation fields of ShenandoahHeap\n+#define shenandoah_assert_generations_reconciled()                                                             \\\n+                    ShenandoahAsserts::assert_generations_reconciled(__FILE__, __LINE__)\n+\n@@ -216,0 +235,4 @@\n+#define shenandoah_assert_control_or_vm_thread()\n+#define shenandoah_assert_control_or_vm_thread_at_safepoint()\n+#define shenandoah_assert_generational()\n+#define shenandoah_assert_generations_reconciled()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -44,1 +47,1 @@\n-ShenandoahBarrierSet::ShenandoahBarrierSet(ShenandoahHeap* heap) :\n+ShenandoahBarrierSet::ShenandoahBarrierSet(ShenandoahHeap* heap, MemRegion heap_region) :\n@@ -52,0 +55,1 @@\n+  _card_table(nullptr),\n@@ -55,0 +59,4 @@\n+  if (ShenandoahCardBarrier) {\n+    _card_table = new ShenandoahCardTable(heap_region);\n+    _card_table->initialize();\n+  }\n@@ -127,0 +135,6 @@\n+    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+    if (plab != nullptr) {\n+      \/\/ This will assert if plab is not null in non-generational mode\n+      ShenandoahGenerationalHeap::heap()->retire_plab(plab);\n+    }\n+\n@@ -145,0 +159,19 @@\n+\n+void ShenandoahBarrierSet::write_ref_array(HeapWord* start, size_t count) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+\n+  HeapWord* end = (HeapWord*)((char*) start + (count * heapOopSize));\n+  \/\/ In the case of compressed oops, start and end may potentially be misaligned;\n+  \/\/ so we need to conservatively align the first downward (this is not\n+  \/\/ strictly necessary for current uses, but a case of good hygiene and,\n+  \/\/ if you will, aesthetics) and the second upward (this is essential for\n+  \/\/ current uses) to a HeapWord boundary, so we mark all cards overlapping\n+  \/\/ this write.\n+  HeapWord* aligned_start = align_down(start, HeapWordSize);\n+  HeapWord* aligned_end   = align_up  (end,   HeapWordSize);\n+  \/\/ If compressed oops were not being used, these should already be aligned\n+  assert(UseCompressedOops || (aligned_start == start && aligned_end == end),\n+         \"Expected heap word alignment of start and end\");\n+  _heap->old_generation()->card_scan()->mark_range_as_dirty(aligned_start, (aligned_end - aligned_start));\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,0 +35,1 @@\n+class ShenandoahCardTable;\n@@ -38,0 +40,1 @@\n+  ShenandoahCardTable* _card_table;\n@@ -42,1 +45,1 @@\n-  ShenandoahBarrierSet(ShenandoahHeap* heap);\n+  ShenandoahBarrierSet(ShenandoahHeap* heap, MemRegion heap_region);\n@@ -50,0 +53,4 @@\n+  inline ShenandoahCardTable* card_table() {\n+    return _card_table;\n+  }\n+\n@@ -114,0 +121,5 @@\n+  template <DecoratorSet decorators, typename T>\n+  void write_ref_field_post(T* field);\n+\n+  void write_ref_array(HeapWord* start, size_t count);\n+\n@@ -116,1 +128,1 @@\n-  inline void arraycopy_marking(T* src, T* dst, size_t count);\n+  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n@@ -35,0 +38,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -39,0 +43,2 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n@@ -106,0 +112,1 @@\n+      _heap->is_in_active_generation(obj) &&\n@@ -113,0 +120,1 @@\n+      _heap->is_in_active_generation(obj) &&\n@@ -176,0 +184,7 @@\n+template <DecoratorSet decorators, typename T>\n+inline void ShenandoahBarrierSet::write_ref_field_post(T* field) {\n+  assert(ShenandoahCardBarrier, \"Should have been checked by caller\");\n+  volatile CardTable::CardValue* byte = card_table()->byte_for(field);\n+  *byte = CardTable::dirty_card_val();\n+}\n+\n@@ -237,1 +252,4 @@\n-  shenandoah_assert_marked_if(nullptr, value, !CompressedOops::is_null(value) && ShenandoahHeap::heap()->is_evacuation_in_progress());\n+  shenandoah_assert_marked_if(nullptr, value,\n+                              !CompressedOops::is_null(value) && ShenandoahHeap::heap()->is_evacuation_in_progress()\n+                              && !(ShenandoahHeap::heap()->active_generation()->is_young()\n+                                   && ShenandoahHeap::heap()->heap_region_containing(value)->is_old()));\n@@ -257,0 +275,4 @@\n+  if (ShenandoahCardBarrier) {\n+    ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+    bs->write_ref_field_post<decorators>(addr);\n+  }\n@@ -277,1 +299,5 @@\n-  return bs->oop_cmpxchg(decorators, addr, compare_value, new_value);\n+  oop result = bs->oop_cmpxchg(decorators, addr, compare_value, new_value);\n+  if (ShenandoahCardBarrier) {\n+    bs->write_ref_field_post<decorators>(addr);\n+  }\n+  return result;\n@@ -285,1 +311,6 @@\n-  return bs->oop_cmpxchg(resolved_decorators, AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n+  auto addr = AccessInternal::oop_field_addr<decorators>(base, offset);\n+  oop result = bs->oop_cmpxchg(resolved_decorators, addr, compare_value, new_value);\n+  if (ShenandoahCardBarrier) {\n+    bs->write_ref_field_post<decorators>(addr);\n+  }\n+  return result;\n@@ -301,1 +332,5 @@\n-  return bs->oop_xchg(decorators, addr, new_value);\n+  oop result = bs->oop_xchg(decorators, addr, new_value);\n+  if (ShenandoahCardBarrier) {\n+    bs->write_ref_field_post<decorators>(addr);\n+  }\n+  return result;\n@@ -309,1 +344,6 @@\n-  return bs->oop_xchg(resolved_decorators, AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n+  auto addr = AccessInternal::oop_field_addr<decorators>(base, offset);\n+  oop result = bs->oop_xchg(resolved_decorators, addr, new_value);\n+  if (ShenandoahCardBarrier) {\n+    bs->write_ref_field_post<decorators>(addr);\n+  }\n+  return result;\n@@ -326,0 +366,3 @@\n+  T* src = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);\n+  T* dst = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);\n+\n@@ -327,4 +370,6 @@\n-  bs->arraycopy_barrier(arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw),\n-                        arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw),\n-                        length);\n-  return Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);\n+  bs->arraycopy_barrier(src, dst, length);\n+  bool result = Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);\n+  if (ShenandoahCardBarrier) {\n+    bs->write_ref_array((HeapWord*) dst, length);\n+  }\n+  return result;\n@@ -335,1 +380,9 @@\n-  assert(HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n+  \/\/ Young cycles are allowed to run when old marking is in progress. When old marking is in progress,\n+  \/\/ this barrier will be called with ENQUEUE=true and HAS_FWD=false, even though the young generation\n+  \/\/ may have forwarded objects. In this case, the `arraycopy_work` is first called with HAS_FWD=true and\n+  \/\/ ENQUEUE=false.\n+  assert(HAS_FWD == _heap->has_forwarded_objects() || (_heap->gc_state() & ShenandoahHeap::OLD_MARKING) != 0,\n+         \"Forwarded object status is sane\");\n+  \/\/ This function cannot be called to handle marking and evacuation at the same time (they operate on\n+  \/\/ different sides of the copy).\n+  assert((HAS_FWD || EVAC) != ENQUEUE, \"Cannot evacuate and mark both sides of copy.\");\n@@ -353,1 +406,0 @@\n-        obj = fwd;\n@@ -355,1 +407,1 @@\n-      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong_or_old(obj)) {\n@@ -365,0 +417,1 @@\n+    \/\/ No elements to copy, no need for barrier\n@@ -367,0 +420,1 @@\n+\n@@ -368,3 +422,1 @@\n-  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    arraycopy_marking(src, dst, count);\n-  } else if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n+  if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n@@ -375,0 +427,12 @@\n+\n+  if (_heap->mode()->is_generational()) {\n+    assert(ShenandoahSATBBarrier, \"Generational mode assumes SATB mode\");\n+    if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n+      arraycopy_marking(src, dst, count, false);\n+    }\n+    if ((gc_state & ShenandoahHeap::OLD_MARKING) != 0) {\n+      arraycopy_marking(src, dst, count, true);\n+    }\n+  } else if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+    arraycopy_marking(src, dst, count, false);\n+  }\n@@ -378,1 +442,1 @@\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n@@ -380,3 +444,40 @@\n-  T* array = ShenandoahSATBBarrier ? dst : src;\n-  if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(array))) {\n-    arraycopy_work<T, false, false, true>(array, count);\n+  \/*\n+   * Note that an old-gen object is considered live if it is live at the start of OLD marking or if it is promoted\n+   * following the start of OLD marking.\n+   *\n+   * 1. Every object promoted following the start of OLD marking will be above TAMS within its old-gen region\n+   * 2. Every object live at the start of OLD marking will be referenced from a \"root\" or it will be referenced from\n+   *    another live OLD-gen object.  With regards to old-gen, roots include stack locations and all of live young-gen.\n+   *    All root references to old-gen are identified during a bootstrap young collection.  All references from other\n+   *    old-gen objects will be marked during the traversal of all old objects, or will be marked by the SATB barrier.\n+   *\n+   * During old-gen marking (which is interleaved with young-gen collections), call arraycopy_work() if:\n+   *\n+   * 1. The overwritten array resides in old-gen and it is below TAMS within its old-gen region\n+   * 2. Do not call arraycopy_work for any array residing in young-gen because young-gen collection is idle at this time\n+   *\n+   * During young-gen marking, call arraycopy_work() if:\n+   *\n+   * 1. The overwritten array resides in young-gen and is below TAMS within its young-gen region\n+   * 2. Additionally, if array resides in old-gen, regardless of its relationship to TAMS because this old-gen array\n+   *    may hold references to young-gen\n+   *\/\n+  if (ShenandoahSATBBarrier) {\n+    T* array = dst;\n+    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n+    ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n+    if (is_old_marking) {\n+      \/\/ Generational, old marking\n+      assert(_heap->mode()->is_generational(), \"Invariant\");\n+      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n+        arraycopy_work<T, false, false, true>(array, count);\n+      }\n+    } else if (_heap->mode()->is_generational()) {\n+      \/\/ Generational, young marking\n+      if (r->is_old() || (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n+        arraycopy_work<T, false, false, true>(array, count);\n+      }\n+    } else if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n+      \/\/ Non-generational, marking\n+      arraycopy_work<T, false, false, true>(array, count);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":120,"deletions":19,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved. *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+#ifndef PRODUCT\n+void ShenandoahCardStats::log() const {\n+  if (ShenandoahEnableCardStats) {\n+    log_info(gc,remset)(\"Card stats: dirty \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" clean \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" dirty scans\/objs \" SIZE_FORMAT,\n+      _dirty_card_cnt, _max_dirty_run,\n+      _clean_card_cnt, _max_clean_run,\n+      _dirty_scan_obj_cnt);\n+  }\n+}\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+\n+enum CardStatType {\n+  DIRTY_RUN,\n+  CLEAN_RUN,\n+  DIRTY_CARDS,\n+  CLEAN_CARDS,\n+  MAX_DIRTY_RUN,\n+  MAX_CLEAN_RUN,\n+  DIRTY_SCAN_OBJS,\n+  ALTERNATIONS,\n+  MAX_CARD_STAT_TYPE\n+};\n+\n+enum CardStatLogType {\n+  CARD_STAT_SCAN_RS,\n+  CARD_STAT_UPDATE_REFS,\n+  MAX_CARD_STAT_LOG_TYPE\n+};\n+\n+class ShenandoahCardStats: public CHeapObj<mtGC> {\n+private:\n+  size_t _cards_in_cluster;\n+  HdrSeq* _local_card_stats;\n+\n+  size_t _dirty_card_cnt;\n+  size_t _clean_card_cnt;\n+\n+  size_t _max_dirty_run;\n+  size_t _max_clean_run;\n+\n+  size_t _dirty_scan_obj_cnt;\n+\n+  size_t _alternation_cnt;\n+\n+public:\n+  ShenandoahCardStats(size_t cards_in_cluster, HdrSeq* card_stats) :\n+    _cards_in_cluster(cards_in_cluster),\n+    _local_card_stats(card_stats),\n+    _dirty_card_cnt(0),\n+    _clean_card_cnt(0),\n+    _max_dirty_run(0),\n+    _max_clean_run(0),\n+    _dirty_scan_obj_cnt(0),\n+    _alternation_cnt(0)\n+  { }\n+\n+  ~ShenandoahCardStats() {\n+    record();\n+   }\n+\n+   void record() {\n+    if (ShenandoahEnableCardStats) {\n+      \/\/ Update global stats for distribution of dirty\/clean cards as a percentage of chunk\n+      _local_card_stats[DIRTY_CARDS].add(percent_of(_dirty_card_cnt, _cards_in_cluster));\n+      _local_card_stats[CLEAN_CARDS].add(percent_of(_clean_card_cnt, _cards_in_cluster));\n+\n+      \/\/ Update global stats for max dirty\/clean run distribution as a percentage of chunk\n+      _local_card_stats[MAX_DIRTY_RUN].add(percent_of(_max_dirty_run, _cards_in_cluster));\n+      _local_card_stats[MAX_CLEAN_RUN].add(percent_of(_max_clean_run, _cards_in_cluster));\n+\n+      \/\/ Update global stats for dirty obj scan counts\n+      _local_card_stats[DIRTY_SCAN_OBJS].add(_dirty_scan_obj_cnt);\n+\n+      \/\/ Update global stats for alternation counts\n+      _local_card_stats[ALTERNATIONS].add(_alternation_cnt);\n+    }\n+  }\n+\n+public:\n+  inline void record_dirty_run(size_t len) {\n+    if (ShenandoahEnableCardStats) {\n+      _alternation_cnt++;\n+      if (len > _max_dirty_run) {\n+        _max_dirty_run = len;\n+      }\n+      _dirty_card_cnt += len;\n+      assert(len <= _cards_in_cluster, \"Error\");\n+      _local_card_stats[DIRTY_RUN].add(percent_of(len, _cards_in_cluster));\n+    }\n+  }\n+\n+  inline void record_clean_run(size_t len) {\n+    if (ShenandoahEnableCardStats) {\n+      _alternation_cnt++;\n+      if (len > _max_clean_run) {\n+        _max_clean_run = len;\n+      }\n+      _clean_card_cnt += len;\n+      assert(len <= _cards_in_cluster, \"Error\");\n+      _local_card_stats[CLEAN_RUN].add(percent_of(len, _cards_in_cluster));\n+    }\n+  }\n+\n+  inline void record_scan_obj_cnt(size_t i) {\n+    if (ShenandoahEnableCardStats) {\n+      _dirty_scan_obj_cnt += i;\n+    }\n+  }\n+\n+  void log() const PRODUCT_RETURN;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"runtime\/init.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+\n+void ShenandoahCardTable::initialize() {\n+  size_t num_cards = cards_required(_whole_heap.word_size());\n+\n+  \/\/ each card takes 1 byte; + 1 for the guard card\n+  size_t num_bytes = num_cards + 1;\n+  const size_t granularity = os::vm_allocation_granularity();\n+  _byte_map_size = align_up(num_bytes, MAX2(_page_size, granularity));\n+\n+  HeapWord* low_bound  = _whole_heap.start();\n+  HeapWord* high_bound = _whole_heap.end();\n+\n+  \/\/ ReservedSpace constructor would assert rs_align >= os::vm_page_size().\n+  const size_t rs_align = _page_size == os::vm_page_size() ? 0 : MAX2(_page_size, granularity);\n+\n+  ReservedSpace write_space(_byte_map_size, rs_align, _page_size);\n+  initialize(write_space);\n+\n+  \/\/ The assembler store_check code will do an unsigned shift of the oop,\n+  \/\/ then add it to _byte_map_base, i.e.\n+  \/\/\n+  \/\/   _byte_map = _byte_map_base + (uintptr_t(low_bound) >> card_shift)\n+  _byte_map = (CardValue*) write_space.base();\n+  _byte_map_base = _byte_map - (uintptr_t(low_bound) >> _card_shift);\n+  assert(byte_for(low_bound) == &_byte_map[0], \"Checking start of map\");\n+  assert(byte_for(high_bound-1) <= &_byte_map[last_valid_index()], \"Checking end of map\");\n+\n+  _write_byte_map = _byte_map;\n+  _write_byte_map_base = _byte_map_base;\n+\n+  ReservedSpace read_space(_byte_map_size, rs_align, _page_size);\n+  initialize(read_space);\n+\n+  _read_byte_map = (CardValue*) read_space.base();\n+  _read_byte_map_base = _read_byte_map - (uintptr_t(low_bound) >> card_shift());\n+  assert(read_byte_for(low_bound) == &_read_byte_map[0], \"Checking start of map\");\n+  assert(read_byte_for(high_bound-1) <= &_read_byte_map[last_valid_index()], \"Checking end of map\");\n+\n+  _covered[0] = _whole_heap;\n+\n+  log_trace(gc, barrier)(\"ShenandoahCardTable::ShenandoahCardTable:\");\n+  log_trace(gc, barrier)(\"    &_write_byte_map[0]: \" INTPTR_FORMAT \"  &_write_byte_map[_last_valid_index]: \" INTPTR_FORMAT,\n+                         p2i(&_write_byte_map[0]), p2i(&_write_byte_map[last_valid_index()]));\n+  log_trace(gc, barrier)(\"    _write_byte_map_base: \" INTPTR_FORMAT, p2i(_write_byte_map_base));\n+  log_trace(gc, barrier)(\"    &_read_byte_map[0]: \" INTPTR_FORMAT \"  &_read_byte_map[_last_valid_index]: \" INTPTR_FORMAT,\n+                  p2i(&_read_byte_map[0]), p2i(&_read_byte_map[last_valid_index()]));\n+  log_trace(gc, barrier)(\"    _read_byte_map_base: \" INTPTR_FORMAT, p2i(_read_byte_map_base));\n+}\n+\n+void ShenandoahCardTable::initialize(const ReservedSpace& card_table) {\n+  MemTracker::record_virtual_memory_tag((address)card_table.base(), mtGC);\n+\n+  os::trace_page_sizes(\"Card Table\", _byte_map_size, _byte_map_size,\n+                       card_table.base(), card_table.size(), _page_size);\n+  if (!card_table.is_reserved()) {\n+    vm_exit_during_initialization(\"Could not reserve enough space for the card marking array\");\n+  }\n+  os::commit_memory_or_exit(card_table.base(), _byte_map_size, card_table.alignment(), false,\n+                            \"Cannot commit memory for card table\");\n+}\n+\n+bool ShenandoahCardTable::is_in_young(const void* obj) const {\n+  return ShenandoahHeap::heap()->is_in_young(obj);\n+}\n+\n+CardValue* ShenandoahCardTable::read_byte_for(const void* p) {\n+    CardValue* result = &_read_byte_map_base[uintptr_t(p) >> _card_shift];\n+    assert(result >= _read_byte_map && result < _read_byte_map + _byte_map_size,\n+           \"out of bounds accessor for card marking array\");\n+    return result;\n+}\n+\n+size_t ShenandoahCardTable::last_valid_index() {\n+  return CardTable::last_valid_index();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCARDTABLE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHCARDTABLE_HPP\n+\n+#include \"gc\/shared\/cardTable.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class ShenandoahCardTable: public CardTable {\n+  friend class VMStructs;\n+\n+private:\n+  \/\/ We maintain two copies of the card table to facilitate concurrent remembered set scanning\n+  \/\/ and concurrent clearing of stale remembered set information.  During the init_mark safepoint,\n+  \/\/ we copy the contents of _write_byte_map to _read_byte_map and clear _write_byte_map.\n+  \/\/\n+  \/\/ Concurrent remembered set scanning reads from _read_byte_map while concurrent mutator write\n+  \/\/ barriers are overwriting cards of the _write_byte_map with DIRTY codes.  Concurrent remembered\n+  \/\/ set scanning also overwrites cards of the _write_byte_map with DIRTY codes whenever it discovers\n+  \/\/ interesting pointers.\n+  \/\/\n+  \/\/ During a concurrent update-references phase, we scan the _write_byte_map concurrently to find\n+  \/\/ all old-gen references that may need to be updated.\n+  \/\/\n+  \/\/ In a future implementation, we may swap the values of _read_byte_map and _write_byte_map during\n+  \/\/ the init-mark safepoint to avoid the need for bulk STW copying and initialization.  Doing so\n+  \/\/ requires a change to the implementation of mutator write barriers as the address of the card\n+  \/\/ table is currently in-lined and hard-coded.\n+  CardValue* _read_byte_map;\n+  CardValue* _write_byte_map;\n+  CardValue* _read_byte_map_base;\n+  CardValue* _write_byte_map_base;\n+\n+public:\n+  explicit ShenandoahCardTable(MemRegion whole_heap) : CardTable(whole_heap),\n+    _read_byte_map(nullptr), _write_byte_map(nullptr),\n+    _read_byte_map_base(nullptr), _write_byte_map_base(nullptr) {}\n+\n+  void initialize();\n+\n+  bool is_in_young(const void* obj) const override;\n+\n+  CardValue* read_byte_for(const void* p);\n+\n+  size_t last_valid_index();\n+\n+  CardValue* read_byte_map() {\n+    return _read_byte_map;\n+  }\n+\n+  CardValue* write_byte_map() {\n+    return _write_byte_map;\n+  }\n+\n+  CardValue* write_byte_map_base() {\n+    return _write_byte_map_base;\n+  }\n+\n+private:\n+  void initialize(const ReservedSpace& card_table);\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCARDTABLE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+  ShenandoahObjToScanQueue* _old_queue;\n@@ -69,1 +70,1 @@\n-  inline ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp);\n+  inline ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q);\n@@ -92,2 +93,2 @@\n-  ShenandoahMarkRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-          ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+          ShenandoahMarkRefsSuperClosure(q, rp, old_q) {};\n@@ -194,1 +195,1 @@\n-  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp);\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -62,1 +63,3 @@\n-ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n+ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q,\n+                                                               ShenandoahReferenceProcessor* rp,\n+                                                               ShenandoahObjToScanQueue* old_q) :\n@@ -65,0 +68,1 @@\n+        _old_queue(old_q),\n@@ -70,1 +74,1 @@\n-  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _mark_context, _weak);\n+  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _old_queue, _mark_context, _weak);\n@@ -82,1 +86,1 @@\n-  return _mark_context->is_marked(obj);\n+  return _mark_context->is_marked_or_old(obj);\n@@ -93,1 +97,1 @@\n-  return _mark_context->is_marked(obj);\n+  return _mark_context->is_marked_or_old(obj);\n@@ -108,1 +112,1 @@\n-  assert(!ShenandoahHeap::heap()->has_forwarded_objects(), \"Not expected\");\n+  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress() || !ShenandoahHeap::heap()->has_forwarded_objects(), \"Not expected\");\n@@ -218,2 +222,4 @@\n-ShenandoahMarkUpdateRefsClosure<GENERATION>::ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-  ShenandoahMarkRefsSuperClosure(q, rp) {\n+ShenandoahMarkUpdateRefsClosure<GENERATION>::ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q,\n+                                                                             ShenandoahReferenceProcessor* rp,\n+                                                                             ShenandoahObjToScanQueue* old_q) :\n+  ShenandoahMarkRefsSuperClosure(q, rp, old_q) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -44,0 +46,1 @@\n+  _has_old_regions(false),\n@@ -46,0 +49,1 @@\n+  _live(0),\n@@ -47,0 +51,2 @@\n+  _old_garbage(0),\n+  _preselected_regions(nullptr),\n@@ -87,0 +93,2 @@\n+  assert(!r->is_humongous(), \"Only add regular regions to the collection set\");\n+\n@@ -88,0 +96,14 @@\n+  size_t live    = r->get_live_data_bytes();\n+  size_t garbage = r->garbage();\n+  size_t free    = r->free();\n+  if (r->is_young()) {\n+    _young_bytes_to_evacuate += live;\n+    _young_available_bytes_collected += free;\n+    if (ShenandoahHeap::heap()->mode()->is_generational() && r->age() >= ShenandoahGenerationalHeap::heap()->age_census()->tenuring_threshold()) {\n+      _young_bytes_to_promote += live;\n+    }\n+  } else if (r->is_old()) {\n+    _old_bytes_to_evacuate += live;\n+    _old_garbage += garbage;\n+  }\n+\n@@ -89,1 +111,2 @@\n-  _garbage += r->garbage();\n+  _has_old_regions |= r->is_old();\n+  _garbage += garbage;\n@@ -91,1 +114,1 @@\n-\n+  _live += live;\n@@ -98,0 +121,1 @@\n+\n@@ -107,0 +131,1 @@\n+  _old_garbage = 0;\n@@ -108,0 +133,1 @@\n+  _live = 0;\n@@ -111,0 +137,8 @@\n+\n+  _young_bytes_to_evacuate = 0;\n+  _young_bytes_to_promote = 0;\n+  _old_bytes_to_evacuate = 0;\n+\n+  _young_available_bytes_collected = 0;\n+\n+  _has_old_regions = false;\n@@ -154,1 +188,5 @@\n-  out->print_cr(\"Collection Set : \" SIZE_FORMAT \"\", count());\n+  out->print_cr(\"Collection Set: Regions: \"\n+                SIZE_FORMAT \", Garbage: \" SIZE_FORMAT \"%s, Live: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s\", count(),\n+                byte_size_in_proper_unit(garbage()), proper_unit_for_byte_size(garbage()),\n+                byte_size_in_proper_unit(live()),    proper_unit_for_byte_size(live()),\n+                byte_size_in_proper_unit(used()),    proper_unit_for_byte_size(used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -36,0 +37,8 @@\n+  friend class ShenandoahCollectionSetPreselector;\n+\n+  void establish_preselected(bool *preselected) {\n+   assert(_preselected_regions == nullptr, \"Over-writing\");\n+   _preselected_regions = preselected;\n+  }\n+  void abandon_preselected() { _preselected_regions = nullptr; }\n+\n@@ -46,0 +55,1 @@\n+  bool                  _has_old_regions;\n@@ -48,0 +58,1 @@\n+  size_t                _live;\n@@ -50,0 +61,16 @@\n+  size_t                _young_bytes_to_evacuate;\n+  size_t                _young_bytes_to_promote;\n+  size_t                _old_bytes_to_evacuate;\n+\n+  \/\/ How many bytes of old garbage are present in a mixed collection set?\n+  size_t                _old_garbage;\n+\n+  \/\/ Points to array identifying which tenure-age regions have been preselected\n+  \/\/ for inclusion in collection set. This field is only valid during brief\n+  \/\/ spans of time while collection set is being constructed.\n+  bool*                 _preselected_regions;\n+\n+  \/\/ When a region having memory available to be allocated is added to the collection set, the region's available memory\n+  \/\/ should be subtracted from what's available.\n+  size_t                _young_available_bytes_collected;\n+\n@@ -80,2 +107,25 @@\n-  size_t used()      const { return _used; }\n-  size_t garbage()   const { return _garbage;   }\n+  \/\/ It is not known how many of these bytes will be promoted.\n+  inline size_t get_young_bytes_reserved_for_evacuation();\n+  inline size_t get_old_bytes_reserved_for_evacuation();\n+\n+  inline size_t get_young_bytes_to_be_promoted();\n+\n+  size_t get_young_available_bytes_collected() { return _young_available_bytes_collected; }\n+\n+  inline size_t get_old_garbage();\n+\n+  bool is_preselected(size_t region_idx) {\n+    assert(_preselected_regions != nullptr, \"Missing etsablish after abandon\");\n+    return _preselected_regions[region_idx];\n+  }\n+\n+  bool* preselected_regions() {\n+    assert(_preselected_regions != nullptr, \"Null ptr\");\n+    return _preselected_regions;\n+  }\n+\n+  bool has_old_regions() const { return _has_old_regions; }\n+  size_t used()          const { return _used; }\n+  size_t live()          const { return _live; }\n+  size_t garbage()       const { return _garbage; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -56,0 +57,16 @@\n+size_t ShenandoahCollectionSet::get_old_bytes_reserved_for_evacuation() {\n+  return _old_bytes_to_evacuate;\n+}\n+\n+size_t ShenandoahCollectionSet::get_young_bytes_reserved_for_evacuation() {\n+  return _young_bytes_to_evacuate - _young_bytes_to_promote;\n+}\n+\n+size_t ShenandoahCollectionSet::get_young_bytes_to_be_promoted() {\n+  return _young_bytes_to_promote;\n+}\n+\n+size_t ShenandoahCollectionSet::get_old_garbage() {\n+  return _old_garbage;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCOLLECTIONSETPRESELECTOR_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHCOLLECTIONSETPRESELECTOR_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+class ShenandoahCollectionSetPreselector : public StackObj {\n+  ShenandoahCollectionSet* _cset;\n+  bool* _pset;\n+  ResourceMark _rm;\n+\n+public:\n+  ShenandoahCollectionSetPreselector(ShenandoahCollectionSet* cset, size_t num_regions):\n+    _cset(cset) {\n+    _pset = NEW_RESOURCE_ARRAY(bool, num_regions);\n+    for (unsigned int i = 0; i < num_regions; i++) {\n+        _pset[i] = false;\n+    }\n+    _cset->establish_preselected(_pset);\n+  }\n+\n+  ~ShenandoahCollectionSetPreselector() {\n+    _cset->abandon_preselected();\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCOLLECTIONSETPRESELECTOR_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSetPreselector.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -39,0 +40,4 @@\n+  _consecutive_young_gcs(0),\n+  _mixed_gcs(0),\n+  _success_old_gcs(0),\n+  _interrupted_old_gcs(0),\n@@ -69,1 +74,3 @@\n-void ShenandoahCollectorPolicy::record_success_concurrent(bool is_abbreviated) {\n+void ShenandoahCollectorPolicy::record_success_concurrent(bool is_young, bool is_abbreviated) {\n+  update_young(is_young);\n+\n@@ -77,1 +84,17 @@\n-void ShenandoahCollectorPolicy::record_success_degenerated(bool is_abbreviated) {\n+void ShenandoahCollectorPolicy::record_mixed_cycle() {\n+  _mixed_gcs++;\n+}\n+\n+void ShenandoahCollectorPolicy::record_success_old() {\n+  _consecutive_young_gcs = 0;\n+  _success_old_gcs++;\n+}\n+\n+void ShenandoahCollectorPolicy::record_interrupted_old() {\n+  _consecutive_young_gcs = 0;\n+  _interrupted_old_gcs++;\n+}\n+\n+void ShenandoahCollectorPolicy::record_success_degenerated(bool is_young, bool is_abbreviated) {\n+  update_young(is_young);\n+\n@@ -85,0 +108,8 @@\n+void ShenandoahCollectorPolicy::update_young(bool is_young) {\n+  if (is_young) {\n+    _consecutive_young_gcs++;\n+  } else {\n+    _consecutive_young_gcs = 0;\n+  }\n+}\n+\n@@ -87,0 +118,1 @@\n+  _consecutive_young_gcs = 0;\n@@ -104,1 +136,1 @@\n-  return cause != GCCause::_allocation_failure\n+  return cause != GCCause::_no_gc\n@@ -106,0 +138,1 @@\n+      && cause != GCCause::_allocation_failure\n@@ -123,0 +156,4 @@\n+bool ShenandoahCollectorPolicy::is_requested_gc(GCCause::Cause cause) {\n+  return is_explicit_gc(cause) || is_implicit_gc(cause);\n+}\n+\n@@ -144,1 +181,1 @@\n-  size_t completed_gcs = _success_full_gcs + _success_degenerated_gcs + _success_concurrent_gcs;\n+  size_t completed_gcs = _success_full_gcs + _success_degenerated_gcs + _success_concurrent_gcs + _success_old_gcs;\n@@ -174,0 +211,7 @@\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    out->print_cr(SIZE_FORMAT_W(5) \" Completed Old GCs (%.2f%%)\",        _success_old_gcs, percent_of(_success_old_gcs, completed_gcs));\n+    out->print_cr(\"  \" SIZE_FORMAT_W(5) \" mixed\",                        _mixed_gcs);\n+    out->print_cr(\"  \" SIZE_FORMAT_W(5) \" interruptions\",                _interrupted_old_gcs);\n+    out->cr();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahTrace.hpp\"\n@@ -34,5 +36,0 @@\n-class ShenandoahTracer : public GCTracer, public CHeapObj<mtGC> {\n-public:\n-  ShenandoahTracer() : GCTracer(Shenandoah) {}\n-};\n-\n@@ -48,0 +45,4 @@\n+  volatile size_t _consecutive_young_gcs;\n+  size_t _mixed_gcs;\n+  size_t _success_old_gcs;\n+  size_t _interrupted_old_gcs;\n@@ -61,0 +62,4 @@\n+  void record_mixed_cycle();\n+  void record_success_old();\n+  void record_interrupted_old();\n+\n@@ -66,2 +71,2 @@\n-  void record_success_concurrent(bool is_abbreviated);\n-  void record_success_degenerated(bool is_abbreviated);\n+  void record_success_concurrent(bool is_young, bool is_abbreviated);\n+  void record_success_degenerated(bool is_young, bool is_abbreviated);\n@@ -92,0 +97,1 @@\n+  static bool is_requested_gc(GCCause::Cause cause);\n@@ -94,0 +100,7 @@\n+\n+  inline size_t consecutive_young_gc_count() const {\n+    return _consecutive_young_gcs;\n+  }\n+\n+private:\n+  void update_young(bool is_young);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -36,0 +37,4 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -89,2 +94,3 @@\n-ShenandoahConcurrentGC::ShenandoahConcurrentGC() :\n-  _mark(),\n+ShenandoahConcurrentGC::ShenandoahConcurrentGC(ShenandoahGeneration* generation, bool do_old_gc_bootstrap) :\n+  _mark(generation),\n+  _generation(generation),\n@@ -92,1 +98,2 @@\n-  _abbreviated(false) {\n+  _abbreviated(false),\n+  _do_old_gc_bootstrap(do_old_gc_bootstrap) {\n@@ -99,4 +106,0 @@\n-void ShenandoahConcurrentGC::cancel() {\n-  ShenandoahConcurrentMark::cancel();\n-}\n-\n@@ -105,0 +108,1 @@\n+\n@@ -115,0 +119,9 @@\n+\n+    \/\/ Reset task queue stats here, rather than in mark_concurrent_roots,\n+    \/\/ because remembered set scan will `push` oops into the queues and\n+    \/\/ resetting after this happens will lose those counts.\n+    TASKQUEUE_STATS_ONLY(_mark.task_queues()->reset_taskqueue_stats());\n+\n+    \/\/ Concurrent remembered set scanning\n+    entry_scan_remembered_set();\n+\n@@ -117,1 +130,1 @@\n-    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_outside_cycle)) {\n+    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_roots)) {\n@@ -135,1 +148,1 @@\n-  if (heap->is_concurrent_mark_in_progress()) {\n+  if (_generation->is_concurrent_mark_in_progress()) {\n@@ -153,1 +166,2 @@\n-  \/\/ the space. This would be the last action if there is nothing to evacuate.\n+  \/\/ the space. This would be the last action if there is nothing to evacuate.  Note that\n+  \/\/ we will not age young-gen objects in the case that we skip evacuation.\n@@ -199,0 +213,17 @@\n+    \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n+    \/\/ However, there may still be regions to promote in place, so do that now.\n+    if (has_in_place_promotions(heap)) {\n+      entry_promote_in_place();\n+\n+      \/\/ If the promote-in-place operation was cancelled, we can have the degenerated\n+      \/\/ cycle complete the operation. It will see that no evacuations are in progress,\n+      \/\/ and that there are regions wanting promotion. The risk with not handling the\n+      \/\/ cancellation would be failing to restore top for these regions and leaving\n+      \/\/ them unable to serve allocations for the old generation.\n+      if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ At this point, the cycle is effectively complete. If the cycle has been cancelled here,\n+    \/\/ the control thread will detect it on its next iteration and run a degenerated young cycle.\n@@ -203,0 +234,5 @@\n+  \/\/ We defer generation resizing actions until after cset regions have been recycled.  We do this even following an\n+  \/\/ abbreviated cycle.\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahGenerationalHeap::heap()->complete_concurrent_cycle();\n+  }\n@@ -303,1 +339,1 @@\n-  static const char* msg = \"Pause Final Roots\";\n+  const char* msg = final_roots_event_message();\n@@ -312,0 +348,2 @@\n+  heap->try_inject_alloc_failure();\n+\n@@ -313,3 +351,10 @@\n-  static const char* msg = \"Concurrent reset\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset);\n-  EventMark em(\"%s\", msg);\n+  {\n+    const char* msg = conc_reset_event_message();\n+    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset);\n+    EventMark em(\"%s\", msg);\n+\n+    ShenandoahWorkerScope scope(heap->workers(),\n+                                ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                                msg);\n+    op_reset();\n+  }\n@@ -317,3 +362,7 @@\n-  ShenandoahWorkerScope scope(heap->workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n-                              \"concurrent reset\");\n+  if (_do_old_gc_bootstrap) {\n+    static const char* msg = \"Concurrent reset (Old)\";\n+    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_old);\n+    ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                                ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                                msg);\n+    EventMark em(\"%s\", msg);\n@@ -321,2 +370,19 @@\n-  heap->try_inject_alloc_failure();\n-  op_reset();\n+    heap->old_generation()->prepare_gc();\n+  }\n+}\n+\n+void ShenandoahConcurrentGC::entry_scan_remembered_set() {\n+  if (_generation->is_young()) {\n+    ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+    TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+    const char* msg = \"Concurrent remembered set scanning\";\n+    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::init_scan_rset);\n+    EventMark em(\"%s\", msg);\n+\n+    ShenandoahWorkerScope scope(heap->workers(),\n+                                ShenandoahWorkerPolicy::calc_workers_for_rs_scanning(),\n+                                msg);\n+\n+    heap->try_inject_alloc_failure();\n+    _generation->scan_remembered_set(true \/* is_concurrent *\/);\n+  }\n@@ -371,1 +437,1 @@\n-  static const char* msg = \"Concurrent weak references\";\n+  const char* msg = conc_weak_refs_event_message();\n@@ -386,1 +452,1 @@\n-  static const char* msg = \"Concurrent weak roots\";\n+  const char* msg = conc_weak_roots_event_message();\n@@ -433,1 +499,1 @@\n-  static const char* msg = \"Concurrent cleanup\";\n+  const char* msg = conc_cleanup_event_message();\n@@ -458,0 +524,17 @@\n+void ShenandoahConcurrentGC::entry_promote_in_place() {\n+  shenandoah_assert_generational();\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  static const char* msg = \"Promote in place\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::promote_in_place);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),\n+                              \"promote in place\");\n+\n+  ShenandoahGenerationalHeap::heap()->promote_regions_in_place(true);\n+}\n+\n@@ -489,1 +572,1 @@\n-  static const char* msg = \"Concurrent cleanup\";\n+  const char* msg = conc_cleanup_event_message();\n@@ -503,2 +586,1 @@\n-\n-  heap->prepare_gc();\n+  _generation->prepare_gc();\n@@ -517,1 +599,2 @@\n-      \/\/ reset, so it is very likely we don't need to do another write here.\n+      \/\/ reset, so it is very likely we don't need to do another write here.  Since most regions\n+      \/\/ are not \"active\", this path is relatively rare.\n@@ -539,2 +622,2 @@\n-  assert(heap->marking_context()->is_bitmap_clear(), \"need clear marking bitmap\");\n-  assert(!heap->marking_context()->is_complete(), \"should not be complete\");\n+  assert(_generation->is_bitmap_clear(), \"need clear marking bitmap\");\n+  assert(!_generation->is_mark_complete(), \"should not be complete\");\n@@ -543,0 +626,19 @@\n+\n+  if (heap->mode()->is_generational()) {\n+    if (_generation->is_young()) {\n+      \/\/ The current implementation of swap_remembered_set() copies the write-card-table to the read-card-table.\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_swap_rset);\n+      _generation->swap_remembered_set();\n+    }\n+\n+    if (_generation->is_global()) {\n+      heap->old_generation()->cancel_gc();\n+    } else if (heap->is_concurrent_old_mark_in_progress()) {\n+      \/\/ Purge the SATB buffers, transferring any valid, old pointers to the\n+      \/\/ old generation mark queue. Any pointers in a young region will be\n+      \/\/ abandoned.\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_transfer_satb);\n+      heap->old_generation()->transfer_pointers_from_satb();\n+    }\n+  }\n+\n@@ -551,1 +653,1 @@\n-  heap->set_concurrent_mark_in_progress(true);\n+  _generation->set_concurrent_mark_in_progress(true);\n@@ -555,1 +657,3 @@\n-  {\n+  if (_do_old_gc_bootstrap) {\n+    shenandoah_assert_generational();\n+    \/\/ Update region state for both young and old regions\n@@ -559,0 +663,6 @@\n+    heap->old_generation()->ref_processor()->reset_thread_locals();\n+  } else {\n+    \/\/ Update region state for only young regions\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_region_states);\n+    ShenandoahInitMarkUpdateRegionStateClosure cl;\n+    _generation->parallel_heap_region_iterate(&cl);\n@@ -562,1 +672,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n@@ -602,1 +712,4 @@\n-    heap->prepare_regions_and_collection_set(true \/*concurrent*\/);\n+    \/\/ The collection set is chosen by prepare_regions_and_collection_set(). Additionally, certain parameters have been\n+    \/\/ established to govern the evacuation efforts that are about to begin.  Refer to comments on reserve members in\n+    \/\/ ShenandoahGeneration and ShenandoahOldGeneration for more detail.\n+    _generation->prepare_regions_and_collection_set(true \/*concurrent*\/);\n@@ -608,0 +721,7 @@\n+      LogTarget(Debug, gc, cset) lt;\n+      if (lt.is_enabled()) {\n+        ResourceMark rm;\n+        LogStream ls(lt);\n+        heap->collection_set()->print_on(&ls);\n+      }\n+\n@@ -625,1 +745,5 @@\n-        heap->verifier()->verify_after_concmark();\n+        if (has_in_place_promotions(heap)) {\n+          heap->verifier()->verify_after_concmark_with_promotions();\n+        } else {\n+          heap->verifier()->verify_after_concmark();\n+        }\n@@ -635,0 +759,5 @@\n+bool ShenandoahConcurrentGC::has_in_place_promotions(ShenandoahHeap* heap) {\n+  return heap->mode()->is_generational() && heap->old_generation()->has_in_place_promotions();\n+}\n+\n+template<bool GENERATIONAL>\n@@ -638,1 +767,0 @@\n-\n@@ -640,3 +768,1 @@\n-  ShenandoahConcurrentEvacThreadClosure(OopClosure* oops);\n-  void do_thread(Thread* thread);\n-};\n+  explicit ShenandoahConcurrentEvacThreadClosure(OopClosure* oops) : _oops(oops) {}\n@@ -644,8 +770,8 @@\n-ShenandoahConcurrentEvacThreadClosure::ShenandoahConcurrentEvacThreadClosure(OopClosure* oops) :\n-  _oops(oops) {\n-}\n-\n-void ShenandoahConcurrentEvacThreadClosure::do_thread(Thread* thread) {\n-  JavaThread* const jt = JavaThread::cast(thread);\n-  StackWatermarkSet::finish_processing(jt, _oops, StackWatermarkKind::gc);\n-}\n+  void do_thread(Thread* thread) override {\n+    JavaThread* const jt = JavaThread::cast(thread);\n+    StackWatermarkSet::finish_processing(jt, _oops, StackWatermarkKind::gc);\n+    if (GENERATIONAL) {\n+      ShenandoahThreadLocalData::enable_plab_promotions(thread);\n+    }\n+  }\n+};\n@@ -653,0 +779,1 @@\n+template<bool GENERATIONAL>\n@@ -658,1 +785,1 @@\n-  ShenandoahConcurrentEvacUpdateThreadTask(uint n_workers) :\n+  explicit ShenandoahConcurrentEvacUpdateThreadTask(uint n_workers) :\n@@ -663,1 +790,6 @@\n-  void work(uint worker_id) {\n+  void work(uint worker_id) override {\n+    if (GENERATIONAL) {\n+      Thread* worker_thread = Thread::current();\n+      ShenandoahThreadLocalData::enable_plab_promotions(worker_thread);\n+    }\n+\n@@ -667,1 +799,1 @@\n-    ShenandoahConcurrentEvacThreadClosure thr_cl(&oops_cl);\n+    ShenandoahConcurrentEvacThreadClosure<GENERATIONAL> thr_cl(&oops_cl);\n@@ -676,2 +808,7 @@\n-  ShenandoahConcurrentEvacUpdateThreadTask task(heap->workers()->active_workers());\n-  heap->workers()->run_task(&task);\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahConcurrentEvacUpdateThreadTask<true> task(heap->workers()->active_workers());\n+    heap->workers()->run_task(&task);\n+  } else {\n+    ShenandoahConcurrentEvacUpdateThreadTask<false> task(heap->workers()->active_workers());\n+    heap->workers()->run_task(&task);\n+  }\n@@ -688,1 +825,1 @@\n-  heap->ref_processor()->process_references(ShenandoahPhaseTimings::conc_weak_refs, heap->workers(), true \/* concurrent *\/);\n+  _generation->ref_processor()->process_references(ShenandoahPhaseTimings::conc_weak_refs, heap->workers(), true \/* concurrent *\/);\n@@ -715,2 +852,5 @@\n-      \/\/ Note: The obj is dead here. Do not touch it, just clear.\n-      ShenandoahHeap::atomic_clear_oop(p, obj);\n+      shenandoah_assert_generations_reconciled();\n+      if (_heap->is_in_active_generation(obj)) {\n+        \/\/ Note: The obj is dead here. Do not touch it, just clear.\n+        ShenandoahHeap::atomic_clear_oop(p, obj);\n+      }\n@@ -822,0 +962,3 @@\n+  \/\/ We can only toggle concurrent_weak_root_in_progress flag\n+  \/\/ at a safepoint, so that mutators see a consistent\n+  \/\/ value. The flag will be cleared at the next safepoint.\n@@ -918,0 +1061,1 @@\n+  heap->set_update_refs_in_progress(true);\n@@ -921,2 +1065,0 @@\n-\n-  heap->set_update_refs_in_progress(true);\n@@ -970,1 +1112,1 @@\n-    heap->clear_cancelled_gc();\n+    heap->clear_cancelled_gc(true \/* clear oom handler *\/);\n@@ -978,0 +1120,2 @@\n+  \/\/ If we are running in generational mode and this is an aging cycle, this will also age active\n+  \/\/ regions that haven't been used for allocation.\n@@ -983,0 +1127,22 @@\n+  if (heap->mode()->is_generational() && heap->is_concurrent_old_mark_in_progress()) {\n+    \/\/ When the SATB barrier is left on to support concurrent old gen mark, it may pick up writes to\n+    \/\/ objects in the collection set. After those objects are evacuated, the pointers in the\n+    \/\/ SATB are no longer safe. Once we have finished update references, we are guaranteed that\n+    \/\/ no more writes to the collection set are possible.\n+    \/\/\n+    \/\/ This will transfer any old pointers in _active_ regions from the SATB to the old gen\n+    \/\/ mark queues. All other pointers will be discarded. This would also discard any pointers\n+    \/\/ in old regions that were included in a mixed evacuation. We aren't using the SATB filter\n+    \/\/ methods here because we cannot control when they execute. If the SATB filter runs _after_\n+    \/\/ a region has been recycled, we will not be able to detect the bad pointer.\n+    \/\/\n+    \/\/ We are not concerned about skipping this step in abbreviated cycles because regions\n+    \/\/ with no live objects cannot have been written to and so cannot have entries in the SATB\n+    \/\/ buffers.\n+    heap->old_generation()->transfer_pointers_from_satb();\n+\n+    \/\/ Aging_cycle is only relevant during evacuation cycle for individual objects and during final mark for\n+    \/\/ entire regions.  Both of these relevant operations occur before final update refs.\n+    ShenandoahGenerationalHeap::heap()->set_aging_cycle(false);\n+  }\n+\n@@ -995,1 +1161,17 @@\n-  ShenandoahHeap::heap()->set_concurrent_weak_root_in_progress(false);\n+\n+  ShenandoahHeap *heap = ShenandoahHeap::heap();\n+  heap->set_concurrent_weak_root_in_progress(false);\n+  heap->set_evacuation_in_progress(false);\n+\n+  if (heap->mode()->is_generational()) {\n+    \/\/ If the cycle was shortened for having enough immediate garbage, this could be\n+    \/\/ the last GC safepoint before concurrent marking of old resumes. We must be sure\n+    \/\/ that old mark threads don't see any pointers to garbage in the SATB buffers.\n+    if (heap->is_concurrent_old_mark_in_progress()) {\n+      heap->old_generation()->transfer_pointers_from_satb();\n+    }\n+\n+    if (!_generation->is_old()) {\n+      ShenandoahGenerationalHeap::heap()->update_region_ages(_generation->complete_marking_context());\n+    }\n+  }\n@@ -1014,1 +1196,1 @@\n-    return \"Pause Init Mark (unload classes)\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Init Mark\", \" (unload classes)\");\n@@ -1016,1 +1198,1 @@\n-    return \"Pause Init Mark\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Init Mark\", \"\");\n@@ -1022,1 +1204,3 @@\n-  assert(!heap->has_forwarded_objects(), \"Should not have forwarded objects here\");\n+  assert(!heap->has_forwarded_objects() || heap->is_concurrent_old_mark_in_progress(),\n+         \"Should not have forwarded objects during final mark, unless old gen concurrent mark is running\");\n+\n@@ -1024,1 +1208,1 @@\n-    return \"Pause Final Mark (unload classes)\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Final Mark\", \" (unload classes)\");\n@@ -1026,1 +1210,1 @@\n-    return \"Pause Final Mark\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Final Mark\", \"\");\n@@ -1032,1 +1216,2 @@\n-  assert(!heap->has_forwarded_objects(), \"Should not have forwarded objects here\");\n+  assert(!heap->has_forwarded_objects() || heap->is_concurrent_old_mark_in_progress(),\n+         \"Should not have forwarded objects concurrent mark, unless old gen concurrent mark is running\");\n@@ -1034,1 +1219,41 @@\n-    return \"Concurrent marking (unload classes)\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent marking\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent marking\", \"\");\n+  }\n+}\n+\n+const char* ShenandoahConcurrentGC::conc_reset_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent reset\", \"\");\n+  }\n+}\n+\n+const char* ShenandoahConcurrentGC::final_roots_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Final Roots\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Final Roots\", \"\");\n+  }\n+}\n+\n+const char* ShenandoahConcurrentGC::conc_weak_refs_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent weak references\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent weak references\", \"\");\n+  }\n+}\n+\n+const char* ShenandoahConcurrentGC::conc_weak_roots_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent weak roots\", \" (unload classes)\");\n+  } else {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent weak roots\", \"\");\n+  }\n+}\n+\n+const char* ShenandoahConcurrentGC::conc_cleanup_event_message() const {\n+  if (ShenandoahHeap::heap()->unload_classes()) {\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent cleanup\", \" (unload classes)\");\n@@ -1036,1 +1261,1 @@\n-    return \"Concurrent marking\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Concurrent cleanup\", \"\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":290,"deletions":65,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,0 +34,2 @@\n+class ShenandoahGeneration;\n+\n@@ -45,0 +48,4 @@\n+protected:\n+  ShenandoahConcurrentMark    _mark;\n+  ShenandoahGeneration* const _generation;\n+\n@@ -46,3 +53,3 @@\n-  ShenandoahConcurrentMark  _mark;\n-  ShenandoahDegenPoint      _degen_point;\n-  bool                      _abbreviated;\n+  ShenandoahDegenPoint        _degen_point;\n+  bool                        _abbreviated;\n+  const bool                  _do_old_gc_bootstrap;\n@@ -51,2 +58,2 @@\n-  ShenandoahConcurrentGC();\n-  bool collect(GCCause::Cause cause);\n+  ShenandoahConcurrentGC(ShenandoahGeneration* generation, bool do_old_gc_bootstrap);\n+  bool collect(GCCause::Cause cause) override;\n@@ -58,3 +65,1 @@\n-  \/\/ Cancel ongoing concurrent GC\n-  static void cancel();\n-private:\n+protected:\n@@ -81,0 +86,1 @@\n+  void entry_scan_remembered_set();\n@@ -93,0 +99,3 @@\n+  \/\/ Called when the collection set is empty, but the generational mode has regions to promote in place\n+  void entry_promote_in_place();\n+\n@@ -98,1 +107,1 @@\n-  void op_final_mark();\n+  virtual void op_final_mark();\n@@ -113,0 +122,4 @@\n+  \/\/ Check GC cancellation and abort concurrent GC\n+  bool check_cancellation_and_abort(ShenandoahDegenPoint point);\n+\n+private:\n@@ -115,0 +128,2 @@\n+  static bool has_in_place_promotions(ShenandoahHeap* heap) ;\n+\n@@ -119,0 +134,1 @@\n+  const char* final_roots_event_message() const;\n@@ -120,3 +136,4 @@\n-\n-  \/\/ Check GC cancellation and abort concurrent GC\n-  bool check_cancellation_and_abort(ShenandoahDegenPoint point);\n+  const char* conc_reset_event_message() const;\n+  const char* conc_weak_refs_event_message() const;\n+  const char* conc_weak_roots_event_message() const;\n+  const char* conc_cleanup_event_message() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -60,0 +63,1 @@\n+    ShenandoahWorkerTimingsTracker timer(ShenandoahPhaseTimings::conc_mark, ShenandoahPhaseTimings::ParallelMark, worker_id, true);\n@@ -61,1 +65,5 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+    \/\/ Do not use active_generation() : we must use the gc_generation() set by\n+    \/\/ ShenandoahGCScope on the ControllerThread's stack; no safepoint may\n+    \/\/ intervene to update active_generation, so we can't\n+    \/\/ shenandoah_assert_generations_reconciled() here.\n+    ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n@@ -100,1 +108,0 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n@@ -102,0 +109,2 @@\n+    ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n+    shenandoah_assert_generations_reconciled();\n@@ -106,0 +115,1 @@\n+      ShenandoahObjToScanQueue* old_q = _cm->get_old_queue(worker_id);\n@@ -107,1 +117,1 @@\n-      ShenandoahSATBBufferClosure<GENERATION> cl(q);\n+      ShenandoahSATBBufferClosure<GENERATION> cl(q, old_q);\n@@ -122,2 +132,2 @@\n-ShenandoahConcurrentMark::ShenandoahConcurrentMark() :\n-  ShenandoahMark() {}\n+ShenandoahConcurrentMark::ShenandoahConcurrentMark(ShenandoahGeneration* generation) :\n+  ShenandoahMark(generation) {}\n@@ -132,0 +142,1 @@\n+  ShenandoahObjToScanQueueSet* const  _old_queue_set;\n@@ -136,0 +147,1 @@\n+                                    ShenandoahObjToScanQueueSet* old,\n@@ -144,3 +156,4 @@\n-                                                                     ShenandoahReferenceProcessor* rp,\n-                                                                     ShenandoahPhaseTimings::Phase phase,\n-                                                                     uint nworkers) :\n+                                                                                 ShenandoahObjToScanQueueSet* old,\n+                                                                                 ShenandoahReferenceProcessor* rp,\n+                                                                                 ShenandoahPhaseTimings::Phase phase,\n+                                                                                 uint nworkers) :\n@@ -150,0 +163,1 @@\n+  _old_queue_set(old),\n@@ -158,1 +172,3 @@\n-  ShenandoahMarkRefsClosure<GENERATION> cl(q, _rp);\n+  ShenandoahObjToScanQueue* old_q = (_old_queue_set == nullptr) ?\n+          nullptr : _old_queue_set->queue(worker_id);\n+  ShenandoahMarkRefsClosure<GENERATION> cl(q, _rp, old_q);\n@@ -166,2 +182,0 @@\n-  TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n-\n@@ -169,5 +183,31 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n-  task_queues()->reserve(workers->active_workers());\n-  ShenandoahMarkConcurrentRootsTask<NON_GEN> task(task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n-\n-  workers->run_task(&task);\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+  _generation->reserve_task_queues(workers->active_workers());\n+  switch (_generation->type()) {\n+    case YOUNG: {\n+      ShenandoahMarkConcurrentRootsTask<YOUNG> task(task_queues(), old_task_queues(), rp,\n+                                                    ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      workers->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL: {\n+      assert(old_task_queues() == nullptr, \"Global mark should not have old gen mark queues\");\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL> task(task_queues(), nullptr, rp,\n+                                                     ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      workers->run_task(&task);\n+      break;\n+    }\n+    case NON_GEN: {\n+      assert(old_task_queues() == nullptr, \"Non-generational mark should not have old gen mark queues\");\n+      ShenandoahMarkConcurrentRootsTask<NON_GEN> task(task_queues(), nullptr, rp,\n+                                                      ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      workers->run_task(&task);\n+      break;\n+    }\n+    case OLD: {\n+      \/\/ We use a YOUNG generation cycle to bootstrap concurrent old marking.\n+      ShouldNotReachHere();\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -195,0 +235,1 @@\n+  ShenandoahGenerationType gen_type = _generation->type();\n@@ -198,3 +239,28 @@\n-    TaskTerminator terminator(nworkers, task_queues());\n-    ShenandoahConcurrentMarkingTask<NON_GEN> task(this, &terminator);\n-    workers->run_task(&task);\n+    switch (gen_type) {\n+      case YOUNG: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<YOUNG> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      case OLD: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<OLD> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      case GLOBAL: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<GLOBAL> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      case NON_GEN: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<NON_GEN> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -229,3 +295,2 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  heap->set_concurrent_mark_in_progress(false);\n-  heap->mark_complete_marking_context();\n+  _generation->set_concurrent_mark_in_progress(false);\n+  _generation->set_mark_complete();\n@@ -251,2 +316,0 @@\n-  ShenandoahFinalMarkingTask<NON_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n-  heap->workers()->run_task(&task);\n@@ -254,2 +317,24 @@\n-  assert(task_queues()->is_empty(), \"Should be empty\");\n-}\n+  switch (_generation->type()) {\n+    case YOUNG:{\n+      ShenandoahFinalMarkingTask<YOUNG> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    case OLD:{\n+      ShenandoahFinalMarkingTask<OLD> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL:{\n+      ShenandoahFinalMarkingTask<GLOBAL> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    case NON_GEN:{\n+      ShenandoahFinalMarkingTask<NON_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -258,4 +343,1 @@\n-void ShenandoahConcurrentMark::cancel() {\n-  clear();\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n-  rp->abandon_partial_discovery();\n+  assert(task_queues()->is_empty(), \"Should be empty\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":112,"deletions":30,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class ShenandoahGeneration;\n@@ -41,1 +42,2 @@\n-  ShenandoahConcurrentMark();\n+  ShenandoahConcurrentMark(ShenandoahGeneration* generation);\n+\n@@ -44,0 +46,1 @@\n+\n@@ -46,0 +49,1 @@\n+\n@@ -49,2 +53,0 @@\n-  static void cancel();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -88,1 +89,1 @@\n-      log_info(gc)(\"Trigger: Handle Allocation Failure\");\n+      heuristics->log_trigger(\"Handle Allocation Failure\");\n@@ -107,1 +108,1 @@\n-      log_info(gc)(\"Trigger: GC request (%s)\", GCCause::to_string(cause));\n+      heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(cause));\n@@ -318,1 +319,1 @@\n-  ShenandoahGCSession session(cause);\n+  ShenandoahGCSession session(cause, heap->global_generation());\n@@ -322,1 +323,1 @@\n-  ShenandoahConcurrentGC gc;\n+  ShenandoahConcurrentGC gc(heap->global_generation(), false);\n@@ -326,2 +327,3 @@\n-    heap->heuristics()->record_success_concurrent();\n-    heap->shenandoah_policy()->record_success_concurrent(gc.abbreviated());\n+    heap->global_generation()->heuristics()->record_success_concurrent();\n+    heap->shenandoah_policy()->record_success_concurrent(false, gc.abbreviated());\n+    heap->log_heap_status(\"At end of GC\");\n@@ -331,0 +333,1 @@\n+    heap->log_heap_status(\"At end of cancelled GC\");\n@@ -353,0 +356,1 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -354,1 +358,1 @@\n-  ShenandoahGCSession session(cause);\n+  ShenandoahGCSession session(cause, heap->global_generation());\n@@ -362,1 +366,1 @@\n-\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -364,1 +368,1 @@\n-  ShenandoahGCSession session(cause);\n+  ShenandoahGCSession session(cause, heap->global_generation());\n@@ -366,1 +370,1 @@\n-  ShenandoahDegenGC gc(point);\n+  ShenandoahDegenGC gc(point, heap->global_generation());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,2 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -35,0 +38,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -39,0 +43,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -44,1 +49,1 @@\n-ShenandoahDegenGC::ShenandoahDegenGC(ShenandoahDegenPoint degen_point) :\n+ShenandoahDegenGC::ShenandoahDegenGC(ShenandoahDegenPoint degen_point, ShenandoahGeneration* generation) :\n@@ -47,0 +52,1 @@\n+  _generation(generation),\n@@ -52,0 +58,7 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational()) {\n+    bool is_bootstrap_gc = heap->old_generation()->is_bootstrapping();\n+    heap->mmu_tracker()->record_degenerated(GCId::current(), is_bootstrap_gc);\n+    const char* msg = is_bootstrap_gc? \"At end of Degenerated Bootstrap Old GC\": \"At end of Degenerated Young GC\";\n+    heap->log_heap_status(msg);\n+  }\n@@ -67,1 +80,0 @@\n-\n@@ -82,1 +94,20 @@\n-  heap->clear_cancelled_gc();\n+  heap->clear_cancelled_gc(true \/* clear oom handler *\/);\n+\n+#ifdef ASSERT\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahOldGeneration* old_generation = heap->old_generation();\n+    if (!heap->is_concurrent_old_mark_in_progress()) {\n+      \/\/ If we are not marking the old generation, there should be nothing in the old mark queues\n+      assert(old_generation->task_queues()->is_empty(), \"Old gen task queues should be empty\");\n+    }\n+\n+    if (_generation->is_global()) {\n+      \/\/ If we are in a global cycle, the old generation should not be marking. It is, however,\n+      \/\/ allowed to be holding regions for evacuation or coalescing.\n+      assert(old_generation->is_idle()\n+             || old_generation->is_doing_mixed_evacuations()\n+             || old_generation->is_preparing_for_mark(),\n+             \"Old generation cannot be in state: %s\", old_generation->state_name());\n+    }\n+  }\n+#endif\n@@ -98,7 +129,0 @@\n-      \/\/\n-\n-      \/\/ Degenerated from concurrent root mark, reset the flag for STW mark\n-      if (heap->is_concurrent_mark_in_progress()) {\n-        ShenandoahConcurrentMark::cancel();\n-        heap->set_concurrent_mark_in_progress(false);\n-      }\n@@ -108,1 +132,42 @@\n-      heap->set_unload_classes(heap->heuristics()->can_unload_classes());\n+      heap->set_unload_classes(_generation->heuristics()->can_unload_classes() &&\n+                                (!heap->mode()->is_generational() || _generation->is_global()));\n+\n+      if (heap->mode()->is_generational() && _generation->is_young()) {\n+        \/\/ Swap remembered sets for young\n+        _generation->swap_remembered_set();\n+      }\n+\n+    case _degenerated_roots:\n+      \/\/ Degenerated from concurrent root mark, reset the flag for STW mark\n+      if (!heap->mode()->is_generational()) {\n+        if (heap->is_concurrent_mark_in_progress()) {\n+          heap->cancel_concurrent_mark();\n+        }\n+      } else {\n+        if (_generation->is_concurrent_mark_in_progress()) {\n+          \/\/ We want to allow old generation marking to be punctuated by young collections\n+          \/\/ (even if they have degenerated). If this is a global cycle, we'd have cancelled\n+          \/\/ the entire old gc before coming into this switch. Note that cancel_marking on\n+          \/\/ the generation does NOT abandon incomplete SATB buffers as cancel_concurrent_mark does.\n+          \/\/ We need to separate out the old pointers which is done below.\n+          _generation->cancel_marking();\n+        }\n+\n+        if (heap->is_concurrent_mark_in_progress()) {\n+          \/\/ If either old or young marking is in progress, the SATB barrier will be enabled.\n+          \/\/ The SATB buffer may hold a mix of old and young pointers. The old pointers need to be\n+          \/\/ transferred to the old generation mark queues and the young pointers are NOT part\n+          \/\/ of this snapshot, so they must be dropped here. It is safe to drop them here because\n+          \/\/ we will rescan the roots on this safepoint.\n+          heap->old_generation()->transfer_pointers_from_satb();\n+        }\n+\n+        if (_degen_point == ShenandoahDegenPoint::_degenerated_roots) {\n+          \/\/ We only need this if the concurrent cycle has already swapped the card tables.\n+          \/\/ Marking will use the 'read' table, but interesting pointers may have been\n+          \/\/ recorded in the 'write' table in the time between the cancelled concurrent cycle\n+          \/\/ and this degenerated cycle. These pointers need to be included the 'read' table\n+          \/\/ used to scan the remembered set during the STW mark which follows here.\n+          _generation->merge_write_table();\n+        }\n+      }\n@@ -172,1 +237,0 @@\n-\n@@ -189,0 +253,4 @@\n+      } else if (has_in_place_promotions(heap)) {\n+        \/\/ We have nothing to evacuate, but there are still regions to promote in place.\n+        ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_promote_regions);\n+        ShenandoahGenerationalHeap::heap()->promote_regions_in_place(false \/* concurrent*\/);\n@@ -191,0 +259,5 @@\n+      \/\/ Update collector state regardless of whether there are forwarded objects\n+      heap->set_evacuation_in_progress(false);\n+      heap->set_concurrent_weak_root_in_progress(false);\n+      heap->set_concurrent_strong_root_in_progress(false);\n+\n@@ -212,0 +285,5 @@\n+\n+      if (heap->mode()->is_generational()) {\n+        ShenandoahGenerationalHeap::heap()->complete_degenerated_cycle();\n+      }\n+\n@@ -234,2 +312,2 @@\n-    heap->shenandoah_policy()->record_success_degenerated(_abbreviated);\n-    heap->heuristics()->record_success_degenerated();\n+    heap->shenandoah_policy()->record_success_degenerated(_generation->is_young(), _abbreviated);\n+    _generation->heuristics()->record_success_degenerated();\n@@ -240,1 +318,1 @@\n-  ShenandoahHeap::heap()->prepare_gc();\n+  _generation->prepare_gc();\n@@ -244,1 +322,1 @@\n-  assert(!ShenandoahHeap::heap()->is_concurrent_mark_in_progress(), \"Should be reset\");\n+  assert(!_generation->is_concurrent_mark_in_progress(), \"Should be reset\");\n@@ -246,2 +324,1 @@\n-  ShenandoahSTWMark mark(false \/*full gc*\/);\n-  mark.clear();\n+  ShenandoahSTWMark mark(_generation, false \/*full gc*\/);\n@@ -252,1 +329,1 @@\n-  ShenandoahConcurrentMark mark;\n+  ShenandoahConcurrentMark mark(_generation);\n@@ -264,0 +341,1 @@\n+\n@@ -265,1 +343,1 @@\n-  heap->prepare_regions_and_collection_set(false \/*concurrent*\/);\n+  _generation->prepare_regions_and_collection_set(false \/*concurrent*\/);\n@@ -286,1 +364,5 @@\n-      heap->verifier()->verify_after_concmark();\n+      if (has_in_place_promotions(heap)) {\n+        heap->verifier()->verify_after_concmark_with_promotions();\n+      } else {\n+        heap->verifier()->verify_after_concmark();\n+      }\n@@ -295,0 +377,4 @@\n+bool ShenandoahDegenGC::has_in_place_promotions(const ShenandoahHeap* heap) const {\n+  return heap->mode()->is_generational() && heap->old_generation()->has_in_place_promotions();\n+}\n+\n@@ -307,4 +393,0 @@\n-  heap->set_evacuation_in_progress(false);\n-  heap->set_concurrent_weak_root_in_progress(false);\n-  heap->set_concurrent_strong_root_in_progress(false);\n-\n@@ -359,1 +441,1 @@\n-      return \"Pause Degenerated GC (<UNSET>)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Degenerated GC\", \" (<UNSET>)\");\n@@ -361,1 +443,3 @@\n-      return \"Pause Degenerated GC (Outside of Cycle)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Degenerated GC\", \" (Outside of Cycle)\");\n+    case _degenerated_roots:\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Degenerated GC\", \" (Roots)\");\n@@ -363,1 +447,1 @@\n-      return \"Pause Degenerated GC (Mark)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Degenerated GC\", \" (Mark)\");\n@@ -365,1 +449,1 @@\n-      return \"Pause Degenerated GC (Evacuation)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Degenerated GC\", \" (Evacuation)\");\n@@ -367,1 +451,1 @@\n-      return \"Pause Degenerated GC (Update Refs)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Degenerated GC\", \" (Update Refs)\");\n@@ -370,1 +454,1 @@\n-      return \"ERROR\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(_generation->type(), \"Pause Degenerated GC\", \" (?)\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":115,"deletions":31,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class ShenandoahGeneration;\n@@ -36,0 +37,1 @@\n+  ShenandoahGeneration* _generation;\n@@ -39,1 +41,1 @@\n-  ShenandoahDegenGC(ShenandoahDegenPoint degen_point);\n+  ShenandoahDegenGC(ShenandoahDegenPoint degen_point, ShenandoahGeneration* generation);\n@@ -67,0 +69,2 @@\n+\n+  bool has_in_place_promotions(const ShenandoahHeap* heap) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHEVACINFO_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHEVACINFO_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class ShenandoahEvacuationInformation : public StackObj {\n+  \/\/ Values for ShenandoahEvacuationInformation jfr event, sizes stored as bytes\n+  size_t _collection_set_regions;\n+  size_t _collection_set_used_before;\n+  size_t _collection_set_used_after;\n+  size_t _collected_old;\n+  size_t _collected_promoted;\n+  size_t _collected_young;\n+  size_t _regions_promoted_humongous;\n+  size_t _regions_promoted_regular;\n+  size_t _regular_promoted_garbage;\n+  size_t _regular_promoted_free;\n+  size_t _regions_freed;\n+  size_t _regions_immediate;\n+  size_t _immediate_size;\n+\n+public:\n+  ShenandoahEvacuationInformation() :\n+    _collection_set_regions(0), _collection_set_used_before(0), _collection_set_used_after(0),\n+    _collected_old(0), _collected_promoted(0), _collected_young(0), _regions_promoted_humongous(0),\n+    _regions_promoted_regular(0), _regular_promoted_garbage(0), _regular_promoted_free(0),\n+    _regions_freed(0), _regions_immediate(0), _immediate_size(0) { }\n+\n+  void set_collection_set_regions(size_t collection_set_regions) {\n+    _collection_set_regions = collection_set_regions;\n+  }\n+\n+  void set_collection_set_used_before(size_t used) {\n+    _collection_set_used_before = used;\n+  }\n+\n+  void set_collection_set_used_after(size_t used) {\n+    _collection_set_used_after = used;\n+  }\n+\n+  void set_collected_old(size_t collected) {\n+    _collected_old = collected;\n+  }\n+\n+  void set_collected_promoted(size_t collected) {\n+    _collected_promoted = collected;\n+  }\n+\n+  void set_collected_young(size_t collected) {\n+    _collected_young = collected;\n+  }\n+\n+  void set_regions_freed(size_t freed) {\n+    _regions_freed = freed;\n+  }\n+\n+  void set_regions_promoted_humongous(size_t humongous) {\n+    _regions_promoted_humongous = humongous;\n+  }\n+\n+  void set_regions_promoted_regular(size_t regular) {\n+    _regions_promoted_regular = regular;\n+  }\n+\n+  void set_regular_promoted_garbage(size_t garbage) {\n+    _regular_promoted_garbage = garbage;\n+  }\n+\n+  void set_regular_promoted_free(size_t free) {\n+    _regular_promoted_free = free;\n+  }\n+\n+  void set_regions_immediate(size_t immediate) {\n+    _regions_immediate = immediate;\n+  }\n+\n+  void set_immediate_size(size_t size) {\n+    _immediate_size = size;\n+  }\n+\n+  size_t collection_set_regions()     { return _collection_set_regions; }\n+  size_t collection_set_used_before() { return _collection_set_used_before; }\n+  size_t collection_set_used_after()  { return _collection_set_used_after; }\n+  size_t collected_old()              { return _collected_old; }\n+  size_t collected_promoted()         { return _collected_promoted; }\n+  size_t collected_young()            { return _collected_young; }\n+  size_t regions_promoted_humongous() { return _regions_promoted_humongous; }\n+  size_t regions_promoted_regular()   { return _regions_promoted_regular; }\n+  size_t regular_promoted_garbage()   { return _regular_promoted_garbage; }\n+  size_t regular_promoted_free()      { return _regular_promoted_free; }\n+  size_t regions_freed()              { return _regions_freed; }\n+  size_t regions_immediate()          { return _regions_immediate; }\n+  size_t immediate_size()             { return _immediate_size; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHEVACINFO_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacInfo.hpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+ShenandoahEvacuationStats::ShenandoahEvacuationStats()\n+  : _evacuations_completed(0), _bytes_completed(0),\n+    _evacuations_attempted(0), _bytes_attempted(0),\n+    _use_age_table(ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring),\n+    _age_table(nullptr) {\n+  if (_use_age_table) {\n+    _age_table = new AgeTable(false);\n+  }\n+}\n+\n+AgeTable* ShenandoahEvacuationStats::age_table() const {\n+  assert(_use_age_table, \"Don't call\");\n+  return _age_table;\n+}\n+\n+void ShenandoahEvacuationStats::begin_evacuation(size_t bytes) {\n+  ++_evacuations_attempted;\n+  _bytes_attempted += bytes;\n+}\n+\n+void ShenandoahEvacuationStats::end_evacuation(size_t bytes) {\n+  ++_evacuations_completed;\n+  _bytes_completed += bytes;\n+}\n+\n+void ShenandoahEvacuationStats::record_age(size_t bytes, uint age) {\n+  assert(_use_age_table, \"Don't call!\");\n+  if (age <= markWord::max_age) { \/\/ Filter age sentinel.\n+    _age_table->add(age, bytes >> LogBytesPerWord);\n+  }\n+}\n+\n+void ShenandoahEvacuationStats::accumulate(const ShenandoahEvacuationStats* other) {\n+  _evacuations_completed += other->_evacuations_completed;\n+  _bytes_completed += other->_bytes_completed;\n+  _evacuations_attempted += other->_evacuations_attempted;\n+  _bytes_attempted += other->_bytes_attempted;\n+  if (_use_age_table) {\n+    _age_table->merge(other->age_table());\n+  }\n+}\n+\n+void ShenandoahEvacuationStats::reset() {\n+  _evacuations_completed = _evacuations_attempted = 0;\n+  _bytes_completed = _bytes_attempted = 0;\n+  if (_use_age_table) {\n+    _age_table->clear();\n+  }\n+}\n+\n+void ShenandoahEvacuationStats::print_on(outputStream* st) {\n+#ifndef PRODUCT\n+  size_t abandoned_size = _bytes_attempted - _bytes_completed;\n+  size_t abandoned_count = _evacuations_attempted - _evacuations_completed;\n+  st->print_cr(\"Evacuated \" SIZE_FORMAT \"%s across \" SIZE_FORMAT \" objects, \"\n+            \"abandoned \" SIZE_FORMAT \"%s across \" SIZE_FORMAT \" objects.\",\n+            byte_size_in_proper_unit(_bytes_completed), proper_unit_for_byte_size(_bytes_completed),\n+            _evacuations_completed,\n+            byte_size_in_proper_unit(abandoned_size),   proper_unit_for_byte_size(abandoned_size),\n+            abandoned_count);\n+#endif\n+  if (_use_age_table) {\n+    _age_table->print_on(st);\n+  }\n+}\n+\n+void ShenandoahEvacuationTracker::print_global_on(outputStream* st) {\n+  print_evacuations_on(st, &_workers_global, &_mutators_global);\n+}\n+\n+void ShenandoahEvacuationTracker::print_evacuations_on(outputStream* st,\n+                                                       ShenandoahEvacuationStats* workers,\n+                                                       ShenandoahEvacuationStats* mutators) {\n+  st->print(\"Workers: \");\n+  workers->print_on(st);\n+  st->cr();\n+  st->print(\"Mutators: \");\n+  mutators->print_on(st);\n+  st->cr();\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  AgeTable young_region_ages(false);\n+  for (uint i = 0; i < heap->num_regions(); ++i) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    if (r->is_young()) {\n+      young_region_ages.add(r->age(), r->get_live_data_words());\n+    }\n+  }\n+  st->print(\"Young regions: \");\n+  young_region_ages.print_on(st);\n+  st->cr();\n+}\n+\n+class ShenandoahStatAggregator : public ThreadClosure {\n+public:\n+  ShenandoahEvacuationStats* _target;\n+  explicit ShenandoahStatAggregator(ShenandoahEvacuationStats* target) : _target(target) {}\n+  void do_thread(Thread* thread) override {\n+    ShenandoahEvacuationStats* local = ShenandoahThreadLocalData::evacuation_stats(thread);\n+    _target->accumulate(local);\n+    local->reset();\n+  }\n+};\n+\n+ShenandoahCycleStats ShenandoahEvacuationTracker::flush_cycle_to_global() {\n+  ShenandoahEvacuationStats mutators, workers;\n+\n+  ThreadsListHandle java_threads_iterator;\n+  ShenandoahStatAggregator aggregate_mutators(&mutators);\n+  java_threads_iterator.list()->threads_do(&aggregate_mutators);\n+\n+  ShenandoahStatAggregator aggregate_workers(&workers);\n+  ShenandoahHeap::heap()->gc_threads_do(&aggregate_workers);\n+\n+  _mutators_global.accumulate(&mutators);\n+  _workers_global.accumulate(&workers);\n+\n+  if (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n+    \/\/ Ingest mutator & worker collected population vectors into the heap's\n+    \/\/ global census data, and use it to compute an appropriate tenuring threshold\n+    \/\/ for use in the next cycle.\n+    \/\/ The first argument is used for any age 0 cohort population that we may otherwise have\n+    \/\/ missed during the census. This is non-zero only when census happens at marking.\n+    ShenandoahGenerationalHeap::heap()->age_census()->update_census(0, _mutators_global.age_table(), _workers_global.age_table());\n+  }\n+\n+  return {workers, mutators};\n+}\n+\n+void ShenandoahEvacuationTracker::begin_evacuation(Thread* thread, size_t bytes) {\n+  ShenandoahThreadLocalData::begin_evacuation(thread, bytes);\n+}\n+\n+void ShenandoahEvacuationTracker::end_evacuation(Thread* thread, size_t bytes) {\n+  ShenandoahThreadLocalData::end_evacuation(thread, bytes);\n+}\n+\n+void ShenandoahEvacuationTracker::record_age(Thread* thread, size_t bytes, uint age) {\n+  ShenandoahThreadLocalData::record_age(thread, bytes, age);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n+\n+#include \"gc\/shared\/ageTable.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ShenandoahEvacuationStats : public CHeapObj<mtGC> {\n+private:\n+  size_t _evacuations_completed;\n+  size_t _bytes_completed;\n+  size_t _evacuations_attempted;\n+  size_t _bytes_attempted;\n+\n+  bool      _use_age_table;\n+  AgeTable* _age_table;\n+\n+ public:\n+  ShenandoahEvacuationStats();\n+\n+  AgeTable* age_table() const;\n+\n+  void begin_evacuation(size_t bytes);\n+  void end_evacuation(size_t bytes);\n+  void record_age(size_t bytes, uint age);\n+\n+  void print_on(outputStream* st);\n+  void accumulate(const ShenandoahEvacuationStats* other);\n+  void reset();\n+};\n+\n+struct ShenandoahCycleStats {\n+  ShenandoahEvacuationStats workers;\n+  ShenandoahEvacuationStats mutators;\n+};\n+\n+class ShenandoahEvacuationTracker : public CHeapObj<mtGC> {\n+private:\n+\n+  ShenandoahEvacuationStats _workers_global;\n+  ShenandoahEvacuationStats _mutators_global;\n+\n+public:\n+  ShenandoahEvacuationTracker() = default;\n+\n+  void begin_evacuation(Thread* thread, size_t bytes);\n+  void end_evacuation(Thread* thread, size_t bytes);\n+  void record_age(Thread* thread, size_t bytes, uint age);\n+\n+  void print_global_on(outputStream* st);\n+  void print_evacuations_on(outputStream* st,\n+                            ShenandoahEvacuationStats* workers,\n+                            ShenandoahEvacuationStats* mutators);\n+\n+  ShenandoahCycleStats flush_cycle_to_global();\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n@@ -32,0 +33,2 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -43,0 +46,1 @@\n+    case ShenandoahFreeSetPartitionId::OldCollector: return \"OldCollector\";\n@@ -49,0 +53,62 @@\n+class ShenandoahLeftRightIterator {\n+private:\n+  idx_t _idx;\n+  idx_t _end;\n+  ShenandoahRegionPartitions* _partitions;\n+  ShenandoahFreeSetPartitionId _partition;\n+public:\n+  explicit ShenandoahLeftRightIterator(ShenandoahRegionPartitions* partitions, ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n+    : _idx(0), _end(0), _partitions(partitions), _partition(partition) {\n+    _idx = use_empty ? _partitions->leftmost_empty(_partition) : _partitions->leftmost(_partition);\n+    _end = use_empty ? _partitions->rightmost_empty(_partition) : _partitions->rightmost(_partition);\n+  }\n+\n+  bool has_next() const {\n+    if (_idx <= _end) {\n+      assert(_partitions->in_free_set(_partition, _idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, _idx);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  idx_t current() const {\n+    return _idx;\n+  }\n+\n+  idx_t next() {\n+    _idx = _partitions->find_index_of_next_available_region(_partition, _idx + 1);\n+    return current();\n+  }\n+};\n+\n+class ShenandoahRightLeftIterator {\n+private:\n+  idx_t _idx;\n+  idx_t _end;\n+  ShenandoahRegionPartitions* _partitions;\n+  ShenandoahFreeSetPartitionId _partition;\n+public:\n+  explicit ShenandoahRightLeftIterator(ShenandoahRegionPartitions* partitions, ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n+    : _idx(0), _end(0), _partitions(partitions), _partition(partition) {\n+    _idx = use_empty ? _partitions->rightmost_empty(_partition) : _partitions->rightmost(_partition);\n+    _end = use_empty ? _partitions->leftmost_empty(_partition) : _partitions->leftmost(_partition);\n+  }\n+\n+  bool has_next() const {\n+    if (_idx >= _end) {\n+      assert(_partitions->in_free_set(_partition, _idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, _idx);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  idx_t current() const {\n+    return _idx;\n+  }\n+\n+  idx_t next() {\n+    _idx = _partitions->find_index_of_previous_available_region(_partition, _idx - 1);\n+    return current();\n+  }\n+};\n+\n@@ -51,5 +117,8 @@\n-  log_debug(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n-                _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n-                _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n-                _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n-                _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)]);\n+  log_debug(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+               \"], Old Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)]);\n@@ -57,7 +126,10 @@\n-                \"], Empty Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n-                _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n-                _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n-                _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n-                _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)]);\n-\n-  log_debug(gc)(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n+               \"], Empty Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+               \"], Empty Old Collecto range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)]);\n+\n+  log_debug(gc)(\"%6s: %18s %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"Old Collector Bits\", \"NotFree Bits\");\n@@ -84,1 +156,2 @@\n-  uintx free_bits = mutator_bits | collector_bits;\n+  uintx old_collector_bits = _membership[int(ShenandoahFreeSetPartitionId::OldCollector)].bits_at(aligned_idx);\n+  uintx free_bits = mutator_bits | collector_bits | old_collector_bits;\n@@ -86,2 +159,2 @@\n-  log_debug(gc)(SSIZE_FORMAT_W(6) \": \" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0,\n-                aligned_idx, mutator_bits, collector_bits, notfree_bits);\n+  log_debug(gc)(SSIZE_FORMAT_W(6) \": \" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0,\n+               aligned_idx, mutator_bits, collector_bits, old_collector_bits, notfree_bits);\n@@ -95,1 +168,1 @@\n-    _membership{ ShenandoahSimpleBitMap(max_regions), ShenandoahSimpleBitMap(max_regions) }\n+    _membership{ ShenandoahSimpleBitMap(max_regions), ShenandoahSimpleBitMap(max_regions) , ShenandoahSimpleBitMap(max_regions) }\n@@ -165,1 +238,0 @@\n-  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count;\n@@ -185,0 +257,14 @@\n+void ShenandoahRegionPartitions::establish_old_collector_intervals(idx_t old_collector_leftmost, idx_t old_collector_rightmost,\n+                                                                   idx_t old_collector_leftmost_empty,\n+                                                                   idx_t old_collector_rightmost_empty,\n+                                                                   size_t old_collector_region_count, size_t old_collector_used) {\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_leftmost;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_rightmost;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_leftmost_empty;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_rightmost_empty;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_region_count;\n+  _used[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_used;\n+  _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_region_count * _region_size_bytes;\n+}\n+\n@@ -205,1 +291,1 @@\n-      _leftmosts_empty[int(partition)] = leftmost(partition);\n+      _leftmosts_empty[int(partition)] = _leftmosts[int(partition)];\n@@ -292,1 +378,0 @@\n-\n@@ -296,0 +381,17 @@\n+bool ShenandoahRegionPartitions::is_mutator_partition(ShenandoahFreeSetPartitionId p) {\n+  return (p == ShenandoahFreeSetPartitionId::Mutator);\n+}\n+\n+bool ShenandoahRegionPartitions::is_young_collector_partition(ShenandoahFreeSetPartitionId p) {\n+  return (p == ShenandoahFreeSetPartitionId::Collector);\n+}\n+\n+bool ShenandoahRegionPartitions::is_old_collector_partition(ShenandoahFreeSetPartitionId p) {\n+  return (p == ShenandoahFreeSetPartitionId::OldCollector);\n+}\n+\n+bool ShenandoahRegionPartitions::available_implies_empty(size_t available_in_region) {\n+  return (available_in_region == _region_size_bytes);\n+}\n+\n+\n@@ -298,0 +400,1 @@\n+  ShenandoahHeapRegion* r = ShenandoahHeap::heap()->get_region(idx);\n@@ -302,0 +405,5 @@\n+  assert (_membership[int(orig_partition)].is_set(idx), \"Cannot move from partition unless in partition\");\n+  assert ((r != nullptr) && ((r->is_trash() && (available == _region_size_bytes)) ||\n+                             (r->used() + available == _region_size_bytes)),\n+          \"Used: \" SIZE_FORMAT \" + available: \" SIZE_FORMAT \" should equal region size: \" SIZE_FORMAT,\n+          ShenandoahHeap::heap()->get_region(idx)->used(), available, _region_size_bytes);\n@@ -305,0 +413,2 @@\n+  \/\/                          Mutator empty => Collector\n+  \/\/                          Mutator empty => OldCollector\n@@ -306,0 +416,1 @@\n+  \/\/                          Mutator empty => OldCollector\n@@ -307,8 +418,10 @@\n-  assert (((available <= _region_size_bytes) &&\n-           (((orig_partition == ShenandoahFreeSetPartitionId::Mutator)\n-             && (new_partition == ShenandoahFreeSetPartitionId::Collector)) ||\n-            ((orig_partition == ShenandoahFreeSetPartitionId::Collector)\n-             && (new_partition == ShenandoahFreeSetPartitionId::Mutator)))) ||\n-          ((available == _region_size_bytes) &&\n-           ((orig_partition == ShenandoahFreeSetPartitionId::Mutator)\n-            && (new_partition == ShenandoahFreeSetPartitionId::Collector))), \"Unexpected movement between partitions\");\n+  \/\/                          OldCollector Empty => Mutator\n+  assert ((is_mutator_partition(orig_partition) && is_young_collector_partition(new_partition)) ||\n+          (is_mutator_partition(orig_partition) &&\n+           available_implies_empty(available) && is_old_collector_partition(new_partition)) ||\n+          (is_young_collector_partition(orig_partition) && is_mutator_partition(new_partition)) ||\n+          (is_old_collector_partition(orig_partition)\n+           && available_implies_empty(available) && is_mutator_partition(new_partition)),\n+          \"Unexpected movement between partitions, available: \" SIZE_FORMAT \", _region_size_bytes: \" SIZE_FORMAT\n+          \", orig_partition: %s, new_partition: %s\",\n+          available, _region_size_bytes, partition_name(orig_partition), partition_name(new_partition));\n@@ -317,0 +430,3 @@\n+  assert (_used[int(orig_partition)] >= used,\n+          \"Orig partition used: \" SIZE_FORMAT \" must exceed moved used: \" SIZE_FORMAT \" within region \" SSIZE_FORMAT,\n+          _used[int(orig_partition)], used, idx);\n@@ -485,0 +601,1 @@\n+      case ShenandoahFreeSetPartitionId::OldCollector:\n@@ -574,0 +691,35 @@\n+\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n+  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          leftmost(ShenandoahFreeSetPartitionId::OldCollector),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::OldCollector) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          rightmost(ShenandoahFreeSetPartitionId::OldCollector),  _max);\n+\n+  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) == _max\n+          || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                                  ShenandoahFreeSetPartitionId::OldCollector),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::OldCollector));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) == _max\n+          || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                                  ShenandoahFreeSetPartitionId::OldCollector),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+\n+  \/\/ If OldCollector partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n+  beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  end_off = rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost(ShenandoahFreeSetPartitionId::OldCollector));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::OldCollector),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::OldCollector)];\n+  assert (beg_off >= _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::OldCollector));\n+  assert (end_off <= _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost_empty(ShenandoahFreeSetPartitionId::OldCollector));\n@@ -581,1 +733,0 @@\n-  _right_to_left_bias(false),\n@@ -587,0 +738,43 @@\n+void ShenandoahFreeSet::add_promoted_in_place_region_to_old_collector(ShenandoahHeapRegion* region) {\n+  shenandoah_assert_heaplocked();\n+  size_t plab_min_size_in_bytes = ShenandoahGenerationalHeap::heap()->plab_min_size() * HeapWordSize;\n+  size_t idx = region->index();\n+  size_t capacity = alloc_capacity(region);\n+  assert(_partitions.membership(idx) == ShenandoahFreeSetPartitionId::NotFree,\n+         \"Regions promoted in place should have been excluded from Mutator partition\");\n+  if (capacity >= plab_min_size_in_bytes) {\n+    _partitions.make_free(idx, ShenandoahFreeSetPartitionId::OldCollector, capacity);\n+    _heap->old_generation()->augment_promoted_reserve(capacity);\n+  }\n+}\n+\n+HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n+                                                                      ShenandoahAllocRequest& req, bool& in_new_region) {\n+\n+  shenandoah_assert_heaplocked();\n+  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n+  if (_partitions.alloc_from_left_bias(which_partition)) {\n+    ShenandoahLeftRightIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n+    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n+  } else {\n+    ShenandoahRightLeftIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n+    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n+  }\n+}\n+\n+template<typename Iter>\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region) {\n+  for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+    if (r->affiliation() == affiliation) {\n+      HeapWord* result = try_allocate_in(r, req, in_new_region);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+    }\n+  }\n+  log_debug(gc, free)(\"Could not allocate collector region with affiliation: %s for request \" PTR_FORMAT,\n+                      shenandoah_affiliation_name(affiliation), p2i(&req));\n+  return nullptr;\n+}\n+\n@@ -592,1 +786,2 @@\n-  \/\/ Leftmost and rightmost bounds provide enough caching to quickly find a region from which to allocate.\n+  \/\/ Leftmost and rightmost bounds provide enough caching to walk bitmap efficiently. Normally,\n+  \/\/ we would find the region to allocate at right away.\n@@ -598,3 +793,4 @@\n-  \/\/ Free set maintains mutator and collector partitions.  Mutator can only allocate from the\n-  \/\/ Mutator partition.  Collector prefers to allocate from the Collector partition, but may steal\n-  \/\/ regions from the Mutator partition if the Collector partition has been depleted.\n+  \/\/ Free set maintains mutator and collector partitions.  Normally, each allocates only from its partition,\n+  \/\/ except in special cases when the collector steals regions from the mutator partition.\n+\n+  \/\/ Overwrite with non-zero (non-NULL) values only if necessary for allocation bookkeeping.\n@@ -604,67 +800,2 @@\n-    case ShenandoahAllocRequest::_alloc_shared: {\n-      \/\/ Try to allocate in the mutator view\n-      if (_alloc_bias_weight-- <= 0) {\n-        \/\/ We have observed that regions not collected in previous GC cycle tend to congregate at one end or the other\n-        \/\/ of the heap.  Typically, these are the more recently engaged regions and the objects in these regions have not\n-        \/\/ yet had a chance to die (and\/or are treated as floating garbage).  If we use the same allocation bias on each\n-        \/\/ GC pass, these \"most recently\" engaged regions for GC pass N will also be the \"most recently\" engaged regions\n-        \/\/ for GC pass N+1, and the relatively large amount of live data and\/or floating garbage introduced\n-        \/\/ during the most recent GC pass may once again prevent the region from being collected.  We have found that\n-        \/\/ alternating the allocation behavior between GC passes improves evacuation performance by 3-7% on certain\n-        \/\/ benchmarks.  In the best case, this has the effect of consuming these partially consumed regions before\n-        \/\/ the start of the next mark cycle so all of their garbage can be efficiently reclaimed.\n-        \/\/\n-        \/\/ First, finish consuming regions that are already partially consumed so as to more tightly limit ranges of\n-        \/\/ available regions.  Other potential benefits:\n-        \/\/  1. Eventual collection set has fewer regions because we have packed newly allocated objects into fewer regions\n-        \/\/  2. We preserve the \"empty\" regions longer into the GC cycle, reducing likelihood of allocation failures\n-        \/\/     late in the GC cycle.\n-        idx_t non_empty_on_left = (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator)\n-                                     - _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator));\n-        idx_t non_empty_on_right = (_partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator)\n-                                      - _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n-        _right_to_left_bias = (non_empty_on_right > non_empty_on_left);\n-        _alloc_bias_weight = _InitialAllocBiasWeight;\n-      }\n-      if (_right_to_left_bias) {\n-        \/\/ Allocate within mutator free from high memory to low so as to preserve low memory for humongous allocations\n-        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n-          \/\/ Use signed idx.  Otherwise, loop will never terminate.\n-          idx_t leftmost = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n-          for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost; ) {\n-            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n-                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n-            ShenandoahHeapRegion* r = _heap->get_region(idx);\n-            \/\/ try_allocate_in() increases used if the allocation is successful.\n-            HeapWord* result;\n-            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n-            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n-              return result;\n-            }\n-            idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n-          }\n-        }\n-      } else {\n-        \/\/ Allocate from low to high memory.  This keeps the range of fully empty regions more tightly packed.\n-        \/\/ Note that the most recently allocated regions tend not to be evacuated in a given GC cycle.  So this\n-        \/\/ tends to accumulate \"fragmented\" uncollected regions in high memory.\n-        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n-          \/\/ Use signed idx.  Otherwise, loop will never terminate.\n-          idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-          for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= rightmost; ) {\n-            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n-                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n-            ShenandoahHeapRegion* r = _heap->get_region(idx);\n-            \/\/ try_allocate_in() increases used if the allocation is successful.\n-            HeapWord* result;\n-            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n-            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n-              return result;\n-            }\n-            idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, idx + 1);\n-          }\n-        }\n-      }\n-      \/\/ There is no recovery. Mutator does not touch collector view at all.\n-      break;\n-    }\n+    case ShenandoahAllocRequest::_alloc_shared:\n+      return allocate_for_mutator(req, in_new_region);\n@@ -672,14 +803,8 @@\n-      \/\/ GCLABs are for evacuation so we must be in evacuation phase.\n-\n-    case ShenandoahAllocRequest::_alloc_shared_gc: {\n-      \/\/ Fast-path: try to allocate in the collector view first\n-      idx_t leftmost_collector = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n-      for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx >= leftmost_collector; ) {\n-        assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n-               \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n-        HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n-        if (result != nullptr) {\n-          return result;\n-        }\n-        idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Collector, idx - 1);\n-      }\n+    case ShenandoahAllocRequest::_alloc_plab:\n+    case ShenandoahAllocRequest::_alloc_shared_gc:\n+      return allocate_for_collector(req, in_new_region);\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  return nullptr;\n+}\n@@ -687,4 +812,2 @@\n-      \/\/ No dice. Can we borrow space from mutator view?\n-      if (!ShenandoahEvacReserveOverflow) {\n-        return nullptr;\n-      }\n+HeapWord* ShenandoahFreeSet::allocate_for_mutator(ShenandoahAllocRequest &req, bool &in_new_region) {\n+  update_allocation_bias();\n@@ -692,15 +815,54 @@\n-      \/\/ Try to steal an empty region from the mutator view.\n-      idx_t leftmost_mutator_empty = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n-      for (idx_t idx = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost_mutator_empty; ) {\n-        assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n-               \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n-        ShenandoahHeapRegion* r = _heap->get_region(idx);\n-        if (can_allocate_from(r)) {\n-          flip_to_gc(r);\n-          HeapWord *result = try_allocate_in(r, req, in_new_region);\n-          if (result != nullptr) {\n-            log_debug(gc)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n-            return result;\n-          }\n-        }\n-        idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n+  if (_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n+    \/\/ There is no recovery. Mutator does not touch collector view at all.\n+    return nullptr;\n+  }\n+\n+  \/\/ Try to allocate in the mutator view\n+  if (_partitions.alloc_from_left_bias(ShenandoahFreeSetPartitionId::Mutator)) {\n+    \/\/ Allocate from low to high memory.  This keeps the range of fully empty regions more tightly packed.\n+    \/\/ Note that the most recently allocated regions tend not to be evacuated in a given GC cycle.  So this\n+    \/\/ tends to accumulate \"fragmented\" uncollected regions in high memory.\n+    ShenandoahLeftRightIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+    return allocate_from_regions(iterator, req, in_new_region);\n+  }\n+\n+  \/\/ Allocate from high to low memory. This preserves low memory for humongous allocations.\n+  ShenandoahRightLeftIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+  return allocate_from_regions(iterator, req, in_new_region);\n+}\n+\n+void ShenandoahFreeSet::update_allocation_bias() {\n+  if (_alloc_bias_weight-- <= 0) {\n+    \/\/ We have observed that regions not collected in previous GC cycle tend to congregate at one end or the other\n+    \/\/ of the heap.  Typically, these are the more recently engaged regions and the objects in these regions have not\n+    \/\/ yet had a chance to die (and\/or are treated as floating garbage).  If we use the same allocation bias on each\n+    \/\/ GC pass, these \"most recently\" engaged regions for GC pass N will also be the \"most recently\" engaged regions\n+    \/\/ for GC pass N+1, and the relatively large amount of live data and\/or floating garbage introduced\n+    \/\/ during the most recent GC pass may once again prevent the region from being collected.  We have found that\n+    \/\/ alternating the allocation behavior between GC passes improves evacuation performance by 3-7% on certain\n+    \/\/ benchmarks.  In the best case, this has the effect of consuming these partially consumed regions before\n+    \/\/ the start of the next mark cycle so all of their garbage can be efficiently reclaimed.\n+    \/\/\n+    \/\/ First, finish consuming regions that are already partially consumed so as to more tightly limit ranges of\n+    \/\/ available regions.  Other potential benefits:\n+    \/\/  1. Eventual collection set has fewer regions because we have packed newly allocated objects into fewer regions\n+    \/\/  2. We preserve the \"empty\" regions longer into the GC cycle, reducing likelihood of allocation failures\n+    \/\/     late in the GC cycle.\n+    idx_t non_empty_on_left = (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator)\n+                               - _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+    idx_t non_empty_on_right = (_partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator)\n+                                - _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+    _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::Mutator, (non_empty_on_right < non_empty_on_left));\n+    _alloc_bias_weight = INITIAL_ALLOC_BIAS_WEIGHT;\n+  }\n+}\n+\n+template<typename Iter>\n+HeapWord* ShenandoahFreeSet::allocate_from_regions(Iter& iterator, ShenandoahAllocRequest &req, bool &in_new_region) {\n+  for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+    size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab) ? req.min_size() : req.size();\n+    if (alloc_capacity(r) >= min_size) {\n+      HeapWord* result = try_allocate_in(r, req, in_new_region);\n+      if (result != nullptr) {\n+        return result;\n@@ -708,0 +870,4 @@\n+    }\n+  }\n+  return nullptr;\n+}\n@@ -709,3 +875,68 @@\n-      \/\/ No dice. Do not try to mix mutator and GC allocations, because adjusting region UWM\n-      \/\/ due to GC allocations would expose unparsable mutator allocations.\n-      break;\n+HeapWord* ShenandoahFreeSet::allocate_for_collector(ShenandoahAllocRequest &req, bool &in_new_region) {\n+  \/\/ Fast-path: try to allocate in the collector view first\n+  HeapWord* result;\n+  result = allocate_from_partition_with_affiliation(req.affiliation(), req, in_new_region);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+\n+  bool allow_new_region = can_allocate_in_new_region(req);\n+  if (allow_new_region) {\n+    \/\/ Try a free region that is dedicated to GC allocations.\n+    result = allocate_from_partition_with_affiliation(ShenandoahAffiliation::FREE, req, in_new_region);\n+    if (result != nullptr) {\n+      return result;\n+    }\n+  }\n+\n+  \/\/ No dice. Can we borrow space from mutator view?\n+  if (!ShenandoahEvacReserveOverflow) {\n+    return nullptr;\n+  }\n+\n+  if (!allow_new_region && req.is_old() && (_heap->young_generation()->free_unaffiliated_regions() > 0)) {\n+    \/\/ This allows us to flip a mutator region to old_collector\n+    allow_new_region = true;\n+  }\n+\n+  \/\/ We should expand old-gen if this can prevent an old-gen evacuation failure.  We don't care so much about\n+  \/\/ promotion failures since they can be mitigated in a subsequent GC pass.  Would be nice to know if this\n+  \/\/ allocation request is for evacuation or promotion.  Individual threads limit their use of PLAB memory for\n+  \/\/ promotions, so we already have an assurance that any additional memory set aside for old-gen will be used\n+  \/\/ only for old-gen evacuations.\n+  if (allow_new_region) {\n+    \/\/ Try to steal an empty region from the mutator view.\n+    result = try_allocate_from_mutator(req, in_new_region);\n+  }\n+\n+  \/\/ This is it. Do not try to mix mutator and GC allocations, because adjusting region UWM\n+  \/\/ due to GC allocations would expose unparsable mutator allocations.\n+  return result;\n+}\n+\n+bool ShenandoahFreeSet::can_allocate_in_new_region(const ShenandoahAllocRequest& req) {\n+  if (!_heap->mode()->is_generational()) {\n+    return true;\n+  }\n+\n+  assert(req.is_old() || req.is_young(), \"Should request affiliation\");\n+  return (req.is_old() && _heap->old_generation()->free_unaffiliated_regions() > 0)\n+         || (req.is_young() && _heap->young_generation()->free_unaffiliated_regions() > 0);\n+}\n+\n+HeapWord* ShenandoahFreeSet::try_allocate_from_mutator(ShenandoahAllocRequest& req, bool& in_new_region) {\n+  \/\/ The collector prefers to keep longer lived regions toward the right side of the heap, so it always\n+  \/\/ searches for regions from right to left here.\n+  ShenandoahRightLeftIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator, true);\n+  for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+    if (can_allocate_from(r)) {\n+      if (req.is_old()) {\n+        flip_to_old_gc(r);\n+      } else {\n+        flip_to_gc(r);\n+      }\n+      \/\/ Region r is entirely empty.  If try_allocate_in fails on region r, something else is really wrong.\n+      \/\/ Don't bother to retry with other regions.\n+      log_debug(gc, free)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n+      return try_allocate_in(r, req, in_new_region);\n@@ -713,2 +944,0 @@\n-    default:\n-      ShouldNotReachHere();\n@@ -716,0 +945,1 @@\n+\n@@ -719,0 +949,50 @@\n+\/\/ This work method takes an argument corresponding to the number of bytes\n+\/\/ free in a region, and returns the largest amount in heapwords that can be allocated\n+\/\/ such that both of the following conditions are satisfied:\n+\/\/\n+\/\/ 1. it is a multiple of card size\n+\/\/ 2. any remaining shard may be filled with a filler object\n+\/\/\n+\/\/ The idea is that the allocation starts and ends at card boundaries. Because\n+\/\/ a region ('s end) is card-aligned, the remainder shard that must be filled is\n+\/\/ at the start of the free space.\n+\/\/\n+\/\/ This is merely a helper method to use for the purpose of such a calculation.\n+size_t ShenandoahFreeSet::get_usable_free_words(size_t free_bytes) const {\n+  \/\/ e.g. card_size is 512, card_shift is 9, min_fill_size() is 8\n+  \/\/      free is 514\n+  \/\/      usable_free is 512, which is decreased to 0\n+  size_t usable_free = (free_bytes \/ CardTable::card_size()) << CardTable::card_shift();\n+  assert(usable_free <= free_bytes, \"Sanity check\");\n+  if ((free_bytes != usable_free) && (free_bytes - usable_free < ShenandoahHeap::min_fill_size() * HeapWordSize)) {\n+    \/\/ After aligning to card multiples, the remainder would be smaller than\n+    \/\/ the minimum filler object, so we'll need to take away another card's\n+    \/\/ worth to construct a filler object.\n+    if (usable_free >= CardTable::card_size()) {\n+      usable_free -= CardTable::card_size();\n+    } else {\n+      assert(usable_free == 0, \"usable_free is a multiple of card_size and card_size > min_fill_size\");\n+    }\n+  }\n+\n+  return usable_free \/ HeapWordSize;\n+}\n+\n+\/\/ Given a size argument, which is a multiple of card size, a request struct\n+\/\/ for a PLAB, and an old region, return a pointer to the allocated space for\n+\/\/ a PLAB which is card-aligned and where any remaining shard in the region\n+\/\/ has been suitably filled by a filler object.\n+\/\/ It is assumed (and assertion-checked) that such an allocation is always possible.\n+HeapWord* ShenandoahFreeSet::allocate_aligned_plab(size_t size, ShenandoahAllocRequest& req, ShenandoahHeapRegion* r) {\n+  assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n+  assert(r->is_old(), \"All PLABs reside in old-gen\");\n+  assert(!req.is_mutator_alloc(), \"PLABs should not be allocated by mutators.\");\n+  assert(is_aligned(size, CardTable::card_size_in_words()), \"Align by design\");\n+\n+  HeapWord* result = r->allocate_aligned(size, req, CardTable::card_size());\n+  assert(result != nullptr, \"Allocation cannot fail\");\n+  assert(r->top() <= r->end(), \"Allocation cannot span end of region\");\n+  assert(is_aligned(result, CardTable::card_size_in_words()), \"Align by design\");\n+  return result;\n+}\n+\n@@ -724,1 +1004,0 @@\n-\n@@ -732,0 +1011,28 @@\n+    assert(!r->is_affiliated(), \"New region \" SIZE_FORMAT \" should be unaffiliated\", r->index());\n+    r->set_affiliation(req.affiliation());\n+    if (r->is_old()) {\n+      \/\/ Any OLD region allocated during concurrent coalesce-and-fill does not need to be coalesced and filled because\n+      \/\/ all objects allocated within this region are above TAMS (and thus are implicitly marked).  In case this is an\n+      \/\/ OLD region and concurrent preparation for mixed evacuations visits this region before the start of the next\n+      \/\/ old-gen concurrent mark (i.e. this region is allocated following the start of old-gen concurrent mark but before\n+      \/\/ concurrent preparations for mixed evacuations are completed), we mark this region as not requiring any\n+      \/\/ coalesce-and-fill processing.\n+      r->end_preemptible_coalesce_and_fill();\n+      _heap->old_generation()->clear_cards_for(r);\n+    }\n+    _heap->generation_for(r->affiliation())->increment_affiliated_region_count();\n+\n+#ifdef ASSERT\n+    ShenandoahMarkingContext* const ctx = _heap->complete_marking_context();\n+    assert(ctx->top_at_mark_start(r) == r->bottom(), \"Newly established allocation region starts with TAMS equal to bottom\");\n+    assert(ctx->is_bitmap_range_within_region_clear(ctx->top_bitmap(r), r->end()), \"Bitmap above top_bitmap() must be clear\");\n+#endif\n+    log_debug(gc)(\"Using new region (\" SIZE_FORMAT \") for %s (\" PTR_FORMAT \").\",\n+                       r->index(), ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(&req));\n+  } else {\n+    assert(r->is_affiliated(), \"Region \" SIZE_FORMAT \" that is not new should be affiliated\", r->index());\n+    if (r->affiliation() != req.affiliation()) {\n+      assert(_heap->mode()->is_generational(), \"Request for %s from %s region should only happen in generational mode.\",\n+             req.affiliation_name(), r->affiliation_name());\n+      return nullptr;\n+    }\n@@ -736,1 +1043,0 @@\n-    \/\/ This is a GCLAB or a TLAB allocation\n@@ -738,12 +1044,23 @@\n-    size_t free = align_down(r->free() >> LogHeapWordSize, MinObjAlignment);\n-    if (adjusted_size > free) {\n-      adjusted_size = free;\n-    }\n-    if (adjusted_size >= req.min_size()) {\n-      result = r->allocate(adjusted_size, req.type());\n-      log_debug(gc)(\"Allocated \" SIZE_FORMAT \" words (adjusted from \" SIZE_FORMAT \") for %s @\" PTR_FORMAT\n-                          \" from %s region \" SIZE_FORMAT \", free bytes remaining: \" SIZE_FORMAT,\n-                          adjusted_size, req.size(), ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(result),\n-                          _partitions.partition_membership_name(r->index()), r->index(), r->free());\n-      assert (result != nullptr, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, adjusted_size);\n-      req.set_actual_size(adjusted_size);\n+    size_t free = r->free();    \/\/ free represents bytes available within region r\n+    if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+      \/\/ This is a PLAB allocation\n+      assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, r->index()),\n+             \"PLABS must be allocated in old_collector_free regions\");\n+\n+      \/\/ Need to assure that plabs are aligned on multiple of card region\n+      \/\/ Convert free from unaligned bytes to aligned number of words\n+      size_t usable_free = get_usable_free_words(free);\n+      if (adjusted_size > usable_free) {\n+        adjusted_size = usable_free;\n+      }\n+      adjusted_size = align_down(adjusted_size, CardTable::card_size_in_words());\n+      if (adjusted_size >= req.min_size()) {\n+        result = allocate_aligned_plab(adjusted_size, req, r);\n+        assert(result != nullptr, \"allocate must succeed\");\n+        req.set_actual_size(adjusted_size);\n+      } else {\n+        \/\/ Otherwise, leave result == nullptr because the adjusted size is smaller than min size.\n+        log_trace(gc, free)(\"Failed to shrink PLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                            \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n+      }\n@@ -751,2 +1068,14 @@\n-      log_trace(gc, free)(\"Failed to shrink TLAB or GCLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n-                          \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n+      \/\/ This is a GCLAB or a TLAB allocation\n+      \/\/ Convert free from unaligned bytes to aligned number of words\n+      free = align_down(free >> LogHeapWordSize, MinObjAlignment);\n+      if (adjusted_size > free) {\n+        adjusted_size = free;\n+      }\n+      if (adjusted_size >= req.min_size()) {\n+        result = r->allocate(adjusted_size, req);\n+        assert (result != nullptr, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, adjusted_size);\n+        req.set_actual_size(adjusted_size);\n+      } else {\n+        log_trace(gc, free)(\"Failed to shrink TLAB or GCLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                            \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n+      }\n@@ -756,1 +1085,1 @@\n-    result = r->allocate(size, req.type());\n+    result = r->allocate(size, req);\n@@ -759,4 +1088,0 @@\n-      log_debug(gc)(\"Allocated \" SIZE_FORMAT \" words for %s @\" PTR_FORMAT\n-                          \" from %s region \" SIZE_FORMAT \", free bytes remaining: \" SIZE_FORMAT,\n-                          size, ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(result),\n-                          _partitions.partition_membership_name(r->index()),  r->index(), r->free());\n@@ -770,0 +1095,1 @@\n+      assert(req.is_young(), \"Mutator allocations always come from young generation.\");\n@@ -775,1 +1101,2 @@\n-      \/\/ evacuation are not updated during evacuation.\n+      \/\/ evacuation are not updated during evacuation.  For both young and old regions r, it is essential that all\n+      \/\/ PLABs be made parsable at the end of evacuation.  This is enabled by retiring all plabs at end of evacuation.\n@@ -777,0 +1104,7 @@\n+      if (r->is_old()) {\n+        _partitions.increase_used(ShenandoahFreeSetPartitionId::OldCollector, req.actual_size() * HeapWordSize);\n+        assert(req.type() != ShenandoahAllocRequest::_alloc_gclab, \"old-gen allocations use PLAB or shared allocation\");\n+        \/\/ for plabs, we'll sort the difference between evac and promotion usage when we retire the plab\n+      } else {\n+        _partitions.increase_used(ShenandoahFreeSetPartitionId::Collector, req.actual_size() * HeapWordSize);\n+      }\n@@ -791,3 +1125,16 @@\n-    _partitions.retire_from_partition(req.is_mutator_alloc()?\n-                                      ShenandoahFreeSetPartitionId::Mutator: ShenandoahFreeSetPartitionId::Collector,\n-                                      idx, r->used());\n+    ShenandoahFreeSetPartitionId orig_partition;\n+    if (req.is_mutator_alloc()) {\n+      orig_partition = ShenandoahFreeSetPartitionId::Mutator;\n+    } else if (req.type() == ShenandoahAllocRequest::_alloc_gclab) {\n+      orig_partition = ShenandoahFreeSetPartitionId::Collector;\n+    } else if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+      orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n+    } else {\n+      assert(req.type() == ShenandoahAllocRequest::_alloc_shared_gc, \"Unexpected allocation type\");\n+      if (req.is_old()) {\n+        orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n+      } else {\n+        orig_partition = ShenandoahFreeSetPartitionId::Collector;\n+      }\n+    }\n+    _partitions.retire_from_partition(orig_partition, idx, r->used());\n@@ -806,0 +1153,3 @@\n+  assert(req.is_young(), \"Humongous regions always allocated in YOUNG\");\n+  ShenandoahGeneration* generation = _heap->generation_for(req.affiliation());\n+\n@@ -818,1 +1168,1 @@\n-                                                                            start_range, num);\n+                                                                          start_range, num);\n@@ -885,0 +1235,2 @@\n+    r->set_affiliation(req.affiliation());\n+    r->set_update_watermark(r->bottom());\n@@ -887,1 +1239,1 @@\n-\n+  generation->increase_affiliated_region_count(num);\n@@ -900,0 +1252,3 @@\n+  if (remainder != 0) {\n+    req.set_waste(ShenandoahHeapRegion::region_size_words() - remainder);\n+  }\n@@ -905,1 +1260,0 @@\n-    _heap->decrease_used(r->used());\n@@ -963,0 +1317,21 @@\n+void ShenandoahFreeSet::flip_to_old_gc(ShenandoahHeapRegion* r) {\n+  size_t idx = r->index();\n+\n+  assert(_partitions.partition_id_matches(idx, ShenandoahFreeSetPartitionId::Mutator), \"Should be in mutator view\");\n+  assert(can_allocate_from(r), \"Should not be allocated\");\n+\n+  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+  size_t region_capacity = alloc_capacity(r);\n+  _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                               ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n+  _partitions.assert_bounds();\n+  _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n+  bool transferred = gen_heap->generation_sizer()->transfer_to_old(1);\n+  if (!transferred) {\n+    log_warning(gc, free)(\"Forcing transfer of \" SIZE_FORMAT \" to old reserve.\", idx);\n+    gen_heap->generation_sizer()->force_transfer_to_old(1);\n+  }\n+  \/\/ We do not ensure that the region is no longer trash, relying on try_allocate_in(), which always comes next,\n+  \/\/ to recycle trash before attempting to allocate anything in the region.\n+}\n+\n@@ -985,1 +1360,0 @@\n-}\n@@ -987,1 +1361,5 @@\n-void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &cset_regions) {\n+  _alloc_bias_weight = 0;\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::Mutator, true);\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::Collector, false);\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::OldCollector, false);\n+}\n@@ -989,1 +1367,3 @@\n-  cset_regions = 0;\n+void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                                         size_t &first_old_region, size_t &last_old_region,\n+                                                         size_t &old_region_count) {\n@@ -991,0 +1371,7 @@\n+\n+  first_old_region = _heap->num_regions();\n+  last_old_region = 0;\n+  old_region_count = 0;\n+  old_cset_regions = 0;\n+  young_cset_regions = 0;\n+\n@@ -998,1 +1385,0 @@\n-\n@@ -1002,1 +1388,9 @@\n-  for (size_t idx = 0; idx < _heap->num_regions(); idx++) {\n+  size_t old_collector_leftmost = max_regions;\n+  size_t old_collector_rightmost = 0;\n+  size_t old_collector_leftmost_empty = max_regions;\n+  size_t old_collector_rightmost_empty = 0;\n+  size_t old_collector_regions = 0;\n+  size_t old_collector_used = 0;\n+\n+  size_t num_regions = _heap->num_regions();\n+  for (size_t idx = 0; idx < num_regions; idx++) {\n@@ -1007,1 +1401,13 @@\n-      cset_regions++;\n+      if (region->is_old()) {\n+        old_cset_regions++;\n+      } else {\n+        assert(region->is_young(), \"Trashed region should be old or young\");\n+        young_cset_regions++;\n+      }\n+    } else if (region->is_old()) {\n+      \/\/ count both humongous and regular regions, but don't count trash (cset) regions.\n+      old_region_count++;\n+      if (first_old_region > idx) {\n+        first_old_region = idx;\n+      }\n+      last_old_region = idx;\n@@ -1010,0 +1416,1 @@\n+      assert(!region->is_cset(), \"Shouldn't be adding cset regions to the free set\");\n@@ -1014,11 +1421,24 @@\n-        _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::Mutator);\n-\n-        if (idx < mutator_leftmost) {\n-          mutator_leftmost = idx;\n-        }\n-        if (idx > mutator_rightmost) {\n-          mutator_rightmost = idx;\n-        }\n-        if (ac == region_size_bytes) {\n-          if (idx < mutator_leftmost_empty) {\n-            mutator_leftmost_empty = idx;\n+        if (region->is_trash() || !region->is_old()) {\n+          \/\/ Both young and old collected regions (trashed) are placed into the Mutator set\n+          _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::Mutator);\n+          if (idx < mutator_leftmost) {\n+            mutator_leftmost = idx;\n+          }\n+          if (idx > mutator_rightmost) {\n+            mutator_rightmost = idx;\n+          }\n+          if (ac == region_size_bytes) {\n+            if (idx < mutator_leftmost_empty) {\n+              mutator_leftmost_empty = idx;\n+            }\n+            if (idx > mutator_rightmost_empty) {\n+              mutator_rightmost_empty = idx;\n+            }\n+          }\n+          mutator_regions++;\n+          mutator_used += (region_size_bytes - ac);\n+        } else {\n+          \/\/ !region->is_trash() && region is_old()\n+          _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::OldCollector);\n+          if (idx < old_collector_leftmost) {\n+            old_collector_leftmost = idx;\n@@ -1026,2 +1446,2 @@\n-          if (idx > mutator_rightmost_empty) {\n-            mutator_rightmost_empty = idx;\n+          if (idx > old_collector_rightmost) {\n+            old_collector_rightmost = idx;\n@@ -1029,0 +1449,10 @@\n+          if (ac == region_size_bytes) {\n+            if (idx < old_collector_leftmost_empty) {\n+              old_collector_leftmost_empty = idx;\n+            }\n+            if (idx > old_collector_rightmost_empty) {\n+              old_collector_rightmost_empty = idx;\n+            }\n+          }\n+          old_collector_regions++;\n+          old_collector_used += (region_size_bytes - ac);\n@@ -1030,7 +1460,0 @@\n-        mutator_regions++;\n-        mutator_used += (region_size_bytes - ac);\n-\n-        log_debug(gc)(\n-          \"  Adding Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to mutator partition\",\n-          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n-          byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n@@ -1040,0 +1463,18 @@\n+  log_debug(gc)(\"  At end of prep_to_rebuild, mutator_leftmost: \" SIZE_FORMAT\n+                \", mutator_rightmost: \" SIZE_FORMAT\n+                \", mutator_leftmost_empty: \" SIZE_FORMAT\n+                \", mutator_rightmost_empty: \" SIZE_FORMAT\n+                \", mutator_regions: \" SIZE_FORMAT\n+                \", mutator_used: \" SIZE_FORMAT,\n+                mutator_leftmost, mutator_rightmost, mutator_leftmost_empty, mutator_rightmost_empty,\n+                mutator_regions, mutator_used);\n+\n+  log_debug(gc)(\"  old_collector_leftmost: \" SIZE_FORMAT\n+                \", old_collector_rightmost: \" SIZE_FORMAT\n+                \", old_collector_leftmost_empty: \" SIZE_FORMAT\n+                \", old_collector_rightmost_empty: \" SIZE_FORMAT\n+                \", old_collector_regions: \" SIZE_FORMAT\n+                \", old_collector_used: \" SIZE_FORMAT,\n+                old_collector_leftmost, old_collector_rightmost, old_collector_leftmost_empty, old_collector_rightmost_empty,\n+                old_collector_regions, old_collector_used);\n+\n@@ -1044,0 +1485,48 @@\n+  rightmost_idx = (old_collector_leftmost == max_regions)? -1: (idx_t) old_collector_rightmost;\n+  rightmost_empty_idx = (old_collector_leftmost_empty == max_regions)? -1: (idx_t) old_collector_rightmost_empty;\n+  _partitions.establish_old_collector_intervals(old_collector_leftmost, rightmost_idx, old_collector_leftmost_empty,\n+                                                rightmost_empty_idx, old_collector_regions, old_collector_used);\n+  log_debug(gc)(\"  After find_regions_with_alloc_capacity(), Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"],\"\n+                \"  Old Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+}\n+\n+\/\/ Returns number of regions transferred, adds transferred bytes to var argument bytes_transferred\n+size_t ShenandoahFreeSet::transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n+                                                                                   size_t max_xfer_regions,\n+                                                                                   size_t& bytes_transferred) {\n+  shenandoah_assert_heaplocked();\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t transferred_regions = 0;\n+  ShenandoahLeftRightIterator iterator(&_partitions, which_collector, true);\n+  idx_t rightmost = _partitions.rightmost_empty(which_collector);\n+  for (idx_t idx = iterator.current(); transferred_regions < max_xfer_regions && iterator.has_next(); idx = iterator.next()) {\n+    \/\/ Note: can_allocate_from() denotes that region is entirely empty\n+    if (can_allocate_from(idx)) {\n+      _partitions.move_from_partition_to_partition(idx, which_collector, ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n+      transferred_regions++;\n+      bytes_transferred += region_size_bytes;\n+    }\n+  }\n+  return transferred_regions;\n+}\n+\n+\/\/ Returns number of regions transferred, adds transferred bytes to var argument bytes_transferred\n+size_t ShenandoahFreeSet::transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n+                                                                                       size_t max_xfer_regions,\n+                                                                                       size_t& bytes_transferred) {\n+  shenandoah_assert_heaplocked();\n+  size_t transferred_regions = 0;\n+  ShenandoahLeftRightIterator iterator(&_partitions, which_collector, false);\n+  for (idx_t idx = iterator.current(); transferred_regions < max_xfer_regions && iterator.has_next(); idx = iterator.next()) {\n+    size_t ac = alloc_capacity(idx);\n+    if (ac > 0) {\n+      _partitions.move_from_partition_to_partition(idx, which_collector, ShenandoahFreeSetPartitionId::Mutator, ac);\n+      transferred_regions++;\n+      bytes_transferred += ac;\n+    }\n+  }\n+  return transferred_regions;\n@@ -1047,3 +1536,2 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t collector_empty_xfer = 0;\n-  size_t collector_not_empty_xfer = 0;\n+  size_t collector_xfer = 0;\n+  size_t old_collector_xfer = 0;\n@@ -1056,13 +1544,16 @@\n-    idx_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector);\n-    for (idx_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector);\n-         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n-      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n-             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n-      \/\/ Note: can_allocate_from() denotes that region is entirely empty\n-      if (can_allocate_from(idx)) {\n-        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n-                                                     ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n-        max_xfer_regions--;\n-        collector_empty_xfer += region_size_bytes;\n-      }\n-      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n+    max_xfer_regions -=\n+      transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId::Collector, max_xfer_regions,\n+                                                               collector_xfer);\n+  }\n+\n+  \/\/ Process empty regions within the OldCollector free partition\n+  if ((max_xfer_regions > 0) &&\n+      (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::OldCollector)\n+       <= _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::OldCollector))) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    size_t old_collector_regions =\n+      transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId::OldCollector, max_xfer_regions,\n+                                                               old_collector_xfer);\n+    max_xfer_regions -= old_collector_regions;\n+    if (old_collector_regions > 0) {\n+      ShenandoahGenerationalHeap::cast(_heap)->generation_sizer()->transfer_to_young(old_collector_regions);\n@@ -1076,14 +1567,3 @@\n-    idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n-    for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n-         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n-      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n-             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n-      size_t ac = alloc_capacity(idx);\n-      if (ac > 0) {\n-        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n-                                                     ShenandoahFreeSetPartitionId::Mutator, ac);\n-        max_xfer_regions--;\n-        collector_not_empty_xfer += ac;\n-      }\n-      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n-    }\n+    max_xfer_regions -=\n+      transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId::Collector, max_xfer_regions,\n+                                                                   collector_xfer);\n@@ -1092,3 +1572,6 @@\n-  size_t collector_xfer = collector_empty_xfer + collector_not_empty_xfer;\n-  log_info(gc, ergo)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free partition from Collector Reserve\",\n-                     byte_size_in_proper_unit(collector_xfer), proper_unit_for_byte_size(collector_xfer));\n+  size_t total_xfer = collector_xfer + old_collector_xfer;\n+  log_info(gc, ergo)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free set from Collector Reserve (\"\n+                     SIZE_FORMAT \"%s) and from Old Collector Reserve (\" SIZE_FORMAT \"%s)\",\n+                     byte_size_in_proper_unit(total_xfer), proper_unit_for_byte_size(total_xfer),\n+                     byte_size_in_proper_unit(collector_xfer), proper_unit_for_byte_size(collector_xfer),\n+                     byte_size_in_proper_unit(old_collector_xfer), proper_unit_for_byte_size(old_collector_xfer));\n@@ -1097,1 +1580,4 @@\n-void ShenandoahFreeSet::prepare_to_rebuild(size_t &cset_regions) {\n+\n+\/\/ Overwrite arguments to represent the amount of memory in each generation that is about to be recycled\n+void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                           size_t &first_old_region, size_t &last_old_region, size_t &old_region_count) {\n@@ -1099,0 +1585,8 @@\n+  \/\/ This resets all state information, removing all regions from all sets.\n+  clear();\n+  log_debug(gc, free)(\"Rebuilding FreeSet\");\n+\n+  \/\/ This places regions that have alloc_capacity into the old_collector set if they identify as is_old() or the\n+  \/\/ mutator set otherwise.  All trashed (cset) regions are affiliated young and placed in mutator set.\n+  find_regions_with_alloc_capacity(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n+}\n@@ -1100,1 +1594,7 @@\n-  log_debug(gc)(\"Rebuilding FreeSet\");\n+void ShenandoahFreeSet::establish_generation_sizes(size_t young_region_count, size_t old_region_count) {\n+  assert(young_region_count + old_region_count == ShenandoahHeap::heap()->num_regions(), \"Sanity\");\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    ShenandoahOldGeneration* old_gen = heap->old_generation();\n+    ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -1102,2 +1602,18 @@\n-  \/\/ This places regions that have alloc_capacity into the mutator partition.\n-  find_regions_with_alloc_capacity(cset_regions);\n+    size_t original_old_capacity = old_gen->max_capacity();\n+    size_t new_old_capacity = old_region_count * region_size_bytes;\n+    size_t new_young_capacity = young_region_count * region_size_bytes;\n+    old_gen->set_capacity(new_old_capacity);\n+    young_gen->set_capacity(new_young_capacity);\n+\n+    if (new_old_capacity > original_old_capacity) {\n+      size_t region_count = (new_old_capacity - original_old_capacity) \/ region_size_bytes;\n+      log_info(gc, ergo)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                         region_count, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_old_capacity));\n+    } else if (new_old_capacity < original_old_capacity) {\n+      size_t region_count = (original_old_capacity - new_old_capacity) \/ region_size_bytes;\n+      log_info(gc, ergo)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                         region_count, old_gen->name(), young_gen->name(), PROPERFMTARGS(new_young_capacity));\n+    }\n+    \/\/ This balances generations, so clear any pending request to balance.\n+    old_gen->set_region_balance(0);\n+  }\n@@ -1106,1 +1622,2 @@\n-void ShenandoahFreeSet::finish_rebuild(size_t cset_regions) {\n+void ShenandoahFreeSet::finish_rebuild(size_t young_cset_regions, size_t old_cset_regions, size_t old_region_count,\n+                                       bool have_evacuation_reserves) {\n@@ -1108,0 +1625,1 @@\n+  size_t young_reserve(0), old_reserve(0);\n@@ -1109,9 +1627,3 @@\n-  \/\/ Our desire is to reserve this much memory for future evacuation.  We may end up reserving less, if\n-  \/\/ memory is in short supply.\n-\n-  size_t reserve = _heap->max_capacity() * ShenandoahEvacReserve \/ 100;\n-  size_t available_in_collector_partition = (_partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector)\n-                                             - _partitions.used_by(ShenandoahFreeSetPartitionId::Collector));\n-  size_t additional_reserve;\n-  if (available_in_collector_partition < reserve) {\n-    additional_reserve = reserve - available_in_collector_partition;\n+  if (_heap->mode()->is_generational()) {\n+    compute_young_and_old_reserves(young_cset_regions, old_cset_regions, have_evacuation_reserves,\n+                                   young_reserve, old_reserve);\n@@ -1119,1 +1631,2 @@\n-    additional_reserve = 0;\n+    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n+    old_reserve = 0;\n@@ -1122,1 +1635,6 @@\n-  reserve_regions(reserve);\n+  \/\/ Move some of the mutator regions in the Collector and OldCollector partitions in order to satisfy\n+  \/\/ young_reserve and old_reserve.\n+  reserve_regions(young_reserve, old_reserve, old_region_count);\n+  size_t young_region_count = _heap->num_regions() - old_region_count;\n+  establish_generation_sizes(young_region_count, old_region_count);\n+  establish_old_collector_alloc_bias();\n@@ -1127,4 +1645,71 @@\n-void ShenandoahFreeSet::rebuild() {\n-  size_t cset_regions;\n-  prepare_to_rebuild(cset_regions);\n-  finish_rebuild(cset_regions);\n+void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions,\n+                                                       bool have_evacuation_reserves,\n+                                                       size_t& young_reserve_result, size_t& old_reserve_result) const {\n+  shenandoah_assert_generational();\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  ShenandoahOldGeneration* const old_generation = _heap->old_generation();\n+  size_t old_available = old_generation->available();\n+  size_t old_unaffiliated_regions = old_generation->free_unaffiliated_regions();\n+  ShenandoahYoungGeneration* const young_generation = _heap->young_generation();\n+  size_t young_capacity = young_generation->max_capacity();\n+  size_t young_unaffiliated_regions = young_generation->free_unaffiliated_regions();\n+\n+  \/\/ Add in the regions we anticipate to be freed by evacuation of the collection set\n+  old_unaffiliated_regions += old_cset_regions;\n+  young_unaffiliated_regions += young_cset_regions;\n+\n+  \/\/ Consult old-region balance to make adjustments to current generation capacities and availability.\n+  \/\/ The generation region transfers take place after we rebuild.\n+  const ssize_t old_region_balance = old_generation->get_region_balance();\n+  if (old_region_balance != 0) {\n+#ifdef ASSERT\n+    if (old_region_balance > 0) {\n+      assert(old_region_balance <= checked_cast<ssize_t>(old_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+    } else {\n+      assert(0 - old_region_balance <= checked_cast<ssize_t>(young_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+    }\n+#endif\n+\n+    ssize_t xfer_bytes = old_region_balance * checked_cast<ssize_t>(region_size_bytes);\n+    old_available -= xfer_bytes;\n+    old_unaffiliated_regions -= old_region_balance;\n+    young_capacity += xfer_bytes;\n+    young_unaffiliated_regions += old_region_balance;\n+  }\n+\n+  \/\/ All allocations taken from the old collector set are performed by GC, generally using PLABs for both\n+  \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n+  \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentions for\n+  \/\/ each PLAB's available memory.\n+  if (have_evacuation_reserves) {\n+    \/\/ We are rebuilding at the end of final mark, having already established evacuation budgets for this GC pass.\n+    const size_t promoted_reserve = old_generation->get_promoted_reserve();\n+    const size_t old_evac_reserve = old_generation->get_evacuation_reserve();\n+    young_reserve_result = young_generation->get_evacuation_reserve();\n+    old_reserve_result = promoted_reserve + old_evac_reserve;\n+    assert(old_reserve_result <= old_available,\n+           \"Cannot reserve (\" SIZE_FORMAT \" + \" SIZE_FORMAT\") more OLD than is available: \" SIZE_FORMAT,\n+           promoted_reserve, old_evac_reserve, old_available);\n+  } else {\n+    \/\/ We are rebuilding at end of GC, so we set aside budgets specified on command line (or defaults)\n+    young_reserve_result = (young_capacity * ShenandoahEvacReserve) \/ 100;\n+    \/\/ The auto-sizer has already made old-gen large enough to hold all anticipated evacuations and promotions.\n+    \/\/ Affiliated old-gen regions are already in the OldCollector free set.  Add in the relevant number of\n+    \/\/ unaffiliated regions.\n+    old_reserve_result = old_available;\n+  }\n+\n+  \/\/ Old available regions that have less than PLAB::min_size() of available memory are not placed into the OldCollector\n+  \/\/ free set.  Because of this, old_available may not have enough memory to represent the intended reserve.  Adjust\n+  \/\/ the reserve downward to account for this possibility. This loss is part of the reason why the original budget\n+  \/\/ was adjusted with ShenandoahOldEvacWaste and ShenandoahOldPromoWaste multipliers.\n+  if (old_reserve_result >\n+      _partitions.capacity_of(ShenandoahFreeSetPartitionId::OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n+    old_reserve_result =\n+      _partitions.capacity_of(ShenandoahFreeSetPartitionId::OldCollector) + old_unaffiliated_regions * region_size_bytes;\n+  }\n+\n+  if (young_reserve_result > young_unaffiliated_regions * region_size_bytes) {\n+    young_reserve_result = young_unaffiliated_regions * region_size_bytes;\n+  }\n@@ -1133,1 +1718,6 @@\n-void ShenandoahFreeSet::reserve_regions(size_t to_reserve) {\n+\/\/ Having placed all regions that have allocation capacity into the mutator set if they identify as is_young()\n+\/\/ or into the old collector set if they identify as is_old(), move some of these regions from the mutator set\n+\/\/ into the collector set or old collector set in order to assure that the memory available for allocations within\n+\/\/ the collector set is at least to_reserve and the memory available for allocations within the old collector set\n+\/\/ is at least to_reserve_old.\n+void ShenandoahFreeSet::reserve_regions(size_t to_reserve, size_t to_reserve_old, size_t &old_region_count) {\n@@ -1137,1 +1727,0 @@\n-\n@@ -1143,1 +1732,2 @@\n-    assert (ac > 0, \"Membership in free partition implies has capacity\");\n+    assert (ac > 0, \"Membership in free set implies has capacity\");\n+    assert (!r->is_old() || r->is_trash(), \"Except for trash, mutator_is_free regions should not be affiliated OLD\");\n@@ -1145,0 +1735,1 @@\n+    bool move_to_old_collector = _partitions.available_in(ShenandoahFreeSetPartitionId::OldCollector) < to_reserve_old;\n@@ -1146,2 +1737,3 @@\n-    if (!move_to_collector) {\n-      \/\/ We've satisfied to_reserve\n+\n+    if (!move_to_collector && !move_to_old_collector) {\n+      \/\/ We've satisfied both to_reserve and to_reserved_old\n@@ -1151,0 +1743,20 @@\n+    if (move_to_old_collector) {\n+      \/\/ We give priority to OldCollector partition because we desire to pack OldCollector regions into higher\n+      \/\/ addresses than Collector regions.  Presumably, OldCollector regions are more \"stable\" and less likely to\n+      \/\/ be collected in the near future.\n+      if (r->is_trash() || !r->is_affiliated()) {\n+        \/\/ OLD regions that have available memory are already in the old_collector free set.\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                     ShenandoahFreeSetPartitionId::OldCollector, ac);\n+        log_debug(gc)(\"  Shifting region \" SIZE_FORMAT \" from mutator_free to old_collector_free\", idx);\n+        log_debug(gc)(\"  Shifted Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"],\"\n+                      \"  Old Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                      _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                      _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                      _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                      _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+        old_region_count++;\n+        continue;\n+      }\n+    }\n+\n@@ -1163,0 +1775,6 @@\n+      log_debug(gc)(\"  Shifted Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"],\"\n+                    \"  Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                    _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                    _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                    _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector),\n+                    _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -1167,0 +1785,5 @@\n+    size_t old_reserve = _partitions.available_in(ShenandoahFreeSetPartitionId::OldCollector);\n+    if (old_reserve < to_reserve_old) {\n+      log_info(gc, free)(\"Wanted \" PROPERFMT \" for old reserve, but only reserved: \" PROPERFMT,\n+                         PROPERFMTARGS(to_reserve_old), PROPERFMTARGS(old_reserve));\n+    }\n@@ -1175,0 +1798,31 @@\n+void ShenandoahFreeSet::establish_old_collector_alloc_bias() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  shenandoah_assert_heaplocked();\n+\n+  idx_t left_idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n+  idx_t right_idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector);\n+  idx_t middle = (left_idx + right_idx) \/ 2;\n+  size_t available_in_first_half = 0;\n+  size_t available_in_second_half = 0;\n+\n+  for (idx_t index = left_idx; index < middle; index++) {\n+    if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, index)) {\n+      ShenandoahHeapRegion* r = heap->get_region((size_t) index);\n+      available_in_first_half += r->free();\n+    }\n+  }\n+  for (idx_t index = middle; index <= right_idx; index++) {\n+    if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, index)) {\n+      ShenandoahHeapRegion* r = heap->get_region(index);\n+      available_in_second_half += r->free();\n+    }\n+  }\n+\n+  \/\/ We desire to first consume the sparsely distributed regions in order that the remaining regions are densely packed.\n+  \/\/ Densely packing regions reduces the effort to search for a region that has sufficient memory to satisfy a new allocation\n+  \/\/ request.  Regions become sparsely distributed following a Full GC, which tends to slide all regions to the front of the\n+  \/\/ heap rather than allowing survivor regions to remain at the high end of the heap where we intend for them to congregate.\n+  _partitions.set_bias_from_left_to_right(ShenandoahFreeSetPartitionId::OldCollector,\n+                                          (available_in_second_half > available_in_first_half));\n+}\n+\n@@ -1192,5 +1846,0 @@\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t consumed_collector = 0;\n-    size_t available_collector = 0;\n-    size_t consumed_mutator = 0;\n-    size_t available_mutator = 0;\n@@ -1202,3 +1851,7 @@\n-    log_debug(gc)(\"FreeSet map legend: M:mutator_free C:collector_free H:humongous _:retired\");\n-    log_debug(gc)(\" mutator free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"],\"\n-                  \" collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"]\",\n+\n+    log_debug(gc)(\"FreeSet map legend:\"\n+                       \" M:mutator_free C:collector_free O:old_collector_free\"\n+                       \" H:humongous ~:retired old _:retired young\");\n+    log_debug(gc)(\" mutator free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"] allocating from %s, \"\n+                  \" collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"], \"\n+                  \"old collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"] allocates from %s\",\n@@ -1207,0 +1860,1 @@\n+                  _partitions.alloc_from_left_bias(ShenandoahFreeSetPartitionId::Mutator)? \"left to right\": \"right to left\",\n@@ -1208,1 +1862,4 @@\n-                  _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector));\n+                  _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector),\n+                  _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                  _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                  _partitions.alloc_from_left_bias(ShenandoahFreeSetPartitionId::OldCollector)? \"left to right\": \"right to left\");\n@@ -1218,3 +1875,2 @@\n-        available_mutator += capacity;\n-        consumed_mutator += region_size_bytes - capacity;\n-        buffer[idx] = (capacity == region_size_bytes)? 'M': 'm';\n+        assert(!r->is_old() || r->is_trash(), \"Old regions except trash regions should not be in mutator_free set\");\n+        buffer[idx] = (capacity == ShenandoahHeapRegion::region_size_bytes()) ? 'M' : 'm';\n@@ -1223,3 +1879,5 @@\n-        available_collector += capacity;\n-        consumed_collector += region_size_bytes - capacity;\n-        buffer[idx] = (capacity == region_size_bytes)? 'C': 'c';\n+        assert(!r->is_old() || r->is_trash(), \"Old regions except trash regions should not be in collector_free set\");\n+        buffer[idx] = (capacity == ShenandoahHeapRegion::region_size_bytes()) ? 'C' : 'c';\n+      } else if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, i)) {\n+        size_t capacity = alloc_capacity(r);\n+        buffer[idx] = (capacity == ShenandoahHeapRegion::region_size_bytes()) ? 'O' : 'o';\n@@ -1227,1 +1885,5 @@\n-        buffer[idx] = 'h';\n+        if (r->is_old()) {\n+          buffer[idx] = 'H';\n+        } else {\n+          buffer[idx] = 'h';\n+        }\n@@ -1229,1 +1891,5 @@\n-        buffer[idx] = '_';\n+        if (r->is_old()) {\n+          buffer[idx] = '~';\n+        } else {\n+          buffer[idx] = '_';\n+        }\n@@ -1287,1 +1953,0 @@\n-\n@@ -1289,1 +1954,1 @@\n-               byte_size_in_proper_unit(free),          proper_unit_for_byte_size(free),\n+               byte_size_in_proper_unit(total_free),    proper_unit_for_byte_size(total_free),\n@@ -1336,0 +2001,21 @@\n+\n+    if (_heap->mode()->is_generational()) {\n+      size_t max = 0;\n+      size_t total_free = 0;\n+      size_t total_used = 0;\n+\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n+           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, idx)) {\n+          ShenandoahHeapRegion *r = _heap->get_region(idx);\n+          size_t free = alloc_capacity(r);\n+          max = MAX2(max, free);\n+          total_free += free;\n+          total_used += r->used();\n+        }\n+      }\n+      ls.print_cr(\" Old Collector Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s; Used: \" SIZE_FORMAT \"%s\",\n+                  byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n+                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n+                  byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n+    }\n@@ -1347,0 +2033,1 @@\n+      case ShenandoahAllocRequest::_alloc_plab:\n@@ -1363,4 +2050,2 @@\n-  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator mutator(const_cast<ShenandoahRegionPartitions*>(&_partitions), ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = mutator.current(); mutator.has_next(); index = mutator.next()) {\n@@ -1368,1 +2053,0 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -1370,0 +2054,1 @@\n+\n@@ -1371,4 +2056,2 @@\n-  rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator collector(const_cast<ShenandoahRegionPartitions*>(&_partitions), ShenandoahFreeSetPartitionId::Collector);\n+  for (idx_t index = collector.current(); collector.has_next(); index = collector.next()) {\n@@ -1376,1 +2059,10 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, index + 1);\n+  }\n+\n+  if (_heap->mode()->is_generational()) {\n+    out->print_cr(\"Old Collector Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::OldCollector));\n+    for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n+         index <= _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector); index++) {\n+      if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, index)) {\n+        _heap->get_region(index)->print_on(out);\n+      }\n+    }\n@@ -1384,4 +2076,2 @@\n-  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = iterator.current(); iterator.has_next(); index = iterator.next()) {\n@@ -1392,1 +2082,0 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -1407,1 +2096,0 @@\n-\n@@ -1410,4 +2098,2 @@\n-  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = iterator.current(); iterator.has_next(); index = iterator.next()) {\n@@ -1427,1 +2113,0 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":974,"deletions":289,"binary":false,"changes":1263,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+  OldCollector,                 \/\/ Region is in the Old Collector free set:\n+                                \/\/    available memory is reserved for old evacuations and for promotions..\n@@ -83,0 +85,4 @@\n+  \/\/ For each partition p, _left_to_right_bias is true iff allocations are normally made from lower indexed regions\n+  \/\/ before higher indexed regions.\n+  bool _left_to_right_bias[UIntNumPartitions];\n+\n@@ -91,0 +97,5 @@\n+  inline bool is_mutator_partition(ShenandoahFreeSetPartitionId p);\n+  inline bool is_young_collector_partition(ShenandoahFreeSetPartitionId p);\n+  inline bool is_old_collector_partition(ShenandoahFreeSetPartitionId p);\n+  inline bool available_implies_empty(size_t available);\n+\n@@ -115,0 +126,7 @@\n+  \/\/ Set the OldCollector intervals, usage, and capacity according to arguments.  We use this at the end of rebuild_free_set()\n+  \/\/ to avoid the overhead of making many redundant incremental adjustments to the mutator intervals as the free set is being\n+  \/\/ rebuilt.\n+  void establish_old_collector_intervals(ssize_t old_collector_leftmost, ssize_t old_collector_rightmost,\n+                                         ssize_t old_collector_leftmost_empty, ssize_t old_collector_rightmost_empty,\n+                                         size_t old_collector_region_count, size_t old_collector_used);\n+\n@@ -183,0 +201,10 @@\n+  inline void set_bias_from_left_to_right(ShenandoahFreeSetPartitionId which_partition, bool value) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    _left_to_right_bias[int(which_partition)] = value;\n+  }\n+\n+  inline bool alloc_from_left_bias(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _left_to_right_bias[int(which_partition)];\n+  }\n+\n@@ -240,1 +268,1 @@\n-\/\/ The ShenandoahFreeSet endeavors to congregrate survivor objects (objects that have been evacuated at least once) at the\n+\/\/ The ShenandoahFreeSet tries to colocate survivor objects (objects that have been evacuated at least once) at the\n@@ -263,4 +291,6 @@\n-  \/\/ Mutator allocations are biased from left-to-right or from right-to-left based on which end of mutator range\n-  \/\/ is most likely to hold partially used regions.  In general, we want to finish consuming partially used\n-  \/\/ regions and retire them in order to reduce the regions that must be searched for each allocation request.\n-  bool _right_to_left_bias;\n+  HeapWord* allocate_aligned_plab(size_t size, ShenandoahAllocRequest& req, ShenandoahHeapRegion* r);\n+\n+  \/\/ Return the address of memory allocated, setting in_new_region to true iff the allocation is taken\n+  \/\/ from a region that was previously empty.  Return nullptr if memory could not be allocated.\n+  inline HeapWord* allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n+                                                            ShenandoahAllocRequest& req, bool& in_new_region);\n@@ -273,1 +303,1 @@\n-  const ssize_t _InitialAllocBiasWeight = 256;\n+  const ssize_t INITIAL_ALLOC_BIAS_WEIGHT = 256;\n@@ -275,0 +305,2 @@\n+  \/\/ Increases used memory for the partition if the allocation is successful. `in_new_region` will be set\n+  \/\/ if this is the first allocation in the region.\n@@ -290,1 +322,3 @@\n-  \/\/ Change region r from the Mutator partition to the GC's Collector partition.  This requires that the region is entirely empty.\n+  \/\/ Change region r from the Mutator partition to the GC's Collector or OldCollector partition.  This requires that the\n+  \/\/ region is entirely empty.\n+  \/\/\n@@ -293,1 +327,1 @@\n-  \/\/ the Mutator free set into the Collector free set.\n+  \/\/ the Mutator free set into the Collector or OldCollector free set.\n@@ -295,0 +329,25 @@\n+  void flip_to_old_gc(ShenandoahHeapRegion* r);\n+\n+  \/\/ Handle allocation for mutator.\n+  HeapWord* allocate_for_mutator(ShenandoahAllocRequest &req, bool &in_new_region);\n+\n+  \/\/ Update allocation bias and decided whether to allocate from the left or right side of the heap.\n+  void update_allocation_bias();\n+\n+  \/\/ Search for regions to satisfy allocation request using iterator.\n+  template<typename Iter>\n+  HeapWord* allocate_from_regions(Iter& iterator, ShenandoahAllocRequest &req, bool &in_new_region);\n+\n+  \/\/ Handle allocation for collector (for evacuation).\n+  HeapWord* allocate_for_collector(ShenandoahAllocRequest& req, bool& in_new_region);\n+\n+  \/\/ Search for allocation in region with same affiliation as request, using given iterator.\n+  template<typename Iter>\n+  HeapWord* allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n+\n+  \/\/ Return true if the respective generation for this request has free regions.\n+  bool can_allocate_in_new_region(const ShenandoahAllocRequest& req);\n+\n+  \/\/ Attempt to allocate memory for an evacuation from the mutator's partition.\n+  HeapWord* try_allocate_from_mutator(ShenandoahAllocRequest& req, bool& in_new_region);\n+\n@@ -306,5 +365,6 @@\n-  \/\/ This function places all regions that have allocation capacity into the mutator_partition, identifying regions\n-  \/\/ that have no allocation capacity as NotFree.  Subsequently, we will move some of the mutator regions into the\n-  \/\/ collector partition with the intent of packing collector memory into the highest (rightmost) addresses of the\n-  \/\/ heap, with mutator memory consuming the lowest addresses of the heap.\n-  void find_regions_with_alloc_capacity(size_t &cset_regions);\n+  size_t transfer_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n+                                                                  size_t max_xfer_regions,\n+                                                                  size_t& bytes_transferred);\n+  size_t transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n+                                                                      size_t max_xfer_regions,\n+                                                                      size_t& bytes_transferred);\n@@ -312,4 +372,0 @@\n-  \/\/ Having placed all regions that have allocation capacity into the mutator partition, move some of these regions from\n-  \/\/ the mutator partition into the collector partition in order to assure that the memory available for allocations within\n-  \/\/ the collector partition is at least to_reserve.\n-  void reserve_regions(size_t to_reserve);\n@@ -317,2 +373,2 @@\n-  \/\/ Overwrite arguments to represent the number of regions to be reclaimed from the cset\n-  void prepare_to_rebuild(size_t &cset_regions);\n+  \/\/ Determine whether we prefer to allocate from left to right or from right to left within the OldCollector free-set.\n+  void establish_old_collector_alloc_bias();\n@@ -320,1 +376,3 @@\n-  void finish_rebuild(size_t cset_regions);\n+  \/\/ Set max_capacity for young and old generations\n+  void establish_generation_sizes(size_t young_region_count, size_t old_region_count);\n+  size_t get_usable_free_words(size_t free_bytes) const;\n@@ -333,1 +391,37 @@\n-  void rebuild();\n+\n+  \/\/ Examine the existing free set representation, capturing the current state into var arguments:\n+  \/\/\n+  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n+  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/   first_old_region is the index of the first region that is part of the OldCollector set\n+  \/\/    last_old_region is the index of the last region that is part of the OldCollector set\n+  \/\/   old_region_count is the number of regions in the OldCollector set that have memory available to be allocated\n+  void prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+                          size_t &first_old_region, size_t &last_old_region, size_t &old_region_count);\n+\n+  \/\/ At the end of final mark, but before we begin evacuating, heuristics calculate how much memory is required to\n+  \/\/ hold the results of evacuating to young-gen and to old-gen, and have_evacuation_reserves should be true.\n+  \/\/ These quantities, stored as reserves for their respective generations, are consulted prior to rebuilding\n+  \/\/ the free set (ShenandoahFreeSet) in preparation for evacuation.  When the free set is rebuilt, we make sure\n+  \/\/ to reserve sufficient memory in the collector and old_collector sets to hold evacuations.\n+  \/\/\n+  \/\/ We also rebuild the free set at the end of GC, as we prepare to idle GC until the next trigger.  In this case,\n+  \/\/ have_evacuation_reserves is false because we don't yet know how much memory will need to be evacuated in the\n+  \/\/ next GC cycle.  When have_evacuation_reserves is false, the free set rebuild operation reserves for the collector\n+  \/\/ and old_collector sets based on alternative mechanisms, such as ShenandoahEvacReserve, ShenandoahOldEvacReserve, and\n+  \/\/ ShenandoahOldCompactionReserve.  In a future planned enhancement, the reserve for old_collector set when the\n+  \/\/ evacuation reserves are unknown, is based in part on anticipated promotion as determined by analysis of live data\n+  \/\/ found during the previous GC pass which is one less than the current tenure age.\n+  \/\/\n+  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n+  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/    num_old_regions is the number of old-gen regions that have available memory for further allocations (excluding old cset)\n+  \/\/ have_evacuation_reserves is true iff the desired values of young-gen and old-gen evacuation reserves and old-gen\n+  \/\/                    promotion reserve have been precomputed (and can be obtained by invoking\n+  \/\/                    <generation>->get_evacuation_reserve() or old_gen->get_promoted_reserve()\n+  void finish_rebuild(size_t young_cset_regions, size_t old_cset_regions, size_t num_old_regions,\n+                      bool have_evacuation_reserves = false);\n+\n+  \/\/ When a region is promoted in place, we add the region's available memory if it is greater than plab_min_size()\n+  \/\/ into the old collector partition by invoking this method.\n+  void add_promoted_in_place_region_to_old_collector(ShenandoahHeapRegion* region);\n@@ -339,5 +433,0 @@\n-  \/\/\n-  \/\/ Note that we plan to replenish the Collector reserve at the end of update refs, at which time all\n-  \/\/ of the regions recycled from the collection set will be available.  If the very unlikely event that there\n-  \/\/ are fewer regions in the collection set than remain in the collector set, we limit the transfer in order\n-  \/\/ to assure that the replenished Collector reserve can be sufficiently large.\n@@ -347,0 +436,1 @@\n+\n@@ -358,1 +448,0 @@\n-  size_t unsafe_peek_free() const;\n@@ -399,0 +488,22 @@\n+\n+  \/\/ This function places all regions that have allocation capacity into the mutator partition, or if the region\n+  \/\/ is already affiliated with old, into the old collector partition, identifying regions that have no allocation\n+  \/\/ capacity as NotFree.  Capture the modified state of the freeset into var arguments:\n+  \/\/\n+  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n+  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/   first_old_region is the index of the first region that is part of the OldCollector set\n+  \/\/    last_old_region is the index of the last region that is part of the OldCollector set\n+  \/\/   old_region_count is the number of regions in the OldCollector set that have memory available to be allocated\n+  void find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions,\n+                                        size_t &first_old_region, size_t &last_old_region, size_t &old_region_count);\n+\n+  \/\/ Ensure that Collector has at least to_reserve bytes of available memory, and OldCollector has at least old_reserve\n+  \/\/ bytes of available memory.  On input, old_region_count holds the number of regions already present in the\n+  \/\/ OldCollector partition.  Upon return, old_region_count holds the updated number of regions in the OldCollector partition.\n+  void reserve_regions(size_t to_reserve, size_t old_reserve, size_t &old_region_count);\n+\n+  \/\/ Reserve space for evacuations, with regions reserved for old evacuations placed to the right\n+  \/\/ of regions reserved of young evacuations.\n+  void compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves,\n+                                      size_t &young_reserve_result, size_t &old_reserve_result) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":138,"deletions":27,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -39,0 +40,1 @@\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n@@ -41,0 +43,2 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalFullGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n@@ -44,0 +48,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -60,1 +65,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -112,0 +116,4 @@\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahGenerationalFullGC::handle_completion(heap);\n+  }\n+\n@@ -123,1 +131,1 @@\n-  heap->heuristics()->record_success_full();\n+  heap->global_generation()->heuristics()->record_success_full();\n@@ -130,0 +138,4 @@\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahGenerationalFullGC::prepare();\n+  }\n+\n@@ -172,1 +184,1 @@\n-    \/\/ b. Cancel concurrent mark, if in progress\n+    \/\/ b. Cancel all concurrent marks, if in progress\n@@ -174,2 +186,1 @@\n-      ShenandoahConcurrentGC::cancel();\n-      heap->set_concurrent_mark_in_progress(false);\n+      heap->cancel_concurrent_mark();\n@@ -185,1 +196,1 @@\n-    heap->reset_mark_bitmap();\n+    heap->global_generation()->reset_mark_bitmap();\n@@ -187,1 +198,1 @@\n-    assert(!heap->marking_context()->is_complete(), \"sanity\");\n+    assert(!heap->global_generation()->is_mark_complete(), \"sanity\");\n@@ -190,1 +201,1 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n@@ -196,0 +207,4 @@\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGenerationalFullGC::restore_top_before_promote(heap);\n+    }\n+\n@@ -203,0 +218,1 @@\n+    \/\/ Note: PLABs are also retired with GCLABs in generational mode.\n@@ -276,1 +292,1 @@\n-  void heap_region_do(ShenandoahHeapRegion *r) {\n+  void heap_region_do(ShenandoahHeapRegion *r) override {\n@@ -281,1 +297,1 @@\n-  bool is_thread_safe() { return true; }\n+  bool is_thread_safe() override { return true; }\n@@ -290,1 +306,2 @@\n-  ShenandoahPrepareForMarkClosure cl;\n+  ShenandoahPrepareForMarkClosure prepare_for_mark;\n+  ShenandoahExcludeRegionClosure<FREE> cl(&prepare_for_mark);\n@@ -293,1 +310,1 @@\n-  heap->set_unload_classes(heap->heuristics()->can_unload_classes());\n+  heap->set_unload_classes(heap->global_generation()->heuristics()->can_unload_classes());\n@@ -295,1 +312,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n@@ -299,1 +316,1 @@\n-  ShenandoahSTWMark mark(true \/*full_gc*\/);\n+  ShenandoahSTWMark mark(heap->global_generation(), true \/*full_gc*\/);\n@@ -302,0 +319,4 @@\n+\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalFullGC::log_live_in_old(heap);\n+  }\n@@ -429,2 +450,8 @@\n-  ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks->get(worker_id), empty_regions, from_region);\n-  prepare_for_compaction(cl, empty_regions, it, from_region);\n+  if (_heap->mode()->is_generational()) {\n+    ShenandoahPrepareForGenerationalCompactionObjectClosure cl(_preserved_marks->get(worker_id),\n+                                                               empty_regions, from_region, worker_id);\n+    prepare_for_compaction(cl, empty_regions, it, from_region);\n+  } else {\n+    ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks->get(worker_id), empty_regions, from_region);\n+    prepare_for_compaction(cl, empty_regions, it, from_region);\n+  }\n@@ -477,0 +504,1 @@\n+  log_debug(gc)(\"Full GC calculating target humongous objects from end \" SIZE_FORMAT, to_end);\n@@ -519,0 +547,1 @@\n+      \/\/ Leave affiliation unchanged\n@@ -542,1 +571,1 @@\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n@@ -546,2 +575,1 @@\n-        assert(!r->has_live(),\n-               \"Region \" SIZE_FORMAT \" is not marked, should not have live\", r->index());\n+        assert(!r->has_live(), \"Region \" SIZE_FORMAT \" is not marked, should not have live\", r->index());\n@@ -550,2 +578,1 @@\n-        assert(r->has_live(),\n-               \"Region \" SIZE_FORMAT \" should have live\", r->index());\n+        assert(r->has_live(), \"Region \" SIZE_FORMAT \" should have live\", r->index());\n@@ -555,2 +582,1 @@\n-      assert(r->humongous_start_region()->has_live(),\n-             \"Region \" SIZE_FORMAT \" should have live\", r->index());\n+      assert(r->humongous_start_region()->has_live(), \"Region \" SIZE_FORMAT \" should have live\", r->index());\n@@ -719,2 +745,3 @@\n-    ShenandoahTrashImmediateGarbageClosure tigcl;\n-    heap->heap_region_iterate(&tigcl);\n+    ShenandoahTrashImmediateGarbageClosure trash_immediate_garbage;\n+    ShenandoahExcludeRegionClosure<FREE> cl(&trash_immediate_garbage);\n+    heap->heap_region_iterate(&cl);\n@@ -808,0 +835,3 @@\n+      if (_heap->mode()->is_generational()) {\n+        ShenandoahGenerationalFullGC::maybe_coalesce_and_fill_region(r);\n+      }\n@@ -912,1 +942,3 @@\n-  size_t _live;\n+  bool _is_generational;\n+  size_t _young_regions, _young_usage, _young_humongous_waste;\n+  size_t _old_regions, _old_usage, _old_humongous_waste;\n@@ -915,1 +947,10 @@\n-  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()), _live(0) {\n+  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()),\n+                                   _is_generational(_heap->mode()->is_generational()),\n+                                   _young_regions(0),\n+                                   _young_usage(0),\n+                                   _young_humongous_waste(0),\n+                                   _old_regions(0),\n+                                   _old_usage(0),\n+                                   _old_humongous_waste(0)\n+  {\n+    _heap->free_set()->clear();\n@@ -934,0 +975,4 @@\n+      if (!_is_generational) {\n+        r->make_affiliated_maybe();\n+      }\n+      \/\/ else, generational mode compaction has already established affiliation.\n@@ -949,0 +994,6 @@\n+    } else {\n+      if (r->is_old()) {\n+        ShenandoahGenerationalFullGC::account_for_region(r, _old_regions, _old_usage, _old_humongous_waste);\n+      } else if (r->is_young()) {\n+        ShenandoahGenerationalFullGC::account_for_region(r, _young_regions, _young_usage, _young_humongous_waste);\n+      }\n@@ -950,1 +1001,0 @@\n-\n@@ -953,1 +1003,0 @@\n-    _live += live;\n@@ -956,2 +1005,15 @@\n-  size_t get_live() {\n-    return _live;\n+  void update_generation_usage() {\n+    if (_is_generational) {\n+      _heap->old_generation()->establish_usage(_old_regions, _old_usage, _old_humongous_waste);\n+      _heap->young_generation()->establish_usage(_young_regions, _young_usage, _young_humongous_waste);\n+    } else {\n+      assert(_old_regions == 0, \"Old regions only expected in generational mode\");\n+      assert(_old_usage == 0, \"Old usage only expected in generational mode\");\n+      assert(_old_humongous_waste == 0, \"Old humongous waste only expected in generational mode\");\n+    }\n+\n+    \/\/ In generational mode, global usage should be the sum of young and old. This is also true\n+    \/\/ for non-generational modes except that there are no old regions.\n+    _heap->global_generation()->establish_usage(_old_regions + _young_regions,\n+                                                _old_usage + _young_usage,\n+                                                _old_humongous_waste + _young_humongous_waste);\n@@ -988,0 +1050,1 @@\n+      log_debug(gc)(\"Full GC compaction moves humongous object from region \" SIZE_FORMAT \" to region \" SIZE_FORMAT, old_start, new_start);\n@@ -995,0 +1058,1 @@\n+        ShenandoahAffiliation original_affiliation = r->affiliation();\n@@ -997,0 +1061,1 @@\n+          \/\/ Leave humongous region affiliation unchanged.\n@@ -1004,1 +1069,1 @@\n-            r->make_humongous_start_bypass();\n+            r->make_humongous_start_bypass(original_affiliation);\n@@ -1006,1 +1071,1 @@\n-            r->make_humongous_cont_bypass();\n+            r->make_humongous_cont_bypass(original_affiliation);\n@@ -1091,1 +1156,5 @@\n-    heap->set_used(post_compact.get_live());\n+    post_compact.update_generation_usage();\n+\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGenerationalFullGC::balance_generations_after_gc(heap);\n+    }\n@@ -1094,2 +1163,13 @@\n-    heap->free_set()->rebuild();\n-    heap->clear_cancelled_gc();\n+    size_t young_cset_regions, old_cset_regions;\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+\n+    \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n+    \/\/ no longer have objects separated by age into distinct regions.\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGenerationalFullGC::compute_balances();\n+    }\n+\n+    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n+\n+    heap->clear_cancelled_gc(true \/* clear oom handler *\/);\n@@ -1100,0 +1180,7 @@\n+\n+  \/\/ We defer generation resizing actions until after cset regions have been recycled.  We do this even following an\n+  \/\/ abbreviated cycle.\n+  if (heap->mode()->is_generational()) {\n+    ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set();\n+    ShenandoahGenerationalFullGC::rebuild_remembered_set(heap);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":123,"deletions":36,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+    case _degenerated_roots:\n+      return \"Roots\";\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    _degenerated_roots,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1035 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSetPreselector.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahTaskqueue.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+#include \"utilities\/quickSort.hpp\"\n+\n+\n+class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeap* _heap;\n+  ShenandoahMarkingContext* const _ctx;\n+public:\n+  ShenandoahResetUpdateRegionStateClosure() :\n+    _heap(ShenandoahHeap::heap()),\n+    _ctx(_heap->marking_context()) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->is_active()) {\n+      \/\/ Reset live data and set TAMS optimistically. We would recheck these under the pause\n+      \/\/ anyway to capture any updates that happened since now.\n+      _ctx->capture_top_at_mark_start(r);\n+      r->clear_live_data();\n+    }\n+  }\n+\n+  bool is_thread_safe() override { return true; }\n+};\n+\n+class ShenandoahResetBitmapTask : public WorkerTask {\n+private:\n+  ShenandoahRegionIterator _regions;\n+  ShenandoahGeneration* _generation;\n+\n+public:\n+  ShenandoahResetBitmapTask(ShenandoahGeneration* generation) :\n+    WorkerTask(\"Shenandoah Reset Bitmap\"), _generation(generation) {}\n+\n+  void work(uint worker_id) {\n+    ShenandoahHeapRegion* region = _regions.next();\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    ShenandoahMarkingContext* const ctx = heap->marking_context();\n+    while (region != nullptr) {\n+      auto const affiliation = region->affiliation();\n+      bool needs_reset = affiliation == FREE || _generation->contains(affiliation);\n+      if (needs_reset && heap->is_bitmap_slice_committed(region)) {\n+        ctx->clear_bitmap(region);\n+      }\n+      region = _regions.next();\n+    }\n+  }\n+};\n+\n+\/\/ Copy the write-version of the card-table into the read-version, clearing the\n+\/\/ write-copy.\n+class ShenandoahMergeWriteTable: public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahScanRemembered* _scanner;\n+public:\n+  ShenandoahMergeWriteTable(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    assert(r->is_old(), \"Don't waste time doing this for non-old regions\");\n+    _scanner->merge_write_table(r->bottom(), ShenandoahHeapRegion::region_size_words());\n+  }\n+\n+  bool is_thread_safe() override {\n+    return true;\n+  }\n+};\n+\n+class ShenandoahCopyWriteCardTableToRead: public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahScanRemembered* _scanner;\n+public:\n+  ShenandoahCopyWriteCardTableToRead(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* region) override {\n+    assert(region->is_old(), \"Don't waste time doing this for non-old regions\");\n+    _scanner->reset_remset(region->bottom(), ShenandoahHeapRegion::region_size_words());\n+  }\n+\n+  bool is_thread_safe() override { return true; }\n+};\n+\n+\/\/ Add [TAMS, top) volume over young regions. Used to correct age 0 cohort census\n+\/\/ for adaptive tenuring when census is taken during marking.\n+\/\/ In non-product builds, for the purposes of verification, we also collect the total\n+\/\/ live objects in young regions as well.\n+class ShenandoahUpdateCensusZeroCohortClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+  \/\/ Population size units are words (not bytes)\n+  size_t _age0_pop;                \/\/ running tally of age0 population size\n+  size_t _total_pop;               \/\/ total live population size\n+public:\n+  explicit ShenandoahUpdateCensusZeroCohortClosure(ShenandoahMarkingContext* ctx)\n+    : _ctx(ctx), _age0_pop(0), _total_pop(0) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (_ctx != nullptr && r->is_active()) {\n+      assert(r->is_young(), \"Young regions only\");\n+      HeapWord* tams = _ctx->top_at_mark_start(r);\n+      HeapWord* top  = r->top();\n+      if (top > tams) {\n+        _age0_pop += pointer_delta(top, tams);\n+      }\n+      \/\/ TODO: check significance of _ctx != nullptr above, can that\n+      \/\/ spoof _total_pop in some corner cases?\n+      NOT_PRODUCT(_total_pop += r->get_live_data_words();)\n+    }\n+  }\n+\n+  size_t get_age0_population()  const { return _age0_pop; }\n+  size_t get_total_population() const { return _total_pop; }\n+};\n+\n+void ShenandoahGeneration::confirm_heuristics_mode() {\n+  if (_heuristics->is_diagnostic() && !UnlockDiagnosticVMOptions) {\n+    vm_exit_during_initialization(\n+            err_msg(\"Heuristics \\\"%s\\\" is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.\",\n+                    _heuristics->name()));\n+  }\n+  if (_heuristics->is_experimental() && !UnlockExperimentalVMOptions) {\n+    vm_exit_during_initialization(\n+            err_msg(\"Heuristics \\\"%s\\\" is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.\",\n+                    _heuristics->name()));\n+  }\n+}\n+\n+ShenandoahHeuristics* ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  _heuristics = gc_mode->initialize_heuristics(this);\n+  _heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedGCInterval);\n+  confirm_heuristics_mode();\n+  return _heuristics;\n+}\n+\n+size_t ShenandoahGeneration::bytes_allocated_since_gc_start() const {\n+  return Atomic::load(&_bytes_allocated_since_gc_start);\n+}\n+\n+void ShenandoahGeneration::reset_bytes_allocated_since_gc_start() {\n+  Atomic::store(&_bytes_allocated_since_gc_start, (size_t)0);\n+}\n+\n+void ShenandoahGeneration::increase_allocated(size_t bytes) {\n+  Atomic::add(&_bytes_allocated_since_gc_start, bytes, memory_order_relaxed);\n+}\n+\n+void ShenandoahGeneration::set_evacuation_reserve(size_t new_val) {\n+  _evacuation_reserve = new_val;\n+}\n+\n+size_t ShenandoahGeneration::get_evacuation_reserve() const {\n+  return _evacuation_reserve;\n+}\n+\n+void ShenandoahGeneration::augment_evacuation_reserve(size_t increment) {\n+  _evacuation_reserve += increment;\n+}\n+\n+void ShenandoahGeneration::log_status(const char *msg) const {\n+  typedef LogTarget(Info, gc, ergo) LogGcInfo;\n+\n+  if (!LogGcInfo::is_enabled()) {\n+    return;\n+  }\n+\n+  \/\/ Not under a lock here, so read each of these once to make sure\n+  \/\/ byte size in proper unit and proper unit for byte size are consistent.\n+  size_t v_used = used();\n+  size_t v_used_regions = used_regions_size();\n+  size_t v_soft_max_capacity = soft_max_capacity();\n+  size_t v_max_capacity = max_capacity();\n+  size_t v_available = available();\n+  size_t v_humongous_waste = get_humongous_waste();\n+  LogGcInfo::print(\"%s: %s generation used: \" SIZE_FORMAT \"%s, used regions: \" SIZE_FORMAT \"%s, \"\n+                   \"humongous waste: \" SIZE_FORMAT \"%s, soft capacity: \" SIZE_FORMAT \"%s, max capacity: \" SIZE_FORMAT \"%s, \"\n+                   \"available: \" SIZE_FORMAT \"%s\", msg, name(),\n+                   byte_size_in_proper_unit(v_used),              proper_unit_for_byte_size(v_used),\n+                   byte_size_in_proper_unit(v_used_regions),      proper_unit_for_byte_size(v_used_regions),\n+                   byte_size_in_proper_unit(v_humongous_waste),   proper_unit_for_byte_size(v_humongous_waste),\n+                   byte_size_in_proper_unit(v_soft_max_capacity), proper_unit_for_byte_size(v_soft_max_capacity),\n+                   byte_size_in_proper_unit(v_max_capacity),      proper_unit_for_byte_size(v_max_capacity),\n+                   byte_size_in_proper_unit(v_available),         proper_unit_for_byte_size(v_available));\n+}\n+\n+void ShenandoahGeneration::reset_mark_bitmap() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->assert_gc_workers(heap->workers()->active_workers());\n+\n+  set_mark_incomplete();\n+\n+  ShenandoahResetBitmapTask task(this);\n+  heap->workers()->run_task(&task);\n+}\n+\n+\/\/ The ideal is to swap the remembered set so the safepoint effort is no more than a few pointer manipulations.\n+\/\/ However, limitations in the implementation of the mutator write-barrier make it difficult to simply change the\n+\/\/ location of the card table.  So the interim implementation of swap_remembered_set will copy the write-table\n+\/\/ onto the read-table and will then clear the write-table.\n+void ShenandoahGeneration::swap_remembered_set() {\n+  \/\/ Must be sure that marking is complete before we swap remembered set.\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  heap->assert_gc_workers(heap->workers()->active_workers());\n+  shenandoah_assert_safepoint();\n+\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahCopyWriteCardTableToRead task(old_generation->card_scan());\n+  old_generation->parallel_heap_region_iterate(&task);\n+}\n+\n+\/\/ Copy the write-version of the card-table into the read-version, clearing the\n+\/\/ write-version. The work is done at a safepoint and in parallel by the GC\n+\/\/ worker threads.\n+void ShenandoahGeneration::merge_write_table() {\n+  \/\/ This should only happen for degenerated cycles\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  heap->assert_gc_workers(heap->workers()->active_workers());\n+  shenandoah_assert_safepoint();\n+\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahMergeWriteTable task(old_generation->card_scan());\n+  old_generation->parallel_heap_region_iterate(&task);\n+}\n+\n+void ShenandoahGeneration::prepare_gc() {\n+\n+  reset_mark_bitmap();\n+\n+  \/\/ Capture Top At Mark Start for this generation (typically young) and reset mark bitmap.\n+  ShenandoahResetUpdateRegionStateClosure cl;\n+  parallel_heap_region_iterate_free(&cl);\n+}\n+\n+void ShenandoahGeneration::parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(cl);\n+}\n+\n+void ShenandoahGeneration::compute_evacuation_budgets(ShenandoahHeap* const heap) {\n+  shenandoah_assert_generational();\n+\n+  ShenandoahOldGeneration* const old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* const young_generation = heap->young_generation();\n+\n+  \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n+  \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n+  \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n+  \/\/ of execution.\n+\n+  \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n+  \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n+  \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n+  \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n+\n+  \/\/ First priority is to reclaim the easy garbage out of young-gen.\n+\n+  \/\/ maximum_young_evacuation_reserve is upper bound on memory to be evacuated out of young\n+  const size_t maximum_young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+  const size_t young_evacuation_reserve = MIN2(maximum_young_evacuation_reserve, young_generation->available_with_reserve());\n+\n+  \/\/ maximum_old_evacuation_reserve is an upper bound on memory evacuated from old and evacuated to old (promoted),\n+  \/\/ clamped by the old generation space available.\n+  \/\/\n+  \/\/ Here's the algebra.\n+  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+  \/\/     OE = old evac,\n+  \/\/     YE = young evac, and\n+  \/\/     TE = total evac = OE + YE\n+  \/\/ By definition:\n+  \/\/            SOEP\/100 = OE\/TE\n+  \/\/                     = OE\/(OE+YE)\n+  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)         \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n+  \/\/                     = OE\/YE\n+  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n+\n+  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n+  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  const size_t old_available = old_generation->available();\n+  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacRatioPercent == 100) ?\n+    old_available : MIN2((maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n+                          old_available);\n+\n+\n+  \/\/ Second priority is to reclaim garbage out of old-gen if there are old-gen collection candidates.  Third priority\n+  \/\/ is to promote as much as we have room to promote.  However, if old-gen memory is in short supply, this means young\n+  \/\/ GC is operating under \"duress\" and was unable to transfer the memory that we would normally expect.  In this case,\n+  \/\/ old-gen will refrain from compacting itself in order to allow a quicker young-gen cycle (by avoiding the update-refs\n+  \/\/ through ALL of old-gen).  If there is some memory available in old-gen, we will use this for promotions as promotions\n+  \/\/ do not add to the update-refs burden of GC.\n+\n+  size_t old_evacuation_reserve, old_promo_reserve;\n+  if (is_global()) {\n+    \/\/ Global GC is typically triggered by user invocation of System.gc(), and typically indicates that there is lots\n+    \/\/ of garbage to be reclaimed because we are starting a new phase of execution.  Marking for global GC may take\n+    \/\/ significantly longer than typical young marking because we must mark through all old objects.  To expedite\n+    \/\/ evacuation and update-refs, we give emphasis to reclaiming garbage first, wherever that garbage is found.\n+    \/\/ Global GC will adjust generation sizes to accommodate the collection set it chooses.\n+\n+    \/\/ Set old_promo_reserve to enforce that no regions are preselected for promotion.  Such regions typically\n+    \/\/ have relatively high memory utilization.  We still call select_aged_regions() because this will prepare for\n+    \/\/ promotions in place, if relevant.\n+    old_promo_reserve = 0;\n+\n+    \/\/ Dedicate all available old memory to old_evacuation reserve.  This may be small, because old-gen is only\n+    \/\/ expanded based on an existing mixed evacuation workload at the end of the previous GC cycle.  We'll expand\n+    \/\/ the budget for evacuation of old during GLOBAL cset selection.\n+    old_evacuation_reserve = maximum_old_evacuation_reserve;\n+  } else if (old_generation->has_unprocessed_collection_candidates()) {\n+    \/\/ We reserved all old-gen memory at end of previous GC to hold anticipated evacuations to old-gen.  If this is\n+    \/\/ mixed evacuation, reserve all of this memory for compaction of old-gen and do not promote.  Prioritize compaction\n+    \/\/ over promotion in order to defragment OLD so that it will be better prepared to efficiently receive promoted memory.\n+    old_evacuation_reserve = maximum_old_evacuation_reserve;\n+    old_promo_reserve = 0;\n+  } else {\n+    \/\/ Make all old-evacuation memory for promotion, but if we can't use it all for promotion, we'll allow some evacuation.\n+    old_evacuation_reserve = 0;\n+    old_promo_reserve = maximum_old_evacuation_reserve;\n+  }\n+  assert(old_evacuation_reserve <= old_available, \"Error\");\n+\n+  \/\/ We see too many old-evacuation failures if we force ourselves to evacuate into regions that are not initially empty.\n+  \/\/ So we limit the old-evacuation reserve to unfragmented memory.  Even so, old-evacuation is free to fill in nooks and\n+  \/\/ crannies within existing partially used regions and it generally tries to do so.\n+  const size_t old_free_unfragmented = old_generation->free_unaffiliated_regions() * ShenandoahHeapRegion::region_size_bytes();\n+  if (old_evacuation_reserve > old_free_unfragmented) {\n+    const size_t delta = old_evacuation_reserve - old_free_unfragmented;\n+    old_evacuation_reserve -= delta;\n+    \/\/ Let promo consume fragments of old-gen memory if not global\n+    if (!is_global()) {\n+      old_promo_reserve += delta;\n+    }\n+  }\n+\n+  \/\/ Preselect regions for promotion by evacuation (obtaining the live data to seed promoted_reserve),\n+  \/\/ and identify regions that will promote in place. These use the tenuring threshold.\n+  const size_t consumed_by_advance_promotion = select_aged_regions(old_promo_reserve);\n+  assert(consumed_by_advance_promotion <= maximum_old_evacuation_reserve, \"Cannot promote more than available old-gen memory\");\n+\n+  \/\/ Note that unused old_promo_reserve might not be entirely consumed_by_advance_promotion.  Do not transfer this\n+  \/\/ to old_evacuation_reserve because this memory is likely very fragmented, and we do not want to increase the likelihood\n+  \/\/ of old evacuation failure.\n+  young_generation->set_evacuation_reserve(young_evacuation_reserve);\n+  old_generation->set_evacuation_reserve(old_evacuation_reserve);\n+  old_generation->set_promoted_reserve(consumed_by_advance_promotion);\n+\n+  \/\/ There is no need to expand OLD because all memory used here was set aside at end of previous GC, except in the\n+  \/\/ case of a GLOBAL gc.  During choose_collection_set() of GLOBAL, old will be expanded on demand.\n+}\n+\n+\/\/ Having chosen the collection set, adjust the budgets for generational mode based on its composition.  Note\n+\/\/ that young_generation->available() now knows about recently discovered immediate garbage.\n+\/\/\n+void ShenandoahGeneration::adjust_evacuation_budgets(ShenandoahHeap* const heap, ShenandoahCollectionSet* const collection_set) {\n+  shenandoah_assert_generational();\n+  \/\/ We may find that old_evacuation_reserve and\/or loaned_for_young_evacuation are not fully consumed, in which case we may\n+  \/\/  be able to increase regions_available_to_loan\n+\n+  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions_available_to_loan and to make\n+  \/\/ effective use of this memory, including the remnant memory within these regions that may result from rounding loan to\n+  \/\/ integral number of regions.  Excess memory that is available to be loaned is applied to an allocation supplement,\n+  \/\/ which allows mutators to allocate memory beyond the current capacity of young-gen on the promise that the loan\n+  \/\/ will be repaid as soon as we finish updating references for the recently evacuated collection set.\n+\n+  \/\/ We cannot recalculate regions_available_to_loan by simply dividing old_generation->available() by region_size_bytes\n+  \/\/ because the available memory may be distributed between many partially occupied regions that are already holding old-gen\n+  \/\/ objects.  Memory in partially occupied regions is not \"available\" to be loaned.  Note that an increase in old-gen\n+  \/\/ available that results from a decrease in memory consumed by old evacuation is not necessarily available to be loaned\n+  \/\/ to young-gen.\n+\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  ShenandoahOldGeneration* const old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* const young_generation = heap->young_generation();\n+\n+  size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+  size_t old_evacuated_committed = (size_t) (ShenandoahOldEvacWaste * double(old_evacuated));\n+  size_t old_evacuation_reserve = old_generation->get_evacuation_reserve();\n+\n+  if (old_evacuated_committed > old_evacuation_reserve) {\n+    \/\/ This should only happen due to round-off errors when enforcing ShenandoahOldEvacWaste\n+    assert(old_evacuated_committed <= (33 * old_evacuation_reserve) \/ 32,\n+           \"Round-off errors should be less than 3.125%%, committed: \" SIZE_FORMAT \", reserved: \" SIZE_FORMAT,\n+           old_evacuated_committed, old_evacuation_reserve);\n+    old_evacuated_committed = old_evacuation_reserve;\n+    \/\/ Leave old_evac_reserve as previously configured\n+  } else if (old_evacuated_committed < old_evacuation_reserve) {\n+    \/\/ This happens if the old-gen collection consumes less than full budget.\n+    old_evacuation_reserve = old_evacuated_committed;\n+    old_generation->set_evacuation_reserve(old_evacuation_reserve);\n+  }\n+\n+  size_t young_advance_promoted = collection_set->get_young_bytes_to_be_promoted();\n+  size_t young_advance_promoted_reserve_used = (size_t) (ShenandoahPromoEvacWaste * double(young_advance_promoted));\n+\n+  size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n+  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n+\n+  size_t total_young_available = young_generation->available_with_reserve();\n+  assert(young_evacuated_reserve_used <= total_young_available, \"Cannot evacuate more than is available in young\");\n+  young_generation->set_evacuation_reserve(young_evacuated_reserve_used);\n+\n+  size_t old_available = old_generation->available();\n+  \/\/ Now that we've established the collection set, we know how much memory is really required by old-gen for evacuation\n+  \/\/ and promotion reserves.  Try shrinking OLD now in case that gives us a bit more runway for mutator allocations during\n+  \/\/ evac and update phases.\n+  size_t old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n+\n+  if (old_available < old_consumed) {\n+    \/\/ This can happen due to round-off errors when adding the results of truncated integer arithmetic.\n+    \/\/ We've already truncated old_evacuated_committed.  Truncate young_advance_promoted_reserve_used here.\n+    assert(young_advance_promoted_reserve_used <= (33 * (old_available - old_evacuated_committed)) \/ 32,\n+           \"Round-off errors should be less than 3.125%%, committed: \" SIZE_FORMAT \", reserved: \" SIZE_FORMAT,\n+           young_advance_promoted_reserve_used, old_available - old_evacuated_committed);\n+    young_advance_promoted_reserve_used = old_available - old_evacuated_committed;\n+    old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n+  }\n+\n+  assert(old_available >= old_consumed, \"Cannot consume (\" SIZE_FORMAT \") more than is available (\" SIZE_FORMAT \")\",\n+         old_consumed, old_available);\n+  size_t excess_old = old_available - old_consumed;\n+  size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n+  size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n+  assert(old_available >= unaffiliated_old, \"Unaffiliated old is a subset of old available\");\n+\n+  \/\/ Make sure old_evac_committed is unaffiliated\n+  if (old_evacuated_committed > 0) {\n+    if (unaffiliated_old > old_evacuated_committed) {\n+      size_t giveaway = unaffiliated_old - old_evacuated_committed;\n+      size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n+      if (giveaway_regions > 0) {\n+        excess_old = MIN2(excess_old, giveaway_regions * region_size_bytes);\n+      } else {\n+        excess_old = 0;\n+      }\n+    } else {\n+      excess_old = 0;\n+    }\n+  }\n+\n+  \/\/ If we find that OLD has excess regions, give them back to YOUNG now to reduce likelihood we run out of allocation\n+  \/\/ runway during evacuation and update-refs.\n+  size_t regions_to_xfer = 0;\n+  if (excess_old > unaffiliated_old) {\n+    \/\/ we can give back unaffiliated_old (all of unaffiliated is excess)\n+    if (unaffiliated_old_regions > 0) {\n+      regions_to_xfer = unaffiliated_old_regions;\n+    }\n+  } else if (unaffiliated_old_regions > 0) {\n+    \/\/ excess_old < unaffiliated old: we can give back MIN(excess_old\/region_size_bytes, unaffiliated_old_regions)\n+    size_t excess_regions = excess_old \/ region_size_bytes;\n+    regions_to_xfer = MIN2(excess_regions, unaffiliated_old_regions);\n+  }\n+\n+  if (regions_to_xfer > 0) {\n+    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n+    assert(excess_old >= regions_to_xfer * region_size_bytes,\n+           \"Cannot transfer (\" SIZE_FORMAT \", \" SIZE_FORMAT \") more than excess old (\" SIZE_FORMAT \")\",\n+           regions_to_xfer, region_size_bytes, excess_old);\n+    excess_old -= regions_to_xfer * region_size_bytes;\n+    log_debug(gc, ergo)(\"%s transferred \" SIZE_FORMAT \" excess regions to young before start of evacuation\",\n+                       result? \"Successfully\": \"Unsuccessfully\", regions_to_xfer);\n+  }\n+\n+  \/\/ Add in the excess_old memory to hold unanticipated promotions, if any.  If there are more unanticipated\n+  \/\/ promotions than fit in reserved memory, they will be deferred until a future GC pass.\n+  size_t total_promotion_reserve = young_advance_promoted_reserve_used + excess_old;\n+  old_generation->set_promoted_reserve(total_promotion_reserve);\n+  old_generation->reset_promoted_expended();\n+}\n+\n+typedef struct {\n+  ShenandoahHeapRegion* _region;\n+  size_t _live_data;\n+} AgedRegionData;\n+\n+static int compare_by_aged_live(AgedRegionData a, AgedRegionData b) {\n+  if (a._live_data < b._live_data)\n+    return -1;\n+  else if (a._live_data > b._live_data)\n+    return 1;\n+  else return 0;\n+}\n+\n+inline void assert_no_in_place_promotions() {\n+#ifdef ASSERT\n+  class ShenandoahNoInPlacePromotions : public ShenandoahHeapRegionClosure {\n+  public:\n+    void heap_region_do(ShenandoahHeapRegion *r) override {\n+      assert(r->get_top_before_promote() == nullptr,\n+             \"Region \" SIZE_FORMAT \" should not be ready for in-place promotion\", r->index());\n+    }\n+  } cl;\n+  ShenandoahHeap::heap()->heap_region_iterate(&cl);\n+#endif\n+}\n+\n+\/\/ Preselect for inclusion into the collection set regions whose age is at or above tenure age which contain more than\n+\/\/ ShenandoahOldGarbageThreshold amounts of garbage.  We identify these regions by setting the appropriate entry of\n+\/\/ the collection set's preselected regions array to true.  All entries are initialized to false before calling this\n+\/\/ function.\n+\/\/\n+\/\/ During the subsequent selection of the collection set, we give priority to these promotion set candidates.\n+\/\/ Without this prioritization, we found that the aged regions tend to be ignored because they typically have\n+\/\/ much less garbage and much more live data than the recently allocated \"eden\" regions.  When aged regions are\n+\/\/ repeatedly excluded from the collection set, the amount of live memory within the young generation tends to\n+\/\/ accumulate and this has the undesirable side effect of causing young-generation collections to require much more\n+\/\/ CPU and wall-clock time.\n+\/\/\n+\/\/ A second benefit of treating aged regions differently than other regions during collection set selection is\n+\/\/ that this allows us to more accurately budget memory to hold the results of evacuation.  Memory for evacuation\n+\/\/ of aged regions must be reserved in the old generation.  Memory for evacuation of all other regions must be\n+\/\/ reserved in the young generation.\n+size_t ShenandoahGeneration::select_aged_regions(size_t old_available) {\n+\n+  \/\/ There should be no regions configured for subsequent in-place-promotions carried over from the previous cycle.\n+  assert_no_in_place_promotions();\n+\n+  auto const heap = ShenandoahGenerationalHeap::heap();\n+  bool* const candidate_regions_for_promotion_by_copy = heap->collection_set()->preselected_regions();\n+  ShenandoahMarkingContext* const ctx = heap->marking_context();\n+\n+  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+  const size_t old_garbage_threshold = (ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold) \/ 100;\n+\n+  size_t old_consumed = 0;\n+  size_t promo_potential = 0;\n+  size_t candidates = 0;\n+\n+  \/\/ Tracks the padding of space above top in regions eligible for promotion in place\n+  size_t promote_in_place_pad = 0;\n+\n+  \/\/ Sort the promotion-eligible regions in order of increasing live-data-bytes so that we can first reclaim regions that require\n+  \/\/ less evacuation effort.  This prioritizes garbage first, expanding the allocation pool early before we reclaim regions that\n+  \/\/ have more live data.\n+  const size_t num_regions = heap->num_regions();\n+\n+  ResourceMark rm;\n+  AgedRegionData* sorted_regions = NEW_RESOURCE_ARRAY(AgedRegionData, num_regions);\n+\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* const r = heap->get_region(i);\n+    if (r->is_empty() || !r->has_live() || !r->is_young() || !r->is_regular()) {\n+      \/\/ skip over regions that aren't regular young with some live data\n+      continue;\n+    }\n+    if (r->age() >= tenuring_threshold) {\n+      if ((r->garbage() < old_garbage_threshold)) {\n+        \/\/ This tenure-worthy region has too little garbage, so we do not want to expend the copying effort to\n+        \/\/ reclaim the garbage; instead this region may be eligible for promotion-in-place to the\n+        \/\/ old generation.\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        HeapWord* original_top = r->top();\n+        if (!heap->is_concurrent_old_mark_in_progress() && tams == original_top) {\n+          \/\/ No allocations from this region have been made during concurrent mark. It meets all the criteria\n+          \/\/ for in-place-promotion. Though we only need the value of top when we fill the end of the region,\n+          \/\/ we use this field to indicate that this region should be promoted in place during the evacuation\n+          \/\/ phase.\n+          r->save_top_before_promote();\n+\n+          size_t remnant_size = r->free() \/ HeapWordSize;\n+          if (remnant_size > ShenandoahHeap::min_fill_size()) {\n+            ShenandoahHeap::fill_with_object(original_top, remnant_size);\n+            \/\/ Fill the remnant memory within this region to assure no allocations prior to promote in place.  Otherwise,\n+            \/\/ newly allocated objects will not be parsable when promote in place tries to register them.  Furthermore, any\n+            \/\/ new allocations would not necessarily be eligible for promotion.  This addresses both issues.\n+            r->set_top(r->end());\n+            promote_in_place_pad += remnant_size * HeapWordSize;\n+          } else {\n+            \/\/ Since the remnant is so small that it cannot be filled, we don't have to worry about any accidental\n+            \/\/ allocations occurring within this region before the region is promoted in place.\n+          }\n+        }\n+        \/\/ Else, we do not promote this region (either in place or by copy) because it has received new allocations.\n+\n+        \/\/ During evacuation, we exclude from promotion regions for which age > tenure threshold, garbage < garbage-threshold,\n+        \/\/  and get_top_before_promote() != tams\n+      } else {\n+        \/\/ Record this promotion-eligible candidate region. After sorting and selecting the best candidates below,\n+        \/\/ we may still decide to exclude this promotion-eligible region from the current collection set.  If this\n+        \/\/ happens, we will consider this region as part of the anticipated promotion potential for the next GC\n+        \/\/ pass; see further below.\n+        sorted_regions[candidates]._region = r;\n+        sorted_regions[candidates++]._live_data = r->get_live_data_bytes();\n+      }\n+    } else {\n+      \/\/ We only evacuate & promote objects from regular regions whose garbage() is above old-garbage-threshold.\n+      \/\/ Objects in tenure-worthy regions with less garbage are promoted in place. These take a different path to\n+      \/\/ old-gen.  Regions excluded from promotion because their garbage content is too low (causing us to anticipate that\n+      \/\/ the region would be promoted in place) may be eligible for evacuation promotion by the time promotion takes\n+      \/\/ place during a subsequent GC pass because more garbage is found within the region between now and then.  This\n+      \/\/ should not happen if we are properly adapting the tenure age.  The theory behind adaptive tenuring threshold\n+      \/\/ is to choose the youngest age that demonstrates no \"significant\" further loss of population since the previous\n+      \/\/ age.  If not this, we expect the tenure age to demonstrate linear population decay for at least two population\n+      \/\/ samples, whereas we expect to observe exponential population decay for ages younger than the tenure age.\n+      \/\/\n+      \/\/ In the case that certain regions which were anticipated to be promoted in place need to be promoted by\n+      \/\/ evacuation, it may be the case that there is not sufficient reserve within old-gen to hold evacuation of\n+      \/\/ these regions.  The likely outcome is that these regions will not be selected for evacuation or promotion\n+      \/\/ in the current cycle and we will anticipate that they will be promoted in the next cycle.  This will cause\n+      \/\/ us to reserve more old-gen memory so that these objects can be promoted in the subsequent cycle.\n+      if (heap->is_aging_cycle() && (r->age() + 1 == tenuring_threshold)) {\n+        if (r->garbage() >= old_garbage_threshold) {\n+          promo_potential += r->get_live_data_bytes();\n+        }\n+      }\n+    }\n+    \/\/ Note that we keep going even if one region is excluded from selection.\n+    \/\/ Subsequent regions may be selected if they have smaller live data.\n+  }\n+  \/\/ Sort in increasing order according to live data bytes.  Note that candidates represents the number of regions\n+  \/\/ that qualify to be promoted by evacuation.\n+  if (candidates > 0) {\n+    size_t selected_regions = 0;\n+    size_t selected_live = 0;\n+    QuickSort::sort<AgedRegionData>(sorted_regions, candidates, compare_by_aged_live);\n+    for (size_t i = 0; i < candidates; i++) {\n+      ShenandoahHeapRegion* const region = sorted_regions[i]._region;\n+      size_t region_live_data = sorted_regions[i]._live_data;\n+      size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n+      if (old_consumed + promotion_need <= old_available) {\n+        old_consumed += promotion_need;\n+        candidate_regions_for_promotion_by_copy[region->index()] = true;\n+        selected_regions++;\n+        selected_live += region_live_data;\n+      } else {\n+        \/\/ We rejected this promotable region from the collection set because we had no room to hold its copy.\n+        \/\/ Add this region to promo potential for next GC.\n+        promo_potential += region_live_data;\n+        assert(!candidate_regions_for_promotion_by_copy[region->index()], \"Shouldn't be selected\");\n+      }\n+      \/\/ We keep going even if one region is excluded from selection because we need to accumulate all eligible\n+      \/\/ regions that are not preselected into promo_potential\n+    }\n+    log_debug(gc)(\"Preselected \" SIZE_FORMAT \" regions containing \" SIZE_FORMAT \" live bytes,\"\n+                 \" consuming: \" SIZE_FORMAT \" of budgeted: \" SIZE_FORMAT,\n+                 selected_regions, selected_live, old_consumed, old_available);\n+  }\n+\n+  heap->old_generation()->set_pad_for_promote_in_place(promote_in_place_pad);\n+  heap->old_generation()->set_promotion_potential(promo_potential);\n+  return old_consumed;\n+}\n+\n+void ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahCollectionSet* collection_set = heap->collection_set();\n+  bool is_generational = heap->mode()->is_generational();\n+\n+  assert(!heap->is_full_gc_in_progress(), \"Only for concurrent and degenerated GC\");\n+  assert(!is_old(), \"Only YOUNG and GLOBAL GC perform evacuations\");\n+  {\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_update_region_states :\n+                            ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n+    ShenandoahFinalMarkUpdateRegionStateClosure cl(complete_marking_context());\n+    parallel_heap_region_iterate(&cl);\n+\n+    if (is_young()) {\n+      \/\/ We always need to update the watermark for old regions. If there\n+      \/\/ are mixed collections pending, we also need to synchronize the\n+      \/\/ pinned status for old regions. Since we are already visiting every\n+      \/\/ old region here, go ahead and sync the pin status too.\n+      ShenandoahFinalMarkUpdateRegionStateClosure old_cl(nullptr);\n+      heap->old_generation()->parallel_heap_region_iterate(&old_cl);\n+    }\n+  }\n+\n+  \/\/ Tally the census counts and compute the adaptive tenuring threshold\n+  if (is_generational && ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    \/\/ Objects above TAMS weren't included in the age census. Since they were all\n+    \/\/ allocated in this cycle they belong in the age 0 cohort. We walk over all\n+    \/\/ young regions and sum the volume of objects between TAMS and top.\n+    ShenandoahUpdateCensusZeroCohortClosure age0_cl(complete_marking_context());\n+    heap->young_generation()->heap_region_iterate(&age0_cl);\n+    size_t age0_pop = age0_cl.get_age0_population();\n+\n+    \/\/ Update the global census, including the missed age 0 cohort above,\n+    \/\/ along with the census done during marking, and compute the tenuring threshold.\n+    ShenandoahAgeCensus* census = ShenandoahGenerationalHeap::heap()->age_census();\n+    census->update_census(age0_pop);\n+#ifndef PRODUCT\n+    size_t total_pop = age0_cl.get_total_population();\n+    size_t total_census = census->get_total();\n+    \/\/ Usually total_pop > total_census, but not by too much.\n+    \/\/ We use integer division so anything up to just less than 2 is considered\n+    \/\/ reasonable, and the \"+1\" is to avoid divide-by-zero.\n+    assert((total_pop+1)\/(total_census+1) ==  1, \"Extreme divergence: \"\n+           SIZE_FORMAT \"\/\" SIZE_FORMAT, total_pop, total_census);\n+#endif\n+  }\n+\n+  {\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n+                            ShenandoahPhaseTimings::degen_gc_choose_cset);\n+\n+    collection_set->clear();\n+    ShenandoahHeapLocker locker(heap->lock());\n+    if (is_generational) {\n+      \/\/ Seed the collection set with resource area-allocated\n+      \/\/ preselected regions, which are removed when we exit this scope.\n+      ShenandoahCollectionSetPreselector preselector(collection_set, heap->num_regions());\n+\n+      \/\/ Find the amount that will be promoted, regions that will be promoted in\n+      \/\/ place, and preselect older regions that will be promoted by evacuation.\n+      compute_evacuation_budgets(heap);\n+\n+      \/\/ Choose the collection set, including the regions preselected above for\n+      \/\/ promotion into the old generation.\n+      _heuristics->choose_collection_set(collection_set);\n+      if (!collection_set->is_empty()) {\n+        \/\/ only make use of evacuation budgets when we are evacuating\n+        adjust_evacuation_budgets(heap, collection_set);\n+      }\n+\n+      if (is_global()) {\n+        \/\/ We have just chosen a collection set for a global cycle. The mark bitmap covering old regions is complete, so\n+        \/\/ the remembered set scan can use that to avoid walking into garbage. When the next old mark begins, we will\n+        \/\/ use the mark bitmap to make the old regions parsable by coalescing and filling any unmarked objects. Thus,\n+        \/\/ we prepare for old collections by remembering which regions are old at this time. Note that any objects\n+        \/\/ promoted into old regions will be above TAMS, and so will be considered marked. However, free regions that\n+        \/\/ become old after this point will not be covered correctly by the mark bitmap, so we must be careful not to\n+        \/\/ coalesce those regions. Only the old regions which are not part of the collection set at this point are\n+        \/\/ eligible for coalescing. As implemented now, this has the side effect of possibly initiating mixed-evacuations\n+        \/\/ after a global cycle for old regions that were not included in this collection set.\n+        heap->old_generation()->prepare_for_mixed_collections_after_global_gc();\n+      }\n+    } else {\n+      _heuristics->choose_collection_set(collection_set);\n+    }\n+  }\n+\n+\n+  {\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_rebuild_freeset :\n+                            ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n+    ShenandoahHeapLocker locker(heap->lock());\n+    size_t young_cset_regions, old_cset_regions;\n+\n+    \/\/ We are preparing for evacuation.  At this time, we ignore cset region tallies.\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    \/\/ Free set construction uses reserve quantities, because they are known to be valid here\n+    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old, true);\n+  }\n+}\n+\n+bool ShenandoahGeneration::is_bitmap_clear() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* context = heap->marking_context();\n+  const size_t num_regions = heap->num_regions();\n+  for (size_t idx = 0; idx < num_regions; idx++) {\n+    ShenandoahHeapRegion* r = heap->get_region(idx);\n+    if (contains(r) && r->is_affiliated()) {\n+      if (heap->is_bitmap_slice_committed(r) && (context->top_at_mark_start(r) > r->bottom()) &&\n+          !context->is_bitmap_range_within_region_clear(r->bottom(), r->end())) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+bool ShenandoahGeneration::is_mark_complete() {\n+  return _is_marking_complete.is_set();\n+}\n+\n+void ShenandoahGeneration::set_mark_complete() {\n+  _is_marking_complete.set();\n+}\n+\n+void ShenandoahGeneration::set_mark_incomplete() {\n+  _is_marking_complete.unset();\n+}\n+\n+ShenandoahMarkingContext* ShenandoahGeneration::complete_marking_context() {\n+  assert(is_mark_complete(), \"Marking must be completed.\");\n+  return ShenandoahHeap::heap()->marking_context();\n+}\n+\n+void ShenandoahGeneration::cancel_marking() {\n+  log_info(gc)(\"Cancel marking: %s\", name());\n+  if (is_concurrent_mark_in_progress()) {\n+    set_mark_incomplete();\n+  }\n+  _task_queues->clear();\n+  ref_processor()->abandon_partial_discovery();\n+  set_concurrent_mark_in_progress(false);\n+}\n+\n+ShenandoahGeneration::ShenandoahGeneration(ShenandoahGenerationType type,\n+                                           uint max_workers,\n+                                           size_t max_capacity,\n+                                           size_t soft_max_capacity) :\n+  _type(type),\n+  _task_queues(new ShenandoahObjToScanQueueSet(max_workers)),\n+  _ref_processor(new ShenandoahReferenceProcessor(MAX2(max_workers, 1U))),\n+  _affiliated_region_count(0), _humongous_waste(0), _evacuation_reserve(0),\n+  _used(0), _bytes_allocated_since_gc_start(0),\n+  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity),\n+  _heuristics(nullptr)\n+{\n+  _is_marking_complete.set();\n+  assert(max_workers > 0, \"At least one queue\");\n+  for (uint i = 0; i < max_workers; ++i) {\n+    ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();\n+    _task_queues->register_queue(i, task_queue);\n+  }\n+}\n+\n+ShenandoahGeneration::~ShenandoahGeneration() {\n+  for (uint i = 0; i < _task_queues->size(); ++i) {\n+    ShenandoahObjToScanQueue* q = _task_queues->queue(i);\n+    delete q;\n+  }\n+  delete _task_queues;\n+}\n+\n+void ShenandoahGeneration::reserve_task_queues(uint workers) {\n+  _task_queues->reserve(workers);\n+}\n+\n+ShenandoahObjToScanQueueSet* ShenandoahGeneration::old_gen_task_queues() const {\n+  return nullptr;\n+}\n+\n+void ShenandoahGeneration::scan_remembered_set(bool is_concurrent) {\n+  assert(is_young(), \"Should only scan remembered set for young generation.\");\n+\n+  ShenandoahGenerationalHeap* const heap = ShenandoahGenerationalHeap::heap();\n+  uint nworkers = heap->workers()->active_workers();\n+  reserve_task_queues(nworkers);\n+\n+  ShenandoahReferenceProcessor* rp = ref_processor();\n+  ShenandoahRegionChunkIterator work_list(nworkers);\n+  ShenandoahScanRememberedTask task(task_queues(), old_gen_task_queues(), rp, &work_list, is_concurrent);\n+  heap->assert_gc_workers(nworkers);\n+  heap->workers()->run_task(&task);\n+  if (ShenandoahEnableCardStats) {\n+    ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n+    assert(scanner != nullptr, \"Not generational\");\n+    scanner->log_card_stats(nworkers, CARD_STAT_SCAN_RS);\n+  }\n+}\n+\n+size_t ShenandoahGeneration::increment_affiliated_region_count() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n+  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n+  \/\/ a coherent value.\n+  _affiliated_region_count++;\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::decrement_affiliated_region_count() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n+  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n+  \/\/ a coherent value.\n+  _affiliated_region_count--;\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used + _humongous_waste <= _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes()),\n+         \"used + humongous cannot exceed regions\");\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::increase_affiliated_region_count(size_t delta) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _affiliated_region_count += delta;\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::decrease_affiliated_region_count(size_t delta) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(_affiliated_region_count >= delta, \"Affiliated region count cannot be negative\");\n+\n+  _affiliated_region_count -= delta;\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used + _humongous_waste <= _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes()),\n+         \"used + humongous cannot exceed regions\");\n+  return _affiliated_region_count;\n+}\n+\n+void ShenandoahGeneration::establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste) {\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"must be at a safepoint\");\n+  _affiliated_region_count = num_regions;\n+  _used = num_bytes;\n+  _humongous_waste = humongous_waste;\n+}\n+\n+void ShenandoahGeneration::increase_used(size_t bytes) {\n+  Atomic::add(&_used, bytes);\n+}\n+\n+void ShenandoahGeneration::increase_humongous_waste(size_t bytes) {\n+  if (bytes > 0) {\n+    Atomic::add(&_humongous_waste, bytes);\n+  }\n+}\n+\n+void ShenandoahGeneration::decrease_humongous_waste(size_t bytes) {\n+  if (bytes > 0) {\n+    assert(ShenandoahHeap::heap()->is_full_gc_in_progress() || (_humongous_waste >= bytes),\n+           \"Waste (\" SIZE_FORMAT \") cannot be negative (after subtracting \" SIZE_FORMAT \")\", _humongous_waste, bytes);\n+    Atomic::sub(&_humongous_waste, bytes);\n+  }\n+}\n+\n+void ShenandoahGeneration::decrease_used(size_t bytes) {\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used >= bytes), \"cannot reduce bytes used by generation below zero\");\n+  Atomic::sub(&_used, bytes);\n+}\n+\n+size_t ShenandoahGeneration::used_regions() const {\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::free_unaffiliated_regions() const {\n+  size_t result = max_capacity() \/ ShenandoahHeapRegion::region_size_bytes();\n+  if (_affiliated_region_count > result) {\n+    result = 0;\n+  } else {\n+    result -= _affiliated_region_count;\n+  }\n+  return result;\n+}\n+\n+size_t ShenandoahGeneration::used_regions_size() const {\n+  return _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahGeneration::available() const {\n+  return available(max_capacity());\n+}\n+\n+\/\/ For ShenandoahYoungGeneration, Include the young available that may have been reserved for the Collector.\n+size_t ShenandoahGeneration::available_with_reserve() const {\n+  return available(max_capacity());\n+}\n+\n+size_t ShenandoahGeneration::soft_available() const {\n+  return available(soft_max_capacity());\n+}\n+\n+size_t ShenandoahGeneration::available(size_t capacity) const {\n+  size_t in_use = used() + get_humongous_waste();\n+  return in_use > capacity ? 0 : capacity - in_use;\n+}\n+\n+size_t ShenandoahGeneration::increase_capacity(size_t increment) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+\n+  \/\/ We do not enforce that new capacity >= heap->max_size_for(this).  The maximum generation size is treated as a rule of thumb\n+  \/\/ which may be violated during certain transitions, such as when we are forcing transfers for the purpose of promoting regions\n+  \/\/ in place.\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_max_capacity + increment <= ShenandoahHeap::heap()->max_capacity()), \"Generation cannot be larger than heap size\");\n+  assert(increment % ShenandoahHeapRegion::region_size_bytes() == 0, \"Generation capacity must be multiple of region size\");\n+  _max_capacity += increment;\n+\n+  \/\/ This detects arithmetic wraparound on _used\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_affiliated_region_count * ShenandoahHeapRegion::region_size_bytes() >= _used),\n+         \"Affiliated regions must hold more than what is currently used\");\n+  return _max_capacity;\n+}\n+\n+size_t ShenandoahGeneration::set_capacity(size_t byte_size) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _max_capacity = byte_size;\n+  return _max_capacity;\n+}\n+\n+size_t ShenandoahGeneration::decrease_capacity(size_t decrement) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+\n+  \/\/ We do not enforce that new capacity >= heap->min_size_for(this).  The minimum generation size is treated as a rule of thumb\n+  \/\/ which may be violated during certain transitions, such as when we are forcing transfers for the purpose of promoting regions\n+  \/\/ in place.\n+  assert(decrement % ShenandoahHeapRegion::region_size_bytes() == 0, \"Generation capacity must be multiple of region size\");\n+  assert(_max_capacity >= decrement, \"Generation capacity cannot be negative\");\n+\n+  _max_capacity -= decrement;\n+\n+  \/\/ This detects arithmetic wraparound on _used\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_affiliated_region_count * ShenandoahHeapRegion::region_size_bytes() >= _used),\n+         \"Affiliated regions must hold more than what is currently used\");\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used <= _max_capacity), \"Cannot use more than capacity\");\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_affiliated_region_count * ShenandoahHeapRegion::region_size_bytes() <= _max_capacity),\n+         \"Cannot use more than capacity\");\n+  return _max_capacity;\n+}\n+\n+void ShenandoahGeneration::record_success_concurrent(bool abbreviated) {\n+  heuristics()->record_success_concurrent();\n+  ShenandoahHeap::heap()->shenandoah_policy()->record_success_concurrent(is_young(), abbreviated);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1035,"deletions":0,"binary":false,"changes":1035,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHGENERATION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n+#include \"gc\/shenandoah\/shenandoahLock.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n+\n+class ShenandoahCollectionSet;\n+class ShenandoahHeap;\n+class ShenandoahHeapRegion;\n+class ShenandoahHeapRegionClosure;\n+class ShenandoahHeuristics;\n+class ShenandoahMode;\n+class ShenandoahReferenceProcessor;\n+\n+\n+class ShenandoahGeneration : public CHeapObj<mtGC>, public ShenandoahSpaceInfo {\n+  friend class VMStructs;\n+private:\n+  ShenandoahGenerationType const _type;\n+\n+  \/\/ Marking task queues and completeness\n+  ShenandoahObjToScanQueueSet* _task_queues;\n+  ShenandoahSharedFlag _is_marking_complete;\n+\n+  ShenandoahReferenceProcessor* const _ref_processor;\n+\n+  size_t _affiliated_region_count;\n+\n+  \/\/ How much free memory is left in the last region of humongous objects.\n+  \/\/ This is _not_ included in used, but it _is_ deducted from available,\n+  \/\/ which gives the heuristics a more accurate view of how much memory remains\n+  \/\/ for allocation. This figure is also included the heap status logging.\n+  \/\/ The units are bytes. The value is only changed on a safepoint or under the\n+  \/\/ heap lock.\n+  size_t _humongous_waste;\n+\n+  \/\/ Bytes reserved within this generation to hold evacuated objects from the collection set\n+  size_t _evacuation_reserve;\n+\n+protected:\n+  \/\/ Usage\n+\n+  volatile size_t _used;\n+  volatile size_t _bytes_allocated_since_gc_start;\n+  size_t _max_capacity;\n+  size_t _soft_max_capacity;\n+\n+  ShenandoahHeuristics* _heuristics;\n+\n+private:\n+  \/\/ Compute evacuation budgets prior to choosing collection set.\n+  void compute_evacuation_budgets(ShenandoahHeap* heap);\n+\n+  \/\/ Adjust evacuation budgets after choosing collection set.\n+  void adjust_evacuation_budgets(ShenandoahHeap* heap,\n+                                 ShenandoahCollectionSet* collection_set);\n+\n+  \/\/ Preselect for possible inclusion into the collection set exactly the most\n+  \/\/ garbage-dense regions, including those that satisfy criteria 1 & 2 below,\n+  \/\/ and whose live bytes will fit within old_available budget:\n+  \/\/ Criterion 1. region age >= tenuring threshold\n+  \/\/ Criterion 2. region garbage percentage > ShenandoahOldGarbageThreshold\n+  \/\/\n+  \/\/ Identifies regions eligible for promotion in place,\n+  \/\/ being those of at least tenuring_threshold age that have lower garbage\n+  \/\/ density.\n+  \/\/\n+  \/\/ Updates promotion_potential and pad_for_promote_in_place fields\n+  \/\/ of the heap. Returns bytes of live object memory in the preselected\n+  \/\/ regions, which are marked in the preselected_regions() indicator\n+  \/\/ array of the heap's collection set, which should be initialized\n+  \/\/ to false.\n+  size_t select_aged_regions(size_t old_available);\n+\n+  size_t available(size_t capacity) const;\n+\n+ public:\n+  ShenandoahGeneration(ShenandoahGenerationType type,\n+                       uint max_workers,\n+                       size_t max_capacity,\n+                       size_t soft_max_capacity);\n+  ~ShenandoahGeneration();\n+\n+  bool is_young() const  { return _type == YOUNG; }\n+  bool is_old() const    { return _type == OLD; }\n+  bool is_global() const { return _type == GLOBAL || _type == NON_GEN; }\n+\n+  \/\/ see description in field declaration\n+  void set_evacuation_reserve(size_t new_val);\n+  size_t get_evacuation_reserve() const;\n+  void augment_evacuation_reserve(size_t increment);\n+\n+  inline ShenandoahGenerationType type() const { return _type; }\n+\n+  virtual ShenandoahHeuristics* heuristics() const { return _heuristics; }\n+\n+  ShenandoahReferenceProcessor* ref_processor() { return _ref_processor; }\n+\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode);\n+\n+  size_t soft_max_capacity() const override { return _soft_max_capacity; }\n+  size_t max_capacity() const override      { return _max_capacity; }\n+  virtual size_t used_regions() const;\n+  virtual size_t used_regions_size() const;\n+  virtual size_t free_unaffiliated_regions() const;\n+  size_t used() const override { return _used; }\n+  size_t available() const override;\n+  size_t available_with_reserve() const;\n+  size_t used_including_humongous_waste() const {\n+    return used() + get_humongous_waste();\n+  }\n+\n+  \/\/ Returns the memory available based on the _soft_ max heap capacity (soft_max_heap - used).\n+  \/\/ The soft max heap size may be adjusted lower than the max heap size to cause the trigger\n+  \/\/ to believe it has less memory available than is _really_ available. Lowering the soft\n+  \/\/ max heap size will cause the adaptive heuristic to run more frequent cycles.\n+  size_t soft_available() const override;\n+\n+  size_t bytes_allocated_since_gc_start() const override;\n+  void reset_bytes_allocated_since_gc_start();\n+  void increase_allocated(size_t bytes);\n+\n+  \/\/ These methods change the capacity of the generation by adding or subtracting the given number of bytes from the current\n+  \/\/ capacity, returning the capacity of the generation following the change.\n+  size_t increase_capacity(size_t increment);\n+  size_t decrease_capacity(size_t decrement);\n+\n+  \/\/ Set the capacity of the generation, returning the value set\n+  size_t set_capacity(size_t byte_size);\n+\n+  void log_status(const char* msg) const;\n+\n+  \/\/ Used directly by FullGC\n+  void reset_mark_bitmap();\n+\n+  \/\/ Used by concurrent and degenerated GC to reset remembered set.\n+  void swap_remembered_set();\n+\n+  \/\/ Update the read cards with the state of the write table (write table is not cleared).\n+  void merge_write_table();\n+\n+  \/\/ Called before init mark, expected to prepare regions for marking.\n+  virtual void prepare_gc();\n+\n+  \/\/ Called during final mark, chooses collection set, rebuilds free set.\n+  virtual void prepare_regions_and_collection_set(bool concurrent);\n+\n+  \/\/ Cancel marking (used by Full collect and when cancelling cycle).\n+  virtual void cancel_marking();\n+\n+  virtual bool contains(ShenandoahAffiliation affiliation) const = 0;\n+\n+  \/\/ Return true if this region is affiliated with this generation.\n+  virtual bool contains(ShenandoahHeapRegion* region) const = 0;\n+\n+  \/\/ Return true if this object is affiliated with this generation.\n+  virtual bool contains(oop obj) const = 0;\n+\n+  \/\/ Apply closure to all regions affiliated with this generation.\n+  virtual void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) = 0;\n+\n+  \/\/ Apply closure to all regions affiliated with this generation (include free regions);\n+  virtual void parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl);\n+\n+  \/\/ Apply closure to all regions affiliated with this generation (single threaded).\n+  virtual void heap_region_iterate(ShenandoahHeapRegionClosure* cl) = 0;\n+\n+  \/\/ This is public to support cancellation of marking when a Full cycle is started.\n+  virtual void set_concurrent_mark_in_progress(bool in_progress) = 0;\n+\n+  \/\/ Check the bitmap only for regions belong to this generation.\n+  bool is_bitmap_clear();\n+\n+  \/\/ We need to track the status of marking for different generations.\n+  bool is_mark_complete();\n+  virtual void set_mark_complete();\n+  virtual void set_mark_incomplete();\n+\n+  ShenandoahMarkingContext* complete_marking_context();\n+\n+  \/\/ Task queues\n+  ShenandoahObjToScanQueueSet* task_queues() const { return _task_queues; }\n+  virtual void reserve_task_queues(uint workers);\n+  virtual ShenandoahObjToScanQueueSet* old_gen_task_queues() const;\n+\n+  \/\/ Scan remembered set at start of concurrent young-gen marking.\n+  void scan_remembered_set(bool is_concurrent);\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t increment_affiliated_region_count();\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t decrement_affiliated_region_count();\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t increase_affiliated_region_count(size_t delta);\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t decrease_affiliated_region_count(size_t delta);\n+\n+  void establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste);\n+\n+  void increase_used(size_t bytes);\n+  void decrease_used(size_t bytes);\n+\n+  void increase_humongous_waste(size_t bytes);\n+  void decrease_humongous_waste(size_t bytes);\n+  size_t get_humongous_waste() const { return _humongous_waste; }\n+\n+  virtual bool is_concurrent_mark_in_progress() = 0;\n+  void confirm_heuristics_mode();\n+\n+  virtual void record_success_concurrent(bool abbreviated);\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHGENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+\n+\n+ShenandoahGenerationSizer::ShenandoahGenerationSizer()\n+        : _sizer_kind(SizerDefaults),\n+          _min_desired_young_regions(0),\n+          _max_desired_young_regions(0) {\n+\n+  if (FLAG_IS_CMDLINE(NewRatio)) {\n+    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n+    } else {\n+      _sizer_kind = SizerNewRatio;\n+      return;\n+    }\n+  }\n+\n+  if (NewSize > MaxNewSize) {\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"NewSize (\" SIZE_FORMAT \"k) is greater than the MaxNewSize (\" SIZE_FORMAT \"k). \"\n+                            \"A new max generation size of \" SIZE_FORMAT \"k will be used.\",\n+              NewSize\/K, MaxNewSize\/K, NewSize\/K);\n+    }\n+    FLAG_SET_ERGO(MaxNewSize, NewSize);\n+  }\n+\n+  if (FLAG_IS_CMDLINE(NewSize)) {\n+    _min_desired_young_regions = MAX2(uint(NewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+      _sizer_kind = SizerMaxAndNewSize;\n+    } else {\n+      _sizer_kind = SizerNewSizeOnly;\n+    }\n+  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+    _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+    _sizer_kind = SizerMaxNewSizeOnly;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_min_young_regions(size_t heap_region_count) {\n+  size_t min_young_regions = (heap_region_count * ShenandoahMinYoungPercentage) \/ 100;\n+  return MAX2(min_young_regions, (size_t) 1U);\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_max_young_regions(size_t heap_region_count) {\n+  size_t max_young_regions = (heap_region_count * ShenandoahMaxYoungPercentage) \/ 100;\n+  return MAX2(max_young_regions, (size_t) 1U);\n+}\n+\n+void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_region_count) {\n+  assert(heap_region_count > 0, \"Heap must be initialized\");\n+\n+  switch (_sizer_kind) {\n+    case SizerDefaults:\n+      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n+      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n+      break;\n+    case SizerNewSizeOnly:\n+      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n+      _max_desired_young_regions = MAX2(_min_desired_young_regions, _max_desired_young_regions);\n+      break;\n+    case SizerMaxNewSizeOnly:\n+      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n+      _min_desired_young_regions = MIN2(_min_desired_young_regions, _max_desired_young_regions);\n+      break;\n+    case SizerMaxAndNewSize:\n+      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n+      break;\n+    case SizerNewRatio:\n+      _min_desired_young_regions = MAX2(uint(heap_region_count \/ (NewRatio + 1)), 1U);\n+      _max_desired_young_regions = _min_desired_young_regions;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  assert(_min_desired_young_regions <= _max_desired_young_regions, \"Invalid min\/max young gen size values\");\n+}\n+\n+void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n+  recalculate_min_max_young_length(heap_size \/ ShenandoahHeapRegion::region_size_bytes());\n+}\n+\n+bool ShenandoahGenerationSizer::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const {\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n+\n+  if (src->free_unaffiliated_regions() < regions) {\n+    \/\/ Source does not have enough free regions for this transfer. The caller should have\n+    \/\/ already capped the transfer based on available unaffiliated regions.\n+    return false;\n+  }\n+\n+  if (dst->max_capacity() + bytes_to_transfer > max_size_for(dst)) {\n+    \/\/ This transfer would cause the destination generation to grow above its configured maximum size.\n+    return false;\n+  }\n+\n+  if (src->max_capacity() - bytes_to_transfer < min_size_for(src)) {\n+    \/\/ This transfer would cause the source generation to shrink below its configured minimum size.\n+    return false;\n+  }\n+\n+  src->decrease_capacity(bytes_to_transfer);\n+  dst->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = dst->max_capacity();\n+  log_info(gc, ergo)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                     regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n+  return true;\n+}\n+\n+\n+size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return max_young_size();\n+    case OLD:\n+      \/\/ On the command line, max size of OLD is specified indirectly, by setting a minimum size of young.\n+      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n+      return ShenandoahHeap::heap()->max_capacity() - min_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return min_young_size();\n+    case OLD:\n+      \/\/ On the command line, min size of OLD is specified indirectly, by setting a maximum size of young.\n+      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n+      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+\n+\/\/ Returns true iff transfer is successful\n+bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  return transfer_regions(heap->young_generation(), heap->old_generation(), regions);\n+}\n+\n+\/\/ This is used when promoting humongous or highly utilized regular regions in place.  It is not required in this situation\n+\/\/ that the transferred regions be unaffiliated.\n+void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahGeneration* old_gen = heap->old_generation();\n+  ShenandoahGeneration* young_gen = heap->young_generation();\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n+\n+  young_gen->decrease_capacity(bytes_to_transfer);\n+  old_gen->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = old_gen->max_capacity();\n+  log_info(gc, ergo)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                     regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n+}\n+\n+\n+bool ShenandoahGenerationSizer::transfer_to_young(size_t regions) const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  return transfer_regions(heap->old_generation(), heap->young_generation(), regions);\n+}\n+\n+size_t ShenandoahGenerationSizer::min_young_size() const {\n+  return min_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahGenerationSizer::max_young_size() const {\n+  return max_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.cpp","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ShenandoahGeneration;\n+class ShenandoahGenerationalHeap;\n+\n+class ShenandoahGenerationSizer {\n+private:\n+  enum SizerKind {\n+    SizerDefaults,\n+    SizerNewSizeOnly,\n+    SizerMaxNewSizeOnly,\n+    SizerMaxAndNewSize,\n+    SizerNewRatio\n+  };\n+  SizerKind _sizer_kind;\n+\n+  size_t _min_desired_young_regions;\n+  size_t _max_desired_young_regions;\n+\n+  static size_t calculate_min_young_regions(size_t heap_region_count);\n+  static size_t calculate_max_young_regions(size_t heap_region_count);\n+\n+  \/\/ Update the given values for minimum and maximum young gen length in regions\n+  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n+  void recalculate_min_max_young_length(size_t heap_region_count);\n+\n+  \/\/ This will attempt to transfer regions from the `src` generation to `dst` generation.\n+  \/\/ If the transfer would violate the configured minimum size for the source or the configured\n+  \/\/ maximum size of the destination, it will not perform the transfer and will return false.\n+  \/\/ Returns true if the transfer is performed.\n+  bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const;\n+\n+  \/\/ Return the configured maximum size in bytes for the given generation.\n+  size_t max_size_for(ShenandoahGeneration* generation) const;\n+\n+  \/\/ Return the configured minimum size in bytes for the given generation.\n+  size_t min_size_for(ShenandoahGeneration* generation) const;\n+\n+public:\n+  ShenandoahGenerationSizer();\n+\n+  \/\/ Calculate the maximum length of the young gen given the number of regions\n+  \/\/ depending on the sizing algorithm.\n+  void heap_size_changed(size_t heap_size);\n+\n+  \/\/ Minimum size of young generation in bytes as multiple of region size.\n+  size_t min_young_size() const;\n+  size_t min_young_regions() const {\n+    return _min_desired_young_regions;\n+  }\n+\n+  \/\/ Maximum size of young generation in bytes as multiple of region size.\n+  size_t max_young_size() const;\n+  size_t max_young_regions() const {\n+    return _max_desired_young_regions;\n+  }\n+\n+  \/\/ True if transfer succeeds, else false. See transfer_regions.\n+  bool transfer_to_young(size_t regions) const;\n+  bool transfer_to_old(size_t regions) const;\n+\n+  \/\/ force transfer is used when we promote humongous objects.  May violate min\/max limits on generation sizes\n+  void force_transfer_to_old(size_t regions) const;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -29,1 +29,4 @@\n-  NON_GEN           \/\/ non-generational\n+    NON_GEN,         \/\/ non-generational\n+    GLOBAL,          \/\/ generational: Global\n+    YOUNG,           \/\/ generational: Young\n+    OLD              \/\/ generational: Old\n@@ -36,0 +39,6 @@\n+    case GLOBAL:\n+      return \"Global\";\n+    case OLD:\n+      return \"Old\";\n+    case YOUNG:\n+      return \"Young\";\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationType.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,841 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahDegeneratedGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFullGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPacer.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n+#include \"memory\/metaspaceStats.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+ShenandoahGenerationalControlThread::ShenandoahGenerationalControlThread() :\n+  ShenandoahController(),\n+  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahControlGC_lock\", true),\n+  _regulator_lock(Mutex::nosafepoint - 2, \"ShenandoahRegulatorGC_lock\", true),\n+  _requested_gc_cause(GCCause::_no_gc),\n+  _requested_generation(GLOBAL),\n+  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n+  _degen_generation(nullptr),\n+  _mode(none) {\n+  shenandoah_assert_generational();\n+  set_name(\"Shenandoah Control Thread\");\n+  create_and_start();\n+}\n+\n+void ShenandoahGenerationalControlThread::run_service() {\n+  ShenandoahGenerationalHeap* const heap = ShenandoahGenerationalHeap::heap();\n+\n+  const GCMode default_mode = concurrent_normal;\n+  ShenandoahGenerationType generation = GLOBAL;\n+\n+  double last_shrink_time = os::elapsedTime();\n+  uint age_period = 0;\n+\n+  \/\/ Shrink period avoids constantly polling regions for shrinking.\n+  \/\/ Having a period 10x lower than the delay would mean we hit the\n+  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n+  \/\/ ShenandoahUncommitDelay is in msecs, but shrink_period is in seconds.\n+  const double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n+\n+  ShenandoahCollectorPolicy* const policy = heap->shenandoah_policy();\n+\n+  \/\/ Heuristics are notified of allocation failures here and other outcomes\n+  \/\/ of the cycle. They're also used here to control whether the Nth consecutive\n+  \/\/ degenerated cycle should be 'promoted' to a full cycle. The decision to\n+  \/\/ trigger a cycle or not is evaluated on the regulator thread.\n+  ShenandoahHeuristics* global_heuristics = heap->global_generation()->heuristics();\n+  while (!in_graceful_shutdown() && !should_terminate()) {\n+    \/\/ Figure out if we have pending requests.\n+    const bool alloc_failure_pending = _alloc_failure_gc.is_set();\n+    const bool humongous_alloc_failure_pending = _humongous_alloc_failure_gc.is_set();\n+\n+    GCCause::Cause cause = Atomic::xchg(&_requested_gc_cause, GCCause::_no_gc);\n+\n+    const bool is_gc_requested = ShenandoahCollectorPolicy::is_requested_gc(cause);\n+\n+    \/\/ This control loop iteration has seen this much allocation.\n+    const size_t allocs_seen = reset_allocs_seen();\n+\n+    \/\/ Check if we have seen a new target for soft max heap size.\n+    const bool soft_max_changed = heap->check_soft_max_changed();\n+\n+    \/\/ Choose which GC mode to run in. The block below should select a single mode.\n+    set_gc_mode(none);\n+    ShenandoahGC::ShenandoahDegenPoint degen_point = ShenandoahGC::_degenerated_unset;\n+\n+    if (alloc_failure_pending) {\n+      \/\/ Allocation failure takes precedence: we have to deal with it first thing\n+      cause = GCCause::_allocation_failure;\n+\n+      \/\/ Consume the degen point, and seed it with default value\n+      degen_point = _degen_point;\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+\n+      if (degen_point == ShenandoahGC::_degenerated_outside_cycle) {\n+        _degen_generation = heap->young_generation();\n+      } else {\n+        assert(_degen_generation != nullptr, \"Need to know which generation to resume\");\n+      }\n+\n+      ShenandoahHeuristics* heuristics = _degen_generation->heuristics();\n+      generation = _degen_generation->type();\n+      bool old_gen_evacuation_failed = heap->old_generation()->clear_failed_evacuation();\n+\n+      heuristics->log_trigger(\"Handle Allocation Failure\");\n+\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed or if humongous allocation failed\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() &&\n+          !old_gen_evacuation_failed && !humongous_alloc_failure_pending) {\n+        heuristics->record_allocation_failure_gc();\n+        policy->record_alloc_failure_to_degenerated(degen_point);\n+        set_gc_mode(stw_degenerated);\n+      } else {\n+        heuristics->record_allocation_failure_gc();\n+        policy->record_alloc_failure_to_full();\n+        generation = GLOBAL;\n+        set_gc_mode(stw_full);\n+      }\n+    } else if (is_gc_requested) {\n+      generation = GLOBAL;\n+      global_heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(cause));\n+      global_heuristics->record_requested_gc();\n+\n+      if (ShenandoahCollectorPolicy::should_run_full_gc(cause)) {\n+        set_gc_mode(stw_full);\n+      } else {\n+        set_gc_mode(default_mode);\n+        \/\/ Unload and clean up everything\n+        heap->set_unload_classes(global_heuristics->can_unload_classes());\n+      }\n+    } else {\n+      \/\/ We should only be here if the regulator requested a cycle or if\n+      \/\/ there is an old generation mark in progress.\n+      if (cause == GCCause::_shenandoah_concurrent_gc) {\n+        if (_requested_generation == OLD && heap->old_generation()->is_doing_mixed_evacuations()) {\n+          \/\/ If a request to start an old cycle arrived while an old cycle was running, but _before_\n+          \/\/ it chose any regions for evacuation we don't want to start a new old cycle. Rather, we want\n+          \/\/ the heuristic to run a young collection so that we can evacuate some old regions.\n+          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking\");\n+          generation = YOUNG;\n+        } else {\n+          generation = _requested_generation;\n+        }\n+\n+        \/\/ preemption was requested or this is a regular cycle\n+        set_gc_mode(default_mode);\n+\n+        \/\/ Don't start a new old marking if there is one already in progress\n+        if (generation == OLD && heap->is_concurrent_old_mark_in_progress()) {\n+          set_gc_mode(servicing_old);\n+        }\n+\n+        if (generation == GLOBAL) {\n+          heap->set_unload_classes(global_heuristics->should_unload_classes());\n+        } else {\n+          heap->set_unload_classes(false);\n+        }\n+      } else if (heap->is_concurrent_old_mark_in_progress() || heap->is_prepare_for_old_mark_in_progress()) {\n+        \/\/ Nobody asked us to do anything, but we have an old-generation mark or old-generation preparation for\n+        \/\/ mixed evacuation in progress, so resume working on that.\n+        log_info(gc)(\"Resume old GC: marking is%s in progress, preparing is%s in progress\",\n+                     heap->is_concurrent_old_mark_in_progress() ? \"\" : \" NOT\",\n+                     heap->is_prepare_for_old_mark_in_progress() ? \"\" : \" NOT\");\n+\n+        cause = GCCause::_shenandoah_concurrent_gc;\n+        generation = OLD;\n+        set_gc_mode(servicing_old);\n+        heap->set_unload_classes(false);\n+      }\n+    }\n+\n+    const bool gc_requested = (gc_mode() != none);\n+    assert (!gc_requested || cause != GCCause::_no_gc, \"GC cause should be set\");\n+\n+    if (gc_requested) {\n+      \/\/ Blow away all soft references on this cycle, if handling allocation failure,\n+      \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n+      if (generation == GLOBAL && (alloc_failure_pending || is_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n+        heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n+      }\n+\n+      \/\/ GC is starting, bump the internal ID\n+      update_gc_id();\n+\n+      heap->reset_bytes_allocated_since_gc_start();\n+\n+      MetaspaceCombinedStats meta_sizes = MetaspaceUtils::get_combined_statistics();\n+\n+      \/\/ If GC was requested, we are sampling the counters even without actual triggers\n+      \/\/ from allocation machinery. This captures GC phases more accurately.\n+      heap->set_forced_counters_update(true);\n+\n+      \/\/ If GC was requested, we better dump freeset data for performance debugging\n+      heap->free_set()->log_status_under_lock();\n+\n+      \/\/ In case this is a degenerated cycle, remember whether original cycle was aging.\n+      const bool was_aging_cycle = heap->is_aging_cycle();\n+      heap->set_aging_cycle(false);\n+\n+      switch (gc_mode()) {\n+        case concurrent_normal: {\n+          \/\/ At this point:\n+          \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n+          \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n+          \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n+          \/\/ In all three cases, we want to age old objects if this is an aging cycle\n+          if (age_period-- == 0) {\n+             heap->set_aging_cycle(true);\n+             age_period = ShenandoahAgingCyclePeriod - 1;\n+          }\n+          service_concurrent_normal_cycle(heap, generation, cause);\n+          break;\n+        }\n+        case stw_degenerated: {\n+          heap->set_aging_cycle(was_aging_cycle);\n+          service_stw_degenerated_cycle(cause, degen_point);\n+          break;\n+        }\n+        case stw_full: {\n+          if (age_period-- == 0) {\n+            heap->set_aging_cycle(true);\n+            age_period = ShenandoahAgingCyclePeriod - 1;\n+          }\n+          service_stw_full_cycle(cause);\n+          break;\n+        }\n+        case servicing_old: {\n+          assert(generation == OLD, \"Expected old generation here\");\n+          GCIdMark gc_id_mark;\n+          service_concurrent_old_cycle(heap, cause);\n+          break;\n+        }\n+        default:\n+          ShouldNotReachHere();\n+      }\n+\n+      \/\/ If this was the requested GC cycle, notify waiters about it\n+      if (is_gc_requested) {\n+        notify_gc_waiters();\n+      }\n+\n+      \/\/ If this was the allocation failure GC cycle, notify waiters about it\n+      if (alloc_failure_pending) {\n+        notify_alloc_failure_waiters();\n+      }\n+\n+      \/\/ Report current free set state at the end of cycle, whether\n+      \/\/ it is a normal completion, or the abort.\n+      heap->free_set()->log_status_under_lock();\n+\n+      \/\/ Notify Universe about new heap usage. This has implications for\n+      \/\/ global soft refs policy, and we better report it every time heap\n+      \/\/ usage goes down.\n+      heap->update_capacity_and_used_at_gc();\n+\n+      \/\/ Signal that we have completed a visit to all live objects.\n+      heap->record_whole_heap_examined_timestamp();\n+\n+      \/\/ Disable forced counters update, and update counters one more time\n+      \/\/ to capture the state at the end of GC session.\n+      heap->handle_force_counters_update();\n+      heap->set_forced_counters_update(false);\n+\n+      \/\/ Retract forceful part of soft refs policy\n+      heap->soft_ref_policy()->set_should_clear_all_soft_refs(false);\n+\n+      \/\/ Clear metaspace oom flag, if current cycle unloaded classes\n+      if (heap->unload_classes()) {\n+        global_heuristics->clear_metaspace_oom();\n+      }\n+\n+      process_phase_timings(heap);\n+\n+      \/\/ Print Metaspace change following GC (if logging is enabled).\n+      MetaspaceUtils::print_metaspace_change(meta_sizes);\n+\n+      \/\/ GC is over, we are at idle now\n+      if (ShenandoahPacing) {\n+        heap->pacer()->setup_for_idle();\n+      }\n+    } else {\n+      \/\/ Report to pacer that we have seen this many words allocated\n+      if (ShenandoahPacing && (allocs_seen > 0)) {\n+        heap->pacer()->report_alloc(allocs_seen);\n+      }\n+    }\n+\n+    const double current = os::elapsedTime();\n+\n+    if (ShenandoahUncommit && (is_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n+      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n+      \/\/ Soft max change tries to uncommit everything down to target capacity.\n+      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n+\n+      double shrink_before = (is_gc_requested || soft_max_changed) ?\n+                             current :\n+                             current - (ShenandoahUncommitDelay \/ 1000.0);\n+\n+      size_t shrink_until = soft_max_changed ?\n+                             heap->soft_max_capacity() :\n+                             heap->min_capacity();\n+\n+      heap->maybe_uncommit(shrink_before, shrink_until);\n+      heap->phase_timings()->flush_cycle_to_global();\n+      last_shrink_time = current;\n+    }\n+\n+    \/\/ Wait for ShenandoahControlIntervalMax unless there was an allocation failure or another request was made mid-cycle.\n+    if (!is_alloc_failure_gc() && _requested_gc_cause == GCCause::_no_gc) {\n+      \/\/ The timed wait is necessary because this thread has a responsibility to send\n+      \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n+      MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n+      lock.wait(ShenandoahControlIntervalMax);\n+    }\n+  }\n+\n+  \/\/ Wait for the actual stop(), can't leave run_service() earlier.\n+  while (!should_terminate()) {\n+    os::naked_short_sleep(ShenandoahControlIntervalMin);\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::process_phase_timings(const ShenandoahGenerationalHeap* heap) {\n+  \/\/ Commit worker statistics to cycle data\n+  heap->phase_timings()->flush_par_workers_to_cycle();\n+  if (ShenandoahPacing) {\n+    heap->pacer()->flush_stats_to_cycle();\n+  }\n+\n+  ShenandoahEvacuationTracker* evac_tracker = heap->evac_tracker();\n+  ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n+\n+  \/\/ Print GC stats for current cycle\n+  {\n+    LogTarget(Info, gc, stats) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      LogStream ls(lt);\n+      heap->phase_timings()->print_cycle_on(&ls);\n+      evac_tracker->print_evacuations_on(&ls, &evac_stats.workers,\n+                                              &evac_stats.mutators);\n+      if (ShenandoahPacing) {\n+        heap->pacer()->print_cycle_on(&ls);\n+      }\n+    }\n+  }\n+\n+  \/\/ Commit statistics to globals\n+  heap->phase_timings()->flush_cycle_to_global();\n+}\n+\n+\/\/ Young and old concurrent cycles are initiated by the regulator. Implicit\n+\/\/ and explicit GC requests are handled by the controller thread and always\n+\/\/ run a global cycle (which is concurrent by default, but may be overridden\n+\/\/ by command line options). Old cycles always degenerate to a global cycle.\n+\/\/ Young cycles are degenerated to complete the young cycle.  Young\n+\/\/ and old degen may upgrade to Full GC.  Full GC may also be\n+\/\/ triggered directly by a System.gc() invocation.\n+\/\/\n+\/\/\n+\/\/      +-----+ Idle +-----+-----------+---------------------+\n+\/\/      |         +        |           |                     |\n+\/\/      |         |        |           |                     |\n+\/\/      |         |        v           |                     |\n+\/\/      |         |  Bootstrap Old +-- | ------------+       |\n+\/\/      |         |   +                |             |       |\n+\/\/      |         |   |                |             |       |\n+\/\/      |         v   v                v             v       |\n+\/\/      |    Resume Old <----------+ Young +--> Young Degen  |\n+\/\/      |     +  +   ^                            +  +       |\n+\/\/      v     |  |   |                            |  |       |\n+\/\/   Global <-+  |   +----------------------------+  |       |\n+\/\/      +        |                                   |       |\n+\/\/      |        v                                   v       |\n+\/\/      +--->  Global Degen +--------------------> Full <----+\n+\/\/\n+void ShenandoahGenerationalControlThread::service_concurrent_normal_cycle(ShenandoahGenerationalHeap* heap,\n+                                                                          const ShenandoahGenerationType generation,\n+                                                                          GCCause::Cause cause) {\n+  GCIdMark gc_id_mark;\n+  switch (generation) {\n+    case YOUNG: {\n+      \/\/ Run a young cycle. This might or might not, have interrupted an ongoing\n+      \/\/ concurrent mark in the old generation. We need to think about promotions\n+      \/\/ in this case. Promoted objects should be above the TAMS in the old regions\n+      \/\/ they end up in, but we have to be sure we don't promote into any regions\n+      \/\/ that are in the cset.\n+      log_info(gc, ergo)(\"Start GC cycle (Young)\");\n+      service_concurrent_cycle(heap->young_generation(), cause, false);\n+      break;\n+    }\n+    case OLD: {\n+      log_info(gc, ergo)(\"Start GC cycle (Old)\");\n+      service_concurrent_old_cycle(heap, cause);\n+      break;\n+    }\n+    case GLOBAL: {\n+      log_info(gc, ergo)(\"Start GC cycle (Global)\");\n+      service_concurrent_cycle(heap->global_generation(), cause, false);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::service_concurrent_old_cycle(ShenandoahGenerationalHeap* heap, GCCause::Cause &cause) {\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+  ShenandoahOldGeneration::State original_state = old_generation->state();\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  switch (original_state) {\n+    case ShenandoahOldGeneration::FILLING: {\n+      ShenandoahGCSession session(cause, old_generation);\n+      _allow_old_preemption.set();\n+      old_generation->entry_coalesce_and_fill();\n+      _allow_old_preemption.unset();\n+\n+      \/\/ Before bootstrapping begins, we must acknowledge any cancellation request.\n+      \/\/ If the gc has not been cancelled, this does nothing. If it has been cancelled,\n+      \/\/ this will clear the cancellation request and exit before starting the bootstrap\n+      \/\/ phase. This will allow the young GC cycle to proceed normally. If we do not\n+      \/\/ acknowledge the cancellation request, the subsequent young cycle will observe\n+      \/\/ the request and essentially cancel itself.\n+      if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) {\n+        log_info(gc)(\"Preparation for old generation cycle was cancelled\");\n+        return;\n+      }\n+\n+      \/\/ Coalescing threads completed and nothing was cancelled. it is safe to transition from this state.\n+      old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+      return;\n+    }\n+    case ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP:\n+      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n+    case ShenandoahOldGeneration::BOOTSTRAPPING: {\n+      \/\/ Configure the young generation's concurrent mark to put objects in\n+      \/\/ old regions into the concurrent mark queues associated with the old\n+      \/\/ generation. The young cycle will run as normal except that rather than\n+      \/\/ ignore old references it will mark and enqueue them in the old concurrent\n+      \/\/ task queues but it will not traverse them.\n+      set_gc_mode(bootstrapping_old);\n+      young_generation->set_old_gen_task_queues(old_generation->task_queues());\n+      ShenandoahGCSession session(cause, young_generation);\n+      service_concurrent_cycle(heap, young_generation, cause, true);\n+      process_phase_timings(heap);\n+      if (heap->cancelled_gc()) {\n+        \/\/ Young generation bootstrap cycle has failed. Concurrent mark for old generation\n+        \/\/ is going to resume after degenerated bootstrap cycle completes.\n+        log_info(gc)(\"Bootstrap cycle for old generation was cancelled\");\n+        return;\n+      }\n+\n+      \/\/ Reset the degenerated point. Normally this would happen at the top\n+      \/\/ of the control loop, but here we have just completed a young cycle\n+      \/\/ which has bootstrapped the old concurrent marking.\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+\n+      \/\/ From here we will 'resume' the old concurrent mark. This will skip reset\n+      \/\/ and init mark for the concurrent mark. All of that work will have been\n+      \/\/ done by the bootstrapping young cycle.\n+      set_gc_mode(servicing_old);\n+      old_generation->transition_to(ShenandoahOldGeneration::MARKING);\n+    }\n+    case ShenandoahOldGeneration::MARKING: {\n+      ShenandoahGCSession session(cause, old_generation);\n+      bool marking_complete = resume_concurrent_old_cycle(old_generation, cause);\n+      if (marking_complete) {\n+        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking\");\n+        if (original_state == ShenandoahOldGeneration::MARKING) {\n+          heap->mmu_tracker()->record_old_marking_increment(true);\n+          heap->log_heap_status(\"At end of Concurrent Old Marking finishing increment\");\n+        }\n+      } else if (original_state == ShenandoahOldGeneration::MARKING) {\n+        heap->mmu_tracker()->record_old_marking_increment(false);\n+        heap->log_heap_status(\"At end of Concurrent Old Marking increment\");\n+      }\n+      break;\n+    }\n+    default:\n+      fatal(\"Unexpected state for old GC: %s\", ShenandoahOldGeneration::state_name(old_generation->state()));\n+  }\n+}\n+\n+bool ShenandoahGenerationalControlThread::resume_concurrent_old_cycle(ShenandoahOldGeneration* generation, GCCause::Cause cause) {\n+  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n+  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued\", generation->task_queues()->tasks());\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ We can only tolerate being cancelled during concurrent marking or during preparation for mixed\n+  \/\/ evacuation. This flag here (passed by reference) is used to control precisely where the regulator\n+  \/\/ is allowed to cancel a GC.\n+  ShenandoahOldGC gc(generation, _allow_old_preemption);\n+  if (gc.collect(cause)) {\n+    heap->notify_gc_progress();\n+    generation->record_success_concurrent(false);\n+  }\n+\n+  if (heap->cancelled_gc()) {\n+    \/\/ It's possible the gc cycle was cancelled after the last time\n+    \/\/ the collection checked for cancellation. In which case, the\n+    \/\/ old gc cycle is still completed, and we have to deal with this\n+    \/\/ cancellation. We set the degeneration point to be outside\n+    \/\/ the cycle because if this is an allocation failure, that is\n+    \/\/ what must be done (there is no degenerated old cycle). If the\n+    \/\/ cancellation was due to a heuristic wanting to start a young\n+    \/\/ cycle, then we are not actually going to a degenerated cycle,\n+    \/\/ so the degenerated point doesn't matter here.\n+    check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle);\n+    if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n+      heap->shenandoah_policy()->record_interrupted_old();\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void ShenandoahGenerationalControlThread::service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool do_old_gc_bootstrap) {\n+  \/\/ Normal cycle goes via all concurrent phases. If allocation failure (af) happens during\n+  \/\/ any of the concurrent phases, it first degrades to Degenerated GC and completes GC there.\n+  \/\/ If second allocation failure happens during Degenerated GC cycle (for example, when GC\n+  \/\/ tries to evac something and no memory is available), cycle degrades to Full GC.\n+  \/\/\n+  \/\/ There are also a shortcut through the normal cycle: immediate garbage shortcut, when\n+  \/\/ heuristics says there are no regions to compact, and all the collection comes from immediately\n+  \/\/ reclaimable regions.\n+  \/\/\n+  \/\/ ................................................................................................\n+  \/\/\n+  \/\/                                    (immediate garbage shortcut)                Concurrent GC\n+  \/\/                             \/-------------------------------------------\\\n+  \/\/                             |                                           |\n+  \/\/                             |                                           |\n+  \/\/                             |                                           |\n+  \/\/                             |                                           v\n+  \/\/ [START] ----> Conc Mark ----o----> Conc Evac --o--> Conc Update-Refs ---o----> [END]\n+  \/\/                   |                    |                 |              ^\n+  \/\/                   | (af)               | (af)            | (af)         |\n+  \/\/ ..................|....................|.................|..............|.......................\n+  \/\/                   |                    |                 |              |\n+  \/\/                   |                    |                 |              |      Degenerated GC\n+  \/\/                   v                    v                 v              |\n+  \/\/               STW Mark ----------> STW Evac ----> STW Update-Refs ----->o\n+  \/\/                   |                    |                 |              ^\n+  \/\/                   | (af)               | (af)            | (af)         |\n+  \/\/ ..................|....................|.................|..............|.......................\n+  \/\/                   |                    |                 |              |\n+  \/\/                   |                    v                 |              |      Full GC\n+  \/\/                   \\------------------->o<----------------\/              |\n+  \/\/                                        |                                |\n+  \/\/                                        v                                |\n+  \/\/                                      Full GC  --------------------------\/\n+  \/\/\n+  if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) return;\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGCSession session(cause, generation);\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  service_concurrent_cycle(heap, generation, cause, do_old_gc_bootstrap);\n+}\n+\n+void ShenandoahGenerationalControlThread::service_concurrent_cycle(ShenandoahHeap* heap,\n+                                                       ShenandoahGeneration* generation,\n+                                                       GCCause::Cause& cause,\n+                                                       bool do_old_gc_bootstrap) {\n+  assert(!generation->is_old(), \"Old GC takes a different control path\");\n+\n+  ShenandoahConcurrentGC gc(generation, do_old_gc_bootstrap);\n+  if (gc.collect(cause)) {\n+    \/\/ Cycle is complete\n+    heap->notify_gc_progress();\n+    generation->record_success_concurrent(gc.abbreviated());\n+  } else {\n+    assert(heap->cancelled_gc(), \"Must have been cancelled\");\n+    check_cancellation_or_degen(gc.degen_point());\n+\n+    \/\/ Concurrent young-gen collection degenerates to young\n+    \/\/ collection.  Same for global collections.\n+    _degen_generation = generation;\n+  }\n+  const char* msg;\n+  ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n+  if (generation->is_young()) {\n+    if (heap->cancelled_gc()) {\n+      msg = (do_old_gc_bootstrap) ? \"At end of Interrupted Concurrent Bootstrap GC\" :\n+            \"At end of Interrupted Concurrent Young GC\";\n+    } else {\n+      \/\/ We only record GC results if GC was successful\n+      msg = (do_old_gc_bootstrap) ? \"At end of Concurrent Bootstrap GC\" :\n+            \"At end of Concurrent Young GC\";\n+      if (heap->collection_set()->has_old_regions()) {\n+        mmu_tracker->record_mixed(get_gc_id());\n+      } else if (do_old_gc_bootstrap) {\n+        mmu_tracker->record_bootstrap(get_gc_id());\n+      } else {\n+        mmu_tracker->record_young(get_gc_id());\n+      }\n+    }\n+  } else {\n+    assert(generation->is_global(), \"If not young, must be GLOBAL\");\n+    assert(!do_old_gc_bootstrap, \"Do not bootstrap with GLOBAL GC\");\n+    if (heap->cancelled_gc()) {\n+      msg = \"At end of Interrupted Concurrent GLOBAL GC\";\n+    } else {\n+      \/\/ We only record GC results if GC was successful\n+      msg = \"At end of Concurrent Global GC\";\n+      mmu_tracker->record_global(get_gc_id());\n+    }\n+  }\n+  heap->log_heap_status(msg);\n+}\n+\n+bool ShenandoahGenerationalControlThread::check_cancellation_or_degen(ShenandoahGC::ShenandoahDegenPoint point) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (!heap->cancelled_gc()) {\n+    return false;\n+  }\n+\n+  if (in_graceful_shutdown()) {\n+    return true;\n+  }\n+\n+  assert(_degen_point == ShenandoahGC::_degenerated_outside_cycle,\n+         \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n+\n+  if (is_alloc_failure_gc()) {\n+    _degen_point = point;\n+    _preemption_requested.unset();\n+    return true;\n+  }\n+\n+  if (_preemption_requested.is_set()) {\n+    assert(_requested_generation == YOUNG, \"Only young GCs may preempt old.\");\n+    _preemption_requested.unset();\n+\n+    \/\/ Old generation marking is only cancellable during concurrent marking.\n+    \/\/ Once final mark is complete, the code does not check again for cancellation.\n+    \/\/ If old generation was cancelled for an allocation failure, we wouldn't\n+    \/\/ make it to this case. The calling code is responsible for forcing a\n+    \/\/ cancellation due to allocation failure into a degenerated cycle.\n+    _degen_point = point;\n+    heap->clear_cancelled_gc(false \/* clear oom handler *\/);\n+    return true;\n+  }\n+\n+  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking\");\n+  return false;\n+}\n+\n+void ShenandoahGenerationalControlThread::stop_service() {\n+  \/\/ Nothing to do here.\n+}\n+\n+void ShenandoahGenerationalControlThread::service_stw_full_cycle(GCCause::Cause cause) {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  GCIdMark gc_id_mark;\n+  ShenandoahGCSession session(cause, heap->global_generation());\n+\n+  ShenandoahFullGC gc;\n+  gc.collect(cause);\n+}\n+\n+void ShenandoahGenerationalControlThread::service_stw_degenerated_cycle(GCCause::Cause cause,\n+                                                            ShenandoahGC::ShenandoahDegenPoint point) {\n+  assert(point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  GCIdMark gc_id_mark;\n+  ShenandoahGCSession session(cause, _degen_generation);\n+\n+  ShenandoahDegenGC gc(point, _degen_generation);\n+  gc.collect(cause);\n+\n+  assert(heap->young_generation()->task_queues()->is_empty(), \"Unexpected young generation marking tasks\");\n+  if (_degen_generation->is_global()) {\n+    assert(heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n+    assert(heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n+  } else {\n+    assert(_degen_generation->is_young(), \"Expected degenerated young cycle, if not global.\");\n+    ShenandoahOldGeneration* old = heap->old_generation();\n+    if (old->is_bootstrapping()) {\n+      old->transition_to(ShenandoahOldGeneration::MARKING);\n+    }\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::request_gc(GCCause::Cause cause) {\n+  if (ShenandoahCollectorPolicy::should_handle_requested_gc(cause)) {\n+    handle_requested_gc(cause);\n+  }\n+}\n+\n+bool ShenandoahGenerationalControlThread::request_concurrent_gc(ShenandoahGenerationType generation) {\n+  if (_preemption_requested.is_set() || _requested_gc_cause != GCCause::_no_gc || ShenandoahHeap::heap()->cancelled_gc()) {\n+    \/\/ Ignore subsequent requests from the heuristics\n+    log_debug(gc, thread)(\"Reject request for concurrent gc: preemption_requested: %s, gc_requested: %s, gc_cancelled: %s\",\n+                          BOOL_TO_STR(_preemption_requested.is_set()),\n+                          GCCause::to_string(_requested_gc_cause),\n+                          BOOL_TO_STR(ShenandoahHeap::heap()->cancelled_gc()));\n+    return false;\n+  }\n+\n+  if (gc_mode() == none) {\n+    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(existing));\n+      return false;\n+    }\n+\n+    _requested_generation = generation;\n+    notify_control_thread();\n+\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    while (gc_mode() == none) {\n+      ml.wait();\n+    }\n+    return true;\n+  }\n+\n+  if (preempt_old_marking(generation)) {\n+    assert(gc_mode() == servicing_old, \"Expected to be servicing old, but was: %s.\", gc_mode_name(gc_mode()));\n+    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"Reject request to interrupt old gc because another gc is pending: %s\", GCCause::to_string(existing));\n+      return false;\n+    }\n+\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n+    _requested_generation = generation;\n+    _preemption_requested.set();\n+    ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n+    notify_control_thread();\n+\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    while (gc_mode() == servicing_old) {\n+      ml.wait();\n+    }\n+    return true;\n+  }\n+\n+  log_debug(gc, thread)(\"Reject request for concurrent gc: mode: %s, allow_old_preemption: %s\",\n+                        gc_mode_name(gc_mode()),\n+                        BOOL_TO_STR(_allow_old_preemption.is_set()));\n+  return false;\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_control_thread() {\n+  MonitorLocker locker(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _control_lock.notify();\n+}\n+\n+bool ShenandoahGenerationalControlThread::preempt_old_marking(ShenandoahGenerationType generation) {\n+  return (generation == YOUNG) && _allow_old_preemption.try_unset();\n+}\n+\n+void ShenandoahGenerationalControlThread::handle_requested_gc(GCCause::Cause cause) {\n+  \/\/ For normal requested GCs (System.gc) we want to block the caller. However,\n+  \/\/ for whitebox requested GC, we want to initiate the GC and return immediately.\n+  \/\/ The whitebox caller thread will arrange for itself to wait until the GC notifies\n+  \/\/ it that has reached the requested breakpoint (phase in the GC).\n+  if (cause == GCCause::_wb_breakpoint) {\n+    Atomic::xchg(&_requested_gc_cause, cause);\n+    notify_control_thread();\n+    return;\n+  }\n+\n+  \/\/ Make sure we have at least one complete GC cycle before unblocking\n+  \/\/ from the explicit GC request.\n+  \/\/\n+  \/\/ This is especially important for weak references cleanup and\/or native\n+  \/\/ resources (e.g. DirectByteBuffers) machinery: when explicit GC request\n+  \/\/ comes very late in the already running cycle, it would miss lots of new\n+  \/\/ opportunities for cleanup that were made available before the caller\n+  \/\/ requested the GC.\n+\n+  MonitorLocker ml(&_gc_waiters_lock);\n+  size_t current_gc_id = get_gc_id();\n+  size_t required_gc_id = current_gc_id + 1;\n+  while (current_gc_id < required_gc_id) {\n+    \/\/ This races with the regulator thread to start a concurrent gc and the\n+    \/\/ control thread to clear it at the start of a cycle. Threads here are\n+    \/\/ allowed to escalate a heuristic's request for concurrent gc.\n+    GCCause::Cause existing = Atomic::xchg(&_requested_gc_cause, cause);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"GC request supersedes existing request: %s\", GCCause::to_string(existing));\n+    }\n+\n+    notify_control_thread();\n+    ml.wait();\n+    current_gc_id = get_gc_id();\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_gc_waiters() {\n+  MonitorLocker ml(&_gc_waiters_lock);\n+  ml.notify_all();\n+}\n+\n+const char* ShenandoahGenerationalControlThread::gc_mode_name(ShenandoahGenerationalControlThread::GCMode mode) {\n+  switch (mode) {\n+    case none:              return \"idle\";\n+    case concurrent_normal: return \"normal\";\n+    case stw_degenerated:   return \"degenerated\";\n+    case stw_full:          return \"full\";\n+    case servicing_old:     return \"old\";\n+    case bootstrapping_old: return \"bootstrap\";\n+    default:                return \"unknown\";\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::set_gc_mode(ShenandoahGenerationalControlThread::GCMode new_mode) {\n+  if (_mode != new_mode) {\n+    log_debug(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    _mode = new_mode;\n+    ml.notify_all();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":841,"deletions":0,"binary":false,"changes":841,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALCONTROLTHREAD_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALCONTROLTHREAD_HPP\n+\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPadding.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+class ShenandoahOldGeneration;\n+class ShenandoahGeneration;\n+class ShenandoahGenerationalHeap;\n+class ShenandoahHeap;\n+\n+class ShenandoahGenerationalControlThread: public ShenandoahController {\n+  friend class VMStructs;\n+\n+public:\n+  typedef enum {\n+    none,\n+    concurrent_normal,\n+    stw_degenerated,\n+    stw_full,\n+    bootstrapping_old,\n+    servicing_old\n+  } GCMode;\n+\n+private:\n+  Monitor _control_lock;\n+  Monitor _regulator_lock;\n+\n+  ShenandoahSharedFlag _allow_old_preemption;\n+  ShenandoahSharedFlag _preemption_requested;\n+\n+  GCCause::Cause  _requested_gc_cause;\n+  volatile ShenandoahGenerationType _requested_generation;\n+  ShenandoahGC::ShenandoahDegenPoint _degen_point;\n+  ShenandoahGeneration* _degen_generation;\n+\n+  shenandoah_padding(0);\n+  volatile GCMode _mode;\n+  shenandoah_padding(1);\n+\n+public:\n+  ShenandoahGenerationalControlThread();\n+\n+  void run_service() override;\n+  void stop_service() override;\n+\n+  void request_gc(GCCause::Cause cause) override;\n+\n+  \/\/ Return true if the request to start a concurrent GC for the given generation succeeded.\n+  bool request_concurrent_gc(ShenandoahGenerationType generation);\n+\n+  GCMode gc_mode() {\n+    return _mode;\n+  }\n+private:\n+\n+  \/\/ Returns true if the cycle has been cancelled or degenerated.\n+  bool check_cancellation_or_degen(ShenandoahGC::ShenandoahDegenPoint point);\n+\n+  \/\/ Returns true if the old generation marking completed (i.e., final mark executed for old generation).\n+  bool resume_concurrent_old_cycle(ShenandoahOldGeneration* generation, GCCause::Cause cause);\n+  void service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool reset_old_bitmap_specially);\n+  void service_stw_full_cycle(GCCause::Cause cause);\n+  void service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point);\n+\n+  void notify_gc_waiters();\n+\n+  \/\/ Handle GC request.\n+  \/\/ Blocks until GC is over.\n+  void handle_requested_gc(GCCause::Cause cause);\n+\n+  bool is_explicit_gc(GCCause::Cause cause) const;\n+  bool is_implicit_gc(GCCause::Cause cause) const;\n+\n+  \/\/ Returns true if the old generation marking was interrupted to allow a young cycle.\n+  bool preempt_old_marking(ShenandoahGenerationType generation);\n+\n+  void process_phase_timings(const ShenandoahGenerationalHeap* heap);\n+\n+  void service_concurrent_normal_cycle(ShenandoahGenerationalHeap* heap,\n+                                       ShenandoahGenerationType generation,\n+                                       GCCause::Cause cause);\n+\n+  void service_concurrent_old_cycle(ShenandoahGenerationalHeap* heap,\n+                                    GCCause::Cause &cause);\n+\n+  void set_gc_mode(GCMode new_mode);\n+\n+  static const char* gc_mode_name(GCMode mode);\n+\n+  void notify_control_thread();\n+\n+  void service_concurrent_cycle(ShenandoahHeap* heap,\n+                                ShenandoahGeneration* generation,\n+                                GCCause::Cause &cause,\n+                                bool do_old_gc_bootstrap);\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALCONTROLTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,326 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPacer.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+\n+class ShenandoahConcurrentEvacuator : public ObjectClosure {\n+private:\n+  ShenandoahGenerationalHeap* const _heap;\n+  Thread* const _thread;\n+public:\n+  explicit ShenandoahConcurrentEvacuator(ShenandoahGenerationalHeap* heap) :\n+          _heap(heap), _thread(Thread::current()) {}\n+\n+  void do_object(oop p) override {\n+    shenandoah_assert_marked(nullptr, p);\n+    if (!p->is_forwarded()) {\n+      _heap->evacuate_object(p, _thread);\n+    }\n+  }\n+};\n+\n+ShenandoahGenerationalEvacuationTask::ShenandoahGenerationalEvacuationTask(ShenandoahGenerationalHeap* heap,\n+                                                                           ShenandoahRegionIterator* iterator,\n+                                                                           bool concurrent, bool only_promote_regions) :\n+  WorkerTask(\"Shenandoah Evacuation\"),\n+  _heap(heap),\n+  _regions(iterator),\n+  _concurrent(concurrent),\n+  _only_promote_regions(only_promote_regions),\n+  _tenuring_threshold(0)\n+{\n+  shenandoah_assert_generational();\n+  _tenuring_threshold = _heap->age_census()->tenuring_threshold();\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::work(uint worker_id) {\n+  if (_concurrent) {\n+    ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+    ShenandoahSuspendibleThreadSetJoiner stsj;\n+    do_work();\n+  } else {\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    do_work();\n+  }\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::do_work() {\n+  if (_only_promote_regions) {\n+    \/\/ No allocations will be made, do not enter oom-during-evac protocol.\n+    assert(ShenandoahHeap::heap()->collection_set()->is_empty(), \"Should not have a collection set here\");\n+    promote_regions();\n+  } else {\n+    assert(!ShenandoahHeap::heap()->collection_set()->is_empty(), \"Should have a collection set here\");\n+    ShenandoahEvacOOMScope oom_evac_scope;\n+    evacuate_and_promote_regions();\n+  }\n+}\n+\n+void log_region(const ShenandoahHeapRegion* r, LogStream* ls) {\n+  ls->print_cr(\"GenerationalEvacuationTask, looking at %s region \" SIZE_FORMAT \", (age: %d) [%s, %s, %s]\",\n+              r->is_old()? \"old\": r->is_young()? \"young\": \"free\", r->index(), r->age(),\n+              r->is_active()? \"active\": \"inactive\",\n+              r->is_humongous()? (r->is_humongous_start()? \"humongous_start\": \"humongous_continuation\"): \"regular\",\n+              r->is_cset()? \"cset\": \"not-cset\");\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::promote_regions() {\n+  ShenandoahHeapRegion* r;\n+  LogTarget(Debug, gc) lt;\n+\n+  while ((r = _regions->next()) != nullptr) {\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      log_region(r, &ls);\n+    }\n+\n+    maybe_promote_region(r);\n+\n+    if (_heap->check_cancelled_gc_and_yield(_concurrent)) {\n+      break;\n+    }\n+  }\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::evacuate_and_promote_regions() {\n+  LogTarget(Debug, gc) lt;\n+  ShenandoahConcurrentEvacuator cl(_heap);\n+  ShenandoahHeapRegion* r;\n+\n+  while ((r = _regions->next()) != nullptr) {\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      log_region(r, &ls);\n+    }\n+\n+    if (r->is_cset()) {\n+      assert(r->has_live(), \"Region \" SIZE_FORMAT \" should have been reclaimed early\", r->index());\n+      _heap->marked_object_iterate(r, &cl);\n+      if (ShenandoahPacing) {\n+        _heap->pacer()->report_evac(r->used() >> LogHeapWordSize);\n+      }\n+    } else {\n+      maybe_promote_region(r);\n+    }\n+\n+    if (_heap->check_cancelled_gc_and_yield(_concurrent)) {\n+      break;\n+    }\n+  }\n+}\n+\n+\n+void ShenandoahGenerationalEvacuationTask::maybe_promote_region(ShenandoahHeapRegion* r) {\n+  if (r->is_young() && r->is_active() && (r->age() >= _tenuring_threshold)) {\n+    if (r->is_humongous_start()) {\n+      \/\/ We promote humongous_start regions along with their affiliated continuations during evacuation rather than\n+      \/\/ doing this work during a safepoint.  We cannot put humongous regions into the collection set because that\n+      \/\/ triggers the load-reference barrier (LRB) to copy on reference fetch.\n+      \/\/\n+      \/\/ Aged humongous continuation regions are handled with their start region.  If an aged regular region has\n+      \/\/ more garbage than ShenandoahOldGarbageThreshold, we'll promote by evacuation.  If there is room for evacuation\n+      \/\/ in this cycle, the region will be in the collection set.  If there is not room, the region will be promoted\n+      \/\/ by evacuation in some future GC cycle.\n+      promote_humongous(r);\n+    } else if (r->is_regular() && (r->get_top_before_promote() != nullptr)) {\n+      \/\/ Likewise, we cannot put promote-in-place regions into the collection set because that would also trigger\n+      \/\/ the LRB to copy on reference fetch.\n+      \/\/\n+      \/\/ If an aged regular region has received allocations during the current cycle, we do not promote because the\n+      \/\/ newly allocated objects do not have appropriate age; this region's age will be reset to zero at end of cycle.\n+      promote_in_place(r);\n+    }\n+  }\n+}\n+\n+\/\/ When we promote a region in place, we can continue to use the established marking context to guide subsequent remembered\n+\/\/ set scans of this region's content.  The region will be coalesced and filled prior to the next old-gen marking effort.\n+\/\/ We identify the entirety of the region as DIRTY to force the next remembered set scan to identify the \"interesting pointers\"\n+\/\/ contained herein.\n+void ShenandoahGenerationalEvacuationTask::promote_in_place(ShenandoahHeapRegion* region) {\n+  ShenandoahMarkingContext* const marking_context = _heap->complete_marking_context();\n+  HeapWord* const tams = marking_context->top_at_mark_start(region);\n+\n+  {\n+    const size_t old_garbage_threshold = (ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold) \/ 100;\n+    shenandoah_assert_generations_reconciled();\n+    assert(!_heap->is_concurrent_old_mark_in_progress(), \"Cannot promote in place during old marking\");\n+    assert(region->garbage_before_padded_for_promote() < old_garbage_threshold, \"Region \" SIZE_FORMAT \" has too much garbage for promotion\", region->index());\n+    assert(region->is_young(), \"Only young regions can be promoted\");\n+    assert(region->is_regular(), \"Use different service to promote humongous regions\");\n+    assert(region->age() >= _tenuring_threshold, \"Only promote regions that are sufficiently aged\");\n+    assert(region->get_top_before_promote() == tams, \"Region \" SIZE_FORMAT \" has been used for allocations before promotion\", region->index());\n+  }\n+\n+  ShenandoahOldGeneration* const old_gen = _heap->old_generation();\n+  ShenandoahYoungGeneration* const young_gen = _heap->young_generation();\n+\n+  \/\/ Rebuild the remembered set information and mark the entire range as DIRTY.  We do NOT scan the content of this\n+  \/\/ range to determine which cards need to be DIRTY.  That would force us to scan the region twice, once now, and\n+  \/\/ once during the subsequent remembered set scan.  Instead, we blindly (conservatively) mark everything as DIRTY\n+  \/\/ now and then sort out the CLEAN pages during the next remembered set scan.\n+  \/\/\n+  \/\/ Rebuilding the remembered set consists of clearing all object registrations (reset_object_range()) here,\n+  \/\/ then registering every live object and every coalesced range of free objects in the loop that follows.\n+  ShenandoahScanRemembered* const scanner = old_gen->card_scan();\n+  scanner->reset_object_range(region->bottom(), region->end());\n+  scanner->mark_range_as_dirty(region->bottom(), region->get_top_before_promote() - region->bottom());\n+\n+  HeapWord* obj_addr = region->bottom();\n+  while (obj_addr < tams) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != nullptr, \"klass should not be NULL\");\n+      \/\/ This thread is responsible for registering all objects in this region.  No need for lock.\n+      scanner->register_object_without_lock(obj_addr);\n+      obj_addr += obj->size();\n+    } else {\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, tams);\n+      assert(next_marked_obj <= tams, \"next marked object cannot exceed tams\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      assert(fill_size >= ShenandoahHeap::min_fill_size(), \"previously allocated objects known to be larger than min_size\");\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      scanner->register_object_without_lock(obj_addr);\n+      obj_addr = next_marked_obj;\n+    }\n+  }\n+  \/\/ We do not need to scan above TAMS because restored top equals tams\n+  assert(obj_addr == tams, \"Expect loop to terminate when obj_addr equals tams\");\n+\n+\n+  {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+\n+    HeapWord* update_watermark = region->get_update_watermark();\n+\n+    \/\/ Now that this region is affiliated with old, we can allow it to receive allocations, though it may not be in the\n+    \/\/ is_collector_free range.\n+    region->restore_top_before_promote();\n+\n+    size_t region_used = region->used();\n+\n+    \/\/ The update_watermark was likely established while we had the artificially high value of top.  Make it sane now.\n+    assert(update_watermark >= region->top(), \"original top cannot exceed preserved update_watermark\");\n+    region->set_update_watermark(region->top());\n+\n+    \/\/ Unconditionally transfer one region from young to old. This represents the newly promoted region.\n+    \/\/ This expands old and shrinks new by the size of one region.  Strictly, we do not \"need\" to expand old\n+    \/\/ if there are already enough unaffiliated regions in old to account for this newly promoted region.\n+    \/\/ However, if we do not transfer the capacities, we end up reducing the amount of memory that would have\n+    \/\/ otherwise been available to hold old evacuations, because old available is max_capacity - used and now\n+    \/\/ we would be trading a fully empty region for a partially used region.\n+    young_gen->decrease_used(region_used);\n+    young_gen->decrement_affiliated_region_count();\n+\n+    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n+    _heap->generation_sizer()->force_transfer_to_old(1);\n+    region->set_affiliation(OLD_GENERATION);\n+\n+    old_gen->increment_affiliated_region_count();\n+    old_gen->increase_used(region_used);\n+\n+    \/\/ add_old_collector_free_region() increases promoted_reserve() if available space exceeds plab_min_size()\n+    _heap->free_set()->add_promoted_in_place_region_to_old_collector(region);\n+  }\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::promote_humongous(ShenandoahHeapRegion* region) {\n+  ShenandoahMarkingContext* marking_context = _heap->marking_context();\n+  oop obj = cast_to_oop(region->bottom());\n+  assert(_heap->gc_generation()->is_mark_complete(), \"sanity\");\n+  shenandoah_assert_generations_reconciled();\n+  assert(region->is_young(), \"Only young regions can be promoted\");\n+  assert(region->is_humongous_start(), \"Should not promote humongous continuation in isolation\");\n+  assert(region->age() >= _tenuring_threshold, \"Only promote regions that are sufficiently aged\");\n+  assert(marking_context->is_marked(obj), \"promoted humongous object should be alive\");\n+\n+  const size_t used_bytes = obj->size() * HeapWordSize;\n+  const size_t spanned_regions = ShenandoahHeapRegion::required_regions(used_bytes);\n+  const size_t humongous_waste = spanned_regions * ShenandoahHeapRegion::region_size_bytes() - obj->size() * HeapWordSize;\n+  const size_t index_limit = region->index() + spanned_regions;\n+\n+  ShenandoahOldGeneration* const old_gen = _heap->old_generation();\n+  ShenandoahGeneration* const young_gen = _heap->young_generation();\n+  {\n+    \/\/ We need to grab the heap lock in order to avoid a race when changing the affiliations of spanned_regions from\n+    \/\/ young to old.\n+    ShenandoahHeapLocker locker(_heap->lock());\n+\n+    \/\/ We promote humongous objects unconditionally, without checking for availability.  We adjust\n+    \/\/ usage totals, including humongous waste, after evacuation is done.\n+    log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", spanning \" SIZE_FORMAT, region->index(), spanned_regions);\n+\n+    young_gen->decrease_used(used_bytes);\n+    young_gen->decrease_humongous_waste(humongous_waste);\n+    young_gen->decrease_affiliated_region_count(spanned_regions);\n+\n+    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n+    _heap->generation_sizer()->force_transfer_to_old(spanned_regions);\n+\n+    \/\/ For this region and each humongous continuation region spanned by this humongous object, change\n+    \/\/ affiliation to OLD_GENERATION and adjust the generation-use tallies.  The remnant of memory\n+    \/\/ in the last humongous region that is not spanned by obj is currently not used.\n+    for (size_t i = region->index(); i < index_limit; i++) {\n+      ShenandoahHeapRegion* r = _heap->get_region(i);\n+      log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+              r->index(), p2i(r->bottom()), p2i(r->top()));\n+      \/\/ We mark the entire humongous object's range as dirty after loop terminates, so no need to dirty the range here\n+      r->set_affiliation(OLD_GENERATION);\n+    }\n+\n+    old_gen->increase_affiliated_region_count(spanned_regions);\n+    old_gen->increase_used(used_bytes);\n+    old_gen->increase_humongous_waste(humongous_waste);\n+  }\n+\n+  \/\/ Since this region may have served previously as OLD, it may hold obsolete object range info.\n+  HeapWord* const humongous_bottom = region->bottom();\n+  ShenandoahScanRemembered* const scanner = old_gen->card_scan();\n+  scanner->reset_object_range(humongous_bottom, humongous_bottom + spanned_regions * ShenandoahHeapRegion::region_size_words());\n+  \/\/ Since the humongous region holds only one object, no lock is necessary for this register_object() invocation.\n+  scanner->register_object_without_lock(humongous_bottom);\n+\n+  if (obj->is_typeArray()) {\n+    \/\/ Primitive arrays don't need to be scanned.\n+    log_debug(gc)(\"Clean cards for promoted humongous object (Region \" SIZE_FORMAT \") from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+            region->index(), p2i(humongous_bottom), p2i(humongous_bottom + obj->size()));\n+    scanner->mark_range_as_clean(humongous_bottom, obj->size());\n+  } else {\n+    log_debug(gc)(\"Dirty cards for promoted humongous object (Region \" SIZE_FORMAT \") from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+            region->index(), p2i(humongous_bottom), p2i(humongous_bottom + obj->size()));\n+    scanner->mark_range_as_dirty(humongous_bottom, obj->size());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":326,"deletions":0,"binary":false,"changes":326,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALEVACUATIONTASK_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALEVACUATIONTASK_HPP\n+\n+#include \"gc\/shared\/workerThread.hpp\"\n+\n+class ShenandoahGenerationalHeap;\n+class ShenandoahHeapRegion;\n+class ShenandoahRegionIterator;\n+\n+\/\/ Unlike ShenandoahEvacuationTask, this iterates over all regions rather than just the collection set.\n+\/\/ This is needed in order to promote humongous start regions if age() >= tenure threshold.\n+class ShenandoahGenerationalEvacuationTask : public WorkerTask {\n+private:\n+  ShenandoahGenerationalHeap* const _heap;\n+  ShenandoahRegionIterator* _regions;\n+  bool _concurrent;\n+  bool _only_promote_regions;\n+  uint _tenuring_threshold;\n+\n+public:\n+  ShenandoahGenerationalEvacuationTask(ShenandoahGenerationalHeap* sh,\n+                                       ShenandoahRegionIterator* iterator,\n+                                       bool concurrent, bool only_promote_regions);\n+  void work(uint worker_id) override;\n+private:\n+  void do_work();\n+  void promote_regions();\n+  void evacuate_and_promote_regions();\n+  void maybe_promote_region(ShenandoahHeapRegion* region);\n+  void promote_in_place(ShenandoahHeapRegion* region);\n+  void promote_humongous(ShenandoahHeapRegion* region);\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALEVACUATIONTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,390 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalFullGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+\n+#ifdef ASSERT\n+void assert_regions_used_not_more_than_capacity(ShenandoahGeneration* generation) {\n+  assert(generation->used_regions_size() <= generation->max_capacity(),\n+         \"%s generation affiliated regions must be less than capacity\", generation->name());\n+}\n+\n+void assert_usage_not_more_than_regions_used(ShenandoahGeneration* generation) {\n+  assert(generation->used_including_humongous_waste() <= generation->used_regions_size(),\n+         \"%s consumed can be no larger than span of affiliated regions\", generation->name());\n+}\n+#else\n+void assert_regions_used_not_more_than_capacity(ShenandoahGeneration* generation) {}\n+void assert_usage_not_more_than_regions_used(ShenandoahGeneration* generation) {}\n+#endif\n+\n+\n+void ShenandoahGenerationalFullGC::prepare() {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  \/\/ Since we may arrive here from degenerated GC failure of either young or old, establish generation as GLOBAL.\n+  heap->set_gc_generation(heap->global_generation());\n+  heap->set_active_generation();\n+\n+  \/\/ No need for old_gen->increase_used() as this was done when plabs were allocated.\n+  heap->reset_generation_reserves();\n+\n+  \/\/ Full GC supersedes any marking or coalescing in old generation.\n+  heap->old_generation()->cancel_gc();\n+}\n+\n+void ShenandoahGenerationalFullGC::handle_completion(ShenandoahHeap* heap) {\n+  \/\/ Full GC should reset time since last gc for young and old heuristics\n+  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::cast(heap);\n+  ShenandoahYoungGeneration* young = gen_heap->young_generation();\n+  ShenandoahOldGeneration* old = gen_heap->old_generation();\n+  young->heuristics()->record_cycle_end();\n+  old->heuristics()->record_cycle_end();\n+\n+  gen_heap->mmu_tracker()->record_full(GCId::current());\n+  gen_heap->log_heap_status(\"At end of Full GC\");\n+\n+  assert(old->is_idle(), \"After full GC, old generation should be idle.\");\n+\n+  \/\/ Since we allow temporary violation of these constraints during Full GC, we want to enforce that the assertions are\n+  \/\/ made valid by the time Full GC completes.\n+  assert_regions_used_not_more_than_capacity(old);\n+  assert_regions_used_not_more_than_capacity(young);\n+  assert_usage_not_more_than_regions_used(old);\n+  assert_usage_not_more_than_regions_used(young);\n+\n+  \/\/ Establish baseline for next old-has-grown trigger.\n+  old->set_live_bytes_after_last_mark(old->used_including_humongous_waste());\n+}\n+\n+void ShenandoahGenerationalFullGC::rebuild_remembered_set(ShenandoahHeap* heap) {\n+  ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_reconstruct_remembered_set);\n+  ShenandoahRegionIterator regions;\n+  ShenandoahReconstructRememberedSetTask task(&regions);\n+  heap->workers()->run_task(&task);\n+\n+  \/\/ Rebuilding the remembered set recomputes all the card offsets for objects.\n+  \/\/ The adjust pointers phase coalesces and fills all necessary regions. In case\n+  \/\/ we came to the full GC from an incomplete global cycle, we need to indicate\n+  \/\/ that the old regions are parsable.\n+  heap->old_generation()->set_parsable(true);\n+}\n+\n+void ShenandoahGenerationalFullGC::balance_generations_after_gc(ShenandoahHeap* heap) {\n+  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::cast(heap);\n+  ShenandoahOldGeneration* const old_gen = gen_heap->old_generation();\n+\n+  size_t old_usage = old_gen->used_regions_size();\n+  size_t old_capacity = old_gen->max_capacity();\n+\n+  assert(old_usage % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old usage must align with region size\");\n+  assert(old_capacity % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old capacity must align with region size\");\n+\n+  if (old_capacity > old_usage) {\n+    size_t excess_old_regions = (old_capacity - old_usage) \/ ShenandoahHeapRegion::region_size_bytes();\n+    gen_heap->generation_sizer()->transfer_to_young(excess_old_regions);\n+  } else if (old_capacity < old_usage) {\n+    size_t old_regions_deficit = (old_usage - old_capacity) \/ ShenandoahHeapRegion::region_size_bytes();\n+    gen_heap->generation_sizer()->force_transfer_to_old(old_regions_deficit);\n+  }\n+\n+  log_info(gc, ergo)(\"FullGC done: young usage: \" PROPERFMT \", old usage: \" PROPERFMT,\n+               PROPERFMTARGS(gen_heap->young_generation()->used()),\n+               PROPERFMTARGS(old_gen->used()));\n+}\n+\n+void ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set() {\n+  auto result = ShenandoahGenerationalHeap::heap()->balance_generations();\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Full GC\", &ls);\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::log_live_in_old(ShenandoahHeap* heap) {\n+  LogTarget(Debug, gc) lt;\n+  if (lt.is_enabled()) {\n+    size_t live_bytes_in_old = 0;\n+    for (size_t i = 0; i < heap->num_regions(); i++) {\n+      ShenandoahHeapRegion* r = heap->get_region(i);\n+      if (r->is_old()) {\n+        live_bytes_in_old += r->get_live_data_bytes();\n+      }\n+    }\n+    log_debug(gc)(\"Live bytes in old after STW mark: \" PROPERFMT, PROPERFMTARGS(live_bytes_in_old));\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::restore_top_before_promote(ShenandoahHeap* heap) {\n+  for (size_t i = 0; i < heap->num_regions(); i++) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    if (r->get_top_before_promote() != nullptr) {\n+      r->restore_top_before_promote();\n+    }\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n+  region_count++;\n+  region_usage += r->used();\n+  if (r->is_humongous_start()) {\n+    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n+    HeapWord* obj_addr = r->bottom();\n+    oop obj = cast_to_oop(obj_addr);\n+    size_t word_size = obj->size();\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t overreach = word_size % region_size_words;\n+    if (overreach != 0) {\n+      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n+    }\n+    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::maybe_coalesce_and_fill_region(ShenandoahHeapRegion* r) {\n+  if (r->is_pinned() && r->is_old() && r->is_active() && !r->is_humongous()) {\n+    r->begin_preemptible_coalesce_and_fill();\n+    r->oop_coalesce_and_fill(false);\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::compute_balances() {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+\n+  \/\/ In case this Full GC resulted from degeneration, clear the tally on anticipated promotion.\n+  heap->old_generation()->set_promotion_potential(0);\n+  \/\/ Invoke this in case we are able to transfer memory from OLD to YOUNG.\n+  heap->compute_old_generation_balance(0, 0);\n+}\n+\n+ShenandoahPrepareForGenerationalCompactionObjectClosure::ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n+                                                          GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n+                                                          ShenandoahHeapRegion* from_region, uint worker_id) :\n+        _preserved_marks(preserved_marks),\n+        _heap(ShenandoahGenerationalHeap::heap()),\n+        _tenuring_threshold(0),\n+        _empty_regions(empty_regions),\n+        _empty_regions_pos(0),\n+        _old_to_region(nullptr),\n+        _young_to_region(nullptr),\n+        _from_region(nullptr),\n+        _from_affiliation(ShenandoahAffiliation::FREE),\n+        _old_compact_point(nullptr),\n+        _young_compact_point(nullptr),\n+        _worker_id(worker_id) {\n+  assert(from_region != nullptr, \"Worker needs from_region\");\n+  \/\/ assert from_region has live?\n+  if (from_region->is_old()) {\n+    _old_to_region = from_region;\n+    _old_compact_point = from_region->bottom();\n+  } else if (from_region->is_young()) {\n+    _young_to_region = from_region;\n+    _young_compact_point = from_region->bottom();\n+  }\n+\n+  _tenuring_threshold = _heap->age_census()->tenuring_threshold();\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::set_from_region(ShenandoahHeapRegion* from_region) {\n+  log_debug(gc)(\"Worker %u compacting %s Region \" SIZE_FORMAT \" which had used \" SIZE_FORMAT \" and %s live\",\n+                _worker_id, from_region->affiliation_name(),\n+                from_region->index(), from_region->used(), from_region->has_live()? \"has\": \"does not have\");\n+\n+  _from_region = from_region;\n+  _from_affiliation = from_region->affiliation();\n+  if (_from_region->has_live()) {\n+    if (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION) {\n+      if (_old_to_region == nullptr) {\n+        _old_to_region = from_region;\n+        _old_compact_point = from_region->bottom();\n+      }\n+    } else {\n+      assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION, \"from_region must be OLD or YOUNG\");\n+      if (_young_to_region == nullptr) {\n+        _young_to_region = from_region;\n+        _young_compact_point = from_region->bottom();\n+      }\n+    }\n+  } \/\/ else, we won't iterate over this _from_region so we don't need to set up to region to hold copies\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::finish() {\n+  finish_old_region();\n+  finish_young_region();\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::finish_old_region() {\n+  if (_old_to_region != nullptr) {\n+    log_debug(gc)(\"Planned compaction into Old Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT \" tabulated by worker %u\",\n+            _old_to_region->index(), _old_compact_point - _old_to_region->bottom(), _worker_id);\n+    _old_to_region->set_new_top(_old_compact_point);\n+    _old_to_region = nullptr;\n+  }\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::finish_young_region() {\n+  if (_young_to_region != nullptr) {\n+    log_debug(gc)(\"Worker %u planned compaction into Young Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT,\n+            _worker_id, _young_to_region->index(), _young_compact_point - _young_to_region->bottom());\n+    _young_to_region->set_new_top(_young_compact_point);\n+    _young_to_region = nullptr;\n+  }\n+}\n+\n+bool ShenandoahPrepareForGenerationalCompactionObjectClosure::is_compact_same_region() {\n+  return (_from_region == _old_to_region) || (_from_region == _young_to_region);\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::do_object(oop p) {\n+  assert(_from_region != nullptr, \"must set before work\");\n+  assert((_from_region->bottom() <= cast_from_oop<HeapWord*>(p)) && (cast_from_oop<HeapWord*>(p) < _from_region->top()),\n+         \"Object must reside in _from_region\");\n+  assert(_heap->complete_marking_context()->is_marked(p), \"must be marked\");\n+  assert(!_heap->complete_marking_context()->allocated_after_mark_start(p), \"must be truly marked\");\n+\n+  size_t obj_size = p->size();\n+  uint from_region_age = _from_region->age();\n+  uint object_age = p->age();\n+\n+  bool promote_object = false;\n+  if ((_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION) &&\n+      (from_region_age + object_age >= _tenuring_threshold)) {\n+    if ((_old_to_region != nullptr) && (_old_compact_point + obj_size > _old_to_region->end())) {\n+      finish_old_region();\n+      _old_to_region = nullptr;\n+    }\n+    if (_old_to_region == nullptr) {\n+      if (_empty_regions_pos < _empty_regions.length()) {\n+        ShenandoahHeapRegion* new_to_region = _empty_regions.at(_empty_regions_pos);\n+        _empty_regions_pos++;\n+        new_to_region->set_affiliation(OLD_GENERATION);\n+        _old_to_region = new_to_region;\n+        _old_compact_point = _old_to_region->bottom();\n+        promote_object = true;\n+      }\n+      \/\/ Else this worker thread does not yet have any empty regions into which this aged object can be promoted so\n+      \/\/ we leave promote_object as false, deferring the promotion.\n+    } else {\n+      promote_object = true;\n+    }\n+  }\n+\n+  if (promote_object || (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION)) {\n+    assert(_old_to_region != nullptr, \"_old_to_region should not be nullptr when evacuating to OLD region\");\n+    if (_old_compact_point + obj_size > _old_to_region->end()) {\n+      ShenandoahHeapRegion* new_to_region;\n+\n+      log_debug(gc)(\"Worker %u finishing old region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n+      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _old_to_region->index(),\n+              p2i(_old_compact_point), obj_size, p2i(_old_compact_point + obj_size), p2i(_old_to_region->end()));\n+\n+      \/\/ Object does not fit.  Get a new _old_to_region.\n+      finish_old_region();\n+      if (_empty_regions_pos < _empty_regions.length()) {\n+        new_to_region = _empty_regions.at(_empty_regions_pos);\n+        _empty_regions_pos++;\n+        new_to_region->set_affiliation(OLD_GENERATION);\n+      } else {\n+        \/\/ If we've exhausted the previously selected _old_to_region, we know that the _old_to_region is distinct\n+        \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n+        \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n+        new_to_region = _from_region;\n+      }\n+\n+      assert(new_to_region != _old_to_region, \"must not reuse same OLD to-region\");\n+      assert(new_to_region != nullptr, \"must not be nullptr\");\n+      _old_to_region = new_to_region;\n+      _old_compact_point = _old_to_region->bottom();\n+    }\n+\n+    \/\/ Object fits into current region, record new location, if object does not move:\n+    assert(_old_compact_point + obj_size <= _old_to_region->end(), \"must fit\");\n+    shenandoah_assert_not_forwarded(nullptr, p);\n+    if (_old_compact_point != cast_from_oop<HeapWord*>(p)) {\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+      FullGCForwarding::forward_to(p, cast_to_oop(_old_compact_point));\n+    }\n+    _old_compact_point += obj_size;\n+  } else {\n+    assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION,\n+           \"_from_region must be OLD_GENERATION or YOUNG_GENERATION\");\n+    assert(_young_to_region != nullptr, \"_young_to_region should not be nullptr when compacting YOUNG _from_region\");\n+\n+    \/\/ After full gc compaction, all regions have age 0.  Embed the region's age into the object's age in order to preserve\n+    \/\/ tenuring progress.\n+    if (_heap->is_aging_cycle()) {\n+      ShenandoahHeap::increase_object_age(p, from_region_age + 1);\n+    } else {\n+      ShenandoahHeap::increase_object_age(p, from_region_age);\n+    }\n+\n+    if (_young_compact_point + obj_size > _young_to_region->end()) {\n+      ShenandoahHeapRegion* new_to_region;\n+\n+      log_debug(gc)(\"Worker %u finishing young region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n+      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _young_to_region->index(),\n+              p2i(_young_compact_point), obj_size, p2i(_young_compact_point + obj_size), p2i(_young_to_region->end()));\n+\n+      \/\/ Object does not fit.  Get a new _young_to_region.\n+      finish_young_region();\n+      if (_empty_regions_pos < _empty_regions.length()) {\n+        new_to_region = _empty_regions.at(_empty_regions_pos);\n+        _empty_regions_pos++;\n+        new_to_region->set_affiliation(YOUNG_GENERATION);\n+      } else {\n+        \/\/ If we've exhausted the previously selected _young_to_region, we know that the _young_to_region is distinct\n+        \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n+        \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n+        new_to_region = _from_region;\n+      }\n+\n+      assert(new_to_region != _young_to_region, \"must not reuse same OLD to-region\");\n+      assert(new_to_region != nullptr, \"must not be nullptr\");\n+      _young_to_region = new_to_region;\n+      _young_compact_point = _young_to_region->bottom();\n+    }\n+\n+    \/\/ Object fits into current region, record new location, if object does not move:\n+    assert(_young_compact_point + obj_size <= _young_to_region->end(), \"must fit\");\n+    shenandoah_assert_not_forwarded(nullptr, p);\n+\n+    if (_young_compact_point != cast_from_oop<HeapWord*>(p)) {\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+      FullGCForwarding::forward_to(p, cast_to_oop(_young_compact_point));\n+    }\n+    _young_compact_point += obj_size;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":390,"deletions":0,"binary":false,"changes":390,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALFULLGC_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALFULLGC_HPP\n+\n+#include \"gc\/shared\/preservedMarks.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ShenandoahHeap;\n+class ShenandoahHeapRegion;\n+\n+class ShenandoahGenerationalFullGC {\n+public:\n+  \/\/ Prepares the generational mode heap for a full collection.\n+  static void prepare();\n+\n+  \/\/ Full GC may have compacted objects in the old generation, so we need to rebuild the card tables.\n+  static void rebuild_remembered_set(ShenandoahHeap* heap);\n+\n+  \/\/ Records end of cycle for young and old and establishes size of live bytes in old\n+  static void handle_completion(ShenandoahHeap* heap);\n+\n+  \/\/ Full GC may have promoted regions and may have temporarily violated constraints on the usage and\n+  \/\/ capacity of the old generation. This method will balance the accounting of regions between the\n+  \/\/ young and old generations. This is somewhat vestigial, but the outcome of this method is used\n+  \/\/ when rebuilding the free sets.\n+  static void balance_generations_after_gc(ShenandoahHeap* heap);\n+\n+  \/\/ This will compute the target size for the old generation. It will be expressed in terms of\n+  \/\/ a region surplus and deficit, which will be redistributed accordingly after rebuilding the\n+  \/\/ free set.\n+  static void compute_balances();\n+\n+  \/\/ Rebuilding the free set may have resulted in regions being pulled in to the old generation\n+  \/\/ evacuation reserve. For this reason, we must update the usage and capacity of the generations\n+  \/\/ again. In the distant past, the free set did not know anything about generations, so we had\n+  \/\/ a layer built above it to represent how much young\/old memory was available. This layer is\n+  \/\/ redundant and adds complexity. We would like to one day remove it. Until then, we must keep it\n+  \/\/ synchronized with the free set's view of things.\n+  static void balance_generations_after_rebuilding_free_set();\n+\n+  \/\/ Logs the number of live bytes marked in the old generation. This is _not_ the same\n+  \/\/ value used as the baseline for the old generation _after_ the full gc is complete.\n+  \/\/ The value reported in the logs does not include objects and regions that may be\n+  \/\/ promoted during the full gc.\n+  static void log_live_in_old(ShenandoahHeap* heap);\n+\n+  \/\/ This is used to tally the number, usage and space wasted by humongous objects for each generation.\n+  static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste);\n+\n+  \/\/ Regions which are scheduled for in-place promotion during evacuation temporarily\n+  \/\/ have their top set to their end to prevent new objects from being allocated in them\n+  \/\/ before they are promoted. If the full GC encounters such a region, it means the\n+  \/\/ in-place promotion did not happen, and we must restore the original value of top.\n+  static void restore_top_before_promote(ShenandoahHeap* heap);\n+\n+  \/\/ Pinned regions are not compacted, so they may still hold unmarked objects with\n+  \/\/ references to reclaimed memory. Remembered set scanning will crash if it attempts\n+  \/\/ to iterate the oops in these objects. This method fills in dead objects for pinned,\n+  \/\/ old regions.\n+  static void maybe_coalesce_and_fill_region(ShenandoahHeapRegion* r);\n+};\n+\n+class ShenandoahPrepareForGenerationalCompactionObjectClosure : public ObjectClosure {\n+private:\n+  PreservedMarks*             const _preserved_marks;\n+  ShenandoahGenerationalHeap* const _heap;\n+  uint                              _tenuring_threshold;\n+\n+  \/\/ _empty_regions is a thread-local list of heap regions that have been completely emptied by this worker thread's\n+  \/\/ compaction efforts.  The worker thread that drives these efforts adds compacted regions to this list if the\n+  \/\/ region has not been compacted onto itself.\n+  GrowableArray<ShenandoahHeapRegion*>& _empty_regions;\n+  int _empty_regions_pos;\n+  ShenandoahHeapRegion*          _old_to_region;\n+  ShenandoahHeapRegion*          _young_to_region;\n+  ShenandoahHeapRegion*          _from_region;\n+  ShenandoahAffiliation          _from_affiliation;\n+  HeapWord*                      _old_compact_point;\n+  HeapWord*                      _young_compact_point;\n+  uint                           _worker_id;\n+\n+public:\n+  ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n+                                                          GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n+                                                          ShenandoahHeapRegion* from_region, uint worker_id);\n+\n+  void set_from_region(ShenandoahHeapRegion* from_region);\n+  void finish();\n+  void finish_old_region();\n+  void finish_young_region();\n+  bool is_compact_same_region();\n+  int empty_regions_pos() const { return _empty_regions_pos; }\n+\n+  void do_object(oop p) override;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALFULLGC_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,1140 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahInitLogger.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMemoryPool.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n+#include \"gc\/shenandoah\/shenandoahRegulatorThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+\n+class ShenandoahGenerationalInitLogger : public ShenandoahInitLogger {\n+public:\n+  static void print() {\n+    ShenandoahGenerationalInitLogger logger;\n+    logger.print_all();\n+  }\n+\n+  void print_heap() override {\n+    ShenandoahInitLogger::print_heap();\n+\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+\n+    ShenandoahYoungGeneration* young = heap->young_generation();\n+    log_info(gc, init)(\"Young Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(young->soft_max_capacity()));\n+    log_info(gc, init)(\"Young Generation Max: \" EXACTFMT, EXACTFMTARGS(young->max_capacity()));\n+\n+    ShenandoahOldGeneration* old = heap->old_generation();\n+    log_info(gc, init)(\"Old Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(old->soft_max_capacity()));\n+    log_info(gc, init)(\"Old Generation Max: \" EXACTFMT, EXACTFMTARGS(old->max_capacity()));\n+  }\n+\n+protected:\n+  void print_gc_specific() override {\n+    ShenandoahInitLogger::print_gc_specific();\n+\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    log_info(gc, init)(\"Young Heuristics: %s\", heap->young_generation()->heuristics()->name());\n+    log_info(gc, init)(\"Old Heuristics: %s\", heap->old_generation()->heuristics()->name());\n+  }\n+};\n+\n+size_t ShenandoahGenerationalHeap::calculate_min_plab() {\n+  return align_up(PLAB::min_size(), CardTable::card_size_in_words());\n+}\n+\n+size_t ShenandoahGenerationalHeap::calculate_max_plab() {\n+  size_t MaxTLABSizeWords = ShenandoahHeapRegion::max_tlab_size_words();\n+  return align_down(MaxTLABSizeWords, CardTable::card_size_in_words());\n+}\n+\n+\/\/ Returns size in bytes\n+size_t ShenandoahGenerationalHeap::unsafe_max_tlab_alloc(Thread *thread) const {\n+  return MIN2(ShenandoahHeapRegion::max_tlab_size_bytes(), young_generation()->available());\n+}\n+\n+ShenandoahGenerationalHeap::ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy) :\n+  ShenandoahHeap(policy),\n+  _age_census(nullptr),\n+  _evac_tracker(new ShenandoahEvacuationTracker()),\n+  _min_plab_size(calculate_min_plab()),\n+  _max_plab_size(calculate_max_plab()),\n+  _regulator_thread(nullptr),\n+  _young_gen_memory_pool(nullptr),\n+  _old_gen_memory_pool(nullptr) {\n+  assert(is_aligned(_min_plab_size, CardTable::card_size_in_words()), \"min_plab_size must be aligned\");\n+  assert(is_aligned(_max_plab_size, CardTable::card_size_in_words()), \"max_plab_size must be aligned\");\n+}\n+\n+void ShenandoahGenerationalHeap::post_initialize() {\n+  ShenandoahHeap::post_initialize();\n+  _age_census = new ShenandoahAgeCensus();\n+}\n+\n+void ShenandoahGenerationalHeap::print_init_logger() const {\n+  ShenandoahGenerationalInitLogger logger;\n+  logger.print_all();\n+}\n+\n+void ShenandoahGenerationalHeap::print_tracing_info() const {\n+  ShenandoahHeap::print_tracing_info();\n+\n+  LogTarget(Info, gc, stats) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.cr();\n+    ls.cr();\n+    evac_tracker()->print_global_on(&ls);\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::initialize_heuristics() {\n+  \/\/ Initialize global generation and heuristics even in generational mode.\n+  ShenandoahHeap::initialize_heuristics();\n+\n+  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n+  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n+  \/\/ allowed for old and young could exceed the total heap size. It remains the case that the\n+  \/\/ _actual_ capacity of young + old = total.\n+  _generation_sizer.heap_size_changed(max_capacity());\n+  size_t initial_capacity_young = _generation_sizer.max_young_size();\n+  size_t max_capacity_young = _generation_sizer.max_young_size();\n+  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n+  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n+\n+  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young, initial_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old, initial_capacity_old);\n+  _young_generation->initialize_heuristics(mode());\n+  _old_generation->initialize_heuristics(mode());\n+}\n+\n+void ShenandoahGenerationalHeap::initialize_serviceability() {\n+  assert(mode()->is_generational(), \"Only for the generational mode\");\n+  _young_gen_memory_pool = new ShenandoahYoungGenMemoryPool(this);\n+  _old_gen_memory_pool = new ShenandoahOldGenMemoryPool(this);\n+  cycle_memory_manager()->add_pool(_young_gen_memory_pool);\n+  cycle_memory_manager()->add_pool(_old_gen_memory_pool);\n+  stw_memory_manager()->add_pool(_young_gen_memory_pool);\n+  stw_memory_manager()->add_pool(_old_gen_memory_pool);\n+}\n+\n+GrowableArray<MemoryPool*> ShenandoahGenerationalHeap::memory_pools() {\n+  assert(mode()->is_generational(), \"Only for the generational mode\");\n+  GrowableArray<MemoryPool*> memory_pools(2);\n+  memory_pools.append(_young_gen_memory_pool);\n+  memory_pools.append(_old_gen_memory_pool);\n+  return memory_pools;\n+}\n+\n+void ShenandoahGenerationalHeap::initialize_controller() {\n+  auto control_thread = new ShenandoahGenerationalControlThread();\n+  _control_thread = control_thread;\n+  _regulator_thread = new ShenandoahRegulatorThread(control_thread);\n+}\n+\n+void ShenandoahGenerationalHeap::gc_threads_do(ThreadClosure* tcl) const {\n+  if (!shenandoah_policy()->is_at_shutdown()) {\n+    ShenandoahHeap::gc_threads_do(tcl);\n+    tcl->do_thread(regulator_thread());\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::stop() {\n+  regulator_thread()->stop();\n+  ShenandoahHeap::stop();\n+}\n+\n+void ShenandoahGenerationalHeap::evacuate_collection_set(bool concurrent) {\n+  ShenandoahRegionIterator regions;\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, false \/* only promote regions *\/);\n+  workers()->run_task(&task);\n+}\n+\n+void ShenandoahGenerationalHeap::promote_regions_in_place(bool concurrent) {\n+  ShenandoahRegionIterator regions;\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, true \/* only promote regions *\/);\n+  workers()->run_task(&task);\n+}\n+\n+oop ShenandoahGenerationalHeap::evacuate_object(oop p, Thread* thread) {\n+  assert(thread == Thread::current(), \"Expected thread parameter to be current thread.\");\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(thread)) {\n+    \/\/ This thread went through the OOM during evac protocol and it is safe to return\n+    \/\/ the forward pointer. It must not attempt to evacuate anymore.\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  assert(ShenandoahThreadLocalData::is_evac_allowed(thread), \"must be enclosed in oom-evac scope\");\n+\n+  ShenandoahHeapRegion* r = heap_region_containing(p);\n+  assert(!r->is_humongous(), \"never evacuate humongous objects\");\n+\n+  ShenandoahAffiliation target_gen = r->affiliation();\n+  \/\/ gc_generation() can change asynchronously and should not be used here.\n+  assert(active_generation() != nullptr, \"Error\");\n+  if (active_generation()->is_young() && target_gen == YOUNG_GENERATION) {\n+    markWord mark = p->mark();\n+    if (mark.is_marked()) {\n+      \/\/ Already forwarded.\n+      return ShenandoahBarrierSet::resolve_forwarded(p);\n+    }\n+\n+    if (mark.has_displaced_mark_helper()) {\n+      \/\/ We don't want to deal with MT here just to ensure we read the right mark word.\n+      \/\/ Skip the potential promotion attempt for this one.\n+    } else if (r->age() + mark.age() >= age_census()->tenuring_threshold()) {\n+      oop result = try_evacuate_object(p, thread, r, OLD_GENERATION);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+      \/\/ If we failed to promote this aged object, we'll fall through to code below and evacuate to young-gen.\n+    }\n+  }\n+  return try_evacuate_object(p, thread, r, target_gen);\n+}\n+\n+\/\/ try_evacuate_object registers the object and dirties the associated remembered set information when evacuating\n+\/\/ to OLD_GENERATION.\n+oop ShenandoahGenerationalHeap::try_evacuate_object(oop p, Thread* thread, ShenandoahHeapRegion* from_region,\n+                                        ShenandoahAffiliation target_gen) {\n+  bool alloc_from_lab = true;\n+  bool has_plab = false;\n+  HeapWord* copy = nullptr;\n+  size_t size = ShenandoahForwarding::size(p);\n+  bool is_promotion = (target_gen == OLD_GENERATION) && from_region->is_young();\n+\n+#ifdef ASSERT\n+  if (ShenandoahOOMDuringEvacALot &&\n+      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n+    copy = nullptr;\n+  } else {\n+#endif\n+    if (UseTLAB) {\n+      switch (target_gen) {\n+        case YOUNG_GENERATION: {\n+          copy = allocate_from_gclab(thread, size);\n+          if ((copy == nullptr) && (size < ShenandoahThreadLocalData::gclab_size(thread))) {\n+            \/\/ GCLAB allocation failed because we are bumping up against the limit on young evacuation reserve.  Try resetting\n+            \/\/ the desired GCLAB size and retry GCLAB allocation to avoid cascading of shared memory allocations.\n+            ShenandoahThreadLocalData::set_gclab_size(thread, PLAB::min_size());\n+            copy = allocate_from_gclab(thread, size);\n+            \/\/ If we still get nullptr, we'll try a shared allocation below.\n+          }\n+          break;\n+        }\n+        case OLD_GENERATION: {\n+          PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+          if (plab != nullptr) {\n+            has_plab = true;\n+            copy = allocate_from_plab(thread, size, is_promotion);\n+            if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n+                ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n+              \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n+              \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n+              \/\/ where abundance is defined as >= ShenGenHeap::plab_min_size().  In the former case, we try shrinking the\n+              \/\/ desired PLAB size to the minimum and retry PLAB allocation to avoid cascading of shared memory allocations.\n+              if (plab->words_remaining() < plab_min_size()) {\n+                ShenandoahThreadLocalData::set_plab_size(thread, plab_min_size());\n+                copy = allocate_from_plab(thread, size, is_promotion);\n+                \/\/ If we still get nullptr, we'll try a shared allocation below.\n+                if (copy == nullptr) {\n+                  \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n+                  ShenandoahThreadLocalData::disable_plab_retries(thread);\n+                }\n+              }\n+              \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n+            }\n+          }\n+          break;\n+        }\n+        default: {\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (copy == nullptr) {\n+      \/\/ If we failed to allocate in LAB, we'll try a shared allocation.\n+      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n+        ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size, target_gen, is_promotion);\n+        copy = allocate_memory(req);\n+        alloc_from_lab = false;\n+      }\n+      \/\/ else, we leave copy equal to nullptr, signaling a promotion failure below if appropriate.\n+      \/\/ We choose not to promote objects smaller than PLAB::min_size() by way of shared allocations, as this is too\n+      \/\/ costly.  Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB) and will promote in a future\n+      \/\/ evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size <= PLAB::min_size())\n+    }\n+#ifdef ASSERT\n+  }\n+#endif\n+\n+  if (copy == nullptr) {\n+    if (target_gen == OLD_GENERATION) {\n+      if (from_region->is_young()) {\n+        \/\/ Signal that promotion failed. Will evacuate this old object somewhere in young gen.\n+        old_generation()->handle_failed_promotion(thread, size);\n+        return nullptr;\n+      } else {\n+        \/\/ Remember that evacuation to old gen failed. We'll want to trigger a full gc to recover from this\n+        \/\/ after the evacuation threads have finished.\n+        old_generation()->handle_failed_evacuation();\n+      }\n+    }\n+\n+    control_thread()->handle_alloc_failure_evac(size);\n+\n+    oom_evac_handler()->handle_out_of_memory_during_evacuation();\n+\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  \/\/ Copy the object:\n+  NOT_PRODUCT(evac_tracker()->begin_evacuation(thread, size * HeapWordSize));\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n+  oop copy_val = cast_to_oop(copy);\n+\n+  \/\/ Update the age of the evacuated object\n+  if (target_gen == YOUNG_GENERATION && is_aging_cycle()) {\n+    ShenandoahHeap::increase_object_age(copy_val, from_region->age() + 1);\n+  }\n+\n+  \/\/ Try to install the new forwarding pointer.\n+  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n+  if (result == copy_val) {\n+    \/\/ Successfully evacuated. Our copy is now the public one!\n+\n+    \/\/ This is necessary for virtual thread support. This uses the mark word without\n+    \/\/ considering that it may now be a forwarding pointer (and could therefore crash).\n+    \/\/ Secondarily, we do not want to spend cycles relativizing stack chunks for oops\n+    \/\/ that lost the evacuation race (and will therefore not become visible). It is\n+    \/\/ safe to do this on the public copy (this is also done during concurrent mark).\n+    ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+\n+    \/\/ Record that the evacuation succeeded\n+    NOT_PRODUCT(evac_tracker()->end_evacuation(thread, size * HeapWordSize));\n+\n+    if (target_gen == OLD_GENERATION) {\n+      old_generation()->handle_evacuation(copy, size, from_region->is_young());\n+    } else {\n+      \/\/ When copying to the old generation above, we don't care\n+      \/\/ about recording object age in the census stats.\n+      assert(target_gen == YOUNG_GENERATION, \"Error\");\n+      \/\/ We record this census only when simulating pre-adaptive tenuring behavior, or\n+      \/\/ when we have been asked to record the census at evacuation rather than at mark\n+      if (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n+        evac_tracker()->record_age(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n+      }\n+    }\n+    shenandoah_assert_correct(nullptr, copy_val);\n+    return copy_val;\n+  }  else {\n+    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n+    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n+    \/\/ But if it happens to contain references to evacuated regions, those references would\n+    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n+    \/\/ it the next cycle.\n+    if (alloc_from_lab) {\n+      \/\/ For LAB allocations, it is enough to rollback the allocation ptr. Either the next\n+      \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n+      \/\/ do this.\n+      switch (target_gen) {\n+        case YOUNG_GENERATION: {\n+          ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n+          break;\n+        }\n+        case OLD_GENERATION: {\n+          ShenandoahThreadLocalData::plab(thread)->undo_allocation(copy, size);\n+          if (is_promotion) {\n+            ShenandoahThreadLocalData::subtract_from_plab_promoted(thread, size * HeapWordSize);\n+          }\n+          break;\n+        }\n+        default: {\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      }\n+    } else {\n+      \/\/ For non-LAB allocations, we have no way to retract the allocation, and\n+      \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n+      \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n+      assert(size >= ShenandoahHeap::min_fill_size(), \"previously allocated object known to be larger than min_size\");\n+      fill_with_object(copy, size);\n+      shenandoah_assert_correct(nullptr, copy_val);\n+      \/\/ For non-LAB allocations, the object has already been registered\n+    }\n+    shenandoah_assert_correct(nullptr, result);\n+    return result;\n+  }\n+}\n+\n+inline HeapWord* ShenandoahGenerationalHeap::allocate_from_plab(Thread* thread, size_t size, bool is_promotion) {\n+  assert(UseTLAB, \"TLABs should be enabled\");\n+\n+  PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+  HeapWord* obj;\n+\n+  if (plab == nullptr) {\n+    assert(!thread->is_Java_thread() && !thread->is_Worker_thread(), \"Performance: thread should have PLAB: %s\", thread->name());\n+    \/\/ No PLABs in this thread, fallback to shared allocation\n+    return nullptr;\n+  } else if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    return nullptr;\n+  }\n+  \/\/ if plab->word_size() <= 0, thread's plab not yet initialized for this pass, so allow_plab_promotions() is not trustworthy\n+  obj = plab->allocate(size);\n+  if ((obj == nullptr) && (plab->words_remaining() < plab_min_size())) {\n+    \/\/ allocate_from_plab_slow will establish allow_plab_promotions(thread) for future invocations\n+    obj = allocate_from_plab_slow(thread, size, is_promotion);\n+  }\n+  \/\/ if plab->words_remaining() >= ShenGenHeap::heap()->plab_min_size(), just return nullptr so we can use a shared allocation\n+  if (obj == nullptr) {\n+    return nullptr;\n+  }\n+\n+  if (is_promotion) {\n+    ShenandoahThreadLocalData::add_to_plab_promoted(thread, size * HeapWordSize);\n+  }\n+  return obj;\n+}\n+\n+\/\/ Establish a new PLAB and allocate size HeapWords within it.\n+HeapWord* ShenandoahGenerationalHeap::allocate_from_plab_slow(Thread* thread, size_t size, bool is_promotion) {\n+  \/\/ New object should fit the PLAB size\n+\n+  assert(mode()->is_generational(), \"PLABs only relevant to generational GC\");\n+  const size_t plab_min_size = this->plab_min_size();\n+  \/\/ PLABs are aligned to card boundaries to avoid synchronization with concurrent\n+  \/\/ allocations in other PLABs.\n+  const size_t min_size = (size > plab_min_size)? align_up(size, CardTable::card_size_in_words()): plab_min_size;\n+\n+  \/\/ Figure out size of new PLAB, using value determined at last refill.\n+  size_t cur_size = ShenandoahThreadLocalData::plab_size(thread);\n+  if (cur_size == 0) {\n+    cur_size = plab_min_size;\n+  }\n+\n+  \/\/ Expand aggressively, doubling at each refill in this epoch, ceiling at plab_max_size()\n+  size_t future_size = MIN2(cur_size * 2, plab_max_size());\n+  \/\/ Doubling, starting at a card-multiple, should give us a card-multiple. (Ceiling and floor\n+  \/\/ are card multiples.)\n+  assert(is_aligned(future_size, CardTable::card_size_in_words()), \"Card multiple by construction, future_size: \" SIZE_FORMAT\n+          \", card_size: \" SIZE_FORMAT \", cur_size: \" SIZE_FORMAT \", max: \" SIZE_FORMAT,\n+         future_size, (size_t) CardTable::card_size_in_words(), cur_size, plab_max_size());\n+\n+  \/\/ Record new heuristic value even if we take any shortcut. This captures\n+  \/\/ the case when moderately-sized objects always take a shortcut. At some point,\n+  \/\/ heuristics should catch up with them.  Note that the requested cur_size may\n+  \/\/ not be honored, but we remember that this is the preferred size.\n+  log_debug(gc, free)(\"Set new PLAB size: \" SIZE_FORMAT, future_size);\n+  ShenandoahThreadLocalData::set_plab_size(thread, future_size);\n+  if (cur_size < size) {\n+    \/\/ The PLAB to be allocated is still not large enough to hold the object. Fall back to shared allocation.\n+    \/\/ This avoids retiring perfectly good PLABs in order to represent a single large object allocation.\n+    log_debug(gc, free)(\"Current PLAB size (\" SIZE_FORMAT \") is too small for \" SIZE_FORMAT, cur_size, size);\n+    return nullptr;\n+  }\n+\n+  \/\/ Retire current PLAB, and allocate a new one.\n+  PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+  if (plab->words_remaining() < plab_min_size) {\n+    \/\/ Retire current PLAB. This takes care of any PLAB book-keeping.\n+    \/\/ retire_plab() registers the remnant filler object with the remembered set scanner without a lock.\n+    \/\/ Since PLABs are card-aligned, concurrent registrations in other PLABs don't interfere.\n+    retire_plab(plab, thread);\n+\n+    size_t actual_size = 0;\n+    HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n+    if (plab_buf == nullptr) {\n+      if (min_size == plab_min_size) {\n+        \/\/ Disable PLAB promotions for this thread because we cannot even allocate a minimal PLAB. This allows us\n+        \/\/ to fail faster on subsequent promotion attempts.\n+        ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+      }\n+      return nullptr;\n+    } else {\n+      ShenandoahThreadLocalData::enable_plab_retries(thread);\n+    }\n+    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n+    if (ZeroTLAB) {\n+      \/\/ ... and clear it.\n+      Copy::zero_to_words(plab_buf, actual_size);\n+    } else {\n+      \/\/ ...and zap just allocated object.\n+#ifdef ASSERT\n+      \/\/ Skip mangling the space corresponding to the object header to\n+      \/\/ ensure that the returned space is not considered parsable by\n+      \/\/ any concurrent GC thread.\n+      size_t hdr_size = oopDesc::header_size();\n+      Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n+#endif \/\/ ASSERT\n+    }\n+    assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n+    plab->set_buf(plab_buf, actual_size);\n+    if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+      return nullptr;\n+    }\n+    return plab->allocate(size);\n+  } else {\n+    \/\/ If there's still at least min_size() words available within the current plab, don't retire it.  Let's nibble\n+    \/\/ away on this plab as long as we can.  Meanwhile, return nullptr to force this particular allocation request\n+    \/\/ to be satisfied with a shared allocation.  By packing more promotions into the previously allocated PLAB, we\n+    \/\/ reduce the likelihood of evacuation failures, and we reduce the need for downsizing our PLABs.\n+    return nullptr;\n+  }\n+}\n+\n+HeapWord* ShenandoahGenerationalHeap::allocate_new_plab(size_t min_size, size_t word_size, size_t* actual_size) {\n+  \/\/ Align requested sizes to card-sized multiples.  Align down so that we don't violate max size of TLAB.\n+  assert(is_aligned(min_size, CardTable::card_size_in_words()), \"Align by design\");\n+  assert(word_size >= min_size, \"Requested PLAB is too small\");\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_plab(min_size, word_size);\n+  \/\/ Note that allocate_memory() sets a thread-local flag to prohibit further promotions by this thread\n+  \/\/ if we are at risk of infringing on the old-gen evacuation budget.\n+  HeapWord* res = allocate_memory(req);\n+  if (res != nullptr) {\n+    *actual_size = req.actual_size();\n+  } else {\n+    *actual_size = 0;\n+  }\n+  assert(is_aligned(res, CardTable::card_size_in_words()), \"Align by design\");\n+  return res;\n+}\n+\n+void ShenandoahGenerationalHeap::retire_plab(PLAB* plab, Thread* thread) {\n+  \/\/ We don't enforce limits on plab evacuations.  We let it consume all available old-gen memory in order to reduce\n+  \/\/ probability of an evacuation failure.  We do enforce limits on promotion, to make sure that excessive promotion\n+  \/\/ does not result in an old-gen evacuation failure.  Note that a failed promotion is relatively harmless.  Any\n+  \/\/ object that fails to promote in the current cycle will be eligible for promotion in a subsequent cycle.\n+\n+  \/\/ When the plab was instantiated, its entirety was treated as if the entire buffer was going to be dedicated to\n+  \/\/ promotions.  Now that we are retiring the buffer, we adjust for the reality that the plab is not entirely promotions.\n+  \/\/  1. Some of the plab may have been dedicated to evacuations.\n+  \/\/  2. Some of the plab may have been abandoned due to waste (at the end of the plab).\n+  size_t not_promoted =\n+          ShenandoahThreadLocalData::get_plab_actual_size(thread) - ShenandoahThreadLocalData::get_plab_promoted(thread);\n+  ShenandoahThreadLocalData::reset_plab_promoted(thread);\n+  ShenandoahThreadLocalData::set_plab_actual_size(thread, 0);\n+  if (not_promoted > 0) {\n+    old_generation()->unexpend_promoted(not_promoted);\n+  }\n+  const size_t original_waste = plab->waste();\n+  HeapWord* const top = plab->top();\n+\n+  \/\/ plab->retire() overwrites unused memory between plab->top() and plab->hard_end() with a dummy object to make memory parsable.\n+  \/\/ It adds the size of this unused memory, in words, to plab->waste().\n+  plab->retire();\n+  if (top != nullptr && plab->waste() > original_waste && is_in_old(top)) {\n+    \/\/ If retiring the plab created a filler object, then we need to register it with our card scanner so it can\n+    \/\/ safely walk the region backing the plab.\n+    log_debug(gc)(\"retire_plab() is registering remnant of size \" SIZE_FORMAT \" at \" PTR_FORMAT,\n+                  plab->waste() - original_waste, p2i(top));\n+    \/\/ No lock is necessary because the PLAB memory is aligned on card boundaries.\n+    old_generation()->card_scan()->register_object_without_lock(top);\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::retire_plab(PLAB* plab) {\n+  Thread* thread = Thread::current();\n+  retire_plab(plab, thread);\n+}\n+\n+ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalHeap::balance_generations() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+\n+  ShenandoahOldGeneration* old_gen = old_generation();\n+  const ssize_t old_region_balance = old_gen->get_region_balance();\n+  old_gen->set_region_balance(0);\n+\n+  if (old_region_balance > 0) {\n+    const auto old_region_surplus = checked_cast<size_t>(old_region_balance);\n+    const bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n+    return TransferResult {\n+      success, old_region_surplus, \"young\"\n+    };\n+  }\n+\n+  if (old_region_balance < 0) {\n+    const auto old_region_deficit = checked_cast<size_t>(-old_region_balance);\n+    const bool success = generation_sizer()->transfer_to_old(old_region_deficit);\n+    if (!success) {\n+      old_gen->handle_failed_transfer();\n+    }\n+    return TransferResult {\n+      success, old_region_deficit, \"old\"\n+    };\n+  }\n+\n+  return TransferResult {true, 0, \"none\"};\n+}\n+\n+\/\/ Make sure old-generation is large enough, but no larger than is necessary, to hold mixed evacuations\n+\/\/ and promotions, if we anticipate either. Any deficit is provided by the young generation, subject to\n+\/\/ xfer_limit, and any surplus is transferred to the young generation.\n+\/\/ xfer_limit is the maximum we're able to transfer from young to old.\n+void ShenandoahGenerationalHeap::compute_old_generation_balance(size_t old_xfer_limit, size_t old_cset_regions) {\n+\n+  \/\/ We can limit the old reserve to the size of anticipated promotions:\n+  \/\/ max_old_reserve is an upper bound on memory evacuated from old and promoted to old,\n+  \/\/ clamped by the old generation space available.\n+  \/\/\n+  \/\/ Here's the algebra.\n+  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+  \/\/     OE = old evac,\n+  \/\/     YE = young evac, and\n+  \/\/     TE = total evac = OE + YE\n+  \/\/ By definition:\n+  \/\/            SOEP\/100 = OE\/TE\n+  \/\/                     = OE\/(OE+YE)\n+  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)      \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n+  \/\/                     = OE\/YE\n+  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n+\n+  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n+  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  const size_t old_available = old_generation()->available();\n+  \/\/ The free set will reserve this amount of memory to hold young evacuations\n+  const size_t young_reserve = (young_generation()->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+\n+  \/\/ In the case that ShenandoahOldEvacRatioPercent equals 100, max_old_reserve is limited only by xfer_limit.\n+\n+  const double bound_on_old_reserve = old_available + old_xfer_limit + young_reserve;\n+  const double max_old_reserve = (ShenandoahOldEvacRatioPercent == 100)?\n+                                 bound_on_old_reserve: MIN2(double(young_reserve * ShenandoahOldEvacRatioPercent) \/ double(100 - ShenandoahOldEvacRatioPercent),\n+                                                            bound_on_old_reserve);\n+\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  \/\/ Decide how much old space we should reserve for a mixed collection\n+  double reserve_for_mixed = 0;\n+  if (old_generation()->has_unprocessed_collection_candidates()) {\n+    \/\/ We want this much memory to be unfragmented in order to reliably evacuate old.  This is conservative because we\n+    \/\/ may not evacuate the entirety of unprocessed candidates in a single mixed evacuation.\n+    const double max_evac_need = (double(old_generation()->unprocessed_collection_candidates_live_memory()) * ShenandoahOldEvacWaste);\n+    assert(old_available >= old_generation()->free_unaffiliated_regions() * region_size_bytes,\n+           \"Unaffiliated available must be less than total available\");\n+    const double old_fragmented_available = double(old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes);\n+    reserve_for_mixed = max_evac_need + old_fragmented_available;\n+    if (reserve_for_mixed > max_old_reserve) {\n+      reserve_for_mixed = max_old_reserve;\n+    }\n+  }\n+\n+  \/\/ Decide how much space we should reserve for promotions from young\n+  size_t reserve_for_promo = 0;\n+  const size_t promo_load = old_generation()->get_promotion_potential();\n+  const bool doing_promotions = promo_load > 0;\n+  if (doing_promotions) {\n+    \/\/ We're promoting and have a bound on the maximum amount that can be promoted\n+    assert(max_old_reserve >= reserve_for_mixed, \"Sanity\");\n+    const size_t available_for_promotions = max_old_reserve - reserve_for_mixed;\n+    reserve_for_promo = MIN2((size_t)(promo_load * ShenandoahPromoEvacWaste), available_for_promotions);\n+  }\n+\n+  \/\/ This is the total old we want to ideally reserve\n+  const size_t old_reserve = reserve_for_mixed + reserve_for_promo;\n+  assert(old_reserve <= max_old_reserve, \"cannot reserve more than max for old evacuations\");\n+\n+  \/\/ We now check if the old generation is running a surplus or a deficit.\n+  const size_t max_old_available = old_generation()->available() + old_cset_regions * region_size_bytes;\n+  if (max_old_available >= old_reserve) {\n+    \/\/ We are running a surplus, so the old region surplus can go to young\n+    const size_t old_surplus = (max_old_available - old_reserve) \/ region_size_bytes;\n+    const size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_cset_regions;\n+    const size_t old_region_surplus = MIN2(old_surplus, unaffiliated_old_regions);\n+    old_generation()->set_region_balance(checked_cast<ssize_t>(old_region_surplus));\n+  } else {\n+    \/\/ We are running a deficit which we'd like to fill from young.\n+    \/\/ Ignore that this will directly impact young_generation()->max_capacity(),\n+    \/\/ indirectly impacting young_reserve and old_reserve.  These computations are conservative.\n+    \/\/ Note that deficit is rounded up by one region.\n+    const size_t old_need = (old_reserve - max_old_available + region_size_bytes - 1) \/ region_size_bytes;\n+    const size_t max_old_region_xfer = old_xfer_limit \/ region_size_bytes;\n+\n+    \/\/ Round down the regions we can transfer from young to old. If we're running short\n+    \/\/ on young-gen memory, we restrict the xfer. Old-gen collection activities will be\n+    \/\/ curtailed if the budget is restricted.\n+    const size_t old_region_deficit = MIN2(old_need, max_old_region_xfer);\n+    old_generation()->set_region_balance(0 - checked_cast<ssize_t>(old_region_deficit));\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::reset_generation_reserves() {\n+  young_generation()->set_evacuation_reserve(0);\n+  old_generation()->set_evacuation_reserve(0);\n+  old_generation()->set_promoted_reserve(0);\n+}\n+\n+void ShenandoahGenerationalHeap::TransferResult::print_on(const char* when, outputStream* ss) const {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahYoungGeneration* const young_gen = heap->young_generation();\n+  ShenandoahOldGeneration* const old_gen = heap->old_generation();\n+  const size_t young_available = young_gen->available();\n+  const size_t old_available = old_gen->available();\n+  ss->print_cr(\"After %s, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n+                     PROPERFMT \", young_available: \" PROPERFMT,\n+                     when,\n+                     success? \"successfully transferred\": \"failed to transfer\", region_count, region_destination,\n+                     PROPERFMTARGS(old_available), PROPERFMTARGS(young_available));\n+}\n+\n+void ShenandoahGenerationalHeap::coalesce_and_fill_old_regions(bool concurrent) {\n+  class ShenandoahGlobalCoalesceAndFill : public WorkerTask {\n+  private:\n+      ShenandoahPhaseTimings::Phase _phase;\n+      ShenandoahRegionIterator _regions;\n+  public:\n+    explicit ShenandoahGlobalCoalesceAndFill(ShenandoahPhaseTimings::Phase phase) :\n+      WorkerTask(\"Shenandoah Global Coalesce\"),\n+      _phase(phase) {}\n+\n+    void work(uint worker_id) override {\n+      ShenandoahWorkerTimingsTracker timer(_phase,\n+                                           ShenandoahPhaseTimings::ScanClusters,\n+                                           worker_id, true);\n+      ShenandoahHeapRegion* region;\n+      while ((region = _regions.next()) != nullptr) {\n+        \/\/ old region is not in the collection set and was not immediately trashed\n+        if (region->is_old() && region->is_active() && !region->is_humongous()) {\n+          \/\/ Reset the coalesce and fill boundary because this is a global collect\n+          \/\/ and cannot be preempted by young collects. We want to be sure the entire\n+          \/\/ region is coalesced here and does not resume from a previously interrupted\n+          \/\/ or completed coalescing.\n+          region->begin_preemptible_coalesce_and_fill();\n+          region->oop_coalesce_and_fill(false);\n+        }\n+      }\n+    }\n+  };\n+\n+  ShenandoahPhaseTimings::Phase phase = concurrent ?\n+          ShenandoahPhaseTimings::conc_coalesce_and_fill :\n+          ShenandoahPhaseTimings::degen_gc_coalesce_and_fill;\n+\n+  \/\/ This is not cancellable\n+  ShenandoahGlobalCoalesceAndFill coalesce(phase);\n+  workers()->run_task(&coalesce);\n+  old_generation()->set_parsable(true);\n+}\n+\n+template<bool CONCURRENT>\n+class ShenandoahGenerationalUpdateHeapRefsTask : public WorkerTask {\n+private:\n+  ShenandoahGenerationalHeap* _heap;\n+  ShenandoahRegionIterator* _regions;\n+  ShenandoahRegionChunkIterator* _work_chunks;\n+\n+public:\n+  explicit ShenandoahGenerationalUpdateHeapRefsTask(ShenandoahRegionIterator* regions,\n+                                                    ShenandoahRegionChunkIterator* work_chunks) :\n+          WorkerTask(\"Shenandoah Update References\"),\n+          _heap(ShenandoahGenerationalHeap::heap()),\n+          _regions(regions),\n+          _work_chunks(work_chunks)\n+  {\n+    bool old_bitmap_stable = _heap->old_generation()->is_mark_complete();\n+    log_debug(gc, remset)(\"Update refs, scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n+  }\n+\n+  void work(uint worker_id) {\n+    if (CONCURRENT) {\n+      ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+      ShenandoahSuspendibleThreadSetJoiner stsj;\n+      do_work<ShenandoahConcUpdateRefsClosure>(worker_id);\n+    } else {\n+      ShenandoahParallelWorkerSession worker_session(worker_id);\n+      do_work<ShenandoahNonConcUpdateRefsClosure>(worker_id);\n+    }\n+  }\n+\n+private:\n+  template<class T>\n+  void do_work(uint worker_id) {\n+    T cl;\n+\n+    if (CONCURRENT && (worker_id == 0)) {\n+      \/\/ We ask the first worker to replenish the Mutator free set by moving regions previously reserved to hold the\n+      \/\/ results of evacuation.  These reserves are no longer necessary because evacuation has completed.\n+      size_t cset_regions = _heap->collection_set()->count();\n+\n+      \/\/ Now that evacuation is done, we can reassign any regions that had been reserved to hold the results of evacuation\n+      \/\/ to the mutator free set.  At the end of GC, we will have cset_regions newly evacuated fully empty regions from\n+      \/\/ which we will be able to replenish the Collector free set and the OldCollector free set in preparation for the\n+      \/\/ next GC cycle.\n+      _heap->free_set()->move_regions_from_collector_to_mutator(cset_regions);\n+    }\n+    \/\/ If !CONCURRENT, there's no value in expanding Mutator free set\n+\n+    ShenandoahHeapRegion* r = _regions->next();\n+    \/\/ We update references for global, old, and young collections.\n+    ShenandoahGeneration* const gc_generation = _heap->gc_generation();\n+    shenandoah_assert_generations_reconciled();\n+    assert(gc_generation->is_mark_complete(), \"Expected complete marking\");\n+    ShenandoahMarkingContext* const ctx = _heap->marking_context();\n+    bool is_mixed = _heap->collection_set()->has_old_regions();\n+    while (r != nullptr) {\n+      HeapWord* update_watermark = r->get_update_watermark();\n+      assert(update_watermark >= r->bottom(), \"sanity\");\n+\n+      log_debug(gc)(\"Update refs worker \" UINT32_FORMAT \", looking at region \" SIZE_FORMAT, worker_id, r->index());\n+      bool region_progress = false;\n+      if (r->is_active() && !r->is_cset()) {\n+        if (r->is_young()) {\n+          _heap->marked_object_oop_iterate(r, &cl, update_watermark);\n+          region_progress = true;\n+        } else if (r->is_old()) {\n+          if (gc_generation->is_global()) {\n+\n+            _heap->marked_object_oop_iterate(r, &cl, update_watermark);\n+            region_progress = true;\n+          }\n+          \/\/ Otherwise, this is an old region in a young or mixed cycle.  Process it during a second phase, below.\n+          \/\/ Don't bother to report pacing progress in this case.\n+        } else {\n+          \/\/ Because updating of references runs concurrently, it is possible that a FREE inactive region transitions\n+          \/\/ to a non-free active region while this loop is executing.  Whenever this happens, the changing of a region's\n+          \/\/ active status may propagate at a different speed than the changing of the region's affiliation.\n+\n+          \/\/ When we reach this control point, it is because a race has allowed a region's is_active() status to be seen\n+          \/\/ by this thread before the region's affiliation() is seen by this thread.\n+\n+          \/\/ It's ok for this race to occur because the newly transformed region does not have any references to be\n+          \/\/ updated.\n+\n+          assert(r->get_update_watermark() == r->bottom(),\n+                 \"%s Region \" SIZE_FORMAT \" is_active but not recognized as YOUNG or OLD so must be newly transitioned from FREE\",\n+                 r->affiliation_name(), r->index());\n+        }\n+      }\n+\n+      if (region_progress && ShenandoahPacing) {\n+        _heap->pacer()->report_updaterefs(pointer_delta(update_watermark, r->bottom()));\n+      }\n+\n+      if (_heap->check_cancelled_gc_and_yield(CONCURRENT)) {\n+        return;\n+      }\n+\n+      r = _regions->next();\n+    }\n+\n+    if (!gc_generation->is_global()) {\n+      \/\/ Since this is generational and not GLOBAL, we have to process the remembered set.  There's no remembered\n+      \/\/ set processing if not in generational mode or if GLOBAL mode.\n+\n+      \/\/ After this thread has exhausted its traditional update-refs work, it continues with updating refs within\n+      \/\/ remembered set. The remembered set workload is better balanced between threads, so threads that are \"behind\"\n+      \/\/ can catch up with other threads during this phase, allowing all threads to work more effectively in parallel.\n+      update_references_in_remembered_set(worker_id, cl, ctx, is_mixed);\n+    }\n+  }\n+\n+  template<class T>\n+  void update_references_in_remembered_set(uint worker_id, T &cl, const ShenandoahMarkingContext* ctx, bool is_mixed) {\n+\n+    struct ShenandoahRegionChunk assignment;\n+    ShenandoahScanRemembered* scanner = _heap->old_generation()->card_scan();\n+\n+    while (!_heap->check_cancelled_gc_and_yield(CONCURRENT) && _work_chunks->next(&assignment)) {\n+      \/\/ Keep grabbing next work chunk to process until finished, or asked to yield\n+      ShenandoahHeapRegion* r = assignment._r;\n+      if (r->is_active() && !r->is_cset() && r->is_old()) {\n+        HeapWord* start_of_range = r->bottom() + assignment._chunk_offset;\n+        HeapWord* end_of_range = r->get_update_watermark();\n+        if (end_of_range > start_of_range + assignment._chunk_size) {\n+          end_of_range = start_of_range + assignment._chunk_size;\n+        }\n+\n+        if (start_of_range >= end_of_range) {\n+          continue;\n+        }\n+\n+        \/\/ Old region in a young cycle or mixed cycle.\n+        if (is_mixed) {\n+          if (r->is_humongous()) {\n+            \/\/ Need to examine both dirty and clean cards during mixed evac.\n+            r->oop_iterate_humongous_slice_all(&cl,start_of_range, assignment._chunk_size);\n+          } else {\n+            \/\/ Since this is mixed evacuation, old regions that are candidates for collection have not been coalesced\n+            \/\/ and filled.  This will use mark bits to find objects that need to be updated.\n+            update_references_in_old_region(cl, ctx, scanner, r, start_of_range, end_of_range);\n+          }\n+        } else {\n+          \/\/ This is a young evacuation\n+          size_t cluster_size = CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n+          size_t clusters = assignment._chunk_size \/ cluster_size;\n+          assert(clusters * cluster_size == assignment._chunk_size, \"Chunk assignment must align on cluster boundaries\");\n+          scanner->process_region_slice(r, assignment._chunk_offset, clusters, end_of_range, &cl, true, worker_id);\n+        }\n+\n+        if (ShenandoahPacing) {\n+          _heap->pacer()->report_updaterefs(pointer_delta(end_of_range, start_of_range));\n+        }\n+      }\n+    }\n+  }\n+\n+  template<class T>\n+  void update_references_in_old_region(T &cl, const ShenandoahMarkingContext* ctx, ShenandoahScanRemembered* scanner,\n+                                    const ShenandoahHeapRegion* r, HeapWord* start_of_range,\n+                                    HeapWord* end_of_range) const {\n+    \/\/ In case last object in my range spans boundary of my chunk, I may need to scan all the way to top()\n+    ShenandoahObjectToOopBoundedClosure<T> objs(&cl, start_of_range, r->top());\n+\n+    \/\/ Any object that begins in a previous range is part of a different scanning assignment.  Any object that\n+    \/\/ starts after end_of_range is also not my responsibility.  (Either allocated during evacuation, so does\n+    \/\/ not hold pointers to from-space, or is beyond the range of my assigned work chunk.)\n+\n+    \/\/ Find the first object that begins in my range, if there is one. Note that `p` will be set to `end_of_range`\n+    \/\/ when no live object is found in the range.\n+    HeapWord* tams = ctx->top_at_mark_start(r);\n+    HeapWord* p = get_first_object_start_word(ctx, scanner, tams, start_of_range, end_of_range);\n+\n+    while (p < end_of_range) {\n+      \/\/ p is known to point to the beginning of marked object obj\n+      oop obj = cast_to_oop(p);\n+      objs.do_object(obj);\n+      HeapWord* prev_p = p;\n+      p += obj->size();\n+      if (p < tams) {\n+        p = ctx->get_next_marked_addr(p, tams);\n+        \/\/ If there are no more marked objects before tams, this returns tams.  Note that tams is\n+        \/\/ either >= end_of_range, or tams is the start of an object that is marked.\n+      }\n+      assert(p != prev_p, \"Lack of forward progress\");\n+    }\n+  }\n+\n+  HeapWord* get_first_object_start_word(const ShenandoahMarkingContext* ctx, ShenandoahScanRemembered* scanner, HeapWord* tams,\n+                                        HeapWord* start_of_range, HeapWord* end_of_range) const {\n+    HeapWord* p = start_of_range;\n+\n+    if (p >= tams) {\n+      \/\/ We cannot use ctx->is_marked(obj) to test whether an object begins at this address.  Instead,\n+      \/\/ we need to use the remembered set crossing map to advance p to the first object that starts\n+      \/\/ within the enclosing card.\n+      size_t card_index = scanner->card_index_for_addr(start_of_range);\n+      while (true) {\n+        HeapWord* first_object = scanner->first_object_in_card(card_index);\n+        if (first_object != nullptr) {\n+          p = first_object;\n+          break;\n+        } else if (scanner->addr_for_card_index(card_index + 1) < end_of_range) {\n+          card_index++;\n+        } else {\n+          \/\/ Signal that no object was found in range\n+          p = end_of_range;\n+          break;\n+        }\n+      }\n+    } else if (!ctx->is_marked(cast_to_oop(p))) {\n+      p = ctx->get_next_marked_addr(p, tams);\n+      \/\/ If there are no more marked objects before tams, this returns tams.\n+      \/\/ Note that tams is either >= end_of_range, or tams is the start of an object that is marked.\n+    }\n+    return p;\n+  }\n+};\n+\n+void ShenandoahGenerationalHeap::update_heap_references(bool concurrent) {\n+  assert(!is_full_gc_in_progress(), \"Only for concurrent and degenerated GC\");\n+  const uint nworkers = workers()->active_workers();\n+  ShenandoahRegionChunkIterator work_list(nworkers);\n+  if (concurrent) {\n+    ShenandoahGenerationalUpdateHeapRefsTask<true> task(&_update_refs_iterator, &work_list);\n+    workers()->run_task(&task);\n+  } else {\n+    ShenandoahGenerationalUpdateHeapRefsTask<false> task(&_update_refs_iterator, &work_list);\n+    workers()->run_task(&task);\n+  }\n+\n+  if (ShenandoahEnableCardStats) {\n+    \/\/ Only do this if we are collecting card stats\n+    ShenandoahScanRemembered* card_scan = old_generation()->card_scan();\n+    assert(card_scan != nullptr, \"Card table must exist when card stats are enabled\");\n+    card_scan->log_card_stats(nworkers, CARD_STAT_UPDATE_REFS);\n+  }\n+}\n+\n+struct ShenandoahCompositeRegionClosure {\n+  template<typename C1, typename C2>\n+  class Closure : public ShenandoahHeapRegionClosure {\n+  private:\n+    C1 &_c1;\n+    C2 &_c2;\n+\n+  public:\n+    Closure(C1 &c1, C2 &c2) : ShenandoahHeapRegionClosure(), _c1(c1), _c2(c2) {}\n+\n+    void heap_region_do(ShenandoahHeapRegion* r) override {\n+      _c1.heap_region_do(r);\n+      _c2.heap_region_do(r);\n+    }\n+\n+    bool is_thread_safe() override {\n+      return _c1.is_thread_safe() && _c2.is_thread_safe();\n+    }\n+  };\n+\n+  template<typename C1, typename C2>\n+  static Closure<C1, C2> of(C1 &c1, C2 &c2) {\n+    return Closure<C1, C2>(c1, c2);\n+  }\n+};\n+\n+class ShenandoahUpdateRegionAges : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* _ctx;\n+\n+public:\n+  explicit ShenandoahUpdateRegionAges(ShenandoahMarkingContext* ctx) : _ctx(ctx) { }\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    \/\/ Maintenance of region age must follow evacuation in order to account for\n+    \/\/ evacuation allocations within survivor regions.  We consult region age during\n+    \/\/ the subsequent evacuation to determine whether certain objects need to\n+    \/\/ be promoted.\n+    if (r->is_young() && r->is_active()) {\n+      HeapWord *tams = _ctx->top_at_mark_start(r);\n+      HeapWord *top = r->top();\n+\n+      \/\/ Allocations move the watermark when top moves.  However, compacting\n+      \/\/ objects will sometimes lower top beneath the watermark, after which,\n+      \/\/ attempts to read the watermark will assert out (watermark should not be\n+      \/\/ higher than top).\n+      if (top > tams) {\n+        \/\/ There have been allocations in this region since the start of the cycle.\n+        \/\/ Any objects new to this region must not assimilate elevated age.\n+        r->reset_age();\n+      } else if (ShenandoahGenerationalHeap::heap()->is_aging_cycle()) {\n+        r->increment_age();\n+      }\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return true;\n+  }\n+};\n+\n+void ShenandoahGenerationalHeap::final_update_refs_update_region_states() {\n+  ShenandoahSynchronizePinnedRegionStates pins;\n+  ShenandoahUpdateRegionAges ages(active_generation()->complete_marking_context());\n+  auto cl = ShenandoahCompositeRegionClosure::of(pins, ages);\n+  parallel_heap_region_iterate(&cl);\n+}\n+\n+void ShenandoahGenerationalHeap::complete_degenerated_cycle() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  if (is_concurrent_old_mark_in_progress()) {\n+    \/\/ This is still necessary for degenerated cycles because the degeneration point may occur\n+    \/\/ after final mark of the young generation. See ShenandoahConcurrentGC::op_final_updaterefs for\n+    \/\/ a more detailed explanation.\n+    old_generation()->transfer_pointers_from_satb();\n+  }\n+\n+  \/\/ We defer generation resizing actions until after cset regions have been recycled.\n+  TransferResult result = balance_generations();\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Degenerated GC\", &ls);\n+  }\n+\n+  \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up\n+  \/\/ transient state. Otherwise, these actions have no effect.\n+  reset_generation_reserves();\n+\n+  if (!old_generation()->is_parsable()) {\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_coalesce_and_fill);\n+    coalesce_and_fill_old_regions(false);\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::complete_concurrent_cycle() {\n+  if (!old_generation()->is_parsable()) {\n+    \/\/ Class unloading may render the card offsets unusable, so we must rebuild them before\n+    \/\/ the next remembered set scan. We _could_ let the control thread do this sometime after\n+    \/\/ the global cycle has completed and before the next young collection, but under memory\n+    \/\/ pressure the control thread may not have the time (that is, because it's running back\n+    \/\/ to back GCs). In that scenario, we would have to make the old regions parsable before\n+    \/\/ we could start a young collection. This could delay the start of the young cycle and\n+    \/\/ throw off the heuristics.\n+    entry_global_coalesce_and_fill();\n+  }\n+\n+  TransferResult result;\n+  {\n+    ShenandoahHeapLocker locker(lock());\n+\n+    result = balance_generations();\n+    reset_generation_reserves();\n+  }\n+\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Concurrent GC\", &ls);\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::entry_global_coalesce_and_fill() {\n+  const char* msg = \"Coalescing and filling old regions\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent coalesce and fill\");\n+\n+  coalesce_and_fill_old_regions(true);\n+}\n+\n+void ShenandoahGenerationalHeap::update_region_ages(ShenandoahMarkingContext* ctx) {\n+  ShenandoahUpdateRegionAges cl(ctx);\n+  parallel_heap_region_iterate(&cl);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":1140,"deletions":0,"binary":false,"changes":1140,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALHEAP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALHEAP\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+\n+class PLAB;\n+class ShenandoahRegulatorThread;\n+class ShenandoahGenerationalControlThread;\n+class ShenandoahAgeCensus;\n+\n+class ShenandoahGenerationalHeap : public ShenandoahHeap {\n+public:\n+  explicit ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy);\n+  void post_initialize() override;\n+  void initialize_heuristics() override;\n+\n+  static ShenandoahGenerationalHeap* heap() {\n+    shenandoah_assert_generational();\n+    CollectedHeap* heap = Universe::heap();\n+    return cast(heap);\n+  }\n+\n+  static ShenandoahGenerationalHeap* cast(CollectedHeap* heap) {\n+    shenandoah_assert_generational();\n+    return checked_cast<ShenandoahGenerationalHeap*>(heap);\n+  }\n+\n+  void print_init_logger() const override;\n+  void print_tracing_info() const override;\n+\n+  size_t unsafe_max_tlab_alloc(Thread *thread) const override;\n+\n+private:\n+  \/\/ ---------- Evacuations and Promotions\n+  \/\/\n+  \/\/ True when regions and objects should be aged during the current cycle\n+  ShenandoahSharedFlag  _is_aging_cycle;\n+  \/\/ Age census used for adapting tenuring threshold\n+  ShenandoahAgeCensus* _age_census;\n+  \/\/ Used primarily to look for failed evacuation attempts.\n+  ShenandoahEvacuationTracker*  _evac_tracker;\n+\n+public:\n+  void set_aging_cycle(bool cond) {\n+    _is_aging_cycle.set_cond(cond);\n+  }\n+\n+  inline bool is_aging_cycle() const {\n+    return _is_aging_cycle.is_set();\n+  }\n+\n+  \/\/ Return the age census object for young gen\n+  ShenandoahAgeCensus* age_census() const {\n+    return _age_census;\n+  }\n+\n+  ShenandoahEvacuationTracker* evac_tracker() const {\n+    return _evac_tracker;\n+  }\n+\n+  \/\/ Ages regions that haven't been used for allocations in the current cycle.\n+  \/\/ Resets ages for regions that have been used for allocations.\n+  void update_region_ages(ShenandoahMarkingContext* ctx);\n+\n+  oop evacuate_object(oop p, Thread* thread) override;\n+  oop try_evacuate_object(oop p, Thread* thread, ShenandoahHeapRegion* from_region, ShenandoahAffiliation target_gen);\n+  void evacuate_collection_set(bool concurrent) override;\n+  void promote_regions_in_place(bool concurrent);\n+\n+  size_t plab_min_size() const { return _min_plab_size; }\n+  size_t plab_max_size() const { return _max_plab_size; }\n+\n+  void retire_plab(PLAB* plab);\n+  void retire_plab(PLAB* plab, Thread* thread);\n+\n+  \/\/ ---------- Update References\n+  \/\/\n+  void update_heap_references(bool concurrent) override;\n+  void final_update_refs_update_region_states() override;\n+\n+private:\n+  HeapWord* allocate_from_plab(Thread* thread, size_t size, bool is_promotion);\n+  HeapWord* allocate_from_plab_slow(Thread* thread, size_t size, bool is_promotion);\n+  HeapWord* allocate_new_plab(size_t min_size, size_t word_size, size_t* actual_size);\n+\n+  const size_t _min_plab_size;\n+  const size_t _max_plab_size;\n+\n+  static size_t calculate_min_plab();\n+  static size_t calculate_max_plab();\n+\n+public:\n+  \/\/ ---------- Serviceability\n+  \/\/\n+  void initialize_serviceability() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n+\n+  ShenandoahRegulatorThread* regulator_thread() const { return _regulator_thread;  }\n+\n+  void gc_threads_do(ThreadClosure* tcl) const override;\n+\n+  void stop() override;\n+\n+  \/\/ Used for logging the result of a region transfer outside the heap lock\n+  struct TransferResult {\n+    bool success;\n+    size_t region_count;\n+    const char* region_destination;\n+\n+    void print_on(const char* when, outputStream* ss) const;\n+  };\n+\n+  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n+\n+  \/\/ Zeros out the evacuation and promotion reserves\n+  void reset_generation_reserves();\n+\n+  \/\/ Computes the optimal size for the old generation, represented as a surplus or deficit of old regions\n+  void compute_old_generation_balance(size_t old_xfer_limit, size_t old_cset_regions);\n+\n+  \/\/ Transfers surplus old regions to young, or takes regions from young to satisfy old region deficit\n+  TransferResult balance_generations();\n+\n+  \/\/ Balances generations, coalesces and fills old regions if necessary\n+  void complete_degenerated_cycle();\n+  void complete_concurrent_cycle();\n+private:\n+  void initialize_controller() override;\n+  void entry_global_coalesce_and_fill();\n+\n+  \/\/ Makes old regions parsable. This will also rebuild card offsets, which is necessary if classes were unloaded\n+  void coalesce_and_fill_old_regions(bool concurrent);\n+\n+  ShenandoahRegulatorThread* _regulator_thread;\n+\n+  MemoryPool* _young_gen_memory_pool;\n+  MemoryPool* _old_gen_memory_pool;\n+\n+  ShenandoahGenerationSizer     _generation_sizer;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALHEAP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+\n+\n+const char* ShenandoahGlobalGeneration::name() const {\n+  return type() == NON_GEN ? \"\" : \"Global\";\n+}\n+\n+size_t ShenandoahGlobalGeneration::max_capacity() const {\n+  return ShenandoahHeap::heap()->max_capacity();\n+}\n+\n+size_t ShenandoahGlobalGeneration::used_regions() const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  assert(heap->mode()->is_generational(), \"Region usage accounting is only for generational mode\");\n+  return heap->old_generation()->used_regions() + heap->young_generation()->used_regions();\n+}\n+\n+size_t ShenandoahGlobalGeneration::used_regions_size() const {\n+  return ShenandoahHeap::heap()->capacity();\n+}\n+\n+size_t ShenandoahGlobalGeneration::soft_max_capacity() const {\n+  return ShenandoahHeap::heap()->soft_max_capacity();\n+}\n+\n+size_t ShenandoahGlobalGeneration::available() const {\n+  return ShenandoahHeap::heap()->free_set()->available();\n+}\n+\n+size_t ShenandoahGlobalGeneration::soft_available() const {\n+  size_t available = this->available();\n+\n+  \/\/ Make sure the code below treats available without the soft tail.\n+  assert(max_capacity() >= soft_max_capacity(), \"Max capacity must be greater than soft max capacity.\");\n+  size_t soft_tail = max_capacity() - soft_max_capacity();\n+  return (available > soft_tail) ? (available - soft_tail) : 0;\n+}\n+\n+void ShenandoahGlobalGeneration::set_concurrent_mark_in_progress(bool in_progress) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (in_progress && heap->mode()->is_generational()) {\n+    \/\/ Global collection has preempted an old generation mark. This is fine\n+    \/\/ because the global generation includes the old generation, but we\n+    \/\/ want the global collect to start from a clean slate and we don't want\n+    \/\/ any stale state in the old generation.\n+    assert(!heap->is_concurrent_old_mark_in_progress(), \"Old cycle should not be running.\");\n+  }\n+\n+  heap->set_concurrent_young_mark_in_progress(in_progress);\n+}\n+\n+bool ShenandoahGlobalGeneration::contains(ShenandoahAffiliation affiliation) const {\n+  return true;\n+}\n+\n+bool ShenandoahGlobalGeneration::contains(ShenandoahHeapRegion* region) const {\n+  return true;\n+}\n+\n+void ShenandoahGlobalGeneration::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(cl);\n+}\n+\n+void ShenandoahGlobalGeneration::heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahHeap::heap()->heap_region_iterate(cl);\n+}\n+\n+bool ShenandoahGlobalGeneration::is_concurrent_mark_in_progress() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  return heap->is_concurrent_mark_in_progress();\n+}\n+\n+ShenandoahHeuristics* ShenandoahGlobalGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  if (gc_mode->is_generational()) {\n+    _heuristics = new ShenandoahGlobalHeuristics(this);\n+  } else {\n+    _heuristics = gc_mode->initialize_heuristics(this);\n+  }\n+\n+  _heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedGCInterval);\n+  confirm_heuristics_mode();\n+  return _heuristics;\n+}\n+\n+void ShenandoahGlobalGeneration::set_mark_complete() {\n+  ShenandoahGeneration::set_mark_complete();\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    heap->young_generation()->set_mark_complete();\n+    heap->old_generation()->set_mark_complete();\n+  }\n+}\n+\n+void ShenandoahGlobalGeneration::set_mark_incomplete() {\n+  ShenandoahGeneration::set_mark_incomplete();\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    heap->young_generation()->set_mark_incomplete();\n+    heap->old_generation()->set_mark_incomplete();\n+  }\n+}\n+\n+void ShenandoahGlobalGeneration::prepare_gc() {\n+  ShenandoahGeneration::prepare_gc();\n+\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    assert(type() == GLOBAL, \"Unexpected generation type\");\n+    \/\/ Clear any stale\/partial local census data before the start of a\n+    \/\/ new marking cycle\n+    ShenandoahGenerationalHeap::heap()->age_census()->reset_local();\n+  } else {\n+    assert(type() == NON_GEN, \"Unexpected generation type\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+\n+\/\/ A \"generation\" that represents the whole heap.\n+class ShenandoahGlobalGeneration : public ShenandoahGeneration {\n+public:\n+  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n+  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n+\n+public:\n+  const char* name() const override;\n+\n+  size_t max_capacity() const override;\n+  size_t soft_max_capacity() const override;\n+  size_t used_regions() const override;\n+  size_t used_regions_size() const override;\n+  size_t available() const override;\n+  size_t soft_available() const override;\n+\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n+\n+  bool contains(ShenandoahAffiliation affiliation) const override;\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+\n+  bool contains(oop obj) const override {\n+    return ShenandoahHeap::heap()->is_in_reserved(obj);\n+  }\n+\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  bool is_concurrent_mark_in_progress() override;\n+\n+  void set_mark_complete() override;\n+\n+  void set_mark_incomplete() override;\n+\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+\n+  virtual void prepare_gc() override;\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -40,0 +41,3 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n@@ -48,0 +52,3 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n@@ -50,0 +57,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -55,1 +63,0 @@\n-#include \"gc\/shenandoah\/shenandoahMetrics.hpp\"\n@@ -57,0 +64,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -62,0 +70,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -69,0 +78,2 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp\"\n@@ -71,0 +82,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -164,3 +177,0 @@\n-  \/\/ Now we know the number of regions, initialize the heuristics.\n-  initialize_heuristics();\n-\n@@ -220,0 +230,22 @@\n+  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this, _heap_region));\n+\n+  \/\/ Now we know the number of regions and heap sizes, initialize the heuristics.\n+  initialize_heuristics();\n+\n+  assert(_heap_region.byte_size() == heap_rs.size(), \"Need to know reserved size for card table\");\n+\n+  \/\/\n+  \/\/ Worker threads must be initialized after the barrier is configured\n+  \/\/\n+  _workers = new ShenandoahWorkerThreads(\"Shenandoah GC Threads\", _max_workers);\n+  if (_workers == nullptr) {\n+    vm_exit_during_initialization(\"Failed necessary allocation.\");\n+  } else {\n+    _workers->initialize_workers();\n+  }\n+\n+  if (ParallelGCThreads > 1) {\n+    _safepoint_workers = new ShenandoahWorkerThreads(\"Safepoint Cleanup Thread\", ParallelGCThreads);\n+    _safepoint_workers->initialize_workers();\n+  }\n+\n@@ -260,1 +292,1 @@\n-                              align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n+    align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n@@ -267,1 +299,1 @@\n-  _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions, _max_workers);\n+  _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions);\n@@ -351,0 +383,1 @@\n+  _affiliations = NEW_C_HEAP_ARRAY(uint8_t, _num_regions, mtGC);\n@@ -367,0 +400,2 @@\n+\n+      _affiliations[i] = ShenandoahAffiliation::FREE;\n@@ -371,0 +406,1 @@\n+    size_t young_cset_regions, old_cset_regions;\n@@ -372,1 +408,4 @@\n-    _free_set->rebuild();\n+    \/\/ We are initializing free set.  We ignore cset region tallies.\n+    size_t first_old, last_old, num_old;\n+    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    _free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n@@ -421,1 +460,1 @@\n-  _control_thread = new ShenandoahControlThread();\n+  initialize_controller();\n@@ -423,1 +462,1 @@\n-  ShenandoahInitLogger::print();\n+  print_init_logger();\n@@ -430,0 +469,8 @@\n+void ShenandoahHeap::initialize_controller() {\n+  _control_thread = new ShenandoahControlThread();\n+}\n+\n+void ShenandoahHeap::print_init_logger() const {\n+  ShenandoahInitLogger::print();\n+}\n+\n@@ -436,0 +483,2 @@\n+    } else if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+      _gc_mode = new ShenandoahGenerationalMode();\n@@ -456,13 +505,2 @@\n-  assert(_gc_mode != nullptr, \"Must be initialized\");\n-  _heuristics = _gc_mode->initialize_heuristics();\n-\n-  if (_heuristics->is_diagnostic() && !UnlockDiagnosticVMOptions) {\n-    vm_exit_during_initialization(\n-            err_msg(\"Heuristics \\\"%s\\\" is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.\",\n-                    _heuristics->name()));\n-  }\n-  if (_heuristics->is_experimental() && !UnlockExperimentalVMOptions) {\n-    vm_exit_during_initialization(\n-            err_msg(\"Heuristics \\\"%s\\\" is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.\",\n-                    _heuristics->name()));\n-  }\n+  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity(), max_capacity());\n+  _global_generation->initialize_heuristics(mode());\n@@ -478,0 +516,2 @@\n+  _gc_generation(nullptr),\n+  _active_generation(nullptr),\n@@ -479,1 +519,0 @@\n-  _used(0),\n@@ -481,2 +520,1 @@\n-  _bytes_allocated_since_gc_start(0),\n-  _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),\n+  _max_workers(MAX3(ConcGCThreads, ParallelGCThreads, 1U)),\n@@ -488,1 +526,1 @@\n-  _update_refs_iterator(this),\n+  _affiliations(nullptr),\n@@ -491,0 +529,3 @@\n+  _cancel_requested_time(0),\n+  _update_refs_iterator(this),\n+  _global_generation(nullptr),\n@@ -492,0 +533,2 @@\n+  _young_generation(nullptr),\n+  _old_generation(nullptr),\n@@ -494,1 +537,0 @@\n-  _heuristics(nullptr),\n@@ -499,0 +541,1 @@\n+  _mmu_tracker(),\n@@ -505,1 +548,0 @@\n-  _ref_processor(new ShenandoahReferenceProcessor(MAX2(_max_workers, 1U))),\n@@ -515,1 +557,1 @@\n-  \/\/ Initialize GC mode early, so we can adjust barrier support\n+  \/\/ Initialize GC mode early, many subsequent initialization procedures depend on it\n@@ -517,15 +559,0 @@\n-  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));\n-\n-  _max_workers = MAX2(_max_workers, 1U);\n-  _workers = new ShenandoahWorkerThreads(\"Shenandoah GC Threads\", _max_workers);\n-  if (_workers == nullptr) {\n-    vm_exit_during_initialization(\"Failed necessary allocation.\");\n-  } else {\n-    _workers->initialize_workers();\n-  }\n-\n-  if (ParallelGCThreads > 1) {\n-    _safepoint_workers = new ShenandoahWorkerThreads(\"Safepoint Cleanup Thread\",\n-                                                ParallelGCThreads);\n-    _safepoint_workers->initialize_workers();\n-  }\n@@ -538,29 +565,0 @@\n-class ShenandoahResetBitmapTask : public WorkerTask {\n-private:\n-  ShenandoahRegionIterator _regions;\n-\n-public:\n-  ShenandoahResetBitmapTask() :\n-    WorkerTask(\"Shenandoah Reset Bitmap\") {}\n-\n-  void work(uint worker_id) {\n-    ShenandoahHeapRegion* region = _regions.next();\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    ShenandoahMarkingContext* const ctx = heap->marking_context();\n-    while (region != nullptr) {\n-      if (heap->is_bitmap_slice_committed(region)) {\n-        ctx->clear_bitmap(region);\n-      }\n-      region = _regions.next();\n-    }\n-  }\n-};\n-\n-void ShenandoahHeap::reset_mark_bitmap() {\n-  assert_gc_workers(_workers->active_workers());\n-  mark_incomplete_marking_context();\n-\n-  ShenandoahResetBitmapTask task;\n-  _workers->run_task(&task);\n-}\n-\n@@ -581,1 +579,6 @@\n-  if (is_concurrent_mark_in_progress())        st->print(\"marking, \");\n+  if (!mode()->is_generational()) {\n+    if (is_concurrent_mark_in_progress())      st->print(\"marking,\");\n+  } else {\n+    if (is_concurrent_old_mark_in_progress())    st->print(\"old marking, \");\n+    if (is_concurrent_young_mark_in_progress())  st->print(\"young marking, \");\n+  }\n@@ -632,0 +635,2 @@\n+  _mmu_tracker.initialize();\n+\n@@ -645,2 +650,0 @@\n-  _heuristics->initialize();\n-\n@@ -650,0 +653,4 @@\n+ShenandoahHeuristics* ShenandoahHeap::heuristics() {\n+  return _global_generation->heuristics();\n+}\n+\n@@ -651,1 +658,1 @@\n-  return Atomic::load(&_used);\n+  return global_generation()->used();\n@@ -658,4 +665,0 @@\n-size_t ShenandoahHeap::available() const {\n-  return free_set()->available();\n-}\n-\n@@ -672,2 +675,43 @@\n-void ShenandoahHeap::increase_used(size_t bytes) {\n-  Atomic::add(&_used, bytes, memory_order_relaxed);\n+\/\/ For tracking usage based on allocations, it should be the case that:\n+\/\/ * The sum of regions::used == heap::used\n+\/\/ * The sum of a generation's regions::used == generation::used\n+\/\/ * The sum of a generation's humongous regions::free == generation::humongous_waste\n+\/\/ These invariants are checked by the verifier on GC safepoints.\n+\/\/\n+\/\/ Additional notes:\n+\/\/ * When a mutator's allocation request causes a region to be retired, the\n+\/\/   free memory left in that region is considered waste. It does not contribute\n+\/\/   to the usage, but it _does_ contribute to allocation rate.\n+\/\/ * The bottom of a PLAB must be aligned on card size. In some cases this will\n+\/\/   require padding in front of the PLAB (a filler object). Because this padding\n+\/\/   is included in the region's used memory we include the padding in the usage\n+\/\/   accounting as waste.\n+\/\/ * Mutator allocations are used to compute an allocation rate. They are also\n+\/\/   sent to the Pacer for those purposes.\n+\/\/ * There are three sources of waste:\n+\/\/  1. The padding used to align a PLAB on card size\n+\/\/  2. Region's free is less than minimum TLAB size and is retired\n+\/\/  3. The unused portion of memory in the last region of a humongous object\n+void ShenandoahHeap::increase_used(const ShenandoahAllocRequest& req) {\n+  size_t actual_bytes = req.actual_size() * HeapWordSize;\n+  size_t wasted_bytes = req.waste() * HeapWordSize;\n+  ShenandoahGeneration* generation = generation_for(req.affiliation());\n+\n+  if (req.is_gc_alloc()) {\n+    assert(wasted_bytes == 0 || req.type() == ShenandoahAllocRequest::_alloc_plab, \"Only PLABs have waste\");\n+    increase_used(generation, actual_bytes + wasted_bytes);\n+  } else {\n+    assert(req.is_mutator_alloc(), \"Expected mutator alloc here\");\n+    \/\/ padding and actual size both count towards allocation counter\n+    generation->increase_allocated(actual_bytes + wasted_bytes);\n+\n+    \/\/ only actual size counts toward usage for mutator allocations\n+    increase_used(generation, actual_bytes);\n+\n+    \/\/ notify pacer of both actual size and waste\n+    notify_mutator_alloc_words(req.actual_size(), req.waste());\n+\n+    if (wasted_bytes > 0 && ShenandoahHeapRegion::requires_humongous(req.actual_size())) {\n+      increase_humongous_waste(generation,wasted_bytes);\n+    }\n+  }\n@@ -676,2 +720,5 @@\n-void ShenandoahHeap::set_used(size_t bytes) {\n-  Atomic::store(&_used, bytes);\n+void ShenandoahHeap::increase_humongous_waste(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->increase_humongous_waste(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->increase_humongous_waste(bytes);\n+  }\n@@ -680,3 +727,5 @@\n-void ShenandoahHeap::decrease_used(size_t bytes) {\n-  assert(used() >= bytes, \"never decrease heap size by more than we've left\");\n-  Atomic::sub(&_used, bytes, memory_order_relaxed);\n+void ShenandoahHeap::decrease_humongous_waste(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->decrease_humongous_waste(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->decrease_humongous_waste(bytes);\n+  }\n@@ -685,2 +734,5 @@\n-void ShenandoahHeap::increase_allocated(size_t bytes) {\n-  Atomic::add(&_bytes_allocated_since_gc_start, bytes, memory_order_relaxed);\n+void ShenandoahHeap::increase_used(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->increase_used(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->increase_used(bytes);\n+  }\n@@ -689,4 +741,4 @@\n-void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {\n-  size_t bytes = words * HeapWordSize;\n-  if (!waste) {\n-    increase_used(bytes);\n+void ShenandoahHeap::decrease_used(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->decrease_used(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->decrease_used(bytes);\n@@ -694,1 +746,3 @@\n-  increase_allocated(bytes);\n+}\n+\n+void ShenandoahHeap::notify_mutator_alloc_words(size_t words, size_t waste) {\n@@ -697,2 +751,2 @@\n-    if (waste) {\n-      pacer()->claim_for_alloc<true>(words);\n+    if (waste > 0) {\n+      pacer()->claim_for_alloc<true>(waste);\n@@ -828,2 +882,0 @@\n-\n-  \/\/ This is called from allocation path, and thus should be fast.\n@@ -847,0 +899,1 @@\n+\n@@ -853,0 +906,1 @@\n+  log_debug(gc, free)(\"Set new GCLAB size: \" SIZE_FORMAT, new_size);\n@@ -858,0 +912,1 @@\n+    log_debug(gc, free)(\"New gclab size (\" SIZE_FORMAT \") is too small for \" SIZE_FORMAT, new_size, size);\n@@ -887,0 +942,1 @@\n+\/\/ Called from stubs in JIT code or interpreter\n@@ -935,0 +991,1 @@\n+    \/\/ gc_no_progress_count is incremented following each degen or full GC that fails to achieve is_good_progress().\n@@ -937,0 +994,1 @@\n+      req.set_actual_size(0);\n@@ -951,2 +1009,0 @@\n-      \/\/\n-      \/\/ TODO: Consider GLOBAL GC rather than Full GC to remediate OOM condition: https:\/\/bugs.openjdk.org\/browse\/JDK-8335910\n@@ -963,1 +1019,1 @@\n-      if (log_is_enabled(Debug, gc, alloc)) {\n+      if (log_develop_is_enabled(Debug, gc, alloc)) {\n@@ -982,0 +1038,8 @@\n+  if (result == nullptr) {\n+    req.set_actual_size(0);\n+  }\n+\n+  \/\/ This is called regardless of the outcome of the allocation to account\n+  \/\/ for any waste created by retiring regions with this request.\n+  increase_used(req);\n+\n@@ -991,2 +1055,0 @@\n-      notify_mutator_alloc_words(actual, false);\n-\n@@ -999,2 +1061,0 @@\n-    } else {\n-      increase_used(actual*HeapWordSize);\n@@ -1013,1 +1073,37 @@\n-  return _free_set->allocate(req, in_new_region);\n+\n+  \/\/ Make sure the old generation has room for either evacuations or promotions before trying to allocate.\n+  if (req.is_old() && !old_generation()->can_allocate(req)) {\n+    return nullptr;\n+  }\n+\n+  \/\/ If TLAB request size is greater than available, allocate() will attempt to downsize request to fit within available\n+  \/\/ memory.\n+  HeapWord* result = _free_set->allocate(req, in_new_region);\n+\n+  \/\/ Record the plab configuration for this result and register the object.\n+  if (result != nullptr && req.is_old()) {\n+    old_generation()->configure_plab_for_current_thread(req);\n+    if (req.type() == ShenandoahAllocRequest::_alloc_shared_gc) {\n+      \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n+      \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n+      \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n+      \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n+      \/\/\n+      \/\/ objects being \"concurrently\" allocated:\n+      \/\/    [-----a------][-----b-----][--------------c------------------]\n+      \/\/            [---- card table memory range --------------]\n+      \/\/\n+      \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that allocation of object a\n+      \/\/ wants to set the starts-object, first-start, and last-start attributes of the preceding card region.\n+      \/\/ Allocation of object b wants to set the starts-object, first-start, and last-start attributes of this card region.\n+      \/\/ Allocation of object c also wants to set the starts-object, first-start, and last-start attributes of this\n+      \/\/ card region.\n+      \/\/\n+      \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as\n+      \/\/ last-start representing object b while first-start represents object c.  This is why we need to require all\n+      \/\/ register_object() invocations to be \"mutually exclusive\" with respect to each card's memory range.\n+      old_generation()->card_scan()->register_object(result);\n+    }\n+  }\n+\n+  return result;\n@@ -1028,2 +1124,2 @@\n-  if (heuristics()->can_unload_classes()) {\n-    ShenandoahHeuristics* h = heuristics();\n+  ShenandoahHeuristics* h = global_generation()->heuristics();\n+  if (h->can_unload_classes()) {\n@@ -1127,3 +1223,4 @@\n-  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n-    \/\/ This thread went through the OOM during evac protocol and it is safe to return\n-    \/\/ the forward pointer. It must not attempt to evacuate any more.\n+  assert(thread == Thread::current(), \"Expected thread parameter to be current thread.\");\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(thread)) {\n+    \/\/ This thread went through the OOM during evac protocol. It is safe to return\n+    \/\/ the forward pointer. It must not attempt to evacuate any other objects.\n@@ -1135,1 +1232,2 @@\n-  size_t size = ShenandoahForwarding::size(p);\n+  ShenandoahHeapRegion* r = heap_region_containing(p);\n+  assert(!r->is_humongous(), \"never evacuate humongous objects\");\n@@ -1137,1 +1235,3 @@\n-  assert(!heap_region_containing(p)->is_humongous(), \"never evacuate humongous objects\");\n+  ShenandoahAffiliation target_gen = r->affiliation();\n+  return try_evacuate_object(p, thread, r, target_gen);\n+}\n@@ -1139,1 +1239,5 @@\n-  bool alloc_from_gclab = true;\n+oop ShenandoahHeap::try_evacuate_object(oop p, Thread* thread, ShenandoahHeapRegion* from_region,\n+                                               ShenandoahAffiliation target_gen) {\n+  assert(target_gen == YOUNG_GENERATION, \"Only expect evacuations to young in this mode\");\n+  assert(from_region->is_young(), \"Only expect evacuations from young in this mode\");\n+  bool alloc_from_lab = true;\n@@ -1141,0 +1245,1 @@\n+  size_t size = ShenandoahForwarding::size(p);\n@@ -1152,1 +1257,2 @@\n-      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);\n+      \/\/ If we failed to allocate in LAB, we'll try a shared allocation.\n+      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size, target_gen);\n@@ -1154,1 +1260,1 @@\n-      alloc_from_gclab = false;\n+      alloc_from_lab = false;\n@@ -1185,7 +1291,4 @@\n-    \/\/\n-    \/\/ For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next\n-    \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n-    \/\/ do this. For non-GCLAB allocations, we have no way to retract the allocation, and\n-    \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n-    \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n-    if (alloc_from_gclab) {\n+    if (alloc_from_lab) {\n+      \/\/ For LAB allocations, it is enough to rollback the allocation ptr. Either the next\n+      \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n+      \/\/ do this.\n@@ -1194,0 +1297,4 @@\n+      \/\/ For non-LAB allocations, we have no way to retract the allocation, and\n+      \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n+      \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n+      assert(size >= ShenandoahHeap::min_fill_size(), \"previously allocated object known to be larger than min_size\");\n@@ -1196,0 +1303,1 @@\n+      \/\/ For non-LAB allocations, the object has already been registered\n@@ -1229,1 +1337,1 @@\n-void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {\n+size_t ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {\n@@ -1249,0 +1357,1 @@\n+  return required_regions;\n@@ -1258,0 +1367,6 @@\n+\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n+      assert(plab->words_remaining() == 0, \"PLAB should not need retirement\");\n+    }\n@@ -1273,0 +1388,13 @@\n+\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n+\n+      \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n+      \/\/  1. We need to make the plab memory parsable by remembered-set scanning.\n+      \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n+      ShenandoahGenerationalHeap::heap()->retire_plab(plab, thread);\n+      if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n+        ShenandoahThreadLocalData::set_plab_size(thread, 0);\n+      }\n+    }\n@@ -1406,0 +1534,40 @@\n+void ShenandoahHeap::set_gc_generation(ShenandoahGeneration* generation) {\n+  shenandoah_assert_control_or_vm_thread_at_safepoint();\n+  _gc_generation = generation;\n+}\n+\n+\/\/ Active generation may only be set by the VM thread at a safepoint.\n+void ShenandoahHeap::set_active_generation() {\n+  assert(Thread::current()->is_VM_thread(), \"Only the VM Thread\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Only at a safepoint!\");\n+  assert(_gc_generation != nullptr, \"Will set _active_generation to nullptr\");\n+  _active_generation = _gc_generation;\n+}\n+\n+void ShenandoahHeap::on_cycle_start(GCCause::Cause cause, ShenandoahGeneration* generation) {\n+  shenandoah_policy()->record_collection_cause(cause);\n+\n+  assert(gc_cause()  == GCCause::_no_gc, \"Over-writing cause\");\n+  assert(_gc_generation == nullptr, \"Over-writing _gc_generation\");\n+\n+  set_gc_cause(cause);\n+  set_gc_generation(generation);\n+\n+  generation->heuristics()->record_cycle_start();\n+}\n+\n+void ShenandoahHeap::on_cycle_end(ShenandoahGeneration* generation) {\n+  assert(gc_cause() != GCCause::_no_gc, \"cause wasn't set\");\n+  assert(_gc_generation != nullptr, \"_gc_generation wasn't set\");\n+\n+  generation->heuristics()->record_cycle_end();\n+  if (mode()->is_generational() && generation->is_global()) {\n+    \/\/ If we just completed a GLOBAL GC, claim credit for completion of young-gen and old-gen GC as well\n+    young_generation()->heuristics()->record_cycle_end();\n+    old_generation()->heuristics()->record_cycle_end();\n+  }\n+\n+  set_gc_generation(nullptr);\n+  set_gc_cause(GCCause::_no_gc);\n+}\n+\n@@ -1755,99 +1923,0 @@\n-class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-public:\n-  ShenandoahResetUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    if (r->is_active()) {\n-      \/\/ Reset live data and set TAMS optimistically. We would recheck these under the pause\n-      \/\/ anyway to capture any updates that happened since now.\n-      r->clear_live_data();\n-      _ctx->capture_top_at_mark_start(r);\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n-void ShenandoahHeap::prepare_gc() {\n-  reset_mark_bitmap();\n-\n-  ShenandoahResetUpdateRegionStateClosure cl;\n-  parallel_heap_region_iterate(&cl);\n-}\n-\n-class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-  ShenandoahHeapLock* const _lock;\n-\n-public:\n-  ShenandoahFinalMarkUpdateRegionStateClosure() :\n-    _ctx(ShenandoahHeap::heap()->complete_marking_context()), _lock(ShenandoahHeap::heap()->lock()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    if (r->is_active()) {\n-      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n-      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-      if (top > tams) {\n-        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n-      }\n-\n-      \/\/ We are about to select the collection set, make sure it knows about\n-      \/\/ current pinning status. Also, this allows trashing more regions that\n-      \/\/ now have their pinning status dropped.\n-      if (r->is_pinned()) {\n-        if (r->pin_count() == 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_unpinned();\n-        }\n-      } else {\n-        if (r->pin_count() > 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_pinned();\n-        }\n-      }\n-\n-      \/\/ Remember limit for updating refs. It's guaranteed that we get no\n-      \/\/ from-space-refs written from here on.\n-      r->set_update_watermark_at_safepoint(r->top());\n-    } else {\n-      assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n-void ShenandoahHeap::prepare_regions_and_collection_set(bool concurrent) {\n-  assert(!is_full_gc_in_progress(), \"Only for concurrent and degenerated GC\");\n-  {\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_update_region_states :\n-                                         ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n-    ShenandoahFinalMarkUpdateRegionStateClosure cl;\n-    parallel_heap_region_iterate(&cl);\n-\n-    assert_pinned_region_status();\n-  }\n-\n-  {\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n-                                         ShenandoahPhaseTimings::degen_gc_choose_cset);\n-    ShenandoahHeapLocker locker(lock());\n-    _collection_set->clear();\n-    heuristics()->choose_collection_set(_collection_set);\n-  }\n-\n-  {\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_rebuild_freeset :\n-                                         ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n-    ShenandoahHeapLocker locker(lock());\n-    _free_set->rebuild();\n-  }\n-}\n-\n@@ -1856,0 +1925,3 @@\n+  if (mode()->is_generational()) {\n+    old_generation()->set_parsable(false);\n+  }\n@@ -1864,1 +1936,2 @@\n-  ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n+  shenandoah_assert_generations_reconciled();\n+  gc_generation()->ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n@@ -1900,4 +1973,52 @@\n-void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {\n-  assert(!has_forwarded_objects(), \"Not expected before\/after mark phase\");\n-  set_gc_state(MARKING, in_progress);\n-  ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);\n+void ShenandoahHeap::set_concurrent_young_mark_in_progress(bool in_progress) {\n+  uint mask;\n+  assert(!has_forwarded_objects(), \"Young marking is not concurrent with evacuation\");\n+  if (!in_progress && is_concurrent_old_mark_in_progress()) {\n+    assert(mode()->is_generational(), \"Only generational GC has old marking\");\n+    assert(_gc_state.is_set(MARKING), \"concurrent_old_marking_in_progress implies MARKING\");\n+    \/\/ If old-marking is in progress when we turn off YOUNG_MARKING, leave MARKING (and OLD_MARKING) on\n+    mask = YOUNG_MARKING;\n+  } else {\n+    mask = MARKING | YOUNG_MARKING;\n+  }\n+  set_gc_state(mask, in_progress);\n+  manage_satb_barrier(in_progress);\n+}\n+\n+void ShenandoahHeap::set_concurrent_old_mark_in_progress(bool in_progress) {\n+#ifdef ASSERT\n+  \/\/ has_forwarded_objects() iff UPDATEREFS or EVACUATION\n+  bool has_forwarded = has_forwarded_objects();\n+  bool updating_or_evacuating = _gc_state.is_set(UPDATEREFS | EVACUATION);\n+  bool evacuating = _gc_state.is_set(EVACUATION);\n+  assert ((has_forwarded == updating_or_evacuating) || (evacuating && !has_forwarded && collection_set()->is_empty()),\n+          \"Updating or evacuating iff has forwarded objects, or if evacuation phase is promoting in place without forwarding\");\n+#endif\n+  if (!in_progress && is_concurrent_young_mark_in_progress()) {\n+    \/\/ If young-marking is in progress when we turn off OLD_MARKING, leave MARKING (and YOUNG_MARKING) on\n+    assert(_gc_state.is_set(MARKING), \"concurrent_young_marking_in_progress implies MARKING\");\n+    set_gc_state(OLD_MARKING, in_progress);\n+  } else {\n+    set_gc_state(MARKING | OLD_MARKING, in_progress);\n+  }\n+  manage_satb_barrier(in_progress);\n+}\n+\n+bool ShenandoahHeap::is_prepare_for_old_mark_in_progress() const {\n+  return old_generation()->is_preparing_for_mark();\n+}\n+\n+void ShenandoahHeap::manage_satb_barrier(bool active) {\n+  if (is_concurrent_mark_in_progress()) {\n+    \/\/ Ignore request to deactivate barrier while concurrent mark is in progress.\n+    \/\/ Do not attempt to re-activate the barrier if it is already active.\n+    if (active && !ShenandoahBarrierSet::satb_mark_queue_set().is_active()) {\n+      ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(active, !active);\n+    }\n+  } else {\n+    \/\/ No concurrent marking is in progress so honor request to deactivate,\n+    \/\/ but only if the barrier is already active.\n+    if (!active && ShenandoahBarrierSet::satb_mark_queue_set().is_active()) {\n+      ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(active, !active);\n+    }\n+  }\n@@ -1936,0 +2057,11 @@\n+void ShenandoahHeap::cancel_concurrent_mark() {\n+  if (mode()->is_generational()) {\n+    young_generation()->cancel_marking();\n+    old_generation()->cancel_marking();\n+  }\n+\n+  global_generation()->cancel_marking();\n+\n+  ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n+}\n+\n@@ -1941,0 +2073,1 @@\n+    _cancel_requested_time = os::elapsedTime();\n@@ -2064,4 +2197,0 @@\n-size_t ShenandoahHeap::bytes_allocated_since_gc_start() const {\n-  return Atomic::load(&_bytes_allocated_since_gc_start);\n-}\n-\n@@ -2069,1 +2198,6 @@\n-  Atomic::store(&_bytes_allocated_since_gc_start, (size_t)0);\n+  if (mode()->is_generational()) {\n+    young_generation()->reset_bytes_allocated_since_gc_start();\n+    old_generation()->reset_bytes_allocated_since_gc_start();\n+  }\n+\n+  global_generation()->reset_bytes_allocated_since_gc_start();\n@@ -2133,2 +2267,5 @@\n-    assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n-           \"Region \" SIZE_FORMAT \" pinning status is inconsistent\", i);\n+    shenandoah_assert_generations_reconciled();\n+    if (gc_generation()->contains(r)) {\n+      assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n+             \"Region \" SIZE_FORMAT \" pinning status is inconsistent\", i);\n+    }\n@@ -2189,1 +2326,1 @@\n-  ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions) :\n+  explicit ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions) :\n@@ -2209,1 +2346,0 @@\n-    T cl;\n@@ -2214,2 +2350,5 @@\n-      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled because\n-      \/\/ we need the reclaimed collection set regions to replenish the collector reserves\n+\n+      \/\/ Now that evacuation is done, we can reassign any regions that had been reserved to hold the results of evacuation\n+      \/\/ to the mutator free set.  At the end of GC, we will have cset_regions newly evacuated fully empty regions from\n+      \/\/ which we will be able to replenish the Collector free set and the OldCollector free set in preparation for the\n+      \/\/ next GC cycle.\n@@ -2219,1 +2358,1 @@\n-\n+    T cl;\n@@ -2221,1 +2360,0 @@\n-    ShenandoahMarkingContext* const ctx = _heap->complete_marking_context();\n@@ -2227,3 +2365,3 @@\n-      }\n-      if (ShenandoahPacing) {\n-        _heap->pacer()->report_updaterefs(pointer_delta(update_watermark, r->bottom()));\n+        if (ShenandoahPacing) {\n+          _heap->pacer()->report_updaterefs(pointer_delta(update_watermark, r->bottom()));\n+        }\n@@ -2251,30 +2389,0 @@\n-\n-class ShenandoahFinalUpdateRefsUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahHeapLock* const _lock;\n-\n-public:\n-  ShenandoahFinalUpdateRefsUpdateRegionStateClosure() : _lock(ShenandoahHeap::heap()->lock()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    \/\/ Drop unnecessary \"pinned\" state from regions that does not have CP marks\n-    \/\/ anymore, as this would allow trashing them.\n-\n-    if (r->is_active()) {\n-      if (r->is_pinned()) {\n-        if (r->pin_count() == 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_unpinned();\n-        }\n-      } else {\n-        if (r->pin_count() > 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_pinned();\n-        }\n-      }\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n@@ -2289,2 +2397,2 @@\n-    ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl;\n-    parallel_heap_region_iterate(&cl);\n+\n+    final_update_refs_update_region_states();\n@@ -2303,0 +2411,5 @@\n+void ShenandoahHeap::final_update_refs_update_region_states() {\n+  ShenandoahSynchronizePinnedRegionStates cl;\n+  parallel_heap_region_iterate(&cl);\n+}\n+\n@@ -2304,6 +2417,42 @@\n-  {\n-    ShenandoahGCPhase phase(concurrent ?\n-                            ShenandoahPhaseTimings::final_update_refs_rebuild_freeset :\n-                            ShenandoahPhaseTimings::degen_gc_final_update_refs_rebuild_freeset);\n-    ShenandoahHeapLocker locker(lock());\n-    _free_set->rebuild();\n+  ShenandoahGCPhase phase(concurrent ?\n+                          ShenandoahPhaseTimings::final_update_refs_rebuild_freeset :\n+                          ShenandoahPhaseTimings::degen_gc_final_update_refs_rebuild_freeset);\n+  ShenandoahHeapLocker locker(lock());\n+  size_t young_cset_regions, old_cset_regions;\n+  size_t first_old_region, last_old_region, old_region_count;\n+  _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n+  \/\/ If there are no old regions, first_old_region will be greater than last_old_region\n+  assert((first_old_region > last_old_region) ||\n+         ((last_old_region + 1 - first_old_region >= old_region_count) &&\n+          get_region(first_old_region)->is_old() && get_region(last_old_region)->is_old()),\n+         \"sanity: old_region_count: \" SIZE_FORMAT \", first_old_region: \" SIZE_FORMAT \", last_old_region: \" SIZE_FORMAT,\n+         old_region_count, first_old_region, last_old_region);\n+\n+  if (mode()->is_generational()) {\n+#ifdef ASSERT\n+    if (ShenandoahVerify) {\n+      verifier()->verify_before_rebuilding_free_set();\n+    }\n+#endif\n+\n+    \/\/ The computation of bytes_of_allocation_runway_before_gc_trigger is quite conservative so consider all of this\n+    \/\/ available for transfer to old. Note that transfer of humongous regions does not impact available.\n+    ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+    size_t allocation_runway = gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    gen_heap->compute_old_generation_balance(allocation_runway, old_cset_regions);\n+\n+    \/\/ Total old_available may have been expanded to hold anticipated promotions.  We trigger if the fragmented available\n+    \/\/ memory represents more than 16 regions worth of data.  Note that fragmentation may increase when we promote regular\n+    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.  Fragmentation\n+    \/\/ will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n+    \/\/\n+    \/\/ We consider old-gen to have excessive fragmentation if more than 12.5% of old-gen is free memory that resides\n+    \/\/ within partially consumed regions of memory.\n+  }\n+  \/\/ Rebuild free set based on adjusted generation sizes.\n+  _free_set->finish_rebuild(young_cset_regions, old_cset_regions, old_region_count);\n+\n+  if (mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+    ShenandoahOldGeneration* old_gen = gen_heap->old_generation();\n+    old_gen->heuristics()->evaluate_triggers(first_old_region, last_old_region, old_region_count, num_regions());\n@@ -2432,1 +2581,1 @@\n-  return _memory_pool->get_memory_usage();\n+  return MemoryUsage(_initial_size, used(), committed(), max_capacity());\n@@ -2574,0 +2723,23 @@\n+\n+ShenandoahGeneration* ShenandoahHeap::generation_for(ShenandoahAffiliation affiliation) const {\n+  if (!mode()->is_generational()) {\n+    return global_generation();\n+  } else if (affiliation == YOUNG_GENERATION) {\n+    return young_generation();\n+  } else if (affiliation == OLD_GENERATION) {\n+    return old_generation();\n+  }\n+\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+void ShenandoahHeap::log_heap_status(const char* msg) const {\n+  if (mode()->is_generational()) {\n+    young_generation()->log_status(msg);\n+    old_generation()->log_status(msg);\n+  } else {\n+    global_generation()->log_status(msg);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":456,"deletions":284,"binary":false,"changes":740,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,2 +33,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n-#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n@@ -35,0 +34,2 @@\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n@@ -37,0 +38,5 @@\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -48,1 +54,0 @@\n-class ShenandoahControlThread;\n@@ -51,0 +56,3 @@\n+class ShenandoahGeneration;\n+class ShenandoahYoungGeneration;\n+class ShenandoahOldGeneration;\n@@ -120,1 +128,1 @@\n-class ShenandoahHeap : public CollectedHeap, public ShenandoahSpaceInfo {\n+class ShenandoahHeap : public CollectedHeap {\n@@ -130,0 +138,1 @@\n+  friend class ShenandoahOldGC;\n@@ -139,0 +148,13 @@\n+  \/\/ Indicates the generation whose collection is in\n+  \/\/ progress. Mutator threads aren't allowed to read\n+  \/\/ this field.\n+  ShenandoahGeneration* _gc_generation;\n+\n+  \/\/ This is set and cleared by only the VMThread\n+  \/\/ at each STW pause (safepoint) to the value seen in\n+  \/\/ _gc_generation. This allows the value to be always consistently\n+  \/\/ seen by all mutators as well as all GC worker threads.\n+  \/\/ In that sense, it's a stable snapshot of _gc_generation that is\n+  \/\/ updated at each STW pause associated with a ShenandoahVMOp.\n+  ShenandoahGeneration* _active_generation;\n+\n@@ -144,0 +166,22 @@\n+  ShenandoahGeneration* gc_generation() const {\n+    \/\/ We don't want this field read by a mutator thread\n+    assert(!Thread::current()->is_Java_thread(), \"Not allowed\");\n+    \/\/ value of _gc_generation field, see above\n+    return _gc_generation;\n+  }\n+\n+  ShenandoahGeneration* active_generation() const {\n+    \/\/ value of _active_generation field, see above\n+    return _active_generation;\n+  }\n+\n+  \/\/ Set the _gc_generation field\n+  void set_gc_generation(ShenandoahGeneration* generation);\n+\n+  \/\/ Copy the value in the _gc_generation field into\n+  \/\/ the _active_generation field: can only be called at\n+  \/\/ a safepoint by the VMThread.\n+  void set_active_generation();\n+\n+  ShenandoahHeuristics* heuristics();\n+\n@@ -156,2 +200,2 @@\n-  void initialize_heuristics();\n-\n+  virtual void initialize_heuristics();\n+  virtual void print_init_logger() const;\n@@ -178,2 +222,3 @@\n-           size_t _initial_size;\n-           size_t _minimum_size;\n+  size_t _initial_size;\n+  size_t _minimum_size;\n+\n@@ -182,1 +227,0 @@\n-  volatile size_t _used;\n@@ -184,1 +228,0 @@\n-  volatile size_t _bytes_allocated_since_gc_start;\n@@ -187,0 +230,2 @@\n+  void increase_used(const ShenandoahAllocRequest& req);\n+\n@@ -188,3 +233,4 @@\n-  void increase_used(size_t bytes);\n-  void decrease_used(size_t bytes);\n-  void set_used(size_t bytes);\n+  void increase_used(ShenandoahGeneration* generation, size_t bytes);\n+  void decrease_used(ShenandoahGeneration* generation, size_t bytes);\n+  void increase_humongous_waste(ShenandoahGeneration* generation, size_t bytes);\n+  void decrease_humongous_waste(ShenandoahGeneration* generation, size_t bytes);\n@@ -194,1 +240,0 @@\n-  void increase_allocated(size_t bytes);\n@@ -196,1 +241,0 @@\n-  size_t bytes_allocated_since_gc_start() const override;\n@@ -201,1 +245,1 @@\n-  size_t soft_max_capacity() const override;\n+  size_t soft_max_capacity() const;\n@@ -206,1 +250,0 @@\n-  size_t available()         const override;\n@@ -226,0 +269,2 @@\n+  virtual void initialize_controller();\n+\n@@ -242,1 +287,1 @@\n-  ShenandoahRegionIterator _update_refs_iterator;\n+  uint8_t* _affiliations;       \/\/ Holds array of enum ShenandoahAffiliation, including FREE status in non-generational mode\n@@ -259,0 +304,2 @@\n+  inline ShenandoahMmuTracker* mmu_tracker() { return &_mmu_tracker; };\n+\n@@ -274,0 +321,1 @@\n+    \/\/ For generational mode, it means either young or old marking, or both.\n@@ -284,0 +332,6 @@\n+\n+    \/\/ Young regions are under marking, need SATB barriers.\n+    YOUNG_MARKING_BITPOS = 5,\n+\n+    \/\/ Old regions are under marking, need SATB barriers.\n+    OLD_MARKING_BITPOS = 6\n@@ -293,0 +347,2 @@\n+    YOUNG_MARKING = 1 << YOUNG_MARKING_BITPOS,\n+    OLD_MARKING   = 1 << OLD_MARKING_BITPOS\n@@ -298,2 +354,0 @@\n-\n-  \/\/ tracks if new regions have been allocated or retired since last check\n@@ -328,1 +382,2 @@\n-  void set_concurrent_mark_in_progress(bool in_progress);\n+  void set_concurrent_young_mark_in_progress(bool in_progress);\n+  void set_concurrent_old_mark_in_progress(bool in_progress);\n@@ -340,0 +395,1 @@\n+\n@@ -341,0 +397,2 @@\n+  inline bool is_concurrent_young_mark_in_progress() const;\n+  inline bool is_concurrent_old_mark_in_progress() const;\n@@ -351,0 +409,1 @@\n+  bool is_prepare_for_old_mark_in_progress() const;\n@@ -353,0 +412,2 @@\n+  void manage_satb_barrier(bool active);\n+\n@@ -363,0 +424,1 @@\n+  double _cancel_requested_time;\n@@ -364,0 +426,5 @@\n+\n+  \/\/ Returns true if cancel request was successfully communicated.\n+  \/\/ Returns false if some other thread already communicated cancel\n+  \/\/ request.  A true return value does not mean GC has been\n+  \/\/ cancelled, only that the process of cancelling GC has begun.\n@@ -367,1 +434,0 @@\n-\n@@ -371,1 +437,1 @@\n-  inline void clear_cancelled_gc();\n+  inline void clear_cancelled_gc(bool clear_oom_handler = true);\n@@ -373,0 +439,1 @@\n+  void cancel_concurrent_mark();\n@@ -384,0 +451,6 @@\n+protected:\n+  \/\/ This is shared between shConcurrentGC and shDegenerateGC so that degenerated\n+  \/\/ GC can resume update refs from where the concurrent GC was cancelled. It is\n+  \/\/ also used in shGenerationalHeap, which uses a different closure for update refs.\n+  ShenandoahRegionIterator _update_refs_iterator;\n+\n@@ -386,3 +459,0 @@\n-  \/\/ Reset bitmap, prepare regions for new GC cycle\n-  void prepare_gc();\n-  void prepare_regions_and_collection_set(bool concurrent);\n@@ -390,1 +460,1 @@\n-  void evacuate_collection_set(bool concurrent);\n+  virtual void evacuate_collection_set(bool concurrent);\n@@ -398,1 +468,1 @@\n-  void update_heap_references(bool concurrent);\n+  virtual void update_heap_references(bool concurrent);\n@@ -401,1 +471,1 @@\n-  void rebuild_free_set(bool concurrent);\n+  virtual void final_update_refs_update_region_states();\n@@ -406,0 +476,1 @@\n+  void rebuild_free_set(bool concurrent);\n@@ -413,1 +484,9 @@\n-  ShenandoahControlThread*   _control_thread;\n+  ShenandoahGeneration*  _global_generation;\n+\n+protected:\n+  ShenandoahController*  _control_thread;\n+\n+  ShenandoahYoungGeneration* _young_generation;\n+  ShenandoahOldGeneration*   _old_generation;\n+\n+private:\n@@ -416,1 +495,0 @@\n-  ShenandoahHeuristics*      _heuristics;\n@@ -421,3 +499,2 @@\n-  ShenandoahPhaseTimings*    _phase_timings;\n-\n-  ShenandoahControlThread*   control_thread()          { return _control_thread;    }\n+  ShenandoahPhaseTimings*       _phase_timings;\n+  ShenandoahMmuTracker          _mmu_tracker;\n@@ -426,0 +503,15 @@\n+  ShenandoahController*   control_thread() { return _control_thread; }\n+\n+  ShenandoahGeneration*      global_generation() const { return _global_generation; }\n+  ShenandoahYoungGeneration* young_generation()  const {\n+    assert(mode()->is_generational(), \"Young generation requires generational mode\");\n+    return _young_generation;\n+  }\n+\n+  ShenandoahOldGeneration*   old_generation()    const {\n+    assert(mode()->is_generational(), \"Old generation requires generational mode\");\n+    return _old_generation;\n+  }\n+\n+  ShenandoahGeneration*      generation_for(ShenandoahAffiliation affiliation) const;\n+\n@@ -428,1 +520,0 @@\n-  ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }\n@@ -434,0 +525,5 @@\n+  ShenandoahEvacOOMHandler*  oom_evac_handler()        { return &_oom_evac_handler; }\n+\n+  void on_cycle_start(GCCause::Cause cause, ShenandoahGeneration* generation);\n+  void on_cycle_end(ShenandoahGeneration* generation);\n+\n@@ -447,1 +543,1 @@\n-  ShenandoahMonitoringSupport* monitoring_support()          { return _monitoring_support;    }\n+  ShenandoahMonitoringSupport* monitoring_support() const    { return _monitoring_support;    }\n@@ -457,8 +553,0 @@\n-\/\/ ---------- Reference processing\n-\/\/\n-private:\n-  ShenandoahReferenceProcessor* const _ref_processor;\n-\n-public:\n-  ShenandoahReferenceProcessor* ref_processor() { return _ref_processor; }\n-\n@@ -483,0 +571,3 @@\n+  inline void assert_lock_for_affiliation(ShenandoahAffiliation orig_affiliation,\n+                                          ShenandoahAffiliation new_affiliation);\n+\n@@ -500,0 +591,15 @@\n+  \/\/ Returns true if the given oop belongs to a generation that is actively being collected.\n+  inline bool is_in_active_generation(oop obj) const;\n+  inline bool is_in_young(const void* p) const;\n+  inline bool is_in_old(const void* p) const;\n+\n+  \/\/ Returns true iff the young generation is being collected and the given pointer\n+  \/\/ is in the old generation. This is used to prevent the young collection from treating\n+  \/\/ such an object as unreachable.\n+  inline bool is_in_old_during_young_collection(oop obj) const;\n+\n+  inline ShenandoahAffiliation region_affiliation(const ShenandoahHeapRegion* r);\n+  inline void set_affiliation(ShenandoahHeapRegion* r, ShenandoahAffiliation new_affiliation);\n+\n+  inline ShenandoahAffiliation region_affiliation(size_t index);\n+\n@@ -546,1 +652,1 @@\n-  bool can_load_archived_objects() const override { return true; }\n+  bool can_load_archived_objects() const override { return !ShenandoahCardBarrier; }\n@@ -552,0 +658,3 @@\n+protected:\n+  inline HeapWord* allocate_from_gclab(Thread* thread, size_t size);\n+\n@@ -554,1 +663,0 @@\n-  inline HeapWord* allocate_from_gclab(Thread* thread, size_t size);\n@@ -565,1 +673,1 @@\n-  void notify_mutator_alloc_words(size_t words, bool waste);\n+  void notify_mutator_alloc_words(size_t words, size_t waste);\n@@ -603,2 +711,0 @@\n-  inline void mark_complete_marking_context();\n-  inline void mark_incomplete_marking_context();\n@@ -615,2 +721,0 @@\n-  void reset_mark_bitmap();\n-\n@@ -637,0 +741,2 @@\n+  oop try_evacuate_object(oop src, Thread* thread, ShenandoahHeapRegion* from_region, ShenandoahAffiliation target_gen);\n+\n@@ -648,1 +754,1 @@\n-  \/\/ Evacuates object src. Returns the evacuated object, either evacuated\n+  \/\/ Evacuates or promotes object src. Returns the evacuated object, either evacuated\n@@ -650,1 +756,1 @@\n-  oop evacuate_object(oop src, Thread* thread);\n+  virtual oop evacuate_object(oop src, Thread* thread);\n@@ -677,1 +783,10 @@\n-  void trash_humongous_region_at(ShenandoahHeapRegion *r);\n+  size_t trash_humongous_region_at(ShenandoahHeapRegion *r);\n+\n+  static inline void increase_object_age(oop obj, uint additional_age);\n+\n+  \/\/ Return the object's age, or a sentinel value when the age can't\n+  \/\/ necessarily be determined because of concurrent locking by the\n+  \/\/ mutator\n+  static inline uint get_object_age(oop obj);\n+\n+  void log_heap_status(const char *msg) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":169,"deletions":54,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -43,1 +44,1 @@\n-#include \"gc\/shenandoah\/shenandoahControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -51,0 +53,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -267,1 +270,1 @@\n-inline void ShenandoahHeap::clear_cancelled_gc() {\n+inline void ShenandoahHeap::clear_cancelled_gc(bool clear_oom_handler) {\n@@ -269,1 +272,8 @@\n-  _oom_evac_handler.clear();\n+  if (_cancel_requested_time > 0) {\n+    log_debug(gc)(\"GC cancellation took %.3fs\", (os::elapsedTime() - _cancel_requested_time));\n+    _cancel_requested_time = 0;\n+  }\n+\n+  if (clear_oom_handler) {\n+    _oom_evac_handler.clear();\n+  }\n@@ -286,1 +296,0 @@\n-  \/\/ Otherwise...\n@@ -290,0 +299,139 @@\n+void ShenandoahHeap::increase_object_age(oop obj, uint additional_age) {\n+  \/\/ This operates on new copy of an object. This means that the object's mark-word\n+  \/\/ is thread-local and therefore safe to access. However, when the mark is\n+  \/\/ displaced (i.e. stack-locked or monitor-locked), then it must be considered\n+  \/\/ a shared memory location. It can be accessed by other threads.\n+  \/\/ In particular, a competing evacuating thread can succeed to install its copy\n+  \/\/ as the forwardee and continue to unlock the object, at which point 'our'\n+  \/\/ write to the foreign stack-location would potentially over-write random\n+  \/\/ information on that stack. Writing to a monitor is less problematic,\n+  \/\/ but still not safe: while the ObjectMonitor would not randomly disappear,\n+  \/\/ the other thread would also write to the same displaced header location,\n+  \/\/ possibly leading to increase the age twice.\n+  \/\/ For all these reasons, we take the conservative approach and not attempt\n+  \/\/ to increase the age when the header is displaced.\n+  markWord w = obj->mark();\n+  \/\/ The mark-word has been copied from the original object. It can not be\n+  \/\/ inflating, because inflation can not be interrupted by a safepoint,\n+  \/\/ and after a safepoint, a Java thread would first have to successfully\n+  \/\/ evacuate the object before it could inflate the monitor.\n+  assert(!w.is_being_inflated() || LockingMode == LM_LIGHTWEIGHT, \"must not inflate monitor before evacuation of object succeeds\");\n+  \/\/ It is possible that we have copied the object after another thread has\n+  \/\/ already successfully completed evacuation. While harmless (we would never\n+  \/\/ publish our copy), don't even attempt to modify the age when that\n+  \/\/ happens.\n+  if (!w.has_displaced_mark_helper() && !w.is_marked()) {\n+    w = w.set_age(MIN2(markWord::max_age, w.age() + additional_age));\n+    obj->set_mark(w);\n+  }\n+}\n+\n+\/\/ Return the object's age, or a sentinel value when the age can't\n+\/\/ necessarily be determined because of concurrent locking by the\n+\/\/ mutator\n+uint ShenandoahHeap::get_object_age(oop obj) {\n+  markWord w = obj->mark();\n+  assert(!w.is_marked(), \"must not be forwarded\");\n+  if (UseObjectMonitorTable) {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"Must use LW locking, too\");\n+    assert(w.age() <= markWord::max_age, \"Impossible!\");\n+    return w.age();\n+  }\n+  if (w.has_monitor()) {\n+    w = w.monitor()->header();\n+  } else if (w.is_being_inflated() || w.has_displaced_mark_helper()) {\n+    \/\/ Informs caller that we aren't able to determine the age\n+    return markWord::max_age + 1; \/\/ sentinel\n+  }\n+  assert(w.age() <= markWord::max_age, \"Impossible!\");\n+  return w.age();\n+}\n+\n+inline bool ShenandoahHeap::is_in_active_generation(oop obj) const {\n+  if (!mode()->is_generational()) {\n+    \/\/ everything is the same single generation\n+    assert(is_in_reserved(obj), \"Otherwise shouldn't return true below\");\n+    return true;\n+  }\n+\n+  ShenandoahGeneration* const gen = active_generation();\n+\n+  if (gen == nullptr) {\n+    \/\/ no collection is happening: only expect this to be called\n+    \/\/ when concurrent processing is active, but that could change\n+    return false;\n+  }\n+\n+  assert(is_in_reserved(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n+  assert(gen->is_old() || gen->is_young() || gen->is_global(),\n+         \"Active generation must be old, young, or global\");\n+\n+  size_t index = heap_region_containing(obj)->index();\n+\n+  \/\/ No flickering!\n+  assert(gen == active_generation(), \"Race?\");\n+\n+  switch (_affiliations[index]) {\n+  case ShenandoahAffiliation::FREE:\n+    \/\/ Free regions are in old, young, and global collections\n+    return true;\n+  case ShenandoahAffiliation::YOUNG_GENERATION:\n+    \/\/ Young regions are in young and global collections, not in old collections\n+    return !gen->is_old();\n+  case ShenandoahAffiliation::OLD_GENERATION:\n+    \/\/ Old regions are in old and global collections, not in young collections\n+    return !gen->is_young();\n+  default:\n+    assert(false, \"Bad affiliation (%d) for region \" SIZE_FORMAT, _affiliations[index], index);\n+    return false;\n+  }\n+}\n+\n+inline bool ShenandoahHeap::is_in_young(const void* p) const {\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n+}\n+\n+inline bool ShenandoahHeap::is_in_old(const void* p) const {\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n+}\n+\n+inline bool ShenandoahHeap::is_in_old_during_young_collection(oop obj) const {\n+  return active_generation()->is_young() && is_in_old(obj);\n+}\n+\n+inline ShenandoahAffiliation ShenandoahHeap::region_affiliation(const ShenandoahHeapRegion *r) {\n+  return (ShenandoahAffiliation) _affiliations[r->index()];\n+}\n+\n+inline void ShenandoahHeap::assert_lock_for_affiliation(ShenandoahAffiliation orig_affiliation,\n+                                                        ShenandoahAffiliation new_affiliation) {\n+  \/\/ A lock is required when changing from FREE to NON-FREE.  Though it may be possible to elide the lock when\n+  \/\/ transitioning from in-use to FREE, the current implementation uses a lock for this transition.  A lock is\n+  \/\/ not required to change from YOUNG to OLD (i.e. when promoting humongous region).\n+  \/\/\n+  \/\/         new_affiliation is:     FREE   YOUNG   OLD\n+  \/\/  orig_affiliation is:  FREE      X       L      L\n+  \/\/                       YOUNG      L       X\n+  \/\/                         OLD      L       X      X\n+  \/\/  X means state transition won't happen (so don't care)\n+  \/\/  L means lock should be held\n+  \/\/  Blank means no lock required because affiliation visibility will not be required until subsequent safepoint\n+  \/\/\n+  \/\/ Note: during full GC, all transitions between states are possible.  During Full GC, we should be in a safepoint.\n+\n+  if ((orig_affiliation == ShenandoahAffiliation::FREE) || (new_affiliation == ShenandoahAffiliation::FREE)) {\n+    shenandoah_assert_heaplocked_or_safepoint();\n+  }\n+}\n+\n+inline void ShenandoahHeap::set_affiliation(ShenandoahHeapRegion* r, ShenandoahAffiliation new_affiliation) {\n+#ifdef ASSERT\n+  assert_lock_for_affiliation(region_affiliation(r), new_affiliation);\n+#endif\n+  _affiliations[r->index()] = (uint8_t) new_affiliation;\n+}\n+\n+inline ShenandoahAffiliation ShenandoahHeap::region_affiliation(size_t index) {\n+  return (ShenandoahAffiliation) _affiliations[index];\n+}\n+\n@@ -317,0 +465,8 @@\n+inline bool ShenandoahHeap::is_concurrent_young_mark_in_progress() const {\n+  return _gc_state.is_set(YOUNG_MARKING);\n+}\n+\n+inline bool ShenandoahHeap::is_concurrent_old_mark_in_progress() const {\n+  return _gc_state.is_set(OLD_MARKING);\n+}\n+\n@@ -358,2 +514,1 @@\n-  ShenandoahMarkingContext* const ctx = complete_marking_context();\n-  assert(ctx->is_complete(), \"sanity\");\n+  ShenandoahMarkingContext* const ctx = marking_context();\n@@ -490,8 +645,0 @@\n-inline void ShenandoahHeap::mark_complete_marking_context() {\n-  _marking_context->mark_complete();\n-}\n-\n-inline void ShenandoahHeap::mark_incomplete_marking_context() {\n-  _marking_context->mark_incomplete();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":161,"deletions":14,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n- * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -29,0 +31,2 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -33,0 +37,4 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -63,0 +71,1 @@\n+  _top_before_promoted(nullptr),\n@@ -67,0 +76,1 @@\n+  _plab_allocs(0),\n@@ -69,1 +79,6 @@\n-  _update_watermark(start) {\n+  _update_watermark(start),\n+  _age(0)\n+#ifdef SHENANDOAH_CENSUS_NOISE\n+  , _youth(0)\n+#endif \/\/ SHENANDOAH_CENSUS_NOISE\n+  {\n@@ -85,1 +100,1 @@\n-void ShenandoahHeapRegion::make_regular_allocation() {\n+void ShenandoahHeapRegion::make_regular_allocation(ShenandoahAffiliation affiliation) {\n@@ -87,1 +102,1 @@\n-\n+  reset_age();\n@@ -92,0 +107,1 @@\n+      assert(this->affiliation() == affiliation, \"Region affiliation should already be established\");\n@@ -101,0 +117,25 @@\n+\/\/ Change affiliation to YOUNG_GENERATION if _state is not _pinned_cset, _regular, or _pinned.  This implements\n+\/\/ behavior previously performed as a side effect of make_regular_bypass().  This is used by Full GC in non-generational\n+\/\/ modes to transition regions from FREE. Note that all non-free regions in single-generational modes are young.\n+void ShenandoahHeapRegion::make_affiliated_maybe() {\n+  shenandoah_assert_heaplocked();\n+  assert(!ShenandoahHeap::heap()->mode()->is_generational(), \"Only call if non-generational\");\n+  switch (_state) {\n+   case _empty_uncommitted:\n+   case _empty_committed:\n+   case _cset:\n+   case _humongous_start:\n+   case _humongous_cont:\n+     if (affiliation() != YOUNG_GENERATION) {\n+       set_affiliation(YOUNG_GENERATION);\n+     }\n+     return;\n+   case _pinned_cset:\n+   case _regular:\n+   case _pinned:\n+     return;\n+   default:\n+     assert(false, \"Unexpected _state in make_affiliated_maybe\");\n+  }\n+}\n+\n@@ -107,1 +148,1 @@\n-\n+  reset_age();\n@@ -115,0 +156,8 @@\n+      if (_state == _humongous_start || _state == _humongous_cont) {\n+        \/\/ CDS allocates chunks of the heap to fill with regular objects. The allocator\n+        \/\/ will dutifully track any waste in the unused portion of the last region. Once\n+        \/\/ CDS has finished initializing the objects, it will convert these regions to\n+        \/\/ regular regions. The 'waste' in the last region is no longer wasted at this point,\n+        \/\/ so we must stop treating it as such.\n+        decrement_humongous_waste();\n+      }\n@@ -130,0 +179,1 @@\n+  reset_age();\n@@ -141,1 +191,1 @@\n-void ShenandoahHeapRegion::make_humongous_start_bypass() {\n+void ShenandoahHeapRegion::make_humongous_start_bypass(ShenandoahAffiliation affiliation) {\n@@ -144,1 +194,3 @@\n-\n+  \/\/ Don't bother to account for affiliated regions during Full GC.  We recompute totals at end.\n+  set_affiliation(affiliation);\n+  reset_age();\n@@ -159,0 +211,1 @@\n+  reset_age();\n@@ -170,1 +223,1 @@\n-void ShenandoahHeapRegion::make_humongous_cont_bypass() {\n+void ShenandoahHeapRegion::make_humongous_cont_bypass(ShenandoahAffiliation affiliation) {\n@@ -173,1 +226,3 @@\n-\n+  set_affiliation(affiliation);\n+  \/\/ Don't bother to account for affiliated regions during Full GC.  We recompute totals at end.\n+  reset_age();\n@@ -214,0 +269,1 @@\n+      assert(is_affiliated(), \"Pinned region should be affiliated\");\n@@ -232,0 +288,1 @@\n+  \/\/ Leave age untouched.  We need to consult the age when we are deciding whether to promote evacuated objects.\n@@ -244,0 +301,1 @@\n+  reset_age();\n@@ -245,2 +303,0 @@\n-    case _cset:\n-      \/\/ Reclaiming cset regions\n@@ -249,1 +305,7 @@\n-      \/\/ Reclaiming humongous regions\n+    {\n+      \/\/ Reclaiming humongous regions and reclaim humongous waste.  When this region is eventually recycled, we'll reclaim\n+      \/\/ its used memory.  At recycle time, we no longer recognize this as a humongous region.\n+      decrement_humongous_waste();\n+    }\n+    case _cset:\n+      \/\/ Reclaiming cset regions\n@@ -264,1 +326,3 @@\n-  ShenandoahHeap::heap()->complete_marking_context()->reset_top_bitmap(this);\n+  assert(ShenandoahHeap::heap()->gc_generation()->is_mark_complete(), \"Marking should be complete here.\");\n+  shenandoah_assert_generations_reconciled();\n+  ShenandoahHeap::heap()->marking_context()->reset_top_bitmap(this);\n@@ -269,0 +333,2 @@\n+  reset_age();\n+  CENSUS_NOISE(clear_youth();)\n@@ -308,0 +374,1 @@\n+  _plab_allocs = 0;\n@@ -311,1 +378,1 @@\n-  return used() - (_tlab_allocs + _gclab_allocs) * HeapWordSize;\n+  return used() - (_tlab_allocs + _gclab_allocs + _plab_allocs) * HeapWordSize;\n@@ -322,0 +389,4 @@\n+size_t ShenandoahHeapRegion::get_plab_allocs() const {\n+  return _plab_allocs * HeapWordSize;\n+}\n+\n@@ -366,0 +437,2 @@\n+  st->print(\"|%s\", shenandoah_affiliation_code(affiliation()));\n+\n@@ -377,0 +450,3 @@\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    st->print(\"|P \" SIZE_FORMAT_W(5) \"%1s\", byte_size_in_proper_unit(get_plab_allocs()),   proper_unit_for_byte_size(get_plab_allocs()));\n+  }\n@@ -385,6 +461,7 @@\n-void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {\n-  if (!is_active()) return;\n-  if (is_humongous()) {\n-    oop_iterate_humongous(blk);\n-  } else {\n-    oop_iterate_objects(blk);\n+\/\/ oop_iterate without closure, return true if completed without cancellation\n+bool ShenandoahHeapRegion::oop_coalesce_and_fill(bool cancellable) {\n+\n+  assert(!is_humongous(), \"No need to fill or coalesce humongous regions\");\n+  if (!is_active()) {\n+    end_preemptible_coalesce_and_fill();\n+    return true;\n@@ -392,1 +469,0 @@\n-}\n@@ -394,5 +470,17 @@\n-void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {\n-  assert(! is_humongous(), \"no humongous region here\");\n-  HeapWord* obj_addr = bottom();\n-  HeapWord* t = top();\n-  \/\/ Could call objects iterate, but this is easier.\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+\n+  \/\/ Expect marking to be completed before these threads invoke this service.\n+  assert(heap->gc_generation()->is_mark_complete(), \"sanity\");\n+  shenandoah_assert_generations_reconciled();\n+\n+  \/\/ All objects above TAMS are considered live even though their mark bits will not be set.  Note that young-\n+  \/\/ gen evacuations that interrupt a long-running old-gen concurrent mark may promote objects into old-gen\n+  \/\/ while the old-gen concurrent marking is ongoing.  These newly promoted objects will reside above TAMS\n+  \/\/ and will be treated as live during the current old-gen marking pass, even though they will not be\n+  \/\/ explicitly marked.\n+  HeapWord* t = marking_context->top_at_mark_start(this);\n+\n+  \/\/ Resume coalesce and fill from this address\n+  HeapWord* obj_addr = resume_coalesce_and_fill();\n+\n@@ -401,1 +489,17 @@\n-    obj_addr += obj->oop_iterate_size(blk);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != nullptr, \"klass should not be nullptr\");\n+      obj_addr += obj->size();\n+    } else {\n+      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      assert(fill_size >= ShenandoahHeap::min_fill_size(), \"previously allocated object known to be larger than min_size\");\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      heap->old_generation()->card_scan()->coalesce_objects(obj_addr, fill_size);\n+      obj_addr = next_marked_obj;\n+    }\n+    if (cancellable && heap->cancelled_gc()) {\n+      suspend_coalesce_and_fill(obj_addr);\n+      return false;\n+    }\n@@ -403,0 +507,3 @@\n+  \/\/ Mark that this region has been coalesced and filled\n+  end_preemptible_coalesce_and_fill();\n+  return true;\n@@ -405,1 +512,9 @@\n-void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {\n+size_t get_card_count(size_t words) {\n+  assert(words % CardTable::card_size_in_words() == 0, \"Humongous iteration must span whole number of cards\");\n+  assert(CardTable::card_size_in_words() * (words \/ CardTable::card_size_in_words()) == words,\n+         \"slice must be integral number of cards\");\n+  return words \/ CardTable::card_size_in_words();\n+}\n+\n+void ShenandoahHeapRegion::oop_iterate_humongous_slice_dirty(OopIterateClosure* blk,\n+                                                             HeapWord* start, size_t words, bool write_table) const {\n@@ -407,1 +522,1 @@\n-  \/\/ Find head.\n+\n@@ -409,1 +524,0 @@\n-  assert(r->is_humongous_start(), \"need humongous head here\");\n@@ -411,1 +525,30 @@\n-  obj->oop_iterate(blk, MemRegion(bottom(), top()));\n+  size_t num_cards = get_card_count(words);\n+\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n+  size_t card_index = scanner->card_index_for_addr(start);\n+  if (write_table) {\n+    while (num_cards-- > 0) {\n+      if (scanner->is_write_card_dirty(card_index++)) {\n+        obj->oop_iterate(blk, MemRegion(start, start + CardTable::card_size_in_words()));\n+      }\n+      start += CardTable::card_size_in_words();\n+    }\n+  } else {\n+    while (num_cards-- > 0) {\n+      if (scanner->is_card_dirty(card_index++)) {\n+        obj->oop_iterate(blk, MemRegion(start, start + CardTable::card_size_in_words()));\n+      }\n+      start += CardTable::card_size_in_words();\n+    }\n+  }\n+}\n+\n+void ShenandoahHeapRegion::oop_iterate_humongous_slice_all(OopIterateClosure* cl, HeapWord* start, size_t words) const {\n+  assert(is_humongous(), \"only humongous region here\");\n+\n+  ShenandoahHeapRegion* r = humongous_start_region();\n+  oop obj = cast_to_oop(r->bottom());\n+\n+  \/\/ Scan all data, regardless of whether cards are dirty\n+  obj->oop_iterate(cl, MemRegion(start, start + words));\n@@ -430,0 +573,7 @@\n+  shenandoah_assert_heaplocked();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* generation = heap->generation_for(affiliation());\n+\n+  heap->decrease_used(generation, used());\n+  generation->decrement_affiliated_region_count();\n+\n@@ -432,1 +582,0 @@\n-\n@@ -435,1 +584,2 @@\n-  ShenandoahHeap::heap()->marking_context()->reset_top_at_mark_start(this);\n+  heap->marking_context()->reset_top_at_mark_start(this);\n+\n@@ -440,0 +590,1 @@\n+  set_affiliation(FREE);\n@@ -483,0 +634,5 @@\n+  \/\/ Generational Shenandoah needs this alignment for card tables.\n+  if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+    max_heap_size = align_up(max_heap_size , CardTable::ct_max_alignment_constraint());\n+  }\n+\n@@ -661,0 +817,62 @@\n+\n+void ShenandoahHeapRegion::set_affiliation(ShenandoahAffiliation new_affiliation) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  ShenandoahAffiliation region_affiliation = heap->region_affiliation(this);\n+  {\n+    ShenandoahMarkingContext* const ctx = heap->complete_marking_context();\n+    log_debug(gc)(\"Setting affiliation of Region \" SIZE_FORMAT \" from %s to %s, top: \" PTR_FORMAT \", TAMS: \" PTR_FORMAT\n+                  \", watermark: \" PTR_FORMAT \", top_bitmap: \" PTR_FORMAT,\n+                  index(), shenandoah_affiliation_name(region_affiliation), shenandoah_affiliation_name(new_affiliation),\n+                  p2i(top()), p2i(ctx->top_at_mark_start(this)), p2i(_update_watermark), p2i(ctx->top_bitmap(this)));\n+  }\n+\n+#ifdef ASSERT\n+  {\n+    \/\/ During full gc, heap->complete_marking_context() is not valid, may equal nullptr.\n+    ShenandoahMarkingContext* const ctx = heap->complete_marking_context();\n+    size_t idx = this->index();\n+    HeapWord* top_bitmap = ctx->top_bitmap(this);\n+\n+    assert(ctx->is_bitmap_range_within_region_clear(top_bitmap, _end),\n+           \"Region \" SIZE_FORMAT \", bitmap should be clear between top_bitmap: \" PTR_FORMAT \" and end: \" PTR_FORMAT, idx,\n+           p2i(top_bitmap), p2i(_end));\n+  }\n+#endif\n+\n+  if (region_affiliation == new_affiliation) {\n+    return;\n+  }\n+\n+  if (!heap->mode()->is_generational()) {\n+    log_trace(gc)(\"Changing affiliation of region %zu from %s to %s\",\n+                  index(), affiliation_name(), shenandoah_affiliation_name(new_affiliation));\n+    heap->set_affiliation(this, new_affiliation);\n+    return;\n+  }\n+\n+  switch (new_affiliation) {\n+    case FREE:\n+      assert(!has_live(), \"Free region should not have live data\");\n+      break;\n+    case YOUNG_GENERATION:\n+      reset_age();\n+      break;\n+    case OLD_GENERATION:\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      return;\n+  }\n+  heap->set_affiliation(this, new_affiliation);\n+}\n+\n+void ShenandoahHeapRegion::decrement_humongous_waste() const {\n+  assert(is_humongous(), \"Should only use this for humongous regions\");\n+  size_t waste_bytes = free();\n+  if (waste_bytes > 0) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    ShenandoahGeneration* generation = heap->generation_for(affiliation());\n+    heap->decrease_humongous_waste(generation, waste_bytes);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":251,"deletions":33,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,2 @@\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -125,0 +128,1 @@\n+public:\n@@ -143,0 +147,1 @@\n+private:\n@@ -170,1 +175,2 @@\n-  void make_regular_allocation();\n+  void make_regular_allocation(ShenandoahAffiliation affiliation);\n+  void make_affiliated_maybe();\n@@ -174,2 +180,2 @@\n-  void make_humongous_start_bypass();\n-  void make_humongous_cont_bypass();\n+  void make_humongous_start_bypass(ShenandoahAffiliation affiliation);\n+  void make_humongous_cont_bypass(ShenandoahAffiliation affiliation);\n@@ -200,0 +206,5 @@\n+  bool is_regular_pinned()         const { return _state == _pinned; }\n+\n+  inline bool is_young() const;\n+  inline bool is_old() const;\n+  inline bool is_affiliated() const;\n@@ -232,0 +243,2 @@\n+  HeapWord* _top_before_promoted;\n+\n@@ -234,0 +247,1 @@\n+  HeapWord* _coalesce_and_fill_boundary; \/\/ for old regions not selected as collection set candidates.\n@@ -240,0 +254,1 @@\n+  size_t _plab_allocs;\n@@ -246,0 +261,3 @@\n+  uint _age;\n+  CENSUS_NOISE(uint _youth;)   \/\/ tracks epochs of retrograde ageing (rejuvenation)\n+\n@@ -330,2 +348,13 @@\n-  \/\/ Allocation (return null if full)\n-  inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest::Type type);\n+  inline void save_top_before_promote();\n+  inline HeapWord* get_top_before_promote() const { return _top_before_promoted; }\n+  inline void restore_top_before_promote();\n+  inline size_t garbage_before_padded_for_promote() const;\n+\n+  \/\/ If next available memory is not aligned on address that is multiple of alignment, fill the empty space\n+  \/\/ so that returned object is aligned on an address that is a multiple of alignment_in_bytes.  Requested\n+  \/\/ size is in words.  It is assumed that this->is_old().  A pad object is allocated, filled, and registered\n+  \/\/ if necessary to assure the new allocation is properly aligned.  Return nullptr if memory is not available.\n+  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest &req, size_t alignment_in_bytes);\n+\n+  \/\/ Allocation (return nullptr if full)\n+  inline HeapWord* allocate(size_t word_size, const ShenandoahAllocRequest& req);\n@@ -352,1 +381,30 @@\n-  void oop_iterate(OopIterateClosure* cl);\n+  inline void begin_preemptible_coalesce_and_fill() {\n+    _coalesce_and_fill_boundary = _bottom;\n+  }\n+\n+  inline void end_preemptible_coalesce_and_fill() {\n+    _coalesce_and_fill_boundary = _end;\n+  }\n+\n+  inline void suspend_coalesce_and_fill(HeapWord* next_focus) {\n+    _coalesce_and_fill_boundary = next_focus;\n+  }\n+\n+  inline HeapWord* resume_coalesce_and_fill() {\n+    return _coalesce_and_fill_boundary;\n+  }\n+\n+  \/\/ Coalesce contiguous spans of garbage objects by filling header and registering start locations with remembered set.\n+  \/\/ This is used by old-gen GC following concurrent marking to make old-gen HeapRegions parsable. Old regions must be\n+  \/\/ parsable because the mark bitmap is not reliable during the concurrent old mark.\n+  \/\/ Return true iff region is completely coalesced and filled.  Returns false if cancelled before task is complete.\n+  bool oop_coalesce_and_fill(bool cancellable);\n+\n+  \/\/ Invoke closure on every reference contained within the humongous object that spans this humongous\n+  \/\/ region if the reference is contained within a DIRTY card and the reference is no more than words following\n+  \/\/ start within the humongous object.\n+  void oop_iterate_humongous_slice_dirty(OopIterateClosure* cl, HeapWord* start, size_t words, bool write_table) const;\n+\n+  \/\/ Invoke closure on every reference contained within the humongous object starting from start and\n+  \/\/ ending at start + words.\n+  void oop_iterate_humongous_slice_all(OopIterateClosure* cl, HeapWord* start, size_t words) const;\n@@ -372,0 +430,1 @@\n+  size_t used_before_promote() const { return byte_size(bottom(), get_top_before_promote()); }\n@@ -374,0 +433,5 @@\n+  \/\/ Does this region contain this address?\n+  bool contains(HeapWord* p) const {\n+    return (bottom() <= p) && (p < top());\n+  }\n+\n@@ -379,0 +443,1 @@\n+  size_t get_plab_allocs() const;\n@@ -384,0 +449,24 @@\n+  inline ShenandoahAffiliation affiliation() const;\n+  inline const char* affiliation_name() const;\n+\n+  void set_affiliation(ShenandoahAffiliation new_affiliation);\n+\n+  \/\/ Region ageing and rejuvenation\n+  uint age() const { return _age; }\n+  CENSUS_NOISE(uint youth() const { return _youth; })\n+\n+  void increment_age() {\n+    const uint max_age = markWord::max_age;\n+    assert(_age <= max_age, \"Error\");\n+    if (_age++ >= max_age) {\n+      _age = max_age;   \/\/ clamp\n+    }\n+  }\n+\n+  void reset_age() {\n+    CENSUS_NOISE(_youth += _age;)\n+    _age = 0;\n+  }\n+\n+  CENSUS_NOISE(void clear_youth() { _youth = 0; })\n+\n@@ -385,0 +474,1 @@\n+  void decrement_humongous_waste() const;\n@@ -388,3 +478,0 @@\n-  void oop_iterate_objects(OopIterateClosure* cl);\n-  void oop_iterate_humongous(OopIterateClosure* cl);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":96,"deletions":9,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -29,1 +31,0 @@\n-\n@@ -31,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -34,1 +36,54 @@\n-HeapWord* ShenandoahHeapRegion::allocate(size_t size, ShenandoahAllocRequest::Type type) {\n+HeapWord* ShenandoahHeapRegion::allocate_aligned(size_t size, ShenandoahAllocRequest &req, size_t alignment_in_bytes) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(req.is_lab_alloc(), \"allocate_aligned() only applies to LAB allocations\");\n+  assert(is_object_aligned(size), \"alloc size breaks alignment: \" SIZE_FORMAT, size);\n+  assert(is_old(), \"aligned allocations are only taken from OLD regions to support PLABs\");\n+  assert(is_aligned(alignment_in_bytes, HeapWordSize), \"Expect heap word alignment\");\n+\n+  HeapWord* orig_top = top();\n+  size_t alignment_in_words = alignment_in_bytes \/ HeapWordSize;\n+\n+  \/\/ unalignment_words is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n+  \/\/ from alignment_in_words to determine padding required to next alignment point.\n+\n+  HeapWord* aligned_obj = (HeapWord*) align_up(orig_top, alignment_in_bytes);\n+  size_t pad_words = aligned_obj - orig_top;\n+  if ((pad_words > 0) && (pad_words < ShenandoahHeap::min_fill_size())) {\n+    pad_words += alignment_in_words;\n+    aligned_obj += alignment_in_words;\n+  }\n+\n+  if (pointer_delta(end(), aligned_obj) < size) {\n+    \/\/ Shrink size to fit within available space and align it\n+    size = pointer_delta(end(), aligned_obj);\n+    size = align_down(size, alignment_in_words);\n+  }\n+\n+  \/\/ Both originally requested size and adjusted size must be properly aligned\n+  assert (is_aligned(size, alignment_in_words), \"Size must be multiple of alignment constraint\");\n+  if (size >= req.min_size()) {\n+    \/\/ Even if req.min_size() may not be a multiple of card size, we know that size is.\n+    if (pad_words > 0) {\n+      assert(pad_words >= ShenandoahHeap::min_fill_size(), \"pad_words expanded above to meet size constraint\");\n+      ShenandoahHeap::fill_with_object(orig_top, pad_words);\n+      ShenandoahGenerationalHeap::heap()->old_generation()->card_scan()->register_object(orig_top);\n+    }\n+\n+    make_regular_allocation(req.affiliation());\n+    adjust_alloc_metadata(req.type(), size);\n+\n+    HeapWord* new_top = aligned_obj + size;\n+    assert(new_top <= end(), \"PLAB cannot span end of heap region\");\n+    set_top(new_top);\n+    \/\/ We do not req.set_actual_size() here.  The caller sets it.\n+    req.set_waste(pad_words);\n+    assert(is_object_aligned(new_top), \"new top breaks alignment: \" PTR_FORMAT, p2i(new_top));\n+    assert(is_aligned(aligned_obj, alignment_in_bytes), \"obj is not aligned: \" PTR_FORMAT, p2i(aligned_obj));\n+    return aligned_obj;\n+  } else {\n+    \/\/ The aligned size that fits in this region is smaller than min_size, so don't align top and don't allocate.  Return failure.\n+    return nullptr;\n+  }\n+}\n+\n+HeapWord* ShenandoahHeapRegion::allocate(size_t size, const ShenandoahAllocRequest& req) {\n@@ -40,2 +95,2 @@\n-    make_regular_allocation();\n-    adjust_alloc_metadata(type, size);\n+    make_regular_allocation(req.affiliation());\n+    adjust_alloc_metadata(req.type(), size);\n@@ -67,0 +122,3 @@\n+    case ShenandoahAllocRequest::_alloc_plab:\n+      _plab_allocs += size;\n+      break;\n@@ -85,6 +143,0 @@\n-#ifdef ASSERT\n-  size_t live_bytes = new_live_data * HeapWordSize;\n-  size_t used_bytes = used();\n-  assert(live_bytes <= used_bytes,\n-         \"can't have more live data than used: \" SIZE_FORMAT \", \" SIZE_FORMAT, live_bytes, used_bytes);\n-#endif\n@@ -118,0 +170,11 @@\n+inline size_t ShenandoahHeapRegion::garbage_before_padded_for_promote() const {\n+  assert(get_top_before_promote() != nullptr, \"top before promote should not equal null\");\n+  size_t used_before_promote = byte_size(bottom(), get_top_before_promote());\n+  assert(used_before_promote >= get_live_data_bytes(),\n+         \"Live Data must be a subset of used before promotion live: \" SIZE_FORMAT \" used: \" SIZE_FORMAT,\n+         get_live_data_bytes(), used_before_promote);\n+  size_t result = used_before_promote - get_live_data_bytes();\n+  return result;\n+\n+}\n+\n@@ -136,0 +199,30 @@\n+inline ShenandoahAffiliation ShenandoahHeapRegion::affiliation() const {\n+  return ShenandoahHeap::heap()->region_affiliation(this);\n+}\n+\n+inline const char* ShenandoahHeapRegion::affiliation_name() const {\n+  return shenandoah_affiliation_name(affiliation());\n+}\n+\n+inline bool ShenandoahHeapRegion::is_young() const {\n+  return affiliation() == YOUNG_GENERATION;\n+}\n+\n+inline bool ShenandoahHeapRegion::is_old() const {\n+  return affiliation() == OLD_GENERATION;\n+}\n+\n+inline bool ShenandoahHeapRegion::is_affiliated() const {\n+  return affiliation() != FREE;\n+}\n+\n+inline void ShenandoahHeapRegion::save_top_before_promote() {\n+  _top_before_promoted = _top;\n+}\n+\n+inline void ShenandoahHeapRegion::restore_top_before_promote() {\n+  _top = _top_before_promoted;\n+  _top_before_promoted = nullptr;\n+ }\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":103,"deletions":10,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+ShenandoahSynchronizePinnedRegionStates::ShenandoahSynchronizePinnedRegionStates() :\n+  _lock(ShenandoahHeap::heap()->lock()) { }\n+\n+void ShenandoahSynchronizePinnedRegionStates::heap_region_do(ShenandoahHeapRegion* r) {\n+  \/\/ Drop \"pinned\" state from regions that no longer have a pinned count. Put\n+  \/\/ regions with a pinned count into the \"pinned\" state.\n+  if (r->is_active()) {\n+    synchronize_pin_count(r);\n+  }\n+}\n+\n+void ShenandoahSynchronizePinnedRegionStates::synchronize_pin_count(ShenandoahHeapRegion* r) {\n+  if (r->is_pinned()) {\n+    if (r->pin_count() == 0) {\n+      ShenandoahHeapLocker locker(_lock);\n+      r->make_unpinned();\n+    }\n+  } else {\n+    if (r->pin_count() > 0) {\n+      ShenandoahHeapLocker locker(_lock);\n+      r->make_pinned();\n+    }\n+  }\n+}\n+\n+ShenandoahFinalMarkUpdateRegionStateClosure::ShenandoahFinalMarkUpdateRegionStateClosure(ShenandoahMarkingContext *ctx) :\n+        _ctx(ctx) { }\n+\n+void ShenandoahFinalMarkUpdateRegionStateClosure::heap_region_do(ShenandoahHeapRegion* r) {\n+  if (r->is_active()) {\n+    if (_ctx != nullptr) {\n+      \/\/ _ctx may be null when this closure is used to sync only the pin status\n+      \/\/ update the watermark of old regions. For old regions we cannot reset\n+      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n+      \/\/ old marking is complete.\n+\n+      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n+      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n+      HeapWord *tams = _ctx->top_at_mark_start(r);\n+      HeapWord *top = r->top();\n+      if (top > tams) {\n+        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n+      }\n+    }\n+\n+    \/\/ We are about to select the collection set, make sure it knows about\n+    \/\/ current pinning status. Also, this allows trashing more regions that\n+    \/\/ now have their pinning status dropped.\n+    _pins.synchronize_pin_count(r);\n+\n+    \/\/ Remember limit for updating refs. It's guaranteed that we get no\n+    \/\/ from-space-refs written from here on.\n+    r->set_update_watermark_at_safepoint(r->top());\n+  } else {\n+    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n+    assert(_ctx == nullptr || _ctx->top_at_mark_start(r) == r->top(),\n+           \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n+\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+\n+\/\/ Applies the given closure to all regions with the given affiliation\n+template<ShenandoahAffiliation AFFILIATION>\n+class ShenandoahIncludeRegionClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapRegionClosure* _closure;\n+\n+public:\n+  explicit ShenandoahIncludeRegionClosure(ShenandoahHeapRegionClosure* closure): _closure(closure) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->affiliation() == AFFILIATION) {\n+      _closure->heap_region_do(r);\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return _closure->is_thread_safe();\n+  }\n+};\n+\n+\/\/ Applies the given closure to all regions without the given affiliation\n+template<ShenandoahAffiliation AFFILIATION>\n+class ShenandoahExcludeRegionClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapRegionClosure* _closure;\n+\n+public:\n+  explicit ShenandoahExcludeRegionClosure(ShenandoahHeapRegionClosure* closure): _closure(closure) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->affiliation() != AFFILIATION) {\n+      _closure->heap_region_do(r);\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return _closure->is_thread_safe();\n+  }\n+};\n+\n+\/\/ Makes regions pinned or unpinned according to the region's pin count\n+class ShenandoahSynchronizePinnedRegionStates : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapLock* const _lock;\n+\n+public:\n+  ShenandoahSynchronizePinnedRegionStates();\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override;\n+  bool is_thread_safe() override { return true; }\n+\n+  void synchronize_pin_count(ShenandoahHeapRegion* r);\n+};\n+\n+class ShenandoahMarkingContext;\n+\n+\/\/ Synchronizes region pinned status, sets update watermark and adjust live data tally for regions\n+class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+  ShenandoahSynchronizePinnedRegionStates _pins;\n+public:\n+  explicit ShenandoahFinalMarkUpdateRegionStateClosure(ShenandoahMarkingContext* ctx);\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override;\n+  bool is_thread_safe() override { return true; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,0 +27,2 @@\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -30,0 +33,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -33,0 +37,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -52,0 +57,3 @@\n+    cname = PerfDataManager::counter_name(_name_space, \"protocol_version\");\n+    PerfDataManager::create_constant(SUN_GC, cname, PerfData::U_None, VERSION_NUMBER, CHECK);\n+\n@@ -60,0 +68,1 @@\n+    \/\/ Initializing performance data resources for each region\n@@ -66,2 +75,1 @@\n-      _regions_data[i] = PerfDataManager::create_long_variable(SUN_GC, data_name,\n-                                                               PerfData::U_None, CHECK);\n+      _regions_data[i] = PerfDataManager::create_long_variable(SUN_GC, data_name, PerfData::U_None, CHECK);\n@@ -76,0 +84,22 @@\n+void ShenandoahHeapRegionCounters::write_snapshot(PerfLongVariable** regions,\n+                                             PerfLongVariable* ts,\n+                                             PerfLongVariable* status,\n+                                             size_t num_regions,\n+                                             size_t region_size, size_t protocol_version) {\n+  LogTarget(Trace, gc, region) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+\n+    ls.print_cr(JLONG_FORMAT \" \" JLONG_FORMAT \" \" SIZE_FORMAT \" \" SIZE_FORMAT \" \" SIZE_FORMAT,\n+            ts->get_value(), status->get_value(), num_regions, region_size, protocol_version);\n+    if (num_regions > 0) {\n+      ls.print(JLONG_FORMAT, regions[0]->get_value());\n+    }\n+    for (uint i = 1; i < num_regions; ++i) {\n+      ls.print(\" \" JLONG_FORMAT, regions[i]->get_value());\n+    }\n+    ls.cr();\n+  }\n+}\n+\n@@ -80,2 +110,1 @@\n-    if (current - last > ShenandoahRegionSamplingRate &&\n-            Atomic::cmpxchg(&_last_sample_millis, last, current) == last) {\n+    if (current - last > ShenandoahRegionSamplingRate && Atomic::cmpxchg(&_last_sample_millis, last, current) == last) {\n@@ -84,6 +113,1 @@\n-      jlong status = 0;\n-      if (heap->is_concurrent_mark_in_progress())      status |= 1 << 0;\n-      if (heap->is_evacuation_in_progress())           status |= 1 << 1;\n-      if (heap->is_update_refs_in_progress())          status |= 1 << 2;\n-      _status->set_value(status);\n-\n+      _status->set_value(encode_heap_status(heap));\n@@ -92,2 +116,0 @@\n-      size_t num_regions = heap->num_regions();\n-\n@@ -97,0 +119,1 @@\n+        size_t num_regions = heap->num_regions();\n@@ -104,0 +127,1 @@\n+          data |= ((100 * r->get_plab_allocs() \/ rs)     & PERCENT_MASK) << PLAB_SHIFT;\n@@ -105,0 +129,3 @@\n+\n+          data |= (r->age() & AGE_MASK) << AGE_SHIFT;\n+          data |= (r->affiliation() & AFFILIATION_MASK) << AFFILIATION_SHIFT;\n@@ -108,0 +135,3 @@\n+\n+        \/\/ If logging enabled, dump current region snapshot to log file\n+        write_snapshot(_regions_data, _timestamp, _status, num_regions, rs >> 10, VERSION_NUMBER);\n@@ -109,0 +139,3 @@\n+    }\n+  }\n+}\n@@ -110,0 +143,46 @@\n+static int encode_phase(ShenandoahHeap* heap) {\n+  if (heap->is_evacuation_in_progress() || heap->is_full_gc_move_in_progress()) {\n+    return 2;\n+  }\n+  if (heap->is_update_refs_in_progress() || heap->is_full_gc_move_in_progress()) {\n+    return 3;\n+  }\n+  if (heap->is_concurrent_mark_in_progress() || heap->is_full_gc_in_progress()) {\n+    return 1;\n+  }\n+  assert(heap->is_idle(), \"What is it doing?\");\n+  return 0;\n+}\n+\n+static int get_generation_shift(ShenandoahGeneration* generation) {\n+  switch (generation->type()) {\n+    case NON_GEN:\n+    case GLOBAL:\n+      return 0;\n+    case OLD:\n+      return 2;\n+    case YOUNG:\n+      return 4;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n+jlong ShenandoahHeapRegionCounters::encode_heap_status(ShenandoahHeap* heap) {\n+\n+  if (heap->is_idle() && !heap->is_full_gc_in_progress()) {\n+    return 0;\n+  }\n+\n+  jlong status = 0;\n+  if (!heap->mode()->is_generational()) {\n+    status = encode_phase(heap);\n+  } else {\n+    int phase = encode_phase(heap);\n+    ShenandoahGeneration* generation = heap->active_generation();\n+    assert(generation != nullptr, \"Expected active generation in this mode.\");\n+    int shift = get_generation_shift(generation);\n+    status |= ((phase & 0x3) << shift);\n+    if (heap->is_concurrent_old_mark_in_progress()) {\n+      status |= (1 << 2);\n@@ -111,0 +190,2 @@\n+    log_develop_trace(gc)(\"%s, phase=%u, old_mark=%s, status=\" JLONG_FORMAT,\n+                          generation->name(), phase, BOOL_TO_STR(heap->is_concurrent_old_mark_in_progress()), status);\n@@ -112,0 +193,9 @@\n+\n+  if (heap->is_degenerated_gc_in_progress()) {\n+    status |= (1 << 6);\n+  }\n+  if (heap->is_full_gc_in_progress()) {\n+    status |= (1 << 7);\n+  }\n+\n+  return status;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":102,"deletions":12,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,1 @@\n+#include \"logging\/logFileStreamOutput.hpp\"\n@@ -40,3 +42,8 @@\n- *     - bit 0 set when marking in progress\n- *     - bit 1 set when evacuation in progress\n- *     - bit 2 set when update refs in progress\n+ *   | global | old   | young | mode |\n+ *   |  0..1  | 2..3  | 4..5  | 6..7 |\n+ *\n+ *   For each generation:\n+ *   0 = idle, 1 = marking, 2 = evacuating, 3 = updating refs\n+ *\n+ *   For mode:\n+ *   0 = concurrent, 1 = degenerated, 2 = full\n@@ -54,1 +61,1 @@\n- * - bits 35-41  <reserved>\n+ * - bits 35-41  plab allocated memory in percent\n@@ -56,1 +63,2 @@\n- * - bits 51-57  <reserved>\n+ * - bits 51-55  age\n+ * - bits 56-57  affiliation: 0 = free, young = 1, old = 2\n@@ -62,2 +70,4 @@\n-  static const jlong PERCENT_MASK = 0x7f;\n-  static const jlong STATUS_MASK  = 0x3f;\n+  static const jlong PERCENT_MASK      = 0x7f;\n+  static const jlong AGE_MASK          = 0x1f;\n+  static const jlong AFFILIATION_MASK  = 0x03;\n+  static const jlong STATUS_MASK       = 0x3f;\n@@ -65,5 +75,9 @@\n-  static const jlong USED_SHIFT   = 0;\n-  static const jlong LIVE_SHIFT   = 7;\n-  static const jlong TLAB_SHIFT   = 14;\n-  static const jlong GCLAB_SHIFT  = 21;\n-  static const jlong SHARED_SHIFT = 28;\n+  static const jlong USED_SHIFT        = 0;\n+  static const jlong LIVE_SHIFT        = 7;\n+  static const jlong TLAB_SHIFT        = 14;\n+  static const jlong GCLAB_SHIFT       = 21;\n+  static const jlong SHARED_SHIFT      = 28;\n+  static const jlong PLAB_SHIFT        = 35;\n+  static const jlong AGE_SHIFT         = 51;\n+  static const jlong AFFILIATION_SHIFT = 56;\n+  static const jlong STATUS_SHIFT      = 58;\n@@ -71,1 +85,1 @@\n-  static const jlong STATUS_SHIFT = 58;\n+  static const jlong VERSION_NUMBER    = 2;\n@@ -79,0 +93,6 @@\n+  void write_snapshot(PerfLongVariable** regions,\n+                      PerfLongVariable* ts,\n+                      PerfLongVariable* status,\n+                      size_t num_regions,\n+                      size_t region_size, size_t protocolVersion);\n+\n@@ -83,0 +103,3 @@\n+\n+private:\n+  static jlong encode_heap_status(ShenandoahHeap* heap) ;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.hpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -36,4 +38,0 @@\n-ShenandoahMark::ShenandoahMark() :\n-  _task_queues(ShenandoahHeap::heap()->marking_context()->task_queues()) {\n-}\n-\n@@ -49,1 +47,3 @@\n-  CodeCache::on_gc_marking_cycle_finish();\n+  if (!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress()) {\n+    CodeCache::on_gc_marking_cycle_finish();\n+  }\n@@ -52,7 +52,4 @@\n-void ShenandoahMark::clear() {\n-  \/\/ Clean up marking stacks.\n-  ShenandoahObjToScanQueueSet* queues = ShenandoahHeap::heap()->marking_context()->task_queues();\n-  queues->clear();\n-\n-  \/\/ Cancel SATB buffers.\n-  ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n+ShenandoahMark::ShenandoahMark(ShenandoahGeneration* generation) :\n+  _generation(generation),\n+  _task_queues(generation->task_queues()),\n+  _old_gen_task_queues(generation->old_gen_task_queues()) {\n@@ -62,1 +59,1 @@\n-void ShenandoahMark::mark_loop_prework(uint w, TaskTerminator *t, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req) {\n+void ShenandoahMark::mark_loop_prework(uint w, TaskTerminator *t, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req, bool update_refs) {\n@@ -64,0 +61,1 @@\n+  ShenandoahObjToScanQueue* old_q = get_old_queue(w);\n@@ -70,1 +68,1 @@\n-  if (heap->has_forwarded_objects()) {\n+  if (update_refs) {\n@@ -72,1 +70,1 @@\n-    Closure cl(q, rp);\n+    Closure cl(q, rp, old_q);\n@@ -76,1 +74,1 @@\n-    Closure cl(q, rp);\n+    Closure cl(q, rp, old_q);\n@@ -86,1 +84,19 @@\n-  mark_loop_prework<NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req);\n+  bool update_refs = ShenandoahHeap::heap()->has_forwarded_objects();\n+  switch (generation) {\n+    case YOUNG:\n+      mark_loop_prework<YOUNG, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+      break;\n+    case OLD:\n+      \/\/ Old generation collection only performs marking, it should not update references.\n+      mark_loop_prework<OLD, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, false);\n+      break;\n+    case GLOBAL:\n+      mark_loop_prework<GLOBAL, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+      break;\n+    case NON_GEN:\n+      mark_loop_prework<NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+  }\n@@ -90,2 +106,1 @@\n-                               ShenandoahGenerationType generation, bool cancellable,  StringDedupMode dedup_mode,\n-                               StringDedup::Requests* const req) {\n+                               ShenandoahGenerationType generation, bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req) {\n@@ -128,1 +143,6 @@\n-  heap->ref_processor()->set_mark_closure(worker_id, cl);\n+  \/\/ Do not use active_generation() : we must use the gc_generation() set by\n+  \/\/ ShenandoahGCScope on the ControllerThread's stack; no safepoint may\n+  \/\/ intervene to update active_generation, so we can't\n+  \/\/ shenandoah_assert_generations_reconciled() here.\n+  assert(heap->gc_generation()->type() == GENERATION, \"Sanity: %d != %d\", heap->gc_generation()->type(), GENERATION);\n+  heap->gc_generation()->ref_processor()->set_mark_closure(worker_id, cl);\n@@ -148,1 +168,1 @@\n-        do_task<T, GENERATION, STRING_DEDUP>(q, cl, live_data, req, &t);\n+        do_task<T, GENERATION, STRING_DEDUP>(q, cl, live_data, req, &t, worker_id);\n@@ -157,0 +177,1 @@\n+  ShenandoahObjToScanQueue* old_q = get_old_queue(worker_id);\n@@ -158,1 +179,1 @@\n-  ShenandoahSATBBufferClosure<GENERATION> drain_satb(q);\n+  ShenandoahSATBBufferClosure<GENERATION> drain_satb(q, old_q);\n@@ -168,1 +189,0 @@\n-\n@@ -177,1 +197,1 @@\n-        do_task<T, GENERATION, STRING_DEDUP>(q, cl, live_data, req, &t);\n+        do_task<T, GENERATION, STRING_DEDUP>(q, cl, live_data, req, &t, worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shared\/ageTable.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -48,0 +51,1 @@\n+  ShenandoahGeneration* const _generation;\n@@ -49,0 +53,1 @@\n+  ShenandoahObjToScanQueueSet* const _old_gen_task_queues;\n@@ -51,1 +56,1 @@\n-  ShenandoahMark();\n+  ShenandoahMark(ShenandoahGeneration* generation);\n@@ -55,3 +60,1 @@\n-  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n-\n-  static void clear();\n+  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak);\n@@ -65,0 +68,4 @@\n+  ShenandoahObjToScanQueueSet* old_task_queues() {\n+    return _old_gen_task_queues;\n+  }\n+\n@@ -66,0 +73,3 @@\n+  inline ShenandoahObjToScanQueue* get_old_queue(uint index) const;\n+\n+  inline ShenandoahGeneration* generation() { return _generation; };\n@@ -67,1 +77,0 @@\n-\/\/ ---------- Marking loop and tasks\n@@ -69,0 +78,2 @@\n+\/\/ ---------- Marking loop and tasks\n+\n@@ -70,1 +81,1 @@\n-  inline void do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task);\n+  inline void do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task, uint worker_id);\n@@ -79,1 +90,1 @@\n-  inline void count_liveness(ShenandoahLiveData* live_data, oop obj);\n+  inline void count_liveness(ShenandoahLiveData* live_data, oop obj, uint worker_id);\n@@ -85,1 +96,11 @@\n-  void mark_loop_prework(uint worker_id, TaskTerminator *terminator, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req);\n+  void mark_loop_prework(uint worker_id, TaskTerminator *terminator, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req, bool update_refs);\n+\n+  template <ShenandoahGenerationType GENERATION>\n+  static bool in_generation(ShenandoahHeap* const heap, oop obj);\n+\n+  template <class T>\n+  static void mark_non_generational_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n+\n+  static void mark_ref(ShenandoahObjToScanQueue* q,\n+                       ShenandoahMarkingContext* const mark_context,\n+                       bool weak, oop obj);\n@@ -93,0 +114,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -36,0 +38,2 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -61,1 +65,1 @@\n-void ShenandoahMark::do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task) {\n+void ShenandoahMark::do_task(ShenandoahObjToScanQueue* q, T* cl, ShenandoahLiveData* live_data, StringDedup::Requests* const req, ShenandoahMarkTask* task, uint worker_id) {\n@@ -98,1 +102,1 @@\n-      count_liveness<GENERATION>(live_data, obj);\n+      count_liveness<GENERATION>(live_data, obj, worker_id);\n@@ -107,5 +111,17 @@\n-inline void ShenandoahMark::count_liveness(ShenandoahLiveData* live_data, oop obj) {\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  size_t region_idx = heap->heap_region_index_containing(obj);\n-  ShenandoahHeapRegion* region = heap->get_region(region_idx);\n-  size_t size = obj->size();\n+inline void ShenandoahMark::count_liveness(ShenandoahLiveData* live_data, oop obj, uint worker_id) {\n+  const ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  const size_t region_idx = heap->heap_region_index_containing(obj);\n+  ShenandoahHeapRegion* const region = heap->get_region(region_idx);\n+  const size_t size = obj->size();\n+\n+  \/\/ Age census for objects in the young generation\n+  if (GENERATION == YOUNG || (GENERATION == GLOBAL && region->is_young())) {\n+    assert(heap->mode()->is_generational(), \"Only if generational\");\n+    if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+      assert(region->is_young(), \"Only for young objects\");\n+      uint age = ShenandoahHeap::get_object_age(obj);\n+      ShenandoahAgeCensus* const census = ShenandoahGenerationalHeap::heap()->age_census();\n+      CENSUS_NOISE(census->add(age, region->age(), region->youth(), size, worker_id);)\n+      NO_CENSUS_NOISE(census->add(age, region->age(), size, worker_id);)\n+    }\n+  }\n@@ -115,0 +131,1 @@\n+    assert(region->is_affiliated(), \"Do not count live data within Free Regular Region \" SIZE_FORMAT, region_idx);\n@@ -129,0 +146,1 @@\n+    assert(region->is_affiliated(), \"Do not count live data within FREE Humongous Start Region \" SIZE_FORMAT, region_idx);\n@@ -132,0 +150,1 @@\n+      assert(chain_reg->is_affiliated(), \"Do not count live data within FREE Humongous Continuation Region \" SIZE_FORMAT, i);\n@@ -238,0 +257,1 @@\n+  ShenandoahObjToScanQueue* _old_queue;\n@@ -241,1 +261,1 @@\n-  ShenandoahSATBBufferClosure(ShenandoahObjToScanQueue* q) :\n+  ShenandoahSATBBufferClosure(ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q) :\n@@ -243,0 +263,1 @@\n+    _old_queue(old_q),\n@@ -249,1 +270,1 @@\n-    assert(size == 0 || !_heap->has_forwarded_objects(), \"Forwarded objects are not expected here\");\n+    assert(size == 0 || !_heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded objects are not expected here\");\n@@ -252,1 +273,1 @@\n-      ShenandoahMark::mark_through_ref<oop, GENERATION>(p, _queue, _mark_context, false);\n+      ShenandoahMark::mark_through_ref<oop, GENERATION>(p, _queue, _old_queue, _mark_context, false);\n@@ -257,0 +278,16 @@\n+template<ShenandoahGenerationType GENERATION>\n+bool ShenandoahMark::in_generation(ShenandoahHeap* const heap, oop obj) {\n+  \/\/ Each in-line expansion of in_generation() resolves GENERATION at compile time.\n+  if (GENERATION == YOUNG) {\n+    return heap->is_in_young(obj);\n+  }\n+\n+  if (GENERATION == OLD) {\n+    return heap->is_in_old(obj);\n+  }\n+\n+  assert((GENERATION == GLOBAL || GENERATION == NON_GEN), \"Unexpected generation type\");\n+  assert(heap->is_in(obj), \"Object must be in heap\");\n+  return true;\n+}\n+\n@@ -258,1 +295,4 @@\n-inline void ShenandoahMark::mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+inline void ShenandoahMark::mark_through_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+  \/\/ Note: This is a very hot code path, so the code should be conditional on GENERATION template\n+  \/\/ parameter where possible, in order to generate the most efficient code.\n+\n@@ -263,0 +303,44 @@\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    shenandoah_assert_not_forwarded(p, obj);\n+    shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n+    if (in_generation<GENERATION>(heap, obj)) {\n+      mark_ref(q, mark_context, weak, obj);\n+      shenandoah_assert_marked(p, obj);\n+      if (GENERATION == YOUNG && heap->is_in_old(p)) {\n+        \/\/ Mark card as dirty because remembered set scanning still finds interesting pointer.\n+        heap->old_generation()->mark_card_as_dirty((HeapWord*)p);\n+      } else if (GENERATION == GLOBAL && heap->is_in_old(p) && heap->is_in_young(obj)) {\n+        \/\/ Mark card as dirty because GLOBAL marking finds interesting pointer.\n+        heap->old_generation()->mark_card_as_dirty((HeapWord*)p);\n+      }\n+    } else if (old_q != nullptr) {\n+      \/\/ Young mark, bootstrapping old_q or concurrent with old_q marking.\n+      mark_ref(old_q, mark_context, weak, obj);\n+      shenandoah_assert_marked(p, obj);\n+    } else if (GENERATION == OLD) {\n+      \/\/ Old mark, found a young pointer.\n+      if (heap->is_in(p)) {\n+        assert(heap->is_in_young(obj), \"Expected young object.\");\n+        heap->old_generation()->mark_card_as_dirty(p);\n+      }\n+    }\n+  }\n+}\n+\n+template<>\n+inline void ShenandoahMark::mark_through_ref<oop, ShenandoahGenerationType::NON_GEN>(oop *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+  mark_non_generational_ref(p, q, mark_context, weak);\n+}\n+\n+template<>\n+inline void ShenandoahMark::mark_through_ref<narrowOop, ShenandoahGenerationType::NON_GEN>(narrowOop *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+  mark_non_generational_ref(p, q, mark_context, weak);\n+}\n+\n+template<class T>\n+inline void ShenandoahMark::mark_non_generational_ref(T* p, ShenandoahObjToScanQueue* q,\n+                                                      ShenandoahMarkingContext* const mark_context, bool weak) {\n+  oop o = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(o)) {\n+    oop obj = CompressedOops::decode_not_null(o);\n+\n@@ -266,11 +350,1 @@\n-    bool skip_live = false;\n-    bool marked;\n-    if (weak) {\n-      marked = mark_context->mark_weak(obj);\n-    } else {\n-      marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n-    }\n-    if (marked) {\n-      bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n-      assert(pushed, \"overflow queue should always succeed pushing\");\n-    }\n+    mark_ref(q, mark_context, weak, obj);\n@@ -282,0 +356,16 @@\n+inline void ShenandoahMark::mark_ref(ShenandoahObjToScanQueue* q,\n+                              ShenandoahMarkingContext* const mark_context,\n+                              bool weak, oop obj) {\n+  bool skip_live = false;\n+  bool marked;\n+  if (weak) {\n+    marked = mark_context->mark_weak(obj);\n+  } else {\n+    marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n+  }\n+  if (marked) {\n+    bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n+    assert(pushed, \"overflow queue should always succeed pushing\");\n+  }\n+}\n+\n@@ -289,0 +379,8 @@\n+\n+ShenandoahObjToScanQueue* ShenandoahMark::get_old_queue(uint index) const {\n+  if (_old_gen_task_queues != nullptr) {\n+    return _old_gen_task_queues->queue(index);\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":120,"deletions":22,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -46,0 +47,14 @@\n+bool ShenandoahMarkBitMap::is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const {\n+  \/\/ Similar to get_next_marked_addr(), without assertion.\n+  \/\/ Round addr up to a possible object boundary to be safe.\n+  if (start == end) {\n+    return true;\n+  }\n+  size_t const addr_offset = address_to_index(align_up(start, HeapWordSize << LogMinObjAlignment));\n+  size_t const limit_offset = address_to_index(end);\n+  size_t const next_offset = get_next_one_offset(addr_offset, limit_offset);\n+  HeapWord* result = index_to_address(next_offset);\n+  return (result == end);\n+}\n+\n+\n@@ -48,0 +63,5 @@\n+#ifdef ASSERT\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahHeapRegion* r = heap->heap_region_containing(addr);\n+  ShenandoahMarkingContext* ctx = heap->marking_context();\n+  HeapWord* tams = ctx->top_at_mark_start(r);\n@@ -49,0 +69,4 @@\n+  assert(limit <= r->top(), \"limit must be less than top\");\n+  assert(addr <= tams, \"addr must be less than TAMS\");\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -162,0 +163,2 @@\n+  bool is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n@@ -30,2 +30,0 @@\n-#include \"gc\/shenandoah\/shenandoahTaskqueue.inline.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n@@ -33,1 +31,1 @@\n-ShenandoahMarkingContext::ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions, uint max_queues) :\n+ShenandoahMarkingContext::ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions) :\n@@ -38,15 +36,1 @@\n-                      ((uintx) heap_region.start() >> ShenandoahHeapRegion::region_size_bytes_shift())),\n-  _task_queues(new ShenandoahObjToScanQueueSet(max_queues)) {\n-  assert(max_queues > 0, \"At least one queue\");\n-  for (uint i = 0; i < max_queues; ++i) {\n-    ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();\n-    _task_queues->register_queue(i, task_queue);\n-  }\n-}\n-\n-ShenandoahMarkingContext::~ShenandoahMarkingContext() {\n-  for (uint i = 0; i < _task_queues->size(); ++i) {\n-    ShenandoahObjToScanQueue* q = _task_queues->queue(i);\n-    delete q;\n-  }\n-  delete _task_queues;\n+                      ((uintx) heap_region.start() >> ShenandoahHeapRegion::region_size_bytes_shift())) {\n@@ -60,1 +44,2 @@\n-    if (heap->is_bitmap_slice_committed(r) && !is_bitmap_clear_range(r->bottom(), r->end())) {\n+    if (r->is_affiliated() && heap->is_bitmap_slice_committed(r)\n+        && !is_bitmap_range_within_region_clear(r->bottom(), r->end())) {\n@@ -67,2 +52,15 @@\n-bool ShenandoahMarkingContext::is_bitmap_clear_range(HeapWord* start, HeapWord* end) const {\n-  return _mark_bit_map.get_next_marked_addr(start, end) == end;\n+bool ShenandoahMarkingContext::is_bitmap_range_within_region_clear(const HeapWord* start, const HeapWord* end) const {\n+  assert(start <= end, \"Invalid start \" PTR_FORMAT \" and end \" PTR_FORMAT, p2i(start), p2i(end));\n+  if (start < end) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t start_idx = heap->heap_region_index_containing(start);\n+#ifdef ASSERT\n+    size_t end_idx = heap->heap_region_index_containing(end - 1);\n+    assert(start_idx == end_idx, \"Expected range to be within same region (\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", start_idx, end_idx);\n+#endif\n+    ShenandoahHeapRegion* r = heap->get_region(start_idx);\n+    if (!heap->is_bitmap_slice_committed(r)) {\n+      return true;\n+    }\n+  }\n+  return _mark_bit_map.is_bitmap_clear_range(start, end);\n@@ -74,0 +72,1 @@\n+\n@@ -76,0 +75,7 @@\n+\n+  log_debug(gc)(\"SMC:initialize_top_at_mark_start for Region \" SIZE_FORMAT \", TAMS: \" PTR_FORMAT \", TopOfBitMap: \" PTR_FORMAT,\n+                r->index(), p2i(bottom), p2i(r->end()));\n+}\n+\n+HeapWord* ShenandoahMarkingContext::top_bitmap(ShenandoahHeapRegion* r) {\n+  return _top_bitmaps[r->index()];\n@@ -81,0 +87,4 @@\n+\n+  log_debug(gc)(\"SMC:clear_bitmap for %s Region \" SIZE_FORMAT \", top_bitmap: \" PTR_FORMAT,\n+                r->affiliation_name(), r->index(), p2i(top_bitmap));\n+\n@@ -85,1 +95,2 @@\n-  assert(is_bitmap_clear_range(bottom, r->end()),\n+\n+  assert(is_bitmap_range_within_region_clear(bottom, r->end()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -35,0 +36,1 @@\n+class ShenandoahHeapRegion;\n@@ -50,3 +52,0 @@\n-  \/\/ Marking task queues\n-  ShenandoahObjToScanQueueSet* _task_queues;\n-\n@@ -54,2 +53,1 @@\n-  ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions, uint max_queues);\n-  ~ShenandoahMarkingContext();\n+  ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions);\n@@ -71,0 +69,2 @@\n+  inline bool is_marked_or_old(oop obj) const;\n+  inline bool is_marked_strong_or_old(oop obj) const;\n@@ -72,1 +72,1 @@\n-  inline HeapWord* get_next_marked_addr(HeapWord* addr, HeapWord* limit) const;\n+  inline HeapWord* get_next_marked_addr(const HeapWord* addr, const HeapWord* limit) const;\n@@ -74,2 +74,2 @@\n-  inline bool allocated_after_mark_start(oop obj) const;\n-  inline bool allocated_after_mark_start(HeapWord* addr) const;\n+  inline bool allocated_after_mark_start(const oop obj) const;\n+  inline bool allocated_after_mark_start(const HeapWord* addr) const;\n@@ -77,1 +77,1 @@\n-  inline HeapWord* top_at_mark_start(ShenandoahHeapRegion* r) const;\n+  inline HeapWord* top_at_mark_start(const ShenandoahHeapRegion* r) const;\n@@ -82,0 +82,2 @@\n+  HeapWord* top_bitmap(ShenandoahHeapRegion* r);\n+\n@@ -86,1 +88,1 @@\n-  bool is_bitmap_clear_range(HeapWord* start, HeapWord* end) const;\n+  bool is_bitmap_range_within_region_clear(const HeapWord* start, const HeapWord* end) const;\n@@ -91,3 +93,0 @@\n-\n-  \/\/ Task queues\n-  ShenandoahObjToScanQueueSet* task_queues() const { return _task_queues; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,1 +30,0 @@\n-\n@@ -31,0 +31,1 @@\n+#include \"logging\/log.hpp\"\n@@ -60,1 +61,9 @@\n-inline HeapWord* ShenandoahMarkingContext::get_next_marked_addr(HeapWord* start, HeapWord* limit) const {\n+inline bool ShenandoahMarkingContext::is_marked_or_old(oop obj) const {\n+  return is_marked(obj) || ShenandoahHeap::heap()->is_in_old_during_young_collection(obj);\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong_or_old(oop obj) const {\n+  return is_marked_strong(obj) || ShenandoahHeap::heap()->is_in_old_during_young_collection(obj);\n+}\n+\n+inline HeapWord* ShenandoahMarkingContext::get_next_marked_addr(const HeapWord* start, const HeapWord* limit) const {\n@@ -65,1 +74,1 @@\n-  HeapWord* addr = cast_from_oop<HeapWord*>(obj);\n+  const HeapWord* addr = cast_from_oop<HeapWord*>(obj);\n@@ -69,1 +78,1 @@\n-inline bool ShenandoahMarkingContext::allocated_after_mark_start(HeapWord* addr) const {\n+inline bool ShenandoahMarkingContext::allocated_after_mark_start(const HeapWord* addr) const {\n@@ -72,1 +81,1 @@\n-  bool alloc_after_mark_start = addr >= top_at_mark_start;\n+  const bool alloc_after_mark_start = addr >= top_at_mark_start;\n@@ -77,0 +86,5 @@\n+  if (!r->is_affiliated()) {\n+    \/\/ Non-affiliated regions do not need their TAMS updated\n+    return;\n+  }\n+\n@@ -84,1 +98,4 @@\n-  assert(is_bitmap_clear_range(old_tams, new_tams),\n+  assert((new_tams == r->bottom()) || (old_tams == r->bottom()) || (new_tams >= _top_bitmaps[idx]),\n+         \"Region \" SIZE_FORMAT\", top_bitmaps updates should be monotonic: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n+         idx, p2i(_top_bitmaps[idx]), p2i(new_tams));\n+  assert(old_tams == r->bottom() || is_bitmap_range_within_region_clear(old_tams, new_tams),\n@@ -88,0 +105,3 @@\n+  log_debug(gc)(\"Capturing TAMS for %s Region \" SIZE_FORMAT \", was: \" PTR_FORMAT \", now: \" PTR_FORMAT,\n+                r->affiliation_name(), idx, p2i(old_tams), p2i(new_tams));\n+\n@@ -96,1 +116,1 @@\n-inline HeapWord* ShenandoahMarkingContext::top_at_mark_start(ShenandoahHeapRegion* r) const {\n+inline HeapWord* ShenandoahMarkingContext::top_at_mark_start(const ShenandoahHeapRegion* r) const {\n@@ -101,1 +121,1 @@\n-  assert(is_bitmap_clear_range(r->bottom(), r->end()),\n+  assert(is_bitmap_range_within_region_clear(r->bottom(), r->end()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,2 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -28,2 +31,3 @@\n-ShenandoahMemoryPool::ShenandoahMemoryPool(ShenandoahHeap* heap) :\n-        CollectedMemoryPool(\"Shenandoah\",\n+ShenandoahMemoryPool::ShenandoahMemoryPool(ShenandoahHeap* heap,\n+                                           const char* name) :\n+        CollectedMemoryPool(name,\n@@ -35,0 +39,11 @@\n+ShenandoahMemoryPool::ShenandoahMemoryPool(ShenandoahHeap* heap,\n+                                           const char* name,\n+                                           size_t initial_capacity,\n+                                           size_t max_capacity) :\n+        CollectedMemoryPool(name,\n+                            initial_capacity,\n+                            max_capacity,\n+                            true \/* support_usage_threshold *\/),\n+                            _heap(heap) {}\n+\n+\n@@ -54,0 +69,41 @@\n+\n+size_t ShenandoahMemoryPool::used_in_bytes() {\n+  return _heap->used();\n+}\n+\n+size_t ShenandoahMemoryPool::max_size() const {\n+  return _heap->max_capacity();\n+}\n+\n+ShenandoahGenerationalMemoryPool::ShenandoahGenerationalMemoryPool(ShenandoahHeap* heap, const char* name,\n+                                                                   ShenandoahGeneration* generation) :\n+        ShenandoahMemoryPool(heap, name, 0, heap->max_capacity()),\n+        _generation(generation) { }\n+\n+MemoryUsage ShenandoahGenerationalMemoryPool::get_memory_usage() {\n+  size_t initial   = initial_size();\n+  size_t max       = max_size();\n+  size_t used      = used_in_bytes();\n+  size_t committed = _generation->used_regions_size();\n+\n+  return MemoryUsage(initial, used, committed, max);\n+}\n+\n+size_t ShenandoahGenerationalMemoryPool::used_in_bytes() {\n+  return _generation->used();\n+}\n+\n+size_t ShenandoahGenerationalMemoryPool::max_size() const {\n+  return _generation->max_capacity();\n+}\n+\n+\n+ShenandoahYoungGenMemoryPool::ShenandoahYoungGenMemoryPool(ShenandoahHeap* heap) :\n+        ShenandoahGenerationalMemoryPool(heap,\n+                             \"Shenandoah Young Gen\",\n+                             heap->young_generation()) { }\n+\n+ShenandoahOldGenMemoryPool::ShenandoahOldGenMemoryPool(ShenandoahHeap* heap) :\n+        ShenandoahGenerationalMemoryPool(heap,\n+                             \"Shenandoah Old Gen\",\n+                             heap->old_generation()) { }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.cpp","additions":58,"deletions":2,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,1 +29,0 @@\n-#ifndef SERIALGC\n@@ -32,1 +32,0 @@\n-#endif\n@@ -35,1 +34,1 @@\n-private:\n+protected:\n@@ -39,4 +38,31 @@\n-  ShenandoahMemoryPool(ShenandoahHeap* pool);\n-  MemoryUsage get_memory_usage();\n-  size_t used_in_bytes()              { return _heap->used(); }\n-  size_t max_size() const             { return _heap->max_capacity(); }\n+  explicit ShenandoahMemoryPool(ShenandoahHeap* heap,\n+                       const char* name = \"Shenandoah\");\n+  MemoryUsage get_memory_usage() override;\n+  size_t used_in_bytes() override;\n+  size_t max_size() const override;\n+\n+protected:\n+  ShenandoahMemoryPool(ShenandoahHeap* heap,\n+                       const char* name,\n+                       size_t initial_capacity,\n+                       size_t max_capacity);\n+};\n+\n+class ShenandoahGenerationalMemoryPool: public ShenandoahMemoryPool {\n+private:\n+  ShenandoahGeneration* _generation;\n+public:\n+  explicit ShenandoahGenerationalMemoryPool(ShenandoahHeap* heap, const char* name, ShenandoahGeneration* generation);\n+  MemoryUsage get_memory_usage() override;\n+  size_t used_in_bytes() override;\n+  size_t max_size() const override;\n+};\n+\n+class ShenandoahYoungGenMemoryPool : public ShenandoahGenerationalMemoryPool {\n+public:\n+  explicit ShenandoahYoungGenMemoryPool(ShenandoahHeap* heap);\n+};\n+\n+class ShenandoahOldGenMemoryPool : public ShenandoahGenerationalMemoryPool {\n+public:\n+  explicit ShenandoahOldGenMemoryPool(ShenandoahHeap* heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.hpp","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/task.hpp\"\n+\n+class ShenandoahMmuTask : public PeriodicTask {\n+  ShenandoahMmuTracker* _mmu_tracker;\n+public:\n+  explicit ShenandoahMmuTask(ShenandoahMmuTracker* mmu_tracker) :\n+    PeriodicTask(GCPauseIntervalMillis), _mmu_tracker(mmu_tracker) {}\n+\n+  void task() override {\n+    _mmu_tracker->report();\n+  }\n+};\n+\n+class ThreadTimeAccumulator : public ThreadClosure {\n+ public:\n+  size_t total_time;\n+  ThreadTimeAccumulator() : total_time(0) {}\n+  void do_thread(Thread* thread) override {\n+    total_time += os::thread_cpu_time(thread);\n+  }\n+};\n+\n+ShenandoahMmuTracker::ShenandoahMmuTracker() :\n+    _most_recent_timestamp(0.0),\n+    _most_recent_gc_time(0.0),\n+    _most_recent_gcu(0.0),\n+    _most_recent_mutator_time(0.0),\n+    _most_recent_mu(0.0),\n+    _most_recent_periodic_time_stamp(0.0),\n+    _most_recent_periodic_gc_time(0.0),\n+    _most_recent_periodic_mutator_time(0.0),\n+    _mmu_periodic_task(new ShenandoahMmuTask(this)) {\n+}\n+\n+ShenandoahMmuTracker::~ShenandoahMmuTracker() {\n+  _mmu_periodic_task->disenroll();\n+  delete _mmu_periodic_task;\n+}\n+\n+void ShenandoahMmuTracker::fetch_cpu_times(double &gc_time, double &mutator_time) {\n+  ThreadTimeAccumulator cl;\n+  \/\/ We include only the gc threads because those are the only threads\n+  \/\/ we are responsible for.\n+  ShenandoahHeap::heap()->gc_threads_do(&cl);\n+  double most_recent_gc_thread_time = double(cl.total_time) \/ NANOSECS_PER_SEC;\n+  gc_time = most_recent_gc_thread_time;\n+\n+  double process_real_time(0.0), process_user_time(0.0), process_system_time(0.0);\n+  bool valid = os::getTimesSecs(&process_real_time, &process_user_time, &process_system_time);\n+  assert(valid, \"don't know why this would not be valid\");\n+  mutator_time =(process_user_time + process_system_time) - most_recent_gc_thread_time;\n+}\n+\n+void ShenandoahMmuTracker::update_utilization(size_t gcid, const char* msg) {\n+  double current = os::elapsedTime();\n+  _most_recent_gcid = gcid;\n+  _most_recent_is_full = false;\n+\n+  if (gcid == 0) {\n+    fetch_cpu_times(_most_recent_gc_time, _most_recent_mutator_time);\n+\n+    _most_recent_timestamp = current;\n+  } else {\n+    double gc_cycle_period = current - _most_recent_timestamp;\n+    _most_recent_timestamp = current;\n+\n+    double gc_thread_time, mutator_thread_time;\n+    fetch_cpu_times(gc_thread_time, mutator_thread_time);\n+    double gc_time = gc_thread_time - _most_recent_gc_time;\n+    _most_recent_gc_time = gc_thread_time;\n+    _most_recent_gcu = gc_time \/ (_active_processors * gc_cycle_period);\n+    double mutator_time = mutator_thread_time - _most_recent_mutator_time;\n+    _most_recent_mutator_time = mutator_thread_time;\n+    _most_recent_mu = mutator_time \/ (_active_processors * gc_cycle_period);\n+    log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% during period of %.3fs\",\n+                       msg, _most_recent_gcu * 100, _most_recent_mu * 100, gc_cycle_period);\n+  }\n+}\n+\n+void ShenandoahMmuTracker::record_young(size_t gcid) {\n+  update_utilization(gcid, \"Concurrent Young GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_global(size_t gcid) {\n+  update_utilization(gcid, \"Concurrent Global GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_bootstrap(size_t gcid) {\n+  \/\/ Not likely that this will represent an \"ideal\" GCU, but doesn't hurt to try\n+  update_utilization(gcid, \"Concurrent Bootstrap GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_old_marking_increment(bool old_marking_done) {\n+  \/\/ No special processing for old marking\n+  double now = os::elapsedTime();\n+  double duration = now - _most_recent_timestamp;\n+\n+  double gc_time, mutator_time;\n+  fetch_cpu_times(gc_time, mutator_time);\n+  double gcu = (gc_time - _most_recent_gc_time) \/ duration;\n+  double mu = (mutator_time - _most_recent_mutator_time) \/ duration;\n+  log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% for duration %.3fs (totals to be subsumed in next gc report)\",\n+                     old_marking_done? \"last OLD marking increment\": \"OLD marking increment\",\n+                     gcu * 100, mu * 100, duration);\n+}\n+\n+void ShenandoahMmuTracker::record_mixed(size_t gcid) {\n+  update_utilization(gcid, \"Mixed Concurrent GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_degenerated(size_t gcid, bool is_old_bootstrap) {\n+  if ((gcid == _most_recent_gcid) && _most_recent_is_full) {\n+    \/\/ Do nothing.  This is a redundant recording for the full gc that just completed.\n+  } else if (is_old_bootstrap) {\n+    update_utilization(gcid, \"Degenerated Bootstrap Old GC\");\n+  } else {\n+    update_utilization(gcid, \"Degenerated Young GC\");\n+  }\n+}\n+\n+void ShenandoahMmuTracker::record_full(size_t gcid) {\n+  update_utilization(gcid, \"Full GC\");\n+  _most_recent_is_full = true;\n+}\n+\n+void ShenandoahMmuTracker::report() {\n+  \/\/ This is only called by the periodic thread.\n+  double current = os::elapsedTime();\n+  double time_delta = current - _most_recent_periodic_time_stamp;\n+  _most_recent_periodic_time_stamp = current;\n+\n+  double gc_time, mutator_time;\n+  fetch_cpu_times(gc_time, mutator_time);\n+\n+  double gc_delta = gc_time - _most_recent_periodic_gc_time;\n+  _most_recent_periodic_gc_time = gc_time;\n+\n+  double mutator_delta = mutator_time - _most_recent_periodic_mutator_time;\n+  _most_recent_periodic_mutator_time = mutator_time;\n+\n+  double mu = mutator_delta \/ (_active_processors * time_delta);\n+  double gcu = gc_delta \/ (_active_processors * time_delta);\n+  log_debug(gc)(\"Periodic Sample: GCU = %.3f%%, MU = %.3f%% during most recent %.1fs\", gcu * 100, mu * 100, time_delta);\n+}\n+\n+void ShenandoahMmuTracker::initialize() {\n+  \/\/ initialize static data\n+  _active_processors = os::initial_active_processor_count();\n+\n+  _most_recent_periodic_time_stamp = os::elapsedTime();\n+  fetch_cpu_times(_most_recent_periodic_gc_time, _most_recent_periodic_mutator_time);\n+  _mmu_periodic_task->enroll();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+\n+#include \"utilities\/numberSeq.hpp\"\n+\n+class ShenandoahGeneration;\n+class ShenandoahMmuTask;\n+\n+\/**\n+ * This class is responsible for tracking and adjusting the minimum mutator\n+ * utilization (MMU). MMU is defined as the percentage of CPU time available\n+ * to mutator threads over an arbitrary, fixed interval of time. This interval\n+ * defaults to 5 seconds and is configured by GCPauseIntervalMillis. The class\n+ * maintains a decaying average of the last 10 values. The MMU is measured\n+ * by summing all of the time given to the GC threads and comparing this to\n+ * the total CPU time for the process. There are OS APIs to support this on\n+ * all major platforms.\n+ *\n+ * The time spent by GC threads is attributed to the young or old generation.\n+ * The time given to the controller and regulator threads is attributed to the\n+ * global generation. At the end of every collection, the average MMU is inspected.\n+ * If it is below `GCTimeRatio`, this class will attempt to increase the capacity\n+ * of the generation that is consuming the most CPU time. The assumption being\n+ * that increasing memory will reduce the collection frequency and raise the\n+ * MMU.\n+ *\/\n+class ShenandoahMmuTracker {\n+private:\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for calculating\n+  \/\/ CPU time consumed by GC and mutator threads during each GC cycle.\n+  double _most_recent_timestamp;\n+  double _most_recent_gc_time;\n+  double _most_recent_gcu;\n+  double _most_recent_mutator_time;\n+  double _most_recent_mu;\n+\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for reporting\n+  \/\/ periodic consumption of CPU time by GC and mutator threads.\n+  double _most_recent_periodic_time_stamp;\n+  double _most_recent_periodic_gc_time;\n+  double _most_recent_periodic_mutator_time;\n+\n+  size_t _most_recent_gcid;\n+  uint _active_processors;\n+\n+  bool _most_recent_is_full;\n+\n+  ShenandoahMmuTask* _mmu_periodic_task;\n+  TruncatedSeq _mmu_average;\n+\n+  void update_utilization(size_t gcid, const char* msg);\n+  static void fetch_cpu_times(double &gc_time, double &mutator_time);\n+\n+public:\n+  explicit ShenandoahMmuTracker();\n+  ~ShenandoahMmuTracker();\n+\n+  \/\/ This enrolls the periodic task after everything is initialized.\n+  void initialize();\n+\n+  \/\/ At completion of each GC cycle (not including interrupted cycles), we invoke one of the following to record the\n+  \/\/ GC utilization during this cycle.  Incremental efforts spent in an interrupted GC cycle will be accumulated into\n+  \/\/ the CPU time reports for the subsequent completed [degenerated or full] GC cycle.\n+  \/\/\n+  \/\/ We may redundantly record degen and full in the case that a degen upgrades to full.  When this happens, we will invoke\n+  \/\/ both record_full() and record_degenerated() with the same value of gcid.  record_full() is called first and the log\n+  \/\/ reports such a cycle as a FULL cycle.\n+  void record_young(size_t gcid);\n+  void record_global(size_t gcid);\n+  void record_bootstrap(size_t gcid);\n+  void record_old_marking_increment(bool old_marking_done);\n+  void record_mixed(size_t gcid);\n+  void record_full(size_t gcid);\n+  void record_degenerated(size_t gcid, bool is_old_boostrap);\n+\n+  \/\/ This is called by the periodic task timer. The interval is defined by\n+  \/\/ GCPauseIntervalMillis and defaults to 5 seconds. This method computes\n+  \/\/ the MMU over the elapsed interval and records it in a running average.\n+  void report();\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -128,5 +128,2 @@\n-  if (heap->is_concurrent_mark_in_progress()) {\n-    ShenandoahKeepAliveClosure cl;\n-    data->oops_do(&cl);\n-  } else if (heap->is_concurrent_weak_root_in_progress() ||\n-             heap->is_concurrent_strong_root_in_progress() ) {\n+  if (heap->is_concurrent_weak_root_in_progress() ||\n+      heap->is_concurrent_strong_root_in_progress()) {\n@@ -135,0 +132,3 @@\n+  } else if (heap->is_concurrent_mark_in_progress()) {\n+    ShenandoahKeepAliveClosure cl;\n+    data->oops_do(&cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -123,0 +124,64 @@\n+void HdrSeq::add(const HdrSeq& other) {\n+  if (other.num() == 0) {\n+    \/\/ Other sequence is empty, return\n+    return;\n+  }\n+\n+  for (int mag = 0; mag < MagBuckets; mag++) {\n+    int* other_bucket = other._hdr[mag];\n+    if (other_bucket == nullptr) {\n+      \/\/ Nothing to do\n+      continue;\n+    }\n+    int* bucket = _hdr[mag];\n+    if (bucket != nullptr) {\n+      \/\/ Add into our bucket\n+      for (int val = 0; val < ValBuckets; val++) {\n+        bucket[val] += other_bucket[val];\n+      }\n+    } else {\n+      \/\/ Create our bucket and copy the contents over\n+      bucket = NEW_C_HEAP_ARRAY(int, ValBuckets, mtInternal);\n+      for (int val = 0; val < ValBuckets; val++) {\n+        bucket[val] = other_bucket[val];\n+      }\n+      _hdr[mag] = bucket;\n+    }\n+  }\n+\n+  \/\/ This is a hacky way to only update the fields we want.\n+  \/\/ This inlines NumberSeq code without going into AbsSeq and\n+  \/\/ dealing with decayed average\/variance, which we do not\n+  \/\/ know how to compute yet.\n+  _last = other._last;\n+  _maximum = MAX2(_maximum, other._maximum);\n+  _sum += other._sum;\n+  _sum_of_squares += other._sum_of_squares;\n+  _num += other._num;\n+\n+  \/\/ Until JDK-8298902 is fixed, we taint the decaying statistics\n+  _davg = NAN;\n+  _dvariance = NAN;\n+}\n+\n+void HdrSeq::clear() {\n+  \/\/ Clear the storage\n+  for (int mag = 0; mag < MagBuckets; mag++) {\n+    int* bucket = _hdr[mag];\n+    if (bucket != nullptr) {\n+      for (int c = 0; c < ValBuckets; c++) {\n+        bucket[c] = 0;\n+      }\n+    }\n+  }\n+\n+  \/\/ Clear other fields too\n+  _last = 0;\n+  _maximum = 0;\n+  _sum = 0;\n+  _sum_of_squares = 0;\n+  _num = 0;\n+  _davg = 0;\n+  _dvariance = 0;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  void add(const HdrSeq& other);\n@@ -53,0 +54,1 @@\n+  void clear();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+\n+ShenandoahOldGC::ShenandoahOldGC(ShenandoahOldGeneration* generation, ShenandoahSharedFlag& allow_preemption) :\n+    ShenandoahConcurrentGC(generation, false), _old_generation(generation), _allow_preemption(allow_preemption) {\n+}\n+\n+\/\/ Final mark for old-gen is different for young than old, so we\n+\/\/ override the implementation.\n+void ShenandoahOldGC::op_final_mark() {\n+\n+  ShenandoahGenerationalHeap* const heap = ShenandoahGenerationalHeap::heap();\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should be at safepoint\");\n+  assert(!heap->has_forwarded_objects(), \"No forwarded objects on this path\");\n+\n+  if (ShenandoahVerify) {\n+    heap->verifier()->verify_roots_no_forwarded();\n+  }\n+\n+  if (!heap->cancelled_gc()) {\n+    assert(_mark.generation()->is_old(), \"Generation of Old-Gen GC should be OLD\");\n+    _mark.finish_mark();\n+    assert(!heap->cancelled_gc(), \"STW mark cannot OOM\");\n+\n+    \/\/ Old collection is complete, the young generation no longer needs this\n+    \/\/ reference to the old concurrent mark so clean it up.\n+    heap->young_generation()->set_old_gen_task_queues(nullptr);\n+\n+    \/\/ We need to do this because weak root cleaning reports the number of dead handles\n+    JvmtiTagMap::set_needs_cleaning();\n+\n+    _generation->prepare_regions_and_collection_set(true);\n+\n+    heap->set_unload_classes(false);\n+    heap->prepare_concurrent_roots();\n+\n+    \/\/ Believe verification following old-gen concurrent mark needs to be different than verification following\n+    \/\/ young-gen concurrent mark, so am commenting this out for now:\n+    \/\/   if (ShenandoahVerify) {\n+    \/\/     heap->verifier()->verify_after_concmark();\n+    \/\/   }\n+\n+    if (VerifyAfterGC) {\n+      Universe::verify();\n+    }\n+  }\n+}\n+\n+bool ShenandoahOldGC::collect(GCCause::Cause cause) {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  assert(!_old_generation->is_doing_mixed_evacuations(), \"Should not start an old gc with pending mixed evacuations\");\n+  assert(!_old_generation->is_preparing_for_mark(), \"Old regions need to be parsable during concurrent mark.\");\n+\n+  \/\/ Enable preemption of old generation mark.\n+  _allow_preemption.set();\n+\n+  \/\/ Continue concurrent mark, do not reset regions, do not mark roots, do not collect $200.\n+  entry_mark();\n+\n+  \/\/ If we failed to unset the preemption flag, it means another thread has already unset it.\n+  if (!_allow_preemption.try_unset()) {\n+    \/\/ The regulator thread has unset the preemption guard. That thread will shortly cancel\n+    \/\/ the gc, but the control thread is now racing it. Wait until this thread sees the\n+    \/\/ cancellation.\n+    while (!heap->cancelled_gc()) {\n+      SpinPause();\n+    }\n+  }\n+\n+  if (heap->cancelled_gc()) {\n+    return false;\n+  }\n+\n+  \/\/ Complete marking under STW\n+  vmop_entry_final_mark();\n+\n+  if (_generation->is_concurrent_mark_in_progress()) {\n+    assert(heap->cancelled_gc(), \"Safepoint operation observed gc cancellation\");\n+    \/\/ GC may have been cancelled before final mark, but after the preceding cancellation check.\n+    return false;\n+  }\n+\n+  \/\/ We aren't dealing with old generation evacuation yet. Our heuristic\n+  \/\/ should not have built a cset in final mark.\n+  assert(!heap->is_evacuation_in_progress(), \"Old gen evacuations are not supported\");\n+\n+  \/\/ Process weak roots that might still point to regions that would be broken by cleanup\n+  if (heap->is_concurrent_weak_root_in_progress()) {\n+    entry_weak_refs();\n+    entry_weak_roots();\n+  }\n+\n+  \/\/ Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim\n+  \/\/ the space. This would be the last action if there is nothing to evacuate.\n+  entry_cleanup_early();\n+\n+  heap->free_set()->log_status_under_lock();\n+\n+  assert(!heap->is_concurrent_strong_root_in_progress(), \"No evacuations during old gc.\");\n+\n+  \/\/ We must execute this vm operation if we completed final mark. We cannot\n+  \/\/ return from here with weak roots in progress. This is not a valid gc state\n+  \/\/ for any young collections (or allocation failures) that interrupt the old\n+  \/\/ collection.\n+  vmop_entry_final_roots();\n+\n+  \/\/ We do not rebuild_free following increments of old marking because memory has not been reclaimed. However, we may\n+  \/\/ need to transfer memory to OLD in order to efficiently support the mixed evacuations that might immediately follow.\n+  size_t allocation_runway = heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(0);\n+  heap->compute_old_generation_balance(allocation_runway, 0);\n+\n+  ShenandoahGenerationalHeap::TransferResult result;\n+  {\n+    ShenandoahHeapLocker locker(heap->lock());\n+    result = heap->balance_generations();\n+  }\n+\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Old Mark\", &ls);\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOLDGC_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOLDGC_HPP\n+\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+\n+class ShenandoahOldGeneration;\n+\n+class ShenandoahOldGC : public ShenandoahConcurrentGC {\n+ public:\n+  ShenandoahOldGC(ShenandoahOldGeneration* generation, ShenandoahSharedFlag& allow_preemption);\n+  bool collect(GCCause::Cause cause) override;\n+\n+ protected:\n+  void op_final_mark() override;\n+\n+ private:\n+  ShenandoahOldGeneration* _old_generation;\n+  ShenandoahSharedFlag& _allow_preemption;\n+};\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHOLDGC_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,790 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+class ShenandoahFlushAllSATB : public ThreadClosure {\n+private:\n+  SATBMarkQueueSet& _satb_qset;\n+\n+public:\n+  explicit ShenandoahFlushAllSATB(SATBMarkQueueSet& satb_qset) :\n+    _satb_qset(satb_qset) {}\n+\n+  void do_thread(Thread* thread) override {\n+    \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n+    _satb_qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n+  }\n+};\n+\n+class ShenandoahProcessOldSATB : public SATBBufferClosure {\n+private:\n+  ShenandoahObjToScanQueue*       _queue;\n+  ShenandoahHeap*                 _heap;\n+  ShenandoahMarkingContext* const _mark_context;\n+  size_t                          _trashed_oops;\n+\n+public:\n+  explicit ShenandoahProcessOldSATB(ShenandoahObjToScanQueue* q) :\n+    _queue(q),\n+    _heap(ShenandoahHeap::heap()),\n+    _mark_context(_heap->marking_context()),\n+    _trashed_oops(0) {}\n+\n+  void do_buffer(void** buffer, size_t size) override {\n+    assert(size == 0 || !_heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded objects are not expected here\");\n+    for (size_t i = 0; i < size; ++i) {\n+      oop *p = (oop *) &buffer[i];\n+      ShenandoahHeapRegion* region = _heap->heap_region_containing(*p);\n+      if (region->is_old() && region->is_active()) {\n+          ShenandoahMark::mark_through_ref<oop, OLD>(p, _queue, nullptr, _mark_context, false);\n+      } else {\n+        _trashed_oops++;\n+      }\n+    }\n+  }\n+\n+  size_t trashed_oops() const {\n+    return _trashed_oops;\n+  }\n+};\n+\n+class ShenandoahPurgeSATBTask : public WorkerTask {\n+private:\n+  ShenandoahObjToScanQueueSet* _mark_queues;\n+  volatile size_t             _trashed_oops;\n+\n+public:\n+  explicit ShenandoahPurgeSATBTask(ShenandoahObjToScanQueueSet* queues) :\n+    WorkerTask(\"Purge SATB\"),\n+    _mark_queues(queues),\n+    _trashed_oops(0) {\n+    Threads::change_thread_claim_token();\n+  }\n+\n+  ~ShenandoahPurgeSATBTask() {\n+    if (_trashed_oops > 0) {\n+      log_debug(gc)(\"Purged \" SIZE_FORMAT \" oops from old generation SATB buffers\", _trashed_oops);\n+    }\n+  }\n+\n+  void work(uint worker_id) override {\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    ShenandoahSATBMarkQueueSet &satb_queues = ShenandoahBarrierSet::satb_mark_queue_set();\n+    ShenandoahFlushAllSATB flusher(satb_queues);\n+    Threads::possibly_parallel_threads_do(true \/* is_par *\/, &flusher);\n+\n+    ShenandoahObjToScanQueue* mark_queue = _mark_queues->queue(worker_id);\n+    ShenandoahProcessOldSATB processor(mark_queue);\n+    while (satb_queues.apply_closure_to_completed_buffer(&processor)) {}\n+\n+    Atomic::add(&_trashed_oops, processor.trashed_oops());\n+  }\n+};\n+\n+class ShenandoahConcurrentCoalesceAndFillTask : public WorkerTask {\n+private:\n+  uint                    _nworkers;\n+  ShenandoahHeapRegion**  _coalesce_and_fill_region_array;\n+  uint                    _coalesce_and_fill_region_count;\n+  volatile bool           _is_preempted;\n+\n+public:\n+  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers,\n+                                          ShenandoahHeapRegion** coalesce_and_fill_region_array,\n+                                          uint region_count) :\n+    WorkerTask(\"Shenandoah Concurrent Coalesce and Fill\"),\n+    _nworkers(nworkers),\n+    _coalesce_and_fill_region_array(coalesce_and_fill_region_array),\n+    _coalesce_and_fill_region_count(region_count),\n+    _is_preempted(false) {\n+  }\n+\n+  void work(uint worker_id) override {\n+    ShenandoahWorkerTimingsTracker timer(ShenandoahPhaseTimings::conc_coalesce_and_fill, ShenandoahPhaseTimings::ScanClusters, worker_id);\n+    for (uint region_idx = worker_id; region_idx < _coalesce_and_fill_region_count; region_idx += _nworkers) {\n+      ShenandoahHeapRegion* r = _coalesce_and_fill_region_array[region_idx];\n+      if (r->is_humongous()) {\n+        \/\/ There is only one object in this region and it is not garbage,\n+        \/\/ so no need to coalesce or fill.\n+        continue;\n+      }\n+\n+      if (!r->oop_coalesce_and_fill(true)) {\n+        \/\/ Coalesce and fill has been preempted\n+        Atomic::store(&_is_preempted, true);\n+        return;\n+      }\n+    }\n+  }\n+\n+  \/\/ Value returned from is_completed() is only valid after all worker thread have terminated.\n+  bool is_completed() {\n+    return !Atomic::load(&_is_preempted);\n+  }\n+};\n+\n+ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n+  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity),\n+    _coalesce_and_fill_region_array(NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, ShenandoahHeap::heap()->num_regions(), mtGC)),\n+    _old_heuristics(nullptr),\n+    _region_balance(0),\n+    _promoted_reserve(0),\n+    _promoted_expended(0),\n+    _promotion_potential(0),\n+    _pad_for_promote_in_place(0),\n+    _promotable_humongous_regions(0),\n+    _promotable_regular_regions(0),\n+    _is_parsable(true),\n+    _card_scan(nullptr),\n+    _state(WAITING_FOR_BOOTSTRAP),\n+    _growth_before_compaction(INITIAL_GROWTH_BEFORE_COMPACTION),\n+    _min_growth_before_compaction ((ShenandoahMinOldGenGrowthPercent * FRACTIONAL_DENOMINATOR) \/ 100)\n+{\n+  _live_bytes_after_last_mark = ShenandoahHeap::heap()->capacity() * INITIAL_LIVE_FRACTION \/ FRACTIONAL_DENOMINATOR;\n+  \/\/ Always clear references for old generation\n+  ref_processor()->set_soft_reference_policy(true);\n+\n+  if (ShenandoahCardBarrier) {\n+    ShenandoahCardTable* card_table = ShenandoahBarrierSet::barrier_set()->card_table();\n+    size_t card_count = card_table->cards_required(ShenandoahHeap::heap()->reserved_region().word_size());\n+    auto rs = new ShenandoahDirectCardMarkRememberedSet(card_table, card_count);\n+    _card_scan = new ShenandoahScanRemembered(rs);\n+  }\n+}\n+\n+void ShenandoahOldGeneration::set_promoted_reserve(size_t new_val) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _promoted_reserve = new_val;\n+}\n+\n+size_t ShenandoahOldGeneration::get_promoted_reserve() const {\n+  return _promoted_reserve;\n+}\n+\n+void ShenandoahOldGeneration::augment_promoted_reserve(size_t increment) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _promoted_reserve += increment;\n+}\n+\n+void ShenandoahOldGeneration::reset_promoted_expended() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  Atomic::store(&_promoted_expended, (size_t) 0);\n+}\n+\n+size_t ShenandoahOldGeneration::expend_promoted(size_t increment) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(get_promoted_expended() + increment <= get_promoted_reserve(), \"Do not expend more promotion than budgeted\");\n+  return Atomic::add(&_promoted_expended, increment);\n+}\n+\n+size_t ShenandoahOldGeneration::unexpend_promoted(size_t decrement) {\n+  return Atomic::sub(&_promoted_expended, decrement);\n+}\n+\n+size_t ShenandoahOldGeneration::get_promoted_expended() const {\n+  return Atomic::load(&_promoted_expended);\n+}\n+\n+bool ShenandoahOldGeneration::can_allocate(const ShenandoahAllocRequest &req) const {\n+  assert(req.type() != ShenandoahAllocRequest::_alloc_gclab, \"GCLAB pertains only to young-gen memory\");\n+\n+  const size_t requested_bytes = req.size() * HeapWordSize;\n+  \/\/ The promotion reserve may also be used for evacuations. If we can promote this object,\n+  \/\/ then we can also evacuate it.\n+  if (can_promote(requested_bytes)) {\n+    \/\/ The promotion reserve should be able to accommodate this request. The request\n+    \/\/ might still fail if alignment with the card table increases the size. The request\n+    \/\/ may also fail if the heap is badly fragmented and the free set cannot find room for it.\n+    return true;\n+  }\n+\n+  if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+    \/\/ The promotion reserve cannot accommodate this plab request. Check if we still have room for\n+    \/\/ evacuations. Note that we cannot really know how much of the plab will be used for evacuations,\n+    \/\/ so here we only check that some evacuation reserve still exists.\n+    return get_evacuation_reserve() > 0;\n+  }\n+\n+  \/\/ This is a shared allocation request. We've already checked that it can't be promoted, so if\n+  \/\/ it is a promotion, we return false. Otherwise, it is a shared evacuation request, and we allow\n+  \/\/ the allocation to proceed.\n+  return !req.is_promotion();\n+}\n+\n+void\n+ShenandoahOldGeneration::configure_plab_for_current_thread(const ShenandoahAllocRequest &req) {\n+  \/\/ Note: Even when a mutator is performing a promotion outside a LAB, we use a 'shared_gc' request.\n+  if (req.is_gc_alloc()) {\n+    const size_t actual_size = req.actual_size() * HeapWordSize;\n+    if (req.type() ==  ShenandoahAllocRequest::_alloc_plab) {\n+      \/\/ We've created a new plab. Now we configure it whether it will be used for promotions\n+      \/\/ and evacuations - or just evacuations.\n+      Thread* thread = Thread::current();\n+      ShenandoahThreadLocalData::reset_plab_promoted(thread);\n+\n+      \/\/ The actual size of the allocation may be larger than the requested bytes (due to alignment on card boundaries).\n+      \/\/ If this puts us over our promotion budget, we need to disable future PLAB promotions for this thread.\n+      if (can_promote(actual_size)) {\n+        \/\/ Assume the entirety of this PLAB will be used for promotion.  This prevents promotion from overreach.\n+        \/\/ When we retire this plab, we'll unexpend what we don't really use.\n+        expend_promoted(actual_size);\n+        ShenandoahThreadLocalData::enable_plab_promotions(thread);\n+        ShenandoahThreadLocalData::set_plab_actual_size(thread, actual_size);\n+      } else {\n+        \/\/ Disable promotions in this thread because entirety of this PLAB must be available to hold old-gen evacuations.\n+        ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+        ShenandoahThreadLocalData::set_plab_actual_size(thread, 0);\n+      }\n+    } else if (req.is_promotion()) {\n+      \/\/ Shared promotion.\n+      expend_promoted(actual_size);\n+    }\n+  }\n+}\n+\n+size_t ShenandoahOldGeneration::get_live_bytes_after_last_mark() const {\n+  return _live_bytes_after_last_mark;\n+}\n+\n+void ShenandoahOldGeneration::set_live_bytes_after_last_mark(size_t bytes) {\n+  if (bytes == 0) {\n+    \/\/ Restart search for best old-gen size to the initial state\n+    _live_bytes_after_last_mark = ShenandoahHeap::heap()->capacity() * INITIAL_LIVE_FRACTION \/ FRACTIONAL_DENOMINATOR;\n+    _growth_before_compaction = INITIAL_GROWTH_BEFORE_COMPACTION;\n+  } else {\n+    _live_bytes_after_last_mark = bytes;\n+    _growth_before_compaction \/= 2;\n+    if (_growth_before_compaction < _min_growth_before_compaction) {\n+      _growth_before_compaction = _min_growth_before_compaction;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldGeneration::handle_failed_transfer() {\n+  _old_heuristics->trigger_cannot_expand();\n+}\n+\n+size_t ShenandoahOldGeneration::usage_trigger_threshold() const {\n+  size_t result = _live_bytes_after_last_mark + (_live_bytes_after_last_mark * _growth_before_compaction) \/ FRACTIONAL_DENOMINATOR;\n+  return result;\n+}\n+\n+bool ShenandoahOldGeneration::contains(ShenandoahAffiliation affiliation) const {\n+  return affiliation == OLD_GENERATION;\n+}\n+bool ShenandoahOldGeneration::contains(ShenandoahHeapRegion* region) const {\n+  return region->is_old();\n+}\n+\n+void ShenandoahOldGeneration::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahIncludeRegionClosure<OLD_GENERATION> old_regions_cl(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&old_regions_cl);\n+}\n+\n+void ShenandoahOldGeneration::heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahIncludeRegionClosure<OLD_GENERATION> old_regions_cl(cl);\n+  ShenandoahHeap::heap()->heap_region_iterate(&old_regions_cl);\n+}\n+\n+void ShenandoahOldGeneration::set_concurrent_mark_in_progress(bool in_progress) {\n+  ShenandoahHeap::heap()->set_concurrent_old_mark_in_progress(in_progress);\n+}\n+\n+bool ShenandoahOldGeneration::is_concurrent_mark_in_progress() {\n+  return ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress();\n+}\n+\n+void ShenandoahOldGeneration::cancel_marking() {\n+  if (is_concurrent_mark_in_progress()) {\n+    log_debug(gc)(\"Abandon SATB buffers\");\n+    ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n+  }\n+\n+  ShenandoahGeneration::cancel_marking();\n+}\n+\n+void ShenandoahOldGeneration::cancel_gc() {\n+  shenandoah_assert_safepoint();\n+  if (is_idle()) {\n+#ifdef ASSERT\n+    validate_waiting_for_bootstrap();\n+#endif\n+  } else {\n+    log_info(gc)(\"Terminating old gc cycle.\");\n+    \/\/ Stop marking\n+    cancel_marking();\n+    \/\/ Stop tracking old regions\n+    abandon_collection_candidates();\n+    \/\/ Remove old generation access to young generation mark queues\n+    ShenandoahHeap::heap()->young_generation()->set_old_gen_task_queues(nullptr);\n+    \/\/ Transition to IDLE now.\n+    transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+  }\n+}\n+\n+void ShenandoahOldGeneration::prepare_gc() {\n+  \/\/ Now that we have made the old generation parsable, it is safe to reset the mark bitmap.\n+  assert(state() != FILLING, \"Cannot reset old without making it parsable\");\n+\n+  ShenandoahGeneration::prepare_gc();\n+}\n+\n+bool ShenandoahOldGeneration::entry_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  static const char* msg = \"Coalescing and filling (Old)\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              msg);\n+\n+  return coalesce_and_fill();\n+}\n+\n+\/\/ Make the old generation regions parsable, so they can be safely\n+\/\/ scanned when looking for objects in memory indicated by dirty cards.\n+bool ShenandoahOldGeneration::coalesce_and_fill() {\n+  transition_to(FILLING);\n+\n+  \/\/ This code will see the same set of regions to fill on each resumption as it did\n+  \/\/ on the initial run. That's okay because each region keeps track of its own coalesce\n+  \/\/ and fill state. Regions that were filled on a prior attempt will not try to fill again.\n+  uint coalesce_and_fill_regions_count = _old_heuristics->get_coalesce_and_fill_candidates(_coalesce_and_fill_region_array);\n+  assert(coalesce_and_fill_regions_count <= ShenandoahHeap::heap()->num_regions(), \"Sanity\");\n+  if (coalesce_and_fill_regions_count == 0) {\n+    \/\/ No regions need to be filled.\n+    abandon_collection_candidates();\n+    return true;\n+  }\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  WorkerThreads* workers = heap->workers();\n+  uint nworkers = workers->active_workers();\n+  ShenandoahConcurrentCoalesceAndFillTask task(nworkers, _coalesce_and_fill_region_array, coalesce_and_fill_regions_count);\n+\n+  log_debug(gc)(\"Starting (or resuming) coalesce-and-fill of \" UINT32_FORMAT \" old heap regions\", coalesce_and_fill_regions_count);\n+  workers->run_task(&task);\n+  if (task.is_completed()) {\n+    \/\/ We no longer need to track regions that need to be coalesced and filled.\n+    abandon_collection_candidates();\n+    return true;\n+  } else {\n+    \/\/ Coalesce-and-fill has been preempted. We'll finish that effort in the future.  Do not invoke\n+    \/\/ ShenandoahGeneration::prepare_gc() until coalesce-and-fill is done because it resets the mark bitmap\n+    \/\/ and invokes set_mark_incomplete().  Coalesce-and-fill depends on the mark bitmap.\n+    log_debug(gc)(\"Suspending coalesce-and-fill of old heap regions\");\n+    return false;\n+  }\n+}\n+\n+void ShenandoahOldGeneration::transfer_pointers_from_satb() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  shenandoah_assert_safepoint();\n+  assert(heap->is_concurrent_old_mark_in_progress(), \"Only necessary during old marking.\");\n+  log_debug(gc)(\"Transfer SATB buffers\");\n+  uint nworkers = heap->workers()->active_workers();\n+  StrongRootsScope scope(nworkers);\n+\n+  ShenandoahPurgeSATBTask purge_satb_task(task_queues());\n+  heap->workers()->run_task(&purge_satb_task);\n+}\n+\n+bool ShenandoahOldGeneration::contains(oop obj) const {\n+  return ShenandoahHeap::heap()->is_in_old(obj);\n+}\n+\n+void ShenandoahOldGeneration::prepare_regions_and_collection_set(bool concurrent) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(!heap->is_full_gc_in_progress(), \"Only for concurrent and degenerated GC\");\n+\n+  {\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::final_update_region_states :\n+        ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n+    ShenandoahFinalMarkUpdateRegionStateClosure cl(complete_marking_context());\n+\n+    parallel_heap_region_iterate(&cl);\n+    heap->assert_pinned_region_status();\n+  }\n+\n+  {\n+    \/\/ This doesn't actually choose a collection set, but prepares a list of\n+    \/\/ regions as 'candidates' for inclusion in a mixed collection.\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::choose_cset :\n+        ShenandoahPhaseTimings::degen_gc_choose_cset);\n+    ShenandoahHeapLocker locker(heap->lock());\n+    _old_heuristics->prepare_for_old_collections();\n+  }\n+\n+  {\n+    \/\/ Though we did not choose a collection set above, we still may have\n+    \/\/ freed up immediate garbage regions so proceed with rebuilding the free set.\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::final_rebuild_freeset :\n+        ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n+    ShenandoahHeapLocker locker(heap->lock());\n+    size_t cset_young_regions, cset_old_regions;\n+    size_t first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions, first_old, last_old, num_old);\n+    \/\/ This is just old-gen completion.  No future budgeting required here.  The only reason to rebuild the freeset here\n+    \/\/ is in case there was any immediate old garbage identified.\n+    heap->free_set()->finish_rebuild(cset_young_regions, cset_old_regions, num_old);\n+  }\n+}\n+\n+const char* ShenandoahOldGeneration::state_name(State state) {\n+  switch (state) {\n+    case WAITING_FOR_BOOTSTRAP:   return \"Waiting for Bootstrap\";\n+    case FILLING:                 return \"Coalescing\";\n+    case BOOTSTRAPPING:           return \"Bootstrapping\";\n+    case MARKING:                 return \"Marking\";\n+    case EVACUATING:              return \"Evacuating\";\n+    case EVACUATING_AFTER_GLOBAL: return \"Evacuating (G)\";\n+    default:\n+      ShouldNotReachHere();\n+      return \"Unknown\";\n+  }\n+}\n+\n+void ShenandoahOldGeneration::transition_to(State new_state) {\n+  if (_state != new_state) {\n+    log_debug(gc)(\"Old generation transition from %s to %s\", state_name(_state), state_name(new_state));\n+    EventMark event(\"Old was %s, now is %s\", state_name(_state), state_name(new_state));\n+    validate_transition(new_state);\n+    _state = new_state;\n+  }\n+}\n+\n+#ifdef ASSERT\n+\/\/ This diagram depicts the expected state transitions for marking the old generation\n+\/\/ and preparing for old collections. When a young generation cycle executes, the\n+\/\/ remembered set scan must visit objects in old regions. Visiting an object which\n+\/\/ has become dead on previous old cycles will result in crashes. To avoid visiting\n+\/\/ such objects, the remembered set scan will use the old generation mark bitmap when\n+\/\/ possible. It is _not_ possible to use the old generation bitmap when old marking\n+\/\/ is active (bitmap is not complete). For this reason, the old regions are made\n+\/\/ parsable _before_ the old generation bitmap is reset. The diagram does not depict\n+\/\/ cancellation of old collections by global or full collections.\n+\/\/\n+\/\/ When a global collection supersedes an old collection, the global mark still\n+\/\/ \"completes\" the old mark bitmap. Subsequent remembered set scans may use the\n+\/\/ old generation mark bitmap, but any uncollected old regions must still be made parsable\n+\/\/ before the next old generation cycle begins. For this reason, a global collection may\n+\/\/ create mixed collection candidates and coalesce and fill candidates and will put\n+\/\/ the old generation in the respective states (EVACUATING or FILLING). After a Full GC,\n+\/\/ the mark bitmaps are all reset, all regions are parsable and the mark context will\n+\/\/ not be \"complete\". After a Full GC, remembered set scans will _not_ use the mark bitmap\n+\/\/ and we expect the old generation to be waiting for bootstrap.\n+\/\/\n+\/\/                              +-----------------+\n+\/\/               +------------> |     FILLING     | <---+\n+\/\/               |   +--------> |                 |     |\n+\/\/               |   |          +-----------------+     |\n+\/\/               |   |            |                     |\n+\/\/               |   |            | Filling Complete    | <-> A global collection may\n+\/\/               |   |            v                     |     move the old generation\n+\/\/               |   |          +-----------------+     |     directly from waiting for\n+\/\/           +-- |-- |--------> |     WAITING     |     |     bootstrap to filling or\n+\/\/           |   |   |    +---- |  FOR BOOTSTRAP  | ----+     evacuating. It may also\n+\/\/           |   |   |    |     +-----------------+           move from filling to waiting\n+\/\/           |   |   |    |       |                           for bootstrap.\n+\/\/           |   |   |    |       | Reset Bitmap\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |     |    BOOTSTRAP    | <-> |       YOUNG GC       |\n+\/\/           |   |   |    |     |                 |     | (RSet Parses Region) |\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |       |\n+\/\/           |   |   |    |       | Old Marking\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |     |     MARKING     | <-> |       YOUNG GC       |\n+\/\/           |   |   +--------- |                 |     | (RSet Parses Region) |\n+\/\/           |   |        |     +-----------------+     +----------------------+\n+\/\/           |   |        |       |\n+\/\/           |   |        |       | Has Evacuation Candidates\n+\/\/           |   |        |       v\n+\/\/           |   |        |     +-----------------+     +--------------------+\n+\/\/           |   |        +---> |    EVACUATING   | <-> |      YOUNG GC      |\n+\/\/           |   +------------- |                 |     | (RSet Uses Bitmap) |\n+\/\/           |                  +-----------------+     +--------------------+\n+\/\/           |                    |\n+\/\/           |                    | Global Cycle Coalesces and Fills Old Regions\n+\/\/           |                    v\n+\/\/           |                  +-----------------+     +--------------------+\n+\/\/           +----------------- |    EVACUATING   | <-> |      YOUNG GC      |\n+\/\/                              |   AFTER GLOBAL  |     | (RSet Uses Bitmap) |\n+\/\/                              +-----------------+     +--------------------+\n+\/\/\n+\/\/\n+void ShenandoahOldGeneration::validate_transition(State new_state) {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  switch (new_state) {\n+    case FILLING:\n+      assert(_state != BOOTSTRAPPING, \"Cannot begin making old regions parsable after bootstrapping\");\n+      assert(is_mark_complete(), \"Cannot begin filling without first completing marking, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->has_coalesce_and_fill_candidates(), \"Cannot begin filling without something to fill.\");\n+      break;\n+    case WAITING_FOR_BOOTSTRAP:\n+      \/\/ GC cancellation can send us back here from any state.\n+      validate_waiting_for_bootstrap();\n+      break;\n+    case BOOTSTRAPPING:\n+      assert(_state == WAITING_FOR_BOOTSTRAP, \"Cannot reset bitmap without making old regions parsable, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot bootstrap with mixed collection candidates\");\n+      assert(!heap->is_prepare_for_old_mark_in_progress(), \"Cannot still be making old regions parsable.\");\n+      break;\n+    case MARKING:\n+      assert(_state == BOOTSTRAPPING, \"Must have finished bootstrapping before marking, state is '%s'\", state_name(_state));\n+      assert(heap->young_generation()->old_gen_task_queues() != nullptr, \"Young generation needs old mark queues.\");\n+      assert(heap->is_concurrent_old_mark_in_progress(), \"Should be marking old now.\");\n+      break;\n+    case EVACUATING_AFTER_GLOBAL:\n+      assert(_state == EVACUATING, \"Must have been evacuating, state is '%s'\", state_name(_state));\n+      break;\n+    case EVACUATING:\n+      assert(_state == WAITING_FOR_BOOTSTRAP || _state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() > 0, \"Must have collection candidates here.\");\n+      break;\n+    default:\n+      fatal(\"Unknown new state\");\n+  }\n+}\n+\n+bool ShenandoahOldGeneration::validate_waiting_for_bootstrap() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(!heap->is_concurrent_old_mark_in_progress(), \"Cannot become ready for bootstrap during old mark.\");\n+  assert(heap->young_generation()->old_gen_task_queues() == nullptr, \"Cannot become ready for bootstrap when still setup for bootstrapping.\");\n+  assert(!is_concurrent_mark_in_progress(), \"Cannot be marking in IDLE\");\n+  assert(!heap->young_generation()->is_bootstrap_cycle(), \"Cannot have old mark queues if IDLE\");\n+  assert(!_old_heuristics->has_coalesce_and_fill_candidates(), \"Cannot have coalesce and fill candidates in IDLE\");\n+  assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot have mixed collection candidates in IDLE\");\n+  return true;\n+}\n+#endif\n+\n+ShenandoahHeuristics* ShenandoahOldGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  _old_heuristics = new ShenandoahOldHeuristics(this, ShenandoahGenerationalHeap::heap());\n+  _old_heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedOldGCInterval);\n+  _heuristics = _old_heuristics;\n+  return _heuristics;\n+}\n+\n+void ShenandoahOldGeneration::record_success_concurrent(bool abbreviated) {\n+  heuristics()->record_success_concurrent();\n+  ShenandoahHeap::heap()->shenandoah_policy()->record_success_old();\n+}\n+\n+void ShenandoahOldGeneration::handle_failed_evacuation() {\n+  if (_failed_evacuation.try_set()) {\n+    log_debug(gc)(\"Old gen evac failure.\");\n+  }\n+}\n+\n+void ShenandoahOldGeneration::handle_failed_promotion(Thread* thread, size_t size) {\n+  \/\/ We squelch excessive reports to reduce noise in logs.\n+  const size_t MaxReportsPerEpoch = 4;\n+  static size_t last_report_epoch = 0;\n+  static size_t epoch_report_count = 0;\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+\n+  size_t promotion_reserve;\n+  size_t promotion_expended;\n+\n+  const size_t gc_id = heap->control_thread()->get_gc_id();\n+\n+  if ((gc_id != last_report_epoch) || (epoch_report_count++ < MaxReportsPerEpoch)) {\n+    {\n+      \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n+      ShenandoahHeapLocker locker(heap->lock());\n+      promotion_reserve = get_promoted_reserve();\n+      promotion_expended = get_promoted_expended();\n+    }\n+    PLAB* const plab = ShenandoahThreadLocalData::plab(thread);\n+    const size_t words_remaining = (plab == nullptr)? 0: plab->words_remaining();\n+    const char* promote_enabled = ShenandoahThreadLocalData::allow_plab_promotions(thread)? \"enabled\": \"disabled\";\n+\n+    log_info(gc, ergo)(\"Promotion failed, size \" SIZE_FORMAT \", has plab? %s, PLAB remaining: \" SIZE_FORMAT\n+                       \", plab promotions %s, promotion reserve: \" SIZE_FORMAT \", promotion expended: \" SIZE_FORMAT\n+                       \", old capacity: \" SIZE_FORMAT \", old_used: \" SIZE_FORMAT \", old unaffiliated regions: \" SIZE_FORMAT,\n+                       size * HeapWordSize, plab == nullptr? \"no\": \"yes\",\n+                       words_remaining * HeapWordSize, promote_enabled, promotion_reserve, promotion_expended,\n+                       max_capacity(), used(), free_unaffiliated_regions());\n+\n+    if ((gc_id == last_report_epoch) && (epoch_report_count >= MaxReportsPerEpoch)) {\n+      log_debug(gc, ergo)(\"Squelching additional promotion failure reports for current epoch\");\n+    } else if (gc_id != last_report_epoch) {\n+      last_report_epoch = gc_id;\n+      epoch_report_count = 1;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldGeneration::handle_evacuation(HeapWord* obj, size_t words, bool promotion) {\n+  \/\/ Only register the copy of the object that won the evacuation race.\n+  _card_scan->register_object_without_lock(obj);\n+\n+  \/\/ Mark the entire range of the evacuated object as dirty.  At next remembered set scan,\n+  \/\/ we will clear dirty bits that do not hold interesting pointers.  It's more efficient to\n+  \/\/ do this in batch, in a background GC thread than to try to carefully dirty only cards\n+  \/\/ that hold interesting pointers right now.\n+  _card_scan->mark_range_as_dirty(obj, words);\n+\n+  if (promotion) {\n+    \/\/ This evacuation was a promotion, track this as allocation against old gen\n+    increase_allocated(words * HeapWordSize);\n+  }\n+}\n+\n+bool ShenandoahOldGeneration::has_unprocessed_collection_candidates() {\n+  return _old_heuristics->unprocessed_old_collection_candidates() > 0;\n+}\n+\n+size_t ShenandoahOldGeneration::unprocessed_collection_candidates_live_memory() {\n+  return _old_heuristics->unprocessed_old_collection_candidates_live_memory();\n+}\n+\n+void ShenandoahOldGeneration::abandon_collection_candidates() {\n+  _old_heuristics->abandon_collection_candidates();\n+}\n+\n+void ShenandoahOldGeneration::prepare_for_mixed_collections_after_global_gc() {\n+  assert(is_mark_complete(), \"Expected old generation mark to be complete after global cycle.\");\n+  _old_heuristics->prepare_for_old_collections();\n+  log_info(gc, ergo)(\"After choosing global collection set, mixed candidates: \" UINT32_FORMAT \", coalescing candidates: \" SIZE_FORMAT,\n+               _old_heuristics->unprocessed_old_collection_candidates(),\n+               _old_heuristics->coalesce_and_fill_candidates_count());\n+}\n+\n+void ShenandoahOldGeneration::parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  \/\/ Iterate over old and free regions (exclude young).\n+  ShenandoahExcludeRegionClosure<YOUNG_GENERATION> exclude_cl(cl);\n+  ShenandoahGeneration::parallel_heap_region_iterate_free(&exclude_cl);\n+}\n+\n+void ShenandoahOldGeneration::set_parsable(bool parsable) {\n+  _is_parsable = parsable;\n+  if (_is_parsable) {\n+    \/\/ The current state would have been chosen during final mark of the global\n+    \/\/ collection, _before_ any decisions about class unloading have been made.\n+    \/\/\n+    \/\/ After unloading classes, we have made the old generation regions parsable.\n+    \/\/ We can skip filling or transition to a state that knows everything has\n+    \/\/ already been filled.\n+    switch (state()) {\n+      case ShenandoahOldGeneration::EVACUATING:\n+        transition_to(ShenandoahOldGeneration::EVACUATING_AFTER_GLOBAL);\n+        break;\n+      case ShenandoahOldGeneration::FILLING:\n+        assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Expected no mixed collection candidates\");\n+        assert(_old_heuristics->coalesce_and_fill_candidates_count() > 0, \"Expected coalesce and fill candidates\");\n+        \/\/ When the heuristic put the old generation in this state, it didn't know\n+        \/\/ that we would unload classes and make everything parsable. But, we know\n+        \/\/ that now so we can override this state.\n+        abandon_collection_candidates();\n+        transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+        break;\n+      default:\n+        \/\/ We can get here during a full GC. The full GC will cancel anything\n+        \/\/ happening in the old generation and return it to the waiting for bootstrap\n+        \/\/ state. The full GC will then record that the old regions are parsable\n+        \/\/ after rebuilding the remembered set.\n+        assert(is_idle(), \"Unexpected state %s at end of global GC\", state_name());\n+        break;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldGeneration::complete_mixed_evacuations() {\n+  assert(is_doing_mixed_evacuations(), \"Mixed evacuations should be in progress\");\n+  if (!_old_heuristics->has_coalesce_and_fill_candidates()) {\n+    \/\/ No candidate regions to coalesce and fill\n+    transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+    return;\n+  }\n+\n+  if (state() == ShenandoahOldGeneration::EVACUATING) {\n+    transition_to(ShenandoahOldGeneration::FILLING);\n+    return;\n+  }\n+\n+  \/\/ Here, we have no more candidates for mixed collections. The candidates for coalescing\n+  \/\/ and filling have already been processed during the global cycle, so there is nothing\n+  \/\/ more to do.\n+  assert(state() == ShenandoahOldGeneration::EVACUATING_AFTER_GLOBAL, \"Should be evacuating after a global cycle\");\n+  abandon_collection_candidates();\n+  transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+}\n+\n+void ShenandoahOldGeneration::abandon_mixed_evacuations() {\n+  switch(state()) {\n+    case ShenandoahOldGeneration::EVACUATING:\n+      transition_to(ShenandoahOldGeneration::FILLING);\n+      break;\n+    case ShenandoahOldGeneration::EVACUATING_AFTER_GLOBAL:\n+      abandon_collection_candidates();\n+      transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+      break;\n+    default:\n+      log_warning(gc)(\"Abandon mixed evacuations in unexpected state: %s\", state_name(state()));\n+      ShouldNotReachHere();\n+      break;\n+  }\n+}\n+\n+void ShenandoahOldGeneration::clear_cards_for(ShenandoahHeapRegion* region) {\n+  _card_scan->mark_range_as_empty(region->bottom(), pointer_delta(region->end(), region->bottom()));\n+}\n+\n+void ShenandoahOldGeneration::mark_card_as_dirty(void* location) {\n+  _card_scan->mark_card_as_dirty((HeapWord*)location);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":790,"deletions":0,"binary":false,"changes":790,"status":"added"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHOLDGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHOLDGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+class ShenandoahHeapRegion;\n+class ShenandoahHeapRegionClosure;\n+class ShenandoahOldHeuristics;\n+\n+class ShenandoahOldGeneration : public ShenandoahGeneration {\n+private:\n+  ShenandoahHeapRegion** _coalesce_and_fill_region_array;\n+  ShenandoahOldHeuristics* _old_heuristics;\n+\n+  \/\/ After determining the desired size of the old generation (see compute_old_generation_balance), this\n+  \/\/ quantity represents the number of regions above (surplus) or below (deficit) that size.\n+  \/\/ This value is computed prior to the actual exchange of any regions. A positive value represents\n+  \/\/ a surplus of old regions which will be transferred from old _to_ young. A negative value represents\n+  \/\/ a deficit of regions that will be replenished by a transfer _from_ young to old.\n+  ssize_t _region_balance;\n+\n+  \/\/ Set when evacuation in the old generation fails. When this is set, the control thread will initiate a\n+  \/\/ full GC instead of a futile degenerated cycle.\n+  ShenandoahSharedFlag _failed_evacuation;\n+\n+  \/\/ Bytes reserved within old-gen to hold the results of promotion. This is separate from\n+  \/\/ and in addition to the evacuation reserve for intra-generation evacuations (ShenandoahGeneration::_evacuation_reserve).\n+  \/\/ If there is more data ready to be promoted than can fit within this reserve, the promotion of some objects will be\n+  \/\/ deferred until a subsequent evacuation pass.\n+  size_t _promoted_reserve;\n+\n+  \/\/ Bytes of old-gen memory expended on promotions. This may be modified concurrently\n+  \/\/ by mutators and gc workers when promotion LABs are retired during evacuation. It\n+  \/\/ is therefore always accessed through atomic operations. This is increased when a\n+  \/\/ PLAB is allocated for promotions. The value is decreased by the amount of memory\n+  \/\/ remaining in a PLAB when it is retired.\n+  size_t _promoted_expended;\n+\n+  \/\/ Represents the quantity of live bytes we expect to promote in place during the next\n+  \/\/ evacuation cycle. This value is used by the young heuristic to trigger mixed collections.\n+  \/\/ It is also used when computing the optimum size for the old generation.\n+  size_t _promotion_potential;\n+\n+  \/\/ When a region is selected to be promoted in place, the remaining free memory is filled\n+  \/\/ in to prevent additional allocations (preventing premature promotion of newly allocated\n+  \/\/ objects. This field records the total amount of padding used for such regions.\n+  size_t _pad_for_promote_in_place;\n+\n+  \/\/ During construction of the collection set, we keep track of regions that are eligible\n+  \/\/ for promotion in place. These fields track the count of those humongous and regular regions.\n+  \/\/ This data is used to force the evacuation phase even when the collection set is otherwise\n+  \/\/ empty.\n+  size_t _promotable_humongous_regions;\n+  size_t _promotable_regular_regions;\n+\n+  \/\/ True if old regions may be safely traversed by the remembered set scan.\n+  bool _is_parsable;\n+\n+  bool coalesce_and_fill();\n+\n+public:\n+  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n+\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+\n+  const char* name() const override {\n+    return \"Old\";\n+  }\n+\n+  ShenandoahOldHeuristics* heuristics() const override {\n+    return _old_heuristics;\n+  }\n+\n+  \/\/ See description in field declaration\n+  void set_promoted_reserve(size_t new_val);\n+  size_t get_promoted_reserve() const;\n+\n+  \/\/ The promotion reserve is increased when rebuilding the free set transfers a region to the old generation\n+  void augment_promoted_reserve(size_t increment);\n+\n+  \/\/ This zeros out the expended promotion count after the promotion reserve is computed\n+  void reset_promoted_expended();\n+\n+  \/\/ This is incremented when allocations are made to copy promotions into the old generation\n+  size_t expend_promoted(size_t increment);\n+\n+  \/\/ This is used to return unused memory from a retired promotion LAB\n+  size_t unexpend_promoted(size_t decrement);\n+\n+  \/\/ This is used on the allocation path to gate promotions that would exceed the reserve\n+  size_t get_promoted_expended() const;\n+\n+  \/\/ Test if there is enough memory reserved for this promotion\n+  bool can_promote(size_t requested_bytes) const {\n+    size_t promotion_avail = get_promoted_reserve();\n+    size_t promotion_expended = get_promoted_expended();\n+    return promotion_expended + requested_bytes <= promotion_avail;\n+  }\n+\n+  \/\/ Test if there is enough memory available in the old generation to accommodate this request.\n+  \/\/ The request will be subject to constraints on promotion and evacuation reserves.\n+  bool can_allocate(const ShenandoahAllocRequest& req) const;\n+\n+  \/\/ Updates the promotion expenditure tracking and configures whether the plab may be used\n+  \/\/ for promotions and evacuations, or just evacuations.\n+  void configure_plab_for_current_thread(const ShenandoahAllocRequest &req);\n+\n+  \/\/ See description in field declaration\n+  void set_region_balance(ssize_t balance) { _region_balance = balance; }\n+  ssize_t get_region_balance() const { return _region_balance; }\n+  \/\/ See description in field declaration\n+  void set_promotion_potential(size_t val) { _promotion_potential = val; };\n+  size_t get_promotion_potential() const { return _promotion_potential; };\n+\n+  \/\/ See description in field declaration\n+  void set_pad_for_promote_in_place(size_t pad) { _pad_for_promote_in_place = pad; }\n+  size_t get_pad_for_promote_in_place() const { return _pad_for_promote_in_place; }\n+\n+  \/\/ See description in field declaration\n+  void set_expected_humongous_region_promotions(size_t region_count) { _promotable_humongous_regions = region_count; }\n+  void set_expected_regular_region_promotions(size_t region_count) { _promotable_regular_regions = region_count; }\n+  size_t get_expected_in_place_promotions() const { return _promotable_humongous_regions + _promotable_regular_regions; }\n+  bool has_in_place_promotions() const { return get_expected_in_place_promotions() > 0; }\n+\n+  \/\/ Class unloading may render the card table offsets unusable, if they refer to unmarked objects\n+  bool is_parsable() const   { return _is_parsable; }\n+  void set_parsable(bool parsable);\n+\n+  \/\/ This will signal the heuristic to trigger an old generation collection\n+  void handle_failed_transfer();\n+\n+  \/\/ This will signal the control thread to run a full GC instead of a futile degenerated gc\n+  void handle_failed_evacuation();\n+\n+  \/\/ This logs that an evacuation to the old generation has failed\n+  void handle_failed_promotion(Thread* thread, size_t size);\n+\n+  \/\/ A successful evacuation re-dirties the cards and registers the object with the remembered set\n+  void handle_evacuation(HeapWord* obj, size_t words, bool promotion);\n+\n+  \/\/ Clear the flag after it is consumed by the control thread\n+  bool clear_failed_evacuation() {\n+    return _failed_evacuation.try_unset();\n+  }\n+\n+  \/\/ Transition to the next state after mixed evacuations have completed\n+  void complete_mixed_evacuations();\n+\n+  \/\/ Abandon any future mixed collections. This is invoked when all old regions eligible for\n+  \/\/ inclusion in a mixed evacuation are pinned. This should be rare.\n+  void abandon_mixed_evacuations();\n+\n+private:\n+  ShenandoahScanRemembered* _card_scan;\n+\n+public:\n+  ShenandoahScanRemembered* card_scan() { return _card_scan; }\n+\n+  \/\/ Clear cards for given region\n+  void clear_cards_for(ShenandoahHeapRegion* region);\n+\n+  \/\/ Mark card for this location as dirty\n+  void mark_card_as_dirty(void* location);\n+\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  bool contains(ShenandoahAffiliation affiliation) const override;\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+  bool contains(oop obj) const override;\n+\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n+  bool is_concurrent_mark_in_progress() override;\n+\n+  bool entry_coalesce_and_fill();\n+  void prepare_for_mixed_collections_after_global_gc();\n+  void prepare_gc() override;\n+  void prepare_regions_and_collection_set(bool concurrent) override;\n+  void record_success_concurrent(bool abbreviated) override;\n+  void cancel_marking() override;\n+\n+  \/\/ Cancels old gc and transitions to the idle state\n+  void cancel_gc();\n+\n+  \/\/ We leave the SATB barrier on for the entirety of the old generation\n+  \/\/ marking phase. In some cases, this can cause a write to a perfectly\n+  \/\/ reachable oop to enqueue a pointer that later becomes garbage (because\n+  \/\/ it points at an object that is later chosen for the collection set). There are\n+  \/\/ also cases where the referent of a weak reference ends up in the SATB\n+  \/\/ and is later collected. In these cases the oop in the SATB buffer becomes\n+  \/\/ invalid and the _next_ cycle will crash during its marking phase. To\n+  \/\/ avoid this problem, we \"purge\" the SATB buffers during the final update\n+  \/\/ references phase if (and only if) an old generation mark is in progress.\n+  \/\/ At this stage we can safely determine if any of the oops in the SATB\n+  \/\/ buffer belong to trashed regions (before they are recycled). As it\n+  \/\/ happens, flushing a SATB queue also filters out oops which have already\n+  \/\/ been marked - which is the case for anything that is being evacuated\n+  \/\/ from the collection set.\n+  \/\/\n+  \/\/ Alternatively, we could inspect the state of the heap and the age of the\n+  \/\/ object at the barrier, but we reject this approach because it is likely\n+  \/\/ the performance impact would be too severe.\n+  void transfer_pointers_from_satb();\n+\n+  \/\/ True if there are old regions waiting to be selected for a mixed collection\n+  bool has_unprocessed_collection_candidates();\n+\n+  bool is_doing_mixed_evacuations() const {\n+    return state() == EVACUATING || state() == EVACUATING_AFTER_GLOBAL;\n+  }\n+\n+  bool is_preparing_for_mark() const {\n+    return state() == FILLING;\n+  }\n+\n+  bool is_idle() const {\n+    return state() == WAITING_FOR_BOOTSTRAP;\n+  }\n+\n+  bool is_bootstrapping() const {\n+    return state() == BOOTSTRAPPING;\n+  }\n+\n+  \/\/ Amount of live memory (bytes) in regions waiting for mixed collections\n+  size_t unprocessed_collection_candidates_live_memory();\n+\n+  \/\/ Abandon any regions waiting for mixed collections\n+  void abandon_collection_candidates();\n+\n+public:\n+  enum State {\n+    FILLING, WAITING_FOR_BOOTSTRAP, BOOTSTRAPPING, MARKING, EVACUATING, EVACUATING_AFTER_GLOBAL\n+  };\n+\n+#ifdef ASSERT\n+  bool validate_waiting_for_bootstrap();\n+#endif\n+\n+private:\n+  State _state;\n+\n+  static const size_t FRACTIONAL_DENOMINATOR = 65536;\n+\n+  \/\/ During initialization of the JVM, we search for the correct old-gen size by initially performing old-gen\n+  \/\/ collection when old-gen usage is 50% more (INITIAL_GROWTH_BEFORE_COMPACTION) than the initial old-gen size\n+  \/\/ estimate (3.125% of heap).  The next old-gen trigger occurs when old-gen grows 25% larger than its live\n+  \/\/ memory at the end of the first old-gen collection.  Then we trigger again when old-gen grows 12.5%\n+  \/\/ more than its live memory at the end of the previous old-gen collection.  Thereafter, we trigger each time\n+  \/\/ old-gen grows more than 12.5% following the end of its previous old-gen collection.\n+  static const size_t INITIAL_GROWTH_BEFORE_COMPACTION = FRACTIONAL_DENOMINATOR \/ 2;        \/\/  50.0%\n+\n+  \/\/ INITIAL_LIVE_FRACTION represents the initial guess of how large old-gen should be.  We estimate that old-gen\n+  \/\/ needs to consume 6.25% of the total heap size.  And we \"pretend\" that we start out with this amount of live\n+  \/\/ old-gen memory.  The first old-collection trigger will occur when old-gen occupies 50% more than this initial\n+  \/\/ approximation of the old-gen memory requirement, in other words when old-gen usage is 150% of 6.25%, which\n+  \/\/ is 9.375% of the total heap size.\n+  static const uint16_t INITIAL_LIVE_FRACTION = FRACTIONAL_DENOMINATOR \/ 16;                \/\/   6.25%\n+\n+  size_t _live_bytes_after_last_mark;\n+\n+  \/\/ How much growth in usage before we trigger old collection, per FRACTIONAL_DENOMINATOR (65_536)\n+  size_t _growth_before_compaction;\n+  const size_t _min_growth_before_compaction;                                               \/\/ Default is 12.5%\n+\n+  void validate_transition(State new_state) NOT_DEBUG_RETURN;\n+\n+public:\n+  State state() const {\n+    return _state;\n+  }\n+\n+  const char* state_name() const {\n+    return state_name(_state);\n+  }\n+\n+  void transition_to(State new_state);\n+\n+  size_t get_live_bytes_after_last_mark() const;\n+  void set_live_bytes_after_last_mark(size_t new_live);\n+\n+  size_t usage_trigger_threshold() const;\n+\n+  bool can_start_gc() {\n+    return _state == WAITING_FOR_BOOTSTRAP;\n+  }\n+\n+  static const char* state_name(State state);\n+\n+};\n+\n+\n+#endif \/\/SHARE_VM_GC_SHENANDOAH_SHENANDOAHOLDGENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -100,0 +101,1 @@\n+    case init_scan_rset:\n@@ -111,0 +113,1 @@\n+    case degen_gc_coalesce_and_fill:\n@@ -115,0 +118,1 @@\n+    case conc_mark:\n@@ -120,0 +124,1 @@\n+    case conc_coalesce_and_fill:\n@@ -315,1 +320,1 @@\n-        ShenandoahPhaseTimings::ParPhase par_phase, uint worker_id) :\n+        ShenandoahPhaseTimings::ParPhase par_phase, uint worker_id, bool cumulative) :\n@@ -319,1 +324,1 @@\n-  assert(_timings->worker_data(_phase, _par_phase)->get(_worker_id) == ShenandoahWorkerData::uninitialized(),\n+  assert(_timings->worker_data(_phase, _par_phase)->get(_worker_id) == ShenandoahWorkerData::uninitialized() || cumulative,\n@@ -325,1 +330,1 @@\n-  _timings->worker_data(_phase, _par_phase)->set(_worker_id, os::elapsedTime() - _start_time);\n+  _timings->worker_data(_phase, _par_phase)->set_or_add(_worker_id, os::elapsedTime() - _start_time);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -47,0 +48,1 @@\n+  f(CNT_PREFIX ## ScanClusters,             DESC_PREFIX \"Scan Clusters\")               \\\n@@ -51,1 +53,1 @@\n-                                                                                       \\\n+  f(conc_reset_old,                                 \"Concurrent Reset (OLD)\")          \\\n@@ -55,0 +57,2 @@\n+  f(init_swap_rset,                                 \"  Swap Remembered Set\")           \\\n+  f(init_transfer_satb,                             \"  Transfer Old From SATB\")        \\\n@@ -57,0 +61,3 @@\n+  f(init_scan_rset,                                 \"Concurrent Scan Remembered Set\")  \\\n+  SHENANDOAH_PAR_PHASE_DO(init_scan_rset_,          \"  RS: \", f)                       \\\n+                                                                                       \\\n@@ -60,0 +67,1 @@\n+  SHENANDOAH_PAR_PHASE_DO(conc_mark,                \"  CM: \", f)                       \\\n@@ -99,1 +107,1 @@\n-                                                                                       \\\n+  f(promote_in_place,                               \"Concurrent Promote Regions\")      \\\n@@ -118,0 +126,2 @@\n+  f(conc_coalesce_and_fill,                         \"Concurrent Coalesce and Fill\")    \\\n+  SHENANDOAH_PAR_PHASE_DO(conc_coalesce_,           \"  CC&F: \", f)                     \\\n@@ -147,0 +157,3 @@\n+  f(degen_gc_promote_regions,                       \"  Degen Promote Regions\")         \\\n+  f(degen_gc_coalesce_and_fill,                     \"  Degen Coalesce and Fill\")       \\\n+  SHENANDOAH_PAR_PHASE_DO(degen_coalesce_,          \"    DC&F\", f)                     \\\n@@ -173,0 +186,1 @@\n+  f(full_gc_recompute_generation_usage,             \"    Recompute generation usage\")  \\\n@@ -175,0 +189,1 @@\n+  f(full_gc_reconstruct_remembered_set,             \"    Reconstruct Remembered Set\")  \\\n@@ -253,1 +268,4 @@\n-  ShenandoahWorkerTimingsTracker(ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase, uint worker_id);\n+  ShenandoahWorkerTimingsTracker(ShenandoahPhaseTimings::Phase phase,\n+                                 ShenandoahPhaseTimings::ParPhase par_phase,\n+                                 uint worker_id,\n+                                 bool cumulative = false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -60,0 +63,17 @@\n+template <typename T>\n+static void card_mark_barrier(T* field, oop value) {\n+  assert(ShenandoahCardBarrier, \"Card-mark barrier should be on\");\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  assert(heap->is_in_or_null(value), \"Should be in heap\");\n+  if (heap->is_in_old(field) && heap->is_in_young(value)) {\n+    \/\/ For Shenandoah, each generation collects all the _referents_ that belong to the\n+    \/\/ collected generation. We can end up with discovered lists that contain a mixture\n+    \/\/ of old and young _references_. These references are linked together through the\n+    \/\/ discovered field in java.lang.Reference. In some cases, creating or editing this\n+    \/\/ list may result in the creation of _new_ old-to-young pointers which must dirty\n+    \/\/ the corresponding card. Failing to do this may cause heap verification errors and\n+    \/\/ lead to incorrect GC behavior.\n+    heap->old_generation()->mark_card_as_dirty(field);\n+  }\n+}\n+\n@@ -66,0 +86,3 @@\n+  if (ShenandoahCardBarrier) {\n+    card_mark_barrier(field, value);\n+  }\n@@ -71,0 +94,3 @@\n+  if (ShenandoahCardBarrier) {\n+    card_mark_barrier(field, value);\n+  }\n@@ -271,0 +297,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -287,0 +314,5 @@\n+  if (!heap->is_in_active_generation(referent)) {\n+    log_trace(gc,ref)(\"Referent outside of active generation: \" PTR_FORMAT, p2i(referent));\n+    return false;\n+  }\n+\n@@ -352,0 +384,3 @@\n+  \/\/ Each worker thread has a private copy of refproc_data, which includes a private discovered list.  This means\n+  \/\/ there's no risk that a different worker thread will try to manipulate my discovered list head while I'm making\n+  \/\/ reference the head of my discovered list.\n@@ -360,0 +395,11 @@\n+    \/\/ We successfully set this reference object's next pointer to discovered_head.  This marks reference as discovered.\n+    \/\/ If reference_cas_discovered fails, that means some other worker thread took credit for discovery of this reference,\n+    \/\/ and that other thread will place reference on its discovered list, so I can ignore reference.\n+\n+    \/\/ In case we have created an interesting pointer, mark the remembered set card as dirty.\n+    if (ShenandoahCardBarrier) {\n+      T* addr = reinterpret_cast<T*>(java_lang_ref_Reference::discovered_addr_raw(reference));\n+      card_mark_barrier(addr, discovered_head);\n+    }\n+\n+    \/\/ Make the discovered_list_head point to reference.\n@@ -374,1 +420,2 @@\n-  log_trace(gc, ref)(\"Encountered Reference: \" PTR_FORMAT \" (%s)\", p2i(reference), reference_type_name(type));\n+  log_trace(gc, ref)(\"Encountered Reference: \" PTR_FORMAT \" (%s, %s)\",\n+          p2i(reference), reference_type_name(type), ShenandoahHeap::heap()->heap_region_containing(reference)->affiliation_name());\n@@ -389,1 +436,0 @@\n-#ifdef ASSERT\n@@ -391,0 +437,2 @@\n+\n+#ifdef ASSERT\n@@ -398,0 +446,7 @@\n+  \/\/ When this reference was discovered, it would not have been marked. If it ends up surviving\n+  \/\/ the cycle, we need to dirty the card if the reference is old and the referent is young.  Note\n+  \/\/ that if the reference is not dropped, then its pointer to the referent will be nulled before\n+  \/\/ evacuation begins so card does not need to be dirtied.\n+  if (ShenandoahCardBarrier) {\n+    card_mark_barrier(cast_from_oop<HeapWord*>(reference), cast_to_oop(raw_referent));\n+  }\n@@ -449,0 +504,1 @@\n+  \/\/ set_oop_field maintains the card mark barrier as this list is constructed.\n@@ -453,1 +509,1 @@\n-    RawAccess<>::oop_store(p, prev);\n+    set_oop_field(p, prev);\n@@ -525,0 +581,13 @@\n+\n+  \/\/ During reference processing, we maintain a local list of references that are identified by\n+  \/\/   _pending_list and _pending_list_tail.  _pending_list_tail points to the next field of the last Reference object on\n+  \/\/   the local list.\n+  \/\/\n+  \/\/ There is also a global list of reference identified by Universe::_reference_pending_list\n+\n+  \/\/ The following code has the effect of:\n+  \/\/  1. Making the global Universe::_reference_pending_list point to my local list\n+  \/\/  2. Overwriting the next field of the last Reference on my local list to point at the previous head of the\n+  \/\/     global Universe::_reference_pending_list\n+\n+  oop former_head_of_global_list = Universe::swap_reference_pending_list(_pending_list);\n@@ -526,1 +595,1 @@\n-    *reinterpret_cast<narrowOop*>(_pending_list_tail) = CompressedOops::encode(Universe::swap_reference_pending_list(_pending_list));\n+    set_oop_field<narrowOop>(reinterpret_cast<narrowOop*>(_pending_list_tail), former_head_of_global_list);\n@@ -528,1 +597,1 @@\n-    *reinterpret_cast<oop*>(_pending_list_tail) = Universe::swap_reference_pending_list(_pending_list);\n+    set_oop_field<oop>(reinterpret_cast<oop*>(_pending_list_tail), former_head_of_global_list);\n@@ -537,1 +606,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":74,"deletions":6,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahRegulatorThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+ShenandoahRegulatorThread::ShenandoahRegulatorThread(ShenandoahGenerationalControlThread* control_thread) :\n+  ConcurrentGCThread(),\n+  _control_thread(control_thread),\n+  _sleep(ShenandoahControlIntervalMin),\n+  _last_sleep_adjust_time(os::elapsedTime()) {\n+  shenandoah_assert_generational();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  _old_heuristics = heap->old_generation()->heuristics();\n+  _young_heuristics = heap->young_generation()->heuristics();\n+  _global_heuristics = heap->global_generation()->heuristics();\n+\n+  set_name(\"Shenandoah Regulator Thread\");\n+  create_and_start();\n+}\n+\n+void ShenandoahRegulatorThread::run_service() {\n+  if (ShenandoahAllowOldMarkingPreemption) {\n+    regulate_young_and_old_cycles();\n+  } else {\n+    regulate_young_and_global_cycles();\n+  }\n+\n+  log_debug(gc)(\"%s: Done.\", name());\n+}\n+\n+void ShenandoahRegulatorThread::regulate_young_and_old_cycles() {\n+  while (!should_terminate()) {\n+    ShenandoahGenerationalControlThread::GCMode mode = _control_thread->gc_mode();\n+    if (mode == ShenandoahGenerationalControlThread::none) {\n+      if (should_start_metaspace_gc()) {\n+        if (request_concurrent_gc(GLOBAL)) {\n+          log_debug(gc)(\"Heuristics request for global (unload classes) accepted.\");\n+        }\n+      } else {\n+        if (_young_heuristics->should_start_gc()) {\n+          \/\/ Give the old generation a chance to run. The old generation cycle\n+          \/\/ begins with a 'bootstrap' cycle that will also collect young.\n+          if (start_old_cycle()) {\n+            log_debug(gc)(\"Heuristics request for old collection accepted\");\n+          } else if (request_concurrent_gc(YOUNG)) {\n+            log_debug(gc)(\"Heuristics request for young collection accepted\");\n+          }\n+        }\n+      }\n+    } else if (mode == ShenandoahGenerationalControlThread::servicing_old) {\n+      if (start_young_cycle()) {\n+        log_debug(gc)(\"Heuristics request to interrupt old for young collection accepted\");\n+      }\n+    }\n+\n+    regulator_sleep();\n+  }\n+}\n+\n+\n+void ShenandoahRegulatorThread::regulate_young_and_global_cycles() {\n+  while (!should_terminate()) {\n+    if (_control_thread->gc_mode() == ShenandoahGenerationalControlThread::none) {\n+      if (start_global_cycle()) {\n+        log_debug(gc)(\"Heuristics request for global collection accepted.\");\n+      } else if (start_young_cycle()) {\n+        log_debug(gc)(\"Heuristics request for young collection accepted.\");\n+      }\n+    }\n+\n+    regulator_sleep();\n+  }\n+}\n+\n+void ShenandoahRegulatorThread::regulator_sleep() {\n+  \/\/ Wait before performing the next action. If allocation happened during this wait,\n+  \/\/ we exit sooner, to let heuristics re-evaluate new conditions. If we are at idle,\n+  \/\/ back off exponentially.\n+  double current = os::elapsedTime();\n+\n+  if (ShenandoahHeap::heap()->has_changed()) {\n+    _sleep = ShenandoahControlIntervalMin;\n+  } else if ((current - _last_sleep_adjust_time) * 1000 > ShenandoahControlIntervalAdjustPeriod){\n+    _sleep = MIN2<uint>(ShenandoahControlIntervalMax, MAX2(1u, _sleep * 2));\n+    _last_sleep_adjust_time = current;\n+  }\n+\n+  os::naked_short_sleep(_sleep);\n+  if (LogTarget(Debug, gc, thread)::is_enabled()) {\n+    double elapsed = os::elapsedTime() - current;\n+    double hiccup = elapsed - double(_sleep);\n+    if (hiccup > 0.001) {\n+      log_debug(gc, thread)(\"Regulator hiccup time: %.3fs\", hiccup);\n+    }\n+  }\n+}\n+\n+bool ShenandoahRegulatorThread::start_old_cycle() {\n+  return _old_heuristics->should_start_gc() && request_concurrent_gc(OLD);\n+}\n+\n+bool ShenandoahRegulatorThread::start_young_cycle() {\n+  return _young_heuristics->should_start_gc() && request_concurrent_gc(YOUNG);\n+}\n+\n+bool ShenandoahRegulatorThread::start_global_cycle() {\n+  return _global_heuristics->should_start_gc() && request_concurrent_gc(GLOBAL);\n+}\n+\n+bool ShenandoahRegulatorThread::request_concurrent_gc(ShenandoahGenerationType generation) {\n+  double now = os::elapsedTime();\n+  bool accepted = _control_thread->request_concurrent_gc(generation);\n+  if (LogTarget(Debug, gc, thread)::is_enabled() && accepted) {\n+    double wait_time = os::elapsedTime() - now;\n+    if (wait_time > 0.001) {\n+      log_debug(gc, thread)(\"Regulator waited %.3fs for control thread to acknowledge request.\", wait_time);\n+    }\n+  }\n+  return accepted;\n+}\n+\n+void ShenandoahRegulatorThread::stop_service() {\n+  log_debug(gc)(\"%s: Stop requested.\", name());\n+}\n+\n+bool ShenandoahRegulatorThread::should_start_metaspace_gc() {\n+  \/\/ The generational mode can, at present, only unload classes during a global\n+  \/\/ cycle. For this reason, we treat an oom in metaspace as a _trigger_ for a\n+  \/\/ global cycle. But, we check other prerequisites before starting a gc that won't\n+  \/\/ unload anything.\n+  return ClassUnloadingWithConcurrentMark\n+      && _global_heuristics->can_unload_classes()\n+      && _global_heuristics->has_metaspace_oom();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHREGULATORTHREAD_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHREGULATORTHREAD_HPP\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+\n+class ShenandoahHeuristics;\n+class ShenandoahGenerationalControlThread;\n+\n+\/*\n+ * The purpose of this class (and thread) is to allow us to continue\n+ * to evaluate heuristics during a garbage collection. This is necessary\n+ * to allow young generation collections to interrupt an old generation\n+ * collection which is in-progress. This puts heuristic triggers on the\n+ * same footing as other gc requests (alloc failure, System.gc, etc.).\n+ * However, this regulator does not block after submitting a gc request.\n+ *\n+ * We could use a PeriodicTask for this, but this thread will sleep longer\n+ * when the allocation rate is lower and PeriodicTasks cannot adjust their\n+ * sleep time.\n+ *\/\n+class ShenandoahRegulatorThread: public ConcurrentGCThread {\n+  friend class VMStructs;\n+\n+ public:\n+  explicit ShenandoahRegulatorThread(ShenandoahGenerationalControlThread* control_thread);\n+\n+ protected:\n+  void run_service() override;\n+  void stop_service() override;\n+\n+ private:\n+  \/\/ When mode is generational\n+  void regulate_young_and_old_cycles();\n+  \/\/ When mode is generational, but ShenandoahAllowOldMarkingPreemption is false\n+  void regulate_young_and_global_cycles();\n+\n+  \/\/ These return true if a cycle was started.\n+  bool start_old_cycle();\n+  bool start_young_cycle();\n+  bool start_global_cycle();\n+\n+  \/\/ The generational mode can only unload classes in a global cycle. The regulator\n+  \/\/ thread itself will trigger a global cycle if metaspace is out of memory.\n+  bool should_start_metaspace_gc();\n+\n+  \/\/ Regulator will sleep longer when the allocation rate is lower.\n+  void regulator_sleep();\n+\n+  \/\/ Provides instrumentation to track how long it takes to acknowledge a request.\n+  bool request_concurrent_gc(ShenandoahGenerationType generation);\n+\n+  ShenandoahGenerationalControlThread* _control_thread;\n+  ShenandoahHeuristics* _young_heuristics;\n+  ShenandoahHeuristics* _old_heuristics;\n+  ShenandoahHeuristics* _global_heuristics;\n+\n+  uint _sleep;\n+  double _last_sleep_adjust_time;\n+};\n+\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHREGULATORTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -56,1 +59,1 @@\n-void ShenandoahRootVerifier::roots_do(OopClosure* oops) {\n+void ShenandoahRootVerifier::roots_do(OopIterateClosure* oops) {\n@@ -70,0 +73,6 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational() && heap->active_generation()->is_young()) {\n+    shenandoah_assert_safepoint();\n+    ShenandoahGenerationalHeap::heap()->old_generation()->card_scan()->roots_do(oops);\n+  }\n+\n@@ -76,1 +85,1 @@\n-void ShenandoahRootVerifier::strong_roots_do(OopClosure* oops) {\n+void ShenandoahRootVerifier::strong_roots_do(OopIterateClosure* oops) {\n@@ -86,0 +95,6 @@\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational() && heap->active_generation()->is_young()) {\n+    ShenandoahGenerationalHeap::heap()->old_generation()->card_scan()->roots_do(oops);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,2 +45,2 @@\n-  static void roots_do(OopClosure* cl);\n-  static void strong_roots_do(OopClosure* cl);\n+  static void roots_do(OopIterateClosure* cl);\n+  static void strong_roots_do(OopIterateClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -59,2 +61,2 @@\n-ShenandoahSTWMark::ShenandoahSTWMark(bool full_gc) :\n-  ShenandoahMark(),\n+ShenandoahSTWMark::ShenandoahSTWMark(ShenandoahGeneration* generation, bool full_gc) :\n+  ShenandoahMark(generation),\n@@ -62,1 +64,1 @@\n-  _terminator(ShenandoahHeap::heap()->workers()->active_workers(), ShenandoahHeap::heap()->marking_context()->task_queues()),\n+  _terminator(ShenandoahHeap::heap()->workers()->active_workers(), task_queues()),\n@@ -75,1 +77,3 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  assert(ShenandoahHeap::heap()->gc_generation() == _generation, \"Marking unexpected generation\");\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+  shenandoah_assert_generations_reconciled();\n@@ -94,0 +98,5 @@\n+    if (_generation->is_young()) {\n+      \/\/ But only scan the remembered set for young generation.\n+      _generation->scan_remembered_set(false \/* is_concurrent *\/);\n+    }\n+\n@@ -101,1 +110,1 @@\n-  heap->mark_complete_marking_context();\n+  _generation->set_mark_complete();\n@@ -112,3 +121,26 @@\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n-  ShenandoahMarkRefsClosure<NON_GEN> cl(task_queues()->queue(worker_id), rp);\n-  _root_scanner.roots_do(&cl, worker_id);\n+  assert(ShenandoahHeap::heap()->gc_generation() == _generation, \"Marking unexpected generation\");\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+  auto queue = task_queues()->queue(worker_id);\n+  switch (_generation->type()) {\n+    case NON_GEN: {\n+      ShenandoahMarkRefsClosure<NON_GEN> init_mark(queue, rp, nullptr);\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case GLOBAL: {\n+      ShenandoahMarkRefsClosure<GLOBAL> init_mark(queue, rp, nullptr);\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case YOUNG: {\n+      ShenandoahMarkRefsClosure<YOUNG> init_mark(queue, rp, nullptr);\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case OLD:\n+      \/\/ We never exclusively mark the old generation on a safepoint. This would be encompassed\n+      \/\/ by a 'global' collection. Note that both GLOBAL and NON_GEN mark the entire heap, but\n+      \/\/ the GLOBAL closure is specialized for the generational mode.\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -118,0 +150,1 @@\n+  assert(ShenandoahHeap::heap()->gc_generation() == _generation, \"Marking unexpected generation\");\n@@ -120,1 +153,2 @@\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+  shenandoah_assert_generations_reconciled();\n@@ -123,1 +157,2 @@\n-  mark_loop(worker_id, &_terminator, rp, NON_GEN, false \/* not cancellable *\/,\n+  mark_loop(worker_id, &_terminator, rp,\n+            _generation->type(), false \/* not cancellable *\/,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahRootProcessor.hpp\"\n@@ -31,0 +32,1 @@\n+class ShenandoahGeneration;\n@@ -40,1 +42,1 @@\n- ShenandoahSTWMark(bool full_gc);\n+ ShenandoahSTWMark(ShenandoahGeneration* generation, bool full_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,973 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+size_t ShenandoahDirectCardMarkRememberedSet::last_valid_index() const {\n+  return _card_table->last_valid_index();\n+}\n+\n+size_t ShenandoahDirectCardMarkRememberedSet::total_cards() const {\n+  return _total_card_count;\n+}\n+\n+size_t ShenandoahDirectCardMarkRememberedSet::card_index_for_addr(HeapWord *p) const {\n+  return _card_table->index_for(p);\n+}\n+\n+HeapWord* ShenandoahDirectCardMarkRememberedSet::addr_for_card_index(size_t card_index) const {\n+  return _whole_heap_base + CardTable::card_size_in_words() * card_index;\n+}\n+\n+bool ShenandoahDirectCardMarkRememberedSet::is_write_card_dirty(size_t card_index) const {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+bool ShenandoahDirectCardMarkRememberedSet::is_card_dirty(size_t card_index) const {\n+  CardValue* bp = &(_card_table->read_byte_map())[card_index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(size_t card_index) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  bp[0] = CardTable::dirty_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(size_t card_index, size_t num_cards) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  while (num_cards-- > 0) {\n+    *bp++ = CardTable::dirty_card_val();\n+  }\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(size_t card_index) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  bp[0] = CardTable::clean_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(size_t card_index, size_t num_cards) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  while (num_cards-- > 0) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+}\n+\n+bool ShenandoahDirectCardMarkRememberedSet::is_card_dirty(HeapWord* p) const {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->read_byte_map())[index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+bool ShenandoahDirectCardMarkRememberedSet::is_write_card_dirty(HeapWord* p) const {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(HeapWord* p) {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  bp[0] = CardTable::dirty_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(HeapWord* p, size_t num_heap_words) {\n+  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n+  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n+  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to dirty last card.\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n+    end_bp++;\n+  }\n+  while (bp < end_bp) {\n+    *bp++ = CardTable::dirty_card_val();\n+  }\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord* p) {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  bp[0] = CardTable::clean_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n+  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n+  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n+  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to clean last card.\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n+    end_bp++;\n+  }\n+  while (bp < end_bp) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+}\n+\n+\/\/ No lock required because arguments align with card boundaries.\n+void ShenandoahCardCluster::reset_object_range(HeapWord* from, HeapWord* to) {\n+  assert(((((unsigned long long) from) & (CardTable::card_size() - 1)) == 0) &&\n+         ((((unsigned long long) to) & (CardTable::card_size() - 1)) == 0),\n+         \"reset_object_range bounds must align with card boundaries\");\n+  size_t card_at_start = _rs->card_index_for_addr(from);\n+  size_t num_cards = (to - from) \/ CardTable::card_size_in_words();\n+\n+  for (size_t i = 0; i < num_cards; i++) {\n+    _object_starts[card_at_start + i].short_word = 0;\n+  }\n+}\n+\n+\/\/ Assume only one thread at a time registers objects pertaining to\n+\/\/ each card-table entry's range of memory.\n+void ShenandoahCardCluster::register_object(HeapWord* address) {\n+  shenandoah_assert_heaplocked();\n+\n+  register_object_without_lock(address);\n+}\n+\n+void ShenandoahCardCluster::register_object_without_lock(HeapWord* address) {\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n+  HeapWord* card_start_address = _rs->addr_for_card_index(card_at_start);\n+  uint8_t offset_in_card = checked_cast<uint8_t>(pointer_delta(address, card_start_address));\n+\n+  if (!starts_object(card_at_start)) {\n+    set_starts_object_bit(card_at_start);\n+    set_first_start(card_at_start, offset_in_card);\n+    set_last_start(card_at_start, offset_in_card);\n+  } else {\n+    if (offset_in_card < get_first_start(card_at_start))\n+      set_first_start(card_at_start, offset_in_card);\n+    if (offset_in_card > get_last_start(card_at_start))\n+      set_last_start(card_at_start, offset_in_card);\n+  }\n+}\n+\n+void ShenandoahCardCluster::coalesce_objects(HeapWord* address, size_t length_in_words) {\n+\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n+  HeapWord* card_start_address = _rs->addr_for_card_index(card_at_start);\n+  size_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words();\n+\n+  if (card_at_start == card_at_end) {\n+    \/\/ There are no changes to the get_first_start array.  Either get_first_start(card_at_start) returns this coalesced object,\n+    \/\/ or it returns an object that precedes the coalesced object.\n+    if (card_start_address + get_last_start(card_at_start) < address + length_in_words) {\n+      uint8_t coalesced_offset = checked_cast<uint8_t>(pointer_delta(address, card_start_address));\n+      \/\/ The object that used to be the last object starting within this card is being subsumed within the coalesced\n+      \/\/ object.  Since we always coalesce entire objects, this condition only occurs if the last object ends before or at\n+      \/\/ the end of the card's memory range and there is no object following this object.  In this case, adjust last_start\n+      \/\/ to represent the start of the coalesced range.\n+      set_last_start(card_at_start, coalesced_offset);\n+    }\n+    \/\/ Else, no changes to last_starts information.  Either get_last_start(card_at_start) returns the object that immediately\n+    \/\/ follows the coalesced object, or it returns an object that follows the object immediately following the coalesced object.\n+  } else {\n+    uint8_t coalesced_offset = checked_cast<uint8_t>(pointer_delta(address, card_start_address));\n+    if (get_last_start(card_at_start) > coalesced_offset) {\n+      \/\/ Existing last start is being coalesced, create new last start\n+      set_last_start(card_at_start, coalesced_offset);\n+    }\n+    \/\/ otherwise, get_last_start(card_at_start) must equal coalesced_offset\n+\n+    \/\/ All the cards between first and last get cleared.\n+    for (size_t i = card_at_start + 1; i < card_at_end; i++) {\n+      clear_starts_object_bit(i);\n+    }\n+\n+    uint8_t follow_offset = checked_cast<uint8_t>((address + length_in_words) - _rs->addr_for_card_index(card_at_end));\n+    if (starts_object(card_at_end) && (get_first_start(card_at_end) < follow_offset)) {\n+      \/\/ It may be that after coalescing within this last card's memory range, the last card\n+      \/\/ no longer holds an object.\n+      if (get_last_start(card_at_end) >= follow_offset) {\n+        set_first_start(card_at_end, follow_offset);\n+      } else {\n+        \/\/ last_start is being coalesced so this card no longer has any objects.\n+        clear_starts_object_bit(card_at_end);\n+      }\n+    }\n+    \/\/ else\n+    \/\/  card_at_end did not have an object, so it still does not have an object, or\n+    \/\/  card_at_end had an object that starts after the coalesced object, so no changes required for card_at_end\n+\n+  }\n+}\n+\n+\n+size_t ShenandoahCardCluster::get_first_start(size_t card_index) const {\n+  assert(starts_object(card_index), \"Can't get first start because no object starts here\");\n+  return _object_starts[card_index].offsets.first & FirstStartBits;\n+}\n+\n+size_t ShenandoahCardCluster::get_last_start(size_t card_index) const {\n+  assert(starts_object(card_index), \"Can't get last start because no object starts here\");\n+  return _object_starts[card_index].offsets.last;\n+}\n+\n+\/\/ Given a card_index, return the starting address of the first block in the heap\n+\/\/ that straddles into this card. If this card is co-initial with an object, then\n+\/\/ this would return the first address of the range that this card covers, which is\n+\/\/ where the card's first object also begins.\n+HeapWord* ShenandoahCardCluster::block_start(const size_t card_index) const {\n+\n+  HeapWord* left = _rs->addr_for_card_index(card_index);\n+\n+#ifdef ASSERT\n+  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Do not use in non-generational mode\");\n+  ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(left);\n+  assert(region->is_old(), \"Do not use for young regions\");\n+  \/\/ For HumongousRegion:s it's more efficient to jump directly to the\n+  \/\/ start region.\n+  assert(!region->is_humongous(), \"Use region->humongous_start_region() instead\");\n+#endif\n+  if (starts_object(card_index) && get_first_start(card_index) == 0) {\n+    \/\/ This card contains a co-initial object; a fortiori, it covers\n+    \/\/ also the case of a card being the first in a region.\n+    assert(oopDesc::is_oop(cast_to_oop(left)), \"Should be an object\");\n+    return left;\n+  }\n+\n+  HeapWord* p = nullptr;\n+  oop obj = cast_to_oop(p);\n+  ssize_t cur_index = (ssize_t)card_index;\n+  assert(cur_index >= 0, \"Overflow\");\n+  assert(cur_index > 0, \"Should have returned above\");\n+  \/\/ Walk backwards over the cards...\n+  while (--cur_index > 0 && !starts_object(cur_index)) {\n+   \/\/ ... to the one that starts the object\n+  }\n+  \/\/ cur_index should start an object: we should not have walked\n+  \/\/ past the left end of the region.\n+  assert(cur_index >= 0 && (cur_index <= (ssize_t)card_index), \"Error\");\n+  assert(region->bottom() <= _rs->addr_for_card_index(cur_index),\n+         \"Fell off the bottom of containing region\");\n+  assert(starts_object(cur_index), \"Error\");\n+  size_t offset = get_last_start(cur_index);\n+  \/\/ can avoid call via card size arithmetic below instead\n+  p = _rs->addr_for_card_index(cur_index) + offset;\n+  \/\/ Recall that we already dealt with the co-initial object case above\n+  assert(p < left, \"obj should start before left\");\n+  \/\/ While it is safe to ask an object its size in the loop that\n+  \/\/ follows, the (ifdef'd out) loop should never be needed.\n+  \/\/ 1. we ask this question only for regions in the old generation\n+  \/\/ 2. there is no direct allocation ever by mutators in old generation\n+  \/\/    regions. Only GC will ever allocate in old regions, and then\n+  \/\/    too only during promotion\/evacuation phases. Thus there is no danger\n+  \/\/    of races between reading from and writing to the object start array,\n+  \/\/    or of asking partially initialized objects their size (in the loop below).\n+  \/\/ 3. only GC asks this question during phases when it is not concurrently\n+  \/\/    evacuating\/promoting, viz. during concurrent root scanning (before\n+  \/\/    the evacuation phase) and during concurrent update refs (after the\n+  \/\/    evacuation phase) of young collections. This is never called\n+  \/\/    during old or global collections.\n+  \/\/ 4. Every allocation under TAMS updates the object start array.\n+  NOT_PRODUCT(obj = cast_to_oop(p);)\n+  assert(oopDesc::is_oop(obj), \"Should be an object\");\n+#define WALK_FORWARD_IN_BLOCK_START false\n+  while (WALK_FORWARD_IN_BLOCK_START && p + obj->size() < left) {\n+    p += obj->size();\n+  }\n+#undef WALK_FORWARD_IN_BLOCK_START \/\/ false\n+  assert(p + obj->size() > left, \"obj should end after left\");\n+  return p;\n+}\n+\n+size_t ShenandoahScanRemembered::card_index_for_addr(HeapWord* p) {\n+  return _rs->card_index_for_addr(p);\n+}\n+\n+HeapWord* ShenandoahScanRemembered::addr_for_card_index(size_t card_index) {\n+  return _rs->addr_for_card_index(card_index);\n+}\n+\n+bool ShenandoahScanRemembered::is_card_dirty(size_t card_index) {\n+  return _rs->is_card_dirty(card_index);\n+}\n+\n+bool ShenandoahScanRemembered::is_write_card_dirty(size_t card_index) {\n+  return _rs->is_write_card_dirty(card_index);\n+}\n+\n+bool ShenandoahScanRemembered::is_card_dirty(HeapWord* p) {\n+  return _rs->is_card_dirty(p);\n+}\n+\n+void ShenandoahScanRemembered::mark_card_as_dirty(HeapWord* p) {\n+  _rs->mark_card_as_dirty(p);\n+}\n+\n+bool ShenandoahScanRemembered::is_write_card_dirty(HeapWord* p) {\n+  return _rs->is_write_card_dirty(p);\n+}\n+\n+void ShenandoahScanRemembered::mark_range_as_dirty(HeapWord* p, size_t num_heap_words) {\n+  _rs->mark_range_as_dirty(p, num_heap_words);\n+}\n+\n+void ShenandoahScanRemembered::mark_card_as_clean(HeapWord* p) {\n+  _rs->mark_card_as_clean(p);\n+}\n+\n+void ShenandoahScanRemembered:: mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n+  _rs->mark_range_as_clean(p, num_heap_words);\n+}\n+\n+void ShenandoahScanRemembered::reset_object_range(HeapWord* from, HeapWord* to) {\n+  _scc->reset_object_range(from, to);\n+}\n+\n+void ShenandoahScanRemembered::register_object(HeapWord* addr) {\n+  _scc->register_object(addr);\n+}\n+\n+void ShenandoahScanRemembered::register_object_without_lock(HeapWord* addr) {\n+  _scc->register_object_without_lock(addr);\n+}\n+\n+bool ShenandoahScanRemembered::verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx) {\n+\n+  size_t index = card_index_for_addr(address);\n+  if (!_scc->starts_object(index)) {\n+    return false;\n+  }\n+  HeapWord* base_addr = addr_for_card_index(index);\n+  size_t offset = _scc->get_first_start(index);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ Verify that I can find this object within its enclosing card by scanning forward from first_start.\n+  while (base_addr + offset < address) {\n+    oop obj = cast_to_oop(base_addr + offset);\n+    if (!ctx || ctx->is_marked(obj)) {\n+      offset += obj->size();\n+    } else {\n+      \/\/ If this object is not live, don't trust its size(); all objects above tams are live.\n+      ShenandoahHeapRegion* r = heap->heap_region_containing(obj);\n+      HeapWord* tams = ctx->top_at_mark_start(r);\n+      offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n+    }\n+  }\n+  if (base_addr + offset != address){\n+    return false;\n+  }\n+\n+  \/\/ At this point, offset represents object whose registration we are verifying.  We know that at least this object resides\n+  \/\/ within this card's memory.\n+\n+  \/\/ Make sure that last_offset is properly set for the enclosing card, but we can't verify this for\n+  \/\/ candidate collection-set regions during mixed evacuations, so disable this check in general\n+  \/\/ during mixed evacuations.\n+\n+  ShenandoahHeapRegion* r = heap->heap_region_containing(base_addr + offset);\n+  size_t max_offset = r->top() - base_addr;\n+  if (max_offset > CardTable::card_size_in_words()) {\n+    max_offset = CardTable::card_size_in_words();\n+  }\n+  size_t prev_offset;\n+  if (!ctx) {\n+    do {\n+      oop obj = cast_to_oop(base_addr + offset);\n+      prev_offset = offset;\n+      offset += obj->size();\n+    } while (offset < max_offset);\n+    if (_scc->get_last_start(index) != prev_offset) {\n+      return false;\n+    }\n+\n+    \/\/ base + offset represents address of first object that starts on following card, if there is one.\n+\n+    \/\/ Notes: base_addr is addr_for_card_index(index)\n+    \/\/        base_addr + offset is end of the object we are verifying\n+    \/\/        cannot use card_index_for_addr(base_addr + offset) because it asserts arg < end of whole heap\n+    size_t end_card_index = index + offset \/ CardTable::card_size_in_words();\n+\n+    if (end_card_index > index && end_card_index <= _rs->last_valid_index()) {\n+      \/\/ If there is a following object registered on the next card, it should begin where this object ends.\n+      if (_scc->starts_object(end_card_index) &&\n+          ((addr_for_card_index(end_card_index) + _scc->get_first_start(end_card_index)) != (base_addr + offset))) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ Assure that no other objects are registered \"inside\" of this one.\n+    for (index++; index < end_card_index; index++) {\n+      if (_scc->starts_object(index)) {\n+        return false;\n+      }\n+    }\n+  } else {\n+    \/\/ This is a mixed evacuation or a global collect: rely on mark bits to identify which objects need to be properly registered\n+    assert(!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Cannot rely on mark context here.\");\n+    \/\/ If the object reaching or spanning the end of this card's memory is marked, then last_offset for this card\n+    \/\/ should represent this object.  Otherwise, last_offset is a don't care.\n+    ShenandoahHeapRegion* region = heap->heap_region_containing(base_addr + offset);\n+    HeapWord* tams = ctx->top_at_mark_start(region);\n+    oop last_obj = nullptr;\n+    do {\n+      oop obj = cast_to_oop(base_addr + offset);\n+      if (ctx->is_marked(obj)) {\n+        prev_offset = offset;\n+        offset += obj->size();\n+        last_obj = obj;\n+      } else {\n+        offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n+        \/\/ If there are no marked objects remaining in this region, offset equals tams - base_addr.  If this offset is\n+        \/\/ greater than max_offset, we will immediately exit this loop.  Otherwise, the next iteration of the loop will\n+        \/\/ treat the object at offset as marked and live (because address >= tams) and we will continue iterating object\n+        \/\/ by consulting the size() fields of each.\n+      }\n+    } while (offset < max_offset);\n+    if (last_obj != nullptr && prev_offset + last_obj->size() >= max_offset) {\n+      \/\/ last marked object extends beyond end of card\n+      if (_scc->get_last_start(index) != prev_offset) {\n+        return false;\n+      }\n+      \/\/ otherwise, the value of _scc->get_last_start(index) is a don't care because it represents a dead object and we\n+      \/\/ cannot verify its context\n+    }\n+  }\n+  return true;\n+}\n+\n+void ShenandoahScanRemembered::coalesce_objects(HeapWord* addr, size_t length_in_words) {\n+  _scc->coalesce_objects(addr, length_in_words);\n+}\n+\n+void ShenandoahScanRemembered::mark_range_as_empty(HeapWord* addr, size_t length_in_words) {\n+  _rs->mark_range_as_clean(addr, length_in_words);\n+  _scc->clear_objects_in_range(addr, length_in_words);\n+}\n+\n+size_t ShenandoahScanRemembered::cluster_for_addr(HeapWordImpl **addr) {\n+  size_t card_index = _rs->card_index_for_addr(addr);\n+  size_t result = card_index \/ ShenandoahCardCluster::CardsPerCluster;\n+  return result;\n+}\n+\n+HeapWord* ShenandoahScanRemembered::addr_for_cluster(size_t cluster_no) {\n+  size_t card_index = cluster_no * ShenandoahCardCluster::CardsPerCluster;\n+  return addr_for_card_index(card_index);\n+}\n+\n+\/\/ This is used only for debug verification so don't worry about making the scan parallel.\n+void ShenandoahScanRemembered::roots_do(OopIterateClosure* cl) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  bool old_bitmap_stable = heap->old_generation()->is_mark_complete();\n+  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n+  for (size_t i = 0, n = heap->num_regions(); i < n; ++i) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (region->is_old() && region->is_active() && !region->is_cset()) {\n+      HeapWord* start_of_range = region->bottom();\n+      HeapWord* end_of_range = region->top();\n+      size_t start_cluster_no = cluster_for_addr(start_of_range);\n+      size_t num_heapwords = end_of_range - start_of_range;\n+      unsigned int cluster_size = CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n+      size_t num_clusters = (size_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n+\n+      \/\/ Remembered set scanner\n+      if (region->is_humongous()) {\n+        process_humongous_clusters(region->humongous_start_region(), start_cluster_no, num_clusters, end_of_range, cl,\n+                                   false \/* use_write_table *\/);\n+      } else {\n+        process_clusters(start_cluster_no, num_clusters, end_of_range, cl,\n+                         false \/* use_write_table *\/, 0 \/* fake worker id *\/);\n+      }\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+\/\/ Log given card stats\n+void ShenandoahScanRemembered::log_card_stats(HdrSeq* stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    log_info(gc, remset)(\"%18s: [ %8.2f %8.2f %8.2f %8.2f %8.2f ]\",\n+      _card_stats_name[i],\n+      stats[i].percentile(0), stats[i].percentile(25),\n+      stats[i].percentile(50), stats[i].percentile(75),\n+      stats[i].maximum());\n+  }\n+}\n+\n+\/\/ Log card stats for all nworkers for a specific phase t\n+void ShenandoahScanRemembered::log_card_stats(uint nworkers, CardStatLogType t) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+  HdrSeq* sum_stats = card_stats_for_phase(t);\n+  log_info(gc, remset)(\"%s\", _card_stat_log_type[t]);\n+  for (uint i = 0; i < nworkers; i++) {\n+    log_worker_card_stats(i, sum_stats);\n+  }\n+\n+  \/\/ Every so often, log the cumulative global stats\n+  if (++_card_stats_log_counter[t] >= ShenandoahCardStatsLogInterval) {\n+    _card_stats_log_counter[t] = 0;\n+    log_info(gc, remset)(\"Cumulative stats\");\n+    log_card_stats(sum_stats);\n+  }\n+}\n+\n+\/\/ Log card stats for given worker_id, & clear them after merging into given cumulative stats\n+void ShenandoahScanRemembered::log_worker_card_stats(uint worker_id, HdrSeq* sum_stats) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+\n+  HdrSeq* worker_card_stats = card_stats(worker_id);\n+  log_info(gc, remset)(\"Worker %u Card Stats: \", worker_id);\n+  log_card_stats(worker_card_stats);\n+  \/\/ Merge worker stats into the cumulative stats & clear worker stats\n+  merge_worker_card_stats_cumulative(worker_card_stats, sum_stats);\n+}\n+\n+void ShenandoahScanRemembered::merge_worker_card_stats_cumulative(\n+  HdrSeq* worker_stats, HdrSeq* sum_stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    sum_stats[i].add(worker_stats[i]);\n+    worker_stats[i].clear();\n+  }\n+}\n+#endif\n+\n+\/\/ A closure that takes an oop in the old generation and, if it's pointing\n+\/\/ into the young generation, dirties the corresponding remembered set entry.\n+\/\/ This is only used to rebuild the remembered set after a full GC.\n+class ShenandoahDirtyRememberedSetClosure : public BasicOopIterateClosure {\n+protected:\n+  ShenandoahGenerationalHeap* const _heap;\n+  ShenandoahScanRemembered*   const _scanner;\n+\n+public:\n+  ShenandoahDirtyRememberedSetClosure() :\n+          _heap(ShenandoahGenerationalHeap::heap()),\n+          _scanner(_heap->old_generation()->card_scan()) {}\n+\n+  template<class T>\n+  inline void work(T* p) {\n+    assert(_heap->is_in_old(p), \"Expecting to get an old gen address\");\n+    T o = RawAccess<>::oop_load(p);\n+    if (!CompressedOops::is_null(o)) {\n+      oop obj = CompressedOops::decode_not_null(o);\n+      if (_heap->is_in_young(obj)) {\n+        \/\/ Dirty the card containing the cross-generational pointer.\n+        _scanner->mark_card_as_dirty((HeapWord*) p);\n+      }\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n+ShenandoahDirectCardMarkRememberedSet::ShenandoahDirectCardMarkRememberedSet(ShenandoahCardTable* card_table, size_t total_card_count) :\n+  LogCardValsPerIntPtr(log2i_exact(sizeof(intptr_t)) - log2i_exact(sizeof(CardValue))),\n+  LogCardSizeInWords(log2i_exact(CardTable::card_size_in_words())) {\n+\n+  \/\/ Paranoid assert for LogCardsPerIntPtr calculation above\n+  assert(sizeof(intptr_t) > sizeof(CardValue), \"LogsCardValsPerIntPtr would underflow\");\n+\n+  _heap = ShenandoahHeap::heap();\n+  _card_table = card_table;\n+  _total_card_count = total_card_count;\n+  _card_shift = CardTable::card_shift();\n+\n+  _byte_map = _card_table->byte_for_index(0);\n+\n+  _whole_heap_base = _card_table->addr_for(_byte_map);\n+  _byte_map_base = _byte_map - (uintptr_t(_whole_heap_base) >> _card_shift);\n+\n+  assert(total_card_count % ShenandoahCardCluster::CardsPerCluster == 0, \"Invalid card count.\");\n+  assert(total_card_count > 0, \"Card count cannot be zero.\");\n+}\n+\n+\/\/ Merge any dirty values from write table into the read table, while leaving\n+\/\/ the write table unchanged.\n+void ShenandoahDirectCardMarkRememberedSet::merge_write_table(HeapWord* start, size_t word_count) {\n+  size_t start_index = card_index_for_addr(start);\n+#ifdef ASSERT\n+  \/\/ avoid querying card_index_for_addr() for an address past end of heap\n+  size_t end_index = card_index_for_addr(start + word_count - 1) + 1;\n+#endif\n+  assert(start_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n+  assert(end_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n+\n+  \/\/ We'll access in groups of intptr_t worth of card entries\n+  intptr_t* const read_table  = (intptr_t*) &(_card_table->read_byte_map())[start_index];\n+  intptr_t* const write_table = (intptr_t*) &(_card_table->write_byte_map())[start_index];\n+\n+  \/\/ Avoid division, use shift instead\n+  assert(word_count % ((size_t)1 << (LogCardSizeInWords + LogCardValsPerIntPtr)) == 0, \"Expected a multiple of CardSizeInWords*CardValsPerIntPtr\");\n+  size_t const num = word_count >> (LogCardSizeInWords + LogCardValsPerIntPtr);\n+\n+  for (size_t i = 0; i < num; i++) {\n+    read_table[i] &= write_table[i];\n+  }\n+}\n+\n+\/\/ Destructively copy the write table to the read table, and clean the write table.\n+void ShenandoahDirectCardMarkRememberedSet::reset_remset(HeapWord* start, size_t word_count) {\n+  size_t start_index = card_index_for_addr(start);\n+#ifdef ASSERT\n+  \/\/ avoid querying card_index_for_addr() for an address past end of heap\n+  size_t end_index = card_index_for_addr(start + word_count - 1) + 1;\n+#endif\n+  assert(start_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n+  assert(end_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n+\n+  \/\/ We'll access in groups of intptr_t worth of card entries\n+  intptr_t* const read_table  = (intptr_t*) &(_card_table->read_byte_map())[start_index];\n+  intptr_t* const write_table = (intptr_t*) &(_card_table->write_byte_map())[start_index];\n+\n+  \/\/ Avoid division, use shift instead\n+  assert(word_count % ((size_t)1 << (LogCardSizeInWords + LogCardValsPerIntPtr)) == 0, \"Expected a multiple of CardSizeInWords*CardValsPerIntPtr\");\n+  size_t const num = word_count >> (LogCardSizeInWords + LogCardValsPerIntPtr);\n+\n+  for (size_t i = 0; i < num; i++) {\n+    read_table[i]  = write_table[i];\n+    write_table[i] = CardTable::clean_card_row_val();\n+  }\n+}\n+\n+ShenandoahScanRememberedTask::ShenandoahScanRememberedTask(ShenandoahObjToScanQueueSet* queue_set,\n+                                                           ShenandoahObjToScanQueueSet* old_queue_set,\n+                                                           ShenandoahReferenceProcessor* rp,\n+                                                           ShenandoahRegionChunkIterator* work_list, bool is_concurrent) :\n+  WorkerTask(\"Scan Remembered Set\"),\n+  _queue_set(queue_set), _old_queue_set(old_queue_set), _rp(rp), _work_list(work_list), _is_concurrent(is_concurrent) {\n+  bool old_bitmap_stable = ShenandoahHeap::heap()->old_generation()->is_mark_complete();\n+  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n+}\n+\n+void ShenandoahScanRememberedTask::work(uint worker_id) {\n+  if (_is_concurrent) {\n+    \/\/ This sets up a thread local reference to the worker_id which is needed by the weak reference processor.\n+    ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+    ShenandoahSuspendibleThreadSetJoiner stsj;\n+    do_work(worker_id);\n+  } else {\n+    \/\/ This sets up a thread local reference to the worker_id which is needed by the weak reference processor.\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    do_work(worker_id);\n+  }\n+}\n+\n+void ShenandoahScanRememberedTask::do_work(uint worker_id) {\n+  ShenandoahWorkerTimingsTracker x(ShenandoahPhaseTimings::init_scan_rset, ShenandoahPhaseTimings::ScanClusters, worker_id);\n+\n+  ShenandoahObjToScanQueue* q = _queue_set->queue(worker_id);\n+  ShenandoahObjToScanQueue* old = _old_queue_set == nullptr ? nullptr : _old_queue_set->queue(worker_id);\n+  ShenandoahMarkRefsClosure<YOUNG> cl(q, _rp, old);\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n+\n+  \/\/ set up thread local closure for shen ref processor\n+  _rp->set_mark_closure(worker_id, &cl);\n+  struct ShenandoahRegionChunk assignment;\n+  while (_work_list->next(&assignment)) {\n+    ShenandoahHeapRegion* region = assignment._r;\n+    log_debug(gc)(\"ShenandoahScanRememberedTask::do_work(%u), processing slice of region \"\n+                  SIZE_FORMAT \" at offset \" SIZE_FORMAT \", size: \" SIZE_FORMAT,\n+                  worker_id, region->index(), assignment._chunk_offset, assignment._chunk_size);\n+    if (region->is_old()) {\n+      size_t cluster_size =\n+        CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n+      size_t clusters = assignment._chunk_size \/ cluster_size;\n+      assert(clusters * cluster_size == assignment._chunk_size, \"Chunk assignments must align on cluster boundaries\");\n+      HeapWord* end_of_range = region->bottom() + assignment._chunk_offset + assignment._chunk_size;\n+\n+      \/\/ During concurrent mark, region->top() equals TAMS with respect to the current young-gen pass.\n+      if (end_of_range > region->top()) {\n+        end_of_range = region->top();\n+      }\n+      scanner->process_region_slice(region, assignment._chunk_offset, clusters, end_of_range, &cl, false, worker_id);\n+    }\n+#ifdef ENABLE_REMEMBERED_SET_CANCELLATION\n+    \/\/ This check is currently disabled to avoid crashes that occur\n+    \/\/ when we try to cancel remembered set scanning; it should be re-enabled\n+    \/\/ after the issues are fixed, as it would allow more prompt cancellation and\n+    \/\/ transition to degenerated \/ full GCs. Note that work that has been assigned\/\n+    \/\/ claimed above must be completed before we return here upon cancellation.\n+    if (heap->check_cancelled_gc_and_yield(_is_concurrent)) {\n+      return;\n+    }\n+#endif\n+  }\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_regular_group_size() {\n+  \/\/ The group size is calculated from the number of regions.  Suppose the heap has N regions.  The first group processes\n+  \/\/ N\/2 regions.  The second group processes N\/4 regions, the third group N\/8 regions and so on.\n+  \/\/ Note that infinite series N\/2 + N\/4 + N\/8 + N\/16 + ...  sums to N.\n+  \/\/\n+  \/\/ The normal group size is the number of regions \/ 2.\n+  \/\/\n+  \/\/ In the case that the region_size_words is greater than _maximum_chunk_size_words, the first group_size is\n+  \/\/ larger than the normal group size because each chunk in the group will be smaller than the region size.\n+  \/\/\n+  \/\/ The last group also has more than the normal entries because it finishes the total scanning effort.  The chunk sizes are\n+  \/\/ different for each group.  The intention is that the first group processes roughly half of the heap, the second processes\n+  \/\/ half of the remaining heap, the third processes half of what remains and so on.  The smallest chunk size\n+  \/\/ is represented by _smallest_chunk_size_words.  We do not divide work any smaller than this.\n+  \/\/\n+\n+  size_t group_size = _heap->num_regions() \/ 2;\n+  return group_size;\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_first_group_chunk_size_b4_rebalance() {\n+  size_t words_in_first_chunk = ShenandoahHeapRegion::region_size_words();\n+  return words_in_first_chunk;\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_num_groups() {\n+  size_t total_heap_size = _heap->num_regions() * ShenandoahHeapRegion::region_size_words();\n+  size_t num_groups = 0;\n+  size_t cumulative_group_span = 0;\n+  size_t current_group_span = _first_group_chunk_size_b4_rebalance * _regular_group_size;\n+  size_t smallest_group_span = smallest_chunk_size_words() * _regular_group_size;\n+  while ((num_groups < _maximum_groups) && (cumulative_group_span + current_group_span <= total_heap_size)) {\n+    num_groups++;\n+    cumulative_group_span += current_group_span;\n+    if (current_group_span <= smallest_group_span) {\n+      break;\n+    } else {\n+      current_group_span \/= 2;    \/\/ Each group spans half of what the preceding group spanned.\n+    }\n+  }\n+  \/\/ Loop post condition:\n+  \/\/   num_groups <= _maximum_groups\n+  \/\/   cumulative_group_span is the memory spanned by num_groups\n+  \/\/   current_group_span is the span of the last fully populated group (assuming loop iterates at least once)\n+  \/\/   each of num_groups is fully populated with _regular_group_size chunks in each\n+  \/\/ Non post conditions:\n+  \/\/   cumulative_group_span may be less than total_heap size for one or more of the folowing reasons\n+  \/\/   a) The number of regions remaining to be spanned is smaller than a complete group, or\n+  \/\/   b) We have filled up all groups through _maximum_groups and still have not spanned all regions\n+\n+  if (cumulative_group_span < total_heap_size) {\n+    \/\/ We've got more regions to span\n+    if ((num_groups < _maximum_groups) && (current_group_span > smallest_group_span)) {\n+      num_groups++;             \/\/ Place all remaining regions into a new not-full group (chunk_size half that of previous group)\n+    }\n+    \/\/ Else we are unable to create a new group because we've exceed the number of allowed groups or have reached the\n+    \/\/ minimum chunk size.\n+\n+    \/\/ Any remaining regions will be treated as if they are part of the most recently created group.  This group will\n+    \/\/ have more than _regular_group_size chunks within it.\n+  }\n+  return num_groups;\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_total_chunks() {\n+  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+  size_t unspanned_heap_size = _heap->num_regions() * region_size_words;\n+  size_t num_chunks = 0;\n+  size_t cumulative_group_span = 0;\n+  size_t current_group_span = _first_group_chunk_size_b4_rebalance * _regular_group_size;\n+  size_t smallest_group_span = smallest_chunk_size_words() * _regular_group_size;\n+\n+  \/\/ The first group gets special handling because the first chunk size can be no larger than _largest_chunk_size_words\n+  if (region_size_words > _maximum_chunk_size_words) {\n+    \/\/ In the case that we shrink the first group's chunk size, certain other groups will also be subsumed within the first group\n+    size_t effective_chunk_size = _first_group_chunk_size_b4_rebalance;\n+    while (effective_chunk_size >= _maximum_chunk_size_words) {\n+      num_chunks += current_group_span \/ _maximum_chunk_size_words;\n+      unspanned_heap_size -= current_group_span;\n+      effective_chunk_size \/= 2;\n+      current_group_span \/= 2;\n+    }\n+  } else {\n+    num_chunks = _regular_group_size;\n+    unspanned_heap_size -= current_group_span;\n+    current_group_span \/= 2;\n+  }\n+  size_t spanned_groups = 1;\n+  while (unspanned_heap_size > 0) {\n+    if (current_group_span <= unspanned_heap_size) {\n+      unspanned_heap_size -= current_group_span;\n+      num_chunks += _regular_group_size;\n+      spanned_groups++;\n+\n+      \/\/ _num_groups is the number of groups required to span the configured heap size.  We are not allowed\n+      \/\/ to change the number of groups.  The last group is responsible for spanning all chunks not spanned\n+      \/\/ by previously processed groups.\n+      if (spanned_groups >= _num_groups) {\n+        \/\/ The last group has more than _regular_group_size entries.\n+        size_t chunk_span = current_group_span \/ _regular_group_size;\n+        size_t extra_chunks = unspanned_heap_size \/ chunk_span;\n+        assert (extra_chunks * chunk_span == unspanned_heap_size, \"Chunks must precisely span regions\");\n+        num_chunks += extra_chunks;\n+        return num_chunks;\n+      } else if (current_group_span <= smallest_group_span) {\n+        \/\/ We cannot introduce new groups because we've reached the lower bound on group size.  So this last\n+        \/\/ group may hold extra chunks.\n+        size_t chunk_span = smallest_chunk_size_words();\n+        size_t extra_chunks = unspanned_heap_size \/ chunk_span;\n+        assert (extra_chunks * chunk_span == unspanned_heap_size, \"Chunks must precisely span regions\");\n+        num_chunks += extra_chunks;\n+        return num_chunks;\n+      } else {\n+        current_group_span \/= 2;\n+      }\n+    } else {\n+      \/\/ This last group has fewer than _regular_group_size entries.\n+      size_t chunk_span = current_group_span \/ _regular_group_size;\n+      size_t last_group_size = unspanned_heap_size \/ chunk_span;\n+      assert (last_group_size * chunk_span == unspanned_heap_size, \"Chunks must precisely span regions\");\n+      num_chunks += last_group_size;\n+      return num_chunks;\n+    }\n+  }\n+  return num_chunks;\n+}\n+\n+ShenandoahRegionChunkIterator::ShenandoahRegionChunkIterator(size_t worker_count) :\n+    ShenandoahRegionChunkIterator(ShenandoahHeap::heap(), worker_count)\n+{\n+}\n+\n+ShenandoahRegionChunkIterator::ShenandoahRegionChunkIterator(ShenandoahHeap* heap, size_t worker_count) :\n+    _heap(heap),\n+    _regular_group_size(calc_regular_group_size()),\n+    _first_group_chunk_size_b4_rebalance(calc_first_group_chunk_size_b4_rebalance()),\n+    _num_groups(calc_num_groups()),\n+    _total_chunks(calc_total_chunks()),\n+    _index(0)\n+{\n+#ifdef ASSERT\n+  size_t expected_chunk_size_words = _clusters_in_smallest_chunk * CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n+  assert(smallest_chunk_size_words() == expected_chunk_size_words, \"_smallest_chunk_size (\" SIZE_FORMAT\") is not valid because it does not equal (\" SIZE_FORMAT \")\",\n+         smallest_chunk_size_words(), expected_chunk_size_words);\n+#endif\n+  assert(_num_groups <= _maximum_groups,\n+         \"The number of remembered set scanning groups must be less than or equal to maximum groups\");\n+  assert(smallest_chunk_size_words() << (_maximum_groups - 1) == _maximum_chunk_size_words,\n+         \"Maximum number of groups needs to span maximum chunk size to smallest chunk size\");\n+\n+  size_t words_in_region = ShenandoahHeapRegion::region_size_words();\n+  _region_index[0] = 0;\n+  _group_offset[0] = 0;\n+  if (words_in_region > _maximum_chunk_size_words) {\n+    \/\/ In the case that we shrink the first group's chunk size, certain other groups will also be subsumed within the first group\n+    size_t num_chunks = 0;\n+    size_t effective_chunk_size = _first_group_chunk_size_b4_rebalance;\n+    size_t  current_group_span = effective_chunk_size * _regular_group_size;\n+    while (effective_chunk_size >= _maximum_chunk_size_words) {\n+      num_chunks += current_group_span \/ _maximum_chunk_size_words;\n+      effective_chunk_size \/= 2;\n+      current_group_span \/= 2;\n+    }\n+    _group_entries[0] = num_chunks;\n+    _group_chunk_size[0] = _maximum_chunk_size_words;\n+  } else {\n+    _group_entries[0] = _regular_group_size;\n+    _group_chunk_size[0] = _first_group_chunk_size_b4_rebalance;\n+  }\n+\n+  size_t previous_group_span = _group_entries[0] * _group_chunk_size[0];\n+  for (size_t i = 1; i < _num_groups; i++) {\n+    _group_chunk_size[i] = _group_chunk_size[i-1] \/ 2;\n+    size_t chunks_in_group = _regular_group_size;\n+    size_t this_group_span = _group_chunk_size[i] * chunks_in_group;\n+    size_t total_span_of_groups = previous_group_span + this_group_span;\n+    _region_index[i] = previous_group_span \/ words_in_region;\n+    _group_offset[i] = previous_group_span % words_in_region;\n+    _group_entries[i] = _group_entries[i-1] + _regular_group_size;\n+    previous_group_span = total_span_of_groups;\n+  }\n+  if (_group_entries[_num_groups-1] < _total_chunks) {\n+    assert((_total_chunks - _group_entries[_num_groups-1]) * _group_chunk_size[_num_groups-1] + previous_group_span ==\n+           heap->num_regions() * words_in_region, \"Total region chunks (\" SIZE_FORMAT\n+           \") do not span total heap regions (\" SIZE_FORMAT \")\", _total_chunks, _heap->num_regions());\n+    previous_group_span += (_total_chunks - _group_entries[_num_groups-1]) * _group_chunk_size[_num_groups-1];\n+    _group_entries[_num_groups-1] = _total_chunks;\n+  }\n+  assert(previous_group_span == heap->num_regions() * words_in_region, \"Total region chunks (\" SIZE_FORMAT\n+         \") do not span total heap regions (\" SIZE_FORMAT \"): \" SIZE_FORMAT \" does not equal \" SIZE_FORMAT,\n+         _total_chunks, _heap->num_regions(), previous_group_span, heap->num_regions() * words_in_region);\n+\n+  \/\/ Not necessary, but keeps things tidy\n+  for (size_t i = _num_groups; i < _maximum_groups; i++) {\n+    _region_index[i] = 0;\n+    _group_offset[i] = 0;\n+    _group_entries[i] = _group_entries[i-1];\n+    _group_chunk_size[i] = 0;\n+  }\n+}\n+\n+void ShenandoahRegionChunkIterator::reset() {\n+  _index = 0;\n+}\n+\n+ShenandoahReconstructRememberedSetTask::ShenandoahReconstructRememberedSetTask(ShenandoahRegionIterator* regions)\n+  : WorkerTask(\"Shenandoah Reset Bitmap\")\n+  , _regions(regions) { }\n+\n+void ShenandoahReconstructRememberedSetTask::work(uint worker_id) {\n+  ShenandoahParallelWorkerSession worker_session(worker_id);\n+  ShenandoahHeapRegion* r = _regions->next();\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n+  ShenandoahDirtyRememberedSetClosure dirty_cards_for_cross_generational_pointers;\n+\n+  while (r != nullptr) {\n+    if (r->is_old() && r->is_active()) {\n+      HeapWord* obj_addr = r->bottom();\n+      if (r->is_humongous_start()) {\n+        \/\/ First, clear the remembered set\n+        oop obj = cast_to_oop(obj_addr);\n+        size_t size = obj->size();\n+\n+        \/\/ First, clear the remembered set for all spanned humongous regions\n+        size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+        size_t region_span = num_regions * ShenandoahHeapRegion::region_size_words();\n+        scanner->reset_remset(r->bottom(), region_span);\n+        size_t region_index = r->index();\n+        ShenandoahHeapRegion* humongous_region = heap->get_region(region_index);\n+        while (num_regions-- != 0) {\n+          scanner->reset_object_range(humongous_region->bottom(), humongous_region->end());\n+          region_index++;\n+          humongous_region = heap->get_region(region_index);\n+        }\n+\n+        \/\/ Then register the humongous object and DIRTY relevant remembered set cards\n+        scanner->register_object_without_lock(obj_addr);\n+        obj->oop_iterate(&dirty_cards_for_cross_generational_pointers);\n+      } else if (!r->is_humongous()) {\n+        \/\/ First, clear the remembered set\n+        scanner->reset_remset(r->bottom(), ShenandoahHeapRegion::region_size_words());\n+        scanner->reset_object_range(r->bottom(), r->end());\n+\n+        \/\/ Then iterate over all objects, registering object and DIRTYing relevant remembered set cards\n+        HeapWord* t = r->top();\n+        while (obj_addr < t) {\n+          oop obj = cast_to_oop(obj_addr);\n+          scanner->register_object_without_lock(obj_addr);\n+          obj_addr += obj->oop_iterate_size(&dirty_cards_for_cross_generational_pointers);\n+        }\n+      } \/\/ else, ignore humongous continuation region\n+    }\n+    \/\/ else, this region is FREE or YOUNG or inactive and we can ignore it.\n+    r = _regions->next();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":973,"deletions":0,"binary":false,"changes":973,"status":"added"},{"patch":"@@ -0,0 +1,1001 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n+\n+\/\/ Terminology used within this source file:\n+\/\/\n+\/\/ Card Entry:   This is the information that identifies whether a\n+\/\/               particular card-table entry is Clean or Dirty.  A clean\n+\/\/               card entry denotes that the associated memory does not\n+\/\/               hold references to young-gen memory.\n+\/\/\n+\/\/ Card Region, aka\n+\/\/ Card Memory:  This is the region of memory that is assocated with a\n+\/\/               particular card entry.\n+\/\/\n+\/\/ Card Cluster: A card cluster represents 64 card entries.  A card\n+\/\/               cluster is the minimal amount of work performed at a\n+\/\/               time by a parallel thread.  Note that the work required\n+\/\/               to scan a card cluster is somewhat variable in that the\n+\/\/               required effort depends on how many cards are dirty, how\n+\/\/               many references are held within the objects that span a\n+\/\/               DIRTY card's memory, and on the size of the object\n+\/\/               that spans the end of a DIRTY card's memory (because\n+\/\/               that object, if it's not an array, may need to be scanned in\n+\/\/               its entirety, when the object is imprecisely dirtied. Imprecise\n+\/\/               dirtying is when the card corresponding to the object header\n+\/\/               is dirtied, rather than the card on which the updated field lives).\n+\/\/               To better balance work amongst them, parallel worker threads dynamically\n+\/\/               claim clusters and are flexible in the number of clusters they\n+\/\/               process.\n+\/\/\n+\/\/ A cluster represents a \"natural\" quantum of work to be performed by\n+\/\/ a parallel GC thread's background remembered set scanning efforts.\n+\/\/ The notion of cluster is similar to the notion of stripe in the\n+\/\/ implementation of parallel GC card scanning.  However, a cluster is\n+\/\/ typically smaller than a stripe, enabling finer grain division of\n+\/\/ labor between multiple threads, and potentially better load balancing\n+\/\/ when dirty cards are not uniformly distributed in the heap, as is often\n+\/\/ the case with generational workloads where more recently promoted objects\n+\/\/ may be dirtied more frequently that older objects.\n+\/\/\n+\/\/ For illustration, consider the following possible JVM configurations:\n+\/\/\n+\/\/   Scenario 1:\n+\/\/     RegionSize is 128 MB\n+\/\/     Span of a card entry is 512 B\n+\/\/     Each card table entry consumes 1 B\n+\/\/     Assume one long word (8 B)of the card table represents a cluster.\n+\/\/       This long word holds 8 card table entries, spanning a\n+\/\/       total of 8*512 B = 4 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32 K\n+\/\/\n+\/\/   Scenario 2:\n+\/\/     RegionSize is 128 MB\n+\/\/     Span of each card entry is 128 B\n+\/\/     Each card table entry consumes 1 bit\n+\/\/     Assume one int word (4 B) of the card table represents a cluster.\n+\/\/       This int word holds 32 b\/1 b = 32 card table entries, spanning a\n+\/\/       total of 32 * 128 B = 4 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32 K\n+\/\/\n+\/\/   Scenario 3:\n+\/\/     RegionSize is 128 MB\n+\/\/     Span of each card entry is 512 B\n+\/\/     Each card table entry consumes 1 bit\n+\/\/     Assume one long word (8 B) of card table represents a cluster.\n+\/\/       This long word holds 64 b\/ 1 b = 64 card table entries, spanning a\n+\/\/       total of 64 * 512 B = 32 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 32 KB = 4 K\n+\/\/\n+\/\/ At the start of a new young-gen concurrent mark pass, the gang of\n+\/\/ Shenandoah worker threads collaborate in performing the following\n+\/\/ actions:\n+\/\/\n+\/\/  Let old_regions = number of ShenandoahHeapRegion comprising\n+\/\/    old-gen memory\n+\/\/  Let region_size = ShenandoahHeapRegion::region_size_bytes()\n+\/\/    represent the number of bytes in each region\n+\/\/  Let clusters_per_region = region_size \/ 512\n+\/\/  Let rs represent the ShenandoahDirectCardMarkRememberedSet\n+\/\/\n+\/\/  for each ShenandoahHeapRegion old_region in the whole heap\n+\/\/    determine the cluster number of the first cluster belonging\n+\/\/      to that region\n+\/\/    for each cluster contained within that region\n+\/\/      Assure that exactly one worker thread processes each\n+\/\/      cluster, each thread making a series of invocations of the\n+\/\/      following:\n+\/\/\n+\/\/        rs->process_clusters(worker_id, ReferenceProcessor *,\n+\/\/                             ShenandoahConcurrentMark *, cluster_no, cluster_count,\n+\/\/                             HeapWord *end_of_range, OopClosure *oops);\n+\/\/\n+\/\/  For efficiency, divide up the clusters so that different threads\n+\/\/  are responsible for processing different clusters.  Processing costs\n+\/\/  may vary greatly between clusters for the following reasons:\n+\/\/\n+\/\/        a) some clusters contain mostly dirty cards and other\n+\/\/           clusters contain mostly clean cards\n+\/\/        b) some clusters contain mostly primitive data and other\n+\/\/           clusters contain mostly reference data\n+\/\/        c) some clusters are spanned by very large non-array objects that\n+\/\/           begin in some other cluster.  When a large non-array object\n+\/\/           beginning in a preceding cluster spans large portions of\n+\/\/           this cluster, then because of imprecise dirtying, the\n+\/\/           portion of the object in this cluster may be clean, but\n+\/\/           will need to be processed by the worker responsible for\n+\/\/           this cluster, potentially increasing its work.\n+\/\/        d) in the case that the end of this cluster is spanned by a\n+\/\/           very large non-array object, the worker for this cluster will\n+\/\/           be responsible for processing the portion of the object\n+\/\/           in this cluster.\n+\/\/\n+\/\/ Though an initial division of labor between marking threads may\n+\/\/ assign equal numbers of clusters to be scanned by each thread, it\n+\/\/ should be expected that some threads will finish their assigned\n+\/\/ work before others.  Therefore, some amount of the full remembered\n+\/\/ set scanning effort should be held back and assigned incrementally\n+\/\/ to the threads that end up with excess capacity.  Consider the\n+\/\/ following strategy for dividing labor:\n+\/\/\n+\/\/        1. Assume there are 8 marking threads and 1024 remembered\n+\/\/           set clusters to be scanned.\n+\/\/        2. Assign each thread to scan 64 clusters.  This leaves\n+\/\/           512 (1024 - (8*64)) clusters to still be scanned.\n+\/\/        3. As the 8 server threads complete previous cluster\n+\/\/           scanning assignments, issue each of the next 8 scanning\n+\/\/           assignments as units of 32 additional cluster each.\n+\/\/           In the case that there is high variance in effort\n+\/\/           associated with previous cluster scanning assignments,\n+\/\/           multiples of these next assignments may be serviced by\n+\/\/           the server threads that were previously assigned lighter\n+\/\/           workloads.\n+\/\/        4. Make subsequent scanning assignments as follows:\n+\/\/             a) 8 assignments of size 16 clusters\n+\/\/             b) 8 assignments of size 8 clusters\n+\/\/             c) 16 assignments of size 4 clusters\n+\/\/\n+\/\/    When there is no more remembered set processing work to be\n+\/\/    assigned to a newly idled worker thread, that thread can move\n+\/\/    on to work on other tasks associated with root scanning until such\n+\/\/    time as all clusters have been examined.\n+\/\/\n+\/\/ Remembered set scanning is designed to run concurrently with\n+\/\/ mutator threads, with multiple concurrent workers. Furthermore, the\n+\/\/ current implementation of remembered set scanning never clears a\n+\/\/ card once it has been marked.\n+\/\/\n+\/\/ These limitations will be addressed in future enhancements to the\n+\/\/ existing implementation.\n+\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+#include \"gc\/shenandoah\/shenandoahTaskqueue.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ShenandoahReferenceProcessor;\n+class ShenandoahConcurrentMark;\n+class ShenandoahHeap;\n+class ShenandoahHeapRegion;\n+class ShenandoahRegionIterator;\n+class ShenandoahMarkingContext;\n+\n+class CardTable;\n+typedef CardTable::CardValue CardValue;\n+\n+class ShenandoahDirectCardMarkRememberedSet: public CHeapObj<mtGC> {\n+\n+private:\n+\n+  \/\/ Use symbolic constants defined in cardTable.hpp\n+  \/\/  CardTable::card_shift = 9;\n+  \/\/  CardTable::card_size = 512;\n+  \/\/  CardTable::card_size_in_words = 64;\n+  \/\/  CardTable::clean_card_val()\n+  \/\/  CardTable::dirty_card_val()\n+\n+  const size_t LogCardValsPerIntPtr;    \/\/ the number of card values (entries) in an intptr_t\n+  const size_t LogCardSizeInWords;      \/\/ the size of a card in heap word units\n+\n+  ShenandoahHeap* _heap;\n+  ShenandoahCardTable* _card_table;\n+  size_t _card_shift;\n+  size_t _total_card_count;\n+  HeapWord* _whole_heap_base;   \/\/ Points to first HeapWord of data contained within heap memory\n+  CardValue* _byte_map;         \/\/ Points to first entry within the card table\n+  CardValue* _byte_map_base;    \/\/ Points to byte_map minus the bias computed from address of heap memory\n+\n+public:\n+\n+  \/\/ count is the number of cards represented by the card table.\n+  ShenandoahDirectCardMarkRememberedSet(ShenandoahCardTable* card_table, size_t total_card_count);\n+\n+  \/\/ Card index is zero-based relative to _byte_map.\n+  size_t last_valid_index() const;\n+  size_t total_cards() const;\n+  size_t card_index_for_addr(HeapWord* p) const;\n+  HeapWord* addr_for_card_index(size_t card_index) const;\n+  inline const CardValue* get_card_table_byte_map(bool use_write_table) const {\n+    return use_write_table ? _card_table->write_byte_map() : _card_table->read_byte_map();\n+  }\n+\n+  inline bool is_card_dirty(size_t card_index) const;\n+  inline bool is_write_card_dirty(size_t card_index) const;\n+  inline void mark_card_as_dirty(size_t card_index);\n+  inline void mark_range_as_dirty(size_t card_index, size_t num_cards);\n+  inline void mark_card_as_clean(size_t card_index);\n+  inline void mark_range_as_clean(size_t card_index, size_t num_cards);\n+  inline bool is_card_dirty(HeapWord* p) const;\n+  inline bool is_write_card_dirty(HeapWord* p) const;\n+  inline void mark_card_as_dirty(HeapWord* p);\n+  inline void mark_range_as_dirty(HeapWord* p, size_t num_heap_words);\n+  inline void mark_card_as_clean(HeapWord* p);\n+  inline void mark_range_as_clean(HeapWord* p, size_t num_heap_words);\n+\n+  \/\/ Merge any dirty values from write table into the read table, while leaving\n+  \/\/ the write table unchanged.\n+  void merge_write_table(HeapWord* start, size_t word_count);\n+\n+  \/\/ Destructively copy the write table to the read table, and clean the write table.\n+  void reset_remset(HeapWord* start, size_t word_count);\n+};\n+\n+\/\/ A ShenandoahCardCluster represents the minimal unit of work\n+\/\/ performed by independent parallel GC threads during scanning of\n+\/\/ remembered sets.\n+\/\/\n+\/\/ The GC threads that perform card-table remembered set scanning may\n+\/\/ overwrite card-table entries to mark them as clean in the case that\n+\/\/ the associated memory no longer holds references to young-gen\n+\/\/ memory.  Rather than access the card-table entries directly, all GC\n+\/\/ thread access to card-table information is made by way of the\n+\/\/ ShenandoahCardCluster data abstraction.  This abstraction\n+\/\/ effectively manages access to multiple possible underlying\n+\/\/ remembered set implementations, including a traditional card-table\n+\/\/ approach and a SATB-based approach.\n+\/\/\n+\/\/ The API services represent a compromise between efficiency and\n+\/\/ convenience.\n+\/\/\n+\/\/ Multiple GC threads that scan the remembered set\n+\/\/ in parallel.  The desire is to divide the complete scanning effort\n+\/\/ into multiple clusters of work that can be independently processed\n+\/\/ by individual threads without need for synchronizing efforts\n+\/\/ between the work performed by each task.  The term \"cluster\" of\n+\/\/ work is similar to the term \"stripe\" as used in the implementation\n+\/\/ of Parallel GC.\n+\/\/\n+\/\/ Complexity arises when an object to be scanned crosses the boundary\n+\/\/ between adjacent cluster regions.  Here is the protocol that we currently\n+\/\/ follow:\n+\/\/\n+\/\/  1. The thread responsible for scanning the cards in a cluster modifies\n+\/\/     the associated card-table entries. Only cards that are dirty are\n+\/\/     processed, except as described below for the case of objects that\n+\/\/     straddle more than one card.\n+\/\/  2. Object Arrays are precisely dirtied, so only the portion of the obj-array\n+\/\/     that overlaps the range of dirty cards in its cluster are scanned\n+\/\/     by each worker thread. This holds for portions of obj-arrays that extend\n+\/\/     over clusters processed by different workers, with each worked responsible\n+\/\/     for scanning the portion of the obj-array overlapping the dirty cards in\n+\/\/     its cluster.\n+\/\/  3. Non-array objects are precisely dirtied by the interpreter and the compilers\n+\/\/     For such objects that extend over multiple cards, or even multiple clusters,\n+\/\/     the entire object is scanned by the worker that processes the (dirty) card on\n+\/\/     which the object's header lies. (However, GC workers should precisely dirty the\n+\/\/     cards with inter-regional\/inter-generational pointers in the body of this object,\n+\/\/     thus making subsequent scans potentially less expensive.) Such larger non-array\n+\/\/     objects are relatively rare.\n+\/\/\n+\/\/  A possible criticism:\n+\/\/  C. The representation of pointer location descriptive information\n+\/\/     within Klass representations is not designed for efficient\n+\/\/     \"random access\".  An alternative approach to this design would\n+\/\/     be to scan very large objects multiple times, once for each\n+\/\/     cluster that is spanned by the object's range.  This reduces\n+\/\/     unnecessary overscan, but it introduces different sorts of\n+\/\/     overhead effort:\n+\/\/       i) For each spanned cluster, we have to look up the start of\n+\/\/          the crossing object.\n+\/\/      ii) Each time we scan the very large object, we have to\n+\/\/          sequentially walk through its pointer location\n+\/\/          descriptors, skipping over all of the pointers that\n+\/\/          precede the start of the range of addresses that we\n+\/\/          consider relevant.\n+\n+\n+\/\/ Because old-gen heap memory is not necessarily contiguous, and\n+\/\/ because cards are not necessarily maintained for young-gen memory,\n+\/\/ consecutive card numbers do not necessarily correspond to consecutive\n+\/\/ address ranges.  For the traditional direct-card-marking\n+\/\/ implementation of this interface, consecutive card numbers are\n+\/\/ likely to correspond to contiguous regions of memory, but this\n+\/\/ should not be assumed.  Instead, rely only upon the following:\n+\/\/\n+\/\/  1. All card numbers for cards pertaining to the same\n+\/\/     ShenandoahHeapRegion are consecutively numbered.\n+\/\/  2. In the case that neighboring ShenandoahHeapRegions both\n+\/\/     represent old-gen memory, the card regions that span the\n+\/\/     boundary between these neighboring heap regions will be\n+\/\/     consecutively numbered.\n+\/\/  3. (A corollary) In the case that an old-gen object straddles the\n+\/\/     boundary between two heap regions, the card regions that\n+\/\/     correspond to the span of this object will be consecutively\n+\/\/     numbered.\n+\/\/\n+\/\/ ShenandoahCardCluster abstracts access to the remembered set\n+\/\/ and also keeps track of crossing map information to allow efficient\n+\/\/ resolution of object start addresses.\n+\/\/\n+\/\/ ShenandoahCardCluster supports all of the services of\n+\/\/ DirectCardMarkRememberedSet, plus it supports register_object() and lookup_object().\n+\/\/ Note that we only need to register the start addresses of the object that\n+\/\/ overlays the first address of a card; we need to do this for every card.\n+\/\/ In other words, register_object() checks if the object crosses a card boundary,\n+\/\/ and updates the offset value for each card that the object crosses into.\n+\/\/ For objects that don't straddle cards, nothing needs to be done.\n+\/\/\n+class ShenandoahCardCluster: public CHeapObj<mtGC> {\n+\n+private:\n+  ShenandoahDirectCardMarkRememberedSet* _rs;\n+\n+public:\n+  static const size_t CardsPerCluster = 64;\n+\n+private:\n+  typedef struct cross_map { uint8_t first; uint8_t last; } xmap;\n+  typedef union crossing_info { uint16_t short_word; xmap offsets; } crossing_info;\n+\n+  \/\/ ObjectStartsInCardRegion bit is set within a crossing_info.offsets.start iff at least one object starts within\n+  \/\/ a particular card region.  We pack this bit into start byte under assumption that start byte is accessed less\n+  \/\/ frequently than last byte.  This is true when number of clean cards is greater than number of dirty cards.\n+  static const uint8_t ObjectStartsInCardRegion = 0x80;\n+  static const uint8_t FirstStartBits           = 0x7f;\n+\n+  \/\/ Check that we have enough bits to store the largest possible offset into a card for an object start.\n+  \/\/ The value for maximum card size is based on the constraints for GCCardSizeInBytes in gc_globals.hpp.\n+  static const int MaxCardSize = NOT_LP64(512) LP64_ONLY(1024);\n+  STATIC_ASSERT((MaxCardSize \/ HeapWordSize) - 1 <= FirstStartBits);\n+\n+  crossing_info* _object_starts;\n+\n+public:\n+  \/\/ If we're setting first_start, assume the card has an object.\n+  inline void set_first_start(size_t card_index, uint8_t value) {\n+    _object_starts[card_index].offsets.first = ObjectStartsInCardRegion | value;\n+  }\n+\n+  inline void set_last_start(size_t card_index, uint8_t value) {\n+    _object_starts[card_index].offsets.last = value;\n+  }\n+\n+  inline void set_starts_object_bit(size_t card_index) {\n+    _object_starts[card_index].offsets.first |= ObjectStartsInCardRegion;\n+  }\n+\n+  inline void clear_starts_object_bit(size_t card_index) {\n+    _object_starts[card_index].offsets.first &= ~ObjectStartsInCardRegion;\n+  }\n+\n+  \/\/ Returns true iff an object is known to start within the card memory associated with card card_index.\n+  inline bool starts_object(size_t card_index) const {\n+    return (_object_starts[card_index].offsets.first & ObjectStartsInCardRegion) != 0;\n+  }\n+\n+  inline void clear_objects_in_range(HeapWord* addr, size_t num_words) {\n+    size_t card_index = _rs->card_index_for_addr(addr);\n+    size_t last_card_index = _rs->card_index_for_addr(addr + num_words - 1);\n+    while (card_index <= last_card_index)\n+      _object_starts[card_index++].short_word = 0;\n+  }\n+\n+  ShenandoahCardCluster(ShenandoahDirectCardMarkRememberedSet* rs) {\n+    _rs = rs;\n+    _object_starts = NEW_C_HEAP_ARRAY(crossing_info, rs->total_cards(), mtGC);\n+    for (size_t i = 0; i < rs->total_cards(); i++) {\n+      _object_starts[i].short_word = 0;\n+    }\n+  }\n+\n+  ~ShenandoahCardCluster() {\n+    FREE_C_HEAP_ARRAY(crossing_info, _object_starts);\n+    _object_starts = nullptr;\n+  }\n+\n+  \/\/ There is one entry within the object_starts array for each card entry.\n+  \/\/\n+  \/\/  Suppose multiple garbage objects are coalesced during GC sweep\n+  \/\/  into a single larger \"free segment\".  As each two objects are\n+  \/\/  coalesced together, the start information pertaining to the second\n+  \/\/  object must be removed from the objects_starts array.  If the\n+  \/\/  second object had been the first object within card memory,\n+  \/\/  the new first object is the object that follows that object if\n+  \/\/  that starts within the same card memory, or NoObject if the\n+  \/\/  following object starts within the following cluster.  If the\n+  \/\/  second object had been the last object in the card memory,\n+  \/\/  replace this entry with the newly coalesced object if it starts\n+  \/\/  within the same card memory, or with NoObject if it starts in a\n+  \/\/  preceding card's memory.\n+  \/\/\n+  \/\/  Suppose a large free segment is divided into a smaller free\n+  \/\/  segment and a new object.  The second part of the newly divided\n+  \/\/  memory must be registered as a new object, overwriting at most\n+  \/\/  one first_start and one last_start entry.  Note that one of the\n+  \/\/  newly divided two objects might be a new GCLAB.\n+  \/\/\n+  \/\/  Suppose postprocessing of a GCLAB finds that the original GCLAB\n+  \/\/  has been divided into N objects.  Each of the N newly allocated\n+  \/\/  objects will be registered, overwriting at most one first_start\n+  \/\/  and one last_start entries.\n+  \/\/\n+  \/\/  No object registration operations are linear in the length of\n+  \/\/  the registered objects.\n+  \/\/\n+  \/\/ Consider further the following observations regarding object\n+  \/\/ registration costs:\n+  \/\/\n+  \/\/   1. The cost is paid once for each old-gen object (Except when\n+  \/\/      an object is demoted and repromoted, in which case we would\n+  \/\/      pay the cost again).\n+  \/\/   2. The cost can be deferred so that there is no urgency during\n+  \/\/      mutator copy-on-first-access promotion.  Background GC\n+  \/\/      threads will update the object_starts array by post-\n+  \/\/      processing the contents of retired PLAB buffers.\n+  \/\/   3. The bet is that these costs are paid relatively rarely\n+  \/\/      because:\n+  \/\/      a) Most objects die young and objects that die in young-gen\n+  \/\/         memory never need to be registered with the object_starts\n+  \/\/         array.\n+  \/\/      b) Most objects that are promoted into old-gen memory live\n+  \/\/         there without further relocation for a relatively long\n+  \/\/         time, so we get a lot of benefit from each investment\n+  \/\/         in registering an object.\n+\n+public:\n+\n+  \/\/ The starting locations of objects contained within old-gen memory\n+  \/\/ are registered as part of the remembered set implementation.  This\n+  \/\/ information is required when scanning dirty card regions that are\n+  \/\/ spanned by objects beginning within preceding card regions.  It\n+  \/\/ is necessary to find the first and last objects that begin within\n+  \/\/ this card region.  Starting addresses of objects are required to\n+  \/\/ find the object headers, and object headers provide information\n+  \/\/ about which fields within the object hold addresses.\n+  \/\/\n+  \/\/ The old-gen memory allocator invokes register_object() for any\n+  \/\/ object that is allocated within old-gen memory.  This identifies\n+  \/\/ the starting addresses of objects that span boundaries between\n+  \/\/ card regions.\n+  \/\/\n+  \/\/ It is not necessary to invoke register_object at the very instant\n+  \/\/ an object is allocated.  It is only necessary to invoke it\n+  \/\/ prior to the next start of a garbage collection concurrent mark\n+  \/\/ or concurrent update-references phase.  An \"ideal\" time to register\n+  \/\/ objects is during post-processing of a GCLAB after the GCLAB is\n+  \/\/ retired due to depletion of its memory.\n+  \/\/\n+  \/\/ register_object() does not perform synchronization.  In the case\n+  \/\/ that multiple threads are registering objects whose starting\n+  \/\/ addresses are within the same cluster, races between these\n+  \/\/ threads may result in corruption of the object-start data\n+  \/\/ structures.  Parallel GC threads should avoid registering objects\n+  \/\/ residing within the same cluster by adhering to the following\n+  \/\/ coordination protocols:\n+  \/\/\n+  \/\/  1. Align thread-local GCLAB buffers with some TBD multiple of\n+  \/\/     card clusters.  The card cluster size is 32 KB.  If the\n+  \/\/     desired GCLAB size is 128 KB, align the buffer on a multiple\n+  \/\/     of 4 card clusters.\n+  \/\/  2. Post-process the contents of GCLAB buffers to register the\n+  \/\/     objects allocated therein.  Allow one GC thread at a\n+  \/\/     time to do the post-processing of each GCLAB.\n+  \/\/  3. Since only one GC thread at a time is registering objects\n+  \/\/     belonging to a particular allocation buffer, no locking\n+  \/\/     is performed when registering these objects.\n+  \/\/  4. Any remnant of unallocated memory within an expended GC\n+  \/\/     allocation buffer is not returned to the old-gen allocation\n+  \/\/     pool until after the GC allocation buffer has been post\n+  \/\/     processed.  Before any remnant memory is returned to the\n+  \/\/     old-gen allocation pool, the GC thread that scanned this GC\n+  \/\/     allocation buffer performs a write-commit memory barrier.\n+  \/\/  5. Background GC threads that perform tenuring of young-gen\n+  \/\/     objects without a GCLAB use a CAS lock before registering\n+  \/\/     each tenured object.  The CAS lock assures both mutual\n+  \/\/     exclusion and memory coherency\/visibility.  Note that an\n+  \/\/     object tenured by a background GC thread will not overlap\n+  \/\/     with any of the clusters that are receiving tenured objects\n+  \/\/     by way of GCLAB buffers.  Multiple independent GC threads may\n+  \/\/     attempt to tenure objects into a shared cluster.  This is why\n+  \/\/     sychronization may be necessary.  Consider the following\n+  \/\/     scenarios:\n+  \/\/\n+  \/\/     a) If two objects are tenured into the same card region, each\n+  \/\/        registration may attempt to modify the first-start or\n+  \/\/        last-start information associated with that card region.\n+  \/\/        Furthermore, because the representations of first-start\n+  \/\/        and last-start information within the object_starts array\n+  \/\/        entry uses different bits of a shared uint_16 to represent\n+  \/\/        each, it is necessary to lock the entire card entry\n+  \/\/        before modifying either the first-start or last-start\n+  \/\/        information within the entry.\n+  \/\/     b) Suppose GC thread X promotes a tenured object into\n+  \/\/        card region A and this tenured object spans into\n+  \/\/        neighboring card region B.  Suppose GC thread Y (not equal\n+  \/\/        to X) promotes a tenured object into cluster B.  GC thread X\n+  \/\/        will update the object_starts information for card A.  No\n+  \/\/        synchronization is required.\n+  \/\/     c) In summary, when background GC threads register objects\n+  \/\/        newly tenured into old-gen memory, they must acquire a\n+  \/\/        mutual exclusion lock on the card that holds the starting\n+  \/\/        address of the newly tenured object.  This can be achieved\n+  \/\/        by using a CAS instruction to assure that the previous\n+  \/\/        values of first-offset and last-offset have not been\n+  \/\/        changed since the same thread inquired as to their most\n+  \/\/        current values.\n+  \/\/\n+  \/\/     One way to minimize the need for synchronization between\n+  \/\/     background tenuring GC threads is for each tenuring GC thread\n+  \/\/     to promote young-gen objects into distinct dedicated cluster\n+  \/\/     ranges.\n+  \/\/  6. The object_starts information is only required during the\n+  \/\/     starting of concurrent marking and concurrent evacuation\n+  \/\/     phases of GC.  Before we start either of these GC phases, the\n+  \/\/     JVM enters a safe point and all GC threads perform\n+  \/\/     commit-write barriers to assure that access to the\n+  \/\/     object_starts information is coherent.\n+\n+\n+  \/\/ Notes on synchronization of register_object():\n+  \/\/\n+  \/\/  1. For efficiency, there is no locking in the implementation of register_object()\n+  \/\/  2. Thus, it is required that users of this service assure that concurrent\/parallel invocations of\n+  \/\/     register_object() do pertain to the same card's memory range.  See discussion below to understand\n+  \/\/     the risks.\n+  \/\/  3. When allocating from a TLAB or GCLAB, the mutual exclusion can be guaranteed by assuring that each\n+  \/\/     LAB's start and end are aligned on card memory boundaries.\n+  \/\/  4. Use the same lock that guarantees exclusivity when performing free-list allocation within heap regions.\n+  \/\/\n+  \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n+  \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n+  \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n+  \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n+  \/\/\n+  \/\/ objects being \"concurrently\" allocated:\n+  \/\/    [-----a------][-----b-----][--------------c------------------]\n+  \/\/            [---- card table memory range --------------]\n+  \/\/\n+  \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that:\n+  \/\/   allocation of object a wants to set the has-object, first-start, and last-start attributes of the preceding card region.\n+  \/\/   allocation of object b wants to set the has-object, first-start, and last-start attributes of this card region.\n+  \/\/   allocation of object c also wants to set the has-object, first-start, and last-start attributes of this card region.\n+  \/\/\n+  \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as last-start\n+  \/\/ representing object b while first-start represents object c.  This is why we need to require all register_object()\n+  \/\/ invocations associated with objects that are allocated from \"free lists\" to provide their own mutual exclusion locking\n+  \/\/ mechanism.\n+\n+  \/\/ Reset the starts_object() information to false for all cards in the range between from and to.\n+  void reset_object_range(HeapWord* from, HeapWord* to);\n+\n+  \/\/ register_object() requires that the caller hold the heap lock\n+  \/\/ before calling it.\n+  void register_object(HeapWord* address);\n+\n+  \/\/ register_object_without_lock() does not require that the caller hold\n+  \/\/ the heap lock before calling it, under the assumption that the\n+  \/\/ caller has assured no other thread will endeavor to concurrently\n+  \/\/ register objects that start within the same card's memory region\n+  \/\/ as address.\n+  void register_object_without_lock(HeapWord* address);\n+\n+  \/\/ During the reference updates phase of GC, we walk through each old-gen memory region that was\n+  \/\/ not part of the collection set and we invalidate all unmarked objects.  As part of this effort,\n+  \/\/ we coalesce neighboring dead objects in order to make future remembered set scanning more\n+  \/\/ efficient (since future remembered set scanning of any card region containing consecutive\n+  \/\/ dead objects can skip over all of them at once by reading only a single dead object header\n+  \/\/ instead of having to read the header of each of the coalesced dead objects.\n+  \/\/\n+  \/\/ At some future time, we may implement a further optimization: satisfy future allocation requests\n+  \/\/ by carving new objects out of the range of memory that represents the coalesced dead objects.\n+  \/\/\n+  \/\/ Suppose we want to combine several dead objects into a single coalesced object.  How does this\n+  \/\/ impact our representation of crossing map information?\n+  \/\/  1. If the newly coalesced range is contained entirely within a card range, that card's last\n+  \/\/     start entry either remains the same or it is changed to the start of the coalesced region.\n+  \/\/  2. For the card that holds the start of the coalesced object, it will not impact the first start\n+  \/\/     but it may impact the last start.\n+  \/\/  3. For following cards spanned entirely by the newly coalesced object, it will change starts_object\n+  \/\/     to false (and make first-start and last-start \"undefined\").\n+  \/\/  4. For a following card that is spanned patially by the newly coalesced object, it may change\n+  \/\/     first-start value, but it will not change the last-start value.\n+  \/\/\n+  \/\/ The range of addresses represented by the arguments to coalesce_objects() must represent a range\n+  \/\/ of memory that was previously occupied exactly by one or more previously registered objects.  For\n+  \/\/ convenience, it is legal to invoke coalesce_objects() with arguments that span a single previously\n+  \/\/ registered object.\n+  \/\/\n+  \/\/ The role of coalesce_objects is to change the crossing map information associated with all of the coalesced\n+  \/\/ objects.\n+  void coalesce_objects(HeapWord* address, size_t length_in_words);\n+\n+  \/\/ The typical use case is going to look something like this:\n+  \/\/   for each heapregion that comprises old-gen memory\n+  \/\/     for each card number that corresponds to this heap region\n+  \/\/       scan the objects contained therein if the card is dirty\n+  \/\/ To avoid excessive lookups in a sparse array, the API queries\n+  \/\/ the card number pertaining to a particular address and then uses the\n+  \/\/ card number for subsequent information lookups and stores.\n+\n+  \/\/ If starts_object(card_index), this returns the word offset within this card\n+  \/\/ memory at which the first object begins.  If !starts_object(card_index), the\n+  \/\/ result is a don't care value -- asserts in a debug build.\n+  size_t get_first_start(size_t card_index) const;\n+\n+  \/\/ If starts_object(card_index), this returns the word offset within this card\n+  \/\/ memory at which the last object begins.  If !starts_object(card_index), the\n+  \/\/ result is a don't care value.\n+  size_t get_last_start(size_t card_index) const;\n+\n+\n+  \/\/ Given a card_index, return the starting address of the first block in the heap\n+  \/\/ that straddles into the card. If the card is co-initial with an object, then\n+  \/\/ this would return the starting address of the heap that this card covers.\n+  \/\/ Expects to be called for a card affiliated with the old generation in\n+  \/\/ generational mode.\n+  HeapWord* block_start(size_t card_index) const;\n+};\n+\n+\/\/ ShenandoahScanRemembered is a concrete class representing the\n+\/\/ ability to scan the old-gen remembered set for references to\n+\/\/ objects residing in young-gen memory.\n+\/\/\n+\/\/ Scanning normally begins with an invocation of numRegions and ends\n+\/\/ after all clusters of all regions have been scanned.\n+\/\/\n+\/\/ Throughout the scanning effort, the number of regions does not\n+\/\/ change.\n+\/\/\n+\/\/ Even though the regions that comprise old-gen memory are not\n+\/\/ necessarily contiguous, the abstraction represented by this class\n+\/\/ identifies each of the old-gen regions with an integer value\n+\/\/ in the range from 0 to (numRegions() - 1) inclusive.\n+\/\/\n+\n+class ShenandoahScanRemembered: public CHeapObj<mtGC> {\n+\n+private:\n+  ShenandoahDirectCardMarkRememberedSet* _rs;\n+  ShenandoahCardCluster* _scc;\n+\n+  \/\/ Global card stats (cumulative)\n+  HdrSeq _card_stats_scan_rs[MAX_CARD_STAT_TYPE];\n+  HdrSeq _card_stats_update_refs[MAX_CARD_STAT_TYPE];\n+  \/\/ Per worker card stats (multiplexed by phase)\n+  HdrSeq** _card_stats;\n+\n+  \/\/ The types of card metrics that we gather\n+  const char* _card_stats_name[MAX_CARD_STAT_TYPE] = {\n+   \"dirty_run\", \"clean_run\",\n+   \"dirty_cards\", \"clean_cards\",\n+   \"max_dirty_run\", \"max_clean_run\",\n+   \"dirty_scan_objs\",\n+   \"alternations\"\n+  };\n+\n+  \/\/ The statistics are collected and logged separately for\n+  \/\/ card-scans for initial marking, and for updating refs.\n+  const char* _card_stat_log_type[MAX_CARD_STAT_LOG_TYPE] = {\n+   \"Scan Remembered Set\", \"Update Refs\"\n+  };\n+\n+  int _card_stats_log_counter[2] = {0, 0};\n+\n+public:\n+  ShenandoahScanRemembered(ShenandoahDirectCardMarkRememberedSet* rs) {\n+    _rs = rs;\n+    _scc = new ShenandoahCardCluster(rs);\n+\n+    \/\/ We allocate ParallelGCThreads worth even though we usually only\n+    \/\/ use up to ConcGCThreads, because degenerate collections may employ\n+    \/\/ ParallelGCThreads for remembered set scanning.\n+    if (ShenandoahEnableCardStats) {\n+      _card_stats = NEW_C_HEAP_ARRAY(HdrSeq*, ParallelGCThreads, mtGC);\n+      for (uint i = 0; i < ParallelGCThreads; i++) {\n+        _card_stats[i] = new HdrSeq[MAX_CARD_STAT_TYPE];\n+      }\n+    } else {\n+      _card_stats = nullptr;\n+    }\n+  }\n+\n+  ~ShenandoahScanRemembered() {\n+    delete _scc;\n+    if (ShenandoahEnableCardStats) {\n+      for (uint i = 0; i < ParallelGCThreads; i++) {\n+        delete _card_stats[i];\n+      }\n+      FREE_C_HEAP_ARRAY(HdrSeq*, _card_stats);\n+      _card_stats = nullptr;\n+    }\n+    assert(_card_stats == nullptr, \"Error\");\n+  }\n+\n+  HdrSeq* card_stats(uint worker_id) {\n+    assert(worker_id < ParallelGCThreads, \"Error\");\n+    assert(ShenandoahEnableCardStats == (_card_stats != nullptr), \"Error\");\n+    return ShenandoahEnableCardStats ? _card_stats[worker_id] : nullptr;\n+  }\n+\n+  HdrSeq* card_stats_for_phase(CardStatLogType t) {\n+    switch (t) {\n+      case CARD_STAT_SCAN_RS:\n+        return _card_stats_scan_rs;\n+      case CARD_STAT_UPDATE_REFS:\n+        return _card_stats_update_refs;\n+      default:\n+        guarantee(false, \"No such CardStatLogType\");\n+    }\n+    return nullptr; \/\/ Quiet compiler\n+  }\n+\n+  \/\/ Card index is zero-based relative to first spanned card region.\n+  size_t card_index_for_addr(HeapWord* p);\n+  HeapWord* addr_for_card_index(size_t card_index);\n+  bool is_card_dirty(size_t card_index);\n+  bool is_write_card_dirty(size_t card_index);\n+  bool is_card_dirty(HeapWord* p);\n+  bool is_write_card_dirty(HeapWord* p);\n+  void mark_card_as_dirty(HeapWord* p);\n+  void mark_range_as_dirty(HeapWord* p, size_t num_heap_words);\n+  void mark_card_as_clean(HeapWord* p);\n+  void mark_range_as_clean(HeapWord* p, size_t num_heap_words);\n+\n+  void reset_remset(HeapWord* start, size_t word_count) { _rs->reset_remset(start, word_count); }\n+\n+  void merge_write_table(HeapWord* start, size_t word_count) { _rs->merge_write_table(start, word_count); }\n+\n+  size_t cluster_for_addr(HeapWord* addr);\n+  HeapWord* addr_for_cluster(size_t cluster_no);\n+\n+  void reset_object_range(HeapWord* from, HeapWord* to);\n+  void register_object(HeapWord* addr);\n+  void register_object_without_lock(HeapWord* addr);\n+  void coalesce_objects(HeapWord* addr, size_t length_in_words);\n+\n+  HeapWord* first_object_in_card(size_t card_index) {\n+    if (_scc->starts_object(card_index)) {\n+      return addr_for_card_index(card_index) + _scc->get_first_start(card_index);\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+\n+  \/\/ Return true iff this object is \"properly\" registered.\n+  bool verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx);\n+\n+  \/\/ clear the cards to clean, and clear the object_starts info to no objects\n+  void mark_range_as_empty(HeapWord* addr, size_t length_in_words);\n+\n+  \/\/ process_clusters() scans a portion of the remembered set\n+  \/\/ for references from old gen into young. Several worker threads\n+  \/\/ scan different portions of the remembered set by making parallel invocations\n+  \/\/ of process_clusters() with each invocation scanning different\n+  \/\/ \"clusters\" of the remembered set.\n+  \/\/\n+  \/\/ An invocation of process_clusters() examines all of the\n+  \/\/ intergenerational references spanned by `count` clusters starting\n+  \/\/ with `first_cluster`.  The `oops` argument is a worker-thread-local\n+  \/\/ OopClosure that is applied to all \"valid\" references in the remembered set.\n+  \/\/\n+  \/\/ A side-effect of executing process_clusters() is to update the remembered\n+  \/\/ set entries (e.g. marking dirty cards clean if they no longer\n+  \/\/ hold references to young-gen memory).\n+  \/\/\n+  \/\/ An implementation of process_clusters() may choose to efficiently\n+  \/\/ address more typical scenarios in the structure of remembered sets. E.g.\n+  \/\/ in the generational setting, one might expect remembered sets to be very sparse\n+  \/\/ (low mutation rates in the old generation leading to sparse dirty cards,\n+  \/\/ each with very few intergenerational pointers). Specific implementations\n+  \/\/ may choose to degrade gracefully as the sparsity assumption fails to hold,\n+  \/\/ such as when there are sudden spikes in (premature) promotion or in the\n+  \/\/ case of an underprovisioned, poorly-tuned, or poorly-shaped heap.\n+  \/\/\n+  \/\/ At the start of a concurrent young generation marking cycle, we invoke process_clusters\n+  \/\/ with ClosureType ShenandoahInitMarkRootsClosure.\n+  \/\/\n+  \/\/ At the start of a concurrent evacuation phase, we invoke process_clusters with\n+  \/\/ ClosureType ShenandoahEvacuateUpdateRootsClosure.\n+\n+  template <typename ClosureType>\n+  void process_clusters(size_t first_cluster, size_t count, HeapWord* end_of_range, ClosureType* oops,\n+                        bool use_write_table, uint worker_id);\n+\n+  template <typename ClosureType>\n+  void process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n+                                  HeapWord* end_of_range, ClosureType* oops, bool use_write_table);\n+\n+  template <typename ClosureType>\n+  void process_region_slice(ShenandoahHeapRegion* region, size_t offset, size_t clusters, HeapWord* end_of_range,\n+                            ClosureType* cl, bool use_write_table, uint worker_id);\n+\n+  \/\/ To Do:\n+  \/\/  Create subclasses of ShenandoahInitMarkRootsClosure and\n+  \/\/  ShenandoahEvacuateUpdateRootsClosure and any other closures\n+  \/\/  that need to participate in remembered set scanning.  Within the\n+  \/\/  subclasses, add a (probably templated) instance variable that\n+  \/\/  refers to the associated ShenandoahCardCluster object.  Use this\n+  \/\/  ShenandoahCardCluster instance to \"enhance\" the do_oops\n+  \/\/  processing so that we can:\n+  \/\/\n+  \/\/   1. Avoid processing references that correspond to clean card\n+  \/\/      regions, and\n+  \/\/   2. Set card status to CLEAN when the associated card region no\n+  \/\/      longer holds inter-generatioanal references.\n+  \/\/\n+  \/\/  To enable efficient implementation of these behaviors, we\n+  \/\/  probably also want to add a few fields into the\n+  \/\/  ShenandoahCardCluster object that allow us to precompute and\n+  \/\/  remember the addresses at which card status is going to change\n+  \/\/  from dirty to clean and clean to dirty.  The do_oops\n+  \/\/  implementations will want to update this value each time they\n+  \/\/  cross one of these boundaries.\n+  void roots_do(OopIterateClosure* cl);\n+\n+  \/\/ Log stats related to card\/RS stats for given phase t\n+  void log_card_stats(uint nworkers, CardStatLogType t) PRODUCT_RETURN;\n+private:\n+  \/\/ Log stats for given worker id related into given summary card\/RS stats\n+  void log_worker_card_stats(uint worker_id, HdrSeq* sum_stats) PRODUCT_RETURN;\n+\n+  \/\/ Log given stats\n+  void log_card_stats(HdrSeq* stats) PRODUCT_RETURN;\n+\n+  \/\/ Merge the stats from worked_id into the given summary stats, and clear the worker_id's stats.\n+  void merge_worker_card_stats_cumulative(HdrSeq* worker_stats, HdrSeq* sum_stats) PRODUCT_RETURN;\n+};\n+\n+\n+\/\/ A ShenandoahRegionChunk represents a contiguous interval of a ShenandoahHeapRegion, typically representing\n+\/\/ work to be done by a worker thread.\n+struct ShenandoahRegionChunk {\n+  ShenandoahHeapRegion* _r;      \/\/ The region of which this represents a chunk\n+  size_t _chunk_offset;          \/\/ HeapWordSize offset\n+  size_t _chunk_size;            \/\/ HeapWordSize qty\n+};\n+\n+\/\/ ShenandoahRegionChunkIterator divides the total remembered set scanning effort into ShenandoahRegionChunks\n+\/\/ that are assigned one at a time to worker threads. (Here, we use the terms `assignments` and `chunks`\n+\/\/ interchangeably.) Note that the effort required to scan a range of memory is not necessarily a linear\n+\/\/ function of the size of the range.  Some memory ranges hold only a small number of live objects.\n+\/\/ Some ranges hold primarily primitive (non-pointer) data.  We start with larger chunk sizes because larger chunks\n+\/\/ reduce coordination overhead.  We expect that the GC worker threads that receive more difficult assignments\n+\/\/ will work longer on those chunks.  Meanwhile, other worker threads will repeatedly accept and complete multiple\n+\/\/ easier chunks.  As the total amount of work remaining to be completed decreases, we decrease the size of chunks\n+\/\/ given to individual threads.  This reduces the likelihood of significant imbalance between worker thread assignments\n+\/\/ when there is less meaningful work to be performed by the remaining worker threads while they wait for\n+\/\/ worker threads with difficult assignments to finish, reducing the overall duration of the phase.\n+\n+class ShenandoahRegionChunkIterator : public StackObj {\n+private:\n+  \/\/ The largest chunk size is 4 MiB, measured in words.  Otherwise, remembered set scanning may become too unbalanced.\n+  \/\/ If the largest chunk size is too small, there is too much overhead sifting out assignments to individual worker threads.\n+  static const size_t _maximum_chunk_size_words = (4 * 1024 * 1024) \/ HeapWordSize;\n+\n+  static const size_t _clusters_in_smallest_chunk = 4;\n+\n+  \/\/ smallest_chunk_size is 4 clusters.  Each cluster spans 128 KiB.\n+  \/\/ This is computed from CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n+  static size_t smallest_chunk_size_words() {\n+      return _clusters_in_smallest_chunk * CardTable::card_size_in_words() *\n+             ShenandoahCardCluster::CardsPerCluster;\n+  }\n+\n+  \/\/ The total remembered set scanning effort is divided into chunks of work that are assigned to individual worker tasks.\n+  \/\/ The chunks of assigned work are divided into groups, where the size of the typical group (_regular_group_size) is half the\n+  \/\/ total number of regions.  The first group may be larger than\n+  \/\/ _regular_group_size in the case that the first group's chunk\n+  \/\/ size is less than the region size.  The last group may be larger\n+  \/\/ than _regular_group_size because no group is allowed to\n+  \/\/ have smaller assignments than _smallest_chunk_size, which is 128 KB.\n+\n+  \/\/ Under normal circumstances, no configuration needs more than _maximum_groups (default value of 16).\n+  \/\/ The first group \"effectively\" processes chunks of size 1 MiB (or smaller for smaller region sizes).\n+  \/\/ The last group processes chunks of size 128 KiB.  There are four groups total.\n+\n+  \/\/ group[0] is 4 MiB chunk size (_maximum_chunk_size_words)\n+  \/\/ group[1] is 2 MiB chunk size\n+  \/\/ group[2] is 1 MiB chunk size\n+  \/\/ group[3] is 512 KiB chunk size\n+  \/\/ group[4] is 256 KiB chunk size\n+  \/\/ group[5] is 128 Kib shunk size (_smallest_chunk_size_words = 4 * 64 * 64\n+  static const size_t _maximum_groups = 6;\n+\n+  const ShenandoahHeap* _heap;\n+\n+  const size_t _regular_group_size;                        \/\/ Number of chunks in each group\n+  const size_t _first_group_chunk_size_b4_rebalance;\n+  const size_t _num_groups;                        \/\/ Number of groups in this configuration\n+  const size_t _total_chunks;\n+\n+  shenandoah_padding(0);\n+  volatile size_t _index;\n+  shenandoah_padding(1);\n+\n+  size_t _region_index[_maximum_groups];           \/\/ The region index for the first region spanned by this group\n+  size_t _group_offset[_maximum_groups];           \/\/ The offset at which group begins within first region spanned by this group\n+  size_t _group_chunk_size[_maximum_groups];       \/\/ The size of each chunk within this group\n+  size_t _group_entries[_maximum_groups];          \/\/ Total chunks spanned by this group and the ones before it.\n+\n+  \/\/ No implicit copying: iterators should be passed by reference to capture the state\n+  NONCOPYABLE(ShenandoahRegionChunkIterator);\n+\n+  \/\/ Makes use of _heap.\n+  size_t calc_regular_group_size();\n+\n+  \/\/ Makes use of _regular_group_size, which must be initialized before call.\n+  size_t calc_first_group_chunk_size_b4_rebalance();\n+\n+  \/\/ Makes use of _regular_group_size and _first_group_chunk_size_b4_rebalance, both of which must be initialized before call.\n+  size_t calc_num_groups();\n+\n+  \/\/ Makes use of _regular_group_size, _first_group_chunk_size_b4_rebalance, which must be initialized before call.\n+  size_t calc_total_chunks();\n+\n+public:\n+  ShenandoahRegionChunkIterator(size_t worker_count);\n+  ShenandoahRegionChunkIterator(ShenandoahHeap* heap, size_t worker_count);\n+\n+  \/\/ Reset iterator to default state\n+  void reset();\n+\n+  \/\/ Fills in assignment with next chunk of work and returns true iff there is more work.\n+  \/\/ Otherwise, returns false.  This is multi-thread-safe.\n+  inline bool next(struct ShenandoahRegionChunk* assignment);\n+\n+  \/\/ This is *not* MT safe. However, in the absence of multithreaded access, it\n+  \/\/ can be used to determine if there is more work to do.\n+  inline bool has_next() const;\n+};\n+\n+\n+class ShenandoahScanRememberedTask : public WorkerTask {\n+ private:\n+  ShenandoahObjToScanQueueSet* _queue_set;\n+  ShenandoahObjToScanQueueSet* _old_queue_set;\n+  ShenandoahReferenceProcessor* _rp;\n+  ShenandoahRegionChunkIterator* _work_list;\n+  bool _is_concurrent;\n+\n+ public:\n+  ShenandoahScanRememberedTask(ShenandoahObjToScanQueueSet* queue_set,\n+                               ShenandoahObjToScanQueueSet* old_queue_set,\n+                               ShenandoahReferenceProcessor* rp,\n+                               ShenandoahRegionChunkIterator* work_list,\n+                               bool is_concurrent);\n+\n+  void work(uint worker_id);\n+  void do_work(uint worker_id);\n+};\n+\n+\/\/ After Full GC is done, reconstruct the remembered set by iterating over OLD regions,\n+\/\/ registering all objects between bottom() and top(), and dirtying the cards containing\n+\/\/ cross-generational pointers.\n+class ShenandoahReconstructRememberedSetTask : public WorkerTask {\n+private:\n+  ShenandoahRegionIterator* _regions;\n+\n+public:\n+  explicit ShenandoahReconstructRememberedSetTask(ShenandoahRegionIterator* regions);\n+\n+  void work(uint worker_id) override;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":1001,"deletions":0,"binary":false,"changes":1001,"status":"added"},{"patch":"@@ -0,0 +1,405 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBEREDINLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBEREDINLINE_HPP\n+\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"gc\/shared\/collectorCounters.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+\/\/ Process all objects starting within count clusters beginning with first_cluster and for which the start address is\n+\/\/ less than end_of_range.  For any non-array object whose header lies on a dirty card, scan the entire object,\n+\/\/ even if its end reaches beyond end_of_range. Object arrays, on the other hand, are precisely dirtied and\n+\/\/ only the portions of the array on dirty cards need to be scanned.\n+\/\/\n+\/\/ Do not CANCEL within process_clusters.  It is assumed that if a worker thread accepts responsibility for processing\n+\/\/ a chunk of work, it will finish the work it starts.  Otherwise, the chunk of work will be lost in the transition to\n+\/\/ degenerated execution, leading to dangling references.\n+template <typename ClosureType>\n+void ShenandoahScanRemembered::process_clusters(size_t first_cluster, size_t count, HeapWord* end_of_range,\n+                                                               ClosureType* cl, bool use_write_table, uint worker_id) {\n+\n+  assert(ShenandoahHeap::heap()->old_generation()->is_parsable(), \"Old generation regions must be parsable for remembered set scan\");\n+  \/\/ If old-gen evacuation is active, then MarkingContext for old-gen heap regions is valid.  We use the MarkingContext\n+  \/\/ bits to determine which objects within a DIRTY card need to be scanned.  This is necessary because old-gen heap\n+  \/\/ regions that are in the candidate collection set have not been coalesced and filled.  Thus, these heap regions\n+  \/\/ may contain zombie objects.  Zombie objects are known to be dead, but have not yet been \"collected\".  Scanning\n+  \/\/ zombie objects is unsafe because the Klass pointer is not reliable, objects referenced from a zombie may have been\n+  \/\/ collected (if dead), or relocated (if live), or if dead but not yet collected, we don't want to \"revive\" them\n+  \/\/ by marking them (when marking) or evacuating them (when updating references).\n+\n+  \/\/ start and end addresses of range of objects to be scanned, clipped to end_of_range\n+  const size_t start_card_index = first_cluster * ShenandoahCardCluster::CardsPerCluster;\n+  const HeapWord* start_addr = _rs->addr_for_card_index(start_card_index);\n+  \/\/ clip at end_of_range (exclusive)\n+  HeapWord* end_addr = MIN2(end_of_range, (HeapWord*)start_addr + (count * ShenandoahCardCluster::CardsPerCluster\n+                                                                   * CardTable::card_size_in_words()));\n+  assert(start_addr < end_addr, \"Empty region?\");\n+\n+  const size_t whole_cards = (end_addr - start_addr + CardTable::card_size_in_words() - 1)\/CardTable::card_size_in_words();\n+  const size_t end_card_index = start_card_index + whole_cards - 1;\n+  log_debug(gc, remset)(\"Worker %u: cluster = \" SIZE_FORMAT \" count = \" SIZE_FORMAT \" eor = \" INTPTR_FORMAT\n+                        \" start_addr = \" INTPTR_FORMAT \" end_addr = \" INTPTR_FORMAT \" cards = \" SIZE_FORMAT,\n+                        worker_id, first_cluster, count, p2i(end_of_range), p2i(start_addr), p2i(end_addr), whole_cards);\n+\n+  \/\/ use_write_table states whether we are using the card table that is being\n+  \/\/ marked by the mutators. If false, we are using a snapshot of the card table\n+  \/\/ that is not subject to modifications. Even when this arg is true, and\n+  \/\/ the card table is being actively marked, SATB marking ensures that we need not\n+  \/\/ worry about cards marked after the processing here has passed them.\n+  const CardValue* const ctbm = _rs->get_card_table_byte_map(use_write_table);\n+\n+  \/\/ If old gen evacuation is active, ctx will hold the completed marking of\n+  \/\/ old generation objects. We'll only scan objects that are marked live by\n+  \/\/ the old generation marking. These include objects allocated since the\n+  \/\/ start of old generation marking (being those above TAMS).\n+  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  const ShenandoahMarkingContext* ctx = heap->old_generation()->is_mark_complete() ?\n+                                        heap->marking_context() : nullptr;\n+\n+  \/\/ The region we will scan is the half-open interval [start_addr, end_addr),\n+  \/\/ and lies entirely within a single region.\n+  const ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(start_addr);\n+  assert(region->contains(end_addr - 1), \"Slice shouldn't cross regions\");\n+\n+  \/\/ This code may have implicit assumptions of examining only old gen regions.\n+  assert(region->is_old(), \"We only expect to be processing old regions\");\n+  assert(!region->is_humongous(), \"Humongous regions can be processed more efficiently;\"\n+                                  \"see process_humongous_clusters()\");\n+  \/\/ tams and ctx below are for old generation marking. As such, young gen roots must\n+  \/\/ consider everything above tams, since it doesn't represent a TAMS for young gen's\n+  \/\/ SATB marking.\n+  const HeapWord* tams = (ctx == nullptr ? region->bottom() : ctx->top_at_mark_start(region));\n+\n+  NOT_PRODUCT(ShenandoahCardStats stats(whole_cards, card_stats(worker_id));)\n+\n+  \/\/ In the case of imprecise marking, we remember the lowest address\n+  \/\/ scanned in a range of dirty cards, as we work our way left from the\n+  \/\/ highest end_addr. This serves as another upper bound on the address we will\n+  \/\/ scan as we move left over each contiguous range of dirty cards.\n+  HeapWord* upper_bound = nullptr;\n+\n+  \/\/ Starting at the right end of the address range, walk backwards accumulating\n+  \/\/ a maximal dirty range of cards, then process those cards.\n+  ssize_t cur_index = (ssize_t) end_card_index;\n+  assert(cur_index >= 0, \"Overflow\");\n+  assert(((ssize_t)start_card_index) >= 0, \"Overflow\");\n+  while (cur_index >= (ssize_t)start_card_index) {\n+\n+    \/\/ We'll continue the search starting with the card for the upper bound\n+    \/\/ address identified by the last dirty range that we processed, if any,\n+    \/\/ skipping any cards at higher addresses.\n+    if (upper_bound != nullptr) {\n+      ssize_t right_index = _rs->card_index_for_addr(upper_bound);\n+      assert(right_index >= 0, \"Overflow\");\n+      cur_index = MIN2(cur_index, right_index);\n+      assert(upper_bound < end_addr, \"Program logic\");\n+      end_addr  = upper_bound;   \/\/ lower end_addr\n+      upper_bound = nullptr;     \/\/ and clear upper_bound\n+      if (end_addr <= start_addr) {\n+        assert(right_index <= (ssize_t)start_card_index, \"Program logic\");\n+        \/\/ We are done with our cluster\n+        return;\n+      }\n+    }\n+\n+    if (ctbm[cur_index] == CardTable::dirty_card_val()) {\n+      \/\/ ==== BEGIN DIRTY card range processing ====\n+\n+      const size_t dirty_r = cur_index;  \/\/ record right end of dirty range (inclusive)\n+      while (--cur_index >= (ssize_t)start_card_index && ctbm[cur_index] == CardTable::dirty_card_val()) {\n+        \/\/ walk back over contiguous dirty cards to find left end of dirty range (inclusive)\n+      }\n+      \/\/ [dirty_l, dirty_r] is a \"maximal\" closed interval range of dirty card indices:\n+      \/\/ it may not be maximal if we are using the write_table, because of concurrent\n+      \/\/ mutations dirtying the card-table. It may also not be maximal if an upper bound\n+      \/\/ was established by the scan of the previous chunk.\n+      const size_t dirty_l = cur_index + 1;   \/\/ record left end of dirty range (inclusive)\n+      \/\/ Check that we identified a boundary on our left\n+      assert(ctbm[dirty_l] == CardTable::dirty_card_val(), \"First card in range should be dirty\");\n+      assert(dirty_l == start_card_index || use_write_table\n+             || ctbm[dirty_l - 1] == CardTable::clean_card_val(),\n+             \"Interval isn't maximal on the left\");\n+      assert(dirty_r >= dirty_l, \"Error\");\n+      assert(ctbm[dirty_r] == CardTable::dirty_card_val(), \"Last card in range should be dirty\");\n+      \/\/ Record alternations, dirty run length, and dirty card count\n+      NOT_PRODUCT(stats.record_dirty_run(dirty_r - dirty_l + 1);)\n+\n+      \/\/ Find first object that starts this range:\n+      \/\/ [left, right) is a maximal right-open interval of dirty cards\n+      HeapWord* left = _rs->addr_for_card_index(dirty_l);        \/\/ inclusive\n+      HeapWord* right = _rs->addr_for_card_index(dirty_r + 1);   \/\/ exclusive\n+      \/\/ Clip right to end_addr established above (still exclusive)\n+      right = MIN2(right, end_addr);\n+      assert(right <= region->top() && end_addr <= region->top(), \"Busted bounds\");\n+      const MemRegion mr(left, right);\n+\n+      \/\/ NOTE: We'll not call block_start() repeatedly\n+      \/\/ on a very large object if its head card is dirty. If not,\n+      \/\/ (i.e. the head card is clean) we'll call it each time we\n+      \/\/ process a new dirty range on the object. This is always\n+      \/\/ the case for large object arrays, which are typically more\n+      \/\/ common.\n+      HeapWord* p = _scc->block_start(dirty_l);\n+      oop obj = cast_to_oop(p);\n+\n+      \/\/ PREFIX: The object that straddles into this range of dirty cards\n+      \/\/ from the left may be subject to special treatment unless\n+      \/\/ it is an object array.\n+      if (p < left && !obj->is_objArray()) {\n+        \/\/ The mutator (both compiler and interpreter, but not JNI?)\n+        \/\/ typically dirty imprecisely (i.e. only the head of an object),\n+        \/\/ but GC closures typically dirty the object precisely. (It would\n+        \/\/ be nice to have everything be precise for maximum efficiency.)\n+        \/\/\n+        \/\/ To handle this, we check the head card of the object here and,\n+        \/\/ if dirty, (arrange to) scan the object in its entirety. If we\n+        \/\/ find the head card clean, we'll scan only the portion of the\n+        \/\/ object lying in the dirty card range below, assuming this was\n+        \/\/ the result of precise marking by GC closures.\n+\n+        \/\/ index of the \"head card\" for p\n+        const size_t hc_index = _rs->card_index_for_addr(p);\n+        if (ctbm[hc_index] == CardTable::dirty_card_val()) {\n+          \/\/ Scan or skip the object, depending on location of its\n+          \/\/ head card, and remember that we'll have processed all\n+          \/\/ the objects back up to p, which is thus an upper bound\n+          \/\/ for the next iteration of a dirty card loop.\n+          upper_bound = p;   \/\/ remember upper bound for next chunk\n+          if (p < start_addr) {\n+            \/\/ if object starts in a previous slice, it'll be handled\n+            \/\/ in its entirety by the thread processing that slice; we can\n+            \/\/ skip over it and avoid an unnecessary extra scan.\n+            assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n+            p += obj->size();\n+          } else {\n+            \/\/ the object starts in our slice, we scan it in its entirety\n+            assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n+            if (ctx == nullptr || ctx->is_marked(obj)) {\n+              \/\/ Scan the object in its entirety\n+              p += obj->oop_iterate_size(cl);\n+            } else {\n+              assert(p < tams, \"Error 1 in ctx\/marking\/tams logic\");\n+              \/\/ Skip over any intermediate dead objects\n+              p = ctx->get_next_marked_addr(p, tams);\n+              assert(p <= tams, \"Error 2 in ctx\/marking\/tams logic\");\n+            }\n+          }\n+          assert(p > left, \"Should have processed into interior of dirty range\");\n+        }\n+      }\n+\n+      size_t i = 0;\n+      HeapWord* last_p = nullptr;\n+\n+      \/\/ BODY: Deal with (other) objects in this dirty card range\n+      while (p < right) {\n+        obj = cast_to_oop(p);\n+        \/\/ walk right scanning eligible objects\n+        if (ctx == nullptr || ctx->is_marked(obj)) {\n+          \/\/ we need to remember the last object ptr we scanned, in case we need to\n+          \/\/ complete a partial suffix scan after mr, see below\n+          last_p = p;\n+          \/\/ apply the closure to the oops in the portion of\n+          \/\/ the object within mr.\n+          p += obj->oop_iterate_size(cl, mr);\n+          NOT_PRODUCT(i++);\n+        } else {\n+          \/\/ forget the last object pointer we remembered\n+          last_p = nullptr;\n+          assert(p < tams, \"Tams and above are implicitly marked in ctx\");\n+          \/\/ object under tams isn't marked: skip to next live object\n+          p = ctx->get_next_marked_addr(p, tams);\n+          assert(p <= tams, \"Error 3 in ctx\/marking\/tams logic\");\n+        }\n+      }\n+\n+      \/\/ SUFFIX: Fix up a possible incomplete scan at right end of window\n+      \/\/ by scanning the portion of a non-objArray that wasn't done.\n+      if (p > right && last_p != nullptr) {\n+        assert(last_p < right, \"Error\");\n+        \/\/ check if last_p suffix needs scanning\n+        const oop last_obj = cast_to_oop(last_p);\n+        if (!last_obj->is_objArray()) {\n+          \/\/ scan the remaining suffix of the object\n+          const MemRegion last_mr(right, p);\n+          assert(p == last_p + last_obj->size(), \"Would miss portion of last_obj\");\n+          last_obj->oop_iterate(cl, last_mr);\n+          log_develop_debug(gc, remset)(\"Fixed up non-objArray suffix scan in [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \")\",\n+                                        p2i(last_mr.start()), p2i(last_mr.end()));\n+        } else {\n+          log_develop_debug(gc, remset)(\"Skipped suffix scan of objArray in [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \")\",\n+                                        p2i(right), p2i(p));\n+        }\n+      }\n+      NOT_PRODUCT(stats.record_scan_obj_cnt(i);)\n+\n+      \/\/ ==== END   DIRTY card range processing ====\n+    } else {\n+      \/\/ ==== BEGIN CLEAN card range processing ====\n+\n+      \/\/ If we are using the write table (during update refs, e.g.), a mutator may dirty\n+      \/\/ a card at any time. This is fine for the algorithm below because it is only\n+      \/\/ counting contiguous runs of clean cards (and only for non-product builds).\n+      assert(use_write_table || ctbm[cur_index] == CardTable::clean_card_val(), \"Error\");\n+\n+      \/\/ walk back over contiguous clean cards\n+      size_t i = 0;\n+      while (--cur_index >= (ssize_t)start_card_index && ctbm[cur_index] == CardTable::clean_card_val()) {\n+        NOT_PRODUCT(i++);\n+      }\n+      \/\/ Record alternations, clean run length, and clean card count\n+      NOT_PRODUCT(stats.record_clean_run(i);)\n+\n+      \/\/ ==== END CLEAN card range processing ====\n+    }\n+  }\n+}\n+\n+\/\/ Given that this range of clusters is known to span a humongous object spanned by region r, scan the\n+\/\/ portion of the humongous object that corresponds to the specified range.\n+template <typename ClosureType>\n+inline void\n+ShenandoahScanRemembered::process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n+                                                                    HeapWord *end_of_range, ClosureType *cl, bool use_write_table) {\n+  ShenandoahHeapRegion* start_region = r->humongous_start_region();\n+  HeapWord* p = start_region->bottom();\n+  oop obj = cast_to_oop(p);\n+  assert(r->is_humongous(), \"Only process humongous regions here\");\n+  assert(start_region->is_humongous_start(), \"Should be start of humongous region\");\n+  assert(p + obj->size() >= end_of_range, \"Humongous object ends before range ends\");\n+\n+  size_t first_card_index = first_cluster * ShenandoahCardCluster::CardsPerCluster;\n+  HeapWord* first_cluster_addr = _rs->addr_for_card_index(first_card_index);\n+  size_t spanned_words = count * ShenandoahCardCluster::CardsPerCluster * CardTable::card_size_in_words();\n+  start_region->oop_iterate_humongous_slice_dirty(cl, first_cluster_addr, spanned_words, use_write_table);\n+}\n+\n+\n+\/\/ This method takes a region & determines the end of the region that the worker can scan.\n+template <typename ClosureType>\n+inline void\n+ShenandoahScanRemembered::process_region_slice(ShenandoahHeapRegion *region, size_t start_offset, size_t clusters,\n+                                                              HeapWord *end_of_range, ClosureType *cl, bool use_write_table,\n+                                                              uint worker_id) {\n+\n+  \/\/ This is called only for young gen collection, when we scan old gen regions\n+  assert(region->is_old(), \"Expecting an old region\");\n+  HeapWord *start_of_range = region->bottom() + start_offset;\n+  size_t start_cluster_no = cluster_for_addr(start_of_range);\n+  assert(addr_for_cluster(start_cluster_no) == start_of_range, \"process_region_slice range must align on cluster boundary\");\n+\n+  \/\/ region->end() represents the end of memory spanned by this region, but not all of this\n+  \/\/   memory is eligible to be scanned because some of this memory has not yet been allocated.\n+  \/\/\n+  \/\/ region->top() represents the end of allocated memory within this region.  Any addresses\n+  \/\/   beyond region->top() should not be scanned as that memory does not hold valid objects.\n+\n+  if (use_write_table) {\n+    \/\/ This is update-refs servicing.\n+    if (end_of_range > region->get_update_watermark()) {\n+      end_of_range = region->get_update_watermark();\n+    }\n+  } else {\n+    \/\/ This is concurrent mark servicing.  Note that TAMS for this region is TAMS at start of old-gen\n+    \/\/ collection.  Here, we need to scan up to TAMS for most recently initiated young-gen collection.\n+    \/\/ Since all LABs are retired at init mark, and since replacement LABs are allocated lazily, and since no\n+    \/\/ promotions occur until evacuation phase, TAMS for most recent young-gen is same as top().\n+    if (end_of_range > region->top()) {\n+      end_of_range = region->top();\n+    }\n+  }\n+\n+  log_debug(gc)(\"Remembered set scan processing Region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n+                region->index(), p2i(start_of_range), p2i(end_of_range),\n+                use_write_table? \"read\/write (updating)\": \"read (marking)\");\n+\n+  \/\/ Note that end_of_range may point to the middle of a cluster because we limit scanning to\n+  \/\/ region->top() or region->get_update_watermark(). We avoid processing past end_of_range.\n+  \/\/ Objects that start between start_of_range and end_of_range, including humongous objects, will\n+  \/\/ be fully processed by process_clusters. In no case should we need to scan past end_of_range.\n+  if (start_of_range < end_of_range) {\n+    if (region->is_humongous()) {\n+      ShenandoahHeapRegion* start_region = region->humongous_start_region();\n+      process_humongous_clusters(start_region, start_cluster_no, clusters, end_of_range, cl, use_write_table);\n+    } else {\n+      process_clusters(start_cluster_no, clusters, end_of_range, cl, use_write_table, worker_id);\n+    }\n+  }\n+}\n+\n+inline bool ShenandoahRegionChunkIterator::has_next() const {\n+  return _index < _total_chunks;\n+}\n+\n+inline bool ShenandoahRegionChunkIterator::next(struct ShenandoahRegionChunk *assignment) {\n+  if (_index >= _total_chunks) {\n+    return false;\n+  }\n+  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n+  if (new_index > _total_chunks) {\n+    \/\/ First worker that hits new_index == _total_chunks continues, other\n+    \/\/ contending workers return false.\n+    return false;\n+  }\n+  \/\/ convert to zero-based indexing\n+  new_index--;\n+  assert(new_index < _total_chunks, \"Error\");\n+\n+  \/\/ Find the group number for the assigned chunk index\n+  size_t group_no;\n+  for (group_no = 0; new_index >= _group_entries[group_no]; group_no++)\n+    ;\n+  assert(group_no < _num_groups, \"Cannot have group no greater or equal to _num_groups\");\n+\n+  \/\/ All size computations measured in HeapWord\n+  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+  size_t group_region_index = _region_index[group_no];\n+  size_t group_region_offset = _group_offset[group_no];\n+\n+  size_t index_within_group = (group_no == 0)? new_index: new_index - _group_entries[group_no - 1];\n+  size_t group_chunk_size = _group_chunk_size[group_no];\n+  size_t offset_of_this_chunk = group_region_offset + index_within_group * group_chunk_size;\n+  size_t regions_spanned_by_chunk_offset = offset_of_this_chunk \/ region_size_words;\n+  size_t offset_within_region = offset_of_this_chunk % region_size_words;\n+\n+  size_t region_index = group_region_index + regions_spanned_by_chunk_offset;\n+\n+  assignment->_r = _heap->get_region(region_index);\n+  assignment->_chunk_offset = offset_within_region;\n+  assignment->_chunk_size = group_chunk_size;\n+  return true;\n+}\n+\n+#endif   \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBEREDINLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"@@ -124,1 +124,2 @@\n-      if ((ov & mask_val) != 0) {\n+      \/\/ We require all bits of mask_val to be set\n+      if ((ov & mask_val) == mask_val) {\n@@ -131,1 +132,1 @@\n-        \/\/ successfully set\n+        \/\/ successfully set: if value returned from cmpxchg equals ov, then nv has overwritten value.\n@@ -159,0 +160,1 @@\n+  \/\/ Returns true iff any bit set in mask is set in this.value.\n@@ -163,0 +165,8 @@\n+  \/\/ Returns true iff all bits set in mask are set in this.value.\n+  bool is_set_exactly(uint mask) const {\n+    assert (mask < (sizeof(ShenandoahSharedValue) * CHAR_MAX), \"sanity\");\n+    uint uvalue = Atomic::load_acquire(&value);\n+    return (uvalue & mask) == mask;\n+  }\n+\n+  \/\/ Returns true iff all bits set in mask are unset in this.value.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSharedVariables.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -76,3 +77,1 @@\n-    if (_heap->is_concurrent_mark_in_progress()) {\n-      return &_keep_alive_cl;\n-    } else if (_heap->is_concurrent_weak_root_in_progress()) {\n+    if (_heap->is_concurrent_weak_root_in_progress()) {\n@@ -81,0 +80,2 @@\n+    } else if (_heap->is_concurrent_mark_in_progress()) {\n+      return &_keep_alive_cl;\n@@ -93,8 +94,1 @@\n-  if (heap->is_concurrent_mark_in_progress()) {\n-    \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n-    \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n-    \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n-    retire_tlab();\n-\n-    _jt->oops_do_no_frames(closure_from_context(context), &_nm_cl);\n-  } else if (heap->is_concurrent_weak_root_in_progress()) {\n+  if (heap->is_concurrent_weak_root_in_progress()) {\n@@ -109,0 +103,7 @@\n+    _jt->oops_do_no_frames(closure_from_context(context), &_nm_cl);\n+  } else if (heap->is_concurrent_mark_in_progress()) {\n+    \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n+    \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n+    \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n+    retire_tlab();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStackWatermark.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n-\n@@ -31,0 +29,3 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -48,16 +49,4 @@\n-  const markWord mark = obj->mark();\n-\n-  \/\/ Having\/had displaced header, too risky to deal with them, skip\n-  if (mark == markWord::INFLATING() || mark.has_displaced_mark_helper()) {\n-    return false;\n-  }\n-\n-  if (StringDedup::is_below_threshold_age(mark.age())) {\n-    \/\/ Increase string age and enqueue it when it reaches age threshold\n-    markWord new_mark = mark.incr_age();\n-    if (mark == obj->cas_set_mark(new_mark, mark)) {\n-      return StringDedup::is_threshold_age(new_mark.age()) &&\n-             !dedup_requested(obj);\n-    }\n-  }\n-  return false;\n+  uint age = ShenandoahHeap::get_object_age(obj);\n+  return (age <= markWord::max_age) &&\n+         StringDedup::is_below_threshold_age(age) &&\n+         !dedup_requested(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStringDedup.inline.hpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+\n+ShenandoahThreadLocalData::ShenandoahThreadLocalData() :\n+  _gc_state(0),\n+  _oom_scope_nesting_level(0),\n+  _oom_during_evac(false),\n+  _satb_mark_queue(&ShenandoahBarrierSet::satb_mark_queue_set()),\n+  _gclab(nullptr),\n+  _gclab_size(0),\n+  _paced_time(0),\n+  _plab(nullptr),\n+  _plab_desired_size(0),\n+  _plab_actual_size(0),\n+  _plab_promoted(0),\n+  _plab_allows_promotion(true),\n+  _plab_retries_enabled(true),\n+  _evacuation_stats(nullptr) {\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    _evacuation_stats = new ShenandoahEvacuationStats();\n+  }\n+}\n+\n+ShenandoahThreadLocalData::~ShenandoahThreadLocalData() {\n+  if (_gclab != nullptr) {\n+    delete _gclab;\n+  }\n+  if (_plab != nullptr) {\n+    ShenandoahGenerationalHeap::heap()->retire_plab(_plab);\n+    delete _plab;\n+  }\n+\n+  delete _evacuation_stats;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n@@ -33,0 +35,2 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n@@ -34,0 +38,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -44,0 +49,1 @@\n+\n@@ -45,0 +51,3 @@\n+\n+  \/\/ Thread-local allocation buffer for object evacuations.\n+  \/\/ In generational mode, it is exclusive to the young generation.\n@@ -47,0 +56,1 @@\n+\n@@ -49,9 +59,5 @@\n-  ShenandoahThreadLocalData() :\n-    _gc_state(0),\n-    _oom_scope_nesting_level(0),\n-    _oom_during_evac(false),\n-    _satb_mark_queue(&ShenandoahBarrierSet::satb_mark_queue_set()),\n-    _gclab(nullptr),\n-    _gclab_size(0),\n-    _paced_time(0) {\n-  }\n+  \/\/ Thread-local allocation buffer only used in generational mode.\n+  \/\/ Used both by mutator threads and by GC worker threads\n+  \/\/ for evacuations within the old generation and\n+  \/\/ for promotions from the young generation into the old generation.\n+  PLAB* _plab;\n@@ -59,5 +65,21 @@\n-  ~ShenandoahThreadLocalData() {\n-    if (_gclab != nullptr) {\n-      delete _gclab;\n-    }\n-  }\n+  \/\/ Heuristics will grow the desired size of plabs.\n+  size_t _plab_desired_size;\n+\n+  \/\/ Once the plab has been allocated, and we know the actual size, we record it here.\n+  size_t _plab_actual_size;\n+\n+  \/\/ As the plab is used for promotions, this value is incremented. When the plab is\n+  \/\/ retired, the difference between 'actual_size' and 'promoted' will be returned to\n+  \/\/ the old generation's promotion reserve (i.e., it will be 'unexpended').\n+  size_t _plab_promoted;\n+\n+  \/\/ If false, no more promotion by this thread during this evacuation phase.\n+  bool   _plab_allows_promotion;\n+\n+  \/\/ If true, evacuations may attempt to allocate a smaller plab if the original size fails.\n+  bool   _plab_retries_enabled;\n+\n+  ShenandoahEvacuationStats* _evacuation_stats;\n+\n+  ShenandoahThreadLocalData();\n+  ~ShenandoahThreadLocalData();\n@@ -101,0 +123,5 @@\n+\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      data(thread)->_plab = new PLAB(align_up(PLAB::min_size(), CardTable::card_size_in_words()));\n+      data(thread)->_plab_desired_size = 0;\n+    }\n@@ -115,0 +142,78 @@\n+  static void begin_evacuation(Thread* thread, size_t bytes) {\n+    data(thread)->_evacuation_stats->begin_evacuation(bytes);\n+  }\n+\n+  static void end_evacuation(Thread* thread, size_t bytes) {\n+    data(thread)->_evacuation_stats->end_evacuation(bytes);\n+  }\n+\n+  static void record_age(Thread* thread, size_t bytes, uint age) {\n+    data(thread)->_evacuation_stats->record_age(bytes, age);\n+  }\n+\n+  static ShenandoahEvacuationStats* evacuation_stats(Thread* thread) {\n+    shenandoah_assert_generational();\n+    return data(thread)->_evacuation_stats;\n+  }\n+\n+  static PLAB* plab(Thread* thread) {\n+    return data(thread)->_plab;\n+  }\n+\n+  static size_t plab_size(Thread* thread) {\n+    return data(thread)->_plab_desired_size;\n+  }\n+\n+  static void set_plab_size(Thread* thread, size_t v) {\n+    data(thread)->_plab_desired_size = v;\n+  }\n+\n+  static void enable_plab_retries(Thread* thread) {\n+    data(thread)->_plab_retries_enabled = true;\n+  }\n+\n+  static void disable_plab_retries(Thread* thread) {\n+    data(thread)->_plab_retries_enabled = false;\n+  }\n+\n+  static bool plab_retries_enabled(Thread* thread) {\n+    return data(thread)->_plab_retries_enabled;\n+  }\n+\n+  static void enable_plab_promotions(Thread* thread) {\n+    data(thread)->_plab_allows_promotion = true;\n+  }\n+\n+  static void disable_plab_promotions(Thread* thread) {\n+    data(thread)->_plab_allows_promotion = false;\n+  }\n+\n+  static bool allow_plab_promotions(Thread* thread) {\n+    return data(thread)->_plab_allows_promotion;\n+  }\n+\n+  static void reset_plab_promoted(Thread* thread) {\n+    data(thread)->_plab_promoted = 0;\n+  }\n+\n+  static void add_to_plab_promoted(Thread* thread, size_t increment) {\n+    data(thread)->_plab_promoted += increment;\n+  }\n+\n+  static void subtract_from_plab_promoted(Thread* thread, size_t increment) {\n+    assert(data(thread)->_plab_promoted >= increment, \"Cannot subtract more than remaining promoted\");\n+    data(thread)->_plab_promoted -= increment;\n+  }\n+\n+  static size_t get_plab_promoted(Thread* thread) {\n+    return data(thread)->_plab_promoted;\n+  }\n+\n+  static void set_plab_actual_size(Thread* thread, size_t value) {\n+    data(thread)->_plab_actual_size = value;\n+  }\n+\n+  static size_t get_plab_actual_size(Thread* thread) {\n+    return data(thread)->_plab_actual_size;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":119,"deletions":14,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahEvacInfo.hpp\"\n+#include \"gc\/shenandoah\/shenandoahTrace.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+\n+void ShenandoahTracer::report_evacuation_info(ShenandoahEvacuationInformation* info) {\n+  send_evacuation_info_event(info);\n+}\n+\n+void ShenandoahTracer::send_evacuation_info_event(ShenandoahEvacuationInformation* info) {\n+  EventShenandoahEvacuationInformation e;\n+  if (e.should_commit()) {\n+    e.set_gcId(GCId::current());\n+    e.set_cSetRegions(info->collection_set_regions());\n+    e.set_cSetUsedBefore(info->collection_set_used_before());\n+    e.set_cSetUsedAfter(info->collection_set_used_after());\n+    e.set_collectedOld(info->collected_old());\n+    e.set_collectedPromoted(info->collected_promoted());\n+    e.set_collectedYoung(info->collected_young());\n+    e.set_regionsPromotedHumongous(info->regions_promoted_humongous());\n+    e.set_regionsPromotedRegular(info->regions_promoted_regular());\n+    e.set_regularPromotedGarbage(info->regular_promoted_garbage());\n+    e.set_regularPromotedFree(info->regular_promoted_free());\n+    e.set_regionsFreed(info->regions_freed());\n+    e.set_regionsImmediate(info->regions_immediate());\n+    e.set_immediateBytes(info->immediate_size());\n+\n+    e.commit();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTrace.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTRACE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHTRACE_HPP\n+\n+#include \"gc\/shared\/gcTrace.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+class ShenandoahEvacuationInformation;\n+\n+class ShenandoahTracer : public GCTracer, public CHeapObj<mtGC> {\n+public:\n+  ShenandoahTracer() : GCTracer(Shenandoah) {}\n+  void report_evacuation_info(ShenandoahEvacuationInformation* info);\n+\n+private:\n+  void send_evacuation_info_event(ShenandoahEvacuationInformation* info);\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTrace.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -35,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -41,1 +44,1 @@\n-ShenandoahGCSession::ShenandoahGCSession(GCCause::Cause cause) :\n+ShenandoahGCSession::ShenandoahGCSession(GCCause::Cause cause, ShenandoahGeneration* generation) :\n@@ -43,0 +46,1 @@\n+  _generation(generation),\n@@ -47,2 +51,2 @@\n-  _heap->shenandoah_policy()->record_collection_cause(cause);\n-  _heap->set_gc_cause(cause);\n+  _heap->on_cycle_start(cause, _generation);\n+\n@@ -53,1 +57,0 @@\n-  _heap->heuristics()->record_cycle_start();\n@@ -68,1 +71,1 @@\n-  _heap->heuristics()->record_cycle_end();\n+  _heap->on_cycle_end(_generation);\n@@ -71,1 +74,1 @@\n-  _tracer->report_gc_reference_stats(_heap->ref_processor()->reference_process_stats());\n+  _tracer->report_gc_reference_stats(_generation->ref_processor()->reference_process_stats());\n@@ -74,1 +77,0 @@\n-  _heap->set_gc_cause(GCCause::_no_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,0 +45,16 @@\n+class ShenandoahGeneration;\n+\n+#define SHENANDOAH_RETURN_EVENT_MESSAGE(generation_type, prefix, postfix) \\\n+  switch (generation_type) {                                              \\\n+    case NON_GEN:                                                         \\\n+      return prefix postfix;                                              \\\n+    case GLOBAL:                                                          \\\n+      return prefix \" (Global)\" postfix;                                  \\\n+    case YOUNG:                                                           \\\n+      return prefix \" (Young)\" postfix;                                   \\\n+    case OLD:                                                             \\\n+      return prefix \" (Old)\" postfix;                                     \\\n+    default:                                                              \\\n+      ShouldNotReachHere();                                               \\\n+      return prefix \" (Unknown)\" postfix;                                 \\\n+  }                                                                       \\\n@@ -48,0 +65,1 @@\n+  ShenandoahGeneration* const _generation;\n@@ -53,1 +71,1 @@\n-  ShenandoahGCSession(GCCause::Cause cause);\n+  ShenandoahGCSession(GCCause::Cause cause, ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"logging\/log.hpp\"\n@@ -37,0 +39,1 @@\n+  log_active_generation(\"Prologue\");\n@@ -42,0 +45,1 @@\n+  log_active_generation(\"Epilogue\");\n@@ -48,0 +52,15 @@\n+void VM_ShenandoahOperation::log_active_generation(const char* prefix) {\n+  ShenandoahGeneration* agen = ShenandoahHeap::heap()->active_generation();\n+  ShenandoahGeneration* ggen = ShenandoahHeap::heap()->gc_generation();\n+  log_debug(gc, heap)(\"%s: active_generation is %s, gc_generation is %s\", prefix,\n+                      agen == nullptr ? \"nullptr\" : shenandoah_generation_name(agen->type()),\n+                      ggen == nullptr ? \"nullptr\" : shenandoah_generation_name(ggen->type()));\n+}\n+\n+void VM_ShenandoahOperation::set_active_generation() {\n+  if (evaluate_at_safepoint()) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"Error??\");\n+    ShenandoahHeap::heap()->set_active_generation();\n+  }\n+}\n+\n@@ -64,0 +83,1 @@\n+  set_active_generation();\n@@ -70,0 +90,1 @@\n+  set_active_generation();\n@@ -76,0 +97,1 @@\n+  set_active_generation();\n@@ -82,0 +104,1 @@\n+  set_active_generation();\n@@ -88,0 +111,1 @@\n+  set_active_generation();\n@@ -94,0 +118,1 @@\n+  set_active_generation();\n@@ -100,0 +125,1 @@\n+  set_active_generation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+\/\/   - VM_ShenandoahFinalRoots: finish up roots on a non-evacuating cycle\n@@ -47,1 +48,3 @@\n-  uint         _gc_id;\n+  uint _gc_id;\n+\n+  void set_active_generation();\n@@ -51,0 +54,2 @@\n+\n+  void log_active_generation(const char* prefix);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -33,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -36,0 +40,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -65,0 +70,1 @@\n+  ShenandoahGeneration* _generation;\n@@ -76,1 +82,2 @@\n-    _loc(nullptr) {\n+    _loc(nullptr),\n+    _generation(nullptr) {\n@@ -78,0 +85,1 @@\n+        options._verify_marked == ShenandoahVerifier::_verify_marked_complete_satb_empty ||\n@@ -87,0 +95,6 @@\n+\n+    if (_heap->mode()->is_generational()) {\n+      _generation = _heap->gc_generation();\n+      assert(_generation != nullptr, \"Expected active generation in this mode\");\n+      shenandoah_assert_generations_reconciled();\n+    }\n@@ -113,2 +127,1 @@\n-\n-      if (_map->par_mark(obj)) {\n+      if (in_generation(obj) && _map->par_mark(obj)) {\n@@ -121,0 +134,9 @@\n+  bool in_generation(oop obj) {\n+    if (_generation == nullptr) {\n+      return true;\n+    }\n+\n+    ShenandoahHeapRegion* region = _heap->heap_region_containing(obj);\n+    return _generation->contains(region);\n+  }\n+\n@@ -171,1 +193,2 @@\n-          check(ShenandoahAsserts::_safe_oop, obj, obj_reg->has_live(),\n+          check(ShenandoahAsserts::_safe_oop, obj, obj_reg->has_live() ||\n+                (obj_reg->is_old() && _heap->gc_generation()->is_young()),\n@@ -173,0 +196,1 @@\n+          shenandoah_assert_generations_reconciled();\n@@ -238,1 +262,0 @@\n-\n@@ -252,0 +275,1 @@\n+      case ShenandoahVerifier::_verify_marked_complete_satb_empty:\n@@ -338,2 +362,2 @@\n-  virtual void do_oop(oop* p) override { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p) override { do_oop_work(p); }\n+  void do_oop(oop* p) override { do_oop_work(p); }\n+  void do_oop(narrowOop* p) override { do_oop_work(p); }\n@@ -342,0 +366,2 @@\n+\/\/ This closure computes the amounts of used, committed, and garbage memory and the number of regions contained within\n+\/\/ a subset (e.g. the young generation or old generation) of the total heap.\n@@ -344,1 +370,1 @@\n-  size_t _used, _committed, _garbage;\n+  size_t _used, _committed, _garbage, _regions, _humongous_waste, _trashed_regions;\n@@ -346,1 +372,2 @@\n-  ShenandoahCalculateRegionStatsClosure() : _used(0), _committed(0), _garbage(0) {};\n+  ShenandoahCalculateRegionStatsClosure() :\n+      _used(0), _committed(0), _garbage(0), _regions(0), _humongous_waste(0), _trashed_regions(0) {};\n@@ -348,1 +375,1 @@\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n@@ -352,0 +379,43 @@\n+    if (r->is_humongous()) {\n+      _humongous_waste += r->free();\n+    }\n+    if (r->is_trash()) {\n+      _trashed_regions++;\n+    }\n+    _regions++;\n+    log_debug(gc)(\"ShenandoahCalculateRegionStatsClosure: adding \" SIZE_FORMAT \" for %s Region \" SIZE_FORMAT \", yielding: \" SIZE_FORMAT,\n+            r->used(), (r->is_humongous() ? \"humongous\" : \"regular\"), r->index(), _used);\n+  }\n+\n+  size_t used() const { return _used; }\n+  size_t committed() const { return _committed; }\n+  size_t garbage() const { return _garbage; }\n+  size_t regions() const { return _regions; }\n+  size_t waste() const { return _humongous_waste; }\n+\n+  \/\/ span is the total memory affiliated with these stats (some of which is in use and other is available)\n+  size_t span() const { return _regions * ShenandoahHeapRegion::region_size_bytes(); }\n+  size_t non_trashed_span() const { return (_regions - _trashed_regions) * ShenandoahHeapRegion::region_size_bytes(); }\n+};\n+\n+class ShenandoahGenerationStatsClosure : public ShenandoahHeapRegionClosure {\n+ public:\n+  ShenandoahCalculateRegionStatsClosure old;\n+  ShenandoahCalculateRegionStatsClosure young;\n+  ShenandoahCalculateRegionStatsClosure global;\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    switch (r->affiliation()) {\n+      case FREE:\n+        return;\n+      case YOUNG_GENERATION:\n+        young.heap_region_do(r);\n+        global.heap_region_do(r);\n+        break;\n+      case OLD_GENERATION:\n+        old.heap_region_do(r);\n+        global.heap_region_do(r);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -354,3 +424,37 @@\n-  size_t used() { return _used; }\n-  size_t committed() { return _committed; }\n-  size_t garbage() { return _garbage; }\n+  static void log_usage(ShenandoahGeneration* generation, ShenandoahCalculateRegionStatsClosure& stats) {\n+    log_debug(gc)(\"Safepoint verification: %s verified usage: \" SIZE_FORMAT \"%s, recorded usage: \" SIZE_FORMAT \"%s\",\n+                  generation->name(),\n+                  byte_size_in_proper_unit(generation->used()), proper_unit_for_byte_size(generation->used()),\n+                  byte_size_in_proper_unit(stats.used()),       proper_unit_for_byte_size(stats.used()));\n+  }\n+\n+  static void validate_usage(const bool adjust_for_padding,\n+                             const char* label, ShenandoahGeneration* generation, ShenandoahCalculateRegionStatsClosure& stats) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t generation_used = generation->used();\n+    size_t generation_used_regions = generation->used_regions();\n+    if (adjust_for_padding && (generation->is_young() || generation->is_global())) {\n+      size_t pad = heap->old_generation()->get_pad_for_promote_in_place();\n+      generation_used += pad;\n+    }\n+\n+    guarantee(stats.used() == generation_used,\n+              \"%s: generation (%s) used size must be consistent: generation-used: \" PROPERFMT \", regions-used: \" PROPERFMT,\n+              label, generation->name(), PROPERFMTARGS(generation_used), PROPERFMTARGS(stats.used()));\n+\n+    guarantee(stats.regions() == generation_used_regions,\n+              \"%s: generation (%s) used regions (\" SIZE_FORMAT \") must equal regions that are in use (\" SIZE_FORMAT \")\",\n+              label, generation->name(), generation->used_regions(), stats.regions());\n+\n+    size_t generation_capacity = generation->max_capacity();\n+    guarantee(stats.non_trashed_span() <= generation_capacity,\n+              \"%s: generation (%s) size spanned by regions (\" SIZE_FORMAT \") * region size (\" PROPERFMT\n+              \") must not exceed current capacity (\" PROPERFMT \")\",\n+              label, generation->name(), stats.regions(), PROPERFMTARGS(ShenandoahHeapRegion::region_size_bytes()),\n+              PROPERFMTARGS(generation_capacity));\n+\n+    size_t humongous_waste = generation->get_humongous_waste();\n+    guarantee(stats.waste() == humongous_waste,\n+              \"%s: generation (%s) humongous waste must be consistent: generation: \" PROPERFMT \", regions: \" PROPERFMT,\n+              label, generation->name(), PROPERFMTARGS(humongous_waste), PROPERFMTARGS(stats.waste()));\n+  }\n@@ -388,1 +492,1 @@\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n@@ -440,2 +544,5 @@\n-    verify(r, r->get_shared_allocs() + r->get_tlab_allocs() + r->get_gclab_allocs() == r->used(),\n-           \"Accurate accounting: shared + TLAB + GCLAB = used\");\n+    verify(r, r->get_plab_allocs() <= r->capacity(),\n+           \"PLAB alloc count should not be larger than capacity\");\n+\n+    verify(r, r->get_shared_allocs() + r->get_tlab_allocs() + r->get_gclab_allocs() + r->get_plab_allocs() == r->used(),\n+           \"Accurate accounting: shared + TLAB + GCLAB + PLAB = used\");\n@@ -473,1 +580,1 @@\n-  size_t processed() {\n+  size_t processed() const {\n@@ -477,1 +584,1 @@\n-  virtual void work(uint worker_id) {\n+  void work(uint worker_id) override {\n@@ -514,0 +621,10 @@\n+class ShenandoahVerifyNoIncompleteSatbBuffers : public ThreadClosure {\n+public:\n+  void do_thread(Thread* thread) override {\n+    SATBMarkQueue& queue = ShenandoahThreadLocalData::satb_mark_queue(thread);\n+    if (!queue.is_empty()) {\n+      fatal(\"All SATB buffers should have been flushed during mark\");\n+    }\n+  }\n+};\n+\n@@ -523,0 +640,1 @@\n+  ShenandoahGeneration* _generation;\n@@ -536,1 +654,8 @@\n-          _processed(0) {};\n+          _processed(0),\n+          _generation(nullptr) {\n+    if (_heap->mode()->is_generational()) {\n+      _generation = _heap->gc_generation();\n+      assert(_generation != nullptr, \"Expected active generation in this mode.\");\n+      shenandoah_assert_generations_reconciled();\n+    }\n+  };\n@@ -542,1 +667,6 @@\n-  virtual void work(uint worker_id) {\n+  void work(uint worker_id) override {\n+    if (_options._verify_marked == ShenandoahVerifier::_verify_marked_complete_satb_empty) {\n+      ShenandoahVerifyNoIncompleteSatbBuffers verify_satb;\n+      Threads::threads_do(&verify_satb);\n+    }\n+\n@@ -552,0 +682,4 @@\n+        if (!in_generation(r)) {\n+          continue;\n+        }\n+\n@@ -563,0 +697,4 @@\n+  bool in_generation(ShenandoahHeapRegion* r) {\n+    return _generation == nullptr || _generation->contains(r);\n+  }\n+\n@@ -633,1 +771,1 @@\n-  void do_thread(Thread* t) {\n+  void do_thread(Thread* t) override {\n@@ -635,1 +773,1 @@\n-    if (actual != _expected) {\n+    if (!verify_gc_state(actual, _expected)) {\n@@ -639,0 +777,10 @@\n+\n+  static bool verify_gc_state(char actual, char expected) {\n+    \/\/ Old generation marking is allowed in all states.\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      return ((actual & ~(ShenandoahHeap::OLD_MARKING | ShenandoahHeap::MARKING)) == expected);\n+    } else {\n+      assert((actual & ShenandoahHeap::OLD_MARKING) == 0, \"Should not mark old in non-generational mode\");\n+      return (actual == expected);\n+    }\n+  }\n@@ -641,1 +789,2 @@\n-void ShenandoahVerifier::verify_at_safepoint(const char *label,\n+void ShenandoahVerifier::verify_at_safepoint(const char* label,\n+                                             VerifyRememberedSet remembered,\n@@ -645,0 +794,1 @@\n+                                             VerifySize sizeness,\n@@ -668,0 +818,4 @@\n+      case _verify_gcstate_updating:\n+        enabled = true;\n+        expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::UPDATEREFS;\n+        break;\n@@ -687,1 +841,7 @@\n-      if (actual != expected) {\n+\n+      bool is_marking = (actual & ShenandoahHeap::MARKING);\n+      bool is_marking_young_or_old = (actual & (ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING));\n+      assert(is_marking == is_marking_young_or_old, \"MARKING iff (YOUNG_MARKING or OLD_MARKING), gc_state is: %x\", actual);\n+\n+      \/\/ Old generation marking is allowed in all states.\n+      if (!VerifyThreadGCState::verify_gc_state(actual, expected)) {\n@@ -705,7 +865,14 @@\n-    size_t heap_used = _heap->used();\n-    guarantee(cl.used() == heap_used,\n-              \"%s: heap used size must be consistent: heap-used = \" SIZE_FORMAT \"%s, regions-used = \" SIZE_FORMAT \"%s\",\n-              label,\n-              byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),\n-              byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));\n-\n+    size_t heap_used;\n+    if (_heap->mode()->is_generational() && (sizeness == _verify_size_adjusted_for_padding)) {\n+      \/\/ Prior to evacuation, regular regions that are to be evacuated in place are padded to prevent further allocations\n+      heap_used = _heap->used() + _heap->old_generation()->get_pad_for_promote_in_place();\n+    } else if (sizeness != _verify_size_disable) {\n+      heap_used = _heap->used();\n+    }\n+    if (sizeness != _verify_size_disable) {\n+      guarantee(cl.used() == heap_used,\n+                \"%s: heap used size must be consistent: heap-used = \" SIZE_FORMAT \"%s, regions-used = \" SIZE_FORMAT \"%s\",\n+                label,\n+                byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),\n+                byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));\n+    }\n@@ -720,0 +887,55 @@\n+  log_debug(gc)(\"Safepoint verification finished heap usage verification\");\n+\n+  ShenandoahGeneration* generation;\n+  if (_heap->mode()->is_generational()) {\n+    generation = _heap->gc_generation();\n+    guarantee(generation != nullptr, \"Need to know which generation to verify.\");\n+    shenandoah_assert_generations_reconciled();\n+  } else {\n+    generation = nullptr;\n+  }\n+\n+  if (generation != nullptr) {\n+    ShenandoahHeapLocker lock(_heap->lock());\n+\n+    switch (remembered) {\n+      case _verify_remembered_disable:\n+        break;\n+      case _verify_remembered_before_marking:\n+        log_debug(gc)(\"Safepoint verification of remembered set at mark\");\n+        verify_rem_set_before_mark();\n+        break;\n+      case _verify_remembered_before_updating_references:\n+        log_debug(gc)(\"Safepoint verification of remembered set at update ref\");\n+        verify_rem_set_before_update_ref();\n+        break;\n+      case _verify_remembered_after_full_gc:\n+        log_debug(gc)(\"Safepoint verification of remembered set after full gc\");\n+        verify_rem_set_after_full_gc();\n+        break;\n+      default:\n+        fatal(\"Unhandled remembered set verification mode\");\n+    }\n+\n+    ShenandoahGenerationStatsClosure cl;\n+    _heap->heap_region_iterate(&cl);\n+\n+    if (LogTarget(Debug, gc)::is_enabled()) {\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->old_generation(),    cl.old);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->young_generation(),  cl.young);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->global_generation(), cl.global);\n+    }\n+    if (sizeness == _verify_size_adjusted_for_padding) {\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->old_generation(), cl.old);\n+      ShenandoahGenerationStatsClosure::validate_usage(true, label, _heap->young_generation(), cl.young);\n+      ShenandoahGenerationStatsClosure::validate_usage(true, label, _heap->global_generation(), cl.global);\n+    } else if (sizeness == _verify_size_exact) {\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->old_generation(), cl.old);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->young_generation(), cl.young);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->global_generation(), cl.global);\n+    }\n+    \/\/ else: sizeness must equal _verify_size_disable\n+  }\n+\n+  log_debug(gc)(\"Safepoint verification finished remembered set verification\");\n+\n@@ -723,1 +945,5 @@\n-    _heap->heap_region_iterate(&cl);\n+    if (generation != nullptr) {\n+      generation->heap_region_iterate(&cl);\n+    } else {\n+      _heap->heap_region_iterate(&cl);\n+    }\n@@ -726,0 +952,2 @@\n+  log_debug(gc)(\"Safepoint verification finished heap region closure verification\");\n+\n@@ -750,0 +978,2 @@\n+  log_debug(gc)(\"Safepoint verification finished getting initial reachable set\");\n+\n@@ -758,1 +988,4 @@\n-  if (ShenandoahVerifyLevel >= 4 && (marked == _verify_marked_complete || marked == _verify_marked_complete_except_references)) {\n+  if (ShenandoahVerifyLevel >= 4 &&\n+        (marked == _verify_marked_complete ||\n+         marked == _verify_marked_complete_except_references ||\n+         marked == _verify_marked_complete_satb_empty)) {\n@@ -767,0 +1000,2 @@\n+  log_debug(gc)(\"Safepoint verification finished walking marked objects\");\n+\n@@ -773,0 +1008,3 @@\n+      if (generation != nullptr && !generation->contains(r)) {\n+        continue;\n+      }\n@@ -796,0 +1034,3 @@\n+  log_debug(gc)(\"Safepoint verification finished accumulation of liveness data\");\n+\n+\n@@ -805,0 +1046,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -810,0 +1052,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -817,0 +1060,2 @@\n+          _verify_remembered_before_marking,\n+                                       \/\/ verify read-only remembered set from bottom() to top()\n@@ -822,0 +1067,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -829,6 +1075,23 @@\n-          _verify_forwarded_none,      \/\/ no forwarded references\n-          _verify_marked_complete_except_references, \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n-          _verify_cset_none,           \/\/ no references to cset anymore\n-          _verify_liveness_complete,   \/\/ liveness data must be complete here\n-          _verify_regions_disable,     \/\/ trash regions not yet recycled\n-          _verify_gcstate_stable_weakroots  \/\/ heap is still stable, weakroots are in progress\n+          _verify_remembered_disable,         \/\/ do not verify remembered set\n+          _verify_forwarded_none,             \/\/ no forwarded references\n+          _verify_marked_complete_satb_empty, \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n+          _verify_cset_none,                  \/\/ no references to cset anymore\n+          _verify_liveness_complete,          \/\/ liveness data must be complete here\n+          _verify_regions_disable,            \/\/ trash regions not yet recycled\n+          _verify_size_exact,                 \/\/ expect generation and heap sizes to match exactly\n+          _verify_gcstate_stable_weakroots    \/\/ heap is still stable, weakroots are in progress\n+  );\n+}\n+\n+void ShenandoahVerifier::verify_after_concmark_with_promotions() {\n+  verify_at_safepoint(\n+          \"After Mark\",\n+          _verify_remembered_disable,         \/\/ do not verify remembered set\n+          _verify_forwarded_none,             \/\/ no forwarded references\n+          _verify_marked_complete_satb_empty, \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n+          _verify_cset_none,                  \/\/ no references to cset anymore\n+          _verify_liveness_complete,          \/\/ liveness data must be complete here\n+          _verify_regions_disable,            \/\/ trash regions not yet recycled\n+          _verify_size_adjusted_for_padding,  \/\/ expect generation and heap sizes to match after adjustments\n+                                              \/\/ for promote in place padding\n+          _verify_gcstate_stable_weakroots    \/\/ heap is still stable, weakroots are in progress\n@@ -841,0 +1104,1 @@\n+          _verify_remembered_disable,                \/\/ do not verify remembered set\n@@ -846,0 +1110,2 @@\n+          _verify_size_adjusted_for_padding,         \/\/ expect generation and heap sizes to match after adjustments\n+                                                     \/\/  for promote in place padding\n@@ -853,0 +1119,1 @@\n+          _verify_remembered_before_updating_references,  \/\/ verify read-write remembered set\n@@ -858,1 +1125,2 @@\n-          _verify_gcstate_forwarded    \/\/ evacuation should have produced some forwarded objects\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n+          _verify_gcstate_updating     \/\/ evacuation should have produced some forwarded objects\n@@ -862,0 +1130,1 @@\n+\/\/ We have not yet cleanup (reclaimed) the collection set\n@@ -865,0 +1134,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -870,0 +1140,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -877,0 +1148,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -882,0 +1154,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -889,0 +1162,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -894,0 +1168,1 @@\n+          _verify_size_disable,        \/\/ if we degenerate during evacuation, usage not valid: padding and deferred accounting\n@@ -901,0 +1176,1 @@\n+          _verify_remembered_after_full_gc,  \/\/ verify read-write remembered set\n@@ -906,0 +1182,1 @@\n+          _verify_size_exact,           \/\/ expect generation and heap sizes to match exactly\n@@ -910,1 +1187,1 @@\n-class ShenandoahVerifyNoForwared : public OopClosure {\n+class ShenandoahVerifyNoForwarded : public BasicOopIterateClosure {\n@@ -930,1 +1207,1 @@\n-class ShenandoahVerifyInToSpaceClosure : public OopClosure {\n+class ShenandoahVerifyInToSpaceClosure : public BasicOopIterateClosure {\n@@ -939,1 +1216,1 @@\n-      if (!heap->marking_context()->is_marked(obj)) {\n+      if (!heap->marking_context()->is_marked_or_old(obj)) {\n@@ -958,2 +1235,2 @@\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n-  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) override { do_oop_work(p); }\n+  void do_oop(oop* p)       override { do_oop_work(p); }\n@@ -968,1 +1245,1 @@\n-  ShenandoahVerifyNoForwared cl;\n+  ShenandoahVerifyNoForwarded cl;\n@@ -971,0 +1248,165 @@\n+\n+template<typename Scanner>\n+class ShenandoahVerifyRemSetClosure : public BasicOopIterateClosure {\n+protected:\n+  ShenandoahGenerationalHeap* const _heap;\n+  Scanner*   const _scanner;\n+  const char* _message;\n+\n+public:\n+  \/\/ Argument distinguishes between initial mark or start of update refs verification.\n+  explicit ShenandoahVerifyRemSetClosure(Scanner* scanner, const char* message) :\n+            _heap(ShenandoahGenerationalHeap::heap()),\n+            _scanner(scanner),\n+            _message(message) {}\n+\n+  template<class T>\n+  inline void work(T* p) {\n+    T o = RawAccess<>::oop_load(p);\n+    if (!CompressedOops::is_null(o)) {\n+      oop obj = CompressedOops::decode_not_null(o);\n+      if (_heap->is_in_young(obj) && !_scanner->is_card_dirty((HeapWord*) p)) {\n+        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                         _message, \"clean card should be dirty\", __FILE__, __LINE__);\n+      }\n+    }\n+  }\n+\n+  void do_oop(narrowOop* p) override { work(p); }\n+  void do_oop(oop* p)       override { work(p); }\n+};\n+\n+ShenandoahMarkingContext* ShenandoahVerifier::get_marking_context_for_old() {\n+  shenandoah_assert_generations_reconciled();\n+  if (_heap->old_generation()->is_mark_complete() || _heap->gc_generation()->is_global()) {\n+    return _heap->complete_marking_context();\n+  }\n+  return nullptr;\n+}\n+\n+template<typename Scanner>\n+void ShenandoahVerifier::help_verify_region_rem_set(Scanner* scanner, ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n+                                                    HeapWord* registration_watermark, const char* message) {\n+  ShenandoahVerifyRemSetClosure<Scanner> check_interesting_pointers(scanner, message);\n+  HeapWord* from = r->bottom();\n+  HeapWord* obj_addr = from;\n+  if (r->is_humongous_start()) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+      \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n+      \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+      \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+      if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+        obj->oop_iterate(&check_interesting_pointers);\n+      }\n+      \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+    }\n+    \/\/ else, this humongous object is not live so no need to verify its internal pointers\n+\n+    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+      ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                       \"object not properly registered\", __FILE__, __LINE__);\n+    }\n+  } else if (!r->is_humongous()) {\n+    HeapWord* top = r->top();\n+    while (obj_addr < top) {\n+      oop obj = cast_to_oop(obj_addr);\n+      \/\/ ctx->is_marked() returns true if mark bit set or if obj above TAMS.\n+      if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+        \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+        \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+        if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+          obj->oop_iterate(&check_interesting_pointers);\n+        }\n+        \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+\n+        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                           \"object not properly registered\", __FILE__, __LINE__);\n+        }\n+        obj_addr += obj->size();\n+      } else {\n+        \/\/ This object is not live so we don't verify dirty cards contained therein\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n+      }\n+    }\n+  }\n+}\n+\n+class ShenandoahWriteTableScanner {\n+private:\n+  ShenandoahScanRemembered* _scanner;\n+public:\n+  explicit ShenandoahWriteTableScanner(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n+\n+  bool is_card_dirty(HeapWord* obj_addr) {\n+    return _scanner->is_write_card_dirty(obj_addr);\n+  }\n+\n+  bool verify_registration(HeapWord* obj_addr, ShenandoahMarkingContext* ctx) {\n+    return _scanner->verify_registration(obj_addr, ctx);\n+  }\n+};\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.\n+\/\/ This examines the read_card_table between bottom() and top() since all PLABS are retired\n+\/\/ before the safepoint for init_mark.  Actually, we retire them before update-references and don't\n+\/\/ restore them until the start of evacuation.\n+void ShenandoahVerifier::verify_rem_set_before_mark() {\n+  shenandoah_assert_safepoint();\n+  shenandoah_assert_generational();\n+\n+  ShenandoahMarkingContext* ctx = get_marking_context_for_old();\n+  ShenandoahOldGeneration* old_generation = _heap->old_generation();\n+\n+  log_debug(gc)(\"Verifying remembered set at %s mark\", old_generation->is_doing_mixed_evacuations() ? \"mixed\" : \"young\");\n+\n+  ShenandoahScanRemembered* scanner = old_generation->card_scan();\n+  for (size_t i = 0, n = _heap->num_regions(); i < n; ++i) {\n+    ShenandoahHeapRegion* r = _heap->get_region(i);\n+    if (r->is_old() && r->is_active()) {\n+      help_verify_region_rem_set(scanner, r, ctx, r->end(), \"Verify init-mark remembered set violation\");\n+    }\n+  }\n+}\n+\n+void ShenandoahVerifier::verify_rem_set_after_full_gc() {\n+  shenandoah_assert_safepoint();\n+  shenandoah_assert_generational();\n+\n+  ShenandoahWriteTableScanner scanner(ShenandoahGenerationalHeap::heap()->old_generation()->card_scan());\n+  for (size_t i = 0, n = _heap->num_regions(); i < n; ++i) {\n+    ShenandoahHeapRegion* r = _heap->get_region(i);\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(&scanner, r, nullptr, r->top(), \"Remembered set violation at end of Full GC\");\n+    }\n+  }\n+}\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.  Even though\n+\/\/ the update-references scan of remembered set only examines cards up to update_watermark, the remembered\n+\/\/ set should be valid through top.  This examines the write_card_table between bottom() and top() because\n+\/\/ all PLABS are retired immediately before the start of update refs.\n+void ShenandoahVerifier::verify_rem_set_before_update_ref() {\n+  shenandoah_assert_safepoint();\n+  shenandoah_assert_generational();\n+\n+  ShenandoahMarkingContext* ctx = get_marking_context_for_old();\n+  ShenandoahWriteTableScanner scanner(_heap->old_generation()->card_scan());\n+  for (size_t i = 0, n = _heap->num_regions(); i < n; ++i) {\n+    ShenandoahHeapRegion* r = _heap->get_region(i);\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(&scanner, r, ctx, r->get_update_watermark(), \"Remembered set violation at init-update-references\");\n+    }\n+  }\n+}\n+\n+void ShenandoahVerifier::verify_before_rebuilding_free_set() {\n+  ShenandoahGenerationStatsClosure cl;\n+  _heap->heap_region_iterate(&cl);\n+\n+  ShenandoahGenerationStatsClosure::validate_usage(false, \"Before free set rebuild\", _heap->old_generation(), cl.old);\n+  ShenandoahGenerationStatsClosure::validate_usage(false, \"Before free set rebuild\", _heap->young_generation(), cl.young);\n+  ShenandoahGenerationStatsClosure::validate_usage(false, \"Before free set rebuild\", _heap->global_generation(), cl.global);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":488,"deletions":46,"binary":false,"changes":534,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -35,0 +36,1 @@\n+class ShenandoahMarkingContext;\n@@ -60,0 +62,18 @@\n+  typedef enum {\n+    \/\/ Disable remembered set verification.\n+    _verify_remembered_disable,\n+\n+    \/\/ Old objects should be registered and RS cards within *read-only* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_marking,\n+\n+    \/\/ Old objects should be registered and RS cards within *read-write* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_updating_references,\n+\n+    \/\/ Old objects should be registered and RS cards within *read-write* RS are dirty for all\n+    \/\/ inter-generational pointers. Differs from previous verification modes by using top instead\n+    \/\/ of update watermark and not using the marking context.\n+    _verify_remembered_after_full_gc\n+  } VerifyRememberedSet;\n+\n@@ -72,1 +92,6 @@\n-    _verify_marked_complete_except_references\n+    _verify_marked_complete_except_references,\n+\n+    \/\/ Objects should be marked in \"complete\" bitmap, except j.l.r.Reference referents, which\n+    \/\/ may be dangling after marking but before conc-weakrefs-processing. All SATB buffers must\n+    \/\/ be empty.\n+    _verify_marked_complete_satb_empty,\n@@ -125,0 +150,11 @@\n+  typedef enum {\n+    \/\/ Disable size verification\n+    _verify_size_disable,\n+\n+    \/\/ Enforce exact consistency\n+    _verify_size_exact,\n+\n+    \/\/ Expect promote-in-place adjustments: padding inserted to temporarily prevent further allocation in regular regions\n+    _verify_size_adjusted_for_padding\n+  } VerifySize;\n+\n@@ -136,1 +172,4 @@\n-    _verify_gcstate_forwarded\n+    _verify_gcstate_forwarded,\n+\n+    \/\/ Evacuation is done, some objects are forwarded, updating is in progress\n+    _verify_gcstate_updating\n@@ -160,1 +199,2 @@\n-  void verify_at_safepoint(const char *label,\n+  void verify_at_safepoint(const char* label,\n+                           VerifyRememberedSet remembered,\n@@ -166,0 +206,1 @@\n+                           VerifySize sizeness,\n@@ -174,0 +215,1 @@\n+  void verify_after_concmark_with_promotions();\n@@ -184,1 +226,0 @@\n-\n@@ -186,0 +227,13 @@\n+\n+  \/\/ Check that generation usages are accurate before rebuilding free set\n+  void verify_before_rebuilding_free_set();\n+private:\n+  template<typename Scanner>\n+  void help_verify_region_rem_set(Scanner* scanner, ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n+                                  HeapWord* update_watermark, const char* message);\n+\n+  void verify_rem_set_before_mark();\n+  void verify_rem_set_before_update_ref();\n+  void verify_rem_set_after_full_gc();\n+\n+  ShenandoahMarkingContext* get_marking_context_for_old();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+uint ShenandoahWorkerPolicy::calc_workers_for_rs_scanning() {\n+  return ConcGCThreads;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+  \/\/ Calculate the number of workers for remembered set scanning\n+  static uint calc_workers_for_rs_scanning();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp\"\n+\n+ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity) :\n+  ShenandoahGeneration(YOUNG, max_queues, max_capacity, soft_max_capacity),\n+  _old_gen_task_queues(nullptr) {\n+}\n+\n+void ShenandoahYoungGeneration::set_concurrent_mark_in_progress(bool in_progress) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->set_concurrent_young_mark_in_progress(in_progress);\n+  if (is_bootstrap_cycle() && in_progress && !heap->is_prepare_for_old_mark_in_progress()) {\n+    \/\/ This is not a bug. When the bootstrapping marking phase is complete,\n+    \/\/ the old generation marking is still in progress, unless it's not.\n+    \/\/ In the case that old-gen preparation for mixed evacuation has been\n+    \/\/ preempted, we do not want to set concurrent old mark to be in progress.\n+    heap->set_concurrent_old_mark_in_progress(in_progress);\n+  }\n+}\n+\n+bool ShenandoahYoungGeneration::contains(ShenandoahAffiliation affiliation) const {\n+  return affiliation == YOUNG_GENERATION;\n+}\n+\n+bool ShenandoahYoungGeneration::contains(ShenandoahHeapRegion* region) const {\n+  return region->is_young();\n+}\n+\n+void ShenandoahYoungGeneration::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  \/\/ Just iterate over the young generation here.\n+  ShenandoahIncludeRegionClosure<YOUNG_GENERATION> young_regions_cl(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&young_regions_cl);\n+}\n+\n+void ShenandoahYoungGeneration::heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahIncludeRegionClosure<YOUNG_GENERATION> young_regions_cl(cl);\n+  ShenandoahHeap::heap()->heap_region_iterate(&young_regions_cl);\n+}\n+\n+void ShenandoahYoungGeneration::parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  \/\/ Iterate over everything that is not old.\n+  ShenandoahExcludeRegionClosure<OLD_GENERATION> exclude_cl(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&exclude_cl);\n+}\n+\n+bool ShenandoahYoungGeneration::is_concurrent_mark_in_progress() {\n+  return ShenandoahHeap::heap()->is_concurrent_young_mark_in_progress();\n+}\n+\n+void ShenandoahYoungGeneration::reserve_task_queues(uint workers) {\n+  ShenandoahGeneration::reserve_task_queues(workers);\n+  if (is_bootstrap_cycle()) {\n+    _old_gen_task_queues->reserve(workers);\n+  }\n+}\n+\n+bool ShenandoahYoungGeneration::contains(oop obj) const {\n+  return ShenandoahHeap::heap()->is_in_young(obj);\n+}\n+\n+ShenandoahHeuristics* ShenandoahYoungGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  _young_heuristics = new ShenandoahYoungHeuristics(this);\n+  _heuristics = _young_heuristics;\n+  _heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedYoungGCInterval);\n+  confirm_heuristics_mode();\n+  return _heuristics;\n+}\n+\n+size_t ShenandoahYoungGeneration::available() const {\n+  \/\/ The collector reserve may eat into what the mutator is allowed to use. Make sure we are looking\n+  \/\/ at what is available to the mutator when reporting how much memory is available.\n+  size_t available = this->ShenandoahGeneration::available();\n+  return MIN2(available, ShenandoahHeap::heap()->free_set()->available());\n+}\n+\n+size_t ShenandoahYoungGeneration::soft_available() const {\n+  size_t available = this->ShenandoahGeneration::soft_available();\n+  return MIN2(available, ShenandoahHeap::heap()->free_set()->available());\n+}\n+\n+void ShenandoahYoungGeneration::prepare_gc() {\n+\n+  ShenandoahGeneration::prepare_gc();\n+\n+  assert(type() == YOUNG, \"Error?\");\n+  \/\/ Clear any stale\/partial local census data before the start of a\n+  \/\/ new marking cycle\n+  ShenandoahGenerationalHeap::heap()->age_census()->reset_local();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.hpp\"\n+\n+class ShenandoahYoungGeneration : public ShenandoahGeneration {\n+private:\n+  ShenandoahObjToScanQueueSet* _old_gen_task_queues;\n+  ShenandoahYoungHeuristics* _young_heuristics;\n+\n+public:\n+  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t max_soft_capacity);\n+\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+\n+  const char* name() const override {\n+    return \"Young\";\n+  }\n+\n+  ShenandoahYoungHeuristics* heuristics() const override {\n+    return _young_heuristics;\n+  }\n+\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n+  bool is_concurrent_mark_in_progress() override;\n+\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  bool contains(ShenandoahAffiliation affiliation) const override;\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+  bool contains(oop obj) const override;\n+\n+  void reserve_task_queues(uint workers) override;\n+  void set_old_gen_task_queues(ShenandoahObjToScanQueueSet* old_gen_queues) {\n+    _old_gen_task_queues = old_gen_queues;\n+  }\n+  ShenandoahObjToScanQueueSet* old_gen_task_queues() const override {\n+    return _old_gen_task_queues;\n+  }\n+\n+  \/\/ Returns true if the young generation is configured to enqueue old\n+  \/\/ oops for the old generation mark queues.\n+  bool is_bootstrap_cycle() {\n+    return _old_gen_task_queues != nullptr;\n+  }\n+\n+  size_t available() const override;\n+\n+  \/\/ Do not override available_with_reserve() because that needs to see memory reserved for Collector\n+\n+  size_t soft_available() const override;\n+\n+  void prepare_gc() override;\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -36,0 +37,80 @@\n+  product(uintx, ShenandoahGenerationalHumongousReserve, 0, EXPERIMENTAL,   \\\n+          \"(Generational mode only) What percent of the heap should be \"    \\\n+          \"reserved for humongous objects if possible.  Old-generation \"    \\\n+          \"collections will endeavor to evacuate old-gen regions within \"   \\\n+          \"this reserved area even if these regions do not contain high \"   \\\n+          \"percentage of garbage.  Setting a larger value will cause \"      \\\n+          \"more frequent old-gen collections.  A smaller value will \"       \\\n+          \"increase the likelihood that humongous object allocations \"      \\\n+          \"fail, resulting in stop-the-world full GCs.\")                    \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(double, ShenandoahMinOldGenGrowthPercent, 12.5, EXPERIMENTAL,     \\\n+          \"(Generational mode only) If the usage within old generation \"    \\\n+          \"has grown by at least this percent of its live memory size \"     \\\n+          \"at completion of the most recent old-generation marking \"        \\\n+          \"effort, heuristics may trigger the start of a new old-gen \"      \\\n+          \"collection.\")                                                    \\\n+          range(0.0,100.0)                                                  \\\n+                                                                            \\\n+  product(uintx, ShenandoahIgnoreOldGrowthBelowPercentage,10, EXPERIMENTAL, \\\n+          \"(Generational mode only) If the total usage of the old \"         \\\n+          \"generation is smaller than this percent, we do not trigger \"     \\\n+          \"old gen collections even if old has grown, except when \"         \\\n+          \"ShenandoahGenerationalDoNotIgnoreGrowthAfterYoungCycles \"        \\\n+          \"consecutive cycles have been completed following the \"           \\\n+          \"preceding old-gen collection.\")                                  \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(uintx, ShenandoahDoNotIgnoreGrowthAfterYoungCycles,               \\\n+          50, EXPERIMENTAL,                                                 \\\n+          \"(Generational mode only) Even if the usage of old generation \"   \\\n+          \"is below ShenandoahIgnoreOldGrowthBelowPercentage, \"             \\\n+          \"trigger an old-generation mark if old has grown and this \"       \\\n+          \"many consecutive young-gen collections have been \"               \\\n+          \"completed following the preceding old-gen collection.\")          \\\n+                                                                            \\\n+  product(bool, ShenandoahGenerationalCensusAtEvac, false, EXPERIMENTAL,    \\\n+          \"(Generational mode only) Object age census at evacuation, \"      \\\n+          \"rather than during marking.\")                                    \\\n+                                                                            \\\n+  product(bool, ShenandoahGenerationalAdaptiveTenuring, true, EXPERIMENTAL, \\\n+          \"(Generational mode only) Dynamically adapt tenuring age.\")       \\\n+                                                                            \\\n+  product(bool, ShenandoahGenerationalCensusIgnoreOlderCohorts, true,       \\\n+                                                               EXPERIMENTAL,\\\n+          \"(Generational mode only) Ignore mortality rates older than the \" \\\n+          \"oldest cohort under the tenuring age for the last cycle.\" )      \\\n+                                                                            \\\n+  product(uintx, ShenandoahGenerationalMinTenuringAge, 1, EXPERIMENTAL,     \\\n+          \"(Generational mode only) Floor for adaptive tenuring age. \"      \\\n+          \"Setting floor and ceiling to the same value fixes the tenuring \" \\\n+          \"age; setting both to 1 simulates a poor approximation to \"       \\\n+          \"AlwaysTenure, and setting both to 16 simulates NeverTenure.\")    \\\n+          range(1,16)                                                       \\\n+                                                                            \\\n+  product(uintx, ShenandoahGenerationalMaxTenuringAge, 15, EXPERIMENTAL,    \\\n+          \"(Generational mode only) Ceiling for adaptive tenuring age. \"    \\\n+          \"Setting floor and ceiling to the same value fixes the tenuring \" \\\n+          \"age; setting both to 1 simulates a poor approximation to \"       \\\n+          \"AlwaysTenure, and setting both to 16 simulates NeverTenure.\")    \\\n+          range(1,16)                                                       \\\n+                                                                            \\\n+  product(double, ShenandoahGenerationalTenuringMortalityRateThreshold,     \\\n+                                                         0.1, EXPERIMENTAL, \\\n+          \"(Generational mode only) Cohort mortality rates below this \"     \\\n+          \"value will be treated as indicative of longevity, leading to \"   \\\n+          \"tenuring. A lower value delays tenuring, a higher value hastens \"\\\n+          \"it. Used only when ShenandoahGenerationalhenAdaptiveTenuring is \"\\\n+          \"enabled.\")                                                       \\\n+          range(0.001,0.999)                                                \\\n+                                                                            \\\n+  product(size_t, ShenandoahGenerationalTenuringCohortPopulationThreshold,  \\\n+                                                         4*K, EXPERIMENTAL, \\\n+          \"(Generational mode only) Cohorts whose population is lower than \"\\\n+          \"this value in the previous census are ignored wrt tenuring \"     \\\n+          \"decisions. Effectively this makes then tenurable as soon as all \"\\\n+          \"older cohorts are. Set this value to the largest cohort \"        \\\n+          \"population volume that you are comfortable ignoring when making \"\\\n+          \"tenuring decisions.\")                                            \\\n+                                                                            \\\n@@ -56,2 +137,2 @@\n-          \" iu - incremental-update concurrent GC (three pass mark-evac-update);\"  \\\n-          \" passive - stop the world GC only (either degenerated or full)\") \\\n+          \" passive - stop the world GC only (either degenerated or full);\" \\\n+          \" generational - generational concurrent GC\")                     \\\n@@ -71,0 +152,10 @@\n+  product(uintx, ShenandoahExpeditePromotionsThreshold, 5, EXPERIMENTAL,    \\\n+          \"When Shenandoah expects to promote at least this percentage \"    \\\n+          \"of the young generation, trigger a young collection to \"         \\\n+          \"expedite these promotions.\")                                     \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(uintx, ShenandoahExpediteMixedThreshold, 10, EXPERIMENTAL,        \\\n+          \"When there are this many old regions waiting to be collected, \"  \\\n+          \"trigger a mixed collection immediately.\")                        \\\n+                                                                            \\\n@@ -79,0 +170,14 @@\n+  product(uintx, ShenandoahOldGarbageThreshold, 15, EXPERIMENTAL,           \\\n+          \"How much garbage an old region has to contain before it would \"  \\\n+          \"be taken for collection.\")                                       \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(uintx, ShenandoahIgnoreGarbageThreshold, 5, EXPERIMENTAL,         \\\n+          \"When less than this amount of garbage (as a percentage of \"      \\\n+          \"region size) exists within a region, the region will not be \"    \\\n+          \"added to the collection set, even when the heuristic has \"       \\\n+          \"chosen to aggressively add regions with less than \"              \\\n+          \"ShenandoahGarbageThreshold amount of garbage into the \"          \\\n+          \"collection set.\")                                                \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n@@ -80,4 +185,6 @@\n-          \"How much heap should be free before some heuristics trigger the \"\\\n-          \"initial (learning) cycles. Affects cycle frequency on startup \"  \\\n-          \"and after drastic state changes, e.g. after degenerated\/full \"   \\\n-          \"GC cycles. In percents of (soft) max heap size.\")                \\\n+          \"When less than this amount of memory is free within the \"        \\\n+          \"heap or generation, trigger a learning cycle if we are \"         \\\n+          \"in learning mode.  Learning mode happens during initialization \" \\\n+          \"and following a drastic state change, such as following a \"      \\\n+          \"degenerated or Full GC cycle.  In percents of soft max \"         \\\n+          \"heap size.\")                                                     \\\n@@ -87,3 +194,5 @@\n-          \"How much heap should be free before most heuristics trigger the \"\\\n-          \"collection, even without other triggers. Provides the safety \"   \\\n-          \"margin for many heuristics. In percents of (soft) max heap size.\")\\\n+          \"Percentage of free heap memory (or young generation, in \"        \\\n+          \"generational mode) below which most heuristics trigger \"         \\\n+          \"collection independent of other triggers. Provides a safety \"    \\\n+          \"margin for many heuristics. In percents of (soft) max heap \"     \\\n+          \"size.\")                                                          \\\n@@ -152,0 +261,10 @@\n+  product(uintx, ShenandoahGuaranteedOldGCInterval, 10*60*1000, EXPERIMENTAL, \\\n+          \"Run a collection of the old generation at least this often. \"    \\\n+          \"Heuristics may trigger collections more frequently. Time is in \" \\\n+          \"milliseconds. Setting this to 0 disables the feature.\")          \\\n+                                                                            \\\n+  product(uintx, ShenandoahGuaranteedYoungGCInterval, 5*60*1000,  EXPERIMENTAL,  \\\n+          \"Run a collection of the young generation at least this often. \"  \\\n+          \"Heuristics may trigger collections more frequently. Time is in \" \\\n+          \"milliseconds. Setting this to 0 disables the feature.\")          \\\n+                                                                            \\\n@@ -211,4 +330,12 @@\n-          \"How much of heap to reserve for evacuations. Larger values make \"\\\n-          \"GC evacuate more live objects on every cycle, while leaving \"    \\\n-          \"less headroom for application to allocate in. In percents of \"   \\\n-          \"total heap size.\")                                               \\\n+          \"How much of (young-generation) heap to reserve for \"             \\\n+          \"(young-generation) evacuations.  Larger values allow GC to \"     \\\n+          \"evacuate more live objects on every cycle, while leaving \"       \\\n+          \"less headroom for application to allocate while GC is \"          \\\n+          \"evacuating and updating references. This parameter is \"          \\\n+          \"consulted at the end of marking, before selecting the \"          \\\n+          \"collection set.  If available memory at this time is smaller \"   \\\n+          \"than the indicated reserve, the bound on collection set size is \"\\\n+          \"adjusted downward.  The size of a generational mixed \"           \\\n+          \"evacuation collection set (comprised of both young and old \"     \\\n+          \"regions) is also bounded by this parameter.  In percents of \"    \\\n+          \"total (young-generation) heap size.\")                            \\\n@@ -221,1 +348,18 @@\n-          \"GC cycle.\")                                                      \\\n+          \"GC cycle.  Smaller values increase the risk of evacuation \"      \\\n+          \"failures, which will trigger stop-the-world Full GC passes.\")    \\\n+          range(1.0,100.0)                                                  \\\n+                                                                            \\\n+  product(double, ShenandoahOldEvacWaste, 1.4, EXPERIMENTAL,                \\\n+          \"How much waste evacuations produce within the reserved space. \"  \\\n+          \"Larger values make evacuations more resilient against \"          \\\n+          \"evacuation conflicts, at expense of evacuating less on each \"    \\\n+          \"GC cycle.  Smaller values increase the risk of evacuation \"      \\\n+          \"failures, which will trigger stop-the-world Full GC passes.\")    \\\n+          range(1.0,100.0)                                                  \\\n+                                                                            \\\n+  product(double, ShenandoahPromoEvacWaste, 1.2, EXPERIMENTAL,              \\\n+          \"How much waste promotions produce within the reserved space. \"   \\\n+          \"Larger values make evacuations more resilient against \"          \\\n+          \"evacuation conflicts, at expense of promoting less on each \"     \\\n+          \"GC cycle.  Smaller values increase the risk of evacuation \"      \\\n+          \"failures, which will trigger stop-the-world Full GC passes.\")    \\\n@@ -230,0 +374,35 @@\n+  product(uintx, ShenandoahOldEvacRatioPercent, 75, EXPERIMENTAL,           \\\n+          \"The maximum proportion of evacuation from old-gen memory, \"      \\\n+          \"expressed as a percentage. The default value 75 denotes that no\" \\\n+          \"more than 75% of the collection set evacuation workload may be \" \\\n+          \"towards evacuation of old-gen heap regions. This limits both the\"\\\n+          \"promotion of aged regions and the compaction of existing old \"   \\\n+          \"regions.  A value of 75 denotes that the total evacuation work\"  \\\n+          \"may increase to up to four times the young gen evacuation work.\" \\\n+          \"A larger value allows quicker promotion and allows\"              \\\n+          \"a smaller number of mixed evacuations to process \"               \\\n+          \"the entire list of old-gen collection candidates at the cost \"   \\\n+          \"of an increased disruption of the normal cadence of young-gen \"  \\\n+          \"collections.  A value of 100 allows a mixed evacuation to \"      \\\n+          \"focus entirely on old-gen memory, allowing no young-gen \"        \\\n+          \"regions to be collected, likely resulting in subsequent \"        \\\n+          \"allocation failures because the allocation pool is not \"         \\\n+          \"replenished.  A value of 0 allows a mixed evacuation to\"         \\\n+          \"focus entirely on young-gen memory, allowing no old-gen \"        \\\n+          \"regions to be collected, likely resulting in subsequent \"        \\\n+          \"promotion failures and triggering of stop-the-world full GC \"    \\\n+          \"events.\")                                                        \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(uintx, ShenandoahMinYoungPercentage, 20, EXPERIMENTAL,            \\\n+          \"The minimum percentage of the heap to use for the young \"        \\\n+          \"generation. Heuristics will not adjust the young generation \"    \\\n+          \"to be less than this.\")                                          \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uintx, ShenandoahMaxYoungPercentage, 100, EXPERIMENTAL,           \\\n+          \"The maximum percentage of the heap to use for the young \"        \\\n+          \"generation. Heuristics will not adjust the young generation \"    \\\n+          \"to be more than this.\")                                          \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n@@ -304,0 +483,9 @@\n+  product(uintx, ShenandoahCoalesceChance, 0, DIAGNOSTIC,                   \\\n+          \"Testing: Abandon remaining mixed collections with this \"         \\\n+          \"likelihood. Following each mixed collection, abandon all \"       \\\n+          \"remaining mixed collection candidate regions with likelihood \"   \\\n+          \"ShenandoahCoalesceChance. Abandoning a mixed collection will \"   \\\n+          \"cause the old regions to be made parsable, rather than being \"   \\\n+          \"evacuated.\")                                                     \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n@@ -330,0 +518,4 @@\n+  product(bool, ShenandoahCardBarrier, false, DIAGNOSTIC,                   \\\n+          \"Turn on\/off card-marking post-write barrier in Shenandoah: \"     \\\n+          \" true when ShenandoahGCMode is generational, false otherwise\")   \\\n+                                                                            \\\n@@ -345,2 +537,29 @@\n-\n-\/\/ end of GC_SHENANDOAH_FLAGS\n+  product(uintx, ShenandoahOldCompactionReserve, 8, EXPERIMENTAL,           \\\n+          \"During generational GC, prevent promotions from filling \"        \\\n+          \"this number of heap regions.  These regions are reserved \"       \\\n+          \"for the purpose of supporting compaction of old-gen \"            \\\n+          \"memory.  Otherwise, old-gen memory cannot be compacted.\")        \\\n+          range(0, 128)                                                     \\\n+                                                                            \\\n+  product(bool, ShenandoahAllowOldMarkingPreemption, true, DIAGNOSTIC,      \\\n+          \"Allow young generation collections to suspend concurrent\"        \\\n+          \" marking in the old generation.\")                                \\\n+                                                                            \\\n+  product(uintx, ShenandoahAgingCyclePeriod, 1, EXPERIMENTAL,               \\\n+          \"With generational mode, increment the age of objects and\"        \\\n+          \"regions each time this many young-gen GC cycles are completed.\") \\\n+                                                                            \\\n+  develop(bool, ShenandoahEnableCardStats, false,                           \\\n+          \"Enable statistics collection related to clean & dirty cards\")    \\\n+                                                                            \\\n+  develop(int, ShenandoahCardStatsLogInterval, 50,                          \\\n+          \"Log cumulative card stats every so many remembered set or \"      \\\n+          \"update refs scans\")                                              \\\n+                                                                            \\\n+  product(uintx, ShenandoahMinimumOldTimeMs, 100, EXPERIMENTAL,             \\\n+         \"Minimum amount of time in milliseconds to run old collections \"   \\\n+         \"before a young collection is allowed to run. This is intended \"   \\\n+         \"to prevent starvation of the old collector. Setting this to \"     \\\n+         \"0 will allow back to back young collections to run during old \"   \\\n+         \"collections.\")                                                    \\\n+  \/\/ end of GC_SHENANDOAH_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":235,"deletions":16,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -35,1 +37,1 @@\n-  volatile_nonstatic_field(ShenandoahHeap, _used,                  size_t)                            \\\n+  nonstatic_field(ShenandoahHeap, _global_generation,              ShenandoahGeneration*)             \\\n@@ -37,0 +39,1 @@\n+  volatile_nonstatic_field(ShenandoahGeneration, _used,            size_t)                            \\\n@@ -61,0 +64,1 @@\n+  declare_type(ShenandoahGenerationalHeap, ShenandoahHeap)                    \\\n@@ -65,0 +69,2 @@\n+  declare_toplevel_type(ShenandoahGeneration)                                 \\\n+  declare_toplevel_type(ShenandoahGeneration*)                                \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/vmStructs_shenandoah.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include <limits>\n+\n@@ -456,1 +458,1 @@\n-  const size_t old_garbage = old_used - old_live;\n+  const double old_garbage = double(old_used - old_live);\n@@ -461,1 +463,1 @@\n-  const size_t reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n@@ -464,2 +466,8 @@\n-  const double current_young_gc_time_per_bytes_freed = double(young_gc_time) \/ double(reclaimed_per_young_gc);\n-  const double potential_young_gc_time_per_bytes_freed = double(young_gc_time) \/ double(reclaimed_per_young_gc + old_garbage);\n+  const double current_young_gc_time_per_bytes_freed = young_gc_time \/ reclaimed_per_young_gc;\n+  const double potential_young_gc_time_per_bytes_freed = young_gc_time \/ (reclaimed_per_young_gc + old_garbage);\n+\n+  if (current_young_gc_time_per_bytes_freed == std::numeric_limits<double>::infinity()) {\n+    \/\/ Young collection's are not reclaiming any memory. Return infinity as a signal\n+    \/\/ to trigger an old collection, regardless of the amount of old garbage.\n+    return std::numeric_limits<double>::infinity();\n+  }\n@@ -486,2 +494,2 @@\n-  const size_t reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n-  const size_t reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n@@ -490,3 +498,2 @@\n-  const double current_young_gc_time_per_bytes_freed = double(young_gc_time) \/ double(reclaimed_per_young_gc);\n-  const double current_old_gc_time_per_bytes_freed = reclaimed_per_old_gc == 0 ? std::numeric_limits<double>::infinity()\n-                                                                               : (double(old_gc_time) \/ double(reclaimed_per_old_gc));\n+  const double current_young_gc_time_per_bytes_freed = young_gc_time \/ reclaimed_per_young_gc;\n+  const double current_old_gc_time_per_bytes_freed = old_gc_time \/ reclaimed_per_old_gc;\n@@ -534,4 +541,4 @@\n-  const size_t reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n-  const size_t reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n-  const double current_young_bytes_freed_per_gc_time = double(reclaimed_per_young_gc) \/ double(young_gc_time);\n-  const double current_old_bytes_freed_per_gc_time = double(reclaimed_per_old_gc) \/ double(old_gc_time);\n+  const double reclaimed_per_young_gc = stats._young_stats._stat_heap._reclaimed_avg;\n+  const double reclaimed_per_old_gc = stats._old_stats._stat_heap._reclaimed_avg;\n+  const double current_young_bytes_freed_per_gc_time = reclaimed_per_young_gc \/ young_gc_time;\n+  const double current_old_bytes_freed_per_gc_time = reclaimed_per_old_gc \/ old_gc_time;\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+#include <limits>\n+\n@@ -1852,2 +1854,3 @@\n-size_t ZStatHeap::reclaimed_avg() {\n-  return (size_t)_reclaimed_bytes.davg();\n+double ZStatHeap::reclaimed_avg() {\n+  \/\/ Make sure the reclaimed average is greater than 0.0 to avoid division by zero.\n+  return _reclaimed_bytes.davg() + std::numeric_limits<double>::denorm_min();\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -591,1 +591,1 @@\n-  size_t _reclaimed_avg;\n+  double _reclaimed_avg;\n@@ -702,1 +702,1 @@\n-  size_t reclaimed_avg();\n+  double reclaimed_avg();\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1150,7 +1150,0 @@\n-#define JNI_ONLOAD_SYMBOLS   {\"JNI_OnLoad\"}\n-#define JNI_ONUNLOAD_SYMBOLS {\"JNI_OnUnload\"}\n-#define JVM_ONLOAD_SYMBOLS      {\"JVM_OnLoad\"}\n-#define AGENT_ONLOAD_SYMBOLS    {\"Agent_OnLoad\"}\n-#define AGENT_ONUNLOAD_SYMBOLS  {\"Agent_OnUnload\"}\n-#define AGENT_ONATTACH_SYMBOLS  {\"Agent_OnAttach\"}\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2016,1 +2016,3 @@\n-                oopDesc::set_klass_gap(result, 0);\n+                if (oopDesc::has_klass_gap()) {\n+                  oopDesc::set_klass_gap(result, 0);\n+                }\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,4 +62,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -87,4 +83,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -112,4 +104,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -137,4 +125,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -162,4 +146,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -187,4 +167,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -228,4 +204,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1211,0 +1211,17 @@\n+  <Event name=\"ShenandoahEvacuationInformation\" category=\"Java Virtual Machine, GC, Detailed\" label=\"Shenandoah Evacuation Information\" startTime=\"false\">\n+    <Field type=\"uint\" name=\"gcId\" label=\"GC Identifier\" relation=\"GcId\" \/>\n+    <Field type=\"ulong\" name=\"cSetRegions\" label=\"Collection Set Regions\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"cSetUsedBefore\" label=\"Collection Set Before\" description=\"Memory usage before GC in the collection set regions\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"cSetUsedAfter\" label=\"Collection Set After\" description=\"Memory usage after GC in the collection set regions\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"collectedOld\" label=\"Collected Old\" description=\"Memory collected from old generation\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"collectedPromoted\" label=\"Collected Promoted\" description=\"Memory collected from generation promotion\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"collectedYoung\" label=\"Collection Young\" description=\"Memory collected from young generation\" \/>\n+    <Field type=\"ulong\" name=\"regionsPromotedHumongous\" label=\"Regions Promoted Humongous\" \/>\n+    <Field type=\"ulong\" name=\"regionsPromotedRegular\" label=\"Regions Promoted Regular\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"regularPromotedGarbage\" label=\"Regular Promoted Garbage\" description=\"Garbage memory of in place promoted regular regions\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"regularPromotedFree\" label=\"Regular Promoted Free\" description=\"Free memory of in place promoted regular regions\" \/>\n+    <Field type=\"ulong\" name=\"regionsFreed\" label=\"Regions Freed\" description=\"Free regions prior to determining collection set\" \/>\n+    <Field type=\"ulong\" name=\"regionsImmediate\" label=\"Regions Immediate\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"immediateBytes\" label=\"Immediate Bytes\" \/>\n+  <\/Event>\n+  \n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3226,0 +3226,4 @@\n+C2V_VMENTRY_0(jint, getCompilationActivityMode, (JNIEnv* env, jobject))\n+  return CompileBroker::get_compilation_activity_mode();\n+}\n+\n@@ -3388,0 +3392,1 @@\n+  {CC \"getCompilationActivityMode\",                   CC \"()I\",                                                                             FN_PTR(getCompilationActivityMode)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-    ALLOW_C_FUNCTION(::free((void*) _init_error_msg));\n+    ALLOW_C_FUNCTION(::free, ::free((void*) _init_error_msg);)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  nonstatic_field(JavaThread,                  _lock_id,                                      int64_t)                               \\\n+  nonstatic_field(JavaThread,                  _monitor_owner_id,                             int64_t)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,5 +61,0 @@\n-\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"control\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/logging\/logDiagnosticCommand.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  ReservedSpace seg_rs(reserved_segments_size);\n+  ReservedSpace seg_rs(reserved_segments_size, mtCode);\n@@ -235,2 +235,0 @@\n-  MemTracker::record_virtual_memory_tag((address)_segmap.low_boundary(), mtCode);\n-\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,5 +55,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceDCmd.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-ReservedSpace::ReservedSpace(size_t size) : _fd_for_heap(-1) {\n+ReservedSpace::ReservedSpace(size_t size, MemTag mem_tag) : _fd_for_heap(-1) {\n@@ -54,1 +54,1 @@\n-  initialize(size, alignment, page_size, nullptr, false);\n+  initialize(size, alignment, page_size, nullptr, false, mem_tag);\n@@ -61,1 +61,1 @@\n-  size_t alignment = os::vm_allocation_granularity();;\n+  size_t alignment = os::vm_allocation_granularity();\n@@ -84,1 +84,1 @@\n-static char* attempt_map_or_reserve_memory_at(char* base, size_t size, int fd, bool executable) {\n+static char* attempt_map_or_reserve_memory_at(char* base, size_t size, int fd, bool executable, MemTag mem_tag) {\n@@ -88,1 +88,1 @@\n-  return os::attempt_reserve_memory_at(base, size, executable);\n+  return os::attempt_reserve_memory_at(base, size, executable, mem_tag);\n@@ -92,1 +92,1 @@\n-static char* map_or_reserve_memory(size_t size, int fd, bool executable) {\n+static char* map_or_reserve_memory(size_t size, int fd, bool executable, MemTag mem_tag) {\n@@ -96,1 +96,1 @@\n-  return os::reserve_memory(size, executable);\n+  return os::reserve_memory(size, executable, mem_tag);\n@@ -157,1 +157,1 @@\n-                            const size_t alignment, int fd, bool exec) {\n+                            const size_t alignment, int fd, bool exec, MemTag mem_tag) {\n@@ -166,1 +166,1 @@\n-    base = attempt_map_or_reserve_memory_at(requested_address, size, fd, exec);\n+    base = attempt_map_or_reserve_memory_at(requested_address, size, fd, exec, mem_tag);\n@@ -171,1 +171,1 @@\n-    base = map_or_reserve_memory(size, fd, exec);\n+    base = map_or_reserve_memory(size, fd, exec, mem_tag);\n@@ -223,1 +223,2 @@\n-                            bool executable) {\n+                            bool executable,\n+                            MemTag mem_tag) {\n@@ -238,1 +239,1 @@\n-    char* base = reserve_memory(requested_address, size, alignment, _fd_for_heap, executable);\n+    char* base = reserve_memory(requested_address, size, alignment, _fd_for_heap, executable, mem_tag);\n@@ -269,1 +270,1 @@\n-  char* base = reserve_memory(requested_address, size, alignment, -1, executable);\n+  char* base = reserve_memory(requested_address, size, alignment, -1, executable, mem_tag);\n@@ -280,1 +281,2 @@\n-                               bool executable) {\n+                               bool executable,\n+                               MemTag mem_tag) {\n@@ -301,1 +303,1 @@\n-  reserve(size, alignment, page_size, requested_address, executable);\n+  reserve(size, alignment, page_size, requested_address, executable, mem_tag);\n@@ -427,1 +429,1 @@\n-  reserve(size, alignment, page_size, requested_address, false);\n+  reserve(size, alignment, page_size, requested_address, false, mtJavaHeap);\n@@ -613,1 +615,1 @@\n-      initialize(size + noaccess_prefix, alignment, page_size, nullptr, false);\n+      initialize(size + noaccess_prefix, alignment, page_size, nullptr, false, mtJavaHeap);\n@@ -656,1 +658,1 @@\n-    initialize(size, alignment, page_size, nullptr, false);\n+    initialize(size, alignment, page_size, nullptr, false, mtJavaHeap);\n@@ -664,4 +666,0 @@\n-  if (base() != nullptr) {\n-    MemTracker::record_virtual_memory_tag((address)base(), mtJavaHeap);\n-  }\n-\n@@ -682,2 +680,1 @@\n-  initialize(r_size, rs_align, rs_page_size, \/*requested address*\/ nullptr, \/*executable*\/ true);\n-  MemTracker::record_virtual_memory_tag((address)base(), mtCode);\n+  initialize(r_size, rs_align, rs_page_size, \/*requested address*\/ nullptr, \/*executable*\/ true, mtCode);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -64,1 +65,1 @@\n-                  char* requested_address, bool executable);\n+                  char* requested_address, bool executable, MemTag mem_tag = mtNone);\n@@ -67,1 +68,1 @@\n-               char* requested_address, bool executable);\n+               char* requested_address, bool executable, MemTag mem_tag);\n@@ -73,1 +74,1 @@\n-  explicit ReservedSpace(size_t size);\n+  ReservedSpace(size_t size, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,5 +56,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/nmt\/nmtDCmd.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -237,0 +237,4 @@\n+  int size() {\n+    return _node_count;\n+  }\n+\n@@ -307,0 +311,32 @@\n+  TreapNode* closest_gt(const K& key) {\n+    TreapNode* candidate = nullptr;\n+    TreapNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else if (cmp_r <= 0) {\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  struct Range {\n+    TreapNode* start;\n+    TreapNode* end;\n+    Range(TreapNode* start, TreapNode* end)\n+    : start(start), end(end) {}\n+  };\n+\n+  \/\/ Return the range [start, end)\n+  \/\/ where start->key() <= addr < end->key().\n+  \/\/ Failure to find the range leads to start and\/or end being null.\n+  Range find_enclosing_range(K addr) {\n+    TreapNode* start = closest_leq(addr);\n+    TreapNode* end = closest_gt(addr);\n+    return Range(start, end);\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -85,1 +86,1 @@\n-    stB.out = leqA_n->val().out;\n+    stB.out = out_state(leqA_n);\n@@ -90,1 +91,1 @@\n-      stA.in = leqA_n->val().in;\n+      stA.in = in_state(leqA_n);\n@@ -116,1 +117,1 @@\n-      stA.in = leqA_n->val().out; \/\/ .. and the region's prior state is the incoming state\n+      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n@@ -137,1 +138,1 @@\n-    stB.out = head->val().out;\n+    stB.out = out_state(head);\n@@ -218,0 +219,96 @@\n+\n+#ifdef ASSERT\n+void VMATree::print_on(outputStream* out) {\n+  visit_in_order([&](TreapNode* current) {\n+    out->print(SIZE_FORMAT \" (%s) - %s - \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+               statetype_to_string(out_state(current).type()));\n+  });\n+  out->cr();\n+}\n+#endif\n+\n+VMATree::SummaryDiff VMATree::set_tag(const position start, const size size, const MemTag tag) {\n+  auto pos = [](TreapNode* n) { return n->key(); };\n+  position from = start;\n+  position end  = from+size;\n+  size_t remsize = size;\n+  VMATreap::Range range(nullptr, nullptr);\n+\n+  \/\/ Find the next range to adjust and set range, remsize and from\n+  \/\/ appropriately. If it returns false, there is no valid next range.\n+  auto find_next_range = [&]() -> bool {\n+    range = _tree.find_enclosing_range(from);\n+    if ((range.start == nullptr && range.end == nullptr) ||\n+        (range.start != nullptr && range.end == nullptr)) {\n+      \/\/ There is no range containing the starting address\n+      assert(range.start->val().out.type() == StateType::Released, \"must be\");\n+      return false;\n+    } else if (range.start == nullptr && range.end != nullptr) {\n+      position found_end = pos(range.end);\n+      if (found_end >= end) {\n+        \/\/ The found address is outside of our range, we can end now.\n+        return false;\n+      }\n+      \/\/ There is at least one range [found_end, ?) which starts within [start, end)\n+      \/\/ Use this as the range instead.\n+      range = _tree.find_enclosing_range(found_end);\n+      remsize = end - found_end;\n+      from = found_end;\n+    }\n+    return true;\n+  };\n+\n+  bool success = find_next_range();\n+  if (!success) return SummaryDiff();\n+  assert(range.start != nullptr && range.end != nullptr, \"must be\");\n+\n+  end = MIN2(from + remsize, pos(range.end));\n+  IntervalState& out = out_state(range.start);\n+  StateType type = out.type();\n+\n+  SummaryDiff diff;\n+  \/\/ Ignore any released ranges, these must be mtNone and have no stack\n+  if (type != StateType::Released) {\n+    RegionData new_data = RegionData(out.stack(), tag);\n+    SummaryDiff result = register_mapping(from, end, type, new_data);\n+    diff.add(result);\n+  }\n+\n+  remsize = remsize - (end - from);\n+  from = end;\n+\n+  \/\/ If end < from + sz then there are multiple ranges for which to set the flag.\n+  while (end < from + remsize) {\n+    \/\/ Using register_mapping may invalidate the already found range, so we must\n+    \/\/ use find_next_range repeatedly\n+    bool success = find_next_range();\n+    if (!success) return diff;\n+    assert(range.start != nullptr && range.end != nullptr, \"must be\");\n+\n+    end = MIN2(from + remsize, pos(range.end));\n+    IntervalState& out = out_state(range.start);\n+    StateType type = out.type();\n+\n+    if (type != StateType::Released) {\n+      RegionData new_data = RegionData(out.stack(), tag);\n+      SummaryDiff result = register_mapping(from, end, type, new_data);\n+      diff.add(result);\n+    }\n+    remsize = remsize - (end - from);\n+    from = end;\n+  }\n+\n+  return diff;\n+}\n+\n+#ifdef ASSERT\n+void VMATree::SummaryDiff::print_on(outputStream* out) {\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    if (tag[i].reserve == 0 && tag[i].commit == 0) {\n+      continue;\n+    }\n+    out->print_cr(\"Tag %s R: \" INT64_FORMAT \" C: \" INT64_FORMAT, NMTUtil::tag_to_enum_name((MemTag)i), tag[i].reserve,\n+                  tag[i].commit);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":101,"deletions":4,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -45,0 +46,1 @@\n+  using size = size_t;\n@@ -143,0 +145,8 @@\n+  static IntervalState& in_state(TreapNode* node) {\n+    return node->val().in;\n+  }\n+\n+  static IntervalState& out_state(TreapNode* node) {\n+    return node->val().out;\n+  }\n+\n@@ -165,0 +175,1 @@\n+\n@@ -172,0 +183,11 @@\n+\n+    void add(SummaryDiff& other) {\n+      for (int i = 0; i < mt_number_of_tags; i++) {\n+        tag[i].reserve += other.tag[i].reserve;\n+        tag[i].commit += other.tag[i].commit;\n+      }\n+    }\n+\n+#ifdef ASSERT\n+    void print_on(outputStream* out);\n+#endif\n@@ -178,2 +200,6 @@\n-  SummaryDiff reserve_mapping(position from, position sz, const RegionData& metadata) {\n-    return register_mapping(from, from + sz, StateType::Reserved, metadata, false);\n+  SummaryDiff reserve_mapping(position from, size size, const RegionData& metadata) {\n+    return register_mapping(from, from + size, StateType::Reserved, metadata, false);\n+  }\n+\n+  SummaryDiff commit_mapping(position from, size size, const RegionData& metadata, bool use_tag_inplace = false) {\n+    return register_mapping(from, from + size, StateType::Committed, metadata, use_tag_inplace);\n@@ -182,2 +208,8 @@\n-  SummaryDiff commit_mapping(position from, position sz, const RegionData& metadata, bool use_tag_inplace = false) {\n-    return register_mapping(from, from + sz, StateType::Committed, metadata, use_tag_inplace);\n+  \/\/ Given an interval and a tag, find all reserved and committed ranges at least\n+  \/\/ partially contained within that interval and set their tag to the one provided.\n+  \/\/ This may cause merging and splitting of ranges.\n+  \/\/ Released regions are ignored.\n+  SummaryDiff set_tag(position from, size size, MemTag tag);\n+\n+  SummaryDiff uncommit_mapping(position from, size size, const RegionData& metadata) {\n+    return register_mapping(from, from + size, StateType::Reserved, metadata, true);\n@@ -186,2 +218,2 @@\n-  SummaryDiff uncommit_mapping(position from, position sz, const RegionData& metadata) {\n-    return register_mapping(from, from + sz, StateType::Reserved, metadata, true);\n+  SummaryDiff release_mapping(position from, size size) {\n+    return register_mapping(from, from + size, StateType::Released, VMATree::empty_regiondata);\n@@ -190,2 +222,2 @@\n-  SummaryDiff release_mapping(position from, position sz) {\n-    return register_mapping(from, from + sz, StateType::Released, VMATree::empty_regiondata);\n+  VMATreap& tree() {\n+    return _tree;\n@@ -199,0 +231,5 @@\n+\n+#ifdef ASSERT\n+  void print_on(outputStream* out);\n+#endif\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -64,0 +65,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -406,8 +408,20 @@\n-  objArrayOop rr = resolved_references();\n-  if (rr != nullptr) {\n-    int rr_len = rr->length();\n-    for (int i = 0; i < rr_len; i++) {\n-      oop p = rr->obj_at(i);\n-      if (java_lang_String::is_instance(p) &&\n-          !ArchiveHeapWriter::is_string_too_large_to_archive(p)) {\n-        HeapShared::add_to_dumped_interned_strings(p);\n+  InstanceKlass* ik = pool_holder();\n+  if (!ik->is_linked()) {\n+    \/\/ resolved_references() doesn't exist yet, so we have no resolved CONSTANT_String entries. However,\n+    \/\/ some static final fields may have default values that were initialized when the class was parsed.\n+    \/\/ We need to enter those into the CDS archive strings table.\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() == T_OBJECT) {\n+          int offset = fd.offset();\n+          check_and_add_dumped_interned_string(ik->java_mirror()->obj_field(offset));\n+        }\n+      }\n+    }\n+  } else {\n+    objArrayOop rr = resolved_references();\n+    if (rr != nullptr) {\n+      int rr_len = rr->length();\n+      for (int i = 0; i < rr_len; i++) {\n+        check_and_add_dumped_interned_string(rr->obj_at(i));\n@@ -418,0 +432,8 @@\n+\n+void ConstantPool::check_and_add_dumped_interned_string(oop obj) {\n+  if (obj != nullptr && java_lang_String::is_instance(obj) &&\n+      !ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n+    HeapShared::add_to_dumped_interned_strings(obj);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -165,0 +165,1 @@\n+  static void check_and_add_dumped_interned_string(oop obj);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -959,1 +959,0 @@\n-          \/\/ IA64     1     1     1          1    1         50          41\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -227,4 +227,0 @@\n-#if (defined(IA64) && !defined(AIX))\n-  Node* adr_last_Java_fp = basic_plus_adr(top(), thread, in_bytes(JavaThread::last_Java_fp_offset()));\n-  store_to_memory(control(), adr_last_Java_fp, null(), T_ADDRESS, MemNode::unordered);\n-#endif\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2216,1 +2216,1 @@\n-      st->print(\"Profiled_Loop \");\n+      st->print(\"Profiled Loop \");\n@@ -2219,1 +2219,1 @@\n-      st->print(\"Loop_Limit_Check \");\n+      st->print(\"Loop Limit Check \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3685,1 +3685,1 @@\n-  \/\/ Change the lock_id of the JavaThread\n+  \/\/ Change the _monitor_owner_id of the JavaThread\n@@ -3687,2 +3687,2 @@\n-  Node* thread_id_offset = basic_plus_adr(thread, in_bytes(JavaThread::lock_id_offset()));\n-  Node* tid_memory = store_to_memory(control(), thread_id_offset, tid, T_LONG, MemNode::unordered, true);\n+  Node* monitor_owner_id_offset = basic_plus_adr(thread, in_bytes(JavaThread::monitor_owner_id_offset()));\n+  store_to_memory(control(), monitor_owner_id_offset, tid, T_LONG, MemNode::unordered, true);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  \/\/ On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish\n+  \/\/ On platforms with weak memory ordering (e.g., PPC) we distinguish\n@@ -569,1 +569,1 @@\n-  \/\/ On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish\n+  \/\/ On platforms with weak memory ordering (e.g., PPC) we distinguish\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-  \/\/ and memory stacks (ie. IA64).\n+  \/\/ and memory stacks.\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2405,1 +2405,1 @@\n-    bad_address = os::reserve_memory(size);\n+    bad_address = os::reserve_memory(size, false, mtInternal);\n@@ -2409,1 +2409,0 @@\n-      MemTracker::record_virtual_memory_tag((void*)bad_address, mtInternal);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2981,2 +2981,2 @@\n-  \/\/ Set lock id of new current Thread\n-  thread->set_lock_id(java_lang_Thread::thread_id(threadObj));\n+  \/\/ Set _monitor_owner_id of new current Thread\n+  thread->set_monitor_owner_id(java_lang_Thread::thread_id(threadObj));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jvm.h\"\n@@ -271,1 +270,1 @@\n-static bool load_agent_from_executable(JvmtiAgent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+static bool load_agent_from_executable(JvmtiAgent* agent, const char* on_load_symbol) {\n@@ -273,2 +272,2 @@\n-  assert(on_load_symbols != nullptr, \"invariant\");\n-  return os::find_builtin_agent(agent, &on_load_symbols[0], num_symbol_entries);\n+  assert(on_load_symbol != nullptr, \"invariant\");\n+  return os::find_builtin_agent(agent, on_load_symbol);\n@@ -313,1 +312,1 @@\n-static void* load_library(JvmtiAgent* agent, const char* on_symbols[], size_t num_symbol_entries, bool vm_exit_on_error) {\n+static void* load_library(JvmtiAgent* agent, bool vm_exit_on_error) {\n@@ -324,2 +323,1 @@\n-\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n-static OnLoadEntry_t lookup_On_Load_entry_point(JvmtiAgent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+static OnLoadEntry_t lookup_On_Load_entry_point(JvmtiAgent* agent, const char* on_load_symbol) {\n@@ -328,2 +326,2 @@\n-    if (!load_agent_from_executable(agent, on_load_symbols, num_symbol_entries)) {\n-      void* const library = load_library(agent, on_load_symbols, num_symbol_entries, \/* vm exit on error *\/ true);\n+    if (!load_agent_from_executable(agent, on_load_symbol)) {\n+      void* const library = load_library(agent, \/* vm exit on error *\/ true);\n@@ -337,1 +335,1 @@\n-  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbols, num_symbol_entries));\n+  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbol));\n@@ -341,2 +339,1 @@\n-  const char* on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n-  return lookup_On_Load_entry_point(lib, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+  return lookup_On_Load_entry_point(lib, \"JVM_OnLoad\");\n@@ -346,2 +343,1 @@\n-  const char* on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n-  return lookup_On_Load_entry_point(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+  return lookup_On_Load_entry_point(agent, \"Agent_OnLoad\");\n@@ -502,2 +498,1 @@\n-  const char* on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n-  const size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n+  const char* on_attach_symbol = \"Agent_OnAttach\";\n@@ -506,1 +501,1 @@\n-  if (load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+  if (load_agent_from_executable(agent, on_attach_symbol)) {\n@@ -509,1 +504,1 @@\n-    library = load_library(agent, &on_attach_symbols[0], num_symbol_entries, \/* vm_exit_on_error *\/ false);\n+    library = load_library(agent, \/* vm_exit_on_error *\/ false);\n@@ -534,1 +529,1 @@\n-                                                   os::find_agent_function(agent, false, &on_attach_symbols[0], num_symbol_entries));\n+                                                   os::find_agent_function(agent, false, on_attach_symbol));\n@@ -537,1 +532,1 @@\n-    st->print_cr(\"%s is not available in %s\", on_attach_symbols[0], agent->name());\n+    st->print_cr(\"%s is not available in %s\", on_attach_symbol, agent->name());\n@@ -632,1 +627,1 @@\n-  const char* on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n+  const char* on_unload_symbol = \"Agent_OnUnload\";\n@@ -635,1 +630,1 @@\n-                                                 os::find_agent_function(this, false, &on_unload_symbols[0], ARRAY_SIZE(on_unload_symbols)));\n+                                                 os::find_agent_function(this, false, on_unload_symbol));\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -441,1 +441,2 @@\n-    return Universe::heap()->is_in(p);\n+    ShenandoahHeap* sh = ShenandoahHeap::heap();\n+    return sh->mode()->is_generational() ?  sh->is_in_old(p) : sh->is_in(p);\n@@ -713,6 +714,1 @@\n-  jlong addr = 0;\n-\n-  addr = (jlong)(uintptr_t)os::reserve_memory(size);\n-  MemTracker::record_virtual_memory_tag((address)addr, mtTest);\n-\n-  return addr;\n+  return (jlong)(uintptr_t)os::reserve_memory(size, false, mtTest);\n@@ -722,4 +718,1 @@\n-  addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((char*)(uintptr_t)addr, (size_t)size);\n-  MemTracker::record_virtual_memory_tag((address)addr, mtTest);\n-\n-  return addr;\n+  return (jlong)(uintptr_t)os::attempt_reserve_memory_at((char*)(uintptr_t)addr, (size_t)size, false, mtTest);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-                 IA64_ONLY(\"ia64\")               \\\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -325,1 +325,11 @@\n-  if  (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n+  return internal_module_property_helper(property, false);\n+}\n+\n+\/\/ Returns true if property is one of those recognized by is_internal_module_property() but\n+\/\/ is not supported by CDS archived full module graph.\n+bool Arguments::is_incompatible_cds_internal_module_property(const char* property) {\n+  return internal_module_property_helper(property, true);\n+}\n+\n+bool Arguments::internal_module_property_helper(const char* property, bool check_for_cds) {\n+  if (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n@@ -331,1 +341,0 @@\n-        matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||\n@@ -333,1 +342,0 @@\n-        matches_property_suffix(property_suffix, PATH, PATH_LEN) ||\n@@ -335,2 +343,1 @@\n-        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n-        matches_property_suffix(property_suffix, ENABLE_NATIVE_ACCESS, ENABLE_NATIVE_ACCESS_LEN)) {\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN)) {\n@@ -339,0 +346,9 @@\n+\n+    if (!check_for_cds) {\n+      \/\/ CDS notes: these properties are supported by CDS archived full module graph.\n+      if (matches_property_suffix(property_suffix, PATH, PATH_LEN) ||\n+          matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||\n+          matches_property_suffix(property_suffix, ENABLE_NATIVE_ACCESS, ENABLE_NATIVE_ACCESS_LEN)) {\n+        return true;\n+      }\n+    }\n@@ -343,9 +359,0 @@\n-bool Arguments::is_add_modules_property(const char* key) {\n-  return (strcmp(key, MODULE_PROPERTY_PREFIX ADDMODS) == 0);\n-}\n-\n-\/\/ Return true if the key matches the --module-path property name (\"jdk.module.path\").\n-bool Arguments::is_module_path_property(const char* key) {\n-  return (strcmp(key, MODULE_PROPERTY_PREFIX PATH) == 0);\n-}\n-\n@@ -1804,5 +1811,6 @@\n-unsigned int addreads_count = 0;\n-unsigned int addexports_count = 0;\n-unsigned int addopens_count = 0;\n-unsigned int patch_mod_count = 0;\n-unsigned int enable_native_access_count = 0;\n+static unsigned int addreads_count = 0;\n+static unsigned int addexports_count = 0;\n+static unsigned int addopens_count = 0;\n+static unsigned int patch_mod_count = 0;\n+static unsigned int enable_native_access_count = 0;\n+static bool patch_mod_javabase = false;\n@@ -1812,0 +1820,5 @@\n+  \/\/ This may modify compiler flags. Must be called before CompilerConfig::check_args_consistency()\n+  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n+    return false;\n+  }\n+\n@@ -1982,2 +1995,0 @@\n-  bool patch_mod_javabase = false;\n-\n@@ -1997,1 +2008,1 @@\n-  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlagOrigin::JIMAGE_RESOURCE);\n+  jint result = parse_each_vm_init_arg(vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE);\n@@ -2004,1 +2015,1 @@\n-  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2010,1 +2021,1 @@\n-  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlagOrigin::COMMAND_LINE);\n+  result = parse_each_vm_init_arg(cmd_line_args, JVMFlagOrigin::COMMAND_LINE);\n@@ -2017,1 +2028,1 @@\n-  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_options_args, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2038,1 +2049,1 @@\n-  result = finalize_vm_init_args(patch_mod_javabase);\n+  result = finalize_vm_init_args();\n@@ -2093,1 +2104,1 @@\n-int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {\n+int Arguments::process_patch_mod_option(const char* patch_mod_tail) {\n@@ -2109,1 +2120,1 @@\n-      add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);\n+      add_patch_mod_prefix(module_name, module_equal + 1);\n@@ -2240,1 +2251,1 @@\n-jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin) {\n+jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, JVMFlagOrigin origin) {\n@@ -2367,1 +2378,1 @@\n-      int res = process_patch_mod_option(tail, patch_mod_javabase);\n+      int res = process_patch_mod_option(tail);\n@@ -2916,1 +2927,1 @@\n-void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {\n+void Arguments::add_patch_mod_prefix(const char* module_name, const char* path) {\n@@ -2922,1 +2933,1 @@\n-    if (*patch_mod_javabase) {\n+    if (patch_mod_javabase) {\n@@ -2925,1 +2936,1 @@\n-      *patch_mod_javabase = true;\n+      patch_mod_javabase = true;\n@@ -2977,1 +2988,1 @@\n-jint Arguments::finalize_vm_init_args(bool patch_mod_javabase) {\n+jint Arguments::finalize_vm_init_args() {\n@@ -3058,3 +3069,0 @@\n-  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n-    return JNI_ERR;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":45,"deletions":37,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-  static int process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase);\n+  static int process_patch_mod_option(const char* patch_mod_tail);\n@@ -332,2 +332,2 @@\n-  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin);\n-  static jint finalize_vm_init_args(bool patch_mod_javabase);\n+  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, JVMFlagOrigin origin);\n+  static jint finalize_vm_init_args();\n@@ -372,0 +372,2 @@\n+  static bool internal_module_property_helper(const char* property, bool check_for_cds);\n+\n@@ -472,3 +474,1 @@\n-  static bool is_add_modules_property(const char* key);\n-  static unsigned int addmods_count() { return  _addmods_count; }\n-  static bool is_module_path_property(const char* key);\n+  static bool is_incompatible_cds_internal_module_property(const char* property);\n@@ -483,1 +483,1 @@\n-  static void add_patch_mod_prefix(const char *module_name, const char *path, bool* patch_mod_javabase);\n+  static void add_patch_mod_prefix(const char *module_name, const char *path);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -259,1 +259,3 @@\n-    return freeze_internal<SelfT, false>(thread, sp);\n+    freeze_result res = freeze_internal<SelfT, false>(thread, sp);\n+    JFR_ONLY(assert((res == freeze_ok) || (res == thread->last_freeze_fail_result()), \"freeze failure not set\"));\n+    return res;\n@@ -1725,0 +1727,3 @@\n+    if (!preempt) {\n+      JFR_ONLY(current->set_last_freeze_fail_result(res);)\n+    }\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -610,3 +610,0 @@\n-  \/\/ Note: on ia64 this guarantee can be fooled by frames with no memory stack\n-  \/\/ in that it will fail to detect a problem when there is one. This needs\n-  \/\/ more work in tiger timeframe.\n@@ -2345,2 +2342,1 @@\n-    \/\/ 4852688: ProfileInterpreter is off by default for ia64.  The result is\n-    \/\/ infinite heroic-opt-uncommon-trap\/deopt\/recompile cycles, since the\n+    \/\/ The result is infinite heroic-opt-uncommon-trap\/deopt\/recompile cycles, since the\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,4 +167,3 @@\n-  \/\/ For sparc and ia32 use sp. ia64 can have memory frames that are empty so multiple frames\n-  \/\/ will have identical sp values. For ia64 the bsp (fp) value will serve. No real frame\n-  \/\/ should have an id() of null so it is a distinguishing value for an unmatchable frame.\n-  \/\/ We also have relationals which allow comparing a frame to anoth frame's id() allow\n+  \/\/ For sparc and ia32 use sp.\n+  \/\/ No real frame should have an id() of null so it is a distinguishing value for an unmatchable frame.\n+  \/\/ We also have relationals which allow comparing a frame to another frame's id() allowing\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,5 +119,0 @@\n-  \/\/ Do this after the transition because this allows us to put an assert\n-  \/\/ the Java->vm transition which checks to see that stack is not walkable\n-  \/\/ on sparc\/ia64 which will catch violations of the resetting of last_Java_frame\n-  \/\/ invariants (i.e. _flags always cleared on return to Java)\n-\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -239,2 +239,2 @@\n-  \/\/ Set the lock_id to the next thread_id temporarily while initialization runs.\n-  set_lock_id(ThreadIdentifier::next());\n+  \/\/ Set the _monitor_owner_id to the next thread_id temporarily while initialization runs.\n+  set_monitor_owner_id(ThreadIdentifier::next());\n@@ -266,2 +266,2 @@\n-  \/\/ Update the lock_id with the tid value.\n-  set_lock_id(java_lang_Thread::thread_id(thread_oop()));\n+  \/\/ Update the _monitor_owner_id with the tid value.\n+  set_monitor_owner_id(java_lang_Thread::thread_id(thread_oop()));\n@@ -438,1 +438,1 @@\n-  _lock_id(0),\n+  _monitor_owner_id(0),\n@@ -521,0 +521,4 @@\n+#if INCLUDE_JFR\n+  _last_freeze_fail_result(freeze_ok),\n+#endif\n+\n@@ -1543,2 +1547,1 @@\n-      \/\/ _lock_id is the thread ID of the mounted virtual thread\n-      st->print_cr(\"   Carrying virtual thread #\" INT64_FORMAT, lock_id());\n+      st->print_cr(\"   Carrying virtual thread #\" INT64_FORMAT, java_lang_Thread::thread_id(vthread()));\n@@ -1728,1 +1731,1 @@\n-  set_lock_id(java_lang_Thread::thread_id(thread_oop()));\n+  set_monitor_owner_id(java_lang_Thread::thread_id(thread_oop()));\n@@ -2233,1 +2236,1 @@\n-  target->set_lock_id(java_lang_Thread::thread_id(thread_oop()));\n+  target->set_monitor_owner_id(java_lang_Thread::thread_id(thread_oop()));\n@@ -2364,1 +2367,1 @@\n-#endif\n\\ No newline at end of file\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  int64_t _lock_id;\n+  int64_t _monitor_owner_id;\n@@ -172,3 +172,3 @@\n-  void set_lock_id(int64_t tid) {\n-    assert(tid >= ThreadIdentifier::initial() && tid < ThreadIdentifier::current(), \"invalid tid\");\n-    _lock_id = tid;\n+  void set_monitor_owner_id(int64_t id) {\n+    assert(id >= ThreadIdentifier::initial() && id < ThreadIdentifier::current(), \"\");\n+    _monitor_owner_id = id;\n@@ -176,1 +176,1 @@\n-  int64_t lock_id() const { return _lock_id; }\n+  int64_t monitor_owner_id() const { return _monitor_owner_id; }\n@@ -887,1 +887,1 @@\n-  static ByteSize lock_id_offset()            { return byte_offset_of(JavaThread, _lock_id); }\n+  static ByteSize monitor_owner_id_offset()   { return byte_offset_of(JavaThread, _monitor_owner_id); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-\/\/   its tid (return value from owner_from()).\n+\/\/   its owner_id (return value from owner_id_from()).\n@@ -334,1 +334,1 @@\n-  } else if (prev_owner == owner_from(locking_thread)) {\n+  } else if (prev_owner == owner_id_from(locking_thread)) {\n@@ -1551,1 +1551,1 @@\n-\/\/ be set to current's tid, i.e. no ANONYMOUS_OWNER allowed.\n+\/\/ be set to current's owner_id, i.e. no ANONYMOUS_OWNER allowed.\n@@ -1583,1 +1583,1 @@\n-  if (cur == owner_from(current)) {\n+  if (cur == owner_id_from(current)) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-  int64_t volatile _owner;  \/\/ Either tid of owner, NO_OWNER, ANONYMOUS_OWNER or DEFLATER_MARKER.\n+  int64_t volatile _owner;  \/\/ Either owner_id of owner, NO_OWNER, ANONYMOUS_OWNER or DEFLATER_MARKER.\n@@ -287,3 +287,3 @@\n-  \/\/ the monitor with the given thread\/vthread (tid).\n-  static int64_t owner_from(JavaThread* thread);\n-  static int64_t owner_from(oop vthread);\n+  \/\/ the monitor with the given thread\/vthread, AKA owner_id.\n+  static int64_t owner_id_from(JavaThread* thread);\n+  static int64_t owner_id_from(oop vthread);\n@@ -295,1 +295,1 @@\n-  \/\/ Clear _owner field; current value must match thread's tid.\n+  \/\/ Clear _owner field; current value must match thread's owner_id.\n@@ -299,1 +299,1 @@\n-  \/\/ Same as above but uses tid of current as new value.\n+  \/\/ Same as above but uses owner_id of current as new value.\n@@ -305,1 +305,1 @@\n-  \/\/ Same as above but uses tid of current as new_value.\n+  \/\/ Same as above but uses owner_id of current as new_value.\n@@ -319,3 +319,3 @@\n-  \/\/ Returns true if _owner field == tid of thread, false otherwise.\n-  bool has_owner(JavaThread* thread) const { return owner() == owner_from(thread); }\n-  \/\/ Set _owner field to tid of thread; current value must be NO_OWNER.\n+  \/\/ Returns true if _owner field == owner_id of thread, false otherwise.\n+  bool has_owner(JavaThread* thread) const { return owner() == owner_id_from(thread); }\n+  \/\/ Set _owner field to owner_id of thread; current value must be NO_OWNER.\n@@ -323,1 +323,1 @@\n-  \/\/ Try to set _owner field from NO_OWNER to tid of thread.\n+  \/\/ Try to set _owner field from NO_OWNER to owner_id of thread.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,4 +42,4 @@\n-inline int64_t ObjectMonitor::owner_from(JavaThread* thread) {\n-  int64_t tid = thread->lock_id();\n-  assert(tid >= ThreadIdentifier::initial() && tid < ThreadIdentifier::current(), \"must be reasonable\");\n-  return tid;\n+inline int64_t ObjectMonitor::owner_id_from(JavaThread* thread) {\n+  int64_t id = thread->monitor_owner_id();\n+  assert(id >= ThreadIdentifier::initial() && id < ThreadIdentifier::current(), \"must be reasonable\");\n+  return id;\n@@ -48,4 +48,4 @@\n-inline int64_t ObjectMonitor::owner_from(oop vthread) {\n-  int64_t tid = java_lang_Thread::thread_id(vthread);\n-  assert(tid >= ThreadIdentifier::initial() && tid < ThreadIdentifier::current(), \"must be reasonable\");\n-  return tid;\n+inline int64_t ObjectMonitor::owner_id_from(oop vthread) {\n+  int64_t id = java_lang_Thread::thread_id(vthread);\n+  assert(id >= ThreadIdentifier::initial() && id < ThreadIdentifier::current(), \"must be reasonable\");\n+  return id;\n@@ -156,1 +156,1 @@\n-  int64_t old_value = owner_from(old_owner);\n+  int64_t old_value = owner_id_from(old_owner);\n@@ -185,1 +185,1 @@\n-  set_owner_from_raw(old_value, owner_from(current));\n+  set_owner_from_raw(old_value, owner_id_from(current));\n@@ -204,1 +204,1 @@\n-  return try_set_owner_from_raw(old_value, owner_from(current));\n+  return try_set_owner_from_raw(old_value, owner_id_from(current));\n@@ -212,1 +212,1 @@\n-  return owner_from(thread) == Atomic::load(&_succ);\n+  return owner_id_from(thread) == Atomic::load(&_succ);\n@@ -216,1 +216,1 @@\n-  Atomic::store(&_succ, owner_from(thread));\n+  Atomic::store(&_succ, owner_id_from(thread));\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -516,0 +516,5 @@\n+    if (is_vm_statically_linked()) {\n+      _native_java_library = get_default_process_handle();\n+      return _native_java_library;\n+    }\n+\n@@ -549,2 +554,1 @@\n-void* os::find_agent_function(JvmtiAgent *agent_lib, bool check_lib,\n-                              const char *syms[], size_t syms_len) {\n+void* os::find_agent_function(JvmtiAgent *agent_lib, bool check_lib, const char *sym) {\n@@ -552,1 +556,0 @@\n-  const char *lib_name;\n@@ -555,2 +558,0 @@\n-  char *agent_function_name;\n-  size_t i;\n@@ -560,6 +561,4 @@\n-  lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : nullptr);\n-  for (i = 0; i < syms_len; i++) {\n-    agent_function_name = build_agent_function_name(syms[i], lib_name, agent_lib->is_absolute_path());\n-    if (agent_function_name == nullptr) {\n-      break;\n-    }\n+  const char *lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : nullptr);\n+\n+  char* agent_function_name = build_agent_function_name(sym, lib_name, agent_lib->is_absolute_path());\n+  if (agent_function_name != nullptr) {\n@@ -568,3 +567,0 @@\n-    if (entryName != nullptr) {\n-      break;\n-    }\n@@ -576,6 +572,1 @@\n-bool os::find_builtin_agent(JvmtiAgent* agent, const char *syms[],\n-                            size_t syms_len) {\n-  void *ret;\n-  void *proc_handle;\n-  void *save_handle;\n-\n+bool os::find_builtin_agent(JvmtiAgent* agent, const char* sym) {\n@@ -586,1 +577,1 @@\n-  proc_handle = get_default_process_handle();\n+  void* proc_handle = get_default_process_handle();\n@@ -588,1 +579,1 @@\n-  save_handle = agent->os_lib();\n+  void* save_handle = agent->os_lib();\n@@ -591,1 +582,1 @@\n-  ret = find_agent_function(agent, true, syms, syms_len);\n+  void* ret = find_agent_function(agent, true, sym);\n@@ -2502,0 +2493,58 @@\n+\n+\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n+\/\/ which is used to find statically linked in agents.\n+\/\/ Parameters:\n+\/\/            sym_name: Symbol in library we are looking for\n+\/\/            lib_name: Name of library to look in, null for shared libs.\n+\/\/            is_absolute_path == true if lib_name is absolute path to agent\n+\/\/                                     such as \"C:\/a\/b\/L.dll\" or \"\/a\/b\/libL.so\"\n+\/\/            == false if only the base name of the library is passed in\n+\/\/               such as \"L\"\n+char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n+                                    bool is_absolute_path) {\n+  char *agent_entry_name;\n+  size_t len = 0;\n+  size_t name_len = 0;\n+  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n+  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n+  size_t underscore_len = 0; \/\/ optional underscore if lib_name is set\n+  const char *start;\n+\n+  if (lib_name != nullptr) {\n+    if (is_absolute_path) {\n+      \/\/ Need to strip path, prefix and suffix\n+      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n+        lib_name = ++start;\n+      }\n+#ifdef WINDOWS\n+      else { \/\/ Need to check for drive prefix e.g. C:L.dll\n+        if ((start = strchr(lib_name, ':')) != nullptr) {\n+          lib_name = ++start;\n+        }\n+      }\n+#endif\n+      name_len = strlen(lib_name);\n+      if (name_len <= (prefix_len + suffix_len)) {\n+        return nullptr;\n+      }\n+      lib_name += prefix_len;\n+      name_len = strlen(lib_name) - suffix_len;\n+    } else {\n+      name_len = strlen(lib_name);\n+    }\n+    underscore_len = 1;\n+  }\n+  \/\/ Total buffer length to allocate - includes null terminator.\n+  len = strlen(sym_name) + underscore_len + name_len + 1;\n+  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n+  if (agent_entry_name == nullptr) {\n+    return nullptr;\n+  }\n+\n+  strcpy(agent_entry_name, sym_name);\n+  if (lib_name != nullptr) {\n+    strcat(agent_entry_name, \"_\");\n+    strncat(agent_entry_name, lib_name, name_len);\n+  }\n+  return agent_entry_name;\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":72,"deletions":23,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -779,0 +779,3 @@\n+  \/\/ Lookup the named function. This is used by the static JDK.\n+  static void* lookup_function(const char* name);\n+\n@@ -793,2 +796,1 @@\n-  static bool find_builtin_agent(JvmtiAgent *agent_lib, const char *syms[],\n-                                 size_t syms_len);\n+  static bool find_builtin_agent(JvmtiAgent* agent_lib, const char* sym);\n@@ -797,2 +799,1 @@\n-  static void *find_agent_function(JvmtiAgent *agent_lib, bool check_lib,\n-                                   const char *syms[], size_t syms_len);\n+  static void* find_agent_function(JvmtiAgent* agent_lib, bool check_lib, const char* sym);\n@@ -875,2 +876,1 @@\n-  \/\/ only walk stack if %ebp is used as frame pointer; on ia64, it's not\n-  \/\/ possible to walk C stack without having the unwind table.\n+  \/\/ only walk stack if %ebp is used as frame pointer.\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-    case Bytecodes::_lookupswitch:                   \/\/ not rewritten on ia64\n+    case Bytecodes::_lookupswitch:\n","filename":"src\/hotspot\/share\/runtime\/relocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,3 +61,2 @@\n-    char* polling_page = os::reserve_memory(allocation_size);\n-    os::commit_memory_or_exit(polling_page, allocation_size, false, \"Unable to commit Safepoint polling page\");\n-    MemTracker::record_virtual_memory_tag((address)polling_page, mtSafepoint);\n+    char* polling_page = os::reserve_memory(allocation_size, !ExecMem, mtSafepoint);\n+    os::commit_memory_or_exit(polling_page, allocation_size, !ExecMem, \"Unable to commit Safepoint polling page\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1246,1 +1246,1 @@\n-  int64_t key = ObjectMonitor::owner_from(thread);\n+  int64_t key = ObjectMonitor::owner_id_from(thread);\n@@ -1252,1 +1252,1 @@\n-  int64_t key = ObjectMonitor::owner_from(vthread);\n+  int64_t key = ObjectMonitor::owner_id_from(vthread);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  assert(main_thread_tid == thread->lock_id(), \"\");\n+  assert(main_thread_tid == thread->monitor_owner_id(), \"\");\n@@ -581,1 +581,1 @@\n-  \/\/ Set the lock_id now since we will run Java code before the Thread instance\n+  \/\/ Set the _monitor_owner_id now since we will run Java code before the Thread instance\n@@ -583,1 +583,1 @@\n-  main_thread->set_lock_id(ThreadIdentifier::next());\n+  main_thread->set_monitor_owner_id(ThreadIdentifier::next());\n@@ -1393,2 +1393,1 @@\n-          \/\/ _lock_id is the thread ID of the mounted virtual thread\n-          st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, p->lock_id());\n+          st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, java_lang_Thread::thread_id(p->vthread()));\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-    int64_t key = ObjectMonitor::owner_from(thread);\n+    int64_t key = ObjectMonitor::owner_id_from(thread);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-  nonstatic_field(JavaThread,                  _lock_id,                                      int64_t)                               \\\n+  nonstatic_field(JavaThread,                  _monitor_owner_id,                             int64_t)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadSchedulerDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadPollersDCmd>(full_export, true, false));\n@@ -160,2 +162,1 @@\n-  \/\/ These commands won't be exported via the DiagnosticCommandMBean until an\n-  \/\/ appropriate permission is created for them\n+  \/\/ These commands not currently exported via the DiagnosticCommandMBean\n@@ -1109,7 +1110,0 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n-    output()->cr();\n-    CLEAR_PENDING_EXCEPTION;\n-    return;\n-  }\n@@ -1146,0 +1140,39 @@\n+\/\/ Calls a static no-arg method on jdk.internal.vm.JcmdVThreadCommands that returns a byte[] with\n+\/\/ the output. If the method completes successfully then the bytes are copied to the output stream.\n+\/\/ If the method fails then the exception is printed to the output stream.\n+static void execute_vthread_command(Symbol* method_name, outputStream* output, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_JcmdVThreadCommands(), true, CHECK);\n+\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  JavaCalls::call_static(&result,\n+                         k,\n+                         method_name,\n+                         vmSymbols::void_byte_array_signature(),\n+                         &args,\n+                         THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, output);\n+    output->cr();\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  \/\/ copy the bytes to the output stream\n+  oop res = cast_to_oop(result.get_jobject());\n+  typeArrayOop ba = typeArrayOop(res);\n+  jbyte* addr = typeArrayOop(res)->byte_at_addr(0);\n+  output->print_raw((const char*)addr, ba->length());\n+}\n+\n+void VThreadSchedulerDCmd::execute(DCmdSource source, TRAPS) {\n+  execute_vthread_command(vmSymbols::printScheduler_name(), output(), CHECK);\n+}\n+\n+void VThreadPollersDCmd::execute(DCmdSource source, TRAPS) {\n+  execute_vthread_command(vmSymbols::printPollers_name(), output(), CHECK);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -67,5 +67,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.util.PropertyPermission\",\n-                        \"java.vm.version\", \"read\"};\n-    return p;\n-  }\n@@ -83,5 +78,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -104,5 +94,0 @@\n-    static const JavaPermission permission() {\n-      JavaPermission p = {\"java.util.PropertyPermission\",\n-                          \"*\", \"read\"};\n-      return p;\n-    }\n@@ -126,5 +111,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -149,5 +129,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -167,5 +142,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -189,5 +159,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -211,5 +176,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -243,5 +203,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -287,5 +242,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-      \"monitor\", nullptr};\n-      return p;\n-  }\n@@ -306,5 +256,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-      \"monitor\", nullptr};\n-      return p;\n-  }\n@@ -337,5 +282,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -363,5 +303,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -390,5 +325,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -415,5 +345,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -439,5 +364,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -549,6 +469,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n-\n@@ -571,5 +485,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -595,5 +504,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -616,5 +520,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -636,5 +535,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -662,5 +556,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -683,5 +572,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -703,5 +587,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -726,5 +605,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -746,5 +620,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -812,5 +681,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -835,5 +699,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -858,5 +717,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -881,5 +735,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -905,5 +754,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -932,3 +776,22 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class VThreadSchedulerDCmd : public DCmd {\n+public:\n+  VThreadSchedulerDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+  static const char* name() {\n+    return \"Thread.vthread_scheduler\";\n+  }\n+  static const char* description() {\n+    return \"Print the virtual thread scheduler, and the delayed task schedulers that support \"\n+           \"virtual threads doing timed operations.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class VThreadPollersDCmd : public DCmd {\n+public:\n+  VThreadPollersDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+  static const char* name() {\n+    return \"Thread.vthread_pollers\";\n@@ -936,0 +799,4 @@\n+  static const char* description() {\n+    return \"Print the I\/O pollers that support virtual threads doing blocking network I\/O operations.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n@@ -955,5 +822,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -973,5 +835,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -991,5 +848,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":26,"deletions":174,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-                    factory->permission(), factory->num_arguments(),\n+                    factory->num_arguments(),\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,10 +43,0 @@\n-\/\/ Warning: strings referenced by the JavaPermission struct are passed to\n-\/\/ the native part of the JDK. Avoid use of dynamically allocated strings\n-\/\/ that could be de-allocated before the JDK native code had time to\n-\/\/ convert them into Java Strings.\n-struct JavaPermission {\n-  const char* _class;\n-  const char* _name;\n-  const char* _action;\n-};\n-\n@@ -130,1 +120,0 @@\n-  const JavaPermission _permission;  \/* Java Permission required to execute this command if any *\/\n@@ -137,1 +126,0 @@\n-          JavaPermission permission,\n@@ -140,1 +128,1 @@\n-  : _name(name), _description(description), _impact(impact), _permission(permission),\n+  : _name(name), _description(description), _impact(impact),\n@@ -146,1 +134,0 @@\n-  const JavaPermission& permission() const { return _permission; }\n@@ -264,13 +251,0 @@\n-  \/\/ The permission() method returns the description of Java Permission. This\n-  \/\/ permission is required when the diagnostic command is invoked via the\n-  \/\/ DiagnosticCommandMBean. The rationale for this permission check is that\n-  \/\/ the DiagnosticCommandMBean can be used to perform remote invocations of\n-  \/\/ diagnostic commands through the PlatformMBeanServer. The (optional) Java\n-  \/\/ Permission associated with each diagnostic command should ease the work\n-  \/\/ of system administrators to write policy files granting permissions to\n-  \/\/ execute diagnostic commands to remote users. Any diagnostic command with\n-  \/\/ a potential impact on security should overwrite this method.\n-  static const JavaPermission permission() {\n-    JavaPermission p = {nullptr, nullptr, nullptr};\n-    return p;\n-  }\n@@ -390,1 +364,0 @@\n-  virtual const JavaPermission permission() const = 0;\n@@ -434,3 +407,0 @@\n-  const JavaPermission permission() const {\n-    return DCmdClass::permission();\n-  }\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2029,4 +2029,0 @@\n-    JavaPermission p = info->permission();\n-    infoArray[i].permission_class = p._class;\n-    infoArray[i].permission_name = p._name;\n-    infoArray[i].permission_action = p._action;\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -718,1 +718,1 @@\n-  char* page = os::reserve_memory(os::vm_page_size());\n+  char* page = os::reserve_memory(os::vm_page_size(), !ExecMem, mtInternal);\n@@ -720,2 +720,1 @@\n-    MemTracker::record_virtual_memory_tag(page, mtInternal);\n-    if (os::commit_memory(page, os::vm_page_size(), false) &&\n+    if (os::commit_memory(page, os::vm_page_size(), !ExecMem) &&\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  \/\/ first value in the function descriptor (on IA64 and PPC64 they look as follows):\n+  \/\/ first value in the function descriptor (on PPC64 they look as follows):\n@@ -39,1 +39,0 @@\n-  \/\/ IA64 : [function entry point, GP (global pointer) value]\n@@ -41,1 +40,1 @@\n-  \/\/ assert(IA64_ONLY(2) PPC64_ONLY(3) * sizeof(address) == shdr.sh_entsize, \"Size mismatch for '.opd' section entries\");\n+  \/\/ assert(PPC64_ONLY(3) * sizeof(address) == shdr.sh_entsize, \"Size mismatch for '.opd' section entries\");\n","filename":"src\/hotspot\/share\/utilities\/elfFuncDescTable.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,3 +38,2 @@\n-On PowerPC-64 (and other architectures like for example IA64) a pointer to a\n-function is not just a plain code address, but instead a pointer to a so called\n-function descriptor (which is simply a structure containing 3 pointers).\n+On PowerPC-64 a pointer to a function is not just a plain code address, but instead a pointer\n+to a so-called function descriptor (which is simply a structure containing 3 pointers).\n","filename":"src\/hotspot\/share\/utilities\/elfFuncDescTable.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -563,0 +563,3 @@\n+\/\/ A named constant for the integral representation of a Java null.\n+const intptr_t NULL_WORD = 0;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,18 +74,0 @@\n-\/\/ NULL vs NULL_WORD:\n-\/\/ On Linux NULL is defined as a special type '__null'. Assigning __null to\n-\/\/ integer variable will cause gcc warning. Use NULL_WORD in places where a\n-\/\/ pointer is stored as integer value.  On some platforms, sizeof(intptr_t) >\n-\/\/ sizeof(void*), so here we want something which is integer type, but has the\n-\/\/ same size as a pointer.\n-#ifdef __GNUC__\n-  #ifdef _LP64\n-    #define NULL_WORD  0L\n-  #else\n-    \/\/ Cast 0 to intptr_t rather than int32_t since they are not the same type\n-    \/\/ on platforms such as Mac OS X.\n-    #define NULL_WORD  ((intptr_t)0)\n-  #endif\n-#else\n-  #define NULL_WORD  NULL\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,6 +75,0 @@\n-\/\/ NULL vs NULL_WORD:\n-\/\/ On Linux NULL is defined as a special type '__null'. Assigning __null to\n-\/\/ integer variable will cause gcc warning. Use NULL_WORD in places where a\n-\/\/ pointer is stored as integer value.\n-#define NULL_WORD NULL\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+GrowableArrayNestingCheck::GrowableArrayNestingCheck(Arena* arena) :\n+    _nesting((arena->get_tag() == Arena::Tag::tag_ra) ? static_cast<ResourceArea*>(arena)->nesting() : 0) {\n+}\n+\n@@ -73,0 +77,5 @@\n+void GrowableArrayNestingCheck::on_arena_alloc(Arena* arena) const {\n+  if ((arena->get_tag() == Arena::Tag::tag_ra) && (_nesting != static_cast<ResourceArea*>(arena)->nesting())) {\n+    fatal(\"allocation bug: GrowableArray is growing within nested ResourceMark\");\n+  }\n+}\n@@ -92,0 +101,4 @@\n+void GrowableArrayMetadata::on_arena_alloc_check() const {\n+  _nesting_check.on_arena_alloc(arena());\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -611,0 +611,1 @@\n+  GrowableArrayNestingCheck(Arena* arena);\n@@ -613,0 +614,1 @@\n+  void on_arena_alloc(Arena* arena) const;\n@@ -652,1 +654,1 @@\n-      debug_only(COMMA _nesting_check(false)) {\n+      debug_only(COMMA _nesting_check(arena)) {\n@@ -679,0 +681,1 @@\n+  void on_arena_alloc_check() const;\n@@ -743,0 +746,1 @@\n+    debug_only(_metadata.on_arena_alloc_check());\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -465,12 +465,0 @@\n-\/\/ This is a REALLY BIG HACK, but on AIX <sys\/systemcfg.h> unconditionally defines IA64.\n-\/\/ At least on AIX 7.1 this is a real problem because 'systemcfg.h' is indirectly included\n-\/\/ by 'pthread.h' and other common system headers.\n-\n-#if defined(IA64) && !defined(AIX)\n-#define IA64_ONLY(code) code\n-#define NOT_IA64(code)\n-#else\n-#define IA64_ONLY(code)\n-#define NOT_IA64(code) code\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,4 @@\n+  if (is_vm_statically_linked()) {\n+    return os::lookup_function(name);\n+  }\n+\n@@ -90,7 +94,14 @@\n-  if (os::dll_locate_lib(&path[0], sizeof path, Arguments::get_dll_dir(), \"zip\")) {\n-    char ebuf[1024];\n-    _zip_handle = os::dll_load(&path[0], &ebuf[0], sizeof ebuf);\n-  }\n-  if (_zip_handle == nullptr) {\n-    if (vm_exit_on_failure) {\n-      vm_exit_during_initialization(\"Unable to load zip library\", &path[0]);\n+\n+  if (is_vm_statically_linked()) {\n+    _zip_handle = os::get_default_process_handle();\n+  } else {\n+    \/\/ Load the libzip shared library and lookup the needed functions.\n+    if (os::dll_locate_lib(&path[0], sizeof path, Arguments::get_dll_dir(), \"zip\")) {\n+      char ebuf[1024];\n+      _zip_handle = os::dll_load(&path[0], &ebuf[0], sizeof ebuf);\n+    }\n+    if (_zip_handle == nullptr) {\n+      if (vm_exit_on_failure) {\n+        vm_exit_during_initialization(\"Unable to load zip library\", &path[0]);\n+      }\n+      return;\n@@ -98,1 +109,0 @@\n-    return;\n@@ -100,0 +110,1 @@\n+\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.cpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +32,1 @@\n+import java.nio.file.Files;\n@@ -32,1 +34,0 @@\n-import java.nio.file.Paths;\n@@ -64,4 +65,5 @@\n-        try {\n-            return CgroupUtil.readStringValue(controller, param);\n-        }\n-        catch (IOException e) {\n+        Path filePath = Path.of(controller.path(), param);\n+        try (Stream<String> lines = Files.lines(filePath)) {\n+            Optional<String> firstLine = lines.findFirst();\n+            return firstLine.orElse(null);\n+        } catch (UncheckedIOException | IOException e) {\n@@ -70,1 +72,0 @@\n-\n@@ -95,2 +96,2 @@\n-            Path filePath = Paths.get(controller.path(), param);\n-            List<String> lines = CgroupUtil.readAllLinesPrivileged(filePath);\n+            Path filePath = Path.of(controller.path(), param);\n+            List<String> lines = Files.readAllLines(filePath);\n@@ -164,1 +165,1 @@\n-        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(), param))) {\n+        try (Stream<String> lines = Files.lines(Path.of(controller.path(), param))) {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +33,1 @@\n+import java.nio.file.Files;\n@@ -33,1 +35,0 @@\n-import java.nio.file.Paths;\n@@ -143,1 +144,1 @@\n-        List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(cgroups));\n+        List<String> lines = Files.readAllLines(Path.of(cgroups));\n@@ -183,1 +184,1 @@\n-        lines = CgroupUtil.readAllLinesPrivileged(Paths.get(mountInfo));\n+        lines = Files.readAllLines(Path.of(mountInfo));\n@@ -199,2 +200,1 @@\n-        try (Stream<String> selfCgroupLines =\n-             CgroupUtil.readFilePrivileged(Paths.get(selfCgroup))) {\n+        try (Stream<String> selfCgroupLines = Files.lines(Path.of(selfCgroup))) {\n@@ -314,1 +314,1 @@\n-                Path p = Paths.get(mountPath);\n+                Path p = Path.of(mountPath);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.List;\n-import java.util.stream.Stream;\n-\n-public final class CgroupUtil {\n-\n-    @SuppressWarnings(\"removal\")\n-    public static Stream<String> readFilePrivileged(Path path) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n-        Throwable x = pae.getCause();\n-        if (x instanceof IOException)\n-            throw (IOException) x;\n-        if (x instanceof RuntimeException)\n-            throw (RuntimeException) x;\n-        if (x instanceof Error)\n-            throw (Error) x;\n-    }\n-\n-    static String readStringValue(CgroupSubsystemController controller, String param) throws IOException {\n-        PrivilegedExceptionAction<BufferedReader> pea = () ->\n-                Files.newBufferedReader(Paths.get(controller.path(), param));\n-        try (@SuppressWarnings(\"removal\") BufferedReader bufferedReader =\n-                     AccessController.doPrivileged(pea)) {\n-            String line = bufferedReader.readLine();\n-            return line;\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    public static List<String> readAllLinesPrivileged(Path path) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<List<String>> pea = () -> Files.readAllLines(path);\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +31,2 @@\n-import java.nio.file.Paths;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -38,1 +41,0 @@\n-import jdk.internal.platform.CgroupUtil;\n@@ -331,4 +333,3 @@\n-        try {\n-            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(), \"io.stat\"))\n-                                .map(mapFunc)\n-                                .collect(Collectors.summingLong(e -> e));\n+        try (Stream<String> lines = Files.lines(Path.of(unified.path(), \"io.stat\"))) {\n+            return lines.map(mapFunc)\n+                        .collect(Collectors.summingLong(e -> e));\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -84,9 +83,4 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                putService(new ProviderService(p, \"KeyStore\",\n-                           \"KeychainStore\", \"apple.security.KeychainStore$USER\"));\n-                putService(new ProviderService(p, \"KeyStore\",\n-                           \"KeychainStore-ROOT\", \"apple.security.KeychainStore$ROOT\"));\n-                return null;\n-            }\n-        });\n+        putService(new ProviderService(p, \"KeyStore\",\n+                   \"KeychainStore\", \"apple.security.KeychainStore$USER\"));\n+        putService(new ProviderService(p, \"KeyStore\",\n+                   \"KeychainStore-ROOT\", \"apple.security.KeychainStore$ROOT\"));\n","filename":"src\/java.base\/macosx\/classes\/apple\/security\/AppleProvider.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,9 +191,0 @@\n-    private static void permissionCheck() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sec = System.getSecurityManager();\n-\n-        if (sec != null) {\n-            sec.checkPermission(new RuntimePermission(\"useKeychainStore\"));\n-        }\n-    }\n-\n@@ -231,2 +222,0 @@\n-        permissionCheck();\n-\n@@ -335,2 +324,0 @@\n-        permissionCheck();\n-\n@@ -366,2 +353,0 @@\n-        permissionCheck();\n-\n@@ -423,2 +408,0 @@\n-        permissionCheck();\n-\n@@ -464,2 +447,0 @@\n-        permissionCheck();\n-\n@@ -535,2 +516,0 @@\n-        permissionCheck();\n-\n@@ -585,2 +564,0 @@\n-        permissionCheck();\n-\n@@ -600,1 +577,0 @@\n-        permissionCheck();\n@@ -612,1 +588,0 @@\n-        permissionCheck();\n@@ -622,1 +597,0 @@\n-        permissionCheck();\n@@ -634,1 +608,0 @@\n-        permissionCheck();\n@@ -647,1 +620,0 @@\n-        permissionCheck();\n@@ -669,1 +641,0 @@\n-        permissionCheck();\n@@ -707,2 +678,0 @@\n-        permissionCheck();\n-\n@@ -798,2 +767,0 @@\n-        permissionCheck();\n-\n","filename":"src\/java.base\/macosx\/classes\/apple\/security\/KeychainStore.java","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -108,3 +106,1 @@\n-                PrivilegedAction<Enumeration<InetAddress>> pa = ni::getInetAddresses;\n-                @SuppressWarnings(\"removal\")\n-                Enumeration<InetAddress> addrs = AccessController.doPrivileged(pa);\n+                Enumeration<InetAddress> addrs = ni.getInetAddresses();\n","filename":"src\/java.base\/macosx\/classes\/java\/net\/DefaultInterface.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -339,12 +339,13 @@\n-    \/* Find out where the JDK is that we will be using. *\/\n-    if (!GetJDKInstallRoot(jdkroot, so_jdkroot, JNI_FALSE) ) {\n-        JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n-        exit(2);\n-    }\n-    JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%sjvm.cfg\",\n-                 jdkroot, FILESEP, FILESEP);\n-    \/* Find the specified JVM type *\/\n-    if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n-        JLI_ReportErrorMessage(CFG_ERROR7);\n-        exit(1);\n-    }\n+    if (!JLI_IsStaticallyLinked()) {\n+        \/* Find out where the JDK is that we will be using. *\/\n+        if (!GetJDKInstallRoot(jdkroot, so_jdkroot, JNI_FALSE) ) {\n+            JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n+            exit(2);\n+        }\n+        JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%sjvm.cfg\",\n+                     jdkroot, FILESEP, FILESEP);\n+        \/* Find the specified JVM type *\/\n+        if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n+            JLI_ReportErrorMessage(CFG_ERROR7);\n+            exit(1);\n+        }\n@@ -352,6 +353,6 @@\n-    jvmpath[0] = '\\0';\n-    jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);\n-    if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n-        JLI_ReportErrorMessage(CFG_ERROR9);\n-        exit(4);\n-    }\n+        jvmpath[0] = '\\0';\n+        jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);\n+        if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n+            JLI_ReportErrorMessage(CFG_ERROR9);\n+            exit(4);\n+        }\n@@ -359,3 +360,4 @@\n-    if (!GetJVMPath(jdkroot, jvmtype, jvmpath, so_jvmpath)) {\n-        JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);\n-        exit(4);\n+        if (!GetJVMPath(jdkroot, jvmtype, jvmpath, so_jvmpath)) {\n+            JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);\n+            exit(4);\n+        }\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        String ic = SecurityProperties.privilegedGetOverridable(\n+        String ic = SecurityProperties.getOverridableProperty(\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,243 +74,0 @@\n-    private static final short[] MONT_ZETAS_FOR_VECTOR_NTT_ARR = new short[]{\n-            \/\/ level 0\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            -758, -758, -758, -758, -758, -758, -758, -758,\n-            \/\/ level 1\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -359, -359, -359, -359, -359, -359, -359, -359,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n-            \/\/ level 2\n-            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n-            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n-            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n-            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n-            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n-            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n-            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n-            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n-            287, 287, 287, 287, 287, 287, 287, 287,\n-            287, 287, 287, 287, 287, 287, 287, 287,\n-            287, 287, 287, 287, 287, 287, 287, 287,\n-            287, 287, 287, 287, 287, 287, 287, 287,\n-            202, 202, 202, 202, 202, 202, 202, 202,\n-            202, 202, 202, 202, 202, 202, 202, 202,\n-            202, 202, 202, 202, 202, 202, 202, 202,\n-            202, 202, 202, 202, 202, 202, 202, 202,\n-            \/\/ level 3\n-            -171, -171, -171, -171, -171, -171, -171, -171,\n-            -171, -171, -171, -171, -171, -171, -171, -171,\n-            622, 622, 622, 622, 622, 622, 622, 622,\n-            622, 622, 622, 622, 622, 622, 622, 622,\n-            1577, 1577, 1577, 1577, 1577, 1577, 1577, 1577,\n-            1577, 1577, 1577, 1577, 1577, 1577, 1577, 1577,\n-            182, 182, 182, 182, 182, 182, 182, 182,\n-            182, 182, 182, 182, 182, 182, 182, 182,\n-            962, 962, 962, 962, 962, 962, 962, 962,\n-            962, 962, 962, 962, 962, 962, 962, 962,\n-            -1202, -1202, -1202, -1202, -1202, -1202, -1202, -1202,\n-            -1202, -1202, -1202, -1202, -1202, -1202, -1202, -1202,\n-            -1474, -1474, -1474, -1474, -1474, -1474, -1474, -1474,\n-            -1474, -1474, -1474, -1474, -1474, -1474, -1474, -1474,\n-            1468, 1468, 1468, 1468, 1468, 1468, 1468, 1468,\n-            1468, 1468, 1468, 1468, 1468, 1468, 1468, 1468,\n-            \/\/ level 4\n-            573, 573, 573, 573, 573, 573, 573, 573,\n-            -1325, -1325, -1325, -1325, -1325, -1325, -1325, -1325,\n-            264, 264, 264, 264, 264, 264, 264, 264,\n-            383, 383, 383, 383, 383, 383, 383, 383,\n-            -829, -829, -829, -829, -829, -829, -829, -829,\n-            1458, 1458, 1458, 1458, 1458, 1458, 1458, 1458,\n-            -1602, -1602, -1602, -1602, -1602, -1602, -1602, -1602,\n-            -130, -130, -130, -130, -130, -130, -130, -130,\n-            -681, -681, -681, -681, -681, -681, -681, -681,\n-            1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017,\n-            732, 732, 732, 732, 732, 732, 732, 732,\n-            608, 608, 608, 608, 608, 608, 608, 608,\n-            -1542, -1542, -1542, -1542, -1542, -1542, -1542, -1542,\n-            411, 411, 411, 411, 411, 411, 411, 411,\n-            -205, -205, -205, -205, -205, -205, -205, -205,\n-            -1571, -1571, -1571, -1571, -1571, -1571, -1571, -1571,\n-            \/\/ level 5\n-            1223, 1223, 1223, 1223, 652, 652, 652, 652,\n-            -552, -552, -552, -552, 1015, 1015, 1015, 1015,\n-            -1293, -1293, -1293, -1293, 1491, 1491, 1491, 1491,\n-            -282, -282, -282, -282, -1544, -1544, -1544, -1544,\n-            516, 516, 516, 516, -8, -8, -8, -8,\n-            -320, -320, -320, -320, -666, -666, -666, -666,\n-            1711, 1711, 1711, 1711, -1162, -1162, -1162, -1162,\n-            126, 126, 126, 126, 1469, 1469, 1469, 1469,\n-            -853, -853, -853, -853, -90, -90, -90, -90,\n-            -271, -271, -271, -271, 830, 830, 830, 830,\n-            107, 107, 107, 107, -1421, -1421, -1421, -1421,\n-            -247, -247, -247, -247, -951, -951, -951, -951,\n-            -398, -398, -398, -398, 961, 961, 961, 961,\n-            -1508, -1508, -1508, -1508, -725, -725, -725, -725,\n-            448, 448, 448, 448, -1065, -1065, -1065, -1065,\n-            677, 677, 677, 677, -1275, -1275, -1275, -1275,\n-            \/\/ level 6\n-            -1103, -1103, 430, 430, 555, 555, 843, 843,\n-            -1251, -1251, 871, 871, 1550, 1550, 105, 105,\n-            422, 422, 587, 587, 177, 177, -235, -235,\n-            -291, -291, -460, -460, 1574, 1574, 1653, 1653,\n-            -246, -246, 778, 778, 1159, 1159, -147, -147,\n-            -777, -777, 1483, 1483, -602, -602, 1119, 1119,\n-            -1590, -1590, 644, 644, -872, -872, 349, 349,\n-            418, 418, 329, 329, -156, -156, -75, -75,\n-            817, 817, 1097, 1097, 603, 603, 610, 610,\n-            1322, 1322, -1285, -1285, -1465, -1465, 384, 384,\n-            -1215, -1215, -136, -136, 1218, 1218, -1335, -1335,\n-            -874, -874, 220, 220, -1187, -1187, 1670, 1670,\n-            -1185, -1185, -1530, -1530, -1278, -1278, 794, 794,\n-            -1510, -1510, -854, -854, -870, -870, 478, 478,\n-            -108, -108, -308, -308, 996, 996, 991, 991,\n-            958, 958, -1460, -1460, 1522, 1522, 1628, 1628\n-    };\n-    private static final short[] MONT_ZETAS_FOR_VECTOR_INVERSE_NTT_ARR = new short[]{\n-            \/\/ level 0\n-            -1628, -1628, -1522, -1522, 1460, 1460, -958, -958,\n-            -991, -991, -996, -996, 308, 308, 108, 108,\n-            -478, -478, 870, 870, 854, 854, 1510, 1510,\n-            -794, -794, 1278, 1278, 1530, 1530, 1185, 1185,\n-            1659, 1659, 1187, 1187, -220, -220, 874, 874,\n-            1335, 1335, -1218, -1218, 136, 136, 1215, 1215,\n-            -384, -384, 1465, 1465, 1285, 1285, -1322, -1322,\n-            -610, -610, -603, -603, -1097, -1097, -817, -817,\n-            75, 75, 156, 156, -329, -329, -418, -418,\n-            -349, -349, 872, 872, -644, -644, 1590, 1590,\n-            -1119, -1119, 602, 602, -1483, -1483, 777, 777,\n-            147, 147, -1159, -1159, -778, -778, 246, 246,\n-            -1653, -1653, -1574, -1574, 460, 460, 291, 291,\n-            235, 235, -177, -177, -587, -587, -422, -422,\n-            -105, -105, -1550, -1550, -871, -871, 1251, 1251,\n-            -843, -843, -555, -555, -430, -430, 1103, 1103,\n-            \/\/ level 1\n-            1275, 1275, 1275, 1275, -677, -677, -677, -677,\n-            1065, 1065, 1065, 1065, -448, -448, -448, -448,\n-            725, 725, 725, 725, 1508, 1508, 1508, 1508,\n-            -961, -961, -961, -961, 398, 398, 398, 398,\n-            951, 951, 951, 951, 247, 247, 247, 247,\n-            1421, 1421, 1421, 1421, -107, -107, -107, -107,\n-            -830, -830, -830, -830, 271, 271, 271, 271,\n-            90, 90, 90, 90, 853, 853, 853, 853,\n-            -1469, -1469, -1469, -1469, -126, -126, -126, -126,\n-            1162, 1162, 1162, 1162, 1618, 1618, 1618, 1618,\n-            666, 666, 666, 666, 320, 320, 320, 320,\n-            8, 8, 8, 8, -516, -516, -516, -516,\n-            1544, 1544, 1544, 1544, 282, 282, 282, 282,\n-            -1491, -1491, -1491, -1491, 1293, 1293, 1293, 1293,\n-            -1015, -1015, -1015, -1015, 552, 552, 552, 552,\n-            -652, -652, -652, -652, -1223, -1223, -1223, -1223,\n-            \/\/ level 2\n-            1571, 1571, 1571, 1571, 1571, 1571, 1571, 1571,\n-            205, 205, 205, 205, 205, 205, 205, 205,\n-            -411, -411, -411, -411, -411, -411, -411, -411,\n-            1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,\n-            -608, -608, -608, -608, -608, -608, -608, -608,\n-            -732, -732, -732, -732, -732, -732, -732, -732,\n-            -1017, -1017, -1017, -1017, -1017, -1017, -1017, -1017,\n-            681, 681, 681, 681, 681, 681, 681, 681,\n-            130, 130, 130, 130, 130, 130, 130, 130,\n-            1602, 1602, 1602, 1602, 1602, 1602, 1602, 1602,\n-            -1458, -1458, -1458, -1458, -1458, -1458, -1458, -1458,\n-            829, 829, 829, 829, 829, 829, 829, 829,\n-            -383, -383, -383, -383, -383, -383, -383, -383,\n-            -264, -264, -264, -264, -264, -264, -264, -264,\n-            1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,\n-            -573, -573, -573, -573, -573, -573, -573, -573,\n-            \/\/ level 3\n-            -1468, -1468, -1468, -1468, -1468, -1468, -1468, -1468,\n-            -1468, -1468, -1468, -1468, -1468, -1468, -1468, -1468,\n-            1474, 1474, 1474, 1474, 1474, 1474, 1474, 1474,\n-            1474, 1474, 1474, 1474, 1474, 1474, 1474, 1474,\n-            1202, 1202, 1202, 1202, 1202, 1202, 1202, 1202,\n-            1202, 1202, 1202, 1202, 1202, 1202, 1202, 1202,\n-            -962, -962, -962, -962, -962, -962, -962, -962,\n-            -962, -962, -962, -962, -962, -962, -962, -962,\n-            -182, -182, -182, -182, -182, -182, -182, -182,\n-            -182, -182, -182, -182, -182, -182, -182, -182,\n-            -1577, -1577, -1577, -1577, -1577, -1577, -1577, -1577,\n-            -1577, -1577, -1577, -1577, -1577, -1577, -1577, -1577,\n-            -622, -622, -622, -622, -622, -622, -622, -622,\n-            -622, -622, -622, -622, -622, -622, -622, -622,\n-            171, 171, 171, 171, 171, 171, 171, 171,\n-            171, 171, 171, 171, 171, 171, 171, 171,\n-            \/\/ level 4\n-            -202, -202, -202, -202, -202, -202, -202, -202,\n-            -202, -202, -202, -202, -202, -202, -202, -202,\n-            -202, -202, -202, -202, -202, -202, -202, -202,\n-            -202, -202, -202, -202, -202, -202, -202, -202,\n-            -287, -287, -287, -287, -287, -287, -287, -287,\n-            -287, -287, -287, -287, -287, -287, -287, -287,\n-            -287, -287, -287, -287, -287, -287, -287, -287,\n-            -287, -287, -287, -287, -287, -287, -287, -287,\n-            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n-            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n-            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n-            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n-            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n-            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n-            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n-            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n-            \/\/ level 5\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            359, 359, 359, 359, 359, 359, 359, 359,\n-            \/\/ level 6\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758,\n-            758, 758, 758, 758, 758, 758, 758, 758\n-    };\n-\n@@ -336,19 +93,0 @@\n-    private static final short[] MONT_ZETAS_FOR_VECTOR_NTT_MULT_ARR = new short[]{\n-            -1103, 1103, 430, -430, 555, -555, 843, -843,\n-            -1251, 1251, 871, -871, 1550, -1550, 105, -105,\n-            422, -422, 587, -587, 177, -177, -235, 235,\n-            -291, 291, -460, 460, 1574, -1574, 1653, -1653,\n-            -246, 246, 778, -778, 1159, -1159, -147, 147,\n-            -777, 777, 1483, -1483, -602, 602, 1119, -1119,\n-            -1590, 1590, 644, -644, -872, 872, 349, -349,\n-            418, -418, 329, -329, -156, 156, -75, 75,\n-            817, -817, 1097, -1097, 603, -603, 610, -610,\n-            1322, -1322, -1285, 1285, -1465, 1465, 384, -384,\n-            -1215, 1215, -136, 136, 1218, -1218, -1335, 1335,\n-            -874, 874, 220, -220, -1187, 1187, 1670, 1659,\n-            -1185, 1185, -1530, 1530, -1278, 1278, 794, -794,\n-            -1510, 1510, -854, 854, -870, 870, 478, -478,\n-            -108, 108, -308, 308, 996, -996, 991, -991,\n-            958, -958, -1460, 1460, 1522, -1522, 1628, -1628\n-    };\n-\n@@ -502,1 +240,1 @@\n-            kPkePrivateKey.length, encapsKey.length);\n+                kPkePrivateKey.length, encapsKey.length);\n@@ -537,1 +275,1 @@\n-            randomMessage, randomCoins);\n+                randomMessage, randomCoins);\n@@ -567,1 +305,1 @@\n-            kPkePrivateKeyBytes.length);\n+                kPkePrivateKeyBytes.length);\n@@ -681,2 +419,2 @@\n-            new K_PKE_EncryptionKey(pkEncoded),\n-            new K_PKE_DecryptionKey(skEncoded));\n+                new K_PKE_EncryptionKey(pkEncoded),\n+                new K_PKE_DecryptionKey(skEncoded));\n@@ -972,5 +710,3 @@\n-    static void implMlKemNtt(short[] poly, short[] ntt_zetas) {\n-        implMlKemNttJava(poly);\n-    }\n-\n-    private static void implMlKemNttJava(short[] poly) {\n+    \/\/ The elements of poly should be in the range [-ML_KEM_Q, ML_KEM_Q]\n+    \/\/ The elements of poly at return will be in the range of [0, ML_KEM_Q]\n+    private void mlKemNTT(short[] poly) {\n@@ -985,6 +721,0 @@\n-    }\n-\n-    \/\/ The elements of poly should be in the range [-ML_KEM_Q, ML_KEM_Q]\n-    \/\/ The elements of poly at return will be in the range of [0, ML_KEM_Q]\n-    private void mlKemNTT(short[] poly) {\n-        implMlKemNtt(poly, MONT_ZETAS_FOR_VECTOR_NTT_ARR);\n@@ -994,5 +724,3 @@\n-    static void implMlKemInverseNtt(short[] poly, short[] zetas) {\n-        implMlKemInverseNttJava(poly);\n-    }\n-\n-    private static void implMlKemInverseNttJava(short[] poly) {\n+    \/\/ Works in place, but also returns its (modified) input so that it can\n+    \/\/ be used in expressions\n+    private short[] mlKemInverseNTT(short[] poly) {\n@@ -1007,6 +735,0 @@\n-    }\n-\n-    \/\/ Works in place, but also returns its (modified) input so that it can\n-    \/\/ be used in expressions\n-    private short[] mlKemInverseNTT(short[] poly) {\n-        implMlKemInverseNtt(poly, MONT_ZETAS_FOR_VECTOR_INVERSE_NTT_ARR);\n@@ -1103,8 +825,4 @@\n-    static void implMlKemNttMult(short[] result, short[] ntta, short[] nttb,\n-                                short[] zetas) {\n-        implMlKemNttMultJava(result, ntta, nttb);\n-    }\n-\n-    private static void implMlKemNttMultJava(short[] result,\n-                                             short[] ntta, short[] nttb) {\n-\n+    \/\/ Multiplies two polynomials represented in the NTT domain.\n+    \/\/ The result is a representation of the product still in the NTT domain.\n+    \/\/ The coefficients in the result are in the range (-ML_KEM_Q, ML_KEM_Q).\n+    private void nttMult(short[] result, short[] ntta, short[] nttb) {\n@@ -1124,7 +842,0 @@\n-    \/\/ Multiplies two polynomials represented in the NTT domain.\n-    \/\/ The result is a representation of the product still in the NTT domain.\n-    \/\/ The coefficients in the result are in the range (-ML_KEM_Q, ML_KEM_Q).\n-    private void nttMult(short[] result, short[] ntta, short[] nttb) {\n-        implMlKemNttMult(result, ntta, nttb, MONT_ZETAS_FOR_VECTOR_NTT_MULT_ARR);\n-    }\n-\n@@ -1145,11 +856,0 @@\n-    static void implMlKemAddPoly(short[] result, short[] a, short[] b) {\n-        implMlKemAddPolyJava(result, a, b);\n-    }\n-\n-    private static void implMlKemAddPolyJava(short[] result, short[] a, short[] b) {\n-        for (int m = 0; m < ML_KEM_N; m++) {\n-            int r = a[m] + b[m] + ML_KEM_Q; \/\/ This makes r > -ML_KEM_Q\n-            result[m] = (short) r;\n-        }\n-    }\n-\n@@ -1162,10 +862,0 @@\n-        implMlKemAddPoly(a, a, b);\n-    }\n-\n-    static void implMlKemAddPoly(short[] result, short[] a, short[] b, short[] c) {\n-        implMlKemAddPolyJava(result, a, b, c);\n-    }\n-\n-    private static void implMlKemAddPolyJava(short[] result, short[] a,\n-                                             short[] b, short[] c) {\n-\n@@ -1173,2 +863,2 @@\n-            int r = a[m] + b[m] + c[m] + 2 * ML_KEM_Q; \/\/ This makes r > - ML_KEM_Q\n-            result[m] = (short) r;\n+            int r = a[m] + b[m] + ML_KEM_Q; \/\/ This makes r > -ML_KEM_Q\n+            a[m] = (short) r;\n@@ -1184,1 +874,4 @@\n-        implMlKemAddPoly(a, a, b, c);\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            int r = a[m] + b[m] + c[m] + 2 * ML_KEM_Q; \/\/ This makes r > - ML_KEM_Q\n+            a[m] = (short) r;\n+        }\n@@ -1307,17 +1000,0 @@\n-    private static void implMlKem12To16(byte[] condensed, int index,\n-                                        short[] parsed, int parsedLength) {\n-\n-        implMlKem12To16Java(condensed, index, parsed, parsedLength);\n-    }\n-\n-    private static void implMlKem12To16Java(byte[] condensed, int index,\n-                                            short[] parsed, int parsedLength) {\n-\n-        for (int i = 0; i < parsedLength * 3 \/ 2; i += 3) {\n-            parsed[(i \/ 3) * 2] = (short) ((condensed[i + index] & 0xff) +\n-                    256 * (condensed[i + index + 1] & 0xf));\n-            parsed[(i \/ 3) * 2 + 1] = (short) (((condensed[i + index + 1] >>> 4) & 0xf) +\n-                    16 * (condensed[i + index + 2] & 0xff));\n-        }\n-    }\n-\n@@ -1333,1 +1009,6 @@\n-        implMlKem12To16(condensed, index, parsed, parsedLength);\n+        for (int i = 0; i < parsedLength * 3 \/ 2; i += 3) {\n+            parsed[(i \/ 3) * 2] = (short) ((condensed[i + index] & 0xff) +\n+                    256 * (condensed[i + index + 1] & 0xf));\n+            parsed[(i \/ 3) * 2 + 1] = (short) (((condensed[i + index + 1] >>> 4) & 0xf) +\n+                    16 * (condensed[i + index + 2] & 0xff));\n+        }\n@@ -1474,12 +1155,0 @@\n-    static void implMlKemBarrettReduce(short[] coeffs) {\n-        implMlKemBarrettReduceJava(coeffs);\n-    }\n-\n-    private static void implMlKemBarrettReduceJava(short[] coeffs) {\n-        for (int m = 0; m < ML_KEM_N; m++) {\n-            int tmp = ((int) coeffs[m] * BARRETT_MULTIPLIER) >>\n-                    BARRETT_SHIFT;\n-            coeffs[m] = (short) (coeffs[m] - tmp * ML_KEM_Q);\n-        }\n-    }\n-\n@@ -1496,1 +1165,4 @@\n-        implMlKemBarrettReduce(poly);\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            int tmp = ((int) poly[m] * BARRETT_MULTIPLIER) >> BARRETT_SHIFT;\n+            poly[m] = (short) (poly[m] - tmp * ML_KEM_Q);\n+        }\n@@ -1506,2 +1178,2 @@\n-        int m = ((MONT_Q_INV_MOD_R * aLow) << (32 - MONT_R_BITS)) >>\n-                (32 - MONT_R_BITS); \/\/ signed low product\n+        \/\/ signed low product\n+        int m = ((MONT_Q_INV_MOD_R * aLow) << (32 - MONT_R_BITS)) >> (32 - MONT_R_BITS);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":33,"deletions":361,"binary":false,"changes":394,"status":"modified"},{"patch":"@@ -40,13 +40,0 @@\n-    static int name2int(String name) {\n-        if (name.endsWith(\"512\")) {\n-            return 512;\n-        } else if (name.endsWith(\"768\")) {\n-            return 768;\n-        } else if (name.endsWith(\"1024\")) {\n-            return 1024;\n-        } else {\n-            \/\/ should not happen\n-            throw new ProviderException(\"Unknown name \" + name);\n-        }\n-    }\n-\n@@ -167,11 +154,2 @@\n-\n-            byte[] decapsulateResult;\n-            try {\n-                decapsulateResult = mlKem.decapsulate(\n-                        new ML_KEM.ML_KEM_DecapsulationKey(\n-                            decapsulationKey), kpkeCipherText);\n-            } catch (DecapsulateException e) {\n-                throw new DecapsulateException(\"Decapsulate error\", e) ;\n-            }\n-\n-            return decapsulateResult;\n+            return mlKem.decapsulate(new ML_KEM.ML_KEM_DecapsulationKey(\n+                    decapsulationKey), kpkeCipherText);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Impls.java","additions":2,"deletions":24,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilePermission.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -1831,6 +1830,0 @@\n-    private boolean isCustomSubclass() {\n-        \/\/ Return true if this class is a custom subclass of ObjectInputStream\n-        return getClass().getClassLoader()\n-                    != ObjectInputStream.class.getClassLoader();\n-    }\n-\n@@ -1882,6 +1875,0 @@\n-                \/\/ ReflectUtil.checkProxyPackageAccess makes a test\n-                \/\/ equivalent to isCustomSubclass so there's no need\n-                \/\/ to condition this call to isCustomSubclass == true here.\n-                ReflectUtil.checkProxyPackageAccess(\n-                        getClass().getClassLoader(),\n-                        cl.getInterfaces());\n@@ -1957,1 +1944,0 @@\n-        final boolean checksRequired = isCustomSubclass();\n@@ -1961,2 +1947,0 @@\n-            } else if (checksRequired) {\n-                ReflectUtil.checkPackageAccess(cl);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -1173,6 +1172,0 @@\n-    private boolean isCustomSubclass() {\n-        \/\/ Return true if this class is a custom subclass of ObjectOutputStream\n-        return getClass().getClassLoader()\n-                   != ObjectOutputStream.class.getClassLoader();\n-    }\n-\n@@ -1196,3 +1189,0 @@\n-        if (isCustomSubclass()) {\n-            ReflectUtil.checkPackageAccess(cl);\n-        }\n@@ -1225,3 +1215,0 @@\n-        if (cl != null && isCustomSubclass()) {\n-            ReflectUtil.checkPackageAccess(cl);\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import java.security.AllPermission;\n@@ -62,1 +63,0 @@\n-import java.util.HashSet;\n@@ -92,1 +92,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -94,1 +93,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -2723,1 +2721,1 @@\n-            perms.add(SecurityConstants.ALL_PERMISSION);\n+            perms.add(new AllPermission());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -743,1 +742,1 @@\n-            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n+            var sizeString = System.getProperty(propertyName, \"16\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -85,5 +84,0 @@\n-    \/*\n-     * For Throwable to use StackWalker, set useNewThrowable to true.\n-     * Performance work and extensive testing is needed to replace the\n-     * VM built-in backtrace filled in Throwable with the StackWalker.\n-     *\/\n@@ -91,1 +85,1 @@\n-            \"true\".equals(GetPropertyAction.privilegedGetProperty(\"stackwalk.debug\"));\n+            \"true\".equals(System.getProperty(\"stackwalk.debug\"));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackStreamFactory.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -552,1 +552,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -790,1 +789,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -1413,1 +1414,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -1517,1 +1517,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2339,0 +2338,4 @@\n+            public Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers() {\n+                return VirtualThread.delayedTaskSchedulers();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -807,1 +806,1 @@\n-        String propValue = GetPropertyAction.privilegedGetProperty(\"jdk.traceVirtualThreadLocals\");\n+        String propValue = System.getProperty(\"jdk.traceVirtualThreadLocals\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadLocal.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Arrays;\n@@ -35,1 +36,0 @@\n-import java.util.concurrent.ForkJoinWorkerThread;\n@@ -41,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -195,0 +196,7 @@\n+    \/**\n+     * Returns a stream of the delayed task schedulers used to support timed operations.\n+     *\/\n+    static Stream<ScheduledExecutorService> delayedTaskSchedulers() {\n+        return Arrays.stream(DELAYED_TASK_SCHEDULERS);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -459,1 +459,3 @@\n-     * describe the possible return values of this method.\n+     * describe the possible return values of this method.  The return type is\n+     * {@code int} for consistency with union indicator items in other union\n+     * structures in the {@code class} file format.\n@@ -461,1 +463,1 @@\n-    char tag();\n+    int tag();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,6 +63,1 @@\n- * <p>\n- * Class transformation sample where code transformation is stateful:\n- * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"codeRelabeling\"}\n- * <p>\n- * Complex class instrumentation sample chaining multiple transformations:\n- * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"classInstrumentation\"}\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileTransform.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    byte tag();\n+    int tag();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PoolEntry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.classfile.components.ClassRemapper;\n-import java.lang.classfile.components.CodeLocalsShifter;\n-import java.lang.classfile.components.CodeRelabeler;\n@@ -36,2 +33,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.util.ArrayDeque;\n@@ -39,1 +34,0 @@\n-import java.util.Map;\n@@ -41,2 +35,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n@@ -329,76 +321,0 @@\n-    void codeRelabeling(ClassModel classModel) {\n-        \/\/ @start region=\"codeRelabeling\"\n-        byte[] newBytes = ClassFile.of().transformClass(classModel,\n-                ClassTransform.transformingMethodBodies(\n-                        CodeTransform.ofStateful(CodeRelabeler::of)));\n-        \/\/ @end\n-    }\n-\n-    \/\/ @start region=\"classInstrumentation\"\n-    byte[] classInstrumentation(ClassModel target, ClassModel instrumentor, Predicate<MethodModel> instrumentedMethodsFilter) {\n-        var instrumentorCodeMap = instrumentor.methods().stream()\n-                                              .filter(instrumentedMethodsFilter)\n-                                              .collect(Collectors.toMap(mm -> mm.methodName().stringValue() + mm.methodType().stringValue(), mm -> mm.code().orElseThrow()));\n-        var targetFieldNames = target.fields().stream().map(f -> f.fieldName().stringValue()).collect(Collectors.toSet());\n-        var targetMethods = target.methods().stream().map(m -> m.methodName().stringValue() + m.methodType().stringValue()).collect(Collectors.toSet());\n-        var instrumentorClassRemapper = ClassRemapper.of(Map.of(instrumentor.thisClass().asSymbol(), target.thisClass().asSymbol()));\n-        return ClassFile.of().transformClass(target,\n-                ClassTransform.transformingMethods(\n-                        instrumentedMethodsFilter,\n-                        (mb, me) -> {\n-                            if (me instanceof CodeModel targetCodeModel) {\n-                                var mm = targetCodeModel.parent().get();\n-                                \/\/instrumented methods code is taken from instrumentor\n-                                mb.transformCode(instrumentorCodeMap.get(mm.methodName().stringValue() + mm.methodType().stringValue()),\n-                                        \/\/all references to the instrumentor class are remapped to target class\n-                                        instrumentorClassRemapper.asCodeTransform()\n-                                        .andThen((codeBuilder, instrumentorCodeElement) -> {\n-                                            \/\/all invocations of target methods from instrumentor are inlined\n-                                            if (instrumentorCodeElement instanceof InvokeInstruction inv\n-                                                && target.thisClass().asInternalName().equals(inv.owner().asInternalName())\n-                                                && mm.methodName().stringValue().equals(inv.name().stringValue())\n-                                                && mm.methodType().stringValue().equals(inv.type().stringValue())) {\n-\n-                                                \/\/store stacked method parameters into locals\n-                                                var storeStack = new ArrayDeque<StoreInstruction>();\n-                                                int slot = 0;\n-                                                if (!mm.flags().has(AccessFlag.STATIC))\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n-                                                for (var pt : mm.methodTypeSymbol().parameterList()) {\n-                                                    var tk = TypeKind.from(pt);\n-                                                    storeStack.push(StoreInstruction.of(tk, slot));\n-                                                    slot += tk.slotSize();\n-                                                }\n-                                                storeStack.forEach(codeBuilder::with);\n-\n-                                                \/\/inlined target locals must be shifted based on the actual instrumentor locals\n-                                                codeBuilder.block(inlinedBlockBuilder -> inlinedBlockBuilder\n-                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n-                                                        .andThen(CodeRelabeler.of())\n-                                                        .andThen((innerBuilder, shiftedTargetCode) -> {\n-                                                            \/\/returns must be replaced with jump to the end of the inlined method\n-                                                            if (shiftedTargetCode instanceof ReturnInstruction)\n-                                                                innerBuilder.goto_(inlinedBlockBuilder.breakLabel());\n-                                                            else\n-                                                                innerBuilder.with(shiftedTargetCode);\n-                                                        })));\n-                                            } else\n-                                                codeBuilder.with(instrumentorCodeElement);\n-                                        }));\n-                            } else\n-                                mb.with(me);\n-                        })\n-                .andThen(ClassTransform.endHandler(clb ->\n-                    \/\/remaining instrumentor fields and methods are injected at the end\n-                    clb.transform(instrumentor,\n-                            ClassTransform.dropping(cle ->\n-                                    !(cle instanceof FieldModel fm\n-                                            && !targetFieldNames.contains(fm.fieldName().stringValue()))\n-                                    && !(cle instanceof MethodModel mm\n-                                            && !ConstantDescs.INIT_NAME.equals(mm.methodName().stringValue())\n-                                            && !targetMethods.contains(mm.methodName().stringValue() + mm.methodType().stringValue())))\n-                            \/\/and instrumentor class references remapped to target class\n-                            .andThen(instrumentorClassRemapper)))));\n-    }\n-    \/\/ @end\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -855,2 +855,0 @@\n-         * <p>\n-         * This linker option can not be combined with {@link #critical}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1280,3 +1280,3 @@\n-     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (B + 1)}, where\n-     *         {@code B} is the size, in bytes, of the string encoded using UTF-8 charset\n-     *         {@code str.getBytes(StandardCharsets.UTF_8).length})\n+     * @throws IndexOutOfBoundsException if no string terminator (e.g. {@code '\\0'}) is\n+     *         present in this segment between the given {@code offset} and the end of\n+     *         this segment.\n@@ -1318,8 +1318,5 @@\n-     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (B + N)}, where:\n-     *         <ul>\n-     *             <li>{@code B} is the size, in bytes, of the string encoded using the\n-     *             provided charset (e.g. {@code str.getBytes(charset).length});<\/li>\n-     *             <li>{@code N} is the size (in bytes) of the terminator char according\n-     *             to the provided charset. For instance, this is 1 for\n-     *             {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n-     *         <\/ul>\n+     * @throws IndexOutOfBoundsException if no string terminator (e.g. {@code '\\0'}) is\n+     *         present in this segment between the given {@code offset} and the end of\n+     *         this segment. The byte size of the string terminator depends on the\n+     *         selected {@code charset}. For instance, this is 1 for\n+     *         {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -581,1 +581,0 @@\n-        @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-                    clb.withFlags(ACC_ABSTRACT | ACC_SUPER)\n+                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -35,1 +34,0 @@\n-import java.util.Properties;\n@@ -710,1 +708,0 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n@@ -712,1 +709,1 @@\n-                props.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n+                System.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1315,12 +1315,12 @@\n-    ModuleDescriptor(String name,\n-                     Version version,\n-                     Set<Modifier> modifiers,\n-                     Set<Requires> requires,\n-                     Set<Exports> exports,\n-                     Set<Opens> opens,\n-                     Set<String> uses,\n-                     Set<Provides> provides,\n-                     Set<String> packages,\n-                     String mainClass,\n-                     int hashCode,\n-                     boolean unused) {\n+    private ModuleDescriptor(String name,\n+                             Version version,\n+                             Set<Modifier> modifiers,\n+                             Set<Requires> requires,\n+                             Set<Exports> exports,\n+                             Set<Opens> opens,\n+                             Set<String> uses,\n+                             Set<Provides> provides,\n+                             Set<String> packages,\n+                             String mainClass,\n+                             int hashCode,\n+                             boolean unused) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -987,1 +986,1 @@\n-    private static final String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;\n+    private static final String PROXY_PACKAGE_PREFIX = \"com.sun.proxy\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+ * <p>Unless otherwise specified, passing a {@code null} argument to any method\n+ * in this class will cause a {@link NullPointerException} to be thrown.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/net\/IDN.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -557,0 +557,4 @@\n+        \/\/ Empty strings are not parseable\n+        if (addressLiteral.isEmpty()) {\n+            return null;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6Address.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1648,0 +1648,3 @@\n+        if (ipAddressLiteral.isEmpty()) {\n+            throw IPAddressUtil.invalidIpAddressLiteral(ipAddressLiteral);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,1 @@\n-     * Package private constructor. Can't be built directly, instances are\n-     * obtained through the NetworkInterface class.\n+     * This constructor is called via JNI in NetworkInterface.c\n@@ -48,1 +47,1 @@\n-    InterfaceAddress() {\n+    private InterfaceAddress() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/InterfaceAddress.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+        assert address instanceof InetSocketAddress;\n@@ -467,1 +468,1 @@\n-            if (localAddr != null)\n+            if (localAddr != null) {\n@@ -469,6 +470,0 @@\n-            connect(address);\n-        } catch (IOException | IllegalArgumentException e) {\n-            try {\n-                close();\n-            } catch (IOException ce) {\n-                e.addSuppressed(ce);\n@@ -476,1 +471,4 @@\n-            throw e;\n+            connect(address);\n+        } catch (Throwable throwable) {\n+            closeSuppressingExceptions(throwable);\n+            throw throwable;\n@@ -575,0 +573,4 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n+     * connection cannot be established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -593,0 +595,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -609,0 +613,5 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n+     * connection cannot be established, or the timeout expires before the\n+     * connection is established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -629,0 +638,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -648,1 +659,1 @@\n-            throw new SocketException(\"already connected\");\n+            throw new SocketException(\"Already connected\");\n@@ -653,0 +664,6 @@\n+        if (epoint.isUnresolved()) {\n+            var uhe = new UnknownHostException(epoint.getHostName());\n+            closeSuppressingExceptions(uhe);\n+            throw uhe;\n+        }\n+\n@@ -654,1 +671,0 @@\n-        int port = epoint.getPort();\n@@ -659,9 +675,3 @@\n-        } catch (SocketTimeoutException e) {\n-            throw e;\n-        } catch (InterruptedIOException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n-            }\n-            throw e;\n+        } catch (IOException error) {\n+            closeSuppressingExceptions(error);\n+            throw error;\n@@ -1593,0 +1603,8 @@\n+    private void closeSuppressingExceptions(Throwable parentException) {\n+        try {\n+            close();\n+        } catch (IOException exception) {\n+            parentException.addSuppressed(exception);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":37,"deletions":19,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -214,1 +213,2 @@\n-    private static final boolean trustNameService = GetBooleanAction.privilegedGetProperty(\"sun.net.trustNameService\");\n+    private static final boolean trustNameService =\n+            Boolean.getBoolean(\"sun.net.trustNameService\");\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1391,1 +1391,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLConnection.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-            Iterator<AsynchronousChannelProvider> i = sl.iterator();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AsynchronousChannelProvider.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1512,1 +1512,1 @@\n-    private static class FileTypeDetectors{\n+    private static class FileTypeDetectors {\n@@ -1525,7 +1525,5 @@\n-            List<FileTypeDetector> list = new ArrayList<>();\n-            ServiceLoader<FileTypeDetector> loader = ServiceLoader\n-                .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n-            for (FileTypeDetector detector: loader) {\n-                list.add(detector);\n-            }\n-            return list;\n+            return ServiceLoader.load(FileTypeDetector.class,\n+                                      ClassLoader.getSystemClassLoader())\n+                .stream()\n+                .map(ServiceLoader.Provider::get)\n+                .toList();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,8 +47,0 @@\n-    \/\/ isPrivileged and isAuthorized are referenced by the VM - do not remove\n-    \/\/ or change their names\n-    private boolean isPrivileged;\n-    private boolean isAuthorized = false;\n-\n-    \/\/ Note: This field is directly used by the virtual machine\n-    \/\/ native codes. Don't touch it.\n-    private AccessControlContext privilegedContext;\n","filename":"src\/java.base\/share\/classes\/java\/security\/AccessControlContext.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-     *          current execution thread, up to the most recent\n-     *          privileged {@code ProtectionDomain}.\n+     *          current execution thread.\n@@ -58,2 +57,0 @@\n-     *          ProtectionDomains may be inherited from a parent thread,\n-     *          or from a privileged {@code AccessControlContext}.\n","filename":"src\/java.base\/share\/classes\/java\/security\/DomainCombiner.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-        check(\"setIdentityPublicKey\");\n@@ -194,1 +193,0 @@\n-        check(\"setIdentityInfo\");\n@@ -224,2 +222,0 @@\n-        check(\"addIdentityCertificate\");\n-\n@@ -263,1 +259,0 @@\n-        check(\"removeIdentityCertificate\");\n@@ -361,1 +356,0 @@\n-        check(\"printIdentity\");\n@@ -432,7 +426,0 @@\n-\n-    private static void check(String directive) {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSecurityAccess(directive);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/Identity.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -79,7 +79,1 @@\n-        String classname = AccessController.doPrivileged(\n-                                new PrivilegedAction<>() {\n-            public String run() {\n-                return Security.getProperty(\"system.scope\");\n-            }\n-        });\n-\n+        String classname = Security.getProperty(\"system.scope\");\n@@ -156,1 +150,0 @@\n-        check(\"setSystemScope\");\n@@ -244,8 +237,0 @@\n-\n-    private static void check(String directive) {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSecurityAccess(directive);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/IdentityScope.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -990,3 +990,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String kstype = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n-            Security.getProperty(KEYSTORE_TYPE));\n+        String kstype = Security.getProperty(KEYSTORE_TYPE);\n@@ -1996,3 +1994,1 @@\n-            @SuppressWarnings(\"removal\")\n-            var acc = AccessController.getContext();\n-            return new FileBuilder(type, provider, file, protection, acc);\n+            return new FileBuilder(type, provider, file, protection);\n@@ -2051,2 +2047,0 @@\n-            @SuppressWarnings(\"removal\")\n-            private final AccessControlContext context;\n@@ -2059,2 +2053,1 @@\n-                    ProtectionParameter protection,\n-                    @SuppressWarnings(\"removal\") AccessControlContext context) {\n+                    ProtectionParameter protection) {\n@@ -2065,1 +2058,0 @@\n-                this.context = context;\n@@ -2068,1 +2060,0 @@\n-            @SuppressWarnings(\"removal\")\n@@ -2079,6 +2070,4 @@\n-                PrivilegedExceptionAction<KeyStore> action =\n-                        new PrivilegedExceptionAction<KeyStore>() {\n-                    public KeyStore run() throws Exception {\n-                        if (!(protection instanceof CallbackHandlerProtection)) {\n-                            return run0();\n-                        }\n+                try {\n+                    if (!(protection instanceof CallbackHandlerProtection)) {\n+                        keyStore = getKeyStore0();\n+                    } else {\n@@ -2091,1 +2080,2 @@\n-                                return run0();\n+                                keyStore = getKeyStore0();\n+                                break;\n@@ -2101,3 +2091,7 @@\n-                    public KeyStore run0() throws Exception {\n-                        KeyStore ks;\n-                        char[] password;\n+                } catch (Exception e) {\n+                    oldException = e;\n+                    throw new KeyStoreException\n+                        (\"KeyStore instantiation failed\", oldException);\n+                }\n+                return keyStore;\n+            }\n@@ -2105,21 +2099,3 @@\n-                        \/\/ Acquire keystore password\n-                        if (protection instanceof PasswordProtection) {\n-                            password =\n-                                ((PasswordProtection)protection).getPassword();\n-                            keyProtection = protection;\n-                        } else {\n-                            CallbackHandler handler =\n-                                ((CallbackHandlerProtection)protection)\n-                                    .getCallbackHandler();\n-                            PasswordCallback callback = new PasswordCallback\n-                                (\"Password for keystore \" + file.getName(),\n-                                    false);\n-                            handler.handle(new Callback[] {callback});\n-                            password = callback.getPassword();\n-                            if (password == null) {\n-                                throw new KeyStoreException(\"No password\" +\n-                                                            \" provided\");\n-                            }\n-                            callback.clearPassword();\n-                            keyProtection = new PasswordProtection(password);\n-                        }\n+            private KeyStore getKeyStore0() throws Exception {\n+                KeyStore ks;\n+                char[] password;\n@@ -2127,16 +2103,32 @@\n-                        if (type.isEmpty()) {\n-                            \/\/ Instantiate keystore and load keystore data\n-                            ks = KeyStore.getInstance(file, password);\n-                        } else {\n-                            \/\/ Instantiate keystore\n-                            if (provider == null) {\n-                                ks = KeyStore.getInstance(type);\n-                            } else {\n-                                ks = KeyStore.getInstance(type, provider);\n-                            }\n-                            \/\/ Load keystore data\n-                            try (InputStream in = new FileInputStream(file)) {\n-                                ks.load(in, password);\n-                            }\n-                        }\n-                        return ks;\n+                \/\/ Acquire keystore password\n+                if (protection instanceof PasswordProtection) {\n+                    password = ((PasswordProtection)protection).getPassword();\n+                    keyProtection = protection;\n+                } else {\n+                    CallbackHandler handler =\n+                        ((CallbackHandlerProtection)protection)\n+                            .getCallbackHandler();\n+                    PasswordCallback callback = new PasswordCallback\n+                        (\"Password for keystore \" + file.getName(), false);\n+                    handler.handle(new Callback[] {callback});\n+                    password = callback.getPassword();\n+                    if (password == null) {\n+                        throw new KeyStoreException(\"No password\" + \" provided\");\n+                    }\n+                    callback.clearPassword();\n+                    keyProtection = new PasswordProtection(password);\n+                }\n+\n+                if (type.isEmpty()) {\n+                    \/\/ Instantiate keystore and load keystore data\n+                    ks = KeyStore.getInstance(file, password);\n+                } else {\n+                    \/\/ Instantiate keystore\n+                    if (provider == null) {\n+                        ks = KeyStore.getInstance(type);\n+                    } else {\n+                        ks = KeyStore.getInstance(type, provider);\n+                    }\n+                    \/\/ Load keystore data\n+                    try (InputStream in = new FileInputStream(file)) {\n+                        ks.load(in, password);\n@@ -2144,8 +2136,0 @@\n-                };\n-                try {\n-                    keyStore = AccessController.doPrivileged(action, context);\n-                    return keyStore;\n-                } catch (PrivilegedActionException e) {\n-                    oldException = e.getCause();\n-                    throw new KeyStoreException\n-                        (\"KeyStore instantiation failed\", oldException);\n@@ -2153,0 +2137,1 @@\n+                return ks;\n@@ -2198,2 +2183,0 @@\n-            @SuppressWarnings(\"removal\")\n-            final AccessControlContext context = AccessController.getContext();\n@@ -2204,4 +2187,8 @@\n-                private final PrivilegedExceptionAction<KeyStore> action\n-                        = new PrivilegedExceptionAction<>() {\n-\n-                    public KeyStore run() throws Exception {\n+                public synchronized KeyStore getKeyStore()\n+                        throws KeyStoreException {\n+                    if (oldException != null) {\n+                        throw new KeyStoreException\n+                            (\"Previous KeyStore instantiation failed\",\n+                             oldException);\n+                    }\n+                    try {\n@@ -2240,15 +2227,1 @@\n-                    }\n-                };\n-\n-                @SuppressWarnings(\"removal\")\n-                public synchronized KeyStore getKeyStore()\n-                        throws KeyStoreException {\n-                    if (oldException != null) {\n-                        throw new KeyStoreException\n-                            (\"Previous KeyStore instantiation failed\",\n-                             oldException);\n-                    }\n-                    try {\n-                        return AccessController.doPrivileged(action, context);\n-                    } catch (PrivilegedActionException e) {\n-                        Throwable cause = e.getCause();\n+                    } catch (Exception e) {\n@@ -2256,1 +2229,1 @@\n-                            (\"KeyStore instantiation failed\", cause);\n+                            (\"KeyStore instantiation failed\", e);\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyStore.java","additions":62,"deletions":89,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- *       {@linkplain getPolicy getPolicy} method has been changed to always\n+ *       {@linkplain #getPolicy getPolicy} method has been changed to always\n","filename":"src\/java.base\/share\/classes\/java\/security\/Policy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * A computation to be performed with privileges enabled.  The computation is\n- * performed by invoking {@code AccessController.doPrivileged} on the\n+ * A computation to be performed by invoking\n+ * {@code AccessController.doPrivileged} on the\n@@ -47,1 +47,1 @@\n-     * {@code AccessController.doPrivileged} after enabling privileges.\n+     * {@code AccessController.doPrivileged}.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PrivilegedAction.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-     * Returns the exception thrown by the privileged computation that\n+     * Returns the exception thrown by the computation that\n@@ -74,1 +74,1 @@\n-     * @return the exception thrown by the privileged computation that\n+     * @return the exception thrown by the computation that\n@@ -93,1 +93,1 @@\n-     * The exception thrown by the privileged computation that resulted\n+     * The exception thrown by the computation that resulted\n","filename":"src\/java.base\/share\/classes\/java\/security\/PrivilegedActionException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * A computation to be performed with privileges enabled, that throws one or\n- * more checked exceptions.  The computation is performed by invoking\n+ * A computation to be performed that throws one or more checked exceptions.\n+ * The computation is performed by invoking\n@@ -50,1 +50,1 @@\n-     * {@code AccessController.doPrivileged} after enabling privileges.\n+     * {@code AccessController.doPrivileged}.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PrivilegedExceptionAction.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.internal.access.JavaSecurityAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n@@ -54,33 +51,0 @@\n-    private static class JavaSecurityAccessImpl implements JavaSecurityAccess {\n-\n-        private JavaSecurityAccessImpl() {\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        @Override\n-        public <T> T doIntersectionPrivilege(\n-                PrivilegedAction<T> action,\n-                final AccessControlContext stack,\n-                final AccessControlContext context) {\n-            if (action == null) {\n-                throw new NullPointerException();\n-            }\n-\n-            return AccessController.doPrivileged(action);\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        @Override\n-        public <T> T doIntersectionPrivilege(\n-                PrivilegedAction<T> action,\n-                AccessControlContext context) {\n-            return doIntersectionPrivilege(action,\n-                AccessController.getContext(), context);\n-        }\n-    }\n-\n-    static {\n-        \/\/ Set up JavaSecurityAccess in SharedSecrets\n-        SharedSecrets.setJavaSecurityAccess(new JavaSecurityAccessImpl());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/ProtectionDomain.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -348,6 +348,0 @@\n-    \/*\n-     * override the following methods to ensure that provider\n-     * information can only be changed if the caller has the appropriate\n-     * permissions.\n-     *\/\n-\n@@ -362,1 +356,1 @@\n-        check(\"clearProviderProperties.\"+name);\n+        checkInitialized();\n@@ -379,1 +373,1 @@\n-        check(\"putProviderProperty.\"+name);\n+        checkInitialized();\n@@ -397,1 +391,1 @@\n-        check(\"putProviderProperty.\"+name);\n+        checkInitialized();\n@@ -464,1 +458,1 @@\n-        check(\"putProviderProperty.\"+name);\n+        checkInitialized();\n@@ -481,1 +475,1 @@\n-        check(\"putProviderProperty.\"+name);\n+        checkInitialized();\n@@ -497,1 +491,1 @@\n-        check(\"removeProviderProperty.\"+name);\n+        checkInitialized();\n@@ -512,1 +506,1 @@\n-        check(\"removeProviderProperty.\"+name);\n+        checkInitialized();\n@@ -528,1 +522,1 @@\n-        check(\"putProviderProperty.\" + name);\n+        checkInitialized();\n@@ -543,1 +537,1 @@\n-        check(\"putProviderProperty.\" + name);\n+        checkInitialized();\n@@ -561,1 +555,1 @@\n-        check(\"putProviderProperty.\" + name);\n+        checkInitialized();\n@@ -578,2 +572,1 @@\n-        check(\"putProviderProperty.\" + name);\n-        check(\"removeProviderProperty.\" + name);\n+        checkInitialized();\n@@ -597,2 +590,1 @@\n-        check(\"putProviderProperty.\" + name);\n-        check(\"removeProviderProperty.\" + name);\n+        checkInitialized();\n@@ -616,2 +608,1 @@\n-        check(\"putProviderProperty.\" + name);\n-        check(\"removeProviderProperty.\" + name);\n+        checkInitialized();\n@@ -638,2 +629,1 @@\n-        check(\"putProviderProperty.\" + name);\n-        check(\"removeProviderProperty.\" + name);\n+        checkInitialized();\n@@ -697,9 +687,0 @@\n-    private void check(String directive) {\n-        checkInitialized();\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSecurityAccess(directive);\n-        }\n-    }\n-\n@@ -792,2 +773,0 @@\n-     * Internal method to be called AFTER the security check has been\n-     * performed.\n@@ -1242,1 +1221,1 @@\n-        check(\"putProviderProperty.\" + name);\n+        checkInitialized();\n@@ -1306,1 +1285,1 @@\n-        \/\/ use super() to avoid permission check and other processing\n+        \/\/ use super() to avoid other processing\n@@ -1324,1 +1303,1 @@\n-        \/\/ use super() to avoid permission check and other processing\n+        \/\/ use super() to avoid other processing\n@@ -1349,1 +1328,1 @@\n-        check(\"removeProviderProperty.\" + name);\n+        checkInitialized();\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":18,"deletions":39,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -965,5 +965,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String property = AccessController.doPrivileged(\n-                (PrivilegedAction<String>) () -> Security.getProperty(\n-                    \"securerandom.strongAlgorithms\"));\n-\n+        String property = Security.getProperty(\"securerandom.strongAlgorithms\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -315,8 +315,1 @@\n-        \/\/ doPrivileged here because there are multiple\n-        \/\/ things in initialize that might require privs.\n-        \/\/ (the FileInputStream call and the File.exists call, etc)\n-        @SuppressWarnings(\"removal\")\n-        var dummy = AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n-            initialize();\n-            return null;\n-        });\n+        initialize();\n@@ -478,2 +471,0 @@\n-        String providerName = provider.getName();\n-        checkInsertProvider(providerName);\n@@ -486,1 +477,1 @@\n-        return newList.getIndex(providerName) + 1;\n+        return newList.getIndex(provider.getName()) + 1;\n@@ -530,1 +521,0 @@\n-        check(\"removeProvider.\" + name);\n@@ -825,1 +815,0 @@\n-        check(\"getProperty.\" + key);\n@@ -848,1 +837,0 @@\n-        check(\"setProperty.\" + key);\n@@ -862,26 +850,0 @@\n-    private static void check(String directive) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSecurityAccess(directive);\n-        }\n-    }\n-\n-    private static void checkInsertProvider(String name) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            try {\n-                security.checkSecurityAccess(\"insertProvider\");\n-            } catch (SecurityException se1) {\n-                try {\n-                    security.checkSecurityAccess(\"insertProvider.\" + name);\n-                } catch (SecurityException se2) {\n-                    \/\/ throw first exception, but add second to suppressed\n-                    se1.addSuppressed(se2);\n-                    throw se1;\n-                }\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-        check(\"getSignerPrivateKey\");\n@@ -118,2 +117,1 @@\n-        check(\"setSignerKeyPair\");\n-        final PublicKey pub = pair.getPublic();\n+        PublicKey pub = pair.getPublic();\n@@ -125,11 +123,1 @@\n-        try {\n-            AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<>() {\n-                public Void run() throws KeyManagementException {\n-                    setPublicKey(pub);\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException pae) {\n-            throw (KeyManagementException) pae.getException();\n-        }\n+        setPublicKey(pub);\n@@ -159,8 +147,0 @@\n-\n-    private static void check(String directive) {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSecurityAccess(directive);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signer.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import java.text.DateFormat;\n+import java.text.NumberFormat;\n@@ -73,9 +73,10 @@\n- * A {@code Locale} object represents a specific geographical, political,\n- * or cultural region. An operation that requires a {@code Locale} to perform\n- * its task is called <em>locale-sensitive<\/em> and uses the {@code Locale}\n- * to tailor information for the user. For example, displaying a number\n- * is a locale-sensitive operation&mdash; the number should be formatted\n- * according to the customs and conventions of the user's native country,\n- * region, or culture.\n- *\n- * <p> The {@code Locale} class implements IETF BCP 47 which is composed of\n+ * A {@code Locale} represents a specific geographical, political,\n+ * or cultural region. An API that requires a {@code Locale} to perform\n+ * its task is <dfn>{@index \"locale-sensitive\"}<\/dfn> and uses the {@code Locale}\n+ * to tailor information for the user. These <em>locale-sensitive<\/em> APIs\n+ * are principally in the <i>java.text<\/i> and <i>java.util<\/i> packages.\n+ * For example, displaying a number is a <em>locale-sensitive<\/em> operation&mdash;\n+ * the number should be formatted according to the customs and conventions of the\n+ * user's native country, region, or culture.\n+ *\n+ * <p>The {@code Locale} class implements IETF BCP 47 which is composed of\n@@ -86,4 +87,23 @@\n- * exchange.\n- *\n- * <p> A {@code Locale} object logically consists of the fields\n- * described below.\n+ * exchange. Each {@code Locale} is associated with locale data which is provided\n+ * by the Java runtime environment or any deployed {@link\n+ * java.util.spi.LocaleServiceProvider LocaleServiceProvider} implementations.\n+ * The locale data provided by the Java runtime environment may vary by release.\n+ *\n+ * <h2 id=\"loc_comp\">Locale Composition<\/h2>\n+ * <p> A {@code Locale} is composed of the bolded fields described below; note that a\n+ * {@code Locale} need not have all such fields. For example, {@link\n+ * Locale#ENGLISH Locale.ENGLISH} is only comprised of the <em>language<\/em> field.\n+ * In contrast, a {@code Locale} such as the one returned by {@code\n+ * Locale.forLanguageTag(\"en-Latn-US-POSIX-u-nu-latn\")} would be comprised of all\n+ * the fields below. This particular {@code Locale} would represent English in\n+ * the United States using the Latin script and numerics for use in POSIX\n+ * environments.\n+ * <p>\n+ * {@code Locale} implements IETF BCP 47 and any deviations should be observed\n+ * by the comments prefixed by <em>\"BCP 47 deviation:\"<\/em>.\n+ * <a href=\"https:\/\/tools.ietf.org\/html\/rfc5646\">RFC 5646<\/a>\n+ * combines subtags from various ISO (639, 3166, 15924) standards which are also\n+ * included in the composition of {@code Locale}.\n+ * Additionally, the full list of valid codes for each field can be found in the\n+ * <a href=\"https:\/\/www.iana.org\/assignments\/language-subtag-registry\/language-subtag-registry\">\n+ * IANA Language Subtag Registry<\/a> (e.g. search for \"Type: region\").\n@@ -93,3 +113,2 @@\n- *\n- *   <dd>ISO 639 alpha-2 or alpha-3 language code, or registered\n- *   language subtags up to 8 alpha letters (for future enhancements).\n+ *   <dd> ISO 639 alpha-2\/alpha-3 language code or a registered\n+ *   language subtag up to 8 alpha letters (for future enhancements).\n@@ -97,3 +116,3 @@\n- *   alpha-2 code must be used.  You can find a full list of valid\n- *   language codes in the IANA Language Subtag Registry (search for\n- *   \"Type: language\").  The language field is case insensitive, but\n+ *   alpha-2 code must be used.<\/dd>\n+ *\n+ *   <dd> <em>Case convention:<\/em> {@code language} is case insensitive, but\n@@ -102,5 +121,4 @@\n- *   <dd>Well-formed language values have the form\n- *   <code>[a-zA-Z]{2,8}<\/code>.  Note that this is not the full\n- *   BCP47 language production, since it excludes extlang.  They are\n- *   not needed since modern three-letter language codes replace\n- *   them.<\/dd>\n+ *   <dd> <em>Syntax:<\/em> Well-formed {@code language} values have the form {@code [a-zA-Z]{2,8}}.<\/dd>\n+ *   <dd> <em> BCP 47 deviation:<\/em> this is not the full BCP 47 language production, since it excludes\n+ *   <a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc5646#section-2.2.2\">extlang<\/a>\n+ *   (as modern three-letter language codes are preferred).<\/dd>\n@@ -108,1 +126,1 @@\n- *   <dd>Example: \"en\" (English), \"ja\" (Japanese), \"kok\" (Konkani)<\/dd>\n+ *   <dd> <em>Example:<\/em> \"en\" (English), \"ja\" (Japanese), \"kok\" (Konkani)<\/dd>\n@@ -112,3 +130,3 @@\n- *   <dd>ISO 15924 alpha-4 script code.  You can find a full list of\n- *   valid script codes in the IANA Language Subtag Registry (search\n- *   for \"Type: script\").  The script field is case insensitive, but\n+ *   <dd> ISO 15924 alpha-4 script code.<\/dd>\n+ *\n+ *   <dd> <em>Case convention:<\/em> {@code script} is case insensitive, but\n@@ -119,2 +137,2 @@\n- *   <dd>Well-formed script values have the form\n- *   <code>[a-zA-Z]{4}<\/code><\/dd>\n+ *   <dd> <em>Syntax:<\/em> Well-formed {@code script} values have the form {@code\n+ *   [a-zA-Z]{4}}<\/dd>\n@@ -122,1 +140,1 @@\n- *   <dd>Example: \"Latn\" (Latin), \"Cyrl\" (Cyrillic)<\/dd>\n+ *   <dd> <em>Example:<\/em> \"Latn\" (Latin), \"Cyrl\" (Cyrillic)<\/dd>\n@@ -126,4 +144,3 @@\n- *   <dd>ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.\n- *   You can find a full list of valid country and region codes in the\n- *   IANA Language Subtag Registry (search for \"Type: region\").  The\n- *   country (region) field is case insensitive, but\n+ *   <dd> ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.<\/dd>\n+ *\n+ *   <dd> <em>Case convention:<\/em> {@code country (region)} is case insensitive, but\n@@ -132,2 +149,2 @@\n- *   <dd>Well-formed country\/region values have\n- *   the form <code>[a-zA-Z]{2} | [0-9]{3}<\/code><\/dd>\n+ *   <dd> <em>Syntax:<\/em> Well-formed {@code country (region)} values have the form {@code\n+ *   [a-zA-Z]{2} | [0-9]{3}}<\/dd>\n@@ -135,1 +152,1 @@\n- *   <dd>Example: \"US\" (United States), \"FR\" (France), \"029\"\n+ *   <dd> <em>Example:<\/em> \"US\" (United States), \"FR\" (France), \"029\"\n@@ -140,8 +157,4 @@\n- *   <dd>Any arbitrary value used to indicate a variation of a\n- *   {@code Locale}.  Where there are two or more variant values\n- *   each indicating its own semantics, these values should be ordered\n- *   by importance, with most important first, separated by\n- *   underscore('_').  The variant field is case sensitive.<\/dd>\n- *\n- *   <dd>Note: IETF BCP 47 places syntactic restrictions on variant\n- *   subtags.  Also BCP 47 subtags are strictly used to indicate\n+ *   <dd> Any arbitrary value used to indicate a variation of a\n+ *   {@code Locale}. When multiple variants exist, they should be separated by\n+ *   {@code ('_'|'-')}. Variants of higher importance should precede the others.<\/dd>\n+ *   <dd> <em>BCP 47 deviation:<\/em> BCP 47 subtags are strictly used to indicate\n@@ -150,4 +163,1 @@\n- *   region subtags.  You can find a full list of valid variant codes\n- *   in the IANA Language Subtag Registry (search for \"Type: variant\").\n- *\n- *   <p>However, the variant field in {@code Locale} has\n+ *   region subtags. However, the variant field in {@code Locale} has\n@@ -158,1 +168,1 @@\n- *   BCP 47 this kind of information, which does not identify the\n+ *   BCP 47, this kind of information which does not identify the\n@@ -162,4 +172,2 @@\n- *   <dd>Well-formed variant values have the form <code>SUBTAG\n- *   (('_'|'-') SUBTAG)*<\/code> where <code>SUBTAG =\n- *   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}<\/code>. (Note: BCP 47 only\n- *   uses hyphen ('-') as a delimiter, this is more lenient).<\/dd>\n+ *   <dd> <em>Case convention:<\/em> {@code variant} is case sensitive. BCP 47\n+ *   deviation: BCP 47 treats the variant field as case insensitive.<\/dd>\n@@ -167,1 +175,7 @@\n- *   <dd>Example: \"polyton\" (Polytonic Greek), \"POSIX\"<\/dd>\n+ *   <dd> <em>Syntax:<\/em> Well-formed {@code variant} values have the form {@code\n+ *   SUBTAG (('_'|'-') SUBTAG)*} where {@code SUBTAG =\n+ *   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}}.<\/dd>\n+ *   <dd> <em>BCP 47 deviation:<\/em> BCP 47 only\n+ *   uses hyphen ('-') as a delimiter, {@code Locale} is more lenient.<\/dd>\n+ *\n+ *   <dd> <em>Example:<\/em> \"polyton\" (Polytonic Greek), \"POSIX\"<\/dd>\n@@ -171,4 +185,8 @@\n- *   <dd>A map from single character keys to string values, indicating\n- *   extensions apart from language identification.  The extensions in\n- *   {@code Locale} implement the semantics and syntax of BCP 47\n- *   extension subtags and private use subtags. The extensions are\n+ *   <dd> A map from single character keys to string values, indicating\n+ *   extensions apart from language identification.<\/dd>\n+ *   <dd> <em> BCP 47 deviation:<\/em> The {@code\n+ *   extensions} in {@code Locale} implement the semantics and syntax of BCP 47\n+ *   extension subtags <em>and<\/em> private use subtags. The {@code extensions}\n+ *   field cannot have empty values. <\/dd>\n+ *\n+ *   <dd> <em>Case convention:<\/em> {@code extensions} are\n@@ -176,2 +194,1 @@\n- *   extension keys and values to lower case. Note that extensions\n- *   cannot have empty values.<\/dd>\n+ *   extension keys and values to lower case.<\/dd>\n@@ -179,1 +196,1 @@\n- *   <dd>Well-formed keys are single characters from the set\n+ *   <dd> <em>Syntax:<\/em> Well-formed keys are single characters from the set\n@@ -182,2 +199,2 @@\n- *   <code>SUBTAG = [0-9a-zA-Z]{1,8}<\/code> and for other keys\n- *   <code>SUBTAG = [0-9a-zA-Z]{2,8}<\/code> (that is, 'x' allows\n+ *   {@code SUBTAG = [0-9a-zA-Z]{1,8}} and for other keys\n+ *   {@code SUBTAG = [0-9a-zA-Z]{2,8}} (that is, 'x' allows\n@@ -186,1 +203,1 @@\n- *   <dd>Example: key=\"u\"\/value=\"ca-japanese\" (Japanese Calendar),\n+ *   <dd> <em>Example:<\/em> key=\"u\"\/value=\"ca-japanese\" (Japanese Calendar),\n@@ -190,1 +207,1 @@\n- * <b>Note:<\/b> Although BCP 47 requires field values to be registered\n+ * <b>BCP 47 deviation:<\/b> Although BCP 47 requires field values to be registered\n@@ -192,1 +209,3 @@\n- * does not provide any validation features.  The {@code Builder}\n+ * does not validate this requirement. For example, the variant code <em>\"foobar\"<\/em>\n+ * is well-formed since it is composed of 5 to 8 alphanumerics, but is not defined\n+ * the IANA Language Subtag Registry. The {@link Builder}\n@@ -195,1 +214,2 @@\n- * itself.  See {@link Builder} for details.\n+ * itself. Conversely, {@link #of(String, String, String) Locale::of} and its\n+ * overloads do not make any syntactic checks on the input.\n@@ -197,1 +217,1 @@\n- * <h2><a id=\"def_locale_extension\">Unicode locale\/language extension<\/a><\/h2>\n+ * <h3><a id=\"def_locale_extension\">Unicode BCP 47 U Extension<\/a><\/h3>\n@@ -216,1 +236,1 @@\n- * {@link #getUnicodeLocaleType} which allow you to access Unicode\n+ * {@link #getUnicodeLocaleType(String)} which provides access to the Unicode\n@@ -224,2 +244,2 @@\n- * <code>[0-9a-zA-Z]{2}<\/code>.  A well-formed locale type has the\n- * form <code>\"\" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})*<\/code> (it\n+ * {@code [0-9a-zA-Z]{2}}.  A well-formed locale type has the\n+ * form {@code \"\" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})*} (it\n@@ -228,1 +248,1 @@\n- * <code>[0-9a-zA-Z]{3,8}<\/code> (it is a single subtag with the same\n+ * {@code [0-9a-zA-Z]{3,8}} (it is a single subtag with the same\n@@ -237,26 +257,1 @@\n- * <h3><a id=\"ObtainingLocale\">Obtaining a Locale<\/a><\/h3>\n- *\n- * <p>There are several ways to obtain a {@code Locale}\n- * object.\n- *\n- * <h4>Builder<\/h4>\n- *\n- * <p>Using {@link Builder} you can construct a {@code Locale} object\n- * that conforms to BCP 47 syntax.\n- *\n- * <h4>Factory Methods<\/h4>\n- *\n- * <p>The method {@link #forLanguageTag} obtains a {@code Locale}\n- * object for a well-formed BCP 47 language tag. The method\n- * {@link #of(String, String, String)} and its overloads obtain a\n- * {@code Locale} object from given {@code language}, {@code country},\n- * and\/or {@code variant} defined above.\n- *\n- * <h4>Locale Constants<\/h4>\n- *\n- * <p>The {@code Locale} class provides a number of convenient constants\n- * that you can use to obtain {@code Locale} objects for commonly used\n- * locales. For example, {@code Locale.US} is the {@code Locale} object\n- * for the United States.\n- *\n- * <h3><a id=\"default_locale\">Default Locale<\/a><\/h3>\n+ * <h2><a id=\"default_locale\">Default Locale<\/a><\/h2>\n@@ -264,1 +259,1 @@\n- * <p>The default Locale is provided for any locale-sensitive methods if no\n+ * <p>The default Locale is provided for any <em>locale-sensitive<\/em> methods if no\n@@ -266,1 +261,1 @@\n- * {@link DateFormat#getInstance()}. The default Locale is determined at startup\n+ * {@link NumberFormat#getInstance()}. The default Locale is determined at startup\n@@ -319,0 +314,1 @@\n+ * <h3>Locale Category<\/h3>\n@@ -330,1 +326,1 @@\n- * <h3><a id=\"LocaleMatching\">Locale Matching<\/a><\/h3>\n+ * <h2><a id=\"ObtainingLocale\">Obtaining a Locale<\/a><\/h2>\n@@ -332,1 +328,69 @@\n- * <p>If an application or a system is internationalized and provides localized\n+ * <p>There are several ways to obtain a {@code Locale} object.\n+ * It is advised against using the deprecated {@code Locale} constructors.\n+ *\n+ * <dl>\n+ *  <dt><b>Locale Constants<\/b><\/dt>\n+ *  <dd>A number of convenient constants are provided that return {@code Locale}\n+ *  objects for commonly used locales. For example, {@link #US Locale.US} is the\n+ *  {@code Locale} object for the United States.<\/dd>\n+ *  <dt><b>Factory Methods<\/b><\/dt>\n+ *  <dd>{@link #of(String, String, String) Locale::of} and its overloads obtain a\n+ *  {@code Locale} object from the given {@code language}, {@code country},\n+ *  and\/or {@code variant}. {@link #forLanguageTag(String)} obtains a {@code Locale}\n+ *  object for a well-formed BCP 47 language tag.<\/dd>\n+ *  <dt><b>Builder<\/b><\/dt>\n+ *  <dd>{@link Builder} is used to construct a {@code Locale} object that conforms\n+ *  to BCP 47 syntax. Use a builder to enforce syntactic restrictions on the input.<\/dd>\n+ * <\/dl>\n+ * <p>The following invocations produce Locale objects that are all equivalent:\n+ * {@snippet lang=java :\n+ *     Locale.US;\n+ *     Locale.of(\"en\", \"US\");\n+ *     Locale.forLanguageTag(\"en-US\");\n+ *     new Locale.Builder().setLanguage(\"en\").setRegion(\"US\").build();\n+ * }\n+ *\n+ * <h2>Usage Examples<\/h2>\n+ *\n+ * <p>Once a {@code Locale} is {@linkplain ##ObtainingLocale obtained},\n+ * it can be queried for information about itself. For example, use {@link\n+ * #getCountry} to get the country (or region) code and {@link #getLanguage} to\n+ * get the language. {@link #getDisplayCountry} can be used to get the\n+ * name of the country suitable for displaying to the user. Similarly,\n+ * use {@link #getDisplayLanguage()} to get the name of\n+ * the language suitable for displaying to the user. The {@code getDisplayXXX}\n+ * methods are themselves <em>locale-sensitive<\/em> and have two variants; one with an explicit\n+ * locale parameter, and one without. The latter uses the default {@link\n+ * Locale.Category#DISPLAY DISPLAY} locale, so the following are equivalent :\n+ * {@snippet lang=java :\n+ *     Locale.getDefault().getDisplayCountry();\n+ *     Locale.getDefault().getDisplayCountry(Locale.getDefault(Locale.Category.DISPLAY));\n+ * }\n+ *\n+ * <p>The Java Platform provides a number of classes that perform locale-sensitive\n+ * operations. For example, the {@code NumberFormat} class formats\n+ * numbers, currency, and percentages in a <em>locale-sensitive<\/em> manner. Classes such\n+ * as {@code NumberFormat} have several factory methods for creating a default object\n+ * of that type. These methods generally have two variants; one with an explicit\n+ * locale parameter, and one without. The latter uses the default {@link\n+ * Locale.Category#FORMAT FORMAT} locale, so the following are equivalent :\n+ * {@snippet lang=java :\n+ *     NumberFormat.getCurrencyInstance();\n+ *     NumberFormat.getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT));\n+ * }\n+ *\n+ * <p>\n+ * The following example demonstrates <em>locale-sensitive<\/em> currency and\n+ * date related operations under different locales :\n+ * {@snippet lang = java:\n+ *     var number = 1000;\n+ *     NumberFormat.getCurrencyInstance(Locale.US).format(number); \/\/ returns \"$1,000.00\"\n+ *     NumberFormat.getCurrencyInstance(Locale.JAPAN).format(number); \/\/ returns \"\\u00A51,000\"\"\n+ *     var date = LocalDate.of(2024, 1, 1);\n+ *     DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).localizedBy(Locale.US).format(date); \/\/ returns \"January 1, 2024\"\n+ *     DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).localizedBy(Locale.JAPAN).format(date); \/\/ returns \"2024\\u5e741\\u67081\\u65e5\"\n+ * }\n+ *\n+ * <h2><a id=\"LocaleMatching\">Locale Matching<\/a><\/h2>\n+ *\n+ * <p>If an application is internationalized and provides localized\n@@ -335,2 +399,2 @@\n- * that a term \"language tag\" is used interchangeably with \"locale\" in this\n- * locale matching documentation.\n+ * that the term \"<dfn>{@index \"language tag\"}<\/dfn>\" is used interchangeably\n+ * with \"locale\" in the following locale matching documentation.\n@@ -338,1 +402,1 @@\n- * <p>In order to do matching a user's preferred locales to a set of language\n+ * <p>In order to match a user's preferred locales to a set of language\n@@ -342,1 +406,1 @@\n- * <em>lookup<\/em> is to choose the best matching locale.\n+ * <em>lookup<\/em> is to select the best matching locale.\n@@ -351,1 +415,2 @@\n- * <h4>Filtering<\/h4>\n+ *\n+ * <h3>Filtering<\/h3>\n@@ -369,1 +434,1 @@\n- * <h4>Lookup<\/h4>\n+ * <h3>Lookup<\/h3>\n@@ -401,1 +466,1 @@\n- * <h3>Use of Locale<\/h3>\n+ * <h3>Serialization<\/h3>\n@@ -403,11 +468,2 @@\n- * <p>Once you've obtained a {@code Locale} you can query it for information\n- * about itself. Use {@code getCountry} to get the country (or region)\n- * code and {@code getLanguage} to get the language code.\n- * You can use {@code getDisplayCountry} to get the\n- * name of the country suitable for displaying to the user. Similarly,\n- * you can use {@code getDisplayLanguage} to get the name of\n- * the language suitable for displaying to the user. Interestingly,\n- * the {@code getDisplayXXX} methods are themselves locale-sensitive\n- * and have two versions: one that uses the default\n- * {@link Locale.Category#DISPLAY DISPLAY} locale and one\n- * that uses the locale specified as an argument.\n+ * <p>During serialization, writeObject writes all fields to the output\n+ * stream, including extensions.\n@@ -415,36 +471,19 @@\n- * <p>The Java Platform provides a number of classes that perform locale-sensitive\n- * operations. For example, the {@code NumberFormat} class formats\n- * numbers, currency, and percentages in a locale-sensitive manner. Classes\n- * such as {@code NumberFormat} have several convenience methods\n- * for creating a default object of that type. For example, the\n- * {@code NumberFormat} class provides these three convenience methods\n- * for creating a default {@code NumberFormat} object:\n- * {@snippet lang=java :\n- *     NumberFormat.getInstance();\n- *     NumberFormat.getCurrencyInstance();\n- *     NumberFormat.getPercentInstance();\n- * }\n- * Each of these methods has two variants; one with an explicit locale\n- * and one without; the latter uses the default\n- * {@link Locale.Category#FORMAT FORMAT} locale:\n- * {@snippet lang=java :\n- *     NumberFormat.getInstance(myLocale);\n- *     NumberFormat.getCurrencyInstance(myLocale);\n- *     NumberFormat.getPercentInstance(myLocale);\n- * }\n- * A {@code Locale} is the mechanism for identifying the kind of object\n- * ({@code NumberFormat}) that you would like to get. The locale is\n- * <STRONG>just<\/STRONG> a mechanism for identifying objects,\n- * <STRONG>not<\/STRONG> a container for the objects themselves.\n- *\n- * <h3>Compatibility<\/h3>\n- *\n- * <p>In order to maintain compatibility, Locale's\n- * constructors retain their behavior prior to the Java Runtime\n- * Environment version 1.7.  The same is largely true for the\n- * {@code toString} method. Thus Locale objects can continue to\n- * be used as they were. In particular, clients who parse the output\n- * of toString into language, country, and variant fields can continue\n- * to do so (although this is strongly discouraged), although the\n- * variant field will have additional information in it if script or\n- * extensions are present.\n+ * <p>During deserialization, readResolve adds extensions as described\n+ * in {@linkplain ##special_cases_constructor Special Cases}, only\n+ * for the two cases th_TH_TH and ja_JP_JP.\n+ *\n+ * @implNote\n+ * <h2>Compatibility<\/h2>\n+ * <p> The following commentary is provided for apps that want to ensure\n+ * interoperability with older releases of {@code Locale} provided by the\n+ * reference implementation.\n+ * <h3><a id=\"locale_behavior\">Locale Behavior<\/a><\/h3>\n+ * In order to maintain compatibility, Locale's (deprecated) constructors,\n+ * {@link #of(String, String, String)}, and its overloads retain their behavior prior to the Java Runtime\n+ * Environment version 1.7. That is, a length constraint is not imposed on any of\n+ * the input parameters. Similarly, the same preservation of past behavior is largely true\n+ * for the {@link #toString()} method.\n+ * Apps that previously parsed the output of {@link #toString()} into language,\n+ * country, and variant fields can continue to do so (although this is strongly\n+ * discouraged). A caveat is that the variant field will have additional\n+ * information in it if script or extensions are present.\n@@ -455,1 +494,1 @@\n- * losing information. Thus {@code toLanguageTag} cannot\n+ * losing information. Thus {@link #toLanguageTag} cannot\n@@ -459,1 +498,1 @@\n- * <p>Because of these issues, it is recommended that clients migrate\n+ * <p>Because of these issues, it is recommended that apps migrate\n@@ -461,3 +500,3 @@\n- * {@code forLanguageTag} and {@code Locale.Builder} APIs instead.\n- * Clients desiring a string representation of the complete locale can\n- * then always rely on {@code toLanguageTag} for this purpose.\n+ * {@link #forLanguageTag(String)} and {@link Locale.Builder} APIs instead.\n+ * Apps desiring a string representation of the complete locale can\n+ * then always rely on {@link #toLanguageTag} for this purpose.\n@@ -465,1 +504,1 @@\n- * <h4><a id=\"special_cases_constructor\">Special cases<\/a><\/h4>\n+ * <h3><a id=\"special_cases_constructor\">Special cases<\/a><\/h3>\n@@ -470,1 +509,1 @@\n- * in BCP 47 since the variants are too short. To ease migration to BCP 47,\n+ * in BCP 47 since the {@linkplain ##def_variant variants} are too short. To ease migration to BCP 47,\n@@ -490,10 +529,1 @@\n- * <h4>Serialization<\/h4>\n- *\n- * <p>During serialization, writeObject writes all fields to the output\n- * stream, including extensions.\n- *\n- * <p>During deserialization, readResolve adds extensions as described\n- * in {@linkplain ##special_cases_constructor Special Cases}, only\n- * for the two cases th_TH_TH and ja_JP_JP.\n- *\n- * <h4><a id=\"legacy_language_codes\">Legacy language codes<\/a><\/h4>\n+ * <h3><a id=\"legacy_language_codes\">Legacy language codes<\/a><\/h3>\n@@ -501,1 +531,1 @@\n- * <p>Locale's constructor has always converted three language codes to\n+ * <p>Locale's constructors have always converted three language codes to\n@@ -508,1 +538,1 @@\n- * <p>For the backward compatible behavior, the system property\n+ * <p>For backwards compatible behavior, the system property\n@@ -527,12 +557,0 @@\n- * <h4>Three-letter language\/country(region) codes<\/h4>\n- *\n- * <p>The Locale constructors have always specified that the language\n- * and the country param be two characters in length, although in\n- * practice they have accepted any length.  The specification has now\n- * been relaxed to allow language codes of two to eight characters and\n- * country (region) codes of two to three characters, and in\n- * particular, three-letter language codes and three-digit region\n- * codes as specified in the IANA Language Subtag Registry.  For\n- * compatibility, the implementation still does not impose a length\n- * constraint.\n- *\n@@ -543,0 +561,2 @@\n+ * @spec https:\/\/unicode.org\/reports\/tr35\/\n+ *      Unicode Locale Data Markup Language\n@@ -1232,1 +1252,1 @@\n-     * {@return an array of installed locales}\n+     * {@return an array of available locales}\n@@ -1235,1 +1255,1 @@\n-     * by the Java runtime environment and by installed\n+     * by the Java runtime environment and by deployed\n@@ -1238,2 +1258,2 @@\n-     * {@code Locale} instance equal to {@link Locale#ROOT Locale.ROOT} and\n-     * a {@code Locale} instance equal to {@link Locale#US Locale.US}.\n+     * {@code Locale} instance equal to {@link #ROOT Locale.ROOT} and\n+     * a {@code Locale} instance equal to {@link #US Locale.US}.\n@@ -1246,1 +1266,1 @@\n-     * {@return a stream of installed locales}\n+     * {@return a stream of available locales}\n@@ -1249,1 +1269,1 @@\n-     * by the Java runtime environment and by installed\n+     * by the Java runtime environment and by deployed\n@@ -1252,2 +1272,2 @@\n-     * {@code Locale} instance equal to {@link Locale#ROOT Locale.ROOT} and\n-     * a {@code Locale} instance equal to {@link Locale#US Locale.US}.\n+     * {@code Locale} instance equal to {@link #ROOT Locale.ROOT} and\n+     * a {@code Locale} instance equal to {@link #US Locale.US}.\n@@ -1535,2 +1555,2 @@\n-     * the empty string, even if the variant, script, or extensions field is present (you\n-     * can't have a locale with just a variant, the variant must accompany a well-formed\n+     * the empty string, even if the variant, script, or extensions field is present\n+     * (a locale with just a variant is not allowed, the variant must accompany a well-formed\n@@ -1616,1 +1636,1 @@\n-     * <li>if all sub-segments match <code>[0-9a-zA-Z]{1,8}<\/code>\n+     * <li>if all sub-segments match {@code [0-9a-zA-Z]{1,8}}\n@@ -1625,1 +1645,1 @@\n-     * <code>[0-9a-zA-Z]{1,8}<\/code>, the variant will be truncated\n+     * {@code [0-9a-zA-Z]{1,8}}, the variant will be truncated\n@@ -1777,1 +1797,1 @@\n-     * to {@link Locale.Builder#setLanguageTag} which throws an exception\n+     * to {@link Locale.Builder#setLanguageTag(String)} which throws an exception\n@@ -1997,1 +2017,0 @@\n-     * (say, we don't have a Japanese name for Croatian),\n@@ -2015,1 +2034,0 @@\n-     * (say, we don't have a Japanese name for Croatian),\n@@ -2070,1 +2088,0 @@\n-     * (say, we don't have a Japanese name for Croatia),\n@@ -2087,2 +2104,1 @@\n-     * If the name returned cannot be localized according to inLocale.\n-     * (say, we don't have a Japanese name for Croatia),\n+     * If the name returned cannot be localized according to inLocale,\n@@ -2700,1 +2716,1 @@\n-     * {@link Locale#of(String, String, String)}.  However, keep in mind that a {@code Locale}\n+     * {@link #of(String, String, String)}.  However, keep in mind that a {@code Locale}\n@@ -2713,1 +2729,1 @@\n-     * @see Locale#forLanguageTag\n+     * @see Locale#forLanguageTag(String)\n@@ -2763,1 +2779,1 @@\n-         * Locale#forLanguageTag}) are converted to their canonical\n+         * Locale#forLanguageTag(String)}) are converted to their canonical\n@@ -2865,1 +2881,1 @@\n-         * use {@link Locale#of(String, String, String)}.\n+         * use {@link #of(String, String, String)}.\n@@ -2887,1 +2903,1 @@\n-         * <p><b>Note:<\/b> The key {@link Locale#UNICODE_LOCALE_EXTENSION\n+         * <p><b>Note:<\/b> The key {@link #UNICODE_LOCALE_EXTENSION\n@@ -2892,1 +2908,1 @@\n-         * <p><b>Note:<\/b> The key {@link Locale#PRIVATE_USE_EXTENSION\n+         * <p><b>Note:<\/b> The key {@link #PRIVATE_USE_EXTENSION\n@@ -2921,1 +2937,1 @@\n-         * <p><b>Note<\/b>:Setting the 'u' extension via {@link #setExtension}\n+         * <p><b>Note<\/b>:Setting the 'u' extension via {@link #setExtension(char, String)}\n@@ -3013,1 +3029,1 @@\n-         * <p>This applies the conversions listed in {@link Locale#forLanguageTag}\n+         * <p>This applies the conversions listed in {@link #forLanguageTag(String)}\n@@ -3015,1 +3031,1 @@\n-         * {@link #setLanguageTag}.)\n+         * {@link #setLanguageTag(String)}.)\n@@ -3196,4 +3212,4 @@\n-     * @see #filter\n-     * @see #filterTags\n-     * @see #lookup\n-     * @see #lookupTag\n+     * @see #filter(List, Collection, FilteringMode)\n+     * @see #filterTags(List, Collection, FilteringMode)\n+     * @see #lookup(List, Collection)\n+     * @see #lookupTag(List, Collection)\n@@ -3416,1 +3432,1 @@\n-         * @see #mapEquivalents\n+         * @see #mapEquivalents(List, Map)\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":238,"deletions":222,"binary":false,"changes":460,"status":"modified"},{"patch":"@@ -613,6 +613,5 @@\n-     * (external) signal during deactivation. To reduce false-alarm\n-     * reactivations while doing so, we scan multiple times\n-     * (analogously to method quiescent()) before trying to\n-     * reactivate.  Because idle workers are often not yet blocked\n-     * (parked), we use a WorkQueue field to advertise that a waiter\n-     * actually needs unparking upon signal.\n+     * signal during deactivation. To reduce false-alarm reactivations\n+     * while doing so, we scan multiple times (analogously to method\n+     * quiescent()) before trying to reactivate.  Because idle workers\n+     * are often not yet blocked (parked), we use a WorkQueue field to\n+     * advertise that a waiter actually needs unparking upon signal.\n@@ -1999,1 +1998,1 @@\n-        w.stackPred = (int)pc;                \/\/ set ctl stack link\n+        int sp = w.stackPred = (int)pc;       \/\/ set ctl stack link\n@@ -2009,2 +2008,2 @@\n-        for (int k = Math.max(n + (n << 1), SPIN_WAITS << 1);;) {\n-            WorkQueue q; int cap; ForkJoinTask<?>[] a;\n+        for (int k = Math.max(n << 2, SPIN_WAITS << 1);;) {\n+            WorkQueue q; int cap; ForkJoinTask<?>[] a; long c;\n@@ -2015,4 +2014,3 @@\n-            if ((k & 1) != 0)\n-                Thread.onSpinWait();          \/\/ interleave spins and rechecks\n-            else if ((q = qs[k & (n - 1)]) != null &&\n-                     (a = q.array) != null && (cap = a.length) > 0 &&\n+            if ((q = qs[k & (n - 1)]) == null)\n+                Thread.onSpinWait();\n+            else if ((a = q.array) != null && (cap = a.length) > 0 &&\n@@ -2020,1 +2018,2 @@\n-                     ctl == qc && compareAndSetCtl(qc, pc))\n+                     (int)(c = ctl) == activePhase &&\n+                     compareAndSetCtl(c, (sp & LMASK) | ((c + RC_UNIT) & UMASK)))\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -292,1 +292,2 @@\n-     * of locally cached reads.\n+     * of locally cached reads, and include fall-backs for exceptional\n+     * cases including OutOfMemoryErrors and JVM exceptions.\n@@ -1185,2 +1186,1 @@\n-    private void tryInitializeHead() {\n-        Node h = new WriterNode();\n+    private void tryInitializeHead(Node h) {\n@@ -1206,0 +1206,1 @@\n+        long nanos = 0L;\n@@ -1230,1 +1231,5 @@\n-                node = new WriterNode();\n+                try {\n+                    node = new WriterNode();\n+                } catch (OutOfMemoryError oome) {\n+                    return spinLockOnOOME(true, interruptible, timed, time);\n+                }\n@@ -1234,2 +1239,9 @@\n-                if (t == null)\n-                    tryInitializeHead();\n+                if (t == null) {                \/\/ try to initialize\n+                    Node h;\n+                    try {\n+                        h = new WriterNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return spinLockOnOOME(true, interruptible, timed, time);\n+                    }\n+                    tryInitializeHead(h);\n+                }\n@@ -1247,9 +1259,10 @@\n-            } else {\n-                long nanos;\n-                spins = postSpins = (byte)((postSpins << 1) | 1);\n-                if (!timed)\n-                    LockSupport.park(this);\n-                else if ((nanos = time - System.nanoTime()) > 0L)\n-                    LockSupport.parkNanos(this, nanos);\n-                else\n-                    break;\n+            } else if (!timed || (nanos = time - System.nanoTime()) > 0L) {\n+                try {\n+                    if (!timed)\n+                        LockSupport.park(this);\n+                    else\n+                        LockSupport.parkNanos(this, nanos);\n+                } catch (Error | RuntimeException ex) {\n+                    cancelAcquire(node);\n+                    throw ex;\n+                }\n@@ -1259,1 +1272,3 @@\n-            }\n+                spins = postSpins = (byte)((postSpins << 1) | 1);\n+            } else\n+                break;\n@@ -1261,1 +1276,2 @@\n-        return cancelAcquire(node, interrupted);\n+        cancelAcquire(node);\n+        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n@@ -1288,2 +1304,9 @@\n-            else if (t == null)\n-                tryInitializeHead();\n+            else if (t == null) {\n+                 Node h;\n+                 try {\n+                     h = new WriterNode();\n+                 } catch (OutOfMemoryError oome) {\n+                     return spinLockOnOOME(false, interruptible, timed, time);\n+                 }\n+                 tryInitializeHead(h);\n+            }\n@@ -1291,2 +1314,7 @@\n-                if (node == null)\n-                    node = new ReaderNode();\n+                if (node == null) {\n+                    try {\n+                        node = new ReaderNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return spinLockOnOOME(false, interruptible, timed, time);\n+                    }\n+                }\n@@ -1305,2 +1333,7 @@\n-                    else if (node == null)\n-                        node = new ReaderNode();\n+                    else if (node == null) {\n+                        try {\n+                            node = new ReaderNode();\n+                        } catch (OutOfMemoryError oome) {\n+                            return spinLockOnOOME(false, interruptible, timed, time);\n+                        }\n+                    }\n@@ -1316,5 +1349,10 @@\n-                        long nanos = 0L;\n-                        if (!timed)\n-                            LockSupport.park(this);\n-                        else if ((nanos = time - System.nanoTime()) > 0L)\n-                            LockSupport.parkNanos(this, nanos);\n+                        long nanos = (timed) ? time - System.nanoTime(): 0L;\n+                        try {\n+                            if (!timed)\n+                                LockSupport.park(this);\n+                            else if (nanos > 0L)\n+                                LockSupport.parkNanos(this, nanos);\n+                        } catch (Error | RuntimeException ex) {\n+                            cancelCowaiter(node, leader);\n+                            throw ex;\n+                        }\n@@ -1323,2 +1361,4 @@\n-                            (timed && nanos <= 0L))\n-                            return cancelCowaiter(node, leader, interrupted);\n+                            (timed && nanos <= 0L)) {\n+                            cancelCowaiter(node, leader);\n+                            return (interrupted) ? INTERRUPTED : 0L;\n+                        }\n@@ -1344,0 +1384,1 @@\n+        long nanos = 0L;\n@@ -1374,9 +1415,10 @@\n-            } else {\n-                long nanos;\n-                spins = postSpins = (byte)((postSpins << 1) | 1);\n-                if (!timed)\n-                    LockSupport.park(this);\n-                else if ((nanos = time - System.nanoTime()) > 0L)\n-                    LockSupport.parkNanos(this, nanos);\n-                else\n-                    break;\n+            } else if (!timed || (nanos = time - System.nanoTime()) > 0) {\n+                try {\n+                    if (!timed)\n+                        LockSupport.park(this);\n+                    else\n+                        LockSupport.parkNanos(this, nanos);\n+                } catch (Error | RuntimeException ex) {\n+                    cancelAcquire(node);\n+                    throw ex;\n+                }\n@@ -1386,1 +1428,3 @@\n-            }\n+                spins = postSpins = (byte)((postSpins << 1) | 1);\n+            } else\n+                break;\n@@ -1388,1 +1432,2 @@\n-        return cancelAcquire(node, interrupted);\n+        cancelAcquire(node);\n+        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n@@ -1453,2 +1498,0 @@\n-     * @param interrupted if already interrupted\n-     * @return INTERRUPTED if interrupted or Thread.interrupted, else zero\n@@ -1456,1 +1499,1 @@\n-    private long cancelAcquire(Node node, boolean interrupted) {\n+    private void cancelAcquire(Node node) {\n@@ -1464,1 +1507,0 @@\n-        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n@@ -1473,2 +1515,0 @@\n-     * @param interrupted if already interrupted\n-     * @return INTERRUPTED if interrupted or Thread.interrupted, else zero\n@@ -1476,2 +1516,1 @@\n-    private long cancelCowaiter(ReaderNode node, ReaderNode leader,\n-                                boolean interrupted) {\n+    private void cancelCowaiter(ReaderNode node, ReaderNode leader) {\n@@ -1483,1 +1522,20 @@\n-        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n+    }\n+\n+    \/**\n+     * Fallback upon encountering OutOfMemoryErrors\n+     *\/\n+    private long spinLockOnOOME(boolean write, boolean interruptible,\n+                                boolean timed, long time) {\n+        long startTime = (timed) ? System.nanoTime() : 0L;\n+        for (int spins = 0;;) {\n+            long s =  (write) ? tryAcquireWrite() : tryAcquireRead();\n+            if (s != 0L)\n+                return s;\n+            Thread.onSpinWait();\n+            if ((++spins & (1 << 8)) == 0) {  \/\/ occasionally check\n+                if (interruptible && Thread.interrupted())\n+                    return INTERRUPTED;\n+                if (timed && System.nanoTime() - startTime > time)\n+                    return 0L;\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/StampedLock.java","additions":108,"deletions":50,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -293,1 +293,0 @@\n-    \/\/ This is called from within an doPrivileged block.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurity.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-     * Perform privileged work as a particular {@code Subject}.\n+     * Perform work as a particular {@code Subject}.\n@@ -516,1 +516,1 @@\n-     * Perform privileged work as a particular {@code Subject}.\n+     * Perform work as a particular {@code Subject}.\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Subject.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,2 +115,1 @@\n-     *          current execution Thread, up to the most recent\n-     *          privileged {@code ProtectionDomain}.\n+     *          current execution Thread.\n@@ -123,7 +122,3 @@\n-     * @param assignedDomains the ProtectionDomains inherited from the\n-     *          parent Thread, or the ProtectionDomains from the\n-     *          privileged {@code context}, if a call to\n-     *          {@code AccessController.doPrivileged(..., context)}\n-     *          had occurred  This parameter may be {@code null}\n-     *          if there were no ProtectionDomains inherited from the\n-     *          parent Thread, or from the privileged {@code context}.\n+     * @param assignedDomains the inherited ProtectionDomains.\n+     *          This parameter may be {@code null}\n+     *          if there were no inherited ProtectionDomains.\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/SubjectDomainCombiner.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -598,0 +599,5 @@\n+    \/**\n+     * Returns a stream of the delayed task schedulers used for virtual threads.\n+     *\/\n+    Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.access;\n-\n-import java.security.AccessControlContext;\n-import java.security.PrivilegedAction;\n-\n-public interface JavaSecurityAccess {\n-\n-    <T> T doIntersectionPrivilege(PrivilegedAction<T> action,\n-                                  @SuppressWarnings(\"removal\") AccessControlContext stack,\n-                                  @SuppressWarnings(\"removal\") AccessControlContext context);\n-\n-    <T> T doIntersectionPrivilege(PrivilegedAction<T> action,\n-                                  @SuppressWarnings(\"removal\") AccessControlContext context);\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaSecurityAccess.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -42,2 +42,0 @@\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n@@ -45,1 +43,0 @@\n-import java.security.ProtectionDomain;\n@@ -92,1 +89,0 @@\n-    private static JavaSecurityAccess javaSecurityAccess;\n@@ -316,13 +312,0 @@\n-    public static void setJavaSecurityAccess(JavaSecurityAccess jsa) {\n-        javaSecurityAccess = jsa;\n-    }\n-\n-    public static JavaSecurityAccess getJavaSecurityAccess() {\n-        var access = javaSecurityAccess;\n-        if (access == null) {\n-            ensureClassInitialized(ProtectionDomain.class);\n-            access = javaSecurityAccess;\n-        }\n-        return access;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.classfile.components;\n+package jdk.internal.classfile.components;\n@@ -61,2 +61,0 @@\n- *\n- * @since 24\n@@ -71,2 +69,0 @@\n-     *\n-     * @since 24\n@@ -105,2 +101,0 @@\n-     *\n-     * @since 24\n@@ -149,2 +143,0 @@\n-     *\n-     * @since 24\n@@ -164,2 +156,0 @@\n-     *\n-     * @since 24\n@@ -175,2 +165,0 @@\n-     *\n-     * @since 24\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassPrinter.java","additions":1,"deletions":13,"binary":false,"changes":14,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassPrinter.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.classfile.components;\n+package jdk.internal.classfile.components;\n@@ -56,2 +56,0 @@\n- *\n- * @since 24\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassRemapper.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassRemapper.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.classfile.components;\n+package jdk.internal.classfile.components;\n@@ -40,2 +40,0 @@\n- *\n- * @since 24\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeLocalsShifter.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeLocalsShifter.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.classfile.components;\n+package jdk.internal.classfile.components;\n@@ -47,2 +47,0 @@\n- *\n- * @since 24\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeRelabeler.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeRelabeler.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package java.lang.classfile.components;\n+package jdk.internal.classfile.components;\n@@ -52,2 +52,0 @@\n- *\n- * @since 24\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeStackTracker.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeStackTracker.java","status":"renamed"},{"patch":"@@ -113,2 +113,0 @@\n- *\n- * @since 24\n@@ -116,1 +114,1 @@\n-package java.lang.classfile.components;\n+package jdk.internal.classfile.components;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/package-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/package-info.java","status":"renamed"},{"patch":"@@ -28,4 +28,4 @@\n-import java.lang.classfile.components.ClassPrinter;\n-import java.lang.classfile.components.ClassRemapper;\n-import java.lang.classfile.components.CodeLocalsShifter;\n-import java.lang.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n+import jdk.internal.classfile.components.CodeRelabeler;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/snippet-files\/PackageSnippets.java","status":"renamed"},{"patch":"@@ -107,1 +107,1 @@\n-    public abstract byte tag();\n+    public abstract int tag();\n@@ -184,1 +184,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -525,1 +525,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -585,1 +585,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -616,1 +616,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -648,1 +648,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -722,1 +722,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -740,1 +740,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -758,1 +758,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -852,1 +852,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -877,1 +877,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -908,1 +908,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -967,1 +967,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -1005,1 +1005,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -1057,1 +1057,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -1103,1 +1103,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -1148,1 +1148,1 @@\n-        public byte tag() {\n+        public int tag() {\n@@ -1198,1 +1198,1 @@\n-        public byte tag() {\n+        public int tag() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -88,1 +88,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -101,1 +101,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -114,1 +114,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -127,1 +127,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -140,1 +140,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -153,1 +153,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -166,1 +166,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -179,1 +179,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -196,1 +196,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -204,1 +204,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -212,1 +212,1 @@\n-        public char tag() {\n+        public int tag() {\n@@ -220,1 +220,1 @@\n-        public char tag() {\n+        public int tag() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-        switch (value.tag()) {\n+        switch (tag) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,5 +34,5 @@\n-import java.lang.classfile.components.ClassPrinter.LeafNode;\n-import java.lang.classfile.components.ClassPrinter.ListNode;\n-import java.lang.classfile.components.ClassPrinter.MapNode;\n-import java.lang.classfile.components.ClassPrinter.Node;\n-import java.lang.classfile.components.ClassPrinter.Verbosity;\n+import jdk.internal.classfile.components.ClassPrinter.LeafNode;\n+import jdk.internal.classfile.components.ClassPrinter.ListNode;\n+import jdk.internal.classfile.components.ClassPrinter.MapNode;\n+import jdk.internal.classfile.components.ClassPrinter.Node;\n+import jdk.internal.classfile.components.ClassPrinter.Verbosity;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.ClassRemapper;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.classfile.components.CodeLocalsShifter;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.components.CodeRelabeler;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeRelabelerImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.classfile.components.CodeStackTracker;\n+import jdk.internal.classfile.components.CodeStackTracker;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeStackTrackerImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -53,1 +52,1 @@\n-                GetBooleanAction.privilegedGetProperty(JDKContext.COLLECT_FD_STACKTRACES_PROPERTY);\n+                Boolean.getBoolean(JDKContext.COLLECT_FD_STACKTRACES_PROPERTY);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -15,1 +14,1 @@\n-        GetBooleanAction.privilegedGetProperty(COLLECT_FD_STACKTRACES_PROPERTY);\n+        Boolean.getBoolean(COLLECT_FD_STACKTRACES_PROPERTY);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFdResource.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -24,1 +23,1 @@\n-        String[] items = GetPropertyAction.privilegedGetProperty(\"java.class.path\")\n+        String[] items = System.getProperty(\"java.class.path\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -58,1 +57,1 @@\n-        String file = GetPropertyAction.privilegedGetProperty(PROPERTY);\n+        String file = System.getProperty(PROPERTY);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/OpenResourcePolicies.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -71,1 +70,1 @@\n-            GetBooleanAction.privilegedGetProperty(\"jdk.crac.trace-startup-time\");\n+            Boolean.getBoolean(\"jdk.crac.trace-startup-time\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -11,1 +10,1 @@\n-        String implName = GetPropertyAction.privilegedGetProperty(GLOBAL_CONTEXT_IMPL_PROP, \"\");\n+        String implName = System.getProperty(GLOBAL_CONTEXT_IMPL_PROP, \"\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/impl\/GlobalContext.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -892,0 +892,1 @@\n+    @ForceInline\n@@ -897,0 +898,1 @@\n+    @ForceInline\n@@ -903,0 +905,1 @@\n+    @ForceInline\n@@ -909,0 +912,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.util.ByteArrayLittleEndian;\n@@ -53,0 +52,1 @@\n+    private static final long LONG_MASK = ~7L; \/\/ The last three bits are zero\n@@ -78,1 +78,1 @@\n-            for (; offset < limit; offset += 8) {\n+            for (; offset < limit; offset += Long.BYTES) {\n@@ -83,1 +83,1 @@\n-            if (remaining >= 4) {\n+            if (remaining >= Integer.BYTES) {\n@@ -85,2 +85,2 @@\n-                offset += 4;\n-                remaining -= 4;\n+                offset += Integer.BYTES;\n+                remaining -= Integer.BYTES;\n@@ -89,1 +89,1 @@\n-            if (remaining >= 2) {\n+            if (remaining >= Short.BYTES) {\n@@ -91,2 +91,2 @@\n-                offset += 2;\n-                remaining -= 2;\n+                offset += Short.BYTES;\n+                remaining -= Short.BYTES;\n@@ -126,1 +126,1 @@\n-            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - 8));\n+            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n@@ -128,1 +128,1 @@\n-            for (; offset < limit; offset += 8) {\n+            for (; offset < limit; offset += Long.BYTES) {\n@@ -134,1 +134,1 @@\n-            if (remaining >= 4) {\n+            if (remaining >= Integer.BYTES) {\n@@ -137,2 +137,2 @@\n-                offset += 4;\n-                remaining -= 4;\n+                offset += Integer.BYTES;\n+                remaining -= Integer.BYTES;\n@@ -141,1 +141,1 @@\n-            if (remaining >= 2) {\n+            if (remaining >= Short.BYTES) {\n@@ -144,2 +144,2 @@\n-                offset += 2;\n-                remaining -=2;\n+                offset += Short.BYTES;\n+                remaining -= Short.BYTES;\n@@ -205,1 +205,1 @@\n-        final long longBytes = length & ((1L << 62) - 8);\n+        final long longBytes = length & LONG_MASK;\n@@ -207,1 +207,1 @@\n-        for (; fromOffset < limit; fromOffset += 8) {\n+        for (; fromOffset < limit; fromOffset += Long.BYTES) {\n@@ -221,1 +221,1 @@\n-        if (remaining >= 4) {\n+        if (remaining >= Integer.BYTES) {\n@@ -228,2 +228,2 @@\n-            fromOffset += 4;\n-            remaining -= 4;\n+            fromOffset += Integer.BYTES;\n+            remaining -= Integer.BYTES;\n@@ -232,1 +232,1 @@\n-        if (remaining >= 2) {\n+        if (remaining >= Short.BYTES) {\n@@ -237,2 +237,2 @@\n-            fromOffset += 2;\n-            remaining -= 2;\n+            fromOffset += Short.BYTES;\n+            remaining -= Short.BYTES;\n@@ -291,1 +291,1 @@\n-        for (; offset < limit; offset += 8) {\n+        for (; offset < limit; offset += Long.BYTES) {\n@@ -301,1 +301,1 @@\n-        if (remaining >= 4) {\n+        if (remaining >= Integer.BYTES) {\n@@ -307,2 +307,2 @@\n-            offset += 4;\n-            remaining -= 4;\n+            offset += Integer.BYTES;\n+            remaining -= Integer.BYTES;\n@@ -311,1 +311,1 @@\n-        if (remaining >= 2) {\n+        if (remaining >= Short.BYTES) {\n@@ -317,2 +317,2 @@\n-            offset += 2;\n-            remaining -= 2;\n+            offset += Short.BYTES;\n+            remaining -= Short.BYTES;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.util.Architecture;\n@@ -32,0 +33,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -43,1 +45,3 @@\n-    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+    private static final long LONG_MASK = ~7L; \/\/ The last three bits are zero\n@@ -47,1 +51,2 @@\n-    public static String read(MemorySegment segment, long offset, Charset charset) {\n+    @ForceInline\n+    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n@@ -55,1 +60,2 @@\n-    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    public static void write(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -63,4 +69,5 @@\n-    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenByte(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readByte(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        final int len = strlenByte(segment, offset, segment.byteSize());\n+        final byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -70,1 +77,2 @@\n-    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeByte(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -75,4 +83,5 @@\n-    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenShort(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readShort(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        int len = strlenShort(segment, offset, segment.byteSize());\n+        byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -82,1 +91,2 @@\n-    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeShort(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -87,4 +97,5 @@\n-    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlenInt(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readInt(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        int len = strlenInt(segment, offset, segment.byteSize());\n+        byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -94,1 +105,2 @@\n-    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeInt(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -100,2 +112,3 @@\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * {@return the index of the first zero byte beginning at the provided\n+     *          {@code fromOffset} to the encountering of a zero byte in the provided\n+     *          {@code segment} checking bytes before the {@code toOffset}}\n@@ -103,10 +116,2 @@\n-     * The method divides the region of interest into three distinct regions:\n-     * <ul>\n-     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n-     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n-     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The body is using a heuristic method to determine if a long word\n-     * contains a zero byte. The method might have false positives but\n-     * never false negatives.\n+     * The method is using a heuristic method to determine if a long word contains a\n+     * zero byte. The method might have false positives but never false negatives.\n@@ -116,2 +121,3 @@\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n+     * @param segment    to examine\n+     * @param fromOffset from where examination shall begin (inclusive)\n+     * @param toOffset   to where examination shall end (exclusive)\n@@ -121,10 +127,29 @@\n-    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n+    @ForceInline\n+    public static int strlenByte(final AbstractMemorySegmentImpl segment,\n+                                 final long fromOffset,\n+                                 final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            \/\/ The state has to be checked explicitly for zero-length segments\n+            segment.scope.checkValidState();\n+            throw nullNotFound(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroByte(val)) {\n+                for (int j = 0; j < Long.BYTES; j++) {\n+                    if (SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j) == 0) {\n+                        return requireWithinStringSize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        for (; offset < toOffset; offset++) {\n+            byte val = SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset);\n+            if (val == 0) {\n+                return requireWithinStringSize(offset - fromOffset, segment, fromOffset, toOffset);\n@@ -133,0 +158,2 @@\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n@@ -134,11 +161,19 @@\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroByte(curr)) {\n-                for (int j = 0; j < 8; j++) {\n-                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n-                        return offset + j;\n+    @ForceInline\n+    public static int strlenShort(final AbstractMemorySegmentImpl segment,\n+                                  final long fromOffset,\n+                                  final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw nullNotFound(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroShort(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinStringSize(offset + j - fromOffset, segment, fromOffset, toOffset);\n@@ -149,0 +184,11 @@\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 2\n+        final long endScan = toOffset & ~1; \/\/ The last bit is zero\n+        for (; offset < endScan; offset += Short.BYTES) {\n+            short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinStringSize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n@@ -150,2 +196,33 @@\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n+    @ForceInline\n+    public static int strlenInt(final AbstractMemorySegmentImpl segment,\n+                                final long fromOffset,\n+                                final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw nullNotFound(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroInt(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinStringSize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 4\n+        final long endScan = toOffset & ~3; \/\/ The last two bit are zero\n+        for (; offset < endScan; offset += Integer.BYTES) {\n+            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinStringSize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n@@ -154,3 +231,4 @@\n-    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n-       the \"holes\".  Note that there is a hole just to the left of\n-       each byte, with an extra at the end:\n+    \/*\n+    Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+    the \"holes\".  Note that there is a hole just to the left of\n+    each byte, with an extra at the end:\n@@ -158,2 +236,2 @@\n-       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n-       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+    bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+    bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n@@ -161,2 +239,2 @@\n-       The 1-bits make sure that carries propagate to the next 0-bit.\n-       The 0-bits provide holes for carries to fall into.\n+    The 1-bits make sure that carries propagate to the next 0-bit.\n+    The 0-bits provide holes for carries to fall into.\n@@ -167,1 +245,1 @@\n-    static boolean mightContainZeroByte(long l) {\n+    private static boolean mightContainZeroByte(long l) {\n@@ -178,15 +256,2 @@\n-    static int requireWithinArraySize(long size) {\n-        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n-            throw newIaeStringTooLarge();\n-        }\n-        return (int) size;\n-    }\n-\n-    static int bodyCount(long remaining) {\n-        return (int) Math.min(\n-                \/\/ Make sure we do not wrap around\n-                Integer.MAX_VALUE - Long.BYTES,\n-                \/\/ Remaining bytes to consider\n-                remaining)\n-                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n-    }\n+    private static final long HIMAGIC_FOR_INTS = 0x8000_0000_8000_0000L;\n+    private static final long LOMAGIC_FOR_INTS = 0x0000_0001_0000_0001L;\n@@ -194,8 +259,2 @@\n-    private static int strlenByte(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n+    static boolean mightContainZeroInt(long l) {\n+        return ((l - LOMAGIC_FOR_INTS) & (~l) & HIMAGIC_FOR_INTS) != 0;\n@@ -204,17 +263,0 @@\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero short in the provided {@code segment}}\n-     * <p>\n-     * Note: The inspected region must be short aligned.\n-     *\n-     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero shorts\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n@@ -222,22 +264,6 @@\n-        int offset = 0;\n-        for (; offset < headCount; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroShort(curr)) {\n-                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n-                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n+    private static int requireWithinStringSize(long size,\n+                                               AbstractMemorySegmentImpl segment,\n+                                               long fromOffset,\n+                                               long toOffset) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n@@ -245,0 +271,2 @@\n+        return (int) size;\n+    }\n@@ -246,2 +274,4 @@\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n+    private static IllegalArgumentException stringTooLarge(AbstractMemorySegmentImpl segment,\n+                                                           long fromOffset,\n+                                                           long toOffset) {\n+        return new IllegalArgumentException(\"String too large: \" + exceptionInfo(segment, fromOffset, toOffset));\n@@ -250,8 +280,4 @@\n-    private static int strlenShort(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == (short)0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n+    private static IndexOutOfBoundsException nullNotFound(AbstractMemorySegmentImpl segment,\n+                                                          long fromOffset,\n+                                                          long toOffset) {\n+        return new IndexOutOfBoundsException(\"No null terminator found: \" + exceptionInfo(segment, fromOffset, toOffset));\n@@ -260,11 +286,4 @@\n-    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n-    \/\/ so, there is only one method for ints.\n-    public static int strlenInt(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n-            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n-            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n+    private static String exceptionInfo(AbstractMemorySegmentImpl segment,\n+                                        long fromOffset,\n+                                        long toOffset) {\n+        return segment + \" using region [\" + fromOffset + \", \" + toOffset + \")\";\n@@ -326,5 +345,0 @@\n-\n-    private static IllegalArgumentException newIaeStringTooLarge() {\n-        return new IllegalArgumentException(\"String too large\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":166,"deletions":152,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,4 @@\n+    public boolean usingAddressPairs() {\n+        return linkerOptions.allowsHeapAccess();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,3 +111,12 @@\n-                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n-                        Binding.unboxAddress(),\n-                        Binding.vmStore(abi.capturedStateStorage(), long.class)));\n+                if (linkerOptions.allowsHeapAccess()) {\n+                    addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                            Binding.dup(),\n+                            Binding.segmentBase(),\n+                            Binding.vmStore(abi.capturedStateStorage(), Object.class),\n+                            Binding.segmentOffsetAllowHeap(),\n+                            Binding.vmStore(null, long.class)));\n+                } else {\n+                    addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                            Binding.unboxAddress(),\n+                            Binding.vmStore(abi.capturedStateStorage(), long.class)));\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-            callingSequence.needsTransition()\n+            callingSequence.needsTransition(),\n+            callingSequence.usingAddressPairs()\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,5 +66,1 @@\n-        LinkerOptions linkerOptions = new LinkerOptions(optionMap);\n-        if (linkerOptions.hasCapturedCallState() && linkerOptions.isCritical()) {\n-            throw new IllegalArgumentException(\"Incompatible linker options: captureCallState, critical\");\n-        }\n-        return linkerOptions;\n+        return new LinkerOptions(optionMap);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,2 @@\n-                                        boolean needsTransition) {\n+                                        boolean needsTransition,\n+                                        boolean usingAddressPairs) {\n@@ -67,1 +68,1 @@\n-        checkType(methodType, needsReturnBuffer, capturedStateMask);\n+        checkMethodType(methodType, needsReturnBuffer, capturedStateMask, usingAddressPairs);\n@@ -83,3 +84,6 @@\n-    private static void checkType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask) {\n-        if (methodType.parameterType(0) != long.class) {\n-            throw new AssertionError(\"Address expected as first param: \" + methodType);\n+    private static void checkMethodType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask,\n+                                        boolean usingAddressPairs) {\n+        int checkIdx = 0;\n+        checkParamType(methodType, checkIdx++, long.class, \"Function address\");\n+        if (needsReturnBuffer) {\n+            checkParamType(methodType, checkIdx++, long.class, \"Return buffer address\");\n@@ -87,4 +91,13 @@\n-        int checkIdx = 1;\n-        if ((needsReturnBuffer && methodType.parameterType(checkIdx++) != long.class)\n-            || (savedValueMask != 0 && methodType.parameterType(checkIdx) != long.class)) {\n-            throw new AssertionError(\"return buffer and\/or preserved value address expected: \" + methodType);\n+        if (savedValueMask != 0) { \/\/ capturing call state\n+            if (usingAddressPairs) {\n+                checkParamType(methodType, checkIdx++, Object.class, \"Capture state heap base\");\n+                checkParamType(methodType, checkIdx, long.class, \"Capture state offset\");\n+            } else {\n+                checkParamType(methodType, checkIdx, long.class, \"Capture state address\");\n+            }\n+        }\n+    }\n+\n+    private static void checkParamType(MethodType methodType, int checkIdx, Class<?> expectedType, String name) {\n+        if (methodType.parameterType(checkIdx) != expectedType) {\n+            throw new AssertionError(name + \" expected at index \" + checkIdx + \": \" + methodType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.SequenceLayout;\n@@ -88,0 +89,1 @@\n+        assertNotEmpty(function);\n@@ -114,0 +116,1 @@\n+        assertNotEmpty(function);\n@@ -163,0 +166,1 @@\n+            Object captureStateHeapBase = null;\n@@ -165,0 +169,5 @@\n+                if (!invData.allowsHeapAccess) {\n+                    SharedUtils.checkNative(capturedState);\n+                } else {\n+                    captureStateHeapBase = capturedState.heapBase().orElse(null);\n+                }\n@@ -199,1 +208,2 @@\n-            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs, capturedState, invData.capturedStateMask(),\n+            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs,\n+                                   captureStateHeapBase, capturedState, invData.capturedStateMask(),\n@@ -328,0 +338,31 @@\n+\n+    private static void assertNotEmpty(FunctionDescriptor fd) {\n+        fd.returnLayout().ifPresent(FallbackLinker::assertNotEmpty);\n+        fd.argumentLayouts().forEach(FallbackLinker::assertNotEmpty);\n+    }\n+\n+    \/\/ Recursively tests for emptiness\n+    private static void assertNotEmpty(MemoryLayout layout) {\n+        switch (layout) {\n+            case GroupLayout gl -> {\n+                if (gl.memberLayouts().isEmpty()) {\n+                    throw empty(gl);\n+                } else {\n+                    gl.memberLayouts().forEach(FallbackLinker::assertNotEmpty);\n+                }\n+            }\n+            case SequenceLayout sl -> {\n+                if (sl.elementCount() == 0) {\n+                    throw empty(sl);\n+                } else {\n+                    assertNotEmpty(sl.elementLayout());\n+                }\n+            }\n+            default -> { \/* do nothing *\/ }\n+        }\n+    }\n+\n+    private static IllegalArgumentException empty(MemoryLayout layout) {\n+        return new IllegalArgumentException(\"The layout \" + layout + \" is empty\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                           MemorySegment capturedState, int capturedStateMask,\n+                           Object captureStateHeapBase, MemorySegment capturedState, int capturedStateMask,\n@@ -97,0 +97,1 @@\n+                       captureStateHeapBase,\n@@ -215,1 +216,1 @@\n-                                          long capturedState, int capturedStateMask,\n+                                          Object captureStateHeapBase, long capturedState, int capturedStateMask,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -326,1 +324,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -332,6 +329,2 @@\n-            return AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Boolean run() {\n-                    File file = new File(name);\n-                    return file.exists();\n-                }\n-            });\n+            File file = new File(name);\n+            return file.exists();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    private static final boolean DISABLE_JAR_CHECKING;\n+    private static final boolean JAR_CHECKING_ENABLED;\n@@ -88,1 +88,3 @@\n-        DISABLE_JAR_CHECKING = p != null ? p.equals(\"true\") || p.isEmpty() : false;\n+        \/\/ JAR check is disabled by default and will be enabled only if the \"disable JAR check\"\n+        \/\/ system property has been set to \"false\".\n+        JAR_CHECKING_ENABLED = \"false\".equals(p);\n@@ -656,2 +658,4 @@\n-        \/* Throws if the given jar file is does not start with the correct LOC *\/\n-        @SuppressWarnings(\"removal\")\n+        \/*\n+         * Throws an IOException if the LOC file Header Signature (0x04034b50),\n+         * is not found starting at byte 0 of the given jar.\n+         *\/\n@@ -659,2 +663,1 @@\n-            if (System.getSecurityManager() != null && !DISABLE_JAR_CHECKING\n-                && !zipAccess.startsWithLocHeader(jar)) {\n+            if (JAR_CHECKING_ENABLED && !zipAccess.startsWithLocHeader(jar)) {\n@@ -669,1 +672,0 @@\n-\n@@ -907,1 +909,5 @@\n-            path = ParseUtil.decode(path);\n+            try {\n+                path = ParseUtil.decode(path);\n+            } catch (IllegalArgumentException iae) {\n+                throw new IOException(iae);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -345,2 +345,0 @@\n-            \/\/ This is just an optimization to avoid the cost of calling\n-            \/\/ doPrivileged every time.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LazyLoggers.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,2 +151,0 @@\n-            \/\/ Iterator iterates with the access control context stored\n-            \/\/ at ServiceLoader creation time.\n@@ -200,2 +198,0 @@\n-            \/\/ Iterator iterates with the access control context stored\n-            \/\/ at ServiceLoader creation time.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LoggerFinderLoader.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * A thread that has no permissions, is not a member of any user-defined\n+ * A thread that is not a member of any user-defined\n@@ -34,1 +34,0 @@\n-@SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/InnocuousThread.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.Permission;\n-import java.security.PrivilegedAction;\n@@ -52,1 +50,0 @@\n- * @see      jdk.internal.perf.Perf.GetPerfAction\n@@ -61,40 +58,0 @@\n-    \/**\n-     * The GetPerfAction class is a convenience class for acquiring access\n-     * to the singleton Perf instance using the\n-     * <code>AccessController.doPrivileged()<\/code> method.\n-     * <p>\n-     * An instance of this class can be used as the argument to\n-     * <code>AccessController.doPrivileged(PrivilegedAction)<\/code>.\n-     * <p> Here is a suggested idiom for use of this class:\n-     *\n-     * <blockquote><pre>{@code\n-     * class MyTrustedClass {\n-     *   private static final Perf perf =\n-     *       AccessController.doPrivileged(new Perf.GetPerfAction<Perf>());\n-     *   ...\n-     * }\n-     * }<\/pre><\/blockquote>\n-     * <p>\n-     * In the presence of a security manager, the <code>MyTrustedClass<\/code>\n-     * class in the above example will need to be granted the\n-     * <em>\"sun.misc.Perf.getPerf\"<\/em> <code>RuntimePermission<\/code>\n-     * permission in order to successfully acquire the singleton Perf instance.\n-     * <p>\n-     * Please note that the <em>\"sun.misc.Perf.getPerf\"<\/em> permission\n-     * is not a JDK specified permission.\n-     *\n-     * @see  java.security.AccessController#doPrivileged(PrivilegedAction)\n-     * @see  java.lang.RuntimePermission\n-     *\/\n-    public static class GetPerfAction implements PrivilegedAction<Perf>\n-    {\n-        \/**\n-         * Run the <code>Perf.getPerf()<\/code> method in a privileged context.\n-         *\n-         * @see #getPerf\n-         *\/\n-        public Perf run() {\n-            return getPerf();\n-        }\n-    }\n-\n@@ -109,5 +66,0 @@\n-     * If a security manager is installed, its <code>checkPermission<\/code>\n-     * method is called with a <code>RuntimePermission<\/code> with a target\n-     * of <em>\"sun.misc.Perf.getPerf\"<\/em>. A security exception will result\n-     * if the caller has not been granted this permission.\n-     * <p>\n@@ -122,3 +74,0 @@\n-     * <p>\n-     * Please note that the <em>\"sun.misc.Perf.getPerf\"<\/em> permission\n-     * is not a JDK specified permission.\n@@ -127,4 +76,0 @@\n-     * @throws SecurityException  if a security manager exists and its\n-     *         <code>checkPermission<\/code> method doesn't allow access\n-     *         to the <em>\"jdk.internal.perf.Perf.getPerf\"\"<\/em> target.\n-     * @see  java.lang.RuntimePermission\n@@ -135,7 +80,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            Permission perm = new RuntimePermission(\"jdk.internal.perf.Perf.getPerf\");\n-            security.checkPermission(perm);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/perf\/Perf.java","additions":1,"deletions":63,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.security.AccessController;\n@@ -51,3 +50,1 @@\n-    @SuppressWarnings(\"removal\")\n-    private static final Perf perf =\n-        AccessController.doPrivileged(new Perf.GetPerfAction());\n+    private static final Perf perf = Perf.getPerf();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/perf\/PerfCounter.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -139,1 +137,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -146,8 +143,5 @@\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    public Void run() {\n-                        if (System.err != null)\n-                            new Error(\"Cleaner terminated abnormally\", x)\n-                                .printStackTrace();\n-                        System.exit(1);\n-                        return null;\n-                    }});\n+            if (System.err != null) {\n+                new Error(\"Cleaner terminated abnormally\", x)\n+                        .printStackTrace();\n+            }\n+            System.exit(1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/Cleaner.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-     * Heads of a CleanableList for each reference type.\n+     * Currently active PhantomCleanable-s.\n@@ -59,1 +59,1 @@\n-    final PhantomCleanable<?> phantomCleanableList;\n+    final CleanableList activeList;\n@@ -93,1 +93,1 @@\n-        phantomCleanableList = new PhantomCleanableRef();\n+        activeList = new CleanableList();\n@@ -141,1 +141,1 @@\n-        while (!phantomCleanableList.isListEmpty()) {\n+        while (!activeList.isEmpty()) {\n@@ -148,4 +148,6 @@\n-                synchronized (phantomCleanableList) {\n-                    for (var ref = phantomCleanableList.next; ref != phantomCleanableList; ref = ref.next) {\n-                        if (ref.refersTo(null)) {\n-                            refArr.add(ref);\n+                synchronized (activeList) {\n+                    for (var node = activeList.head; node != null; node = node.next) {\n+                        for (int i = node.size - 1; i >= 0; --i) {\n+                            if (node.arr[i].refersTo(null)) {\n+                                refArr.add(node.arr[i]);\n+                            }\n@@ -189,1 +191,1 @@\n-        if (phantomCleanableList.isListEmpty()) {\n+        if (activeList.isEmpty()) {\n@@ -221,8 +223,0 @@\n-        \/**\n-         * Constructor used only for root of phantom cleanable list.\n-         *\/\n-        PhantomCleanableRef() {\n-            super();\n-            this.action = null;\n-        }\n-\n@@ -292,0 +286,133 @@\n+\n+    \/**\n+     * A specialized implementation that tracks phantom cleanables.\n+     *\/\n+    static final class CleanableList {\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node where PhantomCleanables are\n+         * added to or removed from. This is the only node with variable size,\n+         * all other nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n+\n+        \/**\n+         * Cached node instance to provide better behavior near NODE_CAPACITY\n+         * threshold: if list size flips around NODE_CAPACITY, it would reuse\n+         * the cached node instead of wasting and re-allocating a new node all\n+         * the time.\n+         *\/\n+        private Node cache;\n+\n+        public CleanableList() {\n+            reset();\n+        }\n+\n+        \/**\n+         * Testing support: reset list to initial state.\n+         *\/\n+        synchronized void reset() {\n+            this.head = new Node();\n+        }\n+\n+        \/**\n+         * Returns true if cleanable list is empty.\n+         *\n+         * @return true if the list is empty\n+         *\/\n+        public synchronized boolean isEmpty() {\n+            \/\/ Head node size is zero only when the entire list is empty.\n+            return head.size == 0;\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleanable in the list.\n+         *\/\n+        public synchronized void insert(PhantomCleanable<?> phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head node is full, insert new one.\n+                \/\/ If possible, pick a pre-allocated node from cache.\n+                Node newHead;\n+                if (cache != null) {\n+                    newHead = cache;\n+                    cache = null;\n+                } else {\n+                    newHead = new Node();\n+                }\n+                newHead.next = head;\n+                head = newHead;\n+            }\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            final int lastIndex = head.size;\n+            phc.node = head;\n+            phc.index = lastIndex;\n+            head.arr[lastIndex] = phc;\n+            head.size++;\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleanable from the list.\n+         *\n+         * @return true if Cleanable was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public synchronized boolean remove(PhantomCleanable<?> phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            final int lastIndex = head.size - 1;\n+            assert lastIndex >= 0;\n+            if (head != phc.node || (phc.index != lastIndex)) {\n+                PhantomCleanable<?> mover = head.arr[lastIndex];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n+\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head node.\n+            head.arr[lastIndex] = null;\n+            head.size--;\n+\n+            \/\/ If head node becomes empty after this, and there are\n+            \/\/ nodes that follow it, replace the head node with another\n+            \/\/ full one. If needed, stash the now free node in cache.\n+            if (head.size == 0 && head.next != null) {\n+                Node newHead = head.next;\n+                if (cache == null) {\n+                    cache = head;\n+                    cache.next = null;\n+                }\n+                head = newHead;\n+            }\n+\n+            return true;\n+        }\n+\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleanables, and the amount of elements in it.\n+            final PhantomCleanable<?>[] arr = new PhantomCleanable<?>[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node next;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":144,"deletions":17,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     * Links to previous and next in a doubly-linked list.\n+     * The list of PhantomCleanable; synchronizes insert and remove.\n@@ -49,1 +49,1 @@\n-    PhantomCleanable<?> prev = this, next = this;\n+    private final CleanerImpl.CleanableList list;\n@@ -52,1 +52,2 @@\n-     * The list of PhantomCleanable; synchronizes insert and remove.\n+     * Node for this PhantomCleanable in the list.\n+     * Synchronized by the same lock as the list itself.\n@@ -54,1 +55,7 @@\n-    private final PhantomCleanable<?> list;\n+    CleanerImpl.CleanableList.Node node;\n+\n+    \/**\n+     * Index of this PhantomCleanable in the list node.\n+     * Synchronized by the same lock as the list itself.\n+     *\/\n+    int index;\n@@ -65,0 +72,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -67,2 +75,7 @@\n-        this.list = CleanerImpl.getCleanerImpl(cleaner).phantomCleanableList;\n-        insert();\n+        index = -1;\n+        list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n+        list.insert(this);\n+\n+        \/\/ Check that list insertion populated the backlinks.\n+        assert node != null;\n+        assert index >= 0;\n@@ -75,50 +88,0 @@\n-    \/**\n-     * Construct a new root of the list; not inserted.\n-     *\/\n-    PhantomCleanable() {\n-        super(null, null);\n-        this.list = this;\n-    }\n-\n-    \/**\n-     * Insert this PhantomCleanable after the list head.\n-     *\/\n-    private void insert() {\n-        synchronized (list) {\n-            prev = list;\n-            next = list.next;\n-            next.prev = this;\n-            list.next = this;\n-        }\n-    }\n-\n-    \/**\n-     * Remove this PhantomCleanable from the list.\n-     *\n-     * @return true if Cleanable was removed or false if not because\n-     * it had already been removed before\n-     *\/\n-    private boolean remove() {\n-        synchronized (list) {\n-            if (next != this) {\n-                next.prev = prev;\n-                prev.next = next;\n-                prev = this;\n-                next = this;\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if the list's next reference refers to itself.\n-     *\n-     * @return true if the list is empty\n-     *\/\n-    boolean isListEmpty() {\n-        synchronized (list) {\n-            return list == list.next;\n-        }\n-    }\n-\n@@ -131,1 +94,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n@@ -143,1 +106,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":21,"deletions":58,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        assert !Modifier.isNative(method.getModifiers());\n+        assert !MethodHandleAccessorFactory.isSignaturePolymorphicMethod(method);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodHandleAccessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -212,1 +213,1 @@\n-        var mtype = methodType(method.getReturnType(), method.getParameterTypes());\n+        var mtype = methodType(method.getReturnType(), reflectionFactory.getExecutableSharedParameterTypes(method));\n@@ -234,1 +235,1 @@\n-        MethodType mtype = methodType(method.getReturnType(), method.getParameterTypes())\n+        MethodType mtype = methodType(method.getReturnType(), reflectionFactory.getExecutableSharedParameterTypes(method))\n@@ -350,2 +351,2 @@\n-     * 2. a Java native method\n-     * 3. -Djdk.reflect.useNativeAccessorOnly=true is set\n+     * 2. -Djdk.reflect.useNativeAccessorOnly=true is set\n+     * 3. a signature polymorphic method\n@@ -356,0 +357,1 @@\n+     * Conditions 3-5 are due to the restrictions of method handles.\n@@ -362,1 +364,1 @@\n-        if (Modifier.isNative(member.getModifiers()))\n+        if (ReflectionFactory.useNativeAccessorOnly())  \/\/ for testing only\n@@ -365,1 +367,4 @@\n-        if (ReflectionFactory.useNativeAccessorOnly())  \/\/ for testing only\n+        \/\/ java.lang.invoke cannot find the underlying native stubs of signature\n+        \/\/ polymorphic methods that core reflection must invoke.\n+        \/\/ Fall back to use the native implementation instead.\n+        if (member instanceof Method method && isSignaturePolymorphicMethod(method))\n@@ -368,7 +373,5 @@\n-        \/\/ MethodHandle::withVarargs on a member with varargs modifier bit set\n-        \/\/ verifies that the last parameter of the member must be an array type.\n-        \/\/ The JVMS does not require the last parameter descriptor of the method descriptor\n-        \/\/ is an array type if the ACC_VARARGS flag is set in the access_flags item.\n-        \/\/ Hence the reflection implementation does not check the last parameter type\n-        \/\/ if ACC_VARARGS flag is set.  Workaround this by invoking through\n-        \/\/ the native accessor.\n+        \/\/ For members with ACC_VARARGS bit set, MethodHandles produced by lookup\n+        \/\/ always have variable arity set and hence the last parameter of the member\n+        \/\/ must be an array type.  Such restriction does not exist in core reflection\n+        \/\/ and the JVM, which always use fixed-arity invocations.  Fall back to use\n+        \/\/ the native implementation instead.\n@@ -377,1 +380,1 @@\n-                (paramCount == 0 || !(member.getParameterTypes()[paramCount-1].isArray()))) {\n+                (paramCount == 0 || !(reflectionFactory.getExecutableSharedParameterTypes(member)[paramCount-1].isArray()))) {\n@@ -380,0 +383,1 @@\n+\n@@ -399,1 +403,1 @@\n-        Class<?>[] ptypes = member.getParameterTypes();\n+        Class<?>[] ptypes = reflectionFactory.getExecutableSharedParameterTypes(member);\n@@ -409,0 +413,25 @@\n+    \/**\n+     * Signature-polymorphic methods.  Lookup has special rules for these methods,\n+     * but core reflection must observe them as they are declared, and reflective\n+     * invocation must invoke the native method stubs that throw UOE.\n+     *\n+     * @param method the method to check\n+     * @return {@code true} if this method is signature polymorphic\n+     * @jls 15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?\n+     * @jvms 2.9.3 Signature Polymorphic Methods\n+     *\/\n+    public static boolean isSignaturePolymorphicMethod(Method method) {\n+        \/\/ ACC_NATIVE and ACC_VARARGS\n+        if (!method.isVarArgs() || !Modifier.isNative(method.getModifiers())) {\n+            return false;\n+        }\n+        \/\/ Declared in MethodHandle or VarHandle\n+        var declaringClass = method.getDeclaringClass();\n+        if (declaringClass != MethodHandle.class && declaringClass != VarHandle.class) {\n+            return false;\n+        }\n+        \/\/ Single parameter of declared type Object[]\n+        Class<?>[] parameters = reflectionFactory.getExecutableSharedParameterTypes(method);\n+        return parameters.length == 1 && parameters[0] == Object[].class;\n+    }\n+\n@@ -417,0 +446,1 @@\n+    private static final ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.security.PrivilegedAction;\n@@ -78,16 +77,0 @@\n-    \/**\n-     * A convenience class for acquiring the capability to instantiate\n-     * reflective objects.  Use this instead of a raw call to {@link\n-     * #getReflectionFactory} in order to avoid being limited by the\n-     * permissions of your callers.\n-     *\n-     * <p>An instance of this class can be used as the argument of\n-     * <code>AccessController.doPrivileged<\/code>.\n-     *\/\n-    public static final class GetReflectionFactoryAction\n-        implements PrivilegedAction<ReflectionFactory> {\n-        public ReflectionFactory run() {\n-            return getReflectionFactory();\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -54,1 +53,1 @@\n-        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveScopedValueCache\");\n+        String value = System.getProperty(\"jdk.preserveScopedValueCache\");\n@@ -506,1 +505,1 @@\n-        String value = GetPropertyAction.privilegedGetProperty(property);\n+        String value = System.getProperty(property);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.nio.ch.Poller;\n+\n+\/**\n+ * The implementation for the jcmd Thread.vthread_* diagnostic commands. These methods are\n+ * called from the \"Attach Listener\" thread.\n+ *\/\n+public class JcmdVThreadCommands {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private JcmdVThreadCommands() { }\n+\n+    \/**\n+     * Invoked by the VM to print the virtual scheduler to a byte[].\n+     *\/\n+    private static byte[] printScheduler() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        \/\/ virtual thread scheduler\n+        sb.append(JLA.virtualThreadDefaultScheduler())\n+          .append(System.lineSeparator());\n+\n+        \/\/ break\n+        sb.append(System.lineSeparator());\n+\n+        \/\/ delayed task schedulers\n+        sb.append(\"Delayed task schedulers:\").append(System.lineSeparator());\n+        var delayedTaskSchedulers = JLA.virtualThreadDelayedTaskSchedulers().toList();\n+        IntStream.range(0, delayedTaskSchedulers.size())\n+                .forEach(i -> sb.append('[')\n+                                .append(i)\n+                                .append(\"] \")\n+                                .append(delayedTaskSchedulers.get(i))\n+                                .append(System.lineSeparator()));\n+\n+        return sb.toString().getBytes(StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Invoked by the VM to print the I\/O pollers to a byte[].\n+     *\/\n+    private static byte[] printPollers() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        Poller masterPoller = Poller.masterPoller();\n+        List<Poller> readPollers = Poller.readPollers();\n+        List<Poller> writePollers = Poller.writePollers();\n+\n+        if (masterPoller != null) {\n+            sb.append(\"Master I\/O poller:\")\n+              .append(System.lineSeparator())\n+              .append(masterPoller)\n+              .append(System.lineSeparator());\n+\n+            \/\/ break\n+            sb.append(System.lineSeparator());\n+        }\n+\n+        sb.append(\"Read I\/O pollers:\");\n+        sb.append(System.lineSeparator());\n+        IntStream.range(0, readPollers.size())\n+                .forEach(i -> sb.append('[')\n+                                .append(i)\n+                                .append(\"] \")\n+                                .append(readPollers.get(i))\n+                                .append(System.lineSeparator()));\n+\n+        \/\/ break\n+        sb.append(System.lineSeparator());\n+\n+        sb.append(\"Write I\/O pollers:\");\n+        sb.append(System.lineSeparator());\n+        IntStream.range(0, writePollers.size())\n+                .forEach(i -> sb.append('[')\n+                                .append(i)\n+                                .append(\"] \")\n+                                .append(writePollers.get(i))\n+                                .append(System.lineSeparator()));\n+\n+        return sb.toString().getBytes(StandardCharsets.UTF_8);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/JcmdVThreadCommands.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -55,1 +54,1 @@\n-        String s = GetPropertyAction.privilegedGetProperty(\"jdk.trackAllThreads\");\n+        String s = System.getProperty(\"jdk.trackAllThreads\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainers.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-    exports java.lang.classfile.components;\n@@ -183,0 +182,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -321,2 +322,0 @@\n-        java.management.rmi,\n-        java.rmi,\n@@ -335,1 +334,0 @@\n-        java.rmi,\n@@ -350,1 +348,0 @@\n-        java.rmi,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -592,0 +592,9 @@\n+    \/**\n+     * Prints the short usage text to the desired output stream.\n+     *\/\n+    static void printConciseUsageMessage(boolean printToStderr) {\n+        initOutput(printToStderr);\n+        ostream.println(getLocalizedMessage(\"java.launcher.opt.concise.header\",\n+                File.pathSeparator));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\\   or  {0} [options] -jar <jarfile> [args...]\\n\\\n+\\   or  {0} [options] -jar <jarfile>.jar [args...]\\n\\\n@@ -34,1 +34,1 @@\n-\\   or  {0} [options] <sourcefile> [args]\\n\\\n+\\   or  {0} [options] <sourcefile>.java [args]\\n\\\n@@ -36,1 +36,1 @@\n-\\ Arguments following the main class, source file, -jar <jarfile>,\\n\\\n+\\ Arguments following the main class, source file, -jar <jarfile>.jar,\\n\\\n@@ -49,1 +49,1 @@\n-\\                  A {0} separated list of directories, JAR archives,\\n\\\n+\\                  A \"{0}\"-separated list of directories, JAR archives,\\n\\\n@@ -53,1 +53,1 @@\n-\\                  A {0} separated list of elements, each element is a file path\\n\\\n+\\                  A \"{0}\"-separated list of elements, each element is a file path\\n\\\n@@ -57,1 +57,1 @@\n-\\                  A {0} separated list of elements, each element is a file path\\n\\\n+\\                  A \"{0}\"-separated list of elements, each element is a file path\\n\\\n@@ -235,0 +235,17 @@\n+# Translators please note do not translate the options themselves\n+java.launcher.opt.concise.header  =   Usage: java [java options...] <application> [application arguments...]\\n\\n\\\n+\\Where <application> is one of:\\n\\\n+\\  <mainclass>                to execute the main method of a compiled main class\\n\\\n+\\  -jar <jarfile>.jar         to execute the main class of a JAR archive\\n\\\n+\\  -m <module>[\/<mainclass>]  to execute the main class of a module\\n\\\n+\\  <sourcefile>.java          to compile and execute a source-file program\\n\\n\\\n+\\Where key java options include:\\n\\\n+\\  --class-path <class path>\\n\\\n+\\    where <class path> is a list of directories and JAR archives to search for class files, separated by \"{0}\"\\n\\\n+\\  --module-path <module path>\\n\\\n+\\    where <module path> is a list of directories and JAR archives to search for modules, separated by \"{0}\"\\n\\\n+\\  -version\\n\\\n+\\    to print product version to the error stream and exit\\n\\n\\\n+\\For additional help on usage:           java --help\\n\\\n+\\For an interactive Java environment:    jshell\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -713,1 +713,1 @@\n-            if (privilegedLocalHost().getHostAddress().equals(s)) {\n+            if (getLocalHost().getHostAddress().equals(s)) {\n@@ -719,1 +719,1 @@\n-            if (privilegedLocalHost().equals(address)) {\n+            if (getLocalHost().equals(address)) {\n@@ -727,1 +727,1 @@\n-            InetAddress[] names = privilegedGetAllByName(hostName);\n+            InetAddress[] names = getAllByName(hostName);\n@@ -741,1 +741,1 @@\n-    private static InetAddress privilegedLocalHost() throws FtpProtocolException {\n+    private static InetAddress getLocalHost() throws FtpProtocolException {\n@@ -751,1 +751,1 @@\n-    private static InetAddress[] privilegedGetAllByName(String hostName) throws FtpProtocolException {\n+    private static InetAddress[] getAllByName(String hostName) throws FtpProtocolException {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ftp\/impl\/FtpClient.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+     * @throws IllegalArgumentException if {@code s} could not be decoded\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/ParseUtil.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveStream.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.nio.channels.AlreadyConnectedException;\n@@ -169,0 +170,2 @@\n+        else if (x instanceof AlreadyConnectedException)\n+            nx = newSocketException(\"Already connected\");\n@@ -193,4 +196,1 @@\n-    static void translateException(Exception x,\n-                                   boolean unknownHostForUnresolved)\n-        throws IOException\n-    {\n+    static void translateException(Exception x) throws IOException {\n@@ -199,7 +199,0 @@\n-        \/\/ Throw UnknownHostException from here since it cannot\n-        \/\/ be thrown as a SocketException\n-        if (unknownHostForUnresolved &&\n-            (x instanceof UnresolvedAddressException))\n-        {\n-             throw new UnknownHostException();\n-        }\n@@ -209,10 +202,0 @@\n-    static void translateException(Exception x)\n-        throws IOException\n-    {\n-        translateException(x, false);\n-    }\n-\n-    private static InetSocketAddress getLoopbackAddress(int port) {\n-        return new InetSocketAddress(InetAddress.getLoopbackAddress(), port);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-            if (ioe instanceof InterruptedIOException) {\n+            if (ioe instanceof SocketTimeoutException) {\n@@ -610,0 +610,3 @@\n+            } else if (ioe instanceof InterruptedIOException) {\n+                assert Thread.currentThread().isVirtual();\n+                throw new SocketException(\"Closed by interrupt\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -56,0 +57,3 @@\n+    \/\/ the poller or sub-poller thread\n+    private @Stable Thread owner;\n+\n@@ -241,0 +245,1 @@\n+        owner = Thread.currentThread();\n@@ -261,0 +266,1 @@\n+        owner = Thread.currentThread();\n@@ -285,1 +291,2 @@\n-        return Objects.toIdentityString(this) + \" [registered = \" + registered() + \"]\";\n+        return String.format(\"%s [registered = %d, owner = %s]\",\n+                Objects.toIdentityString(this), registered(), owner);\n@@ -445,0 +452,21 @@\n+\n+    \/**\n+     * Return the master poller or null if there is no master poller.\n+     *\/\n+    public static Poller masterPoller() {\n+        return POLLERS.masterPoller();\n+    }\n+\n+    \/**\n+     * Return the list of read pollers.\n+     *\/\n+    public static List<Poller> readPollers() {\n+        return POLLERS.readPollers();\n+    }\n+\n+    \/**\n+     * Return the list of write pollers.\n+     *\/\n+    public static List<Poller> writePollers() {\n+        return POLLERS.writePollers();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.net.UnknownHostException;\n@@ -88,0 +89,8 @@\n+        if (remote instanceof InetSocketAddress isa && isa.isUnresolved()) {\n+            if (!sc.isOpen())\n+                throw new SocketException(\"Socket is closed\");\n+            if (sc.isConnected())\n+                throw new SocketException(\"Already connected\");\n+            close();\n+            throw new UnknownHostException(remote.toString());\n+        }\n@@ -98,1 +107,1 @@\n-            Net.translateException(e, true);\n+            Net.translateException(e);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketAdaptor.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.lang.reflect.Member;\n@@ -44,1 +43,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -138,7 +136,3 @@\n-        if (genericDeclaration instanceof Class<?> c)\n-            ReflectUtil.checkPackageAccess(c);\n-        else if ((genericDeclaration instanceof Method) ||\n-                (genericDeclaration instanceof Constructor))\n-            ReflectUtil.conservativeCheckMemberAccess((Member)genericDeclaration);\n-        else\n-            throw new AssertionError(\"Unexpected kind of GenericDeclaration\");\n+        assert genericDeclaration instanceof Class<?> ||\n+                genericDeclaration instanceof Method ||\n+                genericDeclaration instanceof Constructor : \"Unexpected kind of GenericDeclaration\";\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/TypeVariableImpl.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.misc;\n-\n-import java.lang.reflect.Constructor;\n-\n-public final class ConstructorUtil {\n-\n-    private ConstructorUtil() {\n-    }\n-\n-    public static Constructor<?> getConstructor(Class<?> cls, Class<?>[] params)\n-        throws NoSuchMethodException {\n-        ReflectUtil.checkPackageAccess(cls);\n-        return cls.getConstructor(params);\n-    }\n-\n-    public static Constructor<?>[] getConstructors(Class<?> cls) {\n-        ReflectUtil.checkPackageAccess(cls);\n-        return cls.getConstructors();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ConstructorUtil.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.misc;\n-\n-import java.lang.reflect.Field;\n-\n-\/*\n- * Create a trampoline class.\n- *\/\n-public final class FieldUtil {\n-\n-    private FieldUtil() {\n-    }\n-\n-    public static Field getField(Class<?> cls, String name)\n-        throws NoSuchFieldException {\n-        ReflectUtil.checkPackageAccess(cls);\n-        return cls.getField(name);\n-    }\n-\n-    public static Field[] getFields(Class<?> cls) {\n-        ReflectUtil.checkPackageAccess(cls);\n-        return cls.getFields();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/FieldUtil.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,0 @@\n-        ReflectUtil.checkPackageAccess(cls);\n@@ -86,5 +85,0 @@\n-    public static Method[] getMethods(Class<?> cls) {\n-        ReflectUtil.checkPackageAccess(cls);\n-        return cls.getMethods();\n-    }\n-\n@@ -143,1 +137,0 @@\n-        ReflectUtil.checkPackageAccess(name);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/MethodUtil.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.lang.reflect.Member;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Proxy;\n@@ -70,108 +66,0 @@\n-\n-    \/**\n-     * Does nothing.\n-     *\/\n-    public static void conservativeCheckMemberAccess(Member m) {\n-    }\n-\n-    \/**\n-     * Does nothing.\n-     *\/\n-    public static void checkPackageAccess(Class<?> clazz) {\n-    }\n-\n-    \/**\n-     * Does nothing\n-     *\/\n-    public static void checkPackageAccess(String name) {\n-    }\n-\n-    \/**\n-     * Returns true.\n-     *\/\n-    public static boolean isPackageAccessible(Class<?> clazz) {\n-        return true;\n-    }\n-\n-    \/**\n-     * Returns false.\n-     *\/\n-    public static boolean needsPackageAccessCheck(ClassLoader from, ClassLoader to) {\n-        return false;\n-    }\n-\n-    \/**\n-     * Does nothing\n-     *\/\n-    public static void checkProxyPackageAccess(Class<?> clazz) {\n-    }\n-\n-    \/**\n-     * Does nothing.\n-     *\/\n-    public static void checkProxyPackageAccess(ClassLoader ccl,\n-                                               Class<?>... interfaces) {\n-    }\n-\n-    \/\/ Note that bytecode instrumentation tools may exclude 'sun.*'\n-    \/\/ classes but not generated proxy classes and so keep it in com.sun.*\n-    public static final String PROXY_PACKAGE = \"com.sun.proxy\";\n-\n-    \/**\n-     * Test if the given class is a proxy class that implements\n-     * non-public interface.  Such proxy class may be in a non-restricted\n-     * package that bypasses checkPackageAccess.\n-     *\/\n-    public static boolean isNonPublicProxyClass(Class<?> cls) {\n-        if (!Proxy.isProxyClass(cls)) {\n-            return false;\n-        }\n-        return !Modifier.isPublic(cls.getModifiers());\n-    }\n-\n-    \/**\n-     * Check if the given method is a method declared in the proxy interface\n-     * implemented by the given proxy instance.\n-     *\n-     * @param proxy a proxy instance\n-     * @param method an interface method dispatched to a InvocationHandler\n-     *\n-     * @throws IllegalArgumentException if the given proxy or method is invalid.\n-     *\/\n-    public static void checkProxyMethod(Object proxy, Method method) {\n-        \/\/ check if it is a valid proxy instance\n-        if (proxy == null || !Proxy.isProxyClass(proxy.getClass())) {\n-            throw new IllegalArgumentException(\"Not a Proxy instance\");\n-        }\n-        if (Modifier.isStatic(method.getModifiers())) {\n-            throw new IllegalArgumentException(\"Can't handle static method\");\n-        }\n-\n-        Class<?> c = method.getDeclaringClass();\n-        if (c == Object.class) {\n-            String name = method.getName();\n-            if (name.equals(\"hashCode\") || name.equals(\"equals\") || name.equals(\"toString\")) {\n-                return;\n-            }\n-        }\n-\n-        if (isSuperInterface(proxy.getClass(), c)) {\n-            return;\n-        }\n-\n-        \/\/ disallow any method not declared in one of the proxy interfaces\n-        throw new IllegalArgumentException(\"Can't handle: \" + method);\n-    }\n-\n-    private static boolean isSuperInterface(Class<?> c, Class<?> intf) {\n-        for (Class<?> i : c.getInterfaces()) {\n-            if (i == intf) {\n-                return true;\n-            }\n-            if (isSuperInterface(i, intf)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.action;\n-\n-import java.security.AccessController;\n-\n-\/**\n- * A convenience class for retrieving the boolean value of a system property\n- * as a privileged action.\n- *\n- * <p>An instance of this class can be used as the argument of\n- * <code>AccessController.doPrivileged<\/code>.\n- *\n- * <p>The following code retrieves the boolean value of the system\n- * property named <code>\"prop\"<\/code> as a privileged action:\n- *\n- * <pre>\n- * boolean b = java.security.AccessController.doPrivileged\n- *              (new GetBooleanAction(\"prop\")).booleanValue();\n- * <\/pre>\n- *\n- * @author Roland Schemers\n- * @see java.security.PrivilegedAction\n- * @see java.security.AccessController\n- * @since 1.2\n- *\/\n-\n-public class GetBooleanAction\n-        implements java.security.PrivilegedAction<Boolean> {\n-    private final String theProp;\n-\n-    \/**\n-     * Constructor that takes the name of the system property whose boolean\n-     * value needs to be determined.\n-     *\n-     * @param theProp the name of the system property.\n-     *\/\n-    public GetBooleanAction(String theProp) {\n-        this.theProp = theProp;\n-    }\n-\n-    \/**\n-     * Determines the boolean value of the system property whose name was\n-     * specified in the constructor.\n-     *\n-     * @return the <code>Boolean<\/code> value of the system property.\n-     *\/\n-    public Boolean run() {\n-        return Boolean.getBoolean(theProp);\n-    }\n-\n-    \/**\n-     * Convenience method to get a property without going through doPrivileged\n-     * if no security manager is present. This is unsafe for inclusion in a\n-     * public API but allowable here since this class is now encapsulated.\n-     *\n-     * Note that this method performs a privileged action using caller-provided\n-     * inputs. The caller of this method should take care to ensure that the\n-     * inputs are not tainted and the returned property is not made accessible\n-     * to untrusted code if it contains sensitive information.\n-     *\n-     * @param theProp the name of the system property.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static boolean privilegedGetProperty(String theProp) {\n-        if (System.getSecurityManager() == null) {\n-            return Boolean.getBoolean(theProp);\n-        } else {\n-            return AccessController.doPrivileged(\n-                    new GetBooleanAction(theProp));\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetBooleanAction.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.action;\n-\n-import java.security.AccessController;\n-\n-\/**\n- * A convenience class for retrieving the integer value of a system property\n- * as a privileged action.\n- *\n- * <p>An instance of this class can be used as the argument of\n- * <code>AccessController.doPrivileged<\/code>.\n- *\n- * <p>The following code retrieves the integer value of the system\n- * property named <code>\"prop\"<\/code> as a privileged action. Since it does\n- * not pass a default value to be used in case the property\n- * <code>\"prop\"<\/code> is not defined, it has to check the result for\n- * <code>null<\/code>:\n- *\n- * <pre>\n- * Integer tmp = java.security.AccessController.doPrivileged\n- *     (new sun.security.action.GetIntegerAction(\"prop\"));\n- * int i;\n- * if (tmp != null) {\n- *     i = tmp.intValue();\n- * }\n- * <\/pre>\n- *\n- * <p>The following code retrieves the integer value of the system\n- * property named <code>\"prop\"<\/code> as a privileged action, and also passes\n- * a default value to be used in case the property <code>\"prop\"<\/code> is not\n- * defined:\n- *\n- * <pre>\n- * int i = ((Integer)java.security.AccessController.doPrivileged(\n- *                         new GetIntegerAction(\"prop\", 3))).intValue();\n- * <\/pre>\n- *\n- * @author Roland Schemers\n- * @see java.security.PrivilegedAction\n- * @see java.security.AccessController\n- * @since 1.2\n- *\/\n-\n-public class GetIntegerAction\n-        implements java.security.PrivilegedAction<Integer> {\n-    private final String theProp;\n-    private final int defaultVal;\n-    private final boolean defaultSet;\n-\n-    \/**\n-     * Constructor that takes the name of the system property whose integer\n-     * value needs to be determined.\n-     *\n-     * @param theProp the name of the system property.\n-     *\/\n-    public GetIntegerAction(String theProp) {\n-        this.theProp = theProp;\n-        this.defaultVal = 0;\n-        this.defaultSet = false;\n-    }\n-\n-    \/**\n-     * Constructor that takes the name of the system property and the default\n-     * value of that property.\n-     *\n-     * @param theProp the name of the system property.\n-     * @param defaultVal the default value.\n-     *\/\n-    public GetIntegerAction(String theProp, int defaultVal) {\n-        this.theProp = theProp;\n-        this.defaultVal = defaultVal;\n-        this.defaultSet = true;\n-    }\n-\n-    \/**\n-     * Determines the integer value of the system property whose name was\n-     * specified in the constructor.\n-     *\n-     * <p>If there is no property of the specified name, or if the property\n-     * does not have the correct numeric format, then an <code>Integer<\/code>\n-     * object representing the default value that was specified in the\n-     * constructor is returned, or <code>null<\/code> if no default value was\n-     * specified.\n-     *\n-     * @return the <code>Integer<\/code> value of the property.\n-     *\/\n-    public Integer run() {\n-        Integer value = Integer.getInteger(theProp);\n-        if ((value == null) && defaultSet)\n-            return defaultVal;\n-        return value;\n-    }\n-\n-    \/**\n-     * Convenience method to get a property without going through doPrivileged\n-     * if no security manager is present. This is unsafe for inclusion in a\n-     * public API but allowable here since this class is now encapsulated.\n-     *\n-     * Note that this method performs a privileged action using caller-provided\n-     * inputs. The caller of this method should take care to ensure that the\n-     * inputs are not tainted and the returned property is not made accessible\n-     * to untrusted code if it contains sensitive information.\n-     *\n-     * @param theProp the name of the system property.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static Integer privilegedGetProperty(String theProp) {\n-        if (System.getSecurityManager() == null) {\n-            return Integer.getInteger(theProp);\n-        } else {\n-            return AccessController.doPrivileged(\n-                    new GetIntegerAction(theProp));\n-        }\n-    }\n-\n-    \/**\n-     * Convenience method to get a property without going through doPrivileged\n-     * if no security manager is present. This is unsafe for inclusion in a\n-     * public API but allowable here since this class is now encapsulated.\n-     *\n-     * Note that this method performs a privileged action using caller-provided\n-     * inputs. The caller of this method should take care to ensure that the\n-     * inputs are not tainted and the returned property is not made accessible\n-     * to untrusted code if it contains sensitive information.\n-     *\n-     * @param theProp the name of the system property.\n-     * @param defaultVal the default value.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static Integer privilegedGetProperty(String theProp,\n-            int defaultVal) {\n-        Integer value;\n-        if (System.getSecurityManager() == null) {\n-            value = Integer.getInteger(theProp);\n-        } else {\n-            value = AccessController.doPrivileged(\n-                    new GetIntegerAction(theProp));\n-        }\n-        return (value != null) ? value : defaultVal;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetIntegerAction.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.action;\n-\n-\/**\n- * A convenience class for retrieving the <code>Long<\/code> value of a system\n- * property as a privileged action.\n- *\n- * <p>An instance of this class can be used as the argument of\n- * <code>AccessController.doPrivileged<\/code>.\n- *\n- * <p>The following code retrieves the <code>Long<\/code> value of the system\n- * property named <code>\"prop\"<\/code> as a privileged action. Since it does\n- * not pass a default value to be used in case the property\n- * <code>\"prop\"<\/code> is not defined, it has to check the result for\n- * <code>null<\/code>:\n- *\n- * <pre>\n- * Long tmp = java.security.AccessController.doPrivileged\n- *     (new sun.security.action.GetLongAction(\"prop\"));\n- * long l;\n- * if (tmp != null) {\n- *     l = tmp.longValue();\n- * }\n- * <\/pre>\n- *\n- * <p>The following code retrieves the <code>Long<\/code> value of the system\n- * property named <code>\"prop\"<\/code> as a privileged action, and also passes\n- * a default value to be used in case the property <code>\"prop\"<\/code> is not\n- * defined:\n- *\n- * <pre>\n- * long l = java.security.AccessController.doPrivileged\n- *      (new GetLongAction(\"prop\")).longValue();\n- * <\/pre>\n- *\n- * @author Roland Schemers\n- * @see java.security.PrivilegedAction\n- * @see java.security.AccessController\n- * @since 1.2\n- *\/\n-\n-public class GetLongAction implements java.security.PrivilegedAction<Long> {\n-    private final String theProp;\n-    private final long defaultVal;\n-    private final boolean defaultSet;\n-\n-    \/**\n-     * Constructor that takes the name of the system property whose\n-     * <code>Long<\/code> value needs to be determined.\n-     *\n-     * @param theProp the name of the system property.\n-     *\/\n-    public GetLongAction(String theProp) {\n-        this.theProp = theProp;\n-        this.defaultVal = 0;\n-        this.defaultSet = false;\n-    }\n-\n-    \/**\n-     * Constructor that takes the name of the system property and the default\n-     * value of that property.\n-     *\n-     * @param theProp the name of the system property.\n-     * @param defaultVal the default value.\n-     *\/\n-    public GetLongAction(String theProp, long defaultVal) {\n-        this.theProp = theProp;\n-        this.defaultVal = defaultVal;\n-        this.defaultSet = true;\n-    }\n-\n-    \/**\n-     * Determines the <code>Long<\/code> value of the system property whose\n-     * name was specified in the constructor.\n-     *\n-     * <p>If there is no property of the specified name, or if the property\n-     * does not have the correct numeric format, then a <code>Long<\/code>\n-     * object representing the default value that was specified in the\n-     * constructor is returned, or <code>null<\/code> if no default value was\n-     * specified.\n-     *\n-     * @return the <code>Long<\/code> value of the property.\n-     *\/\n-    public Long run() {\n-        Long value = Long.getLong(theProp);\n-        if ((value == null) && defaultSet)\n-            return defaultVal;\n-        return value;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetLongAction.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.action;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Locale;\n-import java.util.Properties;\n-import sun.security.util.Debug;\n-\n-\/**\n- * A convenience class for retrieving the string value of a system\n- * property as a privileged action.\n- *\n- * <p>An instance of this class can be used as the argument of\n- * <code>AccessController.doPrivileged<\/code>.\n- *\n- * <p>The following code retrieves the value of the system\n- * property named <code>\"prop\"<\/code> as a privileged action:\n- *\n- * <pre>\n- * String s = java.security.AccessController.doPrivileged\n- *                      (new GetPropertyAction(\"prop\"));\n- * <\/pre>\n- *\n- * @author Roland Schemers\n- * @see java.security.PrivilegedAction\n- * @see java.security.AccessController\n- * @since 1.2\n- *\/\n-\n-public class GetPropertyAction implements PrivilegedAction<String> {\n-    private final String theProp;\n-    private final String defaultVal;\n-\n-    \/**\n-     * Constructor that takes the name of the system property whose\n-     * string value needs to be determined.\n-     *\n-     * @param theProp the name of the system property.\n-     *\/\n-    public GetPropertyAction(String theProp) {\n-        this.theProp = theProp;\n-        this.defaultVal = null;\n-    }\n-\n-    \/**\n-     * Constructor that takes the name of the system property and the default\n-     * value of that property.\n-     *\n-     * @param theProp the name of the system property.\n-     * @param defaultVal the default value.\n-     *\/\n-    public GetPropertyAction(String theProp, String defaultVal) {\n-        this.theProp = theProp;\n-        this.defaultVal = defaultVal;\n-    }\n-\n-    \/**\n-     * Determines the string value of the system property whose\n-     * name was specified in the constructor.\n-     *\n-     * @return the string value of the system property,\n-     *         or the default value if there is no property with that key.\n-     *\/\n-    public String run() {\n-        String value = System.getProperty(theProp);\n-        return (value == null) ? defaultVal : value;\n-    }\n-\n-    \/**\n-     * Convenience method to get a property without going through doPrivileged\n-     * if no security manager is present. This is unsafe for inclusion in a\n-     * public API but allowable here since this class is now encapsulated.\n-     *\n-     * Note that this method performs a privileged action using caller-provided\n-     * inputs. The caller of this method should take care to ensure that the\n-     * inputs are not tainted and the returned property is not made accessible\n-     * to untrusted code if it contains sensitive information.\n-     *\n-     * @param theProp the name of the system property.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static String privilegedGetProperty(String theProp) {\n-        if (System.getSecurityManager() == null) {\n-            return System.getProperty(theProp);\n-        } else {\n-            return AccessController.doPrivileged(\n-                    new GetPropertyAction(theProp));\n-        }\n-    }\n-\n-    \/**\n-     * Convenience method to get a property without going through doPrivileged\n-     * if no security manager is present. This is unsafe for inclusion in a\n-     * public API but allowable here since this class is now encapsulated.\n-     *\n-     * Note that this method performs a privileged action using caller-provided\n-     * inputs. The caller of this method should take care to ensure that the\n-     * inputs are not tainted and the returned property is not made accessible\n-     * to untrusted code if it contains sensitive information.\n-     *\n-     * @param theProp the name of the system property.\n-     * @param defaultVal the default value.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static String privilegedGetProperty(String theProp,\n-            String defaultVal) {\n-        if (System.getSecurityManager() == null) {\n-            return System.getProperty(theProp, defaultVal);\n-        } else {\n-            return AccessController.doPrivileged(\n-                    new GetPropertyAction(theProp, defaultVal));\n-        }\n-    }\n-\n-    \/**\n-     * Convenience method to call <code>System.getProperties<\/code> without\n-     * having to go through doPrivileged if no security manager is present.\n-     * This is unsafe for inclusion in a public API but allowable here since\n-     * this class is now encapsulated.\n-     *\n-     * Note that this method performs a privileged action, and callers of\n-     * this method should take care to ensure that the returned properties\n-     * are not made accessible to untrusted code since it may contain\n-     * sensitive information.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static Properties privilegedGetProperties() {\n-        if (System.getSecurityManager() == null) {\n-            return System.getProperties();\n-        } else {\n-            return AccessController.doPrivileged(\n-                    new PrivilegedAction<Properties>() {\n-                        public Properties run() {\n-                            return System.getProperties();\n-                        }\n-                    }\n-            );\n-        }\n-    }\n-\n-    \/**\n-     * Convenience method for fetching System property values that are timeouts.\n-     * Accepted timeout values may be purely numeric, a numeric value\n-     * followed by \"s\" (both interpreted as seconds), or a numeric value\n-     * followed by \"ms\" (interpreted as milliseconds).\n-     *\n-     * @param prop the name of the System property\n-     * @param def a default value (in milliseconds)\n-     * @param dbg a Debug object, if null no debug messages will be sent\n-     *\n-     * @return an integer value corresponding to the timeout value in the System\n-     *      property in milliseconds.  If the property value is empty, negative,\n-     *      or contains non-numeric characters (besides a trailing \"s\" or \"ms\")\n-     *      then the default value will be returned.  If a negative value for\n-     *      the \"def\" parameter is supplied, zero will be returned if the\n-     *      property's value does not conform to the allowed syntax.\n-     *\/\n-    public static int privilegedGetTimeoutProp(String prop, int def, Debug dbg) {\n-        if (def < 0) {\n-            def = 0;\n-        }\n-\n-        String rawPropVal = privilegedGetProperty(prop, \"\").trim();\n-        if (rawPropVal.length() == 0) {\n-            return def;\n-        }\n-\n-        \/\/ Determine if \"ms\" or just \"s\" is on the end of the string.\n-        \/\/ We may do a little surgery on the value so we'll retain\n-        \/\/ the original value in rawPropVal for debug messages.\n-        boolean isMillis = false;\n-        String propVal = rawPropVal;\n-        if (rawPropVal.toLowerCase(Locale.ROOT).endsWith(\"ms\")) {\n-            propVal = rawPropVal.substring(0, rawPropVal.length() - 2);\n-            isMillis = true;\n-        } else if (rawPropVal.toLowerCase(Locale.ROOT).endsWith(\"s\")) {\n-            propVal = rawPropVal.substring(0, rawPropVal.length() - 1);\n-        }\n-\n-        \/\/ Next check to make sure the string is built only from digits\n-        if (propVal.matches(\"^\\\\d+$\")) {\n-            try {\n-                int timeout = Integer.parseInt(propVal);\n-                return isMillis ? timeout : timeout * 1000;\n-            } catch (NumberFormatException nfe) {\n-                if (dbg != null) {\n-                    dbg.println(\"Warning: Unexpected \" + nfe +\n-                            \" for timeout value \" + rawPropVal +\n-                            \". Using default value of \" + def + \" msec.\");\n-                }\n-                return def;\n-            }\n-        } else {\n-            if (dbg != null) {\n-                dbg.println(\"Warning: Incorrect syntax for timeout value \" +\n-                        rawPropVal + \". Using default value of \" + def +\n-                        \" msec.\");\n-            }\n-            return def;\n-        }\n-    }\n-\n-    \/**\n-     * Convenience method for fetching System property values that are booleans.\n-     *\n-     * @param prop the name of the System property\n-     * @param def a default value\n-     * @param dbg a Debug object, if null no debug messages will be sent\n-     *\n-     * @return a boolean value corresponding to the value in the System property.\n-     *      If the property value is neither \"true\" or \"false\", the default value\n-     *      will be returned.\n-     *\/\n-    public static boolean privilegedGetBooleanProp(String prop, boolean def, Debug dbg) {\n-        String rawPropVal = privilegedGetProperty(prop, \"\");\n-        if (\"\".equals(rawPropVal)) {\n-            return def;\n-        }\n-\n-        String lower = rawPropVal.toLowerCase(Locale.ROOT);\n-        if (\"true\".equals(lower)) {\n-            return true;\n-        } else if (\"false\".equals(lower)) {\n-            return false;\n-        } else {\n-            if (dbg != null) {\n-                dbg.println(\"Warning: Unexpected value for \" + prop +\n-                            \": \" + rawPropVal +\n-                            \". Using default value: \" + def);\n-            }\n-            return def;\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetPropertyAction.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.action;\n-\n-import java.util.Map;\n-\n-import java.security.Provider;\n-import java.security.PrivilegedAction;\n-\n-\/**\n- * A convenience PrivilegedAction class for setting the properties of\n- * a provider. See the SunRsaSign provider for a usage example.\n- *\n- * @see sun.security.rsa.SunRsaSign\n- * @author  Andreas Sterbenz\n- * @since   1.5\n- *\/\n-public class PutAllAction implements PrivilegedAction<Void> {\n-\n-    private final Provider provider;\n-    private final Map<?, ?> map;\n-\n-    public PutAllAction(Provider provider, Map<?, ?> map) {\n-        this.provider = provider;\n-        this.map = map;\n-    }\n-\n-    public Void run() {\n-        provider.putAll(map);\n-        return null;\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/PutAllAction.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.AccessController;\n@@ -31,1 +30,0 @@\n-import java.security.PrivilegedAction;\n@@ -183,1 +181,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -186,6 +183,1 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                putEntries();\n-                return null;\n-            }\n-        });\n+        putEntries();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/SunEC.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import sun.security.action.GetBooleanAction;\n-\n@@ -57,2 +55,2 @@\n-    private static final boolean rsaPreMasterSecretFix = GetBooleanAction\n-            .privilegedGetProperty(\"com.sun.net.ssl.rsaPreMasterSecretFix\");\n+    private static final boolean rsaPreMasterSecretFix =\n+            Boolean.getBoolean(\"com.sun.net.ssl.rsaPreMasterSecretFix\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/internal\/spec\/TlsRsaPremasterSecretParameterSpec.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,17 +97,5 @@\n-        @SuppressWarnings(\"removal\")\n-        Boolean o = AccessController.doPrivileged(\n-                                new PrivilegedAction<Boolean>() {\n-            public Boolean run() {\n-                File file = new File(\"\/usr\/lib\/libpkcs11.so\");\n-                if (file.exists() == false) {\n-                    return Boolean.FALSE;\n-                }\n-                if (\"false\".equalsIgnoreCase(System.getProperty\n-                        (\"sun.security.pkcs11.enable-solaris\"))) {\n-                    return Boolean.FALSE;\n-                }\n-                return Boolean.TRUE;\n-            }\n-        });\n-        if (o == Boolean.FALSE) {\n-            tries = MAX_LOAD_TRIES;\n+        File file = new File(\"\/usr\/lib\/libpkcs11.so\");\n+        if (file.exists() == false ||\n+            (\"false\".equalsIgnoreCase(System.getProperty\n+                (\"sun.security.pkcs11.enable-solaris\")))) {\n+             tries = MAX_LOAD_TRIES;\n@@ -193,22 +181,16 @@\n-                    @SuppressWarnings(\"removal\")\n-                    var tmp = AccessController.doPrivileged(\n-                        new PrivilegedAction<Provider>() {\n-                            public Provider run() {\n-                                try {\n-                                    Class<?> c = Class.forName(\n-                                        \"apple.security.AppleProvider\");\n-                                    if (Provider.class.isAssignableFrom(c)) {\n-                                        @SuppressWarnings(\"deprecation\")\n-                                        Object tmp = c.newInstance();\n-                                        return (Provider) tmp;\n-                                    }\n-                                } catch (Exception ex) {\n-                                    if (debug != null) {\n-                                        debug.println(\"Error loading provider Apple\");\n-                                        ex.printStackTrace();\n-                                    }\n-                                }\n-                                return null;\n-                            }\n-                        });\n-                    yield tmp;\n+                    Provider ap = null;\n+                    try {\n+                        Class<?> c = Class.forName(\n+                            \"apple.security.AppleProvider\");\n+                        if (Provider.class.isAssignableFrom(c)) {\n+                            @SuppressWarnings(\"deprecation\")\n+                            Object tmp = c.newInstance();\n+                            ap = (Provider) tmp;\n+                        }\n+                    } catch (Exception ex) {\n+                        if (debug != null) {\n+                            debug.println(\"Error loading provider Apple\");\n+                            ex.printStackTrace();\n+                        }\n+                    }\n+                    yield ap;\n@@ -243,2 +225,0 @@\n-     * NOTE use of doPrivileged().\n-     *\n@@ -250,1 +230,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -252,2 +231,9 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<Provider>() {\n-            public Provider run() {\n+        if (debug != null) {\n+            debug.println(\"Loading provider \" + ProviderConfig.this);\n+        }\n+        try {\n+            Provider p = ProviderLoader.INSTANCE.load(provName);\n+            if (p != null) {\n+                if (hasArgument()) {\n+                    p = p.configure(argument);\n+                }\n@@ -255,1 +241,1 @@\n-                    debug.println(\"Loading provider \" + ProviderConfig.this);\n+                    debug.println(\"Loaded provider \" + p.getName());\n@@ -257,38 +243,4 @@\n-                try {\n-                    Provider p = ProviderLoader.INSTANCE.load(provName);\n-                    if (p != null) {\n-                        if (hasArgument()) {\n-                            p = p.configure(argument);\n-                        }\n-                        if (debug != null) {\n-                            debug.println(\"Loaded provider \" + p.getName());\n-                        }\n-                    } else {\n-                        if (debug != null) {\n-                            debug.println(\"Error loading provider \" +\n-                                ProviderConfig.this);\n-                        }\n-                        disableLoad();\n-                    }\n-                    return p;\n-                } catch (Exception e) {\n-                    if (e instanceof ProviderException) {\n-                        \/\/ pass up\n-                        throw e;\n-                    } else {\n-                        if (debug != null) {\n-                            debug.println(\"Error loading provider \" +\n-                                ProviderConfig.this);\n-                            e.printStackTrace();\n-                        }\n-                        disableLoad();\n-                        return null;\n-                    }\n-                } catch (ExceptionInInitializerError err) {\n-                    \/\/ no sufficient permission to initialize provider class\n-                    if (debug != null) {\n-                        debug.println(\"Error loading provider \" + ProviderConfig.this);\n-                        err.printStackTrace();\n-                    }\n-                    disableLoad();\n-                    return null;\n+            } else {\n+                if (debug != null) {\n+                    debug.println(\"Error loading provider \" +\n+                        ProviderConfig.this);\n@@ -296,0 +248,15 @@\n+                disableLoad();\n+            }\n+            return p;\n+        } catch (Exception e) {\n+            if (e instanceof ProviderException) {\n+                \/\/ pass up\n+                throw e;\n+            } else {\n+                if (debug != null) {\n+                    debug.println(\"Error loading provider \" +\n+                        ProviderConfig.this);\n+                    e.printStackTrace();\n+                }\n+                disableLoad();\n+                return null;\n@@ -297,1 +264,9 @@\n-        });\n+        } catch (ExceptionInInitializerError err) {\n+            \/\/ unable to initialize provider class\n+            if (debug != null) {\n+                debug.println(\"Error loading provider \" + ProviderConfig.this);\n+                err.printStackTrace();\n+            }\n+            disableLoad();\n+            return null;\n+        }\n@@ -302,2 +277,0 @@\n-     *\n-     * NOTE use of doPrivileged().\n@@ -305,1 +278,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -311,9 +283,5 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<String>() {\n-            public String run() {\n-                try {\n-                    return PropertyExpander.expand(value);\n-                } catch (GeneralSecurityException e) {\n-                    throw new ProviderException(e);\n-                }\n-            }\n-        });\n+        try {\n+            return PropertyExpander.expand(value);\n+        } catch (GeneralSecurityException e) {\n+            throw new ProviderException(e);\n+        }\n@@ -359,1 +327,1 @@\n-                } catch (SecurityException | ServiceConfigurationError |\n+                } catch (ServiceConfigurationError |\n@@ -361,1 +329,1 @@\n-                    \/\/ if provider loading fail due to security permission,\n+                    \/\/ if provider loading failed\n@@ -388,0 +356,1 @@\n+        @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n@@ -406,9 +375,1 @@\n-                @SuppressWarnings(\"removal\")\n-                Provider p = AccessController.doPrivileged\n-                    (new PrivilegedExceptionAction<Provider>() {\n-                    @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n-                    public Provider run() throws Exception {\n-                        return (Provider) provClass.newInstance();\n-                    }\n-                });\n-                return p;\n+                return (Provider) provClass.newInstance();\n@@ -432,1 +393,1 @@\n-                \/\/ no sufficient permission to access\/initialize provider class\n+                \/\/ unable to access\/initialize provider class\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderConfig.java","additions":70,"deletions":109,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -90,1 +88,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -92,7 +89,1 @@\n-        \/\/ doPrivileged() because of Security.getProperty()\n-        return AccessController.doPrivileged(\n-                        new PrivilegedAction<ProviderList>() {\n-            public ProviderList run() {\n-                return new ProviderList();\n-            }\n-        });\n+        return new ProviderList();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderList.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.AccessController;\n@@ -39,1 +38,0 @@\n-import java.security.PrivilegedAction;\n@@ -69,1 +67,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -2654,2 +2651,1 @@\n-        return GetPropertyAction.privilegedGetProperty(\n-                USE_LEGACY_PROP) != null;\n+        return System.getProperty(USE_LEGACY_PROP) != null;\n@@ -2662,1 +2658,1 @@\n-        String result = SecurityProperties.privilegedGetOverridable(\n+        String result = SecurityProperties.getOverridableProperty(\n@@ -2672,1 +2668,1 @@\n-        String result = SecurityProperties.privilegedGetOverridable(\n+        String result = SecurityProperties.getOverridableProperty(\n@@ -2685,14 +2681,6 @@\n-        @SuppressWarnings(\"removal\")\n-        String result = AccessController.doPrivileged(new PrivilegedAction<String>() {\n-            public String run() {\n-                String result;\n-                String name1 = \"keystore.pkcs12.keyProtectionAlgorithm\";\n-                String name2 = \"keystore.PKCS12.keyProtectionAlgorithm\";\n-                result = System.getProperty(name1);\n-                if (result != null) {\n-                    return result;\n-                }\n-                result = System.getProperty(name2);\n-                if (result != null) {\n-                    return result;\n-                }\n+        String name1 = \"keystore.pkcs12.keyProtectionAlgorithm\";\n+        String name2 = \"keystore.PKCS12.keyProtectionAlgorithm\";\n+        String result = System.getProperty(name1);\n+        if (result == null) {\n+            result = System.getProperty(name2);\n+            if (result == null) {\n@@ -2700,2 +2688,2 @@\n-                if (result != null) {\n-                    return result;\n+                if (result == null) {\n+                    result = Security.getProperty(name2);\n@@ -2703,1 +2691,0 @@\n-                return Security.getProperty(name2);\n@@ -2705,1 +2692,1 @@\n-        });\n+        }\n@@ -2714,1 +2701,1 @@\n-        String result = SecurityProperties.privilegedGetOverridable(\n+        String result = SecurityProperties.getOverridableProperty(\n@@ -2725,1 +2712,1 @@\n-        String result = SecurityProperties.privilegedGetOverridable(\n+        String result = SecurityProperties.getOverridableProperty(\n@@ -2735,1 +2722,1 @@\n-        String result = SecurityProperties.privilegedGetOverridable(\n+        String result = SecurityProperties.getOverridableProperty(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -40,1 +36,0 @@\n-import javax.security.auth.AuthPermission;\n@@ -162,1 +157,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -165,25 +159,10 @@\n-            \/\/ call in a doPrivileged\n-            \/\/\n-            \/\/ We have already passed the Configuration.getInstance\n-            \/\/ security check.  Also, this class is not freely accessible\n-            \/\/ (it is in the \"sun\" package).\n-\n-            try {\n-                AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                    public Void run() throws IOException {\n-                        if (params == null) {\n-                            init();\n-                        } else {\n-                            if (!(params instanceof URIParameter)) {\n-                                throw new IllegalArgumentException\n-                                        (\"Unrecognized parameter: \" + params);\n-                            }\n-                            URIParameter uriParam = (URIParameter)params;\n-                            url = uriParam.getURI().toURL();\n-                            init();\n-                        }\n-                        return null;\n-                    }\n-                });\n-            } catch (PrivilegedActionException pae) {\n-                throw (IOException)pae.getException();\n+            if (params == null) {\n+                init();\n+            } else {\n+                if (!(params instanceof URIParameter)) {\n+                    throw new IllegalArgumentException\n+                            (\"Unrecognized parameter: \" + params);\n+                }\n+                URIParameter uriParam = (URIParameter)params;\n+                url = uriParam.getURI().toURL();\n+                init();\n@@ -201,2 +180,0 @@\n-         * @throws SecurityException if the caller does not have permission\n-         *                           to initialize the Configuration\n@@ -380,3 +357,0 @@\n-         *\n-         * @throws SecurityException if the caller does not have permission\n-         *                           to refresh the Configuration.\n@@ -384,1 +358,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -388,4 +361,4 @@\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(\n-                    new AuthPermission(\"refreshLoginConfiguration\"));\n+            try {\n+                init();\n+            } catch (IOException ioe) {\n+                throw new SecurityException(ioe.getLocalizedMessage(), ioe);\n@@ -393,12 +366,0 @@\n-\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    try {\n-                        init();\n-                    } catch (IOException ioe) {\n-                        throw new SecurityException(ioe.getLocalizedMessage(),\n-                                                    ioe);\n-                    }\n-                    return null;\n-                }\n-            });\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ConfigFile.java","additions":15,"deletions":54,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.AccessController;\n@@ -32,1 +31,0 @@\n-import java.security.PrivilegedAction;\n@@ -96,4 +94,1 @@\n-\n-        @SuppressWarnings(\"removal\")\n-        String config = AccessController.doPrivileged((PrivilegedAction<String>)\n-                () -> Security.getProperty(PROP_NAME));\n+        String config = Security.getProperty(PROP_NAME);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DRBG.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,3 +73,0 @@\n-     * @throws SecurityException     if a security manager exists and its\n-     *                               <code>checkRead<\/code> method denies read\n-     *                               access to the file.\n@@ -86,3 +83,0 @@\n-        \/\/ (this also checks the read permission on the file if SecurityManager\n-        \/\/ is present, so no checking is needed later when we just return the\n-        \/\/ already opened stream)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,7 +72,1 @@\n-        @SuppressWarnings(\"removal\")\n-        var dummy = AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                md4Provider.put(\"MessageDigest.MD4\", \"sun.security.provider.MD4\");\n-                return null;\n-            }\n-        });\n+        md4Provider.put(\"MessageDigest.MD4\", \"sun.security.provider.MD4\");\n@@ -81,7 +75,2 @@\n-    public static MessageDigest getInstance() {\n-        try {\n-            return MessageDigest.getInstance(\"MD4\", md4Provider);\n-        } catch (NoSuchAlgorithmException e) {\n-            \/\/ should never occur\n-            throw new ProviderException(e);\n-        }\n+    public static MessageDigest getInstance() throws NoSuchAlgorithmException {\n+        return MessageDigest.getInstance(\"MD4\", md4Provider);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/MD4.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -530,1 +529,1 @@\n-                    ((v[vOffset+1] << 8) & 0x3FF);\n+                        ((v[vOffset+1] << 8) & 0x3FF);\n@@ -532,1 +531,1 @@\n-                    ((v[vOffset+2] << 6) & 0x3FF);\n+                        ((v[vOffset+2] << 6) & 0x3FF);\n@@ -534,1 +533,1 @@\n-                    ((v[vOffset+3] << 4) & 0x3FF);\n+                        ((v[vOffset+3] << 4) & 0x3FF);\n@@ -536,1 +535,1 @@\n-                    ((v[vOffset+4] << 2) & 0x3FF);\n+                        ((v[vOffset+4] << 2) & 0x3FF);\n@@ -878,2 +877,2 @@\n-                        ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n-                        ((rawAij[rawOfs + 2] & 0x7F) << 16);\n+                            ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n+                            ((rawAij[rawOfs + 2] & 0x7F) << 16);\n@@ -984,1 +983,1 @@\n-                highPart[i], gamma2 * 2, multiplier);\n+                    highPart[i], gamma2 * 2, multiplier);\n@@ -1035,6 +1034,0 @@\n-        implMlDsaAlmostNttJava(coeffs);\n-        implMlDsaMontMulByConstantJava(coeffs,  MONT_R_MOD_Q);\n-        return coeffs;\n-    }\n-\n-    static void implMlDsaAlmostNttJava(int[] coeffs) {\n@@ -1053,5 +1046,1 @@\n-    }\n-\n-    public static int[] mlDsaInverseNtt(int[] coeffs) {\n-        implMlDsaAlmostInverseNttJava(coeffs);\n-        implMlDsaMontMulByConstantJava(coeffs, MONT_DIM_INVERSE);\n+        montMulByConstant(coeffs,  MONT_R_MOD_Q);\n@@ -1061,1 +1050,1 @@\n-    static void implMlDsaAlmostInverseNttJava(int[] coeffs) {\n+    public static int[] mlDsaInverseNtt(int[] coeffs) {\n@@ -1070,1 +1059,1 @@\n-                        MONT_ZETAS_FOR_INVERSE_NTT[m]);\n+                            MONT_ZETAS_FOR_INVERSE_NTT[m]);\n@@ -1075,0 +1064,2 @@\n+        montMulByConstant(coeffs, MONT_DIM_INVERSE);\n+        return coeffs;\n@@ -1089,6 +1080,1 @@\n-    \/\/Todo\n-    public static void mlDsaNttMultiply(int[] res, int[] coeffs1, int[] coeffs2) {\n-        implMlDsaNttMultJava(res, coeffs1, coeffs2);\n-    }\n-\n-    static void implMlDsaNttMultJava(int[] product, int[] coeffs1, int[] coeffs2) {\n+    public static void mlDsaNttMultiply(int[] product, int[] coeffs1, int[] coeffs2) {\n@@ -1101,4 +1087,0 @@\n-        implMlDsaMontMulByConstantJava(coeffs, constant);\n-    }\n-\n-    static void implMlDsaMontMulByConstantJava(int[] coeffs, int constant) {\n@@ -1112,11 +1094,0 @@\n-        implMlDsaDecomposePoly(input, lowPart, highPart, twoGamma2, multiplier);\n-    }\n-\n-    @IntrinsicCandidate\n-    static void implMlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n-                                          int twoGamma2, int multiplier) {\n-        decomposePolyJava(input, lowPart, highPart, twoGamma2, multiplier);\n-    }\n-\n-    static void decomposePolyJava(int[] input, int[] lowPart, int[] highPart,\n-                                 int twoGamma2, int multiplier) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":13,"deletions":42,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static Version version = Version.DRAFT;\n+    public static Version version = Version.FINAL;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Impls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -167,11 +166,7 @@\n-        java.security.AccessController.doPrivileged\n-            (new java.security.PrivilegedAction<>() {\n-                @Override\n-                public Void run() {\n-                    try {\n-                        \/\/ System properties can change from machine to machine\n-                        Properties p = System.getProperties();\n-                        for (String s: p.stringPropertyNames()) {\n-                            md.update(s.getBytes());\n-                            md.update(p.getProperty(s).getBytes());\n-                        }\n+        try {\n+            \/\/ System properties can change from machine to machine\n+            Properties p = System.getProperties();\n+            for (String s: p.stringPropertyNames()) {\n+                md.update(s.getBytes());\n+                md.update(p.getProperty(s).getBytes());\n+            }\n@@ -179,27 +174,17 @@\n-                        \/\/ Include network adapter names (and a Mac address)\n-                        addNetworkAdapterInfo(md);\n-\n-                        \/\/ The temporary dir\n-                        File f = new File(p.getProperty(\"java.io.tmpdir\"));\n-                        int count = 0;\n-                        try (\n-                            DirectoryStream<Path> stream =\n-                                Files.newDirectoryStream(f.toPath())) {\n-                            \/\/ We use a Random object to choose what file names\n-                            \/\/ should be used. Otherwise, on a machine with too\n-                            \/\/ many files, the same first 1024 files always get\n-                            \/\/ used. Any, We make sure the first 512 files are\n-                            \/\/ always used.\n-                            Random r = new Random();\n-                            for (Path entry: stream) {\n-                                if (count < 512 || r.nextBoolean()) {\n-                                    md.update(entry.getFileName()\n-                                        .toString().getBytes());\n-                                }\n-                                if (count++ > 1024) {\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                    } catch (Exception ex) {\n-                        md.update((byte)ex.hashCode());\n+            \/\/ Include network adapter names (and a Mac address)\n+            addNetworkAdapterInfo(md);\n+\n+            \/\/ The temporary dir\n+            File f = new File(p.getProperty(\"java.io.tmpdir\"));\n+            int count = 0;\n+            try (DirectoryStream<Path> stream =\n+                    Files.newDirectoryStream(f.toPath())) {\n+                \/\/ We use a Random object to choose what file names\n+                \/\/ should be used. Otherwise, on a machine with too\n+                \/\/ many files, the same first 1024 files always get\n+                \/\/ used. Any, We make sure the first 512 files are\n+                \/\/ always used.\n+                Random r = new Random();\n+                for (Path entry: stream) {\n+                    if (count < 512 || r.nextBoolean()) {\n+                        md.update(entry.getFileName().toString().getBytes());\n@@ -207,0 +192,8 @@\n+                    if (count++ > 1024) {\n+                        break;\n+                    }\n+                }\n+            }\n+        } catch (Exception ex) {\n+            md.update((byte)ex.hashCode());\n+        }\n@@ -208,6 +201,6 @@\n-                    \/\/ get Runtime memory stats\n-                    Runtime rt = Runtime.getRuntime();\n-                    byte[] memBytes = longToByteArray(rt.totalMemory());\n-                    md.update(memBytes, 0, memBytes.length);\n-                    memBytes = longToByteArray(rt.freeMemory());\n-                    md.update(memBytes, 0, memBytes.length);\n+        \/\/ get Runtime memory stats\n+        Runtime rt = Runtime.getRuntime();\n+        byte[] memBytes = longToByteArray(rt.totalMemory());\n+        md.update(memBytes, 0, memBytes.length);\n+        memBytes = longToByteArray(rt.freeMemory());\n+        md.update(memBytes, 0, memBytes.length);\n@@ -215,3 +208,0 @@\n-                    return null;\n-                }\n-            });\n@@ -296,23 +286,13 @@\n-            final ThreadGroup[] finalsg = new ThreadGroup[1];\n-            @SuppressWarnings(\"removal\")\n-            Thread t = java.security.AccessController.doPrivileged\n-                (new java.security.PrivilegedAction<>() {\n-                        @Override\n-                        public Thread run() {\n-                            ThreadGroup parent, group =\n-                                Thread.currentThread().getThreadGroup();\n-                            while ((parent = group.getParent()) != null) {\n-                                group = parent;\n-                            }\n-                            finalsg[0] = new ThreadGroup\n-                                (group, \"SeedGenerator ThreadGroup\");\n-                            Thread newT = new Thread(finalsg[0],\n-                                ThreadedSeedGenerator.this,\n-                                \"SeedGenerator Thread\",\n-                                0,\n-                                false);\n-                            newT.setPriority(Thread.MIN_PRIORITY);\n-                            newT.setDaemon(true);\n-                            return newT;\n-                        }\n-                    });\n+            ThreadGroup[] finalsg = new ThreadGroup[1];\n+            ThreadGroup parent, group = Thread.currentThread().getThreadGroup();\n+            while ((parent = group.getParent()) != null) {\n+                group = parent;\n+            }\n+            finalsg[0] = new ThreadGroup(group, \"SeedGenerator ThreadGroup\");\n+            Thread t = new Thread(finalsg[0],\n+                ThreadedSeedGenerator.this,\n+                \"SeedGenerator Thread\",\n+                0,\n+                false);\n+            t.setPriority(Thread.MIN_PRIORITY);\n+            t.setDaemon(true);\n@@ -505,1 +485,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -508,1 +487,1 @@\n-            final URL device = new URL(deviceName);\n+            URL device = new URL(deviceName);\n@@ -510,23 +489,15 @@\n-                seedStream = java.security.AccessController.doPrivileged\n-                    (new java.security.PrivilegedExceptionAction<>() {\n-                        @Override\n-                        public InputStream run() throws IOException {\n-                            \/*\n-                             * return a shared InputStream for file URLs and\n-                             * avoid buffering.\n-                             * The URL.openStream() call wraps InputStream in a\n-                             * BufferedInputStream which\n-                             * can buffer up to 8K bytes. This read is a\n-                             * performance issue for entropy sources which\n-                             * can be slow to replenish.\n-                             *\/\n-                            if (device.getProtocol().equalsIgnoreCase(\"file\")) {\n-                                File deviceFile =\n-                                    SunEntries.getDeviceFile(device);\n-                                return FileInputStreamPool\n-                                    .getInputStream(deviceFile);\n-                            } else {\n-                                return device.openStream();\n-                            }\n-                        }\n-                    });\n+                \/*\n+                 * return a shared InputStream for file URLs and\n+                 * avoid buffering.\n+                 * The URL.openStream() call wraps InputStream in a\n+                 * BufferedInputStream which\n+                 * can buffer up to 8K bytes. This read is a\n+                 * performance issue for entropy sources which\n+                 * can be slow to replenish.\n+                 *\/\n+                if (device.getProtocol().equalsIgnoreCase(\"file\")) {\n+                    File deviceFile = SunEntries.getDeviceFile(device);\n+                    seedStream = FileInputStreamPool.getInputStream(deviceFile);\n+                } else {\n+                    seedStream = device.openStream();\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SeedGenerator.java","additions":68,"deletions":97,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -58,18 +57,2 @@\n-        \/\/ if there is no security manager installed, put directly into\n-        \/\/ the provider\n-        if (System.getSecurityManager() == null) {\n-            putEntries(serviceIter);\n-        } else {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    putEntries(serviceIter);\n-                    return null;\n-                }\n-            });\n-        }\n-    }\n-\n-    void putEntries(Iterator<Provider.Service> i) {\n-        while (i.hasNext()) {\n-            putService(i.next());\n+        while (serviceIter.hasNext()) {\n+            putService(serviceIter.next());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/Sun.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -42,1 +40,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -348,2 +345,1 @@\n-        GetBooleanAction.privilegedGetProperty\n-            (\"jdk.security.legacyDSAKeyPairGenerator\");\n+        Boolean.getBoolean(\"jdk.security.legacyDSAKeyPairGenerator\");\n@@ -354,17 +350,13 @@\n-    @SuppressWarnings(\"removal\")\n-    private static final String seedSource = AccessController.doPrivileged(\n-                new PrivilegedAction<String>() {\n-\n-            @Override\n-            public String run() {\n-                String egdSource = System.getProperty(PROP_EGD, \"\");\n-                if (egdSource.length() != 0) {\n-                    return egdSource;\n-                }\n-                egdSource = Security.getProperty(PROP_RNDSOURCE);\n-                if (egdSource == null) {\n-                    return \"\";\n-                }\n-                return egdSource;\n-            }\n-        });\n+    private static final String seedSource = getOverridableSeedSource();\n+\n+    private static String getOverridableSeedSource() {\n+        String egdSource = System.getProperty(PROP_EGD, \"\");\n+        if (egdSource.length() != 0) {\n+            return egdSource;\n+        }\n+        egdSource = Security.getProperty(PROP_RNDSOURCE);\n+        if (egdSource == null) {\n+            return \"\";\n+        }\n+        return egdSource;\n+    }\n@@ -389,2 +381,0 @@\n-     * Method called within PrivilegedExceptionAction block.\n-     *\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -78,14 +77,2 @@\n-        \/\/ if there is no security manager installed, put directly into\n-        \/\/ the provider\n-        if (System.getSecurityManager() == null) {\n-            putEntries(sunIter);\n-            putEntries(rsaIter);\n-        } else {\n-            AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                public Void run() {\n-                    putEntries(sunIter);\n-                    putEntries(rsaIter);\n-                    return null;\n-                }\n-            });\n-        }\n+        putEntries(sunIter);\n+        putEntries(rsaIter);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/VerificationProvider.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -45,0 +44,1 @@\n+import sun.security.util.SecurityProperties;\n@@ -117,1 +117,1 @@\n-                GetPropertyAction.privilegedGetTimeoutProp(prop, def, debug);\n+                SecurityProperties.getTimeoutSystemProp(prop, def, debug);\n@@ -126,1 +126,1 @@\n-                GetPropertyAction.privilegedGetBooleanProp(prop, def, debug);\n+                SecurityProperties.getBooleanSystemProp(prop, def, debug);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -60,0 +59,1 @@\n+import sun.security.util.SecurityProperties;\n@@ -178,1 +178,1 @@\n-                GetPropertyAction.privilegedGetTimeoutProp(prop, def, debug);\n+                SecurityProperties.getTimeoutSystemProp(prop, def, debug);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/URICertStore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -94,1 +93,1 @@\n-        \"true\".equalsIgnoreCase(GetPropertyAction.privilegedGetProperty(\n+        \"true\".equalsIgnoreCase(System.getProperty(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -51,15 +50,1 @@\n-        Iterator<Provider.Service> serviceIter = new SunRsaSignEntries(p).iterator();\n-\n-        if (System.getSecurityManager() == null) {\n-            putEntries(serviceIter);\n-        } else {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    putEntries(serviceIter);\n-                    return null;\n-                }\n-            });\n-        }\n-    }\n-    void putEntries(Iterator<Provider.Service> i) {\n+        Iterator<Provider.Service> i = new SunRsaSignEntries(p).iterator();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/SunRsaSign.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-                        \"NONE\".equals(SecurityProperties.privilegedGetOverridable(\n+                        \"NONE\".equals(SecurityProperties.getOverridableProperty(\n@@ -986,1 +986,1 @@\n-                        && \"NONE\".equals(SecurityProperties.privilegedGetOverridable(\n+                        && \"NONE\".equals(SecurityProperties.getOverridableProperty(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.AccessController;\n@@ -30,1 +29,0 @@\n-import java.security.PrivilegedAction;\n@@ -51,8 +49,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String property = AccessController.doPrivileged(\n-                new PrivilegedAction<String>() {\n-                    @Override\n-                    public String run() {\n-                        return Security.getProperty(propertyName);\n-                    }\n-                });\n+        String property = Security.getProperty(propertyName);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AbstractAlgorithmConstraints.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -57,1 +56,1 @@\n-        args = GetPropertyAction.privilegedGetProperty(\"java.security.debug\");\n+        args = System.getProperty(\"java.security.debug\");\n@@ -59,2 +58,1 @@\n-        String args2 = GetPropertyAction\n-                .privilegedGetProperty(\"java.security.auth.debug\");\n+        String args2 = System.getProperty(\"java.security.auth.debug\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -208,15 +206,6 @@\n-            @SuppressWarnings(\"removal\")\n-            InputStream is = AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    @Override\n-                    public InputStream run() {\n-                        File f = new File(StaticProperty.javaHome(),\n-                            \"lib\/security\/public_suffix_list.dat\");\n-                        try {\n-                            return new FileInputStream(f);\n-                        } catch (FileNotFoundException e) {\n-                            return null;\n-                        }\n-                    }\n-                }\n-            );\n+            InputStream is = null;\n+            File f = new File(System.getProperty(\"java.home\"),\n+                \"lib\/security\/public_suffix_list.dat\");\n+            try {\n+                is = new FileInputStream(f);\n+            } catch (FileNotFoundException e) { }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DomainName.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        String flag = SecurityProperties.privilegedGetOverridable(\n+        String flag = SecurityProperties.getOverridableProperty(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/FilePermCompat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-                    } catch (UnknownHostException | SecurityException e) {}\n+                    } catch (UnknownHostException e) {}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/HostnameChecker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,3 +67,1 @@\n-        @SuppressWarnings(\"removal\")\n-        var prop = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n-                        Security.getProperty(KEYSTORE_TYPE_COMPAT));\n+        var prop = Security.getProperty(KEYSTORE_TYPE_COMPAT);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyStoreDelegator.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.util;\n-\n-import java.io.File;\n-import java.io.FilePermission;\n-import java.io.IOException;\n-import java.net.URL;\n-import java.security.CodeSource;\n-import java.security.Permission;\n-import java.security.PermissionCollection;\n-import java.util.Enumeration;\n-\n-\/**\n- * This {@code PermissionCollection} implementation delegates to another\n- * {@code PermissionCollection}, taking care to lazily add the permission needed\n- * to read from the given {@code CodeSource} at first use, i.e., when either of\n- * {@link #elements}, {@link #implies} or {@link #toString} is called, or when\n- * the collection is serialized.\n- *\/\n-public final class LazyCodeSourcePermissionCollection\n-        extends PermissionCollection\n-{\n-    @java.io.Serial\n-    private static final long serialVersionUID = -6727011328946861783L;\n-    private final PermissionCollection perms;\n-    private final CodeSource cs;\n-    private volatile boolean permissionAdded;\n-\n-    public LazyCodeSourcePermissionCollection(PermissionCollection perms,\n-                                              CodeSource cs) {\n-        this.perms = perms;\n-        this.cs = cs;\n-    }\n-\n-    private void ensureAdded() {\n-        if (!permissionAdded) {\n-            synchronized(perms) {\n-                if (permissionAdded)\n-                    return;\n-\n-                \/\/ open connection to determine the permission needed\n-                URL location = cs.getLocation();\n-                if (location != null) {\n-                    try {\n-                        Permission p = location.openConnection().getPermission();\n-                        if (p != null) {\n-                            \/\/ for directories then need recursive access\n-                            if (p instanceof FilePermission) {\n-                                String path = p.getName();\n-                                if (path.endsWith(File.separator)) {\n-                                    path += \"-\";\n-                                    p = new FilePermission(path,\n-                                            SecurityConstants.FILE_READ_ACTION);\n-                                }\n-                            }\n-                            perms.add(p);\n-                        }\n-                    } catch (IOException ioe) {\n-                    }\n-                }\n-                if (isReadOnly()) {\n-                    perms.setReadOnly();\n-                }\n-                permissionAdded = true;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void add(Permission permission) {\n-        if (isReadOnly())\n-            throw new SecurityException(\n-                    \"attempt to add a Permission to a readonly PermissionCollection\");\n-        perms.add(permission);\n-    }\n-\n-    @Override\n-    public boolean implies(Permission permission) {\n-        ensureAdded();\n-        return perms.implies(permission);\n-    }\n-\n-    @Override\n-    public Enumeration<Permission> elements() {\n-        ensureAdded();\n-        return perms.elements();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        ensureAdded();\n-        return perms.toString();\n-    }\n-\n-    \/**\n-     * On serialization, initialize and replace with the underlying\n-     * permissions. This removes the laziness on deserialization.\n-     *\/\n-    @java.io.Serial\n-    private Object writeReplace() {\n-        ensureAdded();\n-        return perms;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/LazyCodeSourcePermissionCollection.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-     * allows the actual formatting (and associated permission checks) to be\n-     * avoided unless the resulting string is needed.\n+     * allows the actual formatting to be avoided unless the resulting string\n+     * is needed.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/LocalizedMessage.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.reflect.ReflectPermission;\n-import java.net.NetPermission;\n-import java.net.SocketPermission;\n@@ -32,2 +29,0 @@\n-import java.security.SecurityPermission;\n-import sun.security.action.GetPropertyAction;\n@@ -66,3 +61,1 @@\n-    \/\/ java.lang.Class, java.lang.SecurityManager, java.lang.System,\n-    \/\/ java.net.URLConnection, java.security.AllPermission, java.security.Policy,\n-    \/\/ sun.security.provider.PolicyFile\n+    \/\/ java.net.URLConnection, java.security.AllPermission\n@@ -71,56 +64,0 @@\n-    \/\/ java.net.URL\n-    public static final NetPermission SPECIFY_HANDLER_PERMISSION =\n-       new NetPermission(\"specifyStreamHandler\");\n-\n-    \/\/ java.net.ServerSocket, java.net.Socket\n-    public static final NetPermission SET_SOCKETIMPL_PERMISSION =\n-        new NetPermission(\"setSocketImpl\");\n-\n-    \/\/ java.lang.SecurityManager, sun.applet.AppletPanel\n-    public static final RuntimePermission CREATE_CLASSLOADER_PERMISSION =\n-        new RuntimePermission(\"createClassLoader\");\n-\n-    \/\/ java.lang.SecurityManager\n-    public static final RuntimePermission CHECK_MEMBER_ACCESS_PERMISSION =\n-        new RuntimePermission(\"accessDeclaredMembers\");\n-\n-    \/\/ java.lang.SecurityManager, sun.applet.AppletSecurity\n-    public static final RuntimePermission MODIFY_THREAD_PERMISSION =\n-        new RuntimePermission(\"modifyThread\");\n-\n-    \/\/ java.lang.SecurityManager, sun.applet.AppletSecurity\n-    public static final RuntimePermission MODIFY_THREADGROUP_PERMISSION =\n-        new RuntimePermission(\"modifyThreadGroup\");\n-\n-    \/\/ java.lang.Class\n-    public static final RuntimePermission GET_PD_PERMISSION =\n-        new RuntimePermission(\"getProtectionDomain\");\n-\n-    \/\/ java.lang.Class, java.lang.ClassLoader, java.lang.Thread\n-    public static final RuntimePermission GET_CLASSLOADER_PERMISSION =\n-        new RuntimePermission(\"getClassLoader\");\n-\n-    \/\/ java.lang.Thread\n-    public static final RuntimePermission GET_STACK_TRACE_PERMISSION =\n-       new RuntimePermission(\"getStackTrace\");\n-\n-    \/\/ java.lang.Thread\n-    public static final RuntimePermission SUBCLASS_IMPLEMENTATION_PERMISSION =\n-        new RuntimePermission(\"enableContextClassLoaderOverride\");\n-\n-    \/\/ java.security.AccessControlContext\n-    public static final SecurityPermission CREATE_ACC_PERMISSION =\n-       new SecurityPermission(\"createAccessControlContext\");\n-\n-    \/\/ java.security.AccessControlContext\n-    public static final SecurityPermission GET_COMBINER_PERMISSION =\n-       new SecurityPermission(\"getDomainCombiner\");\n-\n-    \/\/ java.security.Policy, java.security.ProtectionDomain\n-    public static final SecurityPermission GET_POLICY_PERMISSION =\n-        new SecurityPermission (\"getPolicy\");\n-\n-    \/\/ java.lang.SecurityManager\n-    public static final SocketPermission LOCAL_LISTEN_PERMISSION =\n-        new SocketPermission(\"localhost:0\", SOCKET_LISTEN_ACTION);\n-\n@@ -128,10 +65,1 @@\n-        GetPropertyAction.privilegedGetProperty(\"java.specification.version\");\n-\n-    \/\/ java.lang.reflect.AccessibleObject\n-    public static final ReflectPermission ACCESS_PERMISSION =\n-        new ReflectPermission(\"suppressAccessChecks\");\n-\n-    \/\/ sun.reflect.ReflectionFactory\n-    public static final RuntimePermission REFLECTION_FACTORY_ACCESS_PERMISSION =\n-        new RuntimePermission(\"reflectionFactoryAccess\");\n-\n+        System.getProperty(\"java.specification.version\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityConstants.java","additions":2,"deletions":74,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -32,0 +30,1 @@\n+import java.util.Locale;\n@@ -33,0 +32,3 @@\n+\/**\n+ * Utility methods for retrieving security and system properties.\n+ *\/\n@@ -45,9 +47,0 @@\n-    @SuppressWarnings(\"removal\")\n-    public static String privilegedGetOverridable(String propName) {\n-        if (System.getSecurityManager() == null) {\n-            return getOverridableProperty(propName);\n-        } else {\n-            return AccessController.doPrivileged((PrivilegedAction<String>) () -> getOverridableProperty(propName));\n-        }\n-    }\n-\n@@ -72,1 +65,1 @@\n-        String val = privilegedGetOverridable(\"jdk.includeInExceptions\");\n+        String val = getOverridableProperty(\"jdk.includeInExceptions\");\n@@ -86,0 +79,94 @@\n+\n+    \/**\n+     * Convenience method for fetching System property values that are timeouts.\n+     * Accepted timeout values may be purely numeric, a numeric value\n+     * followed by \"s\" (both interpreted as seconds), or a numeric value\n+     * followed by \"ms\" (interpreted as milliseconds).\n+     *\n+     * @param prop the name of the System property\n+     * @param def a default value (in milliseconds)\n+     * @param dbg a Debug object, if null no debug messages will be sent\n+     *\n+     * @return an integer value corresponding to the timeout value in the System\n+     *      property in milliseconds.  If the property value is empty, negative,\n+     *      or contains non-numeric characters (besides a trailing \"s\" or \"ms\")\n+     *      then the default value will be returned.  If a negative value for\n+     *      the \"def\" parameter is supplied, zero will be returned if the\n+     *      property's value does not conform to the allowed syntax.\n+     *\/\n+    public static int getTimeoutSystemProp(String prop, int def, Debug dbg) {\n+        if (def < 0) {\n+            def = 0;\n+        }\n+\n+        String rawPropVal = System.getProperty(prop, \"\").trim();\n+        if (rawPropVal.length() == 0) {\n+            return def;\n+        }\n+\n+        \/\/ Determine if \"ms\" or just \"s\" is on the end of the string.\n+        \/\/ We may do a little surgery on the value so we'll retain\n+        \/\/ the original value in rawPropVal for debug messages.\n+        boolean isMillis = false;\n+        String propVal = rawPropVal;\n+        if (rawPropVal.toLowerCase(Locale.ROOT).endsWith(\"ms\")) {\n+            propVal = rawPropVal.substring(0, rawPropVal.length() - 2);\n+            isMillis = true;\n+        } else if (rawPropVal.toLowerCase(Locale.ROOT).endsWith(\"s\")) {\n+            propVal = rawPropVal.substring(0, rawPropVal.length() - 1);\n+        }\n+\n+        \/\/ Next check to make sure the string is built only from digits\n+        if (propVal.matches(\"^\\\\d+$\")) {\n+            try {\n+                int timeout = Integer.parseInt(propVal);\n+                return isMillis ? timeout : timeout * 1000;\n+            } catch (NumberFormatException nfe) {\n+                if (dbg != null) {\n+                    dbg.println(\"Warning: Unexpected \" + nfe +\n+                            \" for timeout value \" + rawPropVal +\n+                            \". Using default value of \" + def + \" msec.\");\n+                }\n+                return def;\n+            }\n+        } else {\n+            if (dbg != null) {\n+                dbg.println(\"Warning: Incorrect syntax for timeout value \" +\n+                        rawPropVal + \". Using default value of \" + def +\n+                        \" msec.\");\n+            }\n+            return def;\n+        }\n+    }\n+\n+    \/**\n+     * Convenience method for fetching System property values that are booleans.\n+     *\n+     * @param prop the name of the System property\n+     * @param def a default value\n+     * @param dbg a Debug object, if null no debug messages will be sent\n+     *\n+     * @return a boolean value corresponding to the value in the System property.\n+     *      If the property value is neither \"true\" or \"false\", the default value\n+     *      will be returned.\n+     *\/\n+    public static boolean getBooleanSystemProp(String prop, boolean def, Debug dbg) {\n+        String rawPropVal = System.getProperty(prop, \"\");\n+        if (\"\".equals(rawPropVal)) {\n+            return def;\n+        }\n+\n+        String lower = rawPropVal.toLowerCase(Locale.ROOT);\n+        if (\"true\".equals(lower)) {\n+            return true;\n+        } else if (\"false\".equals(lower)) {\n+            return false;\n+        } else {\n+            if (dbg != null) {\n+                dbg.println(\"Warning: Unexpected value for \" + prop +\n+                            \": \" + rawPropVal +\n+                            \". Using default value: \" + def);\n+            }\n+            return def;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProperties.java","additions":99,"deletions":12,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -178,2 +177,1 @@\n-        String keyLengthStr = GetPropertyAction.privilegedGetProperty\n-            (KEY_LENGTH_PROP);\n+        String keyLengthStr = System.getProperty(KEY_LENGTH_PROP);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.security.action.GetIntegerAction;\n@@ -850,2 +849,1 @@\n-        int tmp = GetIntegerAction.privilegedGetProperty(\n-                \"jdk.jar.maxSignatureFileSize\", 16000000);\n+        int tmp = Integer.getInteger(\"jdk.jar.maxSignatureFileSize\", 16000000);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -149,2 +148,1 @@\n-        String prop = GetPropertyAction\n-                .privilegedGetProperty(\"jdk.calendar.japanese.supplemental.era\");\n+        String prop = System.getProperty(\"jdk.calendar.japanese.supplemental.era\");\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/LocalGregorianCalendar.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -118,1 +117,1 @@\n-        String order = GetPropertyAction.privilegedGetProperty(\"java.locale.providers\");\n+        String order = System.getProperty(\"java.locale.providers\");\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleProviderAdapter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -902,1 +901,1 @@\n-        GetPropertyAction.privilegedGetProperty(\"locale.resources.debug\", \"false\"));\n+        System.getProperty(\"locale.resources.debug\", \"false\"));\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleResources.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-File-Date: 2024-06-14\n+File-Date: 2024-11-19\n@@ -47994,0 +47994,10 @@\n+Subtag: kleinsch\n+Description: Kleinschmidt orthography\n+Description: Allattaasitaamut\n+Added: 2024-07-20\n+Prefix: kl\n+Prefix: kl-tunumiit\n+Comments: Orthography for Greenlandic designed by Samuel Kleinschmidt,\n+  used from 1851 to 1973.\n+%%\n+Type: variant\n","filename":"src\/java.base\/share\/data\/lsrdata\/language-subtag-registry.txt","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Extra definitions for Windows \/lib\/tzmappings file. These entries\n+# replace the existing (Windows Zone Name):(REGION) entries, or are added\n+# as new entries\n+\n+# Example entries\n+# Foo Standard Time:US:America\/Los_Angeles:\n+# Bar Standard Time:001:Asia\/Tokyo:\n","filename":"src\/java.base\/share\/data\/tzdata\/tzmappings.override","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -282,1 +282,2 @@\n-However, as in `@`-files, use of a wildcard is not supported. In order to\n+Any wildcard literal `*` in the `JDK_JAVA_OPTIONS` environment variable\n+content isn't expanded and is passed as-is to the starting VM. In order to\n@@ -3102,3 +3103,3 @@\n-    file. That means, an asterisk  `*` is passed on as-is to the starting VM.\n-    For example `*.java` stays `*.java` and is not expanded to `Foo.java`,\n-    `Bar.java`, etc. like on some command line shell.\n+    file. That means an asterisk (`*`) is passed on as-is to the starting VM.\n+    For example `*.java` stays `*.java` and is not expanded to\n+    `Foo.java Bar.java ...`, as would happen with some command line shells.\n@@ -3147,2 +3148,0 @@\n--   Wildcards (\\*) aren't allowed in these lists (such as specifying `*.java`).\n-\n","filename":"src\/java.base\/share\/man\/java.md","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,3 @@\n-                                                              jlong avalues, jlong jcaptured_state, jint captured_state_mask,\n+                                                              jlong avalues,\n+                                                              jarray capture_state_heap_base, jlong captured_state_offset,\n+                                                              jint captured_state_mask,\n@@ -118,0 +120,2 @@\n+  int capture_state_hb_offset = numArgs;\n+  int32_t* captured_state_addr = jlong_to_ptr(captured_state_offset);\n@@ -120,1 +124,1 @@\n-    carrays = malloc(sizeof(void*) * numArgs);\n+    carrays = malloc(sizeof(void*) * (numArgs + 1));\n@@ -133,0 +137,6 @@\n+    if (capture_state_heap_base != NULL) {\n+        jboolean isCopy;\n+        jbyte* arrayPtr = (*env)->GetPrimitiveArrayCritical(env, capture_state_heap_base, &isCopy);\n+        carrays[capture_state_hb_offset] = arrayPtr;\n+        captured_state_addr = (int32_t*) (arrayPtr + captured_state_offset);\n+    }\n@@ -137,0 +147,4 @@\n+  if (captured_state_mask != 0) {\n+    do_capture_state(captured_state_addr, captured_state_mask);\n+  }\n+\n@@ -144,0 +158,3 @@\n+    if (capture_state_heap_base != NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, capture_state_heap_base, carrays[capture_state_hb_offset], JNI_COMMIT);\n+    }\n@@ -146,5 +163,0 @@\n-\n-  if (captured_state_mask != 0) {\n-    int32_t* captured_state = jlong_to_ptr(jcaptured_state);\n-    do_capture_state(captured_state, captured_state_mask);\n-  }\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -67,4 +67,1 @@\n-    const char *onLoadSymbols[] = JNI_ONLOAD_SYMBOLS;\n-    const char *onUnloadSymbols[] = JNI_ONUNLOAD_SYMBOLS;\n-    const char **syms;\n-    int symsLen;\n+    const char *sym;\n@@ -73,1 +70,0 @@\n-    int i;\n@@ -77,6 +73,11 @@\n-    if (isLoad) {\n-        syms = onLoadSymbols;\n-        symsLen = sizeof(onLoadSymbols) \/ sizeof(char *);\n-    } else {\n-        syms = onUnloadSymbols;\n-        symsLen = sizeof(onUnloadSymbols) \/ sizeof(char *);\n+    sym = isLoad ? \"JNI_OnLoad\" : \"JNI_OnUnload\";\n+\n+    \/\/ sym + '_' + cname + '\\0'\n+    if ((len = strlen(sym) + (cname != NULL ? (strlen(cname) + 1) : 0) + 1) >\n+        FILENAME_MAX) {\n+        goto done;\n+    }\n+    jniFunctionName = malloc(len);\n+    if (jniFunctionName == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, NULL);\n+        goto done;\n@@ -84,21 +85,4 @@\n-    for (i = 0; i < symsLen; i++) {\n-        \/\/ cname + sym + '_' + '\\0'\n-        if ((len = (cname != NULL ? strlen(cname) : 0) + strlen(syms[i]) + 2) >\n-            FILENAME_MAX) {\n-            goto done;\n-        }\n-        jniFunctionName = malloc(len);\n-        if (jniFunctionName == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n-            goto done;\n-        }\n-        strcpy(jniFunctionName, syms[i]);\n-        if (cname != NULL) {\n-            strcat(jniFunctionName, \"_\");\n-            strcat(jniFunctionName, cname);\n-        }\n-        entryName = JVM_FindLibraryEntry(handle, jniFunctionName);\n-        free(jniFunctionName);\n-        if(entryName) {\n-            break;\n-        }\n+    strcpy(jniFunctionName, sym);\n+    if (cname != NULL) {\n+        strcat(jniFunctionName, \"_\");\n+        strcat(jniFunctionName, cname);\n@@ -106,0 +90,2 @@\n+    entryName = JVM_FindLibraryEntry(handle, jniFunctionName);\n+    free(jniFunctionName);\n","filename":"src\/java.base\/share\/native\/libjava\/NativeLibraries.c","additions":18,"deletions":32,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -66,0 +66,7 @@\n+enum HelpKind {\n+    HELP_NONE,\n+    HELP_CONCISE,\n+    HELP_FULL,\n+    HELP_EXTRA\n+};\n+\n@@ -68,1 +75,1 @@\n-static jboolean printUsage = JNI_FALSE;   \/* print and exit*\/\n+static enum HelpKind printUsageKind = HELP_NONE; \/* if not NONE, print specified usage and exit*\/\n@@ -70,1 +77,0 @@\n-static jboolean printXUsage = JNI_FALSE;  \/* print and exit*\/\n@@ -123,1 +129,1 @@\n-static void PrintUsage(JNIEnv* env, jboolean doXUsage);\n+static void PrintUsage(JNIEnv* env, enum HelpKind printUsageKind);\n@@ -182,1 +188,1 @@\n-            printUsage = JNI_FALSE; \\\n+            printUsageKind = HELP_NONE; \\\n@@ -192,1 +198,1 @@\n-            printUsage = JNI_TRUE; \\\n+            printUsageKind = HELP_FULL; \\\n@@ -540,2 +546,2 @@\n-    if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {\n-        PrintUsage(env, printXUsage);\n+    if (printUsageKind != HELP_NONE) {\n+        PrintUsage(env, printUsageKind);\n@@ -1238,1 +1244,1 @@\n-            printUsage = JNI_TRUE;\n+            printUsageKind = HELP_FULL;\n@@ -1241,1 +1247,1 @@\n-            printUsage = JNI_TRUE;\n+            printUsageKind = HELP_FULL;\n@@ -1259,1 +1265,1 @@\n-            printXUsage = JNI_TRUE;\n+            printUsageKind = HELP_EXTRA;\n@@ -1262,1 +1268,1 @@\n-            printXUsage = JNI_TRUE;\n+            printUsageKind = HELP_EXTRA;\n@@ -1353,0 +1359,1 @@\n+            printUsageKind = HELP_CONCISE;\n@@ -1922,1 +1929,1 @@\n-PrintUsage(JNIEnv* env, jboolean doXUsage)\n+PrintUsage(JNIEnv* env, enum HelpKind printUsageKind)\n@@ -1924,1 +1931,2 @@\n-  jmethodID initHelp, vmSelect, vmSynonym, printHelp, printXUsageMessage;\n+  jmethodID initHelp, vmSelect, vmSynonym;\n+  jmethodID printHelp, printConciseUsageMessage, printXUsageMessage;\n@@ -1929,32 +1937,41 @@\n-  if (doXUsage) {\n-    NULL_CHECK(printXUsageMessage = (*env)->GetStaticMethodID(env, cls,\n-                                        \"printXUsageMessage\", \"(Z)V\"));\n-    (*env)->CallStaticVoidMethod(env, cls, printXUsageMessage, printTo);\n-  } else {\n-    NULL_CHECK(initHelp = (*env)->GetStaticMethodID(env, cls,\n-                                        \"initHelpMessage\", \"(Ljava\/lang\/String;)V\"));\n-\n-    NULL_CHECK(vmSelect = (*env)->GetStaticMethodID(env, cls, \"appendVmSelectMessage\",\n-                                        \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n-\n-    NULL_CHECK(vmSynonym = (*env)->GetStaticMethodID(env, cls,\n-                                        \"appendVmSynonymMessage\",\n-                                        \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n-\n-    NULL_CHECK(printHelp = (*env)->GetStaticMethodID(env, cls,\n-                                        \"printHelpMessage\", \"(Z)V\"));\n-\n-    NULL_CHECK(jprogname = (*env)->NewStringUTF(env, _program_name));\n-\n-    \/* Initialize the usage message with the usual preamble *\/\n-    (*env)->CallStaticVoidMethod(env, cls, initHelp, jprogname);\n-    CHECK_EXCEPTION_RETURN();\n-\n-\n-    \/* Assemble the other variant part of the usage *\/\n-    for (i=1; i<knownVMsCount; i++) {\n-      if (knownVMs[i].flag == VM_KNOWN) {\n-        NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n-        NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].name+1));\n-        (*env)->CallStaticVoidMethod(env, cls, vmSelect, vm1, vm2);\n-        CHECK_EXCEPTION_RETURN();\n+  switch (printUsageKind) {\n+    case HELP_NONE: break;\n+    case HELP_CONCISE:\n+      NULL_CHECK(printConciseUsageMessage = (*env)->GetStaticMethodID(env, cls,\n+                                          \"printConciseUsageMessage\", \"(Z)V\"));\n+      (*env)->CallStaticVoidMethod(env, cls, printConciseUsageMessage, printTo);\n+      break;\n+    case HELP_EXTRA:\n+      NULL_CHECK(printXUsageMessage = (*env)->GetStaticMethodID(env, cls,\n+                                          \"printXUsageMessage\", \"(Z)V\"));\n+      (*env)->CallStaticVoidMethod(env, cls, printXUsageMessage, printTo);\n+      break;\n+    case HELP_FULL:\n+      NULL_CHECK(initHelp = (*env)->GetStaticMethodID(env, cls,\n+                                          \"initHelpMessage\", \"(Ljava\/lang\/String;)V\"));\n+\n+      NULL_CHECK(vmSelect = (*env)->GetStaticMethodID(env, cls, \"appendVmSelectMessage\",\n+                                          \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n+\n+      NULL_CHECK(vmSynonym = (*env)->GetStaticMethodID(env, cls,\n+                                          \"appendVmSynonymMessage\",\n+                                          \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n+\n+      NULL_CHECK(printHelp = (*env)->GetStaticMethodID(env, cls,\n+                                          \"printHelpMessage\", \"(Z)V\"));\n+\n+      NULL_CHECK(jprogname = (*env)->NewStringUTF(env, _program_name));\n+\n+      \/* Initialize the usage message with the usual preamble *\/\n+      (*env)->CallStaticVoidMethod(env, cls, initHelp, jprogname);\n+      CHECK_EXCEPTION_RETURN();\n+\n+\n+      \/* Assemble the other variant part of the usage *\/\n+      for (i=1; i<knownVMsCount; i++) {\n+        if (knownVMs[i].flag == VM_KNOWN) {\n+          NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n+          NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].name+1));\n+          (*env)->CallStaticVoidMethod(env, cls, vmSelect, vm1, vm2);\n+          CHECK_EXCEPTION_RETURN();\n+        }\n@@ -1962,7 +1979,7 @@\n-    }\n-    for (i=1; i<knownVMsCount; i++) {\n-      if (knownVMs[i].flag == VM_ALIASED_TO) {\n-        NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n-        NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].alias+1));\n-        (*env)->CallStaticVoidMethod(env, cls, vmSynonym, vm1, vm2);\n-        CHECK_EXCEPTION_RETURN();\n+      for (i=1; i<knownVMsCount; i++) {\n+        if (knownVMs[i].flag == VM_ALIASED_TO) {\n+          NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n+          NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].alias+1));\n+          (*env)->CallStaticVoidMethod(env, cls, vmSynonym, vm1, vm2);\n+          CHECK_EXCEPTION_RETURN();\n+        }\n@@ -1970,1 +1987,0 @@\n-    }\n@@ -1972,2 +1988,3 @@\n-    \/* Complete the usage message and print to stderr*\/\n-    (*env)->CallStaticVoidMethod(env, cls, printHelp, printTo);\n+      \/* Complete the usage message and print to stderr*\/\n+      (*env)->CallStaticVoidMethod(env, cls, printHelp, printTo);\n+      break;\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":72,"deletions":55,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -30,0 +31,1 @@\n+\n@@ -43,1 +45,1 @@\n-public class FileURLMapper {\n+final class FileURLMapper {\n@@ -45,2 +47,2 @@\n-    URL url;\n-    String path;\n+    private final URL url;\n+    private String path;\n@@ -48,1 +50,1 @@\n-    public FileURLMapper (URL url) {\n+    FileURLMapper(URL url) {\n@@ -56,2 +58,1 @@\n-\n-    public String getPath () {\n+    String getPath() throws IOException {\n@@ -64,1 +65,5 @@\n-            path = ParseUtil.decode(path);\n+            try {\n+                path = ParseUtil.decode(path);\n+            } catch (IllegalArgumentException iae) {\n+                throw new IOException(iae);\n+            }\n@@ -72,2 +77,2 @@\n-    public boolean exists () {\n-        String s = getPath ();\n+    boolean exists() throws IOException {\n+        String s = getPath();\n@@ -77,1 +82,1 @@\n-            File f = new File (s);\n+            File f = new File(s);\n","filename":"src\/java.base\/unix\/classes\/jdk\/internal\/loader\/FileURLMapper.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -133,9 +132,3 @@\n-        nameservers =\n-            java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<>() {\n-                    public ArrayList<String> run() {\n-                        \/\/ typically MAXNS is 3 but we've picked 5 here\n-                        \/\/ to allow for additional servers if required.\n-                        return resolvconf(\"nameserver\", 1, 5);\n-                    } \/* run *\/\n-                });\n+        \/\/ typically MAXNS is 3 but we've picked 5 here\n+        \/\/ to allow for additional servers if required.\n+        nameservers = resolvconf(\"nameserver\", 1, 5);\n@@ -152,2 +145,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n@@ -156,2 +147,0 @@\n-        ArrayList<String> sl;\n-\n@@ -160,19 +149,3 @@\n-        sl = java.security.AccessController.doPrivileged(\n-                 new java.security.PrivilegedAction<>() {\n-                    public ArrayList<String> run() {\n-                        ArrayList<String> ll;\n-\n-                        \/\/ first try search keyword (max 6 domains)\n-                        ll = resolvconf(\"search\", 6, 1);\n-                        if (ll.size() > 0) {\n-                            return ll;\n-                        }\n-\n-                        return null;\n-\n-                    } \/* run *\/\n-\n-                });\n-        if (sl != null) {\n-            return sl;\n-        }\n+        \/\/ first try search keyword (max 6 domains)\n+        ArrayList<String> sl = resolvconf(\"search\", 6, 1);\n+        if (sl.size() > 0) return sl;\n@@ -183,17 +156,2 @@\n-\n-        sl = java.security.AccessController.doPrivileged(\n-                 new java.security.PrivilegedAction<>() {\n-                    public ArrayList<String> run() {\n-                        ArrayList<String> ll;\n-\n-                        ll = resolvconf(\"domain\", 1, 1);\n-                        if (ll.size() > 0) {\n-                            return ll;\n-                        }\n-                        return null;\n-\n-                    } \/* run *\/\n-                });\n-        if (sl != null) {\n-            return sl;\n-        }\n+        sl = resolvconf(\"domain\", 1, 1);\n+        if (sl.size() > 0) return sl;\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/dns\/ResolverConfigurationImpl.java","additions":9,"deletions":51,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import sun.security.action.GetPropertyAction;\n-\n@@ -57,1 +55,1 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n+        Properties props = System.getProperties();\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/sdp\/SdpProvider.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -75,1 +74,1 @@\n-        NTLMAuthenticationCallback.getNTLMAuthenticationCallback();\n+            NTLMAuthenticationCallback.getNTLMAuthenticationCallback();\n@@ -82,0 +81,1 @@\n+\n@@ -83,3 +83,2 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-        defaultDomain = props.getProperty(\"http.auth.ntlm.domain\", \"\");\n-        String ntlmCacheProp = props.getProperty(\"jdk.ntlm.cache\", \"true\");\n+        defaultDomain = System.getProperty(\"http.auth.ntlm.domain\", \"\");\n+        String ntlmCacheProp = System.getProperty(\"jdk.ntlm.cache\", \"true\");\n@@ -89,1 +88,1 @@\n-    public static boolean supportsTransparentAuth () {\n+    public static boolean supportsTransparentAuth() {\n@@ -104,17 +103,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private void init0() {\n-\n-        hostname = java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-            public String run() {\n-                String localhost;\n-                try {\n-                    localhost = InetAddress.getLocalHost().getHostName();\n-                } catch (UnknownHostException e) {\n-                     localhost = \"localhost\";\n-                }\n-                return localhost;\n-            }\n-        });\n-    };\n-\n@@ -153,1 +135,0 @@\n-        init0();\n@@ -155,1 +136,6 @@\n-            String version = GetPropertyAction.privilegedGetProperty(\"ntlm.version\");\n+            hostname = InetAddress.getLocalHost().getHostName();\n+        } catch (UnknownHostException e) {\n+            hostname = \"localhost\";\n+        }\n+        try {\n+            String version = System.getProperty(\"ntlm.version\");\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/http\/ntlm\/NTLMAuthentication.java","additions":11,"deletions":25,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -141,45 +140,0 @@\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<>() {\n-                @Override\n-                public RandomIO run() {\n-\n-                    File seedFile;\n-                    File nextFile;\n-\n-                    switch(v) {\n-                    case MIXED:\n-                        URL egdUrl;\n-                        File egdFile = null;\n-\n-                        if ((egdUrl = getEgdUrl()) != null) {\n-                            try {\n-                                egdFile = SunEntries.getDeviceFile(egdUrl);\n-                            } catch (IOException e) {\n-                                \/\/ Swallow, seedFile is still null\n-                            }\n-                        }\n-\n-                        \/\/ Try egd first.\n-                        if ((egdFile != null) && egdFile.canRead()) {\n-                            seedFile = egdFile;\n-                        } else {\n-                            \/\/ fall back to \/dev\/random.\n-                            seedFile = new File(NAME_RANDOM);\n-                        }\n-                        nextFile = new File(NAME_URANDOM);\n-                        break;\n-\n-                    case BLOCKING:\n-                        seedFile = new File(NAME_RANDOM);\n-                        nextFile = new File(NAME_RANDOM);\n-                        break;\n-\n-                    case NONBLOCKING:\n-                        seedFile = new File(NAME_URANDOM);\n-                        nextFile = new File(NAME_URANDOM);\n-                        break;\n-\n-                    default:\n-                        \/\/ Shouldn't happen!\n-                        return null;\n-                    }\n@@ -187,5 +141,2 @@\n-                    if (debug != null) {\n-                        debug.println(\"NativePRNG.\" + v +\n-                            \" seedFile: \" + seedFile +\n-                            \" nextFile: \" + nextFile);\n-                    }\n+        File seedFile;\n+        File nextFile;\n@@ -193,7 +144,4 @@\n-                    if (!seedFile.canRead() || !nextFile.canRead()) {\n-                        if (debug != null) {\n-                            debug.println(\"NativePRNG.\" + v +\n-                                \" Couldn't read Files.\");\n-                        }\n-                        return null;\n-                    }\n+        switch(v) {\n+        case MIXED:\n+            URL egdUrl;\n+            File egdFile = null;\n@@ -201,5 +149,5 @@\n-                    try {\n-                        return new RandomIO(seedFile, nextFile);\n-                    } catch (Exception e) {\n-                        return null;\n-                    }\n+            if ((egdUrl = getEgdUrl()) != null) {\n+                try {\n+                    egdFile = SunEntries.getDeviceFile(egdUrl);\n+                } catch (IOException e) {\n+                    \/\/ Swallow, seedFile is still null\n@@ -207,1 +155,46 @@\n-        });\n+            }\n+\n+            \/\/ Try egd first.\n+            if ((egdFile != null) && egdFile.canRead()) {\n+                seedFile = egdFile;\n+            } else {\n+                \/\/ fall back to \/dev\/random.\n+                seedFile = new File(NAME_RANDOM);\n+            }\n+            nextFile = new File(NAME_URANDOM);\n+            break;\n+\n+        case BLOCKING:\n+            seedFile = new File(NAME_RANDOM);\n+            nextFile = new File(NAME_RANDOM);\n+            break;\n+\n+        case NONBLOCKING:\n+            seedFile = new File(NAME_URANDOM);\n+            nextFile = new File(NAME_URANDOM);\n+            break;\n+\n+        default:\n+            \/\/ Shouldn't happen!\n+            return null;\n+        }\n+\n+        if (debug != null) {\n+            debug.println(\"NativePRNG.\" + v +\n+                \" seedFile: \" + seedFile +\n+                \" nextFile: \" + nextFile);\n+        }\n+\n+        if (!seedFile.canRead() || !nextFile.canRead()) {\n+            if (debug != null) {\n+                debug.println(\"NativePRNG.\" + v +\n+                    \" Couldn't read Files.\");\n+            }\n+            return null;\n+        }\n+\n+        try {\n+            return new RandomIO(seedFile, nextFile);\n+        } catch (Exception e) {\n+            return null;\n+        }\n@@ -475,1 +468,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -480,11 +472,5 @@\n-                    seedOut = AccessController.doPrivileged(\n-                            new PrivilegedAction<>() {\n-                        @Override\n-                        public OutputStream run() {\n-                            try {\n-                                return new FileOutputStream(seedFile, true);\n-                            } catch (Exception e) {\n-                                return null;\n-                            }\n-                        }\n-                    });\n+                    try {\n+                        seedOut = new FileOutputStream(seedFile, true);\n+                    } catch (Exception e) {\n+                        seedOut = null;\n+                    }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":62,"deletions":76,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -279,0 +279,7 @@\n+    if (JLI_IsStaticallyLinked()) {\n+        \/\/ With static builds, all JDK and VM natives are statically linked\n+        \/\/ with the launcher executable. No need to manipulate LD_LIBRARY_PATH\n+        \/\/ by adding <jdk_path>\/lib and etc. The 'jrepath', 'jvmpath' and\n+        \/\/ 'jvmcfg' are not used by the caller for static builds. Simply return.\n+        return;\n+    }\n@@ -321,0 +328,1 @@\n+\n@@ -522,5 +530,9 @@\n-    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n-    if (libjvm == NULL) {\n-        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n-        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n-        return JNI_FALSE;\n+    if (JLI_IsStaticallyLinked()) {\n+        libjvm = dlopen(NULL, RTLD_NOW + RTLD_GLOBAL);\n+    } else {\n+        libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n+        if (libjvm == NULL) {\n+            JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n+            JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+            return JNI_FALSE;\n+        }\n@@ -603,5 +615,8 @@\n-        if (!GetJDKInstallRoot(jdkRoot, sizeof(jdkRoot), JNI_FALSE)) {\n-            JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n-            return NULL;\n-        }\n-        ret = JLI_Snprintf(splashPath, sizeof(splashPath), \"%s\/lib\/%s\",\n+        if (JLI_IsStaticallyLinked()) {\n+            hSplashLib = dlopen(NULL, RTLD_LAZY);\n+        } else {\n+            if (!GetJDKInstallRoot(jdkRoot, sizeof(jdkRoot), JNI_FALSE)) {\n+                JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n+                return NULL;\n+            }\n+            ret = JLI_Snprintf(splashPath, sizeof(splashPath), \"%s\/lib\/%s\",\n@@ -610,7 +625,9 @@\n-        if (ret >= (int) sizeof(splashPath)) {\n-            JLI_ReportErrorMessage(LAUNCHER_ERROR3);\n-            return NULL;\n-        }\n-        if (ret < 0) {\n-            JLI_ReportErrorMessage(LAUNCHER_ERROR5);\n-            return NULL;\n+            if (ret >= (int) sizeof(splashPath)) {\n+                JLI_ReportErrorMessage(LAUNCHER_ERROR3);\n+                return NULL;\n+            }\n+            if (ret < 0) {\n+                JLI_ReportErrorMessage(LAUNCHER_ERROR5);\n+                return NULL;\n+            }\n+            hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n@@ -618,1 +635,0 @@\n-        hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":34,"deletions":18,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -30,0 +31,1 @@\n+\n@@ -39,1 +41,1 @@\n-public class FileURLMapper {\n+final class FileURLMapper {\n@@ -41,2 +43,2 @@\n-    URL url;\n-    String file;\n+    private final URL url;\n+    private String file;\n@@ -44,1 +46,1 @@\n-    public FileURLMapper (URL url) {\n+    FileURLMapper (URL url) {\n@@ -52,2 +54,1 @@\n-\n-    public String getPath () {\n+    String getPath() throws IOException {\n@@ -66,1 +67,5 @@\n-        file = ParseUtil.decode(path);\n+        try {\n+            file = ParseUtil.decode(path);\n+        } catch (IllegalArgumentException iae) {\n+            throw new IOException(iae);\n+        }\n@@ -70,1 +75,1 @@\n-    public boolean exists() {\n+    boolean exists() throws IOException {\n@@ -72,1 +77,1 @@\n-        File f = new File (path);\n+        File f = new File(path);\n","filename":"src\/java.base\/windows\/classes\/jdk\/internal\/loader\/FileURLMapper.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -37,0 +39,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -386,0 +389,2 @@\n+        private static final VarHandle RELEASED = MhUtil.findVarHandle(MethodHandles.lookup(),\n+                \"released\", boolean.class);\n@@ -390,0 +395,1 @@\n+        private volatile boolean released;\n@@ -408,1 +414,1 @@\n-            if (buf != dst)\n+            if (buf != dst && RELEASED.compareAndSet(this, false, true)) {\n@@ -410,0 +416,1 @@\n+            }\n@@ -572,0 +579,2 @@\n+        private static final VarHandle RELEASED = MhUtil.findVarHandle(MethodHandles.lookup(),\n+                \"released\", boolean.class);\n@@ -576,0 +585,1 @@\n+        private volatile boolean released;\n@@ -594,1 +604,1 @@\n-            if (buf != src)\n+            if (buf != src && RELEASED.compareAndSet(this, false, true)) {\n@@ -596,0 +606,1 @@\n+            }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousFileChannelImpl.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -34,0 +36,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -370,0 +373,2 @@\n+        private static final VarHandle RELEASED = MhUtil.findVarHandle(MethodHandles.lookup(),\n+                \"released\", boolean.class);\n@@ -374,0 +379,1 @@\n+        private volatile boolean released;\n@@ -464,3 +470,5 @@\n-            for (int i=0; i<numBufs; i++) {\n-                if (!(bufs[i] instanceof DirectBuffer)) {\n-                    Util.releaseTemporaryDirectBuffer(shadow[i]);\n+            if (RELEASED.compareAndSet(this, false, true)) {\n+                for (int i = 0; i < numBufs; i++) {\n+                    if (!(bufs[i] instanceof DirectBuffer)) {\n+                        Util.releaseTemporaryDirectBuffer(shadow[i]);\n+                    }\n@@ -468,0 +476,1 @@\n+                IOUtil.releaseScopes(scopeHandleReleasers);\n@@ -469,1 +478,0 @@\n-            IOUtil.releaseScopes(scopeHandleReleasers);\n@@ -644,0 +652,2 @@\n+        private static final VarHandle RELEASED = MhUtil.findVarHandle(MethodHandles.lookup(),\n+                \"released\", boolean.class);\n@@ -648,0 +658,1 @@\n+        private volatile boolean released;\n@@ -731,3 +742,5 @@\n-            for (int i=0; i<numBufs; i++) {\n-                if (!(bufs[i] instanceof DirectBuffer)) {\n-                    Util.releaseTemporaryDirectBuffer(shadow[i]);\n+            if (RELEASED.compareAndSet(this, false, true)) {\n+                for (int i = 0; i < numBufs; i++) {\n+                    if (!(bufs[i] instanceof DirectBuffer)) {\n+                        Util.releaseTemporaryDirectBuffer(shadow[i]);\n+                    }\n@@ -735,0 +748,1 @@\n+                IOUtil.releaseScopes(scopeHandleReleasers);\n@@ -736,1 +750,0 @@\n-            IOUtil.releaseScopes(scopeHandleReleasers);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousSocketChannelImpl.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -345,10 +345,2 @@\n-    if (! PeekNamedPipe(han, NULL, 0, NULL, pbytes, NULL)) {\n-        \/* PeekNamedPipe fails when at EOF.  In that case we\n-         * simply make *pbytes = 0 which is consistent with the\n-         * behavior we get on Solaris when an fd is at EOF.\n-         * The only alternative is to raise and Exception,\n-         * which isn't really warranted.\n-         *\/\n-        if (GetLastError() != ERROR_BROKEN_PIPE) {\n-            return FALSE;\n-        }\n+    if (!PeekNamedPipe(han, NULL, 0, NULL, pbytes, NULL)) {\n+        \/\/ If PeekNamedPipe fails, set the number of available bytes to zero.\n","filename":"src\/java.base\/windows\/native\/libjava\/io_util_md.c","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,1 +80,4 @@\n-     *  24: tbd\n+     *  24: no changes (primitive Types in Patterns, instanceof, and\n+     *      switch in second preview, module Import Declarations in second\n+     *      preview, simple source files and instance main in fourth\n+     *      preview, flexible constructor bodies in third preview)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -133,5 +133,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkWrite(filename);\n-        }\n@@ -148,5 +143,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkWrite(filename);\n-        }\n@@ -163,5 +153,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkWrite(filename);\n-        }\n@@ -178,5 +163,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkRead(filename);\n-        }\n@@ -193,5 +173,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkRead(filename);\n-        }\n@@ -361,4 +336,0 @@\n-                @SuppressWarnings(\"removal\")\n-                final SecurityManager security = System.getSecurityManager();\n-                if (security != null) security.checkDelete(fileName);\n-\n@@ -385,4 +356,0 @@\n-                @SuppressWarnings(\"removal\")\n-                final SecurityManager security = System.getSecurityManager();\n-                if (security != null) security.checkRead(fileName);\n-\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eio\/FileManager.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        } catch (ClassNotFoundException | SecurityException exception) {\n+        } catch (ClassNotFoundException exception) {\n@@ -98,1 +98,1 @@\n-            } catch (ClassNotFoundException | SecurityException exception) {\n+            } catch (ClassNotFoundException exception) {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/finder\/ClassFinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,5 +48,1 @@\n-        try {\n-            return CACHE.get(type);\n-        } catch (SecurityException exception) {\n-            return DEFAULT;\n-        }\n+        return CACHE.get(type);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/introspect\/ClassInfo.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.*;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKStyle.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,2 +92,0 @@\n-     * @throws SecurityException thrown if the synthesizer cannot be\n-     * opened due to security restrictions.\n@@ -122,2 +120,0 @@\n-     * @throws SecurityException thrown if the synthesizer cannot be\n-     * opened due to security restrictions.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/AudioSynthesizer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-                        \/\/ IllegalArgumentException, SecurityException\n+                        \/\/ IllegalArgumentException\n@@ -1125,1 +1125,1 @@\n-                    \/\/ IllegalArgumentException, SecurityException\n+                    \/\/ IllegalArgumentException\n@@ -1169,2 +1169,1 @@\n-            } catch (final LineUnavailableException | SecurityException\n-                    | IllegalArgumentException e) {\n+            } catch (final LineUnavailableException | IllegalArgumentException e) {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftSynthesizer.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,1 +298,0 @@\n-            String key    = prefix + DOT_FILE_SUFFIX;\n@@ -300,1 +299,4 @@\n-            if (!systemCustomCursorProperties.containsKey(key)) {\n+            String fileName =\n+                systemCustomCursorProperties.getProperty(prefix + DOT_FILE_SUFFIX);\n+\n+            if (fileName == null) {\n@@ -307,4 +309,1 @@\n-            final String fileName =\n-                systemCustomCursorProperties.getProperty(key);\n-\n-            final String localized = systemCustomCursorProperties.getProperty(\n+            String localized = systemCustomCursorProperties.getProperty(\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Cursor.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -896,1 +896,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -898,15 +897,1 @@\n-\n-        if (System.getSecurityManager() == null) {\n-            return true;\n-        }\n-        File f = null;\n-        boolean hasPerm = false;\n-        try {\n-            f = Files.createTempFile(\"+~JT\", \".tmp\").toFile();\n-            f.delete();\n-            f = null;\n-            hasPerm = true;\n-        } catch (Throwable t) {\n-            \/* inc. any kind of SecurityException *\/\n-        }\n-        return hasPerm;\n+        return true;\n@@ -1760,5 +1745,1 @@\n-        String str = null;\n-        try {\n-            str =System.getProperty(nm);\n-        } catch(SecurityException e) {\n-        }\n+        String str = System.getProperty(nm);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Font.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -601,4 +601,1 @@\n-                try {\n-                    setAlwaysOnTop(true);\n-                } catch (SecurityException ignore) {\n-                }\n+                setAlwaysOnTop(true);\n@@ -1308,4 +1305,1 @@\n-            try {\n-                setAlwaysOnTop(false);\n-            }catch(SecurityException e) {\n-            }\n+            setAlwaysOnTop(false);\n@@ -2194,4 +2188,1 @@\n-                try {\n-                    window.setAlwaysOnTop(alwaysOnTop);\n-                } catch (SecurityException ignore) {\n-                }\n+                window.setAlwaysOnTop(alwaysOnTop);\n@@ -3035,1 +3026,1 @@\n-             setAlwaysOnTop(aot); \/\/ since 1.5; subject to permission check\n+             setAlwaysOnTop(aot);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -67,5 +67,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/print\/PrinterJob.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -192,6 +192,1 @@\n-            try {\n-                cls = ClassLoader.getSystemClassLoader();\n-            } catch (SecurityException ex) {\n-                \/\/ We're not allowed to access the system class loader.\n-                \/\/ Drop through.\n-            }\n+            cls = ClassLoader.getSystemClassLoader();\n@@ -441,5 +436,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertiesAccess();\n-        }\n@@ -457,5 +447,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertiesAccess();\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Beans.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -338,5 +338,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertiesAccess();\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Introspector.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertiesAccess();\n-        }\n@@ -112,5 +107,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertiesAccess();\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/PropertyEditorManager.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -178,16 +177,2 @@\n-                try {\n-                    \/\/ Note that the next() call is required to be inside\n-                    \/\/ the try\/catch block; see 6342404.\n-                    IIOServiceProvider r = riter.next();\n-                    registerServiceProvider(r);\n-                } catch (ServiceConfigurationError err) {\n-                    if (System.getSecurityManager() != null) {\n-                        \/\/ In the applet case, we will catch the  error so\n-                        \/\/ registration of other plugins can  proceed\n-                        err.printStackTrace();\n-                    } else {\n-                        \/\/ In the application case, we will  throw the\n-                        \/\/ error to indicate app\/system  misconfiguration\n-                        throw err;\n-                    }\n-                }\n+                IIOServiceProvider r = riter.next();\n+                registerServiceProvider(r);\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/IIORegistry.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -396,10 +396,1 @@\n-        ArrayList<PrintService> registeredServices = null;\n-        try {\n-          @SuppressWarnings(\"removal\")\n-          SecurityManager security = System.getSecurityManager();\n-          if (security != null) {\n-            security.checkPrintJobAccess();\n-          }\n-          registeredServices = getRegisteredServices();\n-        } catch (SecurityException se) {\n-        }\n+        ArrayList<PrintService> registeredServices = getRegisteredServices();\n@@ -461,10 +452,1 @@\n-        ArrayList<PrintService> registeredServices = null;\n-        try {\n-          @SuppressWarnings(\"removal\")\n-          SecurityManager security = System.getSecurityManager();\n-          if (security != null) {\n-            security.checkPrintJobAccess();\n-          }\n-          registeredServices = getRegisteredServices();\n-        } catch (Exception e) {\n-        }\n+        ArrayList<PrintService> registeredServices = getRegisteredServices();\n","filename":"src\/java.desktop\/share\/classes\/javax\/print\/PrintServiceLookup.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -206,4 +206,1 @@\n-            try {\n-                dialog.setAlwaysOnTop(true);\n-            } catch (SecurityException e) {\n-            }\n+            dialog.setAlwaysOnTop(true);\n","filename":"src\/java.desktop\/share\/classes\/javax\/print\/ServiceUI.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -348,2 +348,0 @@\n-     * @throws SecurityException if the receiver cannot be opened due to\n-     *         security restrictions\n@@ -351,1 +349,1 @@\n-    \/\/  abstract void open() throws MidiUnavailableException, SecurityException;\n+    \/\/  abstract void open() throws MidiUnavailableException;\n","filename":"src\/java.desktop\/share\/classes\/javax\/sound\/midi\/Synthesizer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-    private static final Border SAFE_NO_FOCUS_BORDER = new EmptyBorder(1, 1, 1, 1);\n@@ -103,1 +102,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -106,10 +104,4 @@\n-        if (System.getSecurityManager() != null) {\n-            if (border != null) return border;\n-            return SAFE_NO_FOCUS_BORDER;\n-        } else {\n-            if (border != null &&\n-                    (noFocusBorder == null ||\n-                    noFocusBorder == DEFAULT_NO_FOCUS_BORDER)) {\n-                return border;\n-            }\n-            return noFocusBorder;\n+        if (border != null &&\n+                (noFocusBorder == null ||\n+                noFocusBorder == DEFAULT_NO_FOCUS_BORDER)) {\n+            return border;\n@@ -117,0 +109,1 @@\n+        return noFocusBorder;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultListCellRenderer.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -102,4 +102,0 @@\n-        \/\/ Note: This method is not backward-compatible with 1.3 and earlier\n-        \/\/ releases. It now throws a SecurityException in an applet, whereas\n-        \/\/ in previous releases, it did not. This issue was discussed at\n-        \/\/ length, and ultimately approved by Hans.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/FocusManager.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -383,7 +383,0 @@\n-        if (operation == EXIT_ON_CLOSE) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                security.checkExit(0);\n-            }\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JFrame.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1784,6 +1784,2 @@\n-        try {\n-            java.awt.Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(\n-                    new sun.awt.UngrabEvent(this));\n-        } catch (SecurityException e) {\n-            this.dispatchEvent(new sun.awt.UngrabEvent(this));\n-        }\n+        java.awt.Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(\n+                new sun.awt.UngrabEvent(this));\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JInternalFrame.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5563,1 +5563,0 @@\n-                SwingUtilities2.checkAccess(constructor.getModifiers());\n@@ -5587,1 +5586,0 @@\n-                SwingUtilities2.checkAccess(type.getModifiers());\n@@ -6369,3 +6367,0 @@\n-        \/\/ Get a PrinterJob.\n-        \/\/ Do this before anything with side-effects since it may throw a\n-        \/\/ security exception - in which case we don't want to do anything else.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -245,9 +245,1 @@\n-            \/\/ Try to set \"always-on-top\" for the popup window.\n-            \/\/ Applets usually don't have sufficient permissions to do it.\n-            \/\/ In this case simply ignore the exception.\n-            try {\n-                setAlwaysOnTop(true);\n-            } catch (SecurityException se) {\n-                \/\/ setAlwaysOnTop is restricted,\n-                \/\/ the exception is ignored\n-            }\n+            setAlwaysOnTop(true);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/Popup.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-                    } catch (SecurityException ignore) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/TimerQueue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1144,1 +1144,0 @@\n-                SwingUtilities2.checkAccess(c.getModifiers());\n@@ -1152,1 +1151,0 @@\n-                    SwingUtilities2.checkAccess(constructor.getModifiers());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/UIDefaults.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    private static final Border SAFE_NO_FOCUS_BORDER = new EmptyBorder(1, 1, 1, 1);\n@@ -71,1 +70,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -73,5 +71,1 @@\n-        if (System.getSecurityManager() != null) {\n-            return SAFE_NO_FOCUS_BORDER;\n-        } else {\n-            return noFocusBorder;\n-        }\n+        return noFocusBorder;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicComboBoxRenderer.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    private static final Object BASIC_LABEL_UI_KEY = new Object();\n@@ -469,1 +468,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -471,10 +469,0 @@\n-        if (System.getSecurityManager() != null) {\n-            AppContext appContext = AppContext.getAppContext();\n-            BasicLabelUI safeBasicLabelUI =\n-                    (BasicLabelUI) appContext.get(BASIC_LABEL_UI_KEY);\n-            if (safeBasicLabelUI == null) {\n-                safeBasicLabelUI = new BasicLabelUI();\n-                appContext.put(BASIC_LABEL_UI_KEY, safeBasicLabelUI);\n-            }\n-            return safeBasicLabelUI;\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLabelUI.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-    private static final Object METAL_LABEL_UI_KEY = new Object();\n-\n@@ -70,1 +68,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -72,10 +69,0 @@\n-        if (System.getSecurityManager() != null) {\n-            AppContext appContext = AppContext.getAppContext();\n-            MetalLabelUI safeMetalLabelUI =\n-                    (MetalLabelUI) appContext.get(METAL_LABEL_UI_KEY);\n-            if (safeMetalLabelUI == null) {\n-                safeMetalLabelUI = new MetalLabelUI();\n-                appContext.put(METAL_LABEL_UI_KEY, safeMetalLabelUI);\n-            }\n-            return safeMetalLabelUI;\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLabelUI.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -108,3 +108,0 @@\n-    private static Icon SAFE_HORIZ_THUMB_ICON;\n-    private static Icon SAFE_VERT_THUMB_ICON;\n-\n@@ -133,1 +130,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -135,5 +131,1 @@\n-        if (System.getSecurityManager() != null) {\n-            return SAFE_HORIZ_THUMB_ICON;\n-        } else {\n-            return horizThumbIcon;\n-        }\n+        return horizThumbIcon;\n@@ -142,1 +134,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -144,5 +135,1 @@\n-        if (System.getSecurityManager() != null) {\n-            return SAFE_VERT_THUMB_ICON;\n-        } else {\n-            return vertThumbIcon;\n-        }\n+        return vertThumbIcon;\n@@ -154,4 +141,2 @@\n-        horizThumbIcon = SAFE_HORIZ_THUMB_ICON =\n-                UIManager.getIcon( \"Slider.horizontalThumbIcon\" );\n-        vertThumbIcon = SAFE_VERT_THUMB_ICON =\n-                UIManager.getIcon( \"Slider.verticalThumbIcon\" );\n+        horizThumbIcon = UIManager.getIcon( \"Slider.horizontalThumbIcon\" );\n+        vertThumbIcon = UIManager.getIcon( \"Slider.verticalThumbIcon\" );\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalSliderUI.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-    private static final Border SAFE_NO_FOCUS_BORDER = new EmptyBorder(1, 1, 1, 1);\n@@ -120,1 +119,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -123,4 +121,1 @@\n-        if (System.getSecurityManager() != null) {\n-            if (border != null) return border;\n-            return SAFE_NO_FOCUS_BORDER;\n-        } else if (border != null) {\n+        if (border != null) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/DefaultTableCellRenderer.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1434,2 +1434,0 @@\n-        } catch (SecurityException se) {\n-            \/\/ do nothing... there is no allowed system clipboard\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultCaret.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -250,1 +250,0 @@\n-                SwingUtilities2.checkAccess(vc.getModifiers());\n@@ -259,1 +258,0 @@\n-                    SwingUtilities2.checkAccess(cons.getModifiers());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultFormatter.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -474,8 +474,15 @@\n-     * Inserts a string of content.  This will cause a DocumentEvent\n-     * of type DocumentEvent.EventType.INSERT to be sent to the\n-     * registered DocumentListeners, unless an exception is thrown.\n-     * The DocumentEvent will be delivered by calling the\n-     * insertUpdate method on the DocumentListener.\n-     * The offset and length of the generated DocumentEvent\n-     * will indicate what change was actually made to the Document.\n-     * <p style=\"text-align:center\"><img src=\"doc-files\/Document-insert.gif\"\n+     * Inserts a string of content.  This will cause a {@code DocumentEvent}\n+     * of type {@code DocumentEvent.EventType.INSERT} to be sent to the\n+     * registered {@code DocumentListener}s, unless an exception is thrown.\n+     * The {@code DocumentEvent} will be delivered by calling the\n+     * {@code insertUpdate} method on the {@code DocumentListener}.\n+     * The offset and length of the generated {@code DocumentEvent}\n+     * will indicate what change was actually made to the {@code Document}.\n+     * <p>\n+     * For example, if the document contains the text\n+     * <i>&lsquo;The brown fox&rsquo;<\/i>,\n+     * calling {@code insert(4, \"quick \", null)} will insert the word\n+     * <i>&lsquo;quick&rsquo;<\/i> and the following space into the text,\n+     * and all the marks at 4 and above will be moved by 6 (the number\n+     * of inserted characters).\n+     * <p style=\"text-align:center\"><img src=\"doc-files\/Document-insert.svg\"\n@@ -484,2 +491,2 @@\n-     * If the Document structure changed as result of the insertion,\n-     * the details of what Elements were inserted and removed in\n+     * If the {@code Document} structure changed as result of the insertion,\n+     * the details of what {@code Element}s were inserted and removed in\n@@ -487,1 +494,1 @@\n-     * DocumentEvent.  It is up to the implementation of a Document\n+     * {@code DocumentEvent}.  It is up to the implementation of a {@code Document}\n@@ -491,1 +498,1 @@\n-     * If the Document supports undo\/redo, an UndoableEditEvent will\n+     * If the {@code Document} supports undo\/redo, an {@code UndoableEditEvent} will\n@@ -499,1 +506,1 @@\n-     *   content.  This may be null if there are no attributes.\n+     *   content.  This may be {@code null} if there are no attributes.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/Document.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -439,1 +439,0 @@\n-                        SwingUtilities2.checkAccess(valueClass.getModifiers());\n@@ -443,1 +442,0 @@\n-                            SwingUtilities2.checkAccess(cons.getModifiers());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/NumberFormatter.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/doc-files\/Document-insert.gif","binary":true,"status":"deleted"},{"patch":"@@ -0,0 +1,150 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ This code is free software; you can redistribute it and\/or modify it\n+ under the terms of the GNU General Public License version 2 only, as\n+ published by the Free Software Foundation.  Oracle designates this\n+ particular file as subject to the \"Classpath\" exception as provided\n+ by Oracle in the LICENSE file that accompanied this code.\n+\n+ This code is distributed in the hope that it will be useful, but WITHOUT\n+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ version 2 for more details (a copy is included in the LICENSE file that\n+ accompanied this code).\n+\n+ You should have received a copy of the GNU General Public License version\n+ 2 along with this work; if not, write to the Free Software Foundation,\n+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ or visit www.oracle.com if you need additional information or have any\n+ questions.\n+-->\n+\n+<svg width=\"458\" height=\"165\"\n+     version=\"1.1\"\n+     xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\n+    <style><![CDATA[\n+        rect, path {\n+            fill: none;\n+            stroke: black;\n+            stroke-width: 1px;\n+        }\n+        marker path {\n+            fill: black;\n+        }\n+        g#quick rect {\n+            fill: #C0DCC0;\n+        }\n+        line {\n+            stroke: red;\n+            stroke-width: 1px;\n+        }\n+        text {\n+            font-family: Arial, 'DejaVu Sans', sans-serif;\n+            font-size: 13px;\n+            text-anchor: middle;\n+            dominant-baseline: middle;\n+        }\n+        text.left {\n+            text-anchor: start;\n+            dominant-baseline: auto;\n+        }\n+        text.bold {\n+            font-weight: bold;\n+        }\n+        text.top {\n+            dominant-baseline: hanging;\n+        }\n+    ]]><\/style>\n+    <defs>\n+        <marker\n+                id=\"arrow\"\n+                viewBox=\"0 0 10 10\"\n+                refX=\"10\"\n+                refY=\"5\"\n+                markerWidth=\"7\"\n+                markerHeight=\"7\"\n+                orient=\"auto\">\n+            <path\n+                d=\"M 0 0 L 10 5 L 0 10\"\n+            \/>\n+        <\/marker>\n+    <\/defs>\n+\n+    <text x=\"1\" y=\"16\" class=\"left bold\">Before Insert<\/text>\n+\n+    <use\n+            x=\"0\"\n+            y=\"-94\"\n+            xlink:href=\"#the\"\n+    \/>\n+    <use\n+            x=\"-144\"\n+            y=\"-94\"\n+            xlink:href=\"#brownFox\"\n+    \/>\n+\n+    <line x1=\"97.5\" y1=\"22\" x2=\"97.5\" y2=\"55\"\/>\n+    <text x=\"97\" y=\"57\" class=\"top\">4<\/text>\n+\n+    <text x=\"1\" y=\"110\" class=\"left bold\">After Insert<\/text>\n+\n+    <g id=\"the\">\n+        <rect x=\"3.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"13.5\" y=\"129.5\">T<\/text>\n+        <rect x=\"27.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"37.5\" y=\"129.5\">h<\/text>\n+        <rect x=\"51.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"61.5\" y=\"129.5\">e<\/text>\n+        <rect x=\"75.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"85.5\" y=\"129.5\"> <\/text>\n+    <\/g>\n+\n+    <g id=\"quick\">\n+        <rect x=\"99.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"109.5\" y=\"129.5\">q<\/text>\n+        <rect x=\"123.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"133.5\" y=\"129.5\">u<\/text>\n+        <rect x=\"147.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"157.5\" y=\"129.5\">i<\/text>\n+        <rect x=\"171.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"181.5\" y=\"129.5\">c<\/text>\n+        <rect x=\"195.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"205.5\" y=\"129.5\">k<\/text>\n+        <rect x=\"219.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"229.5\" y=\"129.5\"> <\/text>\n+    <\/g>\n+\n+    <g id=\"brownFox\">\n+        <rect x=\"243.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"253.5\" y=\"129.5\">b<\/text>\n+        <rect x=\"267.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"277.5\" y=\"129.5\">r<\/text>\n+        <rect x=\"291.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"301.5\" y=\"129.5\">o<\/text>\n+        <rect x=\"315.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"325.5\" y=\"129.5\">w<\/text>\n+        <rect x=\"339.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"349.5\" y=\"129.5\">n<\/text>\n+        <rect x=\"363.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"373.5\" y=\"129.5\"> <\/text>\n+        <rect x=\"387.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"397.5\" y=\"129.5\">f<\/text>\n+        <rect x=\"411.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"421.5\" y=\"129.5\">o<\/text>\n+        <rect x=\"435.5\" y=\"119.5\" width=\"20\" height=\"20\"\/>\n+        <text x=\"445.5\" y=\"129.5\">x<\/text>\n+    <\/g>\n+\n+    <path d=\"M  97.5,71 L 241.5,114\" marker-end=\"url(#arrow)\"\/>\n+\n+    <line x1=\"241.5\" y1=\"116\" x2=\"241.5\" y2=\"149\"\/>\n+    <text x=\"241\" y=\"151\" class=\"top\">10<\/text>\n+\n+<\/svg>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/doc-files\/Document-insert.svg","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-        <text x=\"13\" y=\"35\">T<\/text>\n+        <text x=\"13.5\" y=\"35.5\">T<\/text>\n@@ -86,1 +86,1 @@\n-        <text x=\"37\" y=\"35\">h<\/text>\n+        <text x=\"37.5\" y=\"35.5\">h<\/text>\n@@ -88,1 +88,1 @@\n-        <text x=\"61\" y=\"35\">e<\/text>\n+        <text x=\"61.5\" y=\"35.5\">e<\/text>\n@@ -90,1 +90,1 @@\n-        <text x=\"85\" y=\"35\"> <\/text>\n+        <text x=\"85.5\" y=\"35.5\"> <\/text>\n@@ -95,1 +95,1 @@\n-        <text x=\"109\" y=\"35\">q<\/text>\n+        <text x=\"109.5\" y=\"35.5\">q<\/text>\n@@ -97,1 +97,1 @@\n-        <text x=\"133\" y=\"35\">u<\/text>\n+        <text x=\"133.5\" y=\"35.5\">u<\/text>\n@@ -99,1 +99,1 @@\n-        <text x=\"157\" y=\"35\">i<\/text>\n+        <text x=\"157.5\" y=\"35.5\">i<\/text>\n@@ -101,1 +101,1 @@\n-        <text x=\"181\" y=\"35\">c<\/text>\n+        <text x=\"181.5\" y=\"35.5\">c<\/text>\n@@ -103,1 +103,1 @@\n-        <text x=\"205\" y=\"35\">k<\/text>\n+        <text x=\"205.5\" y=\"35.5\">k<\/text>\n@@ -105,1 +105,1 @@\n-        <text x=\"229\" y=\"35\"> <\/text>\n+        <text x=\"229.5\" y=\"35.5\"> <\/text>\n@@ -110,1 +110,1 @@\n-        <text x=\"253\" y=\"35\">b<\/text>\n+        <text x=\"253.5\" y=\"35.5\">b<\/text>\n@@ -112,1 +112,1 @@\n-        <text x=\"277\" y=\"35\">r<\/text>\n+        <text x=\"277.5\" y=\"35.5\">r<\/text>\n@@ -114,1 +114,1 @@\n-        <text x=\"301\" y=\"35\">o<\/text>\n+        <text x=\"301.5\" y=\"35.5\">o<\/text>\n@@ -116,1 +116,1 @@\n-        <text x=\"325\" y=\"35\">w<\/text>\n+        <text x=\"325.5\" y=\"35.5\">w<\/text>\n@@ -118,1 +118,1 @@\n-        <text x=\"349\" y=\"35\">n<\/text>\n+        <text x=\"349.5\" y=\"35.5\">n<\/text>\n@@ -120,1 +120,1 @@\n-        <text x=\"373\" y=\"35\"> <\/text>\n+        <text x=\"373.5\" y=\"35.5\"> <\/text>\n@@ -122,1 +122,1 @@\n-        <text x=\"397\" y=\"35\">f<\/text>\n+        <text x=\"397.5\" y=\"35.5\">f<\/text>\n@@ -124,1 +124,1 @@\n-        <text x=\"421\" y=\"35\">o<\/text>\n+        <text x=\"421.5\" y=\"35.5\">o<\/text>\n@@ -126,1 +126,1 @@\n-        <text x=\"445\" y=\"35\">x<\/text>\n+        <text x=\"445.5\" y=\"35.5\">x<\/text>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/doc-files\/Document-remove.svg","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.Map;\n@@ -1092,1 +1093,1 @@\n-    private static final Hashtable<HTML.Attribute, CSS.Attribute[]> htmlAttrToCssAttrMap = new Hashtable<HTML.Attribute, CSS.Attribute[]>(20);\n+    private static final Map<HTML.Attribute, CSS.Attribute[]> htmlAttrToCssAttrMap;\n@@ -1116,47 +1117,51 @@\n-\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.COLOR,\n-                                 new CSS.Attribute[]{CSS.Attribute.COLOR});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.TEXT,\n-                                 new CSS.Attribute[]{CSS.Attribute.COLOR});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.CLEAR,\n-                                 new CSS.Attribute[]{CSS.Attribute.CLEAR});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.BACKGROUND,\n-                                 new CSS.Attribute[]{CSS.Attribute.BACKGROUND_IMAGE});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.BGCOLOR,\n-                                 new CSS.Attribute[]{CSS.Attribute.BACKGROUND_COLOR});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.WIDTH,\n-                                 new CSS.Attribute[]{CSS.Attribute.WIDTH});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.HEIGHT,\n-                                 new CSS.Attribute[]{CSS.Attribute.HEIGHT});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.BORDER,\n-                                 new CSS.Attribute[]{CSS.Attribute.BORDER_TOP_WIDTH, CSS.Attribute.BORDER_RIGHT_WIDTH, CSS.Attribute.BORDER_BOTTOM_WIDTH, CSS.Attribute.BORDER_LEFT_WIDTH});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.CELLPADDING,\n-                                 new CSS.Attribute[]{CSS.Attribute.PADDING});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.CELLSPACING,\n-                                 new CSS.Attribute[]{CSS.Attribute.BORDER_SPACING});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.MARGINWIDTH,\n-                                 new CSS.Attribute[]{CSS.Attribute.MARGIN_LEFT,\n-                                                     CSS.Attribute.MARGIN_RIGHT});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.MARGINHEIGHT,\n-                                 new CSS.Attribute[]{CSS.Attribute.MARGIN_TOP,\n-                                                     CSS.Attribute.MARGIN_BOTTOM});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.HSPACE,\n-                                 new CSS.Attribute[]{CSS.Attribute.PADDING_LEFT,\n-                                                     CSS.Attribute.PADDING_RIGHT});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.VSPACE,\n-                                 new CSS.Attribute[]{CSS.Attribute.PADDING_BOTTOM,\n-                                                     CSS.Attribute.PADDING_TOP});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.FACE,\n-                                 new CSS.Attribute[]{CSS.Attribute.FONT_FAMILY});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.SIZE,\n-                                 new CSS.Attribute[]{CSS.Attribute.FONT_SIZE});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.VALIGN,\n-                                 new CSS.Attribute[]{CSS.Attribute.VERTICAL_ALIGN});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.ALIGN,\n-                                 new CSS.Attribute[]{CSS.Attribute.VERTICAL_ALIGN,\n-                                                     CSS.Attribute.TEXT_ALIGN,\n-                                                     CSS.Attribute.FLOAT});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.TYPE,\n-                                 new CSS.Attribute[]{CSS.Attribute.LIST_STYLE_TYPE});\n-        htmlAttrToCssAttrMap.put(HTML.Attribute.NOWRAP,\n-                                 new CSS.Attribute[]{CSS.Attribute.WHITE_SPACE});\n+        htmlAttrToCssAttrMap = Map.ofEntries(\n+                Map.entry(HTML.Attribute.COLOR,\n+                          new CSS.Attribute[]{CSS.Attribute.COLOR}),\n+                Map.entry(HTML.Attribute.TEXT,\n+                          new CSS.Attribute[]{CSS.Attribute.COLOR}),\n+                Map.entry(HTML.Attribute.CLEAR,\n+                          new CSS.Attribute[]{CSS.Attribute.CLEAR}),\n+                Map.entry(HTML.Attribute.BACKGROUND,\n+                          new CSS.Attribute[]{CSS.Attribute.BACKGROUND_IMAGE}),\n+                Map.entry(HTML.Attribute.BGCOLOR,\n+                          new CSS.Attribute[]{CSS.Attribute.BACKGROUND_COLOR}),\n+                Map.entry(HTML.Attribute.WIDTH,\n+                          new CSS.Attribute[]{CSS.Attribute.WIDTH}),\n+                Map.entry(HTML.Attribute.HEIGHT,\n+                          new CSS.Attribute[]{CSS.Attribute.HEIGHT}),\n+                Map.entry(HTML.Attribute.BORDER,\n+                          new CSS.Attribute[]{CSS.Attribute.BORDER_TOP_WIDTH,\n+                                              CSS.Attribute.BORDER_RIGHT_WIDTH,\n+                                              CSS.Attribute.BORDER_BOTTOM_WIDTH,\n+                                              CSS.Attribute.BORDER_LEFT_WIDTH}),\n+                Map.entry(HTML.Attribute.CELLPADDING,\n+                          new CSS.Attribute[]{CSS.Attribute.PADDING}),\n+                Map.entry(HTML.Attribute.CELLSPACING,\n+                          new CSS.Attribute[]{CSS.Attribute.BORDER_SPACING}),\n+                Map.entry(HTML.Attribute.MARGINWIDTH,\n+                          new CSS.Attribute[]{CSS.Attribute.MARGIN_LEFT,\n+                                              CSS.Attribute.MARGIN_RIGHT}),\n+                Map.entry(HTML.Attribute.MARGINHEIGHT,\n+                          new CSS.Attribute[]{CSS.Attribute.MARGIN_TOP,\n+                                              CSS.Attribute.MARGIN_BOTTOM}),\n+                Map.entry(HTML.Attribute.HSPACE,\n+                          new CSS.Attribute[]{CSS.Attribute.PADDING_LEFT,\n+                                              CSS.Attribute.PADDING_RIGHT}),\n+                Map.entry(HTML.Attribute.VSPACE,\n+                          new CSS.Attribute[]{CSS.Attribute.PADDING_BOTTOM,\n+                                              CSS.Attribute.PADDING_TOP}),\n+                Map.entry(HTML.Attribute.FACE,\n+                          new CSS.Attribute[]{CSS.Attribute.FONT_FAMILY}),\n+                Map.entry(HTML.Attribute.SIZE,\n+                          new CSS.Attribute[]{CSS.Attribute.FONT_SIZE}),\n+                Map.entry(HTML.Attribute.VALIGN,\n+                          new CSS.Attribute[]{CSS.Attribute.VERTICAL_ALIGN}),\n+                Map.entry(HTML.Attribute.ALIGN,\n+                          new CSS.Attribute[]{CSS.Attribute.VERTICAL_ALIGN,\n+                                              CSS.Attribute.TEXT_ALIGN,\n+                                              CSS.Attribute.FLOAT}),\n+                Map.entry(HTML.Attribute.TYPE,\n+                          new CSS.Attribute[]{CSS.Attribute.LIST_STYLE_TYPE}),\n+                Map.entry(HTML.Attribute.NOWRAP,\n+                          new CSS.Attribute[]{CSS.Attribute.WHITE_SPACE})\n+        );\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":53,"deletions":48,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    private static final OSType CURRENT_OSTYPE = getOSTypeImpl();  \/\/ No DoPriv needed\n+    private static final OSType CURRENT_OSTYPE = getOSTypeImpl();\n@@ -104,1 +104,1 @@\n-    public static WindowsVersion getWindowsVersion() throws SecurityException {\n+    public static WindowsVersion getWindowsVersion() {\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/OSInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -704,1 +704,0 @@\n-        checkPermissions(filename);\n@@ -760,1 +759,0 @@\n-        checkPermissions(filename);\n@@ -873,1 +871,0 @@\n-            checkPermissions(filename);\n@@ -891,8 +888,0 @@\n-    private static void checkPermissions(String filename) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkRead(filename);\n-        }\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunToolkit.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-        } catch (ClassNotFoundException | SecurityException | NullPointerException e) {\n+        } catch (ClassNotFoundException | NullPointerException e) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/shell\/ShellFolder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.util.stream.Stream;\n-\n@@ -73,1 +71,1 @@\n-                return checkFile(createShellFolder(homeDir));\n+                return createShellFolder(homeDir);\n@@ -75,1 +73,1 @@\n-                return checkFile(homeDir);\n+                return homeDir;\n@@ -79,1 +77,1 @@\n-            return checkFiles(File.listRoots());\n+            return File.listRoots();\n@@ -89,1 +87,1 @@\n-            return checkFiles(new File[] { (File)get(\"fileChooserDefaultFolder\") });\n+            return new File[] { (File)get(\"fileChooserDefaultFolder\") };\n@@ -95,32 +93,0 @@\n-    private static File checkFile(File f) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        return (sm == null || f == null) ? f : checkFile(f, sm);\n-    }\n-\n-    private static File checkFile(File f, @SuppressWarnings(\"removal\") SecurityManager sm) {\n-        try {\n-            sm.checkRead(f.getPath());\n-            if (f instanceof ShellFolder) {\n-                ShellFolder sf = (ShellFolder)f;\n-                if (sf.isLink()) {\n-                    sm.checkRead(sf.getLinkLocation().getPath());\n-                }\n-            }\n-            return f;\n-        } catch (SecurityException | FileNotFoundException e) {\n-            return null;\n-        }\n-    }\n-\n-    private static File[] checkFiles(File[] fs) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        return (sm == null || fs == null) ? fs : checkFiles(Stream.of(fs), sm);\n-    }\n-\n-    private static File[] checkFiles(Stream<File> fs, @SuppressWarnings(\"removal\") SecurityManager sm) {\n-        return fs.filter(f -> f != null && checkFile(f, sm) != null)\n-                 .toArray(File[]::new);\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/shell\/ShellFolderManager.java","additions":4,"deletions":38,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -129,3 +129,1 @@\n-     * provided as a convenience method so that users do not have to\n-     * perform the same GetPropertyAction check as above to determine whether\n-     * to enable performance logging.\n+     * provided as a convenience method.\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/util\/PerformanceLogger.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -437,6 +437,1 @@\n-        String userName = \"\";\n-        try {\n-          userName = System.getProperty(\"user.name\");\n-        } catch (SecurityException se) {\n-        }\n-\n+        String userName = System.getProperty(\"user.name\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSStreamPrintJob.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -313,6 +313,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n-\n@@ -369,5 +363,0 @@\n-                } catch (SecurityException se) {\n-                    \/\/There is already file read\/write access so at this point\n-                    \/\/ only delete access is denied.  Just ignore it because in\n-                    \/\/ most cases the file created in createNewFile gets overwritten\n-                    \/\/ anyway.\n@@ -679,21 +668,3 @@\n-                try {\n-                    if (fileName != null) {\n-                        if (fileName.isEmpty()) {\n-                            fileName = \".\";\n-                        }\n-                    } else {\n-                        \/\/ defaultDest should not be null.  The following code\n-                        \/\/ is only added to safeguard against a possible\n-                        \/\/ buggy implementation of a PrintService having a\n-                        \/\/ null default Destination.\n-                        fileName = \"out.prn\";\n-                    }\n-                    uri = (new File(fileName)).toURI();\n-                } catch (SecurityException se) {\n-                    try {\n-                        \/\/ '\\\\' file separator is illegal character in opaque\n-                        \/\/ part and causes URISyntaxException, so we replace\n-                        \/\/ it with '\/'\n-                        fileName = fileName.replace('\\\\', '\/');\n-                        uri = new URI(\"file:\"+fileName);\n-                    } catch (URISyntaxException e) {\n+                if (fileName != null) {\n+                    if (fileName.isEmpty()) {\n+                        fileName = \".\";\n@@ -701,0 +672,6 @@\n+                } else {\n+                    \/\/ defaultDest should not be null.  The following code\n+                    \/\/ is only added to safeguard against a possible\n+                    \/\/ buggy implementation of a PrintService having a\n+                    \/\/ null default Destination.\n+                    fileName = \"out.prn\";\n@@ -702,0 +679,1 @@\n+                uri = (new File(fileName)).toURI();\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PrintJob2D.java","additions":10,"deletions":32,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -819,4 +819,1 @@\n-            try {\n-                pageDialog.setAlwaysOnTop(true);\n-            } catch (SecurityException e) {\n-            }\n+            pageDialog.setAlwaysOnTop(true);\n@@ -951,9 +948,0 @@\n-        \/* A security check has already been performed in the\n-         * java.awt.print.printerJob.getPrinterJob method.\n-         * So by the time we get here, it is OK for the current thread\n-         * to print either to a file (from a Dialog we control!) or\n-         * to a chosen printer.\n-         *\n-         * We raise privilege when we put up the dialog, to avoid\n-         * the \"warning applet window\" banner.\n-         *\/\n@@ -1314,5 +1302,1 @@\n-            try {\n-                userNameAttr = getUserName();\n-            } catch (SecurityException e) {\n-                userNameAttr = \"\";\n-            }\n+            userNameAttr = getUserName();\n@@ -1657,5 +1641,0 @@\n-        } catch (SecurityException se) {\n-            \/\/There is already file read\/write access so at this point\n-            \/\/ only delete access is denied.  Just ignore it because in\n-            \/\/ most cases the file created in createNewFile gets overwritten\n-            \/\/ anyway.\n@@ -1821,1 +1800,0 @@\n-     * The caller must have security permission to read system properties.\n@@ -1834,5 +1812,1 @@\n-            try {\n-                return  getUserName();\n-            } catch (SecurityException e) {\n-                return \"\";\n-            }\n+            return getUserName();\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":3,"deletions":29,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -172,4 +172,1 @@\n-                try {\n-                    setAlwaysOnTop(true);\n-                } catch (SecurityException e) {\n-                }\n+                setAlwaysOnTop(true);\n@@ -258,4 +255,1 @@\n-                try {\n-                    setAlwaysOnTop(true);\n-                } catch (SecurityException e) {\n-                }\n+                setAlwaysOnTop(true);\n@@ -2940,7 +2934,1 @@\n-            boolean exists;\n-\n-            try {\n-                exists = selected.exists();\n-            } catch (SecurityException e) {\n-                exists = false;\n-            }\n+            boolean exists = selected.exists();\n@@ -2969,5 +2957,0 @@\n-            } catch (SecurityException se) {\n-                \/\/There is already file read\/write access so at this point\n-                \/\/ only delete access is denied.  Just ignore it because in\n-                \/\/ most cases the file created in createNewFile gets\n-                \/\/ overwritten anyway.\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/ServiceDialog.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -58,6 +58,3 @@\n-        try {\n-              setPriority(Thread.NORM_PRIORITY-1);\n-              setDaemon(true);\n-              start();\n-        } catch (SecurityException e) {\n-        }\n+        setPriority(Thread.NORM_PRIORITY-1);\n+        setDaemon(true);\n+        start();\n@@ -96,4 +93,1 @@\n-        try {\n-            interrupt();\n-        } catch (SecurityException e) {\n-        }\n+        interrupt();\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/ServiceNotifier.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2122,14 +2122,9 @@\n-        try {\n-            if (f instanceof ShellFolder) {\n-                return f.canWrite();\n-            } else {\n-                if (usesShellFolder(getFileChooser())) {\n-                    try {\n-                        return ShellFolder.getShellFolder(f).canWrite();\n-                    } catch (FileNotFoundException ex) {\n-                        \/\/ File doesn't exist\n-                        return false;\n-                    }\n-                } else {\n-                    \/\/ Ordinary file\n-                    return f.canWrite();\n+        if (f instanceof ShellFolder) {\n+            return f.canWrite();\n+        } else {\n+            if (usesShellFolder(getFileChooser())) {\n+                try {\n+                    return ShellFolder.getShellFolder(f).canWrite();\n+                } catch (FileNotFoundException ex) {\n+                    \/\/ File doesn't exist\n+                    return false;\n@@ -2137,0 +2132,3 @@\n+            } else {\n+                \/\/ Ordinary file\n+                return f.canWrite();\n@@ -2138,2 +2136,0 @@\n-        } catch (SecurityException e) {\n-            return false;\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/FilePane.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1465,14 +1465,0 @@\n-    \/**\n-     * Utility method that throws SecurityException if SecurityManager is set\n-     * and modifiers are not public\n-     *\n-     * @param modifiers a set of modifiers\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public static void checkAccess(int modifiers) {\n-        if (System.getSecurityManager() != null\n-                && !Modifier.isPublic(modifiers)) {\n-            throw new SecurityException(\"Resource is not accessible\");\n-        }\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/SwingUtilities2.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -514,5 +514,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n@@ -590,1 +585,0 @@\n-                try {\n@@ -592,7 +586,0 @@\n-                } catch (SecurityException se) {\n-                    try {\n-                        return new Destination(new URI(\"file:out.ps\"));\n-                    } catch (URISyntaxException e) {\n-                        return null;\n-                    }\n-                }\n@@ -800,5 +787,1 @@\n-            String userName = \"\";\n-            try {\n-              userName = System.getProperty(\"user.name\", \"\");\n-            } catch (SecurityException se) {\n-            }\n+            String userName = System.getProperty(\"user.name\", \"\");\n@@ -1577,9 +1560,1 @@\n-            try {\n-                return new Destination((new File(\"out.ps\")).toURI());\n-            } catch (SecurityException se) {\n-                try {\n-                    return new Destination(new URI(\"file:out.ps\"));\n-                } catch (URISyntaxException e) {\n-                    return null;\n-                }\n-            }\n+            return new Destination((new File(\"out.ps\")).toURI());\n@@ -1677,5 +1652,1 @@\n-            String userName = \"\";\n-            try {\n-              userName = System.getProperty(\"user.name\", \"\");\n-            } catch (SecurityException se) {\n-            }\n+            String userName = System.getProperty(\"user.name\", \"\");\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/IPPPrintService.java","additions":3,"deletions":32,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -213,6 +213,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n-\n@@ -552,5 +546,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-          security.checkPrintJobAccess();\n-        }\n@@ -616,5 +605,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-          security.checkPrintJobAccess();\n-        }\n@@ -626,6 +610,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-          security.checkPrintJobAccess();\n-        }\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -710,6 +710,1 @@\n-        String userName = \"\";\n-        try {\n-          userName = System.getProperty(\"user.name\");\n-        } catch (SecurityException se) {\n-        }\n-\n+        String userName = System.getProperty(\"user.name\");\n@@ -794,11 +789,0 @@\n-                    \/\/ check write access\n-                    @SuppressWarnings(\"removal\")\n-                    SecurityManager security = System.getSecurityManager();\n-                    if (security != null) {\n-                      try {\n-                        security.checkWrite(mDestination);\n-                      } catch (SecurityException se) {\n-                        notifyEvent(PrintJobEvent.JOB_FAILED);\n-                        throw new PrintException(se);\n-                      }\n-                    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/UnixPrintJob.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -419,5 +419,0 @@\n-      @SuppressWarnings(\"removal\")\n-      SecurityManager security = System.getSecurityManager();\n-      if (security != null) {\n-        security.checkPrintJobAccess();\n-      }\n@@ -630,9 +625,1 @@\n-            try {\n-                return new Destination((new File(\"out.ps\")).toURI());\n-            } catch (SecurityException se) {\n-                try {\n-                    return new Destination(new URI(\"file:out.ps\"));\n-                } catch (URISyntaxException e) {\n-                    return null;\n-                }\n-            }\n+            return new Destination((new File(\"out.ps\")).toURI());\n@@ -675,5 +662,1 @@\n-            String userName = \"\";\n-            try {\n-              userName = System.getProperty(\"user.name\", \"\");\n-            } catch (SecurityException se) {\n-            }\n+            String userName = System.getProperty(\"user.name\", \"\");\n@@ -736,1 +719,0 @@\n-            try {\n@@ -738,7 +720,0 @@\n-            } catch (SecurityException se) {\n-                try {\n-                    return new Destination(new URI(\"file:out.ps\"));\n-                } catch (URISyntaxException e) {\n-                    return null;\n-                }\n-            }\n@@ -753,5 +728,1 @@\n-            String userName = \"\";\n-            try {\n-              userName = System.getProperty(\"user.name\", \"\");\n-            } catch (SecurityException se) {\n-            }\n+            String userName = System.getProperty(\"user.name\", \"\");\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/UnixPrintService.java","additions":3,"deletions":32,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -135,1 +135,3 @@\n-    if (!JVM_IsStaticallyLinked()) {\n+    if (JVM_IsStaticallyLinked()) {\n+        awtHandle = dlopen(NULL, RTLD_LAZY);\n+    } else {\n","filename":"src\/java.desktop\/unix\/native\/libawt\/awt\/awt_LoadLibrary.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -669,7 +669,0 @@\n-        if (path != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                security.checkRead(path);\n-            }\n-        }\n@@ -753,5 +746,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkRead(getPath());\n-        }\n@@ -816,1 +804,1 @@\n-            return Win32ShellFolderManager2.checkFiles(files);\n+            return files;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolder2.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.util.stream.Stream;\n@@ -170,3 +169,0 @@\n-            } catch (final SecurityException ignored) {\n-                \/\/ Ignore, the message may have sensitive information, not\n-                \/\/ accessible other ways\n@@ -186,3 +182,0 @@\n-            } catch (final SecurityException ignored) {\n-                \/\/ Ignore, the message may have sensitive information, not\n-                \/\/ accessible other ways\n@@ -205,3 +198,0 @@\n-            } catch (final SecurityException ignored) {\n-                \/\/ Ignore, the message may have sensitive information, not\n-                \/\/ accessible other ways\n@@ -221,3 +211,0 @@\n-            } catch (final SecurityException ignored) {\n-                \/\/ Ignore, the message may have sensitive information, not\n-                \/\/ accessible other ways\n@@ -247,3 +234,0 @@\n-            } catch (final SecurityException ignored) {\n-                \/\/ Ignore, the message may have sensitive information, not\n-                \/\/ accessible other ways\n@@ -290,1 +274,1 @@\n-            return checkFile(file);\n+            return file;\n@@ -301,1 +285,1 @@\n-            return checkFiles(roots);\n+            return roots;\n@@ -305,1 +289,1 @@\n-            if (desktop != null && checkFile(desktop) != null) {\n+            if (desktop != null) {\n@@ -316,1 +300,1 @@\n-                File[] secondLevelFolders = checkFiles(desktop.listFiles());\n+                File[] secondLevelFolders = desktop.listFiles();\n@@ -324,1 +308,1 @@\n-                            File[] thirdLevelFolders = checkFiles(folder.listFiles());\n+                            File[] thirdLevelFolders = folder.listFiles();\n@@ -334,1 +318,1 @@\n-                return checkFiles(folders);\n+                return folders.toArray(new File[folders.size()]);\n@@ -377,1 +361,1 @@\n-            return checkFiles(folders);\n+            return folders.toArray(new File[folders.size()]);\n@@ -424,47 +408,0 @@\n-    private static File checkFile(File file) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        return (sm == null || file == null) ? file : checkFile(file, sm);\n-    }\n-\n-    private static File checkFile(File file, @SuppressWarnings(\"removal\") SecurityManager sm) {\n-        try {\n-            sm.checkRead(file.getPath());\n-\n-            if (file instanceof Win32ShellFolder2) {\n-                Win32ShellFolder2 f = (Win32ShellFolder2)file;\n-                if (f.isLink()) {\n-                    Win32ShellFolder2 link = (Win32ShellFolder2)f.getLinkLocation();\n-                    if (link != null)\n-                        sm.checkRead(link.getPath());\n-                }\n-            }\n-            return file;\n-        } catch (SecurityException se) {\n-            return null;\n-        }\n-    }\n-\n-    static File[] checkFiles(File[] files) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null || files == null || files.length == 0) {\n-            return files;\n-        }\n-        return checkFiles(Arrays.stream(files), sm);\n-    }\n-\n-    private static File[] checkFiles(List<File> files) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null || files.isEmpty()) {\n-            return files.toArray(new File[files.size()]);\n-        }\n-        return checkFiles(files.stream(), sm);\n-    }\n-\n-    private static File[] checkFiles(Stream<File> filesStream, @SuppressWarnings(\"removal\") SecurityManager sm) {\n-        return filesStream.filter((file) -> checkFile(file, sm) != null)\n-                .toArray(File[]::new);\n-    }\n-\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolderManager2.java","additions":7,"deletions":70,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -322,0 +322,4 @@\n+\n+        \/\/ Sync currentLocale with the Windows keyboard layout which could be changed\n+        \/\/ while the component was inactive.\n+        getLocale();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WInputMethod.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1916,10 +1916,1 @@\n-                try {\n-                    attributes.add(new Destination(\n-                                               new File(\".\/out.prn\").toURI()));\n-                } catch (SecurityException se) {\n-                    try {\n-                        attributes.add(new Destination(\n-                                                new URI(\"file:out.prn\")));\n-                    } catch (URISyntaxException e) {\n-                    }\n-                }\n+                attributes.add(new Destination(new File(\".\/out.prn\").toURI()));\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -109,5 +109,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n@@ -210,5 +205,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-          security.checkPrintJobAccess();\n-        }\n@@ -276,5 +266,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-          security.checkPrintJobAccess();\n-        }\n@@ -286,6 +271,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-          security.checkPrintJobAccess();\n-        }\n-\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -595,5 +595,1 @@\n-        String userName = \"\";\n-        try {\n-          userName = System.getProperty(\"user.name\");\n-        } catch (SecurityException se) {\n-        }\n+        String userName = System.getProperty(\"user.name\");\n@@ -677,11 +673,0 @@\n-                \/\/ check write access\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager security = System.getSecurityManager();\n-                if (security != null) {\n-                  try {\n-                    security.checkWrite(mDestination);\n-                  } catch (SecurityException se) {\n-                    notifyEvent(PrintJobEvent.JOB_FAILED);\n-                    throw new PrintException(se);\n-                  }\n-                }\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/Win32PrintJob.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -861,5 +861,0 @@\n-      @SuppressWarnings(\"removal\")\n-      SecurityManager security = System.getSecurityManager();\n-      if (security != null) {\n-        security.checkPrintJobAccess();\n-      }\n@@ -1177,9 +1172,1 @@\n-            try {\n-                return new Destination((new File(\"out.prn\")).toURI());\n-            } catch (SecurityException se) {\n-                try {\n-                    return new Destination(new URI(\"file:out.prn\"));\n-                } catch (URISyntaxException e) {\n-                    return null;\n-                }\n-            }\n+            return new Destination((new File(\"out.prn\")).toURI());\n@@ -1226,5 +1213,1 @@\n-            String userName = \"\";\n-            try {\n-              userName = System.getProperty(\"user.name\", \"\");\n-            } catch (SecurityException se) {\n-            }\n+            String userName = System.getProperty(\"user.name\", \"\");\n@@ -1305,5 +1288,1 @@\n-          String userName = \"\";\n-          try {\n-            userName = System.getProperty(\"user.name\", \"\");\n-          } catch (SecurityException se) {\n-          }\n+            String userName = System.getProperty(\"user.name\", \"\");\n@@ -1346,9 +1325,1 @@\n-            try {\n-                return new Destination((new File(\"out.prn\")).toURI());\n-            } catch (SecurityException se) {\n-                try {\n-                    return new Destination(new URI(\"file:out.prn\"));\n-                } catch (URISyntaxException e) {\n-                    return null;\n-                }\n-            }\n+            return new Destination((new File(\"out.prn\")).toURI());\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/Win32PrintService.java","additions":4,"deletions":33,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    \/\/ non final field - make it volatile to make sure that other threads\n+    \/\/ non-final field - make it volatile to make sure that other threads\n@@ -315,1 +315,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -425,3 +424,0 @@\n-    \/\/ LoggerContext maps from AppContext\n-    private WeakHashMap<Object, LoggerContext> contextsMap = null;\n-\n@@ -431,3 +427,2 @@\n-        LoggerContext context = null;\n-        \/\/ for standalone app, return userContext\n-        return context != null ? context : userContext;\n+        \/\/ return userContext\n+        return userContext;\n@@ -450,1 +445,1 @@\n-    \/\/ Otherwise a new logger instance is created and registered\n+    \/\/ Otherwise, a new logger instance is created and registered\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/LogManager.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,5 +32,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permission;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n@@ -38,2 +33,0 @@\n-import java.security.PrivilegedExceptionAction;\n-import java.security.ProtectionDomain;\n@@ -44,0 +37,1 @@\n+import java.util.concurrent.CompletionException;\n@@ -49,1 +43,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -97,1 +90,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -114,33 +106,4 @@\n-\n-        ClassLoaderRepository repository = AccessController.doPrivileged(\n-            new PrivilegedAction<ClassLoaderRepository>() {\n-                public ClassLoaderRepository run() {\n-                    return mbeanServer.getClassLoaderRepository();\n-                }\n-            },\n-            withPermissions(new MBeanPermission(\"*\", \"getClassLoaderRepository\"))\n-        );\n-        this.classLoaderWithRepository = AccessController.doPrivileged(\n-            new PrivilegedAction<ClassLoaderWithRepository>() {\n-                public ClassLoaderWithRepository run() {\n-                    return new ClassLoaderWithRepository(\n-                        repository,\n-                        dcl);\n-                }\n-            },\n-            withPermissions(new RuntimePermission(\"createClassLoader\"))\n-        );\n-\n-        this.defaultContextClassLoader =\n-            AccessController.doPrivileged(\n-                new PrivilegedAction<ClassLoader>() {\n-            @Override\n-                    public ClassLoader run() {\n-                        return new CombinedClassLoader(Thread.currentThread().getContextClassLoader(),\n-                                dcl);\n-                    }\n-                });\n-\n-        serverCommunicatorAdmin = new\n-          RMIServerCommunicatorAdmin(EnvHelp.getServerConnectionTimeout(env));\n-\n+        ClassLoaderRepository repository = mbeanServer.getClassLoaderRepository();\n+        classLoaderWithRepository = new ClassLoaderWithRepository(repository, dcl);\n+        defaultContextClassLoader = new CombinedClassLoader(Thread.currentThread().getContextClassLoader(), dcl);\n+        serverCommunicatorAdmin = new RMIServerCommunicatorAdmin(EnvHelp.getServerConnectionTimeout(env));\n@@ -150,12 +113,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private static AccessControlContext withPermissions(Permission ... perms){\n-        Permissions col = new Permissions();\n-\n-        for (Permission thePerm : perms ) {\n-            col.add(thePerm);\n-        }\n-\n-        final ProtectionDomain pd = new ProtectionDomain(null, col);\n-        return new AccessControlContext( new ProtectionDomain[] { pd });\n-    }\n-\n@@ -400,1 +351,1 @@\n-                                    getClassLoader(loaderName),\n+                                    mbeanServer.getClassLoader(loaderName),\n@@ -1252,1 +1203,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1277,9 +1227,1 @@\n-            final long csn = clientSequenceNumber;\n-            final int mn = maxNotifications;\n-            final long t = timeout;\n-            PrivilegedAction<NotificationResult> action =\n-                new PrivilegedAction<NotificationResult>() {\n-                    public NotificationResult run() {\n-                        return getServerNotifFwd().fetchNotifs(csn, t, mn);\n-                    }\n-            };\n+\n@@ -1287,1 +1229,1 @@\n-                return action.run();\n+                return getServerNotifFwd().fetchNotifs(clientSequenceNumber, timeout, maxNotifications);\n@@ -1289,1 +1231,12 @@\n-                return Subject.doAs(subject, action);\n+                try {\n+                    return Subject.callAs(subject, () -> getServerNotifFwd().fetchNotifs(clientSequenceNumber, timeout, maxNotifications));\n+                } catch (CompletionException ce) {\n+                    Throwable thr = ce.getCause();\n+                    if (thr instanceof SecurityException se) {\n+                        throw se;\n+                    } else if (thr instanceof IOException ioe) {\n+                        throw ioe;\n+                    } else {\n+                        throw new RuntimeException(thr);\n+                    }\n+                }\n@@ -1314,19 +1267,0 @@\n-    private class PrivilegedOperation\n-            implements PrivilegedExceptionAction<Object> {\n-\n-        public PrivilegedOperation(int operation, Object[] params) {\n-            this.operation = operation;\n-            this.params = params;\n-        }\n-\n-        public Object run() throws Exception {\n-            return doOperation(operation, params);\n-        }\n-\n-        private int operation;\n-        private Object[] params;\n-    }\n-\n-    \/\/------------------------------------------------------------------------\n-    \/\/ private classes\n-    \/\/------------------------------------------------------------------------\n@@ -1355,19 +1289,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private ClassLoader getClassLoader(final ObjectName name)\n-        throws InstanceNotFoundException {\n-        try {\n-            return\n-                AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<ClassLoader>() {\n-                        public ClassLoader run() throws InstanceNotFoundException {\n-                            return mbeanServer.getClassLoader(name);\n-                        }\n-                    },\n-                    withPermissions(new MBeanPermission(\"*\", \"getClassLoader\"))\n-            );\n-        } catch (PrivilegedActionException pe) {\n-            throw (InstanceNotFoundException) extractException(pe);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n@@ -1376,13 +1291,2 @@\n-        try {\n-            return (ClassLoader)\n-                AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Object>() {\n-                        public Object run() throws InstanceNotFoundException {\n-                            return mbeanServer.getClassLoaderFor(name);\n-                        }\n-                    },\n-                    withPermissions(new MBeanPermission(\"*\", \"getClassLoaderFor\"))\n-            );\n-        } catch (PrivilegedActionException pe) {\n-            throw (InstanceNotFoundException) extractException(pe);\n-        }\n+\n+        return mbeanServer.getClassLoaderFor(name);\n@@ -1392,1 +1296,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1405,1 +1308,0 @@\n-            PrivilegedOperation op = new PrivilegedOperation(operation, params);\n@@ -1408,1 +1310,1 @@\n-                    return op.run();\n+                    return doOperation(operation, params);\n@@ -1417,1 +1319,14 @@\n-                return Subject.doAs(subject, op);\n+                try {\n+                    return Subject.callAs(subject, () -> doOperation(operation, params));\n+                } catch (CompletionException ce) {\n+                    Throwable thr = ce.getCause();\n+                    if (thr instanceof SecurityException se) {\n+                        throw se;\n+                    } else if (thr instanceof IOException ioe) {\n+                        throw ioe;\n+                    } else if (thr instanceof Exception e1) {\n+                        throw new PrivilegedActionException(e1);\n+                    } else {\n+                        throw new RuntimeException(thr);\n+                    }\n+                }\n@@ -1548,14 +1463,5 @@\n-    private static class SetCcl implements PrivilegedExceptionAction<ClassLoader> {\n-        private final ClassLoader classLoader;\n-\n-        SetCcl(ClassLoader classLoader) {\n-            this.classLoader = classLoader;\n-        }\n-\n-        public ClassLoader run() {\n-            Thread currentThread = Thread.currentThread();\n-            ClassLoader old = currentThread.getContextClassLoader();\n-            if (classLoader != old) {\n-                currentThread.setContextClassLoader(classLoader);\n-            }\n-            return old;\n+    private static ClassLoader setCcl(ClassLoader classLoader) {\n+        Thread currentThread = Thread.currentThread();\n+        ClassLoader old = currentThread.getContextClassLoader();\n+        if (classLoader != old) {\n+            currentThread.setContextClassLoader(classLoader);\n@@ -1563,0 +1469,1 @@\n+        return old;\n@@ -1565,1 +1472,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1581,1 +1487,1 @@\n-            final ClassLoader old = AccessController.doPrivileged(new SetCcl(cl));\n+            ClassLoader old = setCcl(cl);\n@@ -1584,1 +1490,10 @@\n-                    return Subject.doAs(subject, (PrivilegedExceptionAction<T>) () -> wrappedClass.cast(mo.get()));\n+                    try {\n+                        return Subject.callAs(subject, () -> wrappedClass.cast(mo.get()));\n+                    } catch (CompletionException ce) {\n+                        Throwable thr = ce.getCause();\n+                        if (thr instanceof Exception e) {\n+                            throw e;\n+                        } else {\n+                            throw new RuntimeException(thr);\n+                        }\n+                    }\n@@ -1589,1 +1504,1 @@\n-                AccessController.doPrivileged(new SetCcl(old));\n+                setCcl(old);\n@@ -1591,2 +1506,1 @@\n-        } catch (PrivilegedActionException pe) {\n-            Exception e = extractException(pe);\n+        } catch (Exception e) {\n@@ -1596,3 +1510,0 @@\n-            if (e instanceof ClassNotFoundException) {\n-                throw new UnmarshalException(e.toString(), e);\n-            }\n@@ -1601,4 +1512,1 @@\n-        }catch (ClassNotFoundException ex) {\n-            logger.warning(\"unwrap\", \"Failed to unmarshall object: \" + ex);\n-            logger.debug(\"unwrap\", ex);\n-            throw new UnmarshalException(ex.toString(), ex);\n+            throw new UnmarshalException(e.toString(), e);\n@@ -1606,1 +1514,0 @@\n-        return null;\n@@ -1619,9 +1526,2 @@\n-            @SuppressWarnings(\"removal\")\n-            ClassLoader orderCL = AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<ClassLoader>() {\n-                    public ClassLoader run() throws Exception {\n-                        return new CombinedClassLoader(Thread.currentThread().getContextClassLoader(),\n-                                new OrderClassLoaders(cl1, cl2));\n-                    }\n-                }\n-            );\n+            ClassLoader orderCL = new CombinedClassLoader(Thread.currentThread().getContextClassLoader(),\n+                                                          new OrderClassLoaders(cl1, cl2));\n@@ -1629,2 +1529,1 @@\n-        } catch (PrivilegedActionException pe) {\n-            Exception e = extractException(pe);\n+        } catch (Exception e) {\n@@ -1818,1 +1717,0 @@\n-            ReflectUtil.checkPackageAccess(name);\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectionImpl.java","additions":60,"deletions":162,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedExceptionAction;\n@@ -105,1 +102,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -1859,1 +1855,0 @@\n-            ReflectUtil.checkPackageAccess(name);\n@@ -1967,45 +1962,1 @@\n-        PrivilegedExceptionAction<Constructor<?>> action =\n-                new PrivilegedExceptionAction<Constructor<?>>() {\n-            public Constructor<?> run() throws Exception {\n-                Class<RMIConnector> thisClass = RMIConnector.class;\n-                ClassLoader thisLoader = thisClass.getClassLoader();\n-                ProtectionDomain thisProtectionDomain =\n-                        thisClass.getProtectionDomain();\n-\n-                String proxyRefCName = ProxyRef.class.getName();\n-                ClassLoader cl =\n-                        new NoCallStackClassLoader(pRefClassName,\n-                        pRefByteCode,\n-                        new String[] { proxyRefCName },\n-                        thisLoader,\n-                        thisProtectionDomain);\n-\n-                Module jmxModule = ProxyRef.class.getModule();\n-                Module rmiModule = RemoteRef.class.getModule();\n-\n-                String pkg = packageOf(pRefClassName);\n-                assert pkg != null && pkg.length() > 0 &&\n-                        !pkg.equals(packageOf(proxyRefCName));\n-\n-                ModuleDescriptor descriptor =\n-                    ModuleDescriptor.newModule(\"jdk.remoteref\", Set.of(SYNTHETIC))\n-                        .packages(Set.of(pkg))\n-                        .build();\n-                Module m = Modules.defineModule(cl, descriptor, null);\n-\n-                \/\/ jdk.remoteref needs to read to java.base and jmxModule\n-                Modules.addReads(m, Object.class.getModule());\n-                Modules.addReads(m, jmxModule);\n-                Modules.addReads(m, rmiModule);\n-\n-                \/\/ jdk.remoteref needs access to ProxyRef class\n-                Modules.addExports(jmxModule, packageOf(proxyRefCName), m);\n-\n-                \/\/ java.management needs to instantiate the fabricated RemoteRef class\n-                Modules.addReads(jmxModule, m);\n-                Modules.addExports(m, pkg, jmxModule);\n-\n-                Class<?> c = cl.loadClass(pRefClassName);\n-                return c.getConstructor(RemoteRef.class);\n-            }\n-        };\n+\n@@ -2029,3 +1980,42 @@\n-            @SuppressWarnings(\"removal\")\n-            Constructor<?> tmp = (Constructor<?>) AccessController.doPrivileged(action);\n-            constr = tmp;\n+\n+            Class<RMIConnector> thisClass = RMIConnector.class;\n+            ClassLoader thisLoader = thisClass.getClassLoader();\n+            ProtectionDomain thisProtectionDomain =\n+                    thisClass.getProtectionDomain();\n+\n+            String proxyRefCName = ProxyRef.class.getName();\n+            ClassLoader cl =\n+                    new NoCallStackClassLoader(pRefClassName,\n+                    pRefByteCode,\n+                    new String[] { proxyRefCName },\n+                    thisLoader,\n+                    thisProtectionDomain);\n+\n+            Module jmxModule = ProxyRef.class.getModule();\n+            Module rmiModule = RemoteRef.class.getModule();\n+\n+            String pkg = packageOf(pRefClassName);\n+            assert pkg != null && pkg.length() > 0 &&\n+                    !pkg.equals(packageOf(proxyRefCName));\n+\n+            ModuleDescriptor descriptor =\n+                ModuleDescriptor.newModule(\"jdk.remoteref\", Set.of(SYNTHETIC))\n+                    .packages(Set.of(pkg))\n+                    .build();\n+            Module m = Modules.defineModule(cl, descriptor, null);\n+\n+            \/\/ jdk.remoteref needs to read to java.base and jmxModule\n+            Modules.addReads(m, Object.class.getModule());\n+            Modules.addReads(m, jmxModule);\n+            Modules.addReads(m, rmiModule);\n+\n+            \/\/ jdk.remoteref needs access to ProxyRef class\n+            Modules.addExports(jmxModule, packageOf(proxyRefCName), m);\n+\n+            \/\/ java.management needs to instantiate the fabricated RemoteRef class\n+            Modules.addReads(jmxModule, m);\n+            Modules.addExports(m, pkg, jmxModule);\n+\n+            Class<?> c = cl.loadClass(pRefClassName);\n+\n+            constr = c.getConstructor(RemoteRef.class);\n@@ -2175,1 +2165,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2179,10 +2168,6 @@\n-        if (defaultClassLoader != null)\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    if (t.getContextClassLoader() != defaultClassLoader) {\n-                        t.setContextClassLoader(defaultClassLoader);\n-                    }\n-                    return null;\n-                }\n-            });\n-            return old;\n+        if (defaultClassLoader != null) {\n+            if (t.getContextClassLoader() != defaultClassLoader) {\n+                t.setContextClassLoader(defaultClassLoader);\n+            }\n+        }\n+        return old;\n@@ -2191,1 +2176,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2193,9 +2177,4 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                Thread t = Thread.currentThread();\n-                if (t.getContextClassLoader() != old) {\n-                    t.setContextClassLoader(old);\n-                }\n-                return null;\n-            }\n-        });\n+        Thread t = Thread.currentThread();\n+        if (t.getContextClassLoader() != old) {\n+            t.setContextClassLoader(old);\n+        }\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnector.java","additions":53,"deletions":74,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -122,1 +121,0 @@\n-            allowedTypes.forEach(ReflectUtil::checkPackageAccess);\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIJRMPServerImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permission;\n-import java.security.PrivilegedAction;\n@@ -67,1 +63,0 @@\n-import javax.management.MBeanPermission;\n@@ -73,1 +68,0 @@\n-import javax.management.MBeanTrustPermission;\n@@ -251,3 +245,0 @@\n-        checkMBeanPermission(className, null, null, \"instantiate\");\n-        checkMBeanPermission(className, null, name, \"registerMBean\");\n-\n@@ -284,2 +275,0 @@\n-        checkMBeanTrustPermission(theClass);\n-\n@@ -312,3 +301,0 @@\n-        checkMBeanPermission(infoClassName, null, name, \"registerMBean\");\n-        checkMBeanTrustPermission(theClass);\n-\n@@ -420,2 +406,0 @@\n-        checkMBeanPermission(instance, null, name, \"unregisterMBean\");\n-\n@@ -454,2 +438,0 @@\n-        checkMBeanPermission(instance, null, name, \"getObjectInstance\");\n-\n@@ -462,33 +444,1 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ Check if the caller has the right to invoke 'queryMBeans'\n-            \/\/\n-            checkMBeanPermission((String) null, null, null, \"queryMBeans\");\n-\n-            \/\/ Perform query without \"query\".\n-            \/\/\n-            Set<ObjectInstance> list = queryMBeansImpl(name, null);\n-\n-            \/\/ Check if the caller has the right to invoke 'queryMBeans'\n-            \/\/ on each specific classname\/objectname in the list.\n-            \/\/\n-            Set<ObjectInstance> allowedList = new HashSet<>(list.size());\n-            for (ObjectInstance oi : list) {\n-                try {\n-                    checkMBeanPermission(oi.getClassName(), null,\n-                                         oi.getObjectName(), \"queryMBeans\");\n-                    allowedList.add(oi);\n-                } catch (SecurityException e) {\n-                    \/\/ OK: Do not add this ObjectInstance to the list\n-                }\n-            }\n-\n-            \/\/ Apply query to allowed MBeans only.\n-            \/\/\n-            return filterListOfObjectInstances(allowedList, query);\n-        } else {\n-            \/\/ Perform query.\n-            \/\/\n-            return queryMBeansImpl(name, query);\n-        }\n+        return queryMBeansImpl(name, query);\n@@ -507,40 +457,1 @@\n-        Set<ObjectName> queryList;\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ Check if the caller has the right to invoke 'queryNames'\n-            \/\/\n-            checkMBeanPermission((String) null, null, null, \"queryNames\");\n-\n-            \/\/ Perform query without \"query\".\n-            \/\/\n-            Set<ObjectInstance> list = queryMBeansImpl(name, null);\n-\n-            \/\/ Check if the caller has the right to invoke 'queryNames'\n-            \/\/ on each specific classname\/objectname in the list.\n-            \/\/\n-            Set<ObjectInstance> allowedList = new HashSet<>(list.size());\n-            for (ObjectInstance oi : list) {\n-                try {\n-                    checkMBeanPermission(oi.getClassName(), null,\n-                                         oi.getObjectName(), \"queryNames\");\n-                    allowedList.add(oi);\n-                } catch (SecurityException e) {\n-                    \/\/ OK: Do not add this ObjectInstance to the list\n-                }\n-            }\n-\n-            \/\/ Apply query to allowed MBeans only.\n-            \/\/\n-            Set<ObjectInstance> queryObjectInstanceList =\n-                filterListOfObjectInstances(allowedList, query);\n-            queryList = new HashSet<>(queryObjectInstanceList.size());\n-            for (ObjectInstance oi : queryObjectInstanceList) {\n-                queryList.add(oi.getObjectName());\n-            }\n-        } else {\n-            \/\/ Perform query.\n-            \/\/\n-            queryList = queryNamesImpl(name, query);\n-        }\n-        return queryList;\n+        return queryNamesImpl(name, query);\n@@ -565,4 +476,0 @@\n-\n-        \/* No Permission check *\/\n-        \/\/ isRegistered is always unchecked as per JMX spec.\n-\n@@ -573,31 +480,1 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ Check if the caller has the right to invoke 'getDomains'\n-            \/\/\n-            checkMBeanPermission((String) null, null, null, \"getDomains\");\n-\n-            \/\/ Return domains\n-            \/\/\n-            String[] domains = repository.getDomains();\n-\n-            \/\/ Check if the caller has the right to invoke 'getDomains'\n-            \/\/ on each specific domain in the list.\n-            \/\/\n-            List<String> result = new ArrayList<>(domains.length);\n-            for (int i = 0; i < domains.length; i++) {\n-                try {\n-                    ObjectName dom = Util.newObjectName(domains[i] + \":x=x\");\n-                    checkMBeanPermission((String) null, null, dom, \"getDomains\");\n-                    result.add(domains[i]);\n-                } catch (SecurityException e) {\n-                    \/\/ OK: Do not add this domain to the list\n-                }\n-            }\n-\n-            \/\/ Make an array from result.\n-            \/\/\n-            return result.toArray(new String[result.size()]);\n-        } else {\n-            return repository.getDomains();\n-        }\n+        return repository.getDomains();\n@@ -633,1 +510,0 @@\n-        checkMBeanPermission(instance, attribute, name, \"getAttribute\");\n@@ -667,27 +543,1 @@\n-        final String[] allowedAttributes;\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm == null)\n-            allowedAttributes = attributes;\n-        else {\n-            final String classname = getClassName(instance);\n-\n-            \/\/ Check if the caller has the right to invoke 'getAttribute'\n-            \/\/\n-            checkMBeanPermission(classname, null, name, \"getAttribute\");\n-\n-            \/\/ Check if the caller has the right to invoke 'getAttribute'\n-            \/\/ on each specific attribute\n-            \/\/\n-            List<String> allowedList = new ArrayList<>(attributes.length);\n-            for (String attr : attributes) {\n-                try {\n-                    checkMBeanPermission(classname, attr, name, \"getAttribute\");\n-                    allowedList.add(attr);\n-                } catch (SecurityException e) {\n-                    \/\/ OK: Do not add this attribute to the list\n-                }\n-            }\n-            allowedAttributes =\n-                    allowedList.toArray(new String[allowedList.size()]);\n-        }\n+        final String[] allowedAttributes = attributes;\n@@ -728,1 +578,0 @@\n-        checkMBeanPermission(instance, attribute.getName(), name, \"setAttribute\");\n@@ -759,11 +608,1 @@\n-        final AttributeList allowedAttributes;\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm == null)\n-            allowedAttributes = attributes;\n-        else {\n-            String classname = getClassName(instance);\n-\n-            \/\/ Check if the caller has the right to invoke 'setAttribute'\n-            \/\/\n-            checkMBeanPermission(classname, null, name, \"setAttribute\");\n+        final AttributeList allowedAttributes = attributes;\n@@ -771,14 +610,0 @@\n-            \/\/ Check if the caller has the right to invoke 'setAttribute'\n-            \/\/ on each specific attribute\n-            \/\/\n-            allowedAttributes = new AttributeList(attributes.size());\n-            for (Attribute attribute : attributes.asList()) {\n-                try {\n-                    checkMBeanPermission(classname, attribute.getName(),\n-                                         name, \"setAttribute\");\n-                    allowedAttributes.add(attribute);\n-                } catch (SecurityException e) {\n-                    \/\/ OK: Do not add this attribute to the list\n-                }\n-            }\n-        }\n@@ -801,1 +626,0 @@\n-        checkMBeanPermission(instance, operationName, name, \"invoke\");\n@@ -925,2 +749,0 @@\n-            checkMBeanPermission(classname, null, logicalName, \"registerMBean\");\n-\n@@ -1162,1 +984,0 @@\n-        checkMBeanPermission(instance, null, name, \"addNotificationListener\");\n@@ -1291,1 +1112,0 @@\n-        checkMBeanPermission(instance, null, name, \"removeNotificationListener\");\n@@ -1359,2 +1179,0 @@\n-        checkMBeanPermission(mbi.getClassName(), null, name, \"getMBeanInfo\");\n-\n@@ -1368,1 +1186,0 @@\n-        checkMBeanPermission(instance, null, name, \"isInstanceOf\");\n@@ -1410,1 +1227,0 @@\n-        checkMBeanPermission(instance, null, mbeanName, \"getClassLoaderFor\");\n@@ -1425,1 +1241,0 @@\n-            checkMBeanPermission((String) null, null, null, \"getClassLoader\");\n@@ -1430,1 +1245,0 @@\n-        checkMBeanPermission(instance, null, loaderName, \"getClassLoader\");\n@@ -1568,42 +1382,0 @@\n-    \/**\n-     * Applies the specified queries to the set of ObjectInstances.\n-     *\/\n-    private Set<ObjectInstance>\n-            filterListOfObjectInstances(Set<ObjectInstance> list,\n-                                        QueryExp query) {\n-        \/\/ Null query.\n-        \/\/\n-        if (query == null) {\n-            return list;\n-        } else {\n-            Set<ObjectInstance> result = new HashSet<>();\n-            \/\/ Access the filter.\n-            \/\/\n-            for (ObjectInstance oi : list) {\n-                boolean res = false;\n-                MBeanServer oldServer = QueryEval.getMBeanServer();\n-                query.setMBeanServer(server);\n-                try {\n-                    res = query.apply(oi.getObjectName());\n-                } catch (Exception e) {\n-                    res = false;\n-                } finally {\n-                    \/*\n-                     * query.setMBeanServer is probably\n-                     * QueryEval.setMBeanServer so put back the old\n-                     * value.  Since that method uses a ThreadLocal\n-                     * variable, this code is only needed for the\n-                     * unusual case where the user creates a custom\n-                     * QueryExp that calls a nested query on another\n-                     * MBeanServer.\n-                     *\/\n-                    query.setMBeanServer(oldServer);\n-                }\n-                if (res) {\n-                    result.add(oi);\n-                }\n-            }\n-            return result;\n-        }\n-    }\n-\n@@ -1752,50 +1524,0 @@\n-    private static void checkMBeanPermission(DynamicMBean mbean,\n-                                             String member,\n-                                             ObjectName objectName,\n-                                             String actions) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMBeanPermission(safeGetClassName(mbean),\n-                                 member,\n-                                 objectName,\n-                                 actions);\n-        }\n-    }\n-\n-    private static void checkMBeanPermission(String classname,\n-                                             String member,\n-                                             ObjectName objectName,\n-                                             String actions) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            Permission perm = new MBeanPermission(classname,\n-                                                  member,\n-                                                  objectName,\n-                                                  actions);\n-            sm.checkPermission(perm);\n-        }\n-    }\n-\n-    private static void checkMBeanTrustPermission(final Class<?> theClass)\n-        throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            Permission perm = new MBeanTrustPermission(\"register\");\n-            PrivilegedAction<ProtectionDomain> act =\n-                new PrivilegedAction<>() {\n-                    public ProtectionDomain run() {\n-                        return theClass.getProtectionDomain();\n-                    }\n-                };\n-            @SuppressWarnings(\"removal\")\n-            ProtectionDomain pd = AccessController.doPrivileged(act);\n-            @SuppressWarnings(\"removal\")\n-            AccessControlContext acc =\n-                new AccessControlContext(new ProtectionDomain[] { pd });\n-            sm.checkPermission(perm, acc);\n-        }\n-    }\n-\n@@ -2009,1 +1731,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2011,6 +1732,1 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public ModifiableClassLoaderRepository run() {\n-                return instantiator != null ? instantiator.getClassLoaderRepository() : null;\n-            }\n-        });\n+        return instantiator != null ? instantiator.getClassLoaderRepository() : null;\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/interceptor\/DefaultMBeanServerInterceptor.java","additions":7,"deletions":291,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.Permission;\n@@ -37,1 +36,0 @@\n-import javax.management.MBeanPermission;\n@@ -41,1 +39,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -195,1 +192,0 @@\n-        ReflectUtil.checkPackageAccess(className);\n@@ -283,14 +279,1 @@\n-        ClassLoader instance = loadersWithNames.get(name);\n-        if (instance != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                Permission perm =\n-                        new MBeanPermission(instance.getClass().getName(),\n-                        null,\n-                        name,\n-                        \"getClassLoader\");\n-                sm.checkPermission(perm);\n-            }\n-        }\n-        return instance;\n+        return loadersWithNames.get(name);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/ClassLoaderRepositorySupport.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -304,1 +303,0 @@\n-        ReflectUtil.checkPackageAccess(enumClass);\n@@ -429,1 +427,0 @@\n-        ReflectUtil.checkPackageAccess(c);\n@@ -1122,1 +1119,0 @@\n-                ReflectUtil.checkPackageAccess(targetClass);\n@@ -1378,1 +1374,0 @@\n-                ReflectUtil.checkPackageAccess(max.constructor.getDeclaringClass());\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/DefaultMXBeanMappingFactory.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.jmx.mbeanserver;\n-\n-import java.security.PrivilegedAction;\n-\n-\/**\n- * Utility class to be used by the method {@code AccessControler.doPrivileged}\n- * to get a system property.\n- *\n- * @since 1.5\n- *\/\n-public class GetPropertyAction implements PrivilegedAction<String> {\n-    private final String key;\n-\n-    public GetPropertyAction(String key) {\n-        this.key = key;\n-    }\n-\n-    public String run() {\n-        return System.getProperty(key);\n-    }\n-}\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/GetPropertyAction.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-import java.security.AccessController;\n@@ -60,1 +59,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -69,6 +67,1 @@\n-    public static final boolean ALLOW_NONPUBLIC_MBEAN;\n-    static {\n-        @SuppressWarnings(\"removal\")\n-        String val = AccessController.doPrivileged(new GetPropertyAction(\"jdk.jmx.mbeans.allowNonPublic\"));\n-        ALLOW_NONPUBLIC_MBEAN = Boolean.parseBoolean(val);\n-    }\n+    public static final boolean ALLOW_NONPUBLIC_MBEAN = Boolean.parseBoolean(System.getProperty(\"jdk.jmx.mbeans.allowNonPublic\"));\n@@ -279,1 +272,0 @@\n-        ReflectUtil.checkPackageAccess(mbeanInterface);\n@@ -404,1 +396,0 @@\n-            boolean packageAccess = false;\n@@ -411,5 +402,0 @@\n-                        \/\/ Avoid checking access more than once per annotation\n-                        if (!packageAccess) {\n-                            ReflectUtil.checkPackageAccess(c);\n-                            packageAccess = true;\n-                        }\n@@ -563,1 +549,0 @@\n-                    ReflectUtil.checkPackageAccess(readMethod.getDeclaringClass());\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/Introspector.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,4 +33,0 @@\n-import java.security.AccessController;\n-import java.security.Permission;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedExceptionAction;\n@@ -51,1 +47,0 @@\n-import javax.management.MBeanPermission;\n@@ -55,1 +50,0 @@\n-import javax.management.MBeanServerPermission;\n@@ -235,7 +229,1 @@\n-            SecureClassLoaderRepository(AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public ClassLoaderRepository run() {\n-                    return fInstantiator.getClassLoaderRepository();\n-                }\n-            })\n-        );\n+            SecureClassLoaderRepository(fInstantiator.getClassLoaderRepository());\n@@ -950,3 +938,0 @@\n-        \/* Permission check *\/\n-        checkMBeanPermission(className, null, null, \"instantiate\");\n-\n@@ -987,3 +972,0 @@\n-        \/* Permission check *\/\n-        checkMBeanPermission(className, null, null, \"instantiate\");\n-\n@@ -1025,3 +1007,0 @@\n-        \/* Permission check *\/\n-        checkMBeanPermission(className, null, null, \"instantiate\");\n-\n@@ -1068,3 +1047,0 @@\n-        \/* Permission check *\/\n-        checkMBeanPermission(className, null, null, \"instantiate\");\n-\n@@ -1115,2 +1091,0 @@\n-        \/* Permission check *\/\n-        \/\/ This call requires MBeanPermission 'getClassLoaderFor'\n@@ -1148,2 +1122,0 @@\n-        \/* Permission check *\/\n-        \/\/ This call requires MBeanPermission 'getClassLoaderRepository'\n@@ -1200,10 +1172,0 @@\n-        \/* Permission check *\/\n-        \/\/ Make this call just to force the 'getClassLoader'\n-        \/\/ permission check\n-        try {\n-            getClassLoader(loaderName);\n-        } catch (SecurityException e) {\n-            throw e;\n-        } catch (Exception e) {\n-        }\n-\n@@ -1225,8 +1187,1 @@\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<>() {\n-                public Object run() throws Exception {\n-                    mbsInterceptor.registerMBean(\n-                            mBeanServerDelegateObject,\n-                            MBeanServerDelegate.DELEGATE_NAME);\n-                    return null;\n-                }\n-            });\n+            mbsInterceptor.registerMBean(mBeanServerDelegateObject, MBeanServerDelegate.DELEGATE_NAME);\n@@ -1254,7 +1209,1 @@\n-        final ModifiableClassLoaderRepository loaders = AccessController.doPrivileged(new PrivilegedAction<>() {\n-\n-            @Override\n-            public ModifiableClassLoaderRepository run() {\n-                return instantiator.getClassLoaderRepository();\n-            }\n-        });\n+        final ModifiableClassLoaderRepository loaders = instantiator.getClassLoaderRepository();\n@@ -1269,0 +1218,1 @@\n+             *\/\n@@ -1270,10 +1220,0 @@\n-               If this class (JmxMBeanServer) was not loaded by the\n-               system class loader or a parent of it, then the caller\n-               must have RuntimePermission(\"getClassLoader\") for the\n-               getSystemClassLoader() call to succeed.  If the caller\n-               does not have that permission, any call to\n-               Class.getClassLoader() will fail.  Since there are lots\n-               of those in JMX, we better throw the exception now.\n-\n-               This permission question is irrelevant when JMX is part\n-               of J2SE (as of 1.5). *\/\n@@ -1344,2 +1284,0 @@\n-        \/* Permission check *\/\n-        checkMBeanPermission(null, null, null, \"getClassLoaderRepository\");\n@@ -1428,2 +1366,0 @@\n-        checkNewMBeanServerPermission();\n-\n@@ -1496,28 +1432,0 @@\n-\n-    \/\/ SECURITY CHECKS\n-    \/\/----------------\n-\n-    private static void checkMBeanPermission(String classname,\n-                                             String member,\n-                                             ObjectName objectName,\n-                                             String actions)\n-        throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            Permission perm = new MBeanPermission(classname,\n-                                                  member,\n-                                                  objectName,\n-                                                  actions);\n-            sm.checkPermission(perm);\n-        }\n-    }\n-\n-    private static void checkNewMBeanServerPermission() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            Permission perm = new MBeanServerPermission(\"newMBeanServer\");\n-            sm.checkPermission(perm);\n-        }\n-    }\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/JmxMBeanServer.java","additions":5,"deletions":97,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permission;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n@@ -47,1 +42,0 @@\n-import javax.management.MBeanPermission;\n@@ -55,2 +49,0 @@\n-import sun.reflect.misc.ConstructorUtil;\n-import sun.reflect.misc.ReflectUtil;\n@@ -98,1 +90,0 @@\n-        ReflectUtil.checkPackageAccess(className);\n@@ -172,1 +163,0 @@\n-                ReflectUtil.checkPackageAccess(signature[i]);\n@@ -213,2 +203,0 @@\n-        checkMBeanPermission(theClass, null, null, \"instantiate\");\n-\n@@ -226,1 +214,0 @@\n-            ReflectUtil.checkPackageAccess(theClass);\n@@ -265,2 +252,0 @@\n-        checkMBeanPermission(theClass, null, null, \"instantiate\");\n-\n@@ -296,1 +281,0 @@\n-            ReflectUtil.checkPackageAccess(theClass);\n@@ -411,1 +395,0 @@\n-        ReflectUtil.checkPackageAccess(className);\n@@ -614,1 +597,0 @@\n-        checkMBeanPermission((String)null, null, null, \"getClassLoaderRepository\");\n@@ -630,1 +612,0 @@\n-        ReflectUtil.checkPackageAccess(className);\n@@ -681,1 +662,0 @@\n-                ReflectUtil.checkPackageAccess(signature[i]);\n@@ -703,1 +683,1 @@\n-            return ConstructorUtil.getConstructor(c, params);\n+            return c.getConstructor(params);\n@@ -718,25 +698,0 @@\n-    private static void checkMBeanPermission(Class<?> clazz,\n-                                             String member,\n-                                             ObjectName objectName,\n-                                             String actions) {\n-        if (clazz != null) {\n-            checkMBeanPermission(clazz.getName(), member, objectName, actions);\n-        }\n-    }\n-\n-    private static void checkMBeanPermission(String classname,\n-                                             String member,\n-                                             ObjectName objectName,\n-                                             String actions)\n-        throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            Permission perm = new MBeanPermission(classname,\n-                                                  member,\n-                                                  objectName,\n-                                                  actions);\n-            sm.checkPermission(perm);\n-        }\n-    }\n-\n@@ -755,0 +710,2 @@\n+        } else {\n+            return clr.getClassLoader(name);\n@@ -756,14 +713,0 @@\n-        \/\/ Restrict to getClassLoader permission only\n-        Permissions permissions = new Permissions();\n-        permissions.add(new MBeanPermission(\"*\", null, name, \"getClassLoader\"));\n-        ProtectionDomain protectionDomain = new ProtectionDomain(null, permissions);\n-        ProtectionDomain[] domains = {protectionDomain};\n-        @SuppressWarnings(\"removal\")\n-        AccessControlContext ctx = new AccessControlContext(domains);\n-        @SuppressWarnings(\"removal\")\n-        ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<>() {\n-            public ClassLoader run() {\n-                return clr.getClassLoader(name);\n-            }\n-        }, ctx);\n-        return loader;\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/MBeanInstantiator.java","additions":4,"deletions":61,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -179,1 +178,0 @@\n-        ReflectUtil.checkPackageAccess(mbeanType);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/MBeanIntrospector.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -135,1 +134,0 @@\n-        ReflectUtil.checkPackageAccess(mbeanInterfaceType);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/MBeanSupport.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.security.AccessController;\n@@ -148,3 +147,1 @@\n-            @SuppressWarnings(\"removal\")\n-            String multiname = AccessController.doPrivileged(\n-                    new GetPropertyAction(\"jmx.mxbean.multiname\"));\n+            String multiname = System.getProperty(\"jmx.mxbean.multiname\");\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/MXBeanLookup.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -64,1 +63,0 @@\n-            ReflectUtil.checkPackageAccess(name);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/ObjectInputStreamWithLoader.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.AccessController;\n@@ -178,9 +177,1 @@\n-        GetPropertyAction act = new GetPropertyAction(\"jmx.invoke.getters\");\n-        String invokeGettersS;\n-        try {\n-            invokeGettersS = AccessController.doPrivileged(act);\n-        } catch (Exception e) {\n-            \/\/ We don't expect an exception here but if we get one then\n-            \/\/ we'll simply assume that the property is not set.\n-            invokeGettersS = null;\n-        }\n+        String invokeGettersS = System.getProperty(\"jmx.invoke.getters\");\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/PerInterface.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -399,14 +395,0 @@\n-                    \/\/ Skip security check if NotificationBufferFilter is not overloaded\n-                    if (!(filter instanceof ServerNotifForwarder.NotifForwarderBufferFilter)) {\n-                        try {\n-                            ServerNotifForwarder.checkMBeanPermission(this.mBeanServer,\n-                                                      candidate.getObjectName(),\"addNotificationListener\");\n-                        } catch (InstanceNotFoundException | SecurityException e) {\n-                            if (logger.debugOn()) {\n-                                logger.debug(\"fetchNotifications\", \"candidate: \" + candidate + \" skipped. exception \" + e);\n-                            }\n-                            ++nextSeq;\n-                            continue;\n-                        }\n-                    }\n-\n@@ -656,1 +638,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -662,13 +643,4 @@\n-        try {\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                public Void run() throws InstanceNotFoundException {\n-                    mBeanServer.addNotificationListener(name,\n-                                                        listener,\n-                                                        filter,\n-                                                        handback);\n-                    return null;\n-                }\n-            });\n-        } catch (Exception e) {\n-            throw extractException(e);\n-        }\n+        mBeanServer.addNotificationListener(name,\n+                                                listener,\n+                                                filter,\n+                                                handback);\n@@ -677,1 +649,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -681,10 +652,1 @@\n-        try {\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                public Void run() throws Exception {\n-                    mBeanServer.removeNotificationListener(name, listener);\n-                    return null;\n-                }\n-            });\n-        } catch (Exception e) {\n-            throw extractException(e);\n-        }\n+        mBeanServer.removeNotificationListener(name, listener);\n@@ -693,1 +655,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -696,6 +657,0 @@\n-        PrivilegedAction<Set<ObjectName>> act =\n-            new PrivilegedAction<>() {\n-                public Set<ObjectName> run() {\n-                    return mBeanServer.queryNames(name, query);\n-                }\n-            };\n@@ -703,1 +658,1 @@\n-            return AccessController.doPrivileged(act);\n+            return mBeanServer.queryNames(name, query);\n@@ -711,1 +666,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -715,6 +669,0 @@\n-        PrivilegedExceptionAction<Boolean> act =\n-            new PrivilegedExceptionAction<>() {\n-                public Boolean run() throws InstanceNotFoundException {\n-                    return mbs.isInstanceOf(name, className);\n-                }\n-            };\n@@ -722,1 +670,1 @@\n-            return AccessController.doPrivileged(act);\n+            return mbs.isInstanceOf(name, className);\n@@ -828,11 +776,0 @@\n-    \/**\n-     * Iterate until we extract the real exception\n-     * from a stack of PrivilegedActionExceptions.\n-     *\/\n-    private static Exception extractException(Exception e) {\n-        while (e instanceof PrivilegedActionException) {\n-            e = ((PrivilegedActionException)e).getException();\n-        }\n-        return e;\n-    }\n-\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ArrayNotificationBuffer.java","additions":8,"deletions":71,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -59,3 +56,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext acc;\n-\n@@ -142,1 +136,0 @@\n-        this.acc = AccessController.getContext();\n@@ -422,1 +415,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -424,32 +416,7 @@\n-            final AccessControlContext ctxt = ClientNotifForwarder.this.acc;\n-            \/\/ if ctxt is null, log a config message and throw a\n-            \/\/ SecurityException.\n-            if (ctxt == null) {\n-                logOnce(\"AccessControlContext must not be null.\",null);\n-                throw new SecurityException(\"AccessControlContext must not be null\");\n-            }\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    public ClassLoader run() {\n-                        try {\n-                            \/\/ get context class loader - may throw\n-                            \/\/ SecurityException - though unlikely.\n-                            final ClassLoader previous =\n-                                Thread.currentThread().getContextClassLoader();\n-\n-                            \/\/ if nothing needs to be done, break here...\n-                            if (loader == previous) return previous;\n-\n-                            \/\/ reset context class loader - may throw\n-                            \/\/ SecurityException\n-                            Thread.currentThread().setContextClassLoader(loader);\n-                            return previous;\n-                        } catch (SecurityException x) {\n-                            logOnce(\"Permission to set ContextClassLoader missing. \" +\n-                                    \"Notifications will not be dispatched. \" +\n-                                    \"Please check your Java policy configuration: \" +\n-                                    x, x);\n-                            throw x;\n-                        }\n-                    }\n-                }, ctxt);\n+            final ClassLoader previous = Thread.currentThread().getContextClassLoader();\n+\n+            \/\/ if nothing needs to be done, break here...\n+            if (loader == previous) return previous;\n+\n+            Thread.currentThread().setContextClassLoader(loader);\n+            return previous;\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ClientNotifForwarder.java","additions":7,"deletions":40,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -32,4 +32,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -88,3 +84,0 @@\n-        \/\/ Explicitly check MBeanPermission for addNotificationListener\n-        \/\/\n-        checkMBeanPermission(name, \"addNotificationListener\");\n@@ -95,17 +88,6 @@\n-        try {\n-            @SuppressWarnings(\"removal\")\n-            boolean instanceOf =\n-            AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<>() {\n-                        public Boolean run() throws InstanceNotFoundException {\n-                            return mbeanServer.isInstanceOf(name, broadcasterClass);\n-                        }\n-            });\n-            if (!instanceOf) {\n-                throw new IllegalArgumentException(\"The specified MBean [\" +\n-                    name + \"] is not a \" +\n-                    \"NotificationBroadcaster \" +\n-                    \"object.\");\n-            }\n-        } catch (PrivilegedActionException e) {\n-            throw (InstanceNotFoundException) extractException(e);\n+        boolean instanceOf = mbeanServer.isInstanceOf(name, broadcasterClass);\n+        if (!instanceOf) {\n+            throw new IllegalArgumentException(\"The specified MBean [\" +\n+                name + \"] is not a \" +\n+                \"NotificationBroadcaster \" +\n+                \"object.\");\n@@ -157,3 +139,0 @@\n-        \/\/ Explicitly check MBeanPermission for removeNotificationListener\n-        \/\/\n-        checkMBeanPermission(name, \"removeNotificationListener\");\n@@ -376,40 +355,0 @@\n-    \/**\n-     * Explicitly check the MBeanPermission for\n-     * the current access control context.\n-     *\/\n-    public final void checkMBeanPermission(\n-            final ObjectName name, final String actions)\n-            throws InstanceNotFoundException, SecurityException {\n-        checkMBeanPermission(mbeanServer,name,actions);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    static void checkMBeanPermission(\n-            final MBeanServer mbs, final ObjectName name, final String actions)\n-            throws InstanceNotFoundException, SecurityException {\n-\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            AccessControlContext acc = AccessController.getContext();\n-            ObjectInstance oi;\n-            try {\n-                oi = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<>() {\n-                        public ObjectInstance run()\n-                        throws InstanceNotFoundException {\n-                            return mbs.getObjectInstance(name);\n-                        }\n-                });\n-            } catch (PrivilegedActionException e) {\n-                throw (InstanceNotFoundException) extractException(e);\n-            }\n-            String classname = oi.getClassName();\n-            MBeanPermission perm = new MBeanPermission(\n-                classname,\n-                null,\n-                name,\n-                actions);\n-            sm.checkPermission(perm, acc);\n-        }\n-    }\n-\n@@ -422,3 +361,0 @@\n-            if (checkNotificationEmission) {\n-                checkMBeanPermission(name, \"addNotificationListener\");\n-            }\n@@ -447,11 +383,0 @@\n-    \/**\n-     * Iterate until we extract the real exception\n-     * from a stack of PrivilegedActionExceptions.\n-     *\/\n-    private static Exception extractException(Exception e) {\n-        while (e instanceof PrivilegedActionException) {\n-            e = ((PrivilegedActionException)e).getException();\n-        }\n-        return e;\n-    }\n-\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ServerNotifForwarder.java","additions":6,"deletions":81,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -30,1 +29,0 @@\n-import java.io.FilePermission;\n@@ -32,2 +30,0 @@\n-import java.security.AccessControlException;\n-import java.security.AccessController;\n@@ -112,1 +108,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -114,4 +109,2 @@\n-        AccessController.doPrivileged(new GetPropertyAction(\"java.home\")) +\n-        File.separatorChar + \"conf\" +\n-        File.separatorChar + \"management\" + File.separatorChar +\n-        PASSWORD_FILE_NAME;\n+        System.getProperty(\"java.home\") + File.separatorChar + \"conf\" + File.separatorChar\n+        + \"management\" + File.separatorChar + PASSWORD_FILE_NAME;\n@@ -155,1 +148,0 @@\n-    private boolean hasJavaHomePermission;\n@@ -199,8 +191,1 @@\n-            try {\n-                System.getProperty(\"java.home\");\n-                hasJavaHomePermission = true;\n-                passwordFileDisplayName = passwordFile;\n-            } catch (SecurityException e) {\n-                hasJavaHomePermission = false;\n-                passwordFileDisplayName = PASSWORD_FILE_NAME;\n-            }\n+            passwordFileDisplayName = passwordFile;\n@@ -236,12 +221,0 @@\n-        } catch (SecurityException e) {\n-            if (userSuppliedPasswordFile || hasJavaHomePermission) {\n-                throw e;\n-            } else {\n-                final FilePermission fp\n-                        = new FilePermission(passwordFileDisplayName, \"read\");\n-                @SuppressWarnings(\"removal\")\n-                AccessControlException ace = new AccessControlException(\n-                        \"access denied \" + fp.toString());\n-                ace.initCause(e);\n-                throw ace;\n-            }\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/FileLoginModule.java","additions":3,"deletions":30,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -235,1 +235,0 @@\n-     * @throws SecurityException If read\/write file permissions are not granted\n@@ -238,7 +237,1 @@\n-            throws IOException, SecurityException {\n-\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkRead(passwordFile);\n-        }\n+            throws IOException {\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/HashedPasswordManager.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.security.AccessController;\n@@ -32,2 +31,0 @@\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -108,17 +105,1 @@\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sm = System.getSecurityManager();\n-                if (sm != null) {\n-                    sm.checkPermission(\n-                            new AuthPermission(\"createLoginContext.\" +\n-                                               LOGIN_CONFIG_NAME));\n-                }\n-\n-                final String pf = passwordFile;\n-                final String hashPass = hashPasswords;\n-                try {\n-                    @SuppressWarnings(\"removal\")\n-                    var tmp = AccessController.doPrivileged(\n-                        new PrivilegedExceptionAction<LoginContext>() {\n-                            public LoginContext run() throws LoginException {\n-                                return new LoginContext(\n-                                                LOGIN_CONFIG_NAME,\n+                loginContext = new LoginContext(LOGIN_CONFIG_NAME,\n@@ -127,7 +108,1 @@\n-                                                new FileLoginConfig(pf, hashPass));\n-                            }\n-                        });\n-                    loginContext = tmp;\n-                } catch (PrivilegedActionException pae) {\n-                    throw (LoginException) pae.getException();\n-                }\n+                                                new FileLoginConfig(passwordFile, hashPasswords));\n@@ -193,8 +168,1 @@\n-            @SuppressWarnings(\"removal\")\n-            var dummy = AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                    public Void run() {\n-                        subject.setReadOnly();\n-                        return null;\n-                    }\n-                });\n-\n+            subject.setReadOnly();\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/JMXPluggableAuthenticator.java","additions":4,"deletions":36,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.jmx.remote.security;\n-\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.CodeSource;\n-import java.security.Permissions;\n-import java.security.ProtectionDomain;\n-import javax.security.auth.Subject;\n-import javax.security.auth.SubjectDomainCombiner;\n-\n-\/**\n- * <p>This class represents an extension to the {@link SubjectDomainCombiner}\n- * and is used to add a new {@link ProtectionDomain}, comprised of a null\n- * codesource\/signers and an empty permission set, to the access control\n- * context with which this combiner is combined.<\/p>\n- *\n- * <p>When the {@link #combine} method is called the {@link ProtectionDomain}\n- * is augmented with the permissions granted to the set of principals present\n- * in the supplied {@link Subject}.<\/p>\n- *\/\n-@SuppressWarnings(\"removal\")\n-public class JMXSubjectDomainCombiner extends SubjectDomainCombiner {\n-\n-    public JMXSubjectDomainCombiner(Subject s) {\n-        super(s);\n-    }\n-\n-    public ProtectionDomain[] combine(ProtectionDomain[] current,\n-                                      ProtectionDomain[] assigned) {\n-        \/\/ Add a new ProtectionDomain with the null codesource\/signers, and\n-        \/\/ the empty permission set, to the end of the array containing the\n-        \/\/ 'current' protections domains, i.e. the ones that will be augmented\n-        \/\/ with the permissions granted to the set of principals present in\n-        \/\/ the supplied subject.\n-        \/\/\n-        ProtectionDomain[] newCurrent;\n-        if (current == null || current.length == 0) {\n-            newCurrent = new ProtectionDomain[1];\n-            newCurrent[0] = pdNoPerms;\n-        } else {\n-            newCurrent = new ProtectionDomain[current.length + 1];\n-            for (int i = 0; i < current.length; i++) {\n-                newCurrent[i] = current[i];\n-            }\n-            newCurrent[current.length] = pdNoPerms;\n-        }\n-        return super.combine(newCurrent, assigned);\n-    }\n-\n-    \/**\n-     * A null CodeSource.\n-     *\/\n-    private static final CodeSource nullCodeSource =\n-        new CodeSource(null, (java.security.cert.Certificate[]) null);\n-\n-    \/**\n-     * A ProtectionDomain with a null CodeSource and an empty permission set.\n-     *\/\n-    private static final ProtectionDomain pdNoPerms =\n-        new ProtectionDomain(nullCodeSource, new Permissions(), null, null);\n-\n-    \/**\n-     * Get the current AccessControlContext combined with the supplied subject.\n-     *\/\n-    public static AccessControlContext getContext(Subject subject) {\n-        return new AccessControlContext(AccessController.getContext(),\n-                                        new JMXSubjectDomainCombiner(subject));\n-    }\n-\n-    \/**\n-     * Get the AccessControlContext of the domain combiner created with\n-     * the supplied subject, i.e. an AccessControlContext with the domain\n-     * combiner created with the supplied subject and where the caller's\n-     * context has been removed.\n-     *\/\n-    public static AccessControlContext\n-        getDomainCombinerContext(Subject subject) {\n-        return new AccessControlContext(\n-            new AccessControlContext(new ProtectionDomain[0]),\n-            new JMXSubjectDomainCombiner(subject));\n-    }\n-}\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/JMXSubjectDomainCombiner.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -30,1 +29,0 @@\n-import java.security.AccessController;\n@@ -77,7 +75,2 @@\n- * <p>If there is no SecurityManager, then the access controller will refuse\n- * to create an MBean that is a ClassLoader.  This prevents\n- * people from opening security holes unintentionally. Otherwise, it\n- * would not be obvious that granting write access grants the ability to\n- * download and execute arbitrary code in the target MBean server. Advanced\n- * users who do want an MBean which is a ClassLoader are presumably advanced enough\n- * to handle policy files and security managers.<\/p>\n+ * <p>The access controller will refuse to create an MBean that is a ClassLoader.\n+ * <\/p>\n@@ -177,9 +170,3 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            Object object = getMBeanServer().instantiate(className);\n-            checkClassLoader(object);\n-            return getMBeanServer().registerMBean(object, name);\n-        } else {\n-            return getMBeanServer().createMBean(className, name);\n-        }\n+        Object object = getMBeanServer().instantiate(className);\n+        checkClassLoader(object);\n+        return getMBeanServer().registerMBean(object, name);\n@@ -201,12 +188,5 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            Object object = getMBeanServer().instantiate(className,\n-                                                         params,\n-                                                         signature);\n-            checkClassLoader(object);\n-            return getMBeanServer().registerMBean(object, name);\n-        } else {\n-            return getMBeanServer().createMBean(className, name,\n-                                                params, signature);\n-        }\n+        Object object = getMBeanServer().instantiate(className,\n+                                                     params,\n+                                                     signature);\n+        checkClassLoader(object);\n+        return getMBeanServer().registerMBean(object, name);\n@@ -230,10 +210,4 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            Object object = getMBeanServer().instantiate(className,\n-                                                         loaderName);\n-            checkClassLoader(object);\n-            return getMBeanServer().registerMBean(object, name);\n-        } else {\n-            return getMBeanServer().createMBean(className, name, loaderName);\n-        }\n+        Object object = getMBeanServer().instantiate(className,\n+                                                     loaderName);\n+        checkClassLoader(object);\n+        return getMBeanServer().registerMBean(object, name);\n@@ -259,13 +233,6 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            Object object = getMBeanServer().instantiate(className,\n-                                                         loaderName,\n-                                                         params,\n-                                                         signature);\n-            checkClassLoader(object);\n-            return getMBeanServer().registerMBean(object, name);\n-        } else {\n-            return getMBeanServer().createMBean(className, name, loaderName,\n-                                                params, signature);\n-        }\n+        Object object = getMBeanServer().instantiate(className,\n+                                                     loaderName,\n+                                                     params,\n+                                                     signature);\n+        checkClassLoader(object);\n+        return getMBeanServer().registerMBean(object, name);\n@@ -617,2 +584,1 @@\n-                                        \"is forbidden unless a security \" +\n-                                        \"manager is installed.\");\n+                                        \"is forbidden.\");\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/MBeanServerAccessController.java","additions":21,"deletions":55,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n-import java.security.AccessController;\n-\n@@ -49,1 +47,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -275,2 +272,1 @@\n-            GetPropertyAction act = new GetPropertyAction(BUFFER_SIZE_PROPERTY);\n-            String s = AccessController.doPrivileged(act);\n+            String s = System.getProperty(BUFFER_SIZE_PROPERTY);\n@@ -280,2 +276,1 @@\n-                act = new GetPropertyAction(oldP);\n-                s = AccessController.doPrivileged(act);\n+                s = System.getProperty(oldP);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/util\/EnvHelp.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -38,1 +36,0 @@\n-        ReflectUtil.checkPackageAccess(name);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/util\/OrderClassLoaders.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.FilePermission;\n@@ -31,0 +30,1 @@\n+import javax.management.MBeanRegistrationException;\n@@ -34,1 +34,1 @@\n-import javax.management.MBeanServerPermission;\n+import javax.management.NotCompliantMBeanException;\n@@ -37,0 +37,1 @@\n+import javax.management.InstanceAlreadyExistsException;\n@@ -41,5 +42,0 @@\n-import java.security.AccessController;\n-import java.security.Permission;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -472,7 +468,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            Permission perm = new MBeanServerPermission(\"createMBeanServer\");\n-            sm.checkPermission(perm);\n-        }\n-\n@@ -597,4 +586,1 @@\n-        @SuppressWarnings(\"removal\")\n-        ClassLoader loader =\n-            AccessController.doPrivileged(\n-                (PrivilegedAction<ClassLoader>) () -> cls.getClassLoader());\n+        ClassLoader loader = cls.getClassLoader();\n@@ -885,1 +871,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -891,17 +876,11 @@\n-            AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {\n-                final DynamicMBean dmbean;\n-                if (pmo instanceof DynamicMBean) {\n-                    dmbean = DynamicMBean.class.cast(pmo);\n-                } else if (pmo instanceof NotificationEmitter) {\n-                    dmbean = new StandardEmitterMBean(pmo, null, true, (NotificationEmitter) pmo);\n-                } else {\n-                    dmbean = new StandardMBean(pmo, null, true);\n-                }\n-\n-                mbs.registerMBean(dmbean, oname);\n-                return null;\n-            });\n-        } catch (MalformedObjectNameException mone) {\n-            throw new IllegalArgumentException(mone);\n-        } catch (PrivilegedActionException e) {\n-            throw new RuntimeException(e.getException());\n+            final DynamicMBean dmbean;\n+            if (pmo instanceof DynamicMBean) {\n+                dmbean = DynamicMBean.class.cast(pmo);\n+            } else if (pmo instanceof NotificationEmitter) {\n+                dmbean = new StandardEmitterMBean(pmo, null, true, (NotificationEmitter) pmo);\n+            } else {\n+                dmbean = new StandardMBean(pmo, null, true);\n+            }\n+            mbs.registerMBean(dmbean, oname);\n+        } catch (MalformedObjectNameException | InstanceAlreadyExistsException | MBeanRegistrationException | NotCompliantMBeanException e) {\n+            throw new IllegalArgumentException(e);\n@@ -921,13 +900,5 @@\n-            @SuppressWarnings(\"removal\")\n-            List<PlatformMBeanProvider> providers = AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    @Override\n-                    public List<PlatformMBeanProvider> run() {\n-                        List<PlatformMBeanProvider> all = new ArrayList<>();\n-                        for (PlatformMBeanProvider provider : ServiceLoader.loadInstalled(PlatformMBeanProvider.class)) {\n-                            all.add(provider);\n-                        }\n-                        all.add(new DefaultPlatformMBeanProvider());\n-                        return all;\n-                    }\n-                }, null, new FilePermission(\"<<ALL FILES>>\", \"read\"));\n+            List<PlatformMBeanProvider> providers = new ArrayList<>();\n+            for (PlatformMBeanProvider provider : ServiceLoader.loadInstalled(PlatformMBeanProvider.class)) {\n+                providers.add(provider);\n+            }\n+            providers.add(new DefaultPlatformMBeanProvider());\n@@ -1016,1 +987,1 @@\n-    @SuppressWarnings({\"removal\", \"restricted\"})\n+    @SuppressWarnings(\"restricted\")\n@@ -1018,4 +989,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            System.loadLibrary(\"management\");\n-            return null;\n-        });\n+        System.loadLibrary(\"management\");\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":22,"deletions":54,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n@@ -79,2 +76,1 @@\n-        return AccessController.doPrivileged((PrivilegedAction<Long>)\n-                () -> ProcessHandle.current().pid());\n+        return ProcessHandle.current().pid();\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/RuntimeMXBean.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.security.AccessController;\n-\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ClassAttributeValueExp.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.reflect.misc.ReflectUtil;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/JMX.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.AccessController;\n@@ -31,1 +30,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanAttributeInfo.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -554,4 +552,2 @@\n-                    ArrayGettersSafeAction action =\n-                        new ArrayGettersSafeAction(subclass, immutableClass);\n-                    safe = AccessController.doPrivileged(action);\n-                } catch (Exception e) { \/\/ e.g. SecurityException\n+                    safe = arrayGettersSafeHelper(subclass, immutableClass);\n+                } catch (Exception e) {\n@@ -567,19 +563,1 @@\n-    \/*\n-     * The PrivilegedAction stuff is probably overkill.  We can be\n-     * pretty sure the caller does have the required privileges -- a\n-     * JMX user that can't do reflection can't even use Standard\n-     * MBeans!  But there's probably a performance gain by not having\n-     * to check the whole call stack.\n-     *\/\n-    private static class ArrayGettersSafeAction\n-            implements PrivilegedAction<Boolean> {\n-\n-        private final Class<?> subclass;\n-        private final Class<?> immutableClass;\n-\n-        ArrayGettersSafeAction(Class<?> subclass, Class<?> immutableClass) {\n-            this.subclass = subclass;\n-            this.immutableClass = immutableClass;\n-        }\n-\n-        public Boolean run() {\n+    private static boolean arrayGettersSafeHelper(Class<?> subclass, Class<?> immutableClass) {\n@@ -604,1 +582,0 @@\n-        }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanInfo.java","additions":4,"deletions":27,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -71,7 +71,0 @@\n-\/* DELETED:\n- *\n- * <li><p>For the {@link #isRegistered isRegistered} method, the\n- * caller's permissions must imply {@link\n- * MBeanPermission#MBeanPermission(String,String,ObjectName,String)\n- * MBeanPermission(null, null, name, \"isRegistered\")}.<\/p>\n- *\/\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanServer.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-import java.security.AccessController;\n-import java.security.Permission;\n@@ -37,2 +34,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -103,32 +98,0 @@\n-    \/**\n-     * Provide a new {@link javax.management.MBeanServerBuilder}.\n-     * @param builder The new MBeanServerBuilder that will be used to\n-     *        create {@link javax.management.MBeanServer}s.\n-     * @exception IllegalArgumentException if the given builder is null.\n-     *\n-     * @exception SecurityException if there is a SecurityManager and\n-     * the caller's permissions do not include or imply <code>{@link\n-     * MBeanServerPermission}(\"setMBeanServerBuilder\")<\/code>.\n-     *\n-     **\/\n-    \/\/ public static synchronized void\n-    \/\/    setMBeanServerBuilder(MBeanServerBuilder builder) {\n-    \/\/    checkPermission(\"setMBeanServerBuilder\");\n-    \/\/    MBeanServerFactory.builder = builder;\n-    \/\/ }\n-\n-    \/**\n-     * Get the current {@link javax.management.MBeanServerBuilder}.\n-     *\n-     * @return the current {@link javax.management.MBeanServerBuilder}.\n-     *\n-     * @exception SecurityException if there is a SecurityManager and\n-     * the caller's permissions do not include or imply <code>{@link\n-     * MBeanServerPermission}(\"getMBeanServerBuilder\")<\/code>.\n-     *\n-     **\/\n-    \/\/ public static synchronized MBeanServerBuilder getMBeanServerBuilder() {\n-    \/\/     checkPermission(\"getMBeanServerBuilder\");\n-    \/\/     return builder;\n-    \/\/ }\n-\n@@ -149,2 +112,0 @@\n-        checkPermission(\"releaseMBeanServer\");\n-\n@@ -218,2 +179,0 @@\n-        checkPermission(\"createMBeanServer\");\n-\n@@ -293,2 +252,0 @@\n-        checkPermission(\"newMBeanServer\");\n-\n@@ -338,2 +295,0 @@\n-        checkPermission(\"findMBeanServer\");\n-\n@@ -382,10 +337,0 @@\n-    private static void checkPermission(String action)\n-    throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            Permission perm = new MBeanServerPermission(action);\n-            sm.checkPermission(perm);\n-        }\n-    }\n-\n@@ -423,1 +368,1 @@\n-        return ReflectUtil.forName(builderClassName);\n+        return Class.forName(builderClassName);\n@@ -453,4 +398,1 @@\n-            GetPropertyAction act =\n-                    new GetPropertyAction(JMX_INITIAL_BUILDER);\n-            @SuppressWarnings(\"removal\")\n-            String builderClassName = AccessController.doPrivileged(act);\n+            String builderClassName = System.getProperty(JMX_INITIAL_BUILDER);\n@@ -502,3 +444,0 @@\n-     * @exception SecurityException if there is a SecurityManager and\n-     * the caller's permissions do not make it possible to instantiate\n-     * a new builder.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanServerFactory.java","additions":2,"deletions":63,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -34,4 +34,0 @@\n-import java.security.AccessController;\n-\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/Notification.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-\n@@ -36,2 +33,0 @@\n-import java.security.AccessController;\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/NumericValueExp.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -35,1 +34,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ObjectName.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.security.AccessController;\n@@ -1166,3 +1165,1 @@\n-                    MBeanInfoSafeAction action =\n-                        new MBeanInfoSafeAction(subclass);\n-                    safe = AccessController.doPrivileged(action);\n+                    safe = mBeanInfoSafe(subclass);\n@@ -1192,2 +1189,0 @@\n-    private static class MBeanInfoSafeAction\n-            implements PrivilegedAction<Boolean> {\n@@ -1195,7 +1190,1 @@\n-        private final Class<?> subclass;\n-\n-        MBeanInfoSafeAction(Class<?> subclass) {\n-            this.subclass = subclass;\n-        }\n-\n-        public Boolean run() {\n+    private static boolean mBeanInfoSafe(Class<?> subclass) {\n@@ -1233,1 +1222,0 @@\n-        }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/StandardMBean.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -45,1 +44,0 @@\n-import java.security.AccessController;\n@@ -61,2 +59,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -1143,1 +1139,0 @@\n-            ReflectUtil.checkPackageAccess(className);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/DescriptorSupport.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-\n@@ -39,1 +37,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/InvalidTargetObjectTypeException.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -41,1 +40,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanAttributeInfo.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -41,1 +40,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanConstructorInfo.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -40,1 +39,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanInfoSupport.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -40,1 +39,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanNotificationInfo.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -41,1 +40,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanOperationInfo.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -81,2 +78,0 @@\n-import jdk.internal.access.JavaSecurityAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -85,1 +80,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -143,4 +137,0 @@\n-    private static final JavaSecurityAccess javaSecurityAccess = SharedSecrets.getJavaSecurityAccess();\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext acc = AccessController.getContext();\n-\n@@ -967,1 +957,1 @@\n-            final Class<?> targetClass;\n+            Class<?> targetClass = null;\n@@ -971,4 +961,0 @@\n-                    @SuppressWarnings(\"removal\")\n-                    AccessControlContext stack = AccessController.getContext();\n-                    final Object obj = targetObject;\n-                    final String className = opClassName;\n@@ -977,16 +963,6 @@\n-                    targetClass = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<>() {\n-\n-                        @Override\n-                        public Class<?> run() {\n-                            try {\n-                                ReflectUtil.checkPackageAccess(className);\n-                                final ClassLoader targetClassLoader =\n-                                    obj.getClass().getClassLoader();\n-                                return Class.forName(className, false,\n-                                                            targetClassLoader);\n-                            } catch (ClassNotFoundException e) {\n-                                caughtException[0] = e;\n-                            }\n-                            return null;\n-                        }\n-                    }, stack, acc);\n+                    final ClassLoader targetClassLoader = targetObject.getClass().getClassLoader();\n+                    try {\n+                        targetClass = Class.forName(opClassName, false, targetClassLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        caughtException[0] = e;\n+                    }\n@@ -1042,2 +1018,0 @@\n-            @SuppressWarnings(\"removal\")\n-            final AccessControlContext stack = AccessController.getContext();\n@@ -1048,4 +1022,0 @@\n-            javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<Void>() {\n-\n-                @Override\n-                public Void run() {\n@@ -1060,1 +1030,0 @@\n-                                ReflectUtil.checkPackageAccess(sig[i]);\n@@ -1073,3 +1042,0 @@\n-                    return null;\n-                }\n-            }, stack, acc);\n@@ -1126,1 +1092,1 @@\n-        final Class<?> targetClass;\n+        Class<?> targetClass = null;\n@@ -1130,19 +1096,7 @@\n-            @SuppressWarnings(\"removal\")\n-            AccessControlContext stack = AccessController.getContext();\n-            final String className = opClassName;\n-            targetClass = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<>() {\n-\n-                @Override\n-                public Class<?> run() {\n-                    try {\n-                        ReflectUtil.checkPackageAccess(className);\n-                        final ClassLoader targetClassLoader =\n-                            rmmbClass.getClassLoader();\n-                        Class<?> clz = Class.forName(className, false,\n-                                                    targetClassLoader);\n-                        if (!rmmbClass.isAssignableFrom(clz))\n-                            return null;\n-                        return clz;\n-                    } catch (ClassNotFoundException e) {\n-                        return null;\n-                    }\n+            final ClassLoader targetClassLoader = rmmbClass.getClassLoader();\n+            try {\n+                Class<?> clz = Class.forName(opClassName, false, targetClassLoader);\n+                if (!rmmbClass.isAssignableFrom(clz)) {\n+                    targetClass = null;\n+                } else {\n+                    targetClass = clz;\n@@ -1150,1 +1104,2 @@\n-            }, stack, acc);\n+            } catch (ClassNotFoundException e) {\n+            }\n@@ -1168,15 +1123,6 @@\n-            @SuppressWarnings(\"removal\")\n-            AccessControlContext stack = AccessController.getContext();\n-            Object rslt = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<>() {\n-\n-                @Override\n-                public Object run() {\n-                    try {\n-                        ReflectUtil.checkPackageAccess(method.getDeclaringClass());\n-                        return MethodUtil.invoke(method, targetObject, opArgs);\n-                    } catch (InvocationTargetException | IllegalAccessException e) {\n-                        caughtException[0] = e;\n-                    }\n-                    return null;\n-                }\n-            }, stack, acc);\n+            Object rslt = null;\n+            try {\n+                rslt = MethodUtil.invoke(method, targetObject, opArgs);\n+            } catch (InvocationTargetException | IllegalAccessException e) {\n+                caughtException[0] = e;\n+            }\n@@ -1580,18 +1526,7 @@\n-                                @SuppressWarnings(\"removal\")\n-                                AccessControlContext stack = AccessController.getContext();\n-\n-                                Class<?> c = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<>() {\n-\n-                                    @Override\n-                                    public Class<?> run() {\n-                                        try {\n-                                            ReflectUtil.checkPackageAccess(respType);\n-                                            ClassLoader cl =\n-                                                respClass.getClassLoader();\n-                                            return Class.forName(respType, true, cl);\n-                                        } catch (Exception e) {\n-                                            caughException[0] = e;\n-                                        }\n-                                        return null;\n-                                    }\n-                                }, stack, acc);\n+                                ClassLoader cl = respClass.getClassLoader();\n+                                Class<?> c = null;\n+                                try {\n+                                    c = Class.forName(respType, true, cl);\n+                                } catch (Exception e) {\n+                                    caughException[0] = e;\n+                                }\n@@ -2663,2 +2598,0 @@\n-        @SuppressWarnings(\"removal\")\n-        AccessControlContext stack = AccessController.getContext();\n@@ -2667,18 +2600,10 @@\n-        Class<?> c = javaSecurityAccess.doIntersectionPrivilege(new PrivilegedAction<>() {\n-\n-            @Override\n-            public Class<?> run() {\n-                try {\n-                    ReflectUtil.checkPackageAccess(className);\n-                    return Class.forName(className);\n-                } catch (ClassNotFoundException e) {\n-                    final ClassLoaderRepository clr =\n-                        getClassLoaderRepository();\n-                    try {\n-                        if (clr == null) throw new ClassNotFoundException(className);\n-                        return clr.loadClass(className);\n-                    } catch (ClassNotFoundException ex) {\n-                        caughtException[0] = ex;\n-                    }\n-                }\n-                return null;\n+        Class<?> c = null;\n+        try {\n+            c = Class.forName(className);\n+        } catch (ClassNotFoundException e) {\n+            final ClassLoaderRepository clr = getClassLoaderRepository();\n+            try {\n+                if (clr == null) throw new ClassNotFoundException(className);\n+                return clr.loadClass(className);\n+            } catch (ClassNotFoundException ex) {\n+                caughtException[0] = ex;\n@@ -2686,2 +2611,1 @@\n-        }, stack, acc);\n-\n+        }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/RequiredModelMBean.java","additions":42,"deletions":118,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-\n@@ -40,1 +38,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/XMLParseException.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -32,2 +31,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -35,1 +32,0 @@\n-import java.security.ProtectionDomain;\n@@ -173,1 +169,1 @@\n-     * Subject and possibly AccessControlContext of the Monitor.start() caller.\n+     * Subject of the Monitor.start() caller.\n@@ -176,6 +172,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private static final AccessControlContext noPermissionsACC =\n-            new AccessControlContext(\n-            new ProtectionDomain[] {new ProtectionDomain(null, null)});\n-    @SuppressWarnings(\"removal\")\n-    private volatile AccessControlContext acc = noPermissionsACC;\n@@ -207,3 +197,1 @@\n-        @SuppressWarnings(\"removal\")\n-        final String maximumPoolSizeStr = AccessController.doPrivileged(\n-            new GetPropertyAction(maximumPoolSizeSysProp));\n+        final String maximumPoolSizeStr = System.getProperty(maximumPoolSizeSysProp);\n@@ -752,1 +740,1 @@\n-            \/\/ Reset the Subject and AccessControlContext.\n+            \/\/ Reset the Subject.\n@@ -755,1 +743,0 @@\n-            acc = noPermissionsACC;\n@@ -1472,2 +1459,1 @@\n-            \/\/ the executors map. If there is a SecurityManager, the group of\n-            \/\/ System.getSecurityManager() is used, else the group of the thread\n+            \/\/ the executors map.  Use the Thread group of the thread\n@@ -1476,4 +1462,1 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager s = System.getSecurityManager();\n-            ThreadGroup group = (s != null) ? s.getThreadGroup() :\n-                Thread.currentThread().getThreadGroup();\n+            ThreadGroup group = Thread.currentThread().getThreadGroup();\n@@ -1559,2 +1542,1 @@\n-     * the same ThreadGroup. If there is a SecurityManager, it uses\n-     * the group of System.getSecurityManager(), else the group of\n+     * the same ThreadGroup.  Use the Thread group of\n@@ -1575,4 +1557,1 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager s = System.getSecurityManager();\n-            group = (s != null) ? s.getThreadGroup() :\n-                                  Thread.currentThread().getThreadGroup();\n+            group = Thread.currentThread().getThreadGroup();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/monitor\/Monitor.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -696,1 +695,0 @@\n-            ReflectUtil.checkPackageAccess(className);\n@@ -705,2 +703,0 @@\n-            \/\/ It is safe to call this plain Class.getMethod because the class \"c\"\n-            \/\/ was checked before by ReflectUtil.checkPackageAccess(openType.safeGetClassName());\n@@ -727,2 +723,0 @@\n-            \/\/ It is safe to call this plain Class.getConstructor because the class \"c\"\n-            \/\/ was checked before by ReflectUtil.checkPackageAccess(openType.safeGetClassName());\n@@ -767,3 +761,0 @@\n-            \/\/ check access to the provided base type class name and bail out early\n-            ReflectUtil.checkPackageAccess(baseClassName);\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -33,2 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -196,1 +193,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -201,3 +197,1 @@\n-            final GetPropertyAction getExtendOpenTypes =\n-                new GetPropertyAction(\"jmx.extend.open.types\");\n-            if (AccessController.doPrivileged(getExtendOpenTypes) == null) {\n+            if (System.getProperty(\"jmx.extend.open.types\") == null) {\n@@ -212,10 +206,5 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<>() {\n-            public Boolean run() {\n-                try {\n-                    return (c.getMethod(\"getClassName\").getDeclaringClass() !=\n-                            OpenType.class);\n-                } catch (Exception e) {\n-                    return true;  \/\/ fail safe\n-                }\n-            }\n-        });\n+        try {\n+            return (c.getMethod(\"getClassName\").getDeclaringClass() != OpenType.class);\n+        } catch (Exception e) {\n+            return true;  \/\/ fail safe\n+        }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/openmbean\/OpenType.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -34,1 +33,0 @@\n-import java.security.AccessController;\n@@ -151,4 +149,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String useHashMapProp = AccessController.doPrivileged(\n-                new GetPropertyAction(\"jmx.tabular.data.hash.map\"));\n-        boolean useHashMap = \"true\".equalsIgnoreCase(useHashMapProp);\n+        boolean useHashMap = Boolean.getBoolean(\"jmx.tabular.data.hash.map\");\n","filename":"src\/java.management\/share\/classes\/javax\/management\/openmbean\/TabularDataSupport.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -36,1 +35,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/MBeanServerNotificationFilter.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import java.security.AccessController;\n-\n@@ -46,1 +44,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RelationNotification.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -37,2 +36,0 @@\n-import java.security.AccessController;\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RelationTypeSupport.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -37,2 +36,0 @@\n-import java.security.AccessController;\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/Role.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-\n@@ -36,1 +33,0 @@\n-import java.security.AccessController;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RoleInfo.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n-\n@@ -37,2 +34,0 @@\n-import java.security.AccessController;\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RoleResult.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.jmx.mbeanserver.GetPropertyAction;\n@@ -37,2 +36,0 @@\n-import java.security.AccessController;\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RoleUnresolved.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -45,2 +43,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -391,6 +387,1 @@\n-            pkgsObject =\n-                AccessController.doPrivileged(new PrivilegedAction<String>() {\n-                    public String run() {\n-                        return System.getProperty(PROTOCOL_PROVIDER_PACKAGES);\n-                    }\n-                });\n+            pkgsObject = System.getProperty(PROTOCOL_PROVIDER_PACKAGES);\n@@ -450,1 +441,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -452,12 +442,5 @@\n-        return parent != null ? AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public ClassLoader run() {\n-                return new ClassLoader(parent) {\n-                    @Override\n-                    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n-                        ReflectUtil.checkPackageAccess(name);\n-                        return super.loadClass(name, resolve);\n-                    }\n-                };\n-            }\n-        }) : null;\n+        return parent != null ? new ClassLoader(parent) {\n+                                    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException\n+                                        { return super.loadClass(name, resolve); }\n+                                }\n+                              : null;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnectorFactory.java","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,0 @@\n-        Util.checkControlAccess();\n-\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ClassLoadingImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,3 +39,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -50,1 +47,0 @@\n-import java.security.PrivilegedAction;\n@@ -194,1 +190,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -196,10 +191,6 @@\n-            return AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public Class<?> run() {\n-                    Optional<Module> logging = ModuleLayer.boot().findModule(\"java.logging\");\n-                    if (logging.isPresent()) {\n-                        return Class.forName(logging.get(), className);\n-                    }\n-                    return null;\n-                }\n-            });\n+            Optional<Module> logging = ModuleLayer.boot().findModule(\"java.logging\");\n+            if (logging.isPresent()) {\n+                return Class.forName(logging.get(), className);\n+            } else {\n+                return null;\n+            }\n@@ -463,1 +454,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -465,0 +455,2 @@\n+        final ObjectName objName = Util.newObjectName(mbeanName);\n+\n@@ -466,20 +458,5 @@\n-            final ObjectName objName = Util.newObjectName(mbeanName);\n-\n-            \/\/ inner class requires these fields to be final\n-            final MBeanServer mbs0 = mbs;\n-            final Object mbean0 = mbean;\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                public Void run() throws MBeanRegistrationException,\n-                                         NotCompliantMBeanException {\n-                    try {\n-                        mbs0.registerMBean(mbean0, objName);\n-                        return null;\n-                    } catch (InstanceAlreadyExistsException e) {\n-                        \/\/ if an instance with the object name exists in\n-                        \/\/ the MBeanServer ignore the exception\n-                    }\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw new RuntimeException(e.getException());\n+            mbs.registerMBean(mbean, objName);\n+        } catch (InstanceAlreadyExistsException iaee) {\n+            \/\/ if an instance with the object name exists in the MBeanServer, ignore the exception\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n@@ -524,1 +501,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -526,0 +502,2 @@\n+        final ObjectName objName = Util.newObjectName(mbeanName);\n+\n@@ -527,17 +505,5 @@\n-            final ObjectName objName = Util.newObjectName(mbeanName);\n-\n-            \/\/ inner class requires these fields to be final\n-            final MBeanServer mbs0 = mbs;\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                public Void run() throws MBeanRegistrationException,\n-                                           RuntimeOperationsException  {\n-                    try {\n-                        mbs0.unregisterMBean(objName);\n-                    } catch (InstanceNotFoundException e) {\n-                        \/\/ ignore exception if not found\n-                    }\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw new RuntimeException(e.getException());\n+            mbs.unregisterMBean(objName);\n+        } catch (InstanceNotFoundException infe) {\n+            \/\/ ignore exception if not found\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ManagementFactoryHelper.java","additions":21,"deletions":55,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -613,1 +609,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -620,6 +615,2 @@\n-                fromMethod = AccessController.doPrivileged(new PrivilegedExceptionAction<>() {\n-                        public Method run() throws NoSuchMethodException {\n-                            return javaClass.getMethod(\"from\", COMPOSITE_DATA_CLASS);\n-                        }\n-                    });\n-            } catch (PrivilegedActionException e) {\n+                fromMethod = javaClass.getMethod(\"from\", COMPOSITE_DATA_CLASS);\n+            } catch (NoSuchMethodException e) {\n@@ -640,6 +631,1 @@\n-                final Method[] methods =\n-                    AccessController.doPrivileged(new PrivilegedAction<>() {\n-                            public Method[] run() {\n-                                return javaClass.getMethods();\n-                            }\n-                        });\n+                final Method[] methods = javaClass.getMethods();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/MappedMXBeanType.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,0 @@\n-        Util.checkControlAccess();\n-\n","filename":"src\/java.management\/share\/classes\/sun\/management\/MemoryImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,2 +115,0 @@\n-        Util.checkControlAccess();\n-\n@@ -160,2 +158,0 @@\n-        Util.checkControlAccess();\n-\n@@ -212,2 +208,0 @@\n-        Util.checkControlAccess();\n-\n","filename":"src\/java.management\/share\/classes\/sun\/management\/MemoryPoolImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,0 @@\n-        Util.checkMonitorAccess();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/RuntimeImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,1 +132,0 @@\n-        Util.checkMonitorAccess();\n@@ -181,2 +180,0 @@\n-        Util.checkMonitorAccess();\n-\n@@ -199,2 +196,0 @@\n-        Util.checkControlAccess();\n-\n@@ -335,1 +330,0 @@\n-        Util.checkControlAccess();\n@@ -404,1 +398,0 @@\n-        Util.checkControlAccess();\n@@ -429,1 +422,0 @@\n-        Util.checkMonitorAccess();\n@@ -441,2 +433,0 @@\n-        Util.checkMonitorAccess();\n-\n@@ -449,1 +439,0 @@\n-        Util.checkControlAccess();\n@@ -474,2 +463,0 @@\n-\n-        Util.checkMonitorAccess();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,22 +53,3 @@\n-    private static ManagementPermission monitorPermission =\n-        new ManagementPermission(\"monitor\");\n-    private static ManagementPermission controlPermission =\n-        new ManagementPermission(\"control\");\n-\n-    \/**\n-     * Check that the current context is trusted to perform monitoring\n-     * or management.\n-     * <p>\n-     * If the check fails we throw a SecurityException, otherwise\n-     * we return normally.\n-     *\n-     * @exception  SecurityException  if a security manager exists and if\n-     *             the caller does not have ManagementPermission(\"control\").\n-     *\/\n-    static void checkAccess(ManagementPermission p)\n-         throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(p);\n-        }\n+    \/\/ Methods retained temporarily due to usage by jdk.management.\n+    static void checkAccess(ManagementPermission p) {\n+        \/\/ no-op\n@@ -78,1 +59,1 @@\n-        checkAccess(monitorPermission);\n+        \/\/ no-op\n@@ -81,1 +62,1 @@\n-        checkAccess(controlPermission);\n+        \/\/ no-op\n","filename":"src\/java.management\/share\/classes\/sun\/management\/Util.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -205,9 +203,2 @@\n-    public String   getCompilerName() {\n-        @SuppressWarnings(\"removal\")\n-        String name =  AccessController.doPrivileged(\n-            new PrivilegedAction<>() {\n-                public String run() {\n-                    return System.getProperty(\"sun.management.compiler\");\n-                }\n-            });\n-        return name;\n+    public String getCompilerName() {\n+        return System.getProperty(\"sun.management.compiler\");\n@@ -258,2 +249,1 @@\n-        @SuppressWarnings(\"removal\")\n-        Perf perf =  AccessController.doPrivileged(new Perf.GetPerfAction());\n+        Perf perf = Perf.getPerf();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,2 +87,2 @@\n-                Class<?> socketFactoryClass =\n-                        Obj.helper.loadClass(socketFactory);\n+                Class<?> socketFactoryClass = Class.forName(socketFactory,\n+                        true, Thread.currentThread().getContextClassLoader());\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/ClientId.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -186,1 +184,1 @@\n-        PrivilegedAction<String> act = () -> System.getProperty(\n+        String prop = System.getProperty(\n@@ -188,2 +186,0 @@\n-        @SuppressWarnings(\"removal\")\n-        String prop = AccessController.doPrivileged(act);\n@@ -262,1 +258,1 @@\n-        worker = Obj.helper.createThread(this);\n+        worker = new Thread(this);\n@@ -316,1 +312,2 @@\n-                    (Class<? extends SocketFactory>) Obj.helper.loadClass(socketFactoryName);\n+                    (Class<? extends SocketFactory>) Class.forName(socketFactoryName,\n+                            true, Thread.currentThread().getContextClassLoader());\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        qThread = Obj.helper.createThread(this);\n+        qThread = new Thread(this);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/EventQueue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -44,3 +40,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext acc = AccessController.getContext();\n-\n@@ -53,1 +46,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -64,6 +56,1 @@\n-            try {\n-                PrivilegedExceptionAction<Object> pa = () -> Obj.decodeObject(attrs);\n-                obj = AccessController.doPrivileged(pa, acc);\n-            } catch (PrivilegedActionException e) {\n-                throw (NamingException)e.getException();\n-            }\n+            obj = Obj.decodeObject(attrs);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapBindingEnumeration.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -223,1 +221,1 @@\n-            getMechsAllowedToSendCredentials();\n+            System.getProperty(ALLOWED_MECHS_SP);\n@@ -2709,7 +2707,0 @@\n-    \/\/ Load 'mechsAllowedToSendCredentials' system property value\n-    @SuppressWarnings(\"removal\")\n-    private static String getMechsAllowedToSendCredentials() {\n-        PrivilegedAction<String> pa = () -> System.getProperty(ALLOWED_MECHS_SP);\n-        return System.getSecurityManager() == null ? pa.run() : AccessController.doPrivileged(pa);\n-    }\n-\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapCtx.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -35,1 +33,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -53,1 +50,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -55,17 +51,3 @@\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            providers = ServiceLoader.load(\n-                    LdapDnsProvider.class,\n-                    ClassLoader.getSystemClassLoader());\n-        } else {\n-            final PrivilegedAction<ServiceLoader<LdapDnsProvider>> pa =\n-                    () -> ServiceLoader.load(\n-                            LdapDnsProvider.class,\n-                            ClassLoader.getSystemClassLoader());\n-\n-            providers = AccessController.doPrivileged(\n-                pa,\n-                null,\n-                new RuntimePermission(\"ldapDnsProvider\"),\n-                SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-        }\n+        providers = ServiceLoader.load(\n+                LdapDnsProvider.class,\n+                ClassLoader.getSystemClassLoader());\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapDnsProviderService.java","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -63,1 +61,1 @@\n-        \"all\".equalsIgnoreCase(getProperty(DEBUG, null));\n+        \"all\".equalsIgnoreCase(System.getProperty(DEBUG));\n@@ -66,1 +64,1 @@\n-        \"fine\".equalsIgnoreCase(getProperty(DEBUG, null));\n+        \"fine\".equalsIgnoreCase(System.getProperty(DEBUG));\n@@ -123,1 +121,1 @@\n-        maxSize = getInteger(MAX_POOL_SIZE, DEFAULT_MAX_POOL_SIZE);\n+        maxSize = Integer.getInteger(MAX_POOL_SIZE, DEFAULT_MAX_POOL_SIZE);\n@@ -125,1 +123,1 @@\n-        prefSize = getInteger(PREF_POOL_SIZE, DEFAULT_PREF_POOL_SIZE);\n+        prefSize = Integer.getInteger(PREF_POOL_SIZE, DEFAULT_PREF_POOL_SIZE);\n@@ -127,1 +125,1 @@\n-        initSize = getInteger(INIT_POOL_SIZE, DEFAULT_INIT_POOL_SIZE);\n+        initSize = Integer.getInteger(INIT_POOL_SIZE, DEFAULT_INIT_POOL_SIZE);\n@@ -129,1 +127,1 @@\n-        idleTimeout = getLong(POOL_TIMEOUT, DEFAULT_TIMEOUT);\n+        idleTimeout = Long.getLong(POOL_TIMEOUT, DEFAULT_TIMEOUT);\n@@ -132,1 +130,1 @@\n-        String str = getProperty(POOL_AUTH, DEFAULT_AUTH_MECHS);\n+        String str = System.getProperty(POOL_AUTH, DEFAULT_AUTH_MECHS);\n@@ -150,1 +148,1 @@\n-        str= getProperty(POOL_PROTOCOL, DEFAULT_PROTOCOLS);\n+        str = System.getProperty(POOL_PROTOCOL, DEFAULT_PROTOCOLS);\n@@ -174,1 +172,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -177,11 +174,7 @@\n-        PrivilegedAction<Void> pa = new PrivilegedAction<Void>() {\n-            public Void run() {\n-                Thread t = InnocuousThread.newSystemThread(\n-                        \"LDAP PoolCleaner\",\n-                        new PoolCleaner(idleTimeout, pools));\n-                assert t.getContextClassLoader() == null;\n-                t.setDaemon(true);\n-                t.start();\n-                return null;\n-            }};\n-        AccessController.doPrivileged(pa);\n+        Thread t = InnocuousThread.newSystemThread(\n+                \"LDAP PoolCleaner\",\n+                new PoolCleaner(idleTimeout, pools));\n+        assert t.getContextClassLoader() == null;\n+        t.setDaemon(true);\n+        t.start();\n+\n@@ -255,1 +248,2 @@\n-                Class<?> socketFactoryClass = Obj.helper.loadClass(socketFactory);\n+                Class<?> socketFactoryClass = Class.forName(socketFactory, true,\n+                        Thread.currentThread().getContextClassLoader());\n@@ -402,18 +396,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    private static final String getProperty(final String propName, final String defVal) {\n-        PrivilegedAction<String> pa = () -> System.getProperty(propName, defVal);\n-        return AccessController.doPrivileged(pa);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static final int getInteger(final String propName, final int defVal) {\n-        PrivilegedAction<Integer> pa = () -> Integer.getInteger(propName, defVal);\n-        return AccessController.doPrivileged(pa);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static final long getLong(final String propName, final long defVal) {\n-        PrivilegedAction<Long> pa = () -> Long.getLong(propName, defVal);\n-        return AccessController.doPrivileged(pa);\n-    }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapPoolManager.java","additions":18,"deletions":42,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -48,3 +44,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext acc = AccessController.getContext();\n-\n@@ -64,1 +57,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -124,6 +116,1 @@\n-                try {\n-                    PrivilegedExceptionAction<Object> pea = () -> Obj.decodeObject(attrs);\n-                    obj = AccessController.doPrivileged(pea, acc);\n-                } catch (PrivilegedActionException e) {\n-                    throw (NamingException)e.getException();\n-                }\n+                obj = Obj.decodeObject(attrs);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSearchEnumeration.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -76,2 +74,0 @@\n-        PrivilegedAction<String> action = () ->\n-                System.getProperty(PARSE_MODE_PROP, DEFAULT_PARSE_MODE.toString());\n@@ -80,2 +76,1 @@\n-            @SuppressWarnings(\"removal\")\n-            String mode = AccessController.doPrivileged(action);\n+            String mode = System.getProperty(PARSE_MODE_PROP, DEFAULT_PARSE_MODE.toString());\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapURL.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        worker = Obj.helper.createThread(this);\n+        worker = new Thread(this);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/NamingEventNotifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,13 @@\n-    \/\/ package private; used by Connection\n-    static VersionHelper helper = VersionHelper.getVersionHelper();\n+    \/**\n+     * Determines whether objects may be deserialized or reconstructed from a content of\n+     * 'javaSerializedData', 'javaRemoteLocation' or 'javaReferenceAddress' LDAP attributes.\n+     *\/\n+    private static final boolean trustSerialData;\n+\n+    static {\n+        \/\/ System property to control whether classes are allowed to be loaded from\n+        \/\/ 'javaSerializedData', 'javaRemoteLocation' or 'javaReferenceAddress' attributes.\n+        String trustSerialDataSp = System.getProperty(\n+                \"com.sun.jndi.ldap.object.trustSerialData\", \"false\");\n+        trustSerialData = \"true\".equalsIgnoreCase(trustSerialDataSp);\n+    }\n@@ -236,1 +247,1 @@\n-                if (!VersionHelper.isSerialDataAllowed()) {\n+                if (!trustSerialData) {\n@@ -243,1 +254,1 @@\n-                 if (!VersionHelper.isSerialDataAllowed()) {\n+                 if (!trustSerialData) {\n@@ -474,1 +485,1 @@\n-                    if (!VersionHelper.isSerialDataAllowed()) {\n+                    if (!trustSerialData) {\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Obj.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.jndi.ldap;\n-\n-public final class VersionHelper {\n-\n-    private static final VersionHelper helper = new VersionHelper();\n-\n-    \/**\n-     * Determines whether objects may be deserialized or reconstructed from a content of\n-     * 'javaSerializedData', 'javaRemoteLocation' or 'javaReferenceAddress' LDAP attributes.\n-     *\/\n-    private static final boolean trustSerialData;\n-\n-    static {\n-        \/\/ System property to control whether classes are allowed to be loaded from\n-        \/\/ 'javaSerializedData', 'javaRemoteLocation' or 'javaReferenceAddress' attributes.\n-        String trustSerialDataSp = System.getProperty(\n-                \"com.sun.jndi.ldap.object.trustSerialData\", \"false\");\n-        trustSerialData = \"true\".equalsIgnoreCase(trustSerialDataSp);\n-    }\n-\n-    private VersionHelper() {\n-    }\n-\n-    static VersionHelper getVersionHelper() {\n-        return helper;\n-    }\n-\n-    \/**\n-     * Returns true if deserialization or reconstruction of objects from\n-     * 'javaSerializedData', 'javaRemoteLocation' and 'javaReferenceAddress'\n-     * LDAP attributes is allowed.\n-     *\n-     * @return true if deserialization is allowed; false - otherwise\n-     *\/\n-    public static boolean isSerialDataAllowed() {\n-        return trustSerialData;\n-    }\n-\n-    Class<?> loadClass(String className) throws ClassNotFoundException {\n-        return Class.forName(className, true,\n-                             Thread.currentThread().getContextClassLoader());\n-    }\n-\n-    Thread createThread(Runnable r) {\n-        return new Thread(r);\n-    }\n-}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/VersionHelper.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,1 +223,1 @@\n-        String propVal = SecurityProperties.privilegedGetOverridable(propertyName);\n+        String propVal = SecurityProperties.getOverridableProperty(propertyName);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/naming\/internal\/ObjectFactoriesFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1064,23 +1064,0 @@\n-\n-    \/**\n-     * @deprecated An environment property with this name is ignored\n-     *             while constructing an initial context.\n-     * This constant was originally used as a property name to specify an\n-     * {@code Applet} to retrieve parameters from, when creating an initial\n-     * context. Currently any applet properties that need to be passed to an\n-     * initial context should be copied into the environment hashtable:\n-     * <pre>{@code\n-     *     Hashtable env = new Hashtable();\n-     *     env.put(Context.INITIAL_CONTEXT_FACTORY,\n-     *       ((Applet) this).getParameter(Context.INITIAL_CONTEXT_FACTORY));\n-     *     env.put(Context.PROVIDER_URL,\n-     *       ((Applet) this).getParameter(Context.PROVIDER_URL));\n-     *     \/\/ ... other properties ...\n-     *\n-     *     Context ctx = new InitialContext(env);\n-     * }<\/pre>\n-     *\n-     * @since 1.3\n-     *\/\n-    @Deprecated(since = \"9\", forRemoval = true)\n-    String APPLET = \"java.naming.applet\";\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/Context.java","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -35,1 +33,0 @@\n-import java.util.ServiceConfigurationError;\n@@ -184,1 +181,1 @@\n-                StartTlsResponse.class, getContextClassLoader());\n+                StartTlsResponse.class, Thread.currentThread().getContextClassLoader());\n@@ -187,1 +184,1 @@\n-        while (resp == null && privilegedHasNext(iter)) {\n+        while (resp == null && iter.hasNext()) {\n@@ -219,15 +216,0 @@\n-    \/*\n-     * Acquire the class loader associated with this thread.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private final ClassLoader getContextClassLoader() {\n-        PrivilegedAction<ClassLoader> pa = Thread.currentThread()::getContextClassLoader;\n-        return AccessController.doPrivileged(pa);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static final boolean privilegedHasNext(final Iterator<StartTlsResponse> iter) {\n-        PrivilegedAction<Boolean> pa = iter::hasNext;\n-        return AccessController.doPrivileged(pa);\n-    }\n-\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/StartTlsRequest.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -56,5 +56,0 @@\n-    \/\/ The {@code RuntimePermission(\"ldapDnsProvider\")} is\n-    \/\/ necessary to subclass and instantiate the {@code LdapDnsProvider} class.\n-    private static final RuntimePermission DNSPROVIDER_PERMISSION =\n-            new RuntimePermission(\"ldapDnsProvider\");\n-\n@@ -65,14 +60,0 @@\n-        this(checkPermission());\n-    }\n-\n-    private LdapDnsProvider(Void unused) {\n-        \/\/ nothing to do.\n-    }\n-\n-    private static Void checkPermission() {\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(DNSPROVIDER_PERMISSION);\n-        }\n-        return null;\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/ldap\/spi\/LdapDnsProvider.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -474,1 +472,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -495,10 +492,2 @@\n-            if (System.getSecurityManager() == null) {\n-                loader = Thread.currentThread().getContextClassLoader();\n-                if (loader == null) loader = ClassLoader.getSystemClassLoader();\n-            } else {\n-                PrivilegedAction<ClassLoader> pa = () -> {\n-                    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n-                    return (cl == null) ? ClassLoader.getSystemClassLoader() : cl;\n-                };\n-                loader = AccessController.doPrivileged(pa);\n-            }\n+            loader = Thread.currentThread().getContextClassLoader();\n+            if (loader == null) loader = ClassLoader.getSystemClassLoader();\n@@ -573,6 +562,0 @@\n-\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                security.checkSetFactory();\n-            }\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/NamingManager.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -77,4 +76,3 @@\n-        PrivilegedAction<Void> pa = () -> {\n-            HashMap<String, String> attrs = new HashMap<>(2);\n-            attrs.put(\"LDAPSchema\", \"RFC2587\");\n-            attrs.put(\"ImplementedIn\", \"Software\");\n+        HashMap<String, String> attrs = new HashMap<>(2);\n+        attrs.put(\"LDAPSchema\", \"RFC2587\");\n+        attrs.put(\"ImplementedIn\", \"Software\");\n@@ -82,10 +80,7 @@\n-            \/*\n-             * CertStore\n-             * attrs: LDAPSchema, ImplementedIn\n-             *\/\n-            putService(new ProviderService(p, \"CertStore\",\n-                       \"LDAP\", \"sun.security.provider.certpath.ldap.LDAPCertStore\",\n-                       null, attrs));\n-            return null;\n-        };\n-        AccessController.doPrivileged(pa);\n+        \/*\n+         * CertStore\n+         * attrs: LDAPSchema, ImplementedIn\n+         *\/\n+        putService(new ProviderService(p, \"CertStore\",\n+                \"LDAP\", \"sun.security.provider.certpath.ldap.LDAPCertStore\",\n+                null, attrs));\n","filename":"src\/java.naming\/share\/classes\/sun\/security\/provider\/certpath\/ldap\/JdkLDAP.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,6 +139,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkConnect(serverName, port);\n-        }\n-\n","filename":"src\/java.naming\/share\/classes\/sun\/security\/provider\/certpath\/ldap\/LDAPCertStore.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,3 +100,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String s = AccessController.doPrivileged(\n-            (PrivilegedAction<String>) () -> System.getProperty(PROP_LIFETIME));\n+        String s = System.getProperty(PROP_LIFETIME);\n@@ -175,3 +173,2 @@\n-        @SuppressWarnings(\"removal\")\n-        boolean disableAppResourceFiles = AccessController.doPrivileged(\n-            (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(PROP_DISABLE_APP_RESOURCE_FILES));\n+        boolean disableAppResourceFiles =\n+                Boolean.getBoolean(PROP_DISABLE_APP_RESOURCE_FILES);\n","filename":"src\/java.naming\/share\/classes\/sun\/security\/provider\/certpath\/ldap\/LDAPCertStoreImpl.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.rmi.runtime;\n-\n-\/**\n- * A utility class for creating threads. The constructors take a\n- * variety of parameters to configure the thread. The run() method\n- * creates and sets up the thread and returns it, but does not\n- * start it.\n- *\n- * All constructors allow the choice of the Runnable for the new\n- * thread to execute, the name of the new thread (which will be\n- * prefixed with \"RMI \"), and whether or not it will be a daemon\n- * thread.\n- *\n- * The new thread may be created in the system thread group (the root\n- * of the thread group tree) or an internally created non-system\n- * thread group, as specified at construction of this class.\n- *\n- * The new thread will have the system class loader as its initial\n- * context class loader (that is, its context class loader will NOT be\n- * inherited from the current thread).\n- *\n- * @author      Peter Jones\n- **\/\n-public final class NewThreadAction {\n-\n-    \/** cached reference to the system (root) thread group *\/\n-    static final ThreadGroup systemThreadGroup;\n-    static {\n-        ThreadGroup group = Thread.currentThread().getThreadGroup();\n-        ThreadGroup parent;\n-        while ((parent = group.getParent()) != null) {\n-            group = parent;\n-        }\n-        systemThreadGroup = group;\n-    }\n-\n-\n-    \/**\n-     * Special child of the system thread group for running tasks that\n-     * may execute user code. The need for a separate thread group may\n-     * be a vestige of it having had a different security policy from\n-     * the system thread group, so this might no longer be necessary.\n-     *\/\n-    static final ThreadGroup userThreadGroup = new ThreadGroup(systemThreadGroup, \"RMI Runtime\");\n-\n-    private final ThreadGroup group;\n-    private final Runnable runnable;\n-    private final String name;\n-    private final boolean daemon;\n-\n-    NewThreadAction(ThreadGroup group, Runnable runnable,\n-                    String name, boolean daemon)\n-    {\n-        this.group = group;\n-        this.runnable = runnable;\n-        this.name = name;\n-        this.daemon = daemon;\n-    }\n-\n-    \/**\n-     * Creates an action that will create a new thread in the\n-     * system thread group.\n-     *\n-     * @param   runnable the Runnable for the new thread to execute\n-     *\n-     * @param   name the name of the new thread\n-     *\n-     * @param   daemon if true, new thread will be a daemon thread;\n-     * if false, new thread will not be a daemon thread\n-     *\/\n-    public NewThreadAction(Runnable runnable, String name, boolean daemon) {\n-        this(systemThreadGroup, runnable, name, daemon);\n-    }\n-\n-    \/**\n-     * Creates an action that will create a new thread.\n-     *\n-     * @param   runnable the Runnable for the new thread to execute\n-     *\n-     * @param   name the name of the new thread\n-     *\n-     * @param   daemon if true, new thread will be a daemon thread;\n-     * if false, new thread will not be a daemon thread\n-     *\n-     * @param   user if true, thread will be created in a non-system\n-     * thread group; if false, thread will be created in the system\n-     * thread group\n-     *\/\n-    public NewThreadAction(Runnable runnable, String name, boolean daemon,\n-                           boolean user)\n-    {\n-        this(user ? userThreadGroup : systemThreadGroup,\n-             runnable, name, daemon);\n-    }\n-\n-    public Thread run() {\n-        Thread t = new Thread(group, runnable, \"RMI \" + name);\n-        t.setContextClassLoader(ClassLoader.getSystemClassLoader());\n-        t.setDaemon(daemon);\n-        return t;\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/runtime\/NewThreadAction.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -39,0 +39,14 @@\n+ * This class also contains a couple static methods for creating\n+ * threads. The methods allow the choice of the Runnable for the\n+ * new thread to execute, the name of the new thread (which will\n+ * be prefixed with \"RMI \"), and whether or not it will be a daemon\n+ * thread.\n+ *\n+ * The new thread may be created in the system thread group (the root\n+ * of the thread group tree) or an internally created non-system\n+ * thread group (the \"user\" thread group).\n+ *\n+ * The new thread will have the system class loader as its initial\n+ * context class loader (that is, its context class loader will NOT be\n+ * inherited from the current thread).\n+ *\n@@ -43,0 +57,22 @@\n+    \/**\n+     * Cached reference to the system (root) thread group.\n+     *\/\n+    private static final ThreadGroup systemThreadGroup;\n+    static {\n+        ThreadGroup group = Thread.currentThread().getThreadGroup();\n+        ThreadGroup parent;\n+        while ((parent = group.getParent()) != null) {\n+            group = parent;\n+        }\n+        systemThreadGroup = group;\n+    }\n+\n+    \/**\n+     * Special child of the system thread group for running tasks that\n+     * may execute user code. The need for a separate thread group may\n+     * be a vestige of it having had a different security policy from\n+     * the system thread group, so this might no longer be necessary.\n+     *\/\n+    private static final ThreadGroup userThreadGroup =\n+        new ThreadGroup(systemThreadGroup, \"RMI Runtime\");\n+\n@@ -57,0 +93,8 @@\n+    \/**\n+     * Creates the single instance of RuntimeUtil. Note that this is called\n+     * from a static initializer, and it has a ThreadFactory that calls\n+     * static methods on this class, possibly from other threads. This\n+     * should be ok, as the ScheduledThreadPoolExecutor constructor\n+     * returns immediately without blocking on the creation of threads\n+     * by the factory.\n+     *\/\n@@ -64,1 +108,2 @@\n-                        return new NewThreadAction(runnable,\n+                        return newSystemThread(\n+                            runnable,\n@@ -66,1 +111,1 @@\n-                            true).run();\n+                            true);\n@@ -96,0 +141,44 @@\n+\n+    \/\/ Thread creation methods.\n+\n+    \/**\n+     * Internal method to create a new thread with the given settings.\n+     *\n+     * @param group the thread group, should be systemThreadGroup or userThreadGroup\n+     * @param runnable the thread's task\n+     * @param name the thread's name, which will be prefixed with \"RMI \"\n+     * @param daemon whether the thread should be a daemon\n+     * @return the newly created thread\n+     *\/\n+    private static Thread newThread(ThreadGroup group, Runnable runnable, String name, boolean daemon) {\n+        Thread t = new Thread(group, runnable, \"RMI \" + name);\n+        t.setContextClassLoader(ClassLoader.getSystemClassLoader());\n+        t.setDaemon(daemon);\n+        return t;\n+    }\n+\n+    \/**\n+     * Creates and returns, but does not start, a new thread with the given settings.\n+     * The thread will be in the system (\"root\") thread group.\n+     *\n+     * @param runnable the thread's task\n+     * @param name the thread's name, which will be prefixed with \"RMI \"\n+     * @param daemon whether the thread should be a daemon\n+     * @return the newly created thread\n+     *\/\n+    public static Thread newSystemThread(Runnable runnable, String name, boolean daemon) {\n+        return newThread(systemThreadGroup, runnable, name, daemon);\n+    }\n+\n+    \/**\n+     * Creates and returns, but does not start, a new thread with the given settings.\n+     * The thread will be in the RMI user thread group.\n+     *\n+     * @param runnable the thread's task\n+     * @param name the thread's name, which will be prefixed with \"RMI \"\n+     * @param daemon whether the thread should be a daemon\n+     * @return the newly created thread\n+     *\/\n+    public static Thread newUserThread(Runnable runnable, String name, boolean daemon) {\n+        return newThread(userThreadGroup, runnable, name, daemon);\n+    }\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/runtime\/RuntimeUtil.java","additions":91,"deletions":2,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import sun.rmi.runtime.NewThreadAction;\n+import sun.rmi.runtime.RuntimeUtil;\n@@ -240,2 +240,1 @@\n-                new NewThreadAction(new RenewCleanThread(),\n-                                    \"RenewClean-\" + endpoint, true).run();\n+                RuntimeUtil.newSystemThread(new RenewCleanThread(), \"RenewClean-\" + endpoint, true);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCClient.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import sun.rmi.runtime.NewThreadAction;\n+import sun.rmi.runtime.RuntimeUtil;\n@@ -274,1 +274,1 @@\n-                reaper = new NewThreadAction(new Reaper(), \"Reaper\", false).run();\n+                reaper = RuntimeUtil.newSystemThread(new Reaper(), \"Reaper\", false);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/ObjectTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import sun.rmi.runtime.NewThreadAction;\n+import sun.rmi.runtime.RuntimeUtil;\n@@ -315,1 +315,1 @@\n-                new NewThreadAction(() -> {\n+                RuntimeUtil.newUserThread(() -> {\n@@ -318,1 +318,1 @@\n-                }, \"Unreferenced-\" + nextThreadNum++, false, true).run().start();\n+                }, \"Unreferenced-\" + nextThreadNum++, false).start();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/Target.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.rmi.runtime.NewThreadAction;\n@@ -404,3 +403,3 @@\n-        Thread t = new NewThreadAction(ConnectionAcceptor.this,\n-                                       \"TCPChannel Accept-\" + ++ threadNum,\n-                                       true).run();\n+        Thread t = RuntimeUtil.newSystemThread(ConnectionAcceptor.this,\n+                                               \"TCPChannel Accept-\" + ++ threadNum,\n+                                               true);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPChannel.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import sun.rmi.runtime.NewThreadAction;\n+import sun.rmi.runtime.RuntimeUtil;\n@@ -755,1 +755,1 @@\n-            Thread t = new NewThreadAction(FQDN.this, \"FQDN Finder\", true).run();\n+            Thread t = RuntimeUtil.newSystemThread(FQDN.this, \"FQDN Finder\", true);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPEndpoint.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-import sun.rmi.runtime.NewThreadAction;\n+import sun.rmi.runtime.RuntimeUtil;\n@@ -106,2 +106,1 @@\n-                    return new NewThreadAction(\n-                        runnable, \"TCP Connection(idle)\", true, true).run();\n+                    return RuntimeUtil.newUserThread(runnable, \"TCP Connection(idle)\", true);\n@@ -311,2 +310,2 @@\n-                Thread t = new NewThreadAction(new AcceptLoop(server),\n-                                        \"TCP Accept-\" + port, true).run();\n+                Thread t = RuntimeUtil.newSystemThread(\n+                    new AcceptLoop(server), \"TCP Accept-\" + port, true);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-            throw new IllegalArgumentException(e.getMessage());\n+            throw new IllegalArgumentException(\"key creation error\", e);\n","filename":"src\/java.security.jgss\/share\/classes\/javax\/security\/auth\/kerberos\/KeyImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.HashMap;\n@@ -67,1 +66,1 @@\n-    private static final HashMap<String, String> MECH_MAP = constructMechMap();\n+    private static final Oid[] MECH_OIDS = getMechOIDs();\n@@ -70,1 +69,1 @@\n-    private static HashMap<String, String> constructMechMap() {\n+    private static Oid[] getMechOIDs() {\n@@ -115,4 +114,3 @@\n-                 HashMap<String, String> map = new HashMap<>();\n-                 for (int i = 0; i < mechs.length; i++) {\n-                     if (DEBUG) {\n-                         debug(\"Native MF for \" + mechs[i]);\n+                 if (DEBUG) {\n+                     for (Oid mech : mechs) {\n+                         debug(\"Native MF for \" + mech);\n@@ -120,1 +118,0 @@\n-                     map.put(\"GssApiMechanism.\" + mechs[i], MF_CLASS);\n@@ -122,1 +119,1 @@\n-                 return map;\n+                 return mechs;\n@@ -128,1 +125,1 @@\n-    \/\/ initialize INSTANCE after MECH_MAP is constructed\n+    \/\/ initialize INSTANCE after MECH_OIDS is constructed\n@@ -135,2 +132,5 @@\n-        if (MECH_MAP != null) {\n-            putAll(MECH_MAP);\n+        if (MECH_OIDS != null) {\n+            for (Oid mech : MECH_OIDS) {\n+                putService(new Service(this, \"GssApiMechanism\",\n+                        mech.toString(), MF_CLASS, null, null));\n+            }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                SecurityProperties.privilegedGetOverridable(\n+                SecurityProperties.getOverridableProperty(\n@@ -85,1 +85,1 @@\n-                SecurityProperties.privilegedGetOverridable(\n+                SecurityProperties.getOverridableProperty(\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Config.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-            = \"true\".equalsIgnoreCase(SecurityProperties.privilegedGetOverridable(\n+            = \"true\".equalsIgnoreCase(SecurityProperties.getOverridableProperty(\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Credentials.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-    public static final int TGS_DEFAULT_NT = KRB_NT_SRV_INST;\n@@ -110,1 +109,0 @@\n-    public static final String REALM_COMPONENT_SEPARATOR_STR = \".\";\n@@ -114,1 +112,1 @@\n-                    SecurityProperties.privilegedGetOverridable(\n+                    SecurityProperties.getOverridableProperty(\n@@ -138,6 +136,0 @@\n-    \/**\n-     * When constructing a PrincipalName, whether the realm is included in\n-     * the input, or deduced from default realm or domain-realm mapping.\n-     *\/\n-    private final boolean realmDeduced;\n-\n@@ -164,1 +156,0 @@\n-        this.realmDeduced = false;\n@@ -254,1 +245,0 @@\n-        realmDeduced = false;\n@@ -408,3 +398,0 @@\n-        \/\/ No realm info from parameter and string, must deduce later\n-        realmDeduced = realm == null;\n-\n@@ -440,2 +427,2 @@\n-                    } catch (UnknownHostException | SecurityException e) {\n-                        \/\/ not canonicalized or no permission to do so, use old\n+                    } catch (UnknownHostException e) {\n+                        \/\/ not canonicalized, use old\n@@ -729,4 +716,0 @@\n-\n-    public boolean isRealmDeduced() {\n-        return realmDeduced;\n-    }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/PrincipalName.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-    public static final boolean AUTODEDUCEREALM =\n-            Boolean.getBoolean(\"sun.security.krb5.autodeducerealm\");\n-\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Realm.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-        String prop = SecurityProperties.privilegedGetOverridable(\n+        String prop = SecurityProperties.getOverridableProperty(\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/ccache\/FileCredentialsCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,0 @@\n-        } catch (Exception e) {\n-            return null;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/crypto\/dk\/AesDkCrypto.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,2 +114,0 @@\n-        } catch (Exception e) {\n-            return null;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/crypto\/dk\/AesSha2DkCrypto.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,2 +92,0 @@\n-        } catch (Exception e) {\n-            return null;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/crypto\/dk\/ArcFourCrypto.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1895,1 +1895,1 @@\n-     * <code>java.lang.BigDecimal<\/code> value.  The driver converts this to\n+     * <code>java.math.BigDecimal<\/code> value.  The driver converts this to\n","filename":"src\/java.sql.rowset\/share\/classes\/javax\/sql\/rowset\/BaseRowSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-algorithm.classDoesNotExist = Kann URI {0} nicht fr Klasse {1} registrieren weil sie nicht existiert\n+algorithm.classDoesNotExist = Kann URI {0} nicht f\\u00fcr Klasse {1} registrieren weil sie nicht existiert\n@@ -25,4 +25,4 @@\n-algorithm.extendsWrongClass = Kann URI {0} nicht fr Klasse {1} registrieren weil sie nicht von {2} abgeleitet ist\n-algorithms.CannotUseAlgorithmParameterSpecOnDSA = AlgorithmParameterSpec kann nicht fr DSA Signaturen benutzt werden.\n-algorithms.CannotUseAlgorithmParameterSpecOnRSA = AlgorithmParameterSpec kann nicht fr RSA Signaturen benutzt werden.\n-algorithms.CannotUseSecureRandomOnMAC = SecureRandom kann nicht fr MAC's angewandt werden.\n+algorithm.extendsWrongClass = Kann URI {0} nicht f\\u00fcr Klasse {1} registrieren weil sie nicht von {2} abgeleitet ist\n+algorithms.CannotUseAlgorithmParameterSpecOnDSA = AlgorithmParameterSpec kann nicht f\\u00fcr DSA Signaturen benutzt werden.\n+algorithms.CannotUseAlgorithmParameterSpecOnRSA = AlgorithmParameterSpec kann nicht f\\u00fcr RSA Signaturen benutzt werden.\n+algorithms.CannotUseSecureRandomOnMAC = SecureRandom kann nicht f\\u00fcr MAC's angewandt werden.\n@@ -31,1 +31,1 @@\n-algorithms.HMACOutputLengthOnlyForHMAC = Die HMACOutputLength kann nur bei HMAC integritts Algorithmen angegeben werden\n+algorithms.HMACOutputLengthOnlyForHMAC = Die HMACOutputLength kann nur bei HMAC integrit\\u00e4ts Algorithmen angegeben werden\n@@ -33,2 +33,2 @@\n-algorithms.NoSuchAlgorithm = Der Algorithmus {0} ist nicht verfgbar.\n-algorithms.NoSuchAlgorithm = Der Algorithmus {0} ist nicht verfgbar. Original Nachricht war\\: {1}\n+algorithms.NoSuchAlgorithm = Der Algorithmus {0} ist nicht verf\\u00fcgbar.\n+algorithms.NoSuchAlgorithm = Der Algorithmus {0} ist nicht verf\\u00fcgbar. Original Nachricht war\\: {1}\n@@ -37,2 +37,2 @@\n-algorithms.operationOnlyVerification = Ein ffentlicher Schlssel (public key) kann nur zur Verifizierung einer Signatur verwendet werden.\n-algorithms.WrongKeyForThisOperation = Der angegebene Schlssel-Typ kann nicht fr diese Operation verwendet werden. Angegeben wurde {0} aber ein {1} wird bentigt.\n+algorithms.operationOnlyVerification = Ein \\u00f6ffentlicher Schl\\u00fcssel (public key) kann nur zur Verifizierung einer Signatur verwendet werden.\n+algorithms.WrongKeyForThisOperation = Der angegebene Schl\\u00fcssel-Typ kann nicht f\\u00fcr diese Operation verwendet werden. Angegeben wurde {0} aber ein {1} wird ben\\u00f6tigt.\n@@ -40,2 +40,2 @@\n-c14n.Canonicalizer.Exception = Fehler whrend der Kanonisierung\\:  Original Nachricht war {0}\n-c14n.Canonicalizer.IllegalNode = Unzulssiger NodeType {0}, NodeName lautete {1}\n+c14n.Canonicalizer.Exception = Fehler w\\u00e4hrend der Kanonisierung\\:  Original Nachricht war {0}\n+c14n.Canonicalizer.IllegalNode = Unzul\\u00e4ssiger NodeType {0}, NodeName lautete {1}\n@@ -43,1 +43,1 @@\n-c14n.Canonicalizer.ParserConfigurationException = ParserConfigurationException whrend der Kanonisierung\\:  Original Nachricht war {0}\n+c14n.Canonicalizer.ParserConfigurationException = ParserConfigurationException w\\u00e4hrend der Kanonisierung\\:  Original Nachricht war {0}\n@@ -45,5 +45,5 @@\n-c14n.Canonicalizer.SAXException = SAXException whrend der Kanonisierung\\:  Original Nachricht war {0}\n-c14n.Canonicalizer.TraversalNotSupported = Das DOM Dokument untersttzt keine Traversal {0}\n-c14n.Canonicalizer.UnsupportedEncoding = Nicht untersttzte Kodierung {0}\n-c14n.Canonicalizer.UnsupportedOperation = Der Kanonisierer untersttzt diese Operation nicht\n-c14n.XMLUtils.circumventBug2650forgotten = Die Baumstruktur wurde nicht vorbereitet fr die Kanonisierung mit XMLUtils\\#circumventBug2650(Document)\n+c14n.Canonicalizer.SAXException = SAXException w\\u00e4hrend der Kanonisierung\\:  Original Nachricht war {0}\n+c14n.Canonicalizer.TraversalNotSupported = Das DOM Dokument unterst\\u00fctzt keine Traversal {0}\n+c14n.Canonicalizer.UnsupportedEncoding = Nicht unterst\\u00fctzte Kodierung {0}\n+c14n.Canonicalizer.UnsupportedOperation = Der Kanonisierer unterst\\u00fctzt diese Operation nicht\n+c14n.XMLUtils.circumventBug2650forgotten = Die Baumstruktur wurde nicht vorbereitet f\\u00fcr die Kanonisierung mit XMLUtils\\#circumventBug2650(Document)\n@@ -52,1 +52,1 @@\n-certificate.noSki.null = Das Zertifikat enthlt kein SubjectKeyIdentifier\n+certificate.noSki.null = Das Zertifikat enth\\u00e4lt kein SubjectKeyIdentifier\n@@ -60,2 +60,2 @@\n-encryption.ExplicitKeySizeMismatch = Das xenc\\:KeySize Element fordert eine Schlssel-Lnge von {0} bits aber der Algorithmus besitzt {1} bits\n-encryption.nonceLongerThanDecryptedPlaintext = Das angegebene \"Nonce\" ist lnger als der verfgbare Plaintext.\n+encryption.ExplicitKeySizeMismatch = Das xenc\\:KeySize Element fordert eine Schl\\u00fcssel-L\\u00e4nge von {0} bits aber der Algorithmus besitzt {1} bits\n+encryption.nonceLongerThanDecryptedPlaintext = Das angegebene \"Nonce\" ist l\\u00e4nger als der verf\\u00fcgbare Plaintext.\n@@ -68,4 +68,4 @@\n-encryption.nokey = Es ist kein verschlsselungs Schlssel geladen und es konnte kein Schlssel mit Hilfe der \"key resolvers\" gefunden werden.\n-endorsed.jdk1.4.0 = Leider scheint niemand unsere Installations-Anleitung zu lesen, deshalb mssen wir es ber die Exception machen\\: Du hast den \"endorsing\" Mechanismus vom JDK 1.4 nicht richtig angewandt. Schaue unter <http\\:\/\/xml.apache.org\/security\/Java\/installation.html> nach wie man das Problem lst.\n-errorMessages.InvalidDigestValueException = Ungltige Signatur\\: Referen-Validierung fehlgeschlagen.\n-errorMessages.InvalidSignatureValueException = Ungltige Signatur\\: Core Validierung fehlgeschlagen.\n+encryption.nokey = Es ist kein verschl\\u00fcsselungs Schl\\u00fcssel geladen und es konnte kein Schl\\u00fcssel mit Hilfe der \"key resolvers\" gefunden werden.\n+endorsed.jdk1.4.0 = Leider scheint niemand unsere Installations-Anleitung zu lesen, deshalb m\\u00fcssen wir es \\u00fcber die Exception machen\\: Du hast den \"endorsing\" Mechanismus vom JDK 1.4 nicht richtig angewandt. Schaue unter <http\\:\/\/xml.apache.org\/security\/Java\/installation.html> nach wie man das Problem l\\u00f6st.\n+errorMessages.InvalidDigestValueException = Ung\\u00fcltige Signatur\\: Referen-Validierung fehlgeschlagen.\n+errorMessages.InvalidSignatureValueException = Ung\\u00fcltige Signatur\\: Core Validierung fehlgeschlagen.\n@@ -73,2 +73,2 @@\n-errorMessages.MissingKeyFailureException = Verifizierung fehlgeschlagen, weil der ffentliche Schlssel (public key) nicht verfgbar ist. Resourcen via addResource() hinzufgen und erneut versuchen.\n-errorMessages.MissingResourceFailureException = Verifizierung fehlgeschlagen, weil Resourcen nicht verfgbar sind. Resourcen via addResource() hinzufgen und erneut versuchen.\n+errorMessages.MissingKeyFailureException = Verifizierung fehlgeschlagen, weil der \\u00f6ffentliche Schl\\u00fcssel (public key) nicht verf\\u00fcgbar ist. Resourcen via addResource() hinzuf\\u00fcgen und erneut versuchen.\n+errorMessages.MissingResourceFailureException = Verifizierung fehlgeschlagen, weil Resourcen nicht verf\\u00fcgbar sind. Resourcen via addResource() hinzuf\\u00fcgen und erneut versuchen.\n@@ -76,1 +76,1 @@\n-errorMessages.NotYetImplementedException = Funktionalitt noch nicht implementiert.\n+errorMessages.NotYetImplementedException = Funktionalit\\u00e4t noch nicht implementiert.\n@@ -87,3 +87,3 @@\n-java.security.InvalidKeyException = Ungltiger Schlssel\n-java.security.NoSuchProviderException = Unbekannter oder nicht untersttzter Provider\n-java.security.UnknownKeyType = Unbekannter oder nicht untersttzter Schlssel-Typ {0}\n+java.security.InvalidKeyException = Ung\\u00fcltiger Schl\\u00fcssel\n+java.security.NoSuchProviderException = Unbekannter oder nicht unterst\\u00fctzter Provider\n+java.security.UnknownKeyType = Unbekannter oder nicht unterst\\u00fctzter Schl\\u00fcssel-Typ {0}\n@@ -91,4 +91,4 @@\n-KeyInfo.needKeyResolver = Es mssen mehrere KeyResolver registriert sein\n-KeyInfo.nokey = Kann keinen Schlssel aus {0} gewinnen\n-KeyInfo.noKey = Kann keinen ffentlichen Schlssel finden\n-KeyInfo.wrongNumberOfObject = Bentige {0} keyObjects\n+KeyInfo.needKeyResolver = Es m\\u00fcssen mehrere KeyResolver registriert sein\n+KeyInfo.nokey = Kann keinen Schl\\u00fcssel aus {0} gewinnen\n+KeyInfo.noKey = Kann keinen \\u00f6ffentlichen Schl\\u00fcssel finden\n+KeyInfo.wrongNumberOfObject = Ben\\u00f6tige {0} keyObjects\n@@ -96,2 +96,2 @@\n-keyResolver.alreadyRegistered = Die Klasse {1} wurde bereits registriert fr {0}\n-KeyResolver.needStorageResolver = Es wird ein StorageResolver bentigt um ein Zertifikat aus {0} zu holen\n+keyResolver.alreadyRegistered = Die Klasse {1} wurde bereits registriert f\\u00fcr {0}\n+KeyResolver.needStorageResolver = Es wird ein StorageResolver ben\\u00f6tigt um ein Zertifikat aus {0} zu holen\n@@ -103,1 +103,1 @@\n-KeyResoverSpiImpl.need.Element = Es wird der Typ {1} bentigt in der implementierenden Klasse {0}\n+KeyResoverSpiImpl.need.Element = Es wird der Typ {1} ben\\u00f6tigt in der implementierenden Klasse {0}\n@@ -107,1 +107,1 @@\n-KeyStore.alreadyRegistered = Klasse {0} bereits registriert fr {1}\n+KeyStore.alreadyRegistered = Klasse {0} bereits registriert f\\u00fcr {1}\n@@ -109,1 +109,1 @@\n-KeyStore.registerStore.register = Registrierungsfehler fr Typ {0}\n+KeyStore.registerStore.register = Registrierungsfehler f\\u00fcr Typ {0}\n@@ -114,2 +114,2 @@\n-signature.Canonicalizer.UnknownCanonicalizer = Unbekannter Kanonisierer. Kein Handler installiert fr URI {0}\n-signature.DSA.invalidFormat = Ungltige ASN.1 Kodierung der DSA Signatur\n+signature.Canonicalizer.UnknownCanonicalizer = Unbekannter Kanonisierer. Kein Handler installiert f\\u00fcr URI {0}\n+signature.DSA.invalidFormat = Ung\\u00fcltige ASN.1 Kodierung der DSA Signatur\n@@ -122,3 +122,3 @@\n-signature.tooManyReferences = Das Manifest enthlt {0} Referenzen, bei aktivierter \"secure validation\" sind aber maximal {1} erlaubt\n-signature.tooManyTransforms = Die Referenz enthlt {0} Transformationen, bei aktivierter \"secure validation\" sind aber maximal {1} erlaubt\n-signature.Transform.ErrorDuringTransform = Whrend der Transformation {0} trat eine {1} auf.\n+signature.tooManyReferences = Das Manifest enth\\u00e4lt {0} Referenzen, bei aktivierter \"secure validation\" sind aber maximal {1} erlaubt\n+signature.tooManyTransforms = Die Referenz enth\\u00e4lt {0} Transformationen, bei aktivierter \"secure validation\" sind aber maximal {1} erlaubt\n+signature.Transform.ErrorDuringTransform = W\\u00e4hrend der Transformation {0} trat eine {1} auf.\n@@ -127,2 +127,2 @@\n-signature.Transform.NullPointerTransform = Null pointer als URI bergeben. Programmierfehler?\n-signature.Transform.UnknownTransform = Unbekannte Transformation. Kein Handler installiert fr URI {0}\n+signature.Transform.NullPointerTransform = Null pointer als URI \\u00fcbergeben. Programmierfehler?\n+signature.Transform.UnknownTransform = Unbekannte Transformation. Kein Handler installiert f\\u00fcr URI {0}\n@@ -135,1 +135,1 @@\n-signature.Verification.InvalidDigestOrReference = Ungltiger Digest Wert der Referenz {0}\n+signature.Verification.InvalidDigestOrReference = Ung\\u00fcltiger Digest Wert der Referenz {0}\n@@ -137,1 +137,1 @@\n-signature.Verification.keyStore = ffnen des KeyStore fehlgeschlagen\n+signature.Verification.keyStore = \\u00d6ffnen des KeyStore fehlgeschlagen\n@@ -139,1 +139,1 @@\n-signature.Verification.MissingResources = Kann die externe Resource {0} nicht auflsen\n+signature.Verification.MissingResources = Kann die externe Resource {0} nicht aufl\\u00f6sen\n@@ -141,2 +141,2 @@\n-signature.Verification.NoSignatureElement = Input Dokument enthlt kein {0} Element mit dem Namespace {1}\n-signature.Verification.Reference.NoInput = Die Referenz fr den URI {0} hat keinen XMLSignatureInput erhalten.\n+signature.Verification.NoSignatureElement = Input Dokument enth\\u00e4lt kein {0} Element mit dem Namespace {1}\n+signature.Verification.Reference.NoInput = Die Referenz f\\u00fcr den URI {0} hat keinen XMLSignatureInput erhalten.\n@@ -146,1 +146,1 @@\n-transform.Init.IllegalContextArgument = Unzulssiges Kontext Argument der Klasse {0}. Muss String, org.w3c.dom.NodeList oder java.io.InputStream sein.\n+transform.Init.IllegalContextArgument = Unzul\\u00e4ssiges Kontext Argument der Klasse {0}. Muss String, org.w3c.dom.NodeList oder java.io.InputStream sein.\n@@ -149,2 +149,2 @@\n-utils.Base64.IllegalBitlength = Ungltige Byte-Lnge; Muss ein vielfaches von 4 sein\n-utils.resolver.noClass = Keinen Resolver fr URI {0} und Base {1} gefunden\n+utils.Base64.IllegalBitlength = Ung\\u00fcltige Byte-L\\u00e4nge; Muss ein vielfaches von 4 sein\n+utils.resolver.noClass = Keinen Resolver f\\u00fcr URI {0} und Base {1} gefunden\n@@ -160,6 +160,6 @@\n-secureProcessing.MaximumAllowedTransformsPerReference = Die Referenz enthlt {0} Transformationen. Es sind aber maximal {1} erlaubt. Die Limite kann ber das Konfigurations-Property \"MaximumAllowedTransformsPerReference\" erhht werden.\n-secureProcessing.MaximumAllowedReferencesPerManifest = Das Manifest enhlt {0} Referenzen. Es sind aber maximal {1} erlaubt. Die Limite kann ber das Konfigurations-Property \"MaximumAllowedReferencesPerManifest\" erhht werden.\n-secureProcessing.DoNotThrowExceptionForManifests = Signatur-Manifests werden nicht untersttzt. Das werfen dieser Exception kann durch das Konfigurations-Property \"DoNotThrowExceptionForManifests\" verhindert werden.\n-secureProcessing.AllowMD5Algorithm = Vom Einsatz des MD5 Algorithmus wird strengstens abgeraten. Trotzdem kann er ber das Konfigurations-Property \"AllowMD5Algorithm\" erlaubt werden.\n-secureProcessing.AllowNotSameDocumentReferences = Externe Referenzen gefunden. Die Verarbeitung von externen Referenzen ist standardmssig ausgeschaltet. Es kann ber das Konfigurations-Property \"AllowNotSameDocumentReferences\" aktiviert werden.\n-secureProcessing.MaximumAllowedXMLStructureDepth = Die Maximum erlaubte Dokumenten-Tiefe von ({0}) wurde erreicht. Die Limite kann ber das Konfigurations-Property \"MaximumAllowedXMLStructureDepth\" erhht werden.\n+secureProcessing.MaximumAllowedTransformsPerReference = Die Referenz enth\\u00e4lt {0} Transformationen. Es sind aber maximal {1} erlaubt. Die Limite kann \\u00fcber das Konfigurations-Property \"MaximumAllowedTransformsPerReference\" erh\\u00f6ht werden.\n+secureProcessing.MaximumAllowedReferencesPerManifest = Das Manifest enh\\u00e4lt {0} Referenzen. Es sind aber maximal {1} erlaubt. Die Limite kann \\u00fcber das Konfigurations-Property \"MaximumAllowedReferencesPerManifest\" erh\\u00f6ht werden.\n+secureProcessing.DoNotThrowExceptionForManifests = Signatur-Manifests werden nicht unterst\\u00fctzt. Das werfen dieser Exception kann durch das Konfigurations-Property \"DoNotThrowExceptionForManifests\" verhindert werden.\n+secureProcessing.AllowMD5Algorithm = Vom Einsatz des MD5 Algorithmus wird strengstens abgeraten. Trotzdem kann er \\u00fcber das Konfigurations-Property \"AllowMD5Algorithm\" erlaubt werden.\n+secureProcessing.AllowNotSameDocumentReferences = Externe Referenzen gefunden. Die Verarbeitung von externen Referenzen ist standardm\\u00e4ssig ausgeschaltet. Es kann \\u00fcber das Konfigurations-Property \"AllowNotSameDocumentReferences\" aktiviert werden.\n+secureProcessing.MaximumAllowedXMLStructureDepth = Die Maximum erlaubte Dokumenten-Tiefe von ({0}) wurde erreicht. Die Limite kann \\u00fcber das Konfigurations-Property \"MaximumAllowedXMLStructureDepth\" erh\\u00f6ht werden.\n@@ -170,5 +170,5 @@\n-stax.noKey = Kein Schlssel geladen und es konnte kein Schlssel gefunden werden fr {0}\n-stax.keyNotFound = Schlssel nicht gefunden.\n-stax.unsupportedKeyValue = Kein oder ungltiger KeyValue.\n-stax.emptyReferenceURI = Referenz enthlt kein URI Attribut.\n-stax.encryption.unprocessedReferences = Es wurden nicht alle Verschlsselungs-Referenzen verarbeitet...\n+stax.noKey = Kein Schl\\u00fcssel geladen und es konnte kein Schl\\u00fcssel gefunden werden f\\u00fcr {0}\n+stax.keyNotFound = Schl\\u00fcssel nicht gefunden.\n+stax.unsupportedKeyValue = Kein oder ung\\u00fcltiger KeyValue.\n+stax.emptyReferenceURI = Referenz enth\\u00e4lt kein URI Attribut.\n+stax.encryption.unprocessedReferences = Es wurden nicht alle Verschl\\u00fcsselungs-Referenzen verarbeitet...\n@@ -176,1 +176,1 @@\n-stax.unsupportedToken = {0} nicht untersttzt.\n+stax.unsupportedToken = {0} nicht unterst\\u00fctzt.\n@@ -179,2 +179,2 @@\n-stax.encryption.noEncAlgo = xenc\\:EncryptedKey enthlt kein xenc\\:EncryptionMethod\/@Algorithm.\n-stax.encryption.noCipherValue = EncryptedKey enthlt kein xenc\\:CipherData\/xenc\\:CipherValue.\n+stax.encryption.noEncAlgo = xenc\\:EncryptedKey enth\\u00e4lt kein xenc\\:EncryptionMethod\/@Algorithm.\n+stax.encryption.noCipherValue = EncryptedKey enth\\u00e4lt kein xenc\\:CipherData\/xenc\\:CipherValue.\n@@ -187,4 +187,4 @@\n-stax.encryption.encryptionKeyMissing = Kein Schlssel fr die Verschlsselung wurde konfiguriert.\n-stax.unsupportedKeyTransp = Der public-key Algorithmus ist zu kurz um den symmetrischen Schlssel zu verschlsseln.\n-stax.recursiveKeyReference = Rekursive Schlssel referenzierung detektiert.\n-stax.ecParametersNotSupported = ECParameters werden nicht untersttzt.\n+stax.encryption.encryptionKeyMissing = Kein Schl\\u00fcssel f\\u00fcr die Verschl\\u00fcsselung wurde konfiguriert.\n+stax.unsupportedKeyTransp = Der public-key Algorithmus ist zu kurz um den symmetrischen Schl\\u00fcssel zu verschl\\u00fcsseln.\n+stax.recursiveKeyReference = Rekursive Schl\\u00fcssel referenzierung detektiert.\n+stax.ecParametersNotSupported = ECParameters werden nicht unterst\\u00fctzt.\n@@ -192,1 +192,1 @@\n-stax.encryption.securePartNotFound = Part zum Verschlsseln nicht gefunden: {0}\n+stax.encryption.securePartNotFound = Part zum Verschl\\u00fcsseln nicht gefunden: {0}\n@@ -196,2 +196,2 @@\n-stax.keyNotFoundForName = Kein Schlssel fr Schlsselname konfiguriert: {0}\n-stax.keyTypeNotSupported = Key vom Typ {0} nicht fr einen Key-Namenssuche untersttzt\n+stax.keyNotFoundForName = Kein Schl\\u00fcssel fr Schl\\u00fcsselname konfiguriert: {0}\n+stax.keyTypeNotSupported = Key vom Typ {0} nicht f\\u00fcr einen Key-Namenssuche unterst\\u00fctzt\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/xmlsecurity_de.properties","additions":76,"deletions":76,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @LastModified: May 2022\n+ * @LastModified: Dec 2024\n@@ -1200,1 +1200,4 @@\n-          \"Use of the extension element ''{0}'' is not allowed when the secure processing feature is set to true.\"},\n+        \"Use of the extension function ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/res\/XSLTErrorResources.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n- * @LastModified: Nov 2017\n+ * @LastModified: Dec 2024\n@@ -961,1 +961,1 @@\n-    private List<Method> findMethods() {\n+    private List<Method> findMethods() throws TypeCheckError {\n@@ -963,2 +963,2 @@\n-          List<Method> result = null;\n-          final String namespace = _fname.getNamespace();\n+        List<Method> result = null;\n+        final String namespace = _fname.getNamespace();\n@@ -966,1 +966,1 @@\n-          if (_className != null && _className.length() > 0) {\n+        if (_className != null && _className.length() > 0) {\n@@ -974,8 +974,13 @@\n-                    \/\/Check if FSP and SM - only then process with loading\n-                    if (namespace != null && isSecureProcessing\n-                            && isExtensionFunctionEnabled\n-                            && (namespace.startsWith(JAVA_EXT_XALAN)\n-                            || namespace.startsWith(JAVA_EXT_XSLTC)\n-                            || namespace.startsWith(JAVA_EXT_XALAN_OLD)\n-                            || namespace.startsWith(XALAN_CLASSPACKAGE_NAMESPACE))) {\n-                        _clazz = getXSLTC().loadExternalFunction(_className);\n+                    \/\/ the property has the precedence\n+                    if (isExtensionFunctionEnabled) {\n+                        if (getXSLTC().hasExtensionClassLoader()) {\n+                            _clazz = getXSLTC().loadExternalFunction(_className);\n+                        } else {\n+                            _clazz = ObjectFactory.findProviderClass(_className, true);\n+                        }\n+                        if (_clazz == null) {\n+                            final ErrorMsg msg\n+                                    = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n+                            getParser().reportError(Constants.ERROR, msg);\n+                            return null;\n+                        }\n@@ -983,1 +988,1 @@\n-                        _clazz = ObjectFactory.findProviderClass(_className, true);\n+                        throw new TypeCheckError(ErrorMsg.UNSUPPORTED_EXT_FUNC_ERR, _className);\n@@ -985,5 +990,0 @@\n-\n-                if (_clazz == null) {\n-                  final ErrorMsg msg =\n-                        new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n-                  getParser().reportError(Constants.ERROR, msg);\n@@ -991,16 +991,15 @@\n-              }\n-\n-              final String methodName = _fname.getLocalPart();\n-              final Method[] methods = _clazz.getMethods();\n-\n-              for (int i = 0; i < methods.length; i++) {\n-                final int mods = methods[i].getModifiers();\n-                \/\/ Is it public and same number of args ?\n-                if (Modifier.isPublic(mods)\n-                    && methods[i].getName().equals(methodName)\n-                    && methods[i].getParameterTypes().length == nArgs)\n-                {\n-                  if (result == null) {\n-                    result = new ArrayList<>();\n-                  }\n-                  result.add(methods[i]);\n+\n+                final String methodName = _fname.getLocalPart();\n+                final Method[] methods = _clazz.getMethods();\n+\n+                for (int i = 0; i < methods.length; i++) {\n+                    final int mods = methods[i].getModifiers();\n+                    \/\/ Is it public and same number of args ?\n+                    if (Modifier.isPublic(mods)\n+                            && methods[i].getName().equals(methodName)\n+                            && methods[i].getParameterTypes().length == nArgs) {\n+                        if (result == null) {\n+                            result = new ArrayList<>();\n+                        }\n+                        result.add(methods[i]);\n+                    }\n@@ -1008,5 +1007,3 @@\n-              }\n-            }\n-            catch (ClassNotFoundException e) {\n-                  final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n-                  getParser().reportError(Constants.ERROR, msg);\n+            } catch (ClassNotFoundException e) {\n+                final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);\n+                getParser().reportError(Constants.ERROR, msg);\n@@ -1014,2 +1011,2 @@\n-          }\n-          return result;\n+        }\n+        return result;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/FunctionCall.java","additions":40,"deletions":43,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @LastModified: Jan 2022\n+ * @LastModified: Dec 2024\n@@ -294,0 +294,4 @@\n+    boolean hasExtensionClassLoader() {\n+        return _extensionClassLoader != null;\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/XSLTC.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @LastModified: Nov 2024\n+ * @LastModified: Dec 2024\n@@ -555,0 +555,9 @@\n+        \/*\n+         * Note to translators:  property name \"jdk.xml.enableExtensionFunctions\"\n+         * and value \"true\" should not be translated.\n+         *\/\n+        {ErrorMsg.UNSUPPORTED_EXT_FUNC_ERR,\n+        \"Use of the extension function ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/util\/ErrorMessages.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @LastModified: Nov 2024\n+ * @LastModified: Dec 2024\n@@ -108,0 +108,1 @@\n+    public static final String UNSUPPORTED_EXT_FUNC_ERR = \"UNSUPPORTED_EXT_FUNC_ERR\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/util\/ErrorMsg.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +27,1 @@\n+ * @LastModified: Dec 2024\n@@ -278,1 +278,4 @@\n-        \"Use of the extension function ''{0}'' is not allowed when the secure processing feature is set to true.\"},\n+        \"Use of the extension function ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n@@ -281,1 +284,4 @@\n-        \"Use of the extension element ''{0}'' is not allowed when the secure processing feature is set to true.\"},\n+        \"Use of the extension element ''{0}'' is not allowed when extension \"\n+              + \"functions are disabled by the secure processing feature or \"\n+              + \"the property ''jdk.xml.enableExtensionFunctions''. \"\n+              + \"To enable extension functions, set ''jdk.xml.enableExtensionFunctions'' to ''true''.\"},\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/runtime\/ErrorMessages.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-import jdk.xml.internal.SecuritySupport;\n@@ -91,1 +90,1 @@\n- * @LastModified: Nov 2024\n+ * @LastModified: Dec 2024\n@@ -219,1 +218,1 @@\n-    private boolean _isNotSecureProcessing = true;\n+    private boolean _isNotSecureProcessing = false;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerFactoryImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Dec 2024\n@@ -209,1 +209,1 @@\n-    private boolean _isSecureProcessing = false;\n+    private boolean _isSecureProcessing = true;\n@@ -295,0 +295,1 @@\n+        _isSecureProcessing = _tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1212,1 +1212,1 @@\n-\n+        boolean resolveByResolver = false;\n@@ -1217,0 +1217,1 @@\n+            resolveByResolver = xmlInputSource != null;\n@@ -1232,1 +1233,2 @@\n-        if (xmlInputSource == null\n+        if ((xmlInputSource == null || (!resolveByResolver && xmlInputSource.getSystemId() != null\n+                && xmlInputSource.getSystemId().equals(literalSystemId)))\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLEntityManager.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                null, null, true, false, true, true),\n+                null, null, false, false, true, true),\n@@ -385,7 +385,1 @@\n-            if (!getSystemProperty(feature, feature.systemProperty())) {\n-                \/\/if system property is not found, try the older form if any\n-                String oldName = feature.systemPropertyOld();\n-                if (oldName != null) {\n-                    getSystemProperty(feature, oldName);\n-                }\n-            }\n+            getSystemProperty(feature, feature.systemProperty());\n@@ -405,0 +399,5 @@\n+            if (value == null && feature.systemPropertyOld() != null) {\n+                \/\/ legacy system property\n+                value = System.getProperty(feature.systemPropertyOld());\n+            }\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkXmlFeatures.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-   Catalog of DTDs for the Java platform\n+   Catalog of DTDs and XSDs for the Java platform and W3C specifications\n@@ -41,0 +41,115 @@\n+    \n+    <!-- W3C DTDs -->\n+    <group id=\"xhtml11\" prefer = \"system\" xml:base = \"w3c\/dtd\/xhtml11\/\">\n+        <system systemId=\"http:\/\/www.w3.org\/TR\/xhtml11\/DTD\/xhtml11.dtd\" uri=\"xhtml11.dtd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-attribs-1.mod\" uri=\"xhtml-attribs-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-base-1.mod\" uri=\"xhtml-base-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-bdo-1.mod\" uri=\"xhtml-bdo-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-blkphras-1.mod\" uri=\"xhtml-blkphras-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-blkpres-1.mod\" uri=\"xhtml-blkpres-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-blkstruct-1.mod\" uri=\"xhtml-blkstruct-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-charent-1.mod\" uri=\"xhtml-charent-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-cicmap-1.mod\" uri=\"xhtml-cicmap-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-csismap-1.mod\" uri=\"xhtml-csismap-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-datatypes-1.mod\" uri=\"xhtml-datatypes-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-edit-1.mod\" uri=\"xhtml-edit-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-events-1.mod\" uri=\"xhtml-events-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-form-1.mod\" uri=\"xhtml-form-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-framework-1.mod\" uri=\"xhtml-framework-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-hypertext-1.mod\" uri=\"xhtml-hypertext-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-image-1.mod\" uri=\"xhtml-image-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlphras-1.mod\" uri=\"xhtml-inlphras-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlpres-1.mod\" uri=\"xhtml-inlpres-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlstruct-1.mod\" uri=\"xhtml-inlstruct-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlstyle-1.mod\" uri=\"xhtml-inlstyle-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-lat1-1.mod\" uri=\"xhtml-lat1-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-link-1.mod\" uri=\"xhtml-link-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-list-1.mod\" uri=\"xhtml-list-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-meta-1.mod\" uri=\"xhtml-meta-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-object-1.mod\" uri=\"xhtml-object-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-param-1.mod\" uri=\"xhtml-param-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-pres-1.mod\" uri=\"xhtml-pres-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-qname-1.mod\" uri=\"xhtml-qname-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-ruby-1.mod\" uri=\"xhtml-ruby-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-script-1.mod\" uri=\"xhtml-script-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-special-1.mod\" uri=\"xhtml-special-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-ssismap-1.mod\" uri=\"xhtml-ssismap-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-struct-1.mod\" uri=\"xhtml-struct-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-style-1.mod\" uri=\"xhtml-style-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-symbol-1.mod\" uri=\"xhtml-symbol-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-table-1.mod\" uri=\"xhtml-table-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-text-1.mod\" uri=\"xhtml-text-1.mod\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml11-model-1.mod\" uri=\"xhtml11-model-1.mod\"\/>\n+    <\/group>\n+    \n+    <group id=\"xhtml1\" prefer = \"system\" xml:base = \"w3c\/dtd\/xhtml10\/\">\n+        <systemSuffix systemIdSuffix=\"xhtml1-strict.dtd\" uri=\"xhtml1-strict.dtd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml1-transitional.dtd\" uri=\"xhtml1-transitional.dtd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml1-frameset.dtd\" uri=\"xhtml1-frameset.dtd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-lat1.ent\" uri=\"xhtml-lat1.ent\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-special.ent\" uri=\"xhtml-special.ent\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-symbol.ent\" uri=\"xhtml-symbol.ent\"\/>\n+    <\/group>\n+\n+    <group id=\"XMLSchema10\" prefer = \"system\" xml:base = \"w3c\/dtd\/schema10\/\">\n+        <systemSuffix systemIdSuffix=\"XMLSchema.dtd\" uri=\"XMLSchema.dtd\"\/>\n+        <systemSuffix systemIdSuffix=\"datatypes.dtd\" uri=\"datatypes.dtd\"\/>\n+        <public publicId=\"datatypes\" uri=\"datatypes.dtd\"\/>\n+        <public publicId=\"-\/\/W3C\/\/DTD XMLSCHEMA 200102\/\/EN\" uri=\"XMLSchema.dtd\"\/>\n+    <\/group>\n+    \n+    <group id=\"xmlspec\" prefer = \"system\" xml:base = \"w3c\/dtd\/\">\n+        <system systemId=\"http:\/\/www.w3.org\/2002\/xmlspec\/dtd\/2.10\/xmlspec.dtd\" uri=\"xmlspec2_10\/xmlspec.dtd\"\/>\n+    <\/group>\n+    \n+    <!-- W3C XSDs -->\n+    <group id=\"w3cxsd\" prefer = \"system\" xml:base = \"w3c\/xsd\/\">\n+        <systemSuffix systemIdSuffix=\"XMLSchema.xsd\" uri=\"schema10\/XMLSchema.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"XMLSchema-datatypes.xsd\" uri=\"schema10\/XMLSchema-datatypes.xsd\"\/>\n+        <system systemId=\"http:\/\/www.w3.org\/2001\/xml.xsd\" uri=\"xmlNS2001\/xml.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"2001\/xml.xsd\" uri=\"xmlNS2001\/xml.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml1-frameset.xsd\" uri=\"xhtml10\/xhtml1-frameset.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml1-strict.xsd\" uri=\"xhtml10\/xhtml1-strict.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml1-transitional.xsd\" uri=\"xhtml10\/xhtml1-transitional.xsd\"\/>\n+    <\/group>\n+    <group id=\"xhtml11xsd\" prefer = \"system\" xml:base = \"w3c\/xsd\/xhtml11\/\">\n+        <systemSuffix systemIdSuffix=\"xhtml11.xsd\" uri=\"xhtml11.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-attribs-1.xsd\" uri=\"xhtml-attribs-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-base-1.xsd\" uri=\"xhtml-base-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-bdo-1.xsd\" uri=\"xhtml-bdo-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-blkphras-1.xsd\" uri=\"xhtml-blkphras-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-blkpres-1.xsd\" uri=\"xhtml-blkpres-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-blkstruct-1.xsd\" uri=\"xhtml-blkstruct-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-copyright-1.xsd\" uri=\"xhtml-copyright-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-csismap-1.xsd\" uri=\"xhtml-csismap-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-datatypes-1.xsd\" uri=\"xhtml-datatypes-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-edit-1.xsd\" uri=\"xhtml-edit-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-events-1.xsd\" uri=\"xhtml-events-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-form-1.xsd\" uri=\"xhtml-form-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-framework-1.xsd\" uri=\"xhtml-framework-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-hypertext-1.xsd\" uri=\"xhtml-hypertext-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-image-1.xsd\" uri=\"xhtml-image-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlphras-1.xsd\" uri=\"xhtml-inlphras-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlpres-1.xsd\" uri=\"xhtml-inlpres-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlstruct-1.xsd\" uri=\"xhtml-inlstruct-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-inlstyle-1.xsd\" uri=\"xhtml-inlstyle-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-link-1.xsd\" uri=\"xhtml-link-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-list-1.xsd\" uri=\"xhtml-list-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-meta-1.xsd\" uri=\"xhtml-meta-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-notations-1.xsd\" uri=\"xhtml-notations-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-object-1.xsd\" uri=\"xhtml-object-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-param-1.xsd\" uri=\"xhtml-param-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-pres-1.xsd\" uri=\"xhtml-pres-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-ruby-1.xsd\" uri=\"xhtml-ruby-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-script-1.xsd\" uri=\"xhtml-script-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-ssismap-1.xsd\" uri=\"xhtml-ssismap-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-struct-1.xsd\" uri=\"xhtml-struct-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-style-1.xsd\" uri=\"xhtml-style-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-table-1.xsd\" uri=\"xhtml-table-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-target-1.xsd\" uri=\"xhtml-target-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml-text-1.xsd\" uri=\"xhtml-text-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml11-model-1.xsd\" uri=\"xhtml11-model-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xhtml11-modules-1.xsd\" uri=\"xhtml11-modules-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xml-events-1.xsd\" uri=\"xml-events-1.xsd\"\/>\n+        <systemSuffix systemIdSuffix=\"xml-events-copyright-1.xsd\" uri=\"xml-events-copyright-1.xsd\"\/>\n+    <\/group>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/JDKCatalog.xml","additions":117,"deletions":2,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,513 @@\n+<!-- DTD for XML Schema Definition Language Part 1: Structures\n+     Public Identifier: \"-\/\/W3C\/\/DTD XSD 1.1\/\/EN\"\n+     Official Location: http:\/\/www.w3.org\/2009\/XMLSchema\/XMLSchema.dtd -->\n+<!-- Id: structures.dtd,v 1.1 2003\/08\/28 13:30:52 ht Exp  -->\n+<!-- With the exception of cases with multiple namespace\n+     prefixes for the XSD namespace, any XML document which is\n+     not valid per this DTD given redefinitions in its internal subset of the\n+     'p' and 's' parameter entities below appropriate to its namespace\n+     declaration of the XSD namespace is almost certainly not\n+     a valid schema document. -->\n+\n+<!-- See below (at the bottom of this document) for information about\n+      the revision and namespace-versioning policy governing this DTD. -->\n+<!-- The simpleType element and its constituent parts\n+     are defined in XML Schema Definition Language Part 2: Datatypes -->\n+<!ENTITY % xs-datatypes PUBLIC '-\/\/W3C\/\/DTD XSD 1.1 Datatypes\/\/EN' 'datatypes.dtd' >\n+\n+<!ENTITY % p 'xs:'> <!-- can be overridden in the internal subset of a\n+                         schema document to establish a different\n+                         namespace prefix -->\n+<!ENTITY % s ':xs'> <!-- if %p is defined (e.g. as foo:) then you must\n+                         also define %s as the suffix for the appropriate\n+                         namespace declaration (e.g. :foo) -->\n+<!ENTITY % nds 'xmlns%s;'>\n+\n+<!-- Define all the element names, with optional prefix -->\n+<!ENTITY % schema \"%p;schema\">\n+<!ENTITY % defaultOpenContent \"%p;defaultOpenContent\">\n+<!ENTITY % complexType \"%p;complexType\">\n+<!ENTITY % complexContent \"%p;complexContent\">\n+<!ENTITY % openContent \"%p;openContent\">\n+<!ENTITY % simpleContent \"%p;simpleContent\">\n+<!ENTITY % extension \"%p;extension\">\n+<!ENTITY % element \"%p;element\">\n+<!ENTITY % alternative \"%p;alternative\">\n+<!ENTITY % unique \"%p;unique\">\n+<!ENTITY % key \"%p;key\">\n+<!ENTITY % keyref \"%p;keyref\">\n+<!ENTITY % selector \"%p;selector\">\n+<!ENTITY % field \"%p;field\">\n+<!ENTITY % group \"%p;group\">\n+<!ENTITY % all \"%p;all\">\n+<!ENTITY % choice \"%p;choice\">\n+<!ENTITY % sequence \"%p;sequence\">\n+<!ENTITY % any \"%p;any\">\n+<!ENTITY % anyAttribute \"%p;anyAttribute\">\n+<!ENTITY % attribute \"%p;attribute\">\n+<!ENTITY % attributeGroup \"%p;attributeGroup\">\n+<!ENTITY % include \"%p;include\">\n+<!ENTITY % import \"%p;import\">\n+<!ENTITY % redefine \"%p;redefine\">\n+<!ENTITY % override \"%p;override\">\n+<!ENTITY % notation \"%p;notation\">\n+<!ENTITY % assert   \"%p;assert\">\n+\n+\n+<!-- annotation elements -->\n+<!ENTITY % annotation \"%p;annotation\">\n+<!ENTITY % appinfo \"%p;appinfo\">\n+<!ENTITY % documentation \"%p;documentation\">\n+\n+<!-- Customisation entities for the ATTLIST of each element type.\n+     Define one of these if your schema takes advantage of the\n+     anyAttribute='##other' in the\n+     schema for schema documents -->\n+\n+<!ENTITY % schemaAttrs ''>\n+<!ENTITY % defaultOpenContentAttrs ''>\n+<!ENTITY % complexTypeAttrs ''>\n+<!ENTITY % complexContentAttrs ''>\n+<!ENTITY % openContentAttrs ''>\n+<!ENTITY % simpleContentAttrs ''>\n+<!ENTITY % extensionAttrs ''>\n+<!ENTITY % elementAttrs ''>\n+<!ENTITY % groupAttrs ''>\n+<!ENTITY % allAttrs ''>\n+<!ENTITY % choiceAttrs ''>\n+<!ENTITY % sequenceAttrs ''>\n+<!ENTITY % anyAttrs ''>\n+<!ENTITY % anyAttributeAttrs ''>\n+<!ENTITY % attributeAttrs ''>\n+<!ENTITY % attributeGroupAttrs ''>\n+<!ENTITY % uniqueAttrs ''>\n+<!ENTITY % keyAttrs ''>\n+<!ENTITY % keyrefAttrs ''>\n+<!ENTITY % selectorAttrs ''>\n+<!ENTITY % fieldAttrs ''>\n+<!ENTITY % assertAttrs ''>\n+\n+<!ENTITY % includeAttrs ''>\n+<!ENTITY % importAttrs ''>\n+<!ENTITY % redefineAttrs ''>\n+<!ENTITY % overrideAttrs ''>\n+<!ENTITY % notationAttrs ''>\n+<!ENTITY % annotationAttrs ''>\n+<!ENTITY % appinfoAttrs ''>\n+<!ENTITY % documentationAttrs ''>\n+\n+<!ENTITY % complexDerivationSet \"CDATA\">\n+      <!-- #all or space-separated list drawn from derivationChoice -->\n+<!ENTITY % blockSet \"CDATA\">\n+      <!-- #all or space-separated list drawn from\n+                      derivationChoice + 'substitution' -->\n+\n+<!ENTITY % composition '%include; | %import; | %override; | %redefine;'>\n+<!ENTITY % mgs '%all; | %choice; | %sequence;'>\n+<!ENTITY % cs '%choice; | %sequence;'>\n+<!ENTITY % formValues '(qualified|unqualified)'>\n+\n+\n+<!ENTITY % attrDecls    '((%attribute;| %attributeGroup;)*,(%anyAttribute;)?)'>\n+\n+<!ENTITY % assertions   '(%assert;)*'>\n+\n+<!ENTITY % particleAndAttrs '(%openContent;?, (%mgs; | %group;)?,\n+                              %attrDecls;, %assertions;)'>\n+\n+<!-- This is used in part2 -->\n+<!ENTITY % restriction1 '(%openContent;?, (%mgs; | %group;)?)'>\n+\n+%xs-datatypes;\n+\n+<!-- the duplication below is to produce an unambiguous content model\n+     which allows annotation everywhere -->\n+<!ELEMENT %schema; ((%composition; | %annotation;)*,\n+                    (%defaultOpenContent;, (%annotation;)*)?,\n+                    ((%simpleType; | %complexType;\n+                      | %element; | %attribute;\n+                      | %attributeGroup; | %group;\n+                      | %notation; ),\n+                     (%annotation;)*)* )>\n+<!ATTLIST %schema;\n+   targetNamespace      %URIref;               #IMPLIED\n+   version              CDATA                  #IMPLIED\n+   %nds;                %URIref;               #FIXED 'http:\/\/www.w3.org\/2001\/XMLSchema'\n+   xmlns                CDATA                  #IMPLIED\n+   finalDefault         %complexDerivationSet; ''\n+   blockDefault         %blockSet;             ''\n+   id                   ID                     #IMPLIED\n+   elementFormDefault   %formValues;           'unqualified'\n+   attributeFormDefault %formValues;           'unqualified'\n+   defaultAttributes    CDATA                  #IMPLIED\n+   xpathDefaultNamespace    CDATA       '##local'\n+   xml:lang             CDATA                  #IMPLIED\n+   %schemaAttrs;>\n+<!-- Note the xmlns declaration is NOT in the\n+     schema for schema documents,\n+     because at the Infoset level where schemas operate,\n+     xmlns(:prefix) is NOT an attribute! -->\n+<!-- The declaration of xmlns is a convenience for schema authors -->\n+ \n+<!-- The id attribute here and below is for use in external references\n+     from non-schemas using simple fragment identifiers.\n+     It is NOT used for schema-to-schema reference, internal or\n+     external. -->\n+\n+<!ELEMENT %defaultOpenContent; ((%annotation;)?, %any;)>\n+<!ATTLIST %defaultOpenContent;\n+          appliesToEmpty  (true|false)           'false'\n+          mode            (interleave|suffix)    'interleave'\n+          id              ID                     #IMPLIED\n+          %defaultOpenContentAttrs;>\n+\n+<!-- a type is a named content type specification which allows attribute\n+     declarations-->\n+<!-- -->\n+\n+<!ELEMENT %complexType; ((%annotation;)?,\n+                         (%simpleContent;|%complexContent;|\n+                          %particleAndAttrs;))>\n+\n+<!ATTLIST %complexType;\n+          name                    %NCName;                 #IMPLIED\n+          id                      ID                       #IMPLIED\n+          abstract                %boolean;                #IMPLIED\n+          final                   %complexDerivationSet;   #IMPLIED\n+          block                   %complexDerivationSet;   #IMPLIED\n+          mixed                   (true|false)             'false'\n+          defaultAttributesApply  %boolean;                'true'\n+          %complexTypeAttrs;>\n+\n+<!-- particleAndAttrs is shorthand for a root type -->\n+<!-- mixed is disallowed if simpleContent, overridden if complexContent has one too. -->\n+\n+<!-- If anyAttribute appears in one or more referenced attributeGroups\n+     and\/or explicitly, the intersection of the permissions is used -->\n+\n+<!ELEMENT %complexContent; ((%annotation;)?, (%restriction;|%extension;))>\n+<!ATTLIST %complexContent;\n+          mixed (true|false) #IMPLIED\n+          id    ID           #IMPLIED\n+          %complexContentAttrs;>\n+\n+<!ELEMENT %openContent; ((%annotation;)?, (%any;)?)>\n+<!ATTLIST %openContent;\n+          mode            (none|interleave|suffix)  'interleave'\n+          id              ID                        #IMPLIED\n+          %openContentAttrs;>\n+\n+<!-- restriction should use the branch defined above, not the simple\n+     one from part2; extension should use the full model  -->\n+\n+<!ELEMENT %simpleContent; ((%annotation;)?, (%restriction;|%extension;))>\n+<!ATTLIST %simpleContent;\n+          id    ID           #IMPLIED\n+          %simpleContentAttrs;>\n+\n+<!-- restriction should use the simple branch from part2, not the \n+     one defined above; extension should have no particle  -->\n+\n+<!ELEMENT %extension; ((%annotation;)?, (%particleAndAttrs;))>\n+<!ATTLIST %extension;\n+          base  %QName;               #REQUIRED\n+          id    ID                    #IMPLIED\n+          \n+          %extensionAttrs;>\n+\n+<!-- an element is declared by either:\n+ a name and a type (either nested or referenced via the type attribute)\n+ or a ref to an existing element declaration -->\n+\n+<!ELEMENT %element; ((%annotation;)?, (%complexType;| %simpleType;)?,\n+                     (%alternative;)*,\n+                     (%unique; | %key; | %keyref;)*)>\n+<!-- simpleType or complexType only if no type|ref attribute -->\n+<!-- ref not allowed at top level -->\n+<!ATTLIST %element;\n+            name               %NCName;               #IMPLIED\n+            id                 ID                     #IMPLIED\n+            ref                %QName;                #IMPLIED\n+            type               %QName;                #IMPLIED\n+            minOccurs          %nonNegativeInteger;   #IMPLIED\n+            maxOccurs          CDATA                  #IMPLIED\n+            nillable           %boolean;              #IMPLIED\n+            substitutionGroup  %QName;                #IMPLIED\n+            abstract           %boolean;              #IMPLIED\n+            final              %complexDerivationSet; #IMPLIED\n+            block              %blockSet;             #IMPLIED\n+            default            CDATA                  #IMPLIED\n+            fixed              CDATA                  #IMPLIED\n+            form               %formValues;           #IMPLIED\n+            targetNamespace    %URIref;               #IMPLIED\n+            %elementAttrs;>\n+<!-- type and ref are mutually exclusive.\n+     name and ref are mutually exclusive, one is required -->\n+<!-- In the absence of type AND ref, type defaults to type of\n+     substitutionGroup, if any, else xs:anyType, i.e. unconstrained -->\n+<!-- default and fixed are mutually exclusive -->\n+\n+<!ELEMENT %alternative; ((%annotation;)?, \n+            (%simpleType; | %complexType;)?) >\n+<!ATTLIST %alternative; \n+            test                     CDATA     #IMPLIED\n+            type                     %QName;   #IMPLIED\n+            xpathDefaultNamespace    CDATA     #IMPLIED\n+            id                       ID        #IMPLIED >\n+\n+\n+<!ELEMENT %group; ((%annotation;)?,(%mgs;)?)>\n+<!ATTLIST %group; \n+          name        %NCName;               #IMPLIED\n+          ref         %QName;                #IMPLIED\n+          minOccurs   %nonNegativeInteger;   #IMPLIED\n+          maxOccurs   CDATA                  #IMPLIED\n+          id          ID                     #IMPLIED\n+          %groupAttrs;>\n+\n+<!ELEMENT %all; ((%annotation;)?, (%element;| %group;| %any;)*)>\n+<!ATTLIST %all;\n+          minOccurs   (0 | 1)                #IMPLIED\n+          maxOccurs   (0 | 1)                #IMPLIED\n+          id          ID                     #IMPLIED\n+          %allAttrs;>\n+\n+<!ELEMENT %choice; ((%annotation;)?, (%element;| %group;| %cs; | %any;)*)>\n+<!ATTLIST %choice;\n+          minOccurs   %nonNegativeInteger;   #IMPLIED\n+          maxOccurs   CDATA                  #IMPLIED\n+          id          ID                     #IMPLIED\n+          %choiceAttrs;>\n+\n+<!ELEMENT %sequence; ((%annotation;)?, (%element;| %group;| %cs; | %any;)*)>\n+<!ATTLIST %sequence;\n+          minOccurs   %nonNegativeInteger;   #IMPLIED\n+          maxOccurs   CDATA                  #IMPLIED\n+          id          ID                     #IMPLIED\n+          %sequenceAttrs;>\n+\n+<!-- an anonymous grouping in a model, or\n+     a top-level named group definition, or a reference to same -->\n+\n+\n+<!ELEMENT %any; (%annotation;)?>\n+<!ATTLIST %any;\n+            namespace       CDATA                  #IMPLIED\n+            notNamespace    CDATA                  #IMPLIED\n+            notQName        CDATA                  ''\n+            processContents (skip|lax|strict)      'strict'\n+            minOccurs       %nonNegativeInteger;   '1'\n+            maxOccurs       CDATA                  '1'\n+            id              ID                     #IMPLIED\n+            %anyAttrs;>\n+\n+<!-- namespace is interpreted as follows:\n+                  ##any      - - any non-conflicting WFXML at all\n+\n+                  ##other    - - any non-conflicting WFXML from namespace other\n+                                  than targetNamespace\n+\n+                  ##local    - - any unqualified non-conflicting WFXML\/attribute\n+                  one or     - - any non-conflicting WFXML from\n+                  more URI        the listed namespaces\n+                  references\n+\n+                  ##targetNamespace ##local may appear in the above list,\n+                    with the obvious meaning -->\n+\n+<!-- notNamespace is interpreted as follows:\n+                  ##local    - - any unqualified non-conflicting WFXML\/attribute\n+                  one or     - - any non-conflicting WFXML from\n+                  more URI        the listed namespaces\n+                  references\n+\n+                  ##targetNamespace ##local may appear in the above list,\n+                    with the obvious meaning -->\n+\n+<!ELEMENT %anyAttribute; (%annotation;)?>\n+<!ATTLIST %anyAttribute;\n+            namespace       CDATA              #IMPLIED\n+            notNamespace    CDATA              #IMPLIED\n+            notQName        CDATA              ''\n+            processContents (skip|lax|strict)  'strict'\n+            id              ID                 #IMPLIED\n+            %anyAttributeAttrs;>\n+<!-- namespace and notNamespace are interpreted as for 'any' above -->\n+\n+<!-- simpleType only if no type|ref attribute -->\n+<!-- ref not allowed at top level, name iff at top level -->\n+<!ELEMENT %attribute; ((%annotation;)?, (%simpleType;)?)>\n+<!ATTLIST %attribute;\n+          name              %NCName;      #IMPLIED\n+          id                ID            #IMPLIED\n+          ref               %QName;       #IMPLIED\n+          type              %QName;       #IMPLIED\n+          use               (prohibited|optional|required) #IMPLIED\n+          default           CDATA         #IMPLIED\n+          fixed             CDATA         #IMPLIED\n+          form              %formValues;  #IMPLIED\n+          targetNamespace   %URIref;      #IMPLIED\n+          inheritable       %boolean;      #IMPLIED\n+          %attributeAttrs;>\n+<!-- type and ref are mutually exclusive.\n+     name and ref are mutually exclusive, one is required -->\n+<!-- default for use is optional when nested, none otherwise -->\n+<!-- default and fixed are mutually exclusive -->\n+<!-- type attr and simpleType content are mutually exclusive -->\n+\n+<!-- an attributeGroup is a named collection of attribute decls, or a\n+     reference thereto -->\n+<!ELEMENT %attributeGroup; ((%annotation;)?,\n+                       (%attribute; | %attributeGroup;)*,\n+                       (%anyAttribute;)?) >\n+<!ATTLIST %attributeGroup;\n+                 name       %NCName;       #IMPLIED\n+                 id         ID             #IMPLIED\n+                 ref        %QName;        #IMPLIED\n+                 %attributeGroupAttrs;>\n+\n+<!-- ref iff no content, no name.  ref iff not top level -->\n+\n+<!-- better reference mechanisms -->\n+<!ELEMENT %unique; ((%annotation;)?, %selector;, (%field;)+)>\n+<!ATTLIST %unique;\n+          name                     %NCName;       #IMPLIED\n+          ref                      %QName;        #IMPLIED\n+          id                       ID             #IMPLIED\n+          %uniqueAttrs;>\n+\n+<!ELEMENT %key;    ((%annotation;)?, %selector;, (%field;)+)>\n+<!ATTLIST %key;\n+          name                     %NCName;       #IMPLIED\n+          ref                      %QName;        #IMPLIED\n+          id                       ID             #IMPLIED\n+          %keyAttrs;>\n+\n+<!ELEMENT %keyref; ((%annotation;)?, %selector;, (%field;)+)>\n+<!ATTLIST %keyref;\n+          name                     %NCName;       #IMPLIED\n+          ref                      %QName;        #IMPLIED\n+          refer                    %QName;        #IMPLIED\n+          id                       ID             #IMPLIED\n+          %keyrefAttrs;>\n+\n+<!ELEMENT %selector; ((%annotation;)?)>\n+<!ATTLIST %selector;\n+          xpath                    %XPathExpr; #REQUIRED\n+          xpathDefaultNamespace    CDATA       #IMPLIED\n+          id                       ID          #IMPLIED\n+          %selectorAttrs;>\n+<!ELEMENT %field; ((%annotation;)?)>\n+<!ATTLIST %field;\n+          xpath                    %XPathExpr; #REQUIRED\n+          xpathDefaultNamespace    CDATA       #IMPLIED\n+          id                       ID          #IMPLIED\n+          %fieldAttrs;>\n+\n+<!-- co-constraint assertions -->\n+<!ELEMENT %assert; ((%annotation;)?)>\n+<!ATTLIST %assert;\n+          test                     %XPathExpr; #REQUIRED\n+          id                       ID          #IMPLIED\n+          xpathDefaultNamespace    CDATA       #IMPLIED\n+          %assertAttrs;>\n+\n+\n+<!-- Schema combination mechanisms -->\n+<!ELEMENT %include; (%annotation;)?>\n+<!ATTLIST %include;\n+          schemaLocation %URIref; #REQUIRED\n+          id             ID       #IMPLIED\n+          %includeAttrs;>\n+\n+<!ELEMENT %import; (%annotation;)?>\n+<!ATTLIST %import;\n+          namespace      %URIref; #IMPLIED\n+          schemaLocation %URIref; #IMPLIED\n+          id             ID       #IMPLIED\n+          %importAttrs;>\n+\n+<!ELEMENT %redefine; (%annotation; | %simpleType; | %complexType; |\n+                      %attributeGroup; | %group;)*>\n+<!ATTLIST %redefine;\n+          schemaLocation %URIref; #REQUIRED\n+          id             ID       #IMPLIED\n+          %redefineAttrs;>\n+\n+<!ELEMENT %override; ((%annotation;)?,\n+                      ((%simpleType; | %complexType; | %group; | %attributeGroup;) |\n+                       %element; | %attribute; | %notation;)*)>\n+<!ATTLIST %override;\n+          schemaLocation %URIref; #REQUIRED\n+          id             ID       #IMPLIED\n+          %overrideAttrs;>\n+\n+<!ELEMENT %notation; (%annotation;)?>\n+<!ATTLIST %notation;\n+\t  name        %NCName;    #REQUIRED\n+\t  id          ID          #IMPLIED\n+\t  public      CDATA       #REQUIRED\n+\t  system      %URIref;    #IMPLIED\n+\t  %notationAttrs;>\n+\n+<!-- Annotation is either application information or documentation -->\n+<!-- By having these here they are available for datatypes as well\n+     as all the structures elements -->\n+\n+<!ELEMENT %annotation; (%appinfo; | %documentation;)*>\n+<!ATTLIST %annotation; %annotationAttrs;>\n+\n+<!-- User must define annotation elements in internal subset for this\n+     to work -->\n+<!ELEMENT %appinfo; ANY>   <!-- too restrictive -->\n+<!ATTLIST %appinfo;\n+          source     %URIref;      #IMPLIED\n+          id         ID         #IMPLIED\n+          %appinfoAttrs;>\n+<!ELEMENT %documentation; ANY>   <!-- too restrictive -->\n+<!ATTLIST %documentation;\n+          source     %URIref;   #IMPLIED\n+          id         ID         #IMPLIED\n+          xml:lang   CDATA      #IMPLIED\n+          %documentationAttrs;>\n+\n+<!NOTATION XMLSchemaStructures PUBLIC\n+           'structures' 'http:\/\/www.w3.org\/2001\/XMLSchema.xsd' >\n+<!NOTATION XML PUBLIC\n+           'REC-xml-1998-0210' 'http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210' >\n+\n+<!-- \n+      In keeping with the XML Schema WG's standard versioning policy, \n+      this DTD will persist at the URI\n+      http:\/\/www.w3.org\/2012\/04\/XMLSchema.dtd.\n+\n+      At the date of issue it can also be found at the URI\n+      http:\/\/www.w3.org\/2009\/XMLSchema\/XMLSchema.dtd.\n+\n+      The schema document at that URI may however change in the future, \n+      in order to remain compatible with the latest version of XSD \n+      and its namespace.  In other words, if XSD or the XML Schema \n+      namespace change, the version of this document at \n+      http:\/\/www.w3.org\/2009\/XMLSchema\/XMLSchema.dtd will change accordingly; \n+      the version at http:\/\/www.w3.org\/2012\/04\/XMLSchema.dtd \n+      will not change.\n+\n+      Previous dated (and unchanging) versions of this DTD include:\n+\n+       http:\/\/www.w3.org\/2012\/01\/XMLSchema.dtd\n+          (XSD 1.1 Proposed Recommendation)\n+\n+\n+        http:\/\/www.w3.org\/2011\/07\/XMLSchema.dtd\n+          (XSD 1.1 Candidate Recommendation)\n+\n+        http:\/\/www.w3.org\/2009\/04\/XMLSchema.dtd \n+          (XSD 1.1 Candidate Recommendation)\n+\n+        http:\/\/www.w3.org\/2004\/10\/XMLSchema.dtd\n+          (XSD 1.0 Recommendation, Second Edition)\n+\n+        http:\/\/www.w3.org\/2001\/05\/XMLSchema.dtd\n+          (XSD 1.0 Recommendation, First Edition)\n+\n+-->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/schema10\/XMLSchema.dtd","additions":513,"deletions":0,"binary":false,"changes":513,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+<!--\n+        DTD for XML Schemas: Part 2: Datatypes\n+        \n+        Id: datatypes.dtd,v 1.1.2.4 2005\/01\/31 18:40:42 cmsmcq Exp \n+        Note this DTD is NOT normative, or even definitive.\n+  -->\n+\n+<!--\n+        This DTD cannot be used on its own, it is intended\n+        only for incorporation in XMLSchema.dtd, q.v.\n+  -->\n+\n+<!-- Define all the element names, with optional prefix -->\n+<!ENTITY % simpleType \"%p;simpleType\">\n+<!ENTITY % restriction \"%p;restriction\">\n+<!ENTITY % list \"%p;list\">\n+<!ENTITY % union \"%p;union\">\n+<!ENTITY % maxExclusive \"%p;maxExclusive\">\n+<!ENTITY % minExclusive \"%p;minExclusive\">\n+<!ENTITY % maxInclusive \"%p;maxInclusive\">\n+<!ENTITY % minInclusive \"%p;minInclusive\">\n+<!ENTITY % totalDigits \"%p;totalDigits\">\n+<!ENTITY % fractionDigits \"%p;fractionDigits\">\n+\n+<!ENTITY % length \"%p;length\">\n+<!ENTITY % minLength \"%p;minLength\">\n+<!ENTITY % maxLength \"%p;maxLength\">\n+<!ENTITY % enumeration \"%p;enumeration\">\n+<!ENTITY % whiteSpace \"%p;whiteSpace\">\n+<!ENTITY % pattern \"%p;pattern\">\n+\n+<!ENTITY % assertion \"%p;assertion\">\n+\n+<!ENTITY % explicitTimezone \"%p;explicitTimezone\">\n+\n+\n+<!--\n+        Customization entities for the ATTLIST of each element\n+        type. Define one of these if your schema takes advantage\n+        of the anyAttribute='##other' in the schema for schemas\n+  -->\n+\n+<!ENTITY % simpleTypeAttrs \"\">\n+<!ENTITY % restrictionAttrs \"\">\n+<!ENTITY % listAttrs \"\">\n+<!ENTITY % unionAttrs \"\">\n+<!ENTITY % maxExclusiveAttrs \"\">\n+<!ENTITY % minExclusiveAttrs \"\">\n+<!ENTITY % maxInclusiveAttrs \"\">\n+<!ENTITY % minInclusiveAttrs \"\">\n+<!ENTITY % totalDigitsAttrs \"\">\n+<!ENTITY % fractionDigitsAttrs \"\">\n+<!ENTITY % lengthAttrs \"\">\n+<!ENTITY % minLengthAttrs \"\">\n+<!ENTITY % maxLengthAttrs \"\">\n+\n+<!ENTITY % enumerationAttrs \"\">\n+<!ENTITY % whiteSpaceAttrs \"\">\n+<!ENTITY % patternAttrs \"\">\n+<!ENTITY % assertionAttrs \"\">\n+<!ENTITY % explicitTimezoneAttrs \"\">\n+\n+<!-- Define some entities for informative use as attribute\n+        types -->\n+<!ENTITY % URIref \"CDATA\">\n+<!ENTITY % XPathExpr \"CDATA\">\n+<!ENTITY % QName \"NMTOKEN\">\n+<!ENTITY % QNames \"NMTOKENS\">\n+<!ENTITY % NCName \"NMTOKEN\">\n+<!ENTITY % nonNegativeInteger \"NMTOKEN\">\n+<!ENTITY % boolean \"(true|false)\">\n+<!ENTITY % simpleDerivationSet \"CDATA\">\n+<!--\n+        #all or space-separated list drawn from derivationChoice\n+  -->\n+\n+<!--\n+        Note that the use of 'facet' below is less restrictive\n+        than is really intended:  There should in fact be no\n+        more than one of each of minInclusive, minExclusive,\n+        maxInclusive, maxExclusive, totalDigits, fractionDigits,\n+        length, maxLength, minLength within datatype,\n+        and the min- and max- variants of Inclusive and Exclusive\n+        are mutually exclusive. On the other hand,  pattern and\n+        enumeration and assertion may repeat.\n+  -->\n+<!ENTITY % minBound \"(%minInclusive; | %minExclusive;)\">\n+<!ENTITY % maxBound \"(%maxInclusive; | %maxExclusive;)\">\n+<!ENTITY % bounds \"%minBound; | %maxBound;\">\n+<!ENTITY % numeric \"%totalDigits; | %fractionDigits;\"> \n+<!ENTITY % ordered \"%bounds; | %numeric;\">\n+<!ENTITY % unordered\n+   \"%pattern; | %enumeration; | %whiteSpace; | %length; |\n+   %maxLength; | %minLength; | %assertion;\n+   | %explicitTimezone;\">\n+<!ENTITY % implementation-defined-facets \"\">\n+<!ENTITY % facet \"%ordered; | %unordered; %implementation-defined-facets;\">\n+<!ENTITY % facetAttr \n+        \"value CDATA #REQUIRED\n+        id ID #IMPLIED\">\n+<!ENTITY % fixedAttr \"fixed %boolean; #IMPLIED\">\n+<!ENTITY % facetModel \"(%annotation;)?\">\n+<!ELEMENT %simpleType;\n+        ((%annotation;)?, (%restriction; | %list; | %union;))>\n+<!ATTLIST %simpleType;\n+    name      %NCName; #IMPLIED\n+    final     %simpleDerivationSet; #IMPLIED\n+    id        ID       #IMPLIED\n+    %simpleTypeAttrs;>\n+<!-- name is required at top level -->\n+<!ELEMENT %restriction; ((%annotation;)?,\n+                         (%restriction1; |\n+                          ((%simpleType;)?,(%facet;)*)),\n+                         (%attrDecls;))>\n+<!ATTLIST %restriction;\n+    base      %QName;                  #IMPLIED\n+    id        ID       #IMPLIED\n+    %restrictionAttrs;>\n+<!--\n+        base and simpleType child are mutually exclusive,\n+        one is required.\n+\n+        restriction is shared between simpleType and\n+        simpleContent and complexContent (in XMLSchema.xsd).\n+        restriction1 is for the latter cases, when this\n+        is restricting a complex type, as is attrDecls.\n+  -->\n+<!ELEMENT %list; ((%annotation;)?,(%simpleType;)?)>\n+<!ATTLIST %list;\n+    itemType      %QName;             #IMPLIED\n+    id        ID       #IMPLIED\n+    %listAttrs;>\n+<!--\n+        itemType and simpleType child are mutually exclusive,\n+        one is required\n+  -->\n+<!ELEMENT %union; ((%annotation;)?,(%simpleType;)*)>\n+<!ATTLIST %union;\n+    id            ID       #IMPLIED\n+    memberTypes   %QNames;            #IMPLIED\n+    %unionAttrs;>\n+<!--\n+        At least one item in memberTypes or one simpleType\n+        child is required\n+  -->\n+\n+<!ELEMENT %maxExclusive; %facetModel;>\n+<!ATTLIST %maxExclusive;\n+        %facetAttr;\n+        %fixedAttr;\n+        %maxExclusiveAttrs;>\n+<!ELEMENT %minExclusive; %facetModel;>\n+<!ATTLIST %minExclusive;\n+        %facetAttr;\n+        %fixedAttr;\n+        %minExclusiveAttrs;>\n+\n+<!ELEMENT %maxInclusive; %facetModel;>\n+<!ATTLIST %maxInclusive;\n+        %facetAttr;\n+        %fixedAttr;\n+        %maxInclusiveAttrs;>\n+<!ELEMENT %minInclusive; %facetModel;>\n+<!ATTLIST %minInclusive;\n+        %facetAttr;\n+        %fixedAttr;\n+        %minInclusiveAttrs;>\n+\n+<!ELEMENT %totalDigits; %facetModel;>\n+<!ATTLIST %totalDigits;\n+        %facetAttr;\n+        %fixedAttr;\n+        %totalDigitsAttrs;>\n+<!ELEMENT %fractionDigits; %facetModel;>\n+<!ATTLIST %fractionDigits;\n+        %facetAttr;\n+        %fixedAttr;\n+        %fractionDigitsAttrs;>\n+\n+<!ELEMENT %length; %facetModel;>\n+<!ATTLIST %length;\n+        %facetAttr;\n+        %fixedAttr;\n+        %lengthAttrs;>\n+<!ELEMENT %minLength; %facetModel;>\n+<!ATTLIST %minLength;\n+        %facetAttr;\n+        %fixedAttr;\n+        %minLengthAttrs;>\n+<!ELEMENT %maxLength; %facetModel;>\n+<!ATTLIST %maxLength;\n+        %facetAttr;\n+        %fixedAttr;\n+        %maxLengthAttrs;>\n+\n+<!-- This one can be repeated -->\n+<!ELEMENT %enumeration; %facetModel;>\n+<!ATTLIST %enumeration;\n+        %facetAttr;\n+        %enumerationAttrs;>\n+\n+<!ELEMENT %whiteSpace; %facetModel;>\n+<!ATTLIST %whiteSpace;\n+        %facetAttr;\n+        %fixedAttr;\n+        %whiteSpaceAttrs;>\n+\n+<!-- This one can be repeated -->\n+<!ELEMENT %pattern; %facetModel;>\n+<!ATTLIST %pattern;\n+        %facetAttr;\n+        %patternAttrs;>\n+\n+<!ELEMENT %assertion; %facetModel;>\n+<!ATTLIST %assertion;\n+        %facetAttr;\n+        %assertionAttrs;>\n+\n+<!ELEMENT %explicitTimezone; %facetModel;>\n+<!ATTLIST %explicitTimezone;\n+        %facetAttr;\n+        %explicitTimezoneAttrs;>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/schema10\/datatypes.dtd","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+<!-- Portions (C) International Organization for Standardization 1986\n+     Permission to copy in any form is granted for use with\n+     conforming SGML systems and applications as defined in\n+     ISO 8879, provided this notice is included in all copies.\n+-->\n+<!-- Character entity set. Typical invocation:\n+    <!ENTITY % HTMLlat1 PUBLIC\n+       \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+       \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-lat1.ent\">\n+    %HTMLlat1;\n+-->\n+\n+<!ENTITY nbsp   \"&#160;\"> <!-- no-break space = non-breaking space,\n+                                  U+00A0 ISOnum -->\n+<!ENTITY iexcl  \"&#161;\"> <!-- inverted exclamation mark, U+00A1 ISOnum -->\n+<!ENTITY cent   \"&#162;\"> <!-- cent sign, U+00A2 ISOnum -->\n+<!ENTITY pound  \"&#163;\"> <!-- pound sign, U+00A3 ISOnum -->\n+<!ENTITY curren \"&#164;\"> <!-- currency sign, U+00A4 ISOnum -->\n+<!ENTITY yen    \"&#165;\"> <!-- yen sign = yuan sign, U+00A5 ISOnum -->\n+<!ENTITY brvbar \"&#166;\"> <!-- broken bar = broken vertical bar,\n+                                  U+00A6 ISOnum -->\n+<!ENTITY sect   \"&#167;\"> <!-- section sign, U+00A7 ISOnum -->\n+<!ENTITY uml    \"&#168;\"> <!-- diaeresis = spacing diaeresis,\n+                                  U+00A8 ISOdia -->\n+<!ENTITY copy   \"&#169;\"> <!-- copyright sign, U+00A9 ISOnum -->\n+<!ENTITY ordf   \"&#170;\"> <!-- feminine ordinal indicator, U+00AA ISOnum -->\n+<!ENTITY laquo  \"&#171;\"> <!-- left-pointing double angle quotation mark\n+                                  = left pointing guillemet, U+00AB ISOnum -->\n+<!ENTITY not    \"&#172;\"> <!-- not sign = angled dash,\n+                                  U+00AC ISOnum -->\n+<!ENTITY shy    \"&#173;\"> <!-- soft hyphen = discretionary hyphen,\n+                                  U+00AD ISOnum -->\n+<!ENTITY reg    \"&#174;\"> <!-- registered sign = registered trade mark sign,\n+                                  U+00AE ISOnum -->\n+<!ENTITY macr   \"&#175;\"> <!-- macron = spacing macron = overline\n+                                  = APL overbar, U+00AF ISOdia -->\n+<!ENTITY deg    \"&#176;\"> <!-- degree sign, U+00B0 ISOnum -->\n+<!ENTITY plusmn \"&#177;\"> <!-- plus-minus sign = plus-or-minus sign,\n+                                  U+00B1 ISOnum -->\n+<!ENTITY sup2   \"&#178;\"> <!-- superscript two = superscript digit two\n+                                  = squared, U+00B2 ISOnum -->\n+<!ENTITY sup3   \"&#179;\"> <!-- superscript three = superscript digit three\n+                                  = cubed, U+00B3 ISOnum -->\n+<!ENTITY acute  \"&#180;\"> <!-- acute accent = spacing acute,\n+                                  U+00B4 ISOdia -->\n+<!ENTITY micro  \"&#181;\"> <!-- micro sign, U+00B5 ISOnum -->\n+<!ENTITY para   \"&#182;\"> <!-- pilcrow sign = paragraph sign,\n+                                  U+00B6 ISOnum -->\n+<!ENTITY middot \"&#183;\"> <!-- middle dot = Georgian comma\n+                                  = Greek middle dot, U+00B7 ISOnum -->\n+<!ENTITY cedil  \"&#184;\"> <!-- cedilla = spacing cedilla, U+00B8 ISOdia -->\n+<!ENTITY sup1   \"&#185;\"> <!-- superscript one = superscript digit one,\n+                                  U+00B9 ISOnum -->\n+<!ENTITY ordm   \"&#186;\"> <!-- masculine ordinal indicator,\n+                                  U+00BA ISOnum -->\n+<!ENTITY raquo  \"&#187;\"> <!-- right-pointing double angle quotation mark\n+                                  = right pointing guillemet, U+00BB ISOnum -->\n+<!ENTITY frac14 \"&#188;\"> <!-- vulgar fraction one quarter\n+                                  = fraction one quarter, U+00BC ISOnum -->\n+<!ENTITY frac12 \"&#189;\"> <!-- vulgar fraction one half\n+                                  = fraction one half, U+00BD ISOnum -->\n+<!ENTITY frac34 \"&#190;\"> <!-- vulgar fraction three quarters\n+                                  = fraction three quarters, U+00BE ISOnum -->\n+<!ENTITY iquest \"&#191;\"> <!-- inverted question mark\n+                                  = turned question mark, U+00BF ISOnum -->\n+<!ENTITY Agrave \"&#192;\"> <!-- latin capital letter A with grave\n+                                  = latin capital letter A grave,\n+                                  U+00C0 ISOlat1 -->\n+<!ENTITY Aacute \"&#193;\"> <!-- latin capital letter A with acute,\n+                                  U+00C1 ISOlat1 -->\n+<!ENTITY Acirc  \"&#194;\"> <!-- latin capital letter A with circumflex,\n+                                  U+00C2 ISOlat1 -->\n+<!ENTITY Atilde \"&#195;\"> <!-- latin capital letter A with tilde,\n+                                  U+00C3 ISOlat1 -->\n+<!ENTITY Auml   \"&#196;\"> <!-- latin capital letter A with diaeresis,\n+                                  U+00C4 ISOlat1 -->\n+<!ENTITY Aring  \"&#197;\"> <!-- latin capital letter A with ring above\n+                                  = latin capital letter A ring,\n+                                  U+00C5 ISOlat1 -->\n+<!ENTITY AElig  \"&#198;\"> <!-- latin capital letter AE\n+                                  = latin capital ligature AE,\n+                                  U+00C6 ISOlat1 -->\n+<!ENTITY Ccedil \"&#199;\"> <!-- latin capital letter C with cedilla,\n+                                  U+00C7 ISOlat1 -->\n+<!ENTITY Egrave \"&#200;\"> <!-- latin capital letter E with grave,\n+                                  U+00C8 ISOlat1 -->\n+<!ENTITY Eacute \"&#201;\"> <!-- latin capital letter E with acute,\n+                                  U+00C9 ISOlat1 -->\n+<!ENTITY Ecirc  \"&#202;\"> <!-- latin capital letter E with circumflex,\n+                                  U+00CA ISOlat1 -->\n+<!ENTITY Euml   \"&#203;\"> <!-- latin capital letter E with diaeresis,\n+                                  U+00CB ISOlat1 -->\n+<!ENTITY Igrave \"&#204;\"> <!-- latin capital letter I with grave,\n+                                  U+00CC ISOlat1 -->\n+<!ENTITY Iacute \"&#205;\"> <!-- latin capital letter I with acute,\n+                                  U+00CD ISOlat1 -->\n+<!ENTITY Icirc  \"&#206;\"> <!-- latin capital letter I with circumflex,\n+                                  U+00CE ISOlat1 -->\n+<!ENTITY Iuml   \"&#207;\"> <!-- latin capital letter I with diaeresis,\n+                                  U+00CF ISOlat1 -->\n+<!ENTITY ETH    \"&#208;\"> <!-- latin capital letter ETH, U+00D0 ISOlat1 -->\n+<!ENTITY Ntilde \"&#209;\"> <!-- latin capital letter N with tilde,\n+                                  U+00D1 ISOlat1 -->\n+<!ENTITY Ograve \"&#210;\"> <!-- latin capital letter O with grave,\n+                                  U+00D2 ISOlat1 -->\n+<!ENTITY Oacute \"&#211;\"> <!-- latin capital letter O with acute,\n+                                  U+00D3 ISOlat1 -->\n+<!ENTITY Ocirc  \"&#212;\"> <!-- latin capital letter O with circumflex,\n+                                  U+00D4 ISOlat1 -->\n+<!ENTITY Otilde \"&#213;\"> <!-- latin capital letter O with tilde,\n+                                  U+00D5 ISOlat1 -->\n+<!ENTITY Ouml   \"&#214;\"> <!-- latin capital letter O with diaeresis,\n+                                  U+00D6 ISOlat1 -->\n+<!ENTITY times  \"&#215;\"> <!-- multiplication sign, U+00D7 ISOnum -->\n+<!ENTITY Oslash \"&#216;\"> <!-- latin capital letter O with stroke\n+                                  = latin capital letter O slash,\n+                                  U+00D8 ISOlat1 -->\n+<!ENTITY Ugrave \"&#217;\"> <!-- latin capital letter U with grave,\n+                                  U+00D9 ISOlat1 -->\n+<!ENTITY Uacute \"&#218;\"> <!-- latin capital letter U with acute,\n+                                  U+00DA ISOlat1 -->\n+<!ENTITY Ucirc  \"&#219;\"> <!-- latin capital letter U with circumflex,\n+                                  U+00DB ISOlat1 -->\n+<!ENTITY Uuml   \"&#220;\"> <!-- latin capital letter U with diaeresis,\n+                                  U+00DC ISOlat1 -->\n+<!ENTITY Yacute \"&#221;\"> <!-- latin capital letter Y with acute,\n+                                  U+00DD ISOlat1 -->\n+<!ENTITY THORN  \"&#222;\"> <!-- latin capital letter THORN,\n+                                  U+00DE ISOlat1 -->\n+<!ENTITY szlig  \"&#223;\"> <!-- latin small letter sharp s = ess-zed,\n+                                  U+00DF ISOlat1 -->\n+<!ENTITY agrave \"&#224;\"> <!-- latin small letter a with grave\n+                                  = latin small letter a grave,\n+                                  U+00E0 ISOlat1 -->\n+<!ENTITY aacute \"&#225;\"> <!-- latin small letter a with acute,\n+                                  U+00E1 ISOlat1 -->\n+<!ENTITY acirc  \"&#226;\"> <!-- latin small letter a with circumflex,\n+                                  U+00E2 ISOlat1 -->\n+<!ENTITY atilde \"&#227;\"> <!-- latin small letter a with tilde,\n+                                  U+00E3 ISOlat1 -->\n+<!ENTITY auml   \"&#228;\"> <!-- latin small letter a with diaeresis,\n+                                  U+00E4 ISOlat1 -->\n+<!ENTITY aring  \"&#229;\"> <!-- latin small letter a with ring above\n+                                  = latin small letter a ring,\n+                                  U+00E5 ISOlat1 -->\n+<!ENTITY aelig  \"&#230;\"> <!-- latin small letter ae\n+                                  = latin small ligature ae, U+00E6 ISOlat1 -->\n+<!ENTITY ccedil \"&#231;\"> <!-- latin small letter c with cedilla,\n+                                  U+00E7 ISOlat1 -->\n+<!ENTITY egrave \"&#232;\"> <!-- latin small letter e with grave,\n+                                  U+00E8 ISOlat1 -->\n+<!ENTITY eacute \"&#233;\"> <!-- latin small letter e with acute,\n+                                  U+00E9 ISOlat1 -->\n+<!ENTITY ecirc  \"&#234;\"> <!-- latin small letter e with circumflex,\n+                                  U+00EA ISOlat1 -->\n+<!ENTITY euml   \"&#235;\"> <!-- latin small letter e with diaeresis,\n+                                  U+00EB ISOlat1 -->\n+<!ENTITY igrave \"&#236;\"> <!-- latin small letter i with grave,\n+                                  U+00EC ISOlat1 -->\n+<!ENTITY iacute \"&#237;\"> <!-- latin small letter i with acute,\n+                                  U+00ED ISOlat1 -->\n+<!ENTITY icirc  \"&#238;\"> <!-- latin small letter i with circumflex,\n+                                  U+00EE ISOlat1 -->\n+<!ENTITY iuml   \"&#239;\"> <!-- latin small letter i with diaeresis,\n+                                  U+00EF ISOlat1 -->\n+<!ENTITY eth    \"&#240;\"> <!-- latin small letter eth, U+00F0 ISOlat1 -->\n+<!ENTITY ntilde \"&#241;\"> <!-- latin small letter n with tilde,\n+                                  U+00F1 ISOlat1 -->\n+<!ENTITY ograve \"&#242;\"> <!-- latin small letter o with grave,\n+                                  U+00F2 ISOlat1 -->\n+<!ENTITY oacute \"&#243;\"> <!-- latin small letter o with acute,\n+                                  U+00F3 ISOlat1 -->\n+<!ENTITY ocirc  \"&#244;\"> <!-- latin small letter o with circumflex,\n+                                  U+00F4 ISOlat1 -->\n+<!ENTITY otilde \"&#245;\"> <!-- latin small letter o with tilde,\n+                                  U+00F5 ISOlat1 -->\n+<!ENTITY ouml   \"&#246;\"> <!-- latin small letter o with diaeresis,\n+                                  U+00F6 ISOlat1 -->\n+<!ENTITY divide \"&#247;\"> <!-- division sign, U+00F7 ISOnum -->\n+<!ENTITY oslash \"&#248;\"> <!-- latin small letter o with stroke,\n+                                  = latin small letter o slash,\n+                                  U+00F8 ISOlat1 -->\n+<!ENTITY ugrave \"&#249;\"> <!-- latin small letter u with grave,\n+                                  U+00F9 ISOlat1 -->\n+<!ENTITY uacute \"&#250;\"> <!-- latin small letter u with acute,\n+                                  U+00FA ISOlat1 -->\n+<!ENTITY ucirc  \"&#251;\"> <!-- latin small letter u with circumflex,\n+                                  U+00FB ISOlat1 -->\n+<!ENTITY uuml   \"&#252;\"> <!-- latin small letter u with diaeresis,\n+                                  U+00FC ISOlat1 -->\n+<!ENTITY yacute \"&#253;\"> <!-- latin small letter y with acute,\n+                                  U+00FD ISOlat1 -->\n+<!ENTITY thorn  \"&#254;\"> <!-- latin small letter thorn,\n+                                  U+00FE ISOlat1 -->\n+<!ENTITY yuml   \"&#255;\"> <!-- latin small letter y with diaeresis,\n+                                  U+00FF ISOlat1 -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml10\/xhtml-lat1.ent","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+<!-- Special characters for XHTML -->\n+\n+<!-- Character entity set. Typical invocation:\n+     <!ENTITY % HTMLspecial PUBLIC\n+        \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+        \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-special.ent\">\n+     %HTMLspecial;\n+-->\n+\n+<!-- Portions (C) International Organization for Standardization 1986:\n+     Permission to copy in any form is granted for use with\n+     conforming SGML systems and applications as defined in\n+     ISO 8879, provided this notice is included in all copies.\n+-->\n+\n+<!-- Relevant ISO entity set is given unless names are newly introduced.\n+     New names (i.e., not in ISO 8879 list) do not clash with any\n+     existing ISO 8879 entity names. ISO 10646 character numbers\n+     are given for each character, in hex. values are decimal\n+     conversions of the ISO 10646 values and refer to the document\n+     character set. Names are Unicode names. \n+-->\n+\n+<!-- C0 Controls and Basic Latin -->\n+<!ENTITY quot    \"&#34;\"> <!--  quotation mark, U+0022 ISOnum -->\n+<!ENTITY amp     \"&#38;#38;\"> <!--  ampersand, U+0026 ISOnum -->\n+<!ENTITY lt      \"&#38;#60;\"> <!--  less-than sign, U+003C ISOnum -->\n+<!ENTITY gt      \"&#62;\"> <!--  greater-than sign, U+003E ISOnum -->\n+<!ENTITY apos\t \"&#39;\"> <!--  apostrophe = APL quote, U+0027 ISOnum -->\n+\n+<!-- Latin Extended-A -->\n+<!ENTITY OElig   \"&#338;\"> <!--  latin capital ligature OE,\n+                                    U+0152 ISOlat2 -->\n+<!ENTITY oelig   \"&#339;\"> <!--  latin small ligature oe, U+0153 ISOlat2 -->\n+<!-- ligature is a misnomer, this is a separate character in some languages -->\n+<!ENTITY Scaron  \"&#352;\"> <!--  latin capital letter S with caron,\n+                                    U+0160 ISOlat2 -->\n+<!ENTITY scaron  \"&#353;\"> <!--  latin small letter s with caron,\n+                                    U+0161 ISOlat2 -->\n+<!ENTITY Yuml    \"&#376;\"> <!--  latin capital letter Y with diaeresis,\n+                                    U+0178 ISOlat2 -->\n+\n+<!-- Spacing Modifier Letters -->\n+<!ENTITY circ    \"&#710;\"> <!--  modifier letter circumflex accent,\n+                                    U+02C6 ISOpub -->\n+<!ENTITY tilde   \"&#732;\"> <!--  small tilde, U+02DC ISOdia -->\n+\n+<!-- General Punctuation -->\n+<!ENTITY ensp    \"&#8194;\"> <!-- en space, U+2002 ISOpub -->\n+<!ENTITY emsp    \"&#8195;\"> <!-- em space, U+2003 ISOpub -->\n+<!ENTITY thinsp  \"&#8201;\"> <!-- thin space, U+2009 ISOpub -->\n+<!ENTITY zwnj    \"&#8204;\"> <!-- zero width non-joiner,\n+                                    U+200C NEW RFC 2070 -->\n+<!ENTITY zwj     \"&#8205;\"> <!-- zero width joiner, U+200D NEW RFC 2070 -->\n+<!ENTITY lrm     \"&#8206;\"> <!-- left-to-right mark, U+200E NEW RFC 2070 -->\n+<!ENTITY rlm     \"&#8207;\"> <!-- right-to-left mark, U+200F NEW RFC 2070 -->\n+<!ENTITY ndash   \"&#8211;\"> <!-- en dash, U+2013 ISOpub -->\n+<!ENTITY mdash   \"&#8212;\"> <!-- em dash, U+2014 ISOpub -->\n+<!ENTITY lsquo   \"&#8216;\"> <!-- left single quotation mark,\n+                                    U+2018 ISOnum -->\n+<!ENTITY rsquo   \"&#8217;\"> <!-- right single quotation mark,\n+                                    U+2019 ISOnum -->\n+<!ENTITY sbquo   \"&#8218;\"> <!-- single low-9 quotation mark, U+201A NEW -->\n+<!ENTITY ldquo   \"&#8220;\"> <!-- left double quotation mark,\n+                                    U+201C ISOnum -->\n+<!ENTITY rdquo   \"&#8221;\"> <!-- right double quotation mark,\n+                                    U+201D ISOnum -->\n+<!ENTITY bdquo   \"&#8222;\"> <!-- double low-9 quotation mark, U+201E NEW -->\n+<!ENTITY dagger  \"&#8224;\"> <!-- dagger, U+2020 ISOpub -->\n+<!ENTITY Dagger  \"&#8225;\"> <!-- double dagger, U+2021 ISOpub -->\n+<!ENTITY permil  \"&#8240;\"> <!-- per mille sign, U+2030 ISOtech -->\n+<!ENTITY lsaquo  \"&#8249;\"> <!-- single left-pointing angle quotation mark,\n+                                    U+2039 ISO proposed -->\n+<!-- lsaquo is proposed but not yet ISO standardized -->\n+<!ENTITY rsaquo  \"&#8250;\"> <!-- single right-pointing angle quotation mark,\n+                                    U+203A ISO proposed -->\n+<!-- rsaquo is proposed but not yet ISO standardized -->\n+\n+<!-- Currency Symbols -->\n+<!ENTITY euro   \"&#8364;\"> <!--  euro sign, U+20AC NEW -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml10\/xhtml-special.ent","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+<!-- Mathematical, Greek and Symbolic characters for XHTML -->\n+\n+<!-- Character entity set. Typical invocation:\n+     <!ENTITY % HTMLsymbol PUBLIC\n+        \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+        \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-symbol.ent\">\n+     %HTMLsymbol;\n+-->\n+\n+<!-- Portions (C) International Organization for Standardization 1986:\n+     Permission to copy in any form is granted for use with\n+     conforming SGML systems and applications as defined in\n+     ISO 8879, provided this notice is included in all copies.\n+-->\n+\n+<!-- Relevant ISO entity set is given unless names are newly introduced.\n+     New names (i.e., not in ISO 8879 list) do not clash with any\n+     existing ISO 8879 entity names. ISO 10646 character numbers\n+     are given for each character, in hex. values are decimal\n+     conversions of the ISO 10646 values and refer to the document\n+     character set. Names are Unicode names. \n+-->\n+\n+<!-- Latin Extended-B -->\n+<!ENTITY fnof     \"&#402;\"> <!-- latin small letter f with hook = function\n+                                    = florin, U+0192 ISOtech -->\n+\n+<!-- Greek -->\n+<!ENTITY Alpha    \"&#913;\"> <!-- greek capital letter alpha, U+0391 -->\n+<!ENTITY Beta     \"&#914;\"> <!-- greek capital letter beta, U+0392 -->\n+<!ENTITY Gamma    \"&#915;\"> <!-- greek capital letter gamma,\n+                                    U+0393 ISOgrk3 -->\n+<!ENTITY Delta    \"&#916;\"> <!-- greek capital letter delta,\n+                                    U+0394 ISOgrk3 -->\n+<!ENTITY Epsilon  \"&#917;\"> <!-- greek capital letter epsilon, U+0395 -->\n+<!ENTITY Zeta     \"&#918;\"> <!-- greek capital letter zeta, U+0396 -->\n+<!ENTITY Eta      \"&#919;\"> <!-- greek capital letter eta, U+0397 -->\n+<!ENTITY Theta    \"&#920;\"> <!-- greek capital letter theta,\n+                                    U+0398 ISOgrk3 -->\n+<!ENTITY Iota     \"&#921;\"> <!-- greek capital letter iota, U+0399 -->\n+<!ENTITY Kappa    \"&#922;\"> <!-- greek capital letter kappa, U+039A -->\n+<!ENTITY Lambda   \"&#923;\"> <!-- greek capital letter lamda,\n+                                    U+039B ISOgrk3 -->\n+<!ENTITY Mu       \"&#924;\"> <!-- greek capital letter mu, U+039C -->\n+<!ENTITY Nu       \"&#925;\"> <!-- greek capital letter nu, U+039D -->\n+<!ENTITY Xi       \"&#926;\"> <!-- greek capital letter xi, U+039E ISOgrk3 -->\n+<!ENTITY Omicron  \"&#927;\"> <!-- greek capital letter omicron, U+039F -->\n+<!ENTITY Pi       \"&#928;\"> <!-- greek capital letter pi, U+03A0 ISOgrk3 -->\n+<!ENTITY Rho      \"&#929;\"> <!-- greek capital letter rho, U+03A1 -->\n+<!-- there is no Sigmaf, and no U+03A2 character either -->\n+<!ENTITY Sigma    \"&#931;\"> <!-- greek capital letter sigma,\n+                                    U+03A3 ISOgrk3 -->\n+<!ENTITY Tau      \"&#932;\"> <!-- greek capital letter tau, U+03A4 -->\n+<!ENTITY Upsilon  \"&#933;\"> <!-- greek capital letter upsilon,\n+                                    U+03A5 ISOgrk3 -->\n+<!ENTITY Phi      \"&#934;\"> <!-- greek capital letter phi,\n+                                    U+03A6 ISOgrk3 -->\n+<!ENTITY Chi      \"&#935;\"> <!-- greek capital letter chi, U+03A7 -->\n+<!ENTITY Psi      \"&#936;\"> <!-- greek capital letter psi,\n+                                    U+03A8 ISOgrk3 -->\n+<!ENTITY Omega    \"&#937;\"> <!-- greek capital letter omega,\n+                                    U+03A9 ISOgrk3 -->\n+\n+<!ENTITY alpha    \"&#945;\"> <!-- greek small letter alpha,\n+                                    U+03B1 ISOgrk3 -->\n+<!ENTITY beta     \"&#946;\"> <!-- greek small letter beta, U+03B2 ISOgrk3 -->\n+<!ENTITY gamma    \"&#947;\"> <!-- greek small letter gamma,\n+                                    U+03B3 ISOgrk3 -->\n+<!ENTITY delta    \"&#948;\"> <!-- greek small letter delta,\n+                                    U+03B4 ISOgrk3 -->\n+<!ENTITY epsilon  \"&#949;\"> <!-- greek small letter epsilon,\n+                                    U+03B5 ISOgrk3 -->\n+<!ENTITY zeta     \"&#950;\"> <!-- greek small letter zeta, U+03B6 ISOgrk3 -->\n+<!ENTITY eta      \"&#951;\"> <!-- greek small letter eta, U+03B7 ISOgrk3 -->\n+<!ENTITY theta    \"&#952;\"> <!-- greek small letter theta,\n+                                    U+03B8 ISOgrk3 -->\n+<!ENTITY iota     \"&#953;\"> <!-- greek small letter iota, U+03B9 ISOgrk3 -->\n+<!ENTITY kappa    \"&#954;\"> <!-- greek small letter kappa,\n+                                    U+03BA ISOgrk3 -->\n+<!ENTITY lambda   \"&#955;\"> <!-- greek small letter lamda,\n+                                    U+03BB ISOgrk3 -->\n+<!ENTITY mu       \"&#956;\"> <!-- greek small letter mu, U+03BC ISOgrk3 -->\n+<!ENTITY nu       \"&#957;\"> <!-- greek small letter nu, U+03BD ISOgrk3 -->\n+<!ENTITY xi       \"&#958;\"> <!-- greek small letter xi, U+03BE ISOgrk3 -->\n+<!ENTITY omicron  \"&#959;\"> <!-- greek small letter omicron, U+03BF NEW -->\n+<!ENTITY pi       \"&#960;\"> <!-- greek small letter pi, U+03C0 ISOgrk3 -->\n+<!ENTITY rho      \"&#961;\"> <!-- greek small letter rho, U+03C1 ISOgrk3 -->\n+<!ENTITY sigmaf   \"&#962;\"> <!-- greek small letter final sigma,\n+                                    U+03C2 ISOgrk3 -->\n+<!ENTITY sigma    \"&#963;\"> <!-- greek small letter sigma,\n+                                    U+03C3 ISOgrk3 -->\n+<!ENTITY tau      \"&#964;\"> <!-- greek small letter tau, U+03C4 ISOgrk3 -->\n+<!ENTITY upsilon  \"&#965;\"> <!-- greek small letter upsilon,\n+                                    U+03C5 ISOgrk3 -->\n+<!ENTITY phi      \"&#966;\"> <!-- greek small letter phi, U+03C6 ISOgrk3 -->\n+<!ENTITY chi      \"&#967;\"> <!-- greek small letter chi, U+03C7 ISOgrk3 -->\n+<!ENTITY psi      \"&#968;\"> <!-- greek small letter psi, U+03C8 ISOgrk3 -->\n+<!ENTITY omega    \"&#969;\"> <!-- greek small letter omega,\n+                                    U+03C9 ISOgrk3 -->\n+<!ENTITY thetasym \"&#977;\"> <!-- greek theta symbol,\n+                                    U+03D1 NEW -->\n+<!ENTITY upsih    \"&#978;\"> <!-- greek upsilon with hook symbol,\n+                                    U+03D2 NEW -->\n+<!ENTITY piv      \"&#982;\"> <!-- greek pi symbol, U+03D6 ISOgrk3 -->\n+\n+<!-- General Punctuation -->\n+<!ENTITY bull     \"&#8226;\"> <!-- bullet = black small circle,\n+                                     U+2022 ISOpub  -->\n+<!-- bullet is NOT the same as bullet operator, U+2219 -->\n+<!ENTITY hellip   \"&#8230;\"> <!-- horizontal ellipsis = three dot leader,\n+                                     U+2026 ISOpub  -->\n+<!ENTITY prime    \"&#8242;\"> <!-- prime = minutes = feet, U+2032 ISOtech -->\n+<!ENTITY Prime    \"&#8243;\"> <!-- double prime = seconds = inches,\n+                                     U+2033 ISOtech -->\n+<!ENTITY oline    \"&#8254;\"> <!-- overline = spacing overscore,\n+                                     U+203E NEW -->\n+<!ENTITY frasl    \"&#8260;\"> <!-- fraction slash, U+2044 NEW -->\n+\n+<!-- Letterlike Symbols -->\n+<!ENTITY weierp   \"&#8472;\"> <!-- script capital P = power set\n+                                     = Weierstrass p, U+2118 ISOamso -->\n+<!ENTITY image    \"&#8465;\"> <!-- black-letter capital I = imaginary part,\n+                                     U+2111 ISOamso -->\n+<!ENTITY real     \"&#8476;\"> <!-- black-letter capital R = real part symbol,\n+                                     U+211C ISOamso -->\n+<!ENTITY trade    \"&#8482;\"> <!-- trade mark sign, U+2122 ISOnum -->\n+<!ENTITY alefsym  \"&#8501;\"> <!-- alef symbol = first transfinite cardinal,\n+                                     U+2135 NEW -->\n+<!-- alef symbol is NOT the same as hebrew letter alef,\n+     U+05D0 although the same glyph could be used to depict both characters -->\n+\n+<!-- Arrows -->\n+<!ENTITY larr     \"&#8592;\"> <!-- leftwards arrow, U+2190 ISOnum -->\n+<!ENTITY uarr     \"&#8593;\"> <!-- upwards arrow, U+2191 ISOnum-->\n+<!ENTITY rarr     \"&#8594;\"> <!-- rightwards arrow, U+2192 ISOnum -->\n+<!ENTITY darr     \"&#8595;\"> <!-- downwards arrow, U+2193 ISOnum -->\n+<!ENTITY harr     \"&#8596;\"> <!-- left right arrow, U+2194 ISOamsa -->\n+<!ENTITY crarr    \"&#8629;\"> <!-- downwards arrow with corner leftwards\n+                                     = carriage return, U+21B5 NEW -->\n+<!ENTITY lArr     \"&#8656;\"> <!-- leftwards double arrow, U+21D0 ISOtech -->\n+<!-- Unicode does not say that lArr is the same as the 'is implied by' arrow\n+    but also does not have any other character for that function. So lArr can\n+    be used for 'is implied by' as ISOtech suggests -->\n+<!ENTITY uArr     \"&#8657;\"> <!-- upwards double arrow, U+21D1 ISOamsa -->\n+<!ENTITY rArr     \"&#8658;\"> <!-- rightwards double arrow,\n+                                     U+21D2 ISOtech -->\n+<!-- Unicode does not say this is the 'implies' character but does not have \n+     another character with this function so rArr can be used for 'implies'\n+     as ISOtech suggests -->\n+<!ENTITY dArr     \"&#8659;\"> <!-- downwards double arrow, U+21D3 ISOamsa -->\n+<!ENTITY hArr     \"&#8660;\"> <!-- left right double arrow,\n+                                     U+21D4 ISOamsa -->\n+\n+<!-- Mathematical Operators -->\n+<!ENTITY forall   \"&#8704;\"> <!-- for all, U+2200 ISOtech -->\n+<!ENTITY part     \"&#8706;\"> <!-- partial differential, U+2202 ISOtech  -->\n+<!ENTITY exist    \"&#8707;\"> <!-- there exists, U+2203 ISOtech -->\n+<!ENTITY empty    \"&#8709;\"> <!-- empty set = null set, U+2205 ISOamso -->\n+<!ENTITY nabla    \"&#8711;\"> <!-- nabla = backward difference,\n+                                     U+2207 ISOtech -->\n+<!ENTITY isin     \"&#8712;\"> <!-- element of, U+2208 ISOtech -->\n+<!ENTITY notin    \"&#8713;\"> <!-- not an element of, U+2209 ISOtech -->\n+<!ENTITY ni       \"&#8715;\"> <!-- contains as member, U+220B ISOtech -->\n+<!ENTITY prod     \"&#8719;\"> <!-- n-ary product = product sign,\n+                                     U+220F ISOamsb -->\n+<!-- prod is NOT the same character as U+03A0 'greek capital letter pi' though\n+     the same glyph might be used for both -->\n+<!ENTITY sum      \"&#8721;\"> <!-- n-ary summation, U+2211 ISOamsb -->\n+<!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n+     though the same glyph might be used for both -->\n+<!ENTITY minus    \"&#8722;\"> <!-- minus sign, U+2212 ISOtech -->\n+<!ENTITY lowast   \"&#8727;\"> <!-- asterisk operator, U+2217 ISOtech -->\n+<!ENTITY radic    \"&#8730;\"> <!-- square root = radical sign,\n+                                     U+221A ISOtech -->\n+<!ENTITY prop     \"&#8733;\"> <!-- proportional to, U+221D ISOtech -->\n+<!ENTITY infin    \"&#8734;\"> <!-- infinity, U+221E ISOtech -->\n+<!ENTITY ang      \"&#8736;\"> <!-- angle, U+2220 ISOamso -->\n+<!ENTITY and      \"&#8743;\"> <!-- logical and = wedge, U+2227 ISOtech -->\n+<!ENTITY or       \"&#8744;\"> <!-- logical or = vee, U+2228 ISOtech -->\n+<!ENTITY cap      \"&#8745;\"> <!-- intersection = cap, U+2229 ISOtech -->\n+<!ENTITY cup      \"&#8746;\"> <!-- union = cup, U+222A ISOtech -->\n+<!ENTITY int      \"&#8747;\"> <!-- integral, U+222B ISOtech -->\n+<!ENTITY there4   \"&#8756;\"> <!-- therefore, U+2234 ISOtech -->\n+<!ENTITY sim      \"&#8764;\"> <!-- tilde operator = varies with = similar to,\n+                                     U+223C ISOtech -->\n+<!-- tilde operator is NOT the same character as the tilde, U+007E,\n+     although the same glyph might be used to represent both  -->\n+<!ENTITY cong     \"&#8773;\"> <!-- approximately equal to, U+2245 ISOtech -->\n+<!ENTITY asymp    \"&#8776;\"> <!-- almost equal to = asymptotic to,\n+                                     U+2248 ISOamsr -->\n+<!ENTITY ne       \"&#8800;\"> <!-- not equal to, U+2260 ISOtech -->\n+<!ENTITY equiv    \"&#8801;\"> <!-- identical to, U+2261 ISOtech -->\n+<!ENTITY le       \"&#8804;\"> <!-- less-than or equal to, U+2264 ISOtech -->\n+<!ENTITY ge       \"&#8805;\"> <!-- greater-than or equal to,\n+                                     U+2265 ISOtech -->\n+<!ENTITY sub      \"&#8834;\"> <!-- subset of, U+2282 ISOtech -->\n+<!ENTITY sup      \"&#8835;\"> <!-- superset of, U+2283 ISOtech -->\n+<!ENTITY nsub     \"&#8836;\"> <!-- not a subset of, U+2284 ISOamsn -->\n+<!ENTITY sube     \"&#8838;\"> <!-- subset of or equal to, U+2286 ISOtech -->\n+<!ENTITY supe     \"&#8839;\"> <!-- superset of or equal to,\n+                                     U+2287 ISOtech -->\n+<!ENTITY oplus    \"&#8853;\"> <!-- circled plus = direct sum,\n+                                     U+2295 ISOamsb -->\n+<!ENTITY otimes   \"&#8855;\"> <!-- circled times = vector product,\n+                                     U+2297 ISOamsb -->\n+<!ENTITY perp     \"&#8869;\"> <!-- up tack = orthogonal to = perpendicular,\n+                                     U+22A5 ISOtech -->\n+<!ENTITY sdot     \"&#8901;\"> <!-- dot operator, U+22C5 ISOamsb -->\n+<!-- dot operator is NOT the same character as U+00B7 middle dot -->\n+\n+<!-- Miscellaneous Technical -->\n+<!ENTITY lceil    \"&#8968;\"> <!-- left ceiling = APL upstile,\n+                                     U+2308 ISOamsc  -->\n+<!ENTITY rceil    \"&#8969;\"> <!-- right ceiling, U+2309 ISOamsc  -->\n+<!ENTITY lfloor   \"&#8970;\"> <!-- left floor = APL downstile,\n+                                     U+230A ISOamsc  -->\n+<!ENTITY rfloor   \"&#8971;\"> <!-- right floor, U+230B ISOamsc  -->\n+<!ENTITY lang     \"&#9001;\"> <!-- left-pointing angle bracket = bra,\n+                                     U+2329 ISOtech -->\n+<!-- lang is NOT the same character as U+003C 'less than sign' \n+     or U+2039 'single left-pointing angle quotation mark' -->\n+<!ENTITY rang     \"&#9002;\"> <!-- right-pointing angle bracket = ket,\n+                                     U+232A ISOtech -->\n+<!-- rang is NOT the same character as U+003E 'greater than sign' \n+     or U+203A 'single right-pointing angle quotation mark' -->\n+\n+<!-- Geometric Shapes -->\n+<!ENTITY loz      \"&#9674;\"> <!-- lozenge, U+25CA ISOpub -->\n+\n+<!-- Miscellaneous Symbols -->\n+<!ENTITY spades   \"&#9824;\"> <!-- black spade suit, U+2660 ISOpub -->\n+<!-- black here seems to mean filled as opposed to hollow -->\n+<!ENTITY clubs    \"&#9827;\"> <!-- black club suit = shamrock,\n+                                     U+2663 ISOpub -->\n+<!ENTITY hearts   \"&#9829;\"> <!-- black heart suit = valentine,\n+                                     U+2665 ISOpub -->\n+<!ENTITY diams    \"&#9830;\"> <!-- black diamond suit, U+2666 ISOpub -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml10\/xhtml-symbol.ent","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,1235 @@\n+<!--\n+   Extensible HTML version 1.0 Frameset DTD\n+\n+   This is the same as HTML 4 Frameset except for\n+   changes due to the differences between XML and SGML.\n+\n+   Namespace = http:\/\/www.w3.org\/1999\/xhtml\n+\n+   For further information, see: http:\/\/www.w3.org\/TR\/xhtml1\n+\n+   Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),\n+   All Rights Reserved. \n+\n+   This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+   PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Frameset\/\/EN\"\n+   SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-frameset.dtd\"\n+\n+   $Revision: 1.26 $\n+   $Date: 2002\/08\/01 18:16:48 $\n+\n+-->\n+\n+<!--================ Character mnemonic entities =========================-->\n+\n+<!ENTITY % HTMLlat1 PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+   \"xhtml-lat1.ent\">\n+%HTMLlat1;\n+\n+<!ENTITY % HTMLsymbol PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+   \"xhtml-symbol.ent\">\n+%HTMLsymbol;\n+\n+<!ENTITY % HTMLspecial PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+   \"xhtml-special.ent\">\n+%HTMLspecial;\n+\n+<!--================== Imported Names ====================================-->\n+\n+<!ENTITY % ContentType \"CDATA\">\n+    <!-- media type, as per [RFC2045] -->\n+\n+<!ENTITY % ContentTypes \"CDATA\">\n+    <!-- comma-separated list of media types, as per [RFC2045] -->\n+\n+<!ENTITY % Charset \"CDATA\">\n+    <!-- a character encoding, as per [RFC2045] -->\n+\n+<!ENTITY % Charsets \"CDATA\">\n+    <!-- a space separated list of character encodings, as per [RFC2045] -->\n+\n+<!ENTITY % LanguageCode \"NMTOKEN\">\n+    <!-- a language code, as per [RFC3066] -->\n+\n+<!ENTITY % Character \"CDATA\">\n+    <!-- a single character, as per section 2.2 of [XML] -->\n+\n+<!ENTITY % Number \"CDATA\">\n+    <!-- one or more digits -->\n+\n+<!ENTITY % LinkTypes \"CDATA\">\n+    <!-- space-separated list of link types -->\n+\n+<!ENTITY % MediaDesc \"CDATA\">\n+    <!-- single or comma-separated list of media descriptors -->\n+\n+<!ENTITY % URI \"CDATA\">\n+    <!-- a Uniform Resource Identifier, see [RFC2396] -->\n+\n+<!ENTITY % UriList \"CDATA\">\n+    <!-- a space separated list of Uniform Resource Identifiers -->\n+\n+<!ENTITY % Datetime \"CDATA\">\n+    <!-- date and time information. ISO date format -->\n+\n+<!ENTITY % Script \"CDATA\">\n+    <!-- script expression -->\n+\n+<!ENTITY % StyleSheet \"CDATA\">\n+    <!-- style sheet data -->\n+\n+<!ENTITY % Text \"CDATA\">\n+    <!-- used for titles etc. -->\n+\n+<!ENTITY % FrameTarget \"NMTOKEN\">\n+    <!-- render in this frame -->\n+\n+<!ENTITY % Length \"CDATA\">\n+    <!-- nn for pixels or nn% for percentage length -->\n+\n+<!ENTITY % MultiLength \"CDATA\">\n+    <!-- pixel, percentage, or relative -->\n+\n+<!ENTITY % MultiLengths \"CDATA\">\n+    <!-- comma-separated list of MultiLength -->\n+\n+<!ENTITY % Pixels \"CDATA\">\n+    <!-- integer representing length in pixels -->\n+\n+<!-- these are used for image maps -->\n+\n+<!ENTITY % Shape \"(rect|circle|poly|default)\">\n+\n+<!ENTITY % Coords \"CDATA\">\n+    <!-- comma separated list of lengths -->\n+\n+<!-- used for object, applet, img, input and iframe -->\n+<!ENTITY % ImgAlign \"(top|middle|bottom|left|right)\">\n+\n+<!-- a color using sRGB: #RRGGBB as Hex values -->\n+<!ENTITY % Color \"CDATA\">\n+\n+<!-- There are also 16 widely known color names with their sRGB values:\n+\n+    Black  = #000000    Green  = #008000\n+    Silver = #C0C0C0    Lime   = #00FF00\n+    Gray   = #808080    Olive  = #808000\n+    White  = #FFFFFF    Yellow = #FFFF00\n+    Maroon = #800000    Navy   = #000080\n+    Red    = #FF0000    Blue   = #0000FF\n+    Purple = #800080    Teal   = #008080\n+    Fuchsia= #FF00FF    Aqua   = #00FFFF\n+-->\n+\n+<!--=================== Generic Attributes ===============================-->\n+\n+<!-- core attributes common to most elements\n+  id       document-wide unique id\n+  class    space separated list of classes\n+  style    associated style info\n+  title    advisory title\/amplification\n+-->\n+<!ENTITY % coreattrs\n+ \"id          ID             #IMPLIED\n+  class       CDATA          #IMPLIED\n+  style       %StyleSheet;   #IMPLIED\n+  title       %Text;         #IMPLIED\"\n+  >\n+\n+<!-- internationalization attributes\n+  lang        language code (backwards compatible)\n+  xml:lang    language code (as per XML 1.0 spec)\n+  dir         direction for weak\/neutral text\n+-->\n+<!ENTITY % i18n\n+ \"lang        %LanguageCode; #IMPLIED\n+  xml:lang    %LanguageCode; #IMPLIED\n+  dir         (ltr|rtl)      #IMPLIED\"\n+  >\n+\n+<!-- attributes for common UI events\n+  onclick     a pointer button was clicked\n+  ondblclick  a pointer button was double clicked\n+  onmousedown a pointer button was pressed down\n+  onmouseup   a pointer button was released\n+  onmousemove a pointer was moved onto the element\n+  onmouseout  a pointer was moved away from the element\n+  onkeypress  a key was pressed and released\n+  onkeydown   a key was pressed down\n+  onkeyup     a key was released\n+-->\n+<!ENTITY % events\n+ \"onclick     %Script;       #IMPLIED\n+  ondblclick  %Script;       #IMPLIED\n+  onmousedown %Script;       #IMPLIED\n+  onmouseup   %Script;       #IMPLIED\n+  onmouseover %Script;       #IMPLIED\n+  onmousemove %Script;       #IMPLIED\n+  onmouseout  %Script;       #IMPLIED\n+  onkeypress  %Script;       #IMPLIED\n+  onkeydown   %Script;       #IMPLIED\n+  onkeyup     %Script;       #IMPLIED\"\n+  >\n+\n+<!-- attributes for elements that can get the focus\n+  accesskey   accessibility key character\n+  tabindex    position in tabbing order\n+  onfocus     the element got the focus\n+  onblur      the element lost the focus\n+-->\n+<!ENTITY % focus\n+ \"accesskey   %Character;    #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\"\n+  >\n+\n+<!ENTITY % attrs \"%coreattrs; %i18n; %events;\">\n+\n+<!-- text alignment for p, div, h1-h6. The default is\n+     align=\"left\" for ltr headings, \"right\" for rtl -->\n+\n+<!ENTITY % TextAlign \"align (left|center|right|justify) #IMPLIED\">\n+\n+<!--=================== Text Elements ====================================-->\n+\n+<!ENTITY % special.extra\n+   \"object | applet | img | map | iframe\">\n+\t\n+<!ENTITY % special.basic\n+\t\"br | span | bdo\">\n+\n+<!ENTITY % special\n+   \"%special.basic; | %special.extra;\">\n+\n+<!ENTITY % fontstyle.extra \"big | small | font | basefont\">\n+\n+<!ENTITY % fontstyle.basic \"tt | i | b | u\n+                      | s | strike \">\n+\n+<!ENTITY % fontstyle \"%fontstyle.basic; | %fontstyle.extra;\">\n+\n+<!ENTITY % phrase.extra \"sub | sup\">\n+<!ENTITY % phrase.basic \"em | strong | dfn | code | q |\n+                   samp | kbd | var | cite | abbr | acronym\">\n+\n+<!ENTITY % phrase \"%phrase.basic; | %phrase.extra;\">\n+\n+<!ENTITY % inline.forms \"input | select | textarea | label | button\">\n+\n+<!-- these can occur at block or inline level -->\n+<!ENTITY % misc.inline \"ins | del | script\">\n+\n+<!-- these can only occur at block level -->\n+<!ENTITY % misc \"noscript | %misc.inline;\">\n+\n+\n+<!ENTITY % inline \"a | %special; | %fontstyle; | %phrase; | %inline.forms;\">\n+\n+<!-- %Inline; covers inline or \"text-level\" elements -->\n+<!ENTITY % Inline \"(#PCDATA | %inline; | %misc.inline;)*\">\n+\n+<!--================== Block level elements ==============================-->\n+\n+<!ENTITY % heading \"h1|h2|h3|h4|h5|h6\">\n+<!ENTITY % lists \"ul | ol | dl | menu | dir\">\n+<!ENTITY % blocktext \"pre | hr | blockquote | address | center\">\n+\n+<!ENTITY % block\n+    \"p | %heading; | div | %lists; | %blocktext; | isindex | fieldset | table\">\n+\n+<!-- %Flow; mixes block and inline and is used for list items etc. -->\n+<!ENTITY % Flow \"(#PCDATA | %block; | form | %inline; | %misc;)*\">\n+\n+<!--================== Content models for exclusions =====================-->\n+\n+<!-- a elements use %Inline; excluding a -->\n+\n+<!ENTITY % a.content\n+   \"(#PCDATA | %special; | %fontstyle; | %phrase; | %inline.forms; | %misc.inline;)*\">\n+\n+<!-- pre uses %Inline excluding img, object, applet, big, small,\n+     sub, sup, font, or basefont -->\n+\n+<!ENTITY % pre.content\n+   \"(#PCDATA | a | %special.basic; | %fontstyle.basic; | %phrase.basic; |\n+\t   %inline.forms; | %misc.inline;)*\">\n+\n+\n+<!-- form uses %Flow; excluding form -->\n+\n+<!ENTITY % form.content \"(#PCDATA | %block; | %inline; | %misc;)*\">\n+\n+<!-- button uses %Flow; but excludes a, form, form controls, iframe -->\n+\n+<!ENTITY % button.content\n+   \"(#PCDATA | p | %heading; | div | %lists; | %blocktext; |\n+      table | br | span | bdo | object | applet | img | map |\n+      %fontstyle; | %phrase; | %misc;)*\">\n+\n+<!--================ Document Structure ==================================-->\n+\n+<!-- the namespace URI designates the document profile -->\n+\n+<!ELEMENT html (head, frameset)>\n+<!ATTLIST html\n+  %i18n;\n+  id          ID             #IMPLIED\n+  xmlns       %URI;          #FIXED 'http:\/\/www.w3.org\/1999\/xhtml'\n+  >\n+\n+<!--================ Document Head =======================================-->\n+\n+<!ENTITY % head.misc \"(script|style|meta|link|object|isindex)*\">\n+\n+<!-- content model is %head.misc; combined with a single\n+     title and an optional base element in any order -->\n+\n+<!ELEMENT head (%head.misc;,\n+     ((title, %head.misc;, (base, %head.misc;)?) |\n+      (base, %head.misc;, (title, %head.misc;))))>\n+\n+<!ATTLIST head\n+  %i18n;\n+  id          ID             #IMPLIED\n+  profile     %URI;          #IMPLIED\n+  >\n+\n+<!-- The title element is not considered part of the flow of text.\n+       It should be displayed, for example as the page header or\n+       window title. Exactly one title is required per document.\n+    -->\n+<!ELEMENT title (#PCDATA)>\n+<!ATTLIST title \n+  %i18n;\n+  id          ID             #IMPLIED\n+  >\n+\n+<!-- document base URI -->\n+\n+<!ELEMENT base EMPTY>\n+<!ATTLIST base\n+  id          ID             #IMPLIED\n+  href        %URI;          #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!-- generic metainformation -->\n+<!ELEMENT meta EMPTY>\n+<!ATTLIST meta\n+  %i18n;\n+  id          ID             #IMPLIED\n+  http-equiv  CDATA          #IMPLIED\n+  name        CDATA          #IMPLIED\n+  content     CDATA          #REQUIRED\n+  scheme      CDATA          #IMPLIED\n+  >\n+\n+<!--\n+  Relationship values can be used in principle:\n+\n+   a) for document specific toolbars\/menus when used\n+      with the link element in document head e.g.\n+        start, contents, previous, next, index, end, help\n+   b) to link to a separate style sheet (rel=\"stylesheet\")\n+   c) to make a link to a script (rel=\"script\")\n+   d) by stylesheets to control how collections of\n+      html nodes are rendered into printed documents\n+   e) to make a link to a printable version of this document\n+      e.g. a PostScript or PDF version (rel=\"alternate\" media=\"print\")\n+-->\n+\n+<!ELEMENT link EMPTY>\n+<!ATTLIST link\n+  %attrs;\n+  charset     %Charset;      #IMPLIED\n+  href        %URI;          #IMPLIED\n+  hreflang    %LanguageCode; #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  rel         %LinkTypes;    #IMPLIED\n+  rev         %LinkTypes;    #IMPLIED\n+  media       %MediaDesc;    #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!-- style info, which may include CDATA sections -->\n+<!ELEMENT style (#PCDATA)>\n+<!ATTLIST style\n+  %i18n;\n+  id          ID             #IMPLIED\n+  type        %ContentType;  #REQUIRED\n+  media       %MediaDesc;    #IMPLIED\n+  title       %Text;         #IMPLIED\n+  xml:space   (preserve)     #FIXED 'preserve'\n+  >\n+\n+<!-- script statements, which may include CDATA sections -->\n+<!ELEMENT script (#PCDATA)>\n+<!ATTLIST script\n+  id          ID             #IMPLIED\n+  charset     %Charset;      #IMPLIED\n+  type        %ContentType;  #REQUIRED\n+  language    CDATA          #IMPLIED\n+  src         %URI;          #IMPLIED\n+  defer       (defer)        #IMPLIED\n+  xml:space   (preserve)     #FIXED 'preserve'\n+  >\n+\n+<!-- alternate content container for non script-based rendering -->\n+\n+<!ELEMENT noscript %Flow;>\n+<!ATTLIST noscript\n+  %attrs;\n+  >\n+\n+<!--======================= Frames =======================================-->\n+\n+<!-- only one noframes element permitted per document -->\n+\n+<!ELEMENT frameset (frameset|frame|noframes)*>\n+<!ATTLIST frameset\n+  %coreattrs;\n+  rows        %MultiLengths; #IMPLIED\n+  cols        %MultiLengths; #IMPLIED\n+  onload      %Script;       #IMPLIED\n+  onunload    %Script;       #IMPLIED\n+  >\n+\n+<!-- reserved frame names start with \"_\" otherwise starts with letter -->\n+\n+<!-- tiled window within frameset -->\n+\n+<!ELEMENT frame EMPTY>\n+<!ATTLIST frame\n+  %coreattrs;\n+  longdesc    %URI;          #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  src         %URI;          #IMPLIED\n+  frameborder (1|0)          \"1\"\n+  marginwidth %Pixels;       #IMPLIED\n+  marginheight %Pixels;      #IMPLIED\n+  noresize    (noresize)     #IMPLIED\n+  scrolling   (yes|no|auto)  \"auto\"\n+  >\n+\n+<!-- inline subwindow -->\n+\n+<!ELEMENT iframe %Flow;>\n+<!ATTLIST iframe\n+  %coreattrs;\n+  longdesc    %URI;          #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  src         %URI;          #IMPLIED\n+  frameborder (1|0)          \"1\"\n+  marginwidth %Pixels;       #IMPLIED\n+  marginheight %Pixels;      #IMPLIED\n+  scrolling   (yes|no|auto)  \"auto\"\n+  align       %ImgAlign;     #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  >\n+\n+<!-- alternate content container for non frame-based rendering -->\n+\n+<!ELEMENT noframes (body)>\n+<!ATTLIST noframes\n+  %attrs;\n+  >\n+\n+<!--=================== Document Body ====================================-->\n+\n+<!ELEMENT body %Flow;>\n+<!ATTLIST body\n+  %attrs;\n+  onload      %Script;       #IMPLIED\n+  onunload    %Script;       #IMPLIED\n+  background  %URI;          #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  text        %Color;        #IMPLIED\n+  link        %Color;        #IMPLIED\n+  vlink       %Color;        #IMPLIED\n+  alink       %Color;        #IMPLIED\n+  >\n+\n+<!ELEMENT div %Flow;>  <!-- generic language\/style container -->\n+<!ATTLIST div\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!--=================== Paragraphs =======================================-->\n+\n+<!ELEMENT p %Inline;>\n+<!ATTLIST p\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!--=================== Headings =========================================-->\n+\n+<!--\n+  There are six levels of headings from h1 (the most important)\n+  to h6 (the least important).\n+-->\n+\n+<!ELEMENT h1  %Inline;>\n+<!ATTLIST h1\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h2 %Inline;>\n+<!ATTLIST h2\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h3 %Inline;>\n+<!ATTLIST h3\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h4 %Inline;>\n+<!ATTLIST h4\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h5 %Inline;>\n+<!ATTLIST h5\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h6 %Inline;>\n+<!ATTLIST h6\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!--=================== Lists ============================================-->\n+\n+<!-- Unordered list bullet styles -->\n+\n+<!ENTITY % ULStyle \"(disc|square|circle)\">\n+\n+<!-- Unordered list -->\n+\n+<!ELEMENT ul (li)+>\n+<!ATTLIST ul\n+  %attrs;\n+  type        %ULStyle;     #IMPLIED\n+  compact     (compact)     #IMPLIED\n+  >\n+\n+<!-- Ordered list numbering style\n+\n+    1   arabic numbers      1, 2, 3, ...\n+    a   lower alpha         a, b, c, ...\n+    A   upper alpha         A, B, C, ...\n+    i   lower roman         i, ii, iii, ...\n+    I   upper roman         I, II, III, ...\n+\n+    The style is applied to the sequence number which by default\n+    is reset to 1 for the first list item in an ordered list.\n+-->\n+<!ENTITY % OLStyle \"CDATA\">\n+\n+<!-- Ordered (numbered) list -->\n+\n+<!ELEMENT ol (li)+>\n+<!ATTLIST ol\n+  %attrs;\n+  type        %OLStyle;      #IMPLIED\n+  compact     (compact)      #IMPLIED\n+  start       %Number;       #IMPLIED\n+  >\n+\n+<!-- single column list (DEPRECATED) --> \n+<!ELEMENT menu (li)+>\n+<!ATTLIST menu\n+  %attrs;\n+  compact     (compact)     #IMPLIED\n+  >\n+\n+<!-- multiple column list (DEPRECATED) --> \n+<!ELEMENT dir (li)+>\n+<!ATTLIST dir\n+  %attrs;\n+  compact     (compact)     #IMPLIED\n+  >\n+\n+<!-- LIStyle is constrained to: \"(%ULStyle;|%OLStyle;)\" -->\n+<!ENTITY % LIStyle \"CDATA\">\n+\n+<!-- list item -->\n+\n+<!ELEMENT li %Flow;>\n+<!ATTLIST li\n+  %attrs;\n+  type        %LIStyle;      #IMPLIED\n+  value       %Number;       #IMPLIED\n+  >\n+\n+<!-- definition lists - dt for term, dd for its definition -->\n+\n+<!ELEMENT dl (dt|dd)+>\n+<!ATTLIST dl\n+  %attrs;\n+  compact     (compact)      #IMPLIED\n+  >\n+\n+<!ELEMENT dt %Inline;>\n+<!ATTLIST dt\n+  %attrs;\n+  >\n+\n+<!ELEMENT dd %Flow;>\n+<!ATTLIST dd\n+  %attrs;\n+  >\n+\n+<!--=================== Address ==========================================-->\n+\n+<!-- information on author -->\n+\n+<!ELEMENT address (#PCDATA | %inline; | %misc.inline; | p)*>\n+<!ATTLIST address\n+  %attrs;\n+  >\n+\n+<!--=================== Horizontal Rule ==================================-->\n+\n+<!ELEMENT hr EMPTY>\n+<!ATTLIST hr\n+  %attrs;\n+  align       (left|center|right) #IMPLIED\n+  noshade     (noshade)      #IMPLIED\n+  size        %Pixels;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  >\n+\n+<!--=================== Preformatted Text ================================-->\n+\n+<!-- content is %Inline; excluding \n+        \"img|object|applet|big|small|sub|sup|font|basefont\" -->\n+\n+<!ELEMENT pre %pre.content;>\n+<!ATTLIST pre\n+  %attrs;\n+  width       %Number;      #IMPLIED\n+  xml:space   (preserve)    #FIXED 'preserve'\n+  >\n+\n+<!--=================== Block-like Quotes ================================-->\n+\n+<!ELEMENT blockquote %Flow;>\n+<!ATTLIST blockquote\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  >\n+\n+<!--=================== Text alignment ===================================-->\n+\n+<!-- center content -->\n+<!ELEMENT center %Flow;>\n+<!ATTLIST center\n+  %attrs;\n+  >\n+\n+<!--=================== Inserted\/Deleted Text ============================-->\n+\n+\n+<!--\n+  ins\/del are allowed in block and inline content, but its\n+  inappropriate to include block content within an ins element\n+  occurring in inline content.\n+-->\n+<!ELEMENT ins %Flow;>\n+<!ATTLIST ins\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  datetime    %Datetime;     #IMPLIED\n+  >\n+\n+<!ELEMENT del %Flow;>\n+<!ATTLIST del\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  datetime    %Datetime;     #IMPLIED\n+  >\n+\n+<!--================== The Anchor Element ================================-->\n+\n+<!-- content is %Inline; except that anchors shouldn't be nested -->\n+\n+<!ELEMENT a %a.content;>\n+<!ATTLIST a\n+  %attrs;\n+  %focus;\n+  charset     %Charset;      #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  href        %URI;          #IMPLIED\n+  hreflang    %LanguageCode; #IMPLIED\n+  rel         %LinkTypes;    #IMPLIED\n+  rev         %LinkTypes;    #IMPLIED\n+  shape       %Shape;        \"rect\"\n+  coords      %Coords;       #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!--===================== Inline Elements ================================-->\n+\n+<!ELEMENT span %Inline;> <!-- generic language\/style container -->\n+<!ATTLIST span\n+  %attrs;\n+  >\n+\n+<!ELEMENT bdo %Inline;>  <!-- I18N BiDi over-ride -->\n+<!ATTLIST bdo\n+  %coreattrs;\n+  %events;\n+  lang        %LanguageCode; #IMPLIED\n+  xml:lang    %LanguageCode; #IMPLIED\n+  dir         (ltr|rtl)      #REQUIRED\n+  >\n+\n+<!ELEMENT br EMPTY>   <!-- forced line break -->\n+<!ATTLIST br\n+  %coreattrs;\n+  clear       (left|all|right|none) \"none\"\n+  >\n+\n+<!ELEMENT em %Inline;>   <!-- emphasis -->\n+<!ATTLIST em %attrs;>\n+\n+<!ELEMENT strong %Inline;>   <!-- strong emphasis -->\n+<!ATTLIST strong %attrs;>\n+\n+<!ELEMENT dfn %Inline;>   <!-- definitional -->\n+<!ATTLIST dfn %attrs;>\n+\n+<!ELEMENT code %Inline;>   <!-- program code -->\n+<!ATTLIST code %attrs;>\n+\n+<!ELEMENT samp %Inline;>   <!-- sample -->\n+<!ATTLIST samp %attrs;>\n+\n+<!ELEMENT kbd %Inline;>  <!-- something user would type -->\n+<!ATTLIST kbd %attrs;>\n+\n+<!ELEMENT var %Inline;>   <!-- variable -->\n+<!ATTLIST var %attrs;>\n+\n+<!ELEMENT cite %Inline;>   <!-- citation -->\n+<!ATTLIST cite %attrs;>\n+\n+<!ELEMENT abbr %Inline;>   <!-- abbreviation -->\n+<!ATTLIST abbr %attrs;>\n+\n+<!ELEMENT acronym %Inline;>   <!-- acronym -->\n+<!ATTLIST acronym %attrs;>\n+\n+<!ELEMENT q %Inline;>   <!-- inlined quote -->\n+<!ATTLIST q\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  >\n+\n+<!ELEMENT sub %Inline;> <!-- subscript -->\n+<!ATTLIST sub %attrs;>\n+\n+<!ELEMENT sup %Inline;> <!-- superscript -->\n+<!ATTLIST sup %attrs;>\n+\n+<!ELEMENT tt %Inline;>   <!-- fixed pitch font -->\n+<!ATTLIST tt %attrs;>\n+\n+<!ELEMENT i %Inline;>   <!-- italic font -->\n+<!ATTLIST i %attrs;>\n+\n+<!ELEMENT b %Inline;>   <!-- bold font -->\n+<!ATTLIST b %attrs;>\n+\n+<!ELEMENT big %Inline;>   <!-- bigger font -->\n+<!ATTLIST big %attrs;>\n+\n+<!ELEMENT small %Inline;>   <!-- smaller font -->\n+<!ATTLIST small %attrs;>\n+\n+<!ELEMENT u %Inline;>   <!-- underline -->\n+<!ATTLIST u %attrs;>\n+\n+<!ELEMENT s %Inline;>   <!-- strike-through -->\n+<!ATTLIST s %attrs;>\n+\n+<!ELEMENT strike %Inline;>   <!-- strike-through -->\n+<!ATTLIST strike %attrs;>\n+\n+<!ELEMENT basefont EMPTY>  <!-- base font size -->\n+<!ATTLIST basefont\n+  id          ID             #IMPLIED\n+  size        CDATA          #REQUIRED\n+  color       %Color;        #IMPLIED\n+  face        CDATA          #IMPLIED\n+  >\n+\n+<!ELEMENT font %Inline;> <!-- local change to font -->\n+<!ATTLIST font\n+  %coreattrs;\n+  %i18n;\n+  size        CDATA          #IMPLIED\n+  color       %Color;        #IMPLIED\n+  face        CDATA          #IMPLIED\n+  >\n+\n+<!--==================== Object ======================================-->\n+<!--\n+  object is used to embed objects as part of HTML pages.\n+  param elements should precede other content. Parameters\n+  can also be expressed as attribute\/value pairs on the\n+  object element itself when brevity is desired.\n+-->\n+\n+<!ELEMENT object (#PCDATA | param | %block; | form |%inline; | %misc;)*>\n+<!ATTLIST object\n+  %attrs;\n+  declare     (declare)      #IMPLIED\n+  classid     %URI;          #IMPLIED\n+  codebase    %URI;          #IMPLIED\n+  data        %URI;          #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  codetype    %ContentType;  #IMPLIED\n+  archive     %UriList;      #IMPLIED\n+  standby     %Text;         #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  align       %ImgAlign;     #IMPLIED\n+  border      %Pixels;       #IMPLIED\n+  hspace      %Pixels;       #IMPLIED\n+  vspace      %Pixels;       #IMPLIED\n+  >\n+\n+<!--\n+  param is used to supply a named property value.\n+  In XML it would seem natural to follow RDF and support an\n+  abbreviated syntax where the param elements are replaced\n+  by attribute value pairs on the object start tag.\n+-->\n+<!ELEMENT param EMPTY>\n+<!ATTLIST param\n+  id          ID             #IMPLIED\n+  name        CDATA          #REQUIRED\n+  value       CDATA          #IMPLIED\n+  valuetype   (data|ref|object) \"data\"\n+  type        %ContentType;  #IMPLIED\n+  >\n+\n+<!--=================== Java applet ==================================-->\n+<!--\n+  One of code or object attributes must be present.\n+  Place param elements before other content.\n+-->\n+<!ELEMENT applet (#PCDATA | param | %block; | form | %inline; | %misc;)*>\n+<!ATTLIST applet\n+  %coreattrs;\n+  codebase    %URI;          #IMPLIED\n+  archive     CDATA          #IMPLIED\n+  code        CDATA          #IMPLIED\n+  object      CDATA          #IMPLIED\n+  alt         %Text;         #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  width       %Length;       #REQUIRED\n+  height      %Length;       #REQUIRED\n+  align       %ImgAlign;     #IMPLIED\n+  hspace      %Pixels;       #IMPLIED\n+  vspace      %Pixels;       #IMPLIED\n+  >\n+\n+<!--=================== Images ===========================================-->\n+\n+<!--\n+   To avoid accessibility problems for people who aren't\n+   able to see the image, you should provide a text\n+   description using the alt and longdesc attributes.\n+   In addition, avoid the use of server-side image maps.\n+-->\n+\n+<!ELEMENT img EMPTY>\n+<!ATTLIST img\n+  %attrs;\n+  src         %URI;          #REQUIRED\n+  alt         %Text;         #REQUIRED\n+  name        NMTOKEN        #IMPLIED\n+  longdesc    %URI;          #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  ismap       (ismap)        #IMPLIED\n+  align       %ImgAlign;     #IMPLIED\n+  border      %Pixels;       #IMPLIED\n+  hspace      %Pixels;       #IMPLIED\n+  vspace      %Pixels;       #IMPLIED\n+  >\n+\n+<!-- usemap points to a map element which may be in this document\n+  or an external document, although the latter is not widely supported -->\n+\n+<!--================== Client-side image maps ============================-->\n+\n+<!-- These can be placed in the same document or grouped in a\n+     separate document although this isn't yet widely supported -->\n+\n+<!ELEMENT map ((%block; | form | %misc;)+ | area+)>\n+<!ATTLIST map\n+  %i18n;\n+  %events;\n+  id          ID             #REQUIRED\n+  class       CDATA          #IMPLIED\n+  style       %StyleSheet;   #IMPLIED\n+  title       %Text;         #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  >\n+\n+<!ELEMENT area EMPTY>\n+<!ATTLIST area\n+  %attrs;\n+  %focus;\n+  shape       %Shape;        \"rect\"\n+  coords      %Coords;       #IMPLIED\n+  href        %URI;          #IMPLIED\n+  nohref      (nohref)       #IMPLIED\n+  alt         %Text;         #REQUIRED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!--================ Forms ===============================================-->\n+\n+<!ELEMENT form %form.content;>   <!-- forms shouldn't be nested -->\n+\n+<!ATTLIST form\n+  %attrs;\n+  action      %URI;          #REQUIRED\n+  method      (get|post)     \"get\"\n+  name        NMTOKEN        #IMPLIED\n+  enctype     %ContentType;  \"application\/x-www-form-urlencoded\"\n+  onsubmit    %Script;       #IMPLIED\n+  onreset     %Script;       #IMPLIED\n+  accept      %ContentTypes; #IMPLIED\n+  accept-charset %Charsets;  #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!--\n+  Each label must not contain more than ONE field\n+  Label elements shouldn't be nested.\n+-->\n+<!ELEMENT label %Inline;>\n+<!ATTLIST label\n+  %attrs;\n+  for         IDREF          #IMPLIED\n+  accesskey   %Character;    #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\n+  >\n+\n+<!ENTITY % InputType\n+  \"(text | password | checkbox |\n+    radio | submit | reset |\n+    file | hidden | image | button)\"\n+   >\n+\n+<!-- the name attribute is required for all but submit & reset -->\n+\n+<!ELEMENT input EMPTY>     <!-- form control -->\n+<!ATTLIST input\n+  %attrs;\n+  %focus;\n+  type        %InputType;    \"text\"\n+  name        CDATA          #IMPLIED\n+  value       CDATA          #IMPLIED\n+  checked     (checked)      #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  readonly    (readonly)     #IMPLIED\n+  size        CDATA          #IMPLIED\n+  maxlength   %Number;       #IMPLIED\n+  src         %URI;          #IMPLIED\n+  alt         CDATA          #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  onselect    %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  accept      %ContentTypes; #IMPLIED\n+  align       %ImgAlign;     #IMPLIED\n+  >\n+\n+<!ELEMENT select (optgroup|option)+>  <!-- option selector -->\n+<!ATTLIST select\n+  %attrs;\n+  name        CDATA          #IMPLIED\n+  size        %Number;       #IMPLIED\n+  multiple    (multiple)     #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  >\n+\n+<!ELEMENT optgroup (option)+>   <!-- option group -->\n+<!ATTLIST optgroup\n+  %attrs;\n+  disabled    (disabled)     #IMPLIED\n+  label       %Text;         #REQUIRED\n+  >\n+\n+<!ELEMENT option (#PCDATA)>     <!-- selectable choice -->\n+<!ATTLIST option\n+  %attrs;\n+  selected    (selected)     #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  label       %Text;         #IMPLIED\n+  value       CDATA          #IMPLIED\n+  >\n+\n+<!ELEMENT textarea (#PCDATA)>     <!-- multi-line text field -->\n+<!ATTLIST textarea\n+  %attrs;\n+  %focus;\n+  name        CDATA          #IMPLIED\n+  rows        %Number;       #REQUIRED\n+  cols        %Number;       #REQUIRED\n+  disabled    (disabled)     #IMPLIED\n+  readonly    (readonly)     #IMPLIED\n+  onselect    %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  >\n+\n+<!--\n+  The fieldset element is used to group form fields.\n+  Only one legend element should occur in the content\n+  and if present should only be preceded by whitespace.\n+-->\n+<!ELEMENT fieldset (#PCDATA | legend | %block; | form | %inline; | %misc;)*>\n+<!ATTLIST fieldset\n+  %attrs;\n+  >\n+\n+<!ENTITY % LAlign \"(top|bottom|left|right)\">\n+\n+<!ELEMENT legend %Inline;>     <!-- fieldset label -->\n+<!ATTLIST legend\n+  %attrs;\n+  accesskey   %Character;    #IMPLIED\n+  align       %LAlign;       #IMPLIED\n+  >\n+\n+<!--\n+ Content is %Flow; excluding a, form, form controls, iframe\n+--> \n+<!ELEMENT button %button.content;>  <!-- push button -->\n+<!ATTLIST button\n+  %attrs;\n+  %focus;\n+  name        CDATA          #IMPLIED\n+  value       CDATA          #IMPLIED\n+  type        (button|submit|reset) \"submit\"\n+  disabled    (disabled)     #IMPLIED\n+  >\n+\n+<!-- single-line text input control (DEPRECATED) -->\n+<!ELEMENT isindex EMPTY>\n+<!ATTLIST isindex\n+  %coreattrs;\n+  %i18n;\n+  prompt      %Text;         #IMPLIED\n+  >\n+\n+<!--======================= Tables =======================================-->\n+\n+<!-- Derived from IETF HTML table standard, see [RFC1942] -->\n+\n+<!--\n+ The border attribute sets the thickness of the frame around the\n+ table. The default units are screen pixels.\n+\n+ The frame attribute specifies which parts of the frame around\n+ the table should be rendered. The values are not the same as\n+ CALS to avoid a name clash with the valign attribute.\n+-->\n+<!ENTITY % TFrame \"(void|above|below|hsides|lhs|rhs|vsides|box|border)\">\n+\n+<!--\n+ The rules attribute defines which rules to draw between cells:\n+\n+ If rules is absent then assume:\n+     \"none\" if border is absent or border=\"0\" otherwise \"all\"\n+-->\n+\n+<!ENTITY % TRules \"(none | groups | rows | cols | all)\">\n+  \n+<!-- horizontal placement of table relative to document -->\n+<!ENTITY % TAlign \"(left|center|right)\">\n+\n+<!-- horizontal alignment attributes for cell contents\n+\n+  char        alignment char, e.g. char=\":\"\n+  charoff     offset for alignment char\n+-->\n+<!ENTITY % cellhalign\n+  \"align      (left|center|right|justify|char) #IMPLIED\n+   char       %Character;    #IMPLIED\n+   charoff    %Length;       #IMPLIED\"\n+  >\n+\n+<!-- vertical alignment attributes for cell contents -->\n+<!ENTITY % cellvalign\n+  \"valign     (top|middle|bottom|baseline) #IMPLIED\"\n+  >\n+\n+<!ELEMENT table\n+     (caption?, (col*|colgroup*), thead?, tfoot?, (tbody+|tr+))>\n+<!ELEMENT caption  %Inline;>\n+<!ELEMENT thead    (tr)+>\n+<!ELEMENT tfoot    (tr)+>\n+<!ELEMENT tbody    (tr)+>\n+<!ELEMENT colgroup (col)*>\n+<!ELEMENT col      EMPTY>\n+<!ELEMENT tr       (th|td)+>\n+<!ELEMENT th       %Flow;>\n+<!ELEMENT td       %Flow;>\n+\n+<!ATTLIST table\n+  %attrs;\n+  summary     %Text;         #IMPLIED\n+  width       %Length;       #IMPLIED\n+  border      %Pixels;       #IMPLIED\n+  frame       %TFrame;       #IMPLIED\n+  rules       %TRules;       #IMPLIED\n+  cellspacing %Length;       #IMPLIED\n+  cellpadding %Length;       #IMPLIED\n+  align       %TAlign;       #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  >\n+\n+<!ENTITY % CAlign \"(top|bottom|left|right)\">\n+\n+<!ATTLIST caption\n+  %attrs;\n+  align       %CAlign;       #IMPLIED\n+  >\n+\n+<!--\n+colgroup groups a set of col elements. It allows you to group\n+several semantically related columns together.\n+-->\n+<!ATTLIST colgroup\n+  %attrs;\n+  span        %Number;       \"1\"\n+  width       %MultiLength;  #IMPLIED\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!--\n+ col elements define the alignment properties for cells in\n+ one or more columns.\n+\n+ The width attribute specifies the width of the columns, e.g.\n+\n+     width=64        width in screen pixels\n+     width=0.5*      relative width of 0.5\n+\n+ The span attribute causes the attributes of one\n+ col element to apply to more than one column.\n+-->\n+<!ATTLIST col\n+  %attrs;\n+  span        %Number;       \"1\"\n+  width       %MultiLength;  #IMPLIED\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!--\n+    Use thead to duplicate headers when breaking table\n+    across page boundaries, or for static headers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use tfoot to duplicate footers when breaking table\n+    across page boundaries, or for static footers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use multiple tbody sections when rules are needed\n+    between groups of table rows.\n+-->\n+<!ATTLIST thead\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tfoot\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tbody\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tr\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  bgcolor     %Color;        #IMPLIED\n+  >\n+\n+<!-- Scope is simpler than headers attribute for common tables -->\n+<!ENTITY % Scope \"(row|col|rowgroup|colgroup)\">\n+\n+<!-- th is for headers, td for data and for cells acting as both -->\n+\n+<!ATTLIST th\n+  %attrs;\n+  abbr        %Text;         #IMPLIED\n+  axis        CDATA          #IMPLIED\n+  headers     IDREFS         #IMPLIED\n+  scope       %Scope;        #IMPLIED\n+  rowspan     %Number;       \"1\"\n+  colspan     %Number;       \"1\"\n+  %cellhalign;\n+  %cellvalign;\n+  nowrap      (nowrap)       #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  width       %Pixels;       #IMPLIED\n+  height      %Pixels;       #IMPLIED\n+  >\n+\n+<!ATTLIST td\n+  %attrs;\n+  abbr        %Text;         #IMPLIED\n+  axis        CDATA          #IMPLIED\n+  headers     IDREFS         #IMPLIED\n+  scope       %Scope;        #IMPLIED\n+  rowspan     %Number;       \"1\"\n+  colspan     %Number;       \"1\"\n+  %cellhalign;\n+  %cellvalign;\n+  nowrap      (nowrap)       #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  width       %Pixels;       #IMPLIED\n+  height      %Pixels;       #IMPLIED\n+  >\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml10\/xhtml1-frameset.dtd","additions":1235,"deletions":0,"binary":false,"changes":1235,"status":"added"},{"patch":"@@ -0,0 +1,978 @@\n+<!--\n+   Extensible HTML version 1.0 Strict DTD\n+\n+   This is the same as HTML 4 Strict except for\n+   changes due to the differences between XML and SGML.\n+\n+   Namespace = http:\/\/www.w3.org\/1999\/xhtml\n+\n+   For further information, see: http:\/\/www.w3.org\/TR\/xhtml1\n+\n+   Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),\n+   All Rights Reserved. \n+\n+   This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+   PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\"\n+   SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-strict.dtd\"\n+\n+   $Revision: 1.24 $\n+   $Date: 2002\/07\/31 19:34:51 $\n+\n+-->\n+\n+<!--================ Character mnemonic entities =========================-->\n+\n+<!ENTITY % HTMLlat1 PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+   \"xhtml-lat1.ent\">\n+%HTMLlat1;\n+\n+<!ENTITY % HTMLsymbol PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+   \"xhtml-symbol.ent\">\n+%HTMLsymbol;\n+\n+<!ENTITY % HTMLspecial PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+   \"xhtml-special.ent\">\n+%HTMLspecial;\n+\n+<!--================== Imported Names ====================================-->\n+\n+<!ENTITY % ContentType \"CDATA\">\n+    <!-- media type, as per [RFC2045] -->\n+\n+<!ENTITY % ContentTypes \"CDATA\">\n+    <!-- comma-separated list of media types, as per [RFC2045] -->\n+\n+<!ENTITY % Charset \"CDATA\">\n+    <!-- a character encoding, as per [RFC2045] -->\n+\n+<!ENTITY % Charsets \"CDATA\">\n+    <!-- a space separated list of character encodings, as per [RFC2045] -->\n+\n+<!ENTITY % LanguageCode \"NMTOKEN\">\n+    <!-- a language code, as per [RFC3066] -->\n+\n+<!ENTITY % Character \"CDATA\">\n+    <!-- a single character, as per section 2.2 of [XML] -->\n+\n+<!ENTITY % Number \"CDATA\">\n+    <!-- one or more digits -->\n+\n+<!ENTITY % LinkTypes \"CDATA\">\n+    <!-- space-separated list of link types -->\n+\n+<!ENTITY % MediaDesc \"CDATA\">\n+    <!-- single or comma-separated list of media descriptors -->\n+\n+<!ENTITY % URI \"CDATA\">\n+    <!-- a Uniform Resource Identifier, see [RFC2396] -->\n+\n+<!ENTITY % UriList \"CDATA\">\n+    <!-- a space separated list of Uniform Resource Identifiers -->\n+\n+<!ENTITY % Datetime \"CDATA\">\n+    <!-- date and time information. ISO date format -->\n+\n+<!ENTITY % Script \"CDATA\">\n+    <!-- script expression -->\n+\n+<!ENTITY % StyleSheet \"CDATA\">\n+    <!-- style sheet data -->\n+\n+<!ENTITY % Text \"CDATA\">\n+    <!-- used for titles etc. -->\n+\n+<!ENTITY % Length \"CDATA\">\n+    <!-- nn for pixels or nn% for percentage length -->\n+\n+<!ENTITY % MultiLength \"CDATA\">\n+    <!-- pixel, percentage, or relative -->\n+\n+<!ENTITY % Pixels \"CDATA\">\n+    <!-- integer representing length in pixels -->\n+\n+<!-- these are used for image maps -->\n+\n+<!ENTITY % Shape \"(rect|circle|poly|default)\">\n+\n+<!ENTITY % Coords \"CDATA\">\n+    <!-- comma separated list of lengths -->\n+\n+<!--=================== Generic Attributes ===============================-->\n+\n+<!-- core attributes common to most elements\n+  id       document-wide unique id\n+  class    space separated list of classes\n+  style    associated style info\n+  title    advisory title\/amplification\n+-->\n+<!ENTITY % coreattrs\n+ \"id          ID             #IMPLIED\n+  class       CDATA          #IMPLIED\n+  style       %StyleSheet;   #IMPLIED\n+  title       %Text;         #IMPLIED\"\n+  >\n+\n+<!-- internationalization attributes\n+  lang        language code (backwards compatible)\n+  xml:lang    language code (as per XML 1.0 spec)\n+  dir         direction for weak\/neutral text\n+-->\n+<!ENTITY % i18n\n+ \"lang        %LanguageCode; #IMPLIED\n+  xml:lang    %LanguageCode; #IMPLIED\n+  dir         (ltr|rtl)      #IMPLIED\"\n+  >\n+\n+<!-- attributes for common UI events\n+  onclick     a pointer button was clicked\n+  ondblclick  a pointer button was double clicked\n+  onmousedown a pointer button was pressed down\n+  onmouseup   a pointer button was released\n+  onmousemove a pointer was moved onto the element\n+  onmouseout  a pointer was moved away from the element\n+  onkeypress  a key was pressed and released\n+  onkeydown   a key was pressed down\n+  onkeyup     a key was released\n+-->\n+<!ENTITY % events\n+ \"onclick     %Script;       #IMPLIED\n+  ondblclick  %Script;       #IMPLIED\n+  onmousedown %Script;       #IMPLIED\n+  onmouseup   %Script;       #IMPLIED\n+  onmouseover %Script;       #IMPLIED\n+  onmousemove %Script;       #IMPLIED\n+  onmouseout  %Script;       #IMPLIED\n+  onkeypress  %Script;       #IMPLIED\n+  onkeydown   %Script;       #IMPLIED\n+  onkeyup     %Script;       #IMPLIED\"\n+  >\n+\n+<!-- attributes for elements that can get the focus\n+  accesskey   accessibility key character\n+  tabindex    position in tabbing order\n+  onfocus     the element got the focus\n+  onblur      the element lost the focus\n+-->\n+<!ENTITY % focus\n+ \"accesskey   %Character;    #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\"\n+  >\n+\n+<!ENTITY % attrs \"%coreattrs; %i18n; %events;\">\n+\n+<!--=================== Text Elements ====================================-->\n+\n+<!ENTITY % special.pre\n+   \"br | span | bdo | map\">\n+\n+\n+<!ENTITY % special\n+   \"%special.pre; | object | img \">\n+\n+<!ENTITY % fontstyle \"tt | i | b | big | small \">\n+\n+<!ENTITY % phrase \"em | strong | dfn | code | q |\n+                   samp | kbd | var | cite | abbr | acronym | sub | sup \">\n+\n+<!ENTITY % inline.forms \"input | select | textarea | label | button\">\n+\n+<!-- these can occur at block or inline level -->\n+<!ENTITY % misc.inline \"ins | del | script\">\n+\n+<!-- these can only occur at block level -->\n+<!ENTITY % misc \"noscript | %misc.inline;\">\n+\n+<!ENTITY % inline \"a | %special; | %fontstyle; | %phrase; | %inline.forms;\">\n+\n+<!-- %Inline; covers inline or \"text-level\" elements -->\n+<!ENTITY % Inline \"(#PCDATA | %inline; | %misc.inline;)*\">\n+\n+<!--================== Block level elements ==============================-->\n+\n+<!ENTITY % heading \"h1|h2|h3|h4|h5|h6\">\n+<!ENTITY % lists \"ul | ol | dl\">\n+<!ENTITY % blocktext \"pre | hr | blockquote | address\">\n+\n+<!ENTITY % block\n+     \"p | %heading; | div | %lists; | %blocktext; | fieldset | table\">\n+\n+<!ENTITY % Block \"(%block; | form | %misc;)*\">\n+\n+<!-- %Flow; mixes block and inline and is used for list items etc. -->\n+<!ENTITY % Flow \"(#PCDATA | %block; | form | %inline; | %misc;)*\">\n+\n+<!--================== Content models for exclusions =====================-->\n+\n+<!-- a elements use %Inline; excluding a -->\n+\n+<!ENTITY % a.content\n+   \"(#PCDATA | %special; | %fontstyle; | %phrase; | %inline.forms; | %misc.inline;)*\">\n+\n+<!-- pre uses %Inline excluding big, small, sup or sup -->\n+\n+<!ENTITY % pre.content\n+   \"(#PCDATA | a | %fontstyle; | %phrase; | %special.pre; | %misc.inline;\n+      | %inline.forms;)*\">\n+\n+<!-- form uses %Block; excluding form -->\n+\n+<!ENTITY % form.content \"(%block; | %misc;)*\">\n+\n+<!-- button uses %Flow; but excludes a, form and form controls -->\n+\n+<!ENTITY % button.content\n+   \"(#PCDATA | p | %heading; | div | %lists; | %blocktext; |\n+    table | %special; | %fontstyle; | %phrase; | %misc;)*\">\n+\n+<!--================ Document Structure ==================================-->\n+\n+<!-- the namespace URI designates the document profile -->\n+\n+<!ELEMENT html (head, body)>\n+<!ATTLIST html\n+  %i18n;\n+  id          ID             #IMPLIED\n+  xmlns       %URI;          #FIXED 'http:\/\/www.w3.org\/1999\/xhtml'\n+  >\n+\n+<!--================ Document Head =======================================-->\n+\n+<!ENTITY % head.misc \"(script|style|meta|link|object)*\">\n+\n+<!-- content model is %head.misc; combined with a single\n+     title and an optional base element in any order -->\n+\n+<!ELEMENT head (%head.misc;,\n+     ((title, %head.misc;, (base, %head.misc;)?) |\n+      (base, %head.misc;, (title, %head.misc;))))>\n+\n+<!ATTLIST head\n+  %i18n;\n+  id          ID             #IMPLIED\n+  profile     %URI;          #IMPLIED\n+  >\n+\n+<!-- The title element is not considered part of the flow of text.\n+       It should be displayed, for example as the page header or\n+       window title. Exactly one title is required per document.\n+    -->\n+<!ELEMENT title (#PCDATA)>\n+<!ATTLIST title \n+  %i18n;\n+  id          ID             #IMPLIED\n+  >\n+\n+<!-- document base URI -->\n+\n+<!ELEMENT base EMPTY>\n+<!ATTLIST base\n+  href        %URI;          #REQUIRED\n+  id          ID             #IMPLIED\n+  >\n+\n+<!-- generic metainformation -->\n+<!ELEMENT meta EMPTY>\n+<!ATTLIST meta\n+  %i18n;\n+  id          ID             #IMPLIED\n+  http-equiv  CDATA          #IMPLIED\n+  name        CDATA          #IMPLIED\n+  content     CDATA          #REQUIRED\n+  scheme      CDATA          #IMPLIED\n+  >\n+\n+<!--\n+  Relationship values can be used in principle:\n+\n+   a) for document specific toolbars\/menus when used\n+      with the link element in document head e.g.\n+        start, contents, previous, next, index, end, help\n+   b) to link to a separate style sheet (rel=\"stylesheet\")\n+   c) to make a link to a script (rel=\"script\")\n+   d) by stylesheets to control how collections of\n+      html nodes are rendered into printed documents\n+   e) to make a link to a printable version of this document\n+      e.g. a PostScript or PDF version (rel=\"alternate\" media=\"print\")\n+-->\n+\n+<!ELEMENT link EMPTY>\n+<!ATTLIST link\n+  %attrs;\n+  charset     %Charset;      #IMPLIED\n+  href        %URI;          #IMPLIED\n+  hreflang    %LanguageCode; #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  rel         %LinkTypes;    #IMPLIED\n+  rev         %LinkTypes;    #IMPLIED\n+  media       %MediaDesc;    #IMPLIED\n+  >\n+\n+<!-- style info, which may include CDATA sections -->\n+<!ELEMENT style (#PCDATA)>\n+<!ATTLIST style\n+  %i18n;\n+  id          ID             #IMPLIED\n+  type        %ContentType;  #REQUIRED\n+  media       %MediaDesc;    #IMPLIED\n+  title       %Text;         #IMPLIED\n+  xml:space   (preserve)     #FIXED 'preserve'\n+  >\n+\n+<!-- script statements, which may include CDATA sections -->\n+<!ELEMENT script (#PCDATA)>\n+<!ATTLIST script\n+  id          ID             #IMPLIED\n+  charset     %Charset;      #IMPLIED\n+  type        %ContentType;  #REQUIRED\n+  src         %URI;          #IMPLIED\n+  defer       (defer)        #IMPLIED\n+  xml:space   (preserve)     #FIXED 'preserve'\n+  >\n+\n+<!-- alternate content container for non script-based rendering -->\n+\n+<!ELEMENT noscript %Block;>\n+<!ATTLIST noscript\n+  %attrs;\n+  >\n+\n+<!--=================== Document Body ====================================-->\n+\n+<!ELEMENT body %Block;>\n+<!ATTLIST body\n+  %attrs;\n+  onload          %Script;   #IMPLIED\n+  onunload        %Script;   #IMPLIED\n+  >\n+\n+<!ELEMENT div %Flow;>  <!-- generic language\/style container -->\n+<!ATTLIST div\n+  %attrs;\n+  >\n+\n+<!--=================== Paragraphs =======================================-->\n+\n+<!ELEMENT p %Inline;>\n+<!ATTLIST p\n+  %attrs;\n+  >\n+\n+<!--=================== Headings =========================================-->\n+\n+<!--\n+  There are six levels of headings from h1 (the most important)\n+  to h6 (the least important).\n+-->\n+\n+<!ELEMENT h1  %Inline;>\n+<!ATTLIST h1\n+   %attrs;\n+   >\n+\n+<!ELEMENT h2 %Inline;>\n+<!ATTLIST h2\n+   %attrs;\n+   >\n+\n+<!ELEMENT h3 %Inline;>\n+<!ATTLIST h3\n+   %attrs;\n+   >\n+\n+<!ELEMENT h4 %Inline;>\n+<!ATTLIST h4\n+   %attrs;\n+   >\n+\n+<!ELEMENT h5 %Inline;>\n+<!ATTLIST h5\n+   %attrs;\n+   >\n+\n+<!ELEMENT h6 %Inline;>\n+<!ATTLIST h6\n+   %attrs;\n+   >\n+\n+<!--=================== Lists ============================================-->\n+\n+<!-- Unordered list -->\n+\n+<!ELEMENT ul (li)+>\n+<!ATTLIST ul\n+  %attrs;\n+  >\n+\n+<!-- Ordered (numbered) list -->\n+\n+<!ELEMENT ol (li)+>\n+<!ATTLIST ol\n+  %attrs;\n+  >\n+\n+<!-- list item -->\n+\n+<!ELEMENT li %Flow;>\n+<!ATTLIST li\n+  %attrs;\n+  >\n+\n+<!-- definition lists - dt for term, dd for its definition -->\n+\n+<!ELEMENT dl (dt|dd)+>\n+<!ATTLIST dl\n+  %attrs;\n+  >\n+\n+<!ELEMENT dt %Inline;>\n+<!ATTLIST dt\n+  %attrs;\n+  >\n+\n+<!ELEMENT dd %Flow;>\n+<!ATTLIST dd\n+  %attrs;\n+  >\n+\n+<!--=================== Address ==========================================-->\n+\n+<!-- information on author -->\n+\n+<!ELEMENT address %Inline;>\n+<!ATTLIST address\n+  %attrs;\n+  >\n+\n+<!--=================== Horizontal Rule ==================================-->\n+\n+<!ELEMENT hr EMPTY>\n+<!ATTLIST hr\n+  %attrs;\n+  >\n+\n+<!--=================== Preformatted Text ================================-->\n+\n+<!-- content is %Inline; excluding \"img|object|big|small|sub|sup\" -->\n+\n+<!ELEMENT pre %pre.content;>\n+<!ATTLIST pre\n+  %attrs;\n+  xml:space (preserve) #FIXED 'preserve'\n+  >\n+\n+<!--=================== Block-like Quotes ================================-->\n+\n+<!ELEMENT blockquote %Block;>\n+<!ATTLIST blockquote\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  >\n+\n+<!--=================== Inserted\/Deleted Text ============================-->\n+\n+<!--\n+  ins\/del are allowed in block and inline content, but its\n+  inappropriate to include block content within an ins element\n+  occurring in inline content.\n+-->\n+<!ELEMENT ins %Flow;>\n+<!ATTLIST ins\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  datetime    %Datetime;     #IMPLIED\n+  >\n+\n+<!ELEMENT del %Flow;>\n+<!ATTLIST del\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  datetime    %Datetime;     #IMPLIED\n+  >\n+\n+<!--================== The Anchor Element ================================-->\n+\n+<!-- content is %Inline; except that anchors shouldn't be nested -->\n+\n+<!ELEMENT a %a.content;>\n+<!ATTLIST a\n+  %attrs;\n+  %focus;\n+  charset     %Charset;      #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  href        %URI;          #IMPLIED\n+  hreflang    %LanguageCode; #IMPLIED\n+  rel         %LinkTypes;    #IMPLIED\n+  rev         %LinkTypes;    #IMPLIED\n+  shape       %Shape;        \"rect\"\n+  coords      %Coords;       #IMPLIED\n+  >\n+\n+<!--===================== Inline Elements ================================-->\n+\n+<!ELEMENT span %Inline;> <!-- generic language\/style container -->\n+<!ATTLIST span\n+  %attrs;\n+  >\n+\n+<!ELEMENT bdo %Inline;>  <!-- I18N BiDi over-ride -->\n+<!ATTLIST bdo\n+  %coreattrs;\n+  %events;\n+  lang        %LanguageCode; #IMPLIED\n+  xml:lang    %LanguageCode; #IMPLIED\n+  dir         (ltr|rtl)      #REQUIRED\n+  >\n+\n+<!ELEMENT br EMPTY>   <!-- forced line break -->\n+<!ATTLIST br\n+  %coreattrs;\n+  >\n+\n+<!ELEMENT em %Inline;>   <!-- emphasis -->\n+<!ATTLIST em %attrs;>\n+\n+<!ELEMENT strong %Inline;>   <!-- strong emphasis -->\n+<!ATTLIST strong %attrs;>\n+\n+<!ELEMENT dfn %Inline;>   <!-- definitional -->\n+<!ATTLIST dfn %attrs;>\n+\n+<!ELEMENT code %Inline;>   <!-- program code -->\n+<!ATTLIST code %attrs;>\n+\n+<!ELEMENT samp %Inline;>   <!-- sample -->\n+<!ATTLIST samp %attrs;>\n+\n+<!ELEMENT kbd %Inline;>  <!-- something user would type -->\n+<!ATTLIST kbd %attrs;>\n+\n+<!ELEMENT var %Inline;>   <!-- variable -->\n+<!ATTLIST var %attrs;>\n+\n+<!ELEMENT cite %Inline;>   <!-- citation -->\n+<!ATTLIST cite %attrs;>\n+\n+<!ELEMENT abbr %Inline;>   <!-- abbreviation -->\n+<!ATTLIST abbr %attrs;>\n+\n+<!ELEMENT acronym %Inline;>   <!-- acronym -->\n+<!ATTLIST acronym %attrs;>\n+\n+<!ELEMENT q %Inline;>   <!-- inlined quote -->\n+<!ATTLIST q\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  >\n+\n+<!ELEMENT sub %Inline;> <!-- subscript -->\n+<!ATTLIST sub %attrs;>\n+\n+<!ELEMENT sup %Inline;> <!-- superscript -->\n+<!ATTLIST sup %attrs;>\n+\n+<!ELEMENT tt %Inline;>   <!-- fixed pitch font -->\n+<!ATTLIST tt %attrs;>\n+\n+<!ELEMENT i %Inline;>   <!-- italic font -->\n+<!ATTLIST i %attrs;>\n+\n+<!ELEMENT b %Inline;>   <!-- bold font -->\n+<!ATTLIST b %attrs;>\n+\n+<!ELEMENT big %Inline;>   <!-- bigger font -->\n+<!ATTLIST big %attrs;>\n+\n+<!ELEMENT small %Inline;>   <!-- smaller font -->\n+<!ATTLIST small %attrs;>\n+\n+<!--==================== Object ======================================-->\n+<!--\n+  object is used to embed objects as part of HTML pages.\n+  param elements should precede other content. Parameters\n+  can also be expressed as attribute\/value pairs on the\n+  object element itself when brevity is desired.\n+-->\n+\n+<!ELEMENT object (#PCDATA | param | %block; | form | %inline; | %misc;)*>\n+<!ATTLIST object\n+  %attrs;\n+  declare     (declare)      #IMPLIED\n+  classid     %URI;          #IMPLIED\n+  codebase    %URI;          #IMPLIED\n+  data        %URI;          #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  codetype    %ContentType;  #IMPLIED\n+  archive     %UriList;      #IMPLIED\n+  standby     %Text;         #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  >\n+\n+<!--\n+  param is used to supply a named property value.\n+  In XML it would seem natural to follow RDF and support an\n+  abbreviated syntax where the param elements are replaced\n+  by attribute value pairs on the object start tag.\n+-->\n+<!ELEMENT param EMPTY>\n+<!ATTLIST param\n+  id          ID             #IMPLIED\n+  name        CDATA          #IMPLIED\n+  value       CDATA          #IMPLIED\n+  valuetype   (data|ref|object) \"data\"\n+  type        %ContentType;  #IMPLIED\n+  >\n+\n+<!--=================== Images ===========================================-->\n+\n+<!--\n+   To avoid accessibility problems for people who aren't\n+   able to see the image, you should provide a text\n+   description using the alt and longdesc attributes.\n+   In addition, avoid the use of server-side image maps.\n+   Note that in this DTD there is no name attribute. That\n+   is only available in the transitional and frameset DTD.\n+-->\n+\n+<!ELEMENT img EMPTY>\n+<!ATTLIST img\n+  %attrs;\n+  src         %URI;          #REQUIRED\n+  alt         %Text;         #REQUIRED\n+  longdesc    %URI;          #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  ismap       (ismap)        #IMPLIED\n+  >\n+\n+<!-- usemap points to a map element which may be in this document\n+  or an external document, although the latter is not widely supported -->\n+\n+<!--================== Client-side image maps ============================-->\n+\n+<!-- These can be placed in the same document or grouped in a\n+     separate document although this isn't yet widely supported -->\n+\n+<!ELEMENT map ((%block; | form | %misc;)+ | area+)>\n+<!ATTLIST map\n+  %i18n;\n+  %events;\n+  id          ID             #REQUIRED\n+  class       CDATA          #IMPLIED\n+  style       %StyleSheet;   #IMPLIED\n+  title       %Text;         #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  >\n+\n+<!ELEMENT area EMPTY>\n+<!ATTLIST area\n+  %attrs;\n+  %focus;\n+  shape       %Shape;        \"rect\"\n+  coords      %Coords;       #IMPLIED\n+  href        %URI;          #IMPLIED\n+  nohref      (nohref)       #IMPLIED\n+  alt         %Text;         #REQUIRED\n+  >\n+\n+<!--================ Forms ===============================================-->\n+<!ELEMENT form %form.content;>   <!-- forms shouldn't be nested -->\n+\n+<!ATTLIST form\n+  %attrs;\n+  action      %URI;          #REQUIRED\n+  method      (get|post)     \"get\"\n+  enctype     %ContentType;  \"application\/x-www-form-urlencoded\"\n+  onsubmit    %Script;       #IMPLIED\n+  onreset     %Script;       #IMPLIED\n+  accept      %ContentTypes; #IMPLIED\n+  accept-charset %Charsets;  #IMPLIED\n+  >\n+\n+<!--\n+  Each label must not contain more than ONE field\n+  Label elements shouldn't be nested.\n+-->\n+<!ELEMENT label %Inline;>\n+<!ATTLIST label\n+  %attrs;\n+  for         IDREF          #IMPLIED\n+  accesskey   %Character;    #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\n+  >\n+\n+<!ENTITY % InputType\n+  \"(text | password | checkbox |\n+    radio | submit | reset |\n+    file | hidden | image | button)\"\n+   >\n+\n+<!-- the name attribute is required for all but submit & reset -->\n+\n+<!ELEMENT input EMPTY>     <!-- form control -->\n+<!ATTLIST input\n+  %attrs;\n+  %focus;\n+  type        %InputType;    \"text\"\n+  name        CDATA          #IMPLIED\n+  value       CDATA          #IMPLIED\n+  checked     (checked)      #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  readonly    (readonly)     #IMPLIED\n+  size        CDATA          #IMPLIED\n+  maxlength   %Number;       #IMPLIED\n+  src         %URI;          #IMPLIED\n+  alt         CDATA          #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  onselect    %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  accept      %ContentTypes; #IMPLIED\n+  >\n+\n+<!ELEMENT select (optgroup|option)+>  <!-- option selector -->\n+<!ATTLIST select\n+  %attrs;\n+  name        CDATA          #IMPLIED\n+  size        %Number;       #IMPLIED\n+  multiple    (multiple)     #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  >\n+\n+<!ELEMENT optgroup (option)+>   <!-- option group -->\n+<!ATTLIST optgroup\n+  %attrs;\n+  disabled    (disabled)     #IMPLIED\n+  label       %Text;         #REQUIRED\n+  >\n+\n+<!ELEMENT option (#PCDATA)>     <!-- selectable choice -->\n+<!ATTLIST option\n+  %attrs;\n+  selected    (selected)     #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  label       %Text;         #IMPLIED\n+  value       CDATA          #IMPLIED\n+  >\n+\n+<!ELEMENT textarea (#PCDATA)>     <!-- multi-line text field -->\n+<!ATTLIST textarea\n+  %attrs;\n+  %focus;\n+  name        CDATA          #IMPLIED\n+  rows        %Number;       #REQUIRED\n+  cols        %Number;       #REQUIRED\n+  disabled    (disabled)     #IMPLIED\n+  readonly    (readonly)     #IMPLIED\n+  onselect    %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  >\n+\n+<!--\n+  The fieldset element is used to group form fields.\n+  Only one legend element should occur in the content\n+  and if present should only be preceded by whitespace.\n+-->\n+<!ELEMENT fieldset (#PCDATA | legend | %block; | form | %inline; | %misc;)*>\n+<!ATTLIST fieldset\n+  %attrs;\n+  >\n+\n+<!ELEMENT legend %Inline;>     <!-- fieldset label -->\n+<!ATTLIST legend\n+  %attrs;\n+  accesskey   %Character;    #IMPLIED\n+  >\n+\n+<!--\n+ Content is %Flow; excluding a, form and form controls\n+--> \n+<!ELEMENT button %button.content;>  <!-- push button -->\n+<!ATTLIST button\n+  %attrs;\n+  %focus;\n+  name        CDATA          #IMPLIED\n+  value       CDATA          #IMPLIED\n+  type        (button|submit|reset) \"submit\"\n+  disabled    (disabled)     #IMPLIED\n+  >\n+\n+<!--======================= Tables =======================================-->\n+\n+<!-- Derived from IETF HTML table standard, see [RFC1942] -->\n+\n+<!--\n+ The border attribute sets the thickness of the frame around the\n+ table. The default units are screen pixels.\n+\n+ The frame attribute specifies which parts of the frame around\n+ the table should be rendered. The values are not the same as\n+ CALS to avoid a name clash with the valign attribute.\n+-->\n+<!ENTITY % TFrame \"(void|above|below|hsides|lhs|rhs|vsides|box|border)\">\n+\n+<!--\n+ The rules attribute defines which rules to draw between cells:\n+\n+ If rules is absent then assume:\n+     \"none\" if border is absent or border=\"0\" otherwise \"all\"\n+-->\n+\n+<!ENTITY % TRules \"(none | groups | rows | cols | all)\">\n+  \n+<!-- horizontal alignment attributes for cell contents\n+\n+  char        alignment char, e.g. char=':'\n+  charoff     offset for alignment char\n+-->\n+<!ENTITY % cellhalign\n+  \"align      (left|center|right|justify|char) #IMPLIED\n+   char       %Character;    #IMPLIED\n+   charoff    %Length;       #IMPLIED\"\n+  >\n+\n+<!-- vertical alignment attributes for cell contents -->\n+<!ENTITY % cellvalign\n+  \"valign     (top|middle|bottom|baseline) #IMPLIED\"\n+  >\n+\n+<!ELEMENT table\n+     (caption?, (col*|colgroup*), thead?, tfoot?, (tbody+|tr+))>\n+<!ELEMENT caption  %Inline;>\n+<!ELEMENT thead    (tr)+>\n+<!ELEMENT tfoot    (tr)+>\n+<!ELEMENT tbody    (tr)+>\n+<!ELEMENT colgroup (col)*>\n+<!ELEMENT col      EMPTY>\n+<!ELEMENT tr       (th|td)+>\n+<!ELEMENT th       %Flow;>\n+<!ELEMENT td       %Flow;>\n+\n+<!ATTLIST table\n+  %attrs;\n+  summary     %Text;         #IMPLIED\n+  width       %Length;       #IMPLIED\n+  border      %Pixels;       #IMPLIED\n+  frame       %TFrame;       #IMPLIED\n+  rules       %TRules;       #IMPLIED\n+  cellspacing %Length;       #IMPLIED\n+  cellpadding %Length;       #IMPLIED\n+  >\n+\n+<!ATTLIST caption\n+  %attrs;\n+  >\n+\n+<!--\n+colgroup groups a set of col elements. It allows you to group\n+several semantically related columns together.\n+-->\n+<!ATTLIST colgroup\n+  %attrs;\n+  span        %Number;       \"1\"\n+  width       %MultiLength;  #IMPLIED\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!--\n+ col elements define the alignment properties for cells in\n+ one or more columns.\n+\n+ The width attribute specifies the width of the columns, e.g.\n+\n+     width=64        width in screen pixels\n+     width=0.5*      relative width of 0.5\n+\n+ The span attribute causes the attributes of one\n+ col element to apply to more than one column.\n+-->\n+<!ATTLIST col\n+  %attrs;\n+  span        %Number;       \"1\"\n+  width       %MultiLength;  #IMPLIED\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!--\n+    Use thead to duplicate headers when breaking table\n+    across page boundaries, or for static headers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use tfoot to duplicate footers when breaking table\n+    across page boundaries, or for static footers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use multiple tbody sections when rules are needed\n+    between groups of table rows.\n+-->\n+<!ATTLIST thead\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tfoot\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tbody\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tr\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+\n+<!-- Scope is simpler than headers attribute for common tables -->\n+<!ENTITY % Scope \"(row|col|rowgroup|colgroup)\">\n+\n+<!-- th is for headers, td for data and for cells acting as both -->\n+\n+<!ATTLIST th\n+  %attrs;\n+  abbr        %Text;         #IMPLIED\n+  axis        CDATA          #IMPLIED\n+  headers     IDREFS         #IMPLIED\n+  scope       %Scope;        #IMPLIED\n+  rowspan     %Number;       \"1\"\n+  colspan     %Number;       \"1\"\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST td\n+  %attrs;\n+  abbr        %Text;         #IMPLIED\n+  axis        CDATA          #IMPLIED\n+  headers     IDREFS         #IMPLIED\n+  scope       %Scope;        #IMPLIED\n+  rowspan     %Number;       \"1\"\n+  colspan     %Number;       \"1\"\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml10\/xhtml1-strict.dtd","additions":978,"deletions":0,"binary":false,"changes":978,"status":"added"},{"patch":"@@ -0,0 +1,1201 @@\n+<!--\n+   Extensible HTML version 1.0 Transitional DTD\n+\n+   This is the same as HTML 4 Transitional except for\n+   changes due to the differences between XML and SGML.\n+\n+   Namespace = http:\/\/www.w3.org\/1999\/xhtml\n+\n+   For further information, see: http:\/\/www.w3.org\/TR\/xhtml1\n+\n+   Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),\n+   All Rights Reserved. \n+\n+   This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+   PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\"\n+   SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\"\n+\n+   $Revision: 1.27 $\n+   $Date: 2002\/08\/01 18:16:48 $\n+\n+-->\n+\n+<!--================ Character mnemonic entities =========================-->\n+\n+<!ENTITY % HTMLlat1 PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+   \"xhtml-lat1.ent\">\n+%HTMLlat1;\n+\n+<!ENTITY % HTMLsymbol PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+   \"xhtml-symbol.ent\">\n+%HTMLsymbol;\n+\n+<!ENTITY % HTMLspecial PUBLIC\n+   \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+   \"xhtml-special.ent\">\n+%HTMLspecial;\n+\n+<!--================== Imported Names ====================================-->\n+\n+<!ENTITY % ContentType \"CDATA\">\n+    <!-- media type, as per [RFC2045] -->\n+\n+<!ENTITY % ContentTypes \"CDATA\">\n+    <!-- comma-separated list of media types, as per [RFC2045] -->\n+\n+<!ENTITY % Charset \"CDATA\">\n+    <!-- a character encoding, as per [RFC2045] -->\n+\n+<!ENTITY % Charsets \"CDATA\">\n+    <!-- a space separated list of character encodings, as per [RFC2045] -->\n+\n+<!ENTITY % LanguageCode \"NMTOKEN\">\n+    <!-- a language code, as per [RFC3066] -->\n+\n+<!ENTITY % Character \"CDATA\">\n+    <!-- a single character, as per section 2.2 of [XML] -->\n+\n+<!ENTITY % Number \"CDATA\">\n+    <!-- one or more digits -->\n+\n+<!ENTITY % LinkTypes \"CDATA\">\n+    <!-- space-separated list of link types -->\n+\n+<!ENTITY % MediaDesc \"CDATA\">\n+    <!-- single or comma-separated list of media descriptors -->\n+\n+<!ENTITY % URI \"CDATA\">\n+    <!-- a Uniform Resource Identifier, see [RFC2396] -->\n+\n+<!ENTITY % UriList \"CDATA\">\n+    <!-- a space separated list of Uniform Resource Identifiers -->\n+\n+<!ENTITY % Datetime \"CDATA\">\n+    <!-- date and time information. ISO date format -->\n+\n+<!ENTITY % Script \"CDATA\">\n+    <!-- script expression -->\n+\n+<!ENTITY % StyleSheet \"CDATA\">\n+    <!-- style sheet data -->\n+\n+<!ENTITY % Text \"CDATA\">\n+    <!-- used for titles etc. -->\n+\n+<!ENTITY % FrameTarget \"NMTOKEN\">\n+    <!-- render in this frame -->\n+\n+<!ENTITY % Length \"CDATA\">\n+    <!-- nn for pixels or nn% for percentage length -->\n+\n+<!ENTITY % MultiLength \"CDATA\">\n+    <!-- pixel, percentage, or relative -->\n+\n+<!ENTITY % Pixels \"CDATA\">\n+    <!-- integer representing length in pixels -->\n+\n+<!-- these are used for image maps -->\n+\n+<!ENTITY % Shape \"(rect|circle|poly|default)\">\n+\n+<!ENTITY % Coords \"CDATA\">\n+    <!-- comma separated list of lengths -->\n+\n+<!-- used for object, applet, img, input and iframe -->\n+<!ENTITY % ImgAlign \"(top|middle|bottom|left|right)\">\n+\n+<!-- a color using sRGB: #RRGGBB as Hex values -->\n+<!ENTITY % Color \"CDATA\">\n+\n+<!-- There are also 16 widely known color names with their sRGB values:\n+\n+    Black  = #000000    Green  = #008000\n+    Silver = #C0C0C0    Lime   = #00FF00\n+    Gray   = #808080    Olive  = #808000\n+    White  = #FFFFFF    Yellow = #FFFF00\n+    Maroon = #800000    Navy   = #000080\n+    Red    = #FF0000    Blue   = #0000FF\n+    Purple = #800080    Teal   = #008080\n+    Fuchsia= #FF00FF    Aqua   = #00FFFF\n+-->\n+\n+<!--=================== Generic Attributes ===============================-->\n+\n+<!-- core attributes common to most elements\n+  id       document-wide unique id\n+  class    space separated list of classes\n+  style    associated style info\n+  title    advisory title\/amplification\n+-->\n+<!ENTITY % coreattrs\n+ \"id          ID             #IMPLIED\n+  class       CDATA          #IMPLIED\n+  style       %StyleSheet;   #IMPLIED\n+  title       %Text;         #IMPLIED\"\n+  >\n+\n+<!-- internationalization attributes\n+  lang        language code (backwards compatible)\n+  xml:lang    language code (as per XML 1.0 spec)\n+  dir         direction for weak\/neutral text\n+-->\n+<!ENTITY % i18n\n+ \"lang        %LanguageCode; #IMPLIED\n+  xml:lang    %LanguageCode; #IMPLIED\n+  dir         (ltr|rtl)      #IMPLIED\"\n+  >\n+\n+<!-- attributes for common UI events\n+  onclick     a pointer button was clicked\n+  ondblclick  a pointer button was double clicked\n+  onmousedown a pointer button was pressed down\n+  onmouseup   a pointer button was released\n+  onmousemove a pointer was moved onto the element\n+  onmouseout  a pointer was moved away from the element\n+  onkeypress  a key was pressed and released\n+  onkeydown   a key was pressed down\n+  onkeyup     a key was released\n+-->\n+<!ENTITY % events\n+ \"onclick     %Script;       #IMPLIED\n+  ondblclick  %Script;       #IMPLIED\n+  onmousedown %Script;       #IMPLIED\n+  onmouseup   %Script;       #IMPLIED\n+  onmouseover %Script;       #IMPLIED\n+  onmousemove %Script;       #IMPLIED\n+  onmouseout  %Script;       #IMPLIED\n+  onkeypress  %Script;       #IMPLIED\n+  onkeydown   %Script;       #IMPLIED\n+  onkeyup     %Script;       #IMPLIED\"\n+  >\n+\n+<!-- attributes for elements that can get the focus\n+  accesskey   accessibility key character\n+  tabindex    position in tabbing order\n+  onfocus     the element got the focus\n+  onblur      the element lost the focus\n+-->\n+<!ENTITY % focus\n+ \"accesskey   %Character;    #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\"\n+  >\n+\n+<!ENTITY % attrs \"%coreattrs; %i18n; %events;\">\n+\n+<!-- text alignment for p, div, h1-h6. The default is\n+     align=\"left\" for ltr headings, \"right\" for rtl -->\n+\n+<!ENTITY % TextAlign \"align (left|center|right|justify) #IMPLIED\">\n+\n+<!--=================== Text Elements ====================================-->\n+\n+<!ENTITY % special.extra\n+   \"object | applet | img | map | iframe\">\n+\t\n+<!ENTITY % special.basic\n+\t\"br | span | bdo\">\n+\n+<!ENTITY % special\n+   \"%special.basic; | %special.extra;\">\n+\n+<!ENTITY % fontstyle.extra \"big | small | font | basefont\">\n+\n+<!ENTITY % fontstyle.basic \"tt | i | b | u\n+                      | s | strike \">\n+\n+<!ENTITY % fontstyle \"%fontstyle.basic; | %fontstyle.extra;\">\n+\n+<!ENTITY % phrase.extra \"sub | sup\">\n+<!ENTITY % phrase.basic \"em | strong | dfn | code | q |\n+                   samp | kbd | var | cite | abbr | acronym\">\n+\n+<!ENTITY % phrase \"%phrase.basic; | %phrase.extra;\">\n+\n+<!ENTITY % inline.forms \"input | select | textarea | label | button\">\n+\n+<!-- these can occur at block or inline level -->\n+<!ENTITY % misc.inline \"ins | del | script\">\n+\n+<!-- these can only occur at block level -->\n+<!ENTITY % misc \"noscript | %misc.inline;\">\n+\n+<!ENTITY % inline \"a | %special; | %fontstyle; | %phrase; | %inline.forms;\">\n+\n+<!-- %Inline; covers inline or \"text-level\" elements -->\n+<!ENTITY % Inline \"(#PCDATA | %inline; | %misc.inline;)*\">\n+\n+<!--================== Block level elements ==============================-->\n+\n+<!ENTITY % heading \"h1|h2|h3|h4|h5|h6\">\n+<!ENTITY % lists \"ul | ol | dl | menu | dir\">\n+<!ENTITY % blocktext \"pre | hr | blockquote | address | center | noframes\">\n+\n+<!ENTITY % block\n+    \"p | %heading; | div | %lists; | %blocktext; | isindex |fieldset | table\">\n+\n+<!-- %Flow; mixes block and inline and is used for list items etc. -->\n+<!ENTITY % Flow \"(#PCDATA | %block; | form | %inline; | %misc;)*\">\n+\n+<!--================== Content models for exclusions =====================-->\n+\n+<!-- a elements use %Inline; excluding a -->\n+\n+<!ENTITY % a.content\n+   \"(#PCDATA | %special; | %fontstyle; | %phrase; | %inline.forms; | %misc.inline;)*\">\n+\n+<!-- pre uses %Inline excluding img, object, applet, big, small,\n+     font, or basefont -->\n+\n+<!ENTITY % pre.content\n+   \"(#PCDATA | a | %special.basic; | %fontstyle.basic; | %phrase.basic; |\n+\t   %inline.forms; | %misc.inline;)*\">\n+\n+<!-- form uses %Flow; excluding form -->\n+\n+<!ENTITY % form.content \"(#PCDATA | %block; | %inline; | %misc;)*\">\n+\n+<!-- button uses %Flow; but excludes a, form, form controls, iframe -->\n+\n+<!ENTITY % button.content\n+   \"(#PCDATA | p | %heading; | div | %lists; | %blocktext; |\n+      table | br | span | bdo | object | applet | img | map |\n+      %fontstyle; | %phrase; | %misc;)*\">\n+\n+<!--================ Document Structure ==================================-->\n+\n+<!-- the namespace URI designates the document profile -->\n+\n+<!ELEMENT html (head, body)>\n+<!ATTLIST html\n+  %i18n;\n+  id          ID             #IMPLIED\n+  xmlns       %URI;          #FIXED 'http:\/\/www.w3.org\/1999\/xhtml'\n+  >\n+\n+<!--================ Document Head =======================================-->\n+\n+<!ENTITY % head.misc \"(script|style|meta|link|object|isindex)*\">\n+\n+<!-- content model is %head.misc; combined with a single\n+     title and an optional base element in any order -->\n+\n+<!ELEMENT head (%head.misc;,\n+     ((title, %head.misc;, (base, %head.misc;)?) |\n+      (base, %head.misc;, (title, %head.misc;))))>\n+\n+<!ATTLIST head\n+  %i18n;\n+  id          ID             #IMPLIED\n+  profile     %URI;          #IMPLIED\n+  >\n+\n+<!-- The title element is not considered part of the flow of text.\n+       It should be displayed, for example as the page header or\n+       window title. Exactly one title is required per document.\n+    -->\n+<!ELEMENT title (#PCDATA)>\n+<!ATTLIST title \n+  %i18n;\n+  id          ID             #IMPLIED\n+  >\n+\n+<!-- document base URI -->\n+\n+<!ELEMENT base EMPTY>\n+<!ATTLIST base\n+  id          ID             #IMPLIED\n+  href        %URI;          #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!-- generic metainformation -->\n+<!ELEMENT meta EMPTY>\n+<!ATTLIST meta\n+  %i18n;\n+  id          ID             #IMPLIED\n+  http-equiv  CDATA          #IMPLIED\n+  name        CDATA          #IMPLIED\n+  content     CDATA          #REQUIRED\n+  scheme      CDATA          #IMPLIED\n+  >\n+\n+<!--\n+  Relationship values can be used in principle:\n+\n+   a) for document specific toolbars\/menus when used\n+      with the link element in document head e.g.\n+        start, contents, previous, next, index, end, help\n+   b) to link to a separate style sheet (rel=\"stylesheet\")\n+   c) to make a link to a script (rel=\"script\")\n+   d) by stylesheets to control how collections of\n+      html nodes are rendered into printed documents\n+   e) to make a link to a printable version of this document\n+      e.g. a PostScript or PDF version (rel=\"alternate\" media=\"print\")\n+-->\n+\n+<!ELEMENT link EMPTY>\n+<!ATTLIST link\n+  %attrs;\n+  charset     %Charset;      #IMPLIED\n+  href        %URI;          #IMPLIED\n+  hreflang    %LanguageCode; #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  rel         %LinkTypes;    #IMPLIED\n+  rev         %LinkTypes;    #IMPLIED\n+  media       %MediaDesc;    #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!-- style info, which may include CDATA sections -->\n+<!ELEMENT style (#PCDATA)>\n+<!ATTLIST style\n+  %i18n;\n+  id          ID             #IMPLIED\n+  type        %ContentType;  #REQUIRED\n+  media       %MediaDesc;    #IMPLIED\n+  title       %Text;         #IMPLIED\n+  xml:space   (preserve)     #FIXED 'preserve'\n+  >\n+\n+<!-- script statements, which may include CDATA sections -->\n+<!ELEMENT script (#PCDATA)>\n+<!ATTLIST script\n+  id          ID             #IMPLIED\n+  charset     %Charset;      #IMPLIED\n+  type        %ContentType;  #REQUIRED\n+  language    CDATA          #IMPLIED\n+  src         %URI;          #IMPLIED\n+  defer       (defer)        #IMPLIED\n+  xml:space   (preserve)     #FIXED 'preserve'\n+  >\n+\n+<!-- alternate content container for non script-based rendering -->\n+\n+<!ELEMENT noscript %Flow;>\n+<!ATTLIST noscript\n+  %attrs;\n+  >\n+\n+<!--======================= Frames =======================================-->\n+\n+<!-- inline subwindow -->\n+\n+<!ELEMENT iframe %Flow;>\n+<!ATTLIST iframe\n+  %coreattrs;\n+  longdesc    %URI;          #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  src         %URI;          #IMPLIED\n+  frameborder (1|0)          \"1\"\n+  marginwidth %Pixels;       #IMPLIED\n+  marginheight %Pixels;      #IMPLIED\n+  scrolling   (yes|no|auto)  \"auto\"\n+  align       %ImgAlign;     #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  >\n+\n+<!-- alternate content container for non frame-based rendering -->\n+\n+<!ELEMENT noframes %Flow;>\n+<!ATTLIST noframes\n+  %attrs;\n+  >\n+\n+<!--=================== Document Body ====================================-->\n+\n+<!ELEMENT body %Flow;>\n+<!ATTLIST body\n+  %attrs;\n+  onload      %Script;       #IMPLIED\n+  onunload    %Script;       #IMPLIED\n+  background  %URI;          #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  text        %Color;        #IMPLIED\n+  link        %Color;        #IMPLIED\n+  vlink       %Color;        #IMPLIED\n+  alink       %Color;        #IMPLIED\n+  >\n+\n+<!ELEMENT div %Flow;>  <!-- generic language\/style container -->\n+<!ATTLIST div\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!--=================== Paragraphs =======================================-->\n+\n+<!ELEMENT p %Inline;>\n+<!ATTLIST p\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!--=================== Headings =========================================-->\n+\n+<!--\n+  There are six levels of headings from h1 (the most important)\n+  to h6 (the least important).\n+-->\n+\n+<!ELEMENT h1  %Inline;>\n+<!ATTLIST h1\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h2 %Inline;>\n+<!ATTLIST h2\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h3 %Inline;>\n+<!ATTLIST h3\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h4 %Inline;>\n+<!ATTLIST h4\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h5 %Inline;>\n+<!ATTLIST h5\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!ELEMENT h6 %Inline;>\n+<!ATTLIST h6\n+  %attrs;\n+  %TextAlign;\n+  >\n+\n+<!--=================== Lists ============================================-->\n+\n+<!-- Unordered list bullet styles -->\n+\n+<!ENTITY % ULStyle \"(disc|square|circle)\">\n+\n+<!-- Unordered list -->\n+\n+<!ELEMENT ul (li)+>\n+<!ATTLIST ul\n+  %attrs;\n+  type        %ULStyle;     #IMPLIED\n+  compact     (compact)     #IMPLIED\n+  >\n+\n+<!-- Ordered list numbering style\n+\n+    1   arabic numbers      1, 2, 3, ...\n+    a   lower alpha         a, b, c, ...\n+    A   upper alpha         A, B, C, ...\n+    i   lower roman         i, ii, iii, ...\n+    I   upper roman         I, II, III, ...\n+\n+    The style is applied to the sequence number which by default\n+    is reset to 1 for the first list item in an ordered list.\n+-->\n+<!ENTITY % OLStyle \"CDATA\">\n+\n+<!-- Ordered (numbered) list -->\n+\n+<!ELEMENT ol (li)+>\n+<!ATTLIST ol\n+  %attrs;\n+  type        %OLStyle;      #IMPLIED\n+  compact     (compact)      #IMPLIED\n+  start       %Number;       #IMPLIED\n+  >\n+\n+<!-- single column list (DEPRECATED) --> \n+<!ELEMENT menu (li)+>\n+<!ATTLIST menu\n+  %attrs;\n+  compact     (compact)     #IMPLIED\n+  >\n+\n+<!-- multiple column list (DEPRECATED) --> \n+<!ELEMENT dir (li)+>\n+<!ATTLIST dir\n+  %attrs;\n+  compact     (compact)     #IMPLIED\n+  >\n+\n+<!-- LIStyle is constrained to: \"(%ULStyle;|%OLStyle;)\" -->\n+<!ENTITY % LIStyle \"CDATA\">\n+\n+<!-- list item -->\n+\n+<!ELEMENT li %Flow;>\n+<!ATTLIST li\n+  %attrs;\n+  type        %LIStyle;      #IMPLIED\n+  value       %Number;       #IMPLIED\n+  >\n+\n+<!-- definition lists - dt for term, dd for its definition -->\n+\n+<!ELEMENT dl (dt|dd)+>\n+<!ATTLIST dl\n+  %attrs;\n+  compact     (compact)      #IMPLIED\n+  >\n+\n+<!ELEMENT dt %Inline;>\n+<!ATTLIST dt\n+  %attrs;\n+  >\n+\n+<!ELEMENT dd %Flow;>\n+<!ATTLIST dd\n+  %attrs;\n+  >\n+\n+<!--=================== Address ==========================================-->\n+\n+<!-- information on author -->\n+\n+<!ELEMENT address (#PCDATA | %inline; | %misc.inline; | p)*>\n+<!ATTLIST address\n+  %attrs;\n+  >\n+\n+<!--=================== Horizontal Rule ==================================-->\n+\n+<!ELEMENT hr EMPTY>\n+<!ATTLIST hr\n+  %attrs;\n+  align       (left|center|right) #IMPLIED\n+  noshade     (noshade)      #IMPLIED\n+  size        %Pixels;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  >\n+\n+<!--=================== Preformatted Text ================================-->\n+\n+<!-- content is %Inline; excluding \n+        \"img|object|applet|big|small|sub|sup|font|basefont\" -->\n+\n+<!ELEMENT pre %pre.content;>\n+<!ATTLIST pre\n+  %attrs;\n+  width       %Number;      #IMPLIED\n+  xml:space   (preserve)    #FIXED 'preserve'\n+  >\n+\n+<!--=================== Block-like Quotes ================================-->\n+\n+<!ELEMENT blockquote %Flow;>\n+<!ATTLIST blockquote\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  >\n+\n+<!--=================== Text alignment ===================================-->\n+\n+<!-- center content -->\n+<!ELEMENT center %Flow;>\n+<!ATTLIST center\n+  %attrs;\n+  >\n+\n+<!--=================== Inserted\/Deleted Text ============================-->\n+\n+<!--\n+  ins\/del are allowed in block and inline content, but its\n+  inappropriate to include block content within an ins element\n+  occurring in inline content.\n+-->\n+<!ELEMENT ins %Flow;>\n+<!ATTLIST ins\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  datetime    %Datetime;     #IMPLIED\n+  >\n+\n+<!ELEMENT del %Flow;>\n+<!ATTLIST del\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  datetime    %Datetime;     #IMPLIED\n+  >\n+\n+<!--================== The Anchor Element ================================-->\n+\n+<!-- content is %Inline; except that anchors shouldn't be nested -->\n+\n+<!ELEMENT a %a.content;>\n+<!ATTLIST a\n+  %attrs;\n+  %focus;\n+  charset     %Charset;      #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  href        %URI;          #IMPLIED\n+  hreflang    %LanguageCode; #IMPLIED\n+  rel         %LinkTypes;    #IMPLIED\n+  rev         %LinkTypes;    #IMPLIED\n+  shape       %Shape;        \"rect\"\n+  coords      %Coords;       #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!--===================== Inline Elements ================================-->\n+\n+<!ELEMENT span %Inline;> <!-- generic language\/style container -->\n+<!ATTLIST span\n+  %attrs;\n+  >\n+\n+<!ELEMENT bdo %Inline;>  <!-- I18N BiDi over-ride -->\n+<!ATTLIST bdo\n+  %coreattrs;\n+  %events;\n+  lang        %LanguageCode; #IMPLIED\n+  xml:lang    %LanguageCode; #IMPLIED\n+  dir         (ltr|rtl)      #REQUIRED\n+  >\n+\n+<!ELEMENT br EMPTY>   <!-- forced line break -->\n+<!ATTLIST br\n+  %coreattrs;\n+  clear       (left|all|right|none) \"none\"\n+  >\n+\n+<!ELEMENT em %Inline;>   <!-- emphasis -->\n+<!ATTLIST em %attrs;>\n+\n+<!ELEMENT strong %Inline;>   <!-- strong emphasis -->\n+<!ATTLIST strong %attrs;>\n+\n+<!ELEMENT dfn %Inline;>   <!-- definitional -->\n+<!ATTLIST dfn %attrs;>\n+\n+<!ELEMENT code %Inline;>   <!-- program code -->\n+<!ATTLIST code %attrs;>\n+\n+<!ELEMENT samp %Inline;>   <!-- sample -->\n+<!ATTLIST samp %attrs;>\n+\n+<!ELEMENT kbd %Inline;>  <!-- something user would type -->\n+<!ATTLIST kbd %attrs;>\n+\n+<!ELEMENT var %Inline;>   <!-- variable -->\n+<!ATTLIST var %attrs;>\n+\n+<!ELEMENT cite %Inline;>   <!-- citation -->\n+<!ATTLIST cite %attrs;>\n+\n+<!ELEMENT abbr %Inline;>   <!-- abbreviation -->\n+<!ATTLIST abbr %attrs;>\n+\n+<!ELEMENT acronym %Inline;>   <!-- acronym -->\n+<!ATTLIST acronym %attrs;>\n+\n+<!ELEMENT q %Inline;>   <!-- inlined quote -->\n+<!ATTLIST q\n+  %attrs;\n+  cite        %URI;          #IMPLIED\n+  >\n+\n+<!ELEMENT sub %Inline;> <!-- subscript -->\n+<!ATTLIST sub %attrs;>\n+\n+<!ELEMENT sup %Inline;> <!-- superscript -->\n+<!ATTLIST sup %attrs;>\n+\n+<!ELEMENT tt %Inline;>   <!-- fixed pitch font -->\n+<!ATTLIST tt %attrs;>\n+\n+<!ELEMENT i %Inline;>   <!-- italic font -->\n+<!ATTLIST i %attrs;>\n+\n+<!ELEMENT b %Inline;>   <!-- bold font -->\n+<!ATTLIST b %attrs;>\n+\n+<!ELEMENT big %Inline;>   <!-- bigger font -->\n+<!ATTLIST big %attrs;>\n+\n+<!ELEMENT small %Inline;>   <!-- smaller font -->\n+<!ATTLIST small %attrs;>\n+\n+<!ELEMENT u %Inline;>   <!-- underline -->\n+<!ATTLIST u %attrs;>\n+\n+<!ELEMENT s %Inline;>   <!-- strike-through -->\n+<!ATTLIST s %attrs;>\n+\n+<!ELEMENT strike %Inline;>   <!-- strike-through -->\n+<!ATTLIST strike %attrs;>\n+\n+<!ELEMENT basefont EMPTY>  <!-- base font size -->\n+<!ATTLIST basefont\n+  id          ID             #IMPLIED\n+  size        CDATA          #REQUIRED\n+  color       %Color;        #IMPLIED\n+  face        CDATA          #IMPLIED\n+  >\n+\n+<!ELEMENT font %Inline;> <!-- local change to font -->\n+<!ATTLIST font\n+  %coreattrs;\n+  %i18n;\n+  size        CDATA          #IMPLIED\n+  color       %Color;        #IMPLIED\n+  face        CDATA          #IMPLIED\n+  >\n+\n+<!--==================== Object ======================================-->\n+<!--\n+  object is used to embed objects as part of HTML pages.\n+  param elements should precede other content. Parameters\n+  can also be expressed as attribute\/value pairs on the\n+  object element itself when brevity is desired.\n+-->\n+\n+<!ELEMENT object (#PCDATA | param | %block; | form | %inline; | %misc;)*>\n+<!ATTLIST object\n+  %attrs;\n+  declare     (declare)      #IMPLIED\n+  classid     %URI;          #IMPLIED\n+  codebase    %URI;          #IMPLIED\n+  data        %URI;          #IMPLIED\n+  type        %ContentType;  #IMPLIED\n+  codetype    %ContentType;  #IMPLIED\n+  archive     %UriList;      #IMPLIED\n+  standby     %Text;         #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  align       %ImgAlign;     #IMPLIED\n+  border      %Pixels;       #IMPLIED\n+  hspace      %Pixels;       #IMPLIED\n+  vspace      %Pixels;       #IMPLIED\n+  >\n+\n+<!--\n+  param is used to supply a named property value.\n+  In XML it would seem natural to follow RDF and support an\n+  abbreviated syntax where the param elements are replaced\n+  by attribute value pairs on the object start tag.\n+-->\n+<!ELEMENT param EMPTY>\n+<!ATTLIST param\n+  id          ID             #IMPLIED\n+  name        CDATA          #REQUIRED\n+  value       CDATA          #IMPLIED\n+  valuetype   (data|ref|object) \"data\"\n+  type        %ContentType;  #IMPLIED\n+  >\n+\n+<!--=================== Java applet ==================================-->\n+<!--\n+  One of code or object attributes must be present.\n+  Place param elements before other content.\n+-->\n+<!ELEMENT applet (#PCDATA | param | %block; | form | %inline; | %misc;)*>\n+<!ATTLIST applet\n+  %coreattrs;\n+  codebase    %URI;          #IMPLIED\n+  archive     CDATA          #IMPLIED\n+  code        CDATA          #IMPLIED\n+  object      CDATA          #IMPLIED\n+  alt         %Text;         #IMPLIED\n+  name        NMTOKEN        #IMPLIED\n+  width       %Length;       #REQUIRED\n+  height      %Length;       #REQUIRED\n+  align       %ImgAlign;     #IMPLIED\n+  hspace      %Pixels;       #IMPLIED\n+  vspace      %Pixels;       #IMPLIED\n+  >\n+\n+<!--=================== Images ===========================================-->\n+\n+<!--\n+   To avoid accessibility problems for people who aren't\n+   able to see the image, you should provide a text\n+   description using the alt and longdesc attributes.\n+   In addition, avoid the use of server-side image maps.\n+-->\n+\n+<!ELEMENT img EMPTY>\n+<!ATTLIST img\n+  %attrs;\n+  src         %URI;          #REQUIRED\n+  alt         %Text;         #REQUIRED\n+  name        NMTOKEN        #IMPLIED\n+  longdesc    %URI;          #IMPLIED\n+  height      %Length;       #IMPLIED\n+  width       %Length;       #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  ismap       (ismap)        #IMPLIED\n+  align       %ImgAlign;     #IMPLIED\n+  border      %Length;       #IMPLIED\n+  hspace      %Pixels;       #IMPLIED\n+  vspace      %Pixels;       #IMPLIED\n+  >\n+\n+<!-- usemap points to a map element which may be in this document\n+  or an external document, although the latter is not widely supported -->\n+\n+<!--================== Client-side image maps ============================-->\n+\n+<!-- These can be placed in the same document or grouped in a\n+     separate document although this isn't yet widely supported -->\n+\n+<!ELEMENT map ((%block; | form | %misc;)+ | area+)>\n+<!ATTLIST map\n+  %i18n;\n+  %events;\n+  id          ID             #REQUIRED\n+  class       CDATA          #IMPLIED\n+  style       %StyleSheet;   #IMPLIED\n+  title       %Text;         #IMPLIED\n+  name        CDATA          #IMPLIED\n+  >\n+\n+<!ELEMENT area EMPTY>\n+<!ATTLIST area\n+  %attrs;\n+  %focus;\n+  shape       %Shape;        \"rect\"\n+  coords      %Coords;       #IMPLIED\n+  href        %URI;          #IMPLIED\n+  nohref      (nohref)       #IMPLIED\n+  alt         %Text;         #REQUIRED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!--================ Forms ===============================================-->\n+\n+<!ELEMENT form %form.content;>   <!-- forms shouldn't be nested -->\n+\n+<!ATTLIST form\n+  %attrs;\n+  action      %URI;          #REQUIRED\n+  method      (get|post)     \"get\"\n+  name        NMTOKEN        #IMPLIED\n+  enctype     %ContentType;  \"application\/x-www-form-urlencoded\"\n+  onsubmit    %Script;       #IMPLIED\n+  onreset     %Script;       #IMPLIED\n+  accept      %ContentTypes; #IMPLIED\n+  accept-charset %Charsets;  #IMPLIED\n+  target      %FrameTarget;  #IMPLIED\n+  >\n+\n+<!--\n+  Each label must not contain more than ONE field\n+  Label elements shouldn't be nested.\n+-->\n+<!ELEMENT label %Inline;>\n+<!ATTLIST label\n+  %attrs;\n+  for         IDREF          #IMPLIED\n+  accesskey   %Character;    #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\n+  >\n+\n+<!ENTITY % InputType\n+  \"(text | password | checkbox |\n+    radio | submit | reset |\n+    file | hidden | image | button)\"\n+   >\n+\n+<!-- the name attribute is required for all but submit & reset -->\n+\n+<!ELEMENT input EMPTY>     <!-- form control -->\n+<!ATTLIST input\n+  %attrs;\n+  %focus;\n+  type        %InputType;    \"text\"\n+  name        CDATA          #IMPLIED\n+  value       CDATA          #IMPLIED\n+  checked     (checked)      #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  readonly    (readonly)     #IMPLIED\n+  size        CDATA          #IMPLIED\n+  maxlength   %Number;       #IMPLIED\n+  src         %URI;          #IMPLIED\n+  alt         CDATA          #IMPLIED\n+  usemap      %URI;          #IMPLIED\n+  onselect    %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  accept      %ContentTypes; #IMPLIED\n+  align       %ImgAlign;     #IMPLIED\n+  >\n+\n+<!ELEMENT select (optgroup|option)+>  <!-- option selector -->\n+<!ATTLIST select\n+  %attrs;\n+  name        CDATA          #IMPLIED\n+  size        %Number;       #IMPLIED\n+  multiple    (multiple)     #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  tabindex    %Number;       #IMPLIED\n+  onfocus     %Script;       #IMPLIED\n+  onblur      %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  >\n+\n+<!ELEMENT optgroup (option)+>   <!-- option group -->\n+<!ATTLIST optgroup\n+  %attrs;\n+  disabled    (disabled)     #IMPLIED\n+  label       %Text;         #REQUIRED\n+  >\n+\n+<!ELEMENT option (#PCDATA)>     <!-- selectable choice -->\n+<!ATTLIST option\n+  %attrs;\n+  selected    (selected)     #IMPLIED\n+  disabled    (disabled)     #IMPLIED\n+  label       %Text;         #IMPLIED\n+  value       CDATA          #IMPLIED\n+  >\n+\n+<!ELEMENT textarea (#PCDATA)>     <!-- multi-line text field -->\n+<!ATTLIST textarea\n+  %attrs;\n+  %focus;\n+  name        CDATA          #IMPLIED\n+  rows        %Number;       #REQUIRED\n+  cols        %Number;       #REQUIRED\n+  disabled    (disabled)     #IMPLIED\n+  readonly    (readonly)     #IMPLIED\n+  onselect    %Script;       #IMPLIED\n+  onchange    %Script;       #IMPLIED\n+  >\n+\n+<!--\n+  The fieldset element is used to group form fields.\n+  Only one legend element should occur in the content\n+  and if present should only be preceded by whitespace.\n+-->\n+<!ELEMENT fieldset (#PCDATA | legend | %block; | form | %inline; | %misc;)*>\n+<!ATTLIST fieldset\n+  %attrs;\n+  >\n+\n+<!ENTITY % LAlign \"(top|bottom|left|right)\">\n+\n+<!ELEMENT legend %Inline;>     <!-- fieldset label -->\n+<!ATTLIST legend\n+  %attrs;\n+  accesskey   %Character;    #IMPLIED\n+  align       %LAlign;       #IMPLIED\n+  >\n+\n+<!--\n+ Content is %Flow; excluding a, form, form controls, iframe\n+--> \n+<!ELEMENT button %button.content;>  <!-- push button -->\n+<!ATTLIST button\n+  %attrs;\n+  %focus;\n+  name        CDATA          #IMPLIED\n+  value       CDATA          #IMPLIED\n+  type        (button|submit|reset) \"submit\"\n+  disabled    (disabled)     #IMPLIED\n+  >\n+\n+<!-- single-line text input control (DEPRECATED) -->\n+<!ELEMENT isindex EMPTY>\n+<!ATTLIST isindex\n+  %coreattrs;\n+  %i18n;\n+  prompt      %Text;         #IMPLIED\n+  >\n+\n+<!--======================= Tables =======================================-->\n+\n+<!-- Derived from IETF HTML table standard, see [RFC1942] -->\n+\n+<!--\n+ The border attribute sets the thickness of the frame around the\n+ table. The default units are screen pixels.\n+\n+ The frame attribute specifies which parts of the frame around\n+ the table should be rendered. The values are not the same as\n+ CALS to avoid a name clash with the valign attribute.\n+-->\n+<!ENTITY % TFrame \"(void|above|below|hsides|lhs|rhs|vsides|box|border)\">\n+\n+<!--\n+ The rules attribute defines which rules to draw between cells:\n+\n+ If rules is absent then assume:\n+     \"none\" if border is absent or border=\"0\" otherwise \"all\"\n+-->\n+\n+<!ENTITY % TRules \"(none | groups | rows | cols | all)\">\n+  \n+<!-- horizontal placement of table relative to document -->\n+<!ENTITY % TAlign \"(left|center|right)\">\n+\n+<!-- horizontal alignment attributes for cell contents\n+\n+  char        alignment char, e.g. char=':'\n+  charoff     offset for alignment char\n+-->\n+<!ENTITY % cellhalign\n+  \"align      (left|center|right|justify|char) #IMPLIED\n+   char       %Character;    #IMPLIED\n+   charoff    %Length;       #IMPLIED\"\n+  >\n+\n+<!-- vertical alignment attributes for cell contents -->\n+<!ENTITY % cellvalign\n+  \"valign     (top|middle|bottom|baseline) #IMPLIED\"\n+  >\n+\n+<!ELEMENT table\n+     (caption?, (col*|colgroup*), thead?, tfoot?, (tbody+|tr+))>\n+<!ELEMENT caption  %Inline;>\n+<!ELEMENT thead    (tr)+>\n+<!ELEMENT tfoot    (tr)+>\n+<!ELEMENT tbody    (tr)+>\n+<!ELEMENT colgroup (col)*>\n+<!ELEMENT col      EMPTY>\n+<!ELEMENT tr       (th|td)+>\n+<!ELEMENT th       %Flow;>\n+<!ELEMENT td       %Flow;>\n+\n+<!ATTLIST table\n+  %attrs;\n+  summary     %Text;         #IMPLIED\n+  width       %Length;       #IMPLIED\n+  border      %Pixels;       #IMPLIED\n+  frame       %TFrame;       #IMPLIED\n+  rules       %TRules;       #IMPLIED\n+  cellspacing %Length;       #IMPLIED\n+  cellpadding %Length;       #IMPLIED\n+  align       %TAlign;       #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  >\n+\n+<!ENTITY % CAlign \"(top|bottom|left|right)\">\n+\n+<!ATTLIST caption\n+  %attrs;\n+  align       %CAlign;       #IMPLIED\n+  >\n+\n+<!--\n+colgroup groups a set of col elements. It allows you to group\n+several semantically related columns together.\n+-->\n+<!ATTLIST colgroup\n+  %attrs;\n+  span        %Number;       \"1\"\n+  width       %MultiLength;  #IMPLIED\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!--\n+ col elements define the alignment properties for cells in\n+ one or more columns.\n+\n+ The width attribute specifies the width of the columns, e.g.\n+\n+     width=64        width in screen pixels\n+     width=0.5*      relative width of 0.5\n+\n+ The span attribute causes the attributes of one\n+ col element to apply to more than one column.\n+-->\n+<!ATTLIST col\n+  %attrs;\n+  span        %Number;       \"1\"\n+  width       %MultiLength;  #IMPLIED\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!--\n+    Use thead to duplicate headers when breaking table\n+    across page boundaries, or for static headers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use tfoot to duplicate footers when breaking table\n+    across page boundaries, or for static footers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use multiple tbody sections when rules are needed\n+    between groups of table rows.\n+-->\n+<!ATTLIST thead\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tfoot\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tbody\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  >\n+\n+<!ATTLIST tr\n+  %attrs;\n+  %cellhalign;\n+  %cellvalign;\n+  bgcolor     %Color;        #IMPLIED\n+  >\n+\n+<!-- Scope is simpler than headers attribute for common tables -->\n+<!ENTITY % Scope \"(row|col|rowgroup|colgroup)\">\n+\n+<!-- th is for headers, td for data and for cells acting as both -->\n+\n+<!ATTLIST th\n+  %attrs;\n+  abbr        %Text;         #IMPLIED\n+  axis        CDATA          #IMPLIED\n+  headers     IDREFS         #IMPLIED\n+  scope       %Scope;        #IMPLIED\n+  rowspan     %Number;       \"1\"\n+  colspan     %Number;       \"1\"\n+  %cellhalign;\n+  %cellvalign;\n+  nowrap      (nowrap)       #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  width       %Length;       #IMPLIED\n+  height      %Length;       #IMPLIED\n+  >\n+\n+<!ATTLIST td\n+  %attrs;\n+  abbr        %Text;         #IMPLIED\n+  axis        CDATA          #IMPLIED\n+  headers     IDREFS         #IMPLIED\n+  scope       %Scope;        #IMPLIED\n+  rowspan     %Number;       \"1\"\n+  colspan     %Number;       \"1\"\n+  %cellhalign;\n+  %cellvalign;\n+  nowrap      (nowrap)       #IMPLIED\n+  bgcolor     %Color;        #IMPLIED\n+  width       %Length;       #IMPLIED\n+  height      %Length;       #IMPLIED\n+  >\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml10\/xhtml1-transitional.dtd","additions":1201,"deletions":0,"binary":false,"changes":1201,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Common Attributes Module  ...................................... -->\n+<!-- file: xhtml-attribs-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-attribs-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Common Attributes 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-attribs-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Common Attributes\n+\n+     This module declares many of the common attributes for the XHTML DTD.\n+     %NS.decl.attrib; is declared in the XHTML Qname module.\n+\n+\t Note that this file was extended in XHTML Modularization 1.1 to \n+\t include declarations of \"global\" versions of the attribute collections.\n+\t The global versions of the attributes are for use on elements in other \n+\t namespaces.  The global version of \"common\" includes the xmlns declaration\n+\t for the prefixed version of the xhtml namespace.  If you are only using a\n+\t specific attribute or an individual attribute collection, you must also\n+\t include the XHTML.xmlns.attrib.prefixed PE on your elements.\n+-->\n+\n+<!ENTITY % id.attrib\n+     \"id           ID                       #IMPLIED\"\n+>\n+\n+<![%XHTML.global.attrs.prefixed;[\n+<!ENTITY % XHTML.global.id.attrib\n+     \"%XHTML.prefix;:id           ID        #IMPLIED\"\n+>\n+]]>\n+\n+<!ENTITY % class.attrib\n+     \"class        CDATA                 #IMPLIED\"\n+>\n+\n+<![%XHTML.global.attrs.prefixed;[\n+<!ENTITY % XHTML.global.class.attrib\n+     \"%XHTML.prefix;:class        CDATA                 #IMPLIED\"\n+>\n+]]>\n+\n+<!ENTITY % title.attrib\n+     \"title        %Text.datatype;          #IMPLIED\"\n+>\n+\n+<![%XHTML.global.attrs.prefixed;[\n+<!ENTITY % XHTML.global.title.attrib\n+     \"%XHTML.prefix;:title        %Text.datatype;          #IMPLIED\"\n+>\n+]]>\n+\n+<!ENTITY % Core.extra.attrib \"\" >\n+\n+<!ENTITY % Core.attrib\n+     \"%XHTML.xmlns.attrib;\n+      %id.attrib;\n+      %class.attrib;\n+      %title.attrib;\n+      xml:space    ( preserve )             #FIXED 'preserve'\n+      %Core.extra.attrib;\"\n+>\n+\n+<!ENTITY % XHTML.global.core.extra.attrib \"\" >\n+\n+<![%XHTML.global.attrs.prefixed;[\n+\n+<!ENTITY % XHTML.global.core.attrib\n+     \"%XHTML.global.id.attrib;\n+      %XHTML.global.class.attrib;\n+      %XHTML.global.title.attrib;\n+      %XHTML.global.core.extra.attrib;\"\n+>\n+]]>\n+\n+<!ENTITY % XHTML.global.core.attrib \"\" >\n+\n+\n+<!ENTITY % lang.attrib\n+     \"xml:lang     %LanguageCode.datatype;  #IMPLIED\"\n+>\n+\n+<![%XHTML.bidi;[\n+<!ENTITY % dir.attrib\n+     \"dir          ( ltr | rtl )            #IMPLIED\"\n+>\n+\n+<!ENTITY % I18n.attrib\n+     \"%dir.attrib;\n+      %lang.attrib;\"\n+>\n+\n+<![%XHTML.global.attrs.prefixed;[\n+<!ENTITY XHTML.global.i18n.attrib\n+     \"%XHTML.prefix;:dir          ( ltr | rtl )            #IMPLIED\n+      %lang.attrib;\"\n+>\n+]]>\n+<!ENTITY XHTML.global.i18n.attrib \"\" >\n+\n+]]>\n+<!ENTITY % I18n.attrib\n+     \"%lang.attrib;\"\n+>\n+<!ENTITY % XHTML.global.i18n.attrib\n+     \"%lang.attrib;\"\n+>\n+\n+<!ENTITY % Common.extra.attrib \"\" >\n+<!ENTITY % XHTML.global.common.extra.attrib \"\" >\n+\n+<!-- intrinsic event attributes declared previously\n+-->\n+<!ENTITY % Events.attrib \"\" >\n+\n+<!ENTITY % XHTML.global.events.attrib \"\" >\n+\n+<!ENTITY % Common.attrib\n+     \"%Core.attrib;\n+      %I18n.attrib;\n+      %Events.attrib;\n+      %Common.extra.attrib;\"\n+>\n+\n+<!ENTITY % XHTML.global.common.attrib\n+     \"%XHTML.xmlns.attrib.prefixed;\n+      %XHTML.global.core.attrib;\n+\t  %XHTML.global.i18n.attrib;\n+\t  %XHTML.global.events.attrib;\n+\t  %XHTML.global.common.extra.attrib;\"\n+>\n+\n+<!-- end of xhtml-attribs-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-attribs-1.mod","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Base Element Module  ........................................... -->\n+<!-- file: xhtml-base-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-base-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Base Element 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-base-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Base element\n+\n+        base\n+\n+     This module declares the base element type and its attributes,\n+     used to define a base URI against which relative URIs in the\n+     document will be resolved.\n+\n+     Note that this module also redeclares the content model for\n+     the head element to include the base element.\n+-->\n+\n+<!-- base: Document Base URI ........................... -->\n+\n+<!ENTITY % base.element  \"INCLUDE\" >\n+<![%base.element;[\n+<!ENTITY % base.content  \"EMPTY\" >\n+<!ENTITY % base.qname  \"base\" >\n+<!ELEMENT %base.qname;  %base.content; >\n+<!-- end of base.element -->]]>\n+\n+<!ENTITY % base.attlist  \"INCLUDE\" >\n+<![%base.attlist;[\n+<!ATTLIST %base.qname;\n+      %XHTML.xmlns.attrib;\n+      href         %URI.datatype;           #REQUIRED\n+>\n+<!-- end of base.attlist -->]]>\n+\n+<!ENTITY % head.content\n+    \"( %HeadOpts.mix;,\n+     ( ( %title.qname;, %HeadOpts.mix;, ( %base.qname;, %HeadOpts.mix; )? )\n+     | ( %base.qname;, %HeadOpts.mix;, ( %title.qname;, %HeadOpts.mix; ))))\"\n+>\n+\n+<!-- end of xhtml-base-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-base-1.mod","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML BDO Element Module ............................................. -->\n+<!-- file: xhtml-bdo-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-bdo-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML BDO Element 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-bdo-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Bidirectional Override (bdo) Element\n+\n+     This modules declares the element 'bdo', used to override the\n+     Unicode bidirectional algorithm for selected fragments of text.\n+\n+     DEPENDENCIES:\n+     Relies on the conditional section keyword %XHTML.bidi; declared\n+     as \"INCLUDE\". Bidirectional text support includes both the bdo\n+     element and the 'dir' attribute.\n+-->\n+\n+<!ENTITY % bdo.element  \"INCLUDE\" >\n+<![%bdo.element;[\n+<!ENTITY % bdo.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % bdo.qname  \"bdo\" >\n+<!ELEMENT %bdo.qname;  %bdo.content; >\n+<!-- end of bdo.element -->]]>\n+\n+<!ENTITY % bdo.attlist  \"INCLUDE\" >\n+<![%bdo.attlist;[\n+<!ATTLIST %bdo.qname;\n+      %Core.attrib;\n+\t  %lang.attrib;\n+      dir          ( ltr | rtl )            #REQUIRED\n+>\n+]]>\n+\n+<!-- end of xhtml-bdo-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-bdo-1.mod","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Block Phrasal Module  .......................................... -->\n+<!-- file: xhtml-blkphras-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-blkphras-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Block Phrasal 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-blkphras-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Block Phrasal\n+\n+        address, blockquote, pre, h1, h2, h3, h4, h5, h6\n+\n+     This module declares the elements and their attributes used to\n+     support block-level phrasal markup.\n+-->\n+\n+<!ENTITY % address.element  \"INCLUDE\" >\n+<![%address.element;[\n+<!ENTITY % address.content\n+     \"( #PCDATA | %Inline.mix; )*\" >\n+<!ENTITY % address.qname  \"address\" >\n+<!ELEMENT %address.qname;  %address.content; >\n+<!-- end of address.element -->]]>\n+\n+<!ENTITY % address.attlist  \"INCLUDE\" >\n+<![%address.attlist;[\n+<!ATTLIST %address.qname;\n+      %Common.attrib;\n+>\n+<!-- end of address.attlist -->]]>\n+\n+<!ENTITY % blockquote.element  \"INCLUDE\" >\n+<![%blockquote.element;[\n+<!ENTITY % blockquote.content\n+     \"( %Block.mix; )*\"\n+>\n+<!ENTITY % blockquote.qname  \"blockquote\" >\n+<!ELEMENT %blockquote.qname;  %blockquote.content; >\n+<!-- end of blockquote.element -->]]>\n+\n+<!ENTITY % blockquote.attlist  \"INCLUDE\" >\n+<![%blockquote.attlist;[\n+<!ATTLIST %blockquote.qname;\n+      %Common.attrib;\n+      cite         %URI.datatype;           #IMPLIED\n+>\n+<!-- end of blockquote.attlist -->]]>\n+\n+<!ENTITY % pre.element  \"INCLUDE\" >\n+<![%pre.element;[\n+<!ENTITY % pre.content\n+     \"( #PCDATA\n+      | %InlStruct.class;\n+      %InlPhras.class;\n+      | %tt.qname; | %i.qname; | %b.qname;\n+      %I18n.class;\n+      %Anchor.class;\n+      | %map.qname;\n+      %Misc.class;\n+      %Inline.extra; )*\"\n+>\n+<!ENTITY % pre.qname  \"pre\" >\n+<!ELEMENT %pre.qname;  %pre.content; >\n+<!-- end of pre.element -->]]>\n+\n+<!ENTITY % pre.attlist  \"INCLUDE\" >\n+<![%pre.attlist;[\n+<!ATTLIST %pre.qname;\n+      %Common.attrib;\n+>\n+<!-- end of pre.attlist -->]]>\n+\n+<!-- ...................  Heading Elements  ................... -->\n+\n+<!ENTITY % Heading.content  \"( #PCDATA | %Inline.mix; )*\" >\n+\n+<!ENTITY % h1.element  \"INCLUDE\" >\n+<![%h1.element;[\n+<!ENTITY % h1.qname  \"h1\" >\n+<!ELEMENT %h1.qname;  %Heading.content; >\n+<!-- end of h1.element -->]]>\n+\n+<!ENTITY % h1.attlist  \"INCLUDE\" >\n+<![%h1.attlist;[\n+<!ATTLIST %h1.qname;\n+      %Common.attrib;\n+>\n+<!-- end of h1.attlist -->]]>\n+\n+<!ENTITY % h2.element  \"INCLUDE\" >\n+<![%h2.element;[\n+<!ENTITY % h2.qname  \"h2\" >\n+<!ELEMENT %h2.qname;  %Heading.content; >\n+<!-- end of h2.element -->]]>\n+\n+<!ENTITY % h2.attlist  \"INCLUDE\" >\n+<![%h2.attlist;[\n+<!ATTLIST %h2.qname;\n+      %Common.attrib;\n+>\n+<!-- end of h2.attlist -->]]>\n+\n+<!ENTITY % h3.element  \"INCLUDE\" >\n+<![%h3.element;[\n+<!ENTITY % h3.qname  \"h3\" >\n+<!ELEMENT %h3.qname;  %Heading.content; >\n+<!-- end of h3.element -->]]>\n+\n+<!ENTITY % h3.attlist  \"INCLUDE\" >\n+<![%h3.attlist;[\n+<!ATTLIST %h3.qname;\n+      %Common.attrib;\n+>\n+<!-- end of h3.attlist -->]]>\n+\n+<!ENTITY % h4.element  \"INCLUDE\" >\n+<![%h4.element;[\n+<!ENTITY % h4.qname  \"h4\" >\n+<!ELEMENT %h4.qname;  %Heading.content; >\n+<!-- end of h4.element -->]]>\n+\n+<!ENTITY % h4.attlist  \"INCLUDE\" >\n+<![%h4.attlist;[\n+<!ATTLIST %h4.qname;\n+      %Common.attrib;\n+>\n+<!-- end of h4.attlist -->]]>\n+\n+<!ENTITY % h5.element  \"INCLUDE\" >\n+<![%h5.element;[\n+<!ENTITY % h5.qname  \"h5\" >\n+<!ELEMENT %h5.qname;  %Heading.content; >\n+<!-- end of h5.element -->]]>\n+\n+<!ENTITY % h5.attlist  \"INCLUDE\" >\n+<![%h5.attlist;[\n+<!ATTLIST %h5.qname;\n+      %Common.attrib;\n+>\n+<!-- end of h5.attlist -->]]>\n+\n+<!ENTITY % h6.element  \"INCLUDE\" >\n+<![%h6.element;[\n+<!ENTITY % h6.qname  \"h6\" >\n+<!ELEMENT %h6.qname;  %Heading.content; >\n+<!-- end of h6.element -->]]>\n+\n+<!ENTITY % h6.attlist  \"INCLUDE\" >\n+<![%h6.attlist;[\n+<!ATTLIST %h6.qname;\n+      %Common.attrib;\n+>\n+<!-- end of h6.attlist -->]]>\n+\n+<!-- end of xhtml-blkphras-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-blkphras-1.mod","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Block Presentation Module  ..................................... -->\n+<!-- file: xhtml-blkpres-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-blkpres-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Block Presentation 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-blkpres-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Block Presentational Elements\n+\n+        hr\n+\n+     This module declares the elements and their attributes used to\n+     support block-level presentational markup.\n+-->\n+\n+<!ENTITY % hr.element  \"INCLUDE\" >\n+<![%hr.element;[\n+<!ENTITY % hr.content  \"EMPTY\" >\n+<!ENTITY % hr.qname  \"hr\" >\n+<!ELEMENT %hr.qname;  %hr.content; >\n+<!-- end of hr.element -->]]>\n+\n+<!ENTITY % hr.attlist  \"INCLUDE\" >\n+<![%hr.attlist;[\n+<!ATTLIST %hr.qname;\n+      %Common.attrib;\n+>\n+<!-- end of hr.attlist -->]]>\n+\n+<!-- end of xhtml-blkpres-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-blkpres-1.mod","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Block Structural Module  ....................................... -->\n+<!-- file: xhtml-blkstruct-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-blkstruct-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Block Structural 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-blkstruct-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Block Structural\n+\n+        div, p\n+\n+     This module declares the elements and their attributes used to\n+     support block-level structural markup.\n+-->\n+\n+<!ENTITY % div.element  \"INCLUDE\" >\n+<![%div.element;[\n+<!ENTITY % div.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ENTITY % div.qname  \"div\" >\n+<!ELEMENT %div.qname;  %div.content; >\n+<!-- end of div.element -->]]>\n+\n+<!ENTITY % div.attlist  \"INCLUDE\" >\n+<![%div.attlist;[\n+<!ATTLIST %div.qname;\n+      %Common.attrib;\n+>\n+<!-- end of div.attlist -->]]>\n+\n+<!ENTITY % p.element  \"INCLUDE\" >\n+<![%p.element;[\n+<!ENTITY % p.content\n+     \"( #PCDATA | %Inline.mix; )*\" >\n+<!ENTITY % p.qname  \"p\" >\n+<!ELEMENT %p.qname;  %p.content; >\n+<!-- end of p.element -->]]>\n+\n+<!ENTITY % p.attlist  \"INCLUDE\" >\n+<![%p.attlist;[\n+<!ATTLIST %p.qname;\n+      %Common.attrib;\n+>\n+<!-- end of p.attlist -->]]>\n+\n+<!-- end of xhtml-blkstruct-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-blkstruct-1.mod","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Character Entities Module  ......................................... -->\n+<!-- file: xhtml-charent-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-charent-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Character Entities 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-charent-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Character Entities for XHTML\n+\n+     This module declares the set of character entities for XHTML,\n+     including the Latin 1, Symbol and Special character collections.\n+-->\n+\n+<!ENTITY % xhtml-lat1\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+           \"xhtml-lat1.ent\" >\n+%xhtml-lat1;\n+\n+<!ENTITY % xhtml-symbol\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+           \"xhtml-symbol.ent\" >\n+%xhtml-symbol;\n+\n+<!ENTITY % xhtml-special\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+           \"xhtml-special.ent\" >\n+%xhtml-special;\n+\n+<!-- end of xhtml-charent-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-charent-1.mod","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Client-side Image Map Module  .................................. -->\n+<!-- file: xhtml-csismap-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-csismap-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Client-side Image Maps 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-csismap-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Client-side Image Maps\n+\n+        area, map\n+\n+     This module declares elements and attributes to support client-side\n+     image maps. This requires that the Image Module (or a module\n+     declaring the img element type) be included in the DTD.\n+\n+     These can be placed in the same document or grouped in a\n+     separate document, although the latter isn't widely supported\n+-->\n+\n+<!ENTITY % area.element  \"INCLUDE\" >\n+<![%area.element;[\n+<!ENTITY % area.content  \"EMPTY\" >\n+<!ENTITY % area.qname  \"area\" >\n+<!ELEMENT %area.qname;  %area.content; >\n+<!-- end of area.element -->]]>\n+\n+<!ENTITY % Shape.datatype \"( rect | circle | poly | default )\">\n+<!ENTITY % Coords.datatype \"CDATA\" >\n+\n+<!ENTITY % area.attlist  \"INCLUDE\" >\n+<![%area.attlist;[\n+<!ATTLIST %area.qname;\n+      %Common.attrib;\n+      href         %URI.datatype;           #IMPLIED\n+      shape        %Shape.datatype;         'rect'\n+      coords       %Coords.datatype;        #IMPLIED\n+      nohref       ( nohref )               #IMPLIED\n+      alt          %Text.datatype;          #REQUIRED\n+      tabindex     %Number.datatype;        #IMPLIED\n+      accesskey    %Character.datatype;     #IMPLIED\n+>\n+<!-- end of area.attlist -->]]>\n+\n+<!-- modify anchor attribute definition list\n+     to allow for client-side image maps\n+-->\n+<!ATTLIST %a.qname;\n+      shape        %Shape.datatype;         'rect'\n+      coords       %Coords.datatype;        #IMPLIED\n+>\n+\n+<!-- modify img attribute definition list\n+     to allow for client-side image maps\n+-->\n+<!ATTLIST %img.qname;\n+      usemap       %URIREF.datatype;        #IMPLIED\n+>\n+\n+<!-- modify form input attribute definition list\n+     to allow for client-side image maps\n+-->\n+<!ATTLIST %input.qname;\n+      usemap       %URIREF.datatype;        #IMPLIED\n+>\n+\n+<!-- modify object attribute definition list\n+     to allow for client-side image maps\n+-->\n+<!ATTLIST %object.qname;\n+      usemap       %URIREF.datatype;        #IMPLIED\n+>\n+\n+<!-- 'usemap' points to the 'id' attribute of a <map> element,\n+     which must be in the same document; support for external\n+     document maps was not widely supported in HTML and is\n+     eliminated in XHTML.\n+\n+     It is considered an error for the element pointed to by\n+     a usemap URIREF to occur in anything but a <map> element.\n+-->\n+\n+<!ENTITY % map.element  \"INCLUDE\" >\n+<![%map.element;[\n+<!ENTITY % map.content\n+     \"(( %Block.mix; ) | %area.qname; )+\"\n+>\n+<!ENTITY % map.qname  \"map\" >\n+<!ELEMENT %map.qname;  %map.content; >\n+<!-- end of map.element -->]]>\n+\n+<!ENTITY % map.attlist  \"INCLUDE\" >\n+<![%map.attlist;[\n+<!ATTLIST %map.qname;\n+      %XHTML.xmlns.attrib;\n+      id           ID                       #REQUIRED\n+      %class.attrib;\n+      %title.attrib;\n+      %Core.extra.attrib;\n+      %I18n.attrib;\n+      %Events.attrib;\n+>\n+<!-- end of map.attlist -->]]>\n+\n+<!-- end of xhtml-csismap-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-csismap-1.mod","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Datatypes Module  .............................................. -->\n+<!-- file: xhtml-datatypes-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-datatypes-1.mod,v 4.1 2001\/04\/06 19:23:32 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Datatypes 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-datatypes-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Datatypes\n+\n+     defines containers for the following datatypes, many of\n+     these imported from other specifications and standards.\n+-->\n+\n+<!-- Length defined for cellpadding\/cellspacing -->\n+\n+<!-- nn for pixels or nn% for percentage length -->\n+<!ENTITY % Length.datatype \"CDATA\" >\n+\n+<!-- space-separated list of link types -->\n+<!ENTITY % LinkTypes.datatype \"NMTOKENS\" >\n+\n+<!-- single or comma-separated list of media descriptors -->\n+<!ENTITY % MediaDesc.datatype \"CDATA\" >\n+\n+<!-- pixel, percentage, or relative -->\n+<!ENTITY % MultiLength.datatype \"CDATA\" >\n+\n+<!-- one or more digits (NUMBER) -->\n+<!ENTITY % Number.datatype \"CDATA\" >\n+\n+<!-- integer representing length in pixels -->\n+<!ENTITY % Pixels.datatype \"CDATA\" >\n+\n+<!-- script expression -->\n+<!ENTITY % Script.datatype \"CDATA\" >\n+\n+<!-- textual content -->\n+<!ENTITY % Text.datatype \"CDATA\" >\n+\n+<!-- Placeholder Compact URI-related types -->\n+<!ENTITY % CURIE.datatype \"CDATA\" >\n+<!ENTITY % CURIEs.datatype \"CDATA\" >\n+<!ENTITY % SafeCURIE.datatype \"CDATA\" >\n+<!ENTITY % SafeCURIEs.datatype \"CDATA\" >\n+<!ENTITY % URIorSafeCURIE.datatype \"CDATA\" >\n+<!ENTITY % URIorSafeCURIEs.datatype \"CDATA\" >\n+\n+<!-- Imported Datatypes ................................ -->\n+\n+<!-- a single character from [ISO10646] -->\n+<!ENTITY % Character.datatype \"CDATA\" >\n+\n+<!-- a character encoding, as per [RFC2045] -->\n+<!ENTITY % Charset.datatype \"CDATA\" >\n+\n+<!-- a space separated list of character encodings, as per [RFC2045] -->\n+<!ENTITY % Charsets.datatype \"CDATA\" >\n+\n+<!-- Color specification using color name or sRGB (#RRGGBB) values -->\n+<!ENTITY % Color.datatype \"CDATA\" >\n+\n+<!-- media type, as per [RFC2045] -->\n+<!ENTITY % ContentType.datatype \"CDATA\" >\n+\n+<!-- comma-separated list of media types, as per [RFC2045] -->\n+<!ENTITY % ContentTypes.datatype \"CDATA\" >\n+\n+<!-- date and time information. ISO date format -->\n+<!ENTITY % Datetime.datatype \"CDATA\" >\n+\n+<!-- formal public identifier, as per [ISO8879] -->\n+<!ENTITY % FPI.datatype \"CDATA\" >\n+\n+<!-- a language code, as per [RFC3066] or its successor -->\n+<!ENTITY % LanguageCode.datatype \"CDATA\" >\n+\n+<!-- a comma separated list of language code ranges -->\n+<!ENTITY % LanguageCodes.datatype \"CDATA\" >\n+\n+<!-- a qualified name , as per [XMLNS] or its successor -->\n+<!ENTITY % QName.datatype \"CDATA\" >\n+<!ENTITY % QNames.datatype \"CDATA\" >\n+\n+<!-- a Uniform Resource Identifier, see [URI] -->\n+<!ENTITY % URI.datatype \"CDATA\" >\n+\n+<!-- a space-separated list of Uniform Resource Identifiers, see [URI] -->\n+<!ENTITY % URIs.datatype \"CDATA\" >\n+\n+<!-- a relative URI reference consisting of an initial '#' and a fragment ID -->\n+<!ENTITY % URIREF.datatype \"CDATA\" >\n+\n+<!-- end of xhtml-datatypes-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-datatypes-1.mod","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Editing Elements Module  ....................................... -->\n+<!-- file: xhtml-edit-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-edit-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Editing Markup 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-edit-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Editing Elements\n+\n+        ins, del\n+\n+     This module declares element types and attributes used to indicate\n+     inserted and deleted content while editing a document.\n+-->\n+\n+<!-- ins: Inserted Text  ............................... -->\n+\n+<!ENTITY % ins.element  \"INCLUDE\" >\n+<![%ins.element;[\n+<!ENTITY % ins.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ENTITY % ins.qname  \"ins\" >\n+<!ELEMENT %ins.qname;  %ins.content; >\n+<!-- end of ins.element -->]]>\n+\n+<!ENTITY % ins.attlist  \"INCLUDE\" >\n+<![%ins.attlist;[\n+<!ATTLIST %ins.qname;\n+      %Common.attrib;\n+      cite         %URI.datatype;           #IMPLIED\n+      datetime     %Datetime.datatype;      #IMPLIED\n+>\n+<!-- end of ins.attlist -->]]>\n+\n+<!-- del: Deleted Text  ................................ -->\n+\n+<!ENTITY % del.element  \"INCLUDE\" >\n+<![%del.element;[\n+<!ENTITY % del.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ENTITY % del.qname  \"del\" >\n+<!ELEMENT %del.qname;  %del.content; >\n+<!-- end of del.element -->]]>\n+\n+<!ENTITY % del.attlist  \"INCLUDE\" >\n+<![%del.attlist;[\n+<!ATTLIST %del.qname;\n+      %Common.attrib;\n+      cite         %URI.datatype;           #IMPLIED\n+      datetime     %Datetime.datatype;      #IMPLIED\n+>\n+<!-- end of del.attlist -->]]>\n+\n+<!-- end of xhtml-edit-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-edit-1.mod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Intrinsic Events Module  ....................................... -->\n+<!-- file: xhtml-events-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-events-1.mod,v 4.1 2001\/04\/10 09:42:30 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Intrinsic Events 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-events-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Intrinsic Event Attributes\n+\n+     These are the event attributes defined in HTML 4,\n+     Section 18.2.3 \"Intrinsic Events\". This module must be\n+     instantiated prior to the Attributes Module but after\n+     the Datatype Module in the Modular Framework module.\n+\n+    \"Note: Authors of HTML documents are advised that changes\n+     are likely to occur in the realm of intrinsic events\n+     (e.g., how scripts are bound to events). Research in\n+     this realm is carried on by members of the W3C Document\n+     Object Model Working Group (see the W3C Web site at\n+     http:\/\/www.w3.org\/ for more information).\"\n+-->\n+<!-- NOTE: Because the ATTLIST declarations in this module occur\n+     before their respective ELEMENT declarations in other\n+     modules, there may be a dependency on this module that\n+     should be considered if any of the parameter entities used\n+     for element type names (eg., %a.qname;) are redeclared.\n+-->\n+\n+<!ENTITY % Events.attrib\n+     \"onclick      %Script.datatype;        #IMPLIED\n+      ondblclick   %Script.datatype;        #IMPLIED\n+      onmousedown  %Script.datatype;        #IMPLIED\n+      onmouseup    %Script.datatype;        #IMPLIED\n+      onmouseover  %Script.datatype;        #IMPLIED\n+      onmousemove  %Script.datatype;        #IMPLIED\n+      onmouseout   %Script.datatype;        #IMPLIED\n+      onkeypress   %Script.datatype;        #IMPLIED\n+      onkeydown    %Script.datatype;        #IMPLIED\n+      onkeyup      %Script.datatype;        #IMPLIED\"\n+>\n+\n+<![%XHTML.global.attrs.prefixed;[\n+<!ENTITY % XHTML.global.events.attrib\n+     \"%XHTML.prefix;:onclick      %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:ondblclick   %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onmousedown  %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onmouseup    %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onmouseover  %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onmousemove  %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onmouseout   %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onkeypress   %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onkeydown    %Script.datatype;        #IMPLIED\n+      %XHTML.prefix;:onkeyup      %Script.datatype;        #IMPLIED\"\n+>\n+]]>\n+\n+<!-- additional attributes on anchor element\n+-->\n+<!ATTLIST %a.qname;\n+     onfocus      %Script.datatype;         #IMPLIED\n+     onblur       %Script.datatype;         #IMPLIED\n+>\n+\n+<!-- additional attributes on form element\n+-->\n+<!ATTLIST %form.qname;\n+      onsubmit     %Script.datatype;        #IMPLIED\n+      onreset      %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- additional attributes on label element\n+-->\n+<!ATTLIST %label.qname;\n+      onfocus      %Script.datatype;        #IMPLIED\n+      onblur       %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- additional attributes on input element\n+-->\n+<!ATTLIST %input.qname;\n+      onfocus      %Script.datatype;        #IMPLIED\n+      onblur       %Script.datatype;        #IMPLIED\n+      onselect     %Script.datatype;        #IMPLIED\n+      onchange     %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- additional attributes on select element\n+-->\n+<!ATTLIST %select.qname;\n+      onfocus      %Script.datatype;        #IMPLIED\n+      onblur       %Script.datatype;        #IMPLIED\n+      onchange     %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- additional attributes on textarea element\n+-->\n+<!ATTLIST %textarea.qname;\n+      onfocus      %Script.datatype;        #IMPLIED\n+      onblur       %Script.datatype;        #IMPLIED\n+      onselect     %Script.datatype;        #IMPLIED\n+      onchange     %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- additional attributes on button element\n+-->\n+<!ATTLIST %button.qname;\n+      onfocus      %Script.datatype;        #IMPLIED\n+      onblur       %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- additional attributes on body element\n+-->\n+<!ATTLIST %body.qname;\n+      onload       %Script.datatype;        #IMPLIED\n+      onunload     %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- additional attributes on area element\n+-->\n+<!ATTLIST %area.qname;\n+      onfocus      %Script.datatype;        #IMPLIED\n+      onblur       %Script.datatype;        #IMPLIED\n+>\n+\n+<!-- end of xhtml-events-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-events-1.mod","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,292 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Forms Module  .................................................. -->\n+<!-- file: xhtml-form-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-form-1.mod,v 4.1 2001\/04\/10 09:42:30 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Forms 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-form-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Forms\n+\n+        form, label, input, select, optgroup, option,\n+        textarea, fieldset, legend, button\n+\n+     This module declares markup to provide support for online\n+     forms, based on the features found in HTML 4 forms.\n+-->\n+\n+<!-- declare qualified element type names:\n+-->\n+<!ENTITY % form.qname  \"form\" >\n+<!ENTITY % label.qname  \"label\" >\n+<!ENTITY % input.qname  \"input\" >\n+<!ENTITY % select.qname  \"select\" >\n+<!ENTITY % optgroup.qname  \"optgroup\" >\n+<!ENTITY % option.qname  \"option\" >\n+<!ENTITY % textarea.qname  \"textarea\" >\n+<!ENTITY % fieldset.qname  \"fieldset\" >\n+<!ENTITY % legend.qname  \"legend\" >\n+<!ENTITY % button.qname  \"button\" >\n+\n+<!-- %BlkNoForm.mix; includes all non-form block elements,\n+     plus %Misc.class;\n+-->\n+<!ENTITY % BlkNoForm.mix\n+     \"%Heading.class;\n+      | %List.class;\n+      | %BlkStruct.class;\n+      %BlkPhras.class;\n+      %BlkPres.class;\n+      %Table.class;\n+      %Block.extra;\n+      %Misc.class;\"\n+>\n+\n+<!-- form: Form Element ................................ -->\n+\n+<!ENTITY % form.element  \"INCLUDE\" >\n+<![%form.element;[\n+<!ENTITY % form.content\n+     \"( %BlkNoForm.mix;\n+      | %fieldset.qname; )+\"\n+>\n+<!ELEMENT %form.qname;  %form.content; >\n+<!-- end of form.element -->]]>\n+\n+<!ENTITY % form.attlist  \"INCLUDE\" >\n+<![%form.attlist;[\n+<!ATTLIST %form.qname;\n+      %Common.attrib;\n+      action       %URI.datatype;           #REQUIRED\n+      method       ( get | post )           'get'\n+      name         CDATA                    #IMPLIED\n+      enctype      %ContentType.datatype;   'application\/x-www-form-urlencoded'\n+      accept-charset %Charsets.datatype;    #IMPLIED\n+      accept       %ContentTypes.datatype;  #IMPLIED\n+>\n+<!-- end of form.attlist -->]]>\n+\n+<!-- label: Form Field Label Text ...................... -->\n+\n+<!-- Each label must not contain more than ONE field\n+-->\n+\n+<!ENTITY % label.element  \"INCLUDE\" >\n+<![%label.element;[\n+<!ENTITY % label.content\n+     \"( #PCDATA\n+      | %input.qname; | %select.qname; | %textarea.qname; | %button.qname;\n+      | %InlStruct.class;\n+      %InlPhras.class;\n+      %I18n.class;\n+      %InlPres.class;\n+      %Anchor.class;\n+      %InlSpecial.class;\n+      %Inline.extra;\n+      %Misc.class; )*\"\n+>\n+<!ELEMENT %label.qname;  %label.content; >\n+<!-- end of label.element -->]]>\n+\n+<!ENTITY % label.attlist  \"INCLUDE\" >\n+<![%label.attlist;[\n+<!ATTLIST %label.qname;\n+      %Common.attrib;\n+      for          IDREF                    #IMPLIED\n+      accesskey    %Character.datatype;     #IMPLIED\n+>\n+<!-- end of label.attlist -->]]>\n+\n+<!-- input: Form Control ............................... -->\n+\n+<!ENTITY % input.element  \"INCLUDE\" >\n+<![%input.element;[\n+<!ENTITY % input.content  \"EMPTY\" >\n+<!ELEMENT %input.qname;  %input.content; >\n+<!-- end of input.element -->]]>\n+\n+<!ENTITY % input.attlist  \"INCLUDE\" >\n+<![%input.attlist;[\n+<!ENTITY % InputType.class\n+     \"( text | password | checkbox | radio | submit\n+      | reset | file | hidden | image | button )\"\n+>\n+<!-- attribute 'name' required for all but submit & reset\n+-->\n+<!ATTLIST %input.qname;\n+      %Common.attrib;\n+      type         %InputType.class;        'text'\n+      name         CDATA                    #IMPLIED\n+      value        CDATA                    #IMPLIED\n+      checked      ( checked )              #IMPLIED\n+      disabled     ( disabled )             #IMPLIED\n+      readonly     ( readonly )             #IMPLIED\n+      size         %Number.datatype;        #IMPLIED\n+      maxlength    %Number.datatype;        #IMPLIED\n+      src          %URI.datatype;           #IMPLIED\n+      alt          %Text.datatype;          #IMPLIED\n+      tabindex     %Number.datatype;        #IMPLIED\n+      accesskey    %Character.datatype;     #IMPLIED\n+      accept       %ContentTypes.datatype;  #IMPLIED\n+>\n+<!-- end of input.attlist -->]]>\n+\n+<!-- select: Option Selector ........................... -->\n+\n+<!ENTITY % select.element  \"INCLUDE\" >\n+<![%select.element;[\n+<!ENTITY % select.content\n+     \"( %optgroup.qname; | %option.qname; )+\"\n+>\n+<!ELEMENT %select.qname;  %select.content; >\n+<!-- end of select.element -->]]>\n+\n+<!ENTITY % select.attlist  \"INCLUDE\" >\n+<![%select.attlist;[\n+<!ATTLIST %select.qname;\n+      %Common.attrib;\n+      name         CDATA                    #IMPLIED\n+      size         %Number.datatype;        #IMPLIED\n+      multiple     ( multiple )             #IMPLIED\n+      disabled     ( disabled )             #IMPLIED\n+      tabindex     %Number.datatype;        #IMPLIED\n+>\n+<!-- end of select.attlist -->]]>\n+\n+<!-- optgroup: Option Group ............................ -->\n+\n+<!ENTITY % optgroup.element  \"INCLUDE\" >\n+<![%optgroup.element;[\n+<!ENTITY % optgroup.content  \"( %option.qname; )+\" >\n+<!ELEMENT %optgroup.qname;  %optgroup.content; >\n+<!-- end of optgroup.element -->]]>\n+\n+<!ENTITY % optgroup.attlist  \"INCLUDE\" >\n+<![%optgroup.attlist;[\n+<!ATTLIST %optgroup.qname;\n+      %Common.attrib;\n+      disabled     ( disabled )             #IMPLIED\n+      label        %Text.datatype;          #REQUIRED\n+>\n+<!-- end of optgroup.attlist -->]]>\n+\n+<!-- option: Selectable Choice ......................... -->\n+\n+<!ENTITY % option.element  \"INCLUDE\" >\n+<![%option.element;[\n+<!ENTITY % option.content  \"( #PCDATA )\" >\n+<!ELEMENT %option.qname;  %option.content; >\n+<!-- end of option.element -->]]>\n+\n+<!ENTITY % option.attlist  \"INCLUDE\" >\n+<![%option.attlist;[\n+<!ATTLIST %option.qname;\n+      %Common.attrib;\n+      selected     ( selected )             #IMPLIED\n+      disabled     ( disabled )             #IMPLIED\n+      label        %Text.datatype;          #IMPLIED\n+      value        CDATA                    #IMPLIED\n+>\n+<!-- end of option.attlist -->]]>\n+\n+<!-- textarea: Multi-Line Text Field ................... -->\n+\n+<!ENTITY % textarea.element  \"INCLUDE\" >\n+<![%textarea.element;[\n+<!ENTITY % textarea.content  \"( #PCDATA )\" >\n+<!ELEMENT %textarea.qname;  %textarea.content; >\n+<!-- end of textarea.element -->]]>\n+\n+<!ENTITY % textarea.attlist  \"INCLUDE\" >\n+<![%textarea.attlist;[\n+<!ATTLIST %textarea.qname;\n+      %Common.attrib;\n+      name         CDATA                    #IMPLIED\n+      rows         %Number.datatype;        #REQUIRED\n+      cols         %Number.datatype;        #REQUIRED\n+      disabled     ( disabled )             #IMPLIED\n+      readonly     ( readonly )             #IMPLIED\n+      tabindex     %Number.datatype;        #IMPLIED\n+      accesskey    %Character.datatype;     #IMPLIED\n+>\n+<!-- end of textarea.attlist -->]]>\n+\n+<!-- fieldset: Form Control Group ...................... -->\n+\n+<!-- #PCDATA is to solve the mixed content problem,\n+     per specification only whitespace is allowed\n+-->\n+\n+<!ENTITY % fieldset.element  \"INCLUDE\" >\n+<![%fieldset.element;[\n+<!ENTITY % fieldset.content\n+     \"( #PCDATA | %legend.qname; | %Flow.mix; )*\"\n+>\n+<!ELEMENT %fieldset.qname;  %fieldset.content; >\n+<!-- end of fieldset.element -->]]>\n+\n+<!ENTITY % fieldset.attlist  \"INCLUDE\" >\n+<![%fieldset.attlist;[\n+<!ATTLIST %fieldset.qname;\n+      %Common.attrib;\n+>\n+<!-- end of fieldset.attlist -->]]>\n+\n+<!-- legend: Fieldset Legend ........................... -->\n+\n+<!ENTITY % legend.element  \"INCLUDE\" >\n+<![%legend.element;[\n+<!ENTITY % legend.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ELEMENT %legend.qname;  %legend.content; >\n+<!-- end of legend.element -->]]>\n+\n+<!ENTITY % legend.attlist  \"INCLUDE\" >\n+<![%legend.attlist;[\n+<!ATTLIST %legend.qname;\n+      %Common.attrib;\n+      accesskey    %Character.datatype;     #IMPLIED\n+>\n+<!-- end of legend.attlist -->]]>\n+\n+<!-- button: Push Button ............................... -->\n+\n+<!ENTITY % button.element  \"INCLUDE\" >\n+<![%button.element;[\n+<!ENTITY % button.content\n+     \"( #PCDATA\n+      | %BlkNoForm.mix;\n+      | %InlStruct.class;\n+      %InlPhras.class;\n+      %InlPres.class;\n+      %I18n.class;\n+      %InlSpecial.class;\n+      %Inline.extra; )*\"\n+>\n+<!ELEMENT %button.qname;  %button.content; >\n+<!-- end of button.element -->]]>\n+\n+<!ENTITY % button.attlist  \"INCLUDE\" >\n+<![%button.attlist;[\n+<!ATTLIST %button.qname;\n+      %Common.attrib;\n+      name         CDATA                    #IMPLIED\n+      value        CDATA                    #IMPLIED\n+      type         ( button | submit | reset ) 'submit'\n+      disabled     ( disabled )             #IMPLIED\n+      tabindex     %Number.datatype;        #IMPLIED\n+      accesskey    %Character.datatype;     #IMPLIED\n+>\n+<!-- end of button.attlist -->]]>\n+\n+<!-- end of xhtml-form-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-form-1.mod","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Modular Framework Module  ...................................... -->\n+<!-- file: xhtml-framework-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-framework-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Modular Framework 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-framework-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Modular Framework\n+\n+     This required module instantiates the modules needed\n+     to support the XHTML modularization model, including:\n+\n+        +  datatypes\n+        +  namespace-qualified names\n+        +  common attributes\n+        +  document model\n+        +  character entities\n+\n+     The Intrinsic Events module is ignored by default but\n+     occurs in this module because it must be instantiated\n+     prior to Attributes but after Datatypes.\n+-->\n+\n+<!ENTITY % xhtml-arch.module \"IGNORE\" >\n+<![%xhtml-arch.module;[\n+<!ENTITY % xhtml-arch.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Base Architecture 1.0\/\/EN\"\n+            \"xhtml-arch-1.mod\" >\n+%xhtml-arch.mod;]]>\n+\n+<!ENTITY % xhtml-notations.module \"IGNORE\" >\n+<![%xhtml-notations.module;[\n+<!ENTITY % xhtml-notations.mod\n+     PUBLIC \"-\/\/W3C\/\/NOTATIONS XHTML Notations 1.0\/\/EN\"\n+            \"xhtml-notations-1.mod\" >\n+%xhtml-notations.mod;]]>\n+\n+<!ENTITY % xhtml-datatypes.module \"INCLUDE\" >\n+<![%xhtml-datatypes.module;[\n+<!ENTITY % xhtml-datatypes.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Datatypes 1.0\/\/EN\"\n+            \"xhtml-datatypes-1.mod\" >\n+%xhtml-datatypes.mod;]]>\n+\n+<!-- placeholder for XLink support module -->\n+<!ENTITY % xhtml-xlink.mod \"\" >\n+%xhtml-xlink.mod;\n+\n+<!ENTITY % xhtml-qname.module \"INCLUDE\" >\n+<![%xhtml-qname.module;[\n+<!ENTITY % xhtml-qname.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Qualified Names 1.0\/\/EN\"\n+            \"xhtml-qname-1.mod\" >\n+%xhtml-qname.mod;]]>\n+\n+<!ENTITY % xhtml-events.module \"IGNORE\" >\n+<![%xhtml-events.module;[\n+<!ENTITY % xhtml-events.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Intrinsic Events 1.0\/\/EN\"\n+            \"xhtml-events-1.mod\" >\n+%xhtml-events.mod;]]>\n+\n+<!ENTITY % xhtml-attribs.module \"INCLUDE\" >\n+<![%xhtml-attribs.module;[\n+<!ENTITY % xhtml-attribs.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Common Attributes 1.0\/\/EN\"\n+            \"xhtml-attribs-1.mod\" >\n+%xhtml-attribs.mod;]]>\n+\n+<!-- placeholder for content model redeclarations -->\n+<!ENTITY % xhtml-model.redecl \"\" >\n+%xhtml-model.redecl;\n+\n+<!ENTITY % xhtml-model.module \"INCLUDE\" >\n+<![%xhtml-model.module;[\n+<!-- instantiate the Document Model module declared in the DTD driver\n+-->\n+%xhtml-model.mod;]]>\n+\n+<!ENTITY % xhtml-charent.module \"INCLUDE\" >\n+<![%xhtml-charent.module;[\n+<!ENTITY % xhtml-charent.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Character Entities 1.0\/\/EN\"\n+            \"xhtml-charent-1.mod\" >\n+%xhtml-charent.mod;]]>\n+\n+<!-- end of xhtml-framework-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-framework-1.mod","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Hypertext Module  .............................................. -->\n+<!-- file: xhtml-hypertext-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-hypertext-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Hypertext 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-hypertext-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Hypertext\n+\n+        a\n+\n+     This module declares the anchor ('a') element type, which\n+     defines the source of a hypertext link. The destination\n+     (or link 'target') is identified via its 'id' attribute\n+     rather than the 'name' attribute as was used in HTML.\n+-->\n+\n+<!-- ............  Anchor Element  ............ -->\n+\n+<!ENTITY % a.element  \"INCLUDE\" >\n+<![%a.element;[\n+<!ENTITY % a.content\n+     \"( #PCDATA | %InlNoAnchor.mix; )*\"\n+>\n+<!ENTITY % a.qname  \"a\" >\n+<!ELEMENT %a.qname;  %a.content; >\n+<!-- end of a.element -->]]>\n+\n+<!ENTITY % a.attlist  \"INCLUDE\" >\n+<![%a.attlist;[\n+<!ATTLIST %a.qname;\n+      %Common.attrib;\n+      href         %URI.datatype;           #IMPLIED\n+      charset      %Charset.datatype;       #IMPLIED\n+      type         %ContentType.datatype;   #IMPLIED\n+      hreflang     %LanguageCode.datatype;  #IMPLIED\n+      rel          %LinkTypes.datatype;     #IMPLIED\n+      rev          %LinkTypes.datatype;     #IMPLIED\n+      accesskey    %Character.datatype;     #IMPLIED\n+      tabindex     %Number.datatype;        #IMPLIED\n+>\n+<!-- end of a.attlist -->]]>\n+\n+<!-- end of xhtml-hypertext-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-hypertext-1.mod","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Images Module  ................................................. -->\n+<!-- file: xhtml-image-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Rovision: $Id: xhtml-image-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Images 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-image-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Images\n+\n+        img\n+\n+     This module provides markup to support basic image embedding.\n+-->\n+\n+<!-- To avoid problems with text-only UAs as well as to make\n+     image content understandable and navigable to users of\n+     non-visual UAs, you need to provide a description with\n+     the 'alt' attribute, and avoid server-side image maps.\n+-->\n+\n+<!ENTITY % img.element  \"INCLUDE\" >\n+<![%img.element;[\n+<!ENTITY % img.content  \"EMPTY\" >\n+<!ENTITY % img.qname  \"img\" >\n+<!ELEMENT %img.qname;  %img.content; >\n+<!-- end of img.element -->]]>\n+\n+<!ENTITY % img.attlist  \"INCLUDE\" >\n+<![%img.attlist;[\n+<!ATTLIST %img.qname;\n+      %Common.attrib;\n+      src          %URI.datatype;           #REQUIRED\n+      alt          %Text.datatype;          #REQUIRED\n+      longdesc     %URI.datatype;           #IMPLIED\n+      name         CDATA                    #IMPLIED\n+      height       %Length.datatype;        #IMPLIED\n+      width        %Length.datatype;        #IMPLIED\n+>\n+<!-- end of img.attlist -->]]>\n+\n+<!-- end of xhtml-image-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-image-1.mod","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Inline Phrasal Module  ......................................... -->\n+<!-- file: xhtml-inlphras-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-inlphras-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Phrasal 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-inlphras-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Inline Phrasal\n+\n+        abbr, acronym, cite, code, dfn, em, kbd, q, samp, strong, var\n+\n+     This module declares the elements and their attributes used to\n+     support inline-level phrasal markup.\n+-->\n+\n+<!ENTITY % abbr.element  \"INCLUDE\" >\n+<![%abbr.element;[\n+<!ENTITY % abbr.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % abbr.qname  \"abbr\" >\n+<!ELEMENT %abbr.qname;  %abbr.content; >\n+<!-- end of abbr.element -->]]>\n+\n+<!ENTITY % abbr.attlist  \"INCLUDE\" >\n+<![%abbr.attlist;[\n+<!ATTLIST %abbr.qname;\n+      %Common.attrib;\n+>\n+<!-- end of abbr.attlist -->]]>\n+\n+<!ENTITY % acronym.element  \"INCLUDE\" >\n+<![%acronym.element;[\n+<!ENTITY % acronym.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % acronym.qname  \"acronym\" >\n+<!ELEMENT %acronym.qname;  %acronym.content; >\n+<!-- end of acronym.element -->]]>\n+\n+<!ENTITY % acronym.attlist  \"INCLUDE\" >\n+<![%acronym.attlist;[\n+<!ATTLIST %acronym.qname;\n+      %Common.attrib;\n+>\n+<!-- end of acronym.attlist -->]]>\n+\n+<!ENTITY % cite.element  \"INCLUDE\" >\n+<![%cite.element;[\n+<!ENTITY % cite.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % cite.qname  \"cite\" >\n+<!ELEMENT %cite.qname;  %cite.content; >\n+<!-- end of cite.element -->]]>\n+\n+<!ENTITY % cite.attlist  \"INCLUDE\" >\n+<![%cite.attlist;[\n+<!ATTLIST %cite.qname;\n+      %Common.attrib;\n+>\n+<!-- end of cite.attlist -->]]>\n+\n+<!ENTITY % code.element  \"INCLUDE\" >\n+<![%code.element;[\n+<!ENTITY % code.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % code.qname  \"code\" >\n+<!ELEMENT %code.qname;  %code.content; >\n+<!-- end of code.element -->]]>\n+\n+<!ENTITY % code.attlist  \"INCLUDE\" >\n+<![%code.attlist;[\n+<!ATTLIST %code.qname;\n+      %Common.attrib;\n+>\n+<!-- end of code.attlist -->]]>\n+\n+<!ENTITY % dfn.element  \"INCLUDE\" >\n+<![%dfn.element;[\n+<!ENTITY % dfn.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % dfn.qname  \"dfn\" >\n+<!ELEMENT %dfn.qname;  %dfn.content; >\n+<!-- end of dfn.element -->]]>\n+\n+<!ENTITY % dfn.attlist  \"INCLUDE\" >\n+<![%dfn.attlist;[\n+<!ATTLIST %dfn.qname;\n+      %Common.attrib;\n+>\n+<!-- end of dfn.attlist -->]]>\n+\n+<!ENTITY % em.element  \"INCLUDE\" >\n+<![%em.element;[\n+<!ENTITY % em.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % em.qname  \"em\" >\n+<!ELEMENT %em.qname;  %em.content; >\n+<!-- end of em.element -->]]>\n+\n+<!ENTITY % em.attlist  \"INCLUDE\" >\n+<![%em.attlist;[\n+<!ATTLIST %em.qname;\n+      %Common.attrib;\n+>\n+<!-- end of em.attlist -->]]>\n+\n+<!ENTITY % kbd.element  \"INCLUDE\" >\n+<![%kbd.element;[\n+<!ENTITY % kbd.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % kbd.qname  \"kbd\" >\n+<!ELEMENT %kbd.qname;  %kbd.content; >\n+<!-- end of kbd.element -->]]>\n+\n+<!ENTITY % kbd.attlist  \"INCLUDE\" >\n+<![%kbd.attlist;[\n+<!ATTLIST %kbd.qname;\n+      %Common.attrib;\n+>\n+<!-- end of kbd.attlist -->]]>\n+\n+<!ENTITY % q.element  \"INCLUDE\" >\n+<![%q.element;[\n+<!ENTITY % q.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % q.qname  \"q\" >\n+<!ELEMENT %q.qname;  %q.content; >\n+<!-- end of q.element -->]]>\n+\n+<!ENTITY % q.attlist  \"INCLUDE\" >\n+<![%q.attlist;[\n+<!ATTLIST %q.qname;\n+      %Common.attrib;\n+      cite         %URI.datatype;           #IMPLIED\n+>\n+<!-- end of q.attlist -->]]>\n+\n+<!ENTITY % samp.element  \"INCLUDE\" >\n+<![%samp.element;[\n+<!ENTITY % samp.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % samp.qname  \"samp\" >\n+<!ELEMENT %samp.qname;  %samp.content; >\n+<!-- end of samp.element -->]]>\n+\n+<!ENTITY % samp.attlist  \"INCLUDE\" >\n+<![%samp.attlist;[\n+<!ATTLIST %samp.qname;\n+      %Common.attrib;\n+>\n+<!-- end of samp.attlist -->]]>\n+\n+<!ENTITY % strong.element  \"INCLUDE\" >\n+<![%strong.element;[\n+<!ENTITY % strong.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % strong.qname  \"strong\" >\n+<!ELEMENT %strong.qname;  %strong.content; >\n+<!-- end of strong.element -->]]>\n+\n+<!ENTITY % strong.attlist  \"INCLUDE\" >\n+<![%strong.attlist;[\n+<!ATTLIST %strong.qname;\n+      %Common.attrib;\n+>\n+<!-- end of strong.attlist -->]]>\n+\n+<!ENTITY % var.element  \"INCLUDE\" >\n+<![%var.element;[\n+<!ENTITY % var.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % var.qname  \"var\" >\n+<!ELEMENT %var.qname;  %var.content; >\n+<!-- end of var.element -->]]>\n+\n+<!ENTITY % var.attlist  \"INCLUDE\" >\n+<![%var.attlist;[\n+<!ATTLIST %var.qname;\n+      %Common.attrib;\n+>\n+<!-- end of var.attlist -->]]>\n+\n+<!-- end of xhtml-inlphras-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-inlphras-1.mod","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Inline Presentation Module  .................................... -->\n+<!-- file: xhtml-inlpres-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-inlpres-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Presentation 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-inlpres-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Inline Presentational Elements\n+\n+        b, big, i, small, sub, sup, tt\n+\n+     This module declares the elements and their attributes used to\n+     support inline-level presentational markup.\n+-->\n+\n+<!ENTITY % b.element  \"INCLUDE\" >\n+<![%b.element;[\n+<!ENTITY % b.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % b.qname  \"b\" >\n+<!ELEMENT %b.qname;  %b.content; >\n+<!-- end of b.element -->]]>\n+\n+<!ENTITY % b.attlist  \"INCLUDE\" >\n+<![%b.attlist;[\n+<!ATTLIST %b.qname;\n+      %Common.attrib;\n+>\n+<!-- end of b.attlist -->]]>\n+\n+<!ENTITY % big.element  \"INCLUDE\" >\n+<![%big.element;[\n+<!ENTITY % big.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % big.qname  \"big\" >\n+<!ELEMENT %big.qname;  %big.content; >\n+<!-- end of big.element -->]]>\n+\n+<!ENTITY % big.attlist  \"INCLUDE\" >\n+<![%big.attlist;[\n+<!ATTLIST %big.qname;\n+      %Common.attrib;\n+>\n+<!-- end of big.attlist -->]]>\n+\n+<!ENTITY % i.element  \"INCLUDE\" >\n+<![%i.element;[\n+<!ENTITY % i.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % i.qname  \"i\" >\n+<!ELEMENT %i.qname;  %i.content; >\n+<!-- end of i.element -->]]>\n+\n+<!ENTITY % i.attlist  \"INCLUDE\" >\n+<![%i.attlist;[\n+<!ATTLIST %i.qname;\n+      %Common.attrib;\n+>\n+<!-- end of i.attlist -->]]>\n+\n+<!ENTITY % small.element  \"INCLUDE\" >\n+<![%small.element;[\n+<!ENTITY % small.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % small.qname  \"small\" >\n+<!ELEMENT %small.qname;  %small.content; >\n+<!-- end of small.element -->]]>\n+\n+<!ENTITY % small.attlist  \"INCLUDE\" >\n+<![%small.attlist;[\n+<!ATTLIST %small.qname;\n+      %Common.attrib;\n+>\n+<!-- end of small.attlist -->]]>\n+\n+<!ENTITY % sub.element  \"INCLUDE\" >\n+<![%sub.element;[\n+<!ENTITY % sub.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % sub.qname  \"sub\" >\n+<!ELEMENT %sub.qname;  %sub.content; >\n+<!-- end of sub.element -->]]>\n+\n+<!ENTITY % sub.attlist  \"INCLUDE\" >\n+<![%sub.attlist;[\n+<!ATTLIST %sub.qname;\n+      %Common.attrib;\n+>\n+<!-- end of sub.attlist -->]]>\n+\n+<!ENTITY % sup.element  \"INCLUDE\" >\n+<![%sup.element;[\n+<!ENTITY % sup.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % sup.qname  \"sup\" >\n+<!ELEMENT %sup.qname;  %sup.content; >\n+<!-- end of sup.element -->]]>\n+\n+<!ENTITY % sup.attlist  \"INCLUDE\" >\n+<![%sup.attlist;[\n+<!ATTLIST %sup.qname;\n+      %Common.attrib;\n+>\n+<!-- end of sup.attlist -->]]>\n+\n+<!ENTITY % tt.element  \"INCLUDE\" >\n+<![%tt.element;[\n+<!ENTITY % tt.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % tt.qname  \"tt\" >\n+<!ELEMENT %tt.qname;  %tt.content; >\n+<!-- end of tt.element -->]]>\n+\n+<!ENTITY % tt.attlist  \"INCLUDE\" >\n+<![%tt.attlist;[\n+<!ATTLIST %tt.qname;\n+      %Common.attrib;\n+>\n+<!-- end of tt.attlist -->]]>\n+\n+<!-- end of xhtml-inlpres-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-inlpres-1.mod","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Inline Structural Module  ...................................... -->\n+<!-- file: xhtml-inlstruct-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-inlstruct-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Structural 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-inlstruct-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Inline Structural\n+\n+        br, span\n+\n+     This module declares the elements and their attributes\n+     used to support inline-level structural markup.\n+-->\n+\n+<!-- br: forced line break ............................. -->\n+\n+<!ENTITY % br.element  \"INCLUDE\" >\n+<![%br.element;[\n+\n+<!ENTITY % br.content  \"EMPTY\" >\n+<!ENTITY % br.qname  \"br\" >\n+<!ELEMENT %br.qname;  %br.content; >\n+\n+<!-- end of br.element -->]]>\n+\n+<!ENTITY % br.attlist  \"INCLUDE\" >\n+<![%br.attlist;[\n+<!ATTLIST %br.qname;\n+      %Core.attrib;\n+>\n+<!-- end of br.attlist -->]]>\n+\n+<!-- span: generic inline container .................... -->\n+\n+<!ENTITY % span.element  \"INCLUDE\" >\n+<![%span.element;[\n+<!ENTITY % span.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % span.qname  \"span\" >\n+<!ELEMENT %span.qname;  %span.content; >\n+<!-- end of span.element -->]]>\n+\n+<!ENTITY % span.attlist  \"INCLUDE\" >\n+<![%span.attlist;[\n+<!ATTLIST %span.qname;\n+      %Common.attrib;\n+>\n+<!-- end of span.attlist -->]]>\n+\n+<!-- end of xhtml-inlstruct-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-inlstruct-1.mod","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Inline Style Module  ........................................... -->\n+<!-- file: xhtml-inlstyle-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-inlstyle-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Inline Style 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-inlstyle-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Inline Style\n+\n+     This module declares the 'style' attribute, used to support inline\n+     style markup. This module must be instantiated prior to the XHTML\n+     Common Attributes module in order to be included in %Core.attrib;.\n+-->\n+\n+<!ENTITY % style.attrib\n+     \"style        CDATA                    #IMPLIED\"\n+>\n+\n+\n+<!ENTITY % Core.extra.attrib\n+     \"%style.attrib;\"\n+>\n+\n+<!-- end of xhtml-inlstyle-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-inlstyle-1.mod","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,400 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Legacy Markup Module ........................................... -->\n+<!-- file: xhtml-legacy-1.mod\n+\n+     This is an extension of XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-legacy-1.mod,v 4.1 2001\/04\/10 09:42:30 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Legacy Markup 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-legacy-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- HTML Legacy Markup\n+\n+        font, basefont, center, s, strike, u, dir, menu, isindex\n+\n+          (plus additional datatypes and attributes)\n+\n+     This optional module declares additional markup for simple\n+     presentation-related markup based on features found in the\n+     HTML 4 Transitional and Frameset DTDs. This relies on\n+     inclusion of the Legacy Redeclarations module. This module\n+     also declares the frames, inline frames and object modules.\n+\n+     This is to allow XHTML 1.1 documents to be transformed for\n+     display on HTML browsers where CSS support is inconsistent\n+     or unavailable.\n+-->\n+<!-- Constructing a Legacy DTD\n+\n+     To construct a DTD driver obtaining a close approximation\n+     of the HTML 4 Transitional and Frameset DTDs, declare the\n+     Legacy Redeclarations module as the pre-framework redeclaration\n+     parameter entity (%xhtml-prefw-redecl.mod;) and INCLUDE its\n+     conditional section:\n+\n+        ...\n+        <!ENTITY % xhtml-prefw-redecl.module \"INCLUDE\" >\n+        <![%xhtml-prefw-redecl.module;[\n+        <!ENTITY % xhtml-prefw-redecl.mod\n+            PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Legacy Redeclarations 1.0\/\/EN\"\n+                   \"xhtml-legacy-redecl-1.mod\" >\n+        %xhtml-prefw-redecl.mod;]]>\n+\n+     Such a DTD should be named with a variant FPI and redeclare\n+     the value of the %XHTML.version; parameter entity to that FPI:\n+\n+         \"-\/\/Your Name Here\/\/DTD XHTML Legacy 1.1\/\/EN\"\n+\n+     IMPORTANT:  see also the notes included in the Legacy Redeclarations\n+     Module for information on how to construct a DTD using this module.\n+-->\n+\n+\n+<!-- Additional Element Types .................................... -->\n+\n+<!-- font: Local Font Modifier  ........................ -->\n+\n+<!ENTITY % font.element  \"INCLUDE\" >\n+<![%font.element;[\n+<!ENTITY % font.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % font.qname  \"font\" >\n+<!ELEMENT %font.qname;  %font.content; >\n+<!-- end of font.element -->]]>\n+\n+<!ENTITY % font.attlist  \"INCLUDE\" >\n+<![%font.attlist;[\n+<!ATTLIST %font.qname;\n+      %Core.attrib;\n+      %I18n.attrib;\n+      size         CDATA                    #IMPLIED\n+      color        %Color.datatype;         #IMPLIED\n+      face         CDATA                    #IMPLIED\n+>\n+<!-- end of font.attlist -->]]>\n+\n+<!-- basefont: Base Font Size  ......................... -->\n+\n+<!ENTITY % basefont.element  \"INCLUDE\" >\n+<![%basefont.element;[\n+<!ENTITY % basefont.content \"EMPTY\" >\n+<!ENTITY % basefont.qname  \"basefont\" >\n+<!ELEMENT %basefont.qname;  %basefont.content; >\n+<!-- end of basefont.element -->]]>\n+\n+<!ENTITY % basefont.attlist  \"INCLUDE\" >\n+<![%basefont.attlist;[\n+<!ATTLIST %basefont.qname;\n+      %id.attrib;\n+      size         CDATA                    #REQUIRED\n+      color        %Color.datatype;         #IMPLIED\n+      face         CDATA                    #IMPLIED\n+>\n+<!-- end of basefont.attlist -->]]>\n+\n+<!-- center: Center Alignment  ......................... -->\n+\n+<!ENTITY % center.element  \"INCLUDE\" >\n+<![%center.element;[\n+<!ENTITY % center.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ENTITY % center.qname  \"center\" >\n+<!ELEMENT %center.qname;  %center.content; >\n+<!-- end of center.element -->]]>\n+\n+<!ENTITY % center.attlist  \"INCLUDE\" >\n+<![%center.attlist;[\n+<!ATTLIST %center.qname;\n+      %Common.attrib;\n+>\n+<!-- end of center.attlist -->]]>\n+\n+<!-- s: Strike-Thru Text Style  ........................ -->\n+\n+<!ENTITY % s.element  \"INCLUDE\" >\n+<![%s.element;[\n+<!ENTITY % s.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % s.qname  \"s\" >\n+<!ELEMENT %s.qname;  %s.content; >\n+<!-- end of s.element -->]]>\n+\n+<!ENTITY % s.attlist  \"INCLUDE\" >\n+<![%s.attlist;[\n+<!ATTLIST %s.qname;\n+      %Common.attrib;\n+>\n+<!-- end of s.attlist -->]]>\n+\n+<!-- strike: Strike-Thru Text Style  ....................-->\n+\n+<!ENTITY % strike.element  \"INCLUDE\" >\n+<![%strike.element;[\n+<!ENTITY % strike.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % strike.qname  \"strike\" >\n+<!ELEMENT %strike.qname;  %strike.content; >\n+<!-- end of strike.element -->]]>\n+\n+<!ENTITY % strike.attlist  \"INCLUDE\" >\n+<![%strike.attlist;[\n+<!ATTLIST %strike.qname;\n+      %Common.attrib;\n+>\n+<!-- end of strike.attlist -->]]>\n+\n+<!-- u: Underline Text Style  ...........................-->\n+\n+<!ENTITY % u.element  \"INCLUDE\" >\n+<![%u.element;[\n+<!ENTITY % u.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ENTITY % u.qname  \"u\" >\n+<!ELEMENT %u.qname;  %u.content; >\n+<!-- end of u.element -->]]>\n+\n+<!ENTITY % u.attlist  \"INCLUDE\" >\n+<![%u.attlist;[\n+<!ATTLIST %u.qname;\n+      %Common.attrib;\n+>\n+<!-- end of u.attlist -->]]>\n+\n+<!-- dir: Directory List  .............................. -->\n+\n+<!-- NOTE: the content model for <dir> in HTML 4 excluded %Block.mix;\n+-->\n+<!ENTITY % dir.element  \"INCLUDE\" >\n+<![%dir.element;[\n+<!ENTITY % dir.content\n+     \"( %li.qname; )+\"\n+>\n+<!ENTITY % dir.qname  \"dir\" >\n+<!ELEMENT %dir.qname;  %dir.content; >\n+<!-- end of dir.element -->]]>\n+\n+<!ENTITY % dir.attlist  \"INCLUDE\" >\n+<![%dir.attlist;[\n+<!ATTLIST %dir.qname;\n+      %Common.attrib;\n+      compact      ( compact )              #IMPLIED\n+>\n+<!-- end of dir.attlist -->]]>\n+\n+<!-- menu: Menu List  .................................. -->\n+\n+<!-- NOTE: the content model for <menu> in HTML 4 excluded %Block.mix;\n+-->\n+<!ENTITY % menu.element  \"INCLUDE\" >\n+<![%menu.element;[\n+<!ENTITY % menu.content\n+     \"( %li.qname; )+\"\n+>\n+<!ENTITY % menu.qname  \"menu\" >\n+<!ELEMENT %menu.qname;  %menu.content; >\n+<!-- end of menu.element -->]]>\n+\n+<!ENTITY % menu.attlist  \"INCLUDE\" >\n+<![%menu.attlist;[\n+<!ATTLIST %menu.qname;\n+      %Common.attrib;\n+      compact      ( compact )              #IMPLIED\n+>\n+<!-- end of menu.attlist -->]]>\n+\n+<!-- isindex: Single-Line Prompt  ...................... -->\n+\n+<!ENTITY % isindex.element  \"INCLUDE\" >\n+<![%isindex.element;[\n+<!ENTITY % isindex.content \"EMPTY\" >\n+<!ENTITY % isindex.qname  \"isindex\" >\n+<!ELEMENT %isindex.qname;  %isindex.content; >\n+<!-- end of isindex.element -->]]>\n+\n+<!ENTITY % isindex.attlist  \"INCLUDE\" >\n+<![%isindex.attlist;[\n+<!ATTLIST %isindex.qname;\n+      %Core.attrib;\n+      %I18n.attrib;\n+      prompt       %Text.datatype;          #IMPLIED\n+>\n+<!-- end of isindex.attlist -->]]>\n+\n+\n+<!-- Additional Attributes ....................................... -->\n+\n+<!-- Alignment attribute for Transitional use in HTML browsers\n+     (this functionality is generally well-supported in CSS,\n+     except within some contexts)\n+-->\n+<!ENTITY % align.attrib\n+     \"align        ( left | center | right | justify ) #IMPLIED\"\n+>\n+\n+<!ATTLIST %applet.qname;\n+      align       ( top | middle | bottom | left | right ) #IMPLIED\n+      hspace      %Pixels.datatype;         #IMPLIED\n+      vspace      %Pixels.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %body.qname;\n+      background   %URI.datatype;           #IMPLIED\n+      bgcolor      %Color.datatype;         #IMPLIED\n+      text         %Color.datatype;         #IMPLIED\n+      link         %Color.datatype;         #IMPLIED\n+      vlink        %Color.datatype;         #IMPLIED\n+      alink        %Color.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %br.qname;\n+      clear        ( left | all | right | none ) 'none'\n+>\n+\n+<!ATTLIST %caption.qname;\n+      align        ( top | bottom | left | right ) #IMPLIED\n+>\n+\n+<!ATTLIST %div.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %h1.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %h2.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %h3.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %h4.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %h5.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %h6.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %hr.qname;\n+      align        ( left | center | right ) #IMPLIED\n+      noshade      ( noshade )              #IMPLIED\n+      size         %Pixels.datatype;        #IMPLIED\n+      width        %Length.datatype;        #IMPLIED\n+>\n+\n+<!ATTLIST %img.qname;\n+      align       ( top | middle | bottom | left | right ) #IMPLIED\n+      border      %Pixels.datatype;         #IMPLIED\n+      hspace      %Pixels.datatype;         #IMPLIED\n+      vspace      %Pixels.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %input.qname;\n+      align       ( top | middle | bottom | left | right ) #IMPLIED\n+>\n+\n+<!ATTLIST %legend.qname;\n+      align        ( top | bottom | left | right ) #IMPLIED\n+>\n+\n+<!ATTLIST %li.qname;\n+      type         CDATA                     #IMPLIED\n+      value        %Number.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %object.qname;\n+      align        ( top | middle | bottom | left | right ) #IMPLIED\n+      border       %Pixels.datatype;         #IMPLIED\n+      hspace       %Pixels.datatype;         #IMPLIED\n+      vspace       %Pixels.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %dl.qname;\n+      compact      ( compact )              #IMPLIED\n+>\n+\n+<!ATTLIST %ol.qname;\n+      type         CDATA                    #IMPLIED\n+      compact      ( compact )              #IMPLIED\n+      start        %Number.datatype;        #IMPLIED\n+>\n+\n+<!ATTLIST %p.qname;\n+      %align.attrib;\n+>\n+\n+<!ATTLIST %pre.qname;\n+      width        %Length.datatype;        #IMPLIED\n+>\n+\n+<!ATTLIST %script.qname;\n+      language     %ContentType.datatype;   #IMPLIED\n+>\n+\n+<!ATTLIST %table.qname;\n+      align        ( left | center | right ) #IMPLIED\n+      bgcolor      %Color.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %tr.qname;\n+      bgcolor     %Color.datatype;          #IMPLIED\n+>\n+\n+<!ATTLIST %th.qname;\n+      nowrap      ( nowrap )                #IMPLIED\n+      bgcolor     %Color.datatype;          #IMPLIED\n+      width       %Length.datatype;         #IMPLIED\n+      height      %Length.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %td.qname;\n+      nowrap      ( nowrap )                #IMPLIED\n+      bgcolor     %Color.datatype;          #IMPLIED\n+      width       %Length.datatype;         #IMPLIED\n+      height      %Length.datatype;         #IMPLIED\n+>\n+\n+<!ATTLIST %ul.qname;\n+      type         CDATA                    #IMPLIED\n+      compact      ( compact )              #IMPLIED\n+>\n+\n+<!-- Frames Module ............................................... -->\n+<!ENTITY % xhtml-frames.module \"IGNORE\" >\n+<![%xhtml-frames.module;[\n+<!ENTITY % xhtml-frames.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Frames 1.0\/\/EN\"\n+            \"xhtml-frames-1.mod\" >\n+%xhtml-frames.mod;]]>\n+\n+<!-- Inline Frames Module ........................................ -->\n+<!ENTITY % xhtml-iframe.module \"INCLUDE\" >\n+<![%xhtml-iframe.module;[\n+<!ATTLIST %iframe.qname;\n+      align        ( top | middle | bottom | left | right ) #IMPLIED\n+>\n+<!ENTITY % xhtml-iframe.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Frame Element 1.0\/\/EN\"\n+            \"xhtml-iframe-1.mod\" >\n+%xhtml-iframe.mod;]]>\n+\n+<!-- end of xhtml-legacy-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-legacy-1.mod","additions":400,"deletions":0,"binary":false,"changes":400,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Link Element Module  ........................................... -->\n+<!-- file: xhtml-link-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-link-1.mod,v 4.1 2001\/04\/05 06:57:40 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Link Element 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-link-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Link element\n+\n+        link\n+\n+     This module declares the link element type and its attributes,\n+     which could (in principle) be used to define document-level links\n+     to external resources such as:\n+\n+     a) for document specific toolbars\/menus, e.g. start, contents,\n+        previous, next, index, end, help\n+     b) to link to a separate style sheet (rel=\"stylesheet\")\n+     c) to make a link to a script (rel=\"script\")\n+     d) by style sheets to control how collections of html nodes are\n+        rendered into printed documents\n+     e) to make a link to a printable version of this document\n+        e.g. a postscript or pdf version (rel=\"alternate\" media=\"print\")\n+-->\n+\n+<!-- link: Media-Independent Link ...................... -->\n+\n+<!ENTITY % link.element  \"INCLUDE\" >\n+<![%link.element;[\n+<!ENTITY % link.content  \"EMPTY\" >\n+<!ENTITY % link.qname  \"link\" >\n+<!ELEMENT %link.qname;  %link.content; >\n+<!-- end of link.element -->]]>\n+\n+<!ENTITY % link.attlist  \"INCLUDE\" >\n+<![%link.attlist;[\n+<!ATTLIST %link.qname;\n+      %Common.attrib;\n+      charset      %Charset.datatype;       #IMPLIED\n+      href         %URI.datatype;           #IMPLIED\n+      hreflang     %LanguageCode.datatype;  #IMPLIED\n+      type         %ContentType.datatype;   #IMPLIED\n+      rel          %LinkTypes.datatype;     #IMPLIED\n+      rev          %LinkTypes.datatype;     #IMPLIED\n+      media        %MediaDesc.datatype;     #IMPLIED\n+>\n+<!-- end of link.attlist -->]]>\n+\n+<!-- end of xhtml-link-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-link-1.mod","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Lists Module  .................................................. -->\n+<!-- file: xhtml-list-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-list-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Lists 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-list-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Lists\n+\n+        dl, dt, dd, ol, ul, li\n+\n+     This module declares the list-oriented element types\n+     and their attributes.\n+-->\n+\n+<!ENTITY % dl.qname  \"dl\" >\n+<!ENTITY % dt.qname  \"dt\" >\n+<!ENTITY % dd.qname  \"dd\" >\n+<!ENTITY % ol.qname  \"ol\" >\n+<!ENTITY % ul.qname  \"ul\" >\n+<!ENTITY % li.qname  \"li\" >\n+\n+<!-- dl: Definition List ............................... -->\n+\n+<!ENTITY % dl.element  \"INCLUDE\" >\n+<![%dl.element;[\n+<!ENTITY % dl.content  \"( %dt.qname; | %dd.qname; )+\" >\n+<!ELEMENT %dl.qname;  %dl.content; >\n+<!-- end of dl.element -->]]>\n+\n+<!ENTITY % dl.attlist  \"INCLUDE\" >\n+<![%dl.attlist;[\n+<!ATTLIST %dl.qname;\n+      %Common.attrib;\n+>\n+<!-- end of dl.attlist -->]]>\n+\n+<!-- dt: Definition Term ............................... -->\n+\n+<!ENTITY % dt.element  \"INCLUDE\" >\n+<![%dt.element;[\n+<!ENTITY % dt.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ELEMENT %dt.qname;  %dt.content; >\n+<!-- end of dt.element -->]]>\n+\n+<!ENTITY % dt.attlist  \"INCLUDE\" >\n+<![%dt.attlist;[\n+<!ATTLIST %dt.qname;\n+      %Common.attrib;\n+>\n+<!-- end of dt.attlist -->]]>\n+\n+<!-- dd: Definition Description ........................ -->\n+\n+<!ENTITY % dd.element  \"INCLUDE\" >\n+<![%dd.element;[\n+<!ENTITY % dd.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ELEMENT %dd.qname;  %dd.content; >\n+<!-- end of dd.element -->]]>\n+\n+<!ENTITY % dd.attlist  \"INCLUDE\" >\n+<![%dd.attlist;[\n+<!ATTLIST %dd.qname;\n+      %Common.attrib;\n+>\n+<!-- end of dd.attlist -->]]>\n+\n+<!-- ol: Ordered List (numbered styles) ................ -->\n+\n+<!ENTITY % ol.element  \"INCLUDE\" >\n+<![%ol.element;[\n+<!ENTITY % ol.content  \"( %li.qname; )+\" >\n+<!ELEMENT %ol.qname;  %ol.content; >\n+<!-- end of ol.element -->]]>\n+\n+<!ENTITY % ol.attlist  \"INCLUDE\" >\n+<![%ol.attlist;[\n+<!ATTLIST %ol.qname;\n+      %Common.attrib;\n+>\n+<!-- end of ol.attlist -->]]>\n+\n+<!-- ul: Unordered List (bullet styles) ................ -->\n+\n+<!ENTITY % ul.element  \"INCLUDE\" >\n+<![%ul.element;[\n+<!ENTITY % ul.content  \"( %li.qname; )+\" >\n+<!ELEMENT %ul.qname;  %ul.content; >\n+<!-- end of ul.element -->]]>\n+\n+<!ENTITY % ul.attlist  \"INCLUDE\" >\n+<![%ul.attlist;[\n+<!ATTLIST %ul.qname;\n+      %Common.attrib;\n+>\n+<!-- end of ul.attlist -->]]>\n+\n+<!-- li: List Item ..................................... -->\n+\n+<!ENTITY % li.element  \"INCLUDE\" >\n+<![%li.element;[\n+<!ENTITY % li.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ELEMENT %li.qname;  %li.content; >\n+<!-- end of li.element -->]]>\n+\n+<!ENTITY % li.attlist  \"INCLUDE\" >\n+<![%li.attlist;[\n+<!ATTLIST %li.qname;\n+      %Common.attrib;\n+>\n+<!-- end of li.attlist -->]]>\n+\n+<!-- end of xhtml-list-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-list-1.mod","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Document Metainformation Module  ............................... -->\n+<!-- file: xhtml-meta-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-meta-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Metainformation 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-meta-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Meta Information\n+\n+        meta\n+\n+     This module declares the meta element type and its attributes,\n+     used to provide declarative document metainformation.\n+-->\n+\n+<!-- meta: Generic Metainformation ..................... -->\n+\n+<!ENTITY % meta.element  \"INCLUDE\" >\n+<![%meta.element;[\n+<!ENTITY % meta.content  \"EMPTY\" >\n+<!ENTITY % meta.qname  \"meta\" >\n+<!ELEMENT %meta.qname;  %meta.content; >\n+<!-- end of meta.element -->]]>\n+\n+<!ENTITY % meta.attlist  \"INCLUDE\" >\n+<![%meta.attlist;[\n+<!ATTLIST %meta.qname;\n+      %XHTML.xmlns.attrib;\n+      %I18n.attrib;\n+      http-equiv   NMTOKEN                  #IMPLIED\n+      name         NMTOKEN                  #IMPLIED\n+      content      CDATA                    #REQUIRED\n+      scheme       CDATA                    #IMPLIED\n+>\n+<!-- end of meta.attlist -->]]>\n+\n+<!-- end of xhtml-meta-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-meta-1.mod","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Embedded Object Module  ........................................ -->\n+<!-- file: xhtml-object-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-object-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Embedded Object 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-object-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Embedded Objects\n+\n+        object\n+\n+     This module declares the object element type and its attributes, used\n+     to embed external objects as part of XHTML pages. In the document,\n+     place param elements prior to other content within the object element.\n+\n+     Note that use of this module requires instantiation of the Param\n+     Element Module.\n+-->\n+\n+<!-- object: Generic Embedded Object ................... -->\n+\n+<!ENTITY % object.element  \"INCLUDE\" >\n+<![%object.element;[\n+<!ENTITY % object.content\n+     \"( #PCDATA | %Flow.mix; | %param.qname; )*\"\n+>\n+<!ENTITY % object.qname  \"object\" >\n+<!ELEMENT %object.qname;  %object.content; >\n+<!-- end of object.element -->]]>\n+\n+<!ENTITY % object.attlist  \"INCLUDE\" >\n+<![%object.attlist;[\n+<!ATTLIST %object.qname;\n+      %Common.attrib;\n+      declare      ( declare )              #IMPLIED\n+      classid      %URI.datatype;           #IMPLIED\n+      codebase     %URI.datatype;           #IMPLIED\n+      data         %URI.datatype;           #IMPLIED\n+      type         %ContentType.datatype;   #IMPLIED\n+      codetype     %ContentType.datatype;   #IMPLIED\n+      archive      %URIs.datatype;          #IMPLIED\n+      standby      %Text.datatype;          #IMPLIED\n+      height       %Length.datatype;        #IMPLIED\n+      width        %Length.datatype;        #IMPLIED\n+      name         CDATA                    #IMPLIED\n+      tabindex     %Number.datatype;        #IMPLIED\n+>\n+<!-- end of object.attlist -->]]>\n+\n+<!-- end of xhtml-object-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-object-1.mod","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Param Element Module  ..................................... -->\n+<!-- file: xhtml-param-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-param-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Param Element 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-param-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Parameters for Java Applets and Embedded Objects\n+\n+        param\n+\n+     This module provides declarations for the param element,\n+     used to provide named property values for the applet\n+     and object elements.\n+-->\n+\n+<!-- param: Named Property Value ....................... -->\n+\n+<!ENTITY % param.element  \"INCLUDE\" >\n+<![%param.element;[\n+<!ENTITY % param.content  \"EMPTY\" >\n+<!ENTITY % param.qname  \"param\" >\n+<!ELEMENT %param.qname;  %param.content; >\n+<!-- end of param.element -->]]>\n+\n+<!ENTITY % param.attlist  \"INCLUDE\" >\n+<![%param.attlist;[\n+<!ATTLIST %param.qname;\n+      %XHTML.xmlns.attrib;\n+      %id.attrib;\n+      name         CDATA                    #REQUIRED\n+      value        CDATA                    #IMPLIED\n+      valuetype    ( data | ref | object )  'data'\n+      type         %ContentType.datatype;   #IMPLIED\n+>\n+<!-- end of param.attlist -->]]>\n+\n+<!-- end of xhtml-param-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-param-1.mod","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Presentation Module ............................................ -->\n+<!-- file: xhtml-pres-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-pres-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Presentation 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-pres-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Presentational Elements\n+\n+     This module defines elements and their attributes for\n+     simple presentation-related markup.\n+-->\n+\n+<!ENTITY % xhtml-inlpres.module \"INCLUDE\" >\n+<![%xhtml-inlpres.module;[\n+<!ENTITY % xhtml-inlpres.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Presentation 1.0\/\/EN\"\n+            \"xhtml-inlpres-1.mod\" >\n+%xhtml-inlpres.mod;]]>\n+\n+<!ENTITY % xhtml-blkpres.module \"INCLUDE\" >\n+<![%xhtml-blkpres.module;[\n+<!ENTITY % xhtml-blkpres.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Block Presentation 1.0\/\/EN\"\n+            \"xhtml-blkpres-1.mod\" >\n+%xhtml-blkpres.mod;]]>\n+\n+<!-- end of xhtml-pres-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-pres-1.mod","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,318 @@\n+<!-- ....................................................................... -->\n+<!-- XHTML Qname Module  ................................................... -->\n+<!-- file: xhtml-qname-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-qname-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Qualified Names 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-qname-1.mod\"\n+\n+     Revisions:\n+\t   #2000-10-22: added qname declarations for ruby elements\n+     ....................................................................... -->\n+\n+<!-- XHTML Qname (Qualified Name) Module\n+\n+     This module is contained in two parts, labeled Section 'A' and 'B':\n+\n+       Section A declares parameter entities to support namespace-\n+       qualified names, namespace declarations, and name prefixing\n+       for XHTML and extensions.\n+\n+       Section B declares parameter entities used to provide\n+       namespace-qualified names for all XHTML element types:\n+\n+         %applet.qname;   the xmlns-qualified name for <applet>\n+         %base.qname;     the xmlns-qualified name for <base>\n+         ...\n+\n+     XHTML extensions would create a module similar to this one.\n+     Included in the XHTML distribution is a template module\n+     ('template-qname-1.mod') suitable for this purpose.\n+-->\n+\n+<!-- Section A: XHTML XML Namespace Framework :::::::::::::::::::: -->\n+\n+<!-- 1. Declare a %XHTML.prefixed; conditional section keyword, used\n+        to activate namespace prefixing. The default value should\n+        inherit '%NS.prefixed;' from the DTD driver, so that unless\n+        overridden, the default behaviour follows the overall DTD\n+        prefixing scheme.\n+-->\n+<!ENTITY % NS.prefixed \"IGNORE\" >\n+<!ENTITY % XHTML.prefixed \"%NS.prefixed;\" >\n+\n+<!-- By default, we always permit XHTML attribute collections to have\n+     namespace-qualified prefixes as well.\n+-->\n+<!ENTITY % XHTML.global.attrs.prefixed \"INCLUDE\" >\n+<!-- By default, we allow the XML Schema attributes on the root\n+     element.\n+-->\n+<!ENTITY % XHTML.xsi.attrs \"INCLUDE\" >\n+\n+<!-- 2. Declare a parameter entity (eg., %XHTML.xmlns;) containing\n+        the URI reference used to identify the XHTML namespace:\n+-->\n+<!ENTITY % XHTML.xmlns  \"http:\/\/www.w3.org\/1999\/xhtml\" >\n+\n+<!-- 3. Declare parameter entities (eg., %XHTML.prefix;) containing\n+        the default namespace prefix string(s) to use when prefixing\n+        is enabled. This may be overridden in the DTD driver or the\n+        internal subset of an document instance. If no default prefix\n+        is desired, this may be declared as an empty string.\n+\n+     NOTE: As specified in [XMLNAMES], the namespace prefix serves\n+     as a proxy for the URI reference, and is not in itself significant.\n+-->\n+<!ENTITY % XHTML.prefix  \"xhtml\" >\n+\n+<!-- 4. Declare parameter entities (eg., %XHTML.pfx;) containing the\n+        colonized prefix(es) (eg., '%XHTML.prefix;:') used when\n+        prefixing is active, an empty string when it is not.\n+-->\n+<![%XHTML.prefixed;[\n+<!ENTITY % XHTML.pfx  \"%XHTML.prefix;:\" >\n+]]>\n+<!ENTITY % XHTML.pfx  \"\" >\n+\n+<!-- declare qualified name extensions here ............ -->\n+<!ENTITY % xhtml-qname-extra.mod \"\" >\n+%xhtml-qname-extra.mod;\n+\n+<!-- 5. The parameter entity %XHTML.xmlns.extra.attrib; may be\n+        redeclared to contain any non-XHTML namespace declaration\n+        attributes for namespaces embedded in XHTML. The default\n+        is an empty string.  XLink should be included here if used\n+        in the DTD.\n+-->\n+<!ENTITY % XHTML.xmlns.extra.attrib \"\" >\n+\n+<!-- The remainder of Section A is only followed in XHTML, not extensions. -->\n+\n+<!-- Declare a parameter entity %NS.decl.attrib; containing\n+     all XML Namespace declarations used in the DTD, plus the\n+     xmlns declaration for XHTML, its form dependent on whether\n+     prefixing is active.\n+-->\n+<!ENTITY % XHTML.xmlns.attrib.prefixed\n+     \"xmlns:%XHTML.prefix;  %URI.datatype;   #FIXED '%XHTML.xmlns;'\"\n+>\n+<![%XHTML.prefixed;[\n+<!ENTITY % NS.decl.attrib\n+     \"%XHTML.xmlns.attrib.prefixed;\n+      %XHTML.xmlns.extra.attrib;\"\n+>\n+]]>\n+<!ENTITY % NS.decl.attrib\n+     \"%XHTML.xmlns.extra.attrib;\"\n+>\n+\n+<!-- Declare a parameter entity %XSI.prefix as a prefix to use for XML\n+     Schema Instance attributes.\n+-->\n+<!ENTITY % XSI.prefix \"xsi\" >\n+\n+<!ENTITY % XSI.xmlns \"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" >\n+\n+<!-- Declare a parameter entity %XSI.xmlns.attrib as support for the\n+     schemaLocation attribute, since this is legal throughout the DTD.\n+-->\n+<!ENTITY % XSI.xmlns.attrib\n+     \"xmlns:%XSI.prefix;  %URI.datatype;   #FIXED '%XSI.xmlns;'\" >\n+\n+<!-- This is a placeholder for future XLink support.\n+-->\n+<!ENTITY % XLINK.xmlns.attrib \"\" >\n+\n+<!-- This is the attribute for the XML Schema namespace - XHTML\n+     Modularization is also expressed in XML Schema, and it needs to\n+\t be legal to declare the XML Schema namespace and the\n+\t schemaLocation attribute on the root element of XHTML family\n+\t documents.\n+-->\n+<![%XHTML.xsi.attrs;[\n+<!ENTITY % XSI.prefix \"xsi\" >\n+<!ENTITY % XSI.pfx \"%XSI.prefix;:\" >\n+<!ENTITY % XSI.xmlns \"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" >\n+\n+<!ENTITY % XSI.xmlns.attrib\n+     \"xmlns:%XSI.prefix;  %URI.datatype;    #FIXED '%XSI.xmlns;'\"\n+>\n+]]>\n+<!ENTITY % XSI.prefix \"\" >\n+<!ENTITY % XSI.pfx \"\" >\n+<!ENTITY % XSI.xmlns.attrib \"\" >\n+\n+\n+<!-- Declare a parameter entity %NS.decl.attrib; containing all\n+     XML namespace declaration attributes used by XHTML, including\n+     a default xmlns attribute when prefixing is inactive.\n+-->\n+<![%XHTML.prefixed;[\n+<!ENTITY % XHTML.xmlns.attrib\n+     \"%NS.decl.attrib;\n+      %XSI.xmlns.attrib;\n+      %XLINK.xmlns.attrib;\"\n+>\n+]]>\n+<!ENTITY % XHTML.xmlns.attrib\n+     \"xmlns        %URI.datatype;           #FIXED '%XHTML.xmlns;'\n+      %NS.decl.attrib;\n+      %XSI.xmlns.attrib;\n+      %XLINK.xmlns.attrib;\"\n+>\n+\n+<!-- placeholder for qualified name redeclarations -->\n+<!ENTITY % xhtml-qname.redecl \"\" >\n+%xhtml-qname.redecl;\n+\n+<!-- Section B: XHTML Qualified Names ::::::::::::::::::::::::::::: -->\n+\n+<!-- 6. This section declares parameter entities used to provide\n+        namespace-qualified names for all XHTML element types.\n+-->\n+\n+<!-- module:  xhtml-applet-1.mod -->\n+<!ENTITY % applet.qname  \"%XHTML.pfx;applet\" >\n+\n+<!-- module:  xhtml-base-1.mod -->\n+<!ENTITY % base.qname    \"%XHTML.pfx;base\" >\n+\n+<!-- module:  xhtml-bdo-1.mod -->\n+<!ENTITY % bdo.qname     \"%XHTML.pfx;bdo\" >\n+\n+<!-- module:  xhtml-blkphras-1.mod -->\n+<!ENTITY % address.qname \"%XHTML.pfx;address\" >\n+<!ENTITY % blockquote.qname  \"%XHTML.pfx;blockquote\" >\n+<!ENTITY % pre.qname     \"%XHTML.pfx;pre\" >\n+<!ENTITY % h1.qname      \"%XHTML.pfx;h1\" >\n+<!ENTITY % h2.qname      \"%XHTML.pfx;h2\" >\n+<!ENTITY % h3.qname      \"%XHTML.pfx;h3\" >\n+<!ENTITY % h4.qname      \"%XHTML.pfx;h4\" >\n+<!ENTITY % h5.qname      \"%XHTML.pfx;h5\" >\n+<!ENTITY % h6.qname      \"%XHTML.pfx;h6\" >\n+\n+<!-- module:  xhtml-blkpres-1.mod -->\n+<!ENTITY % hr.qname      \"%XHTML.pfx;hr\" >\n+\n+<!-- module:  xhtml-blkstruct-1.mod -->\n+<!ENTITY % div.qname     \"%XHTML.pfx;div\" >\n+<!ENTITY % p.qname       \"%XHTML.pfx;p\" >\n+\n+<!-- module:  xhtml-edit-1.mod -->\n+<!ENTITY % ins.qname     \"%XHTML.pfx;ins\" >\n+<!ENTITY % del.qname     \"%XHTML.pfx;del\" >\n+\n+<!-- module:  xhtml-form-1.mod -->\n+<!ENTITY % form.qname    \"%XHTML.pfx;form\" >\n+<!ENTITY % label.qname   \"%XHTML.pfx;label\" >\n+<!ENTITY % input.qname   \"%XHTML.pfx;input\" >\n+<!ENTITY % select.qname  \"%XHTML.pfx;select\" >\n+<!ENTITY % optgroup.qname  \"%XHTML.pfx;optgroup\" >\n+<!ENTITY % option.qname  \"%XHTML.pfx;option\" >\n+<!ENTITY % textarea.qname  \"%XHTML.pfx;textarea\" >\n+<!ENTITY % fieldset.qname  \"%XHTML.pfx;fieldset\" >\n+<!ENTITY % legend.qname  \"%XHTML.pfx;legend\" >\n+<!ENTITY % button.qname  \"%XHTML.pfx;button\" >\n+\n+<!-- module:  xhtml-hypertext-1.mod -->\n+<!ENTITY % a.qname       \"%XHTML.pfx;a\" >\n+\n+<!-- module:  xhtml-image-1.mod -->\n+<!ENTITY % img.qname     \"%XHTML.pfx;img\" >\n+\n+<!-- module:  xhtml-inlphras-1.mod -->\n+<!ENTITY % abbr.qname    \"%XHTML.pfx;abbr\" >\n+<!ENTITY % acronym.qname \"%XHTML.pfx;acronym\" >\n+<!ENTITY % cite.qname    \"%XHTML.pfx;cite\" >\n+<!ENTITY % code.qname    \"%XHTML.pfx;code\" >\n+<!ENTITY % dfn.qname     \"%XHTML.pfx;dfn\" >\n+<!ENTITY % em.qname      \"%XHTML.pfx;em\" >\n+<!ENTITY % kbd.qname     \"%XHTML.pfx;kbd\" >\n+<!ENTITY % q.qname       \"%XHTML.pfx;q\" >\n+<!ENTITY % samp.qname    \"%XHTML.pfx;samp\" >\n+<!ENTITY % strong.qname  \"%XHTML.pfx;strong\" >\n+<!ENTITY % var.qname     \"%XHTML.pfx;var\" >\n+\n+<!-- module:  xhtml-inlpres-1.mod -->\n+<!ENTITY % b.qname       \"%XHTML.pfx;b\" >\n+<!ENTITY % big.qname     \"%XHTML.pfx;big\" >\n+<!ENTITY % i.qname       \"%XHTML.pfx;i\" >\n+<!ENTITY % small.qname   \"%XHTML.pfx;small\" >\n+<!ENTITY % sub.qname     \"%XHTML.pfx;sub\" >\n+<!ENTITY % sup.qname     \"%XHTML.pfx;sup\" >\n+<!ENTITY % tt.qname      \"%XHTML.pfx;tt\" >\n+\n+<!-- module:  xhtml-inlstruct-1.mod -->\n+<!ENTITY % br.qname      \"%XHTML.pfx;br\" >\n+<!ENTITY % span.qname    \"%XHTML.pfx;span\" >\n+\n+<!-- module:  xhtml-ismap-1.mod (also csismap, ssismap) -->\n+<!ENTITY % map.qname     \"%XHTML.pfx;map\" >\n+<!ENTITY % area.qname    \"%XHTML.pfx;area\" >\n+\n+<!-- module:  xhtml-link-1.mod -->\n+<!ENTITY % link.qname    \"%XHTML.pfx;link\" >\n+\n+<!-- module:  xhtml-list-1.mod -->\n+<!ENTITY % dl.qname      \"%XHTML.pfx;dl\" >\n+<!ENTITY % dt.qname      \"%XHTML.pfx;dt\" >\n+<!ENTITY % dd.qname      \"%XHTML.pfx;dd\" >\n+<!ENTITY % ol.qname      \"%XHTML.pfx;ol\" >\n+<!ENTITY % ul.qname      \"%XHTML.pfx;ul\" >\n+<!ENTITY % li.qname      \"%XHTML.pfx;li\" >\n+\n+<!-- module:  xhtml-meta-1.mod -->\n+<!ENTITY % meta.qname    \"%XHTML.pfx;meta\" >\n+\n+<!-- module:  xhtml-param-1.mod -->\n+<!ENTITY % param.qname   \"%XHTML.pfx;param\" >\n+\n+<!-- module:  xhtml-object-1.mod -->\n+<!ENTITY % object.qname  \"%XHTML.pfx;object\" >\n+\n+<!-- module:  xhtml-script-1.mod -->\n+<!ENTITY % script.qname  \"%XHTML.pfx;script\" >\n+<!ENTITY % noscript.qname  \"%XHTML.pfx;noscript\" >\n+\n+<!-- module:  xhtml-struct-1.mod -->\n+<!ENTITY % html.qname    \"%XHTML.pfx;html\" >\n+<!ENTITY % head.qname    \"%XHTML.pfx;head\" >\n+<!ENTITY % title.qname   \"%XHTML.pfx;title\" >\n+<!ENTITY % body.qname    \"%XHTML.pfx;body\" >\n+\n+<!-- module:  xhtml-style-1.mod -->\n+<!ENTITY % style.qname   \"%XHTML.pfx;style\" >\n+\n+<!-- module:  xhtml-table-1.mod -->\n+<!ENTITY % table.qname   \"%XHTML.pfx;table\" >\n+<!ENTITY % caption.qname \"%XHTML.pfx;caption\" >\n+<!ENTITY % thead.qname   \"%XHTML.pfx;thead\" >\n+<!ENTITY % tfoot.qname   \"%XHTML.pfx;tfoot\" >\n+<!ENTITY % tbody.qname   \"%XHTML.pfx;tbody\" >\n+<!ENTITY % colgroup.qname  \"%XHTML.pfx;colgroup\" >\n+<!ENTITY % col.qname     \"%XHTML.pfx;col\" >\n+<!ENTITY % tr.qname      \"%XHTML.pfx;tr\" >\n+<!ENTITY % th.qname      \"%XHTML.pfx;th\" >\n+<!ENTITY % td.qname      \"%XHTML.pfx;td\" >\n+\n+<!-- module:  xhtml-ruby-1.mod -->\n+\n+<!ENTITY % ruby.qname    \"%XHTML.pfx;ruby\" >\n+<!ENTITY % rbc.qname     \"%XHTML.pfx;rbc\" >\n+<!ENTITY % rtc.qname     \"%XHTML.pfx;rtc\" >\n+<!ENTITY % rb.qname      \"%XHTML.pfx;rb\" >\n+<!ENTITY % rt.qname      \"%XHTML.pfx;rt\" >\n+<!ENTITY % rp.qname      \"%XHTML.pfx;rp\" >\n+\n+<!-- Provisional XHTML 2.0 Qualified Names  ...................... -->\n+\n+<!-- module:  xhtml-image-2.mod -->\n+<!ENTITY % alt.qname     \"%XHTML.pfx;alt\" >\n+\n+<!-- end of xhtml-qname-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-qname-1.mod","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Ruby Module .................................................... -->\n+<!-- file: xhtml-ruby-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1999-2001 W3C (MIT, INRIA, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-ruby-1.mod,v 1.1 2008\/06\/21 19:42:10 smccarro Exp $\n+\n+     This module is based on the W3C Ruby Annotation Specification:\n+\n+        http:\/\/www.w3.org\/TR\/ruby\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Ruby 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/TR\/ruby\/xhtml-ruby-1.mod\"\n+\n+     ...................................................................... -->\n+\n+<!-- Ruby Elements\n+\n+        ruby, rbc, rtc, rb, rt, rp\n+\n+     This module declares the elements and their attributes used to\n+     support ruby annotation markup.\n+-->\n+\n+<!-- declare qualified element type names:\n+-->\n+<!ENTITY % ruby.qname  \"ruby\" >\n+<!ENTITY % rbc.qname  \"rbc\" >\n+<!ENTITY % rtc.qname  \"rtc\" >\n+<!ENTITY % rb.qname  \"rb\" >\n+<!ENTITY % rt.qname  \"rt\" >\n+<!ENTITY % rp.qname  \"rp\" >\n+\n+<!-- rp fallback is included by default.\n+-->\n+<!ENTITY % Ruby.fallback \"INCLUDE\" >\n+<!ENTITY % Ruby.fallback.mandatory \"IGNORE\" >\n+\n+<!-- Complex ruby is included by default; it may be \n+     overridden by other modules to ignore it.\n+-->\n+<!ENTITY % Ruby.complex \"INCLUDE\" >\n+\n+<!-- Fragments for the content model of the ruby element -->\n+<![%Ruby.fallback;[\n+<![%Ruby.fallback.mandatory;[\n+<!ENTITY % Ruby.content.simple \n+     \"( %rb.qname;, %rp.qname;, %rt.qname;, %rp.qname; )\"\n+>\n+]]>\n+<!ENTITY % Ruby.content.simple \n+     \"( %rb.qname;, ( %rt.qname; | ( %rp.qname;, %rt.qname;, %rp.qname; ) ) )\"\n+>\n+]]>\n+<!ENTITY % Ruby.content.simple \"( %rb.qname;, %rt.qname; )\" >\n+\n+<![%Ruby.complex;[\n+<!ENTITY % Ruby.content.complex \n+     \"| ( %rbc.qname;, %rtc.qname;, %rtc.qname;? )\"\n+>\n+]]>\n+<!ENTITY % Ruby.content.complex \"\" >\n+\n+<!-- Content models of the rb and the rt elements are intended to\n+     allow other inline-level elements of its parent markup language,\n+     but it should not include ruby descendent elements. The following\n+     parameter entity %NoRuby.content; can be used to redefine\n+     those content models with minimum effort.  It's defined as\n+     '( #PCDATA )' by default.\n+-->\n+<!ENTITY % NoRuby.content \"( #PCDATA )\" >\n+\n+<!-- one or more digits (NUMBER) -->\n+<!ENTITY % Number.datatype \"CDATA\" >\n+\n+<!-- ruby element ...................................... -->\n+\n+<!ENTITY % ruby.element  \"INCLUDE\" >\n+<![%ruby.element;[\n+<!ENTITY % ruby.content\n+     \"( %Ruby.content.simple; %Ruby.content.complex; )\"\n+>\n+<!ELEMENT %ruby.qname;  %ruby.content; >\n+<!-- end of ruby.element -->]]>\n+\n+<![%Ruby.complex;[\n+<!-- rbc (ruby base component) element ................. -->\n+\n+<!ENTITY % rbc.element  \"INCLUDE\" >\n+<![%rbc.element;[\n+<!ENTITY % rbc.content\n+     \"(%rb.qname;)+\"\n+>\n+<!ELEMENT %rbc.qname;  %rbc.content; >\n+<!-- end of rbc.element -->]]>\n+\n+<!-- rtc (ruby text component) element ................. -->\n+\n+<!ENTITY % rtc.element  \"INCLUDE\" >\n+<![%rtc.element;[\n+<!ENTITY % rtc.content\n+     \"(%rt.qname;)+\"\n+>\n+<!ELEMENT %rtc.qname;  %rtc.content; >\n+<!-- end of rtc.element -->]]>\n+]]>\n+\n+<!-- rb (ruby base) element ............................ -->\n+\n+<!ENTITY % rb.element  \"INCLUDE\" >\n+<![%rb.element;[\n+<!-- %rb.content; uses %NoRuby.content; as its content model,\n+     which is '( #PCDATA )' by default. It may be overridden\n+     by other modules to allow other inline-level elements\n+     of its parent markup language, but it should not include\n+     ruby descendent elements.\n+-->\n+<!ENTITY % rb.content \"%NoRuby.content;\" >\n+<!ELEMENT %rb.qname;  %rb.content; >\n+<!-- end of rb.element -->]]>\n+\n+<!-- rt (ruby text) element ............................ -->\n+\n+<!ENTITY % rt.element  \"INCLUDE\" >\n+<![%rt.element;[\n+<!-- %rt.content; uses %NoRuby.content; as its content model,\n+     which is '( #PCDATA )' by default. It may be overridden\n+     by other modules to allow other inline-level elements\n+     of its parent markup language, but it should not include\n+     ruby descendent elements.\n+-->\n+<!ENTITY % rt.content \"%NoRuby.content;\" >\n+\n+<!ELEMENT %rt.qname;  %rt.content; >\n+<!-- end of rt.element -->]]>\n+\n+<!-- rbspan attribute is used for complex ruby only ...... -->\n+<![%Ruby.complex;[\n+<!ENTITY % rt.attlist  \"INCLUDE\" >\n+<![%rt.attlist;[\n+<!ATTLIST %rt.qname;\n+      rbspan         %Number.datatype;      \"1\"\n+>\n+<!-- end of rt.attlist -->]]>\n+]]>\n+\n+<!-- rp (ruby parenthesis) element ..................... -->\n+\n+<![%Ruby.fallback;[\n+<!ENTITY % rp.element  \"INCLUDE\" >\n+<![%rp.element;[\n+<!ENTITY % rp.content\n+     \"( #PCDATA )\"\n+>\n+<!ELEMENT %rp.qname;  %rp.content; >\n+<!-- end of rp.element -->]]>\n+]]>\n+\n+<!-- Ruby Common Attributes\n+\n+     The following optional ATTLIST declarations provide an easy way\n+     to define common attributes for ruby elements.  These declarations\n+     are ignored by default.\n+\n+     Ruby elements are intended to have common attributes of its\n+     parent markup language.  For example, if a markup language defines\n+     common attributes as a parameter entity %attrs;, you may add\n+     those attributes by just declaring the following parameter entities\n+\n+         <!ENTITY % Ruby.common.attlists  \"INCLUDE\" >\n+         <!ENTITY % Ruby.common.attrib  \"%attrs;\" >\n+\n+     before including the Ruby module.\n+-->\n+\n+<!ENTITY % Ruby.common.attlists  \"IGNORE\" >\n+<![%Ruby.common.attlists;[\n+<!ENTITY % Ruby.common.attrib  \"\" >\n+\n+<!-- common attributes for ruby ........................ -->\n+\n+<!ENTITY % Ruby.common.attlist  \"INCLUDE\" >\n+<![%Ruby.common.attlist;[\n+<!ATTLIST %ruby.qname;\n+      %Ruby.common.attrib;\n+>\n+<!-- end of Ruby.common.attlist -->]]>\n+\n+<![%Ruby.complex;[\n+<!-- common attributes for rbc ......................... -->\n+\n+<!ENTITY % Rbc.common.attlist  \"INCLUDE\" >\n+<![%Rbc.common.attlist;[\n+<!ATTLIST %rbc.qname;\n+      %Ruby.common.attrib;\n+>\n+<!-- end of Rbc.common.attlist -->]]>\n+\n+<!-- common attributes for rtc ......................... -->\n+\n+<!ENTITY % Rtc.common.attlist  \"INCLUDE\" >\n+<![%Rtc.common.attlist;[\n+<!ATTLIST %rtc.qname;\n+      %Ruby.common.attrib;\n+>\n+<!-- end of Rtc.common.attlist -->]]>\n+]]>\n+\n+<!-- common attributes for rb .......................... -->\n+\n+<!ENTITY % Rb.common.attlist  \"INCLUDE\" >\n+<![%Rb.common.attlist;[\n+<!ATTLIST %rb.qname;\n+      %Ruby.common.attrib;\n+>\n+<!-- end of Rb.common.attlist -->]]>\n+\n+<!-- common attributes for rt .......................... -->\n+\n+<!ENTITY % Rt.common.attlist  \"INCLUDE\" >\n+<![%Rt.common.attlist;[\n+<!ATTLIST %rt.qname;\n+      %Ruby.common.attrib;\n+>\n+<!-- end of Rt.common.attlist -->]]>\n+\n+<![%Ruby.fallback;[\n+<!-- common attributes for rp .......................... -->\n+\n+<!ENTITY % Rp.common.attlist  \"INCLUDE\" >\n+<![%Rp.common.attlist;[\n+<!ATTLIST %rp.qname;\n+      %Ruby.common.attrib;\n+>\n+<!-- end of Rp.common.attlist -->]]>\n+]]>\n+]]>\n+\n+<!-- end of xhtml-ruby-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-ruby-1.mod","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Document Scripting Module  ..................................... -->\n+<!-- file: xhtml-script-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-script-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Scripting 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-script-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Scripting\n+\n+        script, noscript\n+\n+     This module declares element types and attributes used to provide\n+     support for executable scripts as well as an alternate content\n+     container where scripts are not supported.\n+-->\n+\n+<!-- script: Scripting Statement ....................... -->\n+\n+<!ENTITY % script.element  \"INCLUDE\" >\n+<![%script.element;[\n+<!ENTITY % script.content  \"( #PCDATA )\" >\n+<!ENTITY % script.qname  \"script\" >\n+<!ELEMENT %script.qname;  %script.content; >\n+<!-- end of script.element -->]]>\n+\n+<!ENTITY % script.attlist  \"INCLUDE\" >\n+<![%script.attlist;[\n+<!ATTLIST %script.qname;\n+      %XHTML.xmlns.attrib;\n+\t  %id.attrib;\n+      xml:space    ( preserve )             #FIXED 'preserve'\n+      charset      %Charset.datatype;       #IMPLIED\n+      type         %ContentType.datatype;   #REQUIRED\n+      src          %URI.datatype;           #IMPLIED\n+      defer        ( defer )                #IMPLIED\n+>\n+<!-- end of script.attlist -->]]>\n+\n+<!-- noscript: No-Script Alternate Content ............. -->\n+\n+<!ENTITY % noscript.element  \"INCLUDE\" >\n+<![%noscript.element;[\n+<!ENTITY % noscript.content\n+     \"( %Block.mix; )+\"\n+>\n+<!ENTITY % noscript.qname  \"noscript\" >\n+<!ELEMENT %noscript.qname;  %noscript.content; >\n+<!-- end of noscript.element -->]]>\n+\n+<!ENTITY % noscript.attlist  \"INCLUDE\" >\n+<![%noscript.attlist;[\n+<!ATTLIST %noscript.qname;\n+      %Common.attrib;\n+>\n+<!-- end of noscript.attlist -->]]>\n+\n+<!-- end of xhtml-script-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-script-1.mod","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Server-side Image Map Module  .................................. -->\n+<!-- file: xhtml-ssismap-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-ssismap-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Server-side Image Maps 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-ssismap-1.mod\"\n+\n+     Revisions:\n+#2000-10-22: added declaration for 'ismap' on <input>\n+     ....................................................................... -->\n+\n+<!-- Server-side Image Maps\n+\n+     This adds the 'ismap' attribute to the img and input elements\n+     to support server-side processing of a user selection.\n+-->\n+\n+<!ATTLIST %img.qname;\n+      ismap        ( ismap )                #IMPLIED\n+>\n+\n+<!ATTLIST %input.qname;\n+      ismap        ( ismap )                #IMPLIED\n+>\n+\n+<!-- end of xhtml-ssismap-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-ssismap-1.mod","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Structure Module  .............................................. -->\n+<!-- file: xhtml-struct-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-struct-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Document Structure 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-struct-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Document Structure\n+\n+        title, head, body, html\n+\n+     The Structure Module defines the major structural elements and\n+     their attributes.\n+\n+     Note that the content model of the head element type is redeclared\n+     when the Base Module is included in the DTD.\n+\n+     The parameter entity containing the XML namespace URI value used\n+     for XHTML is '%XHTML.xmlns;', defined in the Qualified Names module.\n+-->\n+\n+<!-- title: Document Title ............................. -->\n+\n+<!-- The title element is not considered part of the flow of text.\n+     It should be displayed, for example as the page header or\n+     window title. Exactly one title is required per document.\n+-->\n+\n+<!ENTITY % title.element  \"INCLUDE\" >\n+<![%title.element;[\n+<!ENTITY % title.content  \"( #PCDATA )\" >\n+<!ENTITY % title.qname  \"title\" >\n+<!ELEMENT %title.qname;  %title.content; >\n+<!-- end of title.element -->]]>\n+\n+<!ENTITY % title.attlist  \"INCLUDE\" >\n+<![%title.attlist;[\n+<!ATTLIST %title.qname;\n+      %XHTML.xmlns.attrib;\n+      %I18n.attrib;\n+>\n+<!-- end of title.attlist -->]]>\n+\n+<!-- head: Document Head ............................... -->\n+\n+<!ENTITY % head.element  \"INCLUDE\" >\n+<![%head.element;[\n+<!ENTITY % head.content\n+    \"( %HeadOpts.mix;, %title.qname;, %HeadOpts.mix; )\"\n+>\n+<!ENTITY % head.qname  \"head\" >\n+<!ELEMENT %head.qname;  %head.content; >\n+<!-- end of head.element -->]]>\n+\n+<!ENTITY % head.attlist  \"INCLUDE\" >\n+<![%head.attlist;[\n+<!-- reserved for future use with document profiles\n+-->\n+<!ENTITY % profile.attrib\n+     \"profile      %URIs.datatype;           #IMPLIED\"\n+>\n+\n+<!ATTLIST %head.qname;\n+      %XHTML.xmlns.attrib;\n+      %I18n.attrib;\n+      %profile.attrib;\n+      %id.attrib;\n+>\n+<!-- end of head.attlist -->]]>\n+\n+<!-- body: Document Body ............................... -->\n+\n+<!ENTITY % body.element  \"INCLUDE\" >\n+<![%body.element;[\n+<!ENTITY % body.content\n+     \"( %Block.mix; )*\"\n+>\n+<!ENTITY % body.qname  \"body\" >\n+<!ELEMENT %body.qname;  %body.content; >\n+<!-- end of body.element -->]]>\n+\n+<!ENTITY % body.attlist  \"INCLUDE\" >\n+<![%body.attlist;[\n+<!ATTLIST %body.qname;\n+      %Common.attrib;\n+>\n+<!-- end of body.attlist -->]]>\n+\n+<!-- html: XHTML Document Element ...................... -->\n+\n+<!ENTITY % html.element  \"INCLUDE\" >\n+<![%html.element;[\n+<!ENTITY % html.content  \"( %head.qname;, %body.qname; )\" >\n+<!ENTITY % html.qname  \"html\" >\n+<!ELEMENT %html.qname;  %html.content; >\n+<!-- end of html.element -->]]>\n+\n+<![%XHTML.xsi.attrs;[\n+<!-- define a parameter for the XSI schemaLocation attribute -->\n+<!ENTITY % XSI.schemaLocation.attrib\n+     \"%XSI.pfx;schemaLocation  %URIs.datatype;    #IMPLIED\"\n+>\n+]]>\n+<!ENTITY % XSI.schemaLocation.attrib \"\">\n+\n+<!ENTITY % html.attlist  \"INCLUDE\" >\n+<![%html.attlist;[\n+<!-- version attribute value defined in driver\n+-->\n+<!ENTITY % XHTML.version.attrib\n+     \"version      %FPI.datatype;           #FIXED '%XHTML.version;'\"\n+>\n+\n+<!-- see the Qualified Names module for information\n+     on how to extend XHTML using XML namespaces\n+-->\n+<!ATTLIST %html.qname;\n+      %XHTML.xmlns.attrib;\n+      %XSI.schemaLocation.attrib;\n+      %XHTML.version.attrib;\n+      %I18n.attrib;\n+      %id.attrib;\n+>\n+<!-- end of html.attlist -->]]>\n+\n+<!-- end of xhtml-struct-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-struct-1.mod","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Document Style Sheet Module  ................................... -->\n+<!-- file: xhtml-style-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-style-1.mod,v 4.1 2001\/04\/05 06:57:40 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/DTD XHTML Style Sheets 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-style-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Style Sheets\n+\n+        style\n+\n+     This module declares the style element type and its attributes,\n+     used to embed style sheet information in the document head element.\n+-->\n+\n+<!-- style: Style Sheet Information .................... -->\n+\n+<!ENTITY % style.element  \"INCLUDE\" >\n+<![%style.element;[\n+<!ENTITY % style.content  \"( #PCDATA )\" >\n+<!ENTITY % style.qname  \"style\" >\n+<!ELEMENT %style.qname;  %style.content; >\n+<!-- end of style.element -->]]>\n+\n+<!ENTITY % style.attlist  \"INCLUDE\" >\n+<![%style.attlist;[\n+<!ATTLIST %style.qname;\n+      %XHTML.xmlns.attrib;\n+      %id.attrib;\n+      %title.attrib;\n+      %I18n.attrib;\n+      xml:space    ( preserve )             #FIXED 'preserve'\n+      type         %ContentType.datatype;   #REQUIRED\n+      media        %MediaDesc.datatype;     #IMPLIED\n+>\n+<!-- end of style.attlist -->]]>\n+\n+<!-- end of xhtml-style-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-style-1.mod","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Table Module  .................................................. -->\n+<!-- file: xhtml-table-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-table-1.mod,v 4.1 2001\/04\/10 09:42:30 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Tables 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-table-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Tables\n+\n+        table, caption, thead, tfoot, tbody, colgroup, col, tr, th, td\n+\n+     This module declares element types and attributes used to provide\n+     table markup similar to HTML 4, including features that enable\n+     better accessibility for non-visual user agents.\n+-->\n+\n+<!-- declare qualified element type names:\n+-->\n+<!ENTITY % table.qname  \"table\" >\n+<!ENTITY % caption.qname  \"caption\" >\n+<!ENTITY % thead.qname  \"thead\" >\n+<!ENTITY % tfoot.qname  \"tfoot\" >\n+<!ENTITY % tbody.qname  \"tbody\" >\n+<!ENTITY % colgroup.qname  \"colgroup\" >\n+<!ENTITY % col.qname  \"col\" >\n+<!ENTITY % tr.qname  \"tr\" >\n+<!ENTITY % th.qname  \"th\" >\n+<!ENTITY % td.qname  \"td\" >\n+\n+<!-- The frame attribute specifies which parts of the frame around\n+     the table should be rendered. The values are not the same as\n+     CALS to avoid a name clash with the valign attribute.\n+-->\n+<!ENTITY % frame.attrib\n+     \"frame        ( void\n+                   | above\n+                   | below\n+                   | hsides\n+                   | lhs\n+                   | rhs\n+                   | vsides\n+                   | box\n+                   | border )               #IMPLIED\"\n+>\n+\n+<!-- The rules attribute defines which rules to draw between cells:\n+\n+     If rules is absent then assume:\n+\n+       \"none\" if border is absent or border=\"0\" otherwise \"all\"\n+-->\n+<!ENTITY % rules.attrib\n+     \"rules        ( none\n+                   | groups\n+                   | rows\n+                   | cols\n+                   | all )                  #IMPLIED\"\n+>\n+\n+<!-- horizontal alignment attributes for cell contents\n+-->\n+<!ENTITY % CellHAlign.attrib\n+     \"align        ( left\n+                   | center\n+                   | right\n+                   | justify\n+                   | char )                 #IMPLIED\n+      char         %Character.datatype;     #IMPLIED\n+      charoff      %Length.datatype;        #IMPLIED\"\n+>\n+\n+<!-- vertical alignment attribute for cell contents\n+-->\n+<!ENTITY % CellVAlign.attrib\n+     \"valign       ( top\n+                   | middle\n+                   | bottom\n+                   | baseline )             #IMPLIED\"\n+>\n+\n+<!-- scope is simpler than axes attribute for common tables\n+-->\n+<!ENTITY % scope.attrib\n+     \"scope        ( row\n+                   | col\n+                   | rowgroup\n+                   | colgroup )             #IMPLIED\"\n+>\n+\n+<!-- table: Table Element .............................. -->\n+\n+<!ENTITY % table.element  \"INCLUDE\" >\n+<![%table.element;[\n+<!ENTITY % table.content\n+     \"( %caption.qname;?, ( %col.qname;* | %colgroup.qname;* ),\n+      (( %thead.qname;?, %tfoot.qname;?, %tbody.qname;+ ) | ( %tr.qname;+ )))\"\n+>\n+<!ELEMENT %table.qname;  %table.content; >\n+<!-- end of table.element -->]]>\n+\n+<!ENTITY % table.attlist  \"INCLUDE\" >\n+<![%table.attlist;[\n+<!ATTLIST %table.qname;\n+      %Common.attrib;\n+      summary      %Text.datatype;          #IMPLIED\n+      width        %Length.datatype;        #IMPLIED\n+      border       %Pixels.datatype;        #IMPLIED\n+      %frame.attrib;\n+      %rules.attrib;\n+      cellspacing  %Length.datatype;        #IMPLIED\n+      cellpadding  %Length.datatype;        #IMPLIED\n+>\n+<!-- end of table.attlist -->]]>\n+\n+<!-- caption: Table Caption ............................ -->\n+\n+<!ENTITY % caption.element  \"INCLUDE\" >\n+<![%caption.element;[\n+<!ENTITY % caption.content\n+     \"( #PCDATA | %Inline.mix; )*\"\n+>\n+<!ELEMENT %caption.qname;  %caption.content; >\n+<!-- end of caption.element -->]]>\n+\n+<!ENTITY % caption.attlist  \"INCLUDE\" >\n+<![%caption.attlist;[\n+<!ATTLIST %caption.qname;\n+      %Common.attrib;\n+>\n+<!-- end of caption.attlist -->]]>\n+\n+<!-- thead: Table Header ............................... -->\n+\n+<!-- Use thead to duplicate headers when breaking table\n+     across page boundaries, or for static headers when\n+     tbody sections are rendered in scrolling panel.\n+-->\n+\n+<!ENTITY % thead.element  \"INCLUDE\" >\n+<![%thead.element;[\n+<!ENTITY % thead.content  \"( %tr.qname; )+\" >\n+<!ELEMENT %thead.qname;  %thead.content; >\n+<!-- end of thead.element -->]]>\n+\n+<!ENTITY % thead.attlist  \"INCLUDE\" >\n+<![%thead.attlist;[\n+<!ATTLIST %thead.qname;\n+      %Common.attrib;\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of thead.attlist -->]]>\n+\n+<!-- tfoot: Table Footer ............................... -->\n+\n+<!-- Use tfoot to duplicate footers when breaking table\n+     across page boundaries, or for static footers when\n+     tbody sections are rendered in scrolling panel.\n+-->\n+\n+<!ENTITY % tfoot.element  \"INCLUDE\" >\n+<![%tfoot.element;[\n+<!ENTITY % tfoot.content  \"( %tr.qname; )+\" >\n+<!ELEMENT %tfoot.qname;  %tfoot.content; >\n+<!-- end of tfoot.element -->]]>\n+\n+<!ENTITY % tfoot.attlist  \"INCLUDE\" >\n+<![%tfoot.attlist;[\n+<!ATTLIST %tfoot.qname;\n+      %Common.attrib;\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of tfoot.attlist -->]]>\n+\n+<!-- tbody: Table Body ................................. -->\n+\n+<!-- Use multiple tbody sections when rules are needed\n+     between groups of table rows.\n+-->\n+\n+<!ENTITY % tbody.element  \"INCLUDE\" >\n+<![%tbody.element;[\n+<!ENTITY % tbody.content  \"( %tr.qname; )+\" >\n+<!ELEMENT %tbody.qname;  %tbody.content; >\n+<!-- end of tbody.element -->]]>\n+\n+<!ENTITY % tbody.attlist  \"INCLUDE\" >\n+<![%tbody.attlist;[\n+<!ATTLIST %tbody.qname;\n+      %Common.attrib;\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of tbody.attlist -->]]>\n+\n+<!-- colgroup: Table Column Group ...................... -->\n+\n+<!-- colgroup groups a set of col elements. It allows you\n+     to group several semantically-related columns together.\n+-->\n+\n+<!ENTITY % colgroup.element  \"INCLUDE\" >\n+<![%colgroup.element;[\n+<!ENTITY % colgroup.content  \"( %col.qname; )*\" >\n+<!ELEMENT %colgroup.qname;  %colgroup.content; >\n+<!-- end of colgroup.element -->]]>\n+\n+<!ENTITY % colgroup.attlist  \"INCLUDE\" >\n+<![%colgroup.attlist;[\n+<!ATTLIST %colgroup.qname;\n+      %Common.attrib;\n+      span         %Number.datatype;        '1'\n+      width        %MultiLength.datatype;   #IMPLIED\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of colgroup.attlist -->]]>\n+\n+<!-- col: Table Column ................................. -->\n+\n+<!-- col elements define the alignment properties for\n+     cells in one or more columns.\n+\n+     The width attribute specifies the width of the\n+     columns, e.g.\n+\n+       width=\"64\"        width in screen pixels\n+       width=\"0.5*\"      relative width of 0.5\n+\n+     The span attribute causes the attributes of one\n+     col element to apply to more than one column.\n+-->\n+\n+<!ENTITY % col.element  \"INCLUDE\" >\n+<![%col.element;[\n+<!ENTITY % col.content  \"EMPTY\" >\n+<!ELEMENT %col.qname;  %col.content; >\n+<!-- end of col.element -->]]>\n+\n+<!ENTITY % col.attlist  \"INCLUDE\" >\n+<![%col.attlist;[\n+<!ATTLIST %col.qname;\n+      %Common.attrib;\n+      span         %Number.datatype;        '1'\n+      width        %MultiLength.datatype;   #IMPLIED\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of col.attlist -->]]>\n+\n+<!-- tr: Table Row ..................................... -->\n+\n+<!ENTITY % tr.element  \"INCLUDE\" >\n+<![%tr.element;[\n+<!ENTITY % tr.content  \"( %th.qname; | %td.qname; )+\" >\n+<!ELEMENT %tr.qname;  %tr.content; >\n+<!-- end of tr.element -->]]>\n+\n+<!ENTITY % tr.attlist  \"INCLUDE\" >\n+<![%tr.attlist;[\n+<!ATTLIST %tr.qname;\n+      %Common.attrib;\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of tr.attlist -->]]>\n+\n+<!-- th: Table Header Cell ............................. -->\n+\n+<!-- th is for header cells, td for data,\n+     but for cells acting as both use td\n+-->\n+\n+<!ENTITY % th.element  \"INCLUDE\" >\n+<![%th.element;[\n+<!ENTITY % th.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ELEMENT %th.qname;  %th.content; >\n+<!-- end of th.element -->]]>\n+\n+<!ENTITY % th.attlist  \"INCLUDE\" >\n+<![%th.attlist;[\n+<!ATTLIST %th.qname;\n+      %Common.attrib;\n+      abbr         %Text.datatype;          #IMPLIED\n+      axis         CDATA                    #IMPLIED\n+      headers      IDREFS                   #IMPLIED\n+      %scope.attrib;\n+      rowspan      %Number.datatype;        '1'\n+      colspan      %Number.datatype;        '1'\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of th.attlist -->]]>\n+\n+<!-- td: Table Data Cell ............................... -->\n+\n+<!ENTITY % td.element  \"INCLUDE\" >\n+<![%td.element;[\n+<!ENTITY % td.content\n+     \"( #PCDATA | %Flow.mix; )*\"\n+>\n+<!ELEMENT %td.qname;  %td.content; >\n+<!-- end of td.element -->]]>\n+\n+<!ENTITY % td.attlist  \"INCLUDE\" >\n+<![%td.attlist;[\n+<!ATTLIST %td.qname;\n+      %Common.attrib;\n+      abbr         %Text.datatype;          #IMPLIED\n+      axis         CDATA                    #IMPLIED\n+      headers      IDREFS                   #IMPLIED\n+      %scope.attrib;\n+      rowspan      %Number.datatype;        '1'\n+      colspan      %Number.datatype;        '1'\n+      %CellHAlign.attrib;\n+      %CellVAlign.attrib;\n+>\n+<!-- end of td.attlist -->]]>\n+\n+<!-- end of xhtml-table-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-table-1.mod","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+<!-- ...................................................................... -->\n+<!-- XHTML Text Module  ................................................... -->\n+<!-- file: xhtml-text-1.mod\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2005 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml-text-1.mod,v 4.0 2001\/04\/02 22:42:49 altheim Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Text 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-text-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- Textual Content\n+\n+     The Text module includes declarations for all core\n+     text container elements and their attributes.\n+-->\n+\n+<!ENTITY % xhtml-inlstruct.module \"INCLUDE\" >\n+<![%xhtml-inlstruct.module;[\n+<!ENTITY % xhtml-inlstruct.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Structural 1.0\/\/EN\"\n+            \"xhtml-inlstruct-1.mod\" >\n+%xhtml-inlstruct.mod;]]>\n+\n+<!ENTITY % xhtml-inlphras.module \"INCLUDE\" >\n+<![%xhtml-inlphras.module;[\n+<!ENTITY % xhtml-inlphras.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Phrasal 1.0\/\/EN\"\n+            \"xhtml-inlphras-1.mod\" >\n+%xhtml-inlphras.mod;]]>\n+\n+<!ENTITY % xhtml-blkstruct.module \"INCLUDE\" >\n+<![%xhtml-blkstruct.module;[\n+<!ENTITY % xhtml-blkstruct.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Block Structural 1.0\/\/EN\"\n+            \"xhtml-blkstruct-1.mod\" >\n+%xhtml-blkstruct.mod;]]>\n+\n+<!ENTITY % xhtml-blkphras.module \"INCLUDE\" >\n+<![%xhtml-blkphras.module;[\n+<!ENTITY % xhtml-blkphras.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Block Phrasal 1.0\/\/EN\"\n+            \"xhtml-blkphras-1.mod\" >\n+%xhtml-blkphras.mod;]]>\n+\n+<!-- end of xhtml-text-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml-text-1.mod","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,250 @@\n+<!-- ....................................................................... -->\n+<!-- XHTML 1.1 Document Model Module  ...................................... -->\n+<!-- file: xhtml11-model-1.mod\n+\n+     This is XHTML 1.1, a reformulation of HTML as a modular XML application.\n+     Copyright 1998-2008 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n+     Revision: $Id: xhtml11-model-1.mod,v 1.18 2009\/06\/24 17:24:55 ahby Exp $ SMI\n+\n+     This DTD module is identified by the PUBLIC and SYSTEM identifiers:\n+\n+       PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML 1.1 Document Model 1.0\/\/EN\"\n+       SYSTEM \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml11-model-1.mod\"\n+\n+     Revisions:\n+     (none)\n+     ....................................................................... -->\n+\n+<!-- XHTML 1.1 Document Model\n+\n+     This module describes the groupings of elements that make up\n+     common content models for XHTML elements.\n+\n+     XHTML has three basic content models:\n+\n+         %Inline.mix;  character-level elements\n+         %Block.mix;   block-like elements, eg., paragraphs and lists\n+         %Flow.mix;    any block or inline elements\n+\n+     Any parameter entities declared in this module may be used\n+     to create element content models, but the above three are\n+     considered 'global' (insofar as that term applies here).\n+\n+     The reserved word '#PCDATA' (indicating a text string) is now\n+     included explicitly with each element declaration that is\n+     declared as mixed content, as XML requires that this token\n+     occur first in a content model specification.\n+-->\n+<!-- Extending the Model\n+\n+     While in some cases this module may need to be rewritten to\n+     accommodate changes to the document model, minor extensions\n+     may be accomplished by redeclaring any of the three *.extra;\n+     parameter entities to contain extension element types as follows:\n+\n+         %Misc.extra;    whose parent may be any block or\n+                         inline element.\n+\n+         %Inline.extra;  whose parent may be any inline element.\n+\n+         %Block.extra;   whose parent may be any block element.\n+\n+     If used, these parameter entities must be an OR-separated\n+     list beginning with an OR separator (\"|\"), eg., \"| a | b | c\"\n+\n+     All block and inline *.class parameter entities not part\n+     of the *struct.class classes begin with \"| \" to allow for\n+     exclusion from mixes.\n+-->\n+\n+<!-- ..............  Optional Elements in head  .................. -->\n+\n+<!ENTITY % HeadOpts.mix\n+     \"( %script.qname; | %style.qname; | %meta.qname;\n+      | %link.qname; | %object.qname; )*\"\n+>\n+\n+<!-- .................  Miscellaneous Elements  .................. -->\n+\n+<!-- ins and del are used to denote editing changes\n+-->\n+<!ENTITY % Edit.class \"| %ins.qname; | %del.qname;\" >\n+\n+<!-- script and noscript are used to contain scripts\n+     and alternative content\n+-->\n+<!ENTITY % Script.class \"| %script.qname; | %noscript.qname;\" >\n+\n+<!ENTITY % Misc.extra \"\" >\n+\n+<!-- These elements are neither block nor inline, and can\n+     essentially be used anywhere in the document body.\n+-->\n+<!ENTITY % Misc.class\n+     \"%Edit.class;\n+      %Script.class;\n+      %Misc.extra;\"\n+>\n+\n+<!-- ....................  Inline Elements  ...................... -->\n+\n+<!ENTITY % InlStruct.class \"%br.qname; | %span.qname;\" >\n+\n+<!ENTITY % InlPhras.class\n+     \"| %em.qname; | %strong.qname; | %dfn.qname; | %code.qname;\n+      | %samp.qname; | %kbd.qname; | %var.qname; | %cite.qname;\n+      | %abbr.qname; | %acronym.qname; | %q.qname;\" >\n+\n+<!ENTITY % InlPres.class\n+     \"| %tt.qname; | %i.qname; | %b.qname; | %big.qname;\n+      | %small.qname; | %sub.qname; | %sup.qname;\" >\n+\n+<!ENTITY % I18n.class \"| %bdo.qname;\" >\n+\n+<!ENTITY % Anchor.class \"| %a.qname;\" >\n+\n+<!ENTITY % InlSpecial.class\n+     \"| %img.qname; | %map.qname;\n+      | %object.qname;\" >\n+\n+<!ENTITY % InlForm.class\n+     \"| %input.qname; | %select.qname; | %textarea.qname;\n+      | %label.qname; | %button.qname;\" >\n+\n+<!ENTITY % Inline.extra \"\" >\n+\n+<!ENTITY % Ruby.class \"| %ruby.qname;\" >\n+\n+<!-- %Inline.class; includes all inline elements,\n+     used as a component in mixes\n+-->\n+<!ENTITY % Inline.class\n+     \"%InlStruct.class;\n+      %InlPhras.class;\n+      %InlPres.class;\n+      %I18n.class;\n+      %Anchor.class;\n+      %InlSpecial.class;\n+      %InlForm.class;\n+      %Ruby.class;\n+      %Inline.extra;\"\n+>\n+\n+<!-- %InlNoRuby.class; includes all inline elements\n+     except ruby, used as a component in mixes\n+-->\n+<!ENTITY % InlNoRuby.class\n+     \"%InlStruct.class;\n+      %InlPhras.class;\n+      %InlPres.class;\n+      %I18n.class;\n+      %Anchor.class;\n+      %InlSpecial.class;\n+      %InlForm.class;\n+      %Inline.extra;\"\n+>\n+\n+<!-- %NoRuby.content; includes all inlines except ruby\n+-->\n+<!ENTITY % NoRuby.content\n+     \"( #PCDATA\n+      | %InlNoRuby.class;\n+      %Misc.class; )*\"\n+>\n+\n+<!-- %InlNoAnchor.class; includes all non-anchor inlines,\n+     used as a component in mixes\n+-->\n+<!ENTITY % InlNoAnchor.class\n+     \"%InlStruct.class;\n+      %InlPhras.class;\n+      %InlPres.class;\n+      %I18n.class;\n+      %InlSpecial.class;\n+      %InlForm.class;\n+      %Ruby.class;\n+      %Inline.extra;\"\n+>\n+\n+<!-- %InlNoAnchor.mix; includes all non-anchor inlines\n+-->\n+<!ENTITY % InlNoAnchor.mix\n+     \"%InlNoAnchor.class;\n+      %Misc.class;\"\n+>\n+\n+<!-- %Inline.mix; includes all inline elements, including %Misc.class;\n+-->\n+<!ENTITY % Inline.mix\n+     \"%Inline.class;\n+      %Misc.class;\"\n+>\n+\n+<!-- .....................  Block Elements  ...................... -->\n+\n+<!-- In the HTML 4.0 DTD, heading and list elements were included\n+     in the %block; parameter entity. The %Heading.class; and\n+     %List.class; parameter entities must now be included explicitly\n+     on element declarations where desired.\n+-->\n+\n+<!ENTITY % Heading.class\n+     \"%h1.qname; | %h2.qname; | %h3.qname;\n+      | %h4.qname; | %h5.qname; | %h6.qname;\" >\n+\n+<!ENTITY % List.class \"%ul.qname; | %ol.qname; | %dl.qname;\" >\n+\n+<!ENTITY % Table.class \"| %table.qname;\" >\n+\n+<!ENTITY % Form.class  \"| %form.qname;\" >\n+\n+<!ENTITY % Fieldset.class  \"| %fieldset.qname;\" >\n+\n+<!ENTITY % BlkStruct.class \"%p.qname; | %div.qname;\" >\n+\n+<!ENTITY % BlkPhras.class\n+     \"| %pre.qname; | %blockquote.qname; | %address.qname;\" >\n+\n+<!ENTITY % BlkPres.class \"| %hr.qname;\" >\n+\n+<!ENTITY % BlkSpecial.class\n+     \"%Table.class;\n+      %Form.class;\n+      %Fieldset.class;\"\n+>\n+\n+<!ENTITY % Block.extra \"\" >\n+\n+<!-- %Block.class; includes all block elements,\n+     used as an component in mixes\n+-->\n+<!ENTITY % Block.class\n+     \"%BlkStruct.class;\n+      %BlkPhras.class;\n+      %BlkPres.class;\n+      %BlkSpecial.class;\n+      %Block.extra;\"\n+>\n+\n+<!-- %Block.mix; includes all block elements plus %Misc.class;\n+-->\n+<!ENTITY % Block.mix\n+     \"%Heading.class;\n+      | %List.class;\n+      | %Block.class;\n+      %Misc.class;\"\n+>\n+\n+<!-- ................  All Content Elements  .................. -->\n+\n+<!-- %Flow.mix; includes all text content, block and inline\n+-->\n+<!ENTITY % Flow.mix\n+     \"%Heading.class;\n+      | %List.class;\n+      | %Block.class;\n+      | %Inline.class;\n+      %Misc.class;\"\n+>\n+\n+<!-- end of xhtml11-model-1.mod -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml11-model-1.mod","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+<!-- ....................................................................... -->\n+<!-- XHTML 1.1 DTD  ........................................................ -->\n+<!-- file: xhtml11.dtd\n+-->\n+\n+<!-- XHTML 1.1 DTD\n+\n+     This is XHTML, a reformulation of HTML as a modular XML application.\n+\n+     The Extensible HyperText Markup Language (XHTML)\n+     Copyright 1998-2008 World Wide Web Consortium\n+        (Massachusetts Institute of Technology, European Research Consortium\n+         for Informatics and Mathematics, Keio University).\n+         All Rights Reserved.\n+\n+     Permission to use, copy, modify and distribute the XHTML DTD and its \n+     accompanying documentation for any purpose and without fee is hereby \n+     granted in perpetuity, provided that the above copyright notice and \n+     this paragraph appear in all copies.  The copyright holders make no \n+     representation about the suitability of the DTD for any purpose.\n+\n+     It is provided \"as is\" without expressed or implied warranty.\n+\n+        Author:     Murray M. Altheim <altheim@eng.sun.com>\n+        Revision:   $Id: xhtml11.dtd,v 1.1 2010\/11\/24 20:56:19 bertails Exp $\n+\n+-->\n+<!-- This is the driver file for version 1.1 of the XHTML DTD.\n+\n+     Please use this public identifier to identify it:\n+\n+         \"-\/\/W3C\/\/DTD XHTML 1.1\/\/EN\"\n+-->\n+<!ENTITY % XHTML.version  \"-\/\/W3C\/\/DTD XHTML 1.1\/\/EN\" >\n+\n+<!-- Use this URI to identify the default namespace:\n+\n+         \"http:\/\/www.w3.org\/1999\/xhtml\"\n+\n+     See the Qualified Names module for information\n+     on the use of namespace prefixes in the DTD.\n+\n+\t Note that XHTML namespace elements are not prefixed by default,\n+\t but the XHTML namespace prefix is defined as \"xhtml\" so that\n+\t other markup languages can extend this one and use the XHTML\n+\t prefixed global attributes if required.\n+\n+-->\n+<!ENTITY % NS.prefixed \"IGNORE\" >\n+<!ENTITY % XHTML.prefix \"xhtml\" >\n+\n+<!-- Be sure to include prefixed global attributes - we don't need\n+     them, but languages that extend XHTML 1.1 might.\n+-->\n+<!ENTITY % XHTML.global.attrs.prefixed \"INCLUDE\" >\n+\n+<!-- Reserved for use with the XLink namespace:\n+-->\n+<!ENTITY % XLINK.xmlns \"\" >\n+<!ENTITY % XLINK.xmlns.attrib \"\" >\n+\n+<!-- For example, if you are using XHTML 1.1 directly, use the public\n+     identifier in the DOCTYPE declaration, with the namespace declaration\n+     on the document element to identify the default namespace:\n+\n+       <?xml version=\"1.0\"?>\n+       <!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.1\/\/EN\"\n+                             \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml11.dtd\">\n+       <html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+             xml:lang=\"en\">\n+       ...\n+       <\/html>\n+\n+     Revisions:\n+     (none)\n+-->\n+\n+<!-- reserved for future use with document profiles -->\n+<!ENTITY % XHTML.profile  \"\" >\n+\n+<!-- ensure XHTML Notations are disabled -->\n+<!ENTITY % xhtml-notations.module \"IGNORE\" >\n+\n+<!-- Bidirectional Text features\n+     This feature-test entity is used to declare elements\n+     and attributes used for bidirectional text support.\n+-->\n+<!ENTITY % XHTML.bidi  \"INCLUDE\" >\n+\n+<?doc type=\"doctype\" role=\"title\" { XHTML 1.1 } ?>\n+\n+<!-- ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->\n+\n+<!-- Pre-Framework Redeclaration placeholder  .................... -->\n+<!-- this serves as a location to insert markup declarations\n+     into the DTD prior to the framework declarations.\n+-->\n+<!ENTITY % xhtml-prefw-redecl.module \"IGNORE\" >\n+<![%xhtml-prefw-redecl.module;[\n+%xhtml-prefw-redecl.mod;\n+<!-- end of xhtml-prefw-redecl.module -->]]>\n+\n+<!ENTITY % xhtml-events.module \"INCLUDE\" >\n+\n+<!-- Inline Style Module  ........................................ -->\n+<!ENTITY % xhtml-inlstyle.module \"INCLUDE\" >\n+<![%xhtml-inlstyle.module;[\n+<!ENTITY % xhtml-inlstyle.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Inline Style 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-inlstyle-1.mod\" >\n+%xhtml-inlstyle.mod;]]>\n+\n+<!-- declare Document Model module instantiated in framework\n+-->\n+<!ENTITY % xhtml-model.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML 1.1 Document Model 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml11-model-1.mod\" >\n+\n+<!-- adding the lang attribute into the I18N collection -->\n+\n+<!ENTITY % xhtml-datatypes.module \"INCLUDE\" >\n+<![%xhtml-datatypes.module;[\n+<!ENTITY % xhtml-datatypes.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Datatypes 1.0\/\/EN\"\n+            \"xhtml-datatypes-1.mod\" >\n+%xhtml-datatypes.mod;]]>\n+\n+<!ENTITY % lang.attrib\n+     \"xml:lang     %LanguageCode.datatype;  #IMPLIED\n+      lang         %LanguageCode.datatype;  #IMPLIED\"\n+>\n+\n+<!-- Modular Framework Module (required) ......................... -->\n+<!ENTITY % xhtml-framework.module \"INCLUDE\" >\n+<![%xhtml-framework.module;[\n+<!ENTITY % xhtml-framework.mod\n+     PUBLIC \"-\/\/W3C\/\/ENTITIES XHTML Modular Framework 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-framework-1.mod\" >\n+%xhtml-framework.mod;]]>\n+\n+<!-- Post-Framework Redeclaration placeholder  ................... -->\n+<!-- this serves as a location to insert markup declarations\n+     into the DTD following the framework declarations.\n+-->\n+<!ENTITY % xhtml-postfw-redecl.module \"IGNORE\" >\n+<![%xhtml-postfw-redecl.module;[\n+%xhtml-postfw-redecl.mod;\n+<!-- end of xhtml-postfw-redecl.module -->]]>\n+\n+<!-- Text Module (Required)  ..................................... -->\n+<!ENTITY % xhtml-text.module \"INCLUDE\" >\n+<![%xhtml-text.module;[\n+<!ENTITY % xhtml-text.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Text 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-text-1.mod\" >\n+%xhtml-text.mod;]]>\n+\n+<!-- Hypertext Module (required) ................................. -->\n+<!ENTITY % xhtml-hypertext.module \"INCLUDE\" >\n+<![%xhtml-hypertext.module;[\n+<!ENTITY % xhtml-hypertext.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Hypertext 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-hypertext-1.mod\" >\n+%xhtml-hypertext.mod;]]>\n+\n+<!-- Lists Module (required)  .................................... -->\n+<!ENTITY % xhtml-list.module \"INCLUDE\" >\n+<![%xhtml-list.module;[\n+<!ENTITY % xhtml-list.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Lists 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-list-1.mod\" >\n+%xhtml-list.mod;]]>\n+\n+<!-- ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->\n+\n+<!-- Edit Module  ................................................ -->\n+<!ENTITY % xhtml-edit.module \"INCLUDE\" >\n+<![%xhtml-edit.module;[\n+<!ENTITY % xhtml-edit.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Editing Elements 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-edit-1.mod\" >\n+%xhtml-edit.mod;]]>\n+\n+<!-- BIDI Override Module  ....................................... -->\n+<!ENTITY % xhtml-bdo.module \"%XHTML.bidi;\" >\n+<![%xhtml-bdo.module;[\n+<!ENTITY % xhtml-bdo.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML BIDI Override Element 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-bdo-1.mod\" >\n+%xhtml-bdo.mod;]]>\n+\n+<!-- Ruby Module  ................................................ -->\n+<!ENTITY % Ruby.common.attlists \"INCLUDE\" >\n+<!ENTITY % Ruby.common.attrib \"%Common.attrib;\" >\n+<!ENTITY % xhtml-ruby.module \"INCLUDE\" >\n+<![%xhtml-ruby.module;[\n+<!ENTITY % xhtml-ruby.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Ruby 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-ruby-1.mod\" >\n+%xhtml-ruby.mod;]]>\n+\n+<!-- Presentation Module  ........................................ -->\n+<!ENTITY % xhtml-pres.module \"INCLUDE\" >\n+<![%xhtml-pres.module;[\n+<!ENTITY % xhtml-pres.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Presentation 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-pres-1.mod\" >\n+%xhtml-pres.mod;]]>\n+\n+<!-- Link Element Module  ........................................ -->\n+<!ENTITY % xhtml-link.module \"INCLUDE\" >\n+<![%xhtml-link.module;[\n+<!ENTITY % xhtml-link.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Link Element 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-link-1.mod\" >\n+%xhtml-link.mod;]]>\n+\n+<!-- Document Metainformation Module  ............................ -->\n+<!ENTITY % xhtml-meta.module \"INCLUDE\" >\n+<![%xhtml-meta.module;[\n+<!ENTITY % xhtml-meta.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Metainformation 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-meta-1.mod\" >\n+%xhtml-meta.mod;]]>\n+\n+<!-- Base Element Module  ........................................ -->\n+<!ENTITY % xhtml-base.module \"INCLUDE\" >\n+<![%xhtml-base.module;[\n+<!ENTITY % xhtml-base.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Base Element 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-base-1.mod\" >\n+%xhtml-base.mod;]]>\n+\n+<!-- Scripting Module  ........................................... -->\n+<!ENTITY % xhtml-script.module \"INCLUDE\" >\n+<![%xhtml-script.module;[\n+<!ENTITY % xhtml-script.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Scripting 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-script-1.mod\" >\n+%xhtml-script.mod;]]>\n+\n+<!-- Style Sheets Module  ......................................... -->\n+<!ENTITY % xhtml-style.module \"INCLUDE\" >\n+<![%xhtml-style.module;[\n+<!ENTITY % xhtml-style.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Style Sheets 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-style-1.mod\" >\n+%xhtml-style.mod;]]>\n+\n+<!-- Image Module  ............................................... -->\n+<!ENTITY % xhtml-image.module \"INCLUDE\" >\n+<![%xhtml-image.module;[\n+<!ENTITY % xhtml-image.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Images 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-image-1.mod\" >\n+%xhtml-image.mod;]]>\n+\n+<!-- Client-side Image Map Module  ............................... -->\n+<!ENTITY % xhtml-csismap.module \"INCLUDE\" >\n+<![%xhtml-csismap.module;[\n+<!ENTITY % xhtml-csismap.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Client-side Image Maps 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-csismap-1.mod\" >\n+%xhtml-csismap.mod;]]>\n+\n+<!-- Server-side Image Map Module  ............................... -->\n+<!ENTITY % xhtml-ssismap.module \"INCLUDE\" >\n+<![%xhtml-ssismap.module;[\n+<!ENTITY % xhtml-ssismap.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Server-side Image Maps 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-ssismap-1.mod\" >\n+%xhtml-ssismap.mod;]]>\n+\n+<!-- Param Element Module  ....................................... -->\n+<!ENTITY % xhtml-param.module \"INCLUDE\" >\n+<![%xhtml-param.module;[\n+<!ENTITY % xhtml-param.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Param Element 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-param-1.mod\" >\n+%xhtml-param.mod;]]>\n+\n+<!-- Embedded Object Module  ..................................... -->\n+<!ENTITY % xhtml-object.module \"INCLUDE\" >\n+<![%xhtml-object.module;[\n+<!ENTITY % xhtml-object.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Embedded Object 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-object-1.mod\" >\n+%xhtml-object.mod;]]>\n+\n+<!-- Tables Module ............................................... -->\n+<!ENTITY % xhtml-table.module \"INCLUDE\" >\n+<![%xhtml-table.module;[\n+<!ENTITY % xhtml-table.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Tables 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-table-1.mod\" >\n+%xhtml-table.mod;]]>\n+\n+<!-- Forms Module  ............................................... -->\n+<!ENTITY % xhtml-form.module \"INCLUDE\" >\n+<![%xhtml-form.module;[\n+<!ENTITY % xhtml-form.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Forms 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-form-1.mod\" >\n+%xhtml-form.mod;]]>\n+\n+<!-- Legacy Markup ............................................... -->\n+<!ENTITY % xhtml-legacy.module \"IGNORE\" >\n+<![%xhtml-legacy.module;[\n+<!ENTITY % xhtml-legacy.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Legacy Markup 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-legacy-1.mod\" >\n+%xhtml-legacy.mod;]]>\n+\n+<!-- Document Structure Module (required)  ....................... -->\n+<!ENTITY % xhtml-struct.module \"INCLUDE\" >\n+<![%xhtml-struct.module;[\n+<!ENTITY % xhtml-struct.mod\n+     PUBLIC \"-\/\/W3C\/\/ELEMENTS XHTML Document Structure 1.0\/\/EN\"\n+            \"http:\/\/www.w3.org\/MarkUp\/DTD\/xhtml-struct-1.mod\" >\n+%xhtml-struct.mod;]]>\n+\n+<!-- end of XHTML 1.1 DTD  ................................................. -->\n+<!-- ....................................................................... -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xhtml11\/xhtml11.dtd","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,2778 @@\n+<!-- ............................................................... -->\n+<!-- XML specification DTD ......................................... -->\n+<!-- ............................................................... -->\n+\n+<!-- $Id: xmlspec.dtd,v 1.20 2005\/10\/13 15:30:39 NormanWalsh Exp $ -->\n+\n+<!--\n+TYPICAL INVOCATION:\n+#  <!DOCTYPE spec PUBLIC\n+#       \"-\/\/W3C\/\/DTD Specification V2.10\/\/EN\"\n+#       \"http:\/\/www.w3.org\/2002\/xmlspec\/dtd\/2.10\/xmlspec.dtd\">\n+\n+PURPOSE:\n+  This XML DTD is for W3C specifications and other technical reports.\n+  It is based in part on the TEI Lite and Sweb DTDs.\n+\n+COPYRIGHT:\n+\n+  Copyright (C) 2000, 2001, 2002, 2003 Sun Microsystems, Inc. All Rights Reserved.\n+  This document is governed by the W3C Software License[3] as\n+  described in the FAQ[4].\n+\n+    [1] http:\/\/www.w3.org\/TR\/xslt\n+    [2] http:\/\/www.w3.org\/XML\/1998\/06\/xmlspec-report-v21.htm\n+    [3] http:\/\/www.w3.org\/Consortium\/Legal\/copyright-software-19980720\n+    [4] http:\/\/www.w3.org\/Consortium\/Legal\/IPR-FAQ-20000620.html#DTD\n+\n+DEPENDENCIES:\n+  None.\n+\n+CHANGE HISTORY:\n+  The list of historical changes is at the end of the DTD. For recent changes,\n+  see the CVS log.\n+\n+  For all details, see the design report at:\n+\n+  <http:\/\/www.w3.org\/XML\/1998\/06\/xmlspec-report-v21.htm>\n+\n+  This report is now out-of-date, but no more recent report has been prepared.\n+\n+#2003-06-25: nwalsh: Added translationloc, preverrataloc, rfc2119\n+\n+#2003-05-28: nwalsh: Added errataloc, fixed IE bug. Added @num to prod.\n+\n+             Published V2.4\n+\n+#2003-03-12: nwalsh: Added local.* PEs to a number of additional\n+             places to make customization layers easier.\n+\n+             Published V2.3\n+\n+#2002-09-04: nwalsh: Added 'phrase' to title, subtitle, version,\n+             w3c-designation, w3c-doctype, day, month, year, name,\n+             affiliation, email, language, role, lhs, rhs, com,\n+             typename, date, loc, nt, sub, sup, term, termref,\n+             titleref, xnt, xspecref, xtermref\n+\n+             This is *solely* to support automated diffing. Users\n+             are explicitly forbidden from using this as an escape\n+             hatch to get extra markup in these contexts.\n+\n+#2001-10-08: nwalsh: Added local.arg.att and local.proto.att\n+\n+#2002-08-14: nwalsh: Published V2.2\n+\n+  Added marked sections around element and attlist declarations and\n+  added the altlocs element\n+\n+MAINTAINERS:\n+  Norman Walsh\n+  Sun Microsystems, Inc.\n+  Norman.Walsh@Sun.COM\n+  voice: +1 413 256 6985\n+  fax:   +1 413 256 6985\n+\n+  Eve Maler\n+  Sun Microsystems, Inc.\n+  elm@east.sun.com\n+  voice: +1 781 442 3190\n+  fax:   +1 781 442 1437\n+-->\n+\n+<!-- ............................................................... -->\n+<!-- Entities for characters and symbols ........................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1998-03-10: maler: Added &ldquo; and &rdquo;.\n+#                   Used 8879:1986-compatible decimal character\n+#                   references.\n+#                   Merged charent.mod file back into main file.\n+#1998-05-14: maler: Fixed ldquo and rdquo.  Gave mdash a real number.\n+#1998-12-03: maler: Escaped the leading ampersands.\n+-->\n+\n+<!ENTITY lt     \"&#38;#60;\">\n+<!ENTITY gt     \"&#62;\">\n+<!ENTITY amp    \"&#38;#38;\">\n+<!ENTITY apos   \"&#39;\">\n+<!ENTITY quot   \"&#34;\">\n+<!ENTITY nbsp   \"&#160;\">\n+<!ENTITY mdash  \"&#38;#x2014;\">\n+<!ENTITY ldquo  \"&#38;#x201C;\">\n+<!ENTITY rdquo  \"&#38;#x201D;\">\n+\n+<!-- ............................................................... -->\n+<!-- Entities for classes of standalone elements ................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1997-10-16: maler: Added table to %illus.class;.\n+#1997-11-28: maler: Added htable to %illus.class;.\n+#1997-12-29: maler: IGNOREd table.\n+#1998-03-10: maler: Removed SGML Open-specific %illus.class;.\n+#                   Added \"local\" entities for customization.\n+#1998-05-14: maler: Added issue to %note.class;.\n+#                   Removed %[local.]statusp.class;.\n+#1998-05-21: maler: Added constraintnote to %note.class;.\n+#1998-08-22: maler: Changed htable to table in %illus.class;.\n+#                   Added definitions to %illus.class;.\n+#2000-03-07: maler: Added proto and example to %illus.class;.\n+-->\n+\n+<!ENTITY % local.p.class        \" \">\n+<!ENTITY % p.class              \"p\n+                                %local.p.class;\">\n+\n+<!ENTITY % local.list.class     \" \">\n+<!ENTITY % list.class           \"ulist|olist|slist|glist\n+                                %local.list.class;\">\n+\n+<!ENTITY % local.speclist.class \" \">\n+<!ENTITY % speclist.class       \"orglist|blist\n+                                %local.speclist.class;\">\n+\n+<!ENTITY % local.note.class     \" \">\n+<!ENTITY % note.class           \"note|issue|wfcnote|vcnote\n+                                |constraintnote %local.note.class;\">\n+\n+<!ENTITY % local.illus.class    \" \">\n+<!ENTITY % illus.class          \"eg|graphic|scrap|table|definitions\n+                                |proto|example\n+                                %local.illus.class;\">\n+\n+<!-- ............................................................... -->\n+<!-- Entities for classes of phrase-level elements ................. -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1997-12-29: maler: Added xspecref to %ref.class;.\n+#1998-03-10: maler: Added %ednote.class;.\n+#                   Added \"local\" entities for customization.\n+#2000-03-07: maler: Added function, var, el, att, and attval to\n+#                   %tech.class;.\n+#                   Added sub, sup, and phrase to %emph.class;.\n+-->\n+\n+<!ENTITY % local.annot.class    \" \">\n+<!ENTITY % annot.class          \"footnote\n+                                %local.annot.class;\">\n+\n+<!ENTITY % local.termdef.class  \" \">\n+<!ENTITY % termdef.class        \"termdef|term\n+                                %local.termdef.class;\">\n+\n+<!ENTITY % local.emph.class     \" \">\n+<!ENTITY % emph.class           \"emph|phrase|rfc2119|quote|sub|sup\n+                                %local.emph.class;\">\n+\n+<!ENTITY % local.ref.class      \" \">\n+<!ENTITY % ref.class            \"bibref|specref|termref|titleref\n+                                |xspecref|xtermref\n+                                %local.ref.class;\">\n+\n+<!ENTITY % local.loc.class      \" \">\n+<!ENTITY % loc.class            \"loc\n+                                %local.loc.class;\">\n+\n+<!ENTITY % local.tech.class     \" \">\n+<!ENTITY % tech.class           \"kw|nt|xnt|code|function|var\n+                                |el|att|attval\n+                                %local.tech.class;\">\n+\n+<!ENTITY % local.ednote.class   \" \">\n+<!ENTITY % ednote.class         \"ednote\n+                                %local.ednote.class;\">\n+\n+<!-- ............................................................... -->\n+<!-- Entities for mixtures of standalone elements .................. -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1997-09-30: maler: Created %p.mix; to eliminate p from self.\n+#1997-09-30: maler: Added %speclist.class; to %obj.mix; and %p.mix;.\n+#1997-09-30: maler: Added %note.class; to %obj.mix; and %p.mix;.\n+#1997-10-16: maler: Created %entry.mix;.  Note that some elements\n+#                   left out here are still allowed in termdef,\n+#                   which entry can contain through %p.pcd.mix;.\n+#1997-11-28: maler: Added %p.class; to %statusobj.mix;.\n+#1998-03-10: maler: Added %ednote.class; to all mixtures, except\n+#                   %p.mix; and %statusobj.mix;, because paragraphs\n+#                   and status paragraphs will contain ednote\n+#                   through %p.pcd.mix;.\n+#1998-03-23: maler: Added %termdef.mix; (broken out from\n+#                    %termdef.pcd.mix;).\n+#1998-05-14: maler: Removed %statusobj.mix; and all mentions of\n+#                   %statusp.mix;.\n+-->\n+\n+<!ENTITY % local.div.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % div.mix\n+        \"%p.class;|%list.class;|%speclist.class;|%note.class;\n+        |%illus.class;|%ednote.class;%local.div.mix;\">\n+\n+<!ENTITY % local.obj.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % obj.mix\n+        \"%p.class;|%list.class;|%speclist.class;|%note.class;\n+        |%illus.class;|%ednote.class;%local.obj.mix;\">\n+\n+<!ENTITY % local.p.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % p.mix\n+        \"%list.class;|%speclist.class;|%note.class;|%illus.class;%local.p.mix;\">\n+\n+<!ENTITY % local.entry.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % entry.mix\n+        \"%list.class;|note|eg|graphic|%ednote.class;%local.entry.mix;\">\n+\n+<!ENTITY % local.hdr.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % hdr.mix\n+        \"%p.class;|%list.class;|%ednote.class;%local.hdr.mix;\">\n+\n+<!ENTITY % local.termdef.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % termdef.mix\n+        \"%note.class;|%illus.class;%local.termdef.mix;\">\n+\n+<!-- ............................................................... -->\n+<!-- Entities for mixtures of #PCDATA and phrase-level elements .... -->\n+<!-- ............................................................... -->\n+\n+<!--    Note that %termdef.pcd.mix contains %note.class;\n+        and %illus.class;, considered standalone elements. -->\n+\n+<!--\n+#1997-09-30: maler: Added scrap and %note.class; to %termdef.pcd.mix;.\n+#1997-11-28: maler: Added %loc.class; to %p.pcd.mix;.\n+#1998-03-10: maler: Added %ednote.class; to all mixtures.\n+#1998-03-23: maler: Moved some %termdef.pcd.mix; stuff out to\n+#                   %termdef.mix;.\n+#1998-05-14: maler: Removed %statusp.pcd.mix;.\n+#1998-05-21: maler: Added constraint element to %eg.pcd.mix;.\n+#1999-07-02: maler: Added %loc.class; to %head.pcd.mix;,\n+#                   %label.pcd.mix;, %eg.pcd.mix;, %termdef.pcd.mix;,\n+#                   %tech.pcd.mix; (net: all PCD mixes have it).\n+#                   Removed unused %loc.pcd.mix;.\n+-->\n+\n+<!ENTITY % local.p.pcd.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % p.pcd.mix\n+        \"#PCDATA|%annot.class;|%termdef.class;|%emph.class;\n+        |%ref.class;|%tech.class;|%loc.class;|%ednote.class;%local.p.pcd.mix;\">\n+\n+<!ENTITY % local.head.pcd.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % head.pcd.mix\n+        \"#PCDATA|%annot.class;|%emph.class;|%tech.class;\n+        |%loc.class;|%ednote.class;%local.head.pcd.mix;\">\n+\n+<!ENTITY % local.label.pcd.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % label.pcd.mix\n+        \"#PCDATA|%annot.class;|%termdef.class;|%emph.class;\n+        |%tech.class;|%loc.class;|%ednote.class;%local.label.pcd.mix;\">\n+\n+<!ENTITY % local.eg.pcd.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % eg.pcd.mix\n+        \"#PCDATA|%annot.class;|%emph.class;|%loc.class;\n+        |%ednote.class;|constraint %local.eg.pcd.mix;\">\n+\n+<!ENTITY % local.termdef.pcd.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % termdef.pcd.mix\n+        \"#PCDATA|term|%emph.class;|%ref.class;|%tech.class;\n+        |%loc.class;|%ednote.class;%local.termdef.pcd.mix;\">\n+\n+<!ENTITY % local.bibl.pcd.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % bibl.pcd.mix\n+        \"#PCDATA|%emph.class;|%ref.class;|%loc.class;|%ednote.class;%local.bibl.pcd.mix;\">\n+\n+<!ENTITY % local.tech.pcd.mix \" \"> <!-- compensate for IE bug; suggested by ht -->\n+<!ENTITY % tech.pcd.mix\n+        \"#PCDATA|%loc.class;|%ednote.class;|phrase|rfc2119 %local.tech.pcd.mix;\">\n+\n+<!-- ............................................................... -->\n+<!-- Entities for customizable content models ...................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1998-03-10: maler: Added customization entities.\n+#1998-05-14: maler: Allowed prevlocs and latestloc in either order.\n+#1999-07-02: maler: Made version optional; added copyright element.\n+#2000-03-07: maler: Allowed status and abstract in opposite order.\n+-->\n+\n+<!ENTITY % spec.mdl\n+        \"header, front?, body, back?\">\n+\n+<!ENTITY % header.mdl\n+        \"title, subtitle?, version?, w3c-designation, w3c-doctype,\n+        pubdate, notice*, publoc, altlocs?, ((prevlocs, latestloc?) |\n+        (latestloc, prevlocs?))?, authlist, errataloc?, preverrataloc?,\n+        translationloc?, copyright?,\n+        ((status, abstract) | (abstract, status)), pubstmt?,\n+        sourcedesc?, langusage, revisiondesc\">\n+\n+<!ENTITY % pubdate.mdl\n+        \"day?, month, year\">\n+\n+<!-- ............................................................... -->\n+<!-- Entities for common attributes ................................ -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#2000-03-07: maler: Added %argtypes;.\n+-->\n+\n+<!--    argtypes:\n+        Values for function prototype argument datatypes. -->\n+<!ENTITY % argtypes\n+        '(boolean\n+         |expression\n+         |location-set\n+         |node-set\n+         |number\n+         |object\n+         |point\n+         |range\n+         |string)'>\n+\n+<!--    key attribute:\n+        Optionally provides a sorting or indexing key, for cases when\n+        the element content is inappropriate for this purpose. -->\n+<!ENTITY % key.att\n+        'key                    CDATA           #IMPLIED'>\n+\n+<!--    def attribute:\n+        Points to the element where the relevant definition can be\n+        found, using the IDREF mechanism.  %def.att; is for optional\n+        def attributes, and %def-req.att; is for required def\n+        attributes. -->\n+<!ENTITY % def.att\n+        'def                    IDREF           #IMPLIED'>\n+<!ENTITY % def-req.att\n+        'def                    IDREF           #REQUIRED'>\n+\n+<!--    ref attribute:\n+        Points to the element where more information can be found,\n+        using the IDREF mechanism.  %ref.att; is for optional\n+        ref attributes, and %ref-req.att; is for required ref\n+        attributes. -->\n+<!ENTITY % ref.att\n+        'ref                    IDREF           #IMPLIED'>\n+<!ENTITY % ref-req.att\n+        'ref                    IDREF           #REQUIRED'>\n+\n+<!--\n+#1998-03-23: maler: Added show and actuate attributes to href.\n+#                   Added semi-common xml:space attribute.\n+#1998-08-22: maler: Used new xlink:form and #IMPLIED features.\n+#1999-07-02: maler: Reorganized XLink-related entities completely;\n+#                   added xmlns:xlink attribute to the mix.\n+#2000-03-07: maler: Updated XLink usage to February 2000 draft,\n+#                   except that href still has no namespace prefix.\n+-->\n+\n+<!--    xmlns:xlink and xlink:type attributes:\n+        xmlns:xlink declares the association of the xlink prefix\n+        with the namespace created by the XLink specification.\n+        xlink:type identifies an element as an XLink \"simple\" linking\n+        element. -->\n+<!ENTITY % simple-xlink.att\n+        'xmlns:xlink            CDATA   #FIXED\n+                                        \"http:\/\/www.w3.org\/1999\/xlink\"\n+        xlink:type              CDATA   #FIXED \"simple\" '>\n+\n+<!--    href attributes:\n+        The href attribute locates the remote-resource half of a\n+        simple link; the element on which the href appears is the\n+        local-resource half.  Some elements are usable links only if\n+        the author chooses to supply a functional href.  The attribute\n+        name should really be xlink:href, but is kept without the\n+        prefix for now in order to be backwards-compatible. -->\n+\n+<!ENTITY % href.att\n+        'href                   CDATA           #IMPLIED '>\n+<!ENTITY % href-req.att\n+        'href                   CDATA           #REQUIRED '>\n+\n+<!--    xlink:show and xlink:actuate attributes:\n+        These attributes offer instructions to the display engine\n+        about how to handle traversal to resource indicated by an\n+        href locator. -->\n+<!ENTITY % auto-embed.att\n+        'xlink:show             CDATA           #FIXED \"embed\"\n+        xlink:actuate           CDATA           #FIXED \"onLoad\" '>\n+<!ENTITY % user-replace.att\n+        'xlink:show             CDATA           #FIXED \"replace\"\n+        xlink:actuate           CDATA           #FIXED \"onRequest\" '>\n+<!ENTITY % user-new.att\n+        'xlink:show             CDATA           #FIXED \"new\"\n+        xlink:actuate           CDATA           #FIXED \"onRequest\" '>\n+\n+<!--    xml:space attribute:\n+        Indicates that the element contains whitespace that the\n+        formatter or other application should retain, as appropriate\n+        to its function. -->\n+<!ENTITY % xmlspace.att\n+        'xml:space              (default\n+                                |preserve)      #FIXED \"preserve\" '>\n+\n+<!--\n+#2000-03-07: maler: Added common diff attribute.  Made %role.att;.\n+-->\n+\n+<!--    diff attribute:\n+        Indicates in what way the element has changed.  When a value\n+        is not provided, that subelement should inherit a value from\n+        its parent.  If the root element has no value supplied,\n+        assume \"off\". -->\n+<!ENTITY % diff.att\n+        'diff                   (chg\n+                                |add\n+                                |del\n+                                |off)           #IMPLIED'>\n+\n+<!--    role attribute:\n+        Extends the useful life of the DTD by allowing authors to\n+        make a subtype of any element.  No default. -->\n+<!ENTITY % role.att\n+        'role                   NMTOKEN         #IMPLIED'>\n+\n+<!--    Common attributes:\n+        Every element has an ID attribute for links, a role\n+        attribute, and a diff attribute. %common.att; is for\n+        common attributes where the ID is optional, and\n+        %common-idreq.att; is for common attributes where the\n+        ID is required. -->\n+\n+<!ENTITY % local.common.att \" \">\n+<!ENTITY % common.att\n+        'id                     ID              #IMPLIED\n+        %role.att;\n+        %diff.att;\n+        %local.common.att;'>\n+\n+<!ENTITY % local.common-idreq.att \" \">\n+<!ENTITY % common-idreq.att\n+        'id                     ID              #REQUIRED\n+        %role.att;\n+        %diff.att;\n+        %local.common-idreq.att;'>\n+\n+<!-- ............................................................... -->\n+<!-- Common elements ............................................... -->\n+<!-- ............................................................... -->\n+\n+<!--    head: Title on divisions, productions, and the like -->\n+<!ENTITY % head.element \"INCLUDE\">\n+<![%head.element;[\n+<!ELEMENT head (%head.pcd.mix;)*>\n+]]>\n+<!ENTITY % head.attlist \"INCLUDE\">\n+<![%head.attlist;[\n+<!ATTLIST head %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Major specification structure ................................. -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1998-03-10: maler: Made spec content model easily customizable.\n+#1999-07-02: maler: Added doctype atts and status att.\n+#2000-03-07: maler: Added cr, issues, and dispcmts to w3c-doctype.\n+-->\n+\n+<!ENTITY % spec.element \"INCLUDE\">\n+<![%spec.element;[\n+<!ELEMENT spec (%spec.mdl;)>\n+]]>\n+<!--    w3c-doctype attributes:\n+        Indicates the type of document, so that the appropriate\n+        stylesheet or workflow routing can be applied.  Should\n+        *not* generate any text (such as the \"REC-\" or \"NOTE-\"\n+        prefix on the W3C designation content).  No default.  If\n+        w3c-doctype is \"other\", other-doctype should be filled in.\n+\n+        status attribute:\n+        Indicates the stage of review of the document.  May affect\n+        the stylesheet's treatment of ednotes (e.g., whether to\n+        output them).  No default. -->\n+\n+<!ENTITY % local.spec.att \" \">\n+<!ENTITY % spec.attlist \"INCLUDE\">\n+<![%spec.attlist;[\n+<!ATTLIST spec\n+        %common.att;\n+        %local.spec.att;\n+        w3c-doctype     (cr\n+                        |dispcmts\n+                        |issues\n+                        |wgnote\n+                        |memsub\n+                        |teamsub\n+                        |note\n+                        |other\n+                        |pr\n+                        |per\n+                        |rec\n+                        |wd\n+                        |review)                #IMPLIED\n+        other-doctype   CDATA                   #IMPLIED\n+        status          (int-review\n+                        |ext-review\n+                        |final)                 #IMPLIED\n+>\n+]]>\n+\n+<!ENTITY % front.element \"INCLUDE\">\n+<![%front.element;[\n+<!ELEMENT front (div1+)>\n+]]>\n+<!ENTITY % front.attlist \"INCLUDE\">\n+<![%front.attlist;[\n+<!ATTLIST front %common.att;>\n+]]>\n+\n+<!ENTITY % body.element \"INCLUDE\">\n+<![%body.element;[\n+<!ELEMENT body (div1+)>\n+]]>\n+<!ENTITY % body.attlist \"INCLUDE\">\n+<![%body.attlist;[\n+<!ATTLIST body %common.att;>\n+]]>\n+\n+<!--\n+#1997-09-30: maler: Added inform-div1 to back content.\n+-->\n+\n+<!ENTITY % back.element \"INCLUDE\">\n+<![%back.element;[\n+<!ELEMENT back ((div1+, inform-div1*) | inform-div1+)>\n+]]>\n+<!ENTITY % back.attlist \"INCLUDE\">\n+<![%back.attlist;[\n+<!ATTLIST back %common.att;>\n+]]>\n+\n+<!ENTITY % div1.element \"INCLUDE\">\n+<![%div1.element;[\n+<!ELEMENT div1 (head, (%div.mix;)*, div2*)>\n+]]>\n+<!ENTITY % div1.attlist \"INCLUDE\">\n+<![%div1.attlist;[\n+<!ATTLIST div1 %common.att;>\n+]]>\n+\n+<!--\n+#1997-09-30: maler: Added inform-div1 declarations.\n+#2000-03-07: maler: Added div5 level.\n+-->\n+\n+<!--    inform-div1: Non-normative division in back matter -->\n+<!ENTITY % inform-div1.element \"INCLUDE\">\n+<![%inform-div1.element;[\n+<!ELEMENT inform-div1 (head, (%div.mix;)*, div2*)>\n+]]>\n+<!ENTITY % inform-div1.attlist \"INCLUDE\">\n+<![%inform-div1.attlist;[\n+<!ATTLIST inform-div1 %common.att;>\n+]]>\n+\n+<!ENTITY % div2.element \"INCLUDE\">\n+<![%div2.element;[\n+<!ELEMENT div2 (head, (%div.mix;)*, div3*)>\n+]]>\n+<!ENTITY % div2.attlist \"INCLUDE\">\n+<![%div2.attlist;[\n+<!ATTLIST div2 %common.att;>\n+]]>\n+\n+<!ENTITY % div3.element \"INCLUDE\">\n+<![%div3.element;[\n+<!ELEMENT div3 (head, (%div.mix;)*, div4*)>\n+]]>\n+<!ENTITY % div3.attlist \"INCLUDE\">\n+<![%div3.attlist;[\n+<!ATTLIST div3 %common.att;>\n+]]>\n+\n+<!ENTITY % div4.element \"INCLUDE\">\n+<![%div4.element;[\n+<!ELEMENT div4 (head, (%div.mix;)*, div5*)>\n+]]>\n+<!ENTITY % div4.attlist \"INCLUDE\">\n+<![%div4.attlist;[\n+<!ATTLIST div4 %common.att;>\n+]]>\n+\n+<!ENTITY % div5.element \"INCLUDE\">\n+<![%div5.element;[\n+<!ELEMENT div5 (head, (%div.mix;)*)>\n+]]>\n+<!ENTITY % div5.attlist \"INCLUDE\">\n+<![%div5.attlist;[\n+<!ATTLIST div5 %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Specification header .......................................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1998-03-10: maler: Made header content model easily customizable.\n+-->\n+\n+<!ENTITY % header.element \"INCLUDE\">\n+<![%header.element;[\n+<!ELEMENT header (%header.mdl;)>\n+]]>\n+<!ENTITY % header.attlist \"INCLUDE\">\n+<![%header.attlist;[\n+<!ATTLIST header %common.att;>\n+]]>\n+\n+<!--    Example of title: \"Extensible Cheese Language (XCL)\" -->\n+<!ENTITY % title.element \"INCLUDE\">\n+<![%title.element;[\n+<!ELEMENT title (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % title.attlist \"INCLUDE\">\n+<![%title.attlist;[\n+<!ATTLIST title %common.att;>\n+]]>\n+\n+<!--    Example of subtitle: \"A Cheesy Specification\" -->\n+<!ENTITY % subtitle.element \"INCLUDE\">\n+<![%subtitle.element;[\n+<!ELEMENT subtitle (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % subtitle.attlist \"INCLUDE\">\n+<![%subtitle.attlist;[\n+<!ATTLIST subtitle %common.att;>\n+]]>\n+\n+<!--    Example of version: \"Version 666.0\" -->\n+<!ENTITY % version.element \"INCLUDE\">\n+<![%version.element;[\n+<!ELEMENT version (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % version.attlist \"INCLUDE\">\n+<![%version.attlist;[\n+<!ATTLIST version %common.att;>\n+]]>\n+\n+<!--    Example of w3c-designation: \"WD-xcl-19991231\" -->\n+<!ENTITY % w3c-designation.element \"INCLUDE\">\n+<![%w3c-designation.element;[\n+<!ELEMENT w3c-designation (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % w3c-designation.attlist \"INCLUDE\">\n+<![%w3c-designation.attlist;[\n+<!ATTLIST w3c-designation %common.att;>\n+]]>\n+\n+<!--    Example of w3c-doctype: \"W3C Working Draft\" -->\n+<!ENTITY % w3c-doctype.element \"INCLUDE\">\n+<![%w3c-doctype.element;[\n+<!ELEMENT w3c-doctype (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % w3c-doctype.attlist \"INCLUDE\">\n+<![%w3c-doctype.attlist;[\n+<!ATTLIST w3c-doctype %common.att;>\n+]]>\n+\n+<!--\n+#1998-03-10: maler: Made pubdate content model easily customizable.\n+-->\n+\n+<!ENTITY % pubdate.element \"INCLUDE\">\n+<![%pubdate.element;[\n+<!ELEMENT pubdate (%pubdate.mdl;)>\n+]]>\n+<!ENTITY % pubdate.attlist \"INCLUDE\">\n+<![%pubdate.attlist;[\n+<!ATTLIST pubdate %common.att;>\n+]]>\n+\n+<!ENTITY % day.element \"INCLUDE\">\n+<![%day.element;[\n+<!ELEMENT day (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % day.attlist \"INCLUDE\">\n+<![%day.attlist;[\n+<!ATTLIST day %common.att;>\n+]]>\n+\n+<!ENTITY % month.element \"INCLUDE\">\n+<![%month.element;[\n+<!ELEMENT month (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % month.attlist \"INCLUDE\">\n+<![%month.attlist;[\n+<!ATTLIST month %common.att;>\n+]]>\n+\n+<!ENTITY % year.element \"INCLUDE\">\n+<![%year.element;[\n+<!ELEMENT year (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % year.attlist \"INCLUDE\">\n+<![%year.attlist;[\n+<!ATTLIST year %common.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Declared copyright element.\n+-->\n+\n+<!ENTITY % copyright.element \"INCLUDE\">\n+<![%copyright.element;[\n+<!ELEMENT copyright (%hdr.mix;)+>\n+]]>\n+<!ENTITY % copyright.attlist \"INCLUDE\">\n+<![%copyright.attlist;[\n+<!ATTLIST copyright %common.att;>\n+]]>\n+\n+<!--    Example of notice: \"This draft is for public comment...\" -->\n+<!ENTITY % notice.element \"INCLUDE\">\n+<![%notice.element;[\n+<!ELEMENT notice (%hdr.mix;)+>\n+]]>\n+<!ENTITY % notice.attlist \"INCLUDE\">\n+<![%notice.attlist;[\n+<!ATTLIST notice %common.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Broadened models of *loc to %p.pcd.mix;.\n+-->\n+\n+<!ENTITY % publoc.element \"INCLUDE\">\n+<![%publoc.element;[\n+<!ELEMENT publoc (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % publoc.attlist \"INCLUDE\">\n+<![%publoc.attlist;[\n+<!ATTLIST publoc %common.att;>\n+]]>\n+\n+<!--\n+#2002-08-15: nwalsh: Added altlocs element.\n+  The semantics of the altlocs are equivalent to the Dublin Core relation element\n+  with type=\"hasVersion\". Each of the loc elements inside altlocs should identify\n+  an alternate version of the resource described by the document, for example\n+  HTML, XML, and PDF forms.\n+-->\n+<!ENTITY % altlocs.element \"INCLUDE\">\n+<![%altlocs.element;[\n+<!ELEMENT altlocs (loc+)>\n+]]>\n+<!ENTITY % altlocs.attlist \"INCLUDE\">\n+<![%altlocs.attlist;[\n+<!ATTLIST altlocs %common.att;>\n+]]>\n+\n+<!ENTITY % prevlocs.element \"INCLUDE\">\n+<![%prevlocs.element;[\n+<!ELEMENT prevlocs (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % prevlocs.attlist \"INCLUDE\">\n+<![%prevlocs.attlist;[\n+<!ATTLIST prevlocs %common.att;>\n+]]>\n+\n+<!--\n+#2005-10-13: nwalsh: restrict latestloc content model.\n+  New pubrules allows for multiple latestlocs. For some reason, this element\n+  used to allow PCDATA. Now it allows only loc elements. If this causes\n+  trouble, tell Norm.\n+-->\n+<!ENTITY % latestloc.element \"INCLUDE\">\n+<![%latestloc.element;[\n+<!ELEMENT latestloc (loc+)>\n+]]>\n+<!ENTITY % latestloc.attlist \"INCLUDE\">\n+<![%latestloc.attlist;[\n+<!ATTLIST latestloc %common.att;>\n+]]>\n+\n+<!ENTITY % errataloc.element \"INCLUDE\">\n+<![%errataloc.element;[\n+<!ELEMENT errataloc EMPTY>\n+]]>\n+<!ENTITY % errataloc.attlist \"INCLUDE\">\n+<![%errataloc.attlist;[\n+<!ATTLIST errataloc\n+\t%common.att;\n+        %simple-xlink.att;\n+\t%href-req.att;\n+>\n+]]>\n+\n+<!ENTITY % preverrataloc.element \"INCLUDE\">\n+<![%preverrataloc.element;[\n+<!ELEMENT preverrataloc EMPTY>\n+]]>\n+<!ENTITY % preverrataloc.attlist \"INCLUDE\">\n+<![%preverrataloc.attlist;[\n+<!ATTLIST preverrataloc\n+\t%common.att;\n+        %simple-xlink.att;\n+\t%href-req.att;\n+>\n+]]>\n+\n+<!ENTITY % translationloc.element \"INCLUDE\">\n+<![%translationloc.element;[\n+<!ELEMENT translationloc EMPTY>\n+]]>\n+<!ENTITY % translationloc.attlist \"INCLUDE\">\n+<![%translationloc.attlist;[\n+<!ATTLIST translationloc\n+\t%common.att;\n+        %simple-xlink.att;\n+\t%href-req.att;\n+>\n+]]>\n+\n+<!--      loc (defined in \"Phrase-level elements\" below) -->\n+\n+<!ENTITY % authlist.element \"INCLUDE\">\n+<![%authlist.element;[\n+<!ELEMENT authlist (author+)>\n+]]>\n+<!ENTITY % authlist.attlist \"INCLUDE\">\n+<![%authlist.attlist;[\n+<!ATTLIST authlist %common.att;>\n+]]>\n+\n+<!--\n+#1997-09-30: maler: Made affiliation optional.\n+#1998-03-10: maler: Made email optional.\n+-->\n+\n+<!ENTITY % author.element \"INCLUDE\">\n+<![%author.element;[\n+<!ELEMENT author (name, affiliation?, email?)>\n+]]>\n+<!ENTITY % author.attlist \"INCLUDE\">\n+<![%author.attlist;[\n+<!ATTLIST author %common.att;>\n+]]>\n+\n+<!ENTITY % name.element \"INCLUDE\">\n+<![%name.element;[\n+<!ELEMENT name (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % name.attlist \"INCLUDE\">\n+<![%name.attlist;[\n+<!ATTLIST name\n+        %common.att;\n+        %key.att;>\n+]]>\n+\n+<!ENTITY % affiliation.element \"INCLUDE\">\n+<![%affiliation.element;[\n+<!ELEMENT affiliation (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % affiliation.attlist \"INCLUDE\">\n+<![%affiliation.attlist;[\n+<!ATTLIST affiliation %common.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Added show\/actuate attributes and default values.\n+-->\n+\n+\n+<!ENTITY % email.element \"INCLUDE\">\n+<![%email.element;[\n+<!ELEMENT email (#PCDATA|phrase)*>\n+]]>\n+<!--    href attribute:\n+        email functions as a hypertext reference through this\n+        required attribute.  Typically the reference would use\n+        the mailto: scheme.  E.g.:\n+\n+<email href=\"mailto:elm@arbortext.com\">elm@arbortext.com<\/email>\n+        -->\n+\n+<!ENTITY % email.attlist \"INCLUDE\">\n+<![%email.attlist;[\n+<!ATTLIST email\n+        %common.att;\n+        %simple-xlink.att;\n+        %href-req.att;\n+        %user-new.att;>\n+]]>\n+\n+<!--\n+#1998-05-15: maler: Changed status content from %statusobj.mix;\n+#                   to plain %obj.mix;.  statusp is obsolete.\n+-->\n+\n+<!ENTITY % status.element \"INCLUDE\">\n+<![%status.element;[\n+<!ELEMENT status (%obj.mix;)+>\n+]]>\n+<!ENTITY % status.attlist \"INCLUDE\">\n+<![%status.attlist;[\n+<!ATTLIST status %common.att;>\n+]]>\n+\n+<!ENTITY % abstract.element \"INCLUDE\">\n+<![%abstract.element;[\n+<!ELEMENT abstract (%hdr.mix;)*>\n+]]>\n+<!ENTITY % abstract.attlist \"INCLUDE\">\n+<![%abstract.attlist;[\n+<!ATTLIST abstract %common.att;>\n+]]>\n+\n+<!ENTITY % pubstmt.element \"INCLUDE\">\n+<![%pubstmt.element;[\n+<!ELEMENT pubstmt (%hdr.mix;)+>\n+]]>\n+<!ENTITY % pubstmt.attlist \"INCLUDE\">\n+<![%pubstmt.attlist;[\n+<!ATTLIST pubstmt %common.att;>\n+]]>\n+\n+<!ENTITY % sourcedesc.element \"INCLUDE\">\n+<![%sourcedesc.element;[\n+<!ELEMENT sourcedesc (%hdr.mix;)+>\n+]]>\n+<!ENTITY % sourcedesc.attlist \"INCLUDE\">\n+<![%sourcedesc.attlist;[\n+<!ATTLIST sourcedesc %common.att;>\n+]]>\n+\n+<!ENTITY % langusage.element \"INCLUDE\">\n+<![%langusage.element;[\n+<!ELEMENT langusage (language+)>\n+]]>\n+<!ENTITY % langusage.attlist \"INCLUDE\">\n+<![%langusage.attlist;[\n+<!ATTLIST langusage %common.att;>\n+]]>\n+\n+<!ENTITY % language.element \"INCLUDE\">\n+<![%language.element;[\n+<!ELEMENT language (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % language.attlist \"INCLUDE\">\n+<![%language.attlist;[\n+<!ATTLIST language %common.att;>\n+]]>\n+\n+<!ENTITY % revisiondesc.element \"INCLUDE\">\n+<![%revisiondesc.element;[\n+<!ELEMENT revisiondesc (%hdr.mix;)+>\n+]]>\n+<!ENTITY % revisiondesc.attlist \"INCLUDE\">\n+<![%revisiondesc.attlist;[\n+<!ATTLIST revisiondesc %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Paragraph ..................................................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1997-09-30: maler: Changed from %obj.mix; to %p.mix;.\n+#1997-12-29: maler: Changed order of %p.mix; and %p.pcd.mix;\n+#                   references.\n+#1997-12-29: maler: Changed order of %statusobj.mix; and\n+#                   %statusp.pcd.mix; references.\n+#1998-05-14: maler: Removed statusp declarations.\n+-->\n+\n+<!ENTITY % p.element \"INCLUDE\">\n+<![%p.element;[\n+<!ELEMENT p (%p.pcd.mix;|%p.mix;)*>\n+]]>\n+<!ENTITY % p.attlist \"INCLUDE\">\n+<![%p.attlist;[\n+<!ATTLIST p %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Regular lists ................................................. -->\n+<!-- ............................................................... -->\n+\n+<!--    ulist: Unordered list, typically bulleted. -->\n+<!ENTITY % ulist.element \"INCLUDE\">\n+<![%ulist.element;[\n+<!ELEMENT ulist (item+)>\n+]]>\n+<!--    spacing attribute:\n+        Use \"normal\" to get normal vertical spacing for items;\n+        use \"compact\" to get less spacing.  The default is dependent\n+        on the stylesheet. -->\n+<!ENTITY % ulist.attlist \"INCLUDE\">\n+<![%ulist.attlist;[\n+<!ATTLIST ulist\n+        %common.att;\n+        spacing         (normal|compact)        #IMPLIED>\n+]]>\n+\n+<!--    olist: Ordered list, typically numbered. -->\n+<!ENTITY % olist.element \"INCLUDE\">\n+<![%olist.element;[\n+<!ELEMENT olist (item+)>\n+]]>\n+<!--    spacing attribute:\n+        Use \"normal\" to get normal vertical spacing for items;\n+        use \"compact\" to get less spacing.  The default is dependent\n+        on the stylesheet. -->\n+<!ENTITY % olist.attlist \"INCLUDE\">\n+<![%olist.attlist;[\n+<!ATTLIST olist\n+        %common.att;\n+        spacing         (normal|compact)        #IMPLIED>\n+]]>\n+\n+<!ENTITY % item.element \"INCLUDE\">\n+<![%item.element;[\n+<!ELEMENT item (%obj.mix;)+>\n+]]>\n+<!ENTITY % item.attlist \"INCLUDE\">\n+<![%item.attlist;[\n+<!ATTLIST item %common.att;>\n+]]>\n+\n+<!--    slist: Simple list, typically with no mark. -->\n+<!ENTITY % slist.element \"INCLUDE\">\n+<![%slist.element;[\n+<!ELEMENT slist (sitem+)>\n+]]>\n+<!ENTITY % slist.attlist \"INCLUDE\">\n+<![%slist.attlist;[\n+<!ATTLIST slist %common.att;>\n+]]>\n+\n+<!ENTITY % sitem.element \"INCLUDE\">\n+<![%sitem.element;[\n+<!ELEMENT sitem (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % sitem.attlist \"INCLUDE\">\n+<![%sitem.attlist;[\n+<!ATTLIST sitem %common.att;>\n+]]>\n+\n+<!--    glist: Glossary list, typically two-column. -->\n+<!ENTITY % glist.element \"INCLUDE\">\n+<![%glist.element;[\n+<!ELEMENT glist (gitem+)>\n+]]>\n+<!ENTITY % glist.attlist \"INCLUDE\">\n+<![%glist.attlist;[\n+<!ATTLIST glist %common.att;>\n+]]>\n+\n+<!ENTITY % gitem.element \"INCLUDE\">\n+<![%gitem.element;[\n+<!ELEMENT gitem (label, def)>\n+]]>\n+<!ENTITY % gitem.attlist \"INCLUDE\">\n+<![%gitem.attlist;[\n+<!ATTLIST gitem %common.att;>\n+]]>\n+\n+<!ENTITY % label.element \"INCLUDE\">\n+<![%label.element;[\n+<!ELEMENT label (%label.pcd.mix;)*>\n+]]>\n+<!ENTITY % label.attlist \"INCLUDE\">\n+<![%label.attlist;[\n+<!ATTLIST label %common.att;>\n+]]>\n+\n+<!ENTITY % def.element \"INCLUDE\">\n+<![%def.element;[\n+<!ELEMENT def (%obj.mix;)*>\n+]]>\n+<!ENTITY % def.attlist \"INCLUDE\">\n+<![%def.attlist;[\n+<!ATTLIST def %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Special lists ................................................. -->\n+<!-- ............................................................... -->\n+\n+<!--    blist: Bibliography list. -->\n+<!ENTITY % blist.element \"INCLUDE\">\n+<![%blist.element;[\n+<!ELEMENT blist (bibl+)>\n+]]>\n+<!ENTITY % blist.attlist \"INCLUDE\">\n+<![%blist.attlist;[\n+<!ATTLIST blist %common.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Added show\/actuate attributes and default values.\n+-->\n+\n+<!ENTITY % bibl.element \"INCLUDE\">\n+<![%bibl.element;[\n+<!ELEMENT bibl (%bibl.pcd.mix;)*>\n+]]>\n+<!--    href attribute:\n+        bibl optionally functions as a hypertext reference to the\n+        referred-to resource through this attribute.  E.g.:\n+\n+        <bibl href=\"http:\/\/www.my.com\/doc.htm\">My Document<\/bibl>\n+        -->\n+<!ENTITY % bibl.attlist \"INCLUDE\">\n+<![%bibl.attlist;[\n+<!ATTLIST bibl\n+        %common.att;\n+        %simple-xlink.att;\n+        %href.att;\n+        %user-replace.att;\n+        %key.att;>\n+]]>\n+\n+<!--    orglist: Organization member list. -->\n+<!ENTITY % orglist.element \"INCLUDE\">\n+<![%orglist.element;[\n+<!ELEMENT orglist (member+)>\n+]]>\n+<!ENTITY % orglist.attlist \"INCLUDE\">\n+<![%orglist.attlist;[\n+<!ATTLIST orglist %common.att;>\n+]]>\n+\n+<!--\n+#1997-09-30: maler: Added optional affiliation.\n+-->\n+\n+<!ENTITY % member.element \"INCLUDE\">\n+<![%member.element;[\n+<!ELEMENT member (name, affiliation?, role?)>\n+]]>\n+<!ENTITY % member.attlist \"INCLUDE\">\n+<![%member.attlist;[\n+<!ATTLIST member %common.att;>\n+]]>\n+\n+<!--      name (defined in \"Specification header\" above) -->\n+<!--      affiliation (defined in \"Specification header\" above) -->\n+\n+<!ENTITY % role.element \"INCLUDE\">\n+<![%role.element;[\n+<!ELEMENT role (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % role.attlist \"INCLUDE\">\n+<![%role.attlist;[\n+<!ATTLIST role %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Notes ......................................................... -->\n+<!-- ............................................................... -->\n+\n+<!ENTITY % note.element \"INCLUDE\">\n+<![%note.element;[\n+<!ELEMENT note (%obj.mix;)+>\n+]]>\n+<!ENTITY % note.attlist \"INCLUDE\">\n+<![%note.attlist;[\n+<!ATTLIST note %common.att;>\n+]]>\n+\n+<!--\n+#1998-05-14: maler: Declared issue element.\n+#2000-03-07: maler: Added head, source, resolution, and status.\n+-->\n+\n+<!ENTITY % issue.element \"INCLUDE\">\n+<![%issue.element;[\n+<!ELEMENT issue (head?, source*, (%obj.mix;)+, resolution?)>\n+]]>\n+<!--    status attribute:\n+        Indicates whether the issue is open or closed.  Note that\n+        the lack of a resolution element does not necessarily mean\n+        that the issue is still open. -->\n+<!ENTITY % issue.attlist \"INCLUDE\">\n+<![%issue.attlist;[\n+<!ATTLIST issue\n+        id              ID              #REQUIRED\n+        %role.att;\n+        %diff.att;\n+        status          (open\n+                        |closed)        \"open\"\n+>\n+]]>\n+\n+<!ENTITY % source.element \"INCLUDE\">\n+<![%source.element;[\n+<!ELEMENT source (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % source.attlist \"INCLUDE\">\n+<![%source.attlist;[\n+<!ATTLIST source\n+        %common.att;>\n+]]>\n+\n+<!ENTITY % resolution.element \"INCLUDE\">\n+<![%resolution.element;[\n+<!ELEMENT resolution (%obj.mix;)+>\n+]]>\n+<!ENTITY % resolution.attlist \"INCLUDE\">\n+<![%resolution.attlist;[\n+<!ATTLIST resolution %common.att;>\n+]]>\n+\n+<!--    wfcnote: Well-formedness constraint note. -->\n+<!ENTITY % wfcnote.element \"INCLUDE\">\n+<![%wfcnote.element;[\n+<!ELEMENT wfcnote (head, (%obj.mix;)+)>\n+]]>\n+<!--    ID attribute:\n+        wfcnote must have an ID so that it can be pointed to\n+        from a wfc element in a production. -->\n+<!ENTITY % wfcnote.attlist \"INCLUDE\">\n+<![%wfcnote.attlist;[\n+<!ATTLIST wfcnote\n+        %common-idreq.att;>\n+]]>\n+\n+<!--    vcnote: Validity constraint note. -->\n+<!ENTITY % vcnote.element \"INCLUDE\">\n+<![%vcnote.element;[\n+<!ELEMENT vcnote (head, (%obj.mix;)+)>\n+]]>\n+<!--    ID attribute:\n+        vcnote must have an ID so that it can be pointed to\n+        from a vc element in a production. -->\n+<!ENTITY % vcnote.attlist \"INCLUDE\">\n+<![%vcnote.attlist;[\n+<!ATTLIST vcnote\n+        %common-idreq.att;>\n+]]>\n+\n+<!--\n+#1998-05-21: maler: Declared generic constraintnote element.\n+-->\n+\n+<!--    constraintnote: Generic constraint note. -->\n+<!ENTITY % constraintnote.element \"INCLUDE\">\n+<![%constraintnote.element;[\n+<!ELEMENT constraintnote (head, (%obj.mix;)+)>\n+]]>\n+<!--    ID attribute:\n+        constraintnote must have an ID so that it can be\n+        pointed to from a constraint element in a production. -->\n+<!--    type attribute:\n+        constraintnote must have a type value keyword so that\n+        it can be correctly characterized in the specification. -->\n+<!ENTITY % constraintnote.attlist \"INCLUDE\">\n+<![%constraintnote.attlist;[\n+<!ATTLIST constraintnote\n+        %common-idreq.att;\n+        type            NMTOKEN         #REQUIRED>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Basic display elements ........................................ -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1998-03-23: maler: Added xml:space attribute.\n+-->\n+\n+<!--    eg: Example element, with whitespace respected. -->\n+<!ENTITY % eg.element \"INCLUDE\">\n+<![%eg.element;[\n+<!ELEMENT eg (%eg.pcd.mix;)*>\n+]]>\n+<!ENTITY % eg.attlist \"INCLUDE\">\n+<![%eg.attlist;[\n+<!ATTLIST eg\n+        %common.att;\n+        %xmlspace.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Removed the xml:attributes attribute.\n+#                   Added %local.graphic.att;.\n+-->\n+\n+<!--    graphic: Displayed graphic.  Graphic data should be\n+        displayed at the point where it is referenced.  Not\n+        actually conforming to XLink right now. -->\n+<!ENTITY % graphic.element \"INCLUDE\">\n+<![%graphic.element;[\n+<!ELEMENT graphic EMPTY>\n+]]>\n+<!--    source attribute:\n+        The graphic data must reside at the location pointed to. -->\n+<!ENTITY % local.graphic.att \" \">\n+<!ENTITY % graphic.attlist \"INCLUDE\">\n+<![%graphic.attlist;[\n+<!ATTLIST graphic\n+        %common.att;\n+        %simple-xlink.att;\n+        source                  CDATA           #REQUIRED\n+        %auto-embed.att;\n+        alt                     CDATA           #IMPLIED\n+        %local.graphic.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Added proto element structure.\n+-->\n+\n+<!--    proto: Function prototype, in the XPath\/XPointer style. -->\n+<!ENTITY % proto.element \"INCLUDE\">\n+<![%proto.element;[\n+<!ELEMENT proto (arg*)>\n+]]>\n+\n+<!ENTITY % local.proto.att \" \">\n+<!ENTITY % proto.attlist \"INCLUDE\">\n+<![%proto.attlist;[\n+<!ATTLIST proto\n+        %common.att;\n+\t%local.proto.att;\n+        name            NMTOKEN         #REQUIRED\n+        return-type     %argtypes;      #REQUIRED\n+>\n+]]>\n+\n+<!ENTITY % local.arg.att \" \">\n+<!ENTITY % arg.element \"INCLUDE\">\n+<![%arg.element;[\n+<!ELEMENT arg EMPTY>\n+]]>\n+<!ENTITY % arg.attlist \"INCLUDE\">\n+<![%arg.attlist;[\n+<!ATTLIST arg\n+        %common.att;\n+\t%local.arg.att;\n+        type            %argtypes;      #REQUIRED\n+        occur           (opt|req)       #IMPLIED\n+>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Added example element.\n+-->\n+\n+<!ENTITY % example.element \"INCLUDE\">\n+<![%example.element;[\n+<!ELEMENT example (head?, (%obj.mix;)+)>\n+]]>\n+<!ENTITY % example.attlist \"INCLUDE\">\n+<![%example.attlist;[\n+<!ATTLIST example %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- EBNF .......................................................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1997-11-28: maler: Added prodgroup to scrap and defined it.\n+#1998-05-21: maler: Added constraint to prod.\n+#1999-07-02: maler: Added prodrecap to scrap; broadened scrap model.\n+#                   Added headstyle attribute to scrap.\n+-->\n+\n+<!--    scrap: Collection of EBNF language productions. -->\n+<!ENTITY % scrap.element \"INCLUDE\">\n+<![%scrap.element;[\n+<!ELEMENT scrap (head, (prodgroup | prod | bnf | prodrecap)+)>\n+]]>\n+<!--    lang attribute:\n+        The scrap can link to a description of the language used,\n+        found in a language element in the header.\n+        headstyle attribute:\n+        Allows a scrap title to be suppressed from output.  To be\n+        used only when a scrap title directly next to a section\n+        title is distracting or repetetive. -->\n+<!ENTITY % scrap.attlist \"INCLUDE\">\n+<![%scrap.attlist;[\n+<!ATTLIST scrap\n+        %common.att;\n+        lang            IDREF           #IMPLIED\n+        headstyle       (show|suppress) \"show\"\n+>\n+]]>\n+\n+<!--    prodgroup: Sub-collection of productions, needed for\n+        formatting reasons. -->\n+<!ENTITY % prodgroup.element \"INCLUDE\">\n+<![%prodgroup.element;[\n+<!ELEMENT prodgroup (prod+)>\n+]]>\n+<!--    pcw<n> attributes:\n+        Presentational attributes to control the width\n+        of the \"pseudo-table\" columns used to output\n+        groups of productions. -->\n+<!ENTITY % prodgroup.attlist \"INCLUDE\">\n+<![%prodgroup.attlist;[\n+<!ATTLIST prodgroup\n+        %common.att;\n+        pcw1            CDATA           #IMPLIED\n+        pcw2            CDATA           #IMPLIED\n+        pcw3            CDATA           #IMPLIED\n+        pcw4            CDATA           #IMPLIED\n+        pcw5            CDATA           #IMPLIED\n+>\n+]]>\n+\n+<!--    prod: EBNF language production. -->\n+<!ENTITY % prod.element \"INCLUDE\">\n+<![%prod.element;[\n+<!ELEMENT prod (lhs, (rhs, (com|wfc|vc|constraint)*)+)>\n+]]>\n+<!--    ID attribute:\n+        The production must have an ID so that cross-references\n+        (specref) and mentions of nonterminals (nt) can link to\n+        it. -->\n+<!ENTITY % prod.attlist \"INCLUDE\">\n+<![%prod.attlist;[\n+<!ATTLIST prod\n+        %common-idreq.att;\n+\tnum\tCDATA\t#IMPLIED>\n+]]>\n+\n+<!--    lhs: Left-hand side of production. -->\n+<!ENTITY % lhs.element \"INCLUDE\">\n+<![%lhs.element;[\n+<!ELEMENT lhs (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % lhs.attlist \"INCLUDE\">\n+<![%lhs.attlist;[\n+<!ATTLIST lhs %common.att;>\n+]]>\n+\n+<!--    rhs: Right-hand side of production; may have many\n+        \"right-hand sides,\" one to a line. -->\n+<!ENTITY % rhs.element \"INCLUDE\">\n+<![%rhs.element;[\n+<!ELEMENT rhs (#PCDATA|phrase|nt|xnt|com)*>\n+]]>\n+<!ENTITY % rhs.attlist \"INCLUDE\">\n+<![%rhs.attlist;[\n+<!ATTLIST rhs %common.att;>\n+]]>\n+\n+<!--      nt and xnt (defined in \"Phrase-level elements\" below) -->\n+\n+<!--\n+#1997-11-28: maler: Added loc and bibref to com content.\n+-->\n+\n+<!--    com: Production comment. -->\n+<!ENTITY % com.element \"INCLUDE\">\n+<![%com.element;[\n+<!ELEMENT com (#PCDATA|phrase|loc|bibref)*>\n+]]>\n+<!ENTITY % com.attlist \"INCLUDE\">\n+<![%com.attlist;[\n+<!ATTLIST com %common.att;>\n+]]>\n+\n+<!--    wfc: Reference to a well-formedness constraint; should\n+        generate the head of the wfcnote pointed to. -->\n+<!ENTITY % wfc.element \"INCLUDE\">\n+<![%wfc.element;[\n+<!ELEMENT wfc EMPTY>\n+]]>\n+<!--    def attribute:\n+        Each well formedness tagline in a production must link to the\n+        wfcnote that defines it. -->\n+<!ENTITY % wfc.attlist \"INCLUDE\">\n+<![%wfc.attlist;[\n+<!ATTLIST wfc\n+        %def-req.att;\n+        %common.att;>\n+]]>\n+\n+<!--    vc: Reference to a validity constraint; should generate\n+        the head of the vcnote pointed to. -->\n+<!ENTITY % vc.element \"INCLUDE\">\n+<![%vc.element;[\n+<!ELEMENT vc EMPTY>\n+]]>\n+<!--    def attribute:\n+        Each validity tagline in a production must link to the vcnote\n+        that defines it. -->\n+<!ENTITY % vc.attlist \"INCLUDE\">\n+<![%vc.attlist;[\n+<!ATTLIST vc\n+        %def-req.att;\n+        %common.att;>\n+]]>\n+\n+<!--\n+#1998-05-21: maler: Declared generic constraint element.\n+-->\n+\n+<!--    constraint: Reference to a generic constraint; should\n+        generate the head of the constraintnote pointed to. -->\n+<!ENTITY % constraint.element \"INCLUDE\">\n+<![%constraint.element;[\n+<!ELEMENT constraint EMPTY>\n+]]>\n+<!--    def attribute:\n+        Each constraint tagline in a production must link to the\n+        constraint note that defines it. -->\n+<!ENTITY % constraint.attlist \"INCLUDE\">\n+<![%constraint.attlist;[\n+<!ATTLIST constraint\n+        %def-req.att;\n+        %common.att;>\n+]]>\n+\n+<!--\n+#1998-03-23: maler: Added xml:space attribute.\n+-->\n+\n+<!--    bnf: Un-marked-up EBNF production, with whitespace\n+        respected. -->\n+<!ENTITY % bnf.element \"INCLUDE\">\n+<![%bnf.element;[\n+<!ELEMENT bnf (%eg.pcd.mix;)*>\n+]]>\n+<!ENTITY % bnf.attlist \"INCLUDE\">\n+<![%bnf.attlist;[\n+<!ATTLIST bnf\n+        %common.att;\n+        %xmlspace.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Declared prodrecap.\n+-->\n+\n+<!--    prodrecap: Reference to production or bnf that appears\n+        in its \"normative\" form elsewhere in the spec; should\n+        generate a copy of the original production, without\n+        a production number next to it. -->\n+<!ENTITY % prodrecap.element \"INCLUDE\">\n+<![%prodrecap.element;[\n+<!ELEMENT prodrecap EMPTY>\n+]]>\n+<!ENTITY % prodrecap.attlist \"INCLUDE\">\n+<![%prodrecap.attlist;[\n+<!ATTLIST prodrecap\n+        %common.att;\n+        %ref-req.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Table ......................................................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1997-10-16: maler: Added table mechanism.\n+#1997-11-28: maler: Added non-null system ID to entity declaration.\n+#                   Added HTML table module.\n+#1997-12-29: maler: IGNOREd SGML Open table model.\n+#1998-03-10: maler: Removed SGML Open table model.\n+#                   Merged html-tbl.mod file into main file.\n+#                   Added %common.att; to all HTML table elements.\n+#1998-05-14: maler: Replaced table model with full HTML 4.0 model.\n+#                   Removed htable in favor of table.\n+#                   Removed htbody in favor of tbody.\n+-->\n+\n+<!ENTITY % cellhalign.att\n+        'align          (left|center\n+                        |right|justify\n+                        |char)          #IMPLIED\n+        char            CDATA           #IMPLIED\n+        charoff         CDATA           #IMPLIED'>\n+\n+<!ENTITY % cellvalign.att\n+        'valign         (top|middle\n+                        |bottom\n+                        |baseline)      #IMPLIED'>\n+\n+<!ENTITY % thtd.att\n+        'abbr           CDATA           #IMPLIED\n+        axis            CDATA           #IMPLIED\n+        headers         IDREFS          #IMPLIED\n+        scope           (row\n+                        |col\n+                        |rowgroup\n+                        |colgroup)      #IMPLIED\n+        rowspan         NMTOKEN         \"1\"\n+        colspan         NMTOKEN         \"1\"'>\n+\n+<!ENTITY % width.att\n+        'width          CDATA           #IMPLIED'>\n+\n+<!ENTITY % span.att\n+        'span           NMTOKEN         \"1\"'>\n+\n+<!--    table: HTML-based geometric table model. -->\n+<!ENTITY % table.element \"INCLUDE\">\n+<![%table.element;[\n+<!ELEMENT table\n+        (caption?, (col*|colgroup*), thead?, tfoot?, tbody+)>\n+]]>\n+<!ENTITY % table.attlist \"INCLUDE\">\n+<![%table.attlist;[\n+<!ATTLIST table\n+        %common.att;\n+        %width.att;\n+        summary         CDATA           #IMPLIED\n+        border          CDATA           #IMPLIED\n+        frame           (void|above\n+                        |below|hsides\n+                        |lhs|rhs\n+                        |vsides|box\n+                        |border)        #IMPLIED\n+        rules           (none|groups\n+                        |rows|cols\n+                        |all)           #IMPLIED\n+        cellspacing     CDATA           #IMPLIED\n+        cellpadding     CDATA           #IMPLIED>\n+]]>\n+\n+<!ENTITY % caption.element \"INCLUDE\">\n+<![%caption.element;[\n+<!ELEMENT caption (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % caption.attlist \"INCLUDE\">\n+<![%caption.attlist;[\n+<!ATTLIST caption %common.att;>\n+]]>\n+\n+<!ENTITY % col.element \"INCLUDE\">\n+<![%col.element;[\n+<!ELEMENT col EMPTY>\n+]]>\n+<!ENTITY % col.attlist \"INCLUDE\">\n+<![%col.attlist;[\n+<!ATTLIST col\n+        %common.att;\n+        %span.att;\n+        %width.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!ENTITY % colgroup.element \"INCLUDE\">\n+<![%colgroup.element;[\n+<!ELEMENT colgroup (col)*>\n+]]>\n+<!ENTITY % colgroup.attlist \"INCLUDE\">\n+<![%colgroup.attlist;[\n+<!ATTLIST colgroup\n+        %common.att;\n+        %span.att;\n+        %width.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!ENTITY % thead.element \"INCLUDE\">\n+<![%thead.element;[\n+<!ELEMENT thead (tr)+>\n+]]>\n+<!ENTITY % thead.attlist \"INCLUDE\">\n+<![%thead.attlist;[\n+<!ATTLIST thead\n+        %common.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!ENTITY % tfoot.element \"INCLUDE\">\n+<![%tfoot.element;[\n+<!ELEMENT tfoot (tr)+>\n+]]>\n+<!ENTITY % tfoot.attlist \"INCLUDE\">\n+<![%tfoot.attlist;[\n+<!ATTLIST tfoot\n+        %common.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!ENTITY % tbody.element \"INCLUDE\">\n+<![%tbody.element;[\n+<!ELEMENT tbody (tr)+>\n+]]>\n+<!ENTITY % tbody.attlist \"INCLUDE\">\n+<![%tbody.attlist;[\n+<!ATTLIST tbody\n+        %common.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!ENTITY % tr.element \"INCLUDE\">\n+<![%tr.element;[\n+<!ELEMENT tr (th|td)+>\n+]]>\n+<!ENTITY % tr.attlist \"INCLUDE\">\n+<![%tr.attlist;[\n+<!ATTLIST tr\n+        %common.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!ENTITY % th.element \"INCLUDE\">\n+<![%th.element;[\n+<!ELEMENT th (%p.pcd.mix;|%p.mix;)*>\n+]]>\n+<!ENTITY % th.attlist \"INCLUDE\">\n+<![%th.attlist;[\n+<!ATTLIST th\n+        %common.att;\n+        %thtd.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!ENTITY % td.element \"INCLUDE\">\n+<![%td.element;[\n+<!ELEMENT td (%p.pcd.mix;|%p.mix;)*>\n+]]>\n+<!ENTITY % td.attlist \"INCLUDE\">\n+<![%td.attlist;[\n+<!ATTLIST td\n+        %common.att;\n+        %thtd.att;\n+        %cellhalign.att;\n+        %cellvalign.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- IDL structures for DOM specifications ......................... -->\n+<!-- ............................................................... -->\n+\n+<!-- ............................................................... -->\n+<!-- Specialized entities for classes .............................. -->\n+\n+<!ENTITY % idl-desc.class\n+        \"p|note\">\n+\n+<!ENTITY % idl-tdef.class\n+        \"typedef|constant|exception|reference|group\">\n+\n+<!ENTITY % idl-mod.class\n+        \"module|interface\">\n+\n+<!ENTITY % idl-struct.class\n+        \"struct|enum|sequence|union|typename\">\n+\n+<!ENTITY % idl-meth.class\n+        \"method|attribute\">\n+\n+<!-- ............................................................... -->\n+<!-- Specialized entities for mixtures ............................. -->\n+\n+<!--    Quick reference to content model mixtures:\n+\n+                        desc tdef mod struct meth\n+group                     x    x   x    x      x\n+definitions, module       x    x   x\n+interface                 x    x               x\n+typedef, case, component                x\n+-->\n+\n+<!ENTITY % idl-grp.mix\n+        \"%idl-desc.class;|%idl-tdef.class;|%idl-mod.class;\n+        |%idl-struct.class;|%idl-meth.class;\">\n+\n+<!ENTITY % idl-defn.mix\n+        \"%idl-desc.class;|%idl-tdef.class;|%idl-mod.class;\">\n+\n+<!ENTITY % idl-intfc.mix\n+        \"%idl-desc.class;|%idl-tdef.class;|%idl-meth.class;\">\n+\n+<!ENTITY % idl-type.mix\n+        \"%idl-struct.class;\">\n+\n+<!-- ............................................................... -->\n+<!-- Specialized entities for common attributes .................... -->\n+\n+<!--    name attribute:\n+        Provides a name.  Required. -->\n+<!ENTITY % idl-name.att\n+        'name                   CDATA           #REQUIRED'>\n+\n+<!--    type attribute:\n+        Provides a type.  Required. -->\n+<!ENTITY % idl-type.att\n+        'type                   CDATA           #REQUIRED'>\n+\n+<!-- ............................................................... -->\n+<!-- Common IDL element ............................................ -->\n+\n+<!ENTITY % descr.element \"INCLUDE\">\n+<![%descr.element;[\n+<!ELEMENT descr ((%obj.mix;)*)>\n+]]>\n+<!ENTITY % descr.attlist \"INCLUDE\">\n+<![%descr.attlist;[\n+<!ATTLIST descr %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- IDL definition elements ....................................... -->\n+\n+<!--    definitions: Top-level element for definitions. -->\n+<!ENTITY % definitions.element \"INCLUDE\">\n+<![%definitions.element;[\n+<!ELEMENT definitions (%idl-defn.mix;)+>\n+]]>\n+<!ENTITY % definitions.attlist \"INCLUDE\">\n+<![%definitions.attlist;[\n+<!ATTLIST definitions %common.att;>\n+]]>\n+\n+<!--    group: Element used to group a set of definitions. -->\n+\n+<!ENTITY % group.element \"INCLUDE\">\n+<![%group.element;[\n+<!ELEMENT group (descr, (%idl-grp.mix;)*)>\n+]]>\n+<!ENTITY % group.attlist \"INCLUDE\">\n+<![%group.attlist;[\n+<!ATTLIST group\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+\n+<!--    interface: Definition of an interface. -->\n+<!ENTITY % interface.element \"INCLUDE\">\n+<![%interface.element;[\n+<!ELEMENT interface (descr, (%idl-intfc.mix;)*)>\n+]]>\n+<!ENTITY % interface.attlist \"INCLUDE\">\n+<![%interface.attlist;[\n+<!ATTLIST interface\n+        %common.att;\n+        %idl-name.att;\n+        inherits        CDATA           #IMPLIED>\n+]]>\n+\n+<!--    module: Definition of a module. -->\n+<!ENTITY % module.element \"INCLUDE\">\n+<![%module.element;[\n+<!ELEMENT module (descr, (%idl-defn.mix;)*)>\n+]]>\n+<!ENTITY % module.attlist \"INCLUDE\">\n+<![%module.attlist;[\n+<!ATTLIST module\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+\n+<!--    reference: Reference to some other declaration. -->\n+<!ENTITY % reference.element \"INCLUDE\">\n+<![%reference.element;[\n+<!ELEMENT reference EMPTY>\n+]]>\n+<!ENTITY % reference.attlist \"INCLUDE\">\n+<![%reference.attlist;[\n+<!ATTLIST reference\n+        %common.att;\n+        declaration     IDREF           #REQUIRED>\n+]]>\n+\n+<!--    typedef: Definition of a named type. -->\n+<!ENTITY % typedef.element \"INCLUDE\">\n+<![%typedef.element;[\n+<!ELEMENT typedef (descr, (%idl-type.mix;))>\n+]]>\n+<!ENTITY % typedef.attlist \"INCLUDE\">\n+<![%typedef.attlist;[\n+<!ATTLIST typedef\n+        %common.att;\n+        %idl-name.att;\n+        array.size      NMTOKEN         #IMPLIED>\n+]]>\n+\n+<!--    struct: Declaration of a struct type. -->\n+<!ENTITY % struct.element \"INCLUDE\">\n+<![%struct.element;[\n+<!ELEMENT struct (descr, component+)>\n+]]>\n+<!ENTITY % struct.attlist \"INCLUDE\">\n+<![%struct.attlist;[\n+<!ATTLIST struct\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+\n+<!--    component: Declaration of a structural member. -->\n+<!ENTITY % component.element \"INCLUDE\">\n+<![%component.element;[\n+<!ELEMENT component (%idl-type.mix;)>\n+]]>\n+<!ENTITY % component.attlist \"INCLUDE\">\n+<![%component.attlist;[\n+<!ATTLIST component\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+\n+<!--    union: Declaration of a union type. -->\n+<!ENTITY % union.element \"INCLUDE\">\n+<![%union.element;[\n+<!ELEMENT union (descr, case+)>\n+]]>\n+<!ENTITY % union.attlist \"INCLUDE\">\n+<![%union.attlist;[\n+<!ATTLIST union\n+        %common.att;\n+        %idl-name.att;\n+        switch.type     CDATA           #REQUIRED>\n+]]>\n+\n+<!ENTITY % case.element \"INCLUDE\">\n+<![%case.element;[\n+<!ELEMENT case (descr, (%idl-type.mix;))>\n+]]>\n+<!ENTITY % case.attlist \"INCLUDE\">\n+<![%case.attlist;[\n+<!ATTLIST case\n+        %common.att;\n+        labels          CDATA           #REQUIRED>\n+]]>\n+\n+<!--    enum: Declaration of an enum type. -->\n+<!ENTITY % enum.element \"INCLUDE\">\n+<![%enum.element;[\n+<!ELEMENT enum (descr, enumerator+)>\n+]]>\n+<!ENTITY % enum.attlist \"INCLUDE\">\n+<![%enum.attlist;[\n+<!ATTLIST enum\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+\n+<!ENTITY % enumerator.element \"INCLUDE\">\n+<![%enumerator.element;[\n+<!ELEMENT enumerator (descr)>\n+]]>\n+<!ENTITY % enumerator.attlist \"INCLUDE\">\n+<![%enumerator.attlist;[\n+<!ATTLIST enumerator\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+\n+<!--    sequence: Declaration of a sequence type (not named). -->\n+<!ENTITY % sequence.element \"INCLUDE\">\n+<![%sequence.element;[\n+<!ELEMENT sequence (sequence*)>\n+]]>\n+<!ENTITY % sequence.attlist \"INCLUDE\">\n+<![%sequence.attlist;[\n+<!ATTLIST sequence\n+        %common.att;\n+        %idl-type.att;\n+        size            NMTOKEN         #IMPLIED>\n+]]>\n+\n+<!--    constant: Declaration of a named constant. -->\n+<!ENTITY % constant.element \"INCLUDE\">\n+<![%constant.element;[\n+<!ELEMENT constant (descr)>\n+]]>\n+<!ENTITY % constant.attlist \"INCLUDE\">\n+<![%constant.attlist;[\n+<!ATTLIST constant\n+        %common.att;\n+        %idl-name.att;\n+        %idl-type.att;\n+        value           CDATA           #REQUIRED>\n+]]>\n+\n+<!--    exception: Declaration of an exception. -->\n+<!ENTITY % exception.element \"INCLUDE\">\n+<![%exception.element;[\n+<!ELEMENT exception (descr, component*)>\n+]]>\n+<!ENTITY % exception.attlist \"INCLUDE\">\n+<![%exception.attlist;[\n+<!ATTLIST exception\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+<!-- component (defined under struct, above)-->\n+\n+<!--    attribute: Declaration of an attribute (data member). -->\n+<!ENTITY % attribute.element \"INCLUDE\">\n+<![%attribute.element;[\n+<!ELEMENT attribute (descr)>\n+]]>\n+<!ENTITY % attribute.attlist \"INCLUDE\">\n+<![%attribute.attlist;[\n+<!ATTLIST attribute\n+        %common.att;\n+        %idl-name.att;\n+        %idl-type.att;\n+        readonly        (yes\n+                        |no)            \"no\">\n+]]>\n+\n+<!--    method: Declaration of a method. -->\n+<!ENTITY % method.element \"INCLUDE\">\n+<![%method.element;[\n+<!ELEMENT method (descr, parameters, returns, raises)>\n+]]>\n+<!ENTITY % method.attlist \"INCLUDE\">\n+<![%method.attlist;[\n+<!ATTLIST method\n+        %common.att;\n+        %idl-name.att;>\n+]]>\n+\n+<!ENTITY % parameters.element \"INCLUDE\">\n+<![%parameters.element;[\n+<!ELEMENT parameters (param*)>\n+]]>\n+<!ENTITY % parameters.attlist \"INCLUDE\">\n+<![%parameters.attlist;[\n+<!ATTLIST parameters %common.att;>\n+]]>\n+\n+<!ENTITY % param.element \"INCLUDE\">\n+<![%param.element;[\n+<!ELEMENT param (descr)>\n+]]>\n+<!ENTITY % param.attlist \"INCLUDE\">\n+<![%param.attlist;[\n+<!ATTLIST param\n+        %common.att;\n+        %idl-name.att;\n+        %idl-type.att;\n+        attr            (in\n+                        |out\n+                        |inout)         \"inout\">\n+]]>\n+\n+<!ENTITY % returns.element \"INCLUDE\">\n+<![%returns.element;[\n+<!ELEMENT returns (descr)>\n+]]>\n+<!ENTITY % returns.attlist \"INCLUDE\">\n+<![%returns.attlist;[\n+<!ATTLIST returns\n+        %common.att;\n+        %idl-type.att;>\n+]]>\n+\n+<!ENTITY % raises.element \"INCLUDE\">\n+<![%raises.element;[\n+<!ELEMENT raises (exception*)>\n+]]>\n+<!-- exception (defined under constant, above)-->\n+\n+<!ENTITY % typename.element \"INCLUDE\">\n+<![%typename.element;[\n+<!ELEMENT typename (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % typename.attlist \"INCLUDE\">\n+<![%typename.attlist;[\n+<!ATTLIST typename %common.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Phrase-level elements ......................................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#2000-03-07: maler: Added att and attval elements.\n+-->\n+\n+<!--    att: Attribute name. -->\n+<!ENTITY % att.element \"INCLUDE\">\n+<![%att.element;[\n+<!ELEMENT att (%tech.pcd.mix;)*>\n+]]>\n+<!ENTITY % att.attlist \"INCLUDE\">\n+<![%att.attlist;[\n+<!ATTLIST att %common.att;>\n+]]>\n+\n+<!--    attval: Attribute value. -->\n+<!ENTITY % attval.element \"INCLUDE\">\n+<![%attval.element;[\n+<!ELEMENT attval (%tech.pcd.mix;)*>\n+]]>\n+<!ENTITY % attval.attlist \"INCLUDE\">\n+<![%attval.attlist;[\n+<!ATTLIST attval %common.att;>\n+]]>\n+\n+<!--    bibref: Reference to a bibliography list entry; should\n+        generate, in square brackets, \"key\" on bibl. -->\n+<!ENTITY % bibref.element \"INCLUDE\">\n+<![%bibref.element;[\n+<!ELEMENT bibref EMPTY>\n+]]>\n+<!--    ref attribute:\n+        A bibliography reference must link to the bibl element that\n+        describes the resource. -->\n+<!ENTITY % bibref.attlist \"INCLUDE\">\n+<![%bibref.attlist;[\n+<!ATTLIST bibref\n+        %common.att;\n+        %ref-req.att;>\n+]]>\n+\n+<!ENTITY % code.element \"INCLUDE\">\n+<![%code.element;[\n+<!ELEMENT code (%tech.pcd.mix;)*>\n+]]>\n+<!ENTITY % code.attlist \"INCLUDE\">\n+<![%code.attlist;[\n+<!ATTLIST code %common.att;>\n+]]>\n+\n+<!--\n+#1998-03-10: maler: Declared ednote and related elements.\n+#1999-07-02: maler: Changed edtext content from #PCDATA to %p.pcd.mix;.\n+-->\n+\n+<!--    ednote: Editorial note for communication among editors. -->\n+<!ENTITY % ednote.element \"INCLUDE\">\n+<![%ednote.element;[\n+<!ELEMENT ednote (name?, date?, edtext)>\n+]]>\n+<!ENTITY % ednote.attlist \"INCLUDE\">\n+<![%ednote.attlist;[\n+<!ATTLIST ednote %common.att;>\n+]]>\n+\n+<!ENTITY % date.element \"INCLUDE\">\n+<![%date.element;[\n+<!ELEMENT date (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % date.attlist \"INCLUDE\">\n+<![%date.attlist;[\n+<!ATTLIST date %common.att;>\n+]]>\n+\n+<!ENTITY % edtext.element \"INCLUDE\">\n+<![%edtext.element;[\n+<!ELEMENT edtext (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % edtext.attlist \"INCLUDE\">\n+<![%edtext.attlist;[\n+<!ATTLIST edtext %common.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Added el element.\n+-->\n+\n+<!--    el: Element type name (GI). -->\n+<!ENTITY % el.element \"INCLUDE\">\n+<![%el.element;[\n+<!ELEMENT el (%tech.pcd.mix;)*>\n+]]>\n+<!ENTITY % el.attlist \"INCLUDE\">\n+<![%el.attlist;[\n+<!ATTLIST el %common.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Expanded emph to %p.pcd.mix;.\n+-->\n+\n+<!ENTITY % emph.element \"INCLUDE\">\n+<![%emph.element;[\n+<!ELEMENT emph (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % emph.attlist \"INCLUDE\">\n+<![%emph.attlist;[\n+<!ATTLIST emph %common.att;>\n+]]>\n+\n+<!--    footnote: Both footnote content and call to footnote. -->\n+<!ENTITY % footnote.element \"INCLUDE\">\n+<![%footnote.element;[\n+<!ELEMENT footnote (%obj.mix;)+>\n+]]>\n+<!ENTITY % footnote.attlist \"INCLUDE\">\n+<![%footnote.attlist;[\n+<!ATTLIST footnote %common.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Added function and gave it content of\n+#                   %tech.pcd.mix; instead of XPath's #PCDATA.\n+-->\n+\n+<!ENTITY % function.element \"INCLUDE\">\n+<![%function.element;[\n+<!ELEMENT function (%tech.pcd.mix;)*>\n+]]>\n+<!ENTITY % function.attlist \"INCLUDE\">\n+<![%function.attlist;[\n+<!ATTLIST function %common.att;>\n+]]>\n+\n+<!ENTITY % kw.element \"INCLUDE\">\n+<![%kw.element;[\n+<!ELEMENT kw (%tech.pcd.mix;)*>\n+]]>\n+<!ENTITY % kw.attlist \"INCLUDE\">\n+<![%kw.attlist;[\n+<!ATTLIST kw %common.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Added show\/actuate attributes and default values.\n+-->\n+\n+<!--    loc: Generic link to a Web resource, similar to HTML's A. -->\n+<!ENTITY % loc.element \"INCLUDE\">\n+<![%loc.element;[\n+<!ELEMENT loc (#PCDATA|phrase)*>\n+]]>\n+<!--    href attribute:\n+        The purpose of a loc element is to function as a A-like\n+        hypertext link to a resource.  (Ideally, the content of loc\n+        will also mention the URI of the resource, so that readers of\n+        the printed version will be able to locate the resource.) E.g.:\n+\n+<loc href=\"http:\/\/www.my.com\/doc.htm\">http:\/\/www.my.com\/doc.htm<\/loc>\n+        -->\n+<!ENTITY % loc.attlist \"INCLUDE\">\n+<![%loc.attlist;[\n+<!ATTLIST loc\n+        %common.att;\n+        %simple-xlink.att;\n+        %href-req.att;\n+        %user-replace.att;>\n+]]>\n+\n+<!--    nt: Mention of a nonterminal in text, along with a link to\n+        the production in the current document that defines it. -->\n+<!ENTITY % nt.element \"INCLUDE\">\n+<![%nt.element;[\n+<!ELEMENT nt (#PCDATA|phrase)*>\n+]]>\n+<!--    def attribute:\n+        The nonterminal must link to the production that defines\n+        it. -->\n+<!ENTITY % nt.attlist \"INCLUDE\">\n+<![%nt.attlist;[\n+<!ATTLIST nt\n+        %common.att;\n+        %def-req.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Declared phrase.\n+-->\n+\n+<!--    phrase: \"Attribute hanger\" for small bits of (e.g.) differenced\n+        text in a paragraph or similar, when another element isn't handy.\n+        Beware that its content model may allow more nested elements than\n+        would normally be allowed in some contexts. -->\n+<!ENTITY % phrase.element \"INCLUDE\">\n+<![%phrase.element;[\n+<!ELEMENT phrase (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % phrase.attlist \"INCLUDE\">\n+<![%phrase.attlist;[\n+<!ATTLIST phrase %common.att;>\n+]]>\n+\n+<!--\n+#2003-06-25: nwalsh: RFC2119 elements\n+-->\n+\n+<!ENTITY % rfc2119.element \"INCLUDE\">\n+<![%rfc2119.element;[\n+<!ELEMENT rfc2119 (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % rfc2119.attlist \"INCLUDE\">\n+<![%rfc2119.attlist;[\n+<!ATTLIST rfc2119 %common.att;>\n+]]>\n+\n+<!--\n+#1998-03-10: maler: Declared quote.\n+-->\n+\n+<!--    quote: Scare quotes and other purely presentational quotes. -->\n+<!ENTITY % quote.element \"INCLUDE\">\n+<![%quote.element;[\n+<!ELEMENT quote (%p.pcd.mix;)*>\n+]]>\n+<!ENTITY % quote.attlist \"INCLUDE\">\n+<![%quote.attlist;[\n+<!ATTLIST quote %common.att;>\n+]]>\n+\n+<!--    specref: Reference to a div, olist item, prod, or issue\n+        in the current document; should generate italic \"[n.n],\n+        Section Title\" for div, \"n\" for numbered item, \"[n]\" for\n+        production, or \"Issue id\" for issue. -->\n+<!ENTITY % specref.element \"INCLUDE\">\n+<![%specref.element;[\n+<!ELEMENT specref EMPTY>\n+]]>\n+<!--    ref attribute:\n+        The purpose of a specref element is to link to a div, item\n+        in an olist, or production in the current spec. -->\n+<!ENTITY % specref.attlist \"INCLUDE\">\n+<![%specref.attlist;[\n+<!ATTLIST specref\n+        %common.att;\n+        %ref-req.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Added sub and sup.\n+-->\n+\n+<!--    sub: Subscript. -->\n+<!ENTITY % sub.element \"INCLUDE\">\n+<![%sub.element;[\n+<!ELEMENT sub (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % sub.attlist \"INCLUDE\">\n+<![%sub.attlist;[\n+<!ATTLIST sub %common.att;>\n+]]>\n+\n+<!--    sup: Superscript. -->\n+<!ENTITY % sup.element \"INCLUDE\">\n+<![%sup.element;[\n+<!ELEMENT sup (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % sup.attlist \"INCLUDE\">\n+<![%sup.attlist;[\n+<!ATTLIST sup %common.att;>\n+]]>\n+\n+<!--    term: The term in text that is being defined in text. -->\n+<!ENTITY % term.element \"INCLUDE\">\n+<![%term.element;[\n+<!ELEMENT term (#PCDATA|phrase)*>\n+]]>\n+<!ENTITY % term.attlist \"INCLUDE\">\n+<![%term.attlist;[\n+<!ATTLIST term %common.att;>\n+]]>\n+\n+<!--    termdef: Definition of a term in text. -->\n+<!ENTITY % termdef.element \"INCLUDE\">\n+<![%termdef.element;[\n+<!ELEMENT termdef (%termdef.pcd.mix;|%termdef.mix;)*>\n+]]>\n+<!--    ID attribute:\n+        A term definition must have an ID so that it can be linked\n+        to from termref elements. -->\n+<!--    term attribute:\n+        The canonical form of the term or phrase being defined must\n+        appear in this attribute, even if the term or phrase also\n+        appears in the element content in identical form (e.g., in\n+        the term element). -->\n+<!ENTITY % termdef.attlist \"INCLUDE\">\n+<![%termdef.attlist;[\n+<!ATTLIST termdef\n+        %common-idreq.att;\n+        term            CDATA           #REQUIRED>\n+]]>\n+\n+<!--    termref: Mention of a term, along with a link to the\n+        definition in the current document. -->\n+<!ENTITY % termref.element \"INCLUDE\">\n+<![%termref.element;[\n+<!ELEMENT termref (#PCDATA|phrase)*>\n+]]>\n+<!--    ref attribute:\n+        A term reference must link to the termdef element that\n+        defines the term. -->\n+<!ENTITY % termref.attlist \"INCLUDE\">\n+<![%termref.attlist;[\n+<!ATTLIST termref\n+        %common.att;\n+        %def-req.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Added show\/actuate attributes and default values.\n+-->\n+\n+<!--    titleref: Citation of another document, which can also\n+        link to that document if it is a Web resource. -->\n+<!ENTITY % titleref.element \"INCLUDE\">\n+<![%titleref.element;[\n+<!ELEMENT titleref (#PCDATA|phrase)*>\n+]]>\n+<!--    href attribute:\n+        A title reference can optionally function as a hypertext\n+        link to the resource with this title.  E.g.:\n+\n+<loc href=\"http:\/\/www.my.com\/doc.htm\">http:\/\/www.my.com\/doc.htm<\/loc>\n+        -->\n+\n+<!ENTITY % titleref.attlist \"INCLUDE\">\n+<![%titleref.attlist;[\n+<!ATTLIST titleref\n+        %common.att;\n+        %simple-xlink.att;\n+        %href.att;\n+        %user-new.att;>\n+]]>\n+\n+<!--\n+#2000-03-07: maler: Added var.\n+-->\n+\n+<!--    var: String standing for a variable value that the user\n+        or system will supply.  For example: \"For each node\n+        <var>x<\/var> in this node-set...\" -->\n+<!ENTITY % var.element \"INCLUDE\">\n+<![%var.element;[\n+<!ELEMENT var (%tech.pcd.mix;)*>\n+]]>\n+<!ENTITY % var.attlist \"INCLUDE\">\n+<![%var.attlist;[\n+<!ATTLIST var %common.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Added show\/actuate attributes and default values.\n+-->\n+\n+<!--    xnt: Mention of a nonterminal in text, along with a link to\n+        the production in another document that defines it. -->\n+<!ENTITY % xnt.element \"INCLUDE\">\n+<![%xnt.element;[\n+<!ELEMENT xnt (#PCDATA|phrase)*>\n+]]>\n+<!--    href attribute:\n+        The nonterminal must hyperlink to a resource that serves\n+        to define it (e.g., a production in a related XML\n+        specification).  E.g.:\n+\n+<xnt href=\"http:\/\/www.w3.org\/TR\/spec.htm#prod3\">Name<\/xnt>\n+        -->\n+\n+<!ENTITY % xnt.attlist \"INCLUDE\">\n+<![%xnt.attlist;[\n+<!ATTLIST xnt\n+        %common.att;\n+        %simple-xlink.att;\n+        %href-req.att;\n+        %user-new.att;>\n+]]>\n+\n+<!--\n+#1997-12-29: maler: Declared xspecref.\n+#1999-07-02: maler: Added show\/actuate attributes and default values.\n+-->\n+\n+<!--    xspecref: Reference to a div, olist item, prod, or issue\n+        in a related specification document; should generate\n+        no special text. -->\n+<!ENTITY % xspecref.element \"INCLUDE\">\n+<![%xspecref.element;[\n+<!ELEMENT xspecref (#PCDATA|phrase)*>\n+]]>\n+<!--    href attribute:\n+        The spec reference must hyperlink to the resource to\n+        cross-refer to (e.g., a section in a related XML\n+        specification).  E.g.:\n+\n+<xspecref href=\"http:\/\/www.w3.org\/TR\/spec.htm#sec2\">\n+the section on constraints<\/xspecref>\n+        -->\n+\n+<!ENTITY % xspecref.attlist \"INCLUDE\">\n+<![%xspecref.attlist;[\n+<!ATTLIST xspecref\n+        %common.att;\n+        %simple-xlink.att;\n+        %href-req.att;\n+        %user-new.att;>\n+]]>\n+\n+<!--\n+#1999-07-02: maler: Added show\/actuate attributes and default values.\n+-->\n+\n+<!--    termref: Mention of a term, along with a link to the\n+        definition in a related document. -->\n+<!ENTITY % xtermref.element \"INCLUDE\">\n+<![%xtermref.element;[\n+<!ELEMENT xtermref (#PCDATA|phrase)*>\n+]]>\n+<!--    href attribute:\n+        The term reference must hyperlink to the resource that\n+        serves to define the term (e.g., a term definition in\n+        a related XML specification).  E.g.:\n+\n+<xtermref href=\"http:\/\/www.w3.org\/TR\/spec.htm#term5\">\n+entity\n+<\/xtermref>\n+        -->\n+\n+<!ENTITY % xtermref.attlist \"INCLUDE\">\n+<![%xtermref.attlist;[\n+<!ATTLIST xtermref\n+        %common.att;\n+        %simple-xlink.att;\n+        %href-req.att;\n+        %user-new.att;>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Unused elements for ADEPT ..................................... -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#1997-09-30: maler: Added unusued elements.\n+#1997-10-14: maler: Fixed div to move nested div to the mixture.\n+#1998-05-14: maler: Added key-term, htable, and htbody.\n+#1998-11-30: maler: Added para, listitem, itemizedlist, and orderedlist.\n+-->\n+\n+<!--    The following elements are purposely declared but never\n+        referenced.  Declaring them allows them to be pasted from\n+        an HTML document, an earlier version of an XMLspec document,\n+        or a DocBook document into a document using this DTD in ADEPT.\n+        The ATD Context Transformation mechanism will try to convert\n+        them to the appropriate element for this DTD.  While this\n+        conversion will not work for all fragments, it does allow many\n+        cases to work reasonably well. -->\n+\n+<!ENTITY % div.element \"INCLUDE\">\n+<![%div.element;[\n+<!ELEMENT div\n+        (head?, (%div.mix;|ul|ol|h1|h2|h3|h4|h5|h6|div)*)>\n+]]>\n+<!ENTITY % h1.element \"INCLUDE\">\n+<![%h1.element;[\n+<!ELEMENT h1 (%head.pcd.mix;|em|a)*>\n+]]>\n+<!ENTITY % h2.element \"INCLUDE\">\n+<![%h2.element;[\n+<!ELEMENT h2 (%head.pcd.mix;|em|a)*>\n+]]>\n+<!ENTITY % h3.element \"INCLUDE\">\n+<![%h3.element;[\n+<!ELEMENT h3 (%head.pcd.mix;|em|a)*>\n+]]>\n+<!ENTITY % h4.element \"INCLUDE\">\n+<![%h4.element;[\n+<!ELEMENT h4 (%head.pcd.mix;|em|a)*>\n+]]>\n+<!ENTITY % h5.element \"INCLUDE\">\n+<![%h5.element;[\n+<!ELEMENT h5 (%head.pcd.mix;|em|a)*>\n+]]>\n+<!ENTITY % h6.element \"INCLUDE\">\n+<![%h6.element;[\n+<!ELEMENT h6 (%head.pcd.mix;|em|a)*>\n+]]>\n+<!ENTITY % pre.element \"INCLUDE\">\n+<![%pre.element;[\n+<!ELEMENT pre (%eg.pcd.mix;|em)*>\n+]]>\n+<!ENTITY % ul.element \"INCLUDE\">\n+<![%ul.element;[\n+<!ELEMENT ul (item|li)*>\n+]]>\n+<!ENTITY % ol.element \"INCLUDE\">\n+<![%ol.element;[\n+<!ELEMENT ol (item|li)*>\n+]]>\n+<!ENTITY % li.element \"INCLUDE\">\n+<![%li.element;[\n+<!ELEMENT li (#PCDATA|%obj.mix;)*>\n+]]>\n+<!ENTITY % em.element \"INCLUDE\">\n+<![%em.element;[\n+<!ELEMENT em (#PCDATA)*>\n+]]>\n+<!ENTITY % a.element \"INCLUDE\">\n+<![%a.element;[\n+<!ELEMENT a (#PCDATA)*>\n+]]>\n+\n+<!ENTITY % key-term.element \"INCLUDE\">\n+<![%key-term.element;[\n+<!ELEMENT key-term (#PCDATA)*>\n+]]>\n+<!ENTITY % htable.element \"INCLUDE\">\n+<![%htable.element;[\n+<!ELEMENT htable\n+        (caption?, (col*|colgroup*), thead?, tfoot?, tbody+)>\n+]]>\n+<!ENTITY % htbody.element \"INCLUDE\">\n+<![%htbody.element;[\n+<!ELEMENT htbody (tr)+>\n+]]>\n+<!ENTITY % statusp.element \"INCLUDE\">\n+<![%statusp.element;[\n+<!ELEMENT statusp (%p.pcd.mix;|%p.mix;)*>\n+]]>\n+\n+<!ENTITY % itemizedlist.element \"INCLUDE\">\n+<![%itemizedlist.element;[\n+<!ELEMENT itemizedlist (listitem*)>\n+]]>\n+<!ENTITY % orderedlist.element \"INCLUDE\">\n+<![%orderedlist.element;[\n+<!ELEMENT orderedlist (listitem*)>\n+]]>\n+<!ENTITY % listitem.element \"INCLUDE\">\n+<![%listitem.element;[\n+<!ELEMENT listitem (para*)>\n+]]>\n+<!ENTITY % para.element \"INCLUDE\">\n+<![%para.element;[\n+<!ELEMENT para (#PCDATA)*>\n+]]>\n+\n+<!-- ............................................................... -->\n+<!-- Change history ................................................ -->\n+<!-- ............................................................... -->\n+\n+<!--\n+#This revision history is no longer being maintained. See the CVS log\n+#for detailed revisions history.\n+#####################################################################\n+#1997-08-18: maler\n+#- Did a major revision.\n+#1997-09-10: maler\n+#- Updated FPI.\n+#- Removed namekey element and put key attribute on name element.\n+#- Made statusp element and supporting entities.\n+#- Added slist element with sitem+ content.\n+#- Required head on scrap and added new bnf subelement.\n+#- Added an xnt element and allowed it and nt in regular text and rhs.\n+#- Removed the ntref element.\n+#- Added back the com element to the content of rhs.\n+#- Added a key attribute to bibl.\n+#- Removed the ident element.\n+#- Added a term element to be used inside termdef.\n+#- Added an xtermref element parallel to termref.\n+#- Beefed up DTD comments.\n+#1997-09-12: maler\n+#- Allowed term element in general text.\n+#- Changed bibref to EMPTY.\n+#- Added ref.class to termdef.pcd.mix.\n+#1997-09-14: maler\n+#- Changed main attribute of xtermref from def to href.\n+#- Added termdef.class to label contents.\n+#1997-09-30: maler\n+#- Added character entity module and added new entities.\n+#- Removed p from appearing directly in self; created %p.mix;.\n+#- Added inform-div (non-normative division) element.\n+#- Fixed xtermref comment to mention href, not ref.\n+#- Extended orglist model to allow optional affiliation.\n+#- Modified author to make affiliation optional.\n+#- Added %speclist.class; and %note.class; to %obj.mix; and %p.mix;.\n+#- Added %note.class; and %illus.class; to %termdef.pcd.mix;.\n+#- Added unused HTML elements.\n+#- Put empty system ID next to public ID in entity declarations.\n+#1997-10-14: maler\n+#- Fixed \"unused\" div content model to move nested div to mixture.\n+#1997-10-16: maler\n+#- Added SGML Open Exchange tables.\n+#1997-11-28: maler\n+#- Added support for prodgroup and its attributes.\n+#- Added support for HTML tables.\n+#- Added loc and bibref to content of com.\n+#- Added loc to general p content models.\n+#- Allowed p as alternative to statusp in status.\n+#- Added non-null system IDs to external parameter entity declarations.\n+#- (Modified the SGML Open table module to make it XML-compliant.)\n+#- (Modified the character entity module.)\n+#1997-12-29: maler\n+#- Moved #PCDATA occurrences to come before GIs in content models.\n+#- Removed use of the SGML Open table module.\n+#- Added xspecref element.\n+#- Ensured that all FPIs contain 4-digit year.\n+#- (Modified the character entity module.)\n+#1998-03-10: maler\n+#- Merged the character entity and table modules into the main file.\n+#- Added ldquo and rdquo entities.\n+#- Added common attributes to prodgroup.\n+#- Made the email element in header optional.\n+#- Removed reference to the SGML Open table model.\n+#- Added ednote element.\n+#- Added quote element.\n+#- Updated XLink usage to reflect 3 March 1998 WD.\n+#- Added \"local\" entities to the class entities for customization.\n+#- Parameterized several content models to allow for customization.\n+#1998-03-23: maler\n+#- Cleaned up some comments and removed some others.\n+#- Added xml:space semi-common attribute to eg and bnf elements.\n+#- Added show and embed attributes on all the uses of href.\n+#- Added %common.att; to all HTML table elements.\n+#- Added a real URI to the \"typical invocation\" comment.\n+#1998-05-14: maler\n+#- Fixed mdash, ldquo, and rdquo character entities.\n+#- Switched to the full HTML 4.0 table model.\n+#- Removed htable\/htbody elements and replaced them with table\/tbody.\n+#- Added issue element to %note.class; and declared it.\n+#- Allowed prevlocs and latestloc in either order.\n+#- Added key-term, htable, htbody, and statusp as unused elements.\n+#- Removed real statusp element in favor of plain p.\n+#1998-05-21: maler\n+#- Declared generic constraint and constraintnote elements.\n+#- Added constraintnote to %note.class;.\n+#- Added constraint to %eg.pcd.mix; and prod content model.\n+#1998-08-22: maler\n+#- Fixed %illus.class; to mention table instead of htable.\n+#- Added definitions to %illus.class; for DOM model.\n+#- Added DOM definitions element and its substructure.\n+#- Updated XLink usage in %href.att; to use xlink:form and #IMPLIED.\n+#- Added clarifying comments to href-using elements.\n+#1998-11-30: maler\n+#- Added new unused elements to support DocBook translation.\n+#- Updated maler phone numbers.\n+#1998-12-3: maler\n+#- Fixed character entities with respect to escaping of ampersands.\n+#- Added many more explanatory comments.\n+#1999-07-02: maler\n+#- Added %loc.class; to all PCD mixes that didn't already have it.\n+#- Removed unused %loc.pcd.mix;.\n+#- Made version in spec header optional.\n+#- Added three new attributes to spec.\n+#- Broadened content of edtext.\n+#- Added optional copyright element to header.\n+#- Reorganized XLink-related parameter entities; added xmlns:xlink.\n+#- Changed edtext content from #PCDATA to %p.pcd.mix;.\n+#- Added show\/actuate atts and default values to all href elements.\n+#- Changed versioning scheme from 8-digit dates to version numbers.\n+#- Added w3c-doctype, other-doctype, status atts to spec element.\n+#- Added prodrecap element inside scrap.\n+#- Added headstyle attribute to scrap.\n+#2000-03-07: maler\n+#- Added proto element, its arg subelement, and the %argtypes; entity.\n+#- Added function, var, sub, sup, phrase, el, att, attval elements.\n+#- Expanded emph to %p.pcd.mix;.\n+#- Allowed status and abstract to appear in the opposite order.\n+#- Updated XLink usage to the latest WD, except for href and source.\n+#- Removed the xml:attributes attribute from graphic.\n+#- Added %local.graphic.att; to graphic.\n+#- Added common diff attribute.\n+#- Added div5 element.\n+#- Broadened content models of publoc, prevlocs, and latestloc.\n+#- Added head, source, resolution, and status attribute to issue.\n+#- Added cr, issues, and dispcmts to w3c-doctype attribute on spec.\n+#- Added example element.\n+-->\n+\n+<!-- ............................................................... -->\n+<!-- End of XML specification DTD .................................. -->\n+<!-- ............................................................... -->\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/dtd\/xmlspec2_10\/xmlspec.dtd","additions":2778,"deletions":0,"binary":false,"changes":2778,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+<?xml version='1.0'?>\n+<!-- XML Schema schema for XML Schemas: Part 2: Datatypes -->\n+<!DOCTYPE schema PUBLIC \"-\/\/W3C\/\/DTD XMLSCHEMA 200102\/\/EN\" \"XMLSchema.dtd\" [\n+<!ENTITY % s ''>\n+<!ENTITY % p ''>\n+]>\n+<schema xmlns=\"http:\/\/www.w3.org\/2001\/XMLSchema\" targetNamespace=\"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\"\n+\tversion=\"$Id: XMLSchema-datatypes.xsd,v 1.5 2001\/03\/16 20:53:32 ht Exp $\">\n+  <annotation>\n+   <documentation>Note this schema is NOT a normative schema - -\n+     It contains types derived from all the builtin simple type definitions\n+     with the same local name but in a distinct namespace, for use\n+     by applications which do no wish to import the full XMLSchema\n+     schema.  Since derivation is not symmetric, unexpected results may\n+     follow from mixing references to these definitions with references\n+     to the definitions in the XMLSchema namespace.  For example,\n+     although dt:positiveInteger is derived from xs:integer, the converse\n+     does not hold.<\/documentation>\n+  <\/annotation>\n+\n+  <simpleType name=\"string\">\n+   <restriction base=\"string\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"boolean\">\n+   <restriction base=\"boolean\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"float\">\n+   <restriction base=\"float\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"double\">\n+   <restriction base=\"double\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"decimal\">\n+   <restriction base=\"decimal\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"dateTime\">\n+   <restriction base=\"dateTime\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"duration\">\n+   <restriction base=\"duration\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"hexBinary\">\n+   <restriction base=\"hexBinary\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"base64Binary\">\n+   <restriction base=\"base64Binary\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"anyURI\">\n+   <restriction base=\"anyURI\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"ID\">\n+   <restriction base=\"ID\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"IDREF\">\n+   <restriction base=\"IDREF\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"ENTITY\">\n+   <restriction base=\"ENTITY\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"NOTATION\">\n+   <restriction base=\"NOTATION\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"normalizedString\">\n+   <restriction base=\"normalizedString\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"token\">\n+   <restriction base=\"token\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"language\">\n+   <restriction base=\"language\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"IDREFS\">\n+   <restriction base=\"IDREFS\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"ENTITIES\">\n+   <restriction base=\"ENTITIES\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"NMTOKEN\">\n+   <restriction base=\"NMTOKEN\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"NMTOKENS\">\n+   <restriction base=\"NMTOKENS\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"Name\">\n+   <restriction base=\"Name\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"QName\">\n+   <restriction base=\"QName\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"NCName\">\n+   <restriction base=\"NCName\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"integer\">\n+   <restriction base=\"integer\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"nonNegativeInteger\">\n+   <restriction base=\"nonNegativeInteger\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"positiveInteger\">\n+   <restriction base=\"positiveInteger\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"nonPositiveInteger\">\n+   <restriction base=\"nonPositiveInteger\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"negativeInteger\">\n+   <restriction base=\"negativeInteger\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"byte\">\n+   <restriction base=\"byte\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"int\">\n+   <restriction base=\"int\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"long\">\n+   <restriction base=\"long\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"short\">\n+   <restriction base=\"short\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"unsignedByte\">\n+   <restriction base=\"unsignedByte\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"unsignedInt\">\n+   <restriction base=\"unsignedInt\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"unsignedLong\">\n+   <restriction base=\"unsignedLong\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"unsignedShort\">\n+   <restriction base=\"unsignedShort\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"date\">\n+   <restriction base=\"date\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"time\">\n+   <restriction base=\"time\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"gYearMonth\">\n+   <restriction base=\"gYearMonth\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"gYear\">\n+   <restriction base=\"gYear\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"gMonthDay\">\n+   <restriction base=\"gMonthDay\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"gDay\">\n+   <restriction base=\"gDay\"\/>\n+  <\/simpleType>\n+  <simpleType name=\"gMonth\">\n+   <restriction base=\"gMonth\"\/>\n+  <\/simpleType>\n+\n+<\/schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/schema10\/XMLSchema-datatypes.xsd","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,2364 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- XML Schema schema for XML Schemas: Part 1: Structures -->\n+<!-- Note this schema is NOT the normative structures schema. -->\n+<!-- The prose copy in the structures REC is the normative -->\n+<!-- version (which shouldn't differ from this one except for -->\n+<!-- this comment and entity expansions, but just in case -->\n+<!DOCTYPE xs:schema PUBLIC \"-\/\/W3C\/\/DTD XMLSCHEMA 200102\/\/EN\" \"XMLSchema.dtd\">\n+<xs:schema targetNamespace=\"http:\/\/www.w3.org\/2001\/XMLSchema\" blockDefault=\"#all\" elementFormDefault=\"qualified\" version=\"1.0\" xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\" xml:lang=\"EN\" xmlns:hfp=\"http:\/\/www.w3.org\/2001\/XMLSchema-hasFacetAndProperty\">\n+ <xs:annotation>\n+  <xs:documentation>\n+    Part 1 version: Id: structures.xsd,v 1.2 2004\/01\/15 11:34:25 ht Exp \n+    Part 2 version: Id: datatypes.xsd,v 1.3 2004\/01\/23 18:11:13 ht Exp \n+  <\/xs:documentation>\n+ <\/xs:annotation>\n+\n+ <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2004\/PER-xmlschema-1-20040318\/structures.html\">\n+   The schema corresponding to this document is normative,\n+   with respect to the syntactic constraints it expresses in the\n+   XML Schema language.  The documentation (within &lt;documentation&gt; elements)\n+   below, is not normative, but rather highlights important aspects of\n+   the W3C Recommendation of which this is a part<\/xs:documentation>\n+ <\/xs:annotation>\n+\n+ <xs:annotation>\n+   <xs:documentation>\n+   The simpleType element and all of its members are defined\n+      towards the end of this schema document<\/xs:documentation>\n+ <\/xs:annotation>\n+\n+ <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\" schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+   <xs:annotation>\n+     <xs:documentation>\n+       Get access to the xml: attribute groups for xml:lang\n+       as declared on 'schema' and 'documentation' below\n+     <\/xs:documentation>\n+   <\/xs:annotation>\n+ <\/xs:import>\n+\n+ <xs:complexType name=\"openAttrs\">\n+   <xs:annotation>\n+     <xs:documentation>\n+       This type is extended by almost all schema types\n+       to allow attributes from other namespaces to be\n+       added to user schemas.\n+     <\/xs:documentation>\n+   <\/xs:annotation>\n+   <xs:complexContent>\n+     <xs:restriction base=\"xs:anyType\">\n+       <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+     <\/xs:restriction>\n+   <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"annotated\">\n+   <xs:annotation>\n+     <xs:documentation>\n+       This type is extended by all types which allow annotation\n+       other than &lt;schema&gt; itself\n+     <\/xs:documentation>\n+   <\/xs:annotation>\n+   <xs:complexContent>\n+     <xs:extension base=\"xs:openAttrs\">\n+       <xs:sequence>\n+         <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+       <\/xs:sequence>\n+       <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+     <\/xs:extension>\n+   <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:group name=\"schemaTop\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   This group is for the\n+   elements which occur freely at the top level of schemas.\n+   All of their types are based on the \"annotated\" type by extension.<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:choice>\n+   <xs:group ref=\"xs:redefinable\"\/>\n+   <xs:element ref=\"xs:element\"\/>\n+   <xs:element ref=\"xs:attribute\"\/>\n+   <xs:element ref=\"xs:notation\"\/>\n+  <\/xs:choice>\n+ <\/xs:group>\n+ \n+ <xs:group name=\"redefinable\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   This group is for the\n+   elements which can self-redefine (see &lt;redefine&gt; below).<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:choice>\n+   <xs:element ref=\"xs:simpleType\"\/>\n+   <xs:element ref=\"xs:complexType\"\/>\n+   <xs:element ref=\"xs:group\"\/>\n+   <xs:element ref=\"xs:attributeGroup\"\/>\n+  <\/xs:choice>\n+ <\/xs:group>\n+\n+ <xs:simpleType name=\"formChoice\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:restriction base=\"xs:NMTOKEN\">\n+   <xs:enumeration value=\"qualified\"\/>\n+   <xs:enumeration value=\"unqualified\"\/>\n+  <\/xs:restriction>\n+ <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"reducedDerivationControl\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:restriction base=\"xs:derivationControl\">\n+   <xs:enumeration value=\"extension\"\/>\n+   <xs:enumeration value=\"restriction\"\/>\n+  <\/xs:restriction>\n+ <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"derivationSet\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+   <xs:documentation>\n+   #all or (possibly empty) subset of {extension, restriction}<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:union>\n+   <xs:simpleType>    \n+    <xs:restriction base=\"xs:token\">\n+     <xs:enumeration value=\"#all\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+   <xs:simpleType>\n+    <xs:list itemType=\"xs:reducedDerivationControl\"\/>\n+   <\/xs:simpleType>\n+  <\/xs:union>\n+ <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"typeDerivationControl\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:restriction base=\"xs:derivationControl\">\n+   <xs:enumeration value=\"extension\"\/>\n+   <xs:enumeration value=\"restriction\"\/>\n+   <xs:enumeration value=\"list\"\/>\n+   <xs:enumeration value=\"union\"\/>\n+  <\/xs:restriction>\n+ <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"fullDerivationSet\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+   <xs:documentation>\n+   #all or (possibly empty) subset of {extension, restriction, list, union}<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:union>\n+   <xs:simpleType>    \n+    <xs:restriction base=\"xs:token\">\n+     <xs:enumeration value=\"#all\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+   <xs:simpleType>\n+    <xs:list itemType=\"xs:typeDerivationControl\"\/>\n+   <\/xs:simpleType>\n+  <\/xs:union>\n+ <\/xs:simpleType>\n+\n+ <xs:element name=\"schema\" id=\"schema\">\n+  <xs:annotation>\n+    <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-schema\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:openAttrs\">\n+     <xs:sequence>\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+       <xs:element ref=\"xs:include\"\/>\n+       <xs:element ref=\"xs:import\"\/>\n+       <xs:element ref=\"xs:redefine\"\/>\n+       <xs:element ref=\"xs:annotation\"\/>\n+      <\/xs:choice>\n+      <xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n+       <xs:group ref=\"xs:schemaTop\"\/>\n+       <xs:element ref=\"xs:annotation\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+      <\/xs:sequence>\n+     <\/xs:sequence>\n+     <xs:attribute name=\"targetNamespace\" type=\"xs:anyURI\"\/>\n+     <xs:attribute name=\"version\" type=\"xs:token\"\/>\n+     <xs:attribute name=\"finalDefault\" type=\"xs:fullDerivationSet\" use=\"optional\" default=\"\"\/>\n+     <xs:attribute name=\"blockDefault\" type=\"xs:blockSet\" use=\"optional\" default=\"\"\/>\n+     <xs:attribute name=\"attributeFormDefault\" type=\"xs:formChoice\" use=\"optional\" default=\"unqualified\"\/>\n+     <xs:attribute name=\"elementFormDefault\" type=\"xs:formChoice\" use=\"optional\" default=\"unqualified\"\/>\n+     <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+     <xs:attribute ref=\"xml:lang\"\/>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+\n+  <xs:key name=\"element\">\n+   <xs:selector xpath=\"xs:element\"\/>\n+   <xs:field xpath=\"@name\"\/>\n+  <\/xs:key>\n+\n+  <xs:key name=\"attribute\">\n+   <xs:selector xpath=\"xs:attribute\"\/>\n+   <xs:field xpath=\"@name\"\/>\n+  <\/xs:key>\n+\n+  <xs:key name=\"type\">\n+   <xs:selector xpath=\"xs:complexType|xs:simpleType\"\/>\n+   <xs:field xpath=\"@name\"\/>\n+  <\/xs:key>\n+ \n+  <xs:key name=\"group\">\n+   <xs:selector xpath=\"xs:group\"\/>\n+   <xs:field xpath=\"@name\"\/>\n+  <\/xs:key>\n+ \n+  <xs:key name=\"attributeGroup\">\n+   <xs:selector xpath=\"xs:attributeGroup\"\/>\n+   <xs:field xpath=\"@name\"\/>\n+  <\/xs:key>\n+ \n+  <xs:key name=\"notation\">\n+   <xs:selector xpath=\"xs:notation\"\/>\n+   <xs:field xpath=\"@name\"\/>\n+  <\/xs:key>\n+\n+  <xs:key name=\"identityConstraint\">\n+   <xs:selector xpath=\".\/\/xs:key|.\/\/xs:unique|.\/\/xs:keyref\"\/>\n+   <xs:field xpath=\"@name\"\/>\n+  <\/xs:key>\n+\n+ <\/xs:element>\n+\n+ <xs:simpleType name=\"allNNI\">\n+  <xs:annotation><xs:documentation>\n+   for maxOccurs<\/xs:documentation><\/xs:annotation>\n+  <xs:union memberTypes=\"xs:nonNegativeInteger\">\n+   <xs:simpleType>\n+    <xs:restriction base=\"xs:NMTOKEN\">\n+     <xs:enumeration value=\"unbounded\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+  <\/xs:union>\n+ <\/xs:simpleType>\n+\n+ <xs:attributeGroup name=\"occurs\">\n+  <xs:annotation><xs:documentation>\n+   for all particles<\/xs:documentation><\/xs:annotation>\n+  <xs:attribute name=\"minOccurs\" type=\"xs:nonNegativeInteger\" use=\"optional\" default=\"1\"\/>\n+  <xs:attribute name=\"maxOccurs\" type=\"xs:allNNI\" use=\"optional\" default=\"1\"\/>\n+ <\/xs:attributeGroup>\n+\n+ <xs:attributeGroup name=\"defRef\">\n+  <xs:annotation><xs:documentation>\n+   for element, group and attributeGroup,\n+   which both define and reference<\/xs:documentation><\/xs:annotation>\n+  <xs:attribute name=\"name\" type=\"xs:NCName\"\/>\n+  <xs:attribute name=\"ref\" type=\"xs:QName\"\/>\n+ <\/xs:attributeGroup>\n+\n+ <xs:group name=\"typeDefParticle\">\n+  <xs:annotation>\n+    <xs:documentation>\n+   'complexType' uses this<\/xs:documentation><\/xs:annotation>\n+  <xs:choice>\n+   <xs:element name=\"group\" type=\"xs:groupRef\"\/>\n+   <xs:element ref=\"xs:all\"\/>\n+   <xs:element ref=\"xs:choice\"\/>\n+   <xs:element ref=\"xs:sequence\"\/>\n+  <\/xs:choice>\n+ <\/xs:group>\n+ \n+ \n+\n+ <xs:group name=\"nestedParticle\">\n+  <xs:choice>\n+   <xs:element name=\"element\" type=\"xs:localElement\"\/>\n+   <xs:element name=\"group\" type=\"xs:groupRef\"\/>\n+   <xs:element ref=\"xs:choice\"\/>\n+   <xs:element ref=\"xs:sequence\"\/>\n+   <xs:element ref=\"xs:any\"\/>\n+  <\/xs:choice>\n+ <\/xs:group>\n+ \n+ <xs:group name=\"particle\">\n+  <xs:choice>\n+   <xs:element name=\"element\" type=\"xs:localElement\"\/>\n+   <xs:element name=\"group\" type=\"xs:groupRef\"\/>\n+   <xs:element ref=\"xs:all\"\/>\n+   <xs:element ref=\"xs:choice\"\/>\n+   <xs:element ref=\"xs:sequence\"\/>\n+   <xs:element ref=\"xs:any\"\/>\n+  <\/xs:choice>\n+ <\/xs:group>\n+ \n+ <xs:complexType name=\"attribute\">\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:sequence>\n+     <xs:element name=\"simpleType\" minOccurs=\"0\" type=\"xs:localSimpleType\"\/>\n+    <\/xs:sequence>\n+    <xs:attributeGroup ref=\"xs:defRef\"\/>\n+    <xs:attribute name=\"type\" type=\"xs:QName\"\/>\n+    <xs:attribute name=\"use\" use=\"optional\" default=\"optional\">\n+     <xs:simpleType>\n+      <xs:restriction base=\"xs:NMTOKEN\">\n+       <xs:enumeration value=\"prohibited\"\/>\n+       <xs:enumeration value=\"optional\"\/>\n+       <xs:enumeration value=\"required\"\/>\n+      <\/xs:restriction>\n+     <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"default\" type=\"xs:string\"\/>\n+    <xs:attribute name=\"fixed\" type=\"xs:string\"\/>\n+    <xs:attribute name=\"form\" type=\"xs:formChoice\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"topLevelAttribute\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:attribute\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:element name=\"simpleType\" minOccurs=\"0\" type=\"xs:localSimpleType\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"ref\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"form\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"use\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"name\" use=\"required\" type=\"xs:NCName\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:group name=\"attrDecls\">\n+  <xs:sequence>\n+   <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+    <xs:element name=\"attribute\" type=\"xs:attribute\"\/>\n+    <xs:element name=\"attributeGroup\" type=\"xs:attributeGroupRef\"\/>\n+   <\/xs:choice>\n+   <xs:element ref=\"xs:anyAttribute\" minOccurs=\"0\"\/>\n+  <\/xs:sequence>\n+ <\/xs:group>\n+\n+ <xs:element name=\"anyAttribute\" type=\"xs:wildcard\" id=\"anyAttribute\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-anyAttribute\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:group name=\"complexTypeModel\">\n+  <xs:choice>\n+      <xs:element ref=\"xs:simpleContent\"\/>\n+      <xs:element ref=\"xs:complexContent\"\/>\n+      <xs:sequence>\n+       <xs:annotation>\n+        <xs:documentation>\n+   This branch is short for\n+   &lt;complexContent&gt;\n+   &lt;restriction base=\"xs:anyType\"&gt;\n+   ...\n+   &lt;\/restriction&gt;\n+   &lt;\/complexContent&gt;<\/xs:documentation>\n+       <\/xs:annotation>\n+       <xs:group ref=\"xs:typeDefParticle\" minOccurs=\"0\"\/>\n+       <xs:group ref=\"xs:attrDecls\"\/>\n+      <\/xs:sequence>\n+  <\/xs:choice>\n+ <\/xs:group>\n+\n+ <xs:complexType name=\"complexType\" abstract=\"true\">\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:group ref=\"xs:complexTypeModel\"\/>\n+    <xs:attribute name=\"name\" type=\"xs:NCName\">\n+     <xs:annotation>\n+      <xs:documentation>\n+      Will be restricted to required or forbidden<\/xs:documentation>\n+     <\/xs:annotation>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"mixed\" type=\"xs:boolean\" use=\"optional\" default=\"false\">\n+     <xs:annotation>\n+      <xs:documentation>\n+      Not allowed if simpleContent child is chosen.\n+      May be overriden by setting on complexContent child.<\/xs:documentation>\n+    <\/xs:annotation>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"abstract\" type=\"xs:boolean\" use=\"optional\" default=\"false\"\/>\n+    <xs:attribute name=\"final\" type=\"xs:derivationSet\"\/>\n+    <xs:attribute name=\"block\" type=\"xs:derivationSet\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"topLevelComplexType\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:complexType\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:group ref=\"xs:complexTypeModel\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"name\" type=\"xs:NCName\" use=\"required\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"localComplexType\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:complexType\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:group ref=\"xs:complexTypeModel\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"name\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"abstract\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"final\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"block\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"restrictionType\">\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:sequence>\n+     <xs:choice minOccurs=\"0\">\n+      <xs:group ref=\"xs:typeDefParticle\"\/>\n+      <xs:group ref=\"xs:simpleRestrictionModel\"\/>\n+     <\/xs:choice>\n+     <xs:group ref=\"xs:attrDecls\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"base\" type=\"xs:QName\" use=\"required\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>       \n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"complexRestrictionType\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:restrictionType\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:choice minOccurs=\"0\">\n+      <xs:annotation>\n+       <xs:documentation>This choice is added simply to\n+                   make this a valid restriction per the REC<\/xs:documentation>\n+      <\/xs:annotation>\n+      <xs:group ref=\"xs:typeDefParticle\"\/>\n+     <\/xs:choice>\n+     <xs:group ref=\"xs:attrDecls\"\/>\n+    <\/xs:sequence>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>       \n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"extensionType\">\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:sequence>\n+     <xs:group ref=\"xs:typeDefParticle\" minOccurs=\"0\"\/>\n+     <xs:group ref=\"xs:attrDecls\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"base\" type=\"xs:QName\" use=\"required\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>       \n+ <\/xs:complexType>\n+\n+ <xs:element name=\"complexContent\" id=\"complexContent\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-complexContent\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:annotated\">\n+     <xs:choice>\n+      <xs:element name=\"restriction\" type=\"xs:complexRestrictionType\"\/>\n+      <xs:element name=\"extension\" type=\"xs:extensionType\"\/>\n+     <\/xs:choice>     \n+     <xs:attribute name=\"mixed\" type=\"xs:boolean\">\n+      <xs:annotation>\n+       <xs:documentation>\n+       Overrides any setting on complexType parent.<\/xs:documentation>\n+      <\/xs:annotation>\n+    <\/xs:attribute>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:complexType name=\"simpleRestrictionType\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:restrictionType\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:choice minOccurs=\"0\">\n+      <xs:annotation>\n+       <xs:documentation>This choice is added simply to\n+                   make this a valid restriction per the REC<\/xs:documentation>\n+      <\/xs:annotation>\n+      <xs:group ref=\"xs:simpleRestrictionModel\"\/>\n+     <\/xs:choice>\n+     <xs:group ref=\"xs:attrDecls\"\/>\n+    <\/xs:sequence>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"simpleExtensionType\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:extensionType\">\n+    <xs:sequence>\n+     <xs:annotation>\n+      <xs:documentation>\n+      No typeDefParticle group reference<\/xs:documentation>\n+     <\/xs:annotation>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:group ref=\"xs:attrDecls\"\/>\n+    <\/xs:sequence>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:element name=\"simpleContent\" id=\"simpleContent\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-simpleContent\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:annotated\">\n+     <xs:choice>\n+      <xs:element name=\"restriction\" type=\"xs:simpleRestrictionType\"\/>\n+      <xs:element name=\"extension\" type=\"xs:simpleExtensionType\"\/>\n+     <\/xs:choice>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+ \n+ <xs:element name=\"complexType\" type=\"xs:topLevelComplexType\" id=\"complexType\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-complexType\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+\n+  <xs:simpleType name=\"blockSet\">\n+   <xs:annotation>\n+    <xs:documentation>\n+    A utility type, not for public use<\/xs:documentation>\n+    <xs:documentation>\n+    #all or (possibly empty) subset of {substitution, extension,\n+    restriction}<\/xs:documentation>\n+   <\/xs:annotation>\n+   <xs:union>\n+    <xs:simpleType>    \n+     <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"#all\"\/>\n+     <\/xs:restriction>\n+    <\/xs:simpleType>\n+    <xs:simpleType>\n+     <xs:list>\n+      <xs:simpleType>\n+       <xs:restriction base=\"xs:derivationControl\">\n+        <xs:enumeration value=\"extension\"\/>\n+        <xs:enumeration value=\"restriction\"\/>\n+        <xs:enumeration value=\"substitution\"\/>\n+       <\/xs:restriction>\n+      <\/xs:simpleType>\n+     <\/xs:list>\n+    <\/xs:simpleType>\n+   <\/xs:union>  \n+  <\/xs:simpleType>\n+\n+ <xs:complexType name=\"element\" abstract=\"true\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   The element element can be used either\n+   at the top level to define an element-type binding globally,\n+   or within a content model to either reference a globally-defined\n+   element or type or declare an element-type binding locally.\n+   The ref form is not allowed at the top level.<\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:sequence>\n+     <xs:choice minOccurs=\"0\">\n+      <xs:element name=\"simpleType\" type=\"xs:localSimpleType\"\/>\n+      <xs:element name=\"complexType\" type=\"xs:localComplexType\"\/>\n+     <\/xs:choice>\n+     <xs:group ref=\"xs:identityConstraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+    <xs:attributeGroup ref=\"xs:defRef\"\/>\n+    <xs:attribute name=\"type\" type=\"xs:QName\"\/>\n+    <xs:attribute name=\"substitutionGroup\" type=\"xs:QName\"\/>\n+    <xs:attributeGroup ref=\"xs:occurs\"\/>\n+    <xs:attribute name=\"default\" type=\"xs:string\"\/>\n+    <xs:attribute name=\"fixed\" type=\"xs:string\"\/>\n+    <xs:attribute name=\"nillable\" type=\"xs:boolean\" use=\"optional\" default=\"false\"\/>\n+    <xs:attribute name=\"abstract\" type=\"xs:boolean\" use=\"optional\" default=\"false\"\/>\n+    <xs:attribute name=\"final\" type=\"xs:derivationSet\"\/>\n+    <xs:attribute name=\"block\" type=\"xs:blockSet\"\/>\n+    <xs:attribute name=\"form\" type=\"xs:formChoice\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"topLevelElement\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:element\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:choice minOccurs=\"0\">\n+      <xs:element name=\"simpleType\" type=\"xs:localSimpleType\"\/>\n+      <xs:element name=\"complexType\" type=\"xs:localComplexType\"\/>\n+     <\/xs:choice>\n+     <xs:group ref=\"xs:identityConstraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"ref\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"form\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"minOccurs\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"maxOccurs\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"name\" use=\"required\" type=\"xs:NCName\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"localElement\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:element\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:choice minOccurs=\"0\">\n+      <xs:element name=\"simpleType\" type=\"xs:localSimpleType\"\/>\n+      <xs:element name=\"complexType\" type=\"xs:localComplexType\"\/>\n+     <\/xs:choice>\n+     <xs:group ref=\"xs:identityConstraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"substitutionGroup\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"final\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"abstract\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:element name=\"element\" type=\"xs:topLevelElement\" id=\"element\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-element\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:complexType name=\"group\" abstract=\"true\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   group type for explicit groups, named top-level groups and\n+   group references<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:group ref=\"xs:particle\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <xs:attributeGroup ref=\"xs:defRef\"\/>\n+    <xs:attributeGroup ref=\"xs:occurs\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"realGroup\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:group\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:choice minOccurs=\"0\" maxOccurs=\"1\">\n+      <xs:element ref=\"xs:all\"\/>\n+      <xs:element ref=\"xs:choice\"\/>\n+      <xs:element ref=\"xs:sequence\"\/>\n+     <\/xs:choice>\n+    <\/xs:sequence>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"namedGroup\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:realGroup\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:choice minOccurs=\"1\" maxOccurs=\"1\">\n+      <xs:element name=\"all\">\n+       <xs:complexType>\n+        <xs:complexContent>\n+         <xs:restriction base=\"xs:all\">\n+          <xs:group ref=\"xs:allModel\"\/>\n+          <xs:attribute name=\"minOccurs\" use=\"prohibited\"\/>\n+          <xs:attribute name=\"maxOccurs\" use=\"prohibited\"\/>\n+          <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+         <\/xs:restriction>\n+        <\/xs:complexContent>\n+       <\/xs:complexType>\n+      <\/xs:element>\n+      <xs:element name=\"choice\" type=\"xs:simpleExplicitGroup\"\/>\n+      <xs:element name=\"sequence\" type=\"xs:simpleExplicitGroup\"\/>\n+     <\/xs:choice>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"name\" use=\"required\" type=\"xs:NCName\"\/>\n+    <xs:attribute name=\"ref\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"minOccurs\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"maxOccurs\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"groupRef\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:realGroup\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"ref\" use=\"required\" type=\"xs:QName\"\/>\n+    <xs:attribute name=\"name\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"explicitGroup\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   group type for the three kinds of group<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:group\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:group ref=\"xs:nestedParticle\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"name\" type=\"xs:NCName\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"ref\" type=\"xs:QName\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"simpleExplicitGroup\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:explicitGroup\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:group ref=\"xs:nestedParticle\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"minOccurs\" use=\"prohibited\"\/>\n+    <xs:attribute name=\"maxOccurs\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:group name=\"allModel\">\n+  <xs:sequence>\n+      <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+       <xs:annotation>\n+        <xs:documentation>This choice with min\/max is here to\n+                          avoid a pblm with the Elt:All\/Choice\/Seq\n+                          Particle derivation constraint<\/xs:documentation>\n+       <\/xs:annotation>\n+       <xs:element name=\"element\" type=\"xs:narrowMaxMin\"\/>\n+      <\/xs:choice>\n+     <\/xs:sequence>\n+ <\/xs:group>\n+ \n+ \n+ <xs:complexType name=\"narrowMaxMin\">\n+  <xs:annotation>\n+   <xs:documentation>restricted max\/min<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:localElement\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:choice minOccurs=\"0\">\n+      <xs:element name=\"simpleType\" type=\"xs:localSimpleType\"\/>\n+      <xs:element name=\"complexType\" type=\"xs:localComplexType\"\/>\n+     <\/xs:choice>\n+     <xs:group ref=\"xs:identityConstraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"minOccurs\" use=\"optional\" default=\"1\">\n+     <xs:simpleType>\n+      <xs:restriction base=\"xs:nonNegativeInteger\">\n+       <xs:enumeration value=\"0\"\/>\n+       <xs:enumeration value=\"1\"\/>\n+      <\/xs:restriction>\n+     <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"maxOccurs\" use=\"optional\" default=\"1\">\n+     <xs:simpleType>\n+      <xs:restriction base=\"xs:allNNI\">\n+       <xs:enumeration value=\"0\"\/>\n+       <xs:enumeration value=\"1\"\/>\n+      <\/xs:restriction>\n+     <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+  <xs:complexType name=\"all\">\n+   <xs:annotation>\n+    <xs:documentation>\n+   Only elements allowed inside<\/xs:documentation>\n+   <\/xs:annotation>\n+   <xs:complexContent>\n+    <xs:restriction base=\"xs:explicitGroup\">\n+     <xs:group ref=\"xs:allModel\"\/>\n+     <xs:attribute name=\"minOccurs\" use=\"optional\" default=\"1\">\n+      <xs:simpleType>\n+       <xs:restriction base=\"xs:nonNegativeInteger\">\n+        <xs:enumeration value=\"0\"\/>\n+        <xs:enumeration value=\"1\"\/>\n+       <\/xs:restriction>\n+      <\/xs:simpleType>\n+     <\/xs:attribute>\n+     <xs:attribute name=\"maxOccurs\" use=\"optional\" default=\"1\">\n+      <xs:simpleType>\n+       <xs:restriction base=\"xs:allNNI\">\n+        <xs:enumeration value=\"1\"\/>\n+       <\/xs:restriction>\n+      <\/xs:simpleType>\n+     <\/xs:attribute>\n+     <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+    <\/xs:restriction>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+\n+ <xs:element name=\"all\" id=\"all\" type=\"xs:all\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-all\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:element name=\"choice\" type=\"xs:explicitGroup\" id=\"choice\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-choice\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:element name=\"sequence\" type=\"xs:explicitGroup\" id=\"sequence\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-sequence\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:element name=\"group\" type=\"xs:namedGroup\" id=\"group\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-group\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:complexType name=\"wildcard\">\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:attribute name=\"namespace\" type=\"xs:namespaceList\" use=\"optional\" default=\"##any\"\/>\n+    <xs:attribute name=\"processContents\" use=\"optional\" default=\"strict\">\n+     <xs:simpleType>\n+      <xs:restriction base=\"xs:NMTOKEN\">\n+       <xs:enumeration value=\"skip\"\/>\n+       <xs:enumeration value=\"lax\"\/>\n+       <xs:enumeration value=\"strict\"\/>\n+      <\/xs:restriction>\n+     <\/xs:simpleType>\n+    <\/xs:attribute>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:element name=\"any\" id=\"any\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-any\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:wildcard\">\n+     <xs:attributeGroup ref=\"xs:occurs\"\/>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+\n+  <xs:annotation>\n+   <xs:documentation>\n+   simple type for the value of the 'namespace' attr of\n+   'any' and 'anyAttribute'<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:annotation>\n+   <xs:documentation>\n+   Value is\n+              ##any      - - any non-conflicting WFXML\/attribute at all\n+\n+              ##other    - - any non-conflicting WFXML\/attribute from\n+                              namespace other than targetNS\n+\n+              ##local    - - any unqualified non-conflicting WFXML\/attribute \n+\n+              one or     - - any non-conflicting WFXML\/attribute from\n+              more URI        the listed namespaces\n+              references\n+              (space separated)\n+\n+    ##targetNamespace or ##local may appear in the above list, to\n+        refer to the targetNamespace of the enclosing\n+        schema or an absent targetNamespace respectively<\/xs:documentation>\n+  <\/xs:annotation>\n+\n+ <xs:simpleType name=\"namespaceList\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:union>\n+   <xs:simpleType>\n+    <xs:restriction base=\"xs:token\">\n+     <xs:enumeration value=\"##any\"\/>\n+     <xs:enumeration value=\"##other\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+   <xs:simpleType>\n+    <xs:list>\n+     <xs:simpleType>\n+      <xs:union memberTypes=\"xs:anyURI\">\n+       <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+         <xs:enumeration value=\"##targetNamespace\"\/>\n+         <xs:enumeration value=\"##local\"\/>\n+        <\/xs:restriction>\n+       <\/xs:simpleType>\n+      <\/xs:union>\n+     <\/xs:simpleType>\n+    <\/xs:list>\n+   <\/xs:simpleType>\n+  <\/xs:union>\n+ <\/xs:simpleType>\n+\n+ <xs:element name=\"attribute\" type=\"xs:topLevelAttribute\" id=\"attribute\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-attribute\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:complexType name=\"attributeGroup\" abstract=\"true\">\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:group ref=\"xs:attrDecls\"\/>\n+    <xs:attributeGroup ref=\"xs:defRef\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ \n+ <xs:complexType name=\"namedAttributeGroup\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:attributeGroup\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+     <xs:group ref=\"xs:attrDecls\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"name\" use=\"required\" type=\"xs:NCName\"\/>\n+    <xs:attribute name=\"ref\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:complexType name=\"attributeGroupRef\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:attributeGroup\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"ref\" use=\"required\" type=\"xs:QName\"\/>\n+    <xs:attribute name=\"name\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:element name=\"attributeGroup\" type=\"xs:namedAttributeGroup\" id=\"attributeGroup\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-attributeGroup\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+\n+ <xs:element name=\"include\" id=\"include\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-include\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:annotated\">\n+     <xs:attribute name=\"schemaLocation\" type=\"xs:anyURI\" use=\"required\"\/>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:element name=\"redefine\" id=\"redefine\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-redefine\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:openAttrs\">\n+     <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:element ref=\"xs:annotation\"\/>\n+      <xs:group ref=\"xs:redefinable\"\/>\n+     <\/xs:choice>\n+     <xs:attribute name=\"schemaLocation\" type=\"xs:anyURI\" use=\"required\"\/>\n+     <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:element name=\"import\" id=\"import\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-import\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:annotated\">\n+     <xs:attribute name=\"namespace\" type=\"xs:anyURI\"\/>\n+     <xs:attribute name=\"schemaLocation\" type=\"xs:anyURI\"\/>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:element name=\"selector\" id=\"selector\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-selector\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+     <xs:attribute name=\"xpath\" use=\"required\">\n+      <xs:simpleType>\n+       <xs:annotation>\n+        <xs:documentation>A subset of XPath expressions for use\n+in selectors<\/xs:documentation>\n+        <xs:documentation>A utility type, not for public\n+use<\/xs:documentation>\n+       <\/xs:annotation>\n+       <xs:restriction base=\"xs:token\">\n+        <xs:annotation>\n+         <xs:documentation>The following pattern is intended to allow XPath\n+                           expressions per the following EBNF:\n+          Selector    ::=    Path ( '|' Path )*  \n+          Path    ::=    ('.\/\/')? Step ( '\/' Step )*  \n+          Step    ::=    '.' | NameTest  \n+          NameTest    ::=    QName | '*' | NCName ':' '*'  \n+                           child:: is also allowed\n+         <\/xs:documentation>\n+        <\/xs:annotation>\n+        <xs:pattern value=\"(\\.\/\/)?(((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.)(\/(((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.))*(\\|(\\.\/\/)?(((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.)(\/(((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.))*)*\">\n+        <\/xs:pattern>\n+       <\/xs:restriction>\n+      <\/xs:simpleType>\n+     <\/xs:attribute>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:element name=\"field\" id=\"field\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-field\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+     <xs:attribute name=\"xpath\" use=\"required\">\n+      <xs:simpleType>\n+       <xs:annotation>\n+        <xs:documentation>A subset of XPath expressions for use\n+in fields<\/xs:documentation>\n+        <xs:documentation>A utility type, not for public\n+use<\/xs:documentation>\n+       <\/xs:annotation>\n+       <xs:restriction base=\"xs:token\">\n+        <xs:annotation>\n+         <xs:documentation>The following pattern is intended to allow XPath\n+                           expressions per the same EBNF as for selector,\n+                           with the following change:\n+          Path    ::=    ('.\/\/')? ( Step '\/' )* ( Step | '@' NameTest ) \n+         <\/xs:documentation>\n+        <\/xs:annotation>\n+        <xs:pattern value=\"(\\.\/\/)?((((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.)\/)*((((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.)|((attribute::|@)((\\i\\c*:)?(\\i\\c*|\\*))))(\\|(\\.\/\/)?((((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.)\/)*((((child::)?((\\i\\c*:)?(\\i\\c*|\\*)))|\\.)|((attribute::|@)((\\i\\c*:)?(\\i\\c*|\\*)))))*\">\n+        <\/xs:pattern>\n+       <\/xs:restriction>\n+      <\/xs:simpleType>\n+     <\/xs:attribute>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:complexType name=\"keybase\">\n+  <xs:complexContent>\n+   <xs:extension base=\"xs:annotated\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:selector\"\/>\n+     <xs:element ref=\"xs:field\" minOccurs=\"1\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"name\" type=\"xs:NCName\" use=\"required\"\/>\n+   <\/xs:extension>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+ <xs:group name=\"identityConstraint\">\n+  <xs:annotation>\n+   <xs:documentation>The three kinds of identity constraints, all with\n+                     type of or derived from 'keybase'.\n+   <\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:choice>\n+   <xs:element ref=\"xs:unique\"\/>\n+   <xs:element ref=\"xs:key\"\/>\n+   <xs:element ref=\"xs:keyref\"\/>\n+  <\/xs:choice>\n+ <\/xs:group>\n+\n+ <xs:element name=\"unique\" type=\"xs:keybase\" id=\"unique\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-unique\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+ <xs:element name=\"key\" type=\"xs:keybase\" id=\"key\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-key\"\/>\n+  <\/xs:annotation>\n+ <\/xs:element>\n+ <xs:element name=\"keyref\" id=\"keyref\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-keyref\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:keybase\">\n+     <xs:attribute name=\"refer\" type=\"xs:QName\" use=\"required\"\/>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:element name=\"notation\" id=\"notation\">\n+  <xs:annotation>\n+   <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-notation\"\/>\n+  <\/xs:annotation>\n+  <xs:complexType>\n+   <xs:complexContent>\n+    <xs:extension base=\"xs:annotated\">\n+     <xs:attribute name=\"name\" type=\"xs:NCName\" use=\"required\"\/>\n+     <xs:attribute name=\"public\" type=\"xs:public\"\/>\n+     <xs:attribute name=\"system\" type=\"xs:anyURI\"\/>\n+    <\/xs:extension>\n+   <\/xs:complexContent>\n+  <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:simpleType name=\"public\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+   <xs:documentation>\n+   A public identifier, per ISO 8879<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:restriction base=\"xs:token\"\/>\n+ <\/xs:simpleType>\n+\n+ <xs:element name=\"appinfo\" id=\"appinfo\">\n+   <xs:annotation>\n+     <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-appinfo\"\/>\n+   <\/xs:annotation>\n+   <xs:complexType mixed=\"true\">\n+    <xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n+     <xs:any processContents=\"lax\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"source\" type=\"xs:anyURI\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:element name=\"documentation\" id=\"documentation\">\n+   <xs:annotation>\n+     <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-documentation\"\/>\n+   <\/xs:annotation>\n+   <xs:complexType mixed=\"true\">\n+    <xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n+     <xs:any processContents=\"lax\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"source\" type=\"xs:anyURI\"\/>\n+    <xs:attribute ref=\"xml:lang\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:element name=\"annotation\" id=\"annotation\">\n+   <xs:annotation>\n+     <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-1\/#element-annotation\"\/>\n+   <\/xs:annotation>\n+   <xs:complexType>\n+    <xs:complexContent>\n+     <xs:extension base=\"xs:openAttrs\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+       <xs:element ref=\"xs:appinfo\"\/>\n+       <xs:element ref=\"xs:documentation\"\/>\n+      <\/xs:choice>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+     <\/xs:extension>\n+    <\/xs:complexContent>\n+   <\/xs:complexType>\n+ <\/xs:element>\n+\n+ <xs:annotation>\n+  <xs:documentation>\n+   notations for use within XML Schema schemas<\/xs:documentation>\n+ <\/xs:annotation>\n+\n+ <xs:notation name=\"XMLSchemaStructures\" public=\"structures\" system=\"http:\/\/www.w3.org\/2000\/08\/XMLSchema.xsd\"\/>\n+ <xs:notation name=\"XML\" public=\"REC-xml-19980210\" system=\"http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210\"\/>\n+  \n+ <xs:complexType name=\"anyType\" mixed=\"true\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   Not the real urType, but as close an approximation as we can\n+   get in the XML representation<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:sequence>\n+   <xs:any minOccurs=\"0\" maxOccurs=\"unbounded\" processContents=\"lax\"\/>\n+  <\/xs:sequence>\n+  <xs:anyAttribute processContents=\"lax\"\/>\n+ <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+      First the built-in primitive datatypes.  These definitions are for\n+      information only, the real built-in definitions are magic.\n+    <\/xs:documentation>\n+\n+    <xs:documentation>\n+      For each built-in datatype in this schema (both primitive and\n+      derived) can be uniquely addressed via a URI constructed\n+      as follows:\n+        1) the base URI is the URI of the XML Schema namespace\n+        2) the fragment identifier is the name of the datatype\n+\n+      For example, to address the int datatype, the URI is:\n+\n+        http:\/\/www.w3.org\/2001\/XMLSchema#int\n+\n+      Additionally, each facet definition element can be uniquely\n+      addressed via a URI constructed as follows:\n+        1) the base URI is the URI of the XML Schema namespace\n+        2) the fragment identifier is the name of the facet\n+\n+      For example, to address the maxInclusive facet, the URI is:\n+\n+        http:\/\/www.w3.org\/2001\/XMLSchema#maxInclusive\n+\n+      Additionally, each facet usage in a built-in datatype definition\n+      can be uniquely addressed via a URI constructed as follows:\n+        1) the base URI is the URI of the XML Schema namespace\n+        2) the fragment identifier is the name of the datatype, followed\n+           by a period (\".\") followed by the name of the facet\n+\n+      For example, to address the usage of the maxInclusive facet in\n+      the definition of int, the URI is:\n+\n+        http:\/\/www.w3.org\/2001\/XMLSchema#int.maxInclusive\n+\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"string\" id=\"string\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#string\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"preserve\" id=\"string.preserve\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"boolean\" id=\"boolean\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"finite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#boolean\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"boolean.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"float\" id=\"float\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"total\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"true\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"finite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"true\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#float\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"float.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"double\" id=\"double\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"total\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"true\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"finite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"true\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#double\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"double.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"decimal\" id=\"decimal\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"totalDigits\"\/>\n+        <hfp:hasFacet name=\"fractionDigits\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"total\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"true\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#decimal\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"decimal.whiteSpace\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+\n+   <xs:simpleType name=\"duration\" id=\"duration\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#duration\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"duration.whiteSpace\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"dateTime\" id=\"dateTime\">\n+    <xs:annotation>\n+    <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#dateTime\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"dateTime.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"time\" id=\"time\">\n+    <xs:annotation>\n+    <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#time\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"time.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"date\" id=\"date\">\n+   <xs:annotation>\n+    <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#date\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"date.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"gYearMonth\" id=\"gYearMonth\">\n+   <xs:annotation>\n+    <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#gYearMonth\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"gYearMonth.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"gYear\" id=\"gYear\">\n+    <xs:annotation>\n+    <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#gYear\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"gYear.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"gMonthDay\" id=\"gMonthDay\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+       <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#gMonthDay\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+         <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"gMonthDay.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"gDay\" id=\"gDay\">\n+    <xs:annotation>\n+  <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#gDay\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+         <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"gDay.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"gMonth\" id=\"gMonth\">\n+    <xs:annotation>\n+  <xs:appinfo>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"maxInclusive\"\/>\n+        <hfp:hasFacet name=\"maxExclusive\"\/>\n+        <hfp:hasFacet name=\"minInclusive\"\/>\n+        <hfp:hasFacet name=\"minExclusive\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"partial\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#gMonth\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+         <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"gMonth.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+   <xs:simpleType name=\"hexBinary\" id=\"hexBinary\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#binary\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"hexBinary.whiteSpace\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"base64Binary\" id=\"base64Binary\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#base64Binary\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"base64Binary.whiteSpace\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+\n+   <xs:simpleType name=\"anyURI\" id=\"anyURI\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#anyURI\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"anyURI.whiteSpace\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"QName\" id=\"QName\">\n+    <xs:annotation>\n+        <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#QName\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"QName.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+   <xs:simpleType name=\"NOTATION\" id=\"NOTATION\">\n+    <xs:annotation>\n+        <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#NOTATION\"\/>\n+      <xs:documentation>\n+        NOTATION cannot be used directly in a schema; rather a type\n+        must be derived from it by specifying at least one enumeration\n+        facet whose value is the name of a NOTATION declared in the\n+        schema.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anySimpleType\">\n+      <xs:whiteSpace value=\"collapse\" fixed=\"true\" id=\"NOTATION.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+      Now the derived primitive types\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"normalizedString\" id=\"normalizedString\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#normalizedString\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:whiteSpace value=\"replace\" id=\"normalizedString.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"token\" id=\"token\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#token\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:normalizedString\">\n+      <xs:whiteSpace value=\"collapse\" id=\"token.whiteSpace\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"language\" id=\"language\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#language\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:pattern value=\"[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*\" id=\"language.pattern\">\n+        <xs:annotation>\n+          <xs:documentation source=\"http:\/\/www.ietf.org\/rfc\/rfc3066.txt\">\n+            pattern specifies the content of section 2.12 of XML 1.0e2\n+            and RFC 3066 (Revised version of RFC 1766).\n+          <\/xs:documentation>\n+        <\/xs:annotation>\n+      <\/xs:pattern>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"IDREFS\" id=\"IDREFS\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#IDREFS\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction>\n+      <xs:simpleType>\n+        <xs:list itemType=\"xs:IDREF\"\/>\n+      <\/xs:simpleType>\n+        <xs:minLength value=\"1\" id=\"IDREFS.minLength\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"ENTITIES\" id=\"ENTITIES\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#ENTITIES\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction>\n+      <xs:simpleType>\n+        <xs:list itemType=\"xs:ENTITY\"\/>\n+      <\/xs:simpleType>\n+        <xs:minLength value=\"1\" id=\"ENTITIES.minLength\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"NMTOKEN\" id=\"NMTOKEN\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#NMTOKEN\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:pattern value=\"\\c+\" id=\"NMTOKEN.pattern\">\n+        <xs:annotation>\n+          <xs:documentation source=\"http:\/\/www.w3.org\/TR\/REC-xml#NT-Nmtoken\">\n+            pattern matches production 7 from the XML spec\n+          <\/xs:documentation>\n+        <\/xs:annotation>\n+      <\/xs:pattern>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"NMTOKENS\" id=\"NMTOKENS\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasFacet name=\"length\"\/>\n+        <hfp:hasFacet name=\"minLength\"\/>\n+        <hfp:hasFacet name=\"maxLength\"\/>\n+        <hfp:hasFacet name=\"enumeration\"\/>\n+        <hfp:hasFacet name=\"whiteSpace\"\/>\n+        <hfp:hasFacet name=\"pattern\"\/>\n+        <hfp:hasProperty name=\"ordered\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"bounded\" value=\"false\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"countably infinite\"\/>\n+        <hfp:hasProperty name=\"numeric\" value=\"false\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#NMTOKENS\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction>\n+      <xs:simpleType>\n+        <xs:list itemType=\"xs:NMTOKEN\"\/>\n+      <\/xs:simpleType>\n+        <xs:minLength value=\"1\" id=\"NMTOKENS.minLength\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Name\" id=\"Name\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#Name\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:pattern value=\"\\i\\c*\" id=\"Name.pattern\">\n+        <xs:annotation>\n+          <xs:documentation source=\"http:\/\/www.w3.org\/TR\/REC-xml#NT-Name\">\n+            pattern matches production 5 from the XML spec\n+          <\/xs:documentation>\n+        <\/xs:annotation>\n+      <\/xs:pattern>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"NCName\" id=\"NCName\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#NCName\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:Name\">\n+      <xs:pattern value=\"[\\i-[:]][\\c-[:]]*\" id=\"NCName.pattern\">\n+        <xs:annotation>\n+          <xs:documentation source=\"http:\/\/www.w3.org\/TR\/REC-xml-names\/#NT-NCName\">\n+            pattern matches production 4 from the Namespaces in XML spec\n+          <\/xs:documentation>\n+        <\/xs:annotation>\n+      <\/xs:pattern>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+   <xs:simpleType name=\"ID\" id=\"ID\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#ID\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NCName\"\/>\n+   <\/xs:simpleType>\n+\n+   <xs:simpleType name=\"IDREF\" id=\"IDREF\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#IDREF\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NCName\"\/>\n+   <\/xs:simpleType>\n+\n+   <xs:simpleType name=\"ENTITY\" id=\"ENTITY\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#ENTITY\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NCName\"\/>\n+   <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"integer\" id=\"integer\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#integer\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:decimal\">\n+      <xs:fractionDigits value=\"0\" fixed=\"true\" id=\"integer.fractionDigits\"\/>\n+      <xs:pattern value=\"[\\-+]?[0-9]+\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"nonPositiveInteger\" id=\"nonPositiveInteger\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#nonPositiveInteger\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:integer\">\n+      <xs:maxInclusive value=\"0\" id=\"nonPositiveInteger.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"negativeInteger\" id=\"negativeInteger\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#negativeInteger\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonPositiveInteger\">\n+      <xs:maxInclusive value=\"-1\" id=\"negativeInteger.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"long\" id=\"long\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasProperty name=\"bounded\" value=\"true\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"finite\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#long\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:integer\">\n+      <xs:minInclusive value=\"-9223372036854775808\" id=\"long.minInclusive\"\/>\n+      <xs:maxInclusive value=\"9223372036854775807\" id=\"long.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"int\" id=\"int\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#int\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:long\">\n+      <xs:minInclusive value=\"-2147483648\" id=\"int.minInclusive\"\/>\n+      <xs:maxInclusive value=\"2147483647\" id=\"int.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"short\" id=\"short\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#short\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:int\">\n+      <xs:minInclusive value=\"-32768\" id=\"short.minInclusive\"\/>\n+      <xs:maxInclusive value=\"32767\" id=\"short.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"byte\" id=\"byte\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#byte\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:short\">\n+      <xs:minInclusive value=\"-128\" id=\"byte.minInclusive\"\/>\n+      <xs:maxInclusive value=\"127\" id=\"byte.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"nonNegativeInteger\" id=\"nonNegativeInteger\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#nonNegativeInteger\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:integer\">\n+      <xs:minInclusive value=\"0\" id=\"nonNegativeInteger.minInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"unsignedLong\" id=\"unsignedLong\">\n+    <xs:annotation>\n+      <xs:appinfo>\n+        <hfp:hasProperty name=\"bounded\" value=\"true\"\/>\n+        <hfp:hasProperty name=\"cardinality\" value=\"finite\"\/>\n+      <\/xs:appinfo>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#unsignedLong\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\">\n+      <xs:maxInclusive value=\"18446744073709551615\" id=\"unsignedLong.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"unsignedInt\" id=\"unsignedInt\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#unsignedInt\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:unsignedLong\">\n+      <xs:maxInclusive value=\"4294967295\" id=\"unsignedInt.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"unsignedShort\" id=\"unsignedShort\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#unsignedShort\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:unsignedInt\">\n+      <xs:maxInclusive value=\"65535\" id=\"unsignedShort.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"unsignedByte\" id=\"unsignedByte\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#unsignedByte\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:unsignedShort\">\n+      <xs:maxInclusive value=\"255\" id=\"unsignedByte.maxInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"positiveInteger\" id=\"positiveInteger\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#positiveInteger\"\/>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\">\n+      <xs:minInclusive value=\"1\" id=\"positiveInteger.minInclusive\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+ <xs:simpleType name=\"derivationControl\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:restriction base=\"xs:NMTOKEN\">\n+   <xs:enumeration value=\"substitution\"\/>\n+   <xs:enumeration value=\"extension\"\/>\n+   <xs:enumeration value=\"restriction\"\/>\n+   <xs:enumeration value=\"list\"\/>\n+   <xs:enumeration value=\"union\"\/>\n+  <\/xs:restriction>\n+ <\/xs:simpleType>\n+\n+ <xs:group name=\"simpleDerivation\">\n+  <xs:choice>\n+    <xs:element ref=\"xs:restriction\"\/>\n+    <xs:element ref=\"xs:list\"\/>\n+    <xs:element ref=\"xs:union\"\/>\n+  <\/xs:choice>\n+ <\/xs:group>\n+\n+ <xs:simpleType name=\"simpleDerivationSet\">\n+  <xs:annotation>\n+   <xs:documentation>\n+   #all or (possibly empty) subset of {restriction, union, list}\n+   <\/xs:documentation>\n+   <xs:documentation>\n+   A utility type, not for public use<\/xs:documentation>\n+  <\/xs:annotation>\n+  <xs:union>\n+   <xs:simpleType>\n+    <xs:restriction base=\"xs:token\">\n+     <xs:enumeration value=\"#all\"\/>\n+    <\/xs:restriction>\n+   <\/xs:simpleType>\n+   <xs:simpleType>\n+    <xs:list>\n+     <xs:simpleType>\n+      <xs:restriction base=\"xs:derivationControl\">\n+       <xs:enumeration value=\"list\"\/>\n+       <xs:enumeration value=\"union\"\/>\n+       <xs:enumeration value=\"restriction\"\/>\n+      <\/xs:restriction>\n+     <\/xs:simpleType>\n+    <\/xs:list>\n+   <\/xs:simpleType>\n+  <\/xs:union>\n+ <\/xs:simpleType>\n+\n+  <xs:complexType name=\"simpleType\" abstract=\"true\">\n+    <xs:complexContent>\n+      <xs:extension base=\"xs:annotated\">\n+        <xs:group ref=\"xs:simpleDerivation\"\/>\n+        <xs:attribute name=\"final\" type=\"xs:simpleDerivationSet\"\/>\n+        <xs:attribute name=\"name\" type=\"xs:NCName\">\n+          <xs:annotation>\n+            <xs:documentation>\n+              Can be restricted to required or forbidden\n+            <\/xs:documentation>\n+          <\/xs:annotation>\n+        <\/xs:attribute>\n+      <\/xs:extension>\n+    <\/xs:complexContent>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"topLevelSimpleType\">\n+    <xs:complexContent>\n+      <xs:restriction base=\"xs:simpleType\">\n+        <xs:sequence>\n+          <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+          <xs:group ref=\"xs:simpleDerivation\"\/>\n+        <\/xs:sequence>\n+        <xs:attribute name=\"name\" use=\"required\" type=\"xs:NCName\">\n+          <xs:annotation>\n+            <xs:documentation>\n+              Required at the top level\n+            <\/xs:documentation>\n+          <\/xs:annotation>\n+        <\/xs:attribute>\n+       <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+      <\/xs:restriction>\n+    <\/xs:complexContent>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"localSimpleType\">\n+    <xs:complexContent>\n+      <xs:restriction base=\"xs:simpleType\">\n+        <xs:sequence>\n+          <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+          <xs:group ref=\"xs:simpleDerivation\"\/>\n+        <\/xs:sequence>\n+        <xs:attribute name=\"name\" use=\"prohibited\">\n+          <xs:annotation>\n+            <xs:documentation>\n+              Forbidden when nested\n+            <\/xs:documentation>\n+          <\/xs:annotation>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"final\" use=\"prohibited\"\/>\n+       <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+      <\/xs:restriction>\n+    <\/xs:complexContent>\n+  <\/xs:complexType>\n+\n+  <xs:element name=\"simpleType\" type=\"xs:topLevelSimpleType\" id=\"simpleType\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-simpleType\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+\n+  <xs:group name=\"facets\">\n+   <xs:annotation>\n+    <xs:documentation>\n+       We should use a substitution group for facets, but\n+       that's ruled out because it would allow users to\n+       add their own, which we're not ready for yet.\n+    <\/xs:documentation>\n+   <\/xs:annotation>\n+   <xs:choice>\n+    <xs:element ref=\"xs:minExclusive\"\/>\n+    <xs:element ref=\"xs:minInclusive\"\/>\n+    <xs:element ref=\"xs:maxExclusive\"\/>\n+    <xs:element ref=\"xs:maxInclusive\"\/>\n+    <xs:element ref=\"xs:totalDigits\"\/>\n+    <xs:element ref=\"xs:fractionDigits\"\/>\n+    <xs:element ref=\"xs:length\"\/>\n+    <xs:element ref=\"xs:minLength\"\/>\n+    <xs:element ref=\"xs:maxLength\"\/>\n+    <xs:element ref=\"xs:enumeration\"\/>\n+    <xs:element ref=\"xs:whiteSpace\"\/>\n+    <xs:element ref=\"xs:pattern\"\/>\n+   <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"simpleRestrictionModel\">\n+   <xs:sequence>\n+    <xs:element name=\"simpleType\" type=\"xs:localSimpleType\" minOccurs=\"0\"\/>\n+    <xs:group ref=\"xs:facets\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+   <\/xs:sequence>\n+  <\/xs:group>\n+\n+  <xs:element name=\"restriction\" id=\"restriction\">\n+   <xs:complexType>\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-restriction\">\n+          base attribute and simpleType child are mutually\n+          exclusive, but one or other is required\n+        <\/xs:documentation>\n+      <\/xs:annotation>\n+      <xs:complexContent>\n+        <xs:extension base=\"xs:annotated\">\n+         <xs:group ref=\"xs:simpleRestrictionModel\"\/>\n+         <xs:attribute name=\"base\" type=\"xs:QName\" use=\"optional\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"list\" id=\"list\">\n+   <xs:complexType>\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-list\">\n+          itemType attribute and simpleType child are mutually\n+          exclusive, but one or other is required\n+        <\/xs:documentation>\n+      <\/xs:annotation>\n+      <xs:complexContent>\n+        <xs:extension base=\"xs:annotated\">\n+          <xs:sequence>\n+            <xs:element name=\"simpleType\" type=\"xs:localSimpleType\" minOccurs=\"0\"\/>\n+          <\/xs:sequence>\n+          <xs:attribute name=\"itemType\" type=\"xs:QName\" use=\"optional\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"union\" id=\"union\">\n+   <xs:complexType>\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-union\">\n+          memberTypes attribute must be non-empty or there must be\n+          at least one simpleType child\n+        <\/xs:documentation>\n+      <\/xs:annotation>\n+      <xs:complexContent>\n+        <xs:extension base=\"xs:annotated\">\n+          <xs:sequence>\n+            <xs:element name=\"simpleType\" type=\"xs:localSimpleType\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+          <\/xs:sequence>\n+          <xs:attribute name=\"memberTypes\" use=\"optional\">\n+            <xs:simpleType>\n+              <xs:list itemType=\"xs:QName\"\/>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:complexType name=\"facet\">\n+    <xs:complexContent>\n+      <xs:extension base=\"xs:annotated\">\n+        <xs:attribute name=\"value\" use=\"required\"\/>\n+        <xs:attribute name=\"fixed\" type=\"xs:boolean\" use=\"optional\" default=\"false\"\/>\n+      <\/xs:extension>\n+    <\/xs:complexContent>\n+  <\/xs:complexType>\n+\n+ <xs:complexType name=\"noFixedFacet\">\n+  <xs:complexContent>\n+   <xs:restriction base=\"xs:facet\">\n+    <xs:sequence>\n+     <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+    <\/xs:sequence>\n+    <xs:attribute name=\"fixed\" use=\"prohibited\"\/>\n+    <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+   <\/xs:restriction>\n+  <\/xs:complexContent>\n+ <\/xs:complexType>\n+\n+  <xs:element name=\"minExclusive\" id=\"minExclusive\" type=\"xs:facet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-minExclusive\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+  <xs:element name=\"minInclusive\" id=\"minInclusive\" type=\"xs:facet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-minInclusive\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+\n+  <xs:element name=\"maxExclusive\" id=\"maxExclusive\" type=\"xs:facet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-maxExclusive\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+  <xs:element name=\"maxInclusive\" id=\"maxInclusive\" type=\"xs:facet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-maxInclusive\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+\n+  <xs:complexType name=\"numFacet\">\n+    <xs:complexContent>\n+      <xs:restriction base=\"xs:facet\">\n+       <xs:sequence>\n+         <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+       <\/xs:sequence>\n+       <xs:attribute name=\"value\" type=\"xs:nonNegativeInteger\" use=\"required\"\/>\n+       <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+      <\/xs:restriction>\n+    <\/xs:complexContent>\n+  <\/xs:complexType>\n+\n+  <xs:element name=\"totalDigits\" id=\"totalDigits\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-totalDigits\"\/>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:complexContent>\n+        <xs:restriction base=\"xs:numFacet\">\n+          <xs:sequence>\n+            <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+          <\/xs:sequence>\n+          <xs:attribute name=\"value\" type=\"xs:positiveInteger\" use=\"required\"\/>\n+         <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+        <\/xs:restriction>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+  <xs:element name=\"fractionDigits\" id=\"fractionDigits\" type=\"xs:numFacet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-fractionDigits\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+\n+  <xs:element name=\"length\" id=\"length\" type=\"xs:numFacet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-length\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+  <xs:element name=\"minLength\" id=\"minLength\" type=\"xs:numFacet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-minLength\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+  <xs:element name=\"maxLength\" id=\"maxLength\" type=\"xs:numFacet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-maxLength\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+\n+  <xs:element name=\"enumeration\" id=\"enumeration\" type=\"xs:noFixedFacet\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-enumeration\"\/>\n+    <\/xs:annotation>\n+  <\/xs:element>\n+\n+  <xs:element name=\"whiteSpace\" id=\"whiteSpace\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-whiteSpace\"\/>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:complexContent>\n+        <xs:restriction base=\"xs:facet\">\n+          <xs:sequence>\n+            <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+          <\/xs:sequence>\n+          <xs:attribute name=\"value\" use=\"required\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:NMTOKEN\">\n+                <xs:enumeration value=\"preserve\"\/>\n+                <xs:enumeration value=\"replace\"\/>\n+                <xs:enumeration value=\"collapse\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+         <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+        <\/xs:restriction>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"pattern\" id=\"pattern\">\n+    <xs:annotation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xmlschema-2\/#element-pattern\"\/>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:complexContent>\n+        <xs:restriction base=\"xs:noFixedFacet\">\n+          <xs:sequence>\n+            <xs:element ref=\"xs:annotation\" minOccurs=\"0\"\/>\n+          <\/xs:sequence>\n+          <xs:attribute name=\"value\" type=\"xs:string\" use=\"required\"\/>\n+         <xs:anyAttribute namespace=\"##other\" processContents=\"lax\"\/>\n+        <\/xs:restriction>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+<\/xs:schema>\n\\ No newline at end of file\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/schema10\/XMLSchema.xsd","additions":2364,"deletions":0,"binary":false,"changes":2364,"status":"added"},{"patch":"@@ -0,0 +1,2847 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema version=\"1.0\" xml:lang=\"en\"\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+    targetNamespace=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns:xml=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+    elementFormDefault=\"qualified\">\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    XHTML 1.0 (Second Edition) Frameset in XML Schema\n+\n+    This is the same as HTML 4 Frameset except for\n+    changes due to the differences between XML and SGML.\n+\n+    Namespace = http:\/\/www.w3.org\/1999\/xhtml\n+\n+    For further information, see: http:\/\/www.w3.org\/TR\/xhtml1\n+\n+    Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),\n+    All Rights Reserved. \n+\n+    The DTD version is identified by the PUBLIC and SYSTEM identifiers:\n+\n+    PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Frameset\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-frameset.dtd\"\n+\n+    $Id: xhtml1-frameset.xsd,v 1.5 2002\/08\/28 09:53:29 mimasa Exp $\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+      schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\"\/>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Character mnemonic entities =========================\n+\n+    XHTML entity sets are identified by the PUBLIC and SYSTEM identifiers:\n+  \n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-lat1.ent\"\n+\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-special.ent\"\n+\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-symbol.ent\"\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Imported Names ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"ContentType\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      media type, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"ContentTypes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      comma-separated list of media types, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Charset\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a character encoding, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Charsets\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a space separated list of character encodings, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"LanguageCode\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a language code, as per [RFC3066]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:language\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Character\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a single character, as per section 2.2 of [XML]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:length value=\"1\" fixed=\"true\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Number\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      one or more digits\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\">\n+      <xs:pattern value=\"[0-9]+\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"tabindexNumber\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      tabindex attribute specifies the position of the current element\n+      in the tabbing order for the current document. This value must be\n+      a number between 0 and 32767. User agents should ignore leading zeros. \n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"Number\">\n+      <xs:minInclusive value=\"0\"\/>\n+      <xs:maxInclusive value=\"32767\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"LinkTypes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      space-separated list of link types\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NMTOKENS\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"MediaDesc\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      single or comma-separated list of media descriptors\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[^,]+(,\\s*[^,]+)*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"URI\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a Uniform Resource Identifier, see [RFC2396]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anyURI\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"UriList\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a space separated list of Uniform Resource Identifiers\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Datetime\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      date and time information. ISO date format\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:dateTime\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Script\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      script expression\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"StyleSheet\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      style sheet data\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Text\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      used for titles etc.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"FrameTarget\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      render in this frame\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NMTOKEN\">\n+      <xs:pattern value=\"_(blank|self|parent|top)|[A-Za-z]\\c*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Length\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      nn for pixels or nn% for percentage length\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"MultiLength\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      pixel, percentage, or relative\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)|[1-9]?(\\d+)?\\*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"MultiLengths\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      comma-separated list of MultiLength\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern\n+          value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)|[1-9]?(\\d+)?\\*(,\\s*[-+]?(\\d+|\\d+(\\.\\d+)?%)|[1-9]?(\\d+)?\\*)*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Pixels\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      integer representing length in pixels\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    these are used for image maps\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"Shape\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"rect\"\/>\n+      <xs:enumeration value=\"circle\"\/>\n+      <xs:enumeration value=\"poly\"\/>\n+      <xs:enumeration value=\"default\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Coords\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      comma separated list of lengths\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern\n+          value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)(,\\s*[-+]?(\\d+|\\d+(\\.\\d+)?%))*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"ImgAlign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      used for object, applet, img, input and iframe\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"top\"\/>\n+      <xs:enumeration value=\"middle\"\/>\n+      <xs:enumeration value=\"bottom\"\/>\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Color\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a color using sRGB: #RRGGBB as Hex values\n+\n+      There are also 16 widely known color names with their sRGB values:\n+\n+      Black  = #000000    Green  = #008000\n+      Silver = #C0C0C0    Lime   = #00FF00\n+      Gray   = #808080    Olive  = #808000\n+      White  = #FFFFFF    Yellow = #FFFF00\n+      Maroon = #800000    Navy   = #000080\n+      Red    = #FF0000    Blue   = #0000FF\n+      Purple = #800080    Teal   = #008080\n+      Fuchsia= #FF00FF    Aqua   = #00FFFF\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[A-Za-z]+|#[0-9A-Fa-f]{3}|#[0-9A-Fa-f]{6}\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Generic Attributes ===============================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:attributeGroup name=\"coreattrs\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      core attributes common to most elements\n+      id       document-wide unique id\n+      class    space separated list of classes\n+      style    associated style info\n+      title    advisory title\/amplification\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <xs:attribute name=\"class\" type=\"xs:NMTOKENS\"\/>\n+    <xs:attribute name=\"style\" type=\"StyleSheet\"\/>\n+    <xs:attribute name=\"title\" type=\"Text\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"i18n\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      internationalization attributes\n+      lang        language code (backwards compatible)\n+      xml:lang    language code (as per XML 1.0 spec)\n+      dir         direction for weak\/neutral text\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"lang\" type=\"LanguageCode\"\/>\n+    <xs:attribute ref=\"xml:lang\"\/>\n+    <xs:attribute name=\"dir\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"ltr\"\/>\n+          <xs:enumeration value=\"rtl\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"events\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      attributes for common UI events\n+      onclick     a pointer button was clicked\n+      ondblclick  a pointer button was double clicked\n+      onmousedown a pointer button was pressed down\n+      onmouseup   a pointer button was released\n+      onmousemove a pointer was moved onto the element\n+      onmouseout  a pointer was moved away from the element\n+      onkeypress  a key was pressed and released\n+      onkeydown   a key was pressed down\n+      onkeyup     a key was released\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"onclick\" type=\"Script\"\/>\n+    <xs:attribute name=\"ondblclick\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmousedown\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseup\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseover\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmousemove\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseout\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeypress\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeydown\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeyup\" type=\"Script\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"focus\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      attributes for elements that can get the focus\n+      accesskey   accessibility key character\n+      tabindex    position in tabbing order\n+      onfocus     the element got the focus\n+      onblur      the element lost the focus\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+    <xs:attribute name=\"tabindex\" type=\"tabindexNumber\"\/>\n+    <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+    <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"attrs\">\n+    <xs:attributeGroup ref=\"coreattrs\"\/>\n+    <xs:attributeGroup ref=\"i18n\"\/>\n+    <xs:attributeGroup ref=\"events\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"TextAlign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      text alignment for p, div, h1-h6. The default is\n+      align=\"left\" for ltr headings, \"right\" for rtl\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"align\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"left\"\/>\n+          <xs:enumeration value=\"center\"\/>\n+          <xs:enumeration value=\"right\"\/>\n+          <xs:enumeration value=\"justify\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Text Elements ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"special.extra\">\n+    <xs:choice>\n+      <xs:element ref=\"object\"\/>\n+      <xs:element ref=\"applet\"\/>\n+      <xs:element ref=\"img\"\/>\n+      <xs:element ref=\"map\"\/>\n+      <xs:element ref=\"iframe\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"special.basic\">\n+    <xs:choice>\n+      <xs:element ref=\"br\"\/>\n+      <xs:element ref=\"span\"\/>\n+      <xs:element ref=\"bdo\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"special\">\n+    <xs:choice>\n+      <xs:group ref=\"special.basic\"\/>\n+      <xs:group ref=\"special.extra\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"fontstyle.extra\">\n+    <xs:choice>\n+      <xs:element ref=\"big\"\/>\n+      <xs:element ref=\"small\"\/>\n+      <xs:element ref=\"font\"\/>\n+      <xs:element ref=\"basefont\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"fontstyle.basic\">\n+    <xs:choice>\n+      <xs:element ref=\"tt\"\/>\n+      <xs:element ref=\"i\"\/>\n+      <xs:element ref=\"b\"\/>\n+      <xs:element ref=\"u\"\/>\n+      <xs:element ref=\"s\"\/>\n+      <xs:element ref=\"strike\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"fontstyle\">\n+    <xs:choice>\n+      <xs:group ref=\"fontstyle.basic\"\/>\n+      <xs:group ref=\"fontstyle.extra\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"phrase.extra\">\n+    <xs:choice>\n+      <xs:element ref=\"sub\"\/>\n+      <xs:element ref=\"sup\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"phrase.basic\">\n+    <xs:choice>\n+      <xs:element ref=\"em\"\/>\n+      <xs:element ref=\"strong\"\/>\n+      <xs:element ref=\"dfn\"\/>\n+      <xs:element ref=\"code\"\/>\n+      <xs:element ref=\"q\"\/>\n+      <xs:element ref=\"samp\"\/>\n+      <xs:element ref=\"kbd\"\/>\n+      <xs:element ref=\"var\"\/>\n+      <xs:element ref=\"cite\"\/>\n+      <xs:element ref=\"abbr\"\/>\n+      <xs:element ref=\"acronym\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"phrase\">\n+    <xs:choice>\n+      <xs:group ref=\"phrase.basic\"\/>\n+      <xs:group ref=\"phrase.extra\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"inline.forms\">\n+    <xs:choice>\n+      <xs:element ref=\"input\"\/>\n+      <xs:element ref=\"select\"\/>\n+      <xs:element ref=\"textarea\"\/>\n+      <xs:element ref=\"label\"\/>\n+      <xs:element ref=\"button\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"misc.inline\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      these can only occur at block level\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice>\n+      <xs:element ref=\"ins\"\/>\n+      <xs:element ref=\"del\"\/>\n+      <xs:element ref=\"script\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"misc\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      these can only occur at block level\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice>\n+      <xs:element ref=\"noscript\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"inline\">\n+    <xs:choice>\n+      <xs:element ref=\"a\"\/>\n+      <xs:group ref=\"special\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:complexType name=\"Inline\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      \"Inline\" covers inline or \"text-level\" element\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Block level elements ==============================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"heading\">\n+    <xs:choice>\n+      <xs:element ref=\"h1\"\/>\n+      <xs:element ref=\"h2\"\/>\n+      <xs:element ref=\"h3\"\/>\n+      <xs:element ref=\"h4\"\/>\n+      <xs:element ref=\"h5\"\/>\n+      <xs:element ref=\"h6\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"lists\">\n+    <xs:choice>\n+      <xs:element ref=\"ul\"\/>\n+      <xs:element ref=\"ol\"\/>\n+      <xs:element ref=\"dl\"\/>\n+      <xs:element ref=\"menu\"\/>\n+      <xs:element ref=\"dir\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"blocktext\">\n+    <xs:choice>\n+      <xs:element ref=\"pre\"\/>\n+      <xs:element ref=\"hr\"\/>\n+      <xs:element ref=\"blockquote\"\/>\n+      <xs:element ref=\"address\"\/>\n+      <xs:element ref=\"center\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"block\">\n+    <xs:choice>\n+      <xs:element ref=\"p\"\/>\n+      <xs:group ref=\"heading\"\/>\n+      <xs:element ref=\"div\"\/>\n+      <xs:group ref=\"lists\"\/>\n+      <xs:group ref=\"blocktext\"\/>\n+      <xs:element ref=\"isindex\"\/>\n+      <xs:element ref=\"fieldset\"\/>\n+      <xs:element ref=\"table\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:complexType name=\"Flow\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      \"Flow\" mixes block and inline and is used for list items etc.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"block\"\/>\n+      <xs:element ref=\"form\"\/>\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Content models for exclusions =====================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:complexType name=\"a.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a elements use \"Inline\" excluding a\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"special\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"pre.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      pre uses \"Inline\" excluding img, object, applet, big, small,\n+      sub, sup, font, or basefont\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:element ref=\"a\"\/>\n+      <xs:group ref=\"special.basic\"\/>\n+      <xs:group ref=\"fontstyle.basic\"\/>\n+      <xs:group ref=\"phrase.basic\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"form.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      form uses \"Flow\" excluding form\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"block\"\/>\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"button.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      button uses \"Flow\" but excludes a, form, form controls, iframe\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:element ref=\"p\"\/>\n+      <xs:group ref=\"heading\"\/>\n+      <xs:element ref=\"div\"\/>\n+      <xs:group ref=\"lists\"\/>\n+      <xs:group ref=\"blocktext\"\/>\n+      <xs:element ref=\"table\"\/>\n+      <xs:element ref=\"br\"\/>\n+      <xs:element ref=\"span\"\/>\n+      <xs:element ref=\"bdo\"\/>\n+      <xs:element ref=\"object\"\/>\n+      <xs:element ref=\"applet\"\/>\n+      <xs:element ref=\"img\"\/>\n+      <xs:element ref=\"map\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Document Structure ==================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"html\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element ref=\"head\"\/>\n+        <xs:element ref=\"frameset\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Document Head =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"head.misc\">\n+    <xs:sequence>\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"script\"\/>\n+        <xs:element ref=\"style\"\/>\n+        <xs:element ref=\"meta\"\/>\n+        <xs:element ref=\"link\"\/>\n+        <xs:element ref=\"object\"\/>\n+        <xs:element ref=\"isindex\"\/>\n+      <\/xs:choice>\n+    <\/xs:sequence>\n+  <\/xs:group>\n+\n+  <xs:element name=\"head\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content model is \"head.misc\" combined with a single\n+      title and an optional base element in any order\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:group ref=\"head.misc\"\/>\n+        <xs:choice>\n+          <xs:sequence>\n+            <xs:element ref=\"title\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+            <xs:sequence minOccurs=\"0\">\n+              <xs:element ref=\"base\"\/>\n+              <xs:group ref=\"head.misc\"\/>\n+            <\/xs:sequence>\n+          <\/xs:sequence>\n+          <xs:sequence>\n+            <xs:element ref=\"base\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+            <xs:element ref=\"title\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+          <\/xs:sequence>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"profile\" type=\"URI\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"title\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The title element is not considered part of the flow of text.\n+      It should be displayed, for example as the page header or\n+      window title. Exactly one title is required per document.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"base\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      document base URI\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"meta\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic metainformation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"http-equiv\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"content\" use=\"required\"\/>\n+      <xs:attribute name=\"scheme\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"link\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Relationship values can be used in principle:\n+\n+      a) for document specific toolbars\/menus when used\n+         with the link element in document head e.g.\n+           start, contents, previous, next, index, end, help\n+      b) to link to a separate style sheet (rel=\"stylesheet\")\n+      c) to make a link to a script (rel=\"script\")\n+      d) by stylesheets to control how collections of\n+         html nodes are rendered into printed documents\n+      e) to make a link to a printable version of this document\n+         e.g. a PostScript or PDF version (rel=\"alternate\" media=\"print\")\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"hreflang\" type=\"LanguageCode\"\/>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"rel\" type=\"LinkTypes\"\/>\n+      <xs:attribute name=\"rev\" type=\"LinkTypes\"\/>\n+      <xs:attribute name=\"media\" type=\"MediaDesc\"\/>\n+      <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"style\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      style info, which may include CDATA sections\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"type\" use=\"required\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"media\" type=\"MediaDesc\"\/>\n+      <xs:attribute name=\"title\" type=\"Text\"\/>\n+      <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"script\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      script statements, which may include CDATA sections\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+      <xs:attribute name=\"type\" use=\"required\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"language\"\/>\n+      <xs:attribute name=\"src\" type=\"URI\"\/>\n+      <xs:attribute name=\"defer\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"defer\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"noscript\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      alternate content container for non script-based rendering\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ======================= Frames =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"frameset\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      only one noframes element permitted per document\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"frameset\"\/>\n+        <xs:element ref=\"frame\"\/>\n+        <xs:element ref=\"noframes\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attribute name=\"rows\" type=\"MultiLengths\"\/>\n+      <xs:attribute name=\"cols\" type=\"MultiLengths\"\/>\n+      <xs:attribute name=\"onload\" type=\"Script\"\/>\n+      <xs:attribute name=\"onunload\" type=\"Script\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    reserved frame names start with \"_\" otherwise starts with letter\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"frame\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      tiled window within frameset\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attribute name=\"longdesc\" type=\"URI\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"src\" type=\"URI\"\/>\n+      <xs:attribute name=\"frameborder\" default=\"1\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"1\"\/>\n+            <xs:enumeration value=\"0\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"marginwidth\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"marginheight\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"noresize\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"noresize\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"scrolling\" default=\"auto\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"yes\"\/>\n+            <xs:enumeration value=\"no\"\/>\n+            <xs:enumeration value=\"auto\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"iframe\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      inline subwindow\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"coreattrs\"\/>\n+          <xs:attribute name=\"longdesc\" type=\"URI\"\/>\n+          <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+          <xs:attribute name=\"src\" type=\"URI\"\/>\n+          <xs:attribute name=\"frameborder\" default=\"1\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"1\"\/>\n+                <xs:enumeration value=\"0\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"marginwidth\" type=\"Pixels\"\/>\n+          <xs:attribute name=\"marginheight\" type=\"Pixels\"\/>\n+          <xs:attribute name=\"scrolling\" default=\"auto\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"yes\"\/>\n+                <xs:enumeration value=\"no\"\/>\n+                <xs:enumeration value=\"auto\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+          <xs:attribute name=\"height\" type=\"Length\"\/>\n+          <xs:attribute name=\"width\" type=\"Length\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+<!--\n+  <xs:element name=\"noframes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      alternate content container for non frame-based rendering\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"body\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+-->\n+  <xs:element name=\"noframes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      alternate content container for non frame-based rendering\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element ref=\"body\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Document Body ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"body\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"onload\" type=\"Script\"\/>\n+          <xs:attribute name=\"onunload\" type=\"Script\"\/>\n+          <xs:attribute name=\"background\" type=\"URI\"\/>\n+          <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+          <xs:attribute name=\"text\" type=\"Color\"\/>\n+          <xs:attribute name=\"link\" type=\"Color\"\/>\n+          <xs:attribute name=\"vlink\" type=\"Color\"\/>\n+          <xs:attribute name=\"alink\" type=\"Color\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"div\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic language\/style container      \n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Paragraphs =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"p\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Headings =========================================\n+\n+    There are six levels of headings from h1 (the most important)\n+    to h6 (the least important).\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"h1\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h2\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h3\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h4\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h5\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h6\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Lists ============================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"ULStyle\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Unordered list bullet styles\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"disc\"\/>\n+      <xs:enumeration value=\"square\"\/>\n+      <xs:enumeration value=\"circle\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"ul\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Unordered list\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"type\" type=\"ULStyle\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"OLStyle\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Ordered list numbering style\n+\n+      1   arabic numbers      1, 2, 3, ...\n+      a   lower alpha         a, b, c, ...\n+      A   upper alpha         A, B, C, ...\n+      i   lower roman         i, ii, iii, ...\n+      I   upper roman         I, II, III, ...\n+\n+      The style is applied to the sequence number which by default\n+      is reset to 1 for the first list item in an ordered list.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"ol\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Ordered (numbered) list\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"type\" type=\"OLStyle\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"start\" type=\"Number\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"menu\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      single column list (DEPRECATED)\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dir\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      multiple column list (DEPRECATED)\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"LIStyle\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      LIStyle is constrained to: \"(ULStyle|OLStyle)\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"li\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      list item\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"type\" type=\"LIStyle\"\/>\n+          <xs:attribute name=\"value\" type=\"Number\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    definition lists - dt for term, dd for its definition\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"dl\">\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"dt\"\/>\n+        <xs:element ref=\"dd\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dt\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dd\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Address ==========================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"address\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      information on author\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:group ref=\"inline\"\/>\n+        <xs:group ref=\"misc.inline\"\/>\n+        <xs:element ref=\"p\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Horizontal Rule ==================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"hr\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"align\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"left\"\/>\n+            <xs:enumeration value=\"center\"\/>\n+            <xs:enumeration value=\"right\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"noshade\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"noshade\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"size\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Preformatted Text ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"pre\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content is \"Inline\" excluding \n+         \"img|object|applet|big|small|sub|sup|font|basefont\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"pre.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"width\" type=\"Number\"\/>\n+          <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Block-like Quotes ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"blockquote\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Text alignment ===================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"center\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      center content\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Inserted\/Deleted Text ============================\n+\n+    ins\/del are allowed in block and inline content, but its\n+    inappropriate to include block content within an ins element\n+    occurring in inline content.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"ins\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+          <xs:attribute name=\"datetime\" type=\"Datetime\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"del\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+          <xs:attribute name=\"datetime\" type=\"Datetime\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== The Anchor Element ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"a\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content is \"Inline\" except that anchors shouldn't be nested\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"a.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"focus\"\/>\n+          <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+          <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+          <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+          <xs:attribute name=\"href\" type=\"URI\"\/>\n+          <xs:attribute name=\"hreflang\" type=\"LanguageCode\"\/>\n+          <xs:attribute name=\"rel\" type=\"LinkTypes\"\/>\n+          <xs:attribute name=\"rev\" type=\"LinkTypes\"\/>\n+          <xs:attribute name=\"shape\" default=\"rect\" type=\"Shape\"\/>\n+          <xs:attribute name=\"coords\" type=\"Coords\"\/>\n+          <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ===================== Inline Elements ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"span\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic language\/style container\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"bdo\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      I18N BiDi over-ride\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"coreattrs\"\/>\n+          <xs:attributeGroup ref=\"events\"\/>\n+          <xs:attribute name=\"lang\" type=\"LanguageCode\"\/>\n+          <xs:attribute ref=\"xml:lang\"\/>\n+          <xs:attribute name=\"dir\" use=\"required\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"ltr\"\/>\n+                <xs:enumeration value=\"rtl\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"br\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      forced line break\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attribute name=\"clear\" default=\"none\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"left\"\/>\n+            <xs:enumeration value=\"all\"\/>\n+            <xs:enumeration value=\"right\"\/>\n+            <xs:enumeration value=\"none\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"em\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      emphasis\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"strong\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      strong emphasis\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dfn\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      definitional\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"code\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      program code\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"samp\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      sample\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"kbd\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      something user would type\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"var\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      variable\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"cite\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      citation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"abbr\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      abbreviation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"acronym\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      acronym\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"q\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      inlined quote\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"sub\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      subscript\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"sup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      superscript\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tt\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      fixed pitch font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"i\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      italic font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"b\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      bold font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"big\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      bigger font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"small\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      smaller font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"u\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      underline\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"s\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      strike-through\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"strike\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      strike-through\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"basefont\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      base font size\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"size\" use=\"required\"\/>\n+      <xs:attribute name=\"color\" type=\"Color\"\/>\n+      <xs:attribute name=\"face\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"font\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      local change to font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"coreattrs\"\/>\n+          <xs:attributeGroup ref=\"i18n\"\/>\n+          <xs:attribute name=\"size\"\/>\n+          <xs:attribute name=\"color\" type=\"Color\"\/>\n+          <xs:attribute name=\"face\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ==================== Object ======================================\n+\n+    object is used to embed objects as part of HTML pages.\n+    param elements should precede other content. Parameters\n+    can also be expressed as attribute\/value pairs on the\n+    object element itself when brevity is desired.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"object\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"param\"\/>\n+        <xs:group ref=\"block\"\/>\n+        <xs:element ref=\"form\"\/>\n+        <xs:group ref=\"inline\"\/>\n+        <xs:group ref=\"misc\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"declare\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"declare\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"classid\" type=\"URI\"\/>\n+      <xs:attribute name=\"codebase\" type=\"URI\"\/>\n+      <xs:attribute name=\"data\" type=\"URI\"\/>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"codetype\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"archive\" type=\"UriList\"\/>\n+      <xs:attribute name=\"standby\" type=\"Text\"\/>\n+      <xs:attribute name=\"height\" type=\"Length\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"tabindex\" type=\"Number\"\/>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+      <xs:attribute name=\"border\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"hspace\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"vspace\" type=\"Pixels\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"param\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      param is used to supply a named property value.\n+      In XML it would seem natural to follow RDF and support an\n+      abbreviated syntax where the param elements are replaced\n+      by attribute value pairs on the object start tag.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"name\" use=\"required\"\/>\n+      <xs:attribute name=\"value\"\/>\n+      <xs:attribute name=\"valuetype\" default=\"data\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"data\"\/>\n+            <xs:enumeration value=\"ref\"\/>\n+            <xs:enumeration value=\"object\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Java applet ==================================\n+\n+    One of code or object attributes must be present.\n+    Place param elements before other content.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"applet\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"param\"\/>\n+        <xs:group ref=\"block\"\/>\n+        <xs:element ref=\"form\"\/>\n+        <xs:group ref=\"inline\"\/>\n+        <xs:group ref=\"misc\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attribute name=\"codebase\" type=\"URI\"\/>\n+      <xs:attribute name=\"archive\"\/>\n+      <xs:attribute name=\"code\"\/>\n+      <xs:attribute name=\"object\"\/>\n+      <xs:attribute name=\"alt\" type=\"Text\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"width\" use=\"required\" type=\"Length\"\/>\n+      <xs:attribute name=\"height\" use=\"required\" type=\"Length\"\/>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+      <xs:attribute name=\"hspace\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"vspace\" type=\"Pixels\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Images ===========================================\n+\n+    To avoid accessibility problems for people who aren't\n+    able to see the image, you should provide a text\n+    description using the alt and longdesc attributes.\n+    In addition, avoid the use of server-side image maps.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"img\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"src\" use=\"required\" type=\"URI\"\/>\n+      <xs:attribute name=\"alt\" use=\"required\" type=\"Text\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"longdesc\" type=\"URI\"\/>\n+      <xs:attribute name=\"height\" type=\"Length\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\">\n+\t<xs:annotation>\n+\t  <xs:documentation>\n+          usemap points to a map element which may be in this document\n+          or an external document, although the latter is not widely supported\n+          <\/xs:documentation>\n+\t<\/xs:annotation>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"ismap\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"ismap\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+      <xs:attribute name=\"border\" type=\"Length\"\/>\n+      <xs:attribute name=\"hspace\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"vspace\" type=\"Pixels\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Client-side image maps ============================\n+\n+    These can be placed in the same document or grouped in a\n+    separate document although this isn't yet widely supported\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"map\">\n+    <xs:complexType>\n+      <xs:choice>\n+        <xs:choice maxOccurs=\"unbounded\">\n+          <xs:group ref=\"block\"\/>\n+          <xs:element ref=\"form\"\/>\n+          <xs:group ref=\"misc\"\/>\n+        <\/xs:choice>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"area\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attributeGroup ref=\"events\"\/>\n+      <xs:attribute name=\"id\" use=\"required\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"class\"\/>\n+      <xs:attribute name=\"style\" type=\"StyleSheet\"\/>\n+      <xs:attribute name=\"title\" type=\"Text\"\/>\n+      <xs:attribute name=\"name\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"area\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"shape\" default=\"rect\" type=\"Shape\"\/>\n+      <xs:attribute name=\"coords\" type=\"Coords\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"nohref\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"nohref\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"alt\" use=\"required\" type=\"Text\"\/>\n+      <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Forms ===============================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"form\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"form.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"action\" use=\"required\" type=\"URI\"\/>\n+          <xs:attribute name=\"method\" default=\"get\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"get\"\/>\n+                <xs:enumeration value=\"post\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"enctype\" type=\"ContentType\"\n+              default=\"application\/x-www-form-urlencoded\"\/>\n+          <xs:attribute name=\"onsubmit\" type=\"Script\"\/>\n+          <xs:attribute name=\"onreset\" type=\"Script\"\/>\n+          <xs:attribute name=\"accept\" type=\"ContentTypes\"\/>\n+          <xs:attribute name=\"accept-charset\" type=\"Charsets\"\/>\n+          <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"label\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Each label must not contain more than ONE field\n+      Label elements shouldn't be nested.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"for\" type=\"xs:IDREF\"\/>\n+          <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+          <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+          <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"InputType\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"text\"\/>\n+      <xs:enumeration value=\"password\"\/>\n+      <xs:enumeration value=\"checkbox\"\/>\n+      <xs:enumeration value=\"radio\"\/>\n+      <xs:enumeration value=\"submit\"\/>\n+      <xs:enumeration value=\"reset\"\/>\n+      <xs:enumeration value=\"file\"\/>\n+      <xs:enumeration value=\"hidden\"\/>\n+      <xs:enumeration value=\"image\"\/>\n+      <xs:enumeration value=\"button\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"input\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      form control\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"type\" default=\"text\" type=\"InputType\"\/>\n+      <xs:attribute name=\"name\">\n+\t<xs:annotation>\n+\t  <xs:documentation>\n+          the name attribute is required for all but submit &amp; reset\n+          <\/xs:documentation>\n+\t<\/xs:annotation>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"value\"\/>\n+      <xs:attribute name=\"checked\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"checked\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"readonly\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"readonly\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"size\"\/>\n+      <xs:attribute name=\"maxlength\" type=\"Number\"\/>\n+      <xs:attribute name=\"src\" type=\"URI\"\/>\n+      <xs:attribute name=\"alt\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\"\/>\n+      <xs:attribute name=\"onselect\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+      <xs:attribute name=\"accept\" type=\"ContentTypes\"\/>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"select\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      option selector\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"optgroup\"\/>\n+        <xs:element ref=\"option\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"size\" type=\"Number\"\/>\n+      <xs:attribute name=\"multiple\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"multiple\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"tabindex\" type=\"tabindexNumber\"\/>\n+      <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+      <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"optgroup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      option group\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"option\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"label\" use=\"required\" type=\"Text\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"option\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      selectable choice\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"selected\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"selected\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"label\" type=\"Text\"\/>\n+      <xs:attribute name=\"value\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"textarea\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      multi-line text field\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"rows\" use=\"required\" type=\"Number\"\/>\n+      <xs:attribute name=\"cols\" use=\"required\" type=\"Number\"\/>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"readonly\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"readonly\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"onselect\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"fieldset\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The fieldset element is used to group form fields.\n+      Only one legend element should occur in the content\n+      and if present should only be preceded by whitespace.\n+\n+      NOTE: this content model is different from the XHTML 1.0 DTD,\n+      closer to the intended content model in HTML4 DTD\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:sequence>\n+        <xs:element ref=\"legend\"\/>\n+        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+          <xs:group ref=\"block\"\/>\n+          <xs:element ref=\"form\"\/>\n+          <xs:group ref=\"inline\"\/>\n+          <xs:group ref=\"misc\"\/>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"LAlign\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"top\"\/>\n+      <xs:enumeration value=\"bottom\"\/>\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"legend\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      fieldset label\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+          <xs:attribute name=\"align\" type=\"LAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"button\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Content is \"Flow\" excluding a, form and form controls\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"button.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"focus\"\/>\n+          <xs:attribute name=\"name\"\/>\n+          <xs:attribute name=\"value\"\/>\n+          <xs:attribute name=\"type\" default=\"submit\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"button\"\/>\n+                <xs:enumeration value=\"submit\"\/>\n+                <xs:enumeration value=\"reset\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"disabled\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"isindex\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      single-line text input control (DEPRECATED)\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"prompt\" type=\"Text\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ======================= Tables =======================================\n+\n+    Derived from IETF HTML table standard, see [RFC1942]\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"TFrame\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The border attribute sets the thickness of the frame around the\n+      table. The default units are screen pixels.\n+\n+      The frame attribute specifies which parts of the frame around\n+      the table should be rendered. The values are not the same as\n+      CALS to avoid a name clash with the valign attribute.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"void\"\/>\n+      <xs:enumeration value=\"above\"\/>\n+      <xs:enumeration value=\"below\"\/>\n+      <xs:enumeration value=\"hsides\"\/>\n+      <xs:enumeration value=\"lhs\"\/>\n+      <xs:enumeration value=\"rhs\"\/>\n+      <xs:enumeration value=\"vsides\"\/>\n+      <xs:enumeration value=\"box\"\/>\n+      <xs:enumeration value=\"border\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"TRules\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The rules attribute defines which rules to draw between cells:\n+\n+      If rules is absent then assume:\n+          \"none\" if border is absent or border=\"0\" otherwise \"all\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"none\"\/>\n+      <xs:enumeration value=\"groups\"\/>\n+      <xs:enumeration value=\"rows\"\/>\n+      <xs:enumeration value=\"cols\"\/>\n+      <xs:enumeration value=\"all\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"TAlign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      horizontal placement of table relative to document\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"center\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:attributeGroup name=\"cellhalign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      horizontal alignment attributes for cell contents\n+\n+      char        alignment char, e.g. char=\":\"\n+      charoff     offset for alignment char\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"align\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"left\"\/>\n+          <xs:enumeration value=\"center\"\/>\n+          <xs:enumeration value=\"right\"\/>\n+          <xs:enumeration value=\"justify\"\/>\n+          <xs:enumeration value=\"char\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"char\" type=\"Character\"\/>\n+    <xs:attribute name=\"charoff\" type=\"Length\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"cellvalign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      vertical alignment attributes for cell contents\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"valign\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"top\"\/>\n+          <xs:enumeration value=\"middle\"\/>\n+          <xs:enumeration value=\"bottom\"\/>\n+          <xs:enumeration value=\"baseline\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:element name=\"table\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element minOccurs=\"0\" ref=\"caption\"\/>\n+        <xs:choice>\n+          <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"col\"\/>\n+          <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"colgroup\"\/>\n+        <\/xs:choice>\n+        <xs:element minOccurs=\"0\" ref=\"thead\"\/>\n+        <xs:element minOccurs=\"0\" ref=\"tfoot\"\/>\n+        <xs:choice>\n+          <xs:element maxOccurs=\"unbounded\" ref=\"tbody\"\/>\n+          <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"summary\" type=\"Text\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"border\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"frame\" type=\"TFrame\"\/>\n+      <xs:attribute name=\"rules\" type=\"TRules\"\/>\n+      <xs:attribute name=\"cellspacing\" type=\"Length\"\/>\n+      <xs:attribute name=\"cellpadding\" type=\"Length\"\/>\n+      <xs:attribute name=\"align\" type=\"TAlign\"\/>\n+      <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"CAlign\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"top\"\/>\n+      <xs:enumeration value=\"bottom\"\/>\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"caption\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"align\" type=\"CAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    Use thead to duplicate headers when breaking table\n+    across page boundaries, or for static headers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use tfoot to duplicate footers when breaking table\n+    across page boundaries, or for static footers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use multiple tbody sections when rules are needed\n+    between groups of table rows.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"thead\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tfoot\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tbody\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"colgroup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      colgroup groups a set of col elements. It allows you to group\n+      several semantically related columns together.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"col\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"span\" default=\"1\" type=\"Number\"\/>\n+      <xs:attribute name=\"width\" type=\"MultiLength\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"col\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      col elements define the alignment properties for cells in\n+      one or more columns.\n+\n+      The width attribute specifies the width of the columns, e.g.\n+\n+          width=64        width in screen pixels\n+          width=0.5*      relative width of 0.5\n+\n+      The span attribute causes the attributes of one\n+      col element to apply to more than one column.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"span\" default=\"1\" type=\"Number\"\/>\n+      <xs:attribute name=\"width\" type=\"MultiLength\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tr\">\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"th\"\/>\n+        <xs:element ref=\"td\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+      <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"Scope\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Scope is simpler than headers attribute for common tables\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"row\"\/>\n+      <xs:enumeration value=\"col\"\/>\n+      <xs:enumeration value=\"rowgroup\"\/>\n+      <xs:enumeration value=\"colgroup\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    th is for headers, td for data and for cells acting as both\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"th\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"abbr\" type=\"Text\"\/>\n+          <xs:attribute name=\"axis\"\/>\n+          <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+          <xs:attribute name=\"scope\" type=\"Scope\"\/>\n+          <xs:attribute name=\"rowspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attribute name=\"colspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attributeGroup ref=\"cellhalign\"\/>\n+          <xs:attributeGroup ref=\"cellvalign\"\/>\n+          <xs:attribute name=\"nowrap\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"nowrap\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+          <xs:attribute name=\"width\" type=\"Length\"\/>\n+          <xs:attribute name=\"height\" type=\"Length\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"td\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"abbr\" type=\"Text\"\/>\n+          <xs:attribute name=\"axis\"\/>\n+          <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+          <xs:attribute name=\"scope\" type=\"Scope\"\/>\n+          <xs:attribute name=\"rowspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attribute name=\"colspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attributeGroup ref=\"cellhalign\"\/>\n+          <xs:attributeGroup ref=\"cellvalign\"\/>\n+          <xs:attribute name=\"nowrap\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"nowrap\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+          <xs:attribute name=\"width\" type=\"Length\"\/>\n+          <xs:attribute name=\"height\" type=\"Length\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml10\/xhtml1-frameset.xsd","additions":2847,"deletions":0,"binary":false,"changes":2847,"status":"added"},{"patch":"@@ -0,0 +1,2211 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema version=\"1.0\" xml:lang=\"en\"\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+    targetNamespace=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns:xml=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+    elementFormDefault=\"qualified\">\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    XHTML 1.0 (Second Edition) Strict in XML Schema\n+\n+    This is the same as HTML 4 Strict except for\n+    changes due to the differences between XML and SGML.\n+\n+    Namespace = http:\/\/www.w3.org\/1999\/xhtml\n+\n+    For further information, see: http:\/\/www.w3.org\/TR\/xhtml1\n+\n+    Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),\n+    All Rights Reserved. \n+\n+    The DTD version is identified by the PUBLIC and SYSTEM identifiers:\n+\n+    PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-strict.dtd\"\n+\n+    $Id: xhtml1-strict.xsd,v 1.2 2002\/08\/28 08:05:44 mimasa Exp $\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+      schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\"\/>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Character mnemonic entities =========================\n+\n+    XHTML entity sets are identified by the PUBLIC and SYSTEM identifiers:\n+  \n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-lat1.ent\"\n+\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-special.ent\"\n+\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-symbol.ent\"\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Imported Names ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"ContentType\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      media type, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"ContentTypes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      comma-separated list of media types, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Charset\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a character encoding, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Charsets\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a space separated list of character encodings, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"LanguageCode\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a language code, as per [RFC3066]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:language\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Character\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a single character, as per section 2.2 of [XML]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:length value=\"1\" fixed=\"true\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Number\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      one or more digits\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\">\n+      <xs:pattern value=\"[0-9]+\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"tabindexNumber\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      tabindex attribute specifies the position of the current element\n+      in the tabbing order for the current document. This value must be\n+      a number between 0 and 32767. User agents should ignore leading zeros. \n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"Number\">\n+      <xs:minInclusive value=\"0\"\/>\n+      <xs:maxInclusive value=\"32767\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"LinkTypes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      space-separated list of link types\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NMTOKENS\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"MediaDesc\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      single or comma-separated list of media descriptors\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[^,]+(,\\s*[^,]+)*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"URI\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a Uniform Resource Identifier, see [RFC2396]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anyURI\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"UriList\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a space separated list of Uniform Resource Identifiers\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Datetime\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      date and time information. ISO date format\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:dateTime\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Script\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      script expression\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"StyleSheet\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      style sheet data\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Text\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      used for titles etc.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Length\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      nn for pixels or nn% for percentage length\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"MultiLength\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      pixel, percentage, or relative\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)|[1-9]?(\\d+)?\\*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Pixels\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      integer representing length in pixels\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    these are used for image maps\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"Shape\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"rect\"\/>\n+      <xs:enumeration value=\"circle\"\/>\n+      <xs:enumeration value=\"poly\"\/>\n+      <xs:enumeration value=\"default\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Coords\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      comma separated list of lengths\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern\n+          value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)(,\\s*[-+]?(\\d+|\\d+(\\.\\d+)?%))*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Generic Attributes ===============================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:attributeGroup name=\"coreattrs\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      core attributes common to most elements\n+      id       document-wide unique id\n+      class    space separated list of classes\n+      style    associated style info\n+      title    advisory title\/amplification\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <xs:attribute name=\"class\" type=\"xs:NMTOKENS\"\/>\n+    <xs:attribute name=\"style\" type=\"StyleSheet\"\/>\n+    <xs:attribute name=\"title\" type=\"Text\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"i18n\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      internationalization attributes\n+      lang        language code (backwards compatible)\n+      xml:lang    language code (as per XML 1.0 spec)\n+      dir         direction for weak\/neutral text\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"lang\" type=\"LanguageCode\"\/>\n+    <xs:attribute ref=\"xml:lang\"\/>\n+    <xs:attribute name=\"dir\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"ltr\"\/>\n+          <xs:enumeration value=\"rtl\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"events\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      attributes for common UI events\n+      onclick     a pointer button was clicked\n+      ondblclick  a pointer button was double clicked\n+      onmousedown a pointer button was pressed down\n+      onmouseup   a pointer button was released\n+      onmousemove a pointer was moved onto the element\n+      onmouseout  a pointer was moved away from the element\n+      onkeypress  a key was pressed and released\n+      onkeydown   a key was pressed down\n+      onkeyup     a key was released\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"onclick\" type=\"Script\"\/>\n+    <xs:attribute name=\"ondblclick\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmousedown\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseup\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseover\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmousemove\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseout\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeypress\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeydown\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeyup\" type=\"Script\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"focus\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      attributes for elements that can get the focus\n+      accesskey   accessibility key character\n+      tabindex    position in tabbing order\n+      onfocus     the element got the focus\n+      onblur      the element lost the focus\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+    <xs:attribute name=\"tabindex\" type=\"tabindexNumber\"\/>\n+    <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+    <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"attrs\">\n+    <xs:attributeGroup ref=\"coreattrs\"\/>\n+    <xs:attributeGroup ref=\"i18n\"\/>\n+    <xs:attributeGroup ref=\"events\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Text Elements ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"special.pre\">\n+    <xs:choice>\n+      <xs:element ref=\"br\"\/>\n+      <xs:element ref=\"span\"\/>\n+      <xs:element ref=\"bdo\"\/>\n+      <xs:element ref=\"map\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"special\">\n+    <xs:choice>\n+      <xs:group ref=\"special.pre\"\/>\n+      <xs:element ref=\"object\"\/>\n+      <xs:element ref=\"img\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"fontstyle\">\n+    <xs:choice>\n+      <xs:element ref=\"tt\"\/>\n+      <xs:element ref=\"i\"\/>\n+      <xs:element ref=\"b\"\/>\n+      <xs:element ref=\"big\"\/>\n+      <xs:element ref=\"small\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"phrase\">\n+    <xs:choice>\n+      <xs:element ref=\"em\"\/>\n+      <xs:element ref=\"strong\"\/>\n+      <xs:element ref=\"dfn\"\/>\n+      <xs:element ref=\"code\"\/>\n+      <xs:element ref=\"q\"\/>\n+      <xs:element ref=\"samp\"\/>\n+      <xs:element ref=\"kbd\"\/>\n+      <xs:element ref=\"var\"\/>\n+      <xs:element ref=\"cite\"\/>\n+      <xs:element ref=\"abbr\"\/>\n+      <xs:element ref=\"acronym\"\/>\n+      <xs:element ref=\"sub\"\/>\n+      <xs:element ref=\"sup\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"inline.forms\">\n+    <xs:choice>\n+      <xs:element ref=\"input\"\/>\n+      <xs:element ref=\"select\"\/>\n+      <xs:element ref=\"textarea\"\/>\n+      <xs:element ref=\"label\"\/>\n+      <xs:element ref=\"button\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"misc.inline\">\n+    <xs:choice>\n+      <xs:element ref=\"ins\"\/>\n+      <xs:element ref=\"del\"\/>\n+      <xs:element ref=\"script\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"misc\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      these can only occur at block level\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice>\n+      <xs:element ref=\"noscript\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"inline\">\n+    <xs:choice>\n+      <xs:element ref=\"a\"\/>\n+      <xs:group ref=\"special\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:complexType name=\"Inline\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      \"Inline\" covers inline or \"text-level\" elements\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Block level elements ==============================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"heading\">\n+    <xs:choice>\n+      <xs:element ref=\"h1\"\/>\n+      <xs:element ref=\"h2\"\/>\n+      <xs:element ref=\"h3\"\/>\n+      <xs:element ref=\"h4\"\/>\n+      <xs:element ref=\"h5\"\/>\n+      <xs:element ref=\"h6\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"lists\">\n+    <xs:choice>\n+      <xs:element ref=\"ul\"\/>\n+      <xs:element ref=\"ol\"\/>\n+      <xs:element ref=\"dl\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"blocktext\">\n+    <xs:choice>\n+      <xs:element ref=\"pre\"\/>\n+      <xs:element ref=\"hr\"\/>\n+      <xs:element ref=\"blockquote\"\/>\n+      <xs:element ref=\"address\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"block\">\n+    <xs:choice>\n+      <xs:element ref=\"p\"\/>\n+      <xs:group ref=\"heading\"\/>\n+      <xs:element ref=\"div\"\/>\n+      <xs:group ref=\"lists\"\/>\n+      <xs:group ref=\"blocktext\"\/>\n+      <xs:element ref=\"fieldset\"\/>\n+      <xs:element ref=\"table\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:complexType name=\"Block\">\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"block\"\/>\n+      <xs:element ref=\"form\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"Flow\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      \"Flow\" mixes block and inline and is used for list items etc.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"block\"\/>\n+      <xs:element ref=\"form\"\/>\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Content models for exclusions =====================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:complexType name=\"a.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a elements use \"Inline\" excluding a\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"special\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"pre.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      pre uses \"Inline\" excluding big, small, sup or sup\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:element ref=\"a\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"special.pre\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"form.content\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      form uses \"Block\" excluding form\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"block\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"button.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      button uses \"Flow\" but excludes a, form and form controls\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:element ref=\"p\"\/>\n+      <xs:group ref=\"heading\"\/>\n+      <xs:element ref=\"div\"\/>\n+      <xs:group ref=\"lists\"\/>\n+      <xs:group ref=\"blocktext\"\/>\n+      <xs:element ref=\"table\"\/>\n+      <xs:group ref=\"special\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Document Structure ==================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"html\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element ref=\"head\"\/>\n+        <xs:element ref=\"body\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Document Head =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"head.misc\">\n+    <xs:sequence>\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"script\"\/>\n+        <xs:element ref=\"style\"\/>\n+        <xs:element ref=\"meta\"\/>\n+        <xs:element ref=\"link\"\/>\n+        <xs:element ref=\"object\"\/>\n+      <\/xs:choice>\n+    <\/xs:sequence>\n+  <\/xs:group>\n+\n+  <xs:element name=\"head\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content model is \"head.misc\" combined with a single\n+      title and an optional base element in any order\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:group ref=\"head.misc\"\/>\n+        <xs:choice>\n+          <xs:sequence>\n+            <xs:element ref=\"title\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+            <xs:sequence minOccurs=\"0\">\n+              <xs:element ref=\"base\"\/>\n+              <xs:group ref=\"head.misc\"\/>\n+            <\/xs:sequence>\n+          <\/xs:sequence>\n+          <xs:sequence>\n+            <xs:element ref=\"base\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+            <xs:element ref=\"title\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+          <\/xs:sequence>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"profile\" type=\"URI\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"title\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The title element is not considered part of the flow of text.\n+      It should be displayed, for example as the page header or\n+      window title. Exactly one title is required per document.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"base\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      document base URI\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"href\" use=\"required\" type=\"URI\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"meta\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic metainformation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"http-equiv\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"content\" use=\"required\"\/>\n+      <xs:attribute name=\"scheme\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"link\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Relationship values can be used in principle:\n+\n+      a) for document specific toolbars\/menus when used\n+         with the link element in document head e.g.\n+           start, contents, previous, next, index, end, help\n+      b) to link to a separate style sheet (rel=\"stylesheet\")\n+      c) to make a link to a script (rel=\"script\")\n+      d) by stylesheets to control how collections of\n+         html nodes are rendered into printed documents\n+      e) to make a link to a printable version of this document\n+         e.g. a PostScript or PDF version (rel=\"alternate\" media=\"print\")\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"hreflang\" type=\"LanguageCode\"\/>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"rel\" type=\"LinkTypes\"\/>\n+      <xs:attribute name=\"rev\" type=\"LinkTypes\"\/>\n+      <xs:attribute name=\"media\" type=\"MediaDesc\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"style\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      style info, which may include CDATA sections\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"type\" use=\"required\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"media\" type=\"MediaDesc\"\/>\n+      <xs:attribute name=\"title\" type=\"Text\"\/>\n+      <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"script\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      script statements, which may include CDATA sections\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+      <xs:attribute name=\"type\" use=\"required\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"src\" type=\"URI\"\/>\n+      <xs:attribute name=\"defer\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"defer\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"noscript\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      alternate content container for non script-based rendering\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:complexContent>\n+        <xs:extension base=\"Block\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Document Body ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"body\">\n+    <xs:complexType>\n+      <xs:complexContent>\n+        <xs:extension base=\"Block\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"onload\" type=\"Script\"\/>\n+          <xs:attribute name=\"onunload\" type=\"Script\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"div\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic language\/style container      \n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Paragraphs =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"p\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Headings =========================================\n+\n+    There are six levels of headings from h1 (the most important)\n+    to h6 (the least important).\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"h1\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h2\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h3\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h4\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h5\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h6\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Lists ============================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"ul\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Unordered list\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"ol\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Ordered (numbered) list\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"li\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      list item\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    definition lists - dt for term, dd for its definition\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"dl\">\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"dt\"\/>\n+        <xs:element ref=\"dd\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dt\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dd\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Address ==========================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"address\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      information on author\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Horizontal Rule ==================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"hr\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Preformatted Text ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"pre\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content is \"Inline\" excluding \"img|object|big|small|sub|sup\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"pre.content\">\n+           <xs:attributeGroup ref=\"attrs\"\/>\n+           <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Block-like Quotes ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"blockquote\">\n+    <xs:complexType>\n+      <xs:complexContent>\n+        <xs:extension base=\"Block\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Inserted\/Deleted Text ============================\n+\n+    ins\/del are allowed in block and inline content, but its\n+    inappropriate to include block content within an ins element\n+    occurring in inline content.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"ins\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+          <xs:attribute name=\"datetime\" type=\"Datetime\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"del\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+          <xs:attribute name=\"datetime\" type=\"Datetime\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== The Anchor Element ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"a\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content is \"Inline\" except that anchors shouldn't be nested\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"a.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"focus\"\/>\n+          <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+          <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+          <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+          <xs:attribute name=\"href\" type=\"URI\"\/>\n+          <xs:attribute name=\"hreflang\" type=\"LanguageCode\"\/>\n+          <xs:attribute name=\"rel\" type=\"LinkTypes\"\/>\n+          <xs:attribute name=\"rev\" type=\"LinkTypes\"\/>\n+          <xs:attribute name=\"shape\" default=\"rect\" type=\"Shape\"\/>\n+          <xs:attribute name=\"coords\" type=\"Coords\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ===================== Inline Elements ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"span\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic language\/style container\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"bdo\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      I18N BiDi over-ride\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"coreattrs\"\/>\n+          <xs:attributeGroup ref=\"events\"\/>\n+          <xs:attribute name=\"lang\" type=\"LanguageCode\"\/>\n+          <xs:attribute ref=\"xml:lang\"\/>\n+          <xs:attribute name=\"dir\" use=\"required\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"ltr\"\/>\n+                <xs:enumeration value=\"rtl\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"br\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      forced line break\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"em\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      emphasis\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"strong\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      strong emphasis\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dfn\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      definitional\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"code\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      program code\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"samp\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      sample\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"kbd\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      something user would type\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"var\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      variable\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"cite\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      citation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"abbr\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      abbreviation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"acronym\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      acronym\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"q\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      inlined quote\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"sub\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      subscript\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"sup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      superscript\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tt\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      fixed pitch font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"i\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      italic font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"b\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      bold font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"big\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      bigger font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"small\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      smaller font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ==================== Object ======================================\n+\n+    object is used to embed objects as part of HTML pages.\n+    param elements should precede other content. Parameters\n+    can also be expressed as attribute\/value pairs on the\n+    object element itself when brevity is desired.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"object\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"param\"\/>\n+        <xs:group ref=\"block\"\/>\n+        <xs:element ref=\"form\"\/>\n+        <xs:group ref=\"inline\"\/>\n+        <xs:group ref=\"misc\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"declare\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"declare\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"classid\" type=\"URI\"\/>\n+      <xs:attribute name=\"codebase\" type=\"URI\"\/>\n+      <xs:attribute name=\"data\" type=\"URI\"\/>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"codetype\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"archive\" type=\"UriList\"\/>\n+      <xs:attribute name=\"standby\" type=\"Text\"\/>\n+      <xs:attribute name=\"height\" type=\"Length\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"tabindex\" type=\"tabindexNumber\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"param\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      param is used to supply a named property value.\n+      In XML it would seem natural to follow RDF and support an\n+      abbreviated syntax where the param elements are replaced\n+      by attribute value pairs on the object start tag.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"value\"\/>\n+      <xs:attribute name=\"valuetype\" default=\"data\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"data\"\/>\n+            <xs:enumeration value=\"ref\"\/>\n+            <xs:enumeration value=\"object\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Images ===========================================\n+\n+    To avoid accessibility problems for people who aren't\n+    able to see the image, you should provide a text\n+    description using the alt and longdesc attributes.\n+    In addition, avoid the use of server-side image maps.\n+    Note that in this DTD there is no name attribute. That\n+    is only available in the transitional and frameset DTD.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"img\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"src\" use=\"required\" type=\"URI\"\/>\n+      <xs:attribute name=\"alt\" use=\"required\" type=\"Text\"\/>\n+      <xs:attribute name=\"longdesc\" type=\"URI\"\/>\n+      <xs:attribute name=\"height\" type=\"Length\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\">\n+\t<xs:annotation>\n+\t  <xs:documentation>\n+          usemap points to a map element which may be in this document\n+          or an external document, although the latter is not widely supported\n+          <\/xs:documentation>\n+\t<\/xs:annotation>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"ismap\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"ismap\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Client-side image maps ============================\n+\n+    These can be placed in the same document or grouped in a\n+    separate document although this isn't yet widely supported\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"map\">\n+    <xs:complexType>\n+      <xs:choice>\n+        <xs:choice maxOccurs=\"unbounded\">\n+          <xs:group ref=\"block\"\/>\n+          <xs:element ref=\"form\"\/>\n+          <xs:group ref=\"misc\"\/>\n+        <\/xs:choice>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"area\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attributeGroup ref=\"events\"\/>\n+      <xs:attribute name=\"id\" use=\"required\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"class\"\/>\n+      <xs:attribute name=\"style\" type=\"StyleSheet\"\/>\n+      <xs:attribute name=\"title\" type=\"Text\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"area\">\n+    <xs:complexType>\n+        <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"shape\" default=\"rect\" type=\"Shape\"\/>\n+      <xs:attribute name=\"coords\" type=\"Coords\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"nohref\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"nohref\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"alt\" use=\"required\" type=\"Text\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Forms ===============================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"form\">\n+    <xs:complexType>\n+      <xs:complexContent>\n+        <xs:extension base=\"form.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"action\" use=\"required\" type=\"URI\"\/>\n+          <xs:attribute name=\"method\" default=\"get\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"get\"\/>\n+                <xs:enumeration value=\"post\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"enctype\" type=\"ContentType\"\n+              default=\"application\/x-www-form-urlencoded\"\/>\n+          <xs:attribute name=\"onsubmit\" type=\"Script\"\/>\n+          <xs:attribute name=\"onreset\" type=\"Script\"\/>\n+          <xs:attribute name=\"accept\" type=\"ContentTypes\"\/>\n+          <xs:attribute name=\"accept-charset\" type=\"Charsets\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"label\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Each label must not contain more than ONE field\n+      Label elements shouldn't be nested.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"for\" type=\"xs:IDREF\"\/>\n+          <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+          <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+          <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"InputType\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"text\"\/>\n+      <xs:enumeration value=\"password\"\/>\n+      <xs:enumeration value=\"checkbox\"\/>\n+      <xs:enumeration value=\"radio\"\/>\n+      <xs:enumeration value=\"submit\"\/>\n+      <xs:enumeration value=\"reset\"\/>\n+      <xs:enumeration value=\"file\"\/>\n+      <xs:enumeration value=\"hidden\"\/>\n+      <xs:enumeration value=\"image\"\/>\n+      <xs:enumeration value=\"button\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"input\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      form control\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"type\" default=\"text\" type=\"InputType\"\/>\n+      <xs:attribute name=\"name\">\n+\t<xs:annotation>\n+\t  <xs:documentation>\n+          the name attribute is required for all but submit &amp; reset\n+          <\/xs:documentation>\n+\t<\/xs:annotation>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"value\"\/>\n+      <xs:attribute name=\"checked\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"checked\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"readonly\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"readonly\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"size\"\/>\n+      <xs:attribute name=\"maxlength\" type=\"Number\"\/>\n+      <xs:attribute name=\"src\" type=\"URI\"\/>\n+      <xs:attribute name=\"alt\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\"\/>\n+      <xs:attribute name=\"onselect\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+      <xs:attribute name=\"accept\" type=\"ContentTypes\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"select\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      option selector\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"optgroup\"\/>\n+        <xs:element ref=\"option\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"size\" type=\"Number\"\/>\n+      <xs:attribute name=\"multiple\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"multiple\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"tabindex\" type=\"tabindexNumber\"\/>\n+      <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+      <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"optgroup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      option group\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"option\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"label\" use=\"required\" type=\"Text\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"option\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      selectable choice\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"selected\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"selected\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"label\" type=\"Text\"\/>\n+      <xs:attribute name=\"value\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"textarea\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      multi-line text field\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"rows\" use=\"required\" type=\"Number\"\/>\n+      <xs:attribute name=\"cols\" use=\"required\" type=\"Number\"\/>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"readonly\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"readonly\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"onselect\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"fieldset\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The fieldset element is used to group form fields.\n+      Only one legend element should occur in the content\n+      and if present should only be preceded by whitespace.\n+\n+      NOTE: this content model is different from the XHTML 1.0 DTD,\n+      closer to the intended content model in HTML4 DTD\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:sequence>\n+        <xs:element ref=\"legend\"\/>\n+        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+          <xs:group ref=\"block\"\/>\n+          <xs:element ref=\"form\"\/>\n+          <xs:group ref=\"inline\"\/>\n+          <xs:group ref=\"misc\"\/>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"legend\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      fieldset label\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"button\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Content is \"Flow\" excluding a, form and form controls\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"button.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"focus\"\/>\n+          <xs:attribute name=\"name\"\/>\n+          <xs:attribute name=\"value\"\/>\n+          <xs:attribute name=\"type\" default=\"submit\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"button\"\/>\n+                <xs:enumeration value=\"submit\"\/>\n+                <xs:enumeration value=\"reset\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"disabled\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ======================= Tables =======================================\n+\n+    Derived from IETF HTML table standard, see [RFC1942]\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"TFrame\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The border attribute sets the thickness of the frame around the\n+      table. The default units are screen pixels.\n+\n+      The frame attribute specifies which parts of the frame around\n+      the table should be rendered. The values are not the same as\n+      CALS to avoid a name clash with the valign attribute.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"void\"\/>\n+      <xs:enumeration value=\"above\"\/>\n+      <xs:enumeration value=\"below\"\/>\n+      <xs:enumeration value=\"hsides\"\/>\n+      <xs:enumeration value=\"lhs\"\/>\n+      <xs:enumeration value=\"rhs\"\/>\n+      <xs:enumeration value=\"vsides\"\/>\n+      <xs:enumeration value=\"box\"\/>\n+      <xs:enumeration value=\"border\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"TRules\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The rules attribute defines which rules to draw between cells:\n+\n+      If rules is absent then assume:\n+          \"none\" if border is absent or border=\"0\" otherwise \"all\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"none\"\/>\n+      <xs:enumeration value=\"groups\"\/>\n+      <xs:enumeration value=\"rows\"\/>\n+      <xs:enumeration value=\"cols\"\/>\n+      <xs:enumeration value=\"all\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:attributeGroup name=\"cellhalign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      horizontal alignment attributes for cell contents\n+\n+      char        alignment char, e.g. char=':'\n+      charoff     offset for alignment char\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"align\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"left\"\/>\n+          <xs:enumeration value=\"center\"\/>\n+          <xs:enumeration value=\"right\"\/>\n+          <xs:enumeration value=\"justify\"\/>\n+          <xs:enumeration value=\"char\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"char\" type=\"Character\"\/>\n+    <xs:attribute name=\"charoff\" type=\"Length\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"cellvalign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      vertical alignment attributes for cell contents\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"valign\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"top\"\/>\n+          <xs:enumeration value=\"middle\"\/>\n+          <xs:enumeration value=\"bottom\"\/>\n+          <xs:enumeration value=\"baseline\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:element name=\"table\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element minOccurs=\"0\" ref=\"caption\"\/>\n+        <xs:choice>\n+          <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"col\"\/>\n+          <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"colgroup\"\/>\n+        <\/xs:choice>\n+        <xs:element minOccurs=\"0\" ref=\"thead\"\/>\n+        <xs:element minOccurs=\"0\" ref=\"tfoot\"\/>\n+        <xs:choice>\n+          <xs:element maxOccurs=\"unbounded\" ref=\"tbody\"\/>\n+          <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"summary\" type=\"Text\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"border\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"frame\" type=\"TFrame\"\/>\n+      <xs:attribute name=\"rules\" type=\"TRules\"\/>\n+      <xs:attribute name=\"cellspacing\" type=\"Length\"\/>\n+      <xs:attribute name=\"cellpadding\" type=\"Length\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"caption\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    Use thead to duplicate headers when breaking table\n+    across page boundaries, or for static headers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use tfoot to duplicate footers when breaking table\n+    across page boundaries, or for static footers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use multiple tbody sections when rules are needed\n+    between groups of table rows.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"thead\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tfoot\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tbody\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"colgroup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      colgroup groups a set of col elements. It allows you to group\n+      several semantically related columns together.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"col\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"span\" default=\"1\" type=\"Number\"\/>\n+      <xs:attribute name=\"width\" type=\"MultiLength\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"col\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      col elements define the alignment properties for cells in\n+      one or more columns.\n+\n+      The width attribute specifies the width of the columns, e.g.\n+\n+          width=64        width in screen pixels\n+          width=0.5*      relative width of 0.5\n+\n+      The span attribute causes the attributes of one\n+      col element to apply to more than one column.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"span\" default=\"1\" type=\"Number\"\/>\n+      <xs:attribute name=\"width\" type=\"MultiLength\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tr\">\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"th\"\/>\n+        <xs:element ref=\"td\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"Scope\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Scope is simpler than headers attribute for common tables\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"row\"\/>\n+      <xs:enumeration value=\"col\"\/>\n+      <xs:enumeration value=\"rowgroup\"\/>\n+      <xs:enumeration value=\"colgroup\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    th is for headers, td for data and for cells acting as both\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"th\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"abbr\" type=\"Text\"\/>\n+          <xs:attribute name=\"axis\"\/>\n+          <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+          <xs:attribute name=\"scope\" type=\"Scope\"\/>\n+          <xs:attribute name=\"rowspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attribute name=\"colspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attributeGroup ref=\"cellhalign\"\/>\n+          <xs:attributeGroup ref=\"cellvalign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"td\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"abbr\" type=\"Text\"\/>\n+          <xs:attribute name=\"axis\"\/>\n+          <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+          <xs:attribute name=\"scope\" type=\"Scope\"\/>\n+          <xs:attribute name=\"rowspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attribute name=\"colspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attributeGroup ref=\"cellhalign\"\/>\n+          <xs:attributeGroup ref=\"cellvalign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml10\/xhtml1-strict.xsd","additions":2211,"deletions":0,"binary":false,"changes":2211,"status":"added"},{"patch":"@@ -0,0 +1,2755 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema version=\"1.0\" xml:lang=\"en\"\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+    targetNamespace=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns:xml=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+    elementFormDefault=\"qualified\">\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    XHTML 1.0 (Second Edition) Transitional in XML Schema\n+\n+    This is the same as HTML 4 Transitional except for\n+    changes due to the differences between XML and SGML.\n+\n+    Namespace = http:\/\/www.w3.org\/1999\/xhtml\n+\n+    For further information, see: http:\/\/www.w3.org\/TR\/xhtml1\n+\n+    Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),\n+    All Rights Reserved. \n+\n+    The DTD version is identified by the PUBLIC and SYSTEM identifiers:\n+\n+    PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\"\n+\n+    $Id: xhtml1-transitional.xsd,v 1.5 2002\/08\/28 09:53:29 mimasa Exp $\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+      schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\"\/>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Character mnemonic entities =========================\n+\n+    XHTML entity sets are identified by the PUBLIC and SYSTEM identifiers:\n+  \n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Latin 1 for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-lat1.ent\"\n+\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Special for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-special.ent\"\n+\n+    PUBLIC \"-\/\/W3C\/\/ENTITIES Symbols for XHTML\/\/EN\"\n+    SYSTEM \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml-symbol.ent\"\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Imported Names ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"ContentType\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      media type, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"ContentTypes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      comma-separated list of media types, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Charset\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a character encoding, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Charsets\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a space separated list of character encodings, as per [RFC2045]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"LanguageCode\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a language code, as per [RFC3066]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:language\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Character\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a single character, as per section 2.2 of [XML]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:length value=\"1\" fixed=\"true\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Number\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      one or more digits\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\">\n+      <xs:pattern value=\"[0-9]+\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"tabindexNumber\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      tabindex attribute specifies the position of the current element\n+      in the tabbing order for the current document. This value must be\n+      a number between 0 and 32767. User agents should ignore leading zeros. \n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"Number\">\n+      <xs:minInclusive value=\"0\"\/>\n+      <xs:maxInclusive value=\"32767\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"LinkTypes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      space-separated list of link types\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NMTOKENS\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"MediaDesc\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      single or comma-separated list of media descriptors\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[^,]+(,\\s*[^,]+)*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"URI\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a Uniform Resource Identifier, see [RFC2396]\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:anyURI\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"UriList\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a space separated list of Uniform Resource Identifiers\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Datetime\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      date and time information. ISO date format\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:dateTime\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Script\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      script expression\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"StyleSheet\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      style sheet data\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Text\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      used for titles etc.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"FrameTarget\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      render in this frame\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:NMTOKEN\">\n+      <xs:pattern value=\"_(blank|self|parent|top)|[A-Za-z]\\c*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Length\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      nn for pixels or nn% for percentage length\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"MultiLength\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      pixel, percentage, or relative\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)|[1-9]?(\\d+)?\\*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Pixels\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      integer representing length in pixels\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:nonNegativeInteger\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    these are used for image maps\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"Shape\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"rect\"\/>\n+      <xs:enumeration value=\"circle\"\/>\n+      <xs:enumeration value=\"poly\"\/>\n+      <xs:enumeration value=\"default\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Coords\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      comma separated list of lengths\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern\n+          value=\"[-+]?(\\d+|\\d+(\\.\\d+)?%)(,\\s*[-+]?(\\d+|\\d+(\\.\\d+)?%))*\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"ImgAlign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      used for object, applet, img, input and iframe\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"top\"\/>\n+      <xs:enumeration value=\"middle\"\/>\n+      <xs:enumeration value=\"bottom\"\/>\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"Color\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a color using sRGB: #RRGGBB as Hex values\n+\n+      There are also 16 widely known color names with their sRGB values:\n+\n+      Black  = #000000    Green  = #008000\n+      Silver = #C0C0C0    Lime   = #00FF00\n+      Gray   = #808080    Olive  = #808000\n+      White  = #FFFFFF    Yellow = #FFFF00\n+      Maroon = #800000    Navy   = #000080\n+      Red    = #FF0000    Blue   = #0000FF\n+      Purple = #800080    Teal   = #008080\n+      Fuchsia= #FF00FF    Aqua   = #00FFFF\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\">\n+      <xs:pattern value=\"[A-Za-z]+|#[0-9A-Fa-f]{3}|#[0-9A-Fa-f]{6}\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Generic Attributes ===============================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:attributeGroup name=\"coreattrs\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      core attributes common to most elements\n+      id       document-wide unique id\n+      class    space separated list of classes\n+      style    associated style info\n+      title    advisory title\/amplification\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <xs:attribute name=\"class\" type=\"xs:NMTOKENS\"\/>\n+    <xs:attribute name=\"style\" type=\"StyleSheet\"\/>\n+    <xs:attribute name=\"title\" type=\"Text\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"i18n\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      internationalization attributes\n+      lang        language code (backwards compatible)\n+      xml:lang    language code (as per XML 1.0 spec)\n+      dir         direction for weak\/neutral text\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"lang\" type=\"LanguageCode\"\/>\n+    <xs:attribute ref=\"xml:lang\"\/>\n+    <xs:attribute name=\"dir\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"ltr\"\/>\n+          <xs:enumeration value=\"rtl\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"events\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      attributes for common UI events\n+      onclick     a pointer button was clicked\n+      ondblclick  a pointer button was double clicked\n+      onmousedown a pointer button was pressed down\n+      onmouseup   a pointer button was released\n+      onmousemove a pointer was moved onto the element\n+      onmouseout  a pointer was moved away from the element\n+      onkeypress  a key was pressed and released\n+      onkeydown   a key was pressed down\n+      onkeyup     a key was released\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"onclick\" type=\"Script\"\/>\n+    <xs:attribute name=\"ondblclick\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmousedown\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseup\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseover\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmousemove\" type=\"Script\"\/>\n+    <xs:attribute name=\"onmouseout\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeypress\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeydown\" type=\"Script\"\/>\n+    <xs:attribute name=\"onkeyup\" type=\"Script\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"focus\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      attributes for elements that can get the focus\n+      accesskey   accessibility key character\n+      tabindex    position in tabbing order\n+      onfocus     the element got the focus\n+      onblur      the element lost the focus\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+    <xs:attribute name=\"tabindex\" type=\"tabindexNumber\"\/>\n+    <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+    <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"attrs\">\n+    <xs:attributeGroup ref=\"coreattrs\"\/>\n+    <xs:attributeGroup ref=\"i18n\"\/>\n+    <xs:attributeGroup ref=\"events\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"TextAlign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      text alignment for p, div, h1-h6. The default is\n+      align=\"left\" for ltr headings, \"right\" for rtl\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"align\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"left\"\/>\n+          <xs:enumeration value=\"center\"\/>\n+          <xs:enumeration value=\"right\"\/>\n+          <xs:enumeration value=\"justify\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Text Elements ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"special.extra\">\n+    <xs:choice>\n+      <xs:element ref=\"object\"\/>\n+      <xs:element ref=\"applet\"\/>\n+      <xs:element ref=\"img\"\/>\n+      <xs:element ref=\"map\"\/>\n+      <xs:element ref=\"iframe\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"special.basic\">\n+    <xs:choice>\n+      <xs:element ref=\"br\"\/>\n+      <xs:element ref=\"span\"\/>\n+      <xs:element ref=\"bdo\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"special\">\n+    <xs:choice>\n+      <xs:group ref=\"special.basic\"\/>\n+      <xs:group ref=\"special.extra\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"fontstyle.extra\">\n+    <xs:choice>\n+      <xs:element ref=\"big\"\/>\n+      <xs:element ref=\"small\"\/>\n+      <xs:element ref=\"font\"\/>\n+      <xs:element ref=\"basefont\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"fontstyle.basic\">\n+    <xs:choice>\n+      <xs:element ref=\"tt\"\/>\n+      <xs:element ref=\"i\"\/>\n+      <xs:element ref=\"b\"\/>\n+      <xs:element ref=\"u\"\/>\n+      <xs:element ref=\"s\"\/>\n+      <xs:element ref=\"strike\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"fontstyle\">\n+    <xs:choice>\n+      <xs:group ref=\"fontstyle.basic\"\/>\n+      <xs:group ref=\"fontstyle.extra\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"phrase.extra\">\n+    <xs:choice>\n+      <xs:element ref=\"sub\"\/>\n+      <xs:element ref=\"sup\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"phrase.basic\">\n+    <xs:choice>\n+      <xs:element ref=\"em\"\/>\n+      <xs:element ref=\"strong\"\/>\n+      <xs:element ref=\"dfn\"\/>\n+      <xs:element ref=\"code\"\/>\n+      <xs:element ref=\"q\"\/>\n+      <xs:element ref=\"samp\"\/>\n+      <xs:element ref=\"kbd\"\/>\n+      <xs:element ref=\"var\"\/>\n+      <xs:element ref=\"cite\"\/>\n+      <xs:element ref=\"abbr\"\/>\n+      <xs:element ref=\"acronym\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"phrase\">\n+    <xs:choice>\n+      <xs:group ref=\"phrase.basic\"\/>\n+      <xs:group ref=\"phrase.extra\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"inline.forms\">\n+    <xs:choice>\n+      <xs:element ref=\"input\"\/>\n+      <xs:element ref=\"select\"\/>\n+      <xs:element ref=\"textarea\"\/>\n+      <xs:element ref=\"label\"\/>\n+      <xs:element ref=\"button\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"misc.inline\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      these can only occur at block level\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice>\n+      <xs:element ref=\"ins\"\/>\n+      <xs:element ref=\"del\"\/>\n+      <xs:element ref=\"script\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"misc\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      these can only occur at block level\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice>\n+      <xs:element ref=\"noscript\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"inline\">\n+    <xs:choice>\n+      <xs:element ref=\"a\"\/>\n+      <xs:group ref=\"special\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:complexType name=\"Inline\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      \"Inline\" covers inline or \"text-level\" element\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Block level elements ==============================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"heading\">\n+    <xs:choice>\n+      <xs:element ref=\"h1\"\/>\n+      <xs:element ref=\"h2\"\/>\n+      <xs:element ref=\"h3\"\/>\n+      <xs:element ref=\"h4\"\/>\n+      <xs:element ref=\"h5\"\/>\n+      <xs:element ref=\"h6\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"lists\">\n+    <xs:choice>\n+      <xs:element ref=\"ul\"\/>\n+      <xs:element ref=\"ol\"\/>\n+      <xs:element ref=\"dl\"\/>\n+      <xs:element ref=\"menu\"\/>\n+      <xs:element ref=\"dir\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"blocktext\">\n+    <xs:choice>\n+      <xs:element ref=\"pre\"\/>\n+      <xs:element ref=\"hr\"\/>\n+      <xs:element ref=\"blockquote\"\/>\n+      <xs:element ref=\"address\"\/>\n+      <xs:element ref=\"center\"\/>\n+      <xs:element ref=\"noframes\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:group name=\"block\">\n+    <xs:choice>\n+      <xs:element ref=\"p\"\/>\n+      <xs:group ref=\"heading\"\/>\n+      <xs:element ref=\"div\"\/>\n+      <xs:group ref=\"lists\"\/>\n+      <xs:group ref=\"blocktext\"\/>\n+      <xs:element ref=\"isindex\"\/>\n+      <xs:element ref=\"fieldset\"\/>\n+      <xs:element ref=\"table\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:complexType name=\"Flow\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      \"Flow\" mixes block and inline and is used for list items etc.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"block\"\/>\n+      <xs:element ref=\"form\"\/>\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Content models for exclusions =====================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:complexType name=\"a.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      a elements use \"Inline\" excluding a\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"special\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"pre.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      pre uses \"Inline\" excluding img, object, applet, big, small,\n+      font, or basefont\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:element ref=\"a\"\/>\n+      <xs:group ref=\"special.basic\"\/>\n+      <xs:group ref=\"fontstyle.basic\"\/>\n+      <xs:group ref=\"phrase.basic\"\/>\n+      <xs:group ref=\"inline.forms\"\/>\n+      <xs:group ref=\"misc.inline\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"form.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      form uses \"Flow\" excluding form\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:group ref=\"block\"\/>\n+      <xs:group ref=\"inline\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:complexType name=\"button.content\" mixed=\"true\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      button uses \"Flow\" but excludes a, form, form controls, iframe\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+      <xs:element ref=\"p\"\/>\n+      <xs:group ref=\"heading\"\/>\n+      <xs:element ref=\"div\"\/>\n+      <xs:group ref=\"lists\"\/>\n+      <xs:group ref=\"blocktext\"\/>\n+      <xs:element ref=\"table\"\/>\n+      <xs:element ref=\"br\"\/>\n+      <xs:element ref=\"span\"\/>\n+      <xs:element ref=\"bdo\"\/>\n+      <xs:element ref=\"object\"\/>\n+      <xs:element ref=\"applet\"\/>\n+      <xs:element ref=\"img\"\/>\n+      <xs:element ref=\"map\"\/>\n+      <xs:group ref=\"fontstyle\"\/>\n+      <xs:group ref=\"phrase\"\/>\n+      <xs:group ref=\"misc\"\/>\n+    <\/xs:choice>\n+  <\/xs:complexType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Document Structure ==================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"html\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element ref=\"head\"\/>\n+        <xs:element ref=\"body\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Document Head =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:group name=\"head.misc\">\n+    <xs:sequence>\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"script\"\/>\n+        <xs:element ref=\"style\"\/>\n+        <xs:element ref=\"meta\"\/>\n+        <xs:element ref=\"link\"\/>\n+        <xs:element ref=\"object\"\/>\n+        <xs:element ref=\"isindex\"\/>\n+      <\/xs:choice>\n+    <\/xs:sequence>\n+  <\/xs:group>\n+\n+  <xs:element name=\"head\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content model is \"head.misc\" combined with a single\n+      title and an optional base element in any order\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:group ref=\"head.misc\"\/>\n+        <xs:choice>\n+          <xs:sequence>\n+            <xs:element ref=\"title\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+            <xs:sequence minOccurs=\"0\">\n+              <xs:element ref=\"base\"\/>\n+              <xs:group ref=\"head.misc\"\/>\n+            <\/xs:sequence>\n+          <\/xs:sequence>\n+          <xs:sequence>\n+            <xs:element ref=\"base\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+            <xs:element ref=\"title\"\/>\n+            <xs:group ref=\"head.misc\"\/>\n+          <\/xs:sequence>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"profile\" type=\"URI\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"title\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The title element is not considered part of the flow of text.\n+      It should be displayed, for example as the page header or\n+      window title. Exactly one title is required per document.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"base\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      document base URI\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"meta\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic metainformation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"http-equiv\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"content\" use=\"required\"\/>\n+      <xs:attribute name=\"scheme\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"link\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Relationship values can be used in principle:\n+\n+      a) for document specific toolbars\/menus when used\n+         with the link element in document head e.g.\n+           start, contents, previous, next, index, end, help\n+      b) to link to a separate style sheet (rel=\"stylesheet\")\n+      c) to make a link to a script (rel=\"script\")\n+      d) by stylesheets to control how collections of\n+         html nodes are rendered into printed documents\n+      e) to make a link to a printable version of this document\n+         e.g. a PostScript or PDF version (rel=\"alternate\" media=\"print\")\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"hreflang\" type=\"LanguageCode\"\/>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"rel\" type=\"LinkTypes\"\/>\n+      <xs:attribute name=\"rev\" type=\"LinkTypes\"\/>\n+      <xs:attribute name=\"media\" type=\"MediaDesc\"\/>\n+      <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"style\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      style info, which may include CDATA sections\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"type\" use=\"required\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"media\" type=\"MediaDesc\"\/>\n+      <xs:attribute name=\"title\" type=\"Text\"\/>\n+      <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"script\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      script statements, which may include CDATA sections\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+      <xs:attribute name=\"type\" use=\"required\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"language\"\/>\n+      <xs:attribute name=\"src\" type=\"URI\"\/>\n+      <xs:attribute name=\"defer\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"defer\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"noscript\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      alternate content container for non script-based rendering\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ======================= Frames =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"iframe\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      inline subwindow\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"coreattrs\"\/>\n+          <xs:attribute name=\"longdesc\" type=\"URI\"\/>\n+          <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+          <xs:attribute name=\"src\" type=\"URI\"\/>\n+          <xs:attribute name=\"frameborder\" default=\"1\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"1\"\/>\n+                <xs:enumeration value=\"0\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"marginwidth\" type=\"Pixels\"\/>\n+          <xs:attribute name=\"marginheight\" type=\"Pixels\"\/>\n+          <xs:attribute name=\"scrolling\" default=\"auto\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"yes\"\/>\n+                <xs:enumeration value=\"no\"\/>\n+                <xs:enumeration value=\"auto\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+          <xs:attribute name=\"height\" type=\"Length\"\/>\n+          <xs:attribute name=\"width\" type=\"Length\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"noframes\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      alternate content container for non frame-based rendering\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Document Body ====================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"body\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"onload\" type=\"Script\"\/>\n+          <xs:attribute name=\"onunload\" type=\"Script\"\/>\n+          <xs:attribute name=\"background\" type=\"URI\"\/>\n+          <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+          <xs:attribute name=\"text\" type=\"Color\"\/>\n+          <xs:attribute name=\"link\" type=\"Color\"\/>\n+          <xs:attribute name=\"vlink\" type=\"Color\"\/>\n+          <xs:attribute name=\"alink\" type=\"Color\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"div\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic language\/style container      \n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Paragraphs =======================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"p\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Headings =========================================\n+\n+    There are six levels of headings from h1 (the most important)\n+    to h6 (the least important).\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"h1\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h2\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h3\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h4\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h5\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"h6\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"TextAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Lists ============================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"ULStyle\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Unordered list bullet styles\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"disc\"\/>\n+      <xs:enumeration value=\"square\"\/>\n+      <xs:enumeration value=\"circle\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"ul\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Unordered list\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"type\" type=\"ULStyle\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"OLStyle\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Ordered list numbering style\n+\n+      1   arabic numbers      1, 2, 3, ...\n+      a   lower alpha         a, b, c, ...\n+      A   upper alpha         A, B, C, ...\n+      i   lower roman         i, ii, iii, ...\n+      I   upper roman         I, II, III, ...\n+\n+      The style is applied to the sequence number which by default\n+      is reset to 1 for the first list item in an ordered list.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"ol\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Ordered (numbered) list\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"type\" type=\"OLStyle\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"start\" type=\"Number\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"menu\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      single column list (DEPRECATED)\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dir\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      multiple column list (DEPRECATED)\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"li\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"LIStyle\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      LIStyle is constrained to: \"(ULStyle|OLStyle)\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:string\"\/>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"li\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      list item\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"type\" type=\"LIStyle\"\/>\n+          <xs:attribute name=\"value\" type=\"Number\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    definition lists - dt for term, dd for its definition\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"dl\">\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"dt\"\/>\n+        <xs:element ref=\"dd\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"compact\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"compact\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dt\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dd\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Address ==========================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"address\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      information on author\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:group ref=\"inline\"\/>\n+        <xs:group ref=\"misc.inline\"\/>\n+        <xs:element ref=\"p\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Horizontal Rule ==================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"hr\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"align\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"left\"\/>\n+            <xs:enumeration value=\"center\"\/>\n+            <xs:enumeration value=\"right\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"noshade\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"noshade\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"size\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Preformatted Text ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"pre\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content is \"Inline\" excluding \n+         \"img|object|applet|big|small|sub|sup|font|basefont\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"pre.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"width\" type=\"Number\"\/>\n+          <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Block-like Quotes ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"blockquote\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Text alignment ===================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"center\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      center content\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Inserted\/Deleted Text ============================\n+\n+    ins\/del are allowed in block and inline content, but its\n+    inappropriate to include block content within an ins element\n+    occurring in inline content.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"ins\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+          <xs:attribute name=\"datetime\" type=\"Datetime\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"del\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+          <xs:attribute name=\"datetime\" type=\"Datetime\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== The Anchor Element ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"a\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      content is \"Inline\" except that anchors shouldn't be nested\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"a.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"focus\"\/>\n+          <xs:attribute name=\"charset\" type=\"Charset\"\/>\n+          <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+          <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+          <xs:attribute name=\"href\" type=\"URI\"\/>\n+          <xs:attribute name=\"hreflang\" type=\"LanguageCode\"\/>\n+          <xs:attribute name=\"rel\" type=\"LinkTypes\"\/>\n+          <xs:attribute name=\"rev\" type=\"LinkTypes\"\/>\n+          <xs:attribute name=\"shape\" default=\"rect\" type=\"Shape\"\/>\n+          <xs:attribute name=\"coords\" type=\"Coords\"\/>\n+          <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ===================== Inline Elements ================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"span\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      generic language\/style container\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"bdo\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      I18N BiDi over-ride\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"coreattrs\"\/>\n+          <xs:attributeGroup ref=\"events\"\/>\n+          <xs:attribute name=\"lang\" type=\"LanguageCode\"\/>\n+          <xs:attribute ref=\"xml:lang\"\/>\n+          <xs:attribute name=\"dir\" use=\"required\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"ltr\"\/>\n+                <xs:enumeration value=\"rtl\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"br\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      forced line break\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attribute name=\"clear\" default=\"none\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"left\"\/>\n+            <xs:enumeration value=\"all\"\/>\n+            <xs:enumeration value=\"right\"\/>\n+            <xs:enumeration value=\"none\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"em\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      emphasis\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"strong\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      strong emphasis\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"dfn\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      definitional\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"code\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      program code\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"samp\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      sample\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"kbd\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      something user would type\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"var\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      variable\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"cite\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      citation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"abbr\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      abbreviation\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"acronym\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      acronym\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"q\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      inlined quote\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"cite\" type=\"URI\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"sub\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      subscript\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"sup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      superscript\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tt\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      fixed pitch font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"i\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      italic font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"b\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      bold font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"big\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      bigger font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"small\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      smaller font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"u\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      underline\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"s\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      strike-through\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"strike\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      strike-through\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"basefont\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      base font size\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"size\" use=\"required\"\/>\n+      <xs:attribute name=\"color\" type=\"Color\"\/>\n+      <xs:attribute name=\"face\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"font\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      local change to font\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"coreattrs\"\/>\n+          <xs:attributeGroup ref=\"i18n\"\/>\n+          <xs:attribute name=\"size\"\/>\n+          <xs:attribute name=\"color\" type=\"Color\"\/>\n+          <xs:attribute name=\"face\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ==================== Object ======================================\n+\n+    object is used to embed objects as part of HTML pages.\n+    param elements should precede other content. Parameters\n+    can also be expressed as attribute\/value pairs on the\n+    object element itself when brevity is desired.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"object\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"param\"\/>\n+        <xs:group ref=\"block\"\/>\n+        <xs:element ref=\"form\"\/>\n+        <xs:group ref=\"inline\"\/>\n+        <xs:group ref=\"misc\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"declare\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"declare\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"classid\" type=\"URI\"\/>\n+      <xs:attribute name=\"codebase\" type=\"URI\"\/>\n+      <xs:attribute name=\"data\" type=\"URI\"\/>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"codetype\" type=\"ContentType\"\/>\n+      <xs:attribute name=\"archive\" type=\"UriList\"\/>\n+      <xs:attribute name=\"standby\" type=\"Text\"\/>\n+      <xs:attribute name=\"height\" type=\"Length\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"tabindex\" type=\"Number\"\/>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+      <xs:attribute name=\"border\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"hspace\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"vspace\" type=\"Pixels\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"param\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      param is used to supply a named property value.\n+      In XML it would seem natural to follow RDF and support an\n+      abbreviated syntax where the param elements are replaced\n+      by attribute value pairs on the object start tag.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"name\" use=\"required\"\/>\n+      <xs:attribute name=\"value\"\/>\n+      <xs:attribute name=\"valuetype\" default=\"data\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"data\"\/>\n+            <xs:enumeration value=\"ref\"\/>\n+            <xs:enumeration value=\"object\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"type\" type=\"ContentType\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Java applet ==================================\n+\n+    One of code or object attributes must be present.\n+    Place param elements before other content.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"applet\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+        <xs:element ref=\"param\"\/>\n+        <xs:group ref=\"block\"\/>\n+        <xs:element ref=\"form\"\/>\n+        <xs:group ref=\"inline\"\/>\n+        <xs:group ref=\"misc\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attribute name=\"codebase\" type=\"URI\"\/>\n+      <xs:attribute name=\"archive\"\/>\n+      <xs:attribute name=\"code\"\/>\n+      <xs:attribute name=\"object\"\/>\n+      <xs:attribute name=\"alt\" type=\"Text\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"width\" use=\"required\" type=\"Length\"\/>\n+      <xs:attribute name=\"height\" use=\"required\" type=\"Length\"\/>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+      <xs:attribute name=\"hspace\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"vspace\" type=\"Pixels\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    =================== Images ===========================================\n+\n+    To avoid accessibility problems for people who aren't\n+    able to see the image, you should provide a text\n+    description using the alt and longdesc attributes.\n+    In addition, avoid the use of server-side image maps.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"img\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"src\" use=\"required\" type=\"URI\"\/>\n+      <xs:attribute name=\"alt\" use=\"required\" type=\"Text\"\/>\n+      <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+      <xs:attribute name=\"longdesc\" type=\"URI\"\/>\n+      <xs:attribute name=\"height\" type=\"Length\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\">\n+\t<xs:annotation>\n+\t  <xs:documentation>\n+          usemap points to a map element which may be in this document\n+          or an external document, although the latter is not widely supported\n+          <\/xs:documentation>\n+\t<\/xs:annotation>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"ismap\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"ismap\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+      <xs:attribute name=\"border\" type=\"Length\"\/>\n+      <xs:attribute name=\"hspace\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"vspace\" type=\"Pixels\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================== Client-side image maps ============================\n+\n+    These can be placed in the same document or grouped in a\n+    separate document although this isn't yet widely supported\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"map\">\n+    <xs:complexType>\n+      <xs:choice>\n+        <xs:choice maxOccurs=\"unbounded\">\n+          <xs:group ref=\"block\"\/>\n+          <xs:element ref=\"form\"\/>\n+          <xs:group ref=\"misc\"\/>\n+        <\/xs:choice>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"area\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attributeGroup ref=\"events\"\/>\n+      <xs:attribute name=\"id\" use=\"required\" type=\"xs:ID\"\/>\n+      <xs:attribute name=\"class\"\/>\n+      <xs:attribute name=\"style\" type=\"StyleSheet\"\/>\n+      <xs:attribute name=\"title\" type=\"Text\"\/>\n+      <xs:attribute name=\"name\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"area\">\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"shape\" default=\"rect\" type=\"Shape\"\/>\n+      <xs:attribute name=\"coords\" type=\"Coords\"\/>\n+      <xs:attribute name=\"href\" type=\"URI\"\/>\n+      <xs:attribute name=\"nohref\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"nohref\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"alt\" use=\"required\" type=\"Text\"\/>\n+      <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ================ Forms ===============================================\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"form\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"form.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"action\" use=\"required\" type=\"URI\"\/>\n+          <xs:attribute name=\"method\" default=\"get\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"get\"\/>\n+                <xs:enumeration value=\"post\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"enctype\" type=\"ContentType\"\n+              default=\"application\/x-www-form-urlencoded\"\/>\n+          <xs:attribute name=\"onsubmit\" type=\"Script\"\/>\n+          <xs:attribute name=\"onreset\" type=\"Script\"\/>\n+          <xs:attribute name=\"accept\" type=\"ContentTypes\"\/>\n+          <xs:attribute name=\"accept-charset\" type=\"Charsets\"\/>\n+          <xs:attribute name=\"target\" type=\"FrameTarget\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"label\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Each label must not contain more than ONE field\n+      Label elements shouldn't be nested.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"for\" type=\"xs:IDREF\"\/>\n+          <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+          <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+          <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"InputType\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"text\"\/>\n+      <xs:enumeration value=\"password\"\/>\n+      <xs:enumeration value=\"checkbox\"\/>\n+      <xs:enumeration value=\"radio\"\/>\n+      <xs:enumeration value=\"submit\"\/>\n+      <xs:enumeration value=\"reset\"\/>\n+      <xs:enumeration value=\"file\"\/>\n+      <xs:enumeration value=\"hidden\"\/>\n+      <xs:enumeration value=\"image\"\/>\n+      <xs:enumeration value=\"button\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"input\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      form control\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"type\" default=\"text\" type=\"InputType\"\/>\n+      <xs:attribute name=\"name\">\n+\t<xs:annotation>\n+\t  <xs:documentation>\n+          the name attribute is required for all but submit &amp; reset\n+          <\/xs:documentation>\n+\t<\/xs:annotation>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"value\"\/>\n+      <xs:attribute name=\"checked\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"checked\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"readonly\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"readonly\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"size\"\/>\n+      <xs:attribute name=\"maxlength\" type=\"Number\"\/>\n+      <xs:attribute name=\"src\" type=\"URI\"\/>\n+      <xs:attribute name=\"alt\"\/>\n+      <xs:attribute name=\"usemap\" type=\"URI\"\/>\n+      <xs:attribute name=\"onselect\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+      <xs:attribute name=\"accept\" type=\"ContentTypes\"\/>\n+      <xs:attribute name=\"align\" type=\"ImgAlign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"select\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      option selector\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"optgroup\"\/>\n+        <xs:element ref=\"option\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"size\" type=\"Number\"\/>\n+      <xs:attribute name=\"multiple\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"multiple\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"tabindex\" type=\"tabindexNumber\"\/>\n+      <xs:attribute name=\"onfocus\" type=\"Script\"\/>\n+      <xs:attribute name=\"onblur\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"optgroup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      option group\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"option\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"label\" use=\"required\" type=\"Text\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"option\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      selectable choice\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"selected\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"selected\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"label\" type=\"Text\"\/>\n+      <xs:attribute name=\"value\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"textarea\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      multi-line text field\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"focus\"\/>\n+      <xs:attribute name=\"name\"\/>\n+      <xs:attribute name=\"rows\" use=\"required\" type=\"Number\"\/>\n+      <xs:attribute name=\"cols\" use=\"required\" type=\"Number\"\/>\n+      <xs:attribute name=\"disabled\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"disabled\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"readonly\">\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:token\">\n+            <xs:enumeration value=\"readonly\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:attribute>\n+      <xs:attribute name=\"onselect\" type=\"Script\"\/>\n+      <xs:attribute name=\"onchange\" type=\"Script\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"fieldset\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The fieldset element is used to group form fields.\n+      Only one legend element should occur in the content\n+      and if present should only be preceded by whitespace.\n+\n+      NOTE: this content model is different from the XHTML 1.0 DTD,\n+      closer to the intended content model in HTML4 DTD\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:sequence>\n+        <xs:element ref=\"legend\"\/>\n+        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+          <xs:group ref=\"block\"\/>\n+          <xs:element ref=\"form\"\/>\n+          <xs:group ref=\"inline\"\/>\n+          <xs:group ref=\"misc\"\/>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"LAlign\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"top\"\/>\n+      <xs:enumeration value=\"bottom\"\/>\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"legend\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      fieldset label\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"accesskey\" type=\"Character\"\/>\n+          <xs:attribute name=\"align\" type=\"LAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"button\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Content is \"Flow\" excluding a, form and form controls\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"button.content\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attributeGroup ref=\"focus\"\/>\n+          <xs:attribute name=\"name\"\/>\n+          <xs:attribute name=\"value\"\/>\n+          <xs:attribute name=\"type\" default=\"submit\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"button\"\/>\n+                <xs:enumeration value=\"submit\"\/>\n+                <xs:enumeration value=\"reset\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"disabled\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"isindex\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      single-line text input control (DEPRECATED)\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"coreattrs\"\/>\n+      <xs:attributeGroup ref=\"i18n\"\/>\n+      <xs:attribute name=\"prompt\" type=\"Text\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    ======================= Tables =======================================\n+\n+    Derived from IETF HTML table standard, see [RFC1942]\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:simpleType name=\"TFrame\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The border attribute sets the thickness of the frame around the\n+      table. The default units are screen pixels.\n+\n+      The frame attribute specifies which parts of the frame around\n+      the table should be rendered. The values are not the same as\n+      CALS to avoid a name clash with the valign attribute.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"void\"\/>\n+      <xs:enumeration value=\"above\"\/>\n+      <xs:enumeration value=\"below\"\/>\n+      <xs:enumeration value=\"hsides\"\/>\n+      <xs:enumeration value=\"lhs\"\/>\n+      <xs:enumeration value=\"rhs\"\/>\n+      <xs:enumeration value=\"vsides\"\/>\n+      <xs:enumeration value=\"box\"\/>\n+      <xs:enumeration value=\"border\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"TRules\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      The rules attribute defines which rules to draw between cells:\n+\n+      If rules is absent then assume:\n+          \"none\" if border is absent or border=\"0\" otherwise \"all\"\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"none\"\/>\n+      <xs:enumeration value=\"groups\"\/>\n+      <xs:enumeration value=\"rows\"\/>\n+      <xs:enumeration value=\"cols\"\/>\n+      <xs:enumeration value=\"all\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:simpleType name=\"TAlign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      horizontal placement of table relative to document\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"center\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:attributeGroup name=\"cellhalign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      horizontal alignment attributes for cell contents\n+\n+      char        alignment char, e.g. char=':'\n+      charoff     offset for alignment char\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"align\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"left\"\/>\n+          <xs:enumeration value=\"center\"\/>\n+          <xs:enumeration value=\"right\"\/>\n+          <xs:enumeration value=\"justify\"\/>\n+          <xs:enumeration value=\"char\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"char\" type=\"Character\"\/>\n+    <xs:attribute name=\"charoff\" type=\"Length\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"cellvalign\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      vertical alignment attributes for cell contents\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attribute name=\"valign\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:token\">\n+          <xs:enumeration value=\"top\"\/>\n+          <xs:enumeration value=\"middle\"\/>\n+          <xs:enumeration value=\"bottom\"\/>\n+          <xs:enumeration value=\"baseline\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+  <\/xs:attributeGroup>\n+\n+  <xs:element name=\"table\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element minOccurs=\"0\" ref=\"caption\"\/>\n+        <xs:choice>\n+          <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"col\"\/>\n+          <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"colgroup\"\/>\n+        <\/xs:choice>\n+        <xs:element minOccurs=\"0\" ref=\"thead\"\/>\n+        <xs:element minOccurs=\"0\" ref=\"tfoot\"\/>\n+        <xs:choice>\n+          <xs:element maxOccurs=\"unbounded\" ref=\"tbody\"\/>\n+          <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+        <\/xs:choice>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"summary\" type=\"Text\"\/>\n+      <xs:attribute name=\"width\" type=\"Length\"\/>\n+      <xs:attribute name=\"border\" type=\"Pixels\"\/>\n+      <xs:attribute name=\"frame\" type=\"TFrame\"\/>\n+      <xs:attribute name=\"rules\" type=\"TRules\"\/>\n+      <xs:attribute name=\"cellspacing\" type=\"Length\"\/>\n+      <xs:attribute name=\"cellpadding\" type=\"Length\"\/>\n+      <xs:attribute name=\"align\" type=\"TAlign\"\/>\n+      <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"CAlign\">\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"top\"\/>\n+      <xs:enumeration value=\"bottom\"\/>\n+      <xs:enumeration value=\"left\"\/>\n+      <xs:enumeration value=\"right\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:element name=\"caption\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Inline\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"align\" type=\"CAlign\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    Use thead to duplicate headers when breaking table\n+    across page boundaries, or for static headers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use tfoot to duplicate footers when breaking table\n+    across page boundaries, or for static footers when\n+    tbody sections are rendered in scrolling panel.\n+\n+    Use multiple tbody sections when rules are needed\n+    between groups of table rows.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"thead\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tfoot\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tbody\">\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element maxOccurs=\"unbounded\" ref=\"tr\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"colgroup\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      colgroup groups a set of col elements. It allows you to group\n+      several semantically related columns together.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:sequence>\n+        <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" ref=\"col\"\/>\n+      <\/xs:sequence>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"span\" default=\"1\" type=\"Number\"\/>\n+      <xs:attribute name=\"width\" type=\"MultiLength\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"col\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      col elements define the alignment properties for cells in\n+      one or more columns.\n+\n+      The width attribute specifies the width of the columns, e.g.\n+\n+          width=64        width in screen pixels\n+          width=0.5*      relative width of 0.5\n+\n+      The span attribute causes the attributes of one\n+      col element to apply to more than one column.\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:complexType>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attribute name=\"span\" default=\"1\" type=\"Number\"\/>\n+      <xs:attribute name=\"width\" type=\"MultiLength\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"tr\">\n+    <xs:complexType>\n+      <xs:choice maxOccurs=\"unbounded\">\n+        <xs:element ref=\"th\"\/>\n+        <xs:element ref=\"td\"\/>\n+      <\/xs:choice>\n+      <xs:attributeGroup ref=\"attrs\"\/>\n+      <xs:attributeGroup ref=\"cellhalign\"\/>\n+      <xs:attributeGroup ref=\"cellvalign\"\/>\n+      <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:simpleType name=\"Scope\">\n+    <xs:annotation>\n+      <xs:documentation>\n+      Scope is simpler than headers attribute for common tables\n+      <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:restriction base=\"xs:token\">\n+      <xs:enumeration value=\"row\"\/>\n+      <xs:enumeration value=\"col\"\/>\n+      <xs:enumeration value=\"rowgroup\"\/>\n+      <xs:enumeration value=\"colgroup\"\/>\n+    <\/xs:restriction>\n+  <\/xs:simpleType>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+    th is for headers, td for data and for cells acting as both\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:element name=\"th\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"abbr\" type=\"Text\"\/>\n+          <xs:attribute name=\"axis\"\/>\n+          <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+          <xs:attribute name=\"scope\" type=\"Scope\"\/>\n+          <xs:attribute name=\"rowspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attribute name=\"colspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attributeGroup ref=\"cellhalign\"\/>\n+          <xs:attributeGroup ref=\"cellvalign\"\/>\n+          <xs:attribute name=\"nowrap\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"nowrap\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+          <xs:attribute name=\"width\" type=\"Length\"\/>\n+          <xs:attribute name=\"height\" type=\"Length\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+  <xs:element name=\"td\">\n+    <xs:complexType mixed=\"true\">\n+      <xs:complexContent>\n+        <xs:extension base=\"Flow\">\n+          <xs:attributeGroup ref=\"attrs\"\/>\n+          <xs:attribute name=\"abbr\" type=\"Text\"\/>\n+          <xs:attribute name=\"axis\"\/>\n+          <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+          <xs:attribute name=\"scope\" type=\"Scope\"\/>\n+          <xs:attribute name=\"rowspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attribute name=\"colspan\" default=\"1\" type=\"Number\"\/>\n+          <xs:attributeGroup ref=\"cellhalign\"\/>\n+          <xs:attributeGroup ref=\"cellvalign\"\/>\n+          <xs:attribute name=\"nowrap\">\n+            <xs:simpleType>\n+              <xs:restriction base=\"xs:token\">\n+                <xs:enumeration value=\"nowrap\"\/>\n+              <\/xs:restriction>\n+            <\/xs:simpleType>\n+          <\/xs:attribute>\n+          <xs:attribute name=\"bgcolor\" type=\"Color\"\/>\n+          <xs:attribute name=\"width\" type=\"Length\"\/>\n+          <xs:attribute name=\"height\" type=\"Length\"\/>\n+        <\/xs:extension>\n+      <\/xs:complexContent>\n+    <\/xs:complexType>\n+  <\/xs:element>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml10\/xhtml1-transitional.xsd","additions":2755,"deletions":0,"binary":false,"changes":2755,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema common attributes module for XHTML\n+      $Id: xhtml-attribs-1.xsd,v 1.9 2009\/11\/18 17:59:51 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_commonatts\"\/>\n+    <\/xs:annotation>\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+             schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        This import brings in the XML namespace attributes\n+        The module itself does not provide the schemaLocation\n+        and expects the driver schema to provide the\n+        actual SchemaLocation.\n+      <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:attributeGroup name=\"xhtml.id\">\n+        <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.class\">\n+        <xs:attribute name=\"class\" type=\"xs:string\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.title\">\n+        <xs:attribute name=\"title\" type=\"xs:string\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.Core.attrib\">\n+        <xs:attribute ref=\"xml:space\" fixed=\"preserve\"\/>\n+        <xs:attributeGroup ref=\"xhtml.id\"\/>\n+        <xs:attributeGroup ref=\"xhtml.class\"\/>\n+        <xs:attributeGroup ref=\"xhtml.title\"\/>\n+        <xs:attributeGroup ref=\"xhtml.Core.extra.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.I18n.attrib\">\n+        <xs:attribute ref=\"xml:lang\" \/>\n+        <xs:attributeGroup ref=\"xhtml.I18n.extra.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.Common.attrib\">\n+        <xs:attributeGroup ref=\"xhtml.Core.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.I18n.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.Common.extra\"\/>\n+    <\/xs:attributeGroup>\n+    <!-- Global attributes -->\n+    <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+    <xs:attribute name=\"class\" type=\"xs:string\"\/>\n+    <xs:attribute name=\"title\" type=\"xs:string\"\/>\n+    <xs:attributeGroup name=\"xhtml.Global.core.attrib\">\n+        <xs:attribute ref=\"id\"\/>\n+        <xs:attribute ref=\"class\"\/>\n+        <xs:attribute ref=\"title\"\/>\n+        <xs:attributeGroup ref=\"xhtml.Global.core.extra.attrib\" \/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.Global.i18n.attrib\">\n+        <xs:attribute ref=\"xml:lang\" \/>\n+        <xs:attributeGroup ref=\"xhtml.Global.I18n.extra.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.Global.common.attrib\">\n+        <xs:attributeGroup ref=\"xhtml.Global.core.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.Global.i18n.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.Global.Common.extra\"\/>\n+    <\/xs:attributeGroup>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-attribs-1.xsd","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+        Base element\n+        This is the XML Schema Base Element module for XHTML      \n+                \n+          * base\n+\n+        This module declares the base element type and its attributes,        \n+        used to define a base URI against which relative URIs in the\n+        document will be resolved.\n+\n+        $Id: xhtml-base-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+      <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_basemodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.base.attlist\">\n+        <xs:attribute name=\"href\" type=\"xh11d:URI\" use=\"required\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.base.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.base.type\">\n+        <xs:group ref=\"xhtml.base.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.base.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-base-1.xsd","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+          Bidirectional Override (bdo) Element\n+          This is the XML Schema BDO Element module for XHTML\n+\n+          This modules declares the element 'bdo' and 'dir' attributes,\n+          Used to override the  Unicode bidirectional algorithm for selected\n+          fragments of text.\n+          Bidirectional text support includes both the bdo element and\n+          the 'dir' attribute.\n+\n+          $Id: xhtml-bdo-1.xsd,v 1.6 2009\/11\/18 17:59:51 ahby Exp $\n+      <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_bdomodule\"\/>\n+    <\/xs:annotation>\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+             schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+           This import brings in the XML namespace attributes\n+           The module itself does not provide the schemaLocation\n+           and expects the driver schema to provide the\n+           actual SchemaLocation.\n+         <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:attributeGroup name=\"xhtml.bdo.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Core.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.I18n.extra.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.bdo.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.bdo.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.bdo.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.bdo.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.dir.attrib\">\n+        <xs:attribute name=\"dir\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"ltr\"\/>\n+                    <xs:enumeration value=\"rtl\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+    <!-- Global dir attribute -->\n+    <xs:attribute name=\"dir\">\n+        <xs:simpleType>\n+            <xs:restriction base=\"xs:NMTOKEN\">\n+                <xs:enumeration value=\"ltr\"\/>\n+                <xs:enumeration value=\"rtl\"\/>\n+            <\/xs:restriction>\n+        <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attributeGroup name=\"xhtml.Global.bdo.attrib\">\n+        <xs:attribute ref=\"dir\"\/>\n+    <\/xs:attributeGroup>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-bdo-1.xsd","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:include schemaLocation=\"xhtml-attribs-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+          This is the XML Schema Block Phrasal support module for XHTML\n+          $Id: xhtml-blkphras-1.xsd,v 1.7 2008\/07\/05 04:11:00 ahby Exp $\n+       <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+           Block Phrasal\n+           This module declares the elements and their attributes used to\n+           support block-level phrasal markup.\n+           This is the XML Schema block phrasal elements module for XHTML\n+\n+            * address, blockquote, pre, h1, h2, h3, h4, h5, h6\n+      <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_textmodule\"\/>\n+    <\/xs:annotation>\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+             schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+          This import brings in the XML namespace attributes \n+          The module itself does not provide the schemaLocation\n+          and expects the driver schema to provide the \n+          actual SchemaLocation.\n+        <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <!-- address -->\n+    <xs:attributeGroup name=\"xhtml.address.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.address.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.address.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.address.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.address.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- blockquote -->\n+    <xs:attributeGroup name=\"xhtml.blockquote.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"cite\" type=\"xh11d:URI\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.blockquote.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Block.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.blockquote.type\">\n+        <xs:group ref=\"xhtml.blockquote.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.blockquote.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- pre -->\n+    <xs:attributeGroup name=\"xhtml.pre.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.pre.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.InlinePre.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.pre.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.pre.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.pre.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- Heading Elements  -->\n+    <xs:attributeGroup name=\"xhtml.heading.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:complexType name=\"xhtml.heading.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <xs:attributeGroup ref=\"xhtml.heading.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.h1.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.h1.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.h1.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.h1.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.h1.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.h2.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.h2.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.h2.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.h2.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.h2.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.h3.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.h3.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.h3.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.h3.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.h3.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.h4.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.h4.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.h4.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.h4.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.h4.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.h5.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.h5.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.h5.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.h5.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.h5.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.h6.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.h6.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.h6.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.h6.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.h6.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-blkphras-1.xsd","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML SchemaBlock presentation element module for XHTML\n+      $Id: xhtml-blkpres-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Block Presentational Elements\n+  \n+        * hr\n+  \n+      This module declares the elements and their attributes used to\n+      support block-level presentational markup.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_presentationmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.hr.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.hr.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.hr.type\">\n+        <xs:group ref=\"xhtml.hr.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.hr.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-blkpres-1.xsd","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Block Structural\n+\n+        * div, p\n+  \n+      This module declares the elements and their attributes used to\n+      support block-level structural markup.            \n+          \n+      This is the XML Schema Block Structural module for XHTML\n+      $Id: xhtml-blkstruct-1.xsd,v 1.3 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <!-- div -->\n+    <xs:attributeGroup name=\"xhtml.div.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.div.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Flow.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.div.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.div.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.div.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- p -->\n+    <xs:attributeGroup name=\"xhtml.p.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.p.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.p.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.p.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.p.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-blkstruct-1.xsd","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+  <xs:annotation>\n+    <xs:documentation>\n+      This is XHTML, a reformulation of HTML as a modular XML application\n+      The Extensible HyperText Markup Language (XHTML)\n+      Copyright &#169;1998-2005 World Wide Web Consortium\n+      (Massachusetts Institute of Technology, European Research Consortium\n+       for Informatics and Mathematics, Keio University).\n+      All Rights Reserved.\n+    \n+      Permission to use, copy, modify and distribute the XHTML Schema\n+      modules and their accompanying xs:documentation for any purpose\n+      and without fee is hereby granted in perpetuity, provided that the above\n+      copyright notice and this paragraph appear in all copies.  \n+      The copyright holders make no representation about the suitability of\n+      these XML Schema modules for any purpose.\n+    \n+      They are provided \"as is\" without expressed or implied warranty.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-copyright-1.xsd","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      Client-side Image Maps    \n+      This is the XML Schema Client-side Image Maps module for XHTML\n+\n+        * area, map      \n+\n+      This module declares elements and attributes to support client-side\n+      image maps. \n+      \n+      $Id: xhtml-csismap-1.xsd,v 1.3 2009\/09\/30 15:12:48 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_imapmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:simpleType name=\"xhtml.Shape.Datatype\">\n+        <xs:restriction base=\"xs:NMTOKEN\">\n+            <xs:enumeration value=\"rect\"\/>\n+            <xs:enumeration value=\"circle\"\/>\n+            <xs:enumeration value=\"poly\"\/>\n+            <xs:enumeration value=\"default\"\/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType>\n+    <xs:simpleType name=\"xhtml.Coords.Datatype\">\n+        <xs:restriction base=\"xh11d:Text\"\/>\n+    <\/xs:simpleType>\n+    <!-- modify anchor attribute definition list -->\n+    <xs:attributeGroup name=\"xhtml.a.csim.attlist\">\n+        <xs:attribute name=\"shape\" type=\"xhtml.Shape.Datatype\" default=\"rect\"\/>\n+        <xs:attribute name=\"coords\" type=\"xhtml.Coords.Datatype\"\/>\n+    <\/xs:attributeGroup>\n+    <!-- modify img attribute definition list -->\n+    <xs:attributeGroup name=\"xhtml.img.csim.attlist\">\n+        <xs:attribute name=\"usemap\" type=\"xh11d:URIREF\"\/>\n+    <\/xs:attributeGroup>\n+    <!-- modify form input attribute definition list -->\n+    <xs:attributeGroup name=\"xhtml.input.csim.attlist\">\n+        <xs:attribute name=\"usemap\" type=\"xh11d:URIREF\"\/>\n+    <\/xs:attributeGroup>\n+    <!-- modify object attribute definition list -->\n+    <xs:attributeGroup name=\"xhtml.object.csim.attlist\">\n+        <xs:attribute name=\"usemap\" type=\"xh11d:URIREF\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.area.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"href\" type=\"xh11d:URI\"\/>\n+        <xs:attribute name=\"shape\" type=\"xhtml.Shape.Datatype\" default=\"rect\"\/>\n+        <xs:attribute name=\"coords\" type=\"xhtml.Coords.Datatype\"\/>\n+        <xs:attribute name=\"nohref\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"nohref\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"alt\" type=\"xh11d:Text\" use=\"required\"\/>\n+        <xs:attribute name=\"tabindex\" type=\"xh11d:Number\"\/>\n+        <xs:attribute name=\"accesskey\" type=\"xh11d:Character\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.area.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.area.type\">\n+        <xs:group ref=\"xhtml.area.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.area.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- map -->\n+    <xs:attributeGroup name=\"xhtml.map.attlist\">\n+        <xs:attribute name=\"id\" type=\"xs:ID\" use=\"required\"\/>\n+        <xs:attributeGroup ref=\"xhtml.class\"\/>\n+        <xs:attributeGroup ref=\"xhtml.title\"\/>\n+        <xs:attributeGroup ref=\"xhtml.Core.extra.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.I18n.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.map.content\">\n+        <xs:sequence>\n+            <xs:choice maxOccurs=\"unbounded\">\n+                <xs:group ref=\"xhtml.Block.mix\"\/>\n+                <xs:element name=\"area\" type=\"xhtml.area.type\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.map.type\">\n+        <xs:group ref=\"xhtml.map.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.map.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-csismap-1.xsd","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+ targetNamespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+ elementFormDefault=\"qualified\"\n+>\n+    <xs:annotation>\n+        <xs:documentation>\n+          XHTML Datatypes\n+          This is the XML Schema datatypes module for XHTML\n+          \n+          Defines containers for the XHTML datatypes, many of\n+          these imported from other specifications and standards.\n+          \n+          $Id: xhtml-datatypes-1.xsd,v 1.12 2009\/09\/30 15:12:48 ahby Exp $\n+        <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstraction.html#s_common_attrtypes\"\/>\n+    <\/xs:annotation>\n+\n+    <!-- nn for pixels or nn% for percentage length -->\n+    <xs:simpleType name=\"Length\">\n+        <xs:union memberTypes=\"xs:nonNegativeInteger\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:token\">\n+                    <xs:pattern value=\"\\d+[%]|\\d*\\.\\d+[%]\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:union>\n+    <\/xs:simpleType>\n+    <!-- space-separated list of link types -->\n+    <xs:simpleType name=\"LinkTypes\">\n+        <xs:list itemType=\"xs:NMTOKEN\"\/>\n+    <\/xs:simpleType>\n+    <!-- single or comma-separated list of media descriptors -->\n+    <xs:simpleType name=\"MediaDesc\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- pixel, percentage, or relative -->\n+    <xs:simpleType name=\"MultiLength\">\n+        <xs:union memberTypes=\"xh11d:Length\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:token\">\n+                    <xs:pattern value=\"\\d*\\*\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:union>\n+    <\/xs:simpleType>\n+    <!-- one or more digits (NUMBER) -->\n+    <xs:simpleType name=\"Number\">\n+        <xs:restriction base=\"xs:nonNegativeInteger\"\/>\n+    <\/xs:simpleType>\n+    <!-- integer representing length in pixels -->\n+    <xs:simpleType name=\"Pixels\">\n+        <xs:restriction base=\"xs:nonNegativeInteger\"\/>\n+    <\/xs:simpleType>\n+    <!-- script expression -->\n+    <xs:simpleType name=\"Script\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- sixteen color names or RGB color expression-->\n+    <xs:simpleType name=\"Color\">\n+        <xs:union memberTypes=\"xs:NMTOKEN\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:token\">\n+                    <xs:pattern value=\"#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:union>\n+    <\/xs:simpleType>\n+    <!-- textual content -->\n+    <xs:simpleType name=\"Text\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- Imported Datatypes  -->\n+    <!-- a single character, as per section 2.2 of [XML] -->\n+    <xs:simpleType name=\"Character\">\n+        <xs:restriction base=\"xs:string\">\n+            <xs:length value=\"1\" fixed=\"true\"\/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType>\n+    <!-- a character encoding, as per [RFC2045] -->\n+    <xs:simpleType name=\"Charset\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- a space separated list of character encodings, as per [RFC2045] -->\n+    <xs:simpleType name=\"Charsets\">\n+        <xs:list itemType=\"Charset\"\/>\n+    <\/xs:simpleType>\n+    <!-- media type, as per [RFC2045] -->\n+    <xs:simpleType name=\"ContentType\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- comma-separated list of media types, as per [RFC2045] -->\n+    <xs:simpleType name=\"ContentTypes\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- date and time information. ISO date format -->\n+    <xs:simpleType name=\"Datetime\">\n+        <xs:restriction base=\"xs:dateTime\"\/>\n+    <\/xs:simpleType>\n+    <!-- formal public identifier, as per [ISO8879] -->\n+    <xs:simpleType name=\"FPI\">\n+        <xs:restriction base=\"xs:normalizedString\"\/>\n+    <\/xs:simpleType>\n+\n+    <!-- a window name as used in the target attribute -->\n+    <xs:simpleType name=\"FrameTarget\">\n+      <xs:union>\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:NMTOKEN\">\n+            <xs:enumeration value=\"_blank\"\/>\n+            <xs:enumeration value=\"_self\"\/>\n+            <xs:enumeration value=\"_parent\"\/>\n+            <xs:enumeration value=\"_top\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+        <xs:simpleType>\n+          <xs:restriction base=\"xs:string\">\n+            <xs:pattern value=\"[a-zA-Z].*\"\/>\n+          <\/xs:restriction>\n+        <\/xs:simpleType>\n+      <\/xs:union>\n+    <\/xs:simpleType>\n+    \n+    <!-- a language code, as per [RFC3066] -->\n+    <xs:simpleType name=\"LanguageCode\">\n+     <xs:union memberTypes=\"xs:language\">\n+       <xs:simpleType>    \n+         <xs:restriction base=\"xs:string\">\n+           <xs:enumeration value=\"\"\/>\n+         <\/xs:restriction>\n+       <\/xs:simpleType>\n+     <\/xs:union>\n+    <\/xs:simpleType>\n+    <!-- a comma separated list of language ranges -->\n+    <xs:simpleType name=\"LanguageCodes\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- a Uniform Resource Identifier, see [URI] -->\n+    <xs:simpleType name=\"URI\">\n+        <xs:restriction base=\"xs:anyURI\"\/>\n+    <\/xs:simpleType>\n+    <!-- a space-separated list of Uniform Resource Identifiers, see [URI] -->\n+    <xs:simpleType name=\"URIs\">\n+        <xs:list itemType=\"xs:anyURI\"\/>\n+    <\/xs:simpleType>\n+    <!-- a relative URI reference to a fragment ID -->\n+    <xs:simpleType name=\"URIREF\">\n+        <xs:restriction base=\"xs:string\">\n+            <xs:pattern value=\"#\\c*\" \/>\n+            <xs:minLength value=\"1\"\/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType> \n+    <!-- comma-separated list of MultiLength -->\n+    <xs:simpleType name=\"MultiLengths\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- character Data -->\n+    <xs:simpleType name=\"CDATA\">\n+        <xs:restriction base=\"xs:string\"\/>\n+    <\/xs:simpleType>\n+    <!-- CURIE placeholder datatypes -->\n+    <xs:simpleType name=\"CURIE\">\n+        <xs:restriction base=\"xs:string\">\n+            <xs:pattern value=\"(([\\i-[:]][\\c-[:]]*)?:)?(\/[^\\s\/][^\\s]*|[^\\s\/][^\\s]*|[^\\s]?)\" \/>\n+            <xs:minLength value=\"1\"\/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType> \n+\n+    <xs:simpleType name=\"CURIEs\">\n+        <xs:list itemType=\"xh11d:CURIE\"\/>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"SafeCURIE\">\n+        <xs:restriction base=\"xs:string\">\n+            <xs:pattern value=\"\\[(([\\i-[:]][\\c-[:]]*)?:)?(\/[^\\s\/][^\\s]*|[^\\s\/][^\\s]*|[^\\s]?)\\]\" \/>\n+            <xs:minLength value=\"3\"\/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"SafeCURIEs\">\n+        <xs:list itemType=\"xh11d:SafeCURIE\"\/>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"URIorSafeCURIE\">\n+        <xs:union memberTypes=\"xs:anyURI xh11d:SafeCURIE\" \/>\n+    <\/xs:simpleType>\n+    <xs:simpleType name=\"URIorSafeCURIEs\">\n+        <xs:list itemType=\"xh11d:URIorSafeCURIE\"\/>\n+    <\/xs:simpleType>\n+\n+    <!-- RDFa Core 1.1 Datatypes -->\n+    <xs:simpleType name=\"PREFIX\">\n+        <xs:restriction base=\"xs:Name\">\n+            <xs:pattern value=\"[\\i-[:]][\\c-[:]]*: [\\i-[:]][\\c-[:]]+:.+\" \/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"PREFIXes\">\n+        <xs:list itemType=\"xh11d:PREFIX\"\/>\n+    <\/xs:simpleType> \n+\n+    <xs:simpleType name=\"TERM\">\n+      <xs:restriction base=\"xs:Name\">\n+        <xs:pattern value=\"[\\i-[:]][\/\\c-[:]]*\" \/>\n+      <\/xs:restriction>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"CURIEorIRI\">\n+        <xs:union memberTypes=\"xh11d:CURIE xs:anyURI\" \/>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"CURIEorIRIs\">\n+        <xs:list itemType=\"xh11d:CURIEorIRI\"\/>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"SafeCURIEorCURIEorIRI\">\n+        <xs:union memberTypes=\"xh11d:SafeCURIE xh11d:CURIE xs:anyURI\" \/>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"SafeCURIEorCURIEorIRIs\">\n+        <xs:list itemType=\"xh11d:SafeCURIEorCURIEorIRI\"\/>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name='AbsIRI'>\n+        <xs:restriction base='xs:string'>\n+            <xs:pattern value=\"[\\i-[:]][\\c-[:]]+:.+\" \/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"TERMorCURIEorAbsIRI\">\n+        <xs:union memberTypes=\"xh11d:TERM xh11d:CURIE xh11d:AbsIRI\" \/>\n+    <\/xs:simpleType>\n+\n+    <xs:simpleType name=\"TERMorCURIEorAbsIRIs\">\n+        <xs:list itemType=\"xh11d:TERMorCURIEorAbsIRI\"\/>\n+    <\/xs:simpleType>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-datatypes-1.xsd","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+          Editing Elements\n+          This is the XML Schema Editing Markup module for XHTML\n+\n+           * ins, del\n+  \n+         This module declares element types and attributes used to indicate\n+         inserted and deleted content while editing a document.\n+\n+          $Id: xhtml-edit-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+        <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_editmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.edit.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"cite\" type=\"xh11d:URI\"\/>\n+        <xs:attribute name=\"datetime\" type=\"xh11d:Datetime\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.edit.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Flow.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.edit.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.edit.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.edit.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-edit-1.xsd","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Intrinsic Events module for XHTML\n+      $Id: xhtml-events-1.xsd,v 1.4 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Intrinsic Event Attributes\n+      These are the event attributes defined in HTML 4,\n+      Section 18.2.3 \"Intrinsic Events\".\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_intrinsiceventsmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.Events.attrib\">\n+        <xs:attribute name=\"onclick\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"ondblclick\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onmousedown\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onmouseup\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onmouseover\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onmousemove\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onmouseout\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onkeypress\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onkeydown\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onkeyup\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on anchor element\n+-->\n+    <xs:attributeGroup name=\"xhtml.a.events.attlist\">\n+        <xs:attribute name=\"onfocus\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onblur\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on form element\n+-->\n+    <xs:attributeGroup name=\"xhtml.form.events.attlist\">\n+        <xs:attribute name=\"onsubmit\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onreset\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on label element\n+-->\n+    <xs:attributeGroup name=\"xhtml.label.events.attlist\">\n+        <xs:attribute name=\"onfocus\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onblur\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on input element\n+-->\n+    <xs:attributeGroup name=\"xhtml.input.events.attlist\">\n+        <xs:attribute name=\"onfocus\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onblur\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onselect\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onchange\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on select element\n+-->\n+    <xs:attributeGroup name=\"xhtml.select.events.attlist\">\n+        <xs:attribute name=\"onfocus\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onblur\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onchange\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on textarea element\n+-->\n+    <xs:attributeGroup name=\"xhtml.textarea.events.attlist\">\n+        <xs:attribute name=\"onfocus\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onblur\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onselect\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onchange\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on button element\n+-->\n+    <xs:attributeGroup name=\"xhtml.button.events.attlist\">\n+        <xs:attribute name=\"onfocus\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onblur\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on body element\n+-->\n+    <xs:attributeGroup name=\"xhtml.body.events.attlist\">\n+        <xs:attribute name=\"onload\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onunload\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+    additional attributes on area element\n+-->\n+    <xs:attributeGroup name=\"xhtml.area.events.attlist\">\n+        <xs:attribute name=\"onfocus\" type=\"xh11d:Script\"\/>\n+        <xs:attribute name=\"onblur\" type=\"xh11d:Script\"\/>\n+    <\/xs:attributeGroup>\n+    <!--\n+   Global Events Attributes\n+-->\n+    <xs:attribute name=\"onclick\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"ondblclick\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onmousedown\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onmouseup\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onmouseover\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onmousemove\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onmouseout\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onkeypress\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onkeydown\" type=\"xh11d:Script\"\/>\n+    <xs:attribute name=\"onkeyup\" type=\"xh11d:Script\"\/>\n+    <xs:attributeGroup name=\"xhtml.Global.events.attrib\">\n+        <xs:attribute ref=\"onclick\"\/>\n+        <xs:attribute ref=\"ondblclick\"\/>\n+        <xs:attribute ref=\"onmousedown\"\/>\n+        <xs:attribute ref=\"onmouseup\"\/>\n+        <xs:attribute ref=\"onmouseover\"\/>\n+        <xs:attribute ref=\"onmousemove\"\/>\n+        <xs:attribute ref=\"onmouseout\"\/>\n+        <xs:attribute ref=\"onkeypress\"\/>\n+        <xs:attribute ref=\"onkeydown\"\/>\n+        <xs:attribute ref=\"onkeyup\"\/>\n+    <\/xs:attributeGroup>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-events-1.xsd","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,327 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      Forms    \n+      This is the XML Schema Forms module for XHTML      \n+  \n+        * form, label, input, select, optgroup, option,\n+          textarea, fieldset, legend, button\n+    \n+      This module declares markup to provide support for online\n+      forms, based on the features found in HTML 4.0 forms.\n+          \n+    \n+      $Id: xhtml-form-1.xsd,v 1.4 2009\/09\/30 15:22:38 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_extformsmodule\"\/>\n+    <\/xs:annotation>\n+    <!-- form: Form Element -->\n+    <xs:attributeGroup name=\"xhtml.form.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"action\" type=\"xh11d:URI\" use=\"required\"\/>\n+        <xs:attribute name=\"method\" default=\"get\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"get\"\/>\n+                    <xs:enumeration value=\"post\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"name\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"enctype\" type=\"xh11d:ContentType\" default=\"application\/x-www-form-urlencoded\"\/>\n+        <xs:attribute name=\"accept-charset\" type=\"xh11d:Charsets\"\/>\n+        <xs:attribute name=\"accept\" type=\"xh11d:ContentTypes\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.form.content\">\n+        <xs:sequence>\n+            <xs:choice maxOccurs=\"unbounded\">\n+                <xs:group ref=\"xhtml.BlkNoForm.mix\"\/>\n+                <xs:element name=\"fieldset\" type=\"xhtml.fieldset.type\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.form.type\">\n+        <xs:group ref=\"xhtml.form.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.form.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- \n+    label: Form Field Label Text \n+    Note: Each label must not contain more than ONE field\n+-->\n+    <xs:group name=\"xhtml.label.content\">\n+        <xs:sequence>\n+            <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                <xs:element name=\"input\" type=\"xhtml.input.type\"\/>\n+                <xs:element name=\"select\" type=\"xhtml.select.type\"\/>\n+                <xs:element name=\"textarea\" type=\"xhtml.textarea.type\"\/>\n+                <xs:element name=\"button\" type=\"xhtml.button.type\"\/>\n+                <xs:group ref=\"xhtml.InlStruct.class\"\/>\n+                <xs:group ref=\"xhtml.InlPhras.class\"\/>\n+                <xs:group ref=\"xhtml.I18n.class\"\/>\n+                <xs:group ref=\"xhtml.InlPres.class\"\/>\n+                <xs:group ref=\"xhtml.InlSpecial.class\"\/>\n+                <xs:group ref=\"xhtml.Inline.extra\"\/>\n+                <xs:group ref=\"xhtml.Misc.class\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:attributeGroup name=\"xhtml.label.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"for\" type=\"xs:IDREF\"\/>\n+        <xs:attribute name=\"accesskey\" type=\"xh11d:Character\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:complexType name=\"xhtml.label.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.label.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.label.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- input: Form Control -->\n+    <xs:simpleType name=\"xhtml.InputType.class\">\n+        <xs:restriction base=\"xs:NMTOKEN\">\n+            <xs:enumeration value=\"text\"\/>\n+            <xs:enumeration value=\"password\"\/>\n+            <xs:enumeration value=\"checkbox\"\/>\n+            <xs:enumeration value=\"radio\"\/>\n+            <xs:enumeration value=\"submit\"\/>\n+            <xs:enumeration value=\"reset\"\/>\n+            <xs:enumeration value=\"hidden\"\/>\n+            <xs:enumeration value=\"image\"\/>\n+            <xs:enumeration value=\"button\"\/>\n+            <xs:enumeration value=\"file\"\/>\n+        <\/xs:restriction>\n+    <\/xs:simpleType>\n+    <!-- \n+    attribute 'name' required for all but submit & reset\n+-->\n+    <xs:attributeGroup name=\"xhtml.input.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"type\" type=\"xhtml.InputType.class\" default=\"text\"\/>\n+        <xs:attribute name=\"name\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"value\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"checked\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"checked\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"disabled\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"readonly\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"readonly\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"size\" type=\"xh11d:Number\"\/>\n+        <xs:attribute name=\"maxlength\" type=\"xh11d:Number\"\/>\n+        <xs:attribute name=\"src\" type=\"xh11d:URI\"\/>\n+        <xs:attribute name=\"alt\" type=\"xh11d:Text\"\/>\n+        <xs:attribute name=\"tabindex\" type=\"xh11d:Number\"\/>\n+        <xs:attribute name=\"accesskey\" type=\"xh11d:Character\"\/>\n+        <xs:attribute name=\"accept\" type=\"xh11d:ContentTypes\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.input.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.input.type\">\n+        <xs:group ref=\"xhtml.input.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.input.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- select: Option Selector  -->\n+    <xs:attributeGroup name=\"xhtml.select.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"name\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"size\" type=\"xh11d:Number\"\/>\n+        <xs:attribute name=\"multiple\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"multiple\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"disabled\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"tabindex\" type=\"xh11d:Number\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.select.content\">\n+        <xs:sequence>\n+            <xs:choice maxOccurs=\"unbounded\">\n+                <xs:element name=\"optgroup\" type=\"xhtml.optgroup.type\"\/>\n+                <xs:element name=\"option\" type=\"xhtml.option.type\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.select.type\">\n+        <xs:group ref=\"xhtml.select.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.select.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- optgroup: Option Group  -->\n+    <xs:attributeGroup name=\"xhtml.optgroup.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"disabled\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"label\" type=\"xh11d:Text\" use=\"required\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.optgroup.content\">\n+        <xs:sequence>\n+            <xs:element name=\"option\" type=\"xhtml.option.type\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.optgroup.type\">\n+        <xs:group ref=\"xhtml.optgroup.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.optgroup.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- option: Selectable Choice  -->\n+    <xs:attributeGroup name=\"xhtml.option.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"selected\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"selected\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"disabled\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"label\" type=\"xh11d:Text\"\/>\n+        <xs:attribute name=\"value\" type=\"xh11d:CDATA\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.option.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.option.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.option.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.option.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- textarea: Multi-Line Text Field  -->\n+    <xs:attributeGroup name=\"xhtml.textarea.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"name\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"rows\" type=\"xh11d:Number\" use=\"required\"\/>\n+        <xs:attribute name=\"cols\" type=\"xh11d:Number\" use=\"required\"\/>\n+        <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"disabled\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"readonly\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"readonly\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"tabindex\" type=\"xh11d:Number\"\/>\n+        <xs:attribute name=\"accesskey\" type=\"xh11d:Character\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.textarea.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.textarea.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.textarea.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.textarea.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- fieldset: Form Control Group  -->\n+    <xs:attributeGroup name=\"xhtml.fieldset.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.fieldset.content\">\n+        <xs:sequence>\n+            <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                <xs:element name=\"legend\" type=\"xhtml.legend.type\"\/>\n+                <xs:group ref=\"xhtml.Flow.mix\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.fieldset.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.fieldset.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.fieldset.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- legend: Fieldset Legend  -->\n+    <xs:attributeGroup name=\"xhtml.legend.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"accesskey\" type=\"xh11d:Character\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.legend.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.legend.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.legend.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.legend.attlist\"\/>\n+    <\/xs:complexType>\n+    <!-- button: Push Button  -->\n+    <xs:attributeGroup name=\"xhtml.button.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"name\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"value\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"type\" default=\"submit\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"button\"\/>\n+                    <xs:enumeration value=\"submit\"\/>\n+                    <xs:enumeration value=\"reset\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"disabled\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"disabled\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"tabindex\" type=\"xh11d:Number\"\/>\n+        <xs:attribute name=\"accesskey\" type=\"xh11d:Character\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.button.content\">\n+        <xs:sequence>\n+            <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                <xs:group ref=\"xhtml.BlkNoForm.mix\"\/>\n+                <xs:group ref=\"xhtml.InlStruct.class\"\/>\n+                <xs:group ref=\"xhtml.InlPhras.class\"\/>\n+                <xs:group ref=\"xhtml.InlPres.class\"\/>\n+                <xs:group ref=\"xhtml.I18n.class\"\/>\n+                <xs:group ref=\"xhtml.InlSpecial.class\"\/>\n+                <xs:group ref=\"xhtml.Inline.extra\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.button.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.button.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.button.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-form-1.xsd","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+ elementFormDefault=\"qualified\"\n+>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Modular Framework support module for XHTML\n+      $Id: xhtml-framework-1.xsd,v 1.5 2005\/09\/26 23:37:47 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      XHTML Modular Framework\n+      This required module instantiates the necessary modules\n+      needed to support the XHTML modularization framework.\n+\n+      The Schema modules instantiated are:\n+        +  notations\n+        +  datatypes\n+        +  common attributes\n+        +  character entities\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_commonatts\"\/>\n+    <\/xs:annotation>\n+    <!-- xs:include schemaLocation=\"xhtml-notations-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+         Notations module\n+         Declares XHTML notations for Attribute data types\n+      <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include -->\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" schemaLocation=\"xhtml-datatypes-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        This module defines XHTML Attribute DataTypes\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstraction.html#s_common_attrtypes\"\/>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:include schemaLocation=\"xhtml-attribs-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        This module defines Common attributes for XHTML\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_commonatts\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <!-- xs:include schemaLocation=\"xhtml-charent-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Character entities module\n+        Note: Entities are not supported in XML Schema\n+        The Schema Module uses DTDs to define Entities\n+\n+        This module defines\n+          + XHTML Latin 1 Character Entities\n+          + XHTML Special Characters\n+          + XHTML Mathematical, Greek, and Symbolic Characters\n+    <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include -->\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-framework-1.xsd","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      Hypertext Module\n+      This is the XML Schema Hypertext module for XHTML\n+            \n+        * a\n+            \n+      This module declares the anchor ('a') element type, which\n+      defines the source of a hypertext link. The destination\n+      (or link 'target') is identified via its 'id' attribute \n+      rather than the 'name' attribute as was used in HTML.\n+\n+      $Id: xhtml-hypertext-1.xsd,v 1.4 2005\/09\/26 23:37:47 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_hypertextmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.a.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"href\" type=\"xh11d:URI\"\/>\n+        <xs:attribute name=\"charset\" type=\"xh11d:Charset\"\/>\n+        <xs:attribute name=\"type\" type=\"xh11d:ContentType\"\/>\n+        <xs:attribute name=\"hreflang\" type=\"xh11d:LanguageCode\"\/>\n+        <xs:attribute name=\"rel\" type=\"xh11d:LinkTypes\"\/>\n+        <xs:attribute name=\"rev\" type=\"xh11d:LinkTypes\"\/>\n+        <xs:attribute name=\"accesskey\" type=\"xh11d:Character\"\/>\n+        <xs:attribute name=\"tabindex\" type=\"xh11d:Number\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.a.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.InlNoAnchor.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.a.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.a.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.a.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-hypertext-1.xsd","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      Images    \n+      This is the XML Schema Images module for XHTML\n+    \n+        * img\n+    \n+      This module provides markup to support basic image embedding.\n+      \n+      To avoid problems with text-only UAs as well as to make\n+      image content understandable and navigable to users of\n+      non-visual UAs, you need to provide a description with\n+      the 'alt' attribute, and avoid server-side image maps.\n+      \n+      \n+      $Id: xhtml-image-1.xsd,v 1.3 2009\/09\/30 15:22:38 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_imagemodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.img.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"src\" type=\"xh11d:URI\" use=\"required\"\/>\n+        <xs:attribute name=\"alt\" type=\"xh11d:Text\" use=\"required\"\/>\n+        <xs:attribute name=\"longdesc\" type=\"xh11d:URI\"\/>\n+        <xs:attribute name=\"name\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"height\" type=\"xh11d:Length\"\/>\n+        <xs:attribute name=\"width\" type=\"xh11d:Length\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.img.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.img.type\">\n+        <xs:group ref=\"xhtml.img.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.img.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-image-1.xsd","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+         This is the XML Schema Inline Phrasal support module for XHTML\n+         $Id: xhtml-inlphras-1.xsd,v 1.4 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Inline Phrasal.\n+      This module declares the elements and their attributes used to\n+      support inline-level phrasal markup.\n+      This is the XML Schema Inline Phrasal module for XHTML\n+\n+        * abbr, acronym, cite, code, dfn, em, kbd, q, samp, strong, var\n+\n+      $Id: xhtml-inlphras-1.xsd,v 1.4 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_textmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.abbr.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.abbr.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.abbr.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.abbr.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.abbr.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.acronym.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.acronym.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.acronym.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.acronym.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.acronym.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.cite.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.cite.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.cite.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.cite.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.cite.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.code.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.code.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.code.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.code.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.code.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.dfn.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.dfn.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.dfn.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.dfn.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.dfn.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.em.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.em.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.em.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.em.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.em.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.kbd.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.kbd.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.kbd.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.kbd.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.kbd.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.samp.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.samp.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.samp.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.samp.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.samp.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.strong.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.strong.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.strong.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.strong.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.strong.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.var.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.var.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.var.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.var.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.var.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.q.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"cite\" type=\"xh11d:URI\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.q.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.q.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.q.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.q.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-inlphras-1.xsd","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Inline Presentation element module for XHTML\n+      $Id: xhtml-inlpres-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Inline Presentational Elements\n+    \n+        * b, big, i, small, sub, sup, tt\n+    \n+      This module declares the elements and their attributes used to\n+      support inline-level presentational markup.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_presentationmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.InlPres.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.InlPres.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.InlPres.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.InlPres.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.InlPres.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-inlpres-1.xsd","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+         This is the XML Schema Inline Structural support module for XHTML\n+         $Id: xhtml-inlstruct-1.xsd,v 1.4 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Inline Structural.\n+      This module declares the elements and their attributes \n+      used to support inline-level structural markup.      \n+      This is the XML Schema Inline Structural element module for XHTML\n+\n+        * br, span\n+      \n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_textmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.br.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Core.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.br.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.br.type\">\n+        <xs:group ref=\"xhtml.br.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.br.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.span.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.span.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.span.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.span.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.span.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-inlstruct-1.xsd","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Inline Style module    \n+      This is the XML Schema Inline Style module for XHTML\n+      \n+         * styloe attribute\n+\n+      This module declares the 'style' attribute, used to support inline \n+      style markup. \n+\n+      $Id: xhtml-inlstyle-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_styleattributemodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.style.attrib\">\n+        <xs:attribute name=\"style\" type=\"xh11d:CDATA\"\/>\n+    <\/xs:attributeGroup>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-inlstyle-1.xsd","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Link Element module for XHTML\n+      $Id: xhtml-link-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Link element\n+    \n+        * link\n+    \n+      This module declares the link element type and its attributes,\n+      which could (in principle) be used to define document-level links\n+      to external resources.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_linkmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.link.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"charset\" type=\"xh11d:Charset\"\/>\n+        <xs:attribute name=\"href\" type=\"xh11d:URI\"\/>\n+        <xs:attribute name=\"hreflang\" type=\"xh11d:LanguageCode\"\/>\n+        <xs:attribute name=\"type\" type=\"xh11d:ContentType\"\/>\n+        <xs:attribute name=\"rel\" type=\"xh11d:LinkTypes\"\/>\n+        <xs:attribute name=\"rev\" type=\"xh11d:LinkTypes\"\/>\n+        <xs:attribute name=\"media\" type=\"xh11d:MediaDesc\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.link.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.link.type\">\n+        <xs:group ref=\"xhtml.link.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.link.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-link-1.xsd","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      List Module\n+      This is the XML Schema Lists module for XHTML\n+      List Module Elements\n+    \n+        * dl, dt, dd, ol, ul, li\n+    \n+      This module declares the list-oriented element types\n+      and their attributes.\n+      $Id: xhtml-list-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $      \n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_listmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.dt.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.dt.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.dt.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.dt.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.dt.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.dd.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.dd.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Flow.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.dd.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.dd.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.dd.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.dl.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.dl.content\">\n+        <xs:sequence>\n+            <xs:choice maxOccurs=\"unbounded\">\n+                <xs:element name=\"dt\" type=\"xhtml.dt.type\"\/>\n+                <xs:element name=\"dd\" type=\"xhtml.dd.type\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.dl.type\">\n+        <xs:group ref=\"xhtml.dl.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.dl.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.li.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.li.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Flow.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.li.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.li.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.li.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.ol.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.ol.content\">\n+        <xs:sequence>\n+            <xs:element name=\"li\" type=\"xhtml.li.type\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.ol.type\">\n+        <xs:group ref=\"xhtml.ol.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.ol.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.ul.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.ul.content\">\n+        <xs:sequence>\n+            <xs:element name=\"li\" type=\"xhtml.li.type\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.ul.type\">\n+        <xs:group ref=\"xhtml.ul.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.ul.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-list-1.xsd","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Metainformation module for XHTML\n+      $Id: xhtml-meta-1.xsd,v 1.3 2008\/07\/05 04:11:00 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Meta Information\n+\n+        * meta\n+\n+      This module declares the meta element type and its attributes,\n+      used to provide declarative document metainformation.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_metamodule\"\/>\n+    <\/xs:annotation>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+        schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+                This import brings in the XML namespace attributes\n+                The module itself does not provide the schemaLocation\n+                and expects the driver schema to provide the\n+                actual SchemaLocation.\n+            <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:attributeGroup name=\"xhtml.meta.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.I18n.attrib\"\/>\n+        <xs:attribute ref=\"xml:space\"\/>\n+        <xs:attribute name=\"http-equiv\" type=\"xs:NMTOKEN\"\/>\n+        <xs:attribute name=\"name\" type=\"xs:NMTOKEN\"\/>\n+        <xs:attribute name=\"content\" type=\"xh11d:CDATA\" use=\"required\"\/>\n+        <xs:attribute name=\"scheme\" type=\"xh11d:CDATA\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.meta.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.meta.type\">\n+        <xs:group ref=\"xhtml.meta.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.meta.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-meta-1.xsd","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Notations module\n+      This is the XML Schema module for data type notations for XHTML\n+      $Id: xhtml-notations-1.xsd,v 1.5 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Notations module\n+      Defines the XHTML notations, many of these imported from \n+      other specifications and standards. When an existing FPI is\n+      known, it is incorporated here.            \n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstraction.html#s_common_attrtypes\"\/>\n+    <\/xs:annotation>\n+    <!-- W3C XML 1.0 Recommendation -->\n+    <xs:notation name=\"w3c-xml\" public=\"ISO 8879\/\/NOTATION Extensible Markup Language (XML) 1.0\/\/EN\"\/>\n+    <!-- XML 1.0 CDATA -->\n+    <xs:notation name=\"cdata\" public=\"-\/\/W3C\/\/NOTATION XML 1.0: CDATA\/\/EN\"\/>\n+    <!-- SGML Formal Public Identifiers -->\n+    <xs:notation name=\"fpi\" public=\"ISO 8879:1986\/\/NOTATION Formal Public Identifier\/\/EN\"\/>\n+    <!-- XHTML Notations ... -->\n+    <!-- Length defined for cellpadding\/cellspacing -->\n+    <!-- nn for pixels or nn% for percentage length -->\n+    <!-- a single character, as per section 2.2 of [XML] -->\n+    <xs:notation name=\"character\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Character\/\/EN\"\/>\n+    <!-- a character encoding, as per [RFC2045] -->\n+    <xs:notation name=\"charset\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Charset\/\/EN\"\/>\n+    <!-- a space separated list of character encodings, as per [RFC2045] -->\n+    <xs:notation name=\"charsets\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Charsets\/\/EN\"\/>\n+    <!-- media type, as per [RFC2045] -->\n+    <xs:notation name=\"contentType\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: ContentType\/\/EN\"\/>\n+    <!-- comma-separated list of media types, as per [RFC2045] -->\n+    <xs:notation name=\"contentTypes\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: ContentTypes\/\/EN\"\/>\n+    <!-- date and time information. ISO date format -->\n+    <xs:notation name=\"datetime\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Datetime\/\/EN\"\/>\n+    <!-- a language code, as per [RFC3066] -->\n+    <xs:notation name=\"languageCode\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: LanguageCode\/\/EN\"\/>\n+    <!-- nn for pixels or nn% for percentage length -->\n+    <xs:notation name=\"length\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Length\/\/EN\"\/>\n+    <!-- space-separated list of link types -->\n+    <xs:notation name=\"linkTypes\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: LinkTypes\/\/EN\"\/>\n+    <!-- single or comma-separated list of media descriptors -->\n+    <xs:notation name=\"mediaDesc\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: MediaDesc\/\/EN\"\/>\n+    <!-- pixel, percentage, or relative -->\n+    <xs:notation name=\"multiLength\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: MultiLength\/\/EN\"\/>\n+    <!-- one or more digits (NUMBER) -->\n+    <xs:notation name=\"number\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Number\/\/EN\"\/>\n+    <!-- one or more digits (NUMBER) -->\n+    <xs:notation name=\"pixels\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Pixels\/\/EN\"\/>\n+    <!-- script expression -->\n+    <xs:notation name=\"script\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Script\/\/EN\"\/>\n+    <!-- textual content -->\n+    <xs:notation name=\"text\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: Text\/\/EN\"\/>\n+    <!-- a Uniform Resource Identifier, see [URI] -->\n+    <xs:notation name=\"uri\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: URI\/\/EN\"\/>\n+    <!-- a space-separated list of Uniform Resource Identifiers, see [URI] -->\n+    <xs:notation name=\"uris\" public=\"-\/\/W3C\/\/NOTATION XHTML Datatype: URIs\/\/EN\"\/>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-notations-1.xsd","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+\t<xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+\t<xs:annotation>\n+\t\t<xs:documentation>\n+      This is the XML Schema Embedded Object module for XHTML\n+      $Id: xhtml-object-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+\t\t<xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+\t<\/xs:annotation>\n+\t<xs:annotation>\n+\t\t<xs:documentation>\n+      This module declares the object element type and its attributes,\n+      used to embed external objects as part of XHTML pages. In the\n+      document, place param elements prior to the object elements \n+      that require their content.\n+          \n+      Note that use of this module requires instantiation of the \n+      Param Element Module prior to this module.\n+      \n+      Elements defined here: \n+      \n+        * object (param)\n+    <\/xs:documentation>\n+\t\t<xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_objectmodule\"\/>\n+\t<\/xs:annotation>\n+\t<xs:include schemaLocation=\"xhtml-param-1.xsd\">\n+\t\t<xs:annotation>\n+\t\t\t<xs:documentation>\n+        Param module\n+        \n+        Elements defined here:\n+          * param\n+      <\/xs:documentation>\n+\t\t<\/xs:annotation>\n+\t<\/xs:include>\n+\t<xs:attributeGroup name=\"xhtml.object.attlist\">\n+\t\t<xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+\t\t<xs:attribute name=\"declare\">\n+\t\t\t<xs:simpleType>\n+\t\t\t\t<xs:restriction base=\"xs:NMTOKEN\">\n+\t\t\t\t\t<xs:enumeration value=\"declare\"\/>\n+\t\t\t\t<\/xs:restriction>\n+\t\t\t<\/xs:simpleType>\n+\t\t<\/xs:attribute>\n+\t\t<xs:attribute name=\"classid\" type=\"xh11d:URI\"\/>\n+\t\t<xs:attribute name=\"codebase\" type=\"xh11d:URI\"\/>\n+\t\t<xs:attribute name=\"data\" type=\"xh11d:URI\"\/>\n+\t\t<xs:attribute name=\"type\" type=\"xh11d:ContentType\"\/>\n+\t\t<xs:attribute name=\"codetype\" type=\"xh11d:ContentType\"\/>\n+\t\t<xs:attribute name=\"archive\" type=\"xh11d:URIs\"\/>\n+\t\t<xs:attribute name=\"standby\" type=\"xh11d:Text\"\/>\n+\t\t<xs:attribute name=\"height\" type=\"xh11d:Length\"\/>\n+\t\t<xs:attribute name=\"width\" type=\"xh11d:Length\"\/>\n+\t\t<xs:attribute name=\"name\" type=\"xh11d:CDATA\"\/>\n+\t\t<xs:attribute name=\"tabindex\" type=\"xh11d:Number\"\/>\n+\t<\/xs:attributeGroup>\n+\t<xs:group name=\"xhtml.object.content\">\n+\t\t<xs:sequence>\n+\t\t\t<xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+\t\t\t\t<xs:element name=\"param\" type=\"xhtml.param.type\"\/>\n+\t\t\t\t<xs:group ref=\"xhtml.Flow.mix\"\/>\n+\t\t\t<\/xs:choice>\n+\t\t<\/xs:sequence>\n+\t<\/xs:group>\n+\t<xs:complexType name=\"xhtml.object.type\" mixed=\"true\">\n+\t\t<xs:group ref=\"xhtml.object.content\"\/>\n+\t\t<xs:attributeGroup ref=\"xhtml.object.attlist\"\/>\n+\t<\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-object-1.xsd","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Param Element module for XHTML\n+      $Id: xhtml-param-1.xsd,v 1.3 2005\/09\/26 22:54:53 ahby Exp $\n+      <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Parameters for Java Applets and Embedded Objects\n+\n+        * param\n+\n+      This module provides declarations for the param element,\n+      used to provide named property values for the applet\n+      and object elements.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_objectmodule\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_appletmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.param.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.id\"\/>\n+        <xs:attribute name=\"name\" type=\"xh11d:CDATA\" use=\"required\"\/>\n+        <xs:attribute name=\"value\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"valuetype\" default=\"data\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"data\"\/>\n+                    <xs:enumeration value=\"ref\"\/>\n+                    <xs:enumeration value=\"object\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"type\" type=\"xh11d:ContentType\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.param.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.param.type\">\n+        <xs:group ref=\"xhtml.param.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.param.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-param-1.xsd","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Presentation module for XHTML\n+      This is a REQUIRED module.\n+      $Id: xhtml-pres-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Presentational Elements\n+\n+      This module defines elements and their attributes for\n+      simple presentation-related markup.\n+ \n+      Elements defined here:\n+\n+        * hr\n+        * b, big, i, small, sub, sup, tt\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_presentationmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:include schemaLocation=\"xhtml-blkpres-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Block Presentational module\n+        Elements defined here:\n+ \n+         * hr\n+      <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"xhtml-inlpres-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Inline Presentational module\n+        Elements defined here:\n+\n+          * b, big, i, small, sub, sup, tt\n+    <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-pres-1.xsd","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+    elementFormDefault=\"qualified\"\n+    xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\">\n+    <xs:import\n+        namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+        schemaLocation=\"xhtml-datatypes-1.xsd\"\/>\n+  <xs:annotation>\n+    <xs:documentation>\n+      This is the Ruby module for XHTML\n+      $Id: xhtml-ruby-1.xsd,v 1.7 2010\/05\/02 17:22:08 ahby Exp $\n+    <\/xs:documentation>\n+    <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+  <\/xs:annotation>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+      \"Ruby\" are short runs of text alongside the base text, typically\n+      used in East Asian documents to indicate pronunciation or to\n+      provide a short annotation. The full specification for Ruby is here:\n+      \n+        http:\/\/www.w3.org\/TR\/2001\/REC-ruby-20010531\/\n+      \n+      This module defines \"Ruby \" or \"complex Ruby\" as described\n+      in the specification:\n+      \n+        http:\/\/www.w3.org\/TR\/2001\/REC-ruby-20010531\/#complex\n+    \n+      Simple or Basic Ruby are defined in a separate module.\n+      \n+      This module declares the elements and their attributes used to\n+      support complex ruby annotation markup. Elements defined here\n+            * ruby, rbc, rtc, rb, rt, rp\n+      \n+      This module expects the document model to define the\n+      following content models\n+        + InlNoRuby.mix                 \n+    <\/xs:documentation>\n+    <xs:documentation\n+         source=\"http:\/\/www.w3.org\/TR\/2001\/REC-ruby-20010531\/\"\/>    \n+  <\/xs:annotation>\n+\n+  <xs:group name=\"xhtml.ruby.content.simple\">\n+      <xs:sequence>\n+          <xs:element name=\"rb\" type=\"xhtml.rb.type\"\/>\n+          <xs:choice>\n+              <xs:element name=\"rt\" type=\"xhtml.rt.type\"\/>\n+              <xs:sequence>\n+                  <xs:element name=\"rp\" type=\"xhtml.rp.type\"\/>\n+                  <xs:element name=\"rt\" type=\"xhtml.rt.type\"\/>\n+                  <xs:element name=\"rp\" type=\"xhtml.rp.type\"\/>\n+              <\/xs:sequence>\n+          <\/xs:choice>\n+      <\/xs:sequence>\n+  <\/xs:group>\n+\n+  <xs:group name=\"xhtml.ruby.content.complex\">\n+    <xs:sequence>\n+      <xs:element name=\"rbc\" type=\"xhtml.rbc.type\"\/>\n+      <xs:element name=\"rtc\" type=\"xhtml.rtc.type\" maxOccurs=\"2\"\/>\n+    <\/xs:sequence>\n+  <\/xs:group>\n+\n+  <!--\n+   add to this group any common attributes for all Ruby elements\n+  -->\n+  <xs:attributeGroup name=\"xhtml.ruby.common.attrib\"\/>\n+  \n+  <xs:group name=\"xhtml.ruby.content\">\n+    <xs:choice>\n+      <xs:group ref=\"xhtml.ruby.content.simple\"\/>\n+      <xs:group ref=\"xhtml.ruby.content.complex\"\/>\n+    <\/xs:choice>\n+  <\/xs:group>\n+\n+  <xs:complexType name=\"xhtml.ruby.type\">\n+    <xs:group ref=\"xhtml.ruby.content\"\/>\n+    <xs:attributeGroup ref=\"xhtml.ruby.common.attrib\"\/>\n+  <\/xs:complexType>\n+\n+  <!--\n+   rbc (ruby base component) element \n+  -->\n+  <xs:attributeGroup name=\"xhtml.rbc.attlist\">\n+    <xs:attributeGroup ref=\"xhtml.ruby.common.attrib\"\/>\n+  <\/xs:attributeGroup>\n+  \n+  <xs:group name=\"xhtml.rbc.content\">\n+    <xs:sequence>\n+      <xs:element name=\"rb\" type=\"xhtml.rb.type\" \/>\n+    <\/xs:sequence>\n+  <\/xs:group>  \n+\n+  <xs:complexType name=\"xhtml.rbc.type\">\n+    <xs:group ref=\"xhtml.rbc.content\"\/>\n+    <xs:attributeGroup ref=\"xhtml.rbc.attlist\"\/>\n+  <\/xs:complexType>\n+\n+  <!--\n+   rtc (ruby text component) element\n+  -->\n+  <xs:attributeGroup name=\"xhtml.rtc.attlist\">\n+    <xs:attributeGroup ref=\"xhtml.ruby.common.attrib\"\/>\n+  <\/xs:attributeGroup>\n+  \n+  <xs:group name=\"xhtml.rtc.content\">\n+    <xs:sequence>\n+      <xs:element name=\"rt\" type=\"xhtml.rt.type\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>  \n+  <\/xs:group>    \n+\n+  <xs:complexType name=\"xhtml.rtc.type\">\n+    <xs:group ref=\"xhtml.rt.content\"\/>  \n+    <xs:attributeGroup ref=\"xhtml.rtc.attlist\"\/>\n+  <\/xs:complexType>\n+\n+  <!--\n+   rb (ruby base) element \n+  -->\n+  <xs:attributeGroup name=\"xhtml.rb.attlist\">\n+    <xs:attributeGroup ref=\"xhtml.ruby.common.attrib\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:group name=\"xhtml.rb.content\">\n+    <xs:sequence>\n+       <xs:group ref=\"xhtml.InlNoRuby.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+  <\/xs:group>      \n+\n+  <xs:complexType name=\"xhtml.rb.type\" mixed=\"true\">\n+    <xs:group ref=\"xhtml.rb.content\"\/>\n+    <xs:attributeGroup ref=\"xhtml.rb.attlist\"\/>\n+  <\/xs:complexType>\n+    \n+  <!--\n+   rt (ruby text) element \n+  -->\n+  <xs:attributeGroup name=\"xhtml.rt.attlist\">\n+    <xs:attributeGroup ref=\"xhtml.ruby.common.attrib\"\/>\n+    <xs:attribute name=\"rbspan\" type=\"xh11d:Number\" default=\"1\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:group name=\"xhtml.rt.content\">\n+    <xs:sequence>\n+       <xs:group ref=\"xhtml.InlNoRuby.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+    <\/xs:sequence>\n+  <\/xs:group>      \n+  \n+  <xs:complexType name=\"xhtml.rt.type\" mixed=\"true\">\n+    <xs:group ref=\"xhtml.rt.content\"\/>  \n+    <xs:attributeGroup ref=\"xhtml.rt.attlist\"\/>\n+  <\/xs:complexType>\n+\n+  <!-- rp (ruby parenthesis) element  -->\n+  <xs:attributeGroup name=\"xhtml.rp.attlist\">\n+    <xs:attributeGroup ref=\"xhtml.ruby.common.attrib\"\/>\n+  <\/xs:attributeGroup>\n+  \n+  <xs:group name=\"xhtml.rp.content\">\n+    <xs:sequence\/>\n+  <\/xs:group>      \n+  \n+\n+  <xs:complexType name=\"xhtml.rp.type\" mixed=\"true\">\n+    <xs:group ref=\"xhtml.rp.content\"\/>\n+    <xs:attributeGroup ref=\"xhtml.rp.attlist\"\/>\n+  <\/xs:complexType>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-ruby-1.xsd","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Scripting module for XHTML\n+      $Id: xhtml-script-1.xsd,v 1.5 2006\/09\/11 08:50:41 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Scripting\n+      \n+        * script, noscript\n+      \n+      This module declares element types and attributes used to provide\n+      support for executable scripts as well as an alternate content\n+      container where scripts are not supported.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_scriptmodule\"\/>\n+    <\/xs:annotation>\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+             schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+          This import brings in the XML namespace attributes \n+          The module itself does not provide the schemaLocation\n+          and expects the driver schema to provide the \n+          actual SchemaLocation.\n+        <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:attributeGroup name=\"xhtml.script.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.id\"\/>\n+        <xs:attribute name=\"charset\" type=\"xh11d:Charset\"\/>\n+        <xs:attribute name=\"type\" type=\"xh11d:ContentType\" use=\"required\"\/>\n+        <xs:attribute name=\"src\" type=\"xh11d:URI\"\/>\n+        <xs:attribute name=\"defer\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"defer\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.script.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.script.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.script.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.script.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.noscript.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.noscript.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Block.mix\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.noscript.type\">\n+        <xs:group ref=\"xhtml.noscript.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.noscript.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-script-1.xsd","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Server-side Image Maps module for XHTML\n+      $Id: xhtml-ssismap-1.xsd,v 1.3 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Server-side Image Maps\n+      \n+      This adds the 'ismap' attribute to the img element to \n+      support server-side processing of a user selection.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_servermapmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.img.ssimap.attlist\">\n+        <xs:attribute name=\"ismap\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"ismap\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.input.ssimap.attlist\">\n+        <xs:attribute name=\"ismap\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"ismap\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-ssismap-1.xsd","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+    elementFormDefault=\"qualified\"\n+    xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\">\n+    <xs:import\n+        namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+        schemaLocation=\"xhtml-datatypes-1.xsd\"\/>\n+    <xs:annotation>\n+        <xs:documentation>\n+        This is the XML Schema Document Structure module for XHTML\n+        Document Structure\n+    \n+          * title, head, body, html\n+    \n+        The Structure Module defines the major structural elements and \n+        their attributes.\n+        \n+        $Id: xhtml-struct-1.xsd,v 1.11 2009\/09\/30 14:13:35 ahby Exp $     \n+      <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_structuremodule\"\/>\n+    <\/xs:annotation>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+        schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+                This import brings in the XML namespace attributes\n+                The module itself does not provide the schemaLocation\n+                and expects the driver schema to provide the\n+                actual SchemaLocation.\n+            <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:attributeGroup\n+        name=\"xhtml.title.attlist\">\n+        <xs:attributeGroup\n+            ref=\"xhtml.I18n.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.id\"\/>\n+        <xs:attribute ref=\"xml:space\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group\n+        name=\"xhtml.title.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType\n+        name=\"xhtml.title.type\"\n+        mixed=\"true\">\n+        <xs:group\n+            ref=\"xhtml.title.content\"\/>\n+        <xs:attributeGroup\n+            ref=\"xhtml.title.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup\n+        name=\"xhtml.profile.attrib\">\n+        <xs:attribute\n+            name=\"profile\"\n+            type=\"xh11d:URIs\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup\n+        name=\"xhtml.head.attlist\">\n+        <xs:attributeGroup\n+            ref=\"xhtml.profile.attrib\"\/>\n+        <xs:attributeGroup\n+            ref=\"xhtml.I18n.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.id\"\/>\n+        <xs:attribute ref=\"xml:space\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:complexType\n+        name=\"xhtml.head.type\">\n+        <xs:group\n+            ref=\"xhtml.head.content\"\/>\n+        <xs:attributeGroup\n+            ref=\"xhtml.head.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup\n+        name=\"xhtml.body.attlist\">\n+        <xs:attributeGroup\n+            ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group\n+        name=\"xhtml.body.content\">\n+        <xs:sequence>\n+            <xs:group\n+                ref=\"xhtml.Block.mix\"\n+                minOccurs=\"0\"\n+                maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType\n+        name=\"xhtml.body.type\">\n+        <xs:group\n+            ref=\"xhtml.body.content\"\/>\n+        <xs:attributeGroup\n+            ref=\"xhtml.body.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup\n+        name=\"xhtml.version.attrib\">\n+        <xs:attribute\n+            name=\"version\"\n+            type=\"xh11d:CDATA\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup\n+        name=\"xhtml.html.attlist\">\n+        <xs:attributeGroup\n+            ref=\"xhtml.version.attrib\"\/>\n+        <xs:attributeGroup\n+            ref=\"xhtml.I18n.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.id\"\/>\n+        <xs:attribute ref=\"xml:space\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group\n+        name=\"xhtml.html.content\">\n+        <xs:sequence>\n+            <xs:element\n+                name=\"head\"\n+                type=\"xhtml.head.type\"\/>\n+            <xs:element\n+                name=\"body\"\n+                type=\"xhtml.body.type\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType\n+        name=\"xhtml.html.type\">\n+        <xs:group\n+            ref=\"xhtml.html.content\"\/>\n+        <xs:attributeGroup\n+            ref=\"xhtml.html.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-struct-1.xsd","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema Stylesheets module for XHTML\n+      $Id: xhtml-style-1.xsd,v 1.5 2006\/09\/11 10:14:57 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Stylesheets\n+      \n+        * style\n+      \n+      This module declares the style element type and its attributes,\n+      used to embed stylesheet information in the document head element.\n+    <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_stylemodule\"\/>\n+    <\/xs:annotation>\n+  <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+             schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+          This import brings in the XML namespace attributes \n+          The module itself does not provide the schemaLocation\n+          and expects the driver schema to provide the \n+          actual SchemaLocation.\n+        <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:attributeGroup name=\"xhtml.style.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.id\"\/>\n+        <xs:attributeGroup ref=\"xhtml.title\"\/>\n+        <xs:attributeGroup ref=\"xhtml.I18n.attrib\"\/>\n+        <xs:attribute name=\"type\" type=\"xh11d:ContentType\" use=\"required\"\/>\n+        <xs:attribute name=\"media\" type=\"xh11d:MediaDesc\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.style.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.style.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.style.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.style.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-style-1.xsd","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+          This is the XML Schema Tables module for XHTML\n+          $Id: xhtml-table-1.xsd,v 1.3 2005\/09\/26 22:54:53 ahby Exp $\n+        <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+          Tables\n+      \n+           * table, caption, thead, tfoot, tbody, colgroup, col, tr, th, td\n+      \n+          This module declares element types and attributes used to provide\n+          table markup similar to HTML 4.0, including features that enable\n+          better accessibility for non-visual user agents.\n+        <\/xs:documentation>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_tablemodule\"\/>\n+    <\/xs:annotation>\n+    <xs:attributeGroup name=\"xhtml.frame.attrib\">\n+        <xs:attribute name=\"frame\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"void\"\/>\n+                    <xs:enumeration value=\"above\"\/>\n+                    <xs:enumeration value=\"below\"\/>\n+                    <xs:enumeration value=\"hsides\"\/>\n+                    <xs:enumeration value=\"lhs\"\/>\n+                    <xs:enumeration value=\"rhs\"\/>\n+                    <xs:enumeration value=\"vsides\"\/>\n+                    <xs:enumeration value=\"box\"\/>\n+                    <xs:enumeration value=\"border\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.rules.attrib\">\n+        <xs:attribute name=\"rules\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"none\"\/>\n+                    <xs:enumeration value=\"groups\"\/>\n+                    <xs:enumeration value=\"rows\"\/>\n+                    <xs:enumeration value=\"cols\"\/>\n+                    <xs:enumeration value=\"all\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.CellVAlign.attrib\">\n+        <xs:attribute name=\"valign\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"top\"\/>\n+                    <xs:enumeration value=\"middle\"\/>\n+                    <xs:enumeration value=\"bottom\"\/>\n+                    <xs:enumeration value=\"baseline\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.CellHAlign.attrib\">\n+        <xs:attribute name=\"align\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"left\"\/>\n+                    <xs:enumeration value=\"center\"\/>\n+                    <xs:enumeration value=\"right\"\/>\n+                    <xs:enumeration value=\"justify\"\/>\n+                    <xs:enumeration value=\"char\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+        <xs:attribute name=\"char\" type=\"xh11d:Character\"\/>\n+        <xs:attribute name=\"charoff\" type=\"xh11d:Length\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.scope.attrib\">\n+        <xs:attribute name=\"scope\">\n+            <xs:simpleType>\n+                <xs:restriction base=\"xs:NMTOKEN\">\n+                    <xs:enumeration value=\"row\"\/>\n+                    <xs:enumeration value=\"col\"\/>\n+                    <xs:enumeration value=\"rowgroup\"\/>\n+                    <xs:enumeration value=\"colgroup\"\/>\n+                <\/xs:restriction>\n+            <\/xs:simpleType>\n+        <\/xs:attribute>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup name=\"xhtml.td.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"abbr\" type=\"xh11d:Text\"\/>\n+        <xs:attribute name=\"axis\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+        <xs:attributeGroup ref=\"xhtml.scope.attrib\"\/>\n+        <xs:attribute name=\"rowspan\" type=\"xh11d:Number\" default=\"1\"\/>\n+        <xs:attribute name=\"colspan\" type=\"xh11d:Number\" default=\"1\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.td.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Flow.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.td.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.td.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.td.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.th.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"abbr\" type=\"xh11d:Text\"\/>\n+        <xs:attribute name=\"axis\" type=\"xh11d:CDATA\"\/>\n+        <xs:attribute name=\"headers\" type=\"xs:IDREFS\"\/>\n+        <xs:attributeGroup ref=\"xhtml.scope.attrib\"\/>\n+        <xs:attribute name=\"rowspan\" type=\"xh11d:Number\" default=\"1\"\/>\n+        <xs:attribute name=\"colspan\" type=\"xh11d:Number\" default=\"1\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.th.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Flow.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.th.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.th.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.th.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.tr.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.tr.content\">\n+        <xs:sequence>\n+            <xs:choice maxOccurs=\"unbounded\">\n+                <xs:element name=\"th\" type=\"xhtml.th.type\"\/>\n+                <xs:element name=\"td\" type=\"xhtml.td.type\"\/>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.tr.type\">\n+        <xs:group ref=\"xhtml.tr.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.tr.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.col.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"span\" type=\"xh11d:Number\" default=\"1\"\/>\n+        <xs:attribute name=\"width\" type=\"xh11d:MultiLength\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.col.content\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.col.type\">\n+        <xs:group ref=\"xhtml.col.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.col.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.colgroup.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"span\" type=\"xh11d:Number\" default=\"1\"\/>\n+        <xs:attribute name=\"width\" type=\"xh11d:MultiLength\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.colgroup.content\">\n+        <xs:sequence>\n+            <xs:element name=\"col\" type=\"xhtml.col.type\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.colgroup.type\">\n+        <xs:group ref=\"xhtml.colgroup.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.colgroup.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.tbody.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.tbody.content\">\n+        <xs:sequence>\n+            <xs:element name=\"tr\" type=\"xhtml.tr.type\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.tbody.type\">\n+        <xs:group ref=\"xhtml.tbody.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.tbody.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.tfoot.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.tfoot.content\">\n+        <xs:sequence>\n+            <xs:element name=\"tr\" type=\"xhtml.tr.type\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.tfoot.type\">\n+        <xs:group ref=\"xhtml.tfoot.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.tfoot.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.thead.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellHAlign.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.CellVAlign.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.thead.content\">\n+        <xs:sequence>\n+            <xs:element name=\"tr\" type=\"xhtml.tr.type\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.thead.type\">\n+        <xs:group ref=\"xhtml.thead.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.thead.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.caption.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.caption.content\">\n+        <xs:sequence>\n+            <xs:group ref=\"xhtml.Inline.mix\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.caption.type\" mixed=\"true\">\n+        <xs:group ref=\"xhtml.caption.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.caption.attlist\"\/>\n+    <\/xs:complexType>\n+    <xs:attributeGroup name=\"xhtml.table.attlist\">\n+        <xs:attributeGroup ref=\"xhtml.Common.attrib\"\/>\n+        <xs:attribute name=\"summary\" type=\"xh11d:Text\"\/>\n+        <xs:attribute name=\"width\" type=\"xh11d:Length\"\/>\n+        <xs:attribute name=\"border\" type=\"xh11d:Pixels\"\/>\n+        <xs:attributeGroup ref=\"xhtml.frame.attrib\"\/>\n+        <xs:attributeGroup ref=\"xhtml.rules.attrib\"\/>\n+        <xs:attribute name=\"cellspacing\" type=\"xh11d:Length\"\/>\n+        <xs:attribute name=\"cellpadding\" type=\"xh11d:Length\"\/>\n+    <\/xs:attributeGroup>\n+    <xs:group name=\"xhtml.table.content\">\n+        <xs:sequence>\n+            <xs:element name=\"caption\" type=\"xhtml.caption.type\" minOccurs=\"0\"\/>\n+            <xs:choice>\n+                <xs:element name=\"col\" type=\"xhtml.col.type\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+                <xs:element name=\"colgroup\" type=\"xhtml.colgroup.type\" minOccurs=\"0\" maxOccurs=\"unbounded\"\/>\n+            <\/xs:choice>\n+            <xs:choice>\n+                <xs:sequence>\n+                    <xs:element name=\"thead\" type=\"xhtml.thead.type\" minOccurs=\"0\"\/>\n+                    <xs:element name=\"tfoot\" type=\"xhtml.tfoot.type\" minOccurs=\"0\"\/>\n+                    <xs:element name=\"tbody\" type=\"xhtml.tbody.type\" maxOccurs=\"unbounded\"\/>\n+                <\/xs:sequence>\n+                <xs:choice>\n+                    <xs:element name=\"tr\" type=\"xhtml.tr.type\" maxOccurs=\"unbounded\"\/>\n+                <\/xs:choice>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:complexType name=\"xhtml.table.type\">\n+        <xs:group ref=\"xhtml.table.content\"\/>\n+        <xs:attributeGroup ref=\"xhtml.table.attlist\"\/>\n+    <\/xs:complexType>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-table-1.xsd","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+  <xs:annotation>\n+    <xs:documentation>\n+      This is the XML Schema Target module for XHTML\n+      $Id: xhtml-target-1.xsd,v 1.3 2007\/04\/03 18:27:01 ahby Exp $\n+    <\/xs:documentation>\n+    <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+  <\/xs:annotation>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+      Target \n+      \n+        * target\n+      \n+      This module declares the 'target' attribute used for opening windows\n+    <\/xs:documentation>\n+    <xs:documentation \n+         source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_targetmodule\"\/>\n+  <\/xs:annotation>\n+  \n+  <xs:attributeGroup name=\"xhtml.base.target.attlist\">\n+    <xs:attribute name=\"target\" type=\"xh11d:FrameTarget\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"xhtml.form.target.attlist\">\n+    <xs:attribute name=\"target\" type=\"xh11d:FrameTarget\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"xhtml.link.target.attlist\">\n+    <xs:attribute name=\"target\" type=\"xh11d:FrameTarget\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"xhtml.area.target.attlist\">\n+    <xs:attribute name=\"target\" type=\"xh11d:FrameTarget\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:attributeGroup name=\"xhtml.a.target.attlist\">\n+    <xs:attribute name=\"target\" type=\"xh11d:FrameTarget\"\/>\n+  <\/xs:attributeGroup>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-target-1.xsd","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+ xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+ elementFormDefault=\"qualified\"\n+ xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+>\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+               schemaLocation=\"xhtml-datatypes-1.xsd\" \/>\n+    <xs:annotation>\n+        <xs:documentation>\n+      Textual Content\n+      This is the XML Schema Text module for XHTML\n+\n+      The Text module includes declarations for all core\n+      text container elements and their attributes.\n+    \n+        +  block phrasal\n+        +  block structural\n+        +  inline phrasal\n+        +  inline structural\n+      \n+      $Id: xhtml-text-1.xsd,v 1.2 2005\/09\/26 22:54:53 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+        <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_textmodule\"\/>\n+    <\/xs:annotation>\n+    <xs:include schemaLocation=\"xhtml-blkphras-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Block Phrasal module\n+        Elements defined here:\n+\n+          * address, blockquote, pre, h1, h2, h3, h4, h5, h6\n+    <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"xhtml-blkstruct-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Block Structural module \n+        Elements defined here:\n+\n+          * div, p\n+    <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"xhtml-inlphras-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Inline Phrasal module\n+        Elements defined here:\n+\n+          * abbr, acronym, cite, code, dfn, em, kbd, q, samp, strong, var\n+    <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"xhtml-inlstruct-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Inline Structural module \n+        Elements defined here:\n+\n+          * br,span\n+    <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml-text-1.xsd","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,716 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+    xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+    elementFormDefault=\"qualified\" >\n+    <xs:import\n+        namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+        schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-datatypes-1.xsd\"\/>\n+    <xs:annotation>\n+        <xs:documentation> \n+            This is the XML Schema module of common content models for XHTML11 \n+            \n+            $Id: xhtml11-model-1.xsd,v 1.9 2009\/02\/03 15:14:49 ahby Exp $ \n+        <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation> \n+            XHTML Document Model \n+            This module describes the groupings of elements\/attributes \n+            that make up common content models for XHTML elements. \n+            XHTML has following basic content models: \n+               xhtml.Inline.mix; character-level elements\n+               xhtml.Block.mix; block-like elements, e.g., paragraphs and lists\n+               xhtml.Flow.mix; any block or inline elements \n+               xhtml.HeadOpts.mix; Head Elements \n+               xhtml.InlinePre.mix; Special class for pre content model \n+               xhtml.InlineNoAnchor.mix; Content model for Anchor \n+            \n+            Any groups declared in this module may be used to create \n+            element content models, but the above are considered 'global' \n+            (insofar as that term applies here). XHTML has the\n+            following Attribute Groups \n+               xhtml.Core.extra.attrib \n+               xhtml.I18n.extra.attrib\n+               xhtml.Common.extra \n+            \n+            The above attribute Groups are considered Global \n+        <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:attributeGroup\n+        name=\"xhtml.I18n.extra.attrib\">\n+        <xs:annotation>\n+            <xs:documentation> Extended I18n attribute <\/xs:documentation>\n+        <\/xs:annotation>\n+        <xs:attributeGroup\n+            ref=\"xhtml.dir.attrib\">\n+            <xs:annotation>\n+                <xs:documentation> \n+                \"dir\" Attribute from Bi Directional Text (bdo) Module\n+                <\/xs:documentation>\n+            <\/xs:annotation>\n+        <\/xs:attributeGroup>\n+        <xs:attribute name=\"lang\" type=\"xh11d:LanguageCode\" \/>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup\n+        name=\"xhtml.Common.extra\">\n+        <xs:annotation>\n+            <xs:documentation> Extended Common Attributes <\/xs:documentation>\n+        <\/xs:annotation>\n+        <xs:attributeGroup\n+            ref=\"xhtml.style.attrib\">\n+            <xs:annotation>\n+                <xs:documentation> \n+                \"style\" attribute from Inline Style Module \n+                <\/xs:documentation>\n+            <\/xs:annotation>\n+        <\/xs:attributeGroup>\n+    \t<xs:attributeGroup ref=\"xhtml.Events.attrib\">\n+\t\t\t<xs:annotation>\n+\t\t\t\t<xs:documentation> \n+\t\t\t\tAttributes from Events Module\n+\t\t\t\t<\/xs:documentation>\n+\t\t\t<\/xs:annotation>\n+\t\t<\/xs:attributeGroup>\n+\t<\/xs:attributeGroup>\n+    <xs:attributeGroup\n+        name=\"xhtml.Core.extra.attrib\">\n+        <xs:annotation>\n+            <xs:documentation> Extend Core Attributes <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup\n+        name=\"xhtml.Global.core.extra.attrib\">\n+        <xs:annotation>\n+            <xs:documentation> Extended Global Core Attributes <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup\n+        name=\"xhtml.Global.I18n.extra.attrib\">\n+        <xs:annotation>\n+            <xs:documentation> Extended Global I18n attributes <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:attributeGroup>\n+    <xs:attributeGroup\n+        name=\"xhtml.Global.Common.extra\">\n+        <xs:annotation>\n+            <xs:documentation> Extended Global Common Attributes <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:attributeGroup>\n+    <xs:group\n+        name=\"xhtml.Head.extra\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.HeadOpts.mix\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"script\"\n+                type=\"xhtml.script.type\"\/>\n+            <xs:element\n+                name=\"style\"\n+                type=\"xhtml.style.type\"\/>\n+            <xs:element\n+                name=\"meta\"\n+                type=\"xhtml.meta.type\"\/>\n+            <xs:element\n+                name=\"link\"\n+                type=\"xhtml.link.type\"\/>\n+            <xs:element\n+                name=\"object\"\n+                type=\"xhtml.object.type\"\/>\n+            <xs:group\n+                ref=\"xhtml.Head.extra\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.head.content\">\n+        <xs:sequence>\n+            <xs:group\n+                ref=\"xhtml.HeadOpts.mix\"\n+                minOccurs=\"0\"\n+                maxOccurs=\"unbounded\"\/>\n+            <xs:choice>\n+                <xs:sequence>\n+                    <xs:element\n+                        name=\"title\"\n+                        minOccurs=\"1\"\n+                        maxOccurs=\"1\"\n+                        type=\"xhtml.title.type\"\/>\n+                    <xs:group\n+                        ref=\"xhtml.HeadOpts.mix\"\n+                        minOccurs=\"0\"\n+                        maxOccurs=\"unbounded\"\/>\n+                    <xs:sequence\n+                        minOccurs=\"0\">\n+                        <xs:element\n+                            name=\"base\"\n+                            type=\"xhtml.base.type\"\/>\n+                        <xs:group\n+                            ref=\"xhtml.HeadOpts.mix\"\n+                            minOccurs=\"0\"\n+                            maxOccurs=\"unbounded\"\/>\n+                    <\/xs:sequence>\n+                <\/xs:sequence>\n+                <xs:sequence>\n+                    <xs:element\n+                        name=\"base\"\n+                        type=\"xhtml.base.type\"\n+                        minOccurs=\"1\"\n+                        maxOccurs=\"1\"\/>\n+                    <xs:group\n+                        ref=\"xhtml.HeadOpts.mix\"\n+                        minOccurs=\"0\"\n+                        maxOccurs=\"unbounded\"\/>\n+                    <xs:element\n+                        name=\"title\"\n+                        minOccurs=\"1\"\n+                        maxOccurs=\"1\"\n+                        type=\"xhtml.title.type\"\/>\n+                    <xs:group\n+                        ref=\"xhtml.HeadOpts.mix\"\n+                        minOccurs=\"0\"\n+                        maxOccurs=\"unbounded\"\/>\n+                <\/xs:sequence>\n+            <\/xs:choice>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <!--\n+    ins and del are used to denote editing changes\n+  -->\n+    <xs:group\n+        name=\"xhtml.Edit.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"ins\"\n+                type=\"xhtml.edit.type\"\/>\n+            <xs:element\n+                name=\"del\"\n+                type=\"xhtml.edit.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    script and noscript are used to contain scripts\n+    and alternative content\n+  -->\n+    <xs:group\n+        name=\"xhtml.Script.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"script\"\n+                type=\"xhtml.script.type\"\/>\n+            <xs:element\n+                name=\"noscript\"\n+                type=\"xhtml.noscript.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Misc.extra\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <!--\n+    These elements are neither block nor inline, and can\n+    essentially be used anywhere in the document body.\n+  -->\n+    <xs:group\n+        name=\"xhtml.Misc.class\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.Edit.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Script.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.extra\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!-- Inline Elements -->\n+    <xs:group\n+        name=\"xhtml.InlStruct.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"br\"\n+                type=\"xhtml.br.type\"\/>\n+            <xs:element\n+                name=\"span\"\n+                type=\"xhtml.span.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.InlPhras.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"em\"\n+                type=\"xhtml.em.type\"\/>\n+            <xs:element\n+                name=\"strong\"\n+                type=\"xhtml.strong.type\"\/>\n+            <xs:element\n+                name=\"dfn\"\n+                type=\"xhtml.dfn.type\"\/>\n+            <xs:element\n+                name=\"code\"\n+                type=\"xhtml.code.type\"\/>\n+            <xs:element\n+                name=\"samp\"\n+                type=\"xhtml.samp.type\"\/>\n+            <xs:element\n+                name=\"kbd\"\n+                type=\"xhtml.kbd.type\"\/>\n+            <xs:element\n+                name=\"var\"\n+                type=\"xhtml.var.type\"\/>\n+            <xs:element\n+                name=\"cite\"\n+                type=\"xhtml.cite.type\"\/>\n+            <xs:element\n+                name=\"abbr\"\n+                type=\"xhtml.abbr.type\"\/>\n+            <xs:element\n+                name=\"acronym\"\n+                type=\"xhtml.acronym.type\"\/>\n+            <xs:element\n+                name=\"q\"\n+                type=\"xhtml.q.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.InlPres.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"tt\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"i\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"b\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"big\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"small\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"sub\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"sup\"\n+                type=\"xhtml.InlPres.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.I18n.class\">\n+        <xs:sequence>\n+            <xs:element\n+                name=\"bdo\"\n+                type=\"xhtml.bdo.type\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Anchor.class\">\n+        <xs:sequence>\n+            <xs:element\n+                name=\"a\"\n+                type=\"xhtml.a.type\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.InlSpecial.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"img\"\n+                type=\"xhtml.img.type\"\/>\n+            <xs:element\n+                name=\"map\"\n+                type=\"xhtml.map.type\"\/>\n+            <xs:element\n+                name=\"object\"\n+                type=\"xhtml.object.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.InlForm.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"input\"\n+                type=\"xhtml.input.type\"\/>\n+            <xs:element\n+                name=\"select\"\n+                type=\"xhtml.select.type\"\/>\n+            <xs:element\n+                name=\"textarea\"\n+                type=\"xhtml.textarea.type\"\/>\n+            <xs:element\n+                name=\"label\"\n+                type=\"xhtml.label.type\"\/>\n+            <xs:element\n+                name=\"button\"\n+                type=\"xhtml.button.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Inline.extra\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Ruby.class\">\n+        <xs:sequence>\n+            <xs:element\n+                name=\"ruby\"\n+                type=\"xhtml.ruby.type\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <!--\n+    Inline.class includes all inline elements,\n+    used as a component in mixes\n+  -->\n+    <xs:group\n+        name=\"xhtml.Inline.class\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.InlStruct.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlPhras.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlPres.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.I18n.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Anchor.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlSpecial.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlForm.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Ruby.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Inline.extra\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+     InlNoRuby.class includes all inline elements\n+     except ruby\n+  -->\n+    <xs:group\n+        name=\"xhtml.InlNoRuby.class\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.InlStruct.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlPhras.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlPres.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.I18n.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Anchor.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlSpecial.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlForm.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Inline.extra\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    InlinePre.mix\n+    Used as a component in pre model\n+  -->\n+    <xs:group\n+        name=\"xhtml.InlinePre.mix\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.InlStruct.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlPhras.class\"\/>\n+            <xs:element\n+                name=\"tt\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"i\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:element\n+                name=\"b\"\n+                type=\"xhtml.InlPres.type\"\/>\n+            <xs:group\n+                ref=\"xhtml.I18n.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Anchor.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.class\"\/>\n+            <xs:element\n+                name=\"map\"\n+                type=\"xhtml.map.type\"\/>\n+            <xs:group\n+                ref=\"xhtml.Inline.extra\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    InlNoAnchor.class includes all non-anchor inlines,\n+    used as a component in mixes\n+  -->\n+    <xs:group\n+        name=\"xhtml.InlNoAnchor.class\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.InlStruct.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlPhras.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlPres.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.I18n.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlSpecial.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.InlForm.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Ruby.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Inline.extra\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    InlNoAnchor.mix includes all non-anchor inlines\n+  -->\n+    <xs:group\n+        name=\"xhtml.InlNoAnchor.mix\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.InlNoAnchor.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.class\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    Inline.mix includes all inline elements, including Misc.class\n+  -->\n+    <xs:group\n+        name=\"xhtml.Inline.mix\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.Inline.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.class\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+   InlNoRuby.mix includes all of inline.mix elements\n+   except ruby\n+  -->\n+    <xs:group\n+        name=\"xhtml.InlNoRuby.mix\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.InlNoRuby.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.class\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    In the HTML 4 DTD, heading and list elements were included\n+    in the block group. The Heading.class and\n+    List.class groups must now be included explicitly\n+    on element declarations where desired.\n+  -->\n+    <xs:group\n+        name=\"xhtml.Heading.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"h1\"\n+                type=\"xhtml.h1.type\"\/>\n+            <xs:element\n+                name=\"h2\"\n+                type=\"xhtml.h2.type\"\/>\n+            <xs:element\n+                name=\"h3\"\n+                type=\"xhtml.h3.type\"\/>\n+            <xs:element\n+                name=\"h4\"\n+                type=\"xhtml.h4.type\"\/>\n+            <xs:element\n+                name=\"h5\"\n+                type=\"xhtml.h5.type\"\/>\n+            <xs:element\n+                name=\"h6\"\n+                type=\"xhtml.h6.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.List.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"ul\"\n+                type=\"xhtml.ul.type\"\/>\n+            <xs:element\n+                name=\"ol\"\n+                type=\"xhtml.ol.type\"\/>\n+            <xs:element\n+                name=\"dl\"\n+                type=\"xhtml.dl.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Table.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"table\"\n+                type=\"xhtml.table.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Form.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"form\"\n+                type=\"xhtml.form.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Fieldset.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"fieldset\"\n+                type=\"xhtml.fieldset.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.BlkStruct.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"p\"\n+                type=\"xhtml.p.type\"\/>\n+            <xs:element\n+                name=\"div\"\n+                type=\"xhtml.div.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.BlkPhras.class\">\n+        <xs:choice>\n+            <xs:element\n+                name=\"pre\"\n+                type=\"xhtml.pre.type\"\/>\n+            <xs:element\n+                name=\"blockquote\"\n+                type=\"xhtml.blockquote.type\"\/>\n+            <xs:element\n+                name=\"address\"\n+                type=\"xhtml.address.type\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.BlkPres.class\">\n+        <xs:sequence>\n+            <xs:element\n+                name=\"hr\"\n+                type=\"xhtml.hr.type\"\/>\n+        <\/xs:sequence>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.BlkSpecial.class\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.Table.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Form.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Fieldset.class\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:group\n+        name=\"xhtml.Block.extra\">\n+        <xs:sequence\/>\n+    <\/xs:group>\n+    <!--\n+    Block.class includes all block elements,\n+    used as an component in mixes\n+  -->\n+    <xs:group\n+        name=\"xhtml.Block.class\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.BlkStruct.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.BlkPhras.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.BlkPres.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.BlkSpecial.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Block.extra\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+   Block.mix includes all block elements plus %Misc.class;\n+  -->\n+    <xs:group\n+        name=\"xhtml.Block.mix\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.Heading.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.List.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Block.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.class\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    All Content Elements\n+    Flow.mix includes all text content, block and inline\n+    Note that the \"any\" element included here allows us\n+    to add data from any other namespace, a necessity\n+    for compound document creation.\n+    Note however that it is not possible to add\n+    to any head level element without further\n+    modification. To add RDF metadata to the head\n+    of a document, modify the structure module.\n+  -->\n+    <xs:group\n+        name=\"xhtml.Flow.mix\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.Heading.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.List.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Block.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Inline.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.class\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <!--\n+    BlkNoForm.mix includes all non-form block elements,\n+    plus Misc.class\n+  -->\n+    <xs:group\n+        name=\"xhtml.BlkNoForm.mix\">\n+        <xs:choice>\n+            <xs:group\n+                ref=\"xhtml.Heading.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.List.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.BlkStruct.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.BlkPhras.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.BlkPres.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Table.class\"\/>\n+            <xs:group\n+                ref=\"xhtml.Block.extra\"\/>\n+            <xs:group\n+                ref=\"xhtml.Misc.class\"\/>\n+        <\/xs:choice>\n+    <\/xs:group>\n+    <xs:element\n+        name=\"html\"\n+        type=\"xhtml.html.type\"\/>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml11-model-1.xsd","additions":716,"deletions":0,"binary":false,"changes":716,"status":"added"},{"patch":"@@ -0,0 +1,605 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\" \n+           elementFormDefault=\"qualified\" \n+           xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" >\n+    <xs:import namespace=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\" \n+        schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-datatypes-1.xsd\" \/>\n+\n+    <xs:annotation>\n+        <xs:documentation>\n+      This schema includes all modules for XHTML1.1 Document Type.\n+      $Id: xhtml11-modules-1.xsd,v 1.10 2009\/02\/03 15:14:49 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+     This schema includes all modules (and redefinitions)\n+     for XHTML1.1 Document Type.\n+     XHTML1.1 Document Type includes the following Modules\n+\n+       XHTML Core modules (Required for XHTML Family Conformance)\n+            +  text\n+            +  hypertext\n+            +  lists\n+            +  structure\n+\n+       Other XHTML modules\n+            +  Edit\n+            +  Bdo\n+            +  Presentational\n+            +  Link\n+            +  Meta\n+            +  Base\n+            +  Scripting\n+            +  Style\n+            +  Image\n+            +  Applet\n+            +  Object\n+            +  Param (Applet\/Object modules require Param Module)\n+            +  Tables\n+            +  Target\n+            +  Forms\n+            +  Client side image maps\n+            +  Server side image maps\n+\n+    <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-framework-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Schema Framework Component Modules:\n+            +  notations\n+            +  datatypes\n+            +  common attributes\n+            +  character entities\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_commonatts\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-text-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Text module\n+\n+        The Text module includes declarations for all core\n+        text container elements and their attributes.\n+\n+            +  block phrasal\n+            +  block structural\n+            +  inline phrasal\n+            +  inline structural\n+\n+        Elements defined here:\n+          * address, blockquote, pre, h1, h2, h3, h4, h5, h6\n+          * div, p\n+          * abbr, acronym, cite, code, dfn, em, kbd, q, samp, strong, var\n+          * br, span\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_textmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-hypertext-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+         Hypertext module\n+\n+         Elements defined here:\n+          * a\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_hypertextmodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.a.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.a.attlist\"\/>\n+            <xs:attributeGroup ref=\"xhtml.a.csim.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+              Redefinition by Client Side Image Map Module\n+            <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.a.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+              Redefinition by XHTML Event Attribute Module\n+            <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.a.target.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+              Target Module - A Attribute Additions\n+            <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-list-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Lists module\n+\n+        Elements defined here:\n+          * dt, dd, dl, ol, ul, li\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_listmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-struct-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Structural module\n+\n+        Elements defined here:\n+          * title, head, body, html\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-xhtml-modularization-20010410\/abstract_modules.html#s_structuremodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.version.attrib\">\n+            <xs:annotation>\n+                <xs:documentation>\n+            Redefinition by the XHTML11 Markup (for value of version attr)\n+         <\/xs:documentation>\n+            <\/xs:annotation>\n+            <xs:attribute name=\"version\" type=\"xh11d:CDATA\" fixed=\"-\/\/W3C\/\/DTD XHTML 1.1\/\/EN\"\/>\n+        <\/xs:attributeGroup>\n+        <xs:attributeGroup name=\"xhtml.body.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.body.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+              Original Body Attlist\n+            <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.body.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+              Redefinition by XHTML Event Attribute Module\n+            <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-edit-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Edit module\n+\n+        Elements defined here:\n+          * ins, del\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_editmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-bdo-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Bidirectional element module\n+\n+        Elements defined here:\n+          * bdo\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_bdomodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-pres-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Presentational module\n+\n+         Elements defined here:\n+           * hr, b, big, i, small,sub, sup, tt\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_presentationmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-link-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+                Link module\n+\n+                Elements defined here:\n+                   * link\n+            <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_linkmodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.link.attlist\">\n+            <xs:annotation>\n+                <xs:documentation>\n+            Changes to XHTML Link Attlist\n+          <\/xs:documentation>\n+            <\/xs:annotation>\n+            <xs:attributeGroup ref=\"xhtml.link.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Link Attributes (declared in Link Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.link.target.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                      XHTML Target Module - Attribute additions\n+                     <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-meta-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Meta module\n+\n+        Elements defined here:\n+        * meta\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_metamodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-base-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Base module\n+\n+        Elements defined here:\n+          * base\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_basemodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.base.attlist\">\n+            <xs:annotation>\n+                <xs:documentation>\n+            Changes to XHTML base Attlist\n+          <\/xs:documentation>\n+            <\/xs:annotation>\n+            <xs:attributeGroup ref=\"xhtml.base.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Base Attributes (declared in Base Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.base.target.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                XHTML Target Module - Attribute additions\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-script-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Scripting module\n+\n+        Elements defined here:\n+          * script, noscript\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_scriptmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-style-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Style module\n+\n+        Elements defined here:\n+          * style\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_stylemodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-inlstyle-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Style attribute module\n+\n+        Attribute defined here:\n+          * style\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_styleattributemodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-image-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Image module\n+\n+        Elements defined here:\n+          * img\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_imagemodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.img.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.img.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Image Attributes (in Image Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.img.csim.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Redefinition by Client Side Image Map Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.img.ssimap.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Redefinition by Server Side Image Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-csismap-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Client-side mage maps module\n+\n+        Elements defined here:\n+          * area, map\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_imapmodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.area.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.area.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Area Attributes (in CSI Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.area.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Redefinition by Events Attribute Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.area.target.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Target Module - Area Attribute Additions\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-ssismap-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+       Server-side image maps module\n+\n+        Attributes defined here:\n+          * ismap on img\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_servermapmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-object-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Object module\n+\n+        Elements defined here:\n+          * object\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_objectmodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.object.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.object.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Object Attlist\n+              <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.object.csim.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Redefinition by Client Image Map Module\n+              <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-param-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Param module\n+\n+        Elements defined here:\n+          * param\n+      <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-table-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Tables module\n+\n+        Elements defined here:\n+          * table, caption, thead, tfoot, tbody, colgroup, col, tr, th, td\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_tablemodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:redefine schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-form-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+            Forms module\n+\n+            Elements defined here:\n+              * form, label, input, select, optgroup, option,\n+              * textarea, fieldset, legend, button\n+          <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_extformsmodule\"\/>\n+        <\/xs:annotation>\n+        <xs:attributeGroup name=\"xhtml.form.attlist\">\n+            <xs:annotation>\n+                <xs:documentation>\n+            Changes to XHTML Form Attlist\n+          <\/xs:documentation>\n+            <\/xs:annotation>\n+            <xs:attributeGroup ref=\"xhtml.form.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Form Attributes (declared in Forms Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.form.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                XHTML Events Module - Attribute additions\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.form.target.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                      XHTML Target Module - Attribute additions\n+                     <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+        <xs:attributeGroup name=\"xhtml.input.attlist\">\n+            <xs:annotation>\n+                <xs:documentation>\n+            Changes to XHTML Form Input Element\n+          <\/xs:documentation>\n+            <\/xs:annotation>\n+            <xs:attributeGroup ref=\"xhtml.input.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Input Attributes (in Forms Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.input.csim.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Redefinition by Client Side Image Map Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.input.ssimap.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Redefinition by Server Side Image Map Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.input.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+               Redefinition by Event Attribute Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+        <xs:attributeGroup name=\"xhtml.label.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.label.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Label Attributes (in Forms Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.label.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+               Redefinition by Event Attribute Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+        <xs:attributeGroup name=\"xhtml.select.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.select.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Select Attributes (in Forms Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.select.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+               Redefinition by Event Attribute Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+        <xs:attributeGroup name=\"xhtml.textarea.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.textarea.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original TextArea Attributes (in Forms Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.textarea.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+               Redefinition by Event Attribute Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+        <xs:attributeGroup name=\"xhtml.button.attlist\">\n+            <xs:attributeGroup ref=\"xhtml.button.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+                Original Button Attributes (in Forms Module)\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+            <xs:attributeGroup ref=\"xhtml.button.events.attlist\">\n+                <xs:annotation>\n+                    <xs:documentation>\n+               Redefinition by Event Attribute Module\n+             <\/xs:documentation>\n+                <\/xs:annotation>\n+            <\/xs:attributeGroup>\n+        <\/xs:attributeGroup>\n+    <\/xs:redefine>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-ruby-1.xsd\">\n+      <xs:annotation>\n+      <xs:documentation>\n+        Ruby module\n+\n+        Elements defined here:\n+          * ruby, rbc, rtc, rb, rt, rp\n+\n+        Note that either Ruby or Basic Ruby should be used but not both\n+      <\/xs:documentation>\n+      <xs:documentation source=\"http:\/\/www.w3.org\/TR\/2001\/REC-ruby-20010531\/#complex\"\/>\n+      <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-events-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        XHTML Events Modules\n+\n+        Attributes defined here:\n+          XHTML Event Types\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_intrinsiceventsmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include schemaLocation=\"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml-target-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        XHTML Target Attribute Module\n+\n+        Attributes defined here:\n+          target\n+      <\/xs:documentation>\n+            <xs:documentation source=\"http:\/\/www.w3.org\/TR\/xhtml-modularization\/abstract_modules.html#s_targetmodule\"\/>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml11-modules-1.xsd","additions":605,"deletions":0,"binary":false,"changes":605,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+    targetNamespace=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns:xh11d=\"http:\/\/www.w3.org\/1999\/xhtml\/datatypes\/\"\n+    xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    elementFormDefault=\"qualified\" >\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the XML Schema driver for XHTML 1.1.\n+      Please use this namespace for XHTML elements:\n+\n+         \"http:\/\/www.w3.org\/1999\/xhtml\"\n+\n+      $Id: xhtml11.xsd,v 1.7 2009\/02\/03 15:14:49 ahby Exp $\n+    <\/xs:documentation>\n+        <xs:documentation source=\"xhtml-copyright-1.xsd\"\/>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is XHTML, a reformulation of HTML as a modular XML application\n+      The Extensible HyperText Markup Language (XHTML)\n+      Copyright &#169;1998-2007 World Wide Web Consortium\n+      (Massachusetts Institute of Technology, European Research Consortium\n+       for Informatics and Mathematics, Keio University).\n+      All Rights Reserved.\n+\n+      Permission to use, copy, modify and distribute the XHTML Schema\n+      modules and their accompanying xs:documentation for any purpose\n+      and without fee is hereby granted in perpetuity, provided that the above\n+      copyright notice and this paragraph appear in all copies.\n+      The copyright holders make no representation about the suitability of\n+      these XML Schema modules for any purpose.\n+\n+      They are provided \"as is\" without expressed or implied warranty.\n+    <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:annotation>\n+        <xs:documentation>\n+      This is the Schema Driver file for XHTML1.1\n+      Document Type\n+\n+     This schema\n+        + imports external schemas (xml.xsd)\n+        + refedines (and include)s schema modules for XHTML1.1 Document Type.\n+        + includes Schema for Named content model for the\n+          XHTML1.1 Document Type\n+\n+        XHTML1.1 Document Type includes the following Modules\n+           XHTML Core modules (Required for XHTML Family Conformance)\n+            +  text\n+            +  hypertext\n+            +  lists\n+            +  structure\n+           Other XHTML modules\n+            +  Edit\n+            +  Bdo\n+            +  Presentational\n+            +  Link\n+            +  Meta\n+            +  Base\n+            +  Scripting\n+            +  Style\n+            +  Image\n+            +  Applet\n+            +  Object\n+            +  Param (Applet\/Object modules require Param Module)\n+            +  Tables\n+            +  Forms\n+            +  Client side image maps\n+            +  Server side image maps\n+            +  Ruby\n+    <\/xs:documentation>\n+    <\/xs:annotation>\n+    <xs:import\n+        namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+        schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+         This import brings in the XML namespace attributes\n+         The XML attributes are used by various modules.\n+       <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:import>\n+    <xs:include\n+        schemaLocation=\"xhtml11-model-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Document Model module for the XHTML1.1 Document Type.\n+        This schema file defines all named models used by XHTML\n+        Modularization Framework for XHTML1.1 Document Type\n+      <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+    <xs:include\n+        schemaLocation=\"xhtml11-modules-1.xsd\">\n+        <xs:annotation>\n+            <xs:documentation>\n+        Schema that includes all modules (and redefinitions)\n+        for XHTML1.1 Document Type.                \n+           <\/xs:documentation>\n+        <\/xs:annotation>\n+    <\/xs:include>\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xhtml11.xsd","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema \n+    targetNamespace=\"http:\/\/www.w3.org\/2001\/xml-events\" \n+    xmlns=\"http:\/\/www.w3.org\/2001\/xml-events\" \n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\" \n+    xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" \n+    xsi:schemaLocation=\"http:\/\/www.w3.org\/2001\/XMLSchema \n+                        http:\/\/www.w3.org\/2001\/XMLSchema.xsd\" \n+    elementFormDefault=\"unqualified\" \n+    blockDefault=\"#all\" \n+    finalDefault=\"#all\" \n+    attributeFormDefault=\"unqualified\">\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+      This is the XML Schema for XML Events\n+\n+      URI: http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xml-events-1.xsd\n+      $Id: xml-events-1.xsd,v 1.8 2004\/11\/22 17:09:15 ahby Exp $\n+    <\/xs:documentation>\n+    <xs:documentation source=\"xml-events-copyright-1.xsd\"\/>\n+  <\/xs:annotation>\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+      XML Events element listener\n+\t\t\n+        This module defines the listener element for XML Events.\n+        This element can be used to define event listeners. This\n+        module relies upon the XmlEvents.attlist attribute group\n+        defined in xml-events-attribs-1.xsd.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+  <xs:attributeGroup name=\"listener.attlist\">\n+    <xs:attribute name=\"event\" use=\"required\" type=\"xs:NMTOKEN\"\/>\n+    <xs:attribute name=\"observer\" type=\"xs:IDREF\"\/>\n+    <xs:attribute name=\"target\" type=\"xs:IDREF\"\/>\n+    <xs:attribute name=\"handler\" type=\"xs:anyURI\"\/>\n+    <xs:attribute name=\"phase\" default=\"default\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:NMTOKEN\">\n+          <xs:enumeration value=\"capture\"\/>\n+          <xs:enumeration value=\"default\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"propagate\" default=\"continue\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:NMTOKEN\">\n+          <xs:enumeration value=\"stop\"\/>\n+          <xs:enumeration value=\"continue\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"defaultAction\" default=\"perform\">\n+      <xs:simpleType>\n+        <xs:restriction base=\"xs:NMTOKEN\">\n+          <xs:enumeration value=\"cancel\"\/>\n+          <xs:enumeration value=\"perform\"\/>\n+        <\/xs:restriction>\n+      <\/xs:simpleType>\n+    <\/xs:attribute>\n+    <xs:attribute name=\"id\" type=\"xs:ID\"\/>\n+  <\/xs:attributeGroup>\n+\n+  <xs:complexType name=\"listener.type\">\n+    <xs:attributeGroup ref=\"listener.attlist\"\/>\n+  <\/xs:complexType>\n+\n+  <xs:element name=\"listener\" type=\"listener.type\"\/>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xml-events-1.xsd","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema\t\n+    targetNamespace=\"http:\/\/www.w3.org\/2001\/xml-events\"\n+    xmlns=\"http:\/\/www.w3.org\/2001\/xml-events\"\n+    xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"  \n+    elementFormDefault=\"unqualified\" \n+    blockDefault=\"#all\" \n+    finalDefault=\"#all\" \n+    attributeFormDefault=\"unqualified\">\n+\n+  <xs:annotation>\n+    <xs:documentation>\n+      This is XML Events, a generalized event model for XML-based\n+      markup languages. \n+\n+        Copyright 2001-2003 World Wide Web Consortium\n+            (Massachusetts Institute of Technology, European Research\n+            Consortium for Informatics and Mathematics, Keio University).\n+            All Rights Reserved.\n+\t\t\n+        Permission to use, copy, modify and distribute the \n+        XML Events Schema modules and their accompanying xs:documentation \n+        for any purpose and without fee is hereby granted in perpetuity, \n+        provided that the above copyright notice and this paragraph appear \n+        in all copies.  \n+\n+        The copyright holders make no representation about the suitability of\n+        these XML Schema modules for any purpose.\n+\t\t\n+        They are provided \"as is\" without expressed or implied warranty.\n+    <\/xs:documentation>\n+  <\/xs:annotation>\n+\n+<\/xs:schema>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xhtml11\/xml-events-copyright-1.xsd","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!DOCTYPE xs:schema PUBLIC \"-\/\/W3C\/\/DTD XMLSCHEMA 200102\/\/EN\" \"XMLSchema.dtd\">\n+<xs:schema targetNamespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\" xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\" xml:lang=\"en\">\n+\n+ <xs:annotation>\n+  <xs:documentation>\n+   See http:\/\/www.w3.org\/XML\/1998\/namespace.html and\n+   http:\/\/www.w3.org\/TR\/REC-xml for information about this namespace.\n+\n+    This schema document describes the XML namespace, in a form\n+    suitable for import by other schema documents.  \n+\n+    Note that local names in this namespace are intended to be defined\n+    only by the World Wide Web Consortium or its subgroups.  The\n+    following names are currently defined in this namespace and should\n+    not be used with conflicting semantics by any Working Group,\n+    specification, or document instance:\n+\n+    base (as an attribute name): denotes an attribute whose value\n+         provides a URI to be used as the base for interpreting any\n+         relative URIs in the scope of the element on which it\n+         appears; its value is inherited.  This name is reserved\n+         by virtue of its definition in the XML Base specification.\n+\n+    lang (as an attribute name): denotes an attribute whose value\n+         is a language code for the natural language of the content of\n+         any element; its value is inherited.  This name is reserved\n+         by virtue of its definition in the XML specification.\n+  \n+    space (as an attribute name): denotes an attribute whose\n+         value is a keyword indicating what whitespace processing\n+         discipline is intended for the content of the element; its\n+         value is inherited.  This name is reserved by virtue of its\n+         definition in the XML specification.\n+\n+    Father (in any context at all): denotes Jon Bosak, the chair of \n+         the original XML Working Group.  This name is reserved by \n+         the following decision of the W3C XML Plenary and \n+         XML Coordination groups:\n+\n+             In appreciation for his vision, leadership and dedication\n+             the W3C XML Plenary on this 10th day of February, 2000\n+             reserves for Jon Bosak in perpetuity the XML name\n+             xml:Father\n+  <\/xs:documentation>\n+ <\/xs:annotation>\n+\n+ <xs:annotation>\n+  <xs:documentation>This schema defines attributes and an attribute group\n+        suitable for use by\n+        schemas wishing to allow xml:base, xml:lang or xml:space attributes\n+        on elements they define.\n+\n+        To enable this, such a schema must import this schema\n+        for the XML namespace, e.g. as follows:\n+        &lt;schema . . .&gt;\n+         . . .\n+         &lt;import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+                    schemaLocation=\"http:\/\/www.w3.org\/2001\/03\/xml.xsd\"\/&gt;\n+\n+        Subsequently, qualified reference to any of the attributes\n+        or the group defined below will have the desired effect, e.g.\n+\n+        &lt;type . . .&gt;\n+         . . .\n+         &lt;attributeGroup ref=\"xml:specialAttrs\"\/&gt;\n+ \n+         will define a type which will schema-validate an instance\n+         element with any of those attributes<\/xs:documentation>\n+ <\/xs:annotation>\n+\n+ <xs:annotation>\n+  <xs:documentation>In keeping with the XML Schema WG's standard versioning\n+   policy, this schema document will persist at\n+   http:\/\/www.w3.org\/2001\/03\/xml.xsd.\n+   At the date of issue it can also be found at\n+   http:\/\/www.w3.org\/2001\/xml.xsd.\n+   The schema document at that URI may however change in the future,\n+   in order to remain compatible with the latest version of XML Schema\n+   itself.  In other words, if the XML Schema namespace changes, the version\n+   of this document at\n+   http:\/\/www.w3.org\/2001\/xml.xsd will change\n+   accordingly; the version at\n+   http:\/\/www.w3.org\/2001\/03\/xml.xsd will not change.\n+  <\/xs:documentation>\n+ <\/xs:annotation>\n+\n+ <xs:attribute name=\"lang\" type=\"xs:language\">\n+  <xs:annotation>\n+   <xs:documentation>In due course, we should install the relevant ISO 2- and 3-letter\n+         codes as the enumerated possible values . . .<\/xs:documentation>\n+  <\/xs:annotation>\n+ <\/xs:attribute>\n+\n+ <xs:attribute name=\"space\" default=\"preserve\">\n+  <xs:simpleType>\n+   <xs:restriction base=\"xs:NCName\">\n+    <xs:enumeration value=\"default\"\/>\n+    <xs:enumeration value=\"preserve\"\/>\n+   <\/xs:restriction>\n+  <\/xs:simpleType>\n+ <\/xs:attribute>\n+\n+ <xs:attribute name=\"base\" type=\"xs:anyURI\">\n+  <xs:annotation>\n+   <xs:documentation>See http:\/\/www.w3.org\/TR\/xmlbase\/ for\n+                     information about this attribute.<\/xs:documentation>\n+  <\/xs:annotation>\n+ <\/xs:attribute>\n+\n+ <xs:attributeGroup name=\"specialAttrs\">\n+  <xs:attribute ref=\"xml:base\"\/>\n+  <xs:attribute ref=\"xml:lang\"\/>\n+  <xs:attribute ref=\"xml:space\"\/>\n+ <\/xs:attributeGroup>\n+\n+<\/xs:schema>\n\\ No newline at end of file\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/w3c\/xsd\/xmlNS2001\/xml.xsd","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -420,5 +420,91 @@\n- * The JDK has a built-in catalog that hosts the following DTDs defined by the Java Platform:\n- * <ul>\n- * <li>DTD for {@link java.util.prefs.Preferences java.util.prefs.Preferences}, preferences.dtd<\/li>\n- * <li>DTD for {@link java.util.Properties java.util.Properties}, properties.dtd<\/li>\n- * <\/ul>\n+ * The JDK has a built-in catalog that hosts DTDs and XSDs list in the following table.\n+ * <table class=\"plain\" id=\"JDKCatalog\">\n+ * <caption>DTDs and XSDs in JDK built-in Catalog<\/caption>\n+ * <thead>\n+ * <tr>\n+ * <th scope=\"col\">Source<\/th>\n+ * <th scope=\"col\">Files<\/th>\n+ * <\/tr>\n+ * <\/thead>\n+ *\n+ * <tbody>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"util_preferences\">\n+ * {@link java.util.prefs.Preferences java.util.prefs.Preferences}<\/th>\n+ * <td style=\"text-align:center\">\n+ * preferences.dtd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"util_properties\">\n+ * {@link java.util.Properties java.util.Properties}<\/th>\n+ * <td style=\"text-align:center\">\n+ * properties.dtd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"XMLSchema\">\n+ * XML Schema Part 1: Structures Second Edition<br>\n+ * XML Schema Part 2: Datatypes Second Edition\n+ * <\/th>\n+ * <td style=\"text-align:center\">\n+ * XMLSchema.dtd<br>\n+ * datatypes.dtd<br>\n+ * XMLSchema.xsd<br>\n+ * datatypes.xsd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"XHTML10\">\n+ * XHTML&trade; 1.0 The Extensible HyperText Markup Language\n+ * <\/th>\n+ * <td style=\"text-align:center\">\n+ * xhtml1-frameset.dtd<br>\n+ * xhtml1-strict.dtd<br>\n+ * xhtml1-transitional.dtd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"XHTML10Schema\">\n+ * XHTML&trade; 1.0 in XML Schema\n+ * <\/th>\n+ * <td style=\"text-align:center\">\n+ * xhtml1-frameset.xsd<br>\n+ * xhtml1-strict.xsd<br>\n+ * xhtml1-transitional.xsd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"XHTML11\">\n+ * XHTML&trade; 1.1 - Module-based XHTML - Second Edition\n+ * <\/th>\n+ * <td style=\"text-align:center\">\n+ * xhtml11.dtd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"XHTML11Schema\">\n+ * XHTML 1.1 XML Schema Definition\n+ * <\/th>\n+ * <td style=\"text-align:center\">\n+ * xhtml11.xsd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"XMLSPEC\">\n+ * XML DTD for W3C specifications\n+ * <\/th>\n+ * <td style=\"text-align:center\">\n+ * xmlspec.dtd\n+ * <\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\" style=\"font-weight:normal\" id=\"Namespace\">\n+ * The \"xml:\" Namespace\n+ * <\/th>\n+ * <td style=\"text-align:center\">\n+ * xml.xsd\n+ * <\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n","filename":"src\/java.xml\/share\/classes\/module-info.java","additions":91,"deletions":5,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -60,3 +60,2 @@\n-# The value type is boolean and the default value is true (allowing\n-# extension functions). The following entry overrides the default value and\n-# disallows extension functions:\n+# The value type is boolean and the default value is false (disallowing\n+# extension functions).\n@@ -64,1 +63,1 @@\n-# jdk.xml.enableExtensionFunctions=false\n+jdk.xml.enableExtensionFunctions=false\n","filename":"src\/java.xml\/share\/conf\/jaxp.properties","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+## XML Schema Part 1: Structures Second Edition\n+\n+### W3C Software and Document license\n+<pre>\n+Software and Document license - 2023 version\n+\n+Copied from:  https:\/\/www.w3.org\/copyright\/software-license-2023\n+\n+License\n+\n+By obtaining and\/or copying this work, you (the licensee) agree that you have\n+read, understood, and will comply with the following terms and conditions.\n+\n+Permission to copy, modify, and distribute this work, with or without modification,\n+for any purpose and without fee or royalty is hereby granted, provided that you\n+include the following on ALL copies of the work or portions thereof, including\n+modifications:\n+\n+    The full text of this NOTICE in a location viewable to users of the\n+    redistributed or derivative work.\n+    Any pre-existing intellectual property disclaimers, notices, or terms and\n+    conditions. If none exist, the W3C software and document short notice should\n+    be included.\n+    Notice of any changes or modifications, through a copyright statement on the\n+    new code or document such as \"This software or document includes material\n+    copied from or derived from [title and URI of the W3C document]. Copyright \n+    [$year-of-document] World Wide Web Consortium.\n+    https:\/\/www.w3.org\/copyright\/software-license-2023\/\"\n+\n+Disclaimers\n+\n+THIS WORK IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR\n+WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF\n+MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE\n+SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,\n+TRADEMARKS OR OTHER RIGHTS.\n+\n+COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR\n+CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.\n+\n+The name and trademarks of copyright holders may NOT be used in advertising or\n+publicity pertaining to the work without specific, written prior permission.\n+Title to copyright in this work will at all times remain with copyright holders.\n+\n+------\n+\n+Copyright  2004 W3C (MIT, ERCIM, Keio), All Rights Reserved. W3C liability,\n+trademark and document use rules apply.\n+\n+\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/schema10part1.md","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+## XML Schema Part 2: Datatypes Second Edition\n+\n+### W3C Software and Document license\n+<pre>\n+Software and Document license - 2023 version\n+\n+Copied from:  https:\/\/www.w3.org\/copyright\/software-license-2023\n+\n+License\n+\n+By obtaining and\/or copying this work, you (the licensee) agree that you have\n+read, understood, and will comply with the following terms and conditions.\n+\n+Permission to copy, modify, and distribute this work, with or without modification,\n+for any purpose and without fee or royalty is hereby granted, provided that you\n+include the following on ALL copies of the work or portions thereof, including\n+modifications:\n+\n+    The full text of this NOTICE in a location viewable to users of the\n+    redistributed or derivative work.\n+    Any pre-existing intellectual property disclaimers, notices, or terms and\n+    conditions. If none exist, the W3C software and document short notice should\n+    be included.\n+    Notice of any changes or modifications, through a copyright statement on the\n+    new code or document such as \"This software or document includes material\n+    copied from or derived from [title and URI of the W3C document]. Copyright \n+    [$year-of-document] World Wide Web Consortium.\n+    https:\/\/www.w3.org\/copyright\/software-license-2023\/\"\n+\n+Disclaimers\n+\n+THIS WORK IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR\n+WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF\n+MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE\n+SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,\n+TRADEMARKS OR OTHER RIGHTS.\n+\n+COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR\n+CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.\n+\n+The name and trademarks of copyright holders may NOT be used in advertising or\n+publicity pertaining to the work without specific, written prior permission.\n+Title to copyright in this work will at all times remain with copyright holders.\n+\n+------\n+\n+Copyright  2004 W3C (MIT, ERCIM, Keio), All Rights Reserved. W3C liability,\n+trademark and document use rules apply.\n+\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/schema10part2.md","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+## XHTML 1.0 The Extensible HyperText Markup Language\n+\n+### W3C Software Notice and License\n+<pre>\n+W3C(R) SOFTWARE NOTICE AND LICENSE\n+\n+Copyright (c) 1994-2002 World Wide Web Consortium, (Massachusetts\n+Institute of Technology, Institut National de Recherche en\n+Informatique et en Automatique, Keio University). All Rights\n+Reserved. http:\/\/www.w3.org\/Consortium\/Legal\/\n+\n+This W3C work (including software, documents, or other related items)\n+is being provided by the copyright holders under the following\n+license. By obtaining, using and\/or copying this work, you (the\n+licensee) agree that you have read, understood, and will comply with\n+the following terms and conditions:\n+\n+Permission to use, copy, modify, and distribute this software and its\n+documentation, with or without modification, for any purpose and\n+without fee or royalty is hereby granted, provided that you include\n+the following on ALL copies of the software and documentation or\n+portions thereof, including modifications, that you make:\n+\n+    The full text of this NOTICE in a location viewable to users of\n+    the redistributed or derivative work.\n+\n+    Any pre-existing intellectual property disclaimers, notices, or\n+    terms and conditions. If none exist, a short notice of the following\n+    form (hypertext is preferred, text is permitted) should be used within\n+    the body of any redistributed or derivative code: \"Copyright (C)\n+    [$date-of-software] World Wide Web Consortium, (Massachusetts\n+    Institute of Technology, Institut National de Recherche en\n+    Informatique et en Automatique, Keio University). All Rights\n+    Reserved. http:\/\/www.w3.org\/Consortium\/Legal\/\"\n+\n+    Notice of any changes or modifications to the W3C files, including\n+    the date changes were made. (We recommend you provide URIs to the\n+    location from which the code is derived.)\n+\n+THIS SOFTWARE AND DOCUMENTATION IS PROVIDED \"AS IS,\" AND COPYRIGHT\n+HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED,\n+INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS\n+FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR\n+DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,\n+TRADEMARKS OR OTHER RIGHTS.\n+\n+COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL\n+OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR\n+DOCUMENTATION.\n+\n+The name and trademarks of copyright holders may NOT be used in\n+advertising or publicity pertaining to the software without specific,\n+written prior permission. Title to copyright in this software and any\n+associated documentation will at all times remain with copyright\n+holders.\n+\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/xhtml10.md","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+## XHTML 1.0 in XML Schema\n+\n+### W3C Intellectual Rights Notice and Legal Disclaimers\n+<pre>\n+Copyright  1994-2002 W3C  (Massachusetts Institute of Technology,\n+Institut National de Recherche en Informatique et en Automatique, Keio University),\n+All Rights Reserved.\n+\n+World Wide Web Consortium (W3C) web site pages may contain other proprietary\n+notices and copyright information, the terms of which must be observed and\n+followed. Specific notices do exist for W3C documents and software. Also, there\n+are specific usage policies associated with some of the W3C Icons. Please see\n+our Intellectual Rights FAQ for common questions about using materials from our site.\n+\n+Notice and Disclaimers\n+\n+1. Unless otherwise noted, all materials contained in this Site are copyrighted\n+and may not be used except as provided in these terms and conditions or in the\n+copyright notice (documents and software) or other proprietary notice provided\n+with the relevant materials.\n+\n+2. The materials contained in the Site may be downloaded or copied provided that\n+ALL copies retain the copyright and any other proprietary notices contained on\n+the materials. No material may be modified, edited or taken out of context such\n+that its use creates a false or misleading statement or impression as to the\n+positions, statements or actions of W3C.\n+\n+3. The name and trademarks of copyright holders may NOT be used in advertising\n+or publicity pertaining to the Web site, its content, specifications, or\n+software without specific, written prior permission. Title to copyright in\n+Web site documents will at all times remain with copyright holders. Use of W3C\n+trademarks and service marks is covered by the W3C Trademark and Servicemark\n+License.\n+\n+4. Caches of W3C materials should comply with the \"maximum time to live\"\n+information provided with the materials. After such materials have expired\n+they should not be served from caches without first validating the contents\n+of the W3C Site. Organizations that want to mirror W3C content must abide by\n+the W3C Mirroring Policy.\n+\n+W3CTrademarks and Generic Terms\n+Trademarks owned by W3C host institutions on behalf of W3C and generic terms\n+used by the W3C\n+\n+5. The trademarks, logos, and service marks (collectively the \"Trademarks\")\n+displayed on the Site are registered and unregistered Trademarks of the\n+Massachusetts Institute of Technology (MIT), Institut National de Recherche\n+en Informatique et en Automatique (INRIA), or Keio University (Keio). All use\n+of the W3C Trademarks is governed by the W3C Trademark and Servicemark License.\n+No additional rights are granted by implication, estoppel, or otherwise. Terms\n+which claimed as generic are not governed by any W3C license and are used as\n+common descriptors by the W3C.\n+\n+The following is a list of W3C terms claimed as a trademark or generic term\n+by MIT, INRIA, and\/or Keio on behalf of the W3C:\n+\n+    W3C, World Wide Web Consortium  (registered in numerous countries)\n+    Amaya, a Web Browser\n+    CSS, Cascading Style Sheets Specification\n+    DOM, Document Object Model\n+    HTML (generic), HyperText Markup Language\n+    HTTP (generic), Hypertext Transfer Protocol\n+    MathML, Mathematical Markup Language\n+    Metadata (generic)\n+    P3P, Platform for Privacy Preferences Project\n+    PICS, Platform for Internet Content Selection\n+    RDF (generic), Resource Description Framework\n+    SMIL, Synchronized Multimedia Integration Language\n+    SVG, Scalable Vector Graphics\n+    WAI, Web Accessibility Initiative\n+    XENC (generic), XML Encryption\n+    XHTML, The Extensible HyperText Markup Language\n+    XML (generic), Extensible Markup Language\n+    XSL,  Extensible Stylesheet Language\n+\n+    ACSS, Aural Cascading Style Sheets\n+    DSig, Digital Signature Initiative\n+    JEPI, Joint Electronic Payment Initiative\n+    Jigsaw\n+    PICSRules\n+    WebFonts\n+\n+The absence of a product or service name or logo from this list does not\n+constitute a waiver of MIT's, INRIA's, or Keio's trademark or other intellectual\n+rights concerning that name or logo.\n+\n+Any questions concerning the use, status, or standing of W3C trademarks should\n+be directed to: site-policy@w3.org or to W3C (c\/o Joseph Reagle), Laboratory\n+for Computer Science NE43-358, Massachusetts Institute of Technology, 200\n+Technology Square, Cambridge, MA 02139.\n+\n+Non-W3C Trademarks; Member Trademarks\n+\n+The trademarks, logos, and service marks not owned on behalf of the W3C and\n+that are displayed on the Site are the registered and unregistered marks of\n+their respective owners. No rights are granted by the W3C to use such marks,\n+whether by implication, estoppel, or otherwise.\n+\n+\"METADATA\" is a trademark of the Metadata Company. W3C uses the term \"metadata\"\n+in a descriptive sense, meaning \"data about data\". W3C is not in any way\n+affiliated with the Metadata Company.\n+Legal Disclaimers\n+\n+6. W3C has not reviewed any or all of the web sites linked to this Site and is\n+not responsible for the content of any off-site pages or any other web sites\n+linked to this Site. Please understand that any non-W3C web site is independent\n+from W3C, and W3C has no control over the content on that web site.\n+In addition, a link to a non-W3C web site does not mean that W3C endorses or\n+accepts any responsibility for the content, or the use, of such site. It is\n+the user's responsibility to take precautions to ensure that whatever is\n+selected is free of such items as viruses, worms, Trojan horses and other\n+items of a destructive nature.\n+\n+7. Information W3C publishes on its Site may contain references or cross\n+references to W3C specifications, projects, programs and services that are\n+not announced or available in your country. Such references do not imply that\n+W3C intends to announce such specifications, projects, programs or services\n+in your country.\n+\n+8. Information on this Site may contain technical inaccuracies or typographical\n+errors. Information may be changed or updated without notice. W3C may make\n+improvements and\/or changes in the materials contained in or described on this\n+site at any time without notice. W3C may also make changes in these Terms and\n+Conditions without notice. User is bound by such revisions and should therefore\n+periodically visit this page to review the then current Terms and Conditions.\n+\n+9. Limitation on Warranties.\n+\n+ALL MATERIALS ON THE W3C SITE ARE PROVIDED \"AS IS.\" W3C, MIT, INRIA, AND KEIO\n+MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT\n+LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n+TITLE OR NON-INFRINGEMENT. AS TO DOCUMENTS AND GRAPHICS PUBLISHED ON THIS SITE,\n+W3C, MIT, INRIA, AND KEIO MAKE NO REPRESENTATION OR WARRANTY THAT THE CONTENTS\n+OF SUCH DOCUMENT OR GRAPHICS ARE FREE FROM ERROR OR SUITABLE FOR ANY PURPOSE;\n+NOR THAT IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY\n+PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.\n+\n+Please note that some jurisdictions may not allow the exclusion of implied\n+ warranties, so some of the above exclusions may not apply to you.\n+\n+10. Limitation on Liability.\n+\n+IN NO EVENT WILL W3C, MIT, INRIA, AND KEIO BE LIABLE TO ANY PARTY FOR ANY\n+DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES FOR ANY USE OF THIS SITE,\n+OR ON ANY OTHER HYPERLINKED WEB SITE, INCLUDING, WITHOUT LIMITATION, ANY LOST\n+PROFITS, BUSINESS INTERRUPTION, LOSS OF PROGRAMS OR OTHER DATA ON YOUR\n+INFORMATION HANDLING SYSTEM OR OTHERWISE, EVEN IF W3C, MIT, INRIA, OR KEIO\n+IS EXPRESSLY ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n+\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/xhtml10schema.md","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+## XHTML 1.1 - Module-based XHTML - Second Edition\n+\n+### W3C Document license\n+<pre>\n+From: https:\/\/www.w3.org\/copyright\/document-license-2023\n+\n+Copied 10\/15\/2024\n+\n+License\n+\n+By using and\/or copying this document, or the W3C document from which this\n+statement is linked, you (the licensee) agree that you have read, understood,\n+and will comply with the following terms and conditions:\n+\n+Permission to copy, and distribute the contents of this document, or the W3C\n+document from which this statement is linked, in any medium for any purpose\n+and without fee or royalty is hereby granted, provided that you include the\n+following on ALL copies of the document, or portions thereof, that you use:\n+\n+    A link or URL to the original W3C document.\n+    The pre-existing copyright notice of the original author, or if it doesn't\n+    exist, a notice (hypertext is preferred, but a textual representation is\n+    permitted) of the form: \"Copyright  [$date-of-document] World Wide Web\n+    Consortium. https:\/\/www.w3.org\/copyright\/document-license-2023\/\"\n+    If it exists, the STATUS of the W3C document.\n+\n+When space permits, inclusion of the full text of this NOTICE should be provided.\n+We request that authorship attribution be provided in any software, documents,\n+or other items or products that you create pursuant to the implementation of the\n+contents of this document, or any portion thereof.\n+\n+No right to create modifications or derivatives of W3C documents is granted\n+pursuant to this license, except as follows: To facilitate implementation of\n+the technical specifications set forth in this document, anyone may prepare\n+and distribute derivative works and portions of this document in software,\n+in supporting materials accompanying software, and in documentation of software,\n+PROVIDED that all such works include the notice below. HOWEVER, the publication\n+of derivative works of this document for use as a technical specification is\n+expressly prohibited.\n+\n+In addition, \"Code Components\" Web IDL in sections clearly marked as Web IDL;\n+and W3C-defined markup (HTML, CSS, etc.) and computer programming language code\n+clearly marked as code examples are licensed under the W3C Software License.\n+\n+The notice is:\n+\n+\"Copyright  2023 W3C. This software or document includes material copied from\n+or derived from [title and URI of the W3C document].\"\n+\n+Disclaimers anchor\n+\n+THIS DOCUMENT IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS\n+OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE;\n+THAT THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE; NOR THAT THE\n+IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS,\n+COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.\n+\n+COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR\n+CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT OR THE PERFORMANCE\n+OR IMPLEMENTATION OF THE CONTENTS THEREOF.\n+\n+The name and trademarks of copyright holders may NOT be used in advertising or\n+publicity pertaining to this document or its contents without specific, written\n+prior permission. Title to copyright in this document will at all times remain\n+with copyright holders.\n+\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/xhtml11.md","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+## XHTML 1.1 XML Schema Definition\n+\n+### W3C SOFTWARE NOTICE AND LICENSE\n+<pre>\n+http:\/\/www.w3.org\/Consortium\/Legal\/copyright-software-19980720\n+\n+W3C SOFTWARE NOTICE AND LICENSE\n+\n+Copyright  1994-2002 World Wide Web Consortium, (Massachusetts Institute of\n+Technology, Institut National de Recherche en Informatique et en Automatique,\n+Keio University). All Rights Reserved. http:\/\/www.w3.org\/Consortium\/Legal\/\n+\n+This W3C work (including software, documents, or other related items) is\n+being provided by the copyright holders under the following license. By\n+obtaining, using and\/or copying this work, you (the licensee) agree that you\n+have read, understood, and will comply with the following terms and conditions:\n+Permission to use, copy, modify, and distribute this software and its\n+documentation, with or without modification,  for any purpose and without fee\n+or royalty is hereby granted, provided that you include the following on ALL\n+copies of the software and documentation or portions thereof, including\n+modifications, that you make:\n+\n+1.      The full text of this NOTICE in a location viewable to users of the\n+redistributed or derivative work.\n+\n+2.      Any pre-existing intellectual property disclaimers, notices, or terms\n+and conditions. If none exist, a short notice of the following form (hypertext\n+is preferred, text is permitted) should be used within the body of any\n+redistributed or derivative code: \"Copyright  [$date-of-software] World Wide\n+Web Consortium, (Massachusetts Institute of Technology, Institut National de\n+Recherche en Informatique et en Automatique, Keio University). All Rights\n+Reserved. http:\/\/www.w3.org\/Consortium\/Legal\/\"\n+\n+3.      Notice of any changes or modifications to the W3C files, including the\n+date changes were made. (We recommend you provide URIs to the location from\n+which the code is derived.)\n+\n+THIS SOFTWARE AND DOCUMENTATION IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE\n+NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT\n+THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY\n+PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.\n+COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR\n+CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENTATION.\n+\n+The name and trademarks of copyright holders may NOT be used in advertising or\n+publicity pertaining to the software without specific, written prior permission.\n+Title to copyright in this software and any associated documentation will at all\n+times remain with copyright holders.\n+\n+The formulation of W3C's notice and license became active on August 14 1998 so\n+as to improve compatibility with GPL. This version ensures that W3C software\n+licensing terms are no more restrictive than GPL and consequently W3C software\n+may be distributed in GPL packages. See the older formulation for the policy\n+prior to this date. Please see our Copyright FAQ for common questions about\n+using materials from our site, including specific terms and conditions for\n+packages like libwww, Amaya, and Jigsaw. Other questions about this notice can\n+be directed to site-policy@w3.org.\n+\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/xhtml11schema.md","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+## XML DTD for W3C specifications\n+\n+### W3C Software Notice and License\n+<pre>\n+W3C(R) SOFTWARE NOTICE AND LICENSE\n+\n+Copyright (c) 1994-2002 World Wide Web Consortium, (Massachusetts\n+Institute of Technology, Institut National de Recherche en\n+Informatique et en Automatique, Keio University). All Rights\n+Reserved. http:\/\/www.w3.org\/Consortium\/Legal\/\n+\n+This W3C work (including software, documents, or other related items)\n+is being provided by the copyright holders under the following\n+license. By obtaining, using and\/or copying this work, you (the\n+licensee) agree that you have read, understood, and will comply with\n+the following terms and conditions:\n+\n+Permission to use, copy, modify, and distribute this software and its\n+documentation, with or without modification, for any purpose and\n+without fee or royalty is hereby granted, provided that you include\n+the following on ALL copies of the software and documentation or\n+portions thereof, including modifications, that you make:\n+\n+    The full text of this NOTICE in a location viewable to users of\n+    the redistributed or derivative work.\n+\n+    Any pre-existing intellectual property disclaimers, notices, or\n+    terms and conditions. If none exist, a short notice of the following\n+    form (hypertext is preferred, text is permitted) should be used within\n+    the body of any redistributed or derivative code: \"Copyright (C)\n+    [$date-of-software] World Wide Web Consortium, (Massachusetts\n+    Institute of Technology, Institut National de Recherche en\n+    Informatique et en Automatique, Keio University). All Rights\n+    Reserved. http:\/\/www.w3.org\/Consortium\/Legal\/\"\n+\n+    Notice of any changes or modifications to the W3C files, including\n+    the date changes were made. (We recommend you provide URIs to the\n+    location from which the code is derived.)\n+\n+THIS SOFTWARE AND DOCUMENTATION IS PROVIDED \"AS IS,\" AND COPYRIGHT\n+HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED,\n+INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS\n+FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR\n+DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,\n+TRADEMARKS OR OTHER RIGHTS.\n+\n+COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL\n+OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR\n+DOCUMENTATION.\n+\n+The name and trademarks of copyright holders may NOT be used in\n+advertising or publicity pertaining to the software without specific,\n+written prior permission. Title to copyright in this software and any\n+associated documentation will at all times remain with copyright\n+holders.\n+\n+----------\n+\n+COPYRIGHT:\n+\n+  Copyright (C) 2000, 2001, 2002, 2003 Sun Microsystems, Inc. All Rights Reserved.\n+\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/xmlspec.md","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+## The \"xml:\" Namespace\n+\n+### W3C Software and Document license\n+<pre>\n+From: https:\/\/www.w3.org\/copyright\/software-license-2023\/\n+Copied on 2024\/10\/15\n+\n+License\n+\n+By obtaining and\/or copying this work, you (the licensee) agree that you have\n+read, understood, and will comply with the following terms and conditions.\n+\n+Permission to copy, modify, and distribute this work, with or without modification,\n+for any purpose and without fee or royalty is hereby granted, provided that you\n+include the following on ALL copies of the work or portions thereof, including\n+modifications:\n+\n+    The full text of this NOTICE in a location viewable to users of the\n+    redistributed or derivative work.\n+    Any pre-existing intellectual property disclaimers, notices, or terms and\n+    conditions. If none exist, the W3C software and document short notice should\n+    be included.\n+    Notice of any changes or modifications, through a copyright statement on the\n+    new code or document such as \"This software or document includes material\n+    copied from or derived from [title and URI of the W3C document]. Copyright \n+    [$year-of-document] World Wide Web Consortium.\n+    https:\/\/www.w3.org\/copyright\/software-license-2023\/\"\n+\n+Disclaimers anchor\n+\n+THIS WORK IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR\n+WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF\n+MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE\n+SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,\n+TRADEMARKS OR OTHER RIGHTS.\n+\n+COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR\n+CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.\n+\n+The name and trademarks of copyright holders may NOT be used in advertising or\n+publicity pertaining to the work without specific, written prior permission.\n+Title to copyright in this work will at all times remain with copyright holders.\n+<\/pre>\n","filename":"src\/java.xml\/share\/legal\/xmlxsd.md","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -4731,1 +4731,1 @@\n-                chk.checkPreview(tree.pos(), env.info.scope.owner, sym);\n+                chk.checkPreview(tree.pos(), env.info.scope.owner, site, sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1848,1 +1848,2 @@\n-            checkPreview(tree.pos(), m, other);\n+            checkPreview(TreeInfo.diagnosticPositionFor(m, tree),\n+                         m, origin.type, other);\n@@ -1928,1 +1929,2 @@\n-                (other.flags() & PREVIEW_API) == 0) {\n+                ((other.flags() & PREVIEW_API) == 0 &&\n+                 (other.owner.flags() & PREVIEW_API) == 0)) {\n@@ -3831,2 +3833,23 @@\n-        if ((s.flags() & PREVIEW_API) != 0 && !preview.participatesInPreview(syms, other, s) && !disablePreviewCheck) {\n-            if ((s.flags() & PREVIEW_REFLECTIVE) == 0) {\n+        checkPreview(pos, other, Type.noType, s);\n+    }\n+\n+    void checkPreview(DiagnosticPosition pos, Symbol other, Type site, Symbol s) {\n+        boolean sIsPreview;\n+        Symbol previewSymbol;\n+        if ((s.flags() & PREVIEW_API) != 0) {\n+            sIsPreview = true;\n+            previewSymbol=  s;\n+        } else if ((s.kind == Kind.MTH || s.kind == Kind.VAR) &&\n+                   site.tsym != null &&\n+                   (site.tsym.flags() & PREVIEW_API) == 0 &&\n+                   (s.owner.flags() & PREVIEW_API) != 0) {\n+            \/\/calling a method, or using a field, whose owner is a preview, but\n+            \/\/using a site that is not a preview. Also produce an error or warning:\n+            sIsPreview = true;\n+            previewSymbol = s.owner;\n+        } else {\n+            sIsPreview = false;\n+            previewSymbol = null;\n+        }\n+        if (sIsPreview && !preview.participatesInPreview(syms, other, s) && !disablePreviewCheck) {\n+            if ((previewSymbol.flags() & PREVIEW_REFLECTIVE) == 0) {\n@@ -4086,0 +4109,23 @@\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            final boolean constructorPrev = constructor;\n+            final boolean firstStatementPrev = firstStatement;\n+            final JCReturn earlyReturnPrev = earlyReturn;\n+            final Name initCallPrev = initCall;\n+            final int scanDepthPrev = scanDepth;\n+            constructor = false;\n+            firstStatement = false;\n+            earlyReturn = null;\n+            initCall = null;\n+            scanDepth = 0;\n+            try {\n+                super.visitLambda(tree);\n+            } finally {\n+                constructor = constructorPrev;\n+                firstStatement = firstStatementPrev;\n+                earlyReturn = earlyReturnPrev;\n+                initCall = initCallPrev;\n+                scanDepth = scanDepthPrev;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":50,"deletions":4,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-import java.util.EnumSet;\n@@ -64,1 +63,0 @@\n-import java.util.stream.Collectors;\n@@ -330,1 +328,1 @@\n-                } catch (ProviderNotFoundException | SecurityException ex) {\n+                } catch (ProviderNotFoundException ex) {\n@@ -559,1 +557,1 @@\n-        public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {\n+        public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1763,7 +1763,1 @@\n-        long mod = 0;\n-        try {\n-            mod = filename.getLastModified();\n-        } catch (SecurityException e) {\n-            throw new AssertionError(\"CRT: couldn't get source file modification date: \" + e.getMessage());\n-        }\n-        return mod;\n+        return filename.getLastModified();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.List;\n@@ -77,1 +76,0 @@\n-                    .checkSecurityManager()\n@@ -111,13 +109,0 @@\n-    \/**\n-     * Checks if a security manager is present and throws an exception if so.\n-     * @return this object\n-     * @throws Fault if a security manager is present\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private SourceLauncher checkSecurityManager() throws Fault {\n-        if (System.getSecurityManager() != null) {\n-            throw new Fault(Errors.SecurityManager);\n-        }\n-        return this;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCInstanceOf;\n@@ -1553,0 +1554,7 @@\n+            public void visitTypeTest(JCInstanceOf tree) {\n+                if (tree.pattern.type.isPrimitive()) {\n+                    hasPatterns = true;\n+                }\n+                super.visitTypeTest(tree);\n+            }\n+            @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3431,1 +3431,1 @@\n-                    if (typeDepth == 0) {\n+                    if (typeDepth == 0 && !peekToken(lookahead, DOT)) {\n@@ -4211,1 +4211,1 @@\n-                            if (token.name() == names.transitive && !isTransitive) {\n+                            if (token.name() == names.transitive) {\n@@ -4216,0 +4216,3 @@\n+                                if (isTransitive) {\n+                                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);\n+                                }\n@@ -4218,3 +4221,0 @@\n-                            } else if (token.name() == names.transitive && isTransitive) {\n-                                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);\n-                                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.file.Path;\n@@ -65,1 +62,0 @@\n-import com.sun.tools.javac.file.JavacFileManager;\n@@ -170,1 +166,0 @@\n-    private SecurityException processorLoaderException;\n@@ -271,12 +266,11 @@\n-        try {\n-            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                try {\n-                    serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n-                } catch (IOException e) {\n-                    throw new Abort(e);\n-                }\n-            } else {\n-                \/\/ If processorpath is not explicitly set, use the classpath.\n-                processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n-                    ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n-                    : fileManager.getClassLoader(CLASS_PATH);\n+        if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+            try {\n+                serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n+            } catch (IOException e) {\n+                throw new Abort(e);\n+            }\n+        } else {\n+            \/\/ If processorpath is not explicitly set, use the classpath.\n+            processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n+                ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n+                : fileManager.getClassLoader(CLASS_PATH);\n@@ -284,2 +278,2 @@\n-                if (options.isSet(\"accessInternalAPI\"))\n-                    ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n+            if (options.isSet(\"accessInternalAPI\"))\n+                ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n@@ -287,3 +281,2 @@\n-                if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n-                    compiler.closeables = compiler.closeables.prepend(closeable);\n-                }\n+            if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n+                compiler.closeables = compiler.closeables.prepend(closeable);\n@@ -291,2 +284,0 @@\n-        } catch (SecurityException e) {\n-            processorLoaderException = e;\n@@ -308,20 +299,16 @@\n-            if (processorLoaderException == null) {\n-                \/*\n-                 * If the \"-processor\" option is used, search the appropriate\n-                 * path for the named class.  Otherwise, use a service\n-                 * provider mechanism to create the processor iterator.\n-                 *\n-                 * Note: if an explicit processor path is not set,\n-                 * only the class path and _not_ the module path are\n-                 * searched for processors.\n-                 *\/\n-                String processorNames = options.get(Option.PROCESSOR);\n-                if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                    processorIterator = (processorNames == null) ?\n-                            new ServiceIterator(serviceLoader, log) :\n-                            new NameServiceIterator(serviceLoader, log, processorNames);\n-                } else if (processorNames != null) {\n-                    processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n-                } else {\n-                    processorIterator = new ServiceIterator(processorClassLoader, log);\n-                }\n+            \/*\n+             * If the \"-processor\" option is used, search the appropriate\n+             * path for the named class.  Otherwise, use a service\n+             * provider mechanism to create the processor iterator.\n+             *\n+             * Note: if an explicit processor path is not set,\n+             * only the class path and _not_ the module path are\n+             * searched for processors.\n+             *\/\n+            String processorNames = options.get(Option.PROCESSOR);\n+            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+                processorIterator = (processorNames == null) ?\n+                        new ServiceIterator(serviceLoader, log) :\n+                        new NameServiceIterator(serviceLoader, log, processorNames);\n+            } else if (processorNames != null) {\n+                processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n@@ -329,8 +316,1 @@\n-                \/*\n-                 * A security exception will occur if we can't create a classloader.\n-                 * Ignore the exception if, with hindsight, we didn't need it anyway\n-                 * (i.e. no processor was specified either explicitly, or implicitly,\n-                 * in service configuration file.) Otherwise, we cannot continue.\n-                 *\/\n-                processorIterator = handleServiceLoaderUnavailability(\"proc.cant.create.loader\",\n-                        processorLoaderException);\n+                processorIterator = new ServiceIterator(processorClassLoader, log);\n@@ -366,41 +346,0 @@\n-    \/**\n-     * Returns an empty processor iterator if no processors are on the\n-     * relevant path, otherwise if processors are present, logs an\n-     * error.  Called when a service loader is unavailable for some\n-     * reason, either because a service loader class cannot be found\n-     * or because a security policy prevents class loaders from being\n-     * created.\n-     *\n-     * @param key The resource key to use to log an error message\n-     * @param e   If non-null, pass this exception to Abort\n-     *\/\n-    private Iterator<Processor> handleServiceLoaderUnavailability(String key, Exception e) {\n-        if (fileManager instanceof JavacFileManager standardFileManager) {\n-            Iterable<? extends Path> workingPath = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n-                ? standardFileManager.getLocationAsPaths(ANNOTATION_PROCESSOR_PATH)\n-                : standardFileManager.getLocationAsPaths(CLASS_PATH);\n-\n-            if (needClassLoader(options.get(Option.PROCESSOR), workingPath) )\n-                handleException(key, e);\n-\n-        } else {\n-            handleException(key, e);\n-        }\n-\n-        return Collections.emptyIterator();\n-    }\n-\n-    \/**\n-     * Handle a security exception thrown during initializing the\n-     * Processor iterator.\n-     *\/\n-    private void handleException(String key, Exception e) {\n-        if (e != null) {\n-            log.error(key, e.getLocalizedMessage());\n-            throw new Abort(e);\n-        } else {\n-            log.error(key);\n-            throw new Abort();\n-        }\n-    }\n-\n@@ -420,7 +359,2 @@\n-                try {\n-                    loader = ServiceLoader.load(Processor.class, classLoader);\n-                    this.iterator = loader.iterator();\n-                } catch (Exception e) {\n-                    \/\/ Fail softly if a loader is not actually needed.\n-                    this.iterator = handleServiceLoaderUnavailability(\"proc.no.service\", null);\n-                }\n+                loader = ServiceLoader.load(Processor.class, classLoader);\n+                this.iterator = loader.iterator();\n@@ -1551,26 +1485,0 @@\n-    \/*\n-     * Called retroactively to determine if a class loader was required,\n-     * after we have failed to create one.\n-     *\/\n-    private boolean needClassLoader(String procNames, Iterable<? extends Path> workingpath) {\n-        if (procNames != null)\n-            return true;\n-\n-        URL[] urls = new URL[1];\n-        for(Path pathElement : workingpath) {\n-            try {\n-                urls[0] = pathElement.toUri().toURL();\n-                if (ServiceProxy.hasService(Processor.class, urls))\n-                    return true;\n-            } catch (MalformedURLException ex) {\n-                throw new AssertionError(ex);\n-            }\n-            catch (ServiceProxy.ServiceConfigurationError e) {\n-                log.error(Errors.ProcBadConfigFile(e.getLocalizedMessage()));\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":35,"deletions":127,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.processing;\n-\n-import java.io.BufferedReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-\/**\n- * Utility class to determine if a service can be found on the\n- * path that might be used to create a class loader.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\n- *\/\n-\/\/ based on sun.misc.Service\n-class ServiceProxy {\n-    static class ServiceConfigurationError extends Error {\n-        static final long serialVersionUID = 7732091036771098303L;\n-\n-        ServiceConfigurationError(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    private static final String prefix = \"META-INF\/services\/\";\n-\n-    private static void fail(Class<?> service, String msg)\n-            throws ServiceConfigurationError {\n-        throw new ServiceConfigurationError(service.getName() + \": \" + msg);\n-    }\n-\n-    private static void fail(Class<?> service, URL u, int line, String msg)\n-            throws ServiceConfigurationError {\n-        fail(service, u + \":\" + line + \": \" + msg);\n-    }\n-\n-    \/**\n-     * Parse the content of the given URL as a provider-configuration file.\n-     *\n-     * @param  service\n-     *         The service class for which providers are being sought;\n-     *         used to construct error detail strings\n-     *\n-     * @param  u\n-     *         The URL naming the configuration file to be parsed\n-     *\n-     * @return true if the name of a service is found\n-     *\n-     * @throws ServiceConfigurationError\n-     *         If an I\/O error occurs while reading from the given URL, or\n-     *         if a configuration-file format error is detected\n-     *\/\n-    private static boolean parse(Class<?> service, URL u) throws ServiceConfigurationError {\n-        InputStream in = null;\n-        BufferedReader r = null;\n-        try {\n-            in = u.openStream();\n-            r = new BufferedReader(new InputStreamReader(in, UTF_8));\n-            int lc = 1;\n-            String ln;\n-            while ((ln = r.readLine()) != null) {\n-                int ci = ln.indexOf('#');\n-                if (ci >= 0) ln = ln.substring(0, ci);\n-                ln = ln.trim();\n-                int n = ln.length();\n-                if (n != 0) {\n-                    if ((ln.indexOf(' ') >= 0) || (ln.indexOf('\\t') >= 0))\n-                        fail(service, u, lc, \"Illegal configuration-file syntax\");\n-                    int cp = ln.codePointAt(0);\n-                    if (!Character.isJavaIdentifierStart(cp))\n-                        fail(service, u, lc, \"Illegal provider-class name: \" + ln);\n-                    for (int i = Character.charCount(cp); i < n; i += Character.charCount(cp)) {\n-                        cp = ln.codePointAt(i);\n-                        if (!Character.isJavaIdentifierPart(cp) && (cp != '.'))\n-                            fail(service, u, lc, \"Illegal provider-class name: \" + ln);\n-                    }\n-                    return true;\n-                }\n-            }\n-        } catch (FileNotFoundException x) {\n-            return false;\n-        } catch (IOException x) {\n-            fail(service, \": \" + x);\n-        } finally {\n-            try {\n-                if (r != null) r.close();\n-            } catch (IOException y) {\n-                fail(service, \": \" + y);\n-            }\n-            try {\n-                if (in != null) in.close();\n-            } catch (IOException y) {\n-                fail(service, \": \" + y);\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Return true if a description for at least one service is found in the\n-     * service configuration files in the given URLs.\n-     *\/\n-    public static boolean hasService(Class<?> service, URL[] urls)\n-            throws ServiceConfigurationError {\n-        for (URL url: urls) {\n-            try {\n-                String fullName = prefix + service.getName();\n-                @SuppressWarnings(\"deprecation\")\n-                URL u = new URL(url, fullName);\n-                boolean found = parse(service, u);\n-                if (found)\n-                    return true;\n-            } catch (MalformedURLException e) {\n-                \/\/ should not happen; ignore it if it does\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/ServiceProxy.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1182,3 +1182,0 @@\n-compiler.err.proc.no.service=\\\n-    A ServiceLoader was not usable and is required for annotation processing.\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,3 +87,0 @@\n-launcher.err.security.manager=\\\n-    cannot use source-code launcher with a security manager enabled\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -447,1 +447,1 @@\n-                CERT_SYSTEM_STORE_LOCAL_MACHINE, pszCertStoreName);\n+                CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_MAXIMUM_ALLOWED_FLAG, pszCertStoreName);\n@@ -801,0 +801,5 @@\n+            DWORD keysetType = 0;\n+            DWORD keysetTypeLen = sizeof(keysetType);\n+            ::CryptGetProvParam((HCRYPTPROV)hCryptProv, PP_KEYSET_TYPE, \/\/deprecated\n+                (BYTE*)&keysetType, &keysetTypeLen, 0);\n+\n@@ -803,1 +808,1 @@\n-                PROV_RSA_AES, 0) == FALSE)\n+                PROV_RSA_AES, 0 | keysetType) == FALSE)\n@@ -805,1 +810,0 @@\n-\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.shenandoah;\n+\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ShenandoahGeneration extends VMObject {\n+    private static CIntegerField used;\n+    static {\n+        VM.registerVMInitializedObserver(new Observer() {\n+            public void update(Observable o, Object data) {\n+                initialize(VM.getVM().getTypeDataBase());\n+            }\n+        });\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ShenandoahGeneration\");\n+        used = type.getCIntegerField(\"_used\");\n+    }\n+\n+    public ShenandoahGeneration(Address addr) {\n+        super(addr);\n+    }\n+\n+    public long used() {\n+        return used.getValue(addr);\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahGeneration.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.shenandoah;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+\n+public class ShenandoahGenerationalHeap extends ShenandoahHeap {\n+    public ShenandoahGenerationalHeap(Address addr) {\n+        super(addr);\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahGenerationalHeap.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-    private static CIntegerField used;\n+    private static AddressField  globalGeneration;\n@@ -63,1 +63,1 @@\n-        used = type.getCIntegerField(\"_used\");\n+        globalGeneration = type.getAddressField(\"_global_generation\");\n@@ -92,1 +92,3 @@\n-        return used.getValue(addr);\n+        Address globalGenerationAddress = globalGeneration.getValue(addr);\n+        ShenandoahGeneration global = VMObjectFactory.newObject(ShenandoahGeneration.class, globalGenerationAddress);\n+        return global.used();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahHeap.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import sun.jvm.hotspot.gc.shenandoah.ShenandoahGenerationalHeap;\n@@ -91,0 +92,1 @@\n+    addHeapTypeIfInDB(db, ShenandoahGenerationalHeap.class);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/Universe.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  private static CIntegerField lockIdField;\n+  private static CIntegerField monitorOwnerIDField;\n@@ -105,1 +105,1 @@\n-    lockIdField        = type.getCIntegerField(\"_lock_id\");\n+    monitorOwnerIDField = type.getCIntegerField(\"_monitor_owner_id\");\n@@ -381,2 +381,2 @@\n-  public Address getLockId() {\n-    return lockIdField.getAddress(addr);\n+  public Address getMonitorOwnerID() {\n+    return monitorOwnerIDField.getAddress(addr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-            if (o.equals(thread.getLockId())) {\n+            if (o.equals(thread.getMonitorOwnerID())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,2 +236,5 @@\n-     * {@link Filter} modules may store arbitrary objects with {@code HttpExchange}\n-     * instances as an out-of-band communication mechanism. Other filters\n+     * Returns the attribute's value from this exchange's\n+     * {@linkplain HttpContext#getAttributes() context attributes}.\n+     *\n+     * @apiNote {@link Filter} modules may store arbitrary objects as attributes through\n+     * {@code HttpExchange} instances as an out-of-band communication mechanism. Other filters\n@@ -244,1 +247,2 @@\n-     * @return the attribute object, or {@code null} if it does not exist\n+     * @return the attribute's value or {@code null} if either the attribute isn't set\n+     *         or the attribute value is {@code null}\n@@ -250,2 +254,5 @@\n-     * {@link Filter} modules may store arbitrary objects with {@code HttpExchange}\n-     * instances as an out-of-band communication mechanism. Other filters\n+     * Sets an attribute with the given {@code name} and {@code value} in this exchange's\n+     * {@linkplain HttpContext#getAttributes() context attributes}.\n+     *\n+     * @apiNote {@link Filter} modules may store arbitrary objects as attributes through\n+     * {@code HttpExchange} instances as an out-of-band communication mechanism. Other filters\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpExchange.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -86,6 +84,1 @@\n-    protected HttpServerProvider() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null)\n-            sm.checkPermission(new RuntimePermission(\"httpServerProvider\"));\n-    }\n+    protected HttpServerProvider() {}\n@@ -110,2 +103,1 @@\n-                 InstantiationException |\n-                 SecurityException x) {\n+                 InstantiationException x) {\n@@ -121,14 +113,4 @@\n-        for (;;) {\n-            try {\n-                if (!i.hasNext())\n-                    return false;\n-                provider = i.next();\n-                return true;\n-            } catch (ServiceConfigurationError sce) {\n-                if (sce.getCause() instanceof SecurityException) {\n-                    \/\/ Ignore the security exception, try the next provider\n-                    continue;\n-                }\n-                throw sce;\n-            }\n-        }\n+        if (!i.hasNext())\n+            return false;\n+        provider = i.next();\n+        return true;\n@@ -173,1 +155,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -178,11 +159,6 @@\n-            return (HttpServerProvider)AccessController\n-                .doPrivileged(new PrivilegedAction<Object>() {\n-                        public Object run() {\n-                            if (loadProviderFromProperty())\n-                                return provider;\n-                            if (loadProviderAsService())\n-                                return provider;\n-                            provider = new sun.net.httpserver.DefaultHttpServerProvider();\n-                            return provider;\n-                        }\n-                    });\n+            if (loadProviderFromProperty())\n+                return provider;\n+            if (loadProviderAsService())\n+                return provider;\n+            provider = new sun.net.httpserver.DefaultHttpServerProvider();\n+            return provider;\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/spi\/HttpServerProvider.java","additions":12,"deletions":36,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,6 +30,0 @@\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.util.*;\n-import javax.security.auth.*;\n-import javax.security.auth.callback.*;\n-import javax.security.auth.login.*;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/AuthFilter.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,0 @@\n-import java.nio.*;\n-import java.security.*;\n-import java.nio.channels.*;\n-import java.util.*;\n@@ -35,1 +31,1 @@\n-import javax.net.ssl.*;\n+\n@@ -37,1 +33,0 @@\n-import com.sun.net.httpserver.spi.*;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/HttpServerImpl.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,0 @@\n-import java.nio.*;\n-import java.security.*;\n-import java.nio.channels.*;\n-import java.util.*;\n@@ -35,1 +31,1 @@\n-import javax.net.ssl.*;\n+\n@@ -37,1 +33,0 @@\n-import com.sun.net.httpserver.spi.*;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/HttpsServerImpl.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.PrivilegedAction;\n@@ -36,2 +35,0 @@\n-\n-@SuppressWarnings(\"removal\")\n@@ -55,2 +52,2 @@\n-    private static long idleTimerScheduleMillis;\n-    private static long idleIntervalMillis;\n+    private static final long idleTimerScheduleMillis;\n+    private static final long idleIntervalMillis;\n@@ -58,1 +55,1 @@\n-    private static long drainAmount;\n+    private static final long drainAmount;\n@@ -62,2 +59,2 @@\n-    private static int maxConnections;\n-    private static int maxIdleConnections;\n+    private static final int maxConnections;\n+    private static final int maxIdleConnections;\n@@ -65,1 +62,1 @@\n-    private static int maxReqHeaders;\n+    private static final int maxReqHeaders;\n@@ -68,1 +65,1 @@\n-    private static int maxReqHeadersSize;\n+    private static final int maxReqHeadersSize;\n@@ -70,4 +67,4 @@\n-    private static long maxReqTime;\n-    private static long maxRspTime;\n-    private static long reqRspTimerScheduleMillis;\n-    private static boolean debug;\n+    private static final long maxReqTime;\n+    private static final long maxRspTime;\n+    private static final long reqRspTimerScheduleMillis;\n+    private static final boolean debug;\n@@ -76,1 +73,1 @@\n-    private static boolean noDelay;\n+    private static final boolean noDelay;\n@@ -79,64 +76,43 @@\n-        java.security.AccessController.doPrivileged(\n-            new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run () {\n-                    idleIntervalMillis = Long.getLong(\"sun.net.httpserver.idleInterval\",\n-                            DEFAULT_IDLE_INTERVAL_IN_SECS) * 1000;\n-                    if (idleIntervalMillis <= 0) {\n-                        idleIntervalMillis = DEFAULT_IDLE_INTERVAL_IN_SECS * 1000;\n-                    }\n-\n-                    idleTimerScheduleMillis = Long.getLong(\"sun.net.httpserver.clockTick\",\n-                            DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS);\n-                    if (idleTimerScheduleMillis <= 0) {\n-                        \/\/ ignore zero or negative value and use the default schedule\n-                        idleTimerScheduleMillis = DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS;\n-                    }\n-\n-                    maxConnections = Integer.getInteger(\n-                            \"jdk.httpserver.maxConnections\",\n-                            DEFAULT_MAX_CONNECTIONS);\n-\n-                    maxIdleConnections = Integer.getInteger(\n-                            \"sun.net.httpserver.maxIdleConnections\",\n-                            DEFAULT_MAX_IDLE_CONNECTIONS);\n-\n-                    drainAmount = Long.getLong(\"sun.net.httpserver.drainAmount\",\n-                            DEFAULT_DRAIN_AMOUNT);\n-\n-                    maxReqHeaders = Integer.getInteger(\n-                            \"sun.net.httpserver.maxReqHeaders\",\n-                            DEFAULT_MAX_REQ_HEADERS);\n-                    if (maxReqHeaders <= 0) {\n-                        maxReqHeaders = DEFAULT_MAX_REQ_HEADERS;\n-                    }\n-\n-                    \/\/ a value <= 0 means unlimited\n-                    maxReqHeadersSize = Integer.getInteger(\n-                            \"sun.net.httpserver.maxReqHeaderSize\",\n-                            DEFAULT_MAX_REQ_HEADER_SIZE);\n-                    if (maxReqHeadersSize <= 0) {\n-                        maxReqHeadersSize = 0;\n-                    }\n-\n-                    maxReqTime = Long.getLong(\"sun.net.httpserver.maxReqTime\",\n-                            DEFAULT_MAX_REQ_TIME);\n-\n-                    maxRspTime = Long.getLong(\"sun.net.httpserver.maxRspTime\",\n-                            DEFAULT_MAX_RSP_TIME);\n-\n-                    reqRspTimerScheduleMillis = Long.getLong(\"sun.net.httpserver.timerMillis\",\n-                            DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS);\n-                    if (reqRspTimerScheduleMillis <= 0) {\n-                        \/\/ ignore any negative or zero value for this configuration and reset\n-                        \/\/ to default schedule\n-                        reqRspTimerScheduleMillis = DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS;\n-                    }\n-\n-                    debug = Boolean.getBoolean(\"sun.net.httpserver.debug\");\n-\n-                    noDelay = Boolean.getBoolean(\"sun.net.httpserver.nodelay\");\n-\n-                    return null;\n-                }\n-            });\n+\n+        long providedIdleIntervalMillis =\n+                Long.getLong(\"sun.net.httpserver.idleInterval\", DEFAULT_IDLE_INTERVAL_IN_SECS) * 1000;\n+        idleIntervalMillis = providedIdleIntervalMillis > 0\n+                ? providedIdleIntervalMillis\n+                : Math.multiplyExact(DEFAULT_IDLE_INTERVAL_IN_SECS, 1000);\n+\n+        long providedIdleTimerScheduleMillis =\n+                Long.getLong(\"sun.net.httpserver.clockTick\", DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS);\n+        \/\/ Ignore zero or negative value and use the default schedule\n+        idleTimerScheduleMillis = providedIdleTimerScheduleMillis > 0\n+                ? providedIdleTimerScheduleMillis\n+                : DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS;\n+\n+        maxConnections = Integer.getInteger(\"jdk.httpserver.maxConnections\", DEFAULT_MAX_CONNECTIONS);\n+\n+        maxIdleConnections = Integer.getInteger(\"sun.net.httpserver.maxIdleConnections\", DEFAULT_MAX_IDLE_CONNECTIONS);\n+\n+        drainAmount = Long.getLong(\"sun.net.httpserver.drainAmount\", DEFAULT_DRAIN_AMOUNT);\n+\n+        int providedMaxReqHeaders = Integer.getInteger(\"sun.net.httpserver.maxReqHeaders\", DEFAULT_MAX_REQ_HEADERS);\n+        maxReqHeaders = providedMaxReqHeaders > 0 ? providedMaxReqHeaders : DEFAULT_MAX_REQ_HEADERS;\n+\n+        \/\/ A value <= 0 means unlimited\n+        maxReqHeadersSize = Math.max(\n+                Integer.getInteger(\"sun.net.httpserver.maxReqHeaderSize\", DEFAULT_MAX_REQ_HEADER_SIZE),\n+                0);\n+\n+        maxReqTime = Long.getLong(\"sun.net.httpserver.maxReqTime\", DEFAULT_MAX_REQ_TIME);\n+\n+        maxRspTime = Long.getLong(\"sun.net.httpserver.maxRspTime\", DEFAULT_MAX_RSP_TIME);\n+\n+        long providedReqRspTimerScheduleMillis = Long.getLong(\n+                \"sun.net.httpserver.timerMillis\",\n+                DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS);\n+        \/\/ Ignore any negative or zero value for this configuration and reset to default schedule\n+        reqRspTimerScheduleMillis = providedReqRspTimerScheduleMillis > 0\n+                ? providedReqRspTimerScheduleMillis\n+                : DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS;\n+\n+        debug = Boolean.getBoolean(\"sun.net.httpserver.debug\");\n+\n+        noDelay = Boolean.getBoolean(\"sun.net.httpserver.nodelay\");\n@@ -151,33 +127,16 @@\n-        java.security.AccessController.doPrivileged(\n-            new PrivilegedAction<Void>() {\n-                public Void run () {\n-                    if (System.getProperty(\"sun.net.httpserver.readTimeout\")\n-                                                !=null)\n-                    {\n-                        logger.log (Level.WARNING,\n-                            \"sun.net.httpserver.readTimeout \"+\n-                            \"property is no longer used. \"+\n-                            \"Use sun.net.httpserver.maxReqTime instead.\"\n-                        );\n-                    }\n-                    if (System.getProperty(\"sun.net.httpserver.writeTimeout\")\n-                                                !=null)\n-                    {\n-                        logger.log (Level.WARNING,\n-                            \"sun.net.httpserver.writeTimeout \"+\n-                            \"property is no longer used. Use \"+\n-                            \"sun.net.httpserver.maxRspTime instead.\"\n-                        );\n-                    }\n-                    if (System.getProperty(\"sun.net.httpserver.selCacheTimeout\")\n-                                                !=null)\n-                    {\n-                        logger.log (Level.WARNING,\n-                            \"sun.net.httpserver.selCacheTimeout \"+\n-                            \"property is no longer used.\"\n-                        );\n-                    }\n-                    return null;\n-                }\n-            }\n-        );\n+        if (System.getProperty(\"sun.net.httpserver.readTimeout\") != null) {\n+            logger.log(\n+                    Level.WARNING,\n+                    \"sun.net.httpserver.readTimeout property is no longer used. \" +\n+                            \"Use sun.net.httpserver.maxReqTime instead.\");\n+        }\n+        if (System.getProperty(\"sun.net.httpserver.writeTimeout\") != null) {\n+            logger.log(\n+                    Level.WARNING,\n+                    \"sun.net.httpserver.writeTimeout property is no longer used. \" +\n+                            \"Use sun.net.httpserver.maxRspTime instead.\");\n+        }\n+        if (System.getProperty(\"sun.net.httpserver.selCacheTimeout\") != null) {\n+            logger.log(Level.WARNING, \"sun.net.httpserver.selCacheTimeout property is no longer used.\");\n+        }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerConfig.java","additions":71,"deletions":112,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -307,1 +305,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -309,8 +306,1 @@\n-        return AccessController.doPrivileged(\n-                new PrivilegedAction<InetSocketAddress>() {\n-                    public InetSocketAddress run() {\n-                        return\n-                            (InetSocketAddress)schan.socket()\n-                                .getLocalSocketAddress();\n-                    }\n-                });\n+        return (InetSocketAddress) schan.socket().getLocalSocketAddress();\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -70,6 +69,0 @@\n-\n-        @SuppressWarnings(\"removal\")\n-        var securityManager = System.getSecurityManager();\n-        if (securityManager != null)\n-            securityManager.checkRead(pathForSecurityCheck(root.toString()));\n-\n@@ -89,5 +82,0 @@\n-    private static String pathForSecurityCheck(String path) {\n-        var separator = String.valueOf(File.separatorChar);\n-        return path.endsWith(separator) ? (path + \"-\") : (path + separator + \"-\");\n-    }\n-\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/FileServerHandler.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -87,1 +85,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -89,5 +86,1 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            if (System.getProperty(SYS_PROP_MAX_CONNECTIONS) != null) {\n-                \/\/ an explicit value has already been set, so we don't override it\n-                return null;\n-            }\n+        if (System.getProperty(SYS_PROP_MAX_CONNECTIONS) == null) {\n@@ -95,2 +88,1 @@\n-            return null;\n-        });\n+        }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/JWebServer.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -34,3 +32,2 @@\n-    @SuppressWarnings(\"removal\")\n-    static final int VECTOR_ACCESS_OOB_CHECK = AccessController.doPrivileged((PrivilegedAction<Integer>) () ->\n-            Integer.getInteger(\"jdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK\", 2));\n+    static final int VECTOR_ACCESS_OOB_CHECK =\n+            Integer.getInteger(\"jdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK\", 2);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.util.*;\n@@ -34,3 +33,0 @@\n-import java.nio.channels.FileChannel;\n-import java.lang.reflect.Constructor;\n-import java.security.AccessController;\n@@ -48,2 +44,0 @@\n-\/\/ Suppreess unchecked conversion warning at line 34.\n-\/\/@SuppressWarnings(\"unchecked\")\n@@ -51,2 +45,1 @@\n-    @SuppressWarnings(\"removal\")\n-    private static final Perf perf = AccessController.doPrivileged(new Perf.GetPerfAction());\n+    private static final Perf perf = Perf.getPerf();\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/PerfDataBuffer.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1525,0 +1525,6 @@\n+\n+    \/**\n+     * Returns the current {@code CompileBroker} compilation activity mode which is one of:\n+     * {@code stop_compilation = 0}, {@code run_compilation = 1} or {@code shutdown_compilation = 2}\n+     *\/\n+    native int getCompilationActivityMode();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1491,0 +1491,8 @@\n+\n+    \/**\n+     * Returns HotSpot's {@code CompileBroker} compilation activity mode which is one of:\n+     * {@code stop_compilation = 0}, {@code run_compilation = 1} or {@code shutdown_compilation = 2}\n+     *\/\n+    public int getCompilationActivityMode() {\n+        return compilerToVm.getCompilationActivityMode();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -283,3 +283,1 @@\n-            if (!options.noExternalSpecsPage()){\n-                writerFactory.newExternalSpecsWriter().buildPage();\n-            }\n+            writerFactory.newExternalSpecsWriter().buildPage();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,7 +147,0 @@\n-    \/**\n-     * Argument for command-line option {@code --no-external-spec-page}.\n-     * True if command-line option \"--no-external-spec-page\" is used. Default value is\n-     * false.\n-     *\/\n-    private boolean noExternalSpecsPage = false;\n-\n@@ -377,8 +370,0 @@\n-                new Hidden(resources, \"--no-external-specs-page\") {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        noExternalSpecsPage = true;\n-                        return true;\n-                    }\n-                },\n-\n@@ -752,9 +737,0 @@\n-    \/**\n-     * Argument for command-line option {@code --no-external-specs-page}.\n-     * True if command-line option \"--no-external-specs-page\" is used. Default value is\n-     * false.\n-     *\/\n-    public boolean noExternalSpecsPage() {\n-        return noExternalSpecsPage;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -740,0 +740,11 @@\n+`Thread.vthread_scheduler`\n+:   Print the virtual thread scheduler, and the delayed task schedulers that support\n+    virtual threads doing timed operations.\n+\n+    Impact: Low\n+\n+`Thread.vthread_pollers`\n+:   Print the I\/O pollers that support virtual threads doing blocking network I\/O operations.\n+\n+    Impact: Low\n+\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.md","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -228,0 +228,1 @@\n+        var tagChar = (char) value.tag();\n@@ -232,1 +233,1 @@\n-                    switch (ev.tag()) {\n+                    switch (tagChar) {\n@@ -261,1 +262,1 @@\n-                            print(ev.tag() + \"#\" + entry.index());\n+                            print(tagChar + \"#\" + entry.index());\n@@ -265,1 +266,1 @@\n-                    print(ev.tag() + \"#\" + ev.constant().index());\n+                    print(tagChar + \"#\" + ev.constant().index());\n@@ -274,1 +275,1 @@\n-                    print(ev.tag() + \"#\" + ev.className().index() + \".#\"\n+                    print(tagChar + \"#\" + ev.className().index() + \".#\"\n@@ -283,1 +284,1 @@\n-                    print(ev.tag() + \"#\" + ev.className().index());\n+                    print(tagChar + \"#\" + ev.className().index());\n@@ -287,1 +288,1 @@\n-                print(ev.tag());\n+                print(tagChar);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -577,4 +577,2 @@\n-        } else if (code != null) {\n-            if (options.showDisassembled || options.showLineAndLocalVariableTables) {\n-                codeWriter.writeMinimal(code);\n-            }\n+        } else if (code != null && options.showDisassembled) {\n+            codeWriter.writeMinimal(code);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -269,5 +269,2 @@\n-        if (options.showDisassembled) {\n-            writeInstrs(attr);\n-            writeExceptionTable(attr);\n-        }\n-\n+        writeInstrs(attr);\n+        writeExceptionTable(attr);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -552,0 +552,4 @@\n+        if (!options.showDisassembled && !options.verbose && options.showLineAndLocalVariableTables) {\n+            reportWarning(\"err.incompatible.options\", \"-l without -c, line number and local variable tables will not be printed\");\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-\\  -l                               Print line number and local variable tables\n+\\  -l                               Print line number and local variable tables, works in combination with -c\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/resources\/javap.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-    return findClass(env, \"Ljava\/lang\/Module;\");\n+    return findClass(env, \"java\/lang\/Module\");\n@@ -53,0 +53,5 @@\n+    if (JNI_FUNC_PTR(env,ExceptionCheck)(env)) {\n+        JNI_FUNC_PTR(env,ExceptionClear)(env); \/\/ keep -Xcheck:jni happy\n+        ERROR_MESSAGE((\"JNI Exception occurred calling Module.getName()\"));\n+        EXIT_ERROR(AGENT_ERROR_JNI_EXCEPTION, NULL);\n+    }\n@@ -81,0 +86,5 @@\n+    if (JNI_FUNC_PTR(env,ExceptionCheck)(env)) {\n+        JNI_FUNC_PTR(env,ExceptionClear)(env); \/\/ keep -Xcheck:jni happy\n+        ERROR_MESSAGE((\"JNI Exception occurred calling ClassLoader.getClassLoader()\"));\n+        EXIT_ERROR(AGENT_ERROR_JNI_EXCEPTION, NULL);\n+    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/ModuleReferenceImpl.c","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -684,11 +684,2 @@\n-    \/* Always restore any exception that was set beforehand.  If\n-     * there is a pending async exception, StopThread will be\n-     * called from threadControl_onEventHandlerExit immediately\n-     * below.  Depending on VM implementation and state, the async\n-     * exception might immediately overwrite the currentException,\n-     * or it might be delayed until later.  *\/\n-    if (currentException != NULL) {\n-        JNI_FUNC_PTR(env,Throw)(env, currentException);\n-    } else {\n-        JNI_FUNC_PTR(env,ExceptionClear)(env);\n-    }\n+    \/* Clear any exception thrown while handling the event. *\/\n+    JNI_FUNC_PTR(env,ExceptionClear)(env);\n@@ -700,1 +691,1 @@\n-        threadControl_onEventHandlerExit(evinfo->ei, thread, eventBag);\n+        threadControl_onEventHandlerExit(evinfo->ei, thread, eventBag, currentException);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -341,0 +341,16 @@\n+static void\n+saveGlobalRefHelper(JNIEnv *env, jobject obj, jobject *pobj)\n+{\n+    \/\/ In order to keep -Xcheck:jni happy, we have to clear any pending\n+    \/\/ exception before calling saveGlobalRef(). We also need to restore\n+    \/\/ it for the caller of this function.\n+    jthrowable exception = JNI_FUNC_PTR(env,ExceptionOccurred)(env);\n+    if (exception != NULL) {\n+        JNI_FUNC_PTR(env,ExceptionClear)(env);\n+    }\n+    saveGlobalRef(env, obj, pobj);\n+    if (exception != NULL) {\n+        JNI_FUNC_PTR(env,Throw)(env, exception);\n+    }\n+}\n+\n@@ -352,1 +368,1 @@\n-        saveGlobalRef(env, object, &(request->returnValue.l));\n+        saveGlobalRefHelper(env, object, &(request->returnValue.l));\n@@ -370,1 +386,1 @@\n-            saveGlobalRef(env, object, &(request->returnValue.l));\n+            saveGlobalRefHelper(env, object, &(request->returnValue.l));\n@@ -458,1 +474,1 @@\n-            saveGlobalRef(env, object, &(request->returnValue.l));\n+            saveGlobalRefHelper(env, object, &(request->returnValue.l));\n@@ -548,1 +564,1 @@\n-            saveGlobalRef(env, object, &(request->returnValue.l));\n+            saveGlobalRefHelper(env, object, &(request->returnValue.l));\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/invoker.c","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2144,1 +2144,1 @@\n-                                 struct bag *eventBag)\n+                                 struct bag *eventBag, jobject currentException)\n@@ -2181,0 +2181,11 @@\n+        if (currentException != NULL) {\n+            \/\/ We need to rethrow the exception that was current when we received the\n+            \/\/ JVMTI event. If there is a pending async exception, StopThread will be\n+            \/\/ called from doPendingTasks() immediately below. Depending on the VM\n+            \/\/ implementation and state, the async exception might immediately overwrite\n+            \/\/ the currentException, or it might be delayed until later.\n+            \/\/\n+            \/\/ Note in order the keep the JNI Checker happy, we had to delay doing this\n+            \/\/ until now. Otherwise there are complaints when JNI IsVirtualThread is called.\n+            JNI_FUNC_PTR(env,Throw)(env, currentException);\n+        }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,1 @@\n-void threadControl_onEventHandlerExit(EventIndex ei, jthread thread, struct bag *);\n-\n+void threadControl_onEventHandlerExit(EventIndex ei, jthread thread, struct bag *, jobject currentException);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.h","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -104,4 +104,0 @@\n-    if (x == NULL) {\n-        ERROR_MESSAGE((\"JDWP Can't find class %s\", name));\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);\n-    }\n@@ -109,2 +105,3 @@\n-        ERROR_MESSAGE((\"JDWP Exception occurred finding class %s\", name));\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);\n+        JNI_FUNC_PTR(env,ExceptionClear)(env); \/\/ keep -Xcheck:jni happy\n+        ERROR_MESSAGE((\"JNI Exception occurred finding class %s\", name));\n+        EXIT_ERROR(AGENT_ERROR_JNI_EXCEPTION,NULL);\n@@ -133,5 +130,0 @@\n-    if (method == NULL) {\n-        ERROR_MESSAGE((\"JDWP Can't find method %s with signature %s\",\n-                                name, signature));\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);\n-    }\n@@ -139,3 +131,4 @@\n-        ERROR_MESSAGE((\"JDWP Exception occurred finding method %s with signature %s\",\n-                                name, signature));\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);\n+        JNI_FUNC_PTR(env,ExceptionClear)(env); \/\/ keep -Xcheck:jni happy\n+        ERROR_MESSAGE((\"JNI Exception occurred finding method %s with signature %s\",\n+                       name, signature));\n+        EXIT_ERROR(AGENT_ERROR_JNI_EXCEPTION,NULL);\n@@ -164,5 +157,0 @@\n-    if (method == NULL) {\n-        ERROR_MESSAGE((\"JDWP Can't find method %s with signature %s\",\n-                                name, signature));\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);\n-    }\n@@ -170,0 +158,1 @@\n+        JNI_FUNC_PTR(env,ExceptionClear)(env); \/\/ keep -Xcheck:jni happy\n@@ -171,2 +160,2 @@\n-                                name, signature));\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);\n+                       name, signature));\n+        EXIT_ERROR(AGENT_ERROR_JNI_EXCEPTION,NULL);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+     * @since 11\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Recording.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -458,0 +458,21 @@\n+    \/**\n+     * Registers an action to perform when new metadata arrives in the stream.\n+     *\n+     * The event type of an event always arrives sometime before the actual event.\n+     * The action must be registered before the stream is started.\n+     * <p>\n+     * The following example shows how to listen to new event types, register\n+     * an action if the event type name matches a regular expression and increase a\n+     * counter if a matching event is found. A benefit of using an action per\n+     * event type, instead of the generic {@link #onEvent(Consumer)} method,\n+     * is that a stream implementation can avoid reading events that are of no\n+     * interest.\n+     *\n+     * {@snippet class = \"Snippets\" region = \"RecordingStreamMetadata\"}\n+     *\n+     * @param action to perform, not {@code null}\n+     *\n+     * @throws IllegalStateException if an action is added after the stream has\n+     *                               started\n+     * @since 16\n+     *\/\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,21 @@\n+    class RecordingStreamMetadata {\n+        \/\/ @start region=\"RecordingStreamMetadata\"\n+        static long count = 0;\n+        public static void main(String... args) throws Exception {\n+            String regExp = args[0];\n+            var pr = Pattern.compile(regExp).asMatchPredicate();\n+            Configuration c = Configuration.getConfiguration(\"default\");\n+            try (var s = new RecordingStream(c)) {\n+                s.setOrdered(false);\n+                s.onMetadata(metadata -> metadata.getAddedEventTypes()\n+                 .stream().map(EventType::getName).filter(pr)\n+                 .forEach(eventName -> s.onEvent(eventName, event -> count++)));\n+                s.startAsync();\n+                System.out.println(\"Running recording for 5 s. Please wait.\");\n+                s.awaitTermination(Duration.ofSeconds(5));\n+                System.out.println(count + \" events matches \" + regExp);\n+            }\n+        }\n+        \/\/ @end\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/snippet-files\/Snippets.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Bytecode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -519,0 +519,4 @@\n+    <event name=\"jdk.ShenandoahEvacuationInformation\">\n+      <setting name=\"enabled\" control=\"gc-enabled-high\">false<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -519,0 +519,4 @@\n+    <event name=\"jdk.ShenandoahEvacuationInformation\">\n+      <setting name=\"enabled\" control=\"gc-enabled-high\">false<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-               \\[--input <files>\\] [--output <file>\\]\n+               \\[--input &lt;files&gt;\\] [--output &lt;file&gt;\\]\n@@ -247,3 +247,3 @@\n-`jfr metadata` \\[--categories <filter>\\]\n-              \\[--events <filter>\\]\n-              \\[<file>\\]\n+`jfr metadata` \\[--categories &lt;filter&gt;\\]\n+              \\[--events &lt;filter&gt;\\]\n+              \\[&lt;file&gt;\\]\n@@ -262,1 +262,1 @@\n-If the <file> parameter is omitted, metadata from the JDK where\n+If the &lt;file&gt; parameter is omitted, metadata from the JDK where\n","filename":"src\/jdk.jfr\/share\/man\/jfr.md","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.io.UncheckedIOException;\n@@ -59,1 +60,0 @@\n-import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n@@ -94,1 +94,0 @@\n-    private final TaskHelper helper;\n@@ -97,2 +96,1 @@\n-                             boolean generateRuntimeImage,\n-                             TaskHelper taskHelper) {\n+                             boolean generateRuntimeImage) {\n@@ -101,1 +99,0 @@\n-        this.helper = taskHelper;\n@@ -121,2 +118,1 @@\n-            boolean generateRuntimeImage,\n-            TaskHelper taskHelper)\n+            boolean generateRuntimeImage)\n@@ -126,2 +122,1 @@\n-                                                      generateRuntimeImage,\n-                                                      taskHelper);\n+                                                      generateRuntimeImage);\n@@ -132,7 +127,5 @@\n-        } catch (RuntimeImageLinkException e) {\n-            \/\/ readAllEntries() might throw this exception.\n-            \/\/ Propagate as IOException with appropriate message for\n-            \/\/ jlink runs from the run-time image. This handles better\n-            \/\/ error messages for the case of modified files in the run-time\n-            \/\/ image.\n-            throw image.newIOException(e);\n+        } catch (UncheckedIOException e) {\n+            \/\/ When linking from the run-time image, readAllEntries() might\n+            \/\/ throw this exception for a modified runtime. Unpack and\n+            \/\/ re-throw as IOException.\n+            throw e.getCause();\n@@ -203,5 +196,0 @@\n-        } catch (RuntimeImageLinkException e) {\n-            \/\/ Propagate as IOException with appropriate message for\n-            \/\/ jlink runs from the run-time image. This handles better\n-            \/\/ error messages for the case of --patch-module.\n-            throw newIOException(e);\n@@ -221,12 +209,0 @@\n-    private IOException newIOException(RuntimeImageLinkException e) throws IOException {\n-        if (JlinkTask.DEBUG) {\n-            e.printStackTrace();\n-        }\n-        String message = switch (e.getReason()) {\n-            case PATCH_MODULE -> helper.getMessage(\"err.runtime.link.patched.module\", e.getFile());\n-            case MODIFIED_FILE -> helper.getMessage(\"err.runtime.link.modified.file\", e.getFile());\n-            default -> throw new AssertionError(\"Unexpected value: \" + e.getReason());\n-        };\n-        throw new IOException(message);\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":9,"deletions":33,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import static jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException.Reason.MODIFIED_FILE;\n-import static jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException.Reason.PATCH_MODULE;\n@@ -40,1 +38,0 @@\n-import java.nio.file.NoSuchFileException;\n@@ -59,1 +56,0 @@\n-import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n@@ -226,1 +222,3 @@\n-                                throw new RuntimeImageLinkException(path.toString(), MODIFIED_FILE);\n+                                String msg = taskHelper.getMessage(\"err.runtime.link.modified.file\", path.toString());\n+                                IOException cause = new IOException(msg);\n+                                throw new UncheckedIOException(cause);\n@@ -463,10 +461,1 @@\n-                            try {\n-                                return Files.size(archive.getPath().resolve(resPath));\n-                            } catch (NoSuchFileException file) {\n-                                \/\/ This indicates that we don't find the class in the\n-                                \/\/ modules image using the JRT FS provider. Yet, we find\n-                                \/\/ the class using the system module finder. Therefore,\n-                                \/\/ we have a patched module. Mention that module patching\n-                                \/\/ is not supported.\n-                                throw new RuntimeImageLinkException(file.getFile(), PATCH_MODULE);\n-                            }\n+                            return Files.size(archive.getPath().resolve(resPath));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import jdk.internal.module.ModuleBootstrap;\n@@ -76,1 +77,0 @@\n-import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n@@ -312,1 +312,1 @@\n-        } catch (IllegalArgumentException | ResolutionException | RuntimeImageLinkException e) {\n+        } catch (IllegalArgumentException | ResolutionException e) {\n@@ -623,0 +623,6 @@\n+            \/\/ Do not permit linking from run-time image when the current image\n+            \/\/ is being patched.\n+            if (ModuleBootstrap.patcher().hasPatches()) {\n+                String msg = taskHelper.getMessage(\"err.runtime.link.patched.module\");\n+                throw new IllegalArgumentException(msg);\n+            }\n@@ -1042,1 +1048,1 @@\n-                    targetPlatform.arch().byteOrder(), stack, generateRuntimeImage, taskHelper);\n+                    targetPlatform.arch().byteOrder(), stack, generateRuntimeImage);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.tools.jlink.internal.runtimelink;\n-\n-import java.util.Objects;\n-\n-\/**\n- * Exception thrown when linking from the run-time image\n- *\/\n-public class RuntimeImageLinkException extends RuntimeException {\n-\n-    private static final long serialVersionUID = -1848914673073119403L;\n-\n-    public static enum Reason {\n-        PATCH_MODULE,  \/* link exception due to patched module *\/\n-        MODIFIED_FILE, \/* link exception due to modified file  *\/\n-    }\n-\n-    private final String file;\n-    private final Reason reason;\n-\n-    public RuntimeImageLinkException(String file, Reason reason) {\n-        this.file = Objects.requireNonNull(file);\n-        this.reason = Objects.requireNonNull(reason);\n-    }\n-\n-    public String getFile() {\n-        return file;\n-    }\n-\n-    public Reason getReason() {\n-        return reason;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return reason + \", file: \" + file;\n-    }\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/RuntimeImageLinkException.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -128,2 +128,2 @@\n-err.runtime.link.patched.module=File {0} not found in the modules image.\\\n-\\ --patch-module is not supported when linking from the run-time image\n+err.runtime.link.patched.module=jlink does not support linking from the run-time image\\\n+\\ when running on a patched runtime with --patch-module\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -664,0 +664,6 @@\n+`wix-conv.xsl`\n+\n+:   WiX source code converter. Used for converting WiX sources from WiX v3 to v4 schema when WiX v4 or newer is used\n+\n+    Default resource is *wix3-to-wix4-conv.xsl*\n+\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -336,8 +336,1 @@\n-            var serviceInstallerResource = initServiceInstallerResource(params);\n-            if (serviceInstallerResource != null) {\n-                if (!Files.exists(serviceInstallerResource.getExternalPath())) {\n-                    throw new ConfigException(I18N.getString(\n-                            \"error.missing-service-installer\"), I18N.getString(\n-                                    \"error.missing-service-installer.advice\"));\n-                }\n-            }\n+            initServiceInstallerResource(params);\n@@ -410,5 +403,9 @@\n-        var serviceInstallerResource = initServiceInstallerResource(params);\n-        if (serviceInstallerResource != null) {\n-            var serviceInstallerPath = serviceInstallerResource.getExternalPath();\n-            params.put(SERVICE_INSTALLER.getID(), new InstallableFile(\n-                    serviceInstallerPath, serviceInstallerPath.getFileName()));\n+        try {\n+            var serviceInstallerResource = initServiceInstallerResource(params);\n+            if (serviceInstallerResource != null) {\n+                var serviceInstallerPath = serviceInstallerResource.getExternalPath();\n+                params.put(SERVICE_INSTALLER.getID(), new InstallableFile(\n+                        serviceInstallerPath, serviceInstallerPath.getFileName()));\n+            }\n+        } catch (ConfigException ex) {\n+            throw new PackagerException(ex);\n@@ -766,1 +763,1 @@\n-            Map<String, ? super Object> params) {\n+            Map<String, ? super Object> params) throws ConfigException {\n@@ -784,2 +781,6 @@\n-        if (result.getResourceDir() == null) {\n-            return null;\n+        if (result.getResourceDir() != null) {\n+            result.setExternal(result.getResourceDir().resolve(result.getPublicName()));\n+\n+            if (Files.exists(result.getExternalPath())) {\n+                return result;\n+            }\n@@ -788,2 +789,2 @@\n-        return result.setExternal(result.getResourceDir().resolve(\n-                result.getPublicName()));\n+        throw new ConfigException(I18N.getString(\"error.missing-service-installer\"),\n+                I18N.getString(\"error.missing-service-installer.advice\"));\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+error.missing-service-installer='service-installer.exe' service installer not found in the resource directory\n+error.missing-service-installer.advice=Add 'service-installer.exe' service installer to the resource directory\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+import java.util.function.UnaryOperator;\n@@ -808,1 +809,1 @@\n-     * Add normal prefixing\/postfixing to embedded newlines in a string,\n+     * Add normal prefixing\/postfixing to embedded newlines in a format string,\n@@ -811,2 +812,2 @@\n-     * @param s the string to prefix\n-     * @return the pre\/post-fixed and bracketed string\n+     * @param format the format string to prefix\/postfix\n+     * @return the pre\/post-fixed and bracketed format string\n@@ -814,2 +815,2 @@\n-    String prefix(String s) {\n-         return prefix(s, feedback.getPre(), feedback.getPost());\n+    String prefix(String format) {\n+         return prefix(format, feedback.getPre(), feedback.getPost());\n@@ -819,1 +820,1 @@\n-     * Add error prefixing\/postfixing to embedded newlines in a string,\n+     * Add error prefixing\/postfixing to embedded newlines in a format string,\n@@ -822,2 +823,2 @@\n-     * @param s the string to prefix\n-     * @return the pre\/post-fixed and bracketed string\n+     * @param format the format string to prefix\/postfix\n+     * @return the pre\/post-fixed and bracketed format string\n@@ -825,2 +826,2 @@\n-    String prefixError(String s) {\n-         return prefix(s, feedback.getErrorPre(), feedback.getErrorPost());\n+    String prefixError(String format) {\n+         return prefix(format, feedback.getErrorPre(), feedback.getErrorPost());\n@@ -830,1 +831,1 @@\n-     * Add prefixing\/postfixing to embedded newlines in a string,\n+     * Add prefixing\/postfixing to embedded newlines in a format string,\n@@ -832,1 +833,1 @@\n-     * Result is expected to be the format for a printf.\n+     * Both input and result strings are expected to be the format for a printf.\n@@ -834,4 +835,4 @@\n-     * @param s the string to prefix\n-     * @param pre the string to prepend to each line\n-     * @param post the string to append to each line (replacing newline)\n-     * @return the pre\/post-fixed and bracketed string\n+     * @param format the format string to prefix\n+     * @param pre the string to prepend to each line (printf safe)\n+     * @param post the string to append to each line (replacing newline; printf safe)\n+     * @return the pre\/post-fixed and bracketed format string\n@@ -839,2 +840,2 @@\n-    String prefix(String s, String pre, String post) {\n-        if (s == null) {\n+    String prefix(String format, String pre, String post) {\n+        if (format == null) {\n@@ -845,1 +846,1 @@\n-            return s + \"%n\";\n+            return format + \"%n\";\n@@ -847,1 +848,1 @@\n-        String pp = s.replaceAll(\"\\\\R\", post + pre);\n+        String pp = format.replaceAll(\"\\\\R\", post + pre);\n@@ -862,1 +863,1 @@\n-        hard(getResourceString(key));\n+        hard(escape(getResourceString(key)));\n@@ -885,1 +886,1 @@\n-        hard(messageFormat(key, args));\n+        hard(escape(messageFormat(key, args)));\n@@ -915,1 +916,1 @@\n-        Map<String, String> a2b = stream.collect(toMap(a, b,\n+        Map<String, String> a2b = stream.collect(toMap(a, b.andThen(this::escape),\n@@ -924,0 +925,7 @@\n+    \/**\n+     * Escape '%' signs in a plain string to make it a valid format string.\n+     *\/\n+    String escape(Object s) {\n+        return s.toString().replace(\"%\", \"%%\");\n+    }\n+\n@@ -2335,1 +2343,1 @@\n-        hard(sb.toString());\n+        hard(escape(sb));\n@@ -3265,1 +3273,1 @@\n-                hard(sb.toString());\n+                hard(escape(sb));\n@@ -3780,1 +3788,1 @@\n-                error(\"Unexpected status: \" + previousStatus.toString() + \"=>\" + status.toString());\n+                error(\"Unexpected status: %s=>%s\", previousStatus, status);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1055,1 +1055,1 @@\n-Both may optionally contain '%%s' which will be substituted with the next snippet ID --\\n\\\n+Both may optionally contain '%s' which will be substituted with the next snippet ID --\\n\\\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,20 +141,0 @@\n- *     <th scope=\"row\">dcmd.permissionClass<\/th><td>String<\/td>\n- *     <td>Some diagnostic command might require a specific permission to be\n- *          executed, in addition to the MBeanPermission to invoke their\n- *          associated MBean operation. This field returns the fully qualified\n- *          name of the permission class or null if no permission is required\n- *   <\/td>\n- *   <\/tr>\n- *   <tr>\n- *     <th scope=\"row\">dcmd.permissionName<\/th><td>String<\/td>\n- *     <td>The fist argument of the permission required to execute this\n- *          diagnostic command or null if no permission is required<\/td>\n- *   <\/tr>\n- *   <tr>\n- *     <th scope=\"row\">dcmd.permissionAction<\/th><td>String<\/td>\n- *     <td>The second argument of the permission required to execute this\n- *          diagnostic command or null if the permission constructor has only\n- *          one argument (like the ManagementPermission) or if no permission\n- *          is required<\/td>\n- *   <\/tr>\n- *   <tr>\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/DiagnosticCommandMBean.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.security.Permission;\n@@ -107,1 +106,0 @@\n-        Permission permission;\n@@ -114,35 +112,0 @@\n-            this.permission = null;\n-            Exception cause = null;\n-            if (info.getPermissionClass() != null) {\n-                try {\n-                    Class<?> c = Class.forName(info.getPermissionClass());\n-                    if (info.getPermissionAction() == null) {\n-                        try {\n-                            Constructor<?> constructor = c.getConstructor(String.class);\n-                            permission = (Permission) constructor.newInstance(info.getPermissionName());\n-\n-                        } catch (InstantiationException | IllegalAccessException\n-                                | IllegalArgumentException | InvocationTargetException\n-                                | NoSuchMethodException | SecurityException ex) {\n-                            cause = ex;\n-                        }\n-                    }\n-                    if (permission == null) {\n-                        try {\n-                            Constructor<?> constructor = c.getConstructor(String.class, String.class);\n-                            permission = (Permission) constructor.newInstance(\n-                                    info.getPermissionName(),\n-                                    info.getPermissionAction());\n-                        } catch (InstantiationException | IllegalAccessException\n-                                | IllegalArgumentException | InvocationTargetException\n-                                | NoSuchMethodException | SecurityException ex) {\n-                            cause = ex;\n-                        }\n-                    }\n-                } catch (ClassNotFoundException ex) { }\n-                if (permission == null) {\n-                    InstantiationException iex =\n-                            new InstantiationException(\"Unable to instantiate required permission\");\n-                    iex.initCause(cause);\n-                }\n-            }\n@@ -300,3 +263,0 @@\n-        map.put(\"dcmd.permissionClass\", w.info.getPermissionClass());\n-        map.put(\"dcmd.permissionName\", w.info.getPermissionName());\n-        map.put(\"dcmd.permissionAction\", w.info.getPermissionAction());\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/DiagnosticCommandImpl.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n-    private final String permissionClass;\n-    private final String permissionName;\n-    private final String permissionAction;\n@@ -76,37 +73,0 @@\n-    \/**\n-     * Returns the name of the permission class required to be allowed\n-     *         to invoke the diagnostic command, or null if no permission\n-     *         is required.\n-     *\n-     * @return the name of the permission class name required to be allowed\n-     *         to invoke the diagnostic command, or null if no permission\n-     *         is required\n-     *\/\n-    String getPermissionClass() {\n-        return permissionClass;\n-    }\n-\n-    \/**\n-     * Returns the permission name required to be allowed to invoke the\n-     *         diagnostic command, or null if no permission is required.\n-     *\n-     * @return the permission name required to be allowed to invoke the\n-     *         diagnostic command, or null if no permission is required\n-     *\/\n-    String getPermissionName() {\n-        return permissionName;\n-    }\n-\n-    \/**\n-     * Returns the permission action required to be allowed to invoke the\n-     *         diagnostic command, or null if no permission is required or\n-     *         if the permission has no action specified.\n-     *\n-     * @return the permission action required to be allowed to invoke the\n-     *         diagnostic command, or null if no permission is required or\n-     *         if the permission has no action specified\n-     *\/\n-    String getPermissionAction() {\n-        return permissionAction;\n-    }\n-\n@@ -137,2 +97,1 @@\n-                                    String impact, String permissionClass,\n-                                    String permissionName, String permissionAction,\n+                                    String impact,\n@@ -145,3 +104,0 @@\n-        this.permissionClass = permissionClass;\n-        this.permissionName = permissionName;\n-        this.permissionAction = permissionAction;\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/DiagnosticCommandInfo.java","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,1 +194,1 @@\n-      \/\/ Ensure capacity for 6 + 3 local refs:\n+      \/\/ Ensure capacity for 6 local refs:\n@@ -196,2 +196,1 @@\n-      \/\/  3 => permission class, name, action\n-      (*env)->PushLocalFrame(env, 6 + 3);\n+      (*env)->PushLocalFrame(env, 6);\n@@ -221,1 +220,1 @@\n-                                \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;ZLjava\/util\/List;)V\",\n+                                \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;ZLjava\/util\/List;)V\",\n@@ -223,3 +222,0 @@\n-                                dcmd_info_array[i].permission_class==NULL?NULL:(*env)->NewStringUTF(env,dcmd_info_array[i].permission_class),\n-                                dcmd_info_array[i].permission_name==NULL?NULL:(*env)->NewStringUTF(env,dcmd_info_array[i].permission_name),\n-                                dcmd_info_array[i].permission_action==NULL?NULL:(*env)->NewStringUTF(env,dcmd_info_array[i].permission_action),\n","filename":"src\/jdk.management\/share\/native\/libmanagement_ext\/DiagnosticCommandImpl.c","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n@@ -55,1 +53,0 @@\n-        PrivilegedExceptionAction<DatagramSocket> action = () -> new DatagramSocket(0);\n@@ -58,2 +55,1 @@\n-            @SuppressWarnings({\"deprecated\", \"removal\"})\n-            DatagramSocket ds = AccessController.doPrivileged(action);\n+            DatagramSocket ds = new DatagramSocket(0);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DNSDatagramChannelFactory.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,3 +93,2 @@\n-        return !filterNameServers(\n-                    ResolverConfiguration.open().nameservers(), true\n-                ).isEmpty();\n+        return !ResolverConfiguration\n+                .open().nameservers().isEmpty();\n@@ -148,2 +147,2 @@\n-                List<String> platformServers = filterNameServers(\n-                    ResolverConfiguration.open().nameservers(), false);\n+                List<String> platformServers =\n+                        ResolverConfiguration.open().nameservers();\n@@ -219,38 +218,0 @@\n-\n-    \/**\n-     * Removes any DNS server that's not permitted to access\n-     * @param input the input server[:port] list, must not be null\n-     * @param oneIsEnough return output once there exists one ok\n-     * @return the filtered list, all non-permitted input removed\n-     *\/\n-    private static List<String> filterNameServers(List<String> input, boolean oneIsEnough) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security == null || input == null || input.isEmpty()) {\n-            return input;\n-        } else {\n-            List<String> output = new ArrayList<>();\n-            for (String platformServer: input) {\n-                int colon = platformServer.indexOf(':',\n-                        platformServer.indexOf(']') + 1);\n-\n-                int p = (colon < 0)\n-                    ? DEFAULT_PORT\n-                    : Integer.parseInt(\n-                        platformServer.substring(colon + 1));\n-                String s = (colon < 0)\n-                    ? platformServer\n-                    : platformServer.substring(0, colon);\n-                try {\n-                    security.checkConnect(s, p);\n-                    output.add(platformServer);\n-                    if (oneIsEnough) {\n-                        return output;\n-                    }\n-                } catch (SecurityException se) {\n-                    continue;\n-                }\n-            }\n-            return output;\n-        }\n-    }\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsContextFactory.java","additions":5,"deletions":44,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -68,2 +66,0 @@\n-        PrivilegedAction<String> action = () ->\n-                System.getProperty(PARSE_MODE_PROP, DEFAULT_PARSE_MODE.toString());\n@@ -72,2 +68,2 @@\n-            @SuppressWarnings(\"removal\")\n-            String mode = AccessController.doPrivileged(action);\n+            String mode = System.getProperty(\n+                    PARSE_MODE_PROP, DEFAULT_PARSE_MODE.toString());\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsUrl.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,5 +61,0 @@\n-    \/\/ Environment property that, if set, indicates that a security\n-    \/\/ manager should be installed (if none is already in place).\n-    public static final String SECURITY_MGR =\n-            \"java.naming.rmi.security.manager\";\n-\n@@ -80,3 +75,0 @@\n-        if (environment.get(SECURITY_MGR) != null) {\n-            installSecurityMgr();\n-        }\n@@ -298,3 +290,0 @@\n-        if (propName.equals(SECURITY_MGR)) {\n-            installSecurityMgr();\n-        }\n@@ -415,13 +404,0 @@\n-    \/**\n-     * Attempts to install a security manager if none is currently in\n-     * place.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static void installSecurityMgr() {\n-\n-        try {\n-            System.setSecurityManager(new SecurityManager());\n-        } catch (Exception e) {\n-        }\n-    }\n-\n","filename":"src\/jdk.naming.rmi\/share\/classes\/com\/sun\/jndi\/rmi\/registry\/RegistryContext.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -60,2 +58,0 @@\n-        PrivilegedAction<String> action = () ->\n-                System.getProperty(PARSE_MODE_PROP, DEFAULT_PARSE_MODE.toString());\n@@ -64,2 +60,1 @@\n-            @SuppressWarnings(\"removal\")\n-            String mode = AccessController.doPrivileged(action);\n+            String mode = System.getProperty(PARSE_MODE_PROP, DEFAULT_PARSE_MODE.toString());\n","filename":"src\/jdk.naming.rmi\/share\/classes\/com\/sun\/jndi\/url\/rmi\/rmiURLContext.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.awt.Color;\n@@ -66,5 +67,0 @@\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(id, getProperties());\n-    }\n-\n@@ -75,0 +71,23 @@\n+\n+    public void setCustomColor(Color color) {\n+        if (color != null) {\n+            String hexColor = String.format(\"#%08X\", color.getRGB());\n+            getProperties().setProperty(\"color\", hexColor);\n+        } else {\n+            getProperties().setProperty(\"color\", null);\n+        }\n+    }\n+\n+    public Color getCustomColor() {\n+        String hexColor = getProperties().get(\"color\");\n+        if (hexColor != null) {\n+            try {\n+                String hex = hexColor.startsWith(\"#\") ? hexColor.substring(1) : hexColor;\n+                int argb = (int) Long.parseLong(hex, 16);\n+                return new Color(argb, true);\n+            } catch (Exception ignored) {\n+                return null;\n+            }\n+        }\n+        return null;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputNode;\n@@ -28,1 +29,2 @@\n-import java.awt.Dimension;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n@@ -30,2 +32,1 @@\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.*;\n@@ -39,1 +40,1 @@\n-    private InputBlock inputBlock;\n+    protected final InputBlock inputBlock;\n@@ -41,1 +42,1 @@\n-    private Diagram diagram;\n+    private final Diagram diagram;\n@@ -62,2 +63,8 @@\n-    public Dimension getNodeOffset() {\n-        return new Dimension(0, -Figure.getVerticalOffset());\n+    public List<? extends Vertex> getVertices() {\n+        List<Vertex> vertices = new ArrayList<>();\n+        for (InputNode inputNode : inputBlock.getNodes()) {\n+            if (diagram.hasFigure(inputNode)) {\n+                vertices.add(diagram.getFigure(inputNode));\n+            }\n+        }\n+        return vertices;\n@@ -70,0 +77,13 @@\n+    @Override\n+    public void setPosition(Point p) {\n+        if (bounds != null) {\n+            bounds.setLocation(p);\n+        }\n+    }\n+\n+    @Override\n+    public Point getPosition() {\n+        return bounds.getLocation();\n+    }\n+\n+    @Override\n@@ -82,0 +102,13 @@\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) return true;\n+        if (obj == null || getClass() != obj.getClass()) return false;\n+        Block other = (Block) obj;\n+        return inputBlock.equals(other.inputBlock);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return inputBlock.hashCode();\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -88,5 +89,0 @@\n-    @Override\n-    public boolean isVIP() {\n-        return true;\n-    }\n-\n@@ -107,0 +103,15 @@\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof BlockConnection that)) return false;\n+        return Objects.equals(this.sourceBlock, that.sourceBlock) &&\n+                Objects.equals(this.destinationBlock, that.destinationBlock) &&\n+                Objects.equals(this.label, that.label);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(sourceBlock, destinationBlock, label);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/BlockConnection.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    private List<Figure> figures;\n+    private final Map<InputNode, Figure> figures;\n@@ -39,0 +39,1 @@\n+    private final InputGraph inputGraph;\n@@ -66,1 +67,1 @@\n-        this.figures = new ArrayList<>();\n+        this.figures = new LinkedHashMap<>();\n@@ -69,0 +70,1 @@\n+        this.inputGraph = graph;\n@@ -84,1 +86,1 @@\n-            this.figures.add(f);\n+            this.figures.put(n, f);\n@@ -116,1 +118,1 @@\n-        for (Figure f : figures) {\n+        for (Figure f : figures.values()) {\n@@ -131,0 +133,4 @@\n+    public InputGraph getInputGraph() {\n+        return inputGraph;\n+    }\n+\n@@ -136,0 +142,9 @@\n+    public boolean hasFigure(InputNode n) {\n+        return figures.containsKey(n);\n+    }\n+\n+    public Figure getFigure(InputNode n) {\n+        assert figures.containsKey(n);\n+        return figures.get(n);\n+    }\n+\n@@ -161,1 +176,1 @@\n-        return Collections.unmodifiableList(figures);\n+        return Collections.unmodifiableList(new ArrayList<>(figures.values()));\n@@ -170,1 +185,1 @@\n-    public void removeAllBlocks(Set<Block> blocksToRemove) {\n+    public void removeAllBlocks(Collection<Block> blocksToRemove) {\n@@ -185,1 +200,1 @@\n-    public void removeAllFigures(Set<Figure> figuresToRemove) {\n+    public void removeAllFigures(Collection<Figure> figuresToRemove) {\n@@ -188,1 +203,1 @@\n-        }\n+            figures.remove(f.getInputNode());\n@@ -190,5 +205,0 @@\n-        ArrayList<Figure> newFigures = new ArrayList<>();\n-        for (Figure f : this.figures) {\n-            if (!figuresToRemove.contains(f)) {\n-                newFigures.add(f);\n-            }\n@@ -196,1 +206,0 @@\n-        figures = newFigures;\n@@ -218,4 +227,3 @@\n-    public void removeFigure(Figure succ) {\n-        assert this.figures.contains(succ);\n-        freeFigure(succ);\n-        this.figures.remove(succ);\n+    public void removeFigure(Figure figure) {\n+        freeFigure(figure);\n+        this.figures.remove(figure.getInputNode());\n@@ -226,1 +234,1 @@\n-        for (Figure f : figures) {\n+        for (Figure f : figures.values()) {\n@@ -249,1 +257,1 @@\n-        List<Figure> tmpFigures = getFigures();\n+        Collection<Figure> tmpFigures = getFigures();\n@@ -281,1 +289,1 @@\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures);\n+        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures.values());\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":30,"deletions":22,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.data.InputGraph;\n@@ -36,1 +37,0 @@\n-    public static final int INSET = 8;\n@@ -38,5 +38,4 @@\n-    public static final int OVERLAPPING = 6;\n-    public static final int SLOT_START = 4;\n-    public static final int SLOT_OFFSET = 8;\n-    public static final int TOP_CFG_HEIGHT = 7;\n-    public static final int BOTTOM_CFG_HEIGHT = 6;\n+    public static final int SLOT_HEIGHT = 10;\n+    public static final int BORDER = 1;\n+    public static final int PADDING = 4;\n+    public static final int SLOT_OFFSET = 16;\n@@ -70,9 +69,6 @@\n-        String nodeText = diagram.getNodeText();\n-        int lines = nodeText.split(\"\\n\").length;\n-        if (hasInputList() && lines > 1) {\n-            lines++;\n-        }\n-        if (getProperties().get(\"extra_label\") != null) {\n-            lines++;\n-        }\n-        heightCash = lines * metrics.getHeight() + INSET;\n+        heightCash = getLines().length * metrics.getHeight() + 2 * PADDING;\n+        heightCash += getSlotsHeight();\n+    }\n+\n+    public int getSlotsHeight() {\n+        int slotHeight = 0;\n@@ -81,1 +77,1 @@\n-                heightCash += TOP_CFG_HEIGHT;\n+                slotHeight += Figure.SLOT_HEIGHT;\n@@ -84,1 +80,1 @@\n-                heightCash += BOTTOM_CFG_HEIGHT;\n+                slotHeight += Figure.SLOT_HEIGHT;\n@@ -87,0 +83,1 @@\n+        return slotHeight;\n@@ -120,6 +117,5 @@\n-            int max = 0;\n-            for (String s : getLines()) {\n-                int cur = metrics.stringWidth(s);\n-                if (cur > max) {\n-                    max = cur;\n-                }\n+        widthCash = 0;\n+        for (String s : getLines()) {\n+            int cur = metrics.stringWidth(s);\n+            if (cur > widthCash) {\n+                widthCash = cur;\n@@ -127,6 +123,8 @@\n-            widthCash = (int)(max * BOLD_LINE_FACTOR) + INSET;\n-            if (getWarning() != null) {\n-                widthCash += WARNING_WIDTH;\n-            }\n-            widthCash = Math.max(widthCash, Figure.getSlotsWidth(inputSlots));\n-            widthCash = Math.max(widthCash, Figure.getSlotsWidth(outputSlots));\n+        }\n+        widthCash += 2 * PADDING;\n+        if (getWarning() != null) {\n+            widthCash += WARNING_WIDTH + PADDING;\n+        }\n+        widthCash = Math.max(widthCash, Figure.getSlotsWidth(inputSlots));\n+        widthCash = Math.max(widthCash, Figure.getSlotsWidth(outputSlots));\n+        widthCash = (int)(widthCash * BOLD_LINE_FACTOR);\n@@ -159,1 +157,6 @@\n-        return color;\n+        Color customColor = inputNode.getCustomColor();\n+        if (customColor != null) {\n+            return customColor;\n+        } else {\n+            return color;\n+        }\n@@ -234,1 +237,1 @@\n-    public InputSlot createInputSlot() {\n+    public void createInputSlot() {\n@@ -237,1 +240,0 @@\n-        return slot;\n@@ -344,1 +346,0 @@\n-                assert(inputLabel != null);\n@@ -382,2 +383,2 @@\n-        int width = Math.max(getWidth(), Figure.SLOT_WIDTH * (Math.max(inputSlots.size(), outputSlots.size()) + 1));\n-        int height = getHeight() + (diagram.isCFG() ? 0 : 2 * Figure.SLOT_WIDTH - 2 * Figure.OVERLAPPING);\n+        int width = getWidth();\n+        int height = getHeight();\n@@ -389,1 +390,2 @@\n-        if (!(o instanceof Figure)) {\n+        if (this == o) return true;\n+        if (!(o instanceof Figure other)) {\n@@ -392,1 +394,1 @@\n-        return getInputNode().equals(((Figure) o).getInputNode());\n+        return Objects.equals(this.getInputNode(), other.getInputNode());\n@@ -397,1 +399,1 @@\n-        return getInputNode().hashCode();\n+        return Objects.hash(getInputNode());\n@@ -405,4 +407,0 @@\n-    public static int getVerticalOffset() {\n-        return Figure.SLOT_WIDTH - Figure.OVERLAPPING;\n-    }\n-\n@@ -426,0 +424,12 @@\n+\n+    public void setCustomColor(Color color) {\n+        \/\/ Apply custom color not just to this input node but to all\n+        \/\/ corresponding input nodes in the group.\n+        InputGraph graph = diagram.getInputGraph();\n+        for (InputGraph g : graph.getGroup().getGraphs()) {\n+            InputNode n = g.getNode(inputNode.getId());\n+            if (n != null) {\n+                n.setCustomColor(color);\n+            }\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":53,"deletions":43,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -44,1 +45,1 @@\n-    private String label;\n+    private final String label;\n@@ -124,0 +125,8 @@\n+    public Figure getFromFigure() {\n+        return outputSlot.getFigure();\n+    }\n+\n+    public Figure getToFigure() {\n+        return inputSlot.getFigure();\n+    }\n+\n@@ -139,5 +148,0 @@\n-    @Override\n-    public boolean isVIP() {\n-        return style == ConnectionStyle.BOLD;\n-    }\n-\n@@ -161,8 +165,4 @@\n-        if (!(o instanceof FigureConnection)) {\n-            return false;\n-        }\n-\n-        return getInputSlot().getFigure().equals(((FigureConnection)o).getInputSlot().getFigure())\n-                && getOutputSlot().getFigure().equals(((FigureConnection)o).getOutputSlot().getFigure())\n-                && getInputSlot().getPosition() == ((FigureConnection)o).getInputSlot().getPosition()\n-                && getOutputSlot().getPosition() == ((FigureConnection) o).getOutputSlot().getPosition();\n+        if (this == o) return true;\n+        if (!(o instanceof FigureConnection that)) return false;\n+        return Objects.equals(this.outputSlot, that.outputSlot) &&\n+                Objects.equals(this.inputSlot, that.inputSlot);\n@@ -171,0 +171,4 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(outputSlot, inputSlot);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -75,1 +76,1 @@\n-        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getInputSlots(), this)) + getWidth()\/2, -Figure.SLOT_START);\n+        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getInputSlots(), this)) + getWidth()\/2, 0);\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/InputSlot.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Objects;\n@@ -57,1 +58,1 @@\n-        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getOutputSlots(), this)) + getWidth()\/2, Figure.SLOT_START);\n+        return new Point(gapAmount + Figure.getSlotsWidth(Figure.getAllBefore(getFigure().getOutputSlots(), this)) + getWidth()\/2, 0);\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/OutputSlot.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n+import java.util.*;\n@@ -48,2 +45,2 @@\n-    private int wantedIndex;\n-    private Source source;\n+    private final int wantedIndex;\n+    private final Source source;\n@@ -51,1 +48,0 @@\n-    private InputNode associatedNode;\n@@ -55,1 +51,1 @@\n-    private Figure figure;\n+    private final Figure figure;\n@@ -83,4 +79,0 @@\n-    public void setAssociatedNode(InputNode node) {\n-        associatedNode = node;\n-    }\n-\n@@ -88,2 +80,3 @@\n-        if (shortName == null || shortName.length() <= 1) {\n-            return Figure.SLOT_WIDTH;\n+        assert shortName != null;\n+        if (shortName.isEmpty()) {\n+            return 0;\n@@ -99,2 +92,2 @@\n-    public int getWantedIndex() {\n-        return wantedIndex;\n+    public int getHeight() {\n+        return Figure.SLOT_HEIGHT;\n@@ -114,1 +107,0 @@\n-\/\/        assert s.length() <= 2;\n@@ -141,1 +133,1 @@\n-        return getShortName() != null && getShortName().length() > 0;\n+        return getShortName() != null && !getShortName().isEmpty();\n@@ -156,1 +148,0 @@\n-        assert figure != null;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Slot.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,0 @@\n-    public boolean isVIP() {\n-        return false;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterEdge.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,0 @@\n-\n-    public boolean isVIP() {\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterIngoingConnection.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -53,0 +54,1 @@\n+        this.position = new Point(0, 0);\n@@ -57,1 +59,0 @@\n-        final ClusterNode thisBlockNode = blockNode;\n@@ -79,1 +80,1 @@\n-                p.x += blockNode.getBorder();\n+                p.x += ClusterNode.PADDING;\n@@ -85,1 +86,1 @@\n-                return thisBlockNode;\n+                return blockNode;\n@@ -127,0 +128,11 @@\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) return true;\n+        if (!(obj instanceof ClusterInputSlotNode other)) return false;\n+        return Objects.equals(this.id, other.id);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterInputSlotNode.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.awt.Rectangle;\n@@ -40,0 +41,1 @@\n+    public static final int PADDING = 8;\n@@ -48,2 +50,0 @@\n-    private final int border;\n-    private final Dimension nodeOffset;\n@@ -53,3 +53,1 @@\n-    public ClusterNode(Cluster cluster, String name, int border,\n-                       Dimension nodeOffset, int headerVerticalSpace,\n-                       Dimension emptySize) {\n+    public ClusterNode(Cluster cluster, String name, int headerVerticalSpace, Dimension emptySize) {\n@@ -61,2 +59,0 @@\n-        this.border = border;\n-        this.nodeOffset = nodeOffset;\n@@ -70,2 +66,2 @@\n-    public ClusterNode(Cluster cluster, String name) {\n-        this(cluster, name, 20, new Dimension(0, 0), 0, new Dimension(0, 0));\n+    public void updateClusterBounds() {\n+        cluster.setBounds(new Rectangle(position, size));\n@@ -148,2 +144,2 @@\n-            n.setPosition(new Point(n.getPosition().x - minX + nodeOffset.width,\n-                                    n.getPosition().y - minY + nodeOffset.height + headerVerticalSpace));\n+            n.setPosition(new Point(n.getPosition().x - minX,\n+                                    n.getPosition().y - minY + headerVerticalSpace));\n@@ -156,1 +152,1 @@\n-                p.y -= minY;\n+                p.y = p.y - minY + headerVerticalSpace;\n@@ -162,2 +158,2 @@\n-        size.width += 2 * border;\n-        size.height += 2 * border;\n+        size.width += 2 * PADDING;\n+        size.height += 2 * PADDING;\n@@ -184,1 +180,1 @@\n-            cur.translate(pos.x + border, pos.y + border);\n+            cur.translate(pos.x + PADDING, pos.y + PADDING);\n@@ -194,1 +190,1 @@\n-                    p2.translate(pos.x + border, pos.y + border);\n+                    p2.translate(pos.x + PADDING, pos.y + PADDING);\n@@ -221,4 +217,0 @@\n-    public int getBorder() {\n-        return border;\n-    }\n-\n@@ -237,0 +229,12 @@\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) return true;\n+        if (!(obj instanceof ClusterNode other)) return false;\n+        return Objects.equals(this.name, other.name);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,4 +72,0 @@\n-\n-    public boolean isVIP() {\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutgoingConnection.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -62,0 +63,1 @@\n+        this.position = new Point(0, 0);\n@@ -66,1 +68,0 @@\n-        final ClusterNode thisBlockNode = blockNode;\n@@ -88,1 +89,1 @@\n-                p.x += blockNode.getBorder();\n+                p.x += ClusterNode.PADDING;\n@@ -94,1 +95,1 @@\n-                return thisBlockNode;\n+                return blockNode;\n@@ -140,0 +141,11 @@\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) return true;\n+        if (!(obj instanceof ClusterOutputSlotNode other)) return false;\n+        return Objects.equals(this.id, other.id);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutputSlotNode.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,3 @@\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.*;\n+import com.sun.hotspot.igv.layout.Cluster;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n@@ -31,1 +32,1 @@\n-public class HierarchicalCFGLayoutManager implements LayoutManager {\n+public class HierarchicalCFGLayoutManager extends LayoutManager {\n@@ -33,1 +34,0 @@\n-    private static final int BLOCK_BORDER = 5;\n@@ -35,7 +35,9 @@\n-    \/\/ Lays out nodes within a single cluster (basic block).\n-    private LayoutManager subManager;\n-    \/\/ Lays out clusters in the CFG.\n-    private LayoutManager manager;\n-    private Set<Cluster> clusters;\n-\n-    public HierarchicalCFGLayoutManager() {\n+    private final HierarchicalLayoutManager manager;\n+    private final Set<? extends Cluster> clusters;\n+    private final Set<? extends Link> clusterLinks;\n+    Map<Cluster, ClusterNode> clusterNodesMap;\n+    Map<Link, ClusterEdge> clusterEdgesMap;\n+\n+    public HierarchicalCFGLayoutManager(Set<? extends Link> clusterLinks, Set<? extends Cluster> clusters) {\n+        this.clusterLinks = clusterLinks;\n+        this.clusters = clusters;\n@@ -46,0 +48,2 @@\n+        manager = new HierarchicalLayoutManager();\n+        manager.setLayoutSelfEdges(true);\n@@ -50,1 +54,0 @@\n-        subManager.setCutEdges(enable);\n@@ -54,14 +57,11 @@\n-    public void setSubManager(LayoutManager manager) {\n-        this.subManager = manager;\n-    }\n-\n-    public void setManager(LayoutManager manager) {\n-        this.manager = manager;\n-    }\n-\n-    public void setClusters(Set<Cluster> clusters) {\n-        this.clusters = clusters;\n-    }\n-\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-        doLayout(graph);\n+    private static void doLinearLayout(ClusterNode clusterNode) {\n+        Cluster cluster = clusterNode.getCluster();\n+        LayoutGraph graph = new LayoutGraph(clusterNode.getSubEdges(), clusterNode.getSubNodes());\n+        int curY = 0;\n+        for (Vertex vertex : cluster.getVertices()) {\n+            if (graph.containsVertex(vertex)) {\n+                vertex.setPosition(new Point(0, curY));\n+                curY += vertex.getSize().height;\n+            }\n+        }\n+        clusterNode.updateSize();\n@@ -71,1 +71,0 @@\n-\n@@ -73,3 +72,4 @@\n-        Map<Cluster, ClusterNode> clusterNode = createClusterNodes(graph);\n-        Set<ClusterEdge> clusterEdges = createClusterEdges(clusterNode);\n-        markRootClusters(clusterEdges);\n+        clusterNodesMap = createClusterNodes(graph.getVertices());\n+        assert clusterNodesMap.size() == clusters.size();\n+        clusterEdgesMap = createClusterEdges(clusterNodesMap);\n+        assert clusterEdgesMap.size() == clusterLinks.size();\n@@ -78,4 +78,9 @@\n-        for (Cluster c : clusters) {\n-            ClusterNode n = clusterNode.get(c);\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n-            n.updateSize();\n+        for (ClusterNode clusterNode : clusterNodesMap.values()) {\n+            doLinearLayout(clusterNode);\n+        }\n+\n+        \/\/ mark root nodes\n+        LayoutGraph clusterGraph = new LayoutGraph(clusterEdgesMap.values(), clusterNodesMap.values());\n+        for (Vertex rootVertex : clusterGraph.findRootVertices()) {\n+            assert rootVertex instanceof ClusterNode;\n+            ((ClusterNode) rootVertex).setRoot(true);\n@@ -85,1 +90,1 @@\n-        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())), new HashSet<>());\n+        manager.doLayout(clusterGraph);\n@@ -88,2 +93,2 @@\n-        writeBackClusterBounds(clusterNode);\n-        writeBackClusterEdgePoints(graph, clusterEdges);\n+        writeBackClusterBounds();\n+        writeBackClusterEdgePoints();\n@@ -92,9 +97,8 @@\n-    private Map<Cluster, ClusterNode> createClusterNodes(LayoutGraph graph) {\n-        Map<Cluster, ClusterNode> clusterNode = new HashMap<>();\n-        for (Cluster c : clusters) {\n-            String blockLabel = \"B\" + c;\n-            Dimension emptySize = new Dimension(fontMetrics.stringWidth(blockLabel) + BLOCK_BORDER * 2,\n-                                                fontMetrics.getHeight() + BLOCK_BORDER);\n-            ClusterNode cn = new ClusterNode(c, c.toString(), BLOCK_BORDER, c.getNodeOffset(),\n-                                             fontMetrics.getHeight(), emptySize);\n-            clusterNode.put(c, cn);\n+    private Map<Cluster, ClusterNode> createClusterNodes(SortedSet<Vertex> vertices) {\n+        Map<Cluster, ClusterNode> clusterNodes = new HashMap<>();\n+        for (Cluster cluster : clusters) {\n+            String blockLabel = \"B\" + cluster;\n+            Dimension emptySize = new Dimension(fontMetrics.stringWidth(blockLabel) + ClusterNode.PADDING,\n+                                                fontMetrics.getHeight() + ClusterNode.PADDING);\n+            ClusterNode clusterNode = new ClusterNode(cluster, cluster.toString(), fontMetrics.getHeight(), emptySize);\n+            clusterNodes.put(cluster, clusterNode);\n@@ -103,4 +107,3 @@\n-        for (Vertex v : graph.getVertices()) {\n-            Cluster c = v.getCluster();\n-            assert c != null : \"Cluster of vertex \" + v + \" is null!\";\n-            clusterNode.get(c).addSubNode(v);\n+        for (Vertex vertex : vertices) {\n+            Cluster cluster = vertex.getCluster();\n+            clusterNodes.get(cluster).addSubNode(vertex);\n@@ -108,1 +111,1 @@\n-        return clusterNode;\n+        return clusterNodes;\n@@ -111,14 +114,2 @@\n-    private Set<ClusterEdge> createClusterEdges(Map<Cluster, ClusterNode> clusterNode) {\n-        Set<ClusterEdge> clusterEdges = new HashSet<>();\n-        for (Cluster c : clusters) {\n-            ClusterNode start = clusterNode.get(c);\n-            for (Cluster succ : c.getSuccessors()) {\n-                ClusterNode end = clusterNode.get(succ);\n-                if (end != null) {\n-                    ClusterEdge e = new ClusterEdge(start, end);\n-                    clusterEdges.add(e);\n-                }\n-            }\n-        }\n-        return clusterEdges;\n-    }\n+    private Map<Link, ClusterEdge> createClusterEdges(Map<Cluster, ClusterNode> clusterNodes) {\n+        Map<Link, ClusterEdge> clusterEdges = new HashMap<>();\n@@ -126,5 +117,6 @@\n-    private void markRootClusters(Set<ClusterEdge> clusterEdges) {\n-        Set<Vertex> roots = new LayoutGraph(clusterEdges).findRootVertices();\n-        for (Vertex v : roots) {\n-            assert v instanceof ClusterNode;\n-            ((ClusterNode) v).setRoot(true);\n+        for (Link clusterLink : clusterLinks) {\n+            ClusterNode fromClusterNode = clusterNodes.get(clusterLink.getFromCluster());\n+            ClusterNode toClusterNode = clusterNodes.get(clusterLink.getToCluster());\n+            assert fromClusterNode != null;\n+            assert toClusterNode != null;\n+            clusterEdges.put(clusterLink, new ClusterEdge(fromClusterNode, toClusterNode));\n@@ -132,0 +124,2 @@\n+\n+        return clusterEdges;\n@@ -134,4 +128,4 @@\n-    private void writeBackClusterBounds(Map<Cluster, ClusterNode> clusterNode) {\n-        for (Cluster c : clusters) {\n-            ClusterNode n = clusterNode.get(c);\n-            c.setBounds(new Rectangle(n.getPosition(), n.getSize()));\n+    private void writeBackClusterBounds() {\n+        assert clusterNodesMap.size() == clusters.size();\n+        for (ClusterNode clusterNode : clusterNodesMap.values()) {\n+            clusterNode.updateClusterBounds();\n@@ -141,10 +135,9 @@\n-    private void writeBackClusterEdgePoints(LayoutGraph graph, Set<ClusterEdge> clusterEdges) {\n-        \/\/ Map from \"primitive\" cluster edges to their input links.\n-        Map<AbstractMap.SimpleEntry<Cluster, Cluster>, Link> inputLink = new HashMap<>();\n-        for (Link l : graph.getLinks()) {\n-            inputLink.put(new AbstractMap.SimpleEntry<>(l.getFromCluster(), l.getToCluster()), l);\n-        }\n-        for (ClusterEdge ce : clusterEdges) {\n-            assert (ce.getControlPoints() != null);\n-            Link l = inputLink.get(new AbstractMap.SimpleEntry<>(ce.getFromCluster(), ce.getToCluster()));\n-            l.setControlPoints(ce.getControlPoints());\n+    private void writeBackClusterEdgePoints() {\n+        assert clusterEdgesMap.size() == clusterLinks.size();\n+        for (Link clusterLink : clusterLinks) {\n+            ClusterEdge clusterEdge = clusterEdgesMap.get(clusterLink);\n+            if (clusterEdge.getControlPoints() != null) {\n+                clusterLink.setControlPoints(clusterEdge.getControlPoints());\n+            } else {\n+                clusterLink.setControlPoints(new ArrayList<>());\n+            }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":78,"deletions":85,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -30,0 +29,1 @@\n+import java.util.List;\n@@ -35,1 +35,1 @@\n-public class HierarchicalClusterLayoutManager implements LayoutManager {\n+public class HierarchicalClusterLayoutManager extends LayoutManager {\n@@ -37,4 +37,2 @@\n-    private HierarchicalLayoutManager.Combine combine;\n-    private LayoutManager subManager = new HierarchicalLayoutManager(combine);\n-    private LayoutManager manager = new HierarchicalLayoutManager(combine);\n-    private static final boolean TRACE = false;\n+    private final LayoutManager manager;\n+    private final HashMap<Cluster, ClusterNode> clusterNodes;\n@@ -42,2 +40,4 @@\n-    public HierarchicalClusterLayoutManager(HierarchicalLayoutManager.Combine combine) {\n-        this.combine = combine;\n+\n+    public HierarchicalClusterLayoutManager() {\n+        this.manager = new HierarchicalLayoutManager();\n+        this.clusterNodes = new HashMap<>();\n@@ -48,1 +48,0 @@\n-        subManager.setCutEdges(enable);\n@@ -52,11 +51,0 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-        doLayout(graph);\n-    }\n-\n-    public void setSubManager(LayoutManager manager) {\n-        this.subManager = manager;\n-    }\n-\n-    public void setManager(LayoutManager manager) {\n-        this.manager = manager;\n-    }\n@@ -65,3 +53,1 @@\n-\n-        assert graph.verify();\n-\n+        clusterNodes.clear();\n@@ -72,1 +58,0 @@\n-        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<>();\n@@ -82,1 +67,7 @@\n-        Set<Cluster> cluster = graph.getClusters();\n+        Set<Cluster> clusters = new TreeSet<>();\n+        for (Vertex v : graph.getVertices()) {\n+            if (v.getCluster() != null) {\n+                clusters.add(v.getCluster());\n+            }\n+        }\n+\n@@ -84,1 +75,1 @@\n-        for (Cluster c : cluster) {\n+        for (Cluster c : clusters) {\n@@ -90,1 +81,8 @@\n-            ClusterNode cn = new ClusterNode(c, \"\" + z);\n+\n+            String blockLabel = \"B\" + c;\n+            Canvas canvas = new Canvas();\n+            FontMetrics fontMetrics = canvas.getFontMetrics(TITLE_FONT);\n+            Dimension emptySize = new Dimension(fontMetrics.stringWidth(blockLabel) + ClusterNode.PADDING * 2,\n+                    fontMetrics.getHeight() + ClusterNode.PADDING * 2);\n+            ClusterNode cn = new ClusterNode(c, \"\" + z, fontMetrics.getHeight(), emptySize);\n+\n@@ -96,15 +94,0 @@\n-        \/\/ Add cluster edges\n-        for (Cluster c : cluster) {\n-\n-            ClusterNode start = clusterNodes.get(c);\n-\n-            for (Cluster succ : c.getSuccessors()) {\n-                ClusterNode end = clusterNodes.get(succ);\n-                if (end != null && start != end) {\n-                    ClusterEdge e = new ClusterEdge(start, end);\n-                    clusterEdges.add(e);\n-                    interClusterEdges.add(e);\n-                }\n-            }\n-        }\n-\n@@ -126,7 +109,0 @@\n-            Port samePort = null;\n-            if (combine == HierarchicalLayoutManager.Combine.SAME_INPUTS) {\n-                samePort = toPort;\n-            } else if (combine == HierarchicalLayoutManager.Combine.SAME_OUTPUTS) {\n-                samePort = fromPort;\n-            }\n-\n@@ -140,2 +116,2 @@\n-                ClusterInputSlotNode inputSlotNode = null;\n-                ClusterOutputSlotNode outputSlotNode = null;\n+                ClusterInputSlotNode inputSlotNode;\n+                ClusterOutputSlotNode outputSlotNode;\n@@ -143,4 +119,2 @@\n-                if (samePort != null) {\n-                    outputSlotNode = clusterOutputSlotHash.get(fromCluster).get(samePort);\n-                    inputSlotNode = clusterInputSlotHash.get(toCluster).get(samePort);\n-                }\n+                outputSlotNode = clusterOutputSlotHash.get(fromCluster).get(fromPort);\n+                inputSlotNode = clusterInputSlotHash.get(toCluster).get(toPort);\n@@ -149,1 +123,1 @@\n-                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort);\n+                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + fromPort);\n@@ -154,3 +128,1 @@\n-                    if (samePort != null) {\n-                        clusterOutputSlotHash.get(fromCluster).put(samePort, outputSlotNode);\n-                    }\n+                    clusterOutputSlotHash.get(fromCluster).put(fromPort, outputSlotNode);\n@@ -164,1 +136,4 @@\n-                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort);\n+                    inputSlotNode = new ClusterInputSlotNode(\n+                            clusterNodes.get(toCluster),\n+                            \"In \" + toCluster.toString() + \" \" + toPort \/\/ Use toPort here\n+                    );\n@@ -170,1 +145,1 @@\n-                clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n+                clusterInputSlotHash.get(toCluster).put(fromPort, inputSlotNode);\n@@ -181,8 +156,1 @@\n-        Timing t = null;\n-\n-        if (TRACE) {\n-            t = new Timing(\"Child timing\");\n-            t.start();\n-        }\n-\n-        for (Cluster c : cluster) {\n+        for (Cluster c : clusters) {\n@@ -190,1 +158,2 @@\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n+            HierarchicalLayoutManager subManager = new HierarchicalLayoutManager();\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()));\n@@ -194,1 +163,1 @@\n-        Set<Vertex> roots = new LayoutGraph(interClusterEdges).findRootVertices();\n+        Set<Vertex> roots = new LayoutGraph(interClusterEdges, new HashSet<>()).findRootVertices();\n@@ -200,1 +169,1 @@\n-        manager.doLayout(new LayoutGraph(clusterEdges, clusterNodeSet), interClusterEdges);\n+        manager.doLayout(new LayoutGraph(clusterEdges, clusterNodeSet));\n@@ -202,1 +171,1 @@\n-        for (Cluster c : cluster) {\n+        for (Cluster c : clusters) {\n@@ -207,7 +176,0 @@\n-        \/\/ TODO: handle case where blocks are not fully connected\n-\n-        if (TRACE) {\n-            t.stop();\n-            t.print();\n-        }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalClusterLayoutManager.java","additions":44,"deletions":82,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.*;\n@@ -30,2 +29,0 @@\n-import com.sun.hotspot.igv.util.Statistics;\n-import java.awt.Dimension;\n@@ -39,79 +36,1 @@\n-public class HierarchicalLayoutManager implements LayoutManager {\n-\n-    public static final boolean TRACE = false;\n-    public static final boolean CHECK = false;\n-    public static final int SWEEP_ITERATIONS = 1;\n-    public static final int CROSSING_ITERATIONS = 2;\n-    public static final int DUMMY_HEIGHT = 1;\n-    public static final int DUMMY_WIDTH = 1;\n-    public static final int X_OFFSET = 8;\n-    public static final int LAYER_OFFSET = 8;\n-    public static final int MAX_LAYER_LENGTH = -1;\n-    public static final int MIN_LAYER_DIFFERENCE = 1;\n-    public static final int VIP_BONUS = 10;\n-\n-    public enum Combine {\n-\n-        NONE,\n-        SAME_INPUTS,\n-        SAME_OUTPUTS\n-    }\n-    \/\/ Options\n-    private final Combine combine;\n-    private final int dummyWidth;\n-    private final int dummyHeight;\n-    private int xOffset;\n-    private int layerOffset;\n-    private int maxLayerLength;\n-    private int minLayerDifference;\n-    private boolean layoutSelfEdges;\n-    \/\/ Algorithm global datastructures\n-    private Set<Link> reversedLinks;\n-    private Set<LayoutEdge> selfEdges;\n-    private List<LayoutNode> nodes;\n-    private HashMap<Vertex, LayoutNode> vertexToLayoutNode;\n-    private HashMap<Link, List<Point>> reversedLinkStartPoints;\n-    private HashMap<Link, List<Point>> reversedLinkEndPoints;\n-    private HashMap<Link, List<Point>> splitStartPoints;\n-    private HashMap<Link, List<Point>> splitEndPoints;\n-    private LayoutGraph graph;\n-    private List<LayoutNode>[] layers;\n-    private int layerCount;\n-    private Set<? extends Link> importantLinks;\n-    private final Set<Link> linksToFollow;\n-\n-    private abstract static class AlgorithmPart {\n-\n-        public void start() {\n-            if (CHECK) {\n-                preCheck();\n-            }\n-\n-            long start = 0;\n-            if (TRACE) {\n-                System.out.println(\"##################################################\");\n-                System.out.println(\"Starting part \" + this.getClass().getName());\n-                start = System.currentTimeMillis();\n-            }\n-            run();\n-            if (TRACE) {\n-                System.out.println(\"Timing for \" + this.getClass().getName() + \" is \" + (System.currentTimeMillis() - start));\n-                printStatistics();\n-            }\n-\n-            if (CHECK) {\n-                postCheck();\n-            }\n-        }\n-\n-        protected abstract void run();\n-\n-        protected void printStatistics() {\n-        }\n-\n-        protected void postCheck() {\n-        }\n-\n-        protected void preCheck() {\n-        }\n-    }\n+public class HierarchicalLayoutManager extends LayoutManager implements LayoutMover {\n@@ -119,11 +38,3 @@\n-    public HierarchicalLayoutManager(Combine b) {\n-        this.combine = b;\n-        this.dummyWidth = DUMMY_WIDTH;\n-        this.dummyHeight = DUMMY_HEIGHT;\n-        this.xOffset = X_OFFSET;\n-        this.layerOffset = LAYER_OFFSET;\n-        this.maxLayerLength = MAX_LAYER_LENGTH;\n-        this.minLayerDifference = MIN_LAYER_DIFFERENCE;\n-        this.layoutSelfEdges = false;\n-        this.linksToFollow = new HashSet<>();\n-    }\n+    int maxLayerLength;\n+    private LayoutGraph graph;\n+    private boolean layoutSelfEdges = false;\n@@ -131,2 +42,3 @@\n-    public void setXOffset(int xOffset) {\n-        this.xOffset = xOffset;\n+    public HierarchicalLayoutManager() {\n+        setCutEdges(false);\n+        setLayoutSelfEdges(false);\n@@ -135,2 +47,2 @@\n-    public void setLayerOffset(int layerOffset) {\n-        this.layerOffset = layerOffset;\n+    public void setLayoutSelfEdges(boolean layoutSelfEdges) {\n+        this.layoutSelfEdges = layoutSelfEdges;\n@@ -144,3 +56,3 @@\n-    public void setMinLayerDifference(int v) {\n-        minLayerDifference = v;\n-    }\n+    @Override\n+    public void doLayout(LayoutGraph layoutGraph) {\n+        layoutGraph.initializeLayout();\n@@ -148,3 +60,1 @@\n-    public void setLayoutSelfEdges(boolean layoutSelfEdges) {\n-        this.layoutSelfEdges = layoutSelfEdges;\n-    }\n+        removeSelfEdges(layoutGraph);\n@@ -152,2 +62,16 @@\n-    public List<LayoutNode> getNodes() {\n-        return nodes;\n+        \/\/ STEP 1: Reverse edges\n+        ReverseEdges.apply(layoutGraph);\n+\n+        \/\/ STEP 2: Assign layers and create dummy nodes\n+        LayerManager.apply(layoutGraph, maxLayerLength);\n+\n+        \/\/ STEP 3: Crossing Reduction\n+        CrossingReduction.apply(layoutGraph);\n+\n+        \/\/ STEP 4: Assign X coordinates\n+        AssignXCoordinates.apply(layoutGraph);\n+\n+        \/\/ STEP 5: Write back to interface\n+        WriteResult.apply(layoutGraph);\n+\n+        graph = layoutGraph;\n@@ -156,10 +80,10 @@\n-    \/\/ Remove self-edges, possibly saving them into the selfEdges set.\n-    private void removeSelfEdges(boolean save) {\n-        for (LayoutNode node : nodes) {\n-            for (LayoutEdge e : new ArrayList<>(node.succs)) {\n-                if (e.to == node) {\n-                    if (save) {\n-                        selfEdges.add(e);\n-                    }\n-                    node.succs.remove(e);\n-                    node.preds.remove(e);\n+    @Override\n+    public void moveLink(Point linkPos, int shiftX) {\n+        int layerNr = graph.findLayer(linkPos.y);\n+        for (LayoutNode node : graph.getLayer(layerNr)) {\n+            if (node.isDummy() && linkPos.x == node.getX()) {\n+                LayoutLayer layer = graph.getLayer(layerNr);\n+                if (layer.contains(node)) {\n+                    node.setX(linkPos.x + shiftX);\n+                    layer.sortNodesByX();\n+                    break;\n@@ -169,0 +93,1 @@\n+        writeBack();\n@@ -172,2 +97,6 @@\n-    public void doLayout(LayoutGraph graph) {\n-        doLayout(graph, new HashSet<>());\n+    public void moveVertices(Set<? extends Vertex> movedVertices) {\n+        for (Vertex vertex : movedVertices) {\n+            moveVertex(vertex);\n+        }\n+        writeBack();\n+    }\n@@ -175,0 +104,5 @@\n+    private void writeBack() {\n+        graph.optimizeBackEdgeCrossings();\n+        graph.updateLayerMinXSpacing();\n+        graph.straightenEdges();\n+        WriteResult.apply(graph);\n@@ -178,21 +112,21 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-\n-        this.importantLinks = importantLinks;\n-        this.graph = graph;\n-\n-        vertexToLayoutNode = new HashMap<>();\n-        reversedLinks = new HashSet<>();\n-        selfEdges = new HashSet<>();\n-        reversedLinkStartPoints = new HashMap<>();\n-        reversedLinkEndPoints = new HashMap<>();\n-        nodes = new ArrayList<>();\n-        splitStartPoints = new HashMap<>();\n-        splitEndPoints = new HashMap<>();\n-\n-        \/\/ #############################################################\n-        \/\/ Step 1: Build up data structure\n-        new BuildDatastructure().start();\n-\n-        if (!layoutSelfEdges) {\n-            \/\/ Remove self-edges from the beginning.\n-            removeSelfEdges(false);\n+    public void moveVertex(Vertex movedVertex) {\n+        Point newLoc = movedVertex.getPosition();\n+        LayoutNode movedNode = graph.getLayoutNode(movedVertex);\n+        assert !movedNode.isDummy();\n+\n+        int layerNr = graph.findLayer(newLoc.y + movedNode.getOuterHeight() \/ 2);\n+        if (movedNode.getLayer() == layerNr) { \/\/ we move the node in the same layer\n+            LayoutLayer layer = graph.getLayer(layerNr);\n+            if (layer.contains(movedNode)) {\n+                movedNode.setX(newLoc.x);\n+                layer.sortNodesByX();\n+            }\n+        } else { \/\/ only remove edges if we moved the node to a new layer\n+            if (maxLayerLength > 0) return; \/\/ TODO: not implemented\n+            graph.removeNodeAndEdges(movedNode);\n+            layerNr = graph.insertNewLayerIfNeeded(movedNode, layerNr);\n+            graph.addNodeToLayer(movedNode, layerNr);\n+            movedNode.setX(newLoc.x);\n+            graph.getLayer(layerNr).sortNodesByX();\n+            graph.removeEmptyLayers();\n+            graph.addEdges(movedNode, maxLayerLength);\n@@ -200,0 +134,1 @@\n+    }\n@@ -201,9 +136,12 @@\n-        \/\/ #############################################################\n-        \/\/ STEP 2: Reverse edges, handle backedges\n-        new ReverseEdges().start();\n-\n-        for (LayoutNode n : nodes) {\n-            ArrayList<LayoutEdge> tmpArr = new ArrayList<>();\n-            for (LayoutEdge e : n.succs) {\n-                if (importantLinks.contains(e.link)) {\n-                    tmpArr.add(e);\n+    \/**\n+     * Removes self-edges from nodes in the graph. If self-edges are to be included in the layout\n+     * (`layoutSelfEdges` is true), it stores them in the node for later processing and marks the graph\n+     * to display self-edges\n+     *\/\n+    private void removeSelfEdges(LayoutGraph graph) {\n+        for (LayoutNode node : graph.getLayoutNodes()) {\n+            \/\/ Collect self-edges first to avoid concurrent modification\n+            List<LayoutEdge> selfEdges = new ArrayList<>();\n+            for (LayoutEdge edge : node.getSuccessors()) {\n+                if (edge.getTo() == node) {\n+                    selfEdges.add(edge);\n@@ -213,3 +151,10 @@\n-            for (LayoutEdge e : tmpArr) {\n-                e.from.succs.remove(e);\n-                e.to.preds.remove(e);\n+            \/\/ Remove each self-edge\n+            for (LayoutEdge edge : selfEdges) {\n+                node.removeSuccessor(edge);\n+                node.removePredecessor(edge);\n+            }\n+            if (layoutSelfEdges) {\n+                for (LayoutEdge selfEdge : selfEdges) {\n+                    node.setSelfEdge(selfEdge);\n+                }\n+                graph.setShowSelfEdges(true);\n@@ -218,28 +163,2 @@\n-\n-        \/\/ Hide self-edges from the layout algorithm and save them for later.\n-        removeSelfEdges(true);\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 3: Assign layers\n-        new AssignLayers().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 4: Create dummy nodes\n-        new CreateDummyNodes().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 5: Crossing Reduction\n-        new CrossingReduction().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 7: Assign X coordinates\n-        new AssignXCoordinates().start();\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 6: Assign Y coordinates\n-        new AssignYCoordinates().start();\n-\n-        \/\/ Put saved self-edges back so that they are assigned points.\n-        for (LayoutEdge e : selfEdges) {\n-            e.from.succs.add(e);\n-            e.to.preds.add(e);\n+        if (layoutSelfEdges) {\n+            graph.setShowSelfEdges(true);\n@@ -247,4 +166,0 @@\n-\n-        \/\/ #############################################################\n-        \/\/ STEP 8: Write back to interface\n-        new WriteResult().start();\n@@ -253,1 +168,3 @@\n-    private class WriteResult extends AlgorithmPart {\n+    public List<LayoutNode> getNodes() {\n+        return graph.getAllNodes();\n+    }\n@@ -255,1 +172,1 @@\n-        private int pointCount;\n+    public static class ReverseEdges {\n@@ -257,2 +174,3 @@\n-        @Override\n-        protected void run() {\n+        static public void apply(LayoutGraph graph) {\n+            reverseRootInputs(graph);\n+            depthFirstSearch(graph);\n@@ -260,6 +178,2 @@\n-            HashMap<Vertex, Point> vertexPositions = new HashMap<>();\n-            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n-            for (Vertex v : graph.getVertices()) {\n-                LayoutNode n = vertexToLayoutNode.get(v);\n-                assert !vertexPositions.containsKey(v);\n-                vertexPositions.put(v, new Point(n.x + n.xOffset, n.y + n.yOffset));\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                node.computeReversedLinkPoints(false);\n@@ -267,0 +181,1 @@\n+        }\n@@ -268,84 +183,5 @@\n-            for (LayoutNode n : nodes) {\n-\n-                for (LayoutEdge e : n.preds) {\n-                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n-                        ArrayList<Point> points = new ArrayList<>();\n-\n-                        Point p = new Point(e.to.x + e.relativeTo, e.to.y + e.to.yOffset + e.link.getTo().getRelativePosition().y);\n-                        points.add(p);\n-                        if (e.to.inOffsets.containsKey(e.relativeTo)) {\n-                            points.add(new Point(p.x, p.y + e.to.inOffsets.get(e.relativeTo) + e.link.getTo().getRelativePosition().y));\n-                        }\n-\n-                        LayoutNode cur = e.from;\n-                        LayoutNode other = e.to;\n-                        LayoutEdge curEdge = e;\n-                        while (cur.vertex == null && cur.preds.size() != 0) {\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y + cur.height));\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y));\n-                            assert cur.preds.size() == 1;\n-                            curEdge = cur.preds.get(0);\n-                            cur = curEdge.from;\n-                        }\n-\n-                        p = new Point(cur.x + curEdge.relativeFrom, cur.y + cur.height - cur.bottomYOffset + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y));\n-                        if (curEdge.from.outOffsets.containsKey(curEdge.relativeFrom)) {\n-                            points.add(new Point(p.x, p.y + curEdge.from.outOffsets.get(curEdge.relativeFrom) + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y)));\n-                        }\n-                        points.add(p);\n-\n-                        Collections.reverse(points);\n-\n-                        if (cur.vertex == null && cur.preds.size() == 0) {\n-\n-                            if (reversedLinkEndPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                                    points.add(new Point(p1.x + e.to.x, p1.y + e.to.y));\n-                                }\n-                            }\n-\n-                            if (splitStartPoints.containsKey(e.link)) {\n-                                points.add(0, null);\n-                                points.addAll(0, splitStartPoints.get(e.link));\n-\n-                                \/\/checkPoints(points);\n-                                if (reversedLinks.contains(e.link)) {\n-                                    Collections.reverse(points);\n-                                }\n-                                assert !linkPositions.containsKey(e.link);\n-                                linkPositions.put(e.link, points);\n-                            } else {\n-                                splitEndPoints.put(e.link, points);\n-                            }\n-\n-                        } else {\n-                            if (reversedLinks.contains(e.link)) {\n-                                Collections.reverse(points);\n-                                if (selfEdges.contains(e)) {\n-                                    \/\/ For self edges, it is enough with the\n-                                    \/\/ start and end points computed by ReverseEdges.\n-                                    points.clear();\n-                                }\n-                            }\n-                            if (reversedLinkStartPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                                    points.add(new Point(p1.x + cur.x, p1.y + cur.y));\n-                                }\n-                            }\n-\n-                            if (reversedLinkEndPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                                    points.add(0, new Point(p1.x + other.x, p1.y + other.y));\n-                                }\n-                            }\n-\n-                            assert !linkPositions.containsKey(e.link);\n-                            linkPositions.put(e.link, points);\n-                        }\n-                        pointCount += points.size();\n+        private static void reverseRootInputs(LayoutGraph graph) {\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                if (node.getVertex().isRoot()) {\n+                    for (LayoutEdge predEdge : new ArrayList<>(node.getPredecessors())) {\n+                        reverseEdge(predEdge);\n@@ -354,0 +190,2 @@\n+            }\n+        }\n@@ -355,38 +193,2 @@\n-                for (LayoutEdge e : n.succs) {\n-                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n-                        ArrayList<Point> points = new ArrayList<>();\n-                        Point p = new Point(e.from.x + e.relativeFrom, e.from.y + e.from.height - e.from.bottomYOffset + e.link.getFrom().getRelativePosition().y);\n-                        points.add(p);\n-                        if (e.from.outOffsets.containsKey(e.relativeFrom)) {\n-                            Point pOffset = new Point(p.x, p.y + e.from.outOffsets.get(e.relativeFrom) +\n-                                                      e.link.getFrom().getRelativePosition().y + e.from.yOffset);\n-                            if (!pOffset.equals(p)) {\n-                                points.add(pOffset);\n-                            }\n-                        }\n-\n-                        LayoutNode cur = e.to;\n-                        LayoutNode other = e.from;\n-                        LayoutEdge curEdge = e;\n-                        while (cur.vertex == null && !cur.succs.isEmpty()) {\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y));\n-                            if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2 && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                                points.remove(points.size() - 1);\n-                            }\n-                            points.add(new Point(cur.x + cur.width \/ 2, cur.y + cur.height));\n-                            if (cur.succs.isEmpty()) {\n-                                break;\n-                            }\n-                            assert cur.succs.size() == 1;\n-                            curEdge = cur.succs.get(0);\n-                            cur = curEdge.to;\n-                        }\n-\n-                        p = new Point(cur.x + curEdge.relativeTo, cur.y + cur.yOffset + ((curEdge.link == null) ? 0 : curEdge.link.getTo().getRelativePosition().y));\n-                        points.add(p);\n-                        if (curEdge.to.inOffsets.containsKey(curEdge.relativeTo)) {\n-                            points.add(new Point(p.x, p.y + curEdge.to.inOffsets.get(curEdge.relativeTo) + ((curEdge.link == null) ? 0 : curEdge.link.getTo().getRelativePosition().y)));\n-                        }\n+        public static void reverseEdge(LayoutEdge edge) {\n+            edge.reverse();\n@@ -394,6 +196,4 @@\n-                        if (cur.succs.isEmpty() && cur.vertex == null) {\n-                            if (reversedLinkStartPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                                    points.add(0, new Point(p1.x + other.x, p1.y + other.y));\n-                                }\n-                            }\n+            LayoutNode fromNode = edge.getFrom();\n+            LayoutNode toNode = edge.getTo();\n+            int relativeFrom = edge.getRelativeFromX();\n+            int relativeTo = edge.getRelativeToX();\n@@ -401,3 +201,4 @@\n-                            if (splitEndPoints.containsKey(e.link)) {\n-                                points.add(null);\n-                                points.addAll(splitEndPoints.get(e.link));\n+            edge.setFrom(toNode);\n+            edge.setTo(fromNode);\n+            edge.setRelativeFromX(relativeTo);\n+            edge.setRelativeToX(relativeFrom);\n@@ -405,9 +206,5 @@\n-                                if (reversedLinks.contains(e.link)) {\n-                                    Collections.reverse(points);\n-                                }\n-                                assert !linkPositions.containsKey(e.link);\n-                                linkPositions.put(e.link, points);\n-                            } else {\n-                                splitStartPoints.put(e.link, points);\n-                            }\n-                        } else {\n+            fromNode.removeSuccessor(edge);\n+            fromNode.addPredecessor(edge);\n+            toNode.removePredecessor(edge);\n+            toNode.addSuccessor(edge);\n+        }\n@@ -415,16 +212,3 @@\n-                            if (reversedLinkStartPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                                    points.add(0, new Point(p1.x + other.x + other.xOffset, p1.y + other.y));\n-                                }\n-                            }\n-                            if (reversedLinkEndPoints.containsKey(e.link)) {\n-                                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                                    points.add(new Point(p1.x + cur.x + cur.xOffset, p1.y + cur.y));\n-                                }\n-                            }\n-                            if (reversedLinks.contains(e.link)) {\n-                                Collections.reverse(points);\n-                            }\n-                            assert !linkPositions.containsKey(e.link);\n-                            linkPositions.put(e.link, points);\n-                        }\n+        private static void depthFirstSearch(LayoutGraph graph) {\n+            Set<LayoutNode> visited = new HashSet<>();\n+            Set<LayoutNode> active = new HashSet<>();\n@@ -432,4 +216,3 @@\n-                        pointCount += points.size();\n-                    }\n-                }\n-            }\n+            for (LayoutNode startNode : graph.getLayoutNodes()) {\n+                Deque<LayoutNode> stack = new ArrayDeque<>();\n+                stack.push(startNode);\n@@ -437,7 +220,2 @@\n-            int minX = Integer.MAX_VALUE;\n-            int minY = Integer.MAX_VALUE;\n-            for (Vertex v : vertexPositions.keySet()) {\n-                Point p = vertexPositions.get(v);\n-                minX = Math.min(minX, p.x);\n-                minY = Math.min(minY, p.y);\n-            }\n+                while (!stack.isEmpty()) {\n+                    LayoutNode node = stack.pop();\n@@ -445,6 +223,3 @@\n-            for (Link l : linkPositions.keySet()) {\n-                List<Point> points = linkPositions.get(l);\n-                for (Point p : points) {\n-                    if (p != null) {\n-                        minX = Math.min(minX, p.x);\n-                        minY = Math.min(minY, p.y);\n+                    if (visited.contains(node)) {\n+                        active.remove(node);\n+                        continue;\n@@ -452,3 +227,0 @@\n-                }\n-\n-            }\n@@ -456,6 +228,3 @@\n-            for (Vertex v : vertexPositions.keySet()) {\n-                Point p = vertexPositions.get(v);\n-                p.x -= minX;\n-                p.y -= minY;\n-                v.setPosition(p);\n-            }\n+                    stack.push(node);\n+                    visited.add(node);\n+                    active.add(node);\n@@ -463,6 +232,7 @@\n-            for (Link l : linkPositions.keySet()) {\n-                List<Point> points = linkPositions.get(l);\n-                for (Point p : points) {\n-                    if (p != null) {\n-                        p.x -= minX;\n-                        p.y -= minY;\n+                    for (LayoutEdge edge : new ArrayList<>(node.getSuccessors())) {\n+                        LayoutNode successor = edge.getTo();\n+                        if (active.contains(successor)) {\n+                            reverseEdge(edge);\n+                        } else if (!visited.contains(successor)) {\n+                            stack.push(successor);\n+                        }\n@@ -471,11 +241,0 @@\n-                l.setControlPoints(points);\n-\n-            }\n-        }\n-\n-        @Override\n-        protected void printStatistics() {\n-            System.out.println(\"Number of nodes: \" + nodes.size());\n-            int edgeCount = 0;\n-            for (LayoutNode n : nodes) {\n-                edgeCount += n.succs.size();\n@@ -483,2 +242,0 @@\n-            System.out.println(\"Number of edges: \" + edgeCount);\n-            System.out.println(\"Number of points: \" + pointCount);\n@@ -488,78 +245,1 @@\n-    public static final Comparator<LayoutNode> nodePositionComparator = Comparator.comparingInt(n -> n.pos);\n-    public static final Comparator<LayoutNode> nodeProcessingDownComparator = (n1, n2) -> {\n-        int n1VIP = 0;\n-        for (LayoutEdge e : n1.preds) {\n-            if (e.vip) {\n-                n1VIP++;\n-            }\n-        }\n-        int n2VIP = 0;\n-        for (LayoutEdge e : n2.preds) {\n-            if (e.vip) {\n-                n2VIP++;\n-            }\n-        }\n-        if (n1VIP != n2VIP) {\n-            return n2VIP - n1VIP;\n-        }\n-        if (n1.vertex == null) {\n-            if (n2.vertex == null) {\n-                return 0;\n-            }\n-            return -1;\n-        }\n-        if (n2.vertex == null) {\n-            return 1;\n-        }\n-        return n1.preds.size() - n2.preds.size();\n-    };\n-    public static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n-        int n1VIP = 0;\n-        for (LayoutEdge e : n1.succs) {\n-            if (e.vip) {\n-                n1VIP++;\n-            }\n-        }\n-        int n2VIP = 0;\n-        for (LayoutEdge e : n2.succs) {\n-            if (e.vip) {\n-                n2VIP++;\n-            }\n-        }\n-        if (n1VIP != n2VIP) {\n-            return n2VIP - n1VIP;\n-        }\n-        if (n1.vertex == null) {\n-            if (n2.vertex == null) {\n-                return 0;\n-            }\n-            return -1;\n-        }\n-        if (n2.vertex == null) {\n-            return 1;\n-        }\n-        return n1.succs.size() - n2.succs.size();\n-    };\n-\n-    private class AssignXCoordinates extends AlgorithmPart {\n-\n-        private ArrayList<Integer>[] space;\n-        private ArrayList<LayoutNode>[] downProcessingOrder;\n-        private ArrayList<LayoutNode>[] upProcessingOrder;\n-\n-        private void initialPositions() {\n-            for (LayoutNode n : nodes) {\n-                n.x = space[n.layer].get(n.pos);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        private void createArrays() {\n-            space = new ArrayList[layers.length];\n-            downProcessingOrder = new ArrayList[layers.length];\n-            upProcessingOrder = new ArrayList[layers.length];\n-        }\n-\n-        @Override\n-        protected void run() {\n-            createArrays();\n+    public static class LayerManager {\n@@ -567,4 +247,2 @@\n-            for (int i = 0; i < layers.length; i++) {\n-                space[i] = new ArrayList<>();\n-                downProcessingOrder[i] = new ArrayList<>();\n-                upProcessingOrder[i] = new ArrayList<>();\n+        private static void assignLayerDownwards(LayoutGraph graph) {\n+            ArrayList<LayoutNode> workingList = new ArrayList<>();\n@@ -572,42 +250,5 @@\n-                int curX = 0;\n-                for (LayoutNode n : layers[i]) {\n-                    space[i].add(curX);\n-                    curX += n.width + xOffset;\n-                    downProcessingOrder[i].add(n);\n-                    upProcessingOrder[i].add(n);\n-                }\n-\n-                downProcessingOrder[i].sort(nodeProcessingDownComparator);\n-                upProcessingOrder[i].sort(nodeProcessingUpComparator);\n-            }\n-\n-            initialPositions();\n-            for (int i = 0; i < SWEEP_ITERATIONS; i++) {\n-                sweepDown();\n-                adjustSpace();\n-                sweepUp();\n-                adjustSpace();\n-            }\n-\n-            sweepDown();\n-            adjustSpace();\n-            sweepUp();\n-        }\n-\n-        private void adjustSpace() {\n-            for (int i = 0; i < layers.length; i++) {\n-                for (LayoutNode n : layers[i]) {\n-                    space[i].add(n.x);\n-                }\n-            }\n-        }\n-\n-        private int calculateOptimalDown(LayoutNode n) {\n-            int size = n.preds.size();\n-            if (size == 0) {\n-                return n.x;\n-            }\n-            int vipCount = 0;\n-            for (LayoutEdge e : n.preds) {\n-                if (e.vip) {\n-                    vipCount++;\n+            \/\/ add all root nodes to layer 0\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                if (!node.hasPredecessors()) {\n+                    workingList.add(node);\n+                    node.setLayer(0);\n@@ -617,14 +258,24 @@\n-            if (vipCount == 0) {\n-                int[] values = new int[size];\n-                for (int i = 0; i < size; i++) {\n-                    LayoutEdge e = n.preds.get(i);\n-                    values[i] = e.from.x + e.relativeFrom - e.relativeTo;\n-                }\n-                return Statistics.median(values);\n-            } else {\n-                int z = 0;\n-                int[] values = new int[vipCount];\n-                for (int i = 0; i < size; i++) {\n-                    LayoutEdge e = n.preds.get(i);\n-                    if (e.vip) {\n-                        values[z++] = e.from.x + e.relativeFrom - e.relativeTo;\n+            \/\/ assign layers downwards starting from roots\n+            int layer = 1;\n+            while (!workingList.isEmpty()) {\n+                ArrayList<LayoutNode> newWorkingList = new ArrayList<>();\n+                for (LayoutNode node : workingList) {\n+                    for (LayoutEdge succEdge : node.getSuccessors()) {\n+                        LayoutNode succNode = succEdge.getTo();\n+                        if (succNode.getLayer() == -1) {\n+                            \/\/ This node was not assigned before.\n+                            boolean assignedPred = true;\n+                            for (LayoutEdge predEdge : succNode.getPredecessors()) {\n+                                LayoutNode predNode = predEdge.getFrom();\n+                                if (predNode.getLayer() == -1 || predNode.getLayer() >= layer) {\n+                                    \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n+                                    assignedPred = false;\n+                                    break;\n+                                }\n+                            }\n+                            if (assignedPred) {\n+                                \/\/ This successor node can be assigned.\n+                                succNode.setLayer(layer);\n+                                newWorkingList.add(succNode);\n+                            }\n+                        }\n@@ -633,15 +284,2 @@\n-                return Statistics.median(values);\n-            }\n-        }\n-\n-        private int calculateOptimalBoth(LayoutNode n) {\n-            if (n.preds.size() == n.succs.size()) {\n-                return n.x;\n-            }\n-\n-            int[] values = new int[n.preds.size() + n.succs.size()];\n-            int i = 0;\n-\n-            for (LayoutEdge e : n.preds) {\n-                values[i] = e.from.x + e.relativeFrom - e.relativeTo;\n-                i++;\n+                workingList = newWorkingList;\n+                layer++;\n@@ -650,3 +288,3 @@\n-            for (LayoutEdge e : n.succs) {\n-                values[i] = e.to.x + e.relativeTo - e.relativeFrom;\n-                i++;\n+            int layerCount = layer - 1;\n+            for (LayoutNode n : graph.getLayoutNodes()) {\n+                n.setLayer((layerCount - 1 - n.getLayer()));\n@@ -654,2 +292,0 @@\n-\n-            return Statistics.median(values);\n@@ -658,15 +294,31 @@\n-        private int calculateOptimalUp(LayoutNode n) {\n-            int size = n.succs.size();\n-            if (size == 0) {\n-                return n.x;\n-            }\n-            int[] values = new int[size];\n-            for (int i = 0; i < size; i++) {\n-                LayoutEdge e = n.succs.get(i);\n-                values[i] = e.to.x + e.relativeTo - e.relativeFrom;\n-                if (e.vip) {\n-                    return values[i];\n-                }\n-            }\n-            return Statistics.median(values);\n-        }\n+        private static void assignLayerUpwards(LayoutGraph graph) {\n+            ArrayList<LayoutNode> workingList = new ArrayList<>();\n+            \/\/ add all leaves to working list, reset layer of non-leave nodes\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                if (!node.hasSuccessors()) {\n+                    workingList.add(node);\n+                } else {\n+                    node.setLayer(-1);\n+                }\n+            }\n+\n+            \/\/ assign layer upwards starting from leaves\n+            \/\/ sinks non-leave nodes down as much as possible\n+            int layer = 1;\n+            while (!workingList.isEmpty()) {\n+                ArrayList<LayoutNode> newWorkingList = new ArrayList<>();\n+                for (LayoutNode node : workingList) {\n+                    if (node.getLayer() < layer) {\n+                        for (LayoutEdge predEdge : node.getPredecessors()) {\n+                            LayoutNode predNode = predEdge.getFrom();\n+                            if (predNode.getLayer() == -1) {\n+                                \/\/ This node was not assigned before.\n+                                boolean assignedSucc = true;\n+                                for (LayoutEdge succEdge : predNode.getSuccessors()) {\n+                                    LayoutNode succNode = succEdge.getTo();\n+                                    if (succNode.getLayer() == -1 || succNode.getLayer() >= layer) {\n+                                        \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n+                                        assignedSucc = false;\n+                                        break;\n+                                    }\n+                                }\n@@ -674,6 +326,10 @@\n-        private void sweepUp() {\n-            for (int i = layers.length - 1; i >= 0; i--) {\n-                NodeRow r = new NodeRow(space[i]);\n-                for (LayoutNode n : upProcessingOrder[i]) {\n-                    int optimal = calculateOptimalUp(n);\n-                    r.insert(n, optimal);\n+                                if (assignedSucc) {\n+                                    \/\/ This predecessor node can be assigned.\n+                                    predNode.setLayer(layer);\n+                                    newWorkingList.add(predNode);\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        newWorkingList.add(node);\n+                    }\n@@ -681,2 +337,0 @@\n-            }\n-        }\n@@ -684,7 +338,2 @@\n-        private void sweepDown() {\n-            for (int i = 1; i < layers.length; i++) {\n-                NodeRow r = new NodeRow(space[i]);\n-                for (LayoutNode n : downProcessingOrder[i]) {\n-                    int optimal = calculateOptimalDown(n);\n-                    r.insert(n, optimal);\n-                }\n+                workingList = newWorkingList;\n+                layer++;\n@@ -692,2 +341,0 @@\n-        }\n-    }\n@@ -695,25 +342,3 @@\n-    public static class NodeRow {\n-\n-        private final TreeSet<LayoutNode> treeSet;\n-        private final ArrayList<Integer> space;\n-\n-        public NodeRow(ArrayList<Integer> space) {\n-            treeSet = new TreeSet<>(nodePositionComparator);\n-            this.space = space;\n-        }\n-\n-        public int offset(LayoutNode n1, LayoutNode n2) {\n-            int v1 = space.get(n1.pos) + n1.width;\n-            int v2 = space.get(n2.pos);\n-            return v2 - v1;\n-        }\n-\n-        public void insert(LayoutNode n, int pos) {\n-\n-            SortedSet<LayoutNode> headSet = treeSet.headSet(n);\n-\n-            LayoutNode leftNeighbor;\n-            int minX = Integer.MIN_VALUE;\n-            if (!headSet.isEmpty()) {\n-                leftNeighbor = headSet.last();\n-                minX = leftNeighbor.x + leftNeighbor.width + offset(leftNeighbor, n);\n+            int layerCount = layer - 1;\n+            for (LayoutNode n : graph.getLayoutNodes()) {\n+                n.setLayer((layerCount - 1 - n.getLayer()));\n@@ -722,29 +347,1 @@\n-            if (pos < minX) {\n-                n.x = minX;\n-            } else {\n-\n-                LayoutNode rightNeighbor;\n-                SortedSet<LayoutNode> tailSet = treeSet.tailSet(n);\n-                int maxX = Integer.MAX_VALUE;\n-                if (!tailSet.isEmpty()) {\n-                    rightNeighbor = tailSet.first();\n-                    maxX = rightNeighbor.x - offset(n, rightNeighbor) - n.width;\n-                }\n-\n-                n.x = Math.min(pos, maxX);\n-\n-                assert minX <= maxX : minX + \" vs \" + maxX;\n-            }\n-\n-            treeSet.add(n);\n-        }\n-    }\n-    private static final Comparator<LayoutNode> crossingNodeComparator = Comparator.comparingInt(n -> n.crossingNumber);\n-\n-    private class CrossingReduction extends AlgorithmPart {\n-\n-        @Override\n-        public void preCheck() {\n-            for (LayoutNode n : nodes) {\n-                assert n.layer < layerCount;\n-            }\n+            graph.initLayers(layerCount);\n@@ -753,3 +350,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        private void createLayers() {\n-            layers = new List[layerCount];\n@@ -757,3 +351,3 @@\n-            for (int i = 0; i < layerCount; i++) {\n-                layers[i] = new ArrayList<>();\n-            }\n+        static private void assignLayers(LayoutGraph graph) {\n+            assignLayerDownwards(graph);\n+            assignLayerUpwards(graph);\n@@ -762,3 +356,3 @@\n-        @Override\n-        protected void run() {\n-            createLayers();\n+        static private void createDummyNodes(LayoutGraph graph, int maxLayerLength) {\n+            List<LayoutNode> layoutNodes = new ArrayList<>(graph.getLayoutNodes());\n+            layoutNodes.sort(LAYOUT_NODE_DEGREE_COMPARATOR);\n@@ -768,7 +362,7 @@\n-            for (LayoutNode n : nodes) {\n-                if (n.layer == 0) {\n-                    layers[0].add(n);\n-                    visited.add(n);\n-                } else if (n.preds.isEmpty()) {\n-                    layers[n.layer].add(n);\n-                    visited.add(n);\n+            for (LayoutNode layoutNode : layoutNodes) {\n+                if (layoutNode.getLayer() == 0) {\n+                    graph.getLayer(0).add(layoutNode);\n+                    visited.add(layoutNode);\n+                } else if (!layoutNode.hasPredecessors()) {\n+                    graph.getLayer(layoutNode.getLayer()).add(layoutNode);\n+                    visited.add(layoutNode);\n@@ -778,9 +372,12 @@\n-            for (int i = 0; i < layers.length - 1; i++) {\n-                for (LayoutNode n : layers[i]) {\n-                    for (LayoutEdge e : n.succs) {\n-                        if (!visited.contains(e.to)) {\n-                            visited.add(e.to);\n-                            layers[i + 1].add(e.to);\n-                            if (!nodes.contains(e.to)) {\n-                                nodes.add(e.to);\n-                            }\n+            for (LayoutNode layoutNode : layoutNodes) {\n+                graph.createDummiesForNodeSuccessor(layoutNode, maxLayerLength);\n+            }\n+\n+            for (int i = 0; i < graph.getLayerCount() - 1; i++) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    for (LayoutEdge e : n.getSuccessors()) {\n+                        if (e.getTo().isDummy()) continue;\n+                        if (!visited.contains(e.getTo())) {\n+                            visited.add(e.getTo());\n+                            graph.getLayer(i + 1).add(e.getTo());\n+                            e.getTo().setLayer(i + 1);\n@@ -791,11 +388,0 @@\n-\n-            updatePositions();\n-\n-            initX();\n-\n-            \/\/ Optimize\n-            for (int i = 0; i < CROSSING_ITERATIONS; i++) {\n-                downSweep();\n-                upSweep();\n-            }\n-            downSweep();\n@@ -804,5 +390,4 @@\n-        private void initX() {\n-\n-            for (int i = 0; i < layers.length; i++) {\n-                updateXOfLayer(i);\n-            }\n+        static public void apply(LayoutGraph graph, int maxLayerLength) {\n+            assignLayers(graph);\n+            createDummyNodes(graph, maxLayerLength);\n+            graph.updatePositions();\n@@ -810,0 +395,1 @@\n+    }\n@@ -811,2 +397,1 @@\n-        private void updateXOfLayer(int index) {\n-            int x = 0;\n+    static class CrossingReduction {\n@@ -814,3 +399,4 @@\n-            for (LayoutNode n : layers[index]) {\n-                n.x = x;\n-                x += n.width + xOffset;\n+        public static void apply(LayoutGraph graph) {\n+            for (int i = 0; i < graph.getLayerCount(); i++) {\n+                graph.getLayer(i).updateNodeIndices();\n+                graph.getLayer(i).initXPositions();\n@@ -818,1 +404,0 @@\n-        }\n@@ -820,7 +405,3 @@\n-        private void updatePositions() {\n-            for (List<LayoutNode> layer : layers) {\n-                int z = 0;\n-                for (LayoutNode n : layer) {\n-                    n.pos = z;\n-                    z++;\n-                }\n+            for (int i = 0; i < CROSSING_ITERATIONS; i++) {\n+                downSweep(graph);\n+                upSweep(graph);\n@@ -828,0 +409,1 @@\n+            downSweep(graph);\n@@ -830,4 +412,1 @@\n-        private void downSweep() {\n-\n-            \/\/ Downsweep\n-            for (int i = 1; i < layerCount; i++) {\n+        private static void downSweep(LayoutGraph graph) {\n@@ -835,2 +414,3 @@\n-                for (LayoutNode n : layers[i]) {\n-                    n.crossingNumber = 0;\n+            for (int i = 1; i < graph.getLayerCount(); i++) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    n.setCrossingNumber(0);\n@@ -838,3 +418,1 @@\n-\n-                for (LayoutNode n : layers[i]) {\n-\n+                for (LayoutNode n : graph.getLayer(i)) {\n@@ -843,8 +421,3 @@\n-                    for (LayoutEdge e : n.preds) {\n-                        int cur = e.from.x + e.relativeFrom;\n-                        int factor = 1;\n-                        if (e.vip) {\n-                            factor = VIP_BONUS;\n-                        }\n-                        sum += cur * factor;\n-                        count += factor;\n+                    for (LayoutEdge e : n.getPredecessors()) {\n+                        sum += e.getStartX();\n+                        count++;\n@@ -855,1 +428,1 @@\n-                        n.crossingNumber = sum;\n+                        n.setCrossingNumber(sum);\n@@ -858,10 +431,4 @@\n-\n-                updateCrossingNumbers(i, true);\n-                layers[i].sort(crossingNodeComparator);\n-                updateXOfLayer(i);\n-\n-                int z = 0;\n-                for (LayoutNode n : layers[i]) {\n-                    n.pos = z;\n-                    z++;\n-                }\n+                updateCrossingNumbers(graph.getLayer(i), true);\n+                graph.getLayer(i).sort(NODE_CROSSING_COMPARATOR);\n+                graph.getLayer(i).initXPositions();\n+                graph.getLayer(i).updateNodeIndices();\n@@ -871,3 +438,3 @@\n-        private void updateCrossingNumbers(int index, boolean down) {\n-            for (int i = 0; i < layers[index].size(); i++) {\n-                LayoutNode n = layers[index].get(i);\n+        private static void updateCrossingNumbers(LayoutLayer layer, boolean down) {\n+            for (int i = 0; i < layer.size(); i++) {\n+                LayoutNode n = layer.get(i);\n@@ -876,1 +443,1 @@\n-                    prev = layers[index].get(i - 1);\n+                    prev = layer.get(i - 1);\n@@ -879,2 +446,2 @@\n-                if (i < layers[index].size() - 1) {\n-                    next = layers[index].get(i + 1);\n+                if (i < layer.size() - 1) {\n+                    next = layer.get(i + 1);\n@@ -882,2 +449,1 @@\n-\n-                boolean cond = n.succs.isEmpty();\n+                boolean cond = !n.hasSuccessors();\n@@ -885,1 +451,1 @@\n-                    cond = n.preds.isEmpty();\n+                    cond = !n.hasPredecessors();\n@@ -887,1 +453,0 @@\n-\n@@ -889,1 +454,0 @@\n-\n@@ -891,1 +455,1 @@\n-                        n.crossingNumber = (prev.crossingNumber + next.crossingNumber) \/ 2;\n+                        n.setCrossingNumber((prev.getCrossingNumber() + next.getCrossingNumber()) \/ 2);\n@@ -893,1 +457,1 @@\n-                        n.crossingNumber = prev.crossingNumber;\n+                        n.setCrossingNumber(prev.getCrossingNumber());\n@@ -895,1 +459,1 @@\n-                        n.crossingNumber = next.crossingNumber;\n+                        n.setCrossingNumber(next.getCrossingNumber());\n@@ -901,6 +465,4 @@\n-        private void upSweep() {\n-            \/\/ Upsweep\n-            for (int i = layerCount - 2; i >= 0; i--) {\n-\n-                for (LayoutNode n : layers[i]) {\n-                    n.crossingNumber = 0;\n+        private static void upSweep(LayoutGraph graph) {\n+            for (int i = graph.getLayerCount() - 2; i >= 0; i--) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    n.setCrossingNumber(0);\n@@ -908,3 +470,1 @@\n-\n-                for (LayoutNode n : layers[i]) {\n-\n+                for (LayoutNode n : graph.getLayer(i)) {\n@@ -913,8 +473,3 @@\n-                    for (LayoutEdge e : n.succs) {\n-                        int cur = e.to.x + e.relativeTo;\n-                        int factor = 1;\n-                        if (e.vip) {\n-                            factor = VIP_BONUS;\n-                        }\n-                        sum += cur * factor;\n-                        count += factor;\n+                    for (LayoutEdge e : n.getSuccessors()) {\n+                        sum += e.getEndX();\n+                        count++;\n@@ -922,1 +477,0 @@\n-\n@@ -925,1 +479,1 @@\n-                        n.crossingNumber = sum;\n+                        n.setCrossingNumber(sum);\n@@ -929,10 +483,4 @@\n-\n-                updateCrossingNumbers(i, false);\n-                layers[i].sort(crossingNodeComparator);\n-                updateXOfLayer(i);\n-\n-                int z = 0;\n-                for (LayoutNode n : layers[i]) {\n-                    n.pos = z;\n-                    z++;\n-                }\n+                updateCrossingNumbers(graph.getLayer(i), false);\n+                graph.getLayer(i).sort(NODE_CROSSING_COMPARATOR);\n+                graph.getLayer(i).initXPositions();\n+                graph.getLayer(i).updateNodeIndices();\n@@ -941,14 +489,0 @@\n-\n-        @Override\n-        public void postCheck() {\n-\n-            HashSet<LayoutNode> visited = new HashSet<>();\n-            for (int i = 0; i < layers.length; i++) {\n-                for (LayoutNode n : layers[i]) {\n-                    assert !visited.contains(n);\n-                    assert n.layer == i;\n-                    visited.add(n);\n-                }\n-            }\n-\n-        }\n@@ -957,22 +491,1 @@\n-    private class AssignYCoordinates extends AlgorithmPart {\n-\n-        @Override\n-        protected void run() {\n-            int curY = 0;\n-\n-            for (List<LayoutNode> layer : layers) {\n-                int maxHeight = 0;\n-                int baseLine = 0;\n-                int bottomBaseLine = 0;\n-                for (LayoutNode n : layer) {\n-                    maxHeight = Math.max(maxHeight, n.height - n.yOffset - n.bottomYOffset);\n-                    baseLine = Math.max(baseLine, n.yOffset);\n-                    bottomBaseLine = Math.max(bottomBaseLine, n.bottomYOffset);\n-                }\n-\n-                int maxXOffset = 0;\n-                for (LayoutNode n : layer) {\n-                    if (n.vertex == null) {\n-                        \/\/ Dummy node\n-                        n.y = curY;\n-                        n.height = maxHeight + baseLine + bottomBaseLine;\n+    static class AssignXCoordinates {\n@@ -980,3 +493,3 @@\n-                    } else {\n-                        n.y = curY + baseLine + (maxHeight - (n.height - n.yOffset - n.bottomYOffset)) \/ 2 - n.yOffset;\n-                    }\n+        private static List<ArrayList<Integer>> space;\n+        private static List<ArrayList<LayoutNode>> downProcessingOrder;\n+        private static List<ArrayList<LayoutNode>> upProcessingOrder;\n@@ -984,4 +497,4 @@\n-                    for (LayoutEdge e : n.succs) {\n-                        int curXOffset = Math.abs(n.x - e.to.x);\n-                        maxXOffset = Math.max(curXOffset, maxXOffset);\n-                    }\n+        private static final Comparator<LayoutNode> nodeProcessingDownComparator = (n1, n2) -> {\n+            if (n1.isDummy()) {\n+                if (n2.isDummy()) {\n+                    return 0;\n@@ -989,3 +502,1 @@\n-\n-                curY += maxHeight + baseLine + bottomBaseLine;\n-                curY += layerOffset + ((int) (Math.sqrt(maxXOffset) * 1.5));\n+                return -1;\n@@ -993,15 +504,5 @@\n-        }\n-    }\n-\n-    private class CreateDummyNodes extends AlgorithmPart {\n-\n-        private int oldNodeCount;\n-\n-        @Override\n-        protected void preCheck() {\n-            for (LayoutNode n : nodes) {\n-                for (LayoutEdge e : n.succs) {\n-                    assert e.from != null;\n-                    assert e.from == n;\n-                    assert e.from.layer < e.to.layer;\n-                }\n+            if (n2.isDummy()) {\n+                return 1;\n+            }\n+            return n1.getInDegree() - n2.getInDegree();\n+        };\n@@ -1009,3 +510,4 @@\n-                for (LayoutEdge e : n.preds) {\n-                    assert e.to != null;\n-                    assert e.to == n;\n+        private static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n+            if (n1.isDummy()) {\n+                if (n2.isDummy()) {\n+                    return 0;\n@@ -1013,0 +515,1 @@\n+                return -1;\n@@ -1014,98 +517,5 @@\n-        }\n-\n-        @Override\n-        protected void run() {\n-            oldNodeCount = nodes.size();\n-\n-            if (combine == Combine.SAME_OUTPUTS) {\n-\n-                Comparator<LayoutEdge> comparator = Comparator.comparingInt(e -> e.to.layer);\n-                HashMap<Integer, List<LayoutEdge>> portHash = new HashMap<>();\n-                ArrayList<LayoutNode> currentNodes = new ArrayList<>(nodes);\n-                for (LayoutNode n : currentNodes) {\n-                    portHash.clear();\n-\n-                    ArrayList<LayoutEdge> succs = new ArrayList<>(n.succs);\n-                    HashMap<Integer, LayoutNode> topNodeHash = new HashMap<>();\n-                    HashMap<Integer, HashMap<Integer, LayoutNode>> bottomNodeHash = new HashMap<>();\n-                    for (LayoutEdge e : succs) {\n-                        assert e.from.layer < e.to.layer;\n-                        if (e.from.layer != e.to.layer - 1) {\n-                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength) {\n-                                assert maxLayerLength > 2;\n-                                e.to.preds.remove(e);\n-                                e.from.succs.remove(e);\n-\n-                                LayoutEdge topEdge;\n-\n-                                if (combine == Combine.SAME_OUTPUTS && topNodeHash.containsKey(e.relativeFrom)) {\n-                                    LayoutNode topNode = topNodeHash.get(e.relativeFrom);\n-                                    topEdge = new LayoutEdge();\n-                                    topEdge.relativeFrom = e.relativeFrom;\n-                                    topEdge.from = e.from;\n-                                    topEdge.relativeTo = topNode.width \/ 2;\n-                                    topEdge.to = topNode;\n-                                    topEdge.link = e.link;\n-                                    topEdge.vip = e.vip;\n-                                    e.from.succs.add(topEdge);\n-                                    topNode.preds.add(topEdge);\n-                                } else {\n-\n-                                    LayoutNode topNode = new LayoutNode();\n-                                    topNode.layer = e.from.layer + 1;\n-                                    topNode.width = DUMMY_WIDTH;\n-                                    topNode.height = DUMMY_HEIGHT;\n-                                    nodes.add(topNode);\n-                                    topEdge = new LayoutEdge();\n-                                    topEdge.relativeFrom = e.relativeFrom;\n-                                    topEdge.from = e.from;\n-                                    topEdge.relativeTo = 0;\n-                                    topEdge.to = topNode;\n-                                    topEdge.link = e.link;\n-                                    topEdge.vip = e.vip;\n-                                    e.from.succs.add(topEdge);\n-                                    topNode.preds.add(topEdge);\n-                                    topNodeHash.put(e.relativeFrom, topNode);\n-                                    bottomNodeHash.put(e.relativeFrom, new HashMap<>());\n-                                }\n-\n-                                HashMap<Integer, LayoutNode> hash = bottomNodeHash.get(e.relativeFrom);\n-\n-                                LayoutNode bottomNode;\n-                                if (hash.containsKey(e.to.layer)) {\n-                                    bottomNode = hash.get(e.to.layer);\n-                                } else {\n-\n-                                    bottomNode = new LayoutNode();\n-                                    bottomNode.layer = e.to.layer - 1;\n-                                    bottomNode.width = DUMMY_WIDTH;\n-                                    bottomNode.height = DUMMY_HEIGHT;\n-                                    nodes.add(bottomNode);\n-                                    hash.put(e.to.layer, bottomNode);\n-                                }\n-\n-                                LayoutEdge bottomEdge = new LayoutEdge();\n-                                bottomEdge.relativeTo = e.relativeTo;\n-                                bottomEdge.to = e.to;\n-                                bottomEdge.relativeFrom = bottomNode.width \/ 2;\n-                                bottomEdge.from = bottomNode;\n-                                bottomEdge.link = e.link;\n-                                bottomEdge.vip = e.vip;\n-                                e.to.preds.add(bottomEdge);\n-                                bottomNode.succs.add(bottomEdge);\n-\n-                            } else {\n-                                Integer i = e.relativeFrom;\n-                                if (!portHash.containsKey(i)) {\n-                                    portHash.put(i, new ArrayList<>());\n-                                }\n-                                portHash.get(i).add(e);\n-                            }\n-                        }\n-                    }\n-\n-                    succs = new ArrayList<>(n.succs);\n-                    for (LayoutEdge e : succs) {\n-\n-                        Integer i = e.relativeFrom;\n-                        if (portHash.containsKey(i)) {\n+            if (n2.isDummy()) {\n+                return 1;\n+            }\n+            return n1.getOutDegree() - n2.getOutDegree();\n+        };\n@@ -1113,2 +523,4 @@\n-                            List<LayoutEdge> list = portHash.get(i);\n-                            list.sort(comparator);\n+        public static void apply(LayoutGraph graph) {\n+            space = new ArrayList<>(graph.getLayerCount());\n+            downProcessingOrder = new ArrayList<>(graph.getLayerCount());\n+            upProcessingOrder = new ArrayList<>(graph.getLayerCount());\n@@ -1116,3 +528,5 @@\n-                            if (list.size() == 1) {\n-                                processSingleEdge(list.get(0));\n-                            } else {\n+            for (int i = 0; i < graph.getLayerCount(); i++) {\n+                \/\/ Add a new empty list for each layer\n+                space.add(new ArrayList<>());\n+                downProcessingOrder.add(new ArrayList<>());\n+                upProcessingOrder.add(new ArrayList<>());\n@@ -1120,4 +534,5 @@\n-                                int maxLayer = list.get(0).to.layer;\n-                                for (LayoutEdge curEdge : list) {\n-                                    maxLayer = Math.max(maxLayer, curEdge.to.layer);\n-                                }\n+                int curX = 0;\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    \/\/ Add the current position to space and increment curX\n+                    space.get(i).add(curX);\n+                    curX += n.getOuterWidth() + NODE_OFFSET;\n@@ -1125,30 +540,4 @@\n-                                int cnt = maxLayer - n.layer - 1;\n-                                LayoutEdge[] edges = new LayoutEdge[cnt];\n-                                LayoutNode[] nodes = new LayoutNode[cnt];\n-                                edges[0] = new LayoutEdge();\n-                                edges[0].from = n;\n-                                edges[0].relativeFrom = i;\n-                                edges[0].vip = e.vip;\n-                                n.succs.add(edges[0]);\n-\n-                                nodes[0] = new LayoutNode();\n-                                nodes[0].width = dummyWidth;\n-                                nodes[0].height = dummyHeight;\n-                                nodes[0].layer = n.layer + 1;\n-                                nodes[0].preds.add(edges[0]);\n-                                edges[0].to = nodes[0];\n-                                edges[0].relativeTo = nodes[0].width \/ 2;\n-                                for (int j = 1; j < cnt; j++) {\n-                                    edges[j] = new LayoutEdge();\n-                                    edges[j].vip = e.vip;\n-                                    edges[j].from = nodes[j - 1];\n-                                    edges[j].relativeFrom = nodes[j - 1].width \/ 2;\n-                                    nodes[j - 1].succs.add(edges[j]);\n-                                    nodes[j] = new LayoutNode();\n-                                    nodes[j].width = dummyWidth;\n-                                    nodes[j].height = dummyHeight;\n-                                    nodes[j].layer = n.layer + j + 1;\n-                                    nodes[j].preds.add(edges[j]);\n-                                    edges[j].to = nodes[j];\n-                                    edges[j].relativeTo = nodes[j].width \/ 2;\n-                                }\n+                    \/\/ Add the current node to processing orders\n+                    downProcessingOrder.get(i).add(n);\n+                    upProcessingOrder.get(i).add(n);\n+                }\n@@ -1156,9 +545,4 @@\n-                                for (LayoutEdge curEdge : list) {\n-                                    assert curEdge.to.layer - n.layer - 2 >= 0;\n-                                    assert curEdge.to.layer - n.layer - 2 < cnt;\n-                                    LayoutNode anchor = nodes[curEdge.to.layer - n.layer - 2];\n-                                    anchor.succs.add(curEdge);\n-                                    curEdge.from = anchor;\n-                                    curEdge.relativeFrom = anchor.width \/ 2;\n-                                    n.succs.remove(curEdge);\n-                                }\n+                \/\/ Sort the processing orders\n+                downProcessingOrder.get(i).sort(nodeProcessingDownComparator);\n+                upProcessingOrder.get(i).sort(nodeProcessingUpComparator);\n+            }\n@@ -1166,1 +550,3 @@\n-                            }\n+            for (LayoutNode n : graph.getLayoutNodes()) {\n+                n.setX(space.get(n.getLayer()).get(n.getPos()));\n+            }\n@@ -1168,13 +554,2 @@\n-                            portHash.remove(i);\n-                        }\n-                    }\n-                }\n-            } else if (combine == Combine.SAME_INPUTS) {\n-                throw new UnsupportedOperationException(\"Currently not supported\");\n-            } else {\n-                ArrayList<LayoutNode> currentNodes = new ArrayList<>(nodes);\n-                for (LayoutNode n : currentNodes) {\n-                    for (LayoutEdge e : List.copyOf(n.succs)) {\n-                        processSingleEdge(e);\n-                    }\n-                }\n+            for (LayoutNode n : graph.getDummyNodes()) {\n+                n.setX(space.get(n.getLayer()).get(n.getPos()));\n@@ -1182,1 +557,0 @@\n-        }\n@@ -1184,7 +558,5 @@\n-        private void processSingleEdge(LayoutEdge e) {\n-            LayoutNode n = e.to;\n-            if (e.to.layer - 1 > e.from.layer) {\n-                LayoutEdge last = e;\n-                for (int i = n.layer - 1; i > last.from.layer; i--) {\n-                    last = addBetween(last, i);\n-                }\n+            for (int i = 0; i < SWEEP_ITERATIONS; i++) {\n+                sweepDown(graph);\n+                adjustSpace(graph);\n+                sweepUp(graph);\n+                adjustSpace(graph);\n@@ -1192,1 +564,0 @@\n-        }\n@@ -1194,20 +565,3 @@\n-        private LayoutEdge addBetween(LayoutEdge e, int layer) {\n-            LayoutNode n = new LayoutNode();\n-            n.width = DUMMY_WIDTH;\n-            n.height = DUMMY_HEIGHT;\n-            n.layer = layer;\n-            n.succs.add(e);\n-            nodes.add(n);\n-            LayoutEdge result = new LayoutEdge();\n-            result.vip = e.vip;\n-            n.preds.add(result);\n-            result.to = n;\n-            result.relativeTo = n.width \/ 2;\n-            result.from = e.from;\n-            result.relativeFrom = e.relativeFrom;\n-            result.link = e.link;\n-            e.relativeFrom = n.width \/ 2;\n-            e.from.succs.remove(e);\n-            e.from.succs.add(result);\n-            e.from = n;\n-            return result;\n+            sweepDown(graph);\n+            adjustSpace(graph);\n+            sweepUp(graph);\n@@ -1216,3 +570,6 @@\n-        @Override\n-        public void printStatistics() {\n-            System.out.println(\"Dummy nodes created: \" + (nodes.size() - oldNodeCount));\n+        private static void adjustSpace(LayoutGraph graph) {\n+            for (int i = 0; i < graph.getLayerCount(); i++) {\n+                for (LayoutNode n : graph.getLayer(i)) {\n+                    space.get(i).add(n.getX());\n+                }\n+            }\n@@ -1221,6 +578,6 @@\n-        @Override\n-        public void postCheck() {\n-            ArrayList<LayoutNode> currentNodes = new ArrayList<>(nodes);\n-            for (LayoutNode n : currentNodes) {\n-                for (LayoutEdge e : n.succs) {\n-                    assert e.from.layer == e.to.layer - 1;\n+        private static void sweepUp(LayoutGraph graph) {\n+            for (int i = graph.getLayerCount() - 1; i >= 0; i--) {\n+                NodeRow r = new NodeRow(space.get(i));\n+                for (LayoutNode n : upProcessingOrder.get(i)) {\n+                    int optimal = n.calculateOptimalXFromSuccessors(true);\n+                    r.insert(n, optimal);\n@@ -1229,0 +586,1 @@\n+        }\n@@ -1230,4 +588,6 @@\n-            for (int i = 0; i < layers.length; i++) {\n-                assert layers[i].size() > 0;\n-                for (LayoutNode n : layers[i]) {\n-                    assert n.layer == i;\n+        private static void sweepDown(LayoutGraph graph) {\n+            for (int i = 1; i < graph.getLayerCount(); i++) {\n+                NodeRow r = new NodeRow(space.get(i));\n+                for (LayoutNode n : downProcessingOrder.get(i)) {\n+                    int optimal = n.calculateOptimalXFromPredecessors(true);\n+                    r.insert(n, optimal);\n@@ -1239,1 +599,1 @@\n-    private class AssignLayers extends AlgorithmPart {\n+    public static class NodeRow {\n@@ -1241,5 +601,6 @@\n-        @Override\n-        public void preCheck() {\n-            for (LayoutNode n : nodes) {\n-                assert n.layer == -1;\n-            }\n+        private final TreeSet<LayoutNode> treeSet;\n+        private final ArrayList<Integer> space;\n+\n+        public NodeRow(ArrayList<Integer> space) {\n+            treeSet = new TreeSet<>(NODE_POS_COMPARATOR);\n+            this.space = space;\n@@ -1248,4 +609,4 @@\n-        @Override\n-        protected void run() {\n-            assignLayerDownwards();\n-            assignLayerUpwards();\n+        public int offset(LayoutNode n1, LayoutNode n2) {\n+            int v1 = space.get(n1.getPos()) + n1.getOuterWidth();\n+            int v2 = space.get(n2.getPos());\n+            return v2 - v1;\n@@ -1254,7 +615,9 @@\n-        private void assignLayerDownwards() {\n-            ArrayList<LayoutNode> hull = new ArrayList<>();\n-            for (LayoutNode n : nodes) {\n-                if (n.preds.isEmpty()) {\n-                    hull.add(n);\n-                    n.layer = 0;\n-                }\n+        public void insert(LayoutNode n, int pos) {\n+\n+            SortedSet<LayoutNode> headSet = treeSet.headSet(n);\n+\n+            LayoutNode leftNeighbor;\n+            int minX = Integer.MIN_VALUE;\n+            if (!headSet.isEmpty()) {\n+                leftNeighbor = headSet.last();\n+                minX = leftNeighbor.getOuterRight() + offset(leftNeighbor, n);\n@@ -1263,18 +626,3 @@\n-            int z = minLayerDifference;\n-            while (!hull.isEmpty()) {\n-                ArrayList<LayoutNode> newSet = new ArrayList<>();\n-                for (LayoutNode n : hull) {\n-                    for (LayoutEdge se : n.succs) {\n-                        LayoutNode s = se.to;\n-                        if (s.layer != -1) {\n-                            \/\/ This node was assigned before.\n-                        } else {\n-                            boolean unassignedPred = false;\n-                            for (LayoutEdge pe : s.preds) {\n-                                LayoutNode p = pe.from;\n-                                if (p.layer == -1 || p.layer >= z) {\n-                                    \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n-                                    unassignedPred = true;\n-                                    break;\n-                                }\n-                            }\n+            if (pos < minX) {\n+                n.setX(minX);\n+            } else {\n@@ -1282,8 +630,6 @@\n-                            if (unassignedPred) {\n-                                \/\/ This successor node can not yet be assigned.\n-                            } else {\n-                                s.layer = z;\n-                                newSet.add(s);\n-                            }\n-                        }\n-                    }\n+                LayoutNode rightNeighbor;\n+                SortedSet<LayoutNode> tailSet = treeSet.tailSet(n);\n+                int maxX = Integer.MAX_VALUE;\n+                if (!tailSet.isEmpty()) {\n+                    rightNeighbor = tailSet.first();\n+                    maxX = rightNeighbor.getX() - offset(n, rightNeighbor) - n.getOuterWidth();\n@@ -1292,2 +638,1 @@\n-                hull = newSet;\n-                z += minLayerDifference;\n+                n.setX(Math.min(pos, maxX));\n@@ -1296,4 +641,1 @@\n-            layerCount = z - minLayerDifference;\n-            for (LayoutNode n : nodes) {\n-                n.layer = (layerCount - 1 - n.layer);\n-            }\n+            treeSet.add(n);\n@@ -1301,0 +643,1 @@\n+    }\n@@ -1302,9 +645,1 @@\n-        private void assignLayerUpwards() {\n-            ArrayList<LayoutNode> hull = new ArrayList<>();\n-            for (LayoutNode n : nodes) {\n-                if (n.succs.isEmpty()) {\n-                    hull.add(n);\n-                } else {\n-                    n.layer = -1;\n-                }\n-            }\n+    public static class WriteResult {\n@@ -1312,19 +647,30 @@\n-            int z = minLayerDifference;\n-            while (!hull.isEmpty()) {\n-                ArrayList<LayoutNode> newSet = new ArrayList<>();\n-                for (LayoutNode n : hull) {\n-                    if (n.layer < z) {\n-                        for (LayoutEdge se : n.preds) {\n-                            LayoutNode s = se.from;\n-                            if (s.layer != -1) {\n-                                \/\/ This node was assigned before.\n-                            } else {\n-                                boolean unassignedSucc = false;\n-                                for (LayoutEdge pe : s.succs) {\n-                                    LayoutNode p = pe.to;\n-                                    if (p.layer == -1 || p.layer >= z) {\n-                                        \/\/ This now has an unscheduled successor or a successor that was scheduled only in this round.\n-                                        unassignedSucc = true;\n-                                        break;\n-                                    }\n-                                }\n+        private static HashMap<Link, List<Point>> computeLinkPositions(LayoutGraph graph) {\n+            HashMap<Link, List<Point>> linkToSplitEndPoints = new HashMap<>();\n+            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n+\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                for (LayoutEdge predEdge : layoutNode.getPredecessors()) {\n+                    LayoutNode fromNode = predEdge.getFrom();\n+                    LayoutNode toNode = predEdge.getTo();\n+\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    \/\/ input edge stub\n+                    linkPoints.add(new Point(predEdge.getEndX(), predEdge.getEndY()));\n+                    linkPoints.add(new Point(predEdge.getEndX(), graph.getLayer(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+\n+                    LayoutEdge curEdge = predEdge;\n+                    while (fromNode.isDummy() && fromNode.hasPredecessors()) {\n+                        linkPoints.add(new Point(fromNode.getCenterX(), graph.getLayer(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        linkPoints.add(new Point(fromNode.getCenterX(), graph.getLayer(fromNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        curEdge = fromNode.getPredecessors().get(0);\n+                        fromNode = curEdge.getFrom();\n+                    }\n+                    linkPoints.add(new Point(curEdge.getStartX(), graph.getLayer(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                    \/\/ output edge stub\n+                    linkPoints.add(new Point(curEdge.getStartX(), curEdge.getStartY()));\n+\n+                    if (predEdge.isReversed()) {\n+                        for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(predEdge.getLink())) {\n+                            Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                            linkPoints.add(0, endPoint);\n+                        }\n@@ -1332,5 +678,5 @@\n-                                if (unassignedSucc) {\n-                                    \/\/ This predecessor node can not yet be assigned.\n-                                } else {\n-                                    s.layer = z;\n-                                    newSet.add(s);\n+                        if (!fromNode.isDummy()) {\n+                            if (fromNode.getReversedLinkStartPoints().containsKey(predEdge.getLink())) {\n+                                for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(predEdge.getLink())) {\n+                                    Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                    linkPoints.add(startPoint);\n@@ -1341,1 +687,1 @@\n-                        newSet.add(n);\n+                        Collections.reverse(linkPoints);\n@@ -1343,1 +689,0 @@\n-                }\n@@ -1345,39 +690,3 @@\n-                hull = newSet;\n-                z += minLayerDifference;\n-            }\n-\n-            layerCount = z - minLayerDifference;\n-\n-            for (LayoutNode n : nodes) {\n-                n.layer = (layerCount - 1 - n.layer);\n-            }\n-        }\n-\n-        @Override\n-        public void postCheck() {\n-            for (LayoutNode n : nodes) {\n-                assert n.layer >= 0;\n-                assert n.layer < layerCount;\n-                for (LayoutEdge e : n.succs) {\n-                    assert e.from.layer < e.to.layer;\n-                }\n-            }\n-        }\n-    }\n-\n-    private class ReverseEdges extends AlgorithmPart {\n-\n-        private HashSet<LayoutNode> visited;\n-        private HashSet<LayoutNode> active;\n-\n-        @Override\n-        protected void run() {\n-\n-            \/\/ Reverse inputs of roots\n-            for (LayoutNode node : nodes) {\n-                if (node.vertex.isRoot()) {\n-                    boolean ok = true;\n-                    for (LayoutEdge e : node.preds) {\n-                        if (e.from.vertex.isRoot()) {\n-                            ok = false;\n-                            break;\n+                    if (fromNode.isDummy()) {\n+                        if (predEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n@@ -1385,3 +694,4 @@\n-                    }\n-                    if (ok) {\n-                        reverseAllInputs(node);\n+                        linkToSplitEndPoints.put(predEdge.getLink(), linkPoints);\n+\n+                    } else {\n+                        linkPositions.put(predEdge.getLink(), linkPoints);\n@@ -1392,6 +702,3 @@\n-            \/\/ Start DFS and reverse back edges\n-            visited = new HashSet<>();\n-            active = new HashSet<>();\n-            for (LayoutNode node : nodes) {\n-                DFS(node);\n-            }\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                for (LayoutEdge succEdge : layoutNode.getSuccessors()) {\n+                    if (succEdge.getLink() == null) continue;\n@@ -1399,1 +706,2 @@\n-            for (LayoutNode node : nodes) {\n+                    LayoutNode fromNode = succEdge.getFrom();\n+                    LayoutNode toNode = succEdge.getTo();\n@@ -1401,1 +709,3 @@\n-                SortedSet<Integer> reversedDown = new TreeSet<>();\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    linkPoints.add(new Point(succEdge.getStartX(), fromNode.getBottom()));\n+                    linkPoints.add(new Point(succEdge.getStartX(), graph.getLayer(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n@@ -1403,7 +713,6 @@\n-                boolean hasSelfEdge = false;\n-                for (LayoutEdge e : node.succs) {\n-                    if (reversedLinks.contains(e.link)) {\n-                        reversedDown.add(e.relativeFrom);\n-                        if (e.from == e.to) {\n-                            hasSelfEdge = true;\n-                        }\n+                    LayoutEdge curEdge = succEdge;\n+                    while (toNode.isDummy() && toNode.hasSuccessors()) {\n+                        linkPoints.add(new Point(toNode.getCenterX(), graph.getLayer(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        linkPoints.add(new Point(toNode.getCenterX(), graph.getLayer(toNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        curEdge = toNode.getSuccessors().get(0);\n+                        toNode = curEdge.getTo();\n@@ -1411,1 +720,2 @@\n-                }\n+                    linkPoints.add(new Point(curEdge.getEndX(), graph.getLayer(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                    linkPoints.add(new Point(curEdge.getEndX(), toNode.getTop()));\n@@ -1413,5 +723,2 @@\n-                \/\/ Whether the node has non-self reversed edges going downwards.\n-                \/\/ If so, reversed edges going upwards are drawn to the left.\n-                boolean hasReversedDown =\n-                    reversedDown.size() > 0 &&\n-                    !(reversedDown.size() == 1 && hasSelfEdge);\n+                    if (succEdge.isReversed()) {\n+                        Collections.reverse(linkPoints);\n@@ -1419,23 +726,5 @@\n-                SortedSet<Integer> reversedUp = null;\n-                if (hasReversedDown) {\n-                    reversedUp = new TreeSet<>();\n-                } else {\n-                    reversedUp = new TreeSet<>(Collections.reverseOrder());\n-                }\n-\n-                for (LayoutEdge e : node.preds) {\n-                    if (reversedLinks.contains(e.link)) {\n-                        reversedUp.add(e.relativeTo);\n-                    }\n-                }\n-\n-                final int offset = xOffset + DUMMY_WIDTH;\n-\n-                int curY = 0;\n-                int curWidth = node.width + reversedDown.size() * offset;\n-                for (int pos : reversedDown) {\n-                    ArrayList<LayoutEdge> reversedSuccs = new ArrayList<>();\n-                    for (LayoutEdge e : node.succs) {\n-                        if (e.relativeFrom == pos && reversedLinks.contains(e.link)) {\n-                            reversedSuccs.add(e);\n-                            e.relativeFrom = curWidth;\n+                        if (fromNode.getReversedLinkStartPoints().containsKey(succEdge.getLink())) {\n+                            for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(succEdge.getLink())) {\n+                                Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                linkPoints.add(startPoint);\n+                            }\n@@ -1443,28 +732,0 @@\n-                    }\n-\n-                    ArrayList<Point> startPoints = new ArrayList<>();\n-                    startPoints.add(new Point(curWidth, curY));\n-                    startPoints.add(new Point(pos, curY));\n-                    startPoints.add(new Point(pos, reversedDown.size() * offset));\n-                    for (LayoutEdge e : reversedSuccs) {\n-                        reversedLinkStartPoints.put(e.link, startPoints);\n-                    }\n-\n-                    node.inOffsets.put(pos, -curY);\n-                    curY += offset;\n-                    node.height += offset;\n-                    node.yOffset += offset;\n-                    curWidth -= offset;\n-                }\n-\n-                int widthFactor = reversedDown.size();\n-                if (hasSelfEdge) {\n-                    widthFactor--;\n-                }\n-                node.width += widthFactor * offset;\n-\n-                int curX = 0;\n-                int minX = 0;\n-                if (hasReversedDown) {\n-                    minX = -offset * reversedUp.size();\n-                }\n@@ -1472,9 +733,6 @@\n-                int oldNodeHeight = node.height;\n-                for (int pos : reversedUp) {\n-                    ArrayList<LayoutEdge> reversedPreds = new ArrayList<>();\n-                    for (LayoutEdge e : node.preds) {\n-                        if (e.relativeTo == pos && reversedLinks.contains(e.link)) {\n-                            if (hasReversedDown) {\n-                                e.relativeTo = curX - offset;\n-                            } else {\n-                                e.relativeTo = node.width + offset;\n+                        if (!toNode.isDummy()) {\n+                            if (toNode.getReversedLinkEndPoints().containsKey(succEdge.getLink())) {\n+                                for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(succEdge.getLink())) {\n+                                    Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                                    linkPoints.add(0, endPoint);\n+                                }\n@@ -1482,2 +740,0 @@\n-\n-                            reversedPreds.add(e);\n@@ -1486,15 +742,0 @@\n-                    node.height += offset;\n-                    ArrayList<Point> endPoints = new ArrayList<>();\n-\n-                    node.width += offset;\n-                    if (hasReversedDown) {\n-                        curX -= offset;\n-                        endPoints.add(new Point(curX, node.height));\n-                    } else {\n-                        curX += offset;\n-                        endPoints.add(new Point(node.width, node.height));\n-                    }\n-\n-                    node.outOffsets.put(pos - minX, curX);\n-                    curX += offset;\n-                    node.bottomYOffset += offset;\n@@ -1502,4 +743,9 @@\n-                    endPoints.add(new Point(pos, node.height));\n-                    endPoints.add(new Point(pos, oldNodeHeight));\n-                    for (LayoutEdge e : reversedPreds) {\n-                        reversedLinkEndPoints.put(e.link, endPoints);\n+                    if (linkToSplitEndPoints.containsKey(succEdge.getLink())) {\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                        linkPoints.add(null);\n+                        linkPoints.addAll(linkToSplitEndPoints.get(succEdge.getLink()));\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n@@ -1507,0 +753,1 @@\n+                    linkPositions.put(succEdge.getLink(), linkPoints);\n@@ -1508,0 +755,1 @@\n+            }\n@@ -1509,7 +757,9 @@\n-                if (minX < 0) {\n-                    for (LayoutEdge e : node.preds) {\n-                        e.relativeTo -= minX;\n-                    }\n-\n-                    for (LayoutEdge e : node.succs) {\n-                        e.relativeFrom -= minX;\n+            if (graph.showSelfEdges()) {\n+                for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                    if (layoutNode.hasSelfEdge()) {\n+                        LayoutEdge selfEdge = layoutNode.getSelfEdge();\n+                        ArrayList<Point> points = layoutNode.getSelfEdgePoints();\n+                        for (Point point : points) {\n+                            point.setLocation(point.getX() + layoutNode.getLeft(), point.getY() + layoutNode.getTop());\n+                        }\n+                        linkPositions.put(selfEdge.getLink(), points);\n@@ -1517,3 +767,0 @@\n-\n-                    node.xOffset = -minX;\n-                    node.width += -minX;\n@@ -1523,0 +770,1 @@\n+            return linkPositions;\n@@ -1525,7 +773,3 @@\n-        private void DFS(LayoutNode startNode) {\n-            if (visited.contains(startNode)) {\n-                return;\n-            }\n-\n-            Stack<LayoutNode> stack = new Stack<>();\n-            stack.push(startNode);\n+        public static void apply(LayoutGraph graph) {\n+            \/\/ Assign Y coordinates\n+            graph.positionLayers();\n@@ -1533,2 +777,2 @@\n-            while (!stack.empty()) {\n-                LayoutNode node = stack.pop();\n+            int minX = Integer.MAX_VALUE;\n+            int minY = Integer.MAX_VALUE;\n@@ -1536,5 +780,1 @@\n-                if (visited.contains(node)) {\n-                    \/\/ Node no longer active\n-                    active.remove(node);\n-                    continue;\n-                }\n+            HashMap<Link, List<Point>> linkPositions = computeLinkPositions(graph);\n@@ -1542,13 +782,5 @@\n-                \/\/ Repush immediately to know when no longer active\n-                stack.push(node);\n-                visited.add(node);\n-                active.add(node);\n-\n-                ArrayList<LayoutEdge> succs = new ArrayList<>(node.succs);\n-                for (LayoutEdge e : succs) {\n-                    if (active.contains(e.to)) {\n-                        assert visited.contains(e.to);\n-                        \/\/ Encountered back edge\n-                        reverseEdge(e);\n-                    } else if (!visited.contains(e.to) && (linksToFollow.size() == 0 || linksToFollow.contains(e.link))) {\n-                        stack.push(e.to);\n+            for (List<Point> points : linkPositions.values()) {\n+                for (Point point : points) {\n+                    if (point != null) {\n+                        minX = Math.min(minX, point.x);\n+                        minY = Math.min(minY, point.y);\n@@ -1558,1 +790,0 @@\n-        }\n@@ -1560,13 +791,3 @@\n-        private void reverseAllInputs(LayoutNode node) {\n-            for (LayoutEdge e : node.preds) {\n-                assert !reversedLinks.contains(e.link);\n-                reversedLinks.add(e.link);\n-                node.succs.add(e);\n-                e.from.preds.add(e);\n-                e.from.succs.remove(e);\n-                int oldRelativeFrom = e.relativeFrom;\n-                int oldRelativeTo = e.relativeTo;\n-                e.to = e.from;\n-                e.from = node;\n-                e.relativeFrom = oldRelativeTo;\n-                e.relativeTo = oldRelativeFrom;\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                minX = Math.min(minX, layoutNode.getX());\n+                minY = Math.min(minY, layoutNode.getY());\n@@ -1574,6 +795,0 @@\n-            node.preds.clear();\n-        }\n-\n-        private void reverseEdge(LayoutEdge e) {\n-            assert !reversedLinks.contains(e.link);\n-            reversedLinks.add(e.link);\n@@ -1581,40 +796,3 @@\n-            LayoutNode oldFrom = e.from;\n-            LayoutNode oldTo = e.to;\n-            int oldRelativeFrom = e.relativeFrom;\n-            int oldRelativeTo = e.relativeTo;\n-\n-            e.from = oldTo;\n-            e.to = oldFrom;\n-            e.relativeFrom = oldRelativeTo;\n-            e.relativeTo = oldRelativeFrom;\n-\n-            oldFrom.succs.remove(e);\n-            oldFrom.preds.add(e);\n-            oldTo.preds.remove(e);\n-            oldTo.succs.add(e);\n-        }\n-\n-        @Override\n-        public void postCheck() {\n-\n-            for (LayoutNode n : nodes) {\n-\n-                HashSet<LayoutNode> curVisited = new HashSet<>();\n-                Queue<LayoutNode> queue = new LinkedList<>();\n-                for (LayoutEdge e : n.succs) {\n-                    LayoutNode s = e.to;\n-                    queue.add(s);\n-                    curVisited.add(s);\n-                }\n-\n-                while (!queue.isEmpty()) {\n-                    LayoutNode curNode = queue.remove();\n-\n-                    for (LayoutEdge e : curNode.succs) {\n-                        assert e.to != n;\n-                        if (!curVisited.contains(e.to)) {\n-                            queue.add(e.to);\n-                            curVisited.add(e.to);\n-                        }\n-                    }\n-                }\n+            for (LayoutNode dummyNode : graph.getDummyNodes()) {\n+                minX = Math.min(minX, dummyNode.getX());\n+                minY = Math.min(minY, dummyNode.getY());\n@@ -1622,6 +800,0 @@\n-        }\n-    }\n-    private final Comparator<Link> linkComparator = (l1, l2) -> {\n-        if (l1.isVIP() && !l2.isVIP()) {\n-            return -1;\n-        }\n@@ -1629,38 +801,2 @@\n-        if (!l1.isVIP() && l2.isVIP()) {\n-            return 1;\n-        }\n-\n-        int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n-        if (result != 0) {\n-            return result;\n-        }\n-        result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n-        if (result != 0) {\n-            return result;\n-        }\n-        result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n-        if (result != 0) {\n-            return result;\n-        }\n-        result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n-        return result;\n-    };\n-\n-    private class BuildDatastructure extends AlgorithmPart {\n-\n-        @Override\n-        protected void run() {\n-            \/\/ Set up nodes\n-            List<Vertex> vertices = new ArrayList<>(graph.getVertices());\n-            \/\/ Order roots first to create more natural layer assignments.\n-            vertices.sort((Vertex a, Vertex b) ->\n-                    a.isRoot() == b.isRoot() ? a.compareTo(b) : Boolean.compare(b.isRoot(), a.isRoot()));\n-\n-            for (Vertex v : vertices) {\n-                LayoutNode node = new LayoutNode();\n-                Dimension size = v.getSize();\n-                node.width = (int) size.getWidth();\n-                node.height = (int) size.getHeight();\n-                node.vertex = v;\n-                nodes.add(node);\n-                vertexToLayoutNode.put(v, node);\n+            for (LayoutLayer layer : graph.getLayers()) {\n+                minY = Math.min(minY, layer.getTop());\n@@ -1669,15 +805,3 @@\n-            \/\/ Set up edges\n-            List<Link> links = new ArrayList<>(graph.getLinks());\n-            links.sort(linkComparator);\n-            for (Link l : links) {\n-                LayoutEdge edge = new LayoutEdge();\n-                assert vertexToLayoutNode.containsKey(l.getFrom().getVertex());\n-                assert vertexToLayoutNode.containsKey(l.getTo().getVertex());\n-                edge.from = vertexToLayoutNode.get(l.getFrom().getVertex());\n-                edge.to = vertexToLayoutNode.get(l.getTo().getVertex());\n-                edge.relativeFrom = l.getFrom().getRelativePosition().x;\n-                edge.relativeTo = l.getTo().getRelativePosition().x;\n-                edge.link = l;\n-                edge.vip = l.isVIP();\n-                edge.from.succs.add(edge);\n-                edge.to.preds.add(edge);\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                layoutNode.setX(layoutNode.getX() - minX);\n+                layoutNode.setY(layoutNode.getY() - minY);\n@@ -1685,13 +809,3 @@\n-\n-            for (Link l : importantLinks) {\n-                if (!vertexToLayoutNode.containsKey(l.getFrom().getVertex())\n-                        || vertexToLayoutNode.containsKey(l.getTo().getVertex())) {\n-                    continue;\n-                }\n-                LayoutNode from = vertexToLayoutNode.get(l.getFrom().getVertex());\n-                LayoutNode to = vertexToLayoutNode.get(l.getTo().getVertex());\n-                for (LayoutEdge e : from.succs) {\n-                    if (e.to == to) {\n-                        linksToFollow.add(e.link);\n-                    }\n-                }\n+            for (LayoutNode dummyNode : graph.getDummyNodes()) {\n+                dummyNode.setX(dummyNode.getX() - minX);\n+                dummyNode.setY(dummyNode.getY() - minY);\n@@ -1699,4 +813,0 @@\n-        }\n-\n-        @Override\n-        public void postCheck() {\n@@ -1704,7 +814,3 @@\n-            assert vertexToLayoutNode.keySet().size() == nodes.size();\n-            assert nodes.size() == graph.getVertices().size();\n-\n-            for (Vertex v : graph.getVertices()) {\n-\n-                LayoutNode node = vertexToLayoutNode.get(v);\n-                assert node != null;\n+            for (LayoutLayer layer : graph.getLayers()) {\n+                layer.moveLayerVertically(-minY);\n+            }\n@@ -1712,3 +818,5 @@\n-                for (LayoutEdge e : node.succs) {\n-                    assert e.from == node;\n-                }\n+            \/\/ Shift vertices by minX\/minY\n+            for (LayoutNode layoutNode : graph.getLayoutNodes()) {\n+                Vertex vertex = layoutNode.getVertex();\n+                vertex.setPosition(new Point(layoutNode.getLeft(), layoutNode.getTop()));\n+            }\n@@ -1716,2 +824,9 @@\n-                for (LayoutEdge e : node.preds) {\n-                    assert e.to == node;\n+            \/\/ shift links by minX\/minY\n+            for (Map.Entry<Link, List<Point>> entry : linkPositions.entrySet()) {\n+                Link link = entry.getKey();\n+                List<Point> points = entry.getValue();\n+                for (Point p : points) {\n+                    if (p != null) {\n+                        p.x -= minX;\n+                        p.y -= minY;\n+                    }\n@@ -1720,0 +835,2 @@\n+                \/\/ write points back to links\n+                link.setControlPoints(points);\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":560,"deletions":1443,"binary":false,"changes":2003,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.LAYER_OFFSET;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.NODE_OFFSET;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.util.Statistics;\n@@ -36,4 +36,0 @@\n-    public static final int DUMMY_HEIGHT = 1;\n-    public static final int DUMMY_WIDTH = 1;\n-    public static final int X_OFFSET = 8;\n-    public static final int LAYER_OFFSET = 8;\n@@ -46,3 +42,1 @@\n-    private HashMap<Link, List<Point>> reversedLinkStartPoints;\n-    private HashMap<Link, List<Point>> reversedLinkEndPoints;\n-    private HashMap<Integer, List<LayoutNode>> layers;\n+    private HashMap<Integer, LayoutLayer> layers;\n@@ -97,1 +91,1 @@\n-        manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n+        manager = new HierarchicalLayoutManager();\n@@ -112,2 +106,2 @@\n-        if (n.preds.isEmpty() && n.succs.isEmpty()) {\n-            return n.x;\n+        if (n.getPredecessors().isEmpty() && n.getSuccessors().isEmpty()) {\n+            return n.getX();\n@@ -116,1 +110,1 @@\n-        int[] values = new int[n.preds.size() + n.succs.size()];\n+        int[] values = new int[n.getPredecessors().size() + n.getSuccessors().size()];\n@@ -119,2 +113,2 @@\n-        for (LayoutEdge e : n.preds) {\n-            values[i] = e.from.x + e.relativeFrom - e.relativeTo;\n+        for (LayoutEdge e : n.getPredecessors()) {\n+            values[i] = e.getFrom().getX() + e.getRelativeFromX() - e.getRelativeToX();\n@@ -124,2 +118,2 @@\n-        for (LayoutEdge e : n.succs) {\n-            values[i] = e.to.x + e.relativeTo - e.relativeFrom;\n+        for (LayoutEdge e : n.getSuccessors()) {\n+            values[i] = e.getTo().getX() + e.getRelativeToX() - e.getRelativeFromX();\n@@ -129,1 +123,1 @@\n-        return Statistics.median(values);\n+        return median(values);\n@@ -132,0 +126,22 @@\n+    public static int median(int[] values) {\n+        Arrays.sort(values);\n+        if (values.length % 2 == 0) {\n+            return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n+        } else {\n+            return values[values.length \/ 2];\n+        }\n+    }\n+\n+    public static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n+        if (n1.getVertex() == null) {\n+            if (n2.getVertex() == null) {\n+                return 0;\n+            }\n+            return -1;\n+        }\n+        if (n2.getVertex() == null) {\n+            return 1;\n+        }\n+        return n1.getSuccessors().size() - n2.getSuccessors().size();\n+    };\n+\n@@ -141,1 +157,1 @@\n-        nodes.sort(HierarchicalLayoutManager.nodePositionComparator);\n+        nodes.sort(Comparator.comparingInt(LayoutNode::getPos));\n@@ -146,1 +162,1 @@\n-            curX += n.width + X_OFFSET;\n+            curX += n.getOuterWidth() + NODE_OFFSET;\n@@ -150,1 +166,1 @@\n-        nodeProcessingOrder.sort(HierarchicalLayoutManager.nodeProcessingUpComparator);\n+        nodeProcessingOrder.sort(nodeProcessingUpComparator);\n@@ -160,2 +176,2 @@\n-            n.succs.removeIf(e -> !nodes.contains(e.to));\n-            n.preds.removeIf(e -> !nodes.contains(e.from));\n+            n.getSuccessorsRaw().removeIf(e -> !nodes.contains(e.getTo()));\n+            n.getPredecessorsRaw().removeIf(e -> !nodes.contains(e.getFrom()));\n@@ -251,2 +267,2 @@\n-                    if (vertexToLayoutNode.get(l.getFrom().getVertex()).layer > vertexToLayoutNode\n-                            .get(l.getTo().getVertex()).layer) {\n+                    if (vertexToLayoutNode.get(l.getFrom().getVertex()).getLayer() > vertexToLayoutNode\n+                            .get(l.getTo().getVertex()).getLayer()) {\n@@ -268,1 +284,1 @@\n-        assert fromNode.layer > toNode.layer;\n+        assert fromNode.getLayer() > toNode.getLayer();\n@@ -276,132 +292,1 @@\n-        \/\/ Reset node data in case there were previous reversed edges\n-        node.width = (int) node.vertex.getSize().getWidth();\n-        node.height = (int) node.vertex.getSize().getHeight();\n-        node.yOffset = 0;\n-        node.bottomYOffset = 0;\n-        node.xOffset = 0;\n-        node.inOffsets.clear();\n-        node.outOffsets.clear();\n-\n-        SortedSet<Integer> reversedDown = new TreeSet<>();\n-\n-        \/\/ Reset relativeFrom for all succ edges\n-        for (LayoutEdge e : node.succs) {\n-            if (e.link == null) {\n-                continue;\n-            }\n-            e.relativeFrom = e.link.getFrom().getRelativePosition().x;\n-            if (reversedLinks.contains(e.link)) {\n-                e.relativeFrom = e.link.getTo().getRelativePosition().x;\n-                reversedDown.add(e.relativeFrom);\n-            }\n-        }\n-\n-        \/\/ Whether the node has non-self reversed edges going downwards.\n-        \/\/ If so, reversed edges going upwards are drawn to the left.\n-        boolean hasReversedDown = !reversedDown.isEmpty();\n-\n-        SortedSet<Integer> reversedUp;\n-        if (hasReversedDown) {\n-            reversedUp = new TreeSet<>();\n-        } else {\n-            reversedUp = new TreeSet<>(Collections.reverseOrder());\n-        }\n-\n-        \/\/ Reset relativeTo for all pred edges\n-        for (LayoutEdge e : node.preds) {\n-            if (e.link == null) {\n-                continue;\n-            }\n-            e.relativeTo = e.link.getTo().getRelativePosition().x;\n-            if (reversedLinks.contains(e.link)) {\n-                e.relativeTo = e.link.getFrom().getRelativePosition().x;\n-                reversedUp.add(e.relativeTo);\n-            }\n-        }\n-\n-        final int offset = X_OFFSET + DUMMY_WIDTH;\n-\n-        int curY = 0;\n-        int curWidth = node.width + reversedDown.size() * offset;\n-        for (int pos : reversedDown) {\n-            ArrayList<LayoutEdge> reversedSuccs = new ArrayList<>();\n-            for (LayoutEdge e : node.succs) {\n-                if (e.relativeFrom == pos && reversedLinks.contains(e.link)) {\n-                    reversedSuccs.add(e);\n-                    e.relativeFrom = curWidth;\n-                }\n-            }\n-\n-            ArrayList<Point> startPoints = new ArrayList<>();\n-            startPoints.add(new Point(curWidth, curY));\n-            startPoints.add(new Point(pos, curY));\n-            startPoints.add(new Point(pos, reversedDown.size() * offset));\n-            for (LayoutEdge e : reversedSuccs) {\n-                reversedLinkStartPoints.put(e.link, startPoints);\n-            }\n-\n-            node.inOffsets.put(pos, -curY);\n-            curY += offset;\n-            node.height += offset;\n-            node.yOffset += offset;\n-            curWidth -= offset;\n-        }\n-\n-        int widthFactor = reversedDown.size();\n-        node.width += widthFactor * offset;\n-\n-        int curX = 0;\n-        int minX = 0;\n-        if (hasReversedDown) {\n-            minX = -offset * reversedUp.size();\n-        }\n-\n-        int oldNodeHeight = node.height;\n-        for (int pos : reversedUp) {\n-            ArrayList<LayoutEdge> reversedPreds = new ArrayList<>();\n-            for (LayoutEdge e : node.preds) {\n-                if (e.relativeTo == pos && reversedLinks.contains(e.link)) {\n-                    if (hasReversedDown) {\n-                        e.relativeTo = curX - offset;\n-                    } else {\n-                        e.relativeTo = node.width + offset;\n-                    }\n-\n-                    reversedPreds.add(e);\n-                }\n-            }\n-            node.height += offset;\n-            ArrayList<Point> endPoints = new ArrayList<>();\n-\n-            node.width += offset;\n-            if (hasReversedDown) {\n-                curX -= offset;\n-                endPoints.add(new Point(curX, node.height));\n-            } else {\n-                curX += offset;\n-                endPoints.add(new Point(node.width, node.height));\n-            }\n-\n-            node.outOffsets.put(pos - minX, curX);\n-            curX += offset;\n-            node.bottomYOffset += offset;\n-\n-            endPoints.add(new Point(pos, node.height));\n-            endPoints.add(new Point(pos, oldNodeHeight));\n-            for (LayoutEdge e : reversedPreds) {\n-                reversedLinkEndPoints.put(e.link, endPoints);\n-            }\n-        }\n-\n-        if (minX < 0) {\n-            for (LayoutEdge e : node.preds) {\n-                e.relativeTo -= minX;\n-            }\n-\n-            for (LayoutEdge e : node.succs) {\n-                e.relativeFrom -= minX;\n-            }\n-\n-            node.xOffset = -minX;\n-            node.width -= minX;\n-        }\n+        node.computeReversedLinkPoints(false);\n@@ -421,2 +306,0 @@\n-        reversedLinkStartPoints = new HashMap<>();\n-        reversedLinkEndPoints = new HashMap<>();\n@@ -433,1 +316,1 @@\n-            nodes = manager.getNodes();\n+            nodes = new ArrayList<>(manager.getNodes());\n@@ -438,1 +321,1 @@\n-            new BuildDatastructure().run();\n+            new BuildDatastructures().run();\n@@ -474,1 +357,1 @@\n-    private class BuildDatastructure {\n+    private class BuildDatastructures {\n@@ -485,1 +368,1 @@\n-                if (node.vertex != null) {\n+                if (node.getVertex() != null) {\n@@ -487,1 +370,1 @@\n-                        if (vertex.equals(node.vertex)) {\n+                        if (vertex.equals(node.getVertex())) {\n@@ -489,2 +372,2 @@\n-                            if (node.width < (int) size.getWidth()) {\n-                                layersToUpdate.add(node.layer);\n+                            if (node.getOuterWidth() < (int) size.getWidth()) {\n+                                layersToUpdate.add(node.getLayer());\n@@ -492,3 +375,2 @@\n-                            node.width = (int) size.getWidth();\n-                            node.height = (int) size.getHeight();\n-                            node.vertex = vertex;\n+                            node.initSize();\n+                            node.setVertex(vertex);\n@@ -497,1 +379,1 @@\n-                    vertexToLayoutNode.put(node.vertex, node);\n+                    vertexToLayoutNode.put(node.getVertex(), node);\n@@ -499,2 +381,1 @@\n-                    node.height = DUMMY_HEIGHT;\n-                    node.width = DUMMY_WIDTH;\n+                    node.initSize();\n@@ -502,2 +383,2 @@\n-                for (LayoutEdge edge : node.preds) {\n-                    if (edge.link != null) {\n+                for (LayoutEdge edge : node.getPredecessors()) {\n+                    if (edge.getLink() != null) {\n@@ -505,3 +386,3 @@\n-                            if (link.equals(edge.link)) {\n-                                edge.link = link;\n-                                if (link.getTo().getVertex().equals(edge.from.vertex)) {\n+                            if (link.equals(edge.getLink())) {\n+                                edge.setLink(link);\n+                                if (link.getTo().getVertex().equals(edge.getFrom().getVertex())) {\n@@ -509,2 +390,2 @@\n-                                    edge.relativeFrom = link.getTo().getRelativePosition().x;\n-                                    edge.relativeTo = link.getFrom().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getTo().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getFrom().getRelativePosition().x);\n@@ -512,2 +393,2 @@\n-                                    edge.relativeFrom = link.getFrom().getRelativePosition().x;\n-                                    edge.relativeTo = link.getTo().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getFrom().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getTo().getRelativePosition().x);\n@@ -520,2 +401,2 @@\n-                for (LayoutEdge edge : node.succs) {\n-                    if (edge.link != null) {\n+                for (LayoutEdge edge : node.getSuccessors()) {\n+                    if (edge.getLink() != null) {\n@@ -523,3 +404,3 @@\n-                            if (link.equals(edge.link)) {\n-                                edge.link = link;\n-                                if (link.getTo().getVertex().equals(edge.from.vertex)) {\n+                            if (link.equals(edge.getLink())) {\n+                                edge.setLink(link);\n+                                if (link.getTo().getVertex().equals(edge.getFrom().getVertex())) {\n@@ -527,2 +408,2 @@\n-                                    edge.relativeFrom = link.getTo().getRelativePosition().x;\n-                                    edge.relativeTo = link.getFrom().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getTo().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getFrom().getRelativePosition().x);\n@@ -530,2 +411,2 @@\n-                                    edge.relativeFrom = link.getFrom().getRelativePosition().x;\n-                                    edge.relativeTo = link.getTo().getRelativePosition().x;\n+                                    edge.setRelativeFromX(link.getFrom().getRelativePosition().x);\n+                                    edge.setRelativeToX(link.getTo().getRelativePosition().x);\n@@ -547,2 +428,2 @@\n-                if (!layers.containsKey(node.layer)) {\n-                    layers.put(node.layer, new ArrayList<>());\n+                if (!layers.containsKey(node.getLayer())) {\n+                    layers.put(node.getLayer(), new LayoutLayer());\n@@ -550,1 +431,1 @@\n-                layers.get(node.layer).add(node);\n+                layers.get(node.getLayer()).add(node);\n@@ -554,1 +435,1 @@\n-                    layers.put(i, new ArrayList<>());\n+                    layers.put(i, new LayoutLayer());\n@@ -581,1 +462,1 @@\n-            layerNodes.sort(HierarchicalLayoutManager.nodePositionComparator);\n+            layerNodes.sort(Comparator.comparingInt(LayoutNode::getPos));\n@@ -589,1 +470,1 @@\n-                    xCoord = layerNodes.get(i).x - node.width - 1;\n+                    xCoord = layerNodes.get(i).getX() - node.getOuterWidth() - 1;\n@@ -591,1 +472,1 @@\n-                    xCoord = layerNodes.get(i - 1).x + layerNodes.get(i - 1).width + 1;\n+                    xCoord = layerNodes.get(i - 1).getX() + layerNodes.get(i - 1).getOuterWidth() + 1;\n@@ -599,5 +480,5 @@\n-                    for (LayoutEdge edge : node.preds) {\n-                        if (edge.from.layer == layer - 1) {\n-                            int fromNodeXCoord = edge.from.x;\n-                            if (edge.from.vertex != null) {\n-                                fromNodeXCoord += edge.relativeFrom;\n+                    for (LayoutEdge edge : node.getPredecessors()) {\n+                        if (edge.getFrom().getLayer() == layer - 1) {\n+                            int fromNodeXCoord = edge.getFrom().getX();\n+                            if (edge.getFrom().getVertex() != null) {\n+                                fromNodeXCoord += edge.getRelativeFromX();\n@@ -606,2 +487,2 @@\n-                            if (node.vertex != null) {\n-                                toNodeXCoord += edge.relativeTo;\n+                            if (node.getVertex() != null) {\n+                                toNodeXCoord += edge.getRelativeToX();\n@@ -610,2 +491,2 @@\n-                                for (LayoutEdge e : n.succs) {\n-                                    if (e.to == null) {\n+                                for (LayoutEdge e : n.getSuccessors()) {\n+                                    if (e.getTo() == null) {\n@@ -614,3 +495,3 @@\n-                                    int compFromXCoord = e.from.x;\n-                                    if (e.from.vertex != null) {\n-                                        compFromXCoord += e.relativeFrom;\n+                                    int compFromXCoord = e.getFrom().getX();\n+                                    if (e.getFrom().getVertex() != null) {\n+                                        compFromXCoord += e.getRelativeFromX();\n@@ -618,3 +499,3 @@\n-                                    int compToXCoord = e.to.x;\n-                                    if (e.to.vertex != null) {\n-                                        compToXCoord += e.relativeTo;\n+                                    int compToXCoord = e.getTo().getX();\n+                                    if (e.getTo().getVertex() != null) {\n+                                        compToXCoord += e.getRelativeToX();\n@@ -636,5 +517,5 @@\n-                    for (LayoutEdge edge : node.succs) {\n-                        if (edge.to.layer == layer + 1) {\n-                            int toNodeXCoord = edge.to.x;\n-                            if (edge.to.vertex != null) {\n-                                toNodeXCoord += edge.relativeTo;\n+                    for (LayoutEdge edge : node.getSuccessors()) {\n+                        if (edge.getTo().getLayer() == layer + 1) {\n+                            int toNodeXCoord = edge.getTo().getX();\n+                            if (edge.getTo().getVertex() != null) {\n+                                toNodeXCoord += edge.getRelativeToX();\n@@ -643,2 +524,2 @@\n-                            if (node.vertex != null) {\n-                                fromNodeXCoord += edge.relativeFrom;\n+                            if (node.getVertex() != null) {\n+                                fromNodeXCoord += edge.getRelativeFromX();\n@@ -647,2 +528,2 @@\n-                                for (LayoutEdge e : n.preds) {\n-                                    if (e.from == null) {\n+                                for (LayoutEdge e : n.getPredecessors()) {\n+                                    if (e.getFrom() == null) {\n@@ -651,3 +532,3 @@\n-                                    int compFromXCoord = e.from.x;\n-                                    if (e.from.vertex != null) {\n-                                        compFromXCoord += e.relativeFrom;\n+                                    int compFromXCoord = e.getFrom().getX();\n+                                    if (e.getFrom().getVertex() != null) {\n+                                        compFromXCoord += e.getRelativeFromX();\n@@ -655,3 +536,3 @@\n-                                    int compToXCoord = e.to.x;\n-                                    if (e.to.vertex != null) {\n-                                        compToXCoord += e.relativeTo;\n+                                    int compToXCoord = e.getTo().getX();\n+                                    if (e.getTo().getVertex() != null) {\n+                                        compToXCoord += e.getRelativeToX();\n@@ -685,2 +566,2 @@\n-            node.layer = layer;\n-            List<LayoutNode> layerNodes = layers.getOrDefault(layer, new ArrayList<LayoutNode>());\n+            node.setLayer(layer);\n+            LayoutLayer layerNodes = layers.getOrDefault(layer, new LayoutLayer());\n@@ -689,1 +570,1 @@\n-                node.pos = 0;\n+                node.setPos(0);\n@@ -691,1 +572,1 @@\n-                node.pos = optimalPosition(node, layer);\n+                node.setPos(optimalPosition(node, layer));\n@@ -695,2 +576,2 @@\n-                if (n.pos >= node.pos) {\n-                    n.pos += 1;\n+                if (n.getPos() >= node.getPos()) {\n+                    n.setPos(n.getPos() + 1);\n@@ -705,2 +586,2 @@\n-            if (node.vertex != null) {\n-                vertexToLayoutNode.put(node.vertex, node);\n+            if (node.getVertex() != null) {\n+                vertexToLayoutNode.put(node.getVertex(), node);\n@@ -713,2 +594,2 @@\n-            LayoutNode n = e.to;\n-            if (e.to.layer - 1 > e.from.layer) {\n+            LayoutNode n = e.getTo();\n+            if (e.getTo().getLayer() - 1 > e.getFrom().getLayer()) {\n@@ -716,1 +597,1 @@\n-                for (int i = n.layer - 1; i > last.from.layer; i--) {\n+                for (int i = n.getLayer() - 1; i > last.getFrom().getLayer(); i--) {\n@@ -724,15 +605,7 @@\n-            n.width = DUMMY_WIDTH;\n-            n.height = DUMMY_HEIGHT;\n-            n.succs.add(e);\n-            LayoutEdge result = new LayoutEdge();\n-            result.vip = e.vip;\n-            n.preds.add(result);\n-            result.to = n;\n-            result.relativeTo = n.width \/ 2;\n-            result.from = e.from;\n-            result.relativeFrom = e.relativeFrom;\n-            result.link = e.link;\n-            e.relativeFrom = n.width \/ 2;\n-            e.from.succs.remove(e);\n-            e.from.succs.add(result);\n-            e.from = n;\n+            n.addSuccessor(e);\n+            LayoutEdge result = new LayoutEdge(e.getFrom(), n, e.getRelativeFromX(), n.getOuterWidth() \/ 2, e.getLink());\n+            n.addPredecessor(result);\n+            e.setRelativeFromX(n.getOuterWidth() \/ 2);\n+            e.getFrom().removeSuccessor(e);\n+            e.getFrom().addSuccessor(result);\n+            e.setFrom(n);\n@@ -744,2 +617,2 @@\n-            LayoutNode from = edge.from;\n-            LayoutNode to = edge.to;\n+            LayoutNode from = edge.getFrom();\n+            LayoutNode to = edge.getTo();\n@@ -748,1 +621,1 @@\n-            LayoutEdge edgeFromSamePort = new LayoutEdge();\n+            LayoutEdge edgeFromSamePort = null;\n@@ -750,2 +623,2 @@\n-            for (LayoutEdge e : edge.from.succs) {\n-                if (e.relativeFrom == edge.relativeFrom && e.to.vertex == null) {\n+            for (LayoutEdge e : edge.getFrom().getSuccessors()) {\n+                if (e.getRelativeFromX() == edge.getRelativeFromX() && e.getTo().getVertex() == null) {\n@@ -763,1 +636,1 @@\n-                while (curEdge.to.layer < to.layer - 1 && curEdge.to.vertex == null && newEdge) {\n+                while (curEdge.getTo().getLayer() < to.getLayer() - 1 && curEdge.getTo().getVertex() == null && newEdge) {\n@@ -767,2 +640,2 @@\n-                    if (curEdge.to.succs.size() == 1) {\n-                        curEdge = curEdge.to.succs.get(0);\n+                    if (curEdge.getTo().getSuccessors().size() == 1) {\n+                        curEdge = curEdge.getTo().getSuccessors().get(0);\n@@ -771,2 +644,2 @@\n-                        for (LayoutEdge e : curEdge.to.succs) {\n-                            if (e.to.vertex == null) {\n+                        for (LayoutEdge e : curEdge.getTo().getSuccessors()) {\n+                            if (e.getTo().getVertex() == null) {\n@@ -782,2 +655,2 @@\n-                if (curEdge.to.vertex != null) {\n-                    prevDummy = curEdge.from;\n+                if (curEdge.getTo().getVertex() != null) {\n+                    prevDummy = curEdge.getFrom();\n@@ -785,1 +658,1 @@\n-                    prevDummy = curEdge.to;\n+                    prevDummy = curEdge.getTo();\n@@ -788,4 +661,4 @@\n-                edge.from = prevDummy;\n-                edge.relativeFrom = prevDummy.width \/ 2;\n-                from.succs.remove(edge);\n-                prevDummy.succs.add(edge);\n+                edge.setFrom(prevDummy);\n+                edge.setRelativeFromX(prevDummy.getOuterWidth() \/ 2);\n+                from.removeSuccessor(edge);\n+                prevDummy.addSuccessor(edge);\n@@ -797,1 +670,1 @@\n-            if (node.layer == 0) {\n+            if (node.getLayer() == 0) {\n@@ -800,3 +673,3 @@\n-            int newLayer = node.layer - 1;\n-            for (LayoutEdge e : node.preds) {\n-                if (e.from.vertex != null && e.from.layer == newLayer) {\n+            int newLayer = node.getLayer() - 1;\n+            for (LayoutEdge e : node.getPredecessors()) {\n+                if (e.getFrom().getVertex() != null && e.getFrom().getLayer() == newLayer) {\n@@ -810,1 +683,1 @@\n-            if (node.layer == layers.keySet().size() - 1) {\n+            if (node.getLayer() == layers.keySet().size() - 1) {\n@@ -813,3 +686,3 @@\n-            int newLayer = node.layer + 1;\n-            for (LayoutEdge e : node.succs) {\n-                if (e.to.vertex != null && e.to.layer == newLayer) {\n+            int newLayer = node.getLayer() + 1;\n+            for (LayoutEdge e : node.getSuccessors()) {\n+                if (e.getTo().getVertex() != null && e.getTo().getLayer() == newLayer) {\n@@ -825,1 +698,1 @@\n-            List<LayoutEdge> previousPredEdges = List.copyOf(node.preds);\n+            List<LayoutEdge> previousPredEdges = List.copyOf(node.getPredecessors());\n@@ -827,7 +700,7 @@\n-                LayoutNode predNode = edge.from;\n-                assert predNode.vertex == null;\n-                for (LayoutEdge e : predNode.preds) {\n-                    e.to = edge.to;\n-                    e.relativeTo = edge.relativeTo;\n-                    node.preds.add(e);\n-                    node.preds.remove(edge);\n+                LayoutNode predNode = edge.getFrom();\n+                assert predNode.getVertex() == null;\n+                for (LayoutEdge e : predNode.getPredecessors()) {\n+                    e.setTo(edge.getTo());\n+                    e.setRelativeToX(edge.getRelativeToX());\n+                    node.addPredecessor(e);\n+                    node.removePredecessor(edge);\n@@ -839,1 +712,1 @@\n-            insertNode(node, node.layer - 1);\n+            insertNode(node, node.getLayer() - 1);\n@@ -841,1 +714,1 @@\n-            for (LayoutEdge edge : List.copyOf(node.succs)) {\n+            for (LayoutEdge edge : List.copyOf(node.getSuccessors())) {\n@@ -849,1 +722,1 @@\n-            List<LayoutEdge> previousSuccEdges = List.copyOf(node.succs);\n+            List<LayoutEdge> previousSuccEdges = List.copyOf(node.getSuccessors());\n@@ -851,7 +724,7 @@\n-                LayoutNode succNode = edge.to;\n-                assert succNode.vertex == null;\n-                for (LayoutEdge e : succNode.succs) {\n-                    e.from = edge.from;\n-                    e.relativeFrom = edge.relativeFrom;\n-                    node.succs.add(e);\n-                    node.succs.remove(edge);\n+                LayoutNode succNode = edge.getTo();\n+                assert succNode.getVertex() == null;\n+                for (LayoutEdge e : succNode.getSuccessors()) {\n+                    e.setFrom(edge.getFrom());\n+                    e.setRelativeFromX(edge.getRelativeFromX());\n+                    node.addSuccessor(e);\n+                    node.removeSuccessor(edge);\n@@ -863,1 +736,1 @@\n-            insertNode(node, node.layer + 1);\n+            insertNode(node, node.getLayer() + 1);\n@@ -865,1 +738,1 @@\n-            for (LayoutEdge edge : List.copyOf(node.preds)) {\n+            for (LayoutEdge edge : List.copyOf(node.getPredecessors())) {\n@@ -887,1 +760,1 @@\n-            int layer = node.layer + 1;\n+            int layer = node.getLayer() + 1;\n@@ -891,1 +764,1 @@\n-                List<LayoutNode> list = layers.get(i);\n+                LayoutLayer list = layers.get(i);\n@@ -893,1 +766,1 @@\n-                    n.layer = i + 1;\n+                    n.setLayer(i + 1);\n@@ -900,1 +773,1 @@\n-            List<LayoutNode> l = new ArrayList<>();\n+            LayoutLayer l = new LayoutLayer();\n@@ -905,1 +778,1 @@\n-                assert n.layer != layer;\n+                assert n.getLayer() != layer;\n@@ -914,3 +787,3 @@\n-                for (LayoutEdge e : n.succs) {\n-                    if (!portHashes.containsKey(e.relativeFrom)) {\n-                        portHashes.put(e.relativeFrom, new ArrayList<>());\n+                for (LayoutEdge e : n.getSuccessors()) {\n+                    if (!portHashes.containsKey(e.getRelativeFromX())) {\n+                        portHashes.put(e.getRelativeFromX(), new ArrayList<>());\n@@ -918,1 +791,1 @@\n-                    portHashes.get(e.relativeFrom).add(e);\n+                    portHashes.get(e.getRelativeFromX()).add(e);\n@@ -925,11 +798,4 @@\n-                    dummy.width = DUMMY_WIDTH;\n-                    dummy.height = DUMMY_HEIGHT;\n-\n-                    LayoutEdge newEdge = new LayoutEdge();\n-                    newEdge.from = n;\n-                    newEdge.relativeFrom = i;\n-                    newEdge.to = dummy;\n-                    newEdge.relativeTo = dummy.width \/ 2;\n-                    newEdge.link = edges.get(0).link; \/\/ issue?\n-                    n.succs.add(newEdge);\n-                    dummy.preds.add(newEdge);\n+\n+                    LayoutEdge newEdge = new LayoutEdge(n, dummy, i, dummy.getOuterWidth() \/ 2, edges.get(0).getLink());\n+                    n.addSuccessor(newEdge);\n+                    dummy.addPredecessor(newEdge);\n@@ -938,5 +804,5 @@\n-                        e.from = dummy;\n-                        e.relativeFrom = dummy.width \/ 2;\n-                        n.succs.remove(e);\n-                        dummy.succs.add(e);\n-                        assert e.to.layer == layer + 1;\n+                        e.setFrom(dummy);\n+                        e.setRelativeFromX(dummy.getOuterWidth() \/ 2);\n+                        n.removeSuccessor(e);\n+                        dummy.addSuccessor(e);\n+                        assert e.getTo().getLayer() == layer + 1;\n@@ -952,1 +818,1 @@\n-            assert node.layer == layer;\n+            assert node.getLayer() == layer;\n@@ -965,1 +831,1 @@\n-            if (toNode.layer == fromNode.layer) {\n+            if (toNode.getLayer() == fromNode.getLayer()) {\n@@ -969,8 +835,2 @@\n-            LayoutEdge edge = new LayoutEdge();\n-            edge.link = l;\n-            edge.from = fromNode;\n-            edge.relativeFrom = l.getFrom().getRelativePosition().x;\n-            edge.to = toNode;\n-            edge.relativeTo = l.getTo().getRelativePosition().x;\n-\n-            boolean reversedLink = fromNode.layer > toNode.layer;\n+            LayoutEdge edge = new LayoutEdge(fromNode, toNode, l.getFrom().getRelativePosition().x, l.getTo().getRelativePosition().x, l);\n+            boolean reversedLink = fromNode.getLayer() > toNode.getLayer();\n@@ -985,2 +845,2 @@\n-                int oldRelativeFrom = edge.relativeFrom;\n-                int oldRelativeTo = edge.relativeTo;\n+                int oldRelativeFrom = edge.getRelativeFromX();\n+                int oldRelativeTo = edge.getRelativeToX();\n@@ -988,4 +848,4 @@\n-                edge.from = fromNode;\n-                edge.to = toNode;\n-                edge.relativeFrom = oldRelativeTo;\n-                edge.relativeTo = oldRelativeFrom;\n+                edge.setFrom(fromNode);\n+                edge.setTo(toNode);\n+                edge.setRelativeFromX(oldRelativeTo);\n+                edge.setRelativeToX(oldRelativeFrom);\n@@ -994,2 +854,2 @@\n-            fromNode.succs.add(edge);\n-            toNode.preds.add(edge);\n+            fromNode.addSuccessor(edge);\n+            toNode.addPredecessor(edge);\n@@ -1001,1 +861,1 @@\n-            if (fromNode.layer != toNode.layer - 1) {\n+            if (fromNode.getLayer() != toNode.getLayer() - 1) {\n@@ -1035,1 +895,1 @@\n-                        if (fromNode.layer > i) {\n+                        if (fromNode.getLayer() > i) {\n@@ -1037,1 +897,1 @@\n-                        } else if (fromNode.layer == i) {\n+                        } else if (fromNode.getLayer() == i) {\n@@ -1040,1 +900,1 @@\n-                        curTotalEdgeLength += Math.abs(fromNode.layer - i);\n+                        curTotalEdgeLength += Math.abs(fromNode.getLayer() - i);\n@@ -1043,1 +903,1 @@\n-                        if (toNode.layer < i) {\n+                        if (toNode.getLayer() < i) {\n@@ -1045,1 +905,1 @@\n-                        } else if (toNode.layer == i) {\n+                        } else if (toNode.getLayer() == i) {\n@@ -1048,1 +908,1 @@\n-                        curTotalEdgeLength += Math.abs(i - toNode.layer);\n+                        curTotalEdgeLength += Math.abs(i - toNode.getLayer());\n@@ -1069,6 +929,1 @@\n-            LayoutNode node = new LayoutNode();\n-            Dimension size = action.vertex.getSize();\n-            node.width = (int) size.getWidth();\n-            node.height = (int) size.getHeight();\n-            node.vertex = action.vertex;\n-\n+            LayoutNode node = new LayoutNode(action.vertex);\n@@ -1084,1 +939,0 @@\n-                LayoutEdge e = new LayoutEdge();\n@@ -1087,5 +941,2 @@\n-                    e.to = node;\n-                    e.from = vertexToLayoutNode.get(l.getFrom().getVertex());\n-                    e.relativeFrom = l.getFrom().getRelativePosition().x;\n-                    e.relativeTo = l.getTo().getRelativePosition().x;\n-                    node.preds.add(e);\n+                    LayoutEdge e = new LayoutEdge(vertexToLayoutNode.get(l.getFrom().getVertex()), node, l.getFrom().getRelativePosition().x, l.getTo().getRelativePosition().x, null);\n+                    node.addPredecessor(e);\n@@ -1094,5 +945,2 @@\n-                    e.from = node;\n-                    e.to = vertexToLayoutNode.get(l.getTo().getVertex());\n-                    e.relativeFrom = l.getFrom().getRelativePosition().x;\n-                    e.relativeTo = l.getTo().getRelativePosition().x;\n-                    node.succs.add(e);\n+                    LayoutEdge e = new LayoutEdge(node, vertexToLayoutNode.get(l.getTo().getVertex()), l.getFrom().getRelativePosition().x, l.getTo().getRelativePosition().x, null);\n+                    node.addSuccessor(e);\n@@ -1102,2 +950,2 @@\n-            node.succs.clear();\n-            node.preds.clear();\n+            node.clearSuccessors();\n+            node.clearPredecessors();\n@@ -1119,1 +967,1 @@\n-            if (toNode.layer < fromNode.layer) {\n+            if (toNode.getLayer() < fromNode.getLayer()) {\n@@ -1121,1 +969,0 @@\n-                LayoutNode temp = toNode;\n@@ -1123,2 +970,0 @@\n-                fromNode = temp;\n-\n@@ -1126,2 +971,0 @@\n-                reversedLinkEndPoints.remove(l);\n-                reversedLinkStartPoints.remove(l);\n@@ -1132,1 +975,1 @@\n-            List<LayoutEdge> toNodePredsEdges = List.copyOf(toNode.preds);\n+            List<LayoutEdge> toNodePredsEdges = List.copyOf(toNode.getPredecessors());\n@@ -1134,1 +977,1 @@\n-                LayoutNode n = edge.from;\n+                LayoutNode n = edge.getFrom();\n@@ -1137,2 +980,2 @@\n-                if (edge.link != null && edge.link.equals(l)) {\n-                    toNode.preds.remove(edge);\n+                if (edge.getLink() != null && edge.getLink().equals(l)) {\n+                    toNode.removePredecessor(edge);\n@@ -1145,1 +988,1 @@\n-                if (n.vertex != null && n.vertex.equals(from)) {\n+                if (n.getVertex() != null && n.getVertex().equals(from)) {\n@@ -1147,1 +990,1 @@\n-                    n.succs.remove(edgeToRemove);\n+                    n.removeSuccessor(edgeToRemove);\n@@ -1153,1 +996,1 @@\n-                    while (n.vertex == null && found) {\n+                    while (n.getVertex() == null && found) {\n@@ -1156,1 +999,1 @@\n-                        if (n.succs.size() <= 1 && n.preds.size() <= 1) {\n+                        if (n.getSuccessors().size() <= 1 && n.getPredecessors().size() <= 1) {\n@@ -1166,2 +1009,2 @@\n-                        if (n.preds.size() == 1) {\n-                            n.succs.remove(edgeToRemove);\n+                        if (n.getPredecessors().size() == 1) {\n+                            n.removeSuccessor(edgeToRemove);\n@@ -1169,2 +1012,2 @@\n-                            edgeToRemove = n.preds.get(0);\n-                            n = edgeToRemove.from;\n+                            edgeToRemove = n.getPredecessors().get(0);\n+                            n = edgeToRemove.getFrom();\n@@ -1175,2 +1018,2 @@\n-                    n.succs.remove(edgeToRemove);\n-                    prev.preds.remove(edgeToRemove);\n+                    n.removeSuccessor(edgeToRemove);\n+                    prev.removePredecessor(edgeToRemove);\n@@ -1195,3 +1038,3 @@\n-            int layer = node.layer;\n-            int pos = node.pos;\n-            List<LayoutNode> remainingLayerNodes = layers.get(layer);\n+            int layer = node.getLayer();\n+            int pos = node.getPos();\n+            LayoutLayer remainingLayerNodes = layers.get(layer);\n@@ -1204,2 +1047,2 @@\n-                if (n.pos > pos) {\n-                    n.pos -= 1;\n+                if (n.getPos() > pos) {\n+                    n.setPos(n.getPos() - 1);\n@@ -1207,1 +1050,1 @@\n-                if (n.vertex != null || n.preds.size() > 1) {\n+                if (n.getVertex() != null || n.getPredecessors().size() > 1) {\n@@ -1215,1 +1058,1 @@\n-                    List<LayoutNode> list = layers.get(i);\n+                    LayoutLayer list = layers.get(i);\n@@ -1219,1 +1062,1 @@\n-                        n.layer -= 1;\n+                        n.setLayer(n.getLayer() - 1);\n@@ -1223,8 +1066,8 @@\n-                    if (n.preds.size() == 1) {\n-                        LayoutEdge predEdge = n.preds.get(0);\n-                        LayoutNode fromNode = predEdge.from;\n-                        fromNode.succs.remove(predEdge);\n-                        for (LayoutEdge e : n.succs) {\n-                            e.from = fromNode;\n-                            e.relativeFrom = predEdge.relativeFrom;\n-                            fromNode.succs.add(e);\n+                    if (n.getPredecessors().size() == 1) {\n+                        LayoutEdge predEdge = n.getPredecessors().get(0);\n+                        LayoutNode fromNode = predEdge.getFrom();\n+                        fromNode.removeSuccessor(predEdge);\n+                        for (LayoutEdge e : n.getSuccessors()) {\n+                            e.setFrom(fromNode);\n+                            e.setRelativeFromX(predEdge.getRelativeFromX());\n+                            fromNode.addSuccessor(e);\n@@ -1289,3 +1132,3 @@\n-                for (LayoutEdge e : n.preds) {\n-                    if (e.link != null) {\n-                        layoutedLinks.add(e.link);\n+                for (LayoutEdge e : n.getPredecessors()) {\n+                    if (e.getLink() != null) {\n+                        layoutedLinks.add(e.getLink());\n@@ -1294,1 +1137,1 @@\n-                if (n.vertex != null) {\n+                if (n.getVertex() != null) {\n@@ -1317,0 +1160,4 @@\n+            int currentY = 0;\n+            for (int i = 0; i < layers.size(); i++) {\n+                LayoutLayer layer = layers.get(i);\n+                layer.setTop(currentY);\n@@ -1318,8 +1165,9 @@\n-            \/\/ Reset all values before assigning y-coordinates\n-            for (LayoutNode n : nodes) {\n-                if (n.vertex != null) {\n-                    updateNodeWithReversedEdges(n);\n-                } else {\n-                    n.height = DUMMY_HEIGHT;\n-                }\n-                n.y = 0;\n+                \/\/ Calculate the maximum layer height and set it for the layer\n+                int maxLayerHeight = layer.calculateMaxLayerHeight();\n+                layer.setHeight(maxLayerHeight);\n+\n+                \/\/ Center nodes vertically within the layer\n+                layer.centerNodesVertically();\n+\n+                \/\/ Update currentY to account for the padded bottom of this layer\n+                currentY += layer.calculatePaddedHeight();\n@@ -1327,0 +1175,2 @@\n+        }\n+    }\n@@ -1328,1 +1178,1 @@\n-            int curY = 0;\n+    private class WriteResult {\n@@ -1330,10 +1180,3 @@\n-            for (int i = 0; i < layers.size(); i++) {\n-                List<LayoutNode> layer = layers.get(i);\n-                int maxHeight = 0;\n-                int baseLine = 0;\n-                int bottomBaseLine = 0;\n-                for (LayoutNode n : layer) {\n-                    maxHeight = Math.max(maxHeight, n.height - n.yOffset - n.bottomYOffset);\n-                    baseLine = Math.max(baseLine, n.yOffset);\n-                    bottomBaseLine = Math.max(bottomBaseLine, n.bottomYOffset);\n-                }\n+        private HashMap<Link, List<Point>> computeLinkPositions() {\n+            HashMap<Link, List<Point>> linkToSplitEndPoints = new HashMap<>();\n+            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n@@ -1341,6 +1184,27 @@\n-                int maxXOffset = 0;\n-                for (LayoutNode n : layer) {\n-                    if (n.vertex == null) {\n-                        \/\/ Dummy node\n-                        n.y = curY;\n-                        n.height = maxHeight + baseLine + bottomBaseLine;\n+            for (LayoutNode layoutNode : nodes) {\n+                if (layoutNode.isDummy()) continue;\n+                for (LayoutEdge predEdge : layoutNode.getPredecessors()) {\n+                    LayoutNode fromNode = predEdge.getFrom();\n+                    LayoutNode toNode = predEdge.getTo();\n+\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    \/\/ input edge stub\n+                    linkPoints.add(new Point(predEdge.getEndX(), predEdge.getEndY()));\n+                    linkPoints.add(new Point(predEdge.getEndX(), layers.get(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+\n+                    LayoutEdge curEdge = predEdge;\n+                    while (fromNode.isDummy() && fromNode.hasPredecessors()) {\n+                        linkPoints.add(new Point(fromNode.getCenterX(), layers.get(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        linkPoints.add(new Point(fromNode.getCenterX(), layers.get(fromNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        curEdge = fromNode.getPredecessors().get(0);\n+                        fromNode = curEdge.getFrom();\n+                    }\n+                    linkPoints.add(new Point(curEdge.getStartX(), layers.get(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                    \/\/ output edge stub\n+                    linkPoints.add(new Point(curEdge.getStartX(), curEdge.getStartY()));\n+\n+                    if (predEdge.isReversed()) {\n+                        for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(predEdge.getLink())) {\n+                            Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                            linkPoints.add(0, endPoint);\n+                        }\n@@ -1348,0 +1212,8 @@\n+                        if (!fromNode.isDummy()) {\n+                            if (fromNode.getReversedLinkStartPoints().containsKey(predEdge.getLink())) {\n+                                for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(predEdge.getLink())) {\n+                                    Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                    linkPoints.add(startPoint);\n+                                }\n+                            }\n+                        }\n@@ -1349,1 +1221,1 @@\n-                        n.y = curY + baseLine + (maxHeight - (n.height - n.yOffset - n.bottomYOffset)) \/ 2 - n.yOffset;\n+                        Collections.reverse(linkPoints);\n@@ -1352,3 +1224,8 @@\n-                    for (LayoutEdge e : n.succs) {\n-                        int curXOffset = Math.abs(n.x - e.to.x);\n-                        maxXOffset = Math.max(curXOffset, maxXOffset);\n+                    if (fromNode.isDummy()) {\n+                        if (predEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                        linkToSplitEndPoints.put(predEdge.getLink(), linkPoints);\n+\n+                    } else {\n+                        linkPositions.put(predEdge.getLink(), linkPoints);\n@@ -1357,3 +1234,0 @@\n-\n-                curY += maxHeight + baseLine + bottomBaseLine;\n-                curY += LAYER_OFFSET + ((int) (Math.sqrt(maxXOffset) * 1.5));\n@@ -1361,2 +1235,0 @@\n-        }\n-    }\n@@ -1364,1 +1236,4 @@\n-    private class WriteResult {\n+            for (LayoutNode layoutNode : nodes) {\n+                if (layoutNode.isDummy()) continue;\n+                for (LayoutEdge succEdge : layoutNode.getSuccessors()) {\n+                    if (succEdge.getLink() == null) continue;\n@@ -1366,2 +1241,2 @@\n-        private List<Point> edgePoints(LayoutEdge e) {\n-            ArrayList<Point> points = new ArrayList<>();\n+                    LayoutNode fromNode = succEdge.getFrom();\n+                    LayoutNode toNode = succEdge.getTo();\n@@ -1369,7 +1244,3 @@\n-            Point p = new Point(e.to.x + e.relativeTo,\n-                    e.to.y + e.to.yOffset + e.link.getTo().getRelativePosition().y);\n-            points.add(p);\n-            if (e.to.inOffsets.containsKey(e.relativeTo)) {\n-                points.add(new Point(p.x,\n-                        p.y + e.to.inOffsets.get(e.relativeTo) + e.link.getTo().getRelativePosition().y));\n-            }\n+                    ArrayList<Point> linkPoints = new ArrayList<>();\n+                    linkPoints.add(new Point(succEdge.getStartX(), fromNode.getBottom()));\n+                    linkPoints.add(new Point(succEdge.getStartX(), layers.get(fromNode.getLayer()).getBottom() + LAYER_OFFSET));\n@@ -1377,28 +1248,9 @@\n-            LayoutNode cur = e.from;\n-            LayoutEdge curEdge = e;\n-            while (cur.vertex == null && !cur.preds.isEmpty()) {\n-                if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2\n-                        && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                    \/\/ On the same vertical line, can remove previous point\n-                    points.remove(points.size() - 1);\n-                }\n-                \/\/ Top of the dummy node\n-                points.add(new Point(cur.x + cur.width \/ 2, cur.y + cur.height));\n-                if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2\n-                        && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n-                    points.remove(points.size() - 1);\n-                }\n-                \/\/ Bottom of the dummy node\n-                points.add(new Point(cur.x + cur.width \/ 2, cur.y));\n-                assert cur.preds.size() == 1;\n-                curEdge = cur.preds.get(0);\n-                cur = curEdge.from;\n-            }\n-\n-            p = new Point(cur.x + curEdge.relativeFrom, cur.y + cur.height - cur.bottomYOffset\n-                    + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y));\n-            if (curEdge.from.outOffsets.containsKey(curEdge.relativeFrom)) {\n-                points.add(new Point(p.x, p.y + curEdge.from.outOffsets.get(curEdge.relativeFrom)\n-                        + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y)));\n-            }\n-            points.add(p);\n+                    LayoutEdge curEdge = succEdge;\n+                    while (toNode.isDummy() && toNode.hasSuccessors()) {\n+                        linkPoints.add(new Point(toNode.getCenterX(), layers.get(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                        linkPoints.add(new Point(toNode.getCenterX(), layers.get(toNode.getLayer()).getBottom() + LAYER_OFFSET));\n+                        curEdge = toNode.getSuccessors().get(0);\n+                        toNode = curEdge.getTo();\n+                    }\n+                    linkPoints.add(new Point(curEdge.getEndX(), layers.get(toNode.getLayer()).getTop() - LAYER_OFFSET));\n+                    linkPoints.add(new Point(curEdge.getEndX(), toNode.getTop()));\n@@ -1406,1 +1258,2 @@\n-            Collections.reverse(points);\n+                    if (succEdge.isReversed()) {\n+                        Collections.reverse(linkPoints);\n@@ -1408,2 +1261,6 @@\n-            if (reversedLinks.contains(e.link)) {\n-                Collections.reverse(points);\n+                        if (fromNode.getReversedLinkStartPoints().containsKey(succEdge.getLink())) {\n+                            for (Point relativeStart : fromNode.getReversedLinkStartPoints().get(succEdge.getLink())) {\n+                                Point startPoint = new Point(fromNode.getLeft() + relativeStart.x, fromNode.getTop() + relativeStart.y);\n+                                linkPoints.add(startPoint);\n+                            }\n+                        }\n@@ -1411,4 +1268,9 @@\n-                assert reversedLinkStartPoints.containsKey(e.link);\n-                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n-                    points.add(new Point(p1.x + cur.x, p1.y + cur.y));\n-                }\n+                        if (!toNode.isDummy()) {\n+                            if (toNode.getReversedLinkEndPoints().containsKey(succEdge.getLink())) {\n+                                for (Point relativeEnd : toNode.getReversedLinkEndPoints().get(succEdge.getLink())) {\n+                                    Point endPoint = new Point(toNode.getLeft() + relativeEnd.x, toNode.getTop() + relativeEnd.y);\n+                                    linkPoints.add(0, endPoint);\n+                                }\n+                            }\n+                        }\n+                    }\n@@ -1416,3 +1278,11 @@\n-                assert reversedLinkEndPoints.containsKey(e.link);\n-                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n-                    points.add(0, new Point(p1.x + e.to.x, p1.y + e.to.y));\n+                    if (linkToSplitEndPoints.containsKey(succEdge.getLink())) {\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                        linkPoints.add(null);\n+                        linkPoints.addAll(linkToSplitEndPoints.get(succEdge.getLink()));\n+                        if (succEdge.isReversed()) {\n+                            Collections.reverse(linkPoints);\n+                        }\n+                    }\n+                    linkPositions.put(succEdge.getLink(), linkPoints);\n@@ -1422,1 +1292,1 @@\n-            return points;\n+            return linkPositions;\n@@ -1425,0 +1295,1 @@\n+\n@@ -1427,1 +1298,1 @@\n-            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n+            HashMap<Link, List<Point>> linkPositions = computeLinkPositions();\n@@ -1429,1 +1300,0 @@\n-            for (LayoutNode n : nodes) {\n@@ -1431,15 +1301,4 @@\n-                if (n.vertex != null) {\n-                    assert !vertexPositions.containsKey(n.vertex);\n-                    vertexPositions.put(n.vertex, new Point(n.x + n.xOffset, n.y + n.yOffset));\n-                } else {\n-                    continue;\n-                }\n-\n-                \/\/ All edges can be drawn from bottom up, the links are stored in the preds list\n-                \/\/ of each node\n-                for (LayoutEdge e : n.preds) {\n-                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n-                        List<Point> points = edgePoints(e);\n-                        assert !linkPositions.containsKey(e.link);\n-                        linkPositions.put(e.link, points);\n-                    }\n+            for (LayoutNode n : nodes) {\n+                if (n.getVertex() != null) {\n+                    assert !vertexPositions.containsKey(n.getVertex());\n+                    vertexPositions.put(n.getVertex(), new Point(n.getLeft(), n.getTop()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalStableLayoutManager.java","additions":368,"deletions":509,"binary":false,"changes":877,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,4 +77,0 @@\n-\n-    public boolean isVIP() {\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/InterClusterConnection.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,8 @@\n+\/**\n+ * The LayoutEdge class represents a connection between two nodes (LayoutNode) in a hierarchical graph layout.\n+ * It stores information about the starting node (from), the ending node (to), and the positions where\n+ * the edge connects to these nodes. It also keeps track of whether the edge has been reversed,\n+ * which is useful for handling edges that go against the main flow in hierarchical layouts (like loops or back edges).\n+ * This class ensures that edges are drawn correctly between nodes,\n+ * helping to create clear and understandable visualizations of the graph.\n+ *\/\n@@ -31,8 +39,195 @@\n-        public LayoutNode from;\n-        public LayoutNode to;\n-        \/\/ Horizontal distance relative to start of 'from'.\n-        public int relativeFrom;\n-        \/\/ Horizontal distance relative to start of 'to'.\n-        public int relativeTo;\n-        public Link link;\n-        public boolean vip;\n+    private LayoutNode from;\n+    private LayoutNode to;\n+    \/\/ Horizontal distance relative to start of 'from'.\n+    private int relativeFromX;\n+    \/\/ Horizontal distance relative to start of 'to'.\n+    private int relativeToX;\n+    private Link link;\n+    private boolean isReversed;\n+\n+    \/**\n+     * Constructs a LayoutEdge between two nodes with the specified link.\n+     * The relative positions are set to zero by default.\n+     *\n+     * @param from The source LayoutNode.\n+     * @param to   The target LayoutNode.\n+     * @param link The Link associated with this edge.\n+     *\/\n+    public LayoutEdge(LayoutNode from, LayoutNode to, Link link) {\n+        this.from = from;\n+        this.to = to;\n+        this.link = link;\n+        this.isReversed = false;\n+    }\n+\n+    \/**\n+     * Constructs a LayoutEdge between two nodes with specified relative positions and link.\n+     *\n+     * @param from          The source LayoutNode.\n+     * @param to            The target LayoutNode.\n+     * @param relativeFromX The horizontal distance relative to the start of 'from' node.\n+     * @param relativeToX   The horizontal distance relative to the start of 'to' node.\n+     * @param link          The Link associated with this edge.\n+     *\/\n+    public LayoutEdge(LayoutNode from, LayoutNode to, int relativeFromX, int relativeToX, Link link) {\n+        this(from, to, link);\n+        this.relativeFromX = relativeFromX;\n+        this.relativeToX = relativeToX;\n+    }\n+\n+    \/**\n+     * Gets the absolute x-coordinate of the starting point of the edge.\n+     *\n+     * @return The x-coordinate of the edge's starting point.\n+     *\/\n+    public int getStartX() {\n+        return relativeFromX + from.getLeft();\n+    }\n+\n+    \/**\n+     * Gets the absolute y-coordinate of the starting point of the edge.\n+     *\n+     * @return The y-coordinate of the edge's starting point.\n+     *\/\n+    public int getStartY() {\n+        return from.getBottom();\n+    }\n+\n+    \/**\n+     * Gets the absolute x-coordinate of the ending point of the edge.\n+     *\n+     * @return The x-coordinate of the edge's ending point.\n+     *\/\n+    public int getEndX() {\n+        return relativeToX + to.getLeft();\n+    }\n+\n+    \/**\n+     * Gets the absolute y-coordinate of the ending point of the edge.\n+     *\n+     * @return The y-coordinate of the edge's ending point.\n+     *\/\n+    public int getEndY() {\n+        return to.getTop();\n+    }\n+\n+    \/**\n+     * Reverses the direction of the edge.\n+     * Marks the edge as reversed, which is used to represent back edges in hierarchical layouts.\n+     *\/\n+    public void reverse() {\n+        isReversed = !isReversed;\n+    }\n+\n+    \/**\n+     * Checks if the edge is reversed.\n+     *\n+     * @return True if the edge is reversed; false otherwise.\n+     *\/\n+    public boolean isReversed() {\n+        return isReversed;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Edge \" + from + \", \" + to;\n+    }\n+\n+    \/**\n+     * Gets the source node of the edge.\n+     *\n+     * @return The source LayoutNode.\n+     *\/\n+    public LayoutNode getFrom() {\n+        return from;\n+    }\n+\n+    \/**\n+     * Sets the source node of the edge.\n+     *\n+     * @param from The LayoutNode to set as the source.\n+     *\/\n+    public void setFrom(LayoutNode from) {\n+        this.from = from;\n+    }\n+\n+    \/**\n+     * Gets the target node of the edge.\n+     *\n+     * @return The target LayoutNode.\n+     *\/\n+    public LayoutNode getTo() {\n+        return to;\n+    }\n+\n+    \/**\n+     * Sets the target node of the edge.\n+     *\n+     * @param to The LayoutNode to set as the target.\n+     *\/\n+    public void setTo(LayoutNode to) {\n+        this.to = to;\n+    }\n+\n+    \/**\n+     * Gets the absolute x-coordinate of the source node's connection point for this edge.\n+     *\n+     * @return The x-coordinate of the source node's connection point.\n+     *\/\n+    public int getFromX() {\n+        return from.getX() + getRelativeFromX();\n+    }\n+\n+    \/**\n+     * Gets the absolute x-coordinate of the target node's connection point for this edge.\n+     *\n+     * @return The x-coordinate of the target node's connection point.\n+     *\/\n+    public int getToX() {\n+        return to.getX() + getRelativeToX();\n+    }\n+\n+    \/**\n+     * Gets the relative horizontal position from the source node's left boundary to the edge's starting point.\n+     *\n+     * @return The relative x-coordinate from the source node.\n+     *\/\n+    public int getRelativeFromX() {\n+        return relativeFromX;\n+    }\n+\n+    \/**\n+     * Sets the relative horizontal position from the source node's left boundary to the edge's starting point.\n+     *\n+     * @param relativeFromX The relative x-coordinate to set.\n+     *\/\n+    public void setRelativeFromX(int relativeFromX) {\n+        this.relativeFromX = relativeFromX;\n+    }\n+\n+    \/**\n+     * Gets the relative horizontal position from the target node's left boundary to the edge's ending point.\n+     *\n+     * @return The relative x-coordinate to the target node.\n+     *\/\n+    public int getRelativeToX() {\n+        return relativeToX;\n+    }\n+\n+    \/**\n+     * Sets the relative horizontal position from the target node's left boundary to the edge's ending point.\n+     *\n+     * @param relativeToX The relative x-coordinate to set.\n+     *\/\n+    public void setRelativeToX(int relativeToX) {\n+        this.relativeToX = relativeToX;\n+    }\n+\n+    \/**\n+     * Gets the Link associated with this edge.\n+     *\n+     * @return The Link object.\n+     *\/\n+    public Link getLink() {\n+        return link;\n+    }\n@@ -40,4 +235,2 @@\n-        @Override\n-        public String toString() {\n-            return \"Edge \" + from + \", \" + to;\n-        }\n+    public void setLink(Link link) {\n+        this.link = link;\n@@ -45,0 +238,1 @@\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutEdge.java","additions":207,"deletions":13,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -0,0 +1,1125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.NODE_POS_COMPARATOR;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Port;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\n+\/**\n+ * The LayoutGraph class is responsible for organizing and arranging a graph's nodes and edges for visual display.\n+ * It takes a collection of nodes (Vertex) and connections between them (Link) and structures them into layers,\n+ * creating a hierarchical layout. The class handles complexities like edges that span multiple layers\n+ * by inserting temporary \"dummy\" nodes to maintain a clear hierarchy.\n+ * This organization helps ensure that when the graph is displayed, it is easy to understand and visually coherent,\n+ * making the relationships between nodes clear and straightforward.\n+ *\n+ * @author Thomas Wuerthinger\n+ *\/\n+public class LayoutGraph {\n+\n+    public static final Comparator<Link> LINK_COMPARATOR =\n+            Comparator.comparing((Link l) -> l.getFrom().getVertex())\n+                    .thenComparing(l -> l.getTo().getVertex())\n+                    .thenComparingInt(l -> l.getFrom().getRelativePosition().x)\n+                    .thenComparingInt(l -> l.getTo().getRelativePosition().x);\n+\n+    \/\/ Registered Graph Components: Links, Vertices, and Port Mappings\n+    private final Set<Link> links;\n+    private final SortedSet<Vertex> vertices;\n+    private final LinkedHashMap<Vertex, Set<Port>> inputPorts;\n+    private final LinkedHashMap<Vertex, Set<Port>> outputPorts;\n+    private final LinkedHashMap<Port, Set<Link>> portLinks;\n+\n+    \/\/ Layout Management: LayoutNodes and LayoutLayers\n+    private final LinkedHashMap<Vertex, LayoutNode> layoutNodes;\n+    private final List<LayoutNode> dummyNodes;\n+    private final List<LayoutLayer> layers;\n+    private boolean showSelfEdges = false;\n+\n+    \/**\n+     * Constructs a new LayoutGraph using the provided collection of links and additional vertices.\n+     * Initializes the graph layout structure with the given links and includes any additional vertices.\n+     *\n+     * @param links              The collection of links that represent the edges of the graph.\n+     * @param additionalVertices The collection of additional vertices to be included in the graph.\n+     *\/\n+    public LayoutGraph(Collection<? extends Link> links, Collection<? extends Vertex> additionalVertices) {\n+        this.links = new HashSet<>(links);\n+        vertices = new TreeSet<>(additionalVertices);\n+        portLinks = new LinkedHashMap<>(links.size());\n+        inputPorts = new LinkedHashMap<>(links.size());\n+        outputPorts = new LinkedHashMap<>(links.size());\n+\n+        for (Link link : links) {\n+            assert link.getFrom() != null;\n+            assert link.getTo() != null;\n+            Port fromPort = link.getFrom();\n+            Port toPort = link.getTo();\n+            Vertex fromVertex = fromPort.getVertex();\n+            Vertex toVertex = toPort.getVertex();\n+\n+            vertices.add(fromVertex);\n+            vertices.add(toVertex);\n+\n+            outputPorts.computeIfAbsent(fromVertex, k -> new HashSet<>()).add(fromPort);\n+            inputPorts.computeIfAbsent(toVertex, k -> new HashSet<>()).add(toPort);\n+\n+            portLinks.computeIfAbsent(fromPort, k -> new HashSet<>()).add(link);\n+            portLinks.computeIfAbsent(toPort, k -> new HashSet<>()).add(link);\n+        }\n+\n+        \/\/ cleanup\n+        layoutNodes = new LinkedHashMap<>();\n+        dummyNodes = new ArrayList<>();\n+        layers = new ArrayList<>();\n+    }\n+\n+    public void clearLayout() {\n+        layoutNodes.clear();\n+        dummyNodes.clear();\n+        layers.clear();\n+    }\n+\n+    public boolean showSelfEdges() {\n+        return showSelfEdges;\n+    }\n+\n+    public void setShowSelfEdges(boolean showSelfEdges) {\n+        this.showSelfEdges = showSelfEdges;\n+    }\n+\n+    \/**\n+     * Initializes or resets the layout structures by clearing existing nodes, dummy nodes, and layers.\n+     * It then sets up the layout nodes for each vertex and creates layout edges based on the sorted links.\n+     *\/\n+    public void initializeLayout() {\n+        \/\/ Reset layout structures\n+        clearLayout();\n+\n+        \/\/ Set up layout nodes for each vertex\n+        for (Vertex vertex : getVertices()) {\n+            createLayoutNode(vertex);\n+        }\n+\n+        \/\/ Set up layout edges in a sorted order for reproducibility\n+        List<Link> sortedLinks = new ArrayList<>(links);\n+        sortedLinks.sort(LINK_COMPARATOR);\n+        for (Link link : sortedLinks) {\n+            createLayoutEdge(link);\n+        }\n+    }\n+\n+    \/**\n+     * Initializes the layers of the graph with the specified number of empty layers.\n+     *\n+     * @param layerCount The number of layers to initialize.\n+     *\/\n+    public void initLayers(int layerCount) {\n+        layers.clear();\n+        for (int i = 0; i < layerCount; i++) {\n+            layers.add(new LayoutLayer());\n+        }\n+    }\n+\n+    \/**\n+     * Retrieves an unmodifiable list of dummy nodes in the graph.\n+     *\n+     * @return An unmodifiable list containing all dummy nodes in the graph.\n+     *\/\n+    public List<LayoutNode> getDummyNodes() {\n+        return Collections.unmodifiableList(dummyNodes);\n+    }\n+\n+    \/**\n+     * Retrieves a collection of all layout nodes in the graph.\n+     *\n+     * @return A collection containing all LayoutNodes.\n+     *\/\n+    public Collection<LayoutNode> getLayoutNodes() {\n+        return Collections.unmodifiableCollection(layoutNodes.values());\n+    }\n+\n+    \/**\n+     * Retrieves a combined list of all nodes in the graph,\n+     * including both layout nodes and dummy nodes.\n+     *\n+     * @return An unmodifiable list containing all nodes in the graph.\n+     *\/\n+    public List<LayoutNode> getAllNodes() {\n+        List<LayoutNode> allNodes = new ArrayList<>();\n+        allNodes.addAll(layoutNodes.values());\n+        allNodes.addAll(dummyNodes);\n+        return Collections.unmodifiableList(allNodes);\n+    }\n+\n+    \/**\n+     * Creates a new layer at the specified index in the layers list.\n+     * Adjusts the layer numbers of existing nodes in layers below the inserted layer.\n+     *\n+     * @param layerNr The index at which to insert the new layer.\n+     * @return The newly created LayoutLayer.\n+     *\/\n+    private LayoutLayer createNewLayer(int layerNr) {\n+        LayoutLayer layer = new LayoutLayer();\n+        layers.add(layerNr, layer);\n+\n+        \/\/ update layer field in nodes below layerNr\n+        for (int l = layerNr + 1; l < getLayerCount(); l++) {\n+            for (LayoutNode layoutNode : getLayer(l)) {\n+                layoutNode.setLayer(l);\n+            }\n+        }\n+        return layer;\n+    }\n+\n+    \/**\n+     * Deletes the layer at the specified index.\n+     * Adjusts the layer numbers of existing nodes in layers below the deleted layer.\n+     *\n+     * @param layerNr The index of the layer to delete.\n+     *\/\n+    private void deleteLayer(int layerNr) {\n+        layers.remove(layerNr);\n+\n+        \/\/ Update the layer field in nodes below the deleted layer\n+        for (int l = layerNr; l < getLayerCount(); l++) {\n+            for (LayoutNode layoutNode : getLayer(l)) {\n+                layoutNode.setLayer(l);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Ensures that no neighboring nodes of the specified node are in the same layer.\n+     * If any neighbor is found in the specified layer, inserts a new layer to avoid conflicts.\n+     * Returns the adjusted layer number where the node can be safely inserted.\n+     *\n+     * @param node    The LayoutNode to check and possibly reposition.\n+     * @param layerNr The proposed layer number for the node.\n+     * @return The layer number where the node can be safely inserted after adjustments.\n+     *\/\n+    public int insertNewLayerIfNeeded(LayoutNode node, int layerNr) {\n+        for (Link inputLink : getInputLinks(node.getVertex())) {\n+            if (inputLink.getFrom().getVertex() == inputLink.getTo().getVertex()) continue;\n+            LayoutNode fromNode = getLayoutNode(inputLink.getFrom().getVertex());\n+            if (fromNode.getLayer() == layerNr) {\n+                moveExpandLayerDown(layerNr + 1);\n+                return layerNr + 1;\n+            }\n+        }\n+        for (Link outputLink : getOutputLinks(node.getVertex())) {\n+            if (outputLink.getFrom().getVertex() == outputLink.getTo().getVertex()) continue;\n+            LayoutNode toNode = getLayoutNode(outputLink.getTo().getVertex());\n+            if (toNode.getLayer() == layerNr) {\n+                moveExpandLayerDown(layerNr);\n+                return layerNr;\n+            }\n+        }\n+        return layerNr;\n+\n+    }\n+\n+    \/**\n+     * Inserts a new layer at the specified index and adjusts nodes and edges accordingly.\n+     * Moves existing nodes and their successors down to accommodate the new layer.\n+     *\n+     * @param layerNr The index at which to insert the new layer.\n+     *\/\n+    private void moveExpandLayerDown(int layerNr) {\n+        LayoutLayer newLayer = createNewLayer(layerNr);\n+\n+        if (layerNr == 0) return;\n+        LayoutLayer layerAbove = getLayer(layerNr - 1);\n+\n+        for (LayoutNode fromNode : layerAbove) {\n+            int fromX = fromNode.getX();\n+            Map<Integer, List<LayoutEdge>> successorsByX = fromNode.groupSuccessorsByX();\n+            fromNode.clearSuccessors();\n+\n+            for (Map.Entry<Integer, List<LayoutEdge>> entry : successorsByX.entrySet()) {\n+                Integer relativeFromX = entry.getKey();\n+                List<LayoutEdge> edges = entry.getValue();\n+                LayoutNode dummyNode = new LayoutNode();\n+                dummyNode.setX(fromX + relativeFromX);\n+                dummyNode.setLayer(layerNr);\n+                for (LayoutEdge edge : edges) {\n+                    dummyNode.addSuccessor(edge);\n+                }\n+                LayoutEdge dummyEdge = new LayoutEdge(fromNode, dummyNode, relativeFromX, 0, edges.get(0).getLink());\n+                if (edges.get(0).isReversed()) dummyEdge.reverse();\n+\n+                fromNode.addSuccessor(dummyEdge);\n+                dummyNode.addPredecessor(dummyEdge);\n+                for (LayoutEdge edge : edges) {\n+                    edge.setFrom(dummyNode);\n+                }\n+                addDummyToLayer(dummyNode, layerNr);\n+            }\n+        }\n+\n+        newLayer.sortNodesByX();\n+    }\n+\n+    \/**\n+     * Retrieves an unmodifiable list of all layers in the graph.\n+     *\n+     * @return An unmodifiable list containing all layers.\n+     *\/\n+    public List<LayoutLayer> getLayers() {\n+        return Collections.unmodifiableList(layers);\n+    }\n+\n+    \/**\n+     * Returns the total number of layers in the graph.\n+     *\n+     * @return The number of layers.\n+     *\/\n+    public int getLayerCount() {\n+        return layers.size();\n+    }\n+\n+    \/**\n+     * Retrieves the LayoutNode associated with the specified Vertex.\n+     *\n+     * @param vertex The vertex whose LayoutNode is to be retrieved.\n+     * @return The LayoutNode corresponding to the given vertex, or null if not found.\n+     *\/\n+    public LayoutNode getLayoutNode(Vertex vertex) {\n+        return layoutNodes.get(vertex);\n+    }\n+\n+    \/**\n+     * Adds a LayoutNode to the specified layer and registers it in the graph.\n+     *\n+     * @param node        The LayoutNode to add to the layer.\n+     * @param layerNumber The index of the layer to which the node will be added.\n+     *\/\n+    public void addNodeToLayer(LayoutNode node, int layerNumber) {\n+        assert !node.isDummy();\n+        node.setLayer(layerNumber);\n+        getLayer(layerNumber).add(node);\n+        if (!layoutNodes.containsKey(node.getVertex())) {\n+            layoutNodes.put(node.getVertex(), node);\n+        }\n+    }\n+\n+    \/**\n+     * Adds a LayoutNode to the specified layer and registers it in the graph.\n+     *\n+     * @param node        The LayoutNode to add to the layer.\n+     * @param layerNumber The index of the layer to which the node will be added.\n+     *\/\n+    public void addDummyToLayer(LayoutNode node, int layerNumber) {\n+        assert node.isDummy();\n+        node.setLayer(layerNumber);\n+        getLayer(layerNumber).add(node);\n+        dummyNodes.add(node);\n+    }\n+\n+    \/**\n+     * Updates the positions of all nodes in each layer.\n+     * Should be called after changes to node positions or layer compositions.\n+     *\/\n+    public void updatePositions() {\n+        for (LayoutLayer layer : layers) {\n+            layer.updateNodeIndices();\n+        }\n+    }\n+\n+    \/\/ Create and register LayoutNode\n+    public LayoutNode createLayoutNode(Vertex vertex) {\n+        if (!vertices.contains(vertex)) {\n+            throw new IllegalArgumentException(\"Vertex does not exist in the graph: \" + vertex);\n+        }\n+        LayoutNode node = new LayoutNode(vertex);\n+        layoutNodes.put(vertex, node);\n+        return node;\n+    }\n+\n+    \/**\n+     * Creates a LayoutEdge based on the given Link and connects it to the corresponding LayoutNodes.\n+     *\n+     * @param link The Link representing the edge in the graph.\n+     * @return The newly created LayoutEdge.\n+     *\/\n+    public LayoutEdge createLayoutEdge(Link link) {\n+        LayoutEdge edge = new LayoutEdge(\n+                layoutNodes.get(link.getFrom().getVertex()),\n+                layoutNodes.get(link.getTo().getVertex()),\n+                link.getFrom().getRelativePosition().x,\n+                link.getTo().getRelativePosition().x,\n+                link);\n+        edge.getFrom().addSuccessor(edge);\n+        edge.getTo().addPredecessor(edge);\n+        return edge;\n+    }\n+\n+    \/**\n+     * Retrieves the set of all links (edges) in the graph.\n+     *\n+     * @return A set containing all links in the graph.\n+     *\/\n+    public Set<Link> getLinks() {\n+        return links;\n+    }\n+\n+    \/**\n+     * Retrieves the set of all vertices in the graph, sorted in natural order.\n+     *\n+     * @return A sorted set of all vertices in the graph.\n+     *\/\n+    public SortedSet<Vertex> getVertices() {\n+        return vertices;\n+    }\n+\n+    \/**\n+     * Checks whether the graph contains the specified vertex.\n+     *\n+     * @param vertex The vertex to check for presence in the graph.\n+     * @return True if the vertex is present, false otherwise.\n+     *\/\n+    public boolean containsVertex(Vertex vertex) {\n+        return vertices.contains(vertex);\n+    }\n+\n+    \/**\n+     * Finds all root vertices in the graph (vertices with no incoming links).\n+     *\n+     * @return A set of root vertices.\n+     *\/\n+    public Set<Vertex> findRootVertices() {\n+        return vertices.stream()\n+                .filter(v -> inputPorts.getOrDefault(v, Collections.emptySet()).isEmpty())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    \/**\n+     * Retrieves all incoming links to the specified vertex.\n+     *\n+     * @param vertex The vertex whose incoming links are to be retrieved.\n+     * @return A set of links that are incoming to the vertex.\n+     *\/\n+    public List<Link> getInputLinks(Vertex vertex) {\n+        List<Link> inputLinks = new ArrayList<>();\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            inputLinks.addAll(portLinks.getOrDefault(inputPort, Collections.emptySet()));\n+        }\n+        return inputLinks;\n+    }\n+\n+    \/**\n+     * Retrieves all outgoing links from the specified vertex.\n+     *\n+     * @param vertex The vertex whose outgoing links are to be retrieved.\n+     * @return A set of links that are outgoing from the vertex.\n+     *\/\n+    public List<Link> getOutputLinks(Vertex vertex) {\n+        List<Link> outputLinks = new ArrayList<>();\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            outputLinks.addAll(portLinks.getOrDefault(outputPort, Collections.emptySet()));\n+        }\n+        return outputLinks;\n+    }\n+\n+    public List<Link> getAllLinks(Vertex vertex) {\n+        List<Link> allLinks = new ArrayList<>();\n+\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            allLinks.addAll(portLinks.getOrDefault(inputPort, Collections.emptySet()));\n+        }\n+\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            allLinks.addAll(portLinks.getOrDefault(outputPort, Collections.emptySet()));\n+        }\n+\n+        return allLinks;\n+    }\n+\n+    \/**\n+     * Removes the specified LayoutNode and all its connected edges from the graph.\n+     *\n+     * @param node The LayoutNode to remove along with its edges.\n+     *\/\n+    public void removeNodeAndEdges(LayoutNode node) {\n+        assert !node.isDummy();\n+        removeEdges(node); \/\/ a node can only be removed together with its edges\n+        int layer = node.getLayer();\n+        layers.get(layer).remove(node);\n+        layers.get(layer).updateNodeIndices();\n+        layoutNodes.remove(node.getVertex());\n+    }\n+\n+    \/**\n+     * Removes all edges connected to the specified LayoutNode.\n+     * Handles the removal of associated dummy nodes if they are no longer needed.\n+     * Updates the graph structure accordingly after node movement.\n+     *\n+     * @param node The LayoutNode whose connected edges are to be removed.\n+     *\/\n+    public void removeEdges(LayoutNode node) {\n+        assert !node.isDummy();\n+        for (Link link : getAllLinks(node.getVertex())) {\n+            removeEdge(link);\n+        }\n+    }\n+\n+    public void removeEdge(Link link) {\n+        Vertex from = link.getFrom().getVertex();\n+        Vertex to = link.getTo().getVertex();\n+        LayoutNode toNode = getLayoutNode(to);\n+        LayoutNode fromNode = getLayoutNode(from);\n+\n+        if (toNode.getLayer() < fromNode.getLayer()) {\n+            \/\/ Reversed edge\n+            toNode = fromNode;\n+        }\n+\n+        \/\/ Remove preds-edges bottom up, starting at \"to\" node\n+        \/\/ Cannot start from \"from\" node since there might be joint edges\n+        List<LayoutEdge> toNodePredsEdges = List.copyOf(toNode.getPredecessors());\n+        for (LayoutEdge edge : toNodePredsEdges) {\n+            LayoutNode predNode = edge.getFrom();\n+            LayoutEdge edgeToRemove;\n+\n+            if (edge.getLink() != null && edge.getLink().equals(link)) {\n+                toNode.removePredecessor(edge);\n+                edgeToRemove = edge;\n+            } else {\n+                \/\/ Wrong edge, look at next\n+                continue;\n+            }\n+\n+            if (!predNode.isDummy() && predNode.getVertex().equals(from)) {\n+                \/\/ No dummy nodes inbetween 'from' and 'to' vertex\n+                predNode.removeSuccessor(edgeToRemove);\n+                break;\n+            } else {\n+                \/\/ Must remove edges between dummy nodes\n+                boolean found = true;\n+                LayoutNode succNode = toNode;\n+                while (predNode.isDummy() && found) {\n+                    found = false;\n+\n+                    if (predNode.getSuccessors().size() <= 1 && predNode.getPredecessors().size() <= 1) {\n+                        \/\/ Dummy node used only for this link, remove if not already removed\n+                        assert predNode.isDummy();\n+                        int layer = predNode.getLayer();\n+                        layers.get(layer).remove(predNode);\n+                        layers.get(layer).updateNodeIndices();\n+                        dummyNodes.remove(predNode);\n+                    } else {\n+                        \/\/ anchor node, should not be removed\n+                        break;\n+                    }\n+\n+                    if (predNode.getPredecessors().size() == 1) {\n+                        predNode.removeSuccessor(edgeToRemove);\n+                        succNode = predNode;\n+                        edgeToRemove = predNode.getPredecessors().get(0);\n+                        predNode = edgeToRemove.getFrom();\n+                        found = true;\n+                    }\n+                }\n+\n+                predNode.removeSuccessor(edgeToRemove);\n+                succNode.removePredecessor(edgeToRemove);\n+            }\n+            break;\n+        }\n+\n+        if (fromNode.getReversedLinkStartPoints().containsKey(link)) {\n+            fromNode.computeReversedLinkPoints(false);\n+        }\n+        if (toNode.getReversedLinkStartPoints().containsKey(link)) {\n+            toNode.computeReversedLinkPoints(false);\n+        }\n+    }\n+\n+    \/**\n+     * Retrieves the LayoutLayer at the specified index.\n+     *\n+     * @param layerNr The index of the layer to retrieve.\n+     * @return The LayoutLayer at the specified index.\n+     *\/\n+    public LayoutLayer getLayer(int layerNr) {\n+        return layers.get(layerNr);\n+    }\n+\n+    \/**\n+     * Finds the layer closest to the given y-coordinate.\n+     *\n+     * @param y the y-coordinate to check\n+     * @return the index of the optimal layer, or -1 if no layers are found\n+     *\/\n+    public int findLayer(int y) {\n+        int optimalLayer = -1;\n+        int minDistance = Integer.MAX_VALUE;\n+        for (int l = 0; l < getLayerCount(); l++) {\n+            \/\/ Check if y is within this layer's bounds\n+            if (y >= getLayer(l).getTop() && y <= getLayer(l).getBottom()) {\n+                return l;\n+            }\n+\n+            int distance = Math.abs(getLayer(l).getCenter() - y);\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                optimalLayer = l;\n+            }\n+        }\n+        return optimalLayer;\n+    }\n+\n+    \/**\n+     * Positions the layers vertically, calculating their heights and setting their positions.\n+     * Centers the nodes within each layer vertically.\n+     *\/\n+    public void positionLayers() {\n+        int currentY = 0;\n+        for (LayoutLayer layer : getLayers()) {\n+            layer.setTop(currentY);\n+\n+            \/\/ Calculate the maximum layer height and set it for the layer\n+            int maxLayerHeight = layer.calculateMaxLayerHeight();\n+            layer.setHeight(maxLayerHeight);\n+\n+            \/\/ Center nodes vertically within the layer\n+            layer.centerNodesVertically();\n+\n+            \/\/ Update currentY to account for the padded bottom of this layer\n+            currentY += layer.calculatePaddedHeight();\n+        }\n+    }\n+\n+    \/**\n+     * Optimizes routing of reversed (back) edges to reduce crossings.\n+     *\/\n+    public void optimizeBackEdgeCrossings() {\n+        for (LayoutNode node : getLayoutNodes()) {\n+            node.optimizeBackEdgeCrossing();\n+        }\n+    }\n+\n+    \/**\n+     * Removes empty layers from the graph.\n+     * Iteratively checks for and removes layers that contain only dummy nodes.\n+     *\/\n+    public void removeEmptyLayers() {\n+        int i = 0;\n+        while (i < getLayerCount()) {\n+            LayoutLayer layer = getLayer(i);\n+            if (layer.containsOnlyDummyNodes()) {\n+                removeEmptyLayer(i);\n+            } else {\n+                i++; \/\/ Move to the next layer only if no removal occurred\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Removes the layer at the specified index if it is empty or contains only dummy nodes.\n+     * Adjusts the positions of nodes and edges accordingly.\n+     *\n+     * @param layerNr The index of the layer to remove.\n+     *\/\n+    private void removeEmptyLayer(int layerNr) {\n+        LayoutLayer layer = getLayer(layerNr);\n+        if (!layer.containsOnlyDummyNodes()) return;\n+\n+        for (LayoutNode dummyNode : layer) {\n+            if (dummyNode.getSuccessors().isEmpty()) {\n+                dummyNode.setLayer(layerNr + 1);\n+                getLayer(layerNr + 1).add(dummyNode);\n+                dummyNode.setX(dummyNode.calculateOptimalXFromPredecessors(true));\n+                getLayer(layerNr + 1).sortNodesByX();\n+                continue;\n+            } else if (dummyNode.getPredecessors().isEmpty()) {\n+                dummyNode.setLayer(layerNr - 1);\n+                dummyNode.setX(dummyNode.calculateOptimalXFromSuccessors(true));\n+                getLayer(layerNr - 1).add(dummyNode);\n+                getLayer(layerNr - 1).sortNodesByX();\n+                continue;\n+            }\n+            LayoutEdge layoutEdge = dummyNode.getPredecessors().get(0);\n+\n+            \/\/ remove the layoutEdge\n+            LayoutNode fromNode = layoutEdge.getFrom();\n+            fromNode.removeSuccessor(layoutEdge);\n+\n+            List<LayoutEdge> successorEdges = dummyNode.getSuccessors();\n+            for (LayoutEdge successorEdge : successorEdges) {\n+                successorEdge.setRelativeFromX(layoutEdge.getRelativeFromX());\n+                successorEdge.setFrom(fromNode);\n+                fromNode.addSuccessor(successorEdge);\n+            }\n+            dummyNode.clearPredecessors();\n+            dummyNode.clearSuccessors();\n+            dummyNodes.remove(dummyNode);\n+        }\n+\n+        deleteLayer(layerNr);\n+    }\n+\n+    \/**\n+     * Repositions the specified LayoutNode horizontally within its layer to the new x-coordinate.\n+     * Ensures no overlap with adjacent nodes and maintains minimum spacing.\n+     *\n+     * @param layoutNode The LayoutNode to reposition.\n+     * @param newX       The new x-coordinate to set for the node.\n+     *\/\n+    private void repositionLayoutNodeX(LayoutNode layoutNode, int newX) {\n+        int currentX = layoutNode.getX();\n+\n+        \/\/ Early exit if the desired position is the same as the current position\n+        if (newX == currentX) {\n+            return;\n+        }\n+\n+        LayoutLayer layer = getLayer(layoutNode.getLayer());\n+        if (newX > currentX) {\n+            layer.tryShiftNodeRight(layoutNode, newX);\n+        } else {\n+            layer.tryShiftNodeLeft(layoutNode, newX);\n+        }\n+    }\n+\n+    \/**\n+     * Aligns the x-coordinate of a single dummy successor node for the given LayoutNode.\n+     * If the node has exactly one successor and that successor is a dummy node,\n+     * sets the dummy node's x-coordinate to align with the current node or the edge's starting point.\n+     *\n+     * @param node The LayoutNode whose dummy successor is to be aligned.\n+     *\/\n+    private void alignSingleSuccessorDummyNodeX(LayoutNode node) {\n+        \/\/ Retrieve the list of successor edges\n+        List<LayoutEdge> successors = node.getSuccessors();\n+\n+        \/\/ Proceed only if there is exactly one successor\n+        if (successors.size() != 1) {\n+            return;\n+        }\n+\n+        LayoutEdge successorEdge = successors.get(0);\n+        LayoutNode successorNode = successorEdge.getTo();\n+\n+        \/\/ Proceed only if the successor node is a dummy node\n+        if (!successorNode.isDummy()) {\n+            return;\n+        }\n+\n+        \/\/ Determine the target x-coordinate based on whether the current node is a dummy\n+        int targetX = node.isDummy() ? node.getX() : successorEdge.getStartX();\n+\n+        \/\/ Align the successor dummy node to the target x-coordinate\n+        repositionLayoutNodeX(successorNode, targetX);\n+    }\n+\n+    \/**\n+     * Aligns the x-coordinates of dummy successor nodes within the specified layer.\n+     * Performs alignment in both forward and backward directions to ensure consistency.\n+     *\n+     * @param layer The LayoutLayer whose nodes' dummy successors need alignment.\n+     *\/\n+    private void alignLayerDummySuccessors(LayoutLayer layer) {\n+        \/\/ Forward pass: Align dummy successors from the first node to the last.\n+        for (LayoutNode node : layer) {\n+            alignSingleSuccessorDummyNodeX(node);\n+        }\n+\n+        \/\/ Backward pass: Align dummy successors from the last node to the first.\n+        for (int i = layer.size() - 1; i >= 0; i--) {\n+            LayoutNode node = layer.get(i);\n+            alignSingleSuccessorDummyNodeX(node);\n+        }\n+    }\n+\n+    \/**\n+     * Straightens edges in the graph by aligning dummy nodes to reduce bends.\n+     * Processes all layers to align dummy successor nodes.\n+     *\/\n+    public void straightenEdges() {\n+        \/\/ Forward pass: Align dummy successors from the first layer to the last.\n+        for (int i = 0; i < getLayerCount(); i++) {\n+            alignLayerDummySuccessors(getLayer(i));\n+        }\n+\n+        \/\/ Backward pass: Align dummy successors from the last layer to the first.\n+        for (int i = getLayerCount() - 1; i >= 0; i--) {\n+            alignLayerDummySuccessors(getLayer(i));\n+        }\n+    }\n+\n+    \/**\n+     * Updates the minimum X spacing for all layers in the graph.\n+     *\/\n+    public void updateLayerMinXSpacing() {\n+        for (LayoutLayer layer : this.getLayers()) {\n+            layer.updateMinXSpacing(false);\n+        }\n+    }\n+\n+    \/**\n+     * Calculates the optimal horizontal position (index) for the specified node within the given layer,\n+     * aiming to minimize the number of edge crossings.\n+     *\n+     * @param node    The node to position.\n+     * @param layerNr The index of the layer in which to position the node.\n+     * @return The optimal position index within the layer for the node.\n+     *\/\n+    private int optimalPosition(LayoutNode node, int layerNr) {\n+        getLayer(layerNr).sort(NODE_POS_COMPARATOR);\n+        int edgeCrossings = Integer.MAX_VALUE;\n+        int optimalPos = -1;\n+\n+        \/\/ Try each possible position in the layerNr\n+        for (int i = 0; i < getLayer(layerNr).size() + 1; i++) {\n+            int xCoord;\n+            if (i == 0) {\n+                xCoord = getLayer(layerNr).get(i).getX() - node.getWidth() - 1;\n+            } else {\n+                xCoord = getLayer(layerNr).get(i - 1).getX() + getLayer(layerNr).get(i - 1).getWidth() + 1;\n+            }\n+\n+            int currentCrossings = 0;\n+\n+            if (0 <= layerNr - 1) {\n+                \/\/ For each link with an end point in vertex, check how many edges cross it\n+                for (LayoutEdge edge : node.getPredecessors()) {\n+                    if (edge.getFrom().getLayer() == layerNr - 1) {\n+                        int fromNodeXCoord = edge.getFromX();\n+                        int toNodeXCoord = xCoord;\n+                        if (!node.isDummy()) {\n+                            toNodeXCoord += edge.getRelativeToX();\n+                        }\n+                        for (LayoutNode n : getLayer(layerNr - 1)) {\n+                            for (LayoutEdge e : n.getSuccessors()) {\n+                                if (e.getTo() == null) {\n+                                    continue;\n+                                }\n+                                int compFromXCoord = e.getFromX();\n+                                int compToXCoord = e.getToX();\n+                                if ((fromNodeXCoord > compFromXCoord && toNodeXCoord < compToXCoord)\n+                                        || (fromNodeXCoord < compFromXCoord\n+                                        && toNodeXCoord > compToXCoord)) {\n+                                    currentCrossings += 1;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            \/\/ Edge crossings across current layerNr and layerNr below\n+            if (layerNr + 1 < getLayerCount()) {\n+                \/\/ For each link with an end point in vertex, check how many edges cross it\n+                for (LayoutEdge edge : node.getSuccessors()) {\n+                    if (edge.getTo().getLayer() == layerNr + 1) {\n+                        int toNodeXCoord = edge.getToX();\n+                        int fromNodeXCoord = xCoord;\n+                        if (!node.isDummy()) {\n+                            fromNodeXCoord += edge.getRelativeFromX();\n+                        }\n+                        for (LayoutNode n : getLayer(layerNr + 1)) {\n+                            for (LayoutEdge e : n.getPredecessors()) {\n+                                if (e.getFrom() == null) {\n+                                    continue;\n+                                }\n+                                int compFromXCoord = e.getFromX();\n+                                int compToXCoord = e.getToX();\n+                                if ((fromNodeXCoord > compFromXCoord && toNodeXCoord < compToXCoord)\n+                                        || (fromNodeXCoord < compFromXCoord\n+                                        && toNodeXCoord > compToXCoord)) {\n+                                    currentCrossings += 1;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (currentCrossings <= edgeCrossings) {\n+                edgeCrossings = currentCrossings;\n+                optimalPos = i;\n+            }\n+        }\n+        return optimalPos;\n+    }\n+\n+    \/**\n+     * Creates layout edges for the specified node and reverses edges as needed.\n+     * Reverses edges that go from lower to higher layers to maintain proper layering.\n+     *\n+     * @param node The LayoutNode for which to create and reverse edges.\n+     *\/\n+    public void createAndReverseLayoutEdges(LayoutNode node) {\n+        List<Link> nodeLinks = new ArrayList<>(getInputLinks(node.getVertex()));\n+        nodeLinks.addAll(getOutputLinks(node.getVertex()));\n+        nodeLinks.sort(LINK_COMPARATOR);\n+\n+        List<LayoutNode> reversedLayoutNodes = new ArrayList<>();\n+        for (Link link : nodeLinks) {\n+            if (link.getFrom().getVertex() == link.getTo().getVertex()) continue;\n+            LayoutEdge layoutEdge = createLayoutEdge(link);\n+\n+            LayoutNode fromNode = layoutEdge.getFrom();\n+            LayoutNode toNode = layoutEdge.getTo();\n+\n+            if (fromNode.getLayer() > toNode.getLayer()) {\n+                HierarchicalLayoutManager.ReverseEdges.reverseEdge(layoutEdge);\n+                reversedLayoutNodes.add(fromNode);\n+                reversedLayoutNodes.add(toNode);\n+            }\n+        }\n+\n+        \/\/ ReverseEdges\n+        for (LayoutNode layoutNode : reversedLayoutNodes) {\n+            layoutNode.computeReversedLinkPoints(false);\n+        }\n+    }\n+\n+    \/**\n+     * Inserts dummy nodes along the edges from predecessors of the specified node,\n+     * for edges that span more than one layer.\n+     *\n+     * @param layoutNode The node for which to create predecessor dummy nodes.\n+     *\/\n+    public void createDummiesForNodePredecessor(LayoutNode layoutNode) {\n+        for (LayoutEdge predEdge : layoutNode.getPredecessors()) {\n+            LayoutNode fromNode = predEdge.getFrom();\n+            LayoutNode toNode = predEdge.getTo();\n+            if (Math.abs(toNode.getLayer() - fromNode.getLayer()) <= 1) continue;\n+\n+            boolean hasEdgeFromSamePort = false;\n+            LayoutEdge edgeFromSamePort = new LayoutEdge(fromNode, toNode, predEdge.getLink());\n+            if (predEdge.isReversed()) edgeFromSamePort.reverse();\n+\n+            for (LayoutEdge succEdge : fromNode.getSuccessors()) {\n+                if (succEdge.getRelativeFromX() == predEdge.getRelativeFromX() && succEdge.getTo().isDummy()) {\n+                    edgeFromSamePort = succEdge;\n+                    hasEdgeFromSamePort = true;\n+                    break;\n+                }\n+            }\n+\n+            if (hasEdgeFromSamePort) {\n+                LayoutEdge curEdge = edgeFromSamePort;\n+                boolean newEdge = true;\n+                while (curEdge.getTo().getLayer() < toNode.getLayer() - 1 && curEdge.getTo().isDummy() && newEdge) {\n+                    \/\/ Traverse down the chain of dummy nodes linking together the edges originating\n+                    \/\/ from the same port\n+                    newEdge = false;\n+                    if (curEdge.getTo().getSuccessors().size() == 1) {\n+                        curEdge = curEdge.getTo().getSuccessors().get(0);\n+                        newEdge = true;\n+                    } else {\n+                        for (LayoutEdge e : curEdge.getTo().getSuccessors()) {\n+                            if (e.getTo().isDummy()) {\n+                                curEdge = e;\n+                                newEdge = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                LayoutNode prevDummy;\n+                if (!curEdge.getTo().isDummy()) {\n+                    prevDummy = curEdge.getFrom();\n+                } else {\n+                    prevDummy = curEdge.getTo();\n+                }\n+\n+                predEdge.setFrom(prevDummy);\n+                predEdge.setRelativeFromX(prevDummy.getWidth() \/ 2);\n+                fromNode.removeSuccessor(predEdge);\n+                prevDummy.addSuccessor(predEdge);\n+            }\n+\n+            LayoutNode layoutNode1 = predEdge.getTo();\n+            if (predEdge.getTo().getLayer() - 1 > predEdge.getFrom().getLayer()) {\n+                LayoutEdge prevEdge = predEdge;\n+                for (int l = layoutNode1.getLayer() - 1; l > prevEdge.getFrom().getLayer(); l--) {\n+                    LayoutNode dummyNode = new LayoutNode();\n+                    dummyNode.addSuccessor(prevEdge);\n+                    LayoutEdge result = new LayoutEdge(prevEdge.getFrom(), dummyNode, prevEdge.getRelativeFromX(), 0, prevEdge.getLink());\n+                    if (prevEdge.isReversed()) result.reverse();\n+                    dummyNode.addPredecessor(result);\n+                    prevEdge.setRelativeFromX(0);\n+                    prevEdge.getFrom().removeSuccessor(prevEdge);\n+                    prevEdge.getFrom().addSuccessor(result);\n+                    prevEdge.setFrom(dummyNode);\n+                    dummyNode.setLayer(l);\n+                    List<LayoutNode> layerNodes = getLayer(l);\n+                    if (layerNodes.isEmpty()) {\n+                        dummyNode.setPos(0);\n+                    } else {\n+                        dummyNode.setPos(optimalPosition(dummyNode, l));\n+                    }\n+                    for (LayoutNode n : layerNodes) {\n+                        if (n.getPos() >= dummyNode.getPos()) {\n+                            n.setPos(n.getPos() + 1);\n+                        }\n+                    }\n+                    addDummyToLayer(dummyNode, l);\n+                    prevEdge = dummyNode.getPredecessors().get(0);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Inserts dummy nodes along the edges to successors of the specified node,\n+     * for edges that span more than one layer.\n+     * Can limit the maximum length of layers an edge spans using maxLayerLength.\n+     *\n+     * @param layoutNode     The node for which to create successor dummy nodes.\n+     * @param maxLayerLength The maximum number of layers an edge can span without splitting it\n+     *\/\n+    public void createDummiesForNodeSuccessor(LayoutNode layoutNode, int maxLayerLength) {\n+        LinkedHashMap<Integer, List<LayoutEdge>> portsToUnprocessedEdges = new LinkedHashMap<>();\n+        ArrayList<LayoutEdge> succs = new ArrayList<>(layoutNode.getSuccessors());\n+        LinkedHashMap<Integer, LayoutNode> portToTopNode = new LinkedHashMap<>();\n+        LinkedHashMap<Integer, LinkedHashMap<Integer, LayoutNode>> portToBottomNodeMapping = new LinkedHashMap<>();\n+        for (LayoutEdge succEdge : succs) {\n+            int startPort = succEdge.getRelativeFromX();\n+            LayoutNode fromNode = succEdge.getFrom();\n+            LayoutNode toNode = succEdge.getTo();\n+\n+            \/\/ edge is longer than one layer => needs dummy nodes\n+            if (fromNode.getLayer() != toNode.getLayer() - 1) {\n+                \/\/ the edge needs to be cut\n+                if (maxLayerLength != -1 && toNode.getLayer() - fromNode.getLayer() > maxLayerLength) {\n+                    \/\/ remove the succEdge before replacing it\n+                    toNode.removePredecessor(succEdge);\n+                    fromNode.removeSuccessor(succEdge);\n+\n+                    LayoutNode topCutNode = portToTopNode.get(startPort);\n+                    if (topCutNode == null) {\n+                        topCutNode = new LayoutNode();\n+                        topCutNode.setLayer(fromNode.getLayer() + 1);\n+                        addDummyToLayer(topCutNode, topCutNode.getLayer());\n+                        portToTopNode.put(startPort, topCutNode);\n+                        portToBottomNodeMapping.put(startPort, new LinkedHashMap<>());\n+                    }\n+                    LayoutEdge edgeToTopCut = new LayoutEdge(fromNode, topCutNode, succEdge.getRelativeFromX(), topCutNode.getWidth() \/ 2, succEdge.getLink());\n+                    if (succEdge.isReversed()) edgeToTopCut.reverse();\n+                    fromNode.addSuccessor(edgeToTopCut);\n+                    topCutNode.addPredecessor(edgeToTopCut);\n+\n+                    LinkedHashMap<Integer, LayoutNode> layerToBottomNode = portToBottomNodeMapping.get(startPort);\n+                    LayoutNode bottomCutNode = layerToBottomNode.get(toNode.getLayer());\n+                    if (bottomCutNode == null) {\n+                        bottomCutNode = new LayoutNode();\n+                        bottomCutNode.setLayer(toNode.getLayer() - 1);\n+                        addDummyToLayer(bottomCutNode, bottomCutNode.getLayer());\n+                        layerToBottomNode.put(toNode.getLayer(), bottomCutNode);\n+                    }\n+                    LayoutEdge bottomEdge = new LayoutEdge(bottomCutNode, toNode, bottomCutNode.getWidth() \/ 2, succEdge.getRelativeToX(), succEdge.getLink());\n+                    if (succEdge.isReversed()) bottomEdge.reverse();\n+                    toNode.addPredecessor(bottomEdge);\n+                    bottomCutNode.addSuccessor(bottomEdge);\n+\n+                } else { \/\/ the edge is not cut, but needs dummy nodes\n+                    portsToUnprocessedEdges.putIfAbsent(startPort, new ArrayList<>());\n+                    portsToUnprocessedEdges.get(startPort).add(succEdge);\n+                }\n+            }\n+        }\n+\n+        for (Map.Entry<Integer, List<LayoutEdge>> portToUnprocessedEdges : portsToUnprocessedEdges.entrySet()) {\n+            Integer startPort = portToUnprocessedEdges.getKey();\n+            List<LayoutEdge> unprocessedEdges = portToUnprocessedEdges.getValue();\n+            unprocessedEdges.sort(Comparator.comparingInt(e -> e.getTo().getLayer()));\n+\n+            if (unprocessedEdges.size() == 1) {\n+                \/\/ process a single edge\n+                LayoutEdge singleEdge = unprocessedEdges.get(0);\n+                LayoutNode fromNode = singleEdge.getFrom();\n+                if (singleEdge.getTo().getLayer() > fromNode.getLayer() + 1) {\n+                    LayoutEdge previousEdge = singleEdge;\n+                    for (int i = fromNode.getLayer() + 1; i < previousEdge.getTo().getLayer(); i++) {\n+                        LayoutNode dummyNode = new LayoutNode();\n+                        dummyNode.setLayer(i);\n+                        dummyNode.addPredecessor(previousEdge);\n+                        addDummyToLayer(dummyNode, dummyNode.getLayer());\n+                        LayoutEdge dummyEdge = new LayoutEdge(dummyNode, previousEdge.getTo(), dummyNode.getWidth() \/ 2, previousEdge.getRelativeToX(), singleEdge.getLink());\n+                        if (previousEdge.isReversed()) dummyEdge.reverse();\n+                        dummyNode.addSuccessor(dummyEdge);\n+                        previousEdge.setRelativeToX(dummyNode.getWidth() \/ 2);\n+                        previousEdge.getTo().removePredecessor(previousEdge);\n+                        previousEdge.getTo().addPredecessor(dummyEdge);\n+                        previousEdge.setTo(dummyNode);\n+                        previousEdge = dummyEdge;\n+                    }\n+                }\n+            } else {\n+                int lastLayer = unprocessedEdges.get(unprocessedEdges.size() - 1).getTo().getLayer();\n+                int dummyCnt = lastLayer - layoutNode.getLayer() - 1;\n+                LayoutEdge[] newDummyEdges = new LayoutEdge[dummyCnt];\n+                LayoutNode[] newDummyNodes = new LayoutNode[dummyCnt];\n+\n+                newDummyNodes[0] = new LayoutNode();\n+                newDummyNodes[0].setLayer(layoutNode.getLayer() + 1);\n+                newDummyEdges[0] = new LayoutEdge(layoutNode, newDummyNodes[0], startPort, newDummyNodes[0].getWidth() \/ 2, null);\n+                newDummyNodes[0].addPredecessor(newDummyEdges[0]);\n+                layoutNode.addSuccessor(newDummyEdges[0]);\n+                for (int j = 1; j < dummyCnt; j++) {\n+                    newDummyNodes[j] = new LayoutNode();\n+                    newDummyNodes[j].setLayer(layoutNode.getLayer() + j + 1);\n+                    newDummyEdges[j] = new LayoutEdge(newDummyNodes[j - 1], newDummyNodes[j], null);\n+                    newDummyNodes[j].addPredecessor(newDummyEdges[j]);\n+                    newDummyNodes[j - 1].addSuccessor(newDummyEdges[j]);\n+                }\n+                for (LayoutEdge unprocessedEdge : unprocessedEdges) {\n+                    LayoutNode anchorNode = newDummyNodes[unprocessedEdge.getTo().getLayer() - layoutNode.getLayer() - 2];\n+                    anchorNode.addSuccessor(unprocessedEdge);\n+                    unprocessedEdge.setFrom(anchorNode);\n+                    unprocessedEdge.setRelativeFromX(anchorNode.getWidth() \/ 2);\n+                    layoutNode.removeSuccessor(unprocessedEdge);\n+                }\n+                for (LayoutNode dummyNode : newDummyNodes) {\n+                    addDummyToLayer(dummyNode, dummyNode.getLayer());\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Adds edges connected to the specified node, including any necessary dummy nodes.\n+     * Handles edge reversal, dummy node insertion for both predecessors and successors,\n+     * and updates node positions accordingly.\n+     *\n+     * @param node           The LayoutNode to which edges will be added.\n+     * @param maxLayerLength The maximum number of layers an edge can span without splitting it\n+     *\/\n+    public void addEdges(LayoutNode node, int maxLayerLength) {\n+        assert !node.isDummy();\n+        createAndReverseLayoutEdges(node);\n+        createDummiesForNodeSuccessor(node, maxLayerLength);\n+        createDummiesForNodePredecessor(node);\n+        updatePositions();\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutGraph.java","additions":1125,"deletions":0,"binary":false,"changes":1125,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.*;\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.NODE_X_COMPARATOR;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+\/**\n+ * The LayoutLayer class represents a single horizontal layer in a hierarchical graph layout.\n+ * It holds a list of nodes (LayoutNode) that are all on the same vertical level.\n+ * This class provides simple methods to manage these nodes: you can add nodes to the layer,\n+ * calculate the maximum height needed to fit all nodes, center the nodes vertically within the layer, and set\n+ * their horizontal positions with proper spacing. In essence, LayoutLayer helps organize nodes neatly in a graph,\n+ * making it easier to display the graph clearly and understand the relationships between nodes.\n+ *\/\n+public class LayoutLayer extends ArrayList<LayoutNode> {\n+\n+    private int height = 0;\n+    private int y = 0;\n+\n+    \/**\n+     * Adds all LayoutNodes from the specified collection to this layer.\n+     * Updates the layer's height based on the nodes added.\n+     *\n+     * @param c The collection of LayoutNodes to be added.\n+     * @return true if this layer changed as a result of the call.\n+     *\/\n+    @Override\n+    public boolean addAll(Collection<? extends LayoutNode> c) {\n+        c.forEach(this::updateLayerHeight);\n+        return super.addAll(c);\n+    }\n+\n+    \/**\n+     * Adds a single LayoutNode to this layer.\n+     * Updates the layer's height based on the node added.\n+     *\n+     * @param n The LayoutNode to be added.\n+     * @return true if the node was added successfully.\n+     *\/\n+    @Override\n+    public boolean add(LayoutNode n) {\n+        updateLayerHeight(n);\n+        return super.add(n);\n+    }\n+\n+    \/**\n+     * Updates the layer's height if the outer height of the given node exceeds the current height.\n+     *\n+     * @param n The LayoutNode whose height is to be considered.\n+     *\/\n+    private void updateLayerHeight(LayoutNode n) {\n+        height = Math.max(height, n.getOuterHeight());\n+    }\n+\n+    \/**\n+     * Calculates and returns the maximum height among the nodes in this layer, including their margins.\n+     * Adjusts the top and bottom margins of non-dummy nodes to be equal, effectively centering them vertically.\n+     *\n+     * @return The maximum outer height of nodes in this layer.\n+     *\/\n+    public int calculateMaxLayerHeight() {\n+        int maxLayerHeight = 0;\n+        for (LayoutNode layoutNode : this) {\n+            if (!layoutNode.isDummy()) {\n+                \/\/ Center the node by setting equal top and bottom margins\n+                layoutNode.centerNode();\n+            }\n+            maxLayerHeight = Math.max(maxLayerHeight, layoutNode.getOuterHeight());\n+        }\n+        return maxLayerHeight;\n+    }\n+\n+    \/**\n+     * Calculates and returns the total height of this layer, including additional padding\n+     * based on the maximum horizontal offset among the edges of its nodes.\n+     * This padding helps in scaling the layer vertically to accommodate edge bends and crossings.\n+     *\n+     * @return The total padded height of the layer.\n+     *\/\n+    public int calculatePaddedHeight() {\n+        int maxXOffset = 0;\n+\n+        for (LayoutNode layoutNode : this) {\n+            for (LayoutEdge succEdge : layoutNode.getSuccessors()) {\n+                maxXOffset = Math.max(Math.abs(succEdge.getStartX() - succEdge.getEndX()), maxXOffset);\n+            }\n+        }\n+\n+        int scalePaddedBottom = this.getHeight();\n+        scalePaddedBottom += (int) (SCALE_LAYER_PADDING * Math.max((int) (Math.sqrt(maxXOffset) * 2), LAYER_OFFSET * 3));\n+        return scalePaddedBottom;\n+    }\n+\n+    \/**\n+     * Centers all nodes in this layer vertically within the layer's assigned space.\n+     * Adjusts each node's Y-coordinate so that it is centered based on the layer's top and height.\n+     *\/\n+    public void centerNodesVertically() {\n+        for (LayoutNode layoutNode : this) {\n+            int centeredY = getTop() + (getHeight() - layoutNode.getOuterHeight()) \/ 2;\n+            layoutNode.setY(centeredY);\n+        }\n+    }\n+\n+    \/**\n+     * Shifts the top Y-coordinate of this layer by the specified amount.\n+     * Useful for moving the entire layer up or down.\n+     *\n+     * @param shift The amount to shift the layer's top position. Positive values move it down.\n+     *\/\n+    public void moveLayerVertically(int shift) {\n+        y += shift;\n+    }\n+\n+    \/**\n+     * Gets the top Y-coordinate of this layer.\n+     *\n+     * @return The Y-coordinate representing the top of the layer.\n+     *\/\n+    public int getTop() {\n+        return y;\n+    }\n+\n+    \/**\n+     * Sets the top Y-coordinate of this layer.\n+     *\n+     * @param top The Y-coordinate representing the top of the layer.\n+     *\/\n+    public void setTop(int top) {\n+        y = top;\n+    }\n+\n+    public int getCenter() {\n+        return y + height \/ 2;\n+    }\n+\n+    \/**\n+     * Gets the bottom Y-coordinate of this layer.\n+     *\n+     * @return The Y-coordinate representing the bottom of the layer.\n+     *\/\n+    public int getBottom() {\n+        return y + height;\n+    }\n+\n+    \/**\n+     * Gets the height of this layer.\n+     *\n+     * @return The height of the layer.\n+     *\/\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    \/**\n+     * Sets the height of this layer.\n+     *\n+     * @param height The height to set for the layer.\n+     *\/\n+    public void setHeight(int height) {\n+        this.height = height;\n+    }\n+\n+    \/**\n+     * Checks if this layer contains only dummy nodes.\n+     *\n+     * @return true if all nodes in the layer are dummy nodes; false otherwise.\n+     *\/\n+    public boolean containsOnlyDummyNodes() {\n+        for (LayoutNode node : this) {\n+            if (!node.isDummy()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Sorts the nodes in this layer by their X-coordinate in increasing order.\n+     * Assigns position indices to nodes based on the sorted order.\n+     * Adjusts the X-coordinates of nodes to ensure minimum spacing between them.\n+     *\/\n+    public void sortNodesByX() {\n+        if (isEmpty()) return;\n+\n+        sort(NODE_X_COMPARATOR); \/\/ Sort nodes in the layer increasingly by x\n+\n+        updateNodeIndices();\n+        updateMinXSpacing(false);\n+    }\n+\n+    \/**\n+     * Ensures nodes have minimum horizontal spacing by adjusting their X positions.\n+     *\n+     * @param startFromZero if true, starts positioning from X = 0; otherwise, uses the first node's current X.\n+     *\/\n+    public void updateMinXSpacing(boolean startFromZero) {\n+        if (isEmpty()) {\n+            return; \/\/ No nodes to adjust.\n+        }\n+\n+        int minX = startFromZero ? 0 : this.get(0).getX();\n+\n+        for (LayoutNode node : this) {\n+            int x = Math.max(node.getX(), minX);\n+            node.setX(x);\n+            minX = x + node.getOuterWidth() + NODE_OFFSET;\n+        }\n+    }\n+\n+    \/**\n+     * Initializes nodes' X positions with spacing.\n+     *\/\n+    public void initXPositions() {\n+        int curX = 0;\n+        for (LayoutNode node : this) {\n+            node.setX(curX);\n+            curX += node.getOuterWidth() + NODE_OFFSET;\n+        }\n+    }\n+\n+    \/**\n+     * Updates the position indices of the nodes in this layer based on their order in the list.\n+     * Useful after nodes have been added or removed to ensure position indices are consistent.\n+     *\/\n+    public void updateNodeIndices() {\n+        int pos = 0;\n+        for (LayoutNode layoutNode : this) {\n+            layoutNode.setPos(pos);\n+            pos++;\n+        }\n+    }\n+\n+    \/**\n+     * Attempts to move the specified node to the right within the layer to the given X-coordinate.\n+     * Ensures that the node does not overlap with its right neighbor by checking required spacing.\n+     * If movement is possible without causing overlap, the node's X-coordinate is updated.\n+     *\n+     * @param layoutNode The node to move.\n+     * @param newX       The desired new X-coordinate for the node.\n+     *\/\n+    public void tryShiftNodeRight(LayoutNode layoutNode, int newX) {\n+        int currentX = layoutNode.getX();\n+        int shiftAmount = newX - currentX;\n+        int rightPos = layoutNode.getPos() + 1;\n+\n+        if (rightPos < size()) {\n+            \/\/ There is a right neighbor\n+            LayoutNode rightNeighbor = get(rightPos);\n+            int proposedRightEdge = layoutNode.getRight() + shiftAmount;\n+            int requiredLeftEdge = rightNeighbor.getOuterLeft() - NODE_OFFSET;\n+\n+            if (proposedRightEdge <= requiredLeftEdge) {\n+                layoutNode.setX(newX);\n+            }\n+        } else {\n+            \/\/ No right neighbor; safe to move freely to the right\n+            layoutNode.setX(newX);\n+        }\n+    }\n+\n+    \/**\n+     * Attempts to move the specified node to the left within the layer to the given X-coordinate.\n+     * Ensures that the node does not overlap with its left neighbor by checking required spacing.\n+     * If movement is possible without causing overlap, the node's X-coordinate is updated.\n+     *\n+     * @param layoutNode The node to move.\n+     * @param newX       The desired new X-coordinate for the node.\n+     *\/\n+    public void tryShiftNodeLeft(LayoutNode layoutNode, int newX) {\n+        int currentX = layoutNode.getX();\n+        int shiftAmount = currentX - newX;\n+        int leftPos = layoutNode.getPos() - 1;\n+\n+        if (leftPos >= 0) {\n+            \/\/ There is a left neighbor\n+            LayoutNode leftNeighbor = get(leftPos);\n+            int proposedLeftEdge = layoutNode.getLeft() - shiftAmount;\n+            int requiredRightEdge = leftNeighbor.getOuterRight() + NODE_OFFSET;\n+\n+            if (requiredRightEdge <= proposedLeftEdge) {\n+                layoutNode.setX(newX);\n+            }\n+        } else {\n+            \/\/ No left neighbor; safe to move freely to the left\n+            layoutNode.setX(newX);\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutLayer.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import java.awt.Font;\n+\n+\/**\n+ *\n+ * @author Thomas Wuerthinger\n+ *\/\n+public abstract class LayoutManager {\n+\n+    public static final Font TITLE_FONT = new Font(\"Arial\", Font.BOLD, 14);\n+    public static final int SWEEP_ITERATIONS = 1;\n+    public static final int CROSSING_ITERATIONS = 1;\n+    public static final int NODE_OFFSET = 8;\n+    public static final int LAYER_OFFSET = 8;\n+    public static final double SCALE_LAYER_PADDING = 1.5;\n+\n+    public abstract void setCutEdges(boolean enable);\n+\n+    public abstract void doLayout(LayoutGraph graph);\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutManager.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n+import java.util.Set;\n+\n+public interface LayoutMover {\n+    \/**\n+     * Moves a link by shifting its position along the X-axis.\n+     *\n+     * @param linkPos The current position of the link.\n+     * @param shiftX  The amount to shift the link along the X-axis.\n+     *\/\n+    void moveLink(Point linkPos, int shiftX);\n+\n+    \/**\n+     * Moves a set of vertices.\n+     *\n+     * @param movedVertices A set of vertices to be moved.\n+     *\/\n+    void moveVertices(Set<? extends Vertex> movedVertices);\n+\n+    \/**\n+     * Moves a single vertex.\n+     *\n+     * @param movedVertex The vertex to be moved.\n+     *\/\n+    void moveVertex(Vertex movedVertex);\n+}\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutMover.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutManager.NODE_OFFSET;\n+import com.sun.hotspot.igv.layout.Link;\n@@ -27,0 +29,2 @@\n+import java.awt.Dimension;\n+import java.awt.Point;\n@@ -29,0 +33,9 @@\n+\/**\n+ * The LayoutNode class represents a node in a hierarchical graph layout.\n+ * It can be either an actual node from the original graph or a temporary \"dummy\" node added during the layout process\n+ * to handle complex edge connections.\n+ * This class stores important layout information like the node's position (x and y coordinates),\n+ * size (width and height), layer level, and connections to other nodes through incoming and outgoing edges.\n+ * It provides methods to calculate optimal positions, manage margins, and handle reversed edges,\n+ * all aimed at arranging the nodes neatly in layers to create a clear and visually organized graph display.\n+ *\/\n@@ -31,9 +44,426 @@\n-        public int x;\n-        public int y;\n-        public int width;\n-        public int height;\n-        public int layer = -1;\n-        public int xOffset;\n-        public int yOffset;\n-        public int bottomYOffset;\n-        public Vertex vertex; \/\/ Only used for non-dummy nodes, otherwise null\n+    \/\/ Comparator constants for sorting LayoutNodes in various ways\n+    public static final Comparator<LayoutNode> LAYOUT_NODE_DEGREE_COMPARATOR = Comparator.comparingInt(LayoutNode::getDegree);\n+    public static final Comparator<LayoutNode> NODE_POS_COMPARATOR = Comparator.comparingInt(LayoutNode::getPos);\n+    public static final Comparator<LayoutNode> NODE_X_COMPARATOR = Comparator.comparingInt(LayoutNode::getX);\n+    public static final Comparator<LayoutNode> NODE_CROSSING_COMPARATOR = Comparator.comparingInt(LayoutNode::getCrossingNumber);\n+\n+\n+    \/\/ Default dimensions for dummy nodes\n+    public static final int DUMMY_HEIGHT = 1;\n+    public static final int DUMMY_WIDTH = 1;\n+    public static final int REVERSE_EDGE_OFFSET = NODE_OFFSET + LayoutNode.DUMMY_WIDTH;\n+    private Vertex vertex; \/\/ Associated graph vertex; null for dummy nodes\n+    private final List<LayoutEdge> preds = new ArrayList<>(); \/\/ Incoming edges\n+    private final List<LayoutEdge> succs = new ArrayList<>(); \/\/ Outgoing edges\n+    private LayoutEdge selfEdge = null;\n+    private final HashMap<Link, List<Point>> reversedLinkStartPoints = new HashMap<>(); \/\/ Start points of reversed edges\n+    private final HashMap<Link, List<Point>> reversedLinkEndPoints = new HashMap<>();   \/\/ End points of reversed edges\n+    \/\/ Layout properties\n+    private int layer = -1;\n+    private int x;\n+    private int y;\n+    private int width;\n+    private int height;\n+    private int topMargin;\n+    private int bottomMargin;\n+    private int rightMargin;\n+    private int leftMargin;\n+    private int pos = -1; \/\/ Position within its layer\n+    private boolean reverseLeft = false;\n+    private int crossingNumber = 0;\n+\n+    public boolean hasSelfEdge() {\n+        return selfEdge != null;\n+    }\n+\n+    public void setSelfEdge(LayoutEdge selfEdge) {\n+        this.selfEdge = selfEdge;\n+        if (selfEdge != null) {\n+            topMargin += REVERSE_EDGE_OFFSET;\n+            bottomMargin += REVERSE_EDGE_OFFSET;\n+            rightMargin += REVERSE_EDGE_OFFSET;\n+        }\n+    }\n+\n+    public LayoutEdge getSelfEdge() {\n+        return selfEdge;\n+    }\n+\n+    \/**\n+     * Constructs a LayoutNode associated with the given Vertex.\n+     * Initializes the node's size based on the vertex's dimensions.\n+     *\n+     * @param v The Vertex associated with this LayoutNode. If null, the node is a dummy node.\n+     *\/\n+    public LayoutNode(Vertex v) {\n+        vertex = v;\n+        initSize();\n+    }\n+\n+    \/**\n+     * Constructs a dummy LayoutNode\n+     *\/\n+    public LayoutNode() {\n+        this(null);\n+    }\n+\n+    \/**\n+     * Initializes the size and margins of the node.\n+     * If the node represents a real vertex, it uses the vertex's size.\n+     * Dummy nodes use default dimensions.\n+     *\/\n+    public void initSize() {\n+        if (vertex == null) {\n+            height = DUMMY_HEIGHT;\n+            width = DUMMY_WIDTH;\n+        } else {\n+            Dimension size = vertex.getSize();\n+            height = size.height;\n+            width = size.width;\n+        }\n+        topMargin = 0;\n+        bottomMargin = 0;\n+        leftMargin = 0;\n+        rightMargin = 0;\n+        if (hasSelfEdge()) {\n+            topMargin += REVERSE_EDGE_OFFSET;\n+            bottomMargin += REVERSE_EDGE_OFFSET;\n+            rightMargin += REVERSE_EDGE_OFFSET;\n+        }\n+    }\n+\n+    public int getCrossingNumber() {\n+        return crossingNumber;\n+    }\n+\n+    public void setCrossingNumber(int crossingNumber) {\n+        this.crossingNumber = crossingNumber;\n+    }\n+\n+    public int calculateOptimalXFromPredecessors(boolean useMedian) {\n+        int numPreds = preds.size();\n+\n+        \/\/ If there are no predecessors, retain the current x position\n+        if (numPreds == 0) {\n+            return getX();\n+        }\n+\n+        \/\/ Collect the x positions from all predecessor edges\n+        List<Integer> positions = new ArrayList<>(numPreds);\n+        for (LayoutEdge edge : preds) {\n+            positions.add(edge.getStartX() - edge.getRelativeToX());\n+        }\n+\n+        if (useMedian) {\n+            \/\/ Calculate the median position\n+            Collections.sort(positions);\n+            int midIndex = numPreds \/ 2;\n+\n+            if (numPreds % 2 == 0) {\n+                \/\/ Even number of predecessors: average the two middle values\n+                return (positions.get(midIndex - 1) + positions.get(midIndex)) \/ 2;\n+            } else {\n+                \/\/ Odd number of predecessors: take the middle value\n+                return positions.get(midIndex);\n+            }\n+        } else {\n+            \/\/ Calculate the average position\n+            long sum = 0;\n+            for (int pos : positions) {\n+                sum += pos;\n+            }\n+            \/\/ Integer division is used; adjust as needed for rounding\n+            return (int) (sum \/ numPreds);\n+        }\n+    }\n+\n+\n+    public int calculateOptimalXFromSuccessors(boolean useMedian) {\n+        int numSuccs = succs.size();\n+\n+        \/\/ If there are no successors, retain the current x position\n+        if (numSuccs == 0) {\n+            return getX();\n+        }\n+\n+        \/\/ Collect the x positions from all successor edges\n+        List<Integer> positions = new ArrayList<>(numSuccs);\n+        for (LayoutEdge edge : succs) {\n+            positions.add(edge.getEndX() - edge.getRelativeFromX());\n+        }\n+\n+        if (useMedian) {\n+            \/\/ Calculate the median position\n+            Collections.sort(positions);\n+            int midIndex = numSuccs \/ 2;\n+\n+            if (numSuccs % 2 == 0) {\n+                \/\/ Even number of successors: average the two middle values\n+                return (positions.get(midIndex - 1) + positions.get(midIndex)) \/ 2;\n+            } else {\n+                \/\/ Odd number of successors: take the middle value\n+                return positions.get(midIndex);\n+            }\n+        } else {\n+            \/\/ Calculate the average position\n+            long sum = 0;\n+            for (int pos : positions) {\n+                sum += pos;\n+            }\n+            \/\/ Integer division is used; adjust as needed for rounding\n+            return (int) (sum \/ numSuccs);\n+        }\n+    }\n+\n+    \/**\n+     * Calculates the node's out-degree (number of outgoing edges).\n+     *\n+     * @return The out-degree of the node.\n+     *\/\n+    public int getOutDegree() {\n+        return succs.size();\n+    }\n+\n+    \/**\n+     * Calculates the node's in-degree (number of incoming edges).\n+     *\n+     * @return The in-degree of the node.\n+     *\/\n+    public int getInDegree() {\n+        return preds.size();\n+    }\n+\n+    \/**\n+     * Calculates the total degree of the node (sum of in-degree and out-degree).\n+     *\n+     * @return The total degree of the node.\n+     *\/\n+    public int getDegree() {\n+        return preds.size() + succs.size();\n+    }\n+\n+    \/**\n+     * Gets the left boundary (excluding left margin) of the node.\n+     *\n+     * @return The x-coordinate of the left boundary.\n+     *\/\n+    public int getLeft() {\n+        return x + leftMargin;\n+    }\n+\n+    \/**\n+     * Gets the outer left boundary (including left margin) of the node.\n+     *\n+     * @return The x-coordinate of the outer left boundary.\n+     *\/\n+    public int getOuterLeft() {\n+        return x;\n+    }\n+\n+    \/**\n+     * Gets the total width of the node, including left and right margins.\n+     *\n+     * @return The total outer width.\n+     *\/\n+    public int getOuterWidth() {\n+        return leftMargin + width + rightMargin;\n+    }\n+\n+    \/**\n+     * Gets the total height of the node, including top and bottom margins.\n+     *\n+     * @return The total outer height.\n+     *\/\n+    public int getOuterHeight() {\n+        return topMargin + height + bottomMargin;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    \/**\n+     * Gets the right boundary (excluding right margin) of the node.\n+     *\n+     * @return The x-coordinate of the right boundary.\n+     *\/\n+    public int getRight() {\n+        return x + leftMargin + width;\n+    }\n+\n+    \/**\n+     * Gets the outer right boundary (including right margin) of the node.\n+     *\n+     * @return The x-coordinate of the outer right boundary.\n+     *\/\n+    public int getOuterRight() {\n+        return x + leftMargin + width + rightMargin;\n+    }\n+\n+    \/**\n+     * Gets the horizontal center point of the node.\n+     *\n+     * @return The x-coordinate of the center.\n+     *\/\n+    public int getCenterX() {\n+        return x + leftMargin + (width \/ 2);\n+    }\n+\n+    \/**\n+     * Gets the top boundary (excluding top margin) of the node.\n+     *\n+     * @return The y-coordinate of the top boundary.\n+     *\/\n+    public int getTop() {\n+        return y + topMargin;\n+    }\n+\n+    \/**\n+     * Gets the bottom boundary (excluding bottom margin) of the node.\n+     *\n+     * @return The y-coordinate of the bottom boundary.\n+     *\/\n+    public int getBottom() {\n+        return y + topMargin + height;\n+    }\n+\n+    \/**\n+     * Checks if the node is a dummy node.\n+     *\n+     * @return True if the node is a dummy node; false otherwise.\n+     *\/\n+    public boolean isDummy() {\n+        return vertex == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (vertex != null) {\n+            return vertex.toString();\n+        } else {\n+            return \"dummy\";\n+        }\n+    }\n+\n+    public int getX() {\n+        return x;\n+    }\n+\n+    public void setX(int x) {\n+        this.x = x;\n+    }\n+\n+    public int getY() {\n+        return y;\n+    }\n+\n+    public void setY(int y) {\n+        this.y = y;\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public int getLayer() {\n+        return layer;\n+    }\n+\n+    public void setLayer(int layer) {\n+        this.layer = layer;\n+    }\n+\n+    \/**\n+     * Centers the node by setting equal top and bottom margins.\n+     * The larger of the two margins is applied to both.\n+     *\/\n+    public void centerNode() {\n+        int offset = Math.max(topMargin, bottomMargin);\n+        topMargin = offset;\n+        bottomMargin = offset;\n+    }\n+\n+    public Vertex getVertex() {\n+        return vertex;\n+    }\n+\n+    public void setVertex(Vertex vertex) {\n+        this.vertex = vertex;\n+    }\n+\n+    public boolean hasPredecessors() {\n+        return !preds.isEmpty();\n+    }\n+\n+    public boolean hasSuccessors() {\n+        return !succs.isEmpty();\n+    }\n+\n+    public void clearSuccessors() {\n+        succs.clear();\n+    }\n+\n+    public void clearPredecessors() {\n+        preds.clear();\n+    }\n+\n+    public List<LayoutEdge> getSuccessors() {\n+        return Collections.unmodifiableList(succs);\n+    }\n+\n+    public List<LayoutEdge> getSuccessorsRaw() {\n+        return succs;\n+    }\n+\n+    public List<LayoutEdge> getPredecessors() {\n+        return Collections.unmodifiableList(preds);\n+    }\n+\n+    public List<LayoutEdge> getPredecessorsRaw() {\n+        return preds;\n+    }\n+\n+    public void addSuccessor(LayoutEdge successor) {\n+        succs.add(successor);\n+    }\n+\n+    public void removeSuccessor(LayoutEdge successor) {\n+        succs.remove(successor);\n+    }\n+\n+    public void addPredecessor(LayoutEdge predecessor) {\n+        preds.add(predecessor);\n+    }\n+\n+    public void removePredecessor(LayoutEdge predecessor) {\n+        preds.remove(predecessor);\n+    }\n+\n+    public Map<Link, List<Point>> getReversedLinkStartPoints() {\n+        return Collections.unmodifiableMap(reversedLinkStartPoints);\n+    }\n+\n+    public Map<Link, List<Point>> getReversedLinkEndPoints() {\n+        return Collections.unmodifiableMap(reversedLinkEndPoints);\n+    }\n+\n+    public int getPos() {\n+        return pos;\n+    }\n+\n+    public void setPos(int pos) {\n+        this.pos = pos;\n+    }\n+\n+    \/**\n+     * Groups the successor edges by their relative x-coordinate from the current node.\n+     *\n+     * @return A map of relative x-coordinate to list of successor edges.\n+     *\/\n+    public Map<Integer, List<LayoutEdge>> groupSuccessorsByX() {\n+        Map<Integer, List<LayoutEdge>> result = new HashMap<>();\n+        for (LayoutEdge succEdge : succs) {\n+            result.computeIfAbsent(succEdge.getRelativeFromX(), k -> new ArrayList<>()).add(succEdge);\n+        }\n+        return result;\n+    }\n@@ -41,5 +471,40 @@\n-        public List<LayoutEdge> preds = new ArrayList<>();\n-        public List<LayoutEdge> succs = new ArrayList<>();\n-        public HashMap<Integer, Integer> outOffsets = new HashMap<>();\n-        public HashMap<Integer, Integer> inOffsets = new HashMap<>();\n-        public int pos = -1; \/\/ Position within layer\n+    private int getBackedgeCrossingScore() {\n+        int score = 0;\n+        for (LayoutEdge predEdge : preds) {\n+            if (predEdge.isReversed()) {\n+                List<Point> points = reversedLinkEndPoints.get(predEdge.getLink());\n+                if (points != null) {\n+                    int x0 = points.get(points.size() - 1).x;\n+                    int xn = points.get(0).x;\n+                    int startPoint = predEdge.getStartX();\n+                    int endPoint = predEdge.getEndX();\n+                    int win = (x0 < xn) ? (startPoint - endPoint) : (endPoint - startPoint);\n+                    score += win;\n+                }\n+            }\n+        }\n+        for (LayoutEdge succEdge : succs) {\n+            if (succEdge.isReversed()) {\n+                List<Point> points = reversedLinkStartPoints.get(succEdge.getLink());\n+                if (points != null) {\n+                    int x0 = points.get(points.size() - 1).x;\n+                    int xn = points.get(0).x;\n+                    int startPoint = succEdge.getStartX();\n+                    int endPoint = succEdge.getEndX();\n+                    int win = (x0 > xn) ? (startPoint - endPoint) : (endPoint - startPoint);\n+                    score += win;\n+                }\n+            }\n+        }\n+        return score;\n+    }\n+\n+    private boolean computeReversedStartPoints(boolean left) {\n+        TreeMap<Integer, ArrayList<LayoutEdge>> sortedDownMap = left ? new TreeMap<>() : new TreeMap<>(Collections.reverseOrder());\n+        for (LayoutEdge succEdge : succs) {\n+            if (succEdge.isReversed()) {\n+                succEdge.setRelativeFromX(succEdge.getLink().getTo().getRelativePosition().x);\n+                sortedDownMap.putIfAbsent(succEdge.getRelativeFromX(), new ArrayList<>());\n+                sortedDownMap.get(succEdge.getRelativeFromX()).add(succEdge);\n+            }\n+        }\n@@ -47,1 +512,29 @@\n-        public int crossingNumber;\n+        int offset = REVERSE_EDGE_OFFSET;\n+        int offsetX = left ? -offset : offset;\n+        int currentX = left ? 0 : width;\n+        int startY = 0;\n+        int currentY = 0;\n+        for (Map.Entry<Integer, ArrayList<LayoutEdge>> entry : sortedDownMap.entrySet()) {\n+            int startX = entry.getKey();\n+            ArrayList<LayoutEdge> reversedSuccs = entry.getValue();\n+\n+            currentX += offsetX;\n+            currentY -= offset;\n+            topMargin += offset;\n+\n+            ArrayList<Point> startPoints = new ArrayList<>();\n+            startPoints.add(new Point(currentX, currentY));\n+            startPoints.add(new Point(startX, currentY));\n+            startPoints.add(new Point(startX, startY));\n+            for (LayoutEdge revEdge : reversedSuccs) {\n+                revEdge.setRelativeFromX(currentX);\n+                reversedLinkStartPoints.put(revEdge.getLink(), startPoints);\n+            }\n+        }\n+        if (left) {\n+            leftMargin += sortedDownMap.size() * offset;\n+        } else {\n+            rightMargin += sortedDownMap.size() * offset;\n+        }\n+        return !sortedDownMap.isEmpty();\n+    }\n@@ -49,3 +542,8 @@\n-        @Override\n-        public String toString() {\n-            return \"Node \" + vertex;\n+    private boolean computeReversedEndPoints(boolean left) {\n+        TreeMap<Integer, ArrayList<LayoutEdge>> sortedUpMap = left ? new TreeMap<>() : new TreeMap<>(Collections.reverseOrder());\n+        for (LayoutEdge predEdge : preds) {\n+            if (predEdge.isReversed()) {\n+                predEdge.setRelativeToX(predEdge.getLink().getFrom().getRelativePosition().x);\n+                sortedUpMap.putIfAbsent(predEdge.getRelativeToX(), new ArrayList<>());\n+                sortedUpMap.get(predEdge.getRelativeToX()).add(predEdge);\n+            }\n@@ -53,0 +551,67 @@\n+\n+        int offset = REVERSE_EDGE_OFFSET;\n+        int offsetX = left ? -offset : offset;\n+        int currentX = left ? 0 : getWidth();\n+        int startY = height;\n+        int currentY = height;\n+        for (Map.Entry<Integer, ArrayList<LayoutEdge>> entry : sortedUpMap.entrySet()) {\n+            int startX = entry.getKey();\n+            ArrayList<LayoutEdge> reversedPreds = entry.getValue();\n+\n+            currentX += offsetX;\n+            currentY += offset;\n+            bottomMargin += offset;\n+\n+            ArrayList<Point> endPoints = new ArrayList<>();\n+            endPoints.add(new Point(currentX, currentY));\n+            endPoints.add(new Point(startX, currentY));\n+            endPoints.add(new Point(startX, startY));\n+            for (LayoutEdge revEdge : reversedPreds) {\n+                revEdge.setRelativeToX(currentX);\n+                reversedLinkEndPoints.put(revEdge.getLink(), endPoints);\n+            }\n+        }\n+        if (left) {\n+            leftMargin += sortedUpMap.size() * offset;\n+        } else {\n+            rightMargin += sortedUpMap.size() * offset;\n+        }\n+\n+        return !sortedUpMap.isEmpty();\n+    }\n+\n+    public void computeReversedLinkPoints(boolean reverseLeft) {\n+        this.reverseLeft = reverseLeft;\n+\n+        initSize();\n+        reversedLinkStartPoints.clear();\n+        reversedLinkEndPoints.clear();\n+\n+        boolean hasReversedDown = computeReversedStartPoints(reverseLeft);\n+        boolean hasReversedUP = computeReversedEndPoints(hasReversedDown != reverseLeft);\n+    }\n+\n+    public boolean isReverseRight() {\n+        return !reverseLeft;\n+    }\n+\n+    public void optimizeBackEdgeCrossing() {\n+        if (reversedLinkStartPoints.isEmpty() && reversedLinkEndPoints.isEmpty()) return;\n+        int orig_score = getBackedgeCrossingScore();\n+        computeReversedLinkPoints(isReverseRight());\n+        int reverse_score = getBackedgeCrossingScore();\n+        if (orig_score > reverse_score) {\n+            computeReversedLinkPoints(isReverseRight());\n+        }\n+    }\n+\n+    public ArrayList<Point> getSelfEdgePoints() {\n+        ArrayList<Point> points = new ArrayList<>();\n+\n+        Link selfEdgeLink = getSelfEdge().getLink();\n+\n+        points.add(new Point(selfEdgeLink.getFrom().getRelativePosition().x,  selfEdgeLink.getFrom().getRelativePosition().y-REVERSE_EDGE_OFFSET));\n+        points.add(new Point(width + REVERSE_EDGE_OFFSET,  selfEdgeLink.getFrom().getRelativePosition().y-REVERSE_EDGE_OFFSET));\n+        points.add(new Point(width + REVERSE_EDGE_OFFSET, height + REVERSE_EDGE_OFFSET));\n+        points.add(new Point(selfEdgeLink.getTo().getRelativePosition().x,  height + REVERSE_EDGE_OFFSET));\n+        return points;\n@@ -54,0 +619,1 @@\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutNode.java","additions":585,"deletions":19,"binary":false,"changes":604,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Vertex;\n-import java.awt.Point;\n-import java.util.*;\n-\n-public class LinearLayoutManager implements LayoutManager {\n-\n-    \/\/ Ranking determining the vertical node ordering.\n-    private final Map<? extends Vertex, Integer> vertexRank;\n-\n-    public LinearLayoutManager(Map<? extends Vertex, Integer> vertexRank) {\n-        this.vertexRank = vertexRank;\n-    }\n-\n-    @Override\n-    public void setCutEdges(boolean enable) {}\n-\n-    @Override\n-    public void doLayout(LayoutGraph graph) {\n-        doLayout(graph, new HashSet<>());\n-    }\n-\n-    @Override\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks) {\n-\n-        assert (graph.getLinks().isEmpty());\n-\n-        \/\/ Sort vertices according to given rank.\n-        List<Vertex> vertices = new ArrayList<>(graph.getVertices());\n-        vertices.sort(Comparator.comparingInt((Vertex v) -> vertexRank.getOrDefault(v, Integer.MAX_VALUE)));\n-\n-        \/\/ Assign vertical coordinates in rank order.\n-        assignVerticalCoordinates(vertices);\n-    }\n-\n-    private void assignVerticalCoordinates(List<Vertex> vertices) {\n-        int curY = 0;\n-        for (Vertex v : vertices) {\n-            v.setPosition(new Point(0, curY));\n-            curY += v.getSize().getHeight();\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LinearLayoutManager.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Timing {\n-\n-    private long lastValue;\n-    private long sum;\n-    private final String name;\n-\n-    public Timing(String name) {\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        long val = sum;\n-        if (lastValue != 0) {\n-            \/\/ Timer running\n-            long newValue = System.nanoTime();\n-            val += (newValue - lastValue);\n-        }\n-        return \"Timing for \" + name + \" is: \" + val \/ 1000000 + \" ms\";\n-    }\n-\n-    public void print() {\n-        System.out.println();\n-    }\n-\n-    public void start() {\n-        lastValue = System.nanoTime();\n-    }\n-\n-    public void stop() {\n-        if (lastValue == 0) {\n-            throw new IllegalStateException(\"You must call start before stop\");\n-        }\n-        long newValue = System.nanoTime();\n-        sum += newValue - lastValue;\n-        lastValue = 0;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Timing.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import java.awt.Dimension;\n+import java.awt.Point;\n@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -38,1 +39,5 @@\n-    Set<? extends Cluster> getSuccessors();\n+    void setPosition(Point p);\n+\n+    Point getPosition();\n+\n+    Rectangle getBounds();\n@@ -40,1 +45,3 @@\n-    Dimension getNodeOffset();\n+    List<? extends Vertex> getVertices();\n+\n+    Set<? extends Cluster> getSuccessors();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,205 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.layout;\n-\n-import java.util.*;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class LayoutGraph {\n-\n-    private final Set<? extends Link> links;\n-    private final SortedSet<Vertex> vertices;\n-    private final HashMap<Vertex, Set<Port>> inputPorts;\n-    private final HashMap<Vertex, Set<Port>> outputPorts;\n-    private final HashMap<Port, Set<Link>> portLinks;\n-\n-    public LayoutGraph(Set<? extends Link> links) {\n-        this(links, new HashSet<>());\n-    }\n-\n-    public LayoutGraph(Set<? extends Link> links, Set<? extends Vertex> additionalVertices) {\n-        this.links = links;\n-        assert verify();\n-\n-        vertices = new TreeSet<>();\n-        portLinks = new HashMap<>(links.size());\n-        inputPorts = new HashMap<>(links.size());\n-        outputPorts = new HashMap<>(links.size());\n-\n-        for (Link l : links) {\n-            if (l.getFrom() == null || l.getTo() == null) {\n-                continue;\n-            }\n-            Port p = l.getFrom();\n-            Port p2 = l.getTo();\n-            Vertex v1 = p.getVertex();\n-            Vertex v2 = p2.getVertex();\n-\n-            if (!vertices.contains(v1)) {\n-\n-                outputPorts.put(v1, new HashSet<>(1));\n-                inputPorts.put(v1, new HashSet<>(3));\n-                vertices.add(v1);\n-                assert vertices.contains(v1);\n-            }\n-\n-            if (!vertices.contains(v2)) {\n-                vertices.add(v2);\n-                assert vertices.contains(v2);\n-                outputPorts.put(v2, new HashSet<>(1));\n-                inputPorts.put(v2, new HashSet<>(3));\n-            }\n-\n-            if (!portLinks.containsKey(p)) {\n-                HashSet<Link> hashSet = new HashSet<>(3);\n-                portLinks.put(p, hashSet);\n-            }\n-\n-            if (!portLinks.containsKey(p2)) {\n-                portLinks.put(p2, new HashSet<>(3));\n-            }\n-\n-            outputPorts.get(v1).add(p);\n-            inputPorts.get(v2).add(p2);\n-\n-            portLinks.get(p).add(l);\n-            portLinks.get(p2).add(l);\n-        }\n-\n-        for (Vertex v : additionalVertices) {\n-            if (!vertices.contains(v)) {\n-                outputPorts.put(v, new HashSet<>(1));\n-                inputPorts.put(v, new HashSet<>(3));\n-                vertices.add(v);\n-            }\n-        }\n-    }\n-\n-    public Set<Port> getInputPorts(Vertex v) {\n-        return this.inputPorts.get(v);\n-    }\n-\n-    public Set<Port> getOutputPorts(Vertex v) {\n-        return this.outputPorts.get(v);\n-    }\n-\n-    public Set<Link> getPortLinks(Port p) {\n-        return portLinks.get(p);\n-    }\n-\n-    public Set<? extends Link> getLinks() {\n-        return links;\n-    }\n-\n-    public boolean verify() {\n-        return true;\n-    }\n-\n-    public SortedSet<Vertex> getVertices() {\n-        return vertices;\n-    }\n-\n-    private void markNotRoot(Set<Vertex> notRootSet, Vertex v, Vertex startingVertex) {\n-\n-        if (notRootSet.contains(v)) {\n-            return;\n-        }\n-        if (v != startingVertex) {\n-            notRootSet.add(v);\n-        }\n-        Set<Port> outPorts = getOutputPorts(v);\n-        for (Port p : outPorts) {\n-            Set<Link> portLinks = getPortLinks(p);\n-            for (Link l : portLinks) {\n-                Port other = l.getTo();\n-                Vertex otherVertex = other.getVertex();\n-                if (otherVertex != startingVertex) {\n-                    markNotRoot(notRootSet, otherVertex, startingVertex);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/ Returns a set of vertices with the following properties:\n-    \/\/ - All Vertices in the set startingRoots are elements of the set.\n-    \/\/ - When starting a DFS at every vertex in the set, every vertex of the\n-    \/\/   whole graph is visited.\n-    public Set<Vertex> findRootVertices(Set<Vertex> startingRoots) {\n-\n-        Set<Vertex> notRootSet = new HashSet<>();\n-        for (Vertex v : startingRoots) {\n-            if (!notRootSet.contains(v)) {\n-                markNotRoot(notRootSet, v, v);\n-            }\n-        }\n-\n-        Set<Vertex> tmpVertices = getVertices();\n-        for (Vertex v : tmpVertices) {\n-            if (!notRootSet.contains(v)) {\n-                if (this.getInputPorts(v).size() == 0) {\n-                    markNotRoot(notRootSet, v, v);\n-                }\n-            }\n-        }\n-\n-        for (Vertex v : tmpVertices) {\n-            if (!notRootSet.contains(v)) {\n-                markNotRoot(notRootSet, v, v);\n-            }\n-        }\n-\n-        Set<Vertex> result = new HashSet<>();\n-        for (Vertex v : tmpVertices) {\n-            if (!notRootSet.contains(v)) {\n-                result.add(v);\n-            }\n-        }\n-        assert tmpVertices.size() == 0 || result.size() > 0;\n-        return result;\n-    }\n-\n-    public Set<Vertex> findRootVertices() {\n-        return findRootVertices(new HashSet<>());\n-    }\n-\n-    public SortedSet<Cluster> getClusters() {\n-\n-        SortedSet<Cluster> clusters = new TreeSet<>();\n-        for (Vertex v : getVertices()) {\n-            if (v.getCluster() != null) {\n-                clusters.add(v.getCluster());\n-            }\n-        }\n-\n-        return clusters;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"LayoutGraph(\" + vertices + \", \" + links + \", \" + getClusters() + \")\";\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutGraph.java","additions":0,"deletions":205,"binary":false,"changes":205,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.layout;\n-\n-import java.util.Set;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public interface LayoutManager {\n-\n-    void setCutEdges(boolean enable);\n-\n-    void doLayout(LayoutGraph graph);\n-\n-    void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks);\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutManager.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-    boolean isVIP();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Link.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-        List<InputNode> schedule = new ArrayList<>();\n+        LinkedHashSet<InputNode> schedule = new LinkedHashSet<InputNode>();\n@@ -410,1 +410,1 @@\n-                    if (!visited.contains(p)) {\n+                    if (!schedule.contains(p.inputNode)) {\n@@ -422,1 +422,1 @@\n-        return schedule;\n+        return new ArrayList<InputNode>(schedule);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,24 @@\n+\n+\/\/ Show Parse Predicate type.\n+function parsePredicateInfo(dump_spec) {\n+  \/\/ It's easier to match with \".*\" because type \"Loop\" can also be found in type \"Loop Limit Check\" and \"Profiled Loop\".\n+  \/\/ Matching with \".*\" also requires us to exclude the optional \"#useless\" string at the end.\n+  var predicateMatch = \/#(.*)(#useless)?\/.exec(dump_spec);\n+  if (predicateMatch != null) {\n+     return predicateMatch[1].trim();\n+  }\n+  return null;\n+}\n+editProperty(matches(\"name\", \"ParsePredicate\"), [\"dump_spec\"], \"extra_label\",\n+             function(dump_spec) { return parsePredicateInfo(dump_spec[0]);});\n+\n+\/\/ Show Assertion Predicate type.\n+function assertionPredicateInfo(dump_spec) {\n+  var predicateMatch = \/#((Init|Last) Value Assertion Predicate)\/.exec(dump_spec);\n+  if (predicateMatch != null) {\n+     return predicateMatch[1];\n+  }\n+  return null;\n+}\n+editProperty(matches(\"name\", \"If|RangeCheck\"), [\"dump_spec\"], \"extra_label\",\n+             function(dump_spec) { return assertionPredicateInfo(dump_spec[0]);});\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/customNodeInfo.filter","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.hotspot.igv.util;\n-\n-import java.util.Arrays;\n-\n-public class Statistics {\n-\n-    public static int median(int[] values) {\n-        Arrays.sort(values);\n-        if (values.length % 2 == 0) {\n-            return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n-        } else {\n-            return values[values.length \/ 2];\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/Statistics.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -30,1 +30,2 @@\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n+import com.sun.hotspot.igv.layout.Cluster;\n+import com.sun.hotspot.igv.hierarchicallayout.LayoutGraph;\n@@ -47,0 +48,1 @@\n+import javax.swing.border.Border;\n@@ -52,2 +54,0 @@\n-import org.netbeans.api.visual.animator.AnimatorEvent;\n-import org.netbeans.api.visual.animator.AnimatorListener;\n@@ -84,0 +84,2 @@\n+    private final Widget shadowWidget;\n+    private final Widget pointerWidget;\n@@ -87,0 +89,3 @@\n+\n+    private final Map<OutputSlot, Set<LineWidget>> outputSlotToLineWidget = new HashMap<>();\n+    private final Map<InputSlot, Set<LineWidget>> inputSlotToLineWidget = new HashMap<>();\n@@ -88,0 +93,2 @@\n+    private HierarchicalLayoutManager seaLayoutManager;\n+    private LayoutMover layoutMover;\n@@ -97,1 +104,1 @@\n-    public static final int BORDER_SIZE = 100;\n+    public static final int BORDER_SIZE = 50;\n@@ -104,1 +111,0 @@\n-    public static final int SLOT_OFFSET = 8;\n@@ -227,1 +233,1 @@\n-            figure.setColor(color);\n+            figure.setCustomColor(color);\n@@ -328,0 +334,2 @@\n+        Border emptyBorder = BorderFactory.createEmptyBorder(BORDER_SIZE, BORDER_SIZE, BORDER_SIZE, BORDER_SIZE);\n+\n@@ -329,0 +337,1 @@\n+        blockLayer.setBorder(emptyBorder);\n@@ -332,0 +341,1 @@\n+        connectionLayer.setBorder(emptyBorder);\n@@ -335,0 +345,1 @@\n+        mainLayer.setBorder(emptyBorder);\n@@ -337,1 +348,6 @@\n-        setBorder(BorderFactory.createLineBorder(Color.white, BORDER_SIZE));\n+        pointerWidget = new Widget(DiagramScene.this);\n+        addChild(pointerWidget);\n+\n+        shadowWidget = new Widget(DiagramScene.this);\n+        addChild(shadowWidget);\n+\n@@ -360,0 +376,1 @@\n+            clearSelectedNodes();\n@@ -481,3 +498,0 @@\n-        this.model = model;\n-        modelState = new ModelState(model);\n-\n@@ -501,0 +515,4 @@\n+        seaLayoutManager = new HierarchicalLayoutManager();\n+\n+        this.model = model;\n+        modelState = new ModelState(model);\n@@ -557,3 +575,5 @@\n-        Collection<Object> objects = new ArrayList<>(getObjects());\n-        for (Object o : objects) {\n-            removeObject(o);\n+        Set<Object> objectSet = new HashSet<>(getObjects());\n+        for (Object object : objectSet) {\n+            if (isObject(object)) {\n+                removeObject(object);\n+            }\n@@ -572,3 +592,3 @@\n-            Map<InputBlock, Integer> maxWidth = new HashMap<>();\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n-                maxWidth.put(inputBlock, 10);\n+            Map<Block, Integer> maxWidth = new HashMap<>();\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n+                maxWidth.put(block, 10);\n@@ -578,2 +598,2 @@\n-                if (figure.getWidth() > maxWidth.get(figure.getBlock().getInputBlock())) {\n-                    maxWidth.put(figure.getBlock().getInputBlock(), figure.getWidth());\n+                if (figure.getWidth() > maxWidth.get(figure.getBlock())) {\n+                    maxWidth.put(figure.getBlock(), figure.getWidth());\n@@ -584,1 +604,1 @@\n-                figure.setWidth(maxWidth.get(figure.getBlock().getInputBlock()));\n+                figure.setWidth(maxWidth.get(figure.getBlock()));\n@@ -589,0 +609,157 @@\n+    private MoveProvider getFigureMoveProvider() {\n+        return new MoveProvider() {\n+\n+            private boolean hasMoved = false; \/\/ Flag to track movement\n+            private int startLayerY;\n+\n+            private void setFigureShadow(Figure f) {\n+                FigureWidget fw = getWidget(f);\n+                Color c = f.getColor();\n+                Border border = new FigureWidget.RoundedBorder(new Color(0,0,0, 50), 1);\n+                shadowWidget.setBorder(border);\n+                shadowWidget.setBackground(new Color(c.getRed(), c.getGreen(), c.getBlue(), 50));\n+                shadowWidget.setPreferredLocation(fw.getPreferredLocation());\n+                shadowWidget.setPreferredSize(f.getSize());\n+                shadowWidget.setVisible(true);\n+                shadowWidget.setOpaque(true);\n+                shadowWidget.revalidate();\n+                shadowWidget.repaint();\n+            }\n+\n+            private void setMovePointer(Figure f) {\n+                Border border = new FigureWidget.RoundedBorder(Color.RED, 1);\n+                pointerWidget.setBorder(border);\n+                pointerWidget.setBackground(Color.RED);\n+                pointerWidget.setPreferredBounds(new Rectangle(0, 0, 3, f.getSize().height));\n+                pointerWidget.setVisible(false);\n+                pointerWidget.setOpaque(true);\n+            }\n+\n+\n+            @Override\n+            public void movementStarted(Widget widget) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+\n+                widget.bringToFront();\n+                startLayerY = widget.getLocation().y;\n+                hasMoved = false; \/\/ Reset the movement flag\n+                Set<Figure> selectedFigures = model.getSelectedFigures();\n+                if (selectedFigures.size() == 1) {\n+                    Figure selectedFigure = selectedFigures.iterator().next();\n+                    setFigureShadow(selectedFigure);\n+                    setMovePointer(selectedFigure);\n+                }\n+            }\n+\n+            @Override\n+            public void movementFinished(Widget widget) {\n+                shadowWidget.setVisible(false);\n+                pointerWidget.setVisible(false);\n+                if (layoutMover == null || !hasMoved) return; \/\/ Do nothing if layoutMover is not available or no movement occurred\n+                rebuilding = true;\n+\n+                Set<Figure> movedFigures = new HashSet<>(model.getSelectedFigures());\n+                for (Figure figure : movedFigures) {\n+                    FigureWidget fw = getWidget(figure);\n+                    figure.setPosition(new Point(fw.getLocation().x, fw.getLocation().y));\n+                }\n+\n+                layoutMover.moveVertices(movedFigures);\n+                rebuildConnectionLayer();\n+\n+                for (FigureWidget fw : getVisibleFigureWidgets()) {\n+                    fw.updatePosition();\n+                }\n+\n+                validateAll();\n+                addUndo();\n+                rebuilding = false;\n+            }\n+\n+            private static final int MAGNET_SIZE = 5;\n+\n+            private int magnetToStartLayerY(Widget widget, Point location) {\n+                int shiftY = location.y - widget.getLocation().y;\n+                if (Math.abs(location.y - startLayerY) <= MAGNET_SIZE) {\n+                    if (Math.abs(widget.getLocation().y - startLayerY) > MAGNET_SIZE) {\n+                        shiftY = startLayerY - widget.getLocation().y;\n+                    } else {\n+                        shiftY = 0;\n+                    }\n+                }\n+                return shiftY;\n+            }\n+\n+            @Override\n+            public Point getOriginalLocation(Widget widget) {\n+                if (layoutMover == null) return widget.getLocation(); \/\/ default behavior\n+                return ActionFactory.createDefaultMoveProvider().getOriginalLocation(widget);\n+            }\n+\n+            @Override\n+            public void setNewLocation(Widget widget, Point location) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                hasMoved = true; \/\/ Mark that a movement occurred\n+\n+                int shiftX = location.x - widget.getLocation().x;\n+                int shiftY = magnetToStartLayerY(widget, location);\n+\n+                List<Figure> selectedFigures = new ArrayList<>( model.getSelectedFigures());\n+                selectedFigures.sort(Comparator.comparingInt(f -> f.getPosition().x));\n+                for (Figure figure : selectedFigures) {\n+                    FigureWidget fw = getWidget(figure);\n+                    for (InputSlot inputSlot : figure.getInputSlots()) {\n+                        assert inputSlot != null;\n+                        if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                            for (LineWidget lw : inputSlotToLineWidget.get(inputSlot)) {\n+                                assert lw != null;\n+                                Point toPt = lw.getTo();\n+                                Point fromPt = lw.getFrom();\n+                                if (toPt != null && fromPt != null) {\n+                                    int xTo = toPt.x + shiftX;\n+                                    int yTo = toPt.y + shiftY;\n+                                    lw.setTo(new Point(xTo, yTo));\n+                                    lw.setFrom(new Point(fromPt.x + shiftX, fromPt.y));\n+                                    LineWidget pred = lw.getPredecessor();\n+                                    pred.setTo(new Point(pred.getTo().x + shiftX, pred.getTo().y));\n+                                    pred.revalidate();\n+                                    lw.revalidate();\n+                                }\n+                            }\n+                        }\n+                    }\n+                    for (OutputSlot outputSlot : figure.getOutputSlots()) {\n+                        assert outputSlot != null;\n+                        if (outputSlotToLineWidget.containsKey(outputSlot)) {\n+                            for (LineWidget lw : outputSlotToLineWidget.get(outputSlot)) {\n+                                assert lw != null;\n+                                Point fromPt = lw.getFrom();\n+                                Point toPt = lw.getTo();\n+                                if (toPt != null && fromPt != null) {\n+                                    int xFrom = fromPt.x + shiftX;\n+                                    int yFrom = fromPt.y + shiftY;\n+                                    lw.setFrom(new Point(xFrom, yFrom));\n+                                    lw.setTo(new Point(toPt.x + shiftX, toPt.y));\n+                                    for (LineWidget succ : lw.getSuccessors()) {\n+                                        succ.setFrom(new Point(succ.getFrom().x + shiftX, succ.getFrom().y));\n+                                        succ.revalidate();\n+                                    }\n+                                    lw.revalidate();\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Point newLocation = new Point(fw.getLocation().x + shiftX, fw.getLocation().y + shiftY);\n+                    ActionFactory.createDefaultMoveProvider().setNewLocation(fw, newLocation);\n+                }\n+\n+                FigureWidget fw = getWidget(selectedFigures.iterator().next());\n+                pointerWidget.setVisible(true);\n+                Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n+                ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                connectionLayer.revalidate();\n+                connectionLayer.repaint();\n+            }\n+        };\n+    }\n+\n@@ -597,0 +774,1 @@\n+            figureWidget.getActions().addAction(ActionFactory.createMoveAction(null, getFigureMoveProvider()));\n@@ -601,1 +779,1 @@\n-                SlotWidget slotWidget = new InputSlotWidget(inputSlot, this, figureWidget, figureWidget);\n+                SlotWidget slotWidget = new InputSlotWidget(inputSlot, this, figureWidget);\n@@ -609,1 +787,1 @@\n-                SlotWidget slotWidget = new OutputSlotWidget(outputSlot, this, figureWidget, figureWidget);\n+                SlotWidget slotWidget = new OutputSlotWidget(outputSlot, this, figureWidget);\n@@ -621,2 +799,2 @@\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n-                BlockWidget blockWidget = new BlockWidget(this, inputBlock);\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n+                BlockWidget blockWidget = new BlockWidget(this, block);\n@@ -625,1 +803,1 @@\n-                addObject(inputBlock, blockWidget);\n+                addObject(block, blockWidget);\n@@ -639,1 +817,16 @@\n-        setFigureSelection(model.getSelectedFigures());\n+        rebuilding = false;\n+    }\n+\n+    private void hiddenNodesChanged() {\n+        relayout();\n+        addUndo();\n+    }\n+\n+    private void relayout() {\n+        rebuilding = true;\n+        Set<FigureWidget> oldVisibleFigureWidgets = getVisibleFigureWidgets();\n+        Set<BlockWidget> oldVisibleBlockWidgets = getVisibleBlockWidgets();\n+\n+        updateVisibleFigureWidgets();\n+        updateNodeHull();\n+        updateVisibleBlockWidgets();\n@@ -641,0 +834,18 @@\n+\n+        Set<Figure> visibleFigures = getVisibleFigures();\n+        Set<Connection> visibleConnections = getVisibleConnections();\n+        if (getModel().getShowStableSea()) {\n+            doStableSeaLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowSea()) {\n+            doSeaLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowBlocks()) {\n+            doClusteredLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowCFG()) {\n+            doCFGLayout(visibleFigures, visibleConnections);\n+        }\n+        rebuildConnectionLayer();\n+\n+        updateFigureWidgetLocations(oldVisibleFigureWidgets);\n+        updateBlockWidgetBounds(oldVisibleBlockWidgets);\n+        validateAll();\n+        setFigureSelection(model.getSelectedFigures());\n@@ -666,1 +877,1 @@\n-                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height), false);\n+                            centerRectangle(new Rectangle(location.x, location.y, bounds.width, bounds.height));\n@@ -674,5 +885,0 @@\n-    private void hiddenNodesChanged() {\n-        relayout();\n-        addUndo();\n-    }\n-\n@@ -683,1 +889,7 @@\n-    private boolean isVisible(Connection c) {\n+    public boolean isVisibleBlockConnection(BlockConnection blockConnection) {\n+        Widget w1 = getWidget(blockConnection.getFromCluster());\n+        Widget w2 = getWidget(blockConnection.getToCluster());\n+        return w1.isVisible() && w2.isVisible();\n+    }\n+\n+    private boolean isVisibleFigureConnection(FigureConnection figureConnection) {\n@@ -687,1 +899,1 @@\n-        if (getModel().getShowCFG() && c instanceof FigureConnection) {\n+        if (getModel().getShowCFG()) {\n@@ -690,9 +902,2 @@\n-        Widget w1, w2;\n-        if (c instanceof BlockConnection) {\n-            w1 = getWidget(((Block)c.getFromCluster()).getInputBlock());\n-            w2 = getWidget(((Block)c.getToCluster()).getInputBlock());\n-        } else {\n-            assert (c instanceof FigureConnection);\n-            w1 = getWidget(c.getFrom().getVertex());\n-            w2 = getWidget(c.getTo().getVertex());\n-        }\n+        Widget w1 = getWidget(figureConnection.getFrom().getVertex());\n+        Widget w2 = getWidget(figureConnection.getTo().getVertex());\n@@ -702,1 +907,2 @@\n-    private void doStableSeaLayout(HashSet<Figure> visibleFigures, HashSet<Connection> visibleConnections) {\n+    private void doStableSeaLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        layoutMover = null;\n@@ -713,64 +919,5 @@\n-    private void doSeaLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n-        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        manager.setCutEdges(model.getCutEdges());\n-        manager.doLayout(new LayoutGraph(edges, figures));\n-        hierarchicalStableLayoutManager.setShouldRedrawLayout(true);\n-    }\n-\n-    private void doClusteredLayout(HashSet<Connection> edges) {\n-        HierarchicalClusterLayoutManager m = new HierarchicalClusterLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        manager.setCutEdges(model.getCutEdges());\n-        manager.setMinLayerDifference(3);\n-        m.setManager(manager);\n-        m.setSubManager(new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS));\n-        m.doLayout(new LayoutGraph(edges));\n-    }\n-\n-    private void doCFGLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n-        Diagram diagram = getModel().getDiagram();\n-        HierarchicalCFGLayoutManager m = new HierarchicalCFGLayoutManager();\n-        HierarchicalLayoutManager manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n-        manager.setCutEdges(model.getCutEdges());\n-        manager.setMinLayerDifference(1);\n-        manager.setLayoutSelfEdges(true);\n-        manager.setXOffset(25);\n-        manager.setLayerOffset(25);\n-        m.setManager(manager);\n-        Map<InputNode, Figure> nodeFig = new HashMap<>();\n-        for (Figure f : figures) {\n-            InputNode n = f.getInputNode();\n-            if (n != null) {\n-                nodeFig.put(n, f);\n-            }\n-        }\n-        \/\/ Compute global ranking among figures given by in-block order. If\n-        \/\/ needed, this could be cached as long as it is computed for all the\n-        \/\/ figures in the model, not just the visible ones.\n-        Map<Figure, Integer> figureRank = new HashMap<>(figures.size());\n-        int r = 0;\n-        for (InputBlock b : diagram.getInputBlocks()) {\n-            for (InputNode n : b.getNodes()) {\n-                Figure f = nodeFig.get(n);\n-                if (f != null) {\n-                    figureRank.put(f, r);\n-                    r++;\n-                }\n-            }\n-        }\n-        \/\/ Add visible connections for CFG edges.\n-        for (BlockConnection c : diagram.getBlockConnections()) {\n-            if (isVisible(c)) {\n-                edges.add(c);\n-            }\n-        }\n-        m.setSubManager(new LinearLayoutManager(figureRank));\n-        Set<Block> visibleBlocks = new HashSet<>();\n-        for (Block b : diagram.getBlocks()) {\n-            BlockWidget w = getWidget(b.getInputBlock());\n-            if (w.isVisible()) {\n-                visibleBlocks.add(b);\n-            }\n-        }\n-        m.setClusters(new HashSet<>(visibleBlocks));\n-        m.doLayout(new LayoutGraph(edges, figures));\n+    private void doSeaLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        seaLayoutManager = new HierarchicalLayoutManager();\n+        layoutMover = seaLayoutManager;\n+        seaLayoutManager.setCutEdges(model.getCutEdges());\n+        seaLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n@@ -779,0 +926,6 @@\n+    private void doClusteredLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        layoutMover = null;\n+        HierarchicalClusterLayoutManager clusterLayoutManager = new HierarchicalClusterLayoutManager();\n+        clusterLayoutManager.setCutEdges(model.getCutEdges());\n+        clusterLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n+    }\n@@ -780,0 +933,6 @@\n+    private void doCFGLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        layoutMover = null;\n+        HierarchicalCFGLayoutManager cfgLayoutManager = new HierarchicalCFGLayoutManager(getVisibleBlockConnections(), getVisibleBlocks());\n+        cfgLayoutManager.setCutEdges(model.getCutEdges());\n+        cfgLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n+    }\n@@ -793,2 +952,5 @@\n-    private void processOutputSlot(OutputSlot outputSlot, List<Connection> connections, int controlPointIndex, Point lastPoint, LineWidget predecessor) {\n-        Map<Point, List<Connection>> pointMap = new HashMap<>(connections.size());\n+    private MoveProvider getFigureConnectionMoveProvider() {\n+        return new MoveProvider() {\n+\n+            Point startLocation;\n+            Point originalPosition;\n@@ -796,3 +958,6 @@\n-        for (Connection connection : connections) {\n-            if (!isVisible(connection)) {\n-                continue;\n+            @Override\n+            public void movementStarted(Widget widget) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                LineWidget lw = (LineWidget) widget;\n+                startLocation = lw.getClientAreaLocation();\n+                originalPosition = lw.getFrom();\n@@ -801,3 +966,20 @@\n-            List<Point> controlPoints = connection.getControlPoints();\n-            if (controlPointIndex >= controlPoints.size()) {\n-                continue;\n+            @Override\n+            public void movementFinished(Widget widget) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                LineWidget lineWidget = (LineWidget) widget;\n+                if (lineWidget.getPredecessor() == null) return;\n+                if (lineWidget.getSuccessors().isEmpty()) return;\n+                if (lineWidget.getFrom().x != lineWidget.getTo().x) return;\n+\n+                int shiftX = lineWidget.getClientAreaLocation().x - startLocation.x;\n+                if (shiftX == 0) return;\n+\n+                rebuilding = true;\n+                layoutMover.moveLink(originalPosition, shiftX);\n+                rebuildConnectionLayer();\n+                for (FigureWidget fw : getVisibleFigureWidgets()) {\n+                    fw.updatePosition();\n+                }\n+                validateAll();\n+                addUndo();\n+                rebuilding = false;\n@@ -806,9 +988,37 @@\n-            Point currentPoint = controlPoints.get(controlPointIndex);\n-            if (currentPoint == null) { \/\/ Long connection, has been cut vertically.\n-                currentPoint = specialNullPoint;\n-            } else if (connection.hasSlots()) {\n-                if (controlPointIndex == 0 && !outputSlot.shouldShowName()) {\n-                    currentPoint = new Point(currentPoint.x, currentPoint.y - SLOT_OFFSET);\n-                } else if (controlPointIndex == controlPoints.size() - 1 &&\n-                           !((Slot)connection.getTo()).shouldShowName()) {\n-                    currentPoint = new Point(currentPoint.x, currentPoint.y + SLOT_OFFSET);\n+            @Override\n+            public Point getOriginalLocation(Widget widget) {\n+                if (layoutMover == null) return widget.getLocation(); \/\/ default behavior\n+                LineWidget lineWidget = (LineWidget) widget;\n+                return lineWidget.getClientAreaLocation();\n+            }\n+\n+            @Override\n+            public void setNewLocation(Widget widget, Point location) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                LineWidget lineWidget = (LineWidget) widget;\n+                if (lineWidget.getPredecessor() == null) return;\n+                if (lineWidget.getSuccessors().isEmpty()) return;\n+                if (lineWidget.getFrom().x != lineWidget.getTo().x) return;\n+\n+                int shiftX = location.x - lineWidget.getClientAreaLocation().x;\n+                if (shiftX == 0) return;\n+\n+                Point oldFrom = lineWidget.getFrom();\n+                Point newFrom = new Point(oldFrom.x + shiftX, oldFrom.y);\n+\n+                Point oldTo = lineWidget.getTo();\n+                Point newTo = new Point(oldTo.x + shiftX, oldTo.y);\n+\n+                lineWidget.setTo(newTo);\n+                lineWidget.setFrom(newFrom);\n+                lineWidget.revalidate();\n+\n+                LineWidget predecessor = lineWidget.getPredecessor();\n+                Point toPt = predecessor.getTo();\n+                predecessor.setTo(new Point(toPt.x + shiftX, toPt.y));\n+                predecessor.revalidate();\n+\n+                for (LineWidget successor : lineWidget.getSuccessors()) {\n+                    Point fromPt = successor.getFrom();\n+                    successor.setFrom(new Point(fromPt.x + shiftX, fromPt.y));\n+                    successor.revalidate();\n@@ -817,0 +1027,2 @@\n+        };\n+    }\n@@ -818,6 +1030,19 @@\n-            if (pointMap.containsKey(currentPoint)) {\n-                pointMap.get(currentPoint).add(connection);\n-            } else {\n-                List<Connection> newList = new ArrayList<>(2);\n-                newList.add(connection);\n-                pointMap.put(currentPoint, newList);\n+    private void processOutputSlot(OutputSlot outputSlot, List<FigureConnection> connections, int controlPointIndex, Point lastPoint, LineWidget predecessor) {\n+        Map<Point, List<FigureConnection>> pointMap = new HashMap<>(connections.size());\n+\n+        for (FigureConnection connection : connections) {\n+            if (isVisibleFigureConnection(connection)) {\n+                List<Point> controlPoints = connection.getControlPoints();\n+                if (controlPointIndex < controlPoints.size()) {\n+                    Point currentPoint = controlPoints.get(controlPointIndex);\n+                    if (currentPoint == null) { \/\/ Long connection, has been cut vertically.\n+                        currentPoint = specialNullPoint;\n+                    } else {\n+                        currentPoint = new Point(currentPoint.x, currentPoint.y);\n+                    }\n+                    if (pointMap.containsKey(currentPoint)) {\n+                        pointMap.get(currentPoint).add(connection);\n+                    } else {\n+                        pointMap.put(currentPoint, new ArrayList<>(Collections.singletonList(connection)));\n+                    }\n+                }\n@@ -828,1 +1053,1 @@\n-            List<Connection> connectionList = pointMap.get(currentPoint);\n+            List<FigureConnection> connectionList = pointMap.get(currentPoint);\n@@ -833,1 +1058,1 @@\n-            for (Connection c : connectionList) {\n+            for (FigureConnection c : connectionList) {\n@@ -851,1 +1076,10 @@\n-                connectionLayer.addChild(newPredecessor);\n+                if (predecessor == null) {\n+                    assert outputSlot != null;\n+                    if (outputSlotToLineWidget.containsKey(outputSlot)) {\n+                        outputSlotToLineWidget.get(outputSlot).add(newPredecessor);\n+                    } else {\n+                        outputSlotToLineWidget.put(outputSlot, new HashSet<>(Collections.singleton(newPredecessor)));\n+                    }\n+                }\n+\n+                newWidgets.add(newPredecessor);\n@@ -854,0 +1088,1 @@\n+                newPredecessor.getActions().addAction(ActionFactory.createMoveAction(null, getFigureConnectionMoveProvider()));\n@@ -858,0 +1093,39 @@\n+\n+        if (pointMap.isEmpty()) {\n+            for (FigureConnection connection : connections) {\n+                if (isVisibleFigureConnection(connection)) {\n+                    InputSlot inputSlot = connection.getInputSlot();\n+                    if (predecessor != null) {\n+                        assert inputSlot != null;\n+                        if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                            inputSlotToLineWidget.get(inputSlot).add(predecessor);\n+                        } else {\n+                            inputSlotToLineWidget.put(inputSlot, new HashSet<>(Collections.singleton(predecessor)));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void processBlockConnection(BlockConnection blockConnection) {\n+        boolean isDashed = blockConnection.getStyle() == Connection.ConnectionStyle.DASHED;\n+        boolean isBold = blockConnection.getStyle() == Connection.ConnectionStyle.BOLD;\n+        boolean isVisible = blockConnection.getStyle() != Connection.ConnectionStyle.INVISIBLE;\n+        Point lastPoint = null;\n+        LineWidget predecessor = null;\n+        for (Point currentPoint : blockConnection.getControlPoints()) {\n+            if (currentPoint == null) { \/\/ Long connection, has been cut vertically.\n+                currentPoint = specialNullPoint;\n+            } else if (lastPoint != specialNullPoint && lastPoint != null) {\n+                List<BlockConnection> connectionList = Collections.singletonList(blockConnection);\n+                Point src = new Point(lastPoint);\n+                Point dest = new Point(currentPoint);\n+                predecessor = new LineWidget(this, null, connectionList, src, dest, predecessor, isBold, isDashed);\n+                predecessor.setVisible(isVisible);\n+                connectionLayer.addChild(predecessor);\n+                addObject(new ConnectionSet(connectionList), predecessor);\n+                predecessor.getActions().addAction(hoverAction);\n+            }\n+            lastPoint = currentPoint;\n+        }\n@@ -874,5 +1148,1 @@\n-        private Set<Connection> connections;\n-\n-        public ConnectionSet(Collection<Connection> connections) {\n-            connections = new HashSet<>(connections);\n-        }\n+        private Collection<? extends Connection> connections;\n@@ -880,2 +1150,2 @@\n-        public Set<Connection> getConnectionSet() {\n-            return Collections.unmodifiableSet(connections);\n+        public ConnectionSet(Collection<? extends Connection> connections) {\n+            this.connections = connections;\n@@ -891,1 +1161,1 @@\n-        BlockWidget bw = getWidget(block.getInputBlock());\n+        BlockWidget bw = getWidget(block);\n@@ -893,1 +1163,1 @@\n-            centerRectangle(bw.getBounds(), true);\n+            centerRectangle(bw.getBounds());\n@@ -940,1 +1210,1 @@\n-            centerRectangle(overallRect, true);\n+            centerRectangle(overallRect);\n@@ -944,1 +1214,1 @@\n-    private void centerRectangle(Rectangle r, boolean zoomToFit) {\n+    private void centerRectangle(Rectangle r) {\n@@ -947,14 +1217,0 @@\n-        if (zoomToFit) {\n-            double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n-            double zoomFactor = getZoomFactor();\n-            double newZoomFactor = zoomFactor * factor;\n-            if (factor < 1.0 || zoomFactor < 1.0) {\n-                newZoomFactor = Math.min(1.0, newZoomFactor);\n-                centredZoom(newZoomFactor, null);\n-                factor = newZoomFactor \/ zoomFactor;\n-                rect.x *= factor;\n-                rect.y *= factor;\n-                rect.width *= factor;\n-                rect.height *= factor;\n-            }\n-        }\n@@ -962,0 +1218,12 @@\n+        double factor = Math.min(viewRect.getWidth() \/ rect.getWidth(),  viewRect.getHeight() \/ rect.getHeight());\n+        double zoomFactor = getZoomFactor();\n+        double newZoomFactor = zoomFactor * factor;\n+        if (factor < 1.0 || zoomFactor < 1.0) {\n+            newZoomFactor = Math.min(1.0, newZoomFactor);\n+            centredZoom(newZoomFactor, null);\n+            factor = newZoomFactor \/ zoomFactor;\n+            rect.x *= factor;\n+            rect.y *= factor;\n+            rect.width *= factor;\n+            rect.height *= factor;\n+        }\n@@ -1006,0 +1274,2 @@\n+    private final ArrayList<LineWidget> newWidgets = new ArrayList<>();\n+\n@@ -1007,0 +1277,2 @@\n+        outputSlotToLineWidget.clear();\n+        inputSlotToLineWidget.clear();\n@@ -1008,0 +1280,1 @@\n+        newWidgets.clear();\n@@ -1010,1 +1283,1 @@\n-                List<Connection> connectionList = new ArrayList<>(outputSlot.getConnections());\n+                List<FigureConnection> connectionList = new ArrayList<>(outputSlot.getConnections());\n@@ -1017,2 +1290,2 @@\n-                if (isVisible(blockConnection)) {\n-                    processOutputSlot(null, Collections.singletonList(blockConnection), 0, null, null);\n+                if (isVisibleBlockConnection(blockConnection)) {\n+                    processBlockConnection(blockConnection);\n@@ -1022,0 +1295,3 @@\n+\n+        connectionLayer.addChildren(newWidgets);\n+        newWidgets.clear();\n@@ -1038,2 +1314,2 @@\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n-                BlockWidget blockWidget = getWidget(inputBlock);\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n+                BlockWidget blockWidget = getWidget(block);\n@@ -1088,1 +1364,1 @@\n-            Set<InputBlock> visibleBlocks = new HashSet<>();\n+            Set<Block> visibleBlocks = new HashSet<>();\n@@ -1092,1 +1368,1 @@\n-                    visibleBlocks.add(figure.getBlock().getInputBlock());\n+                    visibleBlocks.add(figure.getBlock());\n@@ -1097,1 +1373,1 @@\n-                visibleBlocks.addAll(getModel().getDiagram().getInputBlocks());\n+                visibleBlocks.addAll(getModel().getDiagram().getBlocks());\n@@ -1109,1 +1385,1 @@\n-            for (InputBlock inputBlock : getModel().getDiagram().getInputBlocks()) {\n+            for (Block block : getModel().getDiagram().getBlocks()) {\n@@ -1112,4 +1388,3 @@\n-                boolean visibleAfter = visibleBlocks.contains(inputBlock) &&\n-                        !(getModel().getShowCFG() && (inputBlock.isArtificial() || inputBlock.getNodes().isEmpty()));\n-\n-                BlockWidget blockWidget = getWidget(inputBlock);\n+                boolean visibleAfter = visibleBlocks.contains(block) &&\n+                        !(getModel().getShowCFG() && (block.getInputBlock().isArtificial() || block.getInputBlock().getNodes().isEmpty()));\n+                BlockWidget blockWidget = getWidget(block);\n@@ -1121,1 +1396,1 @@\n-    private HashSet<Figure> getVisibleFigures() {\n+    private Set<Figure> getVisibleFigures() {\n@@ -1132,0 +1407,21 @@\n+    private Set<Cluster> getVisibleBlocks() {\n+        Set<Cluster> visibleBlocks = new HashSet<>();\n+        for (Block b : getModel().getDiagram().getBlocks()) {\n+            BlockWidget w = getWidget(b);\n+            if (w.isVisible()) {\n+                visibleBlocks.add(b);\n+            }\n+        }\n+        return visibleBlocks;\n+    }\n+\n+    private Set<Connection> getVisibleBlockConnections() {\n+        Set<Connection> clusterLinks = new HashSet<>();\n+        for (BlockConnection c : getModel().getDiagram().getBlockConnections()) {\n+            if (isVisibleBlockConnection(c)) {\n+                clusterLinks.add(c);\n+            }\n+        }\n+        return clusterLinks;\n+    }\n+\n@@ -1134,2 +1430,2 @@\n-        for (Connection connection : getModel().getDiagram().getConnections()) {\n-            if (isVisible(connection)) {\n+        for (FigureConnection connection : getModel().getDiagram().getConnections()) {\n+            if (isVisibleFigureConnection(connection)) {\n@@ -1161,1 +1457,1 @@\n-                BlockWidget blockWidget = getWidget(block.getInputBlock());\n+                BlockWidget blockWidget = getWidget(block);\n@@ -1174,60 +1470,0 @@\n-    private void centerSingleSelectedFigure() {\n-        if (model.getSelectedFigures().size() == 1) {\n-            if (getSceneAnimator().getPreferredLocationAnimator().isRunning()) {\n-                getSceneAnimator().getPreferredLocationAnimator().addAnimatorListener(new AnimatorListener() {\n-                    @Override\n-                    public void animatorStarted(AnimatorEvent animatorEvent) {}\n-\n-                    @Override\n-                    public void animatorReset(AnimatorEvent animatorEvent) {}\n-\n-                    @Override\n-                    public void animatorFinished(AnimatorEvent animatorEvent) {\n-                        getSceneAnimator().getPreferredLocationAnimator().removeAnimatorListener(this);\n-                    }\n-\n-                    @Override\n-                    public void animatorPreTick(AnimatorEvent animatorEvent) {}\n-\n-                    @Override\n-                    public void animatorPostTick(AnimatorEvent animatorEvent) {\n-                        validateAll();\n-                        centerSelectedFigures();\n-                    }\n-                });\n-            } else {\n-                centerSelectedFigures();\n-            }\n-        }\n-    }\n-\n-    private void relayout() {\n-        rebuilding = true;\n-        Set<FigureWidget> oldVisibleFigureWidgets = getVisibleFigureWidgets();\n-        Set<BlockWidget> oldVisibleBlockWidgets = getVisibleBlockWidgets();\n-\n-        updateVisibleFigureWidgets();\n-        updateNodeHull();\n-        updateVisibleBlockWidgets();\n-\n-        HashSet<Figure> visibleFigures = getVisibleFigures();\n-        HashSet<Connection> visibleConnections = getVisibleConnections();\n-        if (getModel().getShowStableSea()) {\n-            doStableSeaLayout(visibleFigures, visibleConnections);\n-        } else if (getModel().getShowSea()) {\n-            doSeaLayout(visibleFigures, visibleConnections);\n-        } else if (getModel().getShowBlocks()) {\n-            doClusteredLayout(visibleConnections);\n-        } else if (getModel().getShowCFG()) {\n-            doCFGLayout(visibleFigures, visibleConnections);\n-        }\n-        rebuildConnectionLayer();\n-\n-        updateFigureWidgetLocations(oldVisibleFigureWidgets);\n-        updateBlockWidgetBounds(oldVisibleBlockWidgets);\n-        validateAll();\n-\n-        centerSingleSelectedFigure();\n-        rebuilding = false;\n-    }\n-\n@@ -1298,0 +1534,1 @@\n+\n@@ -1306,1 +1543,0 @@\n-        ModelState newModelState = new ModelState(model);\n@@ -1308,0 +1544,1 @@\n+            ModelState newModelState = new ModelState(model);\n@@ -1310,0 +1547,1 @@\n+            modelState = newModelState;\n@@ -1311,1 +1549,0 @@\n-        modelState = newModelState;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":474,"deletions":237,"binary":false,"changes":711,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+        centerPanel.setOpaque(true);\n@@ -199,11 +200,0 @@\n-        diagramViewModel.getGraphChangedEvent().addListener(model -> {\n-            \/\/ HierarchicalStableLayoutManager is not reliable for difference graphs\n-            boolean isDiffGraph = model.getGraph().isDiffGraph();\n-            \/\/ deactivate HierarchicalStableLayoutManager for difference graphs\n-            stableSeaLayoutButton.setEnabled(!isDiffGraph);\n-            if (stableSeaLayoutButton.isSelected() && isDiffGraph) {\n-                \/\/ fallback to HierarchicalLayoutManager for difference graphs\n-                seaLayoutButton.setSelected(true);\n-            }\n-        });\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+    private static final Color NO_COLOR = new Color(0, 0, 0, 0);\n@@ -92,2 +93,2 @@\n-        selectedColorLabel.setOpaque(true);\n-        selectedColorLabel.setBackground(Color.WHITE);\n+        selectedColorLabel.setOpaque(false); \/\/ Allow transparency\n+        selectedColorLabel.setBackground(NO_COLOR); \/\/ Set transparent background\n@@ -103,0 +104,1 @@\n+                selectedColorLabel.setOpaque(selectedColor.getAlpha() != 0);\n@@ -121,0 +123,1 @@\n+                selectedColorLabel.setOpaque(color.getAlpha() != 0);\n@@ -125,0 +128,16 @@\n+\n+        \/\/ Add \"No Color\" button\n+        JButton noColorButton = new JButton(\"No Color\");\n+        noColorButton.setOpaque(true);\n+        noColorButton.setContentAreaFilled(true);\n+        noColorButton.setBorderPainted(true);\n+        noColorButton.setPreferredSize(new Dimension(90, 24));\n+        noColorButton.setFocusPainted(false);\n+        noColorButton.addActionListener(e -> {\n+            selectedColorLabel.setBackground(NO_COLOR);\n+            selectedColorLabel.setOpaque(false);\n+            selectedColorLabel.setForeground(Color.BLACK);\n+        });\n+        colorsPanel.add(noColorButton);\n+\n+        \/\/ Add the preview label\n@@ -151,2 +170,2 @@\n-                        if (selectedColor != null) {\n-                            editor.colorSelectedFigures(selectedColor);\n+                        if (selectedColor.equals(NO_COLOR)) {\n+                            selectedColor = null;\n@@ -154,0 +173,1 @@\n+                        editor.colorSelectedFigures(selectedColor);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ColorAction.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Block;\n@@ -47,1 +48,1 @@\n-    private final InputBlock blockNode;\n+    private final Block block;\n@@ -49,1 +50,1 @@\n-    public BlockWidget(Scene scene, InputBlock blockNode) {\n+    public BlockWidget(Scene scene, Block block) {\n@@ -51,1 +52,1 @@\n-        this.blockNode = blockNode;\n+        this.block = block;\n@@ -74,1 +75,1 @@\n-        String s = \"B\" + blockNode.getName();\n+        String s = \"B\" + getBlockNode().getName();\n@@ -86,1 +87,1 @@\n-            graphProvider.addSelectedNodes(blockWidget.blockNode.getNodes(), false);\n+            graphProvider.addSelectedNodes(blockWidget.getBlockNode().getNodes(), false);\n@@ -90,0 +91,8 @@\n+    public void updatePosition() {\n+        setPreferredLocation(block.getPosition());\n+    }\n+\n+    public InputBlock getBlockNode() {\n+        return block.getInputBlock();\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.graph.Slot;\n@@ -35,0 +36,2 @@\n+import java.awt.geom.Path2D;\n+import java.awt.geom.RoundRectangle2D;\n@@ -42,0 +45,2 @@\n+import javax.swing.border.Border;\n+import javax.swing.border.LineBorder;\n@@ -65,4 +70,4 @@\n-    private Figure figure;\n-    private Widget middleWidget;\n-    private ArrayList<LabelWidget> labelWidgets;\n-    private DiagramScene diagramScene;\n+    private final Figure figure;\n+    private final Widget middleWidget;\n+    private final ArrayList<LabelWidget> labelWidgets;\n+    private final DiagramScene diagramScene;\n@@ -70,2 +75,0 @@\n-    private final Node node;\n-    private Widget dummyTop;\n@@ -120,4 +123,0 @@\n-        Widget outer = new Widget(scene);\n-        outer.setBackground(f.getColor());\n-        outer.setLayout(LayoutFactory.createOverlayLayout());\n-\n@@ -125,4 +124,2 @@\n-        SerialAlignment textAlign = scene.getModel().getShowCFG() ?\n-            LayoutFactory.SerialAlignment.LEFT_TOP :\n-            LayoutFactory.SerialAlignment.CENTER;\n-        middleWidget.setLayout(LayoutFactory.createVerticalFlowLayout(textAlign, 0));\n+        middleWidget.setPreferredBounds(new Rectangle(0, 0, f.getWidth(), f.getHeight()));\n+        middleWidget.setLayout(LayoutFactory.createHorizontalFlowLayout(SerialAlignment.CENTER, 0));\n@@ -132,12 +129,1 @@\n-\n-        dummyTop = new Widget(scene);\n-        int extraTopHeight =\n-            getFigure().getDiagram().isCFG() && getFigure().hasNamedInputSlot() ?\n-            Figure.TOP_CFG_HEIGHT : 0;\n-        dummyTop.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1 + extraTopHeight));\n-        middleWidget.addChild(dummyTop);\n-\n-        \/\/ This widget includes the node text and possibly a warning sign to the right.\n-        Widget nodeInfoWidget = new Widget(scene);\n-        nodeInfoWidget.setLayout(LayoutFactory.createAbsoluteLayout());\n-        middleWidget.addChild(nodeInfoWidget);\n+        this.addChild(middleWidget);\n@@ -146,0 +132,3 @@\n+        SerialAlignment textAlign = scene.getModel().getShowCFG() ?\n+                LayoutFactory.SerialAlignment.LEFT_TOP :\n+                LayoutFactory.SerialAlignment.CENTER;\n@@ -147,1 +136,1 @@\n-        nodeInfoWidget.addChild(textWidget);\n+        middleWidget.addChild(textWidget);\n@@ -160,1 +149,0 @@\n-            lw.setBorder(BorderFactory.createEmptyBorder());\n@@ -166,0 +154,7 @@\n+        for (int i=1; i < labelWidgets.size(); i++) {\n+            labelWidgets.get(i).setFont(Diagram.FONT.deriveFont(Font.ITALIC));\n+            labelWidgets.get(i).setForeground(Color.DARK_GRAY);\n+        }\n+\n+\n+        int textHeight = f.getHeight() - 2 * Figure.PADDING - f.getSlotsHeight();\n@@ -168,2 +163,0 @@\n-            Point warningLocation = new Point(getFigure().getWidth() - Figure.WARNING_WIDTH - Figure.INSET \/ 2, 0);\n-            warningWidget.setPreferredLocation(warningLocation);\n@@ -171,1 +164,7 @@\n-            nodeInfoWidget.addChild(warningWidget);\n+            middleWidget.addChild(warningWidget);\n+            int textWidth = f.getWidth() - 4 * Figure.BORDER;\n+            textWidth -= Figure.WARNING_WIDTH + Figure.PADDING;\n+            textWidget.setPreferredBounds(new Rectangle(0, 0, textWidth, textHeight));\n+        } else {\n+            int textWidth = f.getWidth() - 4 * Figure.BORDER;\n+            textWidget.setPreferredBounds(new Rectangle(0, 0, textWidth, textHeight));\n@@ -174,10 +173,0 @@\n-        Widget dummyBottom = new Widget(scene);\n-        int extraBottomHeight =\n-            getFigure().getDiagram().isCFG() && getFigure().hasNamedOutputSlot() ?\n-            Figure.BOTTOM_CFG_HEIGHT : 0;\n-        dummyBottom.setMinimumSize(new Dimension(Figure.INSET \/ 2, 1  + extraBottomHeight));\n-        middleWidget.addChild(dummyBottom);\n-\n-        middleWidget.setPreferredBounds(new Rectangle(0, Figure.getVerticalOffset(), f.getWidth(), f.getHeight()));\n-        this.addChild(middleWidget);\n-\n@@ -185,1 +174,1 @@\n-        node = new AbstractNode(Children.LEAF) {\n+        Node node = new AbstractNode(Children.LEAF) {\n@@ -199,0 +188,36 @@\n+    public void updatePosition() {\n+        setPreferredLocation(figure.getPosition());\n+    }\n+\n+    public int getFigureHeight() {\n+        return middleWidget.getPreferredBounds().height;\n+    }\n+\n+    public static class RoundedBorder extends LineBorder {\n+\n+        final float RADIUS = 3f;\n+\n+        public RoundedBorder(Color color, int thickness)  {\n+            super(color, thickness);\n+        }\n+\n+        @Override\n+        public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n+            if ((this.thickness > 0) && (g instanceof Graphics2D)) {\n+                Graphics2D g2d = (Graphics2D) g;\n+                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+                Color oldColor = g2d.getColor();\n+                g2d.setColor(this.lineColor);\n+                int offs = this.thickness;\n+                int size = offs + offs;\n+                Shape outer = new RoundRectangle2D.Float(x, y, width, height, RADIUS, RADIUS);\n+                Shape inner = new RoundRectangle2D.Float(x + offs, y + offs, width - size, height - size, RADIUS, RADIUS);\n+                Path2D path = new Path2D.Float(Path2D.WIND_EVEN_ODD);\n+                path.append(outer, false);\n+                path.append(inner, false);\n+                g2d.fill(path);\n+                g2d.setColor(oldColor);\n+            }\n+        }\n+    }\n+\n@@ -211,1 +236,2 @@\n-        int thickness = 1;\n+        Color borderColor = Color.BLACK;\n+        Color innerBorderColor = getFigure().getColor();\n@@ -214,1 +240,1 @@\n-            thickness = 2;\n+            innerBorderColor = Color.BLACK;\n@@ -217,2 +243,0 @@\n-        Color borderColor = Color.BLACK;\n-        Color innerBorderColor = getFigure().getColor();\n@@ -223,1 +247,5 @@\n-        middleWidget.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(borderColor, thickness), BorderFactory.createLineBorder(innerBorderColor, 1)));\n+        Border innerBorder = new RoundedBorder(borderColor, Figure.BORDER);\n+        Border outerBorder = new RoundedBorder(innerBorderColor, Figure.BORDER);\n+        Border roundedBorder = BorderFactory.createCompoundBorder(innerBorder, outerBorder);\n+        middleWidget.setBorder(roundedBorder);\n+\n@@ -246,0 +274,1 @@\n+        refreshColor();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":76,"deletions":47,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.List;\n@@ -48,2 +47,2 @@\n-    public InputSlotWidget(InputSlot slot, DiagramScene scene, Widget parent, FigureWidget fw) {\n-        super(slot, scene, parent, fw);\n+    public InputSlotWidget(InputSlot slot, DiagramScene scene, FigureWidget fw) {\n+        super(slot, scene, fw);\n@@ -58,7 +57,0 @@\n-    @Override\n-    protected int calculateSlotWidth() {\n-        List<InputSlot> slots = getSlot().getFigure().getInputSlots();\n-        assert slots.contains(getSlot());\n-        return calculateWidth(slots.size());\n-    }\n-\n@@ -68,1 +60,1 @@\n-            calculateClientArea().height - 1 : Figure.SLOT_START;\n+            calculateClientArea().height \/ 2 : 0;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-import java.util.ArrayList;\n-import java.util.HashSet;\n+import java.util.*;\n@@ -39,1 +38,0 @@\n-import java.util.Set;\n@@ -64,4 +62,4 @@\n-    private final List<Connection> connections;\n-    private final Point from;\n-    private final Point to;\n-    private final Rectangle clientArea;\n+    private final List<? extends Connection> connections;\n+    private Point from;\n+    private Point to;\n+    private Rectangle clientArea;\n@@ -74,0 +72,1 @@\n+    private boolean needToInitToolTipText = true;\n@@ -75,1 +74,1 @@\n-    public LineWidget(DiagramScene scene, OutputSlot s, List<Connection> connections, Point from, Point to, LineWidget predecessor, boolean isBold, boolean isDashed) {\n+    public LineWidget(DiagramScene scene, OutputSlot s, List<? extends Connection> connections, Point from, Point to, LineWidget predecessor, boolean isBold, boolean isDashed) {\n@@ -79,1 +78,1 @@\n-        this.connections = connections;\n+        this.connections = Collections.unmodifiableList(connections);\n@@ -91,18 +90,1 @@\n-        int minX = from.x;\n-        int minY = from.y;\n-        int maxX = to.x;\n-        int maxY = to.y;\n-        if (minX > maxX) {\n-            int tmp = minX;\n-            minX = maxX;\n-            maxX = tmp;\n-        }\n-\n-        if (minY > maxY) {\n-            int tmp = minY;\n-            minY = maxY;\n-            maxY = tmp;\n-        }\n-\n-        clientArea = new Rectangle(minX, minY, maxX - minX + 1, maxY - minY + 1);\n-        clientArea.grow(BORDER, BORDER);\n+        computeClientArea();\n@@ -111,1 +93,1 @@\n-        if (connections.size() > 0) {\n+        if (!connections.isEmpty()) {\n@@ -114,1 +96,0 @@\n-        setToolTipText(\"<HTML>\" + generateToolTipText(this.connections) + \"<\/HTML>\");\n@@ -116,1 +97,1 @@\n-        setCheckClipping(true);\n+        setCheckClipping(false);\n@@ -147,1 +128,29 @@\n-    private String generateToolTipText(List<Connection> conn) {\n+    public Point getClientAreaLocation() {\n+        return clientArea.getLocation();\n+    }\n+\n+    private void computeClientArea() {\n+        int minX = from.x;\n+        int minY = from.y;\n+        int maxX = to.x;\n+        int maxY = to.y;\n+\n+        \/\/ Ensure min and max values are correct\n+        if (minX > maxX) {\n+            int tmp = minX;\n+            minX = maxX;\n+            maxX = tmp;\n+        }\n+\n+        if (minY > maxY) {\n+            int tmp = minY;\n+            minY = maxY;\n+            maxY = tmp;\n+        }\n+\n+        \/\/ Set client area to include the curve and add a BORDER for extra space\n+        clientArea = new Rectangle(minX, minY, maxX - minX + 1, maxY - minY + 1);\n+        clientArea.grow(BORDER, BORDER);\n+    }\n+\n+    private String generateToolTipText(List<? extends Connection> conn) {\n@@ -156,0 +165,10 @@\n+    public void setFrom(Point from) {\n+        this.from = from;\n+        computeClientArea();\n+    }\n+\n+    public void setTo(Point to) {\n+        this.to= to;\n+        computeClientArea();\n+    }\n+\n@@ -164,0 +183,8 @@\n+    public LineWidget getPredecessor() {\n+        return predecessor;\n+    }\n+\n+    public List<LineWidget> getSuccessors() {\n+        return Collections.unmodifiableList(successors);\n+    }\n+\n@@ -179,1 +206,1 @@\n-        Graphics2D g = getScene().getGraphics();\n+        Graphics2D g = this.getGraphics();\n@@ -198,1 +225,1 @@\n-            g.setStroke(new BasicStroke(width));\n+            g.setStroke(new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER));\n@@ -237,0 +264,1 @@\n+        super.paintWidget();\n@@ -257,0 +285,4 @@\n+            if (enableHighlighting && needToInitToolTipText) {\n+                setToolTipText(\"<HTML>\" + generateToolTipText(this.connections) + \"<\/HTML>\");\n+                needToInitToolTipText = false; \/\/ Ensure it's only set once\n+            }\n@@ -353,0 +385,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":67,"deletions":34,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.graph.Figure;\n@@ -29,2 +28,0 @@\n-import java.util.List;\n-import org.netbeans.api.visual.widget.Widget;\n@@ -40,2 +37,2 @@\n-    public OutputSlotWidget(OutputSlot slot, DiagramScene scene, Widget parent, FigureWidget fw) {\n-        super(slot, scene, parent, fw);\n+    public OutputSlotWidget(OutputSlot slot, DiagramScene scene, FigureWidget fw) {\n+        super(slot, scene, fw);\n@@ -49,8 +46,0 @@\n-    @Override\n-    protected int calculateSlotWidth() {\n-        List<OutputSlot> slots = getSlot().getFigure().getOutputSlots();\n-        assert slots.contains(getSlot());\n-        return calculateWidth(slots.size());\n-\n-    }\n-\n@@ -60,2 +49,2 @@\n-            calculateClientArea().height : Figure.SLOT_START;\n-        return getSlot().getFigure().getHeight() - overlap;\n+            calculateClientArea().height \/ 2 : 0;\n+        return getFigureWidget().getFigureHeight() - overlap;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/OutputSlotWidget.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.hotspot.igv.graph.OutputSlot;\n@@ -53,1 +52,1 @@\n-    public SlotWidget(Slot slot, DiagramScene scene, Widget parent, FigureWidget fw) {\n+    public SlotWidget(Slot slot, DiagramScene scene, FigureWidget fw) {\n@@ -63,6 +62,8 @@\n-        parent.addChild(this);\n-\n-        Point p = slot.getRelativePosition();\n-        p.x -= this.calculateClientArea().width \/ 2;\n-        p.y += yOffset();\n-        this.setPreferredLocation(p);\n+        fw.addChild(this);\n+        if (slot.shouldShowName()) {\n+            Point p = slot.getRelativePosition();\n+            p.x -= slot.getWidth() \/ 2;\n+            p.y -= slot.getHeight() \/ 2;\n+            p.y += yOffset();\n+            this.setPreferredLocation(p);\n+        }\n@@ -143,7 +144,1 @@\n-                if (slot instanceof OutputSlot) {\n-                    g.fillOval(w \/ 2 - r, Figure.SLOT_WIDTH - Figure.SLOT_START - r, 2 * r, 2 * r);\n-                } else {\n-                    g.fillOval(w \/ 2 - r, Figure.SLOT_START - r, 2 * r, 2 * r);\n-                }\n-            } else {\n-                \/\/ Do not paint a slot with connections.\n+                g.fillOval(w \/ 2 - r, h \/ 2 - r, 2 * r, 2 * r);\n@@ -156,1 +151,1 @@\n-        return new Rectangle(0, 0, slot.getWidth(), Figure.SLOT_WIDTH);\n+        return new Rectangle(0, 0, slot.getWidth(), slot.getHeight());\n@@ -159,2 +154,0 @@\n-    protected abstract int calculateSlotWidth();\n-\n@@ -163,4 +156,0 @@\n-    protected int calculateWidth(int count) {\n-        return getFigureWidget().getFigure().getWidth() \/ count;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-mvn --batch-mode -f application\/pom.xml nbm:run-platform >.igv.log 2>&1\n+mvn --batch-mode -f application\/pom.xml nbm:run-platform -Dnetbeans.run.params=\"-J-da\" >.igv.log 2>&1\n","filename":"src\/utils\/IdealGraphVisualizer\/igv.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  jcmd.gc.heap_info jcmd.gc.class_histogram jcmd.gc.finalizer_info jcmd.thread.dump_to_file \\\n+  jcmd.gc.heap_info jcmd.gc.class_histogram jcmd.gc.finalizer_info jcmd.thread.dump_to_file jcmd.thread.vthread_scheduler \\\n@@ -64,0 +64,2 @@\n+jcmd.thread.vthread_scheduler.args=%p Thread.vthread_scheduler\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/common.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"unittest.hpp\"\n+\n+class TestArchiveWorkerTask : public ArchiveWorkerTask {\n+private:\n+  volatile int _sum;\n+  int _max;\n+public:\n+  TestArchiveWorkerTask() : ArchiveWorkerTask(\"Test\"), _sum(0), _max(0) {}\n+  void work(int chunk, int max_chunks) override {\n+    Atomic::add(&_sum, chunk);\n+    Atomic::store(&_max, max_chunks);\n+  }\n+  int sum() { return Atomic::load(&_sum); }\n+  int max() { return Atomic::load(&_max); }\n+};\n+\n+\/\/ Test a repeated cycle of workers init\/shutdown without task works.\n+TEST_VM(ArchiveWorkersTest, continuous_restart) {\n+  for (int c = 0; c < 1000; c++) {\n+    ArchiveWorkers workers;\n+  }\n+}\n+\n+\/\/ Test a repeated cycle of sample task works.\n+TEST_VM(ArchiveWorkersTest, single_task) {\n+  for (int c = 0; c < 1000; c++) {\n+    TestArchiveWorkerTask task;\n+    ArchiveWorkers workers;\n+    workers.run_task(&task);\n+    ASSERT_EQ(task.max() * (task.max() - 1) \/ 2, task.sum());\n+  }\n+}\n+\n+\/\/ Test that reusing the workers fails.\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(ArchiveWorkersTest, multiple_tasks, \".* Should be unused yet\") {\n+  TestArchiveWorkerTask task;\n+  ArchiveWorkers workers;\n+  workers.run_task(&task);\n+  workers.run_task(&task);\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"test\/hotspot\/gtest\/cds\/test_archiveWorkers.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-  ReservedSpace bot_rs(G1BlockOffsetTable::compute_size(heap.word_size()));\n+  ReservedSpace bot_rs(G1BlockOffsetTable::compute_size(heap.word_size()), mtGC);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3,1 +4,0 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,25 @@\n-  HdrSeq seq;\n+  const double err = 0.5;\n+\n+  HdrSeq seq1;\n+  HdrSeq seq2;\n+  HdrSeq seq3;\n+\n+  void print() {\n+    if (seq1.num() > 0) {\n+      print(seq1, \"seq1\");\n+    }\n+    if (seq2.num() > 0) {\n+      print(seq2, \"seq2\");\n+    }\n+    if (seq3.num() > 0) {\n+      print(seq3, \"seq3\");\n+    }\n+  }\n+\n+  void print(HdrSeq& seq, const char* msg) {\n+    std::cout << \"[\";\n+    for (int i = 0; i <= 100; i += 10) {\n+      std::cout << \"\\t p\" << i << \":\" << seq.percentile(i);\n+    }\n+    std::cout << \"\\t] : \" << msg << \"\\n\";\n+  }\n@@ -41,2 +65,1 @@\n- protected:\n-  const double err = 0.5;\n+ public:\n@@ -44,3 +67,3 @@\n-    seq.add(0);\n-    seq.add(1);\n-    seq.add(10);\n+    seq1.add(0);\n+    seq1.add(1);\n+    seq1.add(10);\n@@ -48,1 +71,12 @@\n-      seq.add(100);\n+      seq1.add(100);\n+    }\n+    ShenandoahNumberSeqTest::print();\n+  }\n+};\n+\n+class ShenandoahNumberSeqMergeTest: public ShenandoahNumberSeqTest {\n+ public:\n+  ShenandoahNumberSeqMergeTest() {\n+    for (int i = 0; i < 80; i++) {\n+      seq1.add(1);\n+      seq3.add(1);\n@@ -50,8 +84,6 @@\n-    std::cout << \" p0 = \" << seq.percentile(0);\n-    std::cout << \" p10 = \" << seq.percentile(10);\n-    std::cout << \" p20 = \" << seq.percentile(20);\n-    std::cout << \" p30 = \" << seq.percentile(30);\n-    std::cout << \" p50 = \" << seq.percentile(50);\n-    std::cout << \" p80 = \" << seq.percentile(80);\n-    std::cout << \" p90 = \" << seq.percentile(90);\n-    std::cout << \" p100 = \" << seq.percentile(100);\n+\n+    for (int i = 0; i < 20; i++) {\n+      seq2.add(100);\n+      seq3.add(100);\n+    }\n+    ShenandoahNumberSeqTest::print();\n@@ -62,1 +94,1 @@\n-  EXPECT_EQ(seq.maximum(), 100);\n+  EXPECT_EQ(seq1.maximum(), 100);\n@@ -66,1 +98,1 @@\n-  EXPECT_EQ(0, seq.percentile(0));\n+  EXPECT_EQ(0, seq1.percentile(0));\n@@ -70,8 +102,61 @@\n-  EXPECT_NEAR(0, seq.percentile(10), err);\n-  EXPECT_NEAR(1, seq.percentile(20), err);\n-  EXPECT_NEAR(10, seq.percentile(30), err);\n-  EXPECT_NEAR(100, seq.percentile(40), err);\n-  EXPECT_NEAR(100, seq.percentile(50), err);\n-  EXPECT_NEAR(100, seq.percentile(75), err);\n-  EXPECT_NEAR(100, seq.percentile(90), err);\n-  EXPECT_NEAR(100, seq.percentile(100), err);\n+  EXPECT_NEAR(0, seq1.percentile(10), err);\n+  EXPECT_NEAR(1, seq1.percentile(20), err);\n+  EXPECT_NEAR(10, seq1.percentile(30), err);\n+  EXPECT_NEAR(100, seq1.percentile(40), err);\n+  EXPECT_NEAR(100, seq1.percentile(50), err);\n+  EXPECT_NEAR(100, seq1.percentile(75), err);\n+  EXPECT_NEAR(100, seq1.percentile(90), err);\n+  EXPECT_NEAR(100, seq1.percentile(100), err);\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, clear_test) {\n+  HdrSeq test;\n+  test.add(1);\n+\n+  EXPECT_NE(test.num(), 0);\n+  EXPECT_NE(test.sum(), 0);\n+  EXPECT_NE(test.maximum(), 0);\n+  EXPECT_NE(test.avg(), 0);\n+  EXPECT_EQ(test.sd(), 0);\n+  EXPECT_NE(test.davg(), 0);\n+  EXPECT_EQ(test.dvariance(), 0);\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_NE(test.percentile(i), 0);\n+  }\n+\n+  test.clear();\n+\n+  EXPECT_EQ(test.num(), 0);\n+  EXPECT_EQ(test.sum(), 0);\n+  EXPECT_EQ(test.maximum(), 0);\n+  EXPECT_EQ(test.avg(), 0);\n+  EXPECT_EQ(test.sd(), 0);\n+  EXPECT_EQ(test.davg(), 0);\n+  EXPECT_EQ(test.dvariance(), 0);\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_EQ(test.percentile(i), 0);\n+  }\n+}\n+\n+TEST_VM_F(ShenandoahNumberSeqMergeTest, merge_test) {\n+  EXPECT_EQ(seq1.num(), 80);\n+  EXPECT_EQ(seq2.num(), 20);\n+  EXPECT_EQ(seq3.num(), 100);\n+\n+  HdrSeq merged;\n+  merged.add(seq1);\n+  merged.add(seq2);\n+\n+  EXPECT_EQ(merged.num(), seq3.num());\n+\n+  EXPECT_EQ(merged.maximum(), seq3.maximum());\n+  EXPECT_EQ(merged.percentile(0), seq3.percentile(0));\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_NEAR(merged.percentile(i), seq3.percentile(i), err);\n+  }\n+  EXPECT_NEAR(merged.avg(), seq3.avg(), err);\n+  EXPECT_NEAR(merged.sd(),  seq3.sd(),  err);\n+\n+  \/\/ These are not implemented\n+  EXPECT_TRUE(isnan(merged.davg()));\n+  EXPECT_TRUE(isnan(merged.dvariance()));\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":111,"deletions":26,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+\n+#define SKIP_IF_NOT_SHENANDOAH() \\\n+  if (!(UseShenandoahGC && ShenandoahHeap::heap()->mode()->is_generational())) {                 \\\n+    tty->print_cr(\"skipped (run with -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational)\");  \\\n+    return;                                                                                      \\\n+  }\n+\n+\n+class ShenandoahOldGenerationTest : public ::testing::Test {\n+protected:\n+  static const size_t INITIAL_PLAB_SIZE;\n+  static const size_t INITIAL_PLAB_PROMOTED;\n+\n+  ShenandoahOldGeneration* old;\n+\n+  ShenandoahOldGenerationTest()\n+    : old(nullptr)\n+  {\n+  }\n+\n+  void SetUp() override {\n+    SKIP_IF_NOT_SHENANDOAH();\n+\n+    ShenandoahHeap::heap()->lock()->lock(false);\n+\n+    old = new ShenandoahOldGeneration(8, 1024 * 1024, 1024);\n+    old->set_promoted_reserve(512 * HeapWordSize);\n+    old->expend_promoted(256 * HeapWordSize);\n+    old->set_evacuation_reserve(512 * HeapWordSize);\n+\n+    Thread* thread = Thread::current();\n+    ShenandoahThreadLocalData::reset_plab_promoted(thread);\n+    ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+    ShenandoahThreadLocalData::set_plab_actual_size(thread, INITIAL_PLAB_SIZE);\n+    ShenandoahThreadLocalData::add_to_plab_promoted(thread, INITIAL_PLAB_PROMOTED);\n+  }\n+\n+  void TearDown() override {\n+    if (UseShenandoahGC) {\n+      ShenandoahHeap::heap()->lock()->unlock();\n+      delete old;\n+    }\n+  }\n+\n+  static bool promotions_enabled() {\n+    return ShenandoahThreadLocalData::allow_plab_promotions(Thread::current());\n+  }\n+\n+  static size_t plab_size() {\n+    return ShenandoahThreadLocalData::get_plab_actual_size(Thread::current());\n+  }\n+\n+  static size_t plab_promoted() {\n+    return ShenandoahThreadLocalData::get_plab_promoted(Thread::current());\n+  }\n+};\n+\n+const size_t ShenandoahOldGenerationTest::INITIAL_PLAB_SIZE = 42;\n+const size_t ShenandoahOldGenerationTest::INITIAL_PLAB_PROMOTED = 128;\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_can_promote) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  EXPECT_TRUE(old->can_promote(128 * HeapWordSize)) << \"Should have room to promote\";\n+  EXPECT_FALSE(old->can_promote(384 * HeapWordSize)) << \"Should not have room to promote\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_can_allocate_plab_for_promotion) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_plab(128, 128);\n+  EXPECT_TRUE(old->can_allocate(req)) << \"Should have room to promote\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_can_allocate_plab_for_evacuation) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_plab(384, 384);\n+  EXPECT_FALSE(old->can_promote(req.size() * HeapWordSize)) << \"No room for promotions\";\n+  EXPECT_TRUE(old->can_allocate(req)) << \"Should have room to evacuate\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_cannot_allocate_plab) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  \/\/ Simulate having exhausted the evacuation reserve when request is too big to be promoted\n+  old->set_evacuation_reserve(0);\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_plab(384, 384);\n+  EXPECT_FALSE(old->can_allocate(req)) << \"No room for promotions or evacuations\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_can_allocate_for_shared_evacuation) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(768, ShenandoahAffiliation::OLD_GENERATION, false);\n+  EXPECT_FALSE(old->can_promote(req.size() * HeapWordSize)) << \"No room for promotion\";\n+  EXPECT_TRUE(old->can_allocate(req)) << \"Should have room to evacuate shared (even though evacuation reserve is smaller than request)\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_cannot_allocate_for_shared_promotion) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(768, ShenandoahAffiliation::OLD_GENERATION, true);\n+  EXPECT_FALSE(old->can_promote(req.size() * HeapWordSize)) << \"No room for promotion\";\n+  EXPECT_FALSE(old->can_allocate(req)) << \"No room to promote, should fall back to evacuation in young gen\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_expend_promoted) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_plab(128, 128);\n+\n+  \/\/ simulate the allocation\n+  req.set_actual_size(128);\n+\n+  size_t actual_size = req.actual_size() * HeapWordSize;\n+  EXPECT_TRUE(old->can_promote(actual_size)) << \"Should have room for promotion\";\n+\n+  size_t expended_before = old->get_promoted_expended();\n+  old->configure_plab_for_current_thread(req);\n+  size_t expended_after = old->get_promoted_expended();\n+  EXPECT_EQ(expended_before + actual_size, expended_after) << \"Should expend promotion reserve\";\n+  EXPECT_EQ(plab_promoted(), 0UL) << \"Nothing promoted yet\";\n+  EXPECT_EQ(plab_size(), actual_size) << \"New plab should be able to hold this much promotion\";\n+  EXPECT_TRUE(promotions_enabled()) << \"Plab should be available for promotions\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_actual_size_exceeds_promotion_reserve) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_plab(128, 128);\n+\n+  \/\/ simulate an allocation that exceeds the promotion reserve after allocation\n+  req.set_actual_size(384);\n+  EXPECT_FALSE(old->can_promote(req.actual_size() * HeapWordSize)) << \"Should have room for promotion\";\n+\n+  size_t expended_before = old->get_promoted_expended();\n+  old->configure_plab_for_current_thread(req);\n+  size_t expended_after = old->get_promoted_expended();\n+\n+  EXPECT_EQ(expended_before, expended_after) << \"Did not promote, should not expend promotion\";\n+  EXPECT_EQ(plab_promoted(), 0UL) << \"Cannot promote in new plab\";\n+  EXPECT_EQ(plab_size(), 0UL) << \"Should not have space for promotions\";\n+  EXPECT_FALSE(promotions_enabled()) << \"New plab can only be used for evacuations\";\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_shared_expends_promoted_but_does_not_change_plab) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(128, ShenandoahAffiliation::OLD_GENERATION, true);\n+  req.set_actual_size(128);\n+  size_t actual_size = req.actual_size() * HeapWordSize;\n+\n+  size_t expended_before = old->get_promoted_expended();\n+  old->configure_plab_for_current_thread(req);\n+  size_t expended_after = old->get_promoted_expended();\n+\n+  EXPECT_EQ(expended_before + actual_size, expended_after) << \"Shared promotion still expends promotion\";\n+  EXPECT_EQ(plab_promoted(), INITIAL_PLAB_PROMOTED) << \"Shared promotion should not count in plab\";\n+  EXPECT_EQ(plab_size(), INITIAL_PLAB_SIZE) << \"Shared promotion should not change size of plab\";\n+  EXPECT_FALSE(promotions_enabled());\n+}\n+\n+TEST_VM_F(ShenandoahOldGenerationTest, test_shared_evacuation_has_no_side_effects) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(128, ShenandoahAffiliation::OLD_GENERATION, false);\n+  req.set_actual_size(128);\n+\n+  size_t expended_before = old->get_promoted_expended();\n+  old->configure_plab_for_current_thread(req);\n+  size_t expended_after = old->get_promoted_expended();\n+\n+  EXPECT_EQ(expended_before, expended_after) << \"Not a promotion, should not expend promotion reserve\";\n+  EXPECT_EQ(plab_promoted(), INITIAL_PLAB_PROMOTED) << \"Not a plab, should not have touched plab\";\n+  EXPECT_EQ(plab_size(), INITIAL_PLAB_SIZE) << \"Not a plab, should not have touched plab\";\n+  EXPECT_FALSE(promotions_enabled());\n+}\n+\n+#undef SKIP_IF_NOT_SHENANDOAH\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldGeneration.cpp","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include <cstdarg>\n+\n+\/\/ These tests will all be skipped (unless Shenandoah becomes the default\n+\/\/ collector). To execute these tests, you must enable Shenandoah, which\n+\/\/ is done with:\n+\/\/\n+\/\/ % make exploded-test TEST=\"gtest:ShenandoahOld*\" CONF=release TEST_OPTS=\"JAVA_OPTIONS=-XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational\"\n+\/\/\n+\/\/ Please note that these 'unit' tests are really integration tests and rely\n+\/\/ on the JVM being initialized. These tests manipulate the state of the\n+\/\/ collector in ways that are not compatible with a normal collection run.\n+\/\/ If these tests take longer than the minimum time between gc intervals -\n+\/\/ or, more likely, if you have them paused in a debugger longer than this\n+\/\/ interval - you can expect trouble. These tests will also not run in a build\n+\/\/ with asserts enabled because they use APIs that expect to run on a safepoint.\n+#ifdef ASSERT\n+#define SKIP_IF_NOT_SHENANDOAH()           \\\n+  tty->print_cr(\"skipped (debug build)\" ); \\\n+  return;\n+#else\n+#define SKIP_IF_NOT_SHENANDOAH() \\\n+    if (!UseShenandoahGC) {      \\\n+      tty->print_cr(\"skipped\");  \\\n+      return;                    \\\n+    }\n+#endif\n+\n+class ShenandoahResetRegions : public ShenandoahHeapRegionClosure {\n+ public:\n+  virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n+    if (!region->is_empty()) {\n+      region->make_trash();\n+      region->make_empty();\n+    }\n+    region->set_affiliation(FREE);\n+    region->clear_live_data();\n+    region->set_top(region->bottom());\n+  }\n+};\n+\n+class ShenandoahOldHeuristicTest : public ::testing::Test {\n+ protected:\n+  ShenandoahHeap* _heap;\n+  ShenandoahOldHeuristics* _heuristics;\n+  ShenandoahCollectionSet* _collection_set;\n+\n+  ShenandoahOldHeuristicTest()\n+    : _heap(nullptr),\n+      _heuristics(nullptr),\n+      _collection_set(nullptr) {\n+    SKIP_IF_NOT_SHENANDOAH();\n+    _heap = ShenandoahHeap::heap();\n+    _heuristics = _heap->old_generation()->heuristics();\n+    _collection_set = _heap->collection_set();\n+    _heap->lock()->lock(false);\n+    ShenandoahResetRegions reset;\n+    _heap->heap_region_iterate(&reset);\n+    _heap->old_generation()->set_capacity(ShenandoahHeapRegion::region_size_bytes() * 10);\n+    _heap->old_generation()->set_evacuation_reserve(ShenandoahHeapRegion::region_size_bytes() * 4);\n+    _heuristics->abandon_collection_candidates();\n+    _collection_set->clear();\n+  }\n+\n+  ~ShenandoahOldHeuristicTest() override {\n+    SKIP_IF_NOT_SHENANDOAH();\n+    _heap->lock()->unlock();\n+  }\n+\n+  ShenandoahOldGeneration::State old_generation_state() {\n+    return _heap->old_generation()->state();\n+  }\n+\n+  size_t make_garbage(size_t region_idx, size_t garbage_bytes) {\n+    ShenandoahHeapRegion* region = _heap->get_region(region_idx);\n+    region->set_affiliation(OLD_GENERATION);\n+    region->make_regular_allocation(OLD_GENERATION);\n+    size_t live_bytes = ShenandoahHeapRegion::region_size_bytes() - garbage_bytes;\n+    region->increase_live_data_alloc_words(live_bytes \/ HeapWordSize);\n+    region->set_top(region->end());\n+    return region->garbage();\n+  }\n+\n+  size_t create_too_much_garbage_for_one_mixed_evacuation() {\n+    size_t garbage_target = _heap->old_generation()->max_capacity() \/ 2;\n+    size_t garbage_total = 0;\n+    size_t region_idx = 0;\n+    while (garbage_total < garbage_target && region_idx < _heap->num_regions()) {\n+      garbage_total += make_garbage_above_collection_threshold(region_idx++);\n+    }\n+    return garbage_total;\n+  }\n+\n+  void make_pinned(size_t region_idx) {\n+    ShenandoahHeapRegion* region = _heap->get_region(region_idx);\n+    region->record_pin();\n+    region->make_pinned();\n+  }\n+\n+  void make_unpinned(size_t region_idx) {\n+    ShenandoahHeapRegion* region = _heap->get_region(region_idx);\n+    region->record_unpin();\n+    region->make_unpinned();\n+  }\n+\n+  size_t make_garbage_below_collection_threshold(size_t region_idx) {\n+    return make_garbage(region_idx, collection_threshold() - 100);\n+  }\n+\n+  size_t make_garbage_above_collection_threshold(size_t region_idx) {\n+    return make_garbage(region_idx, collection_threshold() + 100);\n+  }\n+\n+  size_t collection_threshold() const {\n+    return ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold \/ 100;\n+  }\n+\n+  bool collection_set_is(size_t r1) { return _collection_set_is(1, r1); }\n+  bool collection_set_is(size_t r1, size_t r2) { return _collection_set_is(2, r1, r2); }\n+  bool collection_set_is(size_t r1, size_t r2, size_t r3) { return _collection_set_is(3, r1, r2, r3); }\n+\n+  bool _collection_set_is(size_t count, ...) {\n+    va_list args;\n+    va_start(args, count);\n+    EXPECT_EQ(count, _collection_set->count());\n+    bool result = true;\n+    for (size_t i = 0; i < count; ++i) {\n+      size_t index = va_arg(args, size_t);\n+      if (!_collection_set->is_in(index)) {\n+        result = false;\n+        break;\n+      }\n+    }\n+    va_end(args);\n+    return result;\n+  }\n+};\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, select_no_old_regions) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  _heuristics->prepare_for_old_collections();\n+  EXPECT_EQ(0U, _heuristics->coalesce_and_fill_candidates_count());\n+  EXPECT_EQ(0U, _heuristics->last_old_collection_candidate_index());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, select_no_old_region_above_threshold) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ In this case, we have zero regions to add to the collection set,\n+  \/\/ but we will have one region that must still be made parseable.\n+  make_garbage_below_collection_threshold(10);\n+  _heuristics->prepare_for_old_collections();\n+  EXPECT_EQ(1U, _heuristics->coalesce_and_fill_candidates_count());\n+  EXPECT_EQ(0U, _heuristics->last_old_collection_candidate_index());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, select_one_old_region_above_threshold) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  make_garbage_above_collection_threshold(10);\n+  _heuristics->prepare_for_old_collections();\n+  EXPECT_EQ(1U, _heuristics->coalesce_and_fill_candidates_count());\n+  EXPECT_EQ(1U, _heuristics->last_old_collection_candidate_index());\n+  EXPECT_EQ(1U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, prime_one_old_region) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t garbage = make_garbage_above_collection_threshold(10);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(10UL));\n+  EXPECT_EQ(garbage, _collection_set->get_old_garbage());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, prime_many_old_regions) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t g1 = make_garbage_above_collection_threshold(100);\n+  size_t g2 = make_garbage_above_collection_threshold(101);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(100UL, 101UL));\n+  EXPECT_EQ(g1 + g2, _collection_set->get_old_garbage());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, require_multiple_mixed_evacuations) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t garbage = create_too_much_garbage_for_one_mixed_evacuation();\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_LT(_collection_set->get_old_garbage(), garbage);\n+  EXPECT_GT(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, skip_pinned_regions) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n+\n+  \/\/ A region can be pinned when we chose collection set candidates.\n+  make_pinned(1);\n+  _heuristics->prepare_for_old_collections();\n+\n+  \/\/ We only exclude pinned regions when we actually add regions to the collection set.\n+  ASSERT_EQ(3UL, _heuristics->unprocessed_old_collection_candidates());\n+\n+  \/\/ Here the region is still pinned, so it cannot be added to the collection set.\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  \/\/ The two unpinned regions should be added to the collection set and the pinned\n+  \/\/ region should be retained at the front of the list of candidates as it would be\n+  \/\/ likely to become unpinned by the next mixed collection cycle.\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g1 + g3);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 1UL);\n+\n+  \/\/ Simulate another mixed collection after making region 1 unpinned. This time,\n+  \/\/ the now unpinned region should be added to the collection set.\n+  make_unpinned(1);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g2);\n+  EXPECT_TRUE(collection_set_is(1UL));\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, pinned_region_is_first) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n+\n+  make_pinned(0);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(1UL, 2UL));\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 1UL);\n+\n+  make_unpinned(0);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(0UL));\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, pinned_region_is_last) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n+\n+  make_pinned(2);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(0UL, 1UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g1 + g2);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 1UL);\n+\n+  make_unpinned(2);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(2UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g3);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, unpinned_region_is_middle) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n+\n+  make_pinned(0);\n+  make_pinned(2);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(1UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g2);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 2UL);\n+\n+  make_unpinned(0);\n+  make_unpinned(2);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g1 + g3);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, all_candidates_are_pinned) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t g1 = make_garbage_above_collection_threshold(0);\n+  size_t g2 = make_garbage_above_collection_threshold(1);\n+  size_t g3 = make_garbage_above_collection_threshold(2);\n+\n+  make_pinned(0);\n+  make_pinned(1);\n+  make_pinned(2);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  \/\/ In the case when all candidates are pinned, we want to abandon\n+  \/\/ this set of mixed collection candidates so that another old collection\n+  \/\/ can run. This is meant to defend against \"bad\" JNI code that permanently\n+  \/\/ leaves an old region in the pinned state.\n+  EXPECT_EQ(_collection_set->count(), 0UL);\n+  EXPECT_EQ(old_generation_state(), ShenandoahOldGeneration::FILLING);\n+}\n+#undef SKIP_IF_NOT_SHENANDOAH\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -67,1 +67,1 @@\n-    ReservedSpace rs(size);\n+    ReservedSpace rs(size, mtTest);\n@@ -218,1 +218,1 @@\n-        return ReservedSpace(reserve_size_aligned);\n+        return ReservedSpace(reserve_size_aligned, mtTest);\n@@ -390,1 +390,1 @@\n-    ReservedSpace rs(size);\n+    ReservedSpace rs(size, mtTest);\n@@ -519,1 +519,1 @@\n-      return ReservedSpace(reserve_size_aligned);\n+      return ReservedSpace(reserve_size_aligned, mtTest);\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -287,0 +287,182 @@\n+TEST_VM_F(NMTVMATreeTest, SetTag) {\n+  using State = VMATree::StateType;\n+  struct testrange {\n+    VMATree::position from;\n+    VMATree::position to;\n+    MemTag tag;\n+    NCS::StackIndex stack;\n+    State state;\n+  };\n+\n+  \/\/ Take a sorted list of testranges and check that those and only those are found in the tree.\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+    \/\/ With auto& our arrays do not deteriorate to pointers but are kept as testrange[N]\n+    \/\/ so this actually works!\n+    int len = sizeof(expected) \/ sizeof(testrange);\n+    VMATree::position previous_to = 0;\n+    for (int i = 0; i < len; i++) {\n+      testrange expect = expected[i];\n+      assert(previous_to == 0 || previous_to <= expect.from, \"the expected list must be sorted\");\n+      previous_to = expect.to;\n+\n+      VMATree::VMATreap::Range found = tree.tree().find_enclosing_range(expect.from);\n+      ASSERT_NE(nullptr, found.start);\n+      ASSERT_NE(nullptr, found.end);\n+      \/\/ Same region\n+      EXPECT_EQ(expect.from, found.start->key());\n+      EXPECT_EQ(expect.to, found.end->key());\n+      \/\/ Same tag\n+      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag());\n+      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag());\n+      \/\/ Same stack\n+      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n+      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      \/\/ Same state\n+      EXPECT_EQ(expect.state, found.start->val().out.type());\n+      EXPECT_EQ(expect.state, found.end->val().in.type());\n+    }\n+    \/\/ expected must cover all nodes\n+    EXPECT_EQ(len+1, tree.tree().size());\n+  };\n+  NCS::StackIndex si = NCS::StackIndex();\n+  Tree::RegionData rd(si, mtNone);\n+\n+  { \/\/ The gc\/cds case with only reserved data\n+    testrange expected[2]{\n+        {  0, 500,          mtGC, si, State::Reserved},\n+        {500, 600, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+\n+    tree.reserve_mapping(0, 600, rd);\n+\n+    tree.set_tag(0, 500, mtGC);\n+    tree.set_tag(500, 100, mtClassShared);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Now let's add in some committed data\n+    testrange expected[]{\n+        {  0, 100,          mtGC, si, State::Reserved},\n+        {100, 225,          mtGC, si, State::Committed},\n+        {225, 500,          mtGC, si, State::Reserved},\n+        {500, 550, mtClassShared, si, State::Reserved},\n+        {550, 560, mtClassShared, si, State::Committed},\n+        {560, 565, mtClassShared, si, State::Reserved},\n+        {565, 575, mtClassShared, si, State::Committed},\n+        {575, 600, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+\n+    tree.reserve_mapping(0, 600, rd);\n+    \/\/ The committed areas\n+    tree.commit_mapping(100, 125, rd);\n+    tree.commit_mapping(550, 10, rd);\n+    tree.commit_mapping(565, 10, rd);\n+    \/\/ OK, set tag\n+    tree.set_tag(0, 500, mtGC);\n+    tree.set_tag(500, 100, mtClassShared);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag for adjacent regions with same stacks should merge the regions\n+    testrange expected[]{\n+        {0, 200, mtGC, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData gc(si, mtGC);\n+    Tree::RegionData compiler(si, mtCompiler);\n+    tree.reserve_mapping(0, 100, gc);\n+    tree.reserve_mapping(100, 100, compiler);\n+    tree.set_tag(0, 200, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag for adjacent regions with different stacks should NOT merge the regions\n+    NCS::StackIndex si1 = 1;\n+    NCS::StackIndex si2 = 2;\n+    testrange expected[]{\n+        {  0, 100, mtGC, si1, State::Reserved},\n+        {100, 200, mtGC, si2, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData gc(si1, mtGC);\n+    Tree::RegionData compiler(si2, mtCompiler);\n+    tree.reserve_mapping(0, 100, gc);\n+    tree.reserve_mapping(100, 100, compiler);\n+    tree.set_tag(0, 200, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag in the middle of a range causes a split\n+    testrange expected[]{\n+        {  0, 100, mtCompiler, si, State::Reserved},\n+        {100, 150,       mtGC, si, State::Reserved},\n+        {150, 200, mtCompiler, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData compiler(si, mtCompiler);\n+    tree.reserve_mapping(0, 200, compiler);\n+    tree.set_tag(100, 50, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag in between two ranges causes a split\n+    testrange expected[]{\n+        {  0,  75,       mtGC, si, State::Reserved},\n+        { 75, 125,    mtClass, si, State::Reserved},\n+        {125, 200, mtCompiler, si, State::Reserved},\n+    };\n+    VMATree tree;\n+    Tree::RegionData gc(si, mtGC);\n+    Tree::RegionData compiler(si, mtCompiler);\n+    tree.reserve_mapping(0, 100, gc);\n+    tree.reserve_mapping(100, 100, compiler);\n+    tree.set_tag(75, 50, mtClass);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Holes in the address range are acceptable and untouched\n+    testrange expected[]{\n+        { 0,  50,          mtGC, si, State::Reserved},\n+        {50,  75,        mtNone, si, State::Released},\n+        {75,  80,          mtGC, si, State::Reserved},\n+        {80, 100, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData class_shared(si, mtClassShared);\n+    tree.reserve_mapping(0, 50, class_shared);\n+    tree.reserve_mapping(75, 25, class_shared);\n+    tree.set_tag(0, 80, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Check that setting tag with 'hole' not consisting of any regions work\n+    testrange expected[]{\n+        {10, 20, mtCompiler, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData class_shared(si, mtClassShared);\n+    tree.reserve_mapping(10, 10, class_shared);\n+    tree.set_tag(0, 100, mtCompiler);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Check that multiple holes still work\n+    testrange expected[]{\n+        { 0,   1,   mtGC, si, State::Reserved},\n+        { 1,  50, mtNone, si, State::Released},\n+        {50,  75,   mtGC, si, State::Reserved},\n+        {75,  99, mtNone, si, State::Released},\n+        {99, 100,   mtGC, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData class_shared(si, mtClassShared);\n+    tree.reserve_mapping(0, 100, class_shared);\n+    tree.release_mapping(1, 49);\n+    tree.release_mapping(75, 24);\n+    tree.set_tag(0, 100, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+}\n+\n@@ -333,1 +515,1 @@\n-  { \/\/ Adjacent reserved mappings with different flags\n+  { \/\/ Adjacent reserved mappings with different tags\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":183,"deletions":1,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -0,0 +1,473 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#if (defined(RISCV) || defined(RISCV64)) && !defined(ZERO)\n+\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"unittest.hpp\"\n+\n+typedef int64_t (*zicond_func)(int64_t cmp1, int64_t cmp2, int64_t dst, int64_t src);\n+typedef void (MacroAssembler::*cmov_func)(Register cmp1, Register cmp2, Register dst, Register src);\n+\n+class CmovTester {\n+ public:\n+  static void test(cmov_func func, int64_t a0, int64_t a1, int64_t a2, int64_t a3, int64_t result) {\n+    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(bb);\n+    MacroAssembler _masm(&code);\n+    address entry = _masm.pc();\n+    {\n+      ((&_masm)->*func)(c_rarg0, c_rarg1, c_rarg2, c_rarg3);\n+      _masm.mv(c_rarg0, c_rarg2);\n+      _masm.ret();\n+    }\n+    _masm.flush(); \/\/ icache invalidate\n+    int64_t ret = ((zicond_func)entry)(a0, a1, a2, a3);\n+    ASSERT_EQ(ret, result);\n+    BufferBlob::free(bb);\n+  }\n+};\n+\n+void run_cmov_tests() {\n+  \/\/ If 42(a0) eq 42(a1): assign dest(a2\/66) the src(a3\/77), expect result: 77\n+  CmovTester::test(&MacroAssembler::cmov_eq, 42, 42, 66, 77, 77);\n+  \/\/ If 41(a0) eq 42(a1): assign dest(a2\/66) the src(a3\/77), expect result: 66\n+  CmovTester::test(&MacroAssembler::cmov_eq, 41, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_ne, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ne, 42, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_le, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_le, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_le, 42, -1, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_leu, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_leu, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_leu, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_ge, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ge, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ge, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_geu, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_geu, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_geu, 42, -1, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_lt, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_lt, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_lt, 42, -1, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_ltu, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ltu, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_ltu, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_gt, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_gt, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_gt, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_gtu, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_gtu, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_gtu, 42, -1, 66, 77, 66);\n+}\n+\n+TEST_VM(RiscV, cmov) {\n+  run_cmov_tests();\n+  if (UseZicond) {\n+    UseZicond = false;\n+    run_cmov_tests();\n+    UseZicond = true;\n+  }\n+}\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+class CmpxchgTester {\n+ public:\n+  typedef TESTSIZE (*cmpxchg_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result);\n+\n+  static TESTSIZE base_cmpxchg(int variant, intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result, bool boolean_result = false) {\n+    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(bb);\n+    MacroAssembler _masm(&code);\n+    address entry = _masm.pc();\n+    {\n+      switch(variant) {\n+        default:\n+          _masm.cmpxchg(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n+                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        \/*result*\/ c_rarg3, boolean_result);\n+          _masm.mv(c_rarg0, c_rarg3);\n+          break;\n+        case 1:\n+          \/\/ expected == result\n+          _masm.cmpxchg(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n+                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        \/*result*\/ c_rarg1, boolean_result);\n+          _masm.mv(c_rarg0, c_rarg1);\n+          break;\n+        case 2:\n+          \/\/ new_value == result\n+          _masm.cmpxchg(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n+                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        \/*result*\/ c_rarg2, boolean_result);\n+          _masm.mv(c_rarg0, c_rarg2);\n+          break;\n+        case 3:\n+          \/\/ expected == new_value\n+          _masm.cmpxchg(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/ c_rarg1,\n+                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        \/*result*\/ c_rarg2, boolean_result);\n+          _masm.mv(c_rarg0, c_rarg2);\n+          break;\n+\n+      }\n+      _masm.ret();\n+    }\n+    _masm.flush(); \/\/ icache invalidate\n+    TESTSIZE ret = ((cmpxchg_func)entry)(addr, expected, new_value, result);\n+    BufferBlob::free(bb);\n+    return ret;\n+  }\n+};\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+void plain_cmpxchg_test(int variant, TESTSIZE dv, TESTSIZE ex, TESTSIZE nv, TESTSIZE eret, TESTSIZE edata, bool bv) {\n+  TESTSIZE data = dv;\n+  TESTSIZE ret = CmpxchgTester<TESTSIZE, ASMSIZE>::base_cmpxchg(variant, (intptr_t)&data, ex, nv, \/* dummy *\/ 67, bv);\n+  ASSERT_EQ(ret,  eret);\n+  ASSERT_EQ(data, edata);\n+}\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+void run_plain_cmpxchg_tests() {\n+  \/\/ Normal\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/    , 42 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                           1 \/* return *\/    , 42 \/* end value*\/, true \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n+\n+  \/\/ result == expected register\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/    , 42 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                           1 \/* return *\/    , 42 \/* end value*\/, true \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n+\n+  \/\/ new_value == result register\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/    , 42 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                           1 \/* return *\/    , 42 \/* end value*\/, true \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n+\n+  \/\/ expected == new_value register\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1337 \/* expected *\/,   42 \/* new value *\/,\n+                                           1 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n+\n+  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n+                                        1336 \/* expected *\/,   42 \/* new value *\/,\n+                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int64_plain_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_plain_cmpxchg_tests<int64_t, Assembler::int64>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int64_plain_maybe_zacas) {\n+  if (UseZacas) {\n+    run_plain_cmpxchg_tests<int64_t, Assembler::int64>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int32_plain_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_plain_cmpxchg_tests<int32_t, Assembler::int32>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int32_plain_maybe_zacas) {\n+  if (UseZacas) {\n+    run_plain_cmpxchg_tests<int32_t, Assembler::int32>();\n+  }\n+}\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+class NarrowCmpxchgTester {\n+ public:\n+  typedef TESTSIZE (*cmpxchg_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result,\n+                                   int64_t scratch0, int64_t scratch1, int64_t scratch2);\n+\n+  static TESTSIZE narrow_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result, bool boolean_result = false) {\n+    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(bb);\n+    MacroAssembler _masm(&code);\n+    address entry = _masm.pc();\n+    {\n+       _masm.cmpxchg_narrow_value(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n+                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        \/*result*\/ c_rarg3, boolean_result, c_rarg4, c_rarg5, c_rarg6); \/* Uses also t0-t1, caller saved *\/\n+      _masm.mv(c_rarg0, c_rarg3);\n+      _masm.ret();\n+    }\n+    _masm.flush(); \/\/ icache invalidate\n+    TESTSIZE ret = ((cmpxchg_func)entry)(addr, expected, new_value, result, -1, -1, -1);\n+    BufferBlob::free(bb);\n+    return ret;\n+  }\n+};\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+void run_narrow_cmpxchg_tests() {\n+  \/\/ Assume natural aligned\n+  TESTSIZE data[8];\n+  TESTSIZE ret;\n+  for (int i = 0; i < 7; i++) {\n+    memset(data, -1, sizeof(data));\n+\n+    data[i] = 121;\n+    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 121, 42, \/* result *\/ 67, false);\n+    ASSERT_EQ(ret, 121);\n+    ASSERT_EQ(data[i], 42);\n+\n+    data[i] = 121;\n+    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 120, 42, \/* result *\/ 67, false);\n+    ASSERT_EQ(ret, 121);\n+    ASSERT_EQ(data[i], 121);\n+\n+    data[i] = 121;\n+    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 121, 42, \/* result *\/ 67, true);\n+    ASSERT_EQ(ret, 1);\n+    ASSERT_EQ(data[i], 42);\n+\n+    data[i] = 121;\n+    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 120, 42, \/* result *\/ 67, true);\n+    ASSERT_EQ(ret, 0);\n+    ASSERT_EQ(data[i], 121);\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int16_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+  if (UseZacas) {\n+    run_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n+  if (UseZacas) {\n+    run_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n+  }\n+}\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+class WeakCmpxchgTester {\n+ public:\n+  typedef TESTSIZE (*cmpxchg_narrow)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result,\n+                                   int64_t scratch0, int64_t scratch1, int64_t scratch2);\n+\n+  typedef TESTSIZE (*cmpxchg_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result);\n+\n+  static TESTSIZE weak_narrow_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value) {\n+    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(bb);\n+    MacroAssembler _masm(&code);\n+    address entry = _masm.pc();\n+    {\n+       _masm.weak_cmpxchg_narrow_value(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/ c_rarg2,\n+                                      ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                                      \/*result*\/ c_rarg3, c_rarg4, c_rarg5, c_rarg6); \/* Uses also t0-t1, caller saved *\/\n+      _masm.mv(c_rarg0, c_rarg3);\n+      _masm.ret();\n+    }\n+    _masm.flush(); \/\/ icache invalidate\n+    TESTSIZE ret = ((cmpxchg_narrow)entry)(addr, expected, new_value, \/*result*\/ 67, -1, -1, -1);\n+    BufferBlob::free(bb);\n+    return ret;\n+  }\n+\n+  static TESTSIZE weak_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value) {\n+    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(bb);\n+    MacroAssembler _masm(&code);\n+    address entry = _masm.pc();\n+    {\n+       _masm.weak_cmpxchg(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/ c_rarg2,\n+                          ASMSIZE, Assembler::relaxed, Assembler::relaxed, \/*result*\/ c_rarg3);\n+      _masm.mv(c_rarg0, c_rarg3);\n+      _masm.ret();\n+    }\n+    _masm.flush(); \/\/ icache invalidate\n+    TESTSIZE ret = ((cmpxchg_func)entry)(addr, expected, new_value, \/*result*\/ 67);\n+    BufferBlob::free(bb);\n+    return ret;\n+  }\n+};\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+void run_weak_cmpxchg_narrow_value_tests() {\n+  \/\/ Assume natural aligned\n+  TESTSIZE data[8];\n+  TESTSIZE ret;\n+  for (int i = 0; i < 7; i++) {\n+    memset(data, -1, sizeof(data));\n+\n+    data[i] = 121;\n+    ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_narrow_cmpxchg((intptr_t)&data[i], 121, 42);\n+    ASSERT_EQ(ret, 1);\n+    ASSERT_EQ(data[i], 42);\n+\n+    data[i] = 121;\n+    ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_narrow_cmpxchg((intptr_t)&data[i], 120, 42);\n+    ASSERT_EQ(ret, 0);\n+    ASSERT_EQ(data[i], 121);\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_weak_cmpxchg_narrow_value_tests<int16_t, Assembler::int16>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_weak_cmpxchg_narrow_value_tests<int8_t, Assembler::int8>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_maybe_zacas) {\n+  if (UseZacas) {\n+    run_weak_cmpxchg_narrow_value_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_maybe_zacas) {\n+  if (UseZacas) {\n+    run_weak_cmpxchg_narrow_value_tests<int8_t, Assembler::int8>();\n+  }\n+}\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+void run_weak_cmpxchg_tests() {\n+  TESTSIZE data = 121;\n+  TESTSIZE ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_cmpxchg((intptr_t)&data, 121, 42);\n+  ASSERT_EQ(ret, 1);\n+  ASSERT_EQ(data, 42);\n+\n+  data = 121;\n+  ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_cmpxchg((intptr_t)&data, 120, 42);\n+  ASSERT_EQ(ret, 0);\n+  ASSERT_EQ(data, 121);\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int64_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int64_maybe_zacas) {\n+  if (UseZacas) {\n+    run_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int32_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int32_maybe_zacas) {\n+  if (UseZacas) {\n+    run_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+  }\n+}\n+\n+#endif  \/\/ RISCV\n","filename":"test\/hotspot\/gtest\/riscv\/test_assembler_riscv.cpp","additions":473,"deletions":0,"binary":false,"changes":473,"status":"added"},{"patch":"@@ -96,1 +96,1 @@\n-    ReservedSpace rs(size);\n+    ReservedSpace rs(size, mtTest);\n@@ -170,1 +170,1 @@\n-    ReservedSpace rs(size);\n+    ReservedSpace rs(size, mtTest);\n@@ -257,1 +257,1 @@\n-    ReservedSpace rs(size);\n+    ReservedSpace rs(size, mtTest);\n@@ -428,1 +428,1 @@\n-    ReservedSpace rs(size);\n+    ReservedSpace rs(size, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+gc\/shenandoah\/oom\/TestAllocOutOfMemory.java#large 8344312 linux-ppc64le\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,5 +58,1 @@\n-  -runtime\/cds\/CheckSharingWithDefaultArchive.java \\\n-  -runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java \\\n-  -runtime\/cds\/appcds\/dynamicArchive\/DynamicSharedSymbols.java \\\n-  -runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java \\\n-  -runtime\/cds\/appcds\/jcmd\n+  -runtime\/cds\n@@ -400,0 +396,2 @@\n+ -runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java \\\n+ -runtime\/Monitor\/TestRecursiveLocking.java \\\n@@ -494,0 +492,1 @@\n+ -serviceability\/sa\/TestJhsdbJstackPrintVMLocks.java \\\n@@ -666,0 +665,1 @@\n+ -runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8345219\n+ * @summary Test that code generation for FP conversion works as intended\n+ * @library \/test\/lib \/\n+ * @requires os.arch != \"x86\" & os.arch != \"i386\"\n+ * @run driver compiler.c2.irTests.TestFPConversion\n+ *\/\n+public class TestFPConversion {\n+    static final double[] DOUBLES = new double[] {\n+            Double.NEGATIVE_INFINITY,\n+            -Double.MAX_VALUE,\n+            -1.0,\n+            -Double.MIN_VALUE,\n+            -0.0,\n+            0.0,\n+            Double.MIN_VALUE,\n+            1.0,\n+            Double.MAX_VALUE,\n+            Double.POSITIVE_INFINITY,\n+            Double.NaN,\n+    };\n+\n+    static final float[] FLOATS = new float[] {\n+            Float.NEGATIVE_INFINITY,\n+            -Float.MAX_VALUE,\n+            -1.0F,\n+            -Float.MIN_VALUE,\n+            -0.0F,\n+            0.0F,\n+            Float.MIN_VALUE,\n+            1.0F,\n+            Float.MAX_VALUE,\n+            Float.POSITIVE_INFINITY,\n+            Float.NaN,\n+    };\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOV_D2L, \"1\"})\n+    public long doubleToRawLongBits(double x) {\n+        return Double.doubleToRawLongBits(x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOV_D2L, \"1\"})\n+    public long doubleToLongBits(double x) {\n+        return Double.doubleToLongBits(x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOV_L2D, \"1\"})\n+    public double longBitsToDouble(long x) {\n+        return Double.longBitsToDouble(x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOV_F2I, \"1\"})\n+    public int floatToRawIntBits(float x) {\n+        return Float.floatToRawIntBits(x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOV_F2I, \"1\"})\n+    public int floatToIntBits(float x) {\n+        return Float.floatToIntBits(x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOV_I2F, \"1\"})\n+    public float intBitsToFloat(int x) {\n+        return Float.intBitsToFloat(x);\n+    }\n+\n+    @Run(test = {\"doubleToRawLongBits\", \"doubleToLongBits\", \"longBitsToDouble\",\n+                 \"floatToRawIntBits\", \"floatToIntBits\", \"intBitsToFloat\"})\n+    public void runTests() {\n+        for (int i = 0; i < DOUBLES.length; i++) {\n+            double d = DOUBLES[i];\n+            long l1 = doubleToRawLongBits(d);\n+            long l2 = doubleToLongBits(d);\n+            double d1 = longBitsToDouble(l1);\n+            double d2 = longBitsToDouble(l2);\n+            Asserts.assertEquals(d, d1);\n+            Asserts.assertEquals(d, d2);\n+        }\n+        for (int i = 0; i < FLOATS.length; i++) {\n+            float f = FLOATS[i];\n+            int i1 = floatToRawIntBits(f);\n+            int i2 = floatToIntBits(f);\n+            float f1 = intBitsToFloat(i1);\n+            float f2 = intBitsToFloat(i2);\n+            Asserts.assertEquals(f, f1);\n+            Asserts.assertEquals(f, f2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFPConversion.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16Conversion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestAllFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -257,0 +257,40 @@\n+    public static final String SATURATING_ADD_VB = VECTOR_PREFIX + \"SATURATING_ADD_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_ADD_VB, \"SaturatingAddV\", TYPE_BYTE);\n+    }\n+\n+    public static final String SATURATING_ADD_VS = VECTOR_PREFIX + \"SATURATING_ADD_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_ADD_VS, \"SaturatingAddV\", TYPE_SHORT);\n+    }\n+\n+    public static final String SATURATING_ADD_VI = VECTOR_PREFIX + \"SATURATING_ADD_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_ADD_VI, \"SaturatingAddV\", TYPE_INT);\n+    }\n+\n+    public static final String SATURATING_ADD_VL = VECTOR_PREFIX + \"SATURATING_ADD_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_ADD_VL, \"SaturatingAddV\", TYPE_LONG);\n+    }\n+\n+    public static final String SATURATING_SUB_VB = VECTOR_PREFIX + \"SATURATING_SUB_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_SUB_VB, \"SaturatingSubV\", TYPE_BYTE);\n+    }\n+\n+    public static final String SATURATING_SUB_VS = VECTOR_PREFIX + \"SATURATING_SUB_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_SUB_VS, \"SaturatingSubV\", TYPE_SHORT);\n+    }\n+\n+    public static final String SATURATING_SUB_VI = VECTOR_PREFIX + \"SATURATING_SUB_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_SUB_VI, \"SaturatingSubV\", TYPE_INT);\n+    }\n+\n+    public static final String SATURATING_SUB_VL = VECTOR_PREFIX + \"SATURATING_SUB_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SATURATING_SUB_VL, \"SaturatingSubV\", TYPE_LONG);\n+    }\n+\n@@ -1132,0 +1172,20 @@\n+    public static final String MOV_F2I = PREFIX + \"MOV_F2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOV_F2I, \"MoveF2I\");\n+    }\n+\n+    public static final String MOV_I2F = PREFIX + \"MOV_I2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOV_I2F, \"MoveI2F\");\n+    }\n+\n+    public static final String MOV_D2L = PREFIX + \"MOV_D2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOV_D2L, \"MoveD2L\");\n+    }\n+\n+    public static final String MOV_L2D = PREFIX + \"MOD_L2D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOV_L2D, \"MoveL2D\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,547 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8338021 8342677\n+* @summary Add IR validation tests for newly added saturated vector add \/ sub operations\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorSaturatedOperationsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+\n+public class VectorSaturatedOperationsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public void setup_delimiting_byte_inputs() {\n+        \/\/ Saturating add\n+        byte_in1[COUNT - 1] = Byte.MAX_VALUE;\n+        byte_in2[COUNT - 1] = 100;\n+        \/\/ Saturating sub\n+        byte_in1[COUNT - 2] = Byte.MIN_VALUE;\n+        byte_in2[COUNT - 2] = 100;\n+        \/\/ Saturating unsigned add\n+        byte_in1[COUNT - 3] = -1;\n+        byte_in2[COUNT - 3] = 100;\n+        \/\/ Saturating unsigned sub\n+        byte_in1[COUNT - 4] = 0;\n+        byte_in2[COUNT - 4] = 100;\n+    }\n+\n+    public void setup_delimiting_short_inputs() {\n+        \/\/ Saturating add\n+        short_in1[COUNT - 1] = Short.MAX_VALUE;\n+        short_in2[COUNT - 1] = 100;\n+        \/\/ Saturating sub\n+        short_in1[COUNT - 2] = Short.MIN_VALUE;\n+        short_in2[COUNT - 2] = 100;\n+        \/\/ Saturating unsigned add\n+        short_in1[COUNT - 3] = -1;\n+        short_in2[COUNT - 3] = 100;\n+        \/\/ Saturating unsigned sub\n+        short_in1[COUNT - 4] = 0;\n+        short_in2[COUNT - 4] = 100;\n+    }\n+\n+    public void setup_delimiting_int_inputs() {\n+        \/\/ Saturating add\n+        int_in1[COUNT - 1] = Integer.MAX_VALUE;\n+        int_in2[COUNT - 1] = 100;\n+        \/\/ Saturating sub\n+        int_in1[COUNT - 2] = Integer.MIN_VALUE;\n+        int_in2[COUNT - 2] = 100;\n+        \/\/ Saturating unsigned add\n+        int_in1[COUNT - 3] = -1;\n+        int_in2[COUNT - 3] = 100;\n+        \/\/ Saturating unsigned sub\n+        int_in1[COUNT - 4] = 0;\n+        int_in2[COUNT - 4] = 100;\n+    }\n+\n+    public void setup_delimiting_long_inputs() {\n+        \/\/ Saturating add\n+        long_in1[COUNT - 1] = Long.MAX_VALUE;\n+        long_in2[COUNT - 1] = 100;\n+        \/\/ Saturating sub\n+        long_in1[COUNT - 2] = Long.MIN_VALUE;\n+        long_in2[COUNT - 2] = 100;\n+        \/\/ Saturating unsigned add\n+        long_in1[COUNT - 3] =  -1L;\n+        long_in2[COUNT - 3] = 100;\n+        \/\/ Saturating unsigned sub\n+        long_in1[COUNT - 4] = 0;\n+        long_in2[COUNT - 4] = 100;\n+    }\n+\n+    public VectorSaturatedOperationsTest() {\n+        Random r = jdk.test.lib.Utils.getRandomInstance();\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT-4).forEach(\n+            i -> {\n+                long_in1[i] = r.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+                long_in2[i] = r.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+                int_in1[i] = r.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+                int_in2[i] = r.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+                short_in1[i] = (short)r.nextInt(Short.MIN_VALUE, Short.MAX_VALUE);\n+                short_in2[i] = (short)r.nextInt(Short.MIN_VALUE, Short.MAX_VALUE);\n+                byte_in1[i] = (byte)r.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+                byte_in2[i] = (byte)r.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+            }\n+        );\n+\n+        setup_delimiting_byte_inputs();\n+        setup_delimiting_short_inputs();\n+        setup_delimiting_int_inputs();\n+        setup_delimiting_long_inputs();\n+\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VB, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_byte\")\n+    public void sadd_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.addSaturating(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_short\")\n+    public void sadd_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.addSaturating(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_int\")\n+    public void sadd_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.addSaturating(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_long\")\n+    public void sadd_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.addSaturating(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_byte\")\n+    public void suadd_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.addSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_short\")\n+    public void suadd_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.addSaturatingUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_int\")\n+    public void suadd_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.addSaturatingUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_long\")\n+    public void suadd_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.addSaturatingUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VB, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_byte\")\n+    public void ssub_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.subSaturating(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_short\")\n+    public void ssub_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.subSaturating(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_int\")\n+    public void ssub_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.subSaturating(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_long\")\n+    public void ssub_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.subSaturating(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_byte\")\n+    public void susub_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.subSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_short\")\n+    public void susub_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.subSaturatingUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_int\")\n+    public void susub_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.subSaturatingUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_SUB_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"},\n+        phase = {CompilePhase.BEFORE_MATCHING},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_long\")\n+    public void susub_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.subSaturatingUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorSaturatedOperationsTest.java","additions":547,"deletions":0,"binary":false,"changes":547,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+*           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -97,0 +98,17 @@\n+*\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Make sure Shenandoah can recover from humongous allocation fragmentation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahTargetNumRegions=2048\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocHumongousFragment\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahTargetNumRegions=2048\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocHumongousFragment\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocHumongousFragment.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -102,0 +103,17 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocIntArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocIntArrays\n+ *\/\n+\n@@ -150,0 +168,2 @@\n+        \/\/ Each allocated int array is assumed to consume 16 bytes for alignment and header, plus\n+        \/\/  an average of 4 * the average number of elements in the array.\n@@ -153,0 +173,3 @@\n+        \/\/ Repeatedly, allocate an array of int having between 0 and 384K elements, until we have\n+        \/\/ allocated approximately TARGET_MB.  The largest allocated array consumes 384K*4 + 16, which is 1.5 M,\n+        \/\/ which is well below the heap size of 1g.\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocIntArrays.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -102,0 +103,29 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahOOMDuringEvacALot\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahAllocFailureALot\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocObjectArrays\n+ *\/\n+\n@@ -137,0 +167,5 @@\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjectArrays.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -96,0 +97,15 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocObjects\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -31,0 +32,7 @@\n+\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:TieredStopAtLevel=0 -Xmx16m TestArrayCopyCheckCast -XX:ShenandoahGCMode=generational\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestArrayCopyCheckCast.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,1 +30,1 @@\n- * @test\n+ * @test id=default\n@@ -36,0 +37,9 @@\n+\n+\/*\n+ * @test id=generational\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:TieredStopAtLevel=0 -Xmx16m TestArrayCopyStress\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestArrayCopyStress.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -65,0 +66,11 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -Dtarget=10000\n+ *      TestDynamicSoftMaxHeapSize\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -32,1 +33,11 @@\n- * @run driver\/timeout=480 TestEvilSyncBug\n+ * @run driver\/timeout=480 TestEvilSyncBug -XX:ShenandoahGCHeuristics=aggressive\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Tests for crash\/assert when attaching init thread during shutdown\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver\/timeout=480 TestEvilSyncBug -XX:ShenandoahGCMode=generational\n@@ -49,1 +60,1 @@\n-        if (args.length > 0) {\n+        if (\"test\".equals(args[0])) {\n@@ -52,0 +63,1 @@\n+            String options = args[0];\n@@ -64,1 +76,1 @@\n-                            \"-XX:ShenandoahGCHeuristics=aggressive\",\n+                            options,\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestEvilSyncBug.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -79,0 +80,18 @@\n+\/**\n+ * @test id=generational\n+ * @summary Test Shenandoah GC uses concurrent\/parallel threads correctly\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC\n+ *      -XX:ConcGCThreads=2 -XX:ParallelGCThreads=4\n+ *      -Dtarget=1000 -XX:ShenandoahGCMode=generational\n+ *      TestGCThreadGroups\n+ *\n+ * @run main\/othervm -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC\n+ *      -XX:-UseDynamicNumberOfGCThreads\n+ *      -Dtarget=1000 -XX:ShenandoahGCMode=generational\n+ *      TestGCThreadGroups\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestGCThreadGroups.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -66,0 +67,5 @@\n+ *      -XX:+UseShenandoahGC\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n+ *      TestHeapUncommit\n+ *\n+ * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n@@ -80,0 +86,13 @@\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestHeapUncommit\n@@ -82,1 +101,1 @@\n- *      -XX:+UseShenandoahGC\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n@@ -85,0 +104,4 @@\n+ *\n+ * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestHeapUncommit\n@@ -101,0 +124,1 @@\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n@@ -105,1 +129,0 @@\n- *      -XX:-UseTLAB -XX:+ShenandoahVerify\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHeapUncommit.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -75,0 +76,12 @@\n+\/*\n+ * @test id=generational\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/com.sun.tools.attach\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -Dtarget=10000\n+ *      TestJcmdHeapDump\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestJcmdHeapDump.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -37,0 +38,14 @@\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Shenandoah crashes with -XX:ObjectAlignmentInBytes=16\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.bits == \"64\"\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -Xint                   TestLargeObjectAlignment\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -XX:-TieredCompilation  TestLargeObjectAlignment\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -XX:TieredStopAtLevel=1 TestLargeObjectAlignment\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -XX:TieredStopAtLevel=4 TestLargeObjectAlignment\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLargeObjectAlignment.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -74,0 +75,10 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -Dtarget=10000\n+ *      TestLotsOfCycles\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLotsOfCycles.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -58,2 +59,3 @@\n-             {{\"satb\"},    {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n-             {{\"passive\"}, {\"passive\"}}\n+             {{\"satb\"},         {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n+             {{\"generational\"}, {\"adaptive\"}},\n+             {{\"passive\"},      {\"passive\"}}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestObjItrWithHeapDump.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that reference processing works with both parallel and non-parallel variants.\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g -Xms1g                              TestParallelRefprocSanity\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g -Xms1g  -XX:-ParallelRefProcEnabled TestParallelRefprocSanity\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g -Xms1g  -XX:+ParallelRefProcEnabled TestParallelRefprocSanity\n- *\/\n-\n-import java.lang.ref.*;\n-\n-public class TestParallelRefprocSanity {\n-\n-    static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n-\n-    static volatile Object sink;\n-\n-    public static void main(String[] args) throws Exception {\n-        long count = TARGET_MB * 1024 * 1024 \/ 32;\n-        for (long c = 0; c < count; c++) {\n-            sink = new WeakReference<Object>(new Object());\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestParallelRefprocSanity.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -48,2 +49,2 @@\n-        if (periodic && !output.getOutput().contains(\"Trigger: Time since last GC\")) {\n-            throw new AssertionError(msg + \": Should have periodic GC in logs\");\n+        if (periodic) {\n+            output.shouldContain(\"Trigger: Time since last GC\");\n@@ -51,2 +52,19 @@\n-        if (!periodic && output.getOutput().contains(\"Trigger: Time since last GC\")) {\n-            throw new AssertionError(msg + \": Should not have periodic GC in logs\");\n+        if (!periodic) {\n+            output.shouldNotContain(\"Trigger: Time since last GC\");\n+        }\n+    }\n+\n+    public static void testGenerational(boolean periodic, String... args) throws Exception {\n+        String[] cmds = Arrays.copyOf(args, args.length + 2);\n+        cmds[args.length] = TestPeriodicGC.class.getName();\n+        cmds[args.length + 1] = \"test\";\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        if (periodic) {\n+            output.shouldContain(\"Trigger (Young): Time since last GC\");\n+            output.shouldContain(\"Trigger (Old): Time since last GC\");\n+        } else {\n+            output.shouldNotContain(\"Trigger (Young): Time since last GC\");\n+            output.shouldNotContain(\"Trigger (Old): Time since last GC\");\n@@ -129,0 +147,20 @@\n+\n+        testGenerational(true,\n+                         \"-Xlog:gc\",\n+                         \"-XX:+UnlockDiagnosticVMOptions\",\n+                         \"-XX:+UnlockExperimentalVMOptions\",\n+                         \"-XX:+UseShenandoahGC\",\n+                         \"-XX:ShenandoahGCMode=generational\",\n+                         \"-XX:ShenandoahGuaranteedYoungGCInterval=1000\",\n+                         \"-XX:ShenandoahGuaranteedOldGCInterval=1500\"\n+        );\n+\n+        testGenerational(false,\n+                         \"-Xlog:gc\",\n+                         \"-XX:+UnlockDiagnosticVMOptions\",\n+                         \"-XX:+UnlockExperimentalVMOptions\",\n+                         \"-XX:+UseShenandoahGC\",\n+                         \"-XX:ShenandoahGCMode=generational\",\n+                         \"-XX:ShenandoahGuaranteedYoungGCInterval=0\",\n+                         \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n+        );\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestPeriodicGC.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,25 @@\n+\/* @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.shenandoah.TestReferenceRefersToShenandoah\n+ *\/\n+\n+\/* @test id=generational-100\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.base\n+ * @run main jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n+ *      gc.shenandoah.TestReferenceRefersToShenandoah\n+ *\/\n+\n@@ -102,1 +127,5 @@\n-                fail(\"object not promoted by full gc\");\n+                \/\/ This is just a warning, because failing would\n+                \/\/ be overspecifying for generational shenandoah,\n+                \/\/ which need not necessarily promote objects upon\n+                \/\/ a full GC.\n+                warn(\"object not promoted by full gc\");\n@@ -129,0 +158,4 @@\n+    private static void warn(String msg) {\n+        System.out.println(\"Warning: \" + msg);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceRefersToShenandoah.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,13 @@\n+\/* @test id=generational-100\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.base\n+ * @run main jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n+ *      gc.shenandoah.TestReferenceShortcutCycle\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceShortcutCycle.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,0 +45,15 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test that null references\/referents work fine\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestRefprocSanity\n+ *\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestRefprocSanity\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRefprocSanity.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -49,0 +50,9 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahRegionSampling\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestRegionSampling\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSampling.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=default-rotation\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+ShenandoahRegionSampling -XX:+ShenandoahRegionSampling\n+ *      -Xlog:gc+region=trace:region-snapshots-%p.log::filesize=100,filecount=3\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestRegionSamplingLogging\n+ *\/\n+\n+\/*\n+ * @test id=generational-rotation\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+ShenandoahRegionSampling -XX:+ShenandoahRegionSampling\n+ *      -Xlog:gc+region=trace:region-snapshots-%p.log::filesize=100,filecount=3\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestRegionSamplingLogging\n+ *\/\n+import java.io.File;\n+import java.util.Arrays;\n+\n+public class TestRegionSamplingLogging {\n+\n+    static final long TARGET_MB = Long.getLong(\"target\", 2_000); \/\/ 2 Gb allocation\n+\n+    static volatile Object sink;\n+\n+    public static void main(String[] args) throws Exception {\n+        long count = TARGET_MB * 1024 * 1024 \/ 16;\n+        for (long c = 0; c < count; c++) {\n+            sink = new Object();\n+        }\n+\n+        File directory = new File(\".\");\n+        File[] files = directory.listFiles((dir, name) -> name.startsWith(\"region-snapshots\") && name.endsWith(\".log\"));\n+        System.out.println(Arrays.toString(files));\n+        if (files == null || files.length == 0) {\n+            throw new IllegalStateException(\"Did not find expected snapshot log file.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSamplingLogging.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -101,0 +102,20 @@\n+\/*\n+ * @test id=generational\n+ * @key randomness\n+ * @summary Test that Shenandoah is able to work with(out) resizeable TLABs\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      -XX:+ResizeTLAB\n+ *      TestResizeTLAB\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      -XX:-ResizeTLAB\n+ *      TestResizeTLAB\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestResizeTLAB.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -86,0 +87,25 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can deal with retained objects\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestRetainObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n+ *      TestRetainObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n+ *      TestRetainObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestRetainObjects\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRetainObjects.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=rotation\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+ShenandoahRegionSampling\n+ *      -Xlog:gc+region=trace:region-snapshots-%p.log::filesize=100,filecount=3\n+ *      -XX:+UseShenandoahGC\n+ *      TestShenandoahRegionLogging\n+ *\/\n+import java.io.File;\n+\n+public class TestShenandoahRegionLogging {\n+    public static void main(String[] args) throws Exception {\n+        System.gc();\n+\n+        File directory = new File(\".\");\n+        File[] files = directory.listFiles((dir, name) -> name.startsWith(\"region-snapshots\"));\n+\n+        \/\/ Expect one or more log files when region logging is enabled\n+        if (files.length == 0) {\n+            throw new Error(\"Expected at least one log file for region sampling data.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestShenandoahRegionLogging.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -93,0 +94,22 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can deal with retained objects\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n+ *      TestSieveObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n+ *      TestSieveObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestSieveObjects\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -37,0 +38,11 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational         TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx64m TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx32m TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx16m TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx8m  TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx4m  TestSmallHeap\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSmallHeap.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -68,0 +69,14 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test Shenandoah string deduplication implementation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ *\n+ * @run main\/othervm -Xmx256m -Xlog:gc+stats -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:StringDeduplicationAgeThreshold=3\n+ *      TestStringDedup\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedup.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -45,0 +46,16 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test Shenandoah string deduplication implementation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ *\n+ * @run main\/othervm -Xmx1g -Xlog:gc+stats -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -DtargetStrings=3000000\n+ *      TestStringDedupStress\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedupStress.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -78,0 +79,16 @@\n+\/*\n+ * @test id=generational\n+ * @summary Check that Shenandoah cleans up interned strings\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ClassUnloadingWithConcurrentMark\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestStringInternCleanup\n+ *\n+ * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ClassUnloadingWithConcurrentMark\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestStringInternCleanup\n+ *\/\n+\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringInternCleanup.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -59,0 +60,5 @@\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestVerifyJCStress\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyJCStress.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -36,0 +37,10 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=0 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=1 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=2 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=3 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=4 TestVerifyLevels\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyLevels.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -37,0 +38,11 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test Shenandoah with different log levels\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=error   TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=warning TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=info    TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=debug   TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=trace   TestWithLogLevel\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWithLogLevel.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,1 +30,2 @@\n- * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC TestWrongArrayMember\n+ * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC                                   TestWrongArrayMember\n+ * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational TestWrongArrayMember\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWrongArrayMember.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -208,0 +209,88 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test clone barriers work correctly\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -Xint\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:-TieredCompilation\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:TieredStopAtLevel=4\n+ *                   TestClone\n+ *\/\n+\n+\/*\n+ * @test id=generational-verify\n+ * @summary Test clone barriers work correctly\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -Xint\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -XX:-TieredCompilation\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -XX:TieredStopAtLevel=4\n+ *                   TestClone\n+ *\/\n+\n+ \/*\n+  * @test id=generational-no-coops\n+  * @summary Test clone barriers work correctly\n+  * @requires vm.gc.Shenandoah\n+  * @requires vm.bits == \"64\"\n+  *\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -Xint\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:-TieredCompilation\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:TieredStopAtLevel=1\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:TieredStopAtLevel=4\n+  *                   TestClone\n+  *\/\n@@ -209,0 +298,36 @@\n+ \/*\n+  * @test id=generational-no-coops-verify\n+  * @summary Test clone barriers work correctly\n+  * @requires vm.gc.Shenandoah\n+  * @requires vm.bits == \"64\"\n+  *\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -Xint\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -XX:-TieredCompilation\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -XX:TieredStopAtLevel=1\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -XX:TieredStopAtLevel=4\n+  *                   TestClone\n+  *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestClone.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -56,0 +57,26 @@\n+\/*\n+ * @test id=generational\n+ * @summary Shenandoah reference CAS test\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational                                                 TestReferenceCAS\n+ * @run main\/othervm -Diters=100   -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xint                                           TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-TieredCompilation                          TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:TieredStopAtLevel=1                         TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:TieredStopAtLevel=4                         TestReferenceCAS\n+ *\/\n+\n+\/*\n+ * @test id=generational-no-coops\n+ * @summary Shenandoah reference CAS test\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops                          TestReferenceCAS\n+ * @run main\/othervm -Diters=100   -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -Xint                    TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -XX:-TieredCompilation   TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -XX:TieredStopAtLevel=1  TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -XX:TieredStopAtLevel=4  TestReferenceCAS\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestReferenceCAS.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import java.util.Random;\n+import java.util.HashMap;\n+\n+\/*\n+ *  To avoid the risk of false regressions identified by this test, the heap\n+ *  size is set artificially high.  Though this test is known to run reliably\n+ *  in 66 MB heap, the heap size for this test run is currently set to 256 MB.\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that card marking and remembered set scanning do not crash.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -Xms256m -Xmx256m\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:NewRatio=1 -XX:+UnlockExperimentalVMOptions\n+ *      -XX:ShenandoahGuaranteedGCInterval=3000\n+ *      -XX:-UseDynamicNumberOfGCThreads -XX:-ShenandoahPacing\n+ *      gc.shenandoah.generational.TestConcurrentEvac\n+ *\/\n+\n+public class TestConcurrentEvac {\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    private static final int RANDOM_SEED = 46;\n+\n+    \/\/ Smaller table will cause creation of more old-gen garbage\n+    \/\/ as previous entries in table are overwritten with new values.\n+    private static final int TABLE_SIZE = 53;\n+    private static final int MAX_STRING_LENGTH = 47;\n+    private static final int SENTENCE_LENGTH = 5;\n+\n+    private static Random random = new Random(RANDOM_SEED);\n+\n+    public static class Node {\n+\n+        private String name;\n+\n+        \/\/ Each Node instance holds an array containing all substrings of its name\n+\n+        \/\/ This array has entries from 0 .. (name.length() - 1).\n+        \/\/ numSubstrings[i] represents the number of substrings that\n+        \/\/ correspond to a name of length i+1.\n+        private static int [] numSubstrings;\n+\n+        static {\n+            \/\/ Initialize numSubstrings.\n+            \/\/ For a name of length N, there are\n+            \/\/  N substrings of length 1\n+            \/\/  N-1 substrings of length 2\n+            \/\/  N-2 substrings of length 3\n+            \/\/  ...\n+            \/\/  1 substring of length N\n+            \/\/ Note that:\n+            \/\/   numSubstrings[0] = 1\n+            \/\/   numSubstrings[1] = 3\n+            \/\/   numSubstrings[i] = (i + 1) + numSubstrings[i - 1]\n+            numSubstrings = new int[MAX_STRING_LENGTH];\n+            numSubstrings[0] = 1;\n+            for (int i = 1; i < MAX_STRING_LENGTH; i++) {\n+                numSubstrings[i] = (i + 1) + numSubstrings[i - 1];\n+            }\n+        }\n+\n+        private String [] substrings;\n+        private Node [] neighbors;\n+\n+        public Node(String name) {\n+            this.name = name;\n+            this.substrings = new String[numSubstrings[name.length() - 1]];\n+\n+            int index = 0;\n+            for (int substringLength = 1; substringLength <= name.length(); substringLength++) {\n+                for (int offset = 0; offset + substringLength <= name.length(); offset++) {\n+                    this.substrings[index++] = name.substring(offset, offset + substringLength);\n+                }\n+            }\n+        }\n+\n+        public String value() {\n+            return name;\n+        }\n+\n+        public String arbitrarySubstring() {\n+            int index = TestConcurrentEvac.randomUnsignedInt(substrings.length);\n+            return substrings[index];\n+        }\n+    }\n+\n+\n+    \/\/ Return random int between 1 and MAX_STRING_LENGTH inclusive\n+    static int randomStringLength() {\n+        return randomUnsignedInt(MAX_STRING_LENGTH - 1) + 1;\n+    }\n+\n+    static String randomCharacter() {\n+        int index = randomUnsignedInt(52);\n+        return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".substring(index, index + 1);\n+    }\n+\n+    static String randomString() {\n+        int length = randomStringLength();\n+        String result = new String(); \/\/ make the compiler work for this garbage...\n+        for (int i = 0; i < length; i++) {\n+            result += randomCharacter();\n+        }\n+        return result;\n+    }\n+\n+    static int randomUnsignedInt(int max) {\n+        return random.nextInt(max);\n+    }\n+\n+    static int randomIndex() {\n+        return randomUnsignedInt(TABLE_SIZE);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        HashMap<Integer, Node> table = new HashMap<Integer, Node>(TABLE_SIZE);\n+\n+        if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") || !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\")) {\n+            throw new IllegalStateException(\"Command-line options not honored!\");\n+        }\n+\n+        for (int count = java.lang.Integer.MAX_VALUE\/1024; count >= 0; count--) {\n+            int index = randomIndex();\n+            String name = randomString();\n+            table.put(index, new Node(name));\n+        }\n+\n+        String conclusion = \"\";\n+\n+        for (int i = 0; i < SENTENCE_LENGTH; i++) {\n+            Node node = table.get(randomIndex());\n+            if (node == null) {\n+                i--;\n+            } else {\n+                String s = node.arbitrarySubstring();\n+                conclusion += s;\n+                conclusion += \" \";\n+            }\n+        }\n+\n+        conclusion = conclusion.substring(0, conclusion.length() - 1);\n+\n+        System.out.println(\"Conclusion is [\" + conclusion + \"]\");\n+\n+        if (!conclusion.equals(\"HN TInkzoLSDFVJYM mQAirHXbbgCJmUWozx DeispxWF MYFKBh\")) {\n+            throw new IllegalStateException(\"Random sequence of words did not end well!\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestConcurrentEvac.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Test that growth of old-gen triggers old-gen marking\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestOldGrowthTriggers\n+ *\/\n+\n+import java.util.*;\n+import java.math.BigInteger;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestOldGrowthTriggers {\n+\n+    public static void makeOldAllocations() {\n+        \/\/ Expect most of the BigInteger entries placed into array to be promoted, and most will eventually become garbage within old\n+\n+        final int ArraySize = 512 * 1024;   \/\/ 512K entries\n+        final int BitsInBigInteger = 128;\n+        final int RefillIterations = 64;\n+        BigInteger array[] = new BigInteger[ArraySize];\n+        Random r = new Random(46);\n+\n+        for (int i = 0; i < ArraySize; i++) {\n+            array[i] = new BigInteger(BitsInBigInteger, r);\n+        }\n+\n+        for (int refillCount = 0; refillCount < RefillIterations; refillCount++) {\n+            \/\/ Each refill repopulates ArraySize randomly selected elements within array\n+            for (int i = 0; i < ArraySize; i++) {\n+                int replaceIndex = r.nextInt(ArraySize);\n+                int deriveIndex = r.nextInt(ArraySize);\n+                switch (i & 0x3) {\n+                    case 0:\n+                        \/\/ 50% chance of creating garbage\n+                        array[replaceIndex] = array[replaceIndex].max(array[deriveIndex]);\n+                        break;\n+                    case 1:\n+                        \/\/ 50% chance of creating garbage\n+                        array[replaceIndex] = array[replaceIndex].min(array[deriveIndex]);\n+                        break;\n+                    case 2:\n+                        \/\/ creates new old BigInteger, releases old BigInteger,\n+                        \/\/ may create ephemeral data while computing gcd\n+                        array[replaceIndex] = array[replaceIndex].gcd(array[deriveIndex]);\n+                        break;\n+                    case 3:\n+                        \/\/ creates new old BigInteger, releases old BigInteger\n+                        array[replaceIndex] = array[replaceIndex].multiply(array[deriveIndex]);\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void testOld(String... args) throws Exception {\n+        String[] cmds = Arrays.copyOf(args, args.length + 2);\n+        cmds[args.length] = TestOldGrowthTriggers.class.getName();\n+        cmds[args.length + 1] = \"test\";\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(cmds);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(\"Trigger (Old): Old has overgrown\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0 && args[0].equals(\"test\")) {\n+            makeOldAllocations();\n+            return;\n+        }\n+\n+        testOld(\"-Xlog:gc\",\n+                \"-Xms96m\",\n+                \"-Xmx96m\",\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:+UseShenandoahGC\",\n+                \"-XX:ShenandoahGCMode=generational\",\n+                \"-XX:ShenandoahGuaranteedYoungGCInterval=0\",\n+                \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestOldGrowthTriggers.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import java.util.Random;\n+\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that card marking and remembered set scanning do not crash.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.shenandoah.generational.TestSimpleGenerational\n+ *\/\n+public class TestSimpleGenerational {\n+    private static WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static final int RANDOM_SEED = 46;\n+    \/\/ Sequence of random numbers should end with same value\n+    private static final int EXPECTED_LAST_RANDOM = 136227050;\n+\n+\n+    public static class Node {\n+        private static final int NEIGHBOR_COUNT = 5;\n+        private static final int INT_ARRAY_SIZE = 8;\n+        private static final Random RANDOM = new Random(RANDOM_SEED);\n+\n+        private int val;\n+        private Object objectField;\n+\n+        \/\/ Each Node instance holds references to two \"private\" arrays.\n+        \/\/ One array holds raw seething bits (primitive integers) and the other\n+        \/\/ holds references.\n+\n+        private int[] intsField;\n+        private Node [] neighbors;\n+\n+        public Node(int val) {\n+            this.val = val;\n+            this.objectField = new Object();\n+            this.intsField = new int[INT_ARRAY_SIZE];\n+            this.intsField[0] = 0xca;\n+            this.intsField[1] = 0xfe;\n+            this.intsField[2] = 0xba;\n+            this.intsField[3] = 0xbe;\n+            this.intsField[4] = 0xba;\n+            this.intsField[5] = 0xad;\n+            this.intsField[6] = 0xba;\n+            this.intsField[7] = 0xbe;\n+\n+            this.neighbors = new Node[NEIGHBOR_COUNT];\n+        }\n+\n+        public int value() {\n+            return val;\n+        }\n+\n+        \/\/ Copy each neighbor of n into a new node's neighbor array.\n+        \/\/ Then overwrite arbitrarily selected neighbor with newly allocated\n+        \/\/ leaf node.\n+        public static Node upheaval(Node n) {\n+            int firstValue = RANDOM.nextInt(Integer.MAX_VALUE);\n+            Node result = new Node(firstValue);\n+            if (n != null) {\n+                for (int i = 0; i < NEIGHBOR_COUNT; i++) {\n+                    result.neighbors[i] = n.neighbors[i];\n+                }\n+            }\n+            int secondValue = RANDOM.nextInt(Integer.MAX_VALUE);\n+            int overwriteIndex = firstValue % NEIGHBOR_COUNT;\n+            result.neighbors[overwriteIndex] = new Node(secondValue);\n+            return result;\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        Node n = null;\n+\n+        if (!WB.getBooleanVMFlag(\"UseShenandoahGC\") || !WB.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\")) {\n+            throw new IllegalStateException(\"Command-line options not honored!\");\n+        }\n+\n+        for (int count = 10000; count > 0; count--) {\n+            n = Node.upheaval(n);\n+        }\n+\n+        System.out.println(\"Expected Last Random: [\" + n.value() + \"]\");\n+        if (n.value() != EXPECTED_LAST_RANDOM) {\n+            throw new IllegalStateException(\"Random number sequence ended badly!\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestSimpleGenerational.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -25,1 +26,1 @@\n-\/* @test\n+\/* @test id=default\n@@ -35,0 +36,10 @@\n+ \/* @test id=generational\n+  * @summary test JNI critical arrays support in Shenandoah\n+  * @key randomness\n+  * @requires vm.gc.Shenandoah\n+  * @library \/test\/lib\n+  *\n+  * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+ShenandoahVerify TestJNICritical\n+  * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational                       TestJNICritical\n+  *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNICritical.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,0 +45,19 @@\n+\/* @test id=generational-verify\n+ * @summary Test JNI Global Refs with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestJNIGlobalRefs\n+ *\/\n+\n+\/* @test id=generational\n+ * @summary Test JNI Global Refs with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestJNIGlobalRefs\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNIGlobalRefs.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -64,0 +65,16 @@\n+\/* @test id=generational\n+ * @summary Test that garbage in the pinned region does not crash VM\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestPinnedGarbage\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestPinnedGarbage\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestPinnedGarbage.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -66,0 +67,40 @@\n+\/**\n+ * @test id=generational\n+ * @summary Tests JVMTI heap dumps\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.jvmti\n+ * @compile TestHeapDump.java\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCMode=generational\n+ *      TestHeapDump\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=no-coops-generational\n+ * @summary Tests JVMTI heap dumps\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.jvmti\n+ * @requires vm.bits == \"64\"\n+ * @compile TestHeapDump.java\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:-UseCompressedOops TestHeapDump\n+ *\/\n+\n+\/**\n+ * @test id=generational-strdedup\n+ * @summary Tests JVMTI heap dumps\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.jvmti\n+ * @compile TestHeapDump.java\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:+UseStringDeduplication TestHeapDump\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jvmti\/TestHeapDump.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,1 +30,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -46,1 +47,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -58,1 +59,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -70,1 +71,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -82,1 +83,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -90,0 +91,12 @@\n+\/*\n+ * @test id=generational\n+ * @summary Check that MX notifications are reported for all cycles\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -Dprecise=false -Dmem.pool=Young\n+ *      TestChurnNotifications\n+ *\/\n+\n@@ -114,0 +127,2 @@\n+    private static final String POOL_NAME = \"Young\".equals(System.getProperty(\"mem.pool\")) ? \"Shenandoah Young Gen\" : \"Shenandoah\";\n+\n@@ -127,2 +142,2 @@\n-                    MemoryUsage before = mapBefore.get(\"Shenandoah\");\n-                    MemoryUsage after = mapAfter.get(\"Shenandoah\");\n+                    MemoryUsage before = mapBefore.get(POOL_NAME);\n+                    MemoryUsage after = mapAfter.get(POOL_NAME);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -38,0 +39,13 @@\n+\/**\n+ * @test id=generational\n+ * @summary Test JMX memory beans\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational          -Xmx1g TestMemoryMXBeans   -1 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms1g   -Xmx1g TestMemoryMXBeans 1024 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms128m -Xmx1g TestMemoryMXBeans  128 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms1g   -Xmx1g -XX:ShenandoahUncommitDelay=0 TestMemoryMXBeans 1024 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms128m -Xmx1g -XX:ShenandoahUncommitDelay=0 TestMemoryMXBeans  128 1024\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestMemoryMXBeans.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -34,0 +35,9 @@\n+\/**\n+ * @test id=generational\n+ * @summary Test JMX memory pools\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -Xms1g TestMemoryPools\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestMemoryPools.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -86,0 +87,11 @@\n+\/*\n+ * @test id=generational\n+ * @summary Check that MX notifications are reported for all cycles\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestPauseNotifications\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test allocation of small object to result OOM, but not to crash JVM\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @run driver TestAllocLargeObj\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestAllocLargeObj {\n-\n-    static final int SIZE = 1 * 1024 * 1024;\n-    static final int COUNT = 16;\n-\n-    static volatile Object sink;\n-\n-    public static void work() throws Exception {\n-        Object[] root = new Object[COUNT];\n-        sink = root;\n-        for (int c = 0; c < COUNT; c++) {\n-            root[c] = new Object[SIZE];\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0) {\n-            work();\n-            return;\n-        }\n-\n-        {\n-            OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx16m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargeObj.class.getName(),\n-                    \"test\");\n-\n-            analyzer.shouldHaveExitValue(1);\n-            analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-\n-        {\n-            OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx1g\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargeObj.class.getName(),\n-                    \"test\");\n-\n-            analyzer.shouldHaveExitValue(0);\n-            analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocLargeObj.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test that allocation of the object larger than heap fails predictably\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @run driver TestAllocLargerThanHeap\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestAllocLargerThanHeap {\n-\n-    static final int SIZE = 16 * 1024 * 1024;\n-\n-    static volatile Object sink;\n-\n-    public static void work() throws Exception {\n-        sink = new Object[SIZE];\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0) {\n-            work();\n-            return;\n-        }\n-\n-        {\n-            OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx16m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargerThanHeap.class.getName(),\n-                    \"test\");\n-\n-            analyzer.shouldHaveExitValue(1);\n-            analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-\n-        {\n-            OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx1g\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargerThanHeap.class.getName(),\n-                    \"test\");\n-\n-            analyzer.shouldHaveExitValue(0);\n-            analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocLargerThanHeap.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=large\n+ * @summary Test allocation of large objects results in OOM, but will not crash the JVM\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestAllocOutOfMemory large\n+ *\/\n+\n+\/**\n+ * @test id=heap\n+ * @summary Test allocation of a heap-sized object results in OOM, but will not crash the JVM\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestAllocOutOfMemory heap\n+ *\/\n+\n+\/**\n+ * @test id=small\n+ * @summary Test allocation of small objects results in OOM, but will not crash the JVM\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestAllocOutOfMemory small\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestAllocOutOfMemory {\n+\n+    static volatile Object sink;\n+\n+    public static void work(int size, int count) throws Exception {\n+        Object[] root = new Object[count];\n+        sink = root;\n+        for (int c = 0; c < count; c++) {\n+            root[c] = new Object[size];\n+        }\n+    }\n+\n+    private static void allocate(String size, int multiplier) throws Exception {\n+        switch (size) {\n+            case \"large\":\n+                work(1024 * 1024, 16 * multiplier);\n+                break;\n+            case \"heap\":\n+                work(16 * 1024 * 1024, multiplier);\n+                break;\n+            case \"small\":\n+                work(1, 16 * 1024 * 1024 * multiplier);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Usage: test [large|small|heap]\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 2) {\n+            \/\/ Called from test, size is second argument, heap requested is third\n+            String size = args[1];\n+            long spec_heap = Integer.parseInt(args[2]);\n+\n+            \/\/ The actual heap we get may be larger than the one we asked for\n+            \/\/ (particularly in the generational case)\n+            final long actual_heap = Runtime.getRuntime().maxMemory();\n+            int multiplier = 1;\n+            if (actual_heap > spec_heap) {\n+                \/\/ A suitable multiplier is used, so as to allocate an\n+                \/\/ amount appropriate to the larger actual heap size than what\n+                \/\/ was specified.\n+                multiplier = (int)((actual_heap + spec_heap - 1)\/spec_heap);\n+            }\n+\n+            allocate(size, multiplier);\n+            return;\n+        }\n+\n+        \/\/ Called from jtreg, size is first argument\n+        String size = args[0];\n+        {\n+            int heap = 16*1024*1024;      \/\/ -Xmx16m\n+            expectFailure(\"-Xmx16m\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+\n+            expectFailure(\"-Xmx16m\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\", \"-XX:ShenandoahGCMode=generational\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+        }\n+\n+        {\n+            int heap = 1*1024*1024*1024;  \/\/ -Xmx1g\n+            expectSuccess(\"-Xmx1g\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+\n+            expectSuccess(\"-Xmx1g\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\", \"-XX:ShenandoahGCMode=generational\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+        }\n+    }\n+\n+    private static void expectSuccess(String... args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n+    }\n+\n+    private static void expectFailure(String... args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(1);\n+        analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocOutOfMemory.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test allocation of small object to result OOM, but not to crash JVM\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @run driver TestAllocSmallObj\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestAllocSmallObj {\n-\n-    static final int COUNT = 16 * 1024 * 1024;\n-\n-    static volatile Object sink;\n-\n-    public static void work() throws Exception {\n-        Object[] root = new Object[COUNT];\n-        sink = root;\n-        for (int c = 0; c < COUNT; c++) {\n-            root[c] = new Object();\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0) {\n-            work();\n-            return;\n-        }\n-\n-        {\n-            OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx16m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocSmallObj.class.getName(),\n-                    \"test\");\n-\n-            analyzer.shouldHaveExitValue(1);\n-            analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-\n-        {\n-            OutputAnalyzer analyzer = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx1g\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocSmallObj.class.getName(),\n-                    \"test\");\n-\n-            analyzer.shouldHaveExitValue(0);\n-            analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocSmallObj.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -126,2 +127,3 @@\n-             {{\"satb\"},    {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n-             {{\"passive\"}, {\"passive\"}}\n+             {{\"satb\"},         {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n+             {{\"passive\"},      {\"passive\"}},\n+             {{\"generational\"}, {\"adaptive\"}}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestClassLoaderLeak.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -56,0 +57,5 @@\n+                \/\/ If we experience OutOfMemoryError during our attempt to instantiate NastyThread, we'll abort\n+                \/\/ main and will not print \"All good\".  We'll also report a non-zero termination code.  In the\n+                \/\/ case that the previously instantiated NastyThread accumulated more than SheanndoahNoProgressThreshold\n+                \/\/ unproductive GC cycles before failing, the main thread may not try a Full GC before it experiences\n+                \/\/ OutOfMemoryError exception.\n@@ -59,0 +65,3 @@\n+                \/\/ Having joined thread, we know the memory consumed by thread is now garbage, and will eventually be\n+                \/\/ collected.  Some or all of that memory may have been promoted, so we may need to perform a Full GC\n+                \/\/ in order to reclaim it quickly.\n@@ -76,0 +85,14 @@\n+\n+        {\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                    \"-Xmx32m\",\n+                    \"-XX:+UnlockExperimentalVMOptions\",\n+                    \"-XX:+UseShenandoahGC\", \"-XX:ShenandoahGCMode=generational\",\n+                    TestThreadFailure.class.getName(),\n+                    \"test\");\n+\n+            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+            analyzer.shouldHaveExitValue(0);\n+            analyzer.shouldContain(\"java.lang.OutOfMemoryError\");\n+            analyzer.shouldContain(\"All good\");\n+        }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -47,2 +48,3 @@\n-        testWith(\"-XX:ShenandoahGCMode=satb\",    Mode.PRODUCT);\n-        testWith(\"-XX:ShenandoahGCMode=passive\", Mode.DIAGNOSTIC);\n+        testWith(\"-XX:ShenandoahGCMode=satb\",         Mode.PRODUCT);\n+        testWith(\"-XX:ShenandoahGCMode=passive\",      Mode.DIAGNOSTIC);\n+        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.EXPERIMENTAL);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestModeUnlock.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+        String[] generational = {\n+                \"ShenandoahCardBarrier\"\n+        };\n+\n@@ -53,0 +57,3 @@\n+        shouldPassAll(\"-XX:ShenandoahGCMode=passive\",          generational);\n+        shouldPassAll(\"-XX:ShenandoahGCMode=satb\",             generational);\n+        shouldFailAll(\"-XX:ShenandoahGCMode=generational\",     generational);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierDisable.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,3 +40,4 @@\n-        String[] concurrent = {\n-                \"ShenandoahSATBBarrier\",\n-        };\n+        String[] concurrent = { \"ShenandoahSATBBarrier\" };\n+        String[] generational = { \"ShenandoahCardBarrier\" };\n+        String[] all = { \"ShenandoahSATBBarrier\", \"ShenandoahCardBarrier\" };\n+\n@@ -48,0 +49,3 @@\n+        shouldPassAll(\"-XX:ShenandoahGCMode=generational\",     all);\n+        shouldFailAll(\"-XX:ShenandoahGCMode=satb\",             generational);\n+        shouldFailAll(\"-XX:ShenandoahGCMode=passive\",          generational);\n@@ -81,1 +85,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierEnable.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -182,0 +183,37 @@\n+\/*\n+ * @test id=generational\n+ * @key stress\n+ * @library \/\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.flavor == \"server\" & !vm.emulatedClient\n+ * @summary Stress the Shenandoah GC by trying to make old objects more likely to be garbage than young objects.\n+ *\n+ * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+ *\n+ * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+ *\/\n+\n+ \/*\n+  * @test id=generational-deopt-nmethod\n+  * @key stress\n+  * @library \/\n+  * @requires vm.gc.Shenandoah\n+  * @requires vm.flavor == \"server\" & !vm.emulatedClient & vm.opt.ClassUnloading != false\n+  * @summary Stress Shenandoah GC with nmethod barrier forced deoptimization enabled.\n+  *\n+  * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+  *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n+  *      -XX:+ShenandoahVerify\n+  *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+  *\n+  * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+  *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n+  *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+  *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithShenandoah.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+* Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -105,0 +106,16 @@\n+\/*\n+ * @test id=generational\n+ * @key stress randomness\n+ * @library \/ \/test\/lib\n+ * @requires vm.gc.Shenandoah\n+ * @summary Stress the GC by trying to make old objects more likely to be garbage than young objects.\n+ *\n+ * @run main\/othervm\/timeout=600 -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n+ *\n+ * @run main\/othervm -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcold\/TestGCOldWithShenandoah.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -43,0 +44,17 @@\n+\n+\/*\n+ * @test id=generational\n+ * @key stress\n+ * @library \/\n+ * @requires vm.gc.Shenandoah\n+ * @summary Stress the Shenandoah GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n+ *\n+ * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.systemgc.TestSystemGCWithShenandoah 270\n+ *\n+ * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.stress.systemgc.TestSystemGCWithShenandoah 270\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceUtilsGtests.java","additions":0,"deletions":0,"binary":false,"changes":0,"status":"deleted"},{"patch":"@@ -66,1 +66,1 @@\n-        \/\/ we should have crashed with an internal error. We should definitly NOT have crashed with a segfault\n+        \/\/ we should have crashed with an internal error. We should definitely NOT have crashed with a segfault\n@@ -73,1 +73,1 @@\n-            Pattern[] pattern = new Pattern[] { Pattern.compile(\"Registers:\"), null };\n+            Pattern[] pattern = null;\n@@ -75,1 +75,1 @@\n-                pattern[1] = Pattern.compile(\"RAX=.*\");\n+                pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"RAX=.*\")};\n@@ -77,1 +77,1 @@\n-                pattern[1] = Pattern.compile(\"EAX=.*\");\n+                pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"EAX=.*\")};\n@@ -79,1 +79,9 @@\n-                pattern[1] = Pattern.compile(\"R0=.*\");\n+                pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"R0=.*\")};\n+            } else if (Platform.isS390x()) {\n+                pattern = new Pattern[] { Pattern.compile(\"General Purpose Registers:\"),\n+                                          Pattern.compile(\"^-{26}$\"),\n+                                          Pattern.compile(\"  r0  =.*\")};\n+            } else if (Platform.isPPC()) {\n+                pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"pc =.*\")};\n+            } else {\n+                pattern = new Pattern[] { Pattern.compile(\"Registers:\") };\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ShowRegistersOnAssertTest.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/ArrayBaseOffsets.java","additions":0,"deletions":0,"binary":false,"changes":0,"status":"deleted"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xint_outer_inner\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=Xint_alternate_AB\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n+\n+\/*\n+ * @test id=C1_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=C1_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n+\n+\/*\n+ * @test id=C2_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=C2_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,568 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xint_outer_inner\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=Xint_alternate_AB\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+\/*\n+ * @test id=C1_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=C1_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+\/*\n+ * @test id=C2_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=C2_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+public class TestRecursiveLocking {\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final int flagLockingMode = WB.getIntVMFlag(\"LockingMode\").intValue();\n+    static final int constLockStackCapacity = WB.getLockStackCapacity();\n+    static final int LM_MONITOR = 0;\n+    static final int LM_LEGACY = 1;\n+    static final int LM_LIGHTWEIGHT = 2;\n+    static final int def_mode = 2;\n+    static final int def_n_secs = 30;\n+    static final SyncThread syncThread = new SyncThread();\n+\n+    \/\/ This SynchronizedObject class and the OUTER followed by INNER testing\n+    \/\/ model is adapted from runtime\/lockStack\/TestLockStackCapacity.java.\n+    static class SynchronizedObject {\n+        private int counter;\n+\n+        synchronized void runInner(int depth, SynchronizedObject outer) {\n+            counter++;\n+\n+            \/\/ Legacy mode has no lock stack, i.e., there is no limit\n+            \/\/ on recursion, so for legacy mode we can't say that\n+            \/\/ \"outer\" must be inflated here, which we can say for all\n+            \/\/ the other locking modes.\n+            if (flagLockingMode != LM_LEGACY) {\n+                outer.assertInflated();\n+            }\n+\n+            \/\/ We haven't reached the stack lock capacity (recursion\n+            \/\/ level), so we shouldn't be inflated here. Except for\n+            \/\/ monitor mode, which is always inflated.\n+            if (flagLockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+            if (depth == 1) {\n+                return;\n+            } else {\n+                runInner(depth - 1, outer);\n+            }\n+            if (flagLockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+        }\n+\n+        synchronized void runOuter(int depth, SynchronizedObject inner) {\n+            counter++;\n+\n+            if (flagLockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+            if (depth == 1) {\n+                inner.runInner(constLockStackCapacity, this);\n+            } else {\n+                runOuter(depth - 1, inner);\n+            }\n+            if (flagLockingMode != LM_LEGACY) {\n+                assertInflated();\n+            }\n+        }\n+\n+        \/\/ This test nests x recursive locks of INNER, in x recursive\n+        \/\/ locks of OUTER. The number x is taken from the max number\n+        \/\/ of elements in the lock stack.\n+        public void runOuterInnerTest() {\n+            final SynchronizedObject OUTER = new SynchronizedObject();\n+            final SynchronizedObject INNER = new SynchronizedObject();\n+\n+            \/\/ Just checking since they are new objects:\n+            OUTER.assertNotInflated();\n+            INNER.assertNotInflated();\n+\n+            synchronized (OUTER) {\n+                OUTER.counter++;\n+\n+                if (flagLockingMode != LM_MONITOR) {\n+                    OUTER.assertNotInflated();\n+                }\n+                INNER.assertNotInflated();\n+                OUTER.runOuter(constLockStackCapacity - 1, INNER);\n+\n+                if (flagLockingMode != LM_LEGACY) {\n+                    OUTER.assertInflated();\n+                }\n+                if (flagLockingMode != LM_MONITOR) {\n+                    INNER.assertNotInflated();\n+                }\n+            }\n+\n+            \/\/ Verify that the nested monitors have been properly released:\n+            syncThread.verifyCanBeSynced(OUTER);\n+            syncThread.verifyCanBeSynced(INNER);\n+\n+            Asserts.assertEquals(OUTER.counter, constLockStackCapacity);\n+            Asserts.assertEquals(INNER.counter, constLockStackCapacity);\n+        }\n+\n+        synchronized void runA(int depth, SynchronizedObject B) {\n+            counter++;\n+\n+            if (flagLockingMode == LM_LIGHTWEIGHT) {\n+                \/\/ First time we lock A, A is the only one on the lock\n+                \/\/ stack.\n+                if (counter == 1) {\n+                    assertNotInflated();\n+                } else {\n+                    \/\/ Second time we want to lock A, the lock stack\n+                    \/\/ looks like this [A, B]. Lightweight locking\n+                    \/\/ doesn't allow interleaving ([A, B, A]), instead\n+                    \/\/ it inflates A and removes it from the lock\n+                    \/\/ stack. Which leaves us with only [B] on the\n+                    \/\/ lock stack. After more recursions it will grow\n+                    \/\/ to [B, B ... B].\n+                    assertInflated();\n+                }\n+            } else if (flagLockingMode == LM_MONITOR) {\n+                assertInflated();\n+            }\n+\n+            \/\/ Call runB() at the same depth as runA's depth:\n+            B.runB(depth, this);\n+        }\n+\n+        synchronized void runB(int depth, SynchronizedObject A) {\n+            counter++;\n+\n+            if (flagLockingMode != LM_MONITOR) {\n+                \/\/ Legacy tolerates endless recursions. While testing\n+                \/\/ lightweight we don't go deeper than the size of the\n+                \/\/ lock stack, which in this test case will be filled\n+                \/\/ with a number of B-elements. See comment in runA()\n+                \/\/ above for more info.\n+                assertNotInflated();\n+            } else {\n+                assertInflated();\n+            }\n+\n+            if (depth == 1) {\n+                \/\/ Reached LockStackCapacity in depth so we're done.\n+                return;\n+            } else {\n+                A.runA(depth - 1, this);\n+            }\n+        }\n+\n+        \/\/ This test alternates by locking A and B.\n+        public void runAlternateABTest() {\n+            final SynchronizedObject A = new SynchronizedObject();\n+            final SynchronizedObject B = new SynchronizedObject();\n+\n+            \/\/ Just checking since they are new objects:\n+            A.assertNotInflated();\n+            B.assertNotInflated();\n+\n+            A.runA(constLockStackCapacity, B);\n+\n+            \/\/ Verify that the nested monitors have been properly released:\n+            syncThread.verifyCanBeSynced(A);\n+            syncThread.verifyCanBeSynced(B);\n+\n+            Asserts.assertEquals(A.counter, constLockStackCapacity);\n+            Asserts.assertEquals(B.counter, constLockStackCapacity);\n+            if (flagLockingMode == LM_LEGACY) {\n+                A.assertNotInflated();\n+            }\n+            \/\/ Implied else: for LM_MONITOR or LM_LIGHTWEIGHT it can be\n+            \/\/ either inflated or not because A is not locked anymore\n+            \/\/ and subject to deflation.\n+\n+            if (flagLockingMode != LM_MONITOR) {\n+                B.assertNotInflated();\n+            }\n+        }\n+\n+        void assertNotInflated() {\n+            Asserts.assertFalse(WB.isMonitorInflated(this));\n+        }\n+\n+        void assertInflated() {\n+            Asserts.assertTrue(WB.isMonitorInflated(this));\n+        }\n+    }\n+\n+    static void usage() {\n+        System.err.println();\n+        System.err.println(\"Usage: java TestRecursiveLocking [n_secs]\");\n+        System.err.println(\"       java TestRecursiveLocking n_secs [mode]\");\n+        System.err.println();\n+        System.err.println(\"where:\");\n+        System.err.println(\"    n_secs  ::= > 0\");\n+        System.err.println(\"            Default n_secs is \" + def_n_secs + \".\");\n+        System.err.println(\"    mode    ::= 1 - outer and inner\");\n+        System.err.println(\"            ::= 2 - alternate A and B\");\n+        System.err.println(\"            Default mode is \" + def_mode + \".\");\n+        System.exit(1);\n+    }\n+\n+    public static void main(String... argv) throws Exception {\n+        int mode = def_mode;\n+        int n_secs = def_n_secs;\n+\n+        if (argv.length != 0 && argv.length != 1 && argv.length != 2) {\n+            usage();\n+        } else if (argv.length > 0) {\n+            try {\n+                n_secs = Integer.parseInt(argv[0]);\n+                if (n_secs <= 0) {\n+                    throw new NumberFormatException(\"Not > 0: '\" + argv[0]\n+                                                    + \"'\");\n+                }\n+            } catch (NumberFormatException nfe) {\n+                System.err.println();\n+                System.err.println(nfe);\n+                System.err.println(\"ERROR: '\" + argv[0]\n+                                   + \"': invalid n_secs value.\");\n+                usage();\n+            }\n+\n+            if (argv.length > 1) {\n+                try {\n+                    mode = Integer.parseInt(argv[1]);\n+                    if (mode != 1 && mode != 2) {\n+                        throw new NumberFormatException(\"Not 1 -> 2: '\"\n+                                                        + argv[1] + \"'\");\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println();\n+                    System.err.println(nfe);\n+                    System.err.println(\"ERROR: '\" + argv[1]\n+                                       + \"': invalid mode value.\");\n+                    usage();\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"INFO: LockingMode=\" + flagLockingMode);\n+        System.out.println(\"INFO: LockStackCapacity=\" + constLockStackCapacity);\n+        System.out.println(\"INFO: n_secs=\" + n_secs);\n+        System.out.println(\"INFO: mode=\" + mode);\n+\n+        long loopCount = 0;\n+        long endTime = System.currentTimeMillis() + n_secs * 1000;\n+\n+        syncThread.waitForStart();\n+\n+        while (System.currentTimeMillis() < endTime) {\n+            loopCount++;\n+            SynchronizedObject syncObj = new SynchronizedObject();\n+            switch (mode) {\n+            case 1:\n+                syncObj.runOuterInnerTest();\n+                break;\n+\n+            case 2:\n+                syncObj.runAlternateABTest();\n+                break;\n+\n+            default:\n+                throw new RuntimeException(\"bad mode parameter: \" + mode);\n+            }\n+        }\n+\n+        syncThread.setDone();\n+        try {\n+            syncThread.join();\n+        } catch (InterruptedException ie) {\n+            \/\/ This should not happen.\n+            ie.printStackTrace();\n+        }\n+\n+        System.out.println(\"INFO: main executed \" + loopCount + \" loops in \"\n+                           + n_secs + \" seconds.\");\n+    }\n+}\n+\n+class SyncThread extends Thread {\n+    static final boolean verbose = false;  \/\/ set to true for debugging\n+    private boolean done = false;\n+    private boolean haveWork = false;\n+    private Object obj;\n+    private Object waiter = new Object();\n+\n+    public void run() {\n+        if (verbose) System.out.println(\"SyncThread: running.\");\n+        synchronized (waiter) {\n+            \/\/ Let main know that we are running:\n+            if (verbose) System.out.println(\"SyncThread: notify main running.\");\n+            waiter.notify();\n+\n+            while (!done) {\n+                if (verbose) System.out.println(\"SyncThread: waiting.\");\n+                try {\n+                    waiter.wait();\n+                } catch (InterruptedException ie) {\n+                    \/\/ This should not happen.\n+                    ie.printStackTrace();\n+                }\n+                if (haveWork) {\n+                    if (verbose) System.out.println(\"SyncThread: working.\");\n+                    synchronized (obj) {\n+                    }\n+                    if (verbose) System.out.println(\"SyncThread: worked.\");\n+                    haveWork = false;\n+                    waiter.notify();\n+                    if (verbose) System.out.println(\"SyncThread: notified.\");\n+                }\n+                else if (verbose) {\n+                    System.out.println(\"SyncThread: notified without work.\");\n+                }\n+            }\n+        }\n+        if (verbose) System.out.println(\"SyncThread: exiting.\");\n+    }\n+\n+    public void setDone() {\n+        synchronized (waiter) {\n+            if (verbose) System.out.println(\"main: set done.\");\n+            done = true;\n+            waiter.notify();\n+        }\n+    }\n+\n+    public void verifyCanBeSynced(Object obj) {\n+        synchronized (waiter) {\n+            if (verbose) System.out.println(\"main: queueing up work.\");\n+            this.obj = obj;\n+            haveWork = true;\n+            if (verbose) System.out.println(\"main: notifying SyncThread.\");\n+            waiter.notify();\n+            if (verbose) System.out.println(\"main: waiting for SyncThread.\");\n+            while (haveWork) {\n+                try {\n+                    waiter.wait();\n+                } catch (InterruptedException ie) {\n+                    \/\/ This should not happen.\n+                    ie.printStackTrace();\n+                }\n+            }\n+            if (verbose) System.out.println(\"main: waited for SyncThread.\");\n+        }\n+    }\n+\n+    public void waitForStart() {\n+        synchronized (waiter) {\n+            this.start();\n+\n+            \/\/ Wait for SyncThread to actually get running:\n+            if (verbose) System.out.println(\"main: wait for SyncThread start.\");\n+            try {\n+                waiter.wait();\n+            } catch (InterruptedException ie) {\n+                \/\/ This should not happen.\n+                ie.printStackTrace();\n+            }\n+            if (verbose) System.out.println(\"main: waited for SyncThread start.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/TestRecursiveLocking.java","additions":568,"deletions":0,"binary":false,"changes":568,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+        \"-XX:+SegmentedCodeCache\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommandLineFlagCombo.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-            .assertAbnormalExit(\"Mismatched --add-modules module name(s)\",\n+            .assertAbnormalExit(\"Mismatched values for property jdk.module.addmods\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVMOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-          .shouldContain(\"Mismatched --add-modules module name(s).\")\n-          .shouldContain(\"dump time: jdk.jconsole runtime: jdk.incubator.vector\")\n+          .shouldContain(\"Mismatched values for property jdk.module.addmods\")\n+          .shouldContain(\"runtime jdk.incubator.vector dump time jdk.jconsole\")\n@@ -92,1 +92,1 @@\n-          .shouldContain(\"Module jdk.httpserver specified during dump time but not during runtime\")\n+          .shouldContain(\"jdk.httpserver specified during dump time but not during runtime\")\n@@ -112,1 +112,1 @@\n-          .shouldContain(\"--add-modules module name(s) specified during runtime but not found in archive: jdk.jconsole\")\n+          .shouldContain(\"jdk.jconsole specified during runtime but not during dump time\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/addmods\/AddmodsOption.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342089\n+ * @summary Test consistency of --enable-native-access option for CDS dump time and runtime\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver EnableNativeAccessCDS\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class EnableNativeAccessCDS {\n+    public static void main(String[] args) throws Exception {\n+        final String module0 = \"java.base\";\n+        final String module1 = \"jdk.httpserver\";\n+        final String disabledOptimizedModule = \"Disabling optimized module handling\";\n+        final String loggingOption = \"-Xlog:cds=debug\";\n+\n+        String archiveName = TestCommon.getNewArchiveName(\"native-access\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+\n+        \/\/ dump a base archive with --enable-native-access=java.base\n+        OutputAnalyzer oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"--enable-native-access\", module0,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ same module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--enable-native-access\", module0,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"use_full_module_graph = true\");\n+\n+        \/\/ different module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--enable-native-access\", module1,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Mismatched values for property jdk.module.enable.native.access: runtime jdk.httpserver dump time java.base\")\n+          .shouldContain(disabledOptimizedModule);\n+\n+        \/\/ no module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Mismatched values for property jdk.module.enable.native.access: java.base specified during dump time but not during runtime\")\n+          .shouldContain(disabledOptimizedModule);\n+\n+        \/\/ dump an archive without --enable-native-access option\n+        archiveName = TestCommon.getNewArchiveName(\"no-native-access-modules\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ run with --enable-native-access\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--enable-native-access\", module0,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Mismatched values for property jdk.module.enable.native.access: java.base specified during runtime but not during dump time\")\n+          .shouldContain(disabledOptimizedModule);\n+\n+        \/\/ dump an archive with multiple modules with native access\n+        archiveName = TestCommon.getNewArchiveName(\"multiple-native-access-modules\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"--enable-native-access\", module0 + \",\" + module1,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ same module specified during runtime but in a different order\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--enable-native-access\", module1 + \",\" + module0,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"use_full_module_graph = true\");\n+\n+        \/\/ same module specified during runtime but specifying --enable-native-access twice\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--enable-native-access\", module0,\n+            \"--enable-native-access\", module1,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"use_full_module_graph = true\");\n+\n+        \/\/ run with only one same module\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--enable-native-access\", module0,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Mismatched values for property jdk.module.enable.native.access: runtime java.base dump time java.base,jdk.httpserver\")\n+          .shouldContain(disabledOptimizedModule);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/module\/EnableNativeAccessCDS.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-          .shouldContain(\"Mismatched modules: runtime jdk.compiler dump time jdk.httpserver\")\n+          .shouldContain(\"Mismatched values for property jdk.module.main: runtime jdk.compiler dump time jdk.httpserver\")\n@@ -81,1 +81,1 @@\n-          .shouldContain(\"Module jdk.httpserver specified during dump time but not during runtime\")\n+          .shouldContain(\"Mismatched values for property jdk.module.main: jdk.httpserver specified during dump time but not during runtime\")\n@@ -99,1 +99,1 @@\n-          .shouldContain(\"Module jdk.httpserver specified during runtime but not during dump time\")\n+          .shouldContain(\"Mismatched values for property jdk.module.main: jdk.httpserver specified during runtime but not during dump time\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/module\/ModuleOption.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-                    System.out.println(Class.forName(\\\"Foo\\\"));\n-                    System.out.println(Class.forName(\\\"Bar\\\"));\n+                    System.out.println(Class.forName(\"pkg1.Foo\"));\n+                    System.out.println(Class.forName(\"pkg2.Bar\"));\n@@ -62,0 +62,1 @@\n+            package pkg1;\n@@ -73,0 +74,1 @@\n+            package pkg1;\n@@ -84,0 +86,1 @@\n+            package pkg2;\n@@ -110,1 +113,0 @@\n-     * Bar.class\n@@ -112,0 +114,2 @@\n+     * pkg2\/\n+     * pkg2\/Bar.class\n@@ -113,2 +117,4 @@\n-     * META-INF\/versions\/9\/Bar.class\n-     * META-INF\/versions\/9\/Foo.class\n+     * META-INF\/versions\/9\/pkg1\n+     * META-INF\/versions\/9\/pkg1\/Foo.class\n+     * META-INF\/versions\/9\/pkg2\n+     * META-INF\/versions\/9\/pkg2\/Bar.class\n@@ -116,1 +122,2 @@\n-     * META-INF\/versions\/24\/Foo.class\n+     * META-INF\/versions\/24\/pkg1\n+     * META-INF\/versions\/24\/pkg1Foo.class\n@@ -166,1 +173,1 @@\n-        String appClasses[] = {\"Foo\", \"Bar\"};\n+        String appClasses[] = {\"pkg1\/Foo\", \"pkg2\/Bar\"};\n@@ -172,1 +179,1 @@\n-        String agentCmdArg = \"-agentlib:SimpleClassFileLoadHook=Foo,Hello,HELLO\";\n+        String agentCmdArg = \"-agentlib:SimpleClassFileLoadHook=pkg1\/Foo,Hello,HELLO\";\n@@ -178,1 +185,1 @@\n-        output.shouldMatch(\".*Foo.source:.*multi-version.jar\")\n+        output.shouldMatch(\".*pkg1.Foo.source:.*multi-version.jar\")\n@@ -181,1 +188,1 @@\n-              .shouldContain(\"class Foo\") \/\/ output from Main\n+              .shouldContain(\"class pkg1.Foo\") \/\/ output from Main\n@@ -185,1 +192,1 @@\n-              .shouldContain(\"class Bar\"); \/\/ output from Main\n+              .shouldContain(\"class pkg2.Bar\"); \/\/ output from Main\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/CFLH\/MultiReleaseJars.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+\n+\/\/ Compiled from this source, but we want the version to be 49.0 to use the old verifier.\n+\n+class OldClassWithStaticString {\n+    static final String s = \"xxxx123yyyy456\";\n+    static final String t = \"OldClassWithStaticString\";\n+}\n+\n+*\/\n+\n+public super class OldClassWithStaticString\n+    version 49:0\n+{\n+    public static final Field s:\"Ljava\/lang\/String;\" = String \"xxxx123yyyy456\";\n+    public static final Field t:\"Ljava\/lang\/String;\" = String \"OldClassWithStaticString\";\n+\n+    Method \"<init>\":\"()V\"\n+        stack 1 locals 1\n+    {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/OldClassWithStaticString.jasm","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8344904\n+ * @summary make sure all interned strings in old classes are archived.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build OldClassWithStaticString\n+ * @build StaticStringInOldClass\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ *                 -jar StaticStringInOldClass.jar StaticStringInOldClass StaticStringInOldClassApp OldClassWithStaticString\n+ * @run driver StaticStringInOldClass\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class StaticStringInOldClass {\n+    static final String appClass = StaticStringInOldClassApp.class.getName();\n+    static String[] classes = {\n+        appClass,\n+        OldClassWithStaticString.class.getName(),\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"StaticStringInOldClass.jar\");\n+        OutputAnalyzer output;\n+        output = TestCommon.testDump(appJar, TestCommon.list(classes));\n+        output = TestCommon.exec(appJar, appClass);\n+        TestCommon.checkExec(output, \"Hello\");\n+    }\n+}\n+\n+class StaticStringInOldClassApp {\n+    static String a = \"xxxx123\";\n+    public static void main(String args[]) throws Exception {\n+        System.out.println(\"Hello\");\n+        String x = (a + \"yyyy456\").intern();\n+        Class c = OldClassWithStaticString.class;\n+        Field f = c.getField(\"s\");\n+        String y = (String)(f.get(null));\n+        if (x != y) {\n+            throw new RuntimeException(\"Interned strings not equal: \" +\n+                                       \"\\\"\" + x + \"\\\" @ \" + System.identityHashCode(x) + \" vs \" +\n+                                       \"\\\"\" + y + \"\\\" @ \" + System.identityHashCode(y));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/StaticStringInOldClass.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337199\n+ * @summary Basic test for jcmd Thread.vthread_scheduler and Thread.vthread_pollers\n+ * @requires vm.continuations\n+ * @modules jdk.jcmd\n+ * @library \/test\/lib\n+ * @run junit\/othervm VThreadCommandsTest\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.lang.management.ManagementFactory;\n+import jdk.management.VirtualThreadSchedulerMXBean;\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class VThreadCommandsTest {\n+\n+    \/**\n+     * Thread.vthread_scheduler\n+     *\/\n+    @Test\n+    void testVThreadScheduler() {\n+        \/\/ ensure default scheduler and timeout schedulers are initialized\n+        Thread.startVirtualThread(() -> { });\n+\n+        jcmd(\"Thread.vthread_scheduler\")\n+                .shouldContain(Objects.toIdentityString(defaultScheduler()))\n+                .shouldContain(\"Delayed task schedulers:\")\n+                .shouldContain(\"[0] \" + ScheduledThreadPoolExecutor.class.getName());\n+    }\n+\n+    \/**\n+     * Thread.vthread_pollers\n+     *\/\n+    @Test\n+    void testVThreadPollers() throws Exception {\n+        \/\/ do blocking I\/O op on a virtual thread to ensure poller mechanism is initialized\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            executor.submit(() -> {\n+                try (var listener = new ServerSocket()) {\n+                    InetAddress lb = InetAddress.getLoopbackAddress();\n+                    listener.bind(new InetSocketAddress(lb, 0));\n+                    listener.setSoTimeout(200);\n+                    try (Socket s = listener.accept()) {\n+                        System.err.format(\"Connection from %s ??%n\", s.getRemoteSocketAddress());\n+                    } catch (SocketTimeoutException e) {\n+                        \/\/ expected\n+                    }\n+                }\n+                return null;\n+            }).get();\n+        }\n+\n+        jcmd(\"Thread.vthread_pollers\")\n+                .shouldContain(\"Read I\/O pollers:\")\n+                .shouldContain(\"Write I\/O pollers:\")\n+                .shouldMatch(\"^\\\\[0\\\\] sun\\\\.nio\\\\.ch\\\\..+ \\\\[registered = [\\\\d]+, owner = .+\\\\]$\");\n+    }\n+\n+    private OutputAnalyzer jcmd(String cmd) {\n+        return new PidJcmdExecutor().execute(cmd);\n+    }\n+\n+    \/**\n+     * Returns the virtual thread default scheduler. This implementation works by finding\n+     * all FJ worker threads and mapping them to their pool. VirtualThreadSchedulerMXBean\n+     * is used to temporarily changing target parallelism to an \"unique\" value, make it\n+     * possbile to find the right pool.\n+     *\/\n+    private ForkJoinPool defaultScheduler() {\n+        var done = new AtomicBoolean();\n+        Thread vthread = Thread.startVirtualThread(() -> {\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        var bean = ManagementFactory.getPlatformMXBean(VirtualThreadSchedulerMXBean.class);\n+        int parallelism = bean.getParallelism();\n+        try {\n+            bean.setParallelism(133);\n+            return Thread.getAllStackTraces()\n+                    .keySet()\n+                    .stream()\n+                    .filter(ForkJoinWorkerThread.class::isInstance)\n+                    .map(t -> ((ForkJoinWorkerThread) t).getPool())\n+                    .filter(p -> p.getParallelism() == 133)\n+                    .findAny()\n+                    .orElseThrow();\n+        } finally {\n+            bean.setParallelism(parallelism);\n+            done.set(true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/VThreadCommandsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -354,1 +354,1 @@\n-  \/\/ enable VM_INIT event notification mode\n+  \/\/ enable VM_INIT\/VM_DEATH event notification modes\n@@ -357,1 +357,7 @@\n-    LOG1(\"Agent_OnLoad: Error in JVMTI SetEventNotificationMode: %d\\n\", err);\n+    LOG1(\"Agent_OnLoad: Error in JVMTI SetEventNotificationMode(JVMTI_EVENT_VM_INIT): %d\\n\", err);\n+    failed = true;\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG1(\"Agent_OnLoad: Error in JVMTI SetEventNotificationMode(JVMTI_EVENT_VM_DEATH): %d\\n\", err);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HiddenClass\/libHiddenClassSigTest.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -111,0 +111,4 @@\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/libVMObjectAlloc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-                log.display(\"TEST #5: Caught expected exception while in loop: \" + t);\n+                log.display(\"TEST #5: Caught expected exception while in sleep: \" + t);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/stop\/stop002t.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+                return;\n@@ -126,0 +127,3 @@\n+        if (env->ExceptionCheck()) {\n+          return;\n+        }\n@@ -127,1 +131,1 @@\n-        \/\/ wait till JNI local reference can be released (it will heppen then we will leave the method)\n+        \/\/ wait till JNI local reference can be released (it will happen then we will leave the method)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jni\/JNIreferences.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,4 @@\n+        if (env->ExceptionOccurred()) {\n+                env->ExceptionDescribe();\n+                env->FatalError(\"ERROR: Failed to log message.\");\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/libNativeMethodsTestThread.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+                return;\n@@ -81,0 +82,3 @@\n+        if (env->ExceptionOccurred()) {\n+                return;\n+        }\n@@ -88,0 +92,3 @@\n+        if (env->ExceptionOccurred()) {\n+                return;\n+        }\n@@ -95,0 +102,3 @@\n+        if (env->ExceptionOccurred()) {\n+                return;\n+        }\n@@ -103,0 +113,3 @@\n+        if (env->ExceptionOccurred()) {\n+                return;\n+        }\n@@ -105,0 +118,3 @@\n+        if (env->ExceptionOccurred()) {\n+                return;\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/locks\/JNIMonitorLocker.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import org.testng.Assert;\n@@ -63,0 +64,3 @@\n+    public static final String CLS_DIR = System.getProperty(\"test.classes\");\n+    public static final String SRC_DIR = System.getProperty(\"test.src\");\n+    public static final boolean isWindows = System.getProperty(\"os.name\").contains(\"Windows\");\n@@ -376,0 +380,28 @@\n+    \/**\n+     * Asserts the run does not cause a Throwable. May be replaced with JUnit 5.\n+     * @param runnable the runnable\n+     * @param message the message if the test fails\n+     *\/\n+    public static void assertDoesNotThrow(Assert.ThrowingRunnable runnable, String message) {\n+        try {\n+            runnable.run();\n+        } catch (Throwable t) {\n+            Assert.fail(message + \"\\n Exception thrown: \" + t.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * Returns the System identifier (URI) of the source.\n+     * @param path the path to the source\n+     * @return the System identifier\n+     *\/\n+    public static String getSystemId(String path) {\n+        if (path == null) return null;\n+        String xmlSysId = \"file:\/\/\" + path;\n+        if (isWindows) {\n+            path = path.replace('\\\\', '\/');\n+            xmlSysId = \"file:\/\/\/\" + path;\n+        }\n+        return xmlSysId;\n+    }\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/libs\/jaxp\/library\/JAXPTestUtilities.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * @bug 8158084 8162438 8162442 8163535 8166220\n+ * @bug 8158084 8162438 8162442 8163535 8166220 8344800\n@@ -237,1 +237,1 @@\n-            {false, true, xml_catalog, xsd_xmlSchema, null},\n+            {false, true, xml_catalog, xsd_val_test_dtd, null},\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/CatalogSupport2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * @bug 8158084 8162438 8162442 8163535 8166220\n+ * @bug 8158084 8162438 8162442 8163535 8166220 8344800\n@@ -239,1 +239,1 @@\n-            {true, false, xml_catalog, xsd_xmlSchema, null},\n+            {true, false, xml_catalog, xsd_val_test_dtd, null},\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/CatalogSupport3.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-    String xml_val_test, xml_val_test_id, xsd_val_test;\n+    String xml_val_test, xml_val_test_id, xsd_val_test, xsd_val_test_dtd;\n@@ -257,0 +257,1 @@\n+        xsd_val_test_dtd = Paths.get(filepath + \"val_test_dtd.xsd\").toUri().toASCIIString();\n@@ -378,1 +379,5 @@\n-        Schema schema = factory.newSchema(new StreamSource(new StringReader(xsd)));\n+        if (xsd.endsWith(\".xsd\")) {\n+            Schema schema = factory.newSchema(new StreamSource(xsd));\n+        } else {\n+            Schema schema = factory.newSchema(new StreamSource(new StringReader(xsd)));\n+        }\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/CatalogSupportBase.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\"?>\n+<!DOCTYPE  xsd:schema  PUBLIC  \"-\/\/OPENJDK\/\/XML CATALOG DTD\/\/USECATALOG\"  \n+     \"http:\/\/openjdk_java_net\/xml\/catalog\/dtd\/usecatalogtest.dtd\">\n+\n+<xsd:schema xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+             targetNamespace=\"test\">\n+     <xsd:element name=\"root\">\n+         <xsd:complexType>\n+             <xsd:sequence>\n+                 <xsd:element name=\"child\" type=\"xsd:anyType\"\/>\n+             <\/xsd:sequence>\n+         <\/xsd:complexType>\n+\n+         <xsd:key name=\"key1\">\n+             <xsd:selector xpath=\".\"\/>\n+             <xsd:field xpath=\"child\"\/>\n+         <\/xsd:key>\n+     <\/xsd:element>\n+<\/xsd:schema>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/val_test_dtd.xsd","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -105,1 +105,1 @@\n-        {\"true\", \"false\", \"continue\", \"allow\", \"2500\", \"100000\",\n+        {\"false\", \"false\", \"continue\", \"allow\", \"2500\", \"100000\",\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/ImplProperties.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.jdkcatalog;\n+\n+import java.io.StringReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Collectors;\n+import javax.xml.XMLConstants;\n+import javax.xml.catalog.CatalogFeatures;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.sax.SAXSource;\n+import javax.xml.validation.SchemaFactory;\n+import javax.xml.validation.Validator;\n+import org.testng.Assert;\n+import org.testng.Assert.ThrowingRunnable;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+\/*\n+ * @test\n+ * @bug 8344800 8345353\n+ * @run testng\/othervm common.jdkcatalog.JDKCatalogTest\n+ * @summary Verifies the W3C DTDs and XSDs in the JDK built-in catalog.\n+ *\/\n+public class JDKCatalogTest {\n+    static String CLS_DIR = System.getProperty(\"test.classes\");\n+    static String SRC_DIR = System.getProperty(\"test.src\");\n+    public static boolean isWindows = false;\n+    static {\n+        if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n+            isWindows = true;\n+        }\n+    };\n+    public static final String JDKCATALOG_RESOLVE = \"jdk.xml.jdkcatalog.resolve\";\n+    static final String PUBLIC_ID = \"{{publicId}}\";\n+    static final String SYSTEM_ID = \"{{systemId}}\";\n+    static final String XSD_LOCATION = \"{{SCHEMA_LOCATION}}\";\n+    static final String TARGET_NAMESPACE = \"{{targetNamespace}}\";\n+    static final String ROOT_ELEMENT = \"{{rootElement}}\";\n+\n+    \/*\n+     * DataProvider: for verifying DTDs in the JDKCatalog\n+     * Data provided: see test testExternalDTD\n+     *\/\n+    @DataProvider(name = \"externalDTD\")\n+    public Object[][] getDTD() throws Exception {\n+        return new Object[][]{\n+            \/\/ verifies the test method correctly throws an exception if the specified\n+            \/\/ DTD can not be resolved\n+            {\"-\/\/ORG\/\/DTD FOO 200102\/\/EN\", \"http:\/\/foo.org\/2001\/bar.dtd\", SAXException.class},\n+            \/\/ this test also verifies datatypes.dtd as it's referenced in XMLSchema.dtd\n+            {\"-\/\/W3C\/\/DTD XMLSCHEMA 200102\/\/EN\", \"http:\/\/www.w3.org\/2001\/XMLSchema.dtd\", null},\n+            {\"-\/\/W3C\/\/DTD XHTML 1.0 Frameset\/\/EN\", \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-frameset.dtd\", null},\n+            {\"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\", \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-strict.dtd\", null},\n+            {\"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\", \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\", null},\n+            {\"-\/\/W3C\/\/DTD XHTML 1.1\/\/EN\", \"http:\/\/www.w3.org\/TR\/xhtml11\/DTD\/xhtml11.dtd\", null},\n+            {\"-\/\/W3C\/\/DTD Specification V2.10\/\/EN\", \"http:\/\/www.w3.org\/2002\/xmlspec\/dtd\/2.10\/xmlspec.dtd\", null},\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: for verifying XSDs in the JDKCatalog\n+     * Data provided: see test testXSD\n+     *\/\n+    @DataProvider(name = \"getXSD\")\n+    public Object[][] getXSD() throws Exception {\n+        return new Object[][]{\n+            \/\/ verifies the test method correctly throws an exception if the specified\n+            \/\/ XSD can not be resolved\n+            {\"xsdtest.xml\", \"http:\/\/foo.org\/2001\/bar.xsd\", \"http:\/\/foo.org\/2001\/bar\", \"root\", null, SAXException.class},\n+            \/\/ application XSD is resolved by a custom catalog, the W3C XSD then by the JDKCatalog\n+            {\"testXML.xml\", \"http:\/\/www.w3.org\/2001\/xml.xsd\", \"http:\/\/www.w3.org\/XML\/1998\/namespace\", \"testXMLXSD\", \"TestCatalog.xml\", null},\n+            \/\/ this test also verifies XMLSchema.dtd and xml.xsd as they are referenced\n+            {\"testXMLSchema.xml\", \"http:\/\/www.w3.org\/2001\/XMLSchema.xsd\", \"http:\/\/www.w3.org\/2001\/XMLSchema\", \"xs:schema\", null, null},\n+            {\"testDatatypes.xml\", \"http:\/\/www.w3.org\/2009\/XMLSchema\/XMLSchema-datatypes.xsd\", \"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\", \"testDatatypes\", \"TestCatalog.xml\", null},\n+            {\"xhtml-frameset.xml\", \"https:\/\/www.w3.org\/2002\/08\/xhtml\/xhtml1-frameset.xsd\", \"http:\/\/www.w3.org\/1999\/xhtml\", \"html\", null, null},\n+            {\"xhtml.xml\", \"https:\/\/www.w3.org\/2002\/08\/xhtml\/xhtml1-strict.xsd\", \"http:\/\/www.w3.org\/1999\/xhtml\", \"html\", null, null},\n+            {\"xhtml.xml\", \"https:\/\/www.w3.org\/2002\/08\/xhtml\/xhtml1-transitional.xsd\", \"http:\/\/www.w3.org\/1999\/xhtml\", \"html\", null, null},\n+            {\"xhtml.xml\", \"http:\/\/www.w3.org\/MarkUp\/SCHEMA\/xhtml11.xsd\", \"http:\/\/www.w3.org\/1999\/xhtml\", \"html\", null, null},\n+        };\n+    }\n+\n+    \/**\n+     * Verifies that references to the W3C DTDs are resolved by the JDK built-in\n+     * catalog.\n+     * @param publicId the PUBLIC identifier\n+     * @param systemId the SYSTEM identifier\n+     * @param expectedThrow the expected throw if the specified DTD can not be\n+     *                      resolved.\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"externalDTD\")\n+    public void testExternalDTD(String publicId, String systemId, Class<Throwable> expectedThrow)\n+            throws Exception {\n+        final String xmlString = generateXMLWithDTDRef(publicId, systemId);\n+\n+        if (expectedThrow == null) {\n+            assertDoesNotThrow(() -> parseWithResolveStrict(xmlString),\n+                    \"JDKCatalog shall resolve \" + systemId + \" but exception is thrown.\");\n+        } else {\n+            Assert.assertThrows(expectedThrow,\n+                () -> parseWithResolveStrict(xmlString));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that references to the W3C DTDs are resolved by the JDK built-in\n+     * catalog.\n+     * @param xmlTemplate a template used to generate an XML instance\n+     * @param xsdLocation the XSD to be resolved\n+     * @param targetNS the target namespace\n+     * @param rootElement the root element\n+     * @param catalog the custom catalog to be used to resolve XSDs used by the\n+     *                test.\n+     * @param expectedThrow the expected throw if the specified DTD can not be\n+     *                      resolved.\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"getXSD\")\n+    public void testXSD(String xmlTemplate, String xsdLocation, String targetNS, String rootElement, String catalog,\n+            Class<Throwable> expectedThrow)\n+            throws Exception {\n+        String xmlSrcPath = SRC_DIR + \"\/\" + xmlTemplate;\n+        final String xmlSrcId = getSysId(xmlSrcPath);\n+\n+        final String customCatalog = getSysId((catalog != null) ? SRC_DIR + \"\/\" + catalog : null);\n+\n+        final String xmlString = generateXMLWithXSDRef(xmlSrcPath, xsdLocation,\n+                targetNS, rootElement);\n+        if (expectedThrow == null) {\n+            assertDoesNotThrow(() -> validateWithResolveStrict(xmlString, xmlSrcId, customCatalog),\n+                    \"JDKCatalog shall resolve \" + xsdLocation + \" but exception is thrown.\");\n+        } else {\n+            Assert.assertThrows(expectedThrow,\n+                () -> validateWithResolveStrict(xmlString, xmlSrcId, customCatalog));\n+        }\n+    }\n+\n+    \/**\n+     * Validate the specified XML document with jdk.xml.jdkCatalog.resolve set to strict.\n+     * @param xml  the XML document to be validated\n+     * @param xmlSrcPathId the URI to the XML source (template in this case)\n+     * @param customCatalog the custom catalog used to resolve local XSDs\n+     * @throws Exception if validation fails\n+     *\/\n+    public void validateWithResolveStrict(String xml, String xmlSrcPathId, String customCatalog)\n+            throws Exception {\n+        SAXSource ss = new SAXSource(new InputSource(new StringReader(xml)));\n+        ss.setSystemId(xmlSrcPathId);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        schemaFactory.setProperty(JDKCATALOG_RESOLVE, \"strict\");\n+        if (customCatalog != null) {\n+            schemaFactory.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), customCatalog);\n+            schemaFactory.setProperty(CatalogFeatures.Feature.RESOLVE.getPropertyName(), \"continue\");\n+        }\n+        Validator validator = schemaFactory.newSchema().newValidator();\n+        validator.validate(ss);\n+    }\n+\n+    \/**\n+     * Parses the XML with jdk.xml.jdkCatalog.resolve set to strict.\n+     * @param xml the XML document to be parsed\n+     * @throws Exception if external access is denied\n+     *\/\n+    public void parseWithResolveStrict(String xml)\n+            throws Exception {\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        saxParserFactory.setNamespaceAware(true);\n+        XMLReader xmlReader = saxParserFactory.newSAXParser().getXMLReader();\n+        xmlReader.setProperty(JDKCATALOG_RESOLVE, \"strict\");\n+        xmlReader.setContentHandler(new DefaultHandler());\n+        xmlReader.parse(new InputSource(new StringReader(xml)));\n+    }\n+\n+    \/**\n+     * Generates an XML with the specified PUBLIC and SYSTEM identifiers.\n+     * @param publicId the public identifier\n+     * @param systemId the system identifier\n+     * @return an XML\n+     * @throws Exception if error happens\n+     *\/\n+    private String generateXMLWithDTDRef(String publicId, String systemId)\n+            throws Exception {\n+        Path path = Paths.get(SRC_DIR + \"\/dtdtest.xml\");\n+        String xmlString = Files.lines(path).map(line -> {\n+            line = line.replace(PUBLIC_ID, publicId);\n+            line = line.replace(SYSTEM_ID, systemId);\n+            return line;\n+        }).collect(Collectors.joining(System.lineSeparator()));\n+        return xmlString;\n+    }\n+\n+    \/**\n+     * Generates an XML with the specified XSD location.\n+     * @param xmlSrcPath the path to the XML source\n+     * @param xsd the XSD location\n+     * @return an XML\n+     * @throws Exception if error happens\n+     *\/\n+    private String generateXMLWithXSDRef(String xmlSrcPath, String xsd,\n+            String targetNS, String rootElement)\n+            throws Exception {\n+        String xmlString = Files.lines(Paths.get(xmlSrcPath)).map(line -> {\n+            if (line.contains(XSD_LOCATION)) {\n+                line = line.replace(XSD_LOCATION, xsd);\n+            }\n+            if (line.contains(TARGET_NAMESPACE)) {\n+                line = line.replace(TARGET_NAMESPACE, targetNS);\n+            }\n+            if (line.contains(ROOT_ELEMENT)) {\n+                line = line.replace(ROOT_ELEMENT, rootElement);\n+            }\n+            return line;\n+        }).collect(Collectors.joining(System.lineSeparator()));\n+        return xmlString;\n+    }\n+\n+    \/**\n+     * Returns the System identifier (URI) of the source.\n+     * @param path the path to the source\n+     * @return the System identifier\n+     *\/\n+    private String getSysId(String path) {\n+        if (path == null) return null;\n+        String xmlSysId = \"file:\/\/\" + path;\n+        if (isWindows) {\n+            path = path.replace('\\\\', '\/');\n+            xmlSysId = \"file:\/\/\/\" + path;\n+        }\n+        return xmlSysId;\n+    }\n+\n+    \/**\n+     * Asserts the run does not cause a Throwable.\n+     * @param runnable the runnable\n+     * @param message the message if the test fails\n+     *\/\n+    private void assertDoesNotThrow(ThrowingRunnable runnable, String message) {\n+        try {\n+            runnable.run();\n+        } catch (Throwable t) {\n+            Assert.fail(message + \"\\n Exception thrown: \" + t.getMessage());\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/JDKCatalogTest.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<catalog xmlns=\"urn:oasis:names:tc:entity:xmlns:xml:catalog\">\n+    <!-- Catalog for testing the JDKCatalog\n+    -->\n+    <systemSuffix systemIdSuffix=\"testDatatypes.xsd\" uri=\"testDatatypes.xsd\"\/>\n+    <systemSuffix systemIdSuffix=\"testXML.xsd\" uri=\"testXML.xsd\"\/>\n+\n+<\/catalog>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/TestCatalog.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+<?xml version=\"1.0\"?>\n+    <!DOCTYPE html PUBLIC \"{{publicId}}\"\n+      \"{{systemId}}\">\n+<html>\n+    <head>\n+        <title>\n+            XHTML 1.0\n+        <\/title>\n+    <\/head>\n+    <body>\n+        <h1>\n+            XHTML 1.0\n+        <\/h1>\n+        <ul>\n+            <li>\n+                xhtml1-transition.dtd\n+            <\/li>\n+        <\/ul>\n+    <\/body>\n+<\/html>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/dtdtest.xml","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<testDatatypes xmlns=\"http:\/\/xmlschema.datatypes\/testSchema\"\n+          xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+          xsi:schemaLocation=\"http:\/\/xmlschema.datatypes\/testSchema testDatatypes.xsd\">\n+\n+    <stringType>Hello, World!<\/stringType>\n+    <integerType>12345<\/integerType>\n+    <decimalType>67.78<\/decimalType>\n+    <booleanType>false<\/booleanType>\n+    <dateType>2024-11-24<\/dateType>\n+<\/testDatatypes>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/testDatatypes.xml","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+           targetNamespace=\"http:\/\/xmlschema.datatypes\/testSchema\"\n+           xmlns=\"http:\/\/xmlschema.datatypes\/testSchema\"\n+           elementFormDefault=\"qualified\">\n+\n+    <!-- Import the XMLSchema-datatypes.xsd -->\n+    <xs:import namespace=\"http:\/\/www.w3.org\/2001\/XMLSchema-datatypes\" schemaLocation=\"http:\/\/www.w3.org\/2009\/XMLSchema\/XMLSchema-datatypes.xsd\">\n+      <xs:annotation>\n+        <xs:documentation>\n+          Get access to the type defined in datatypes\n+        <\/xs:documentation>\n+      <\/xs:annotation>\n+    <\/xs:import>\n+\n+    <!-- Define a root element that uses built-in datatypes -->\n+    <xs:element name=\"testDatatypes\">\n+        <xs:complexType>\n+            <xs:sequence>\n+                <xs:element name=\"stringType\" type=\"xs:string\"\/>\n+                <xs:element name=\"integerType\" type=\"xs:integer\"\/>\n+                <xs:element name=\"decimalType\" type=\"xs:decimal\"\/>\n+                <xs:element name=\"booleanType\" type=\"xs:boolean\"\/>\n+                <xs:element name=\"dateType\" type=\"xs:date\"\/>\n+            <\/xs:sequence>\n+        <\/xs:complexType>\n+    <\/xs:element>\n+\n+<\/xs:schema>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/testDatatypes.xsd","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<testXMLXSD xmlns=\"http:\/\/xml.xsd.test\/testXMLXSD\"\n+          xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+          xmlns:xml=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+          xsi:schemaLocation=\"http:\/\/xml.xsd.test\/testXMLXSD testXML.xsd\"\n+          xml:lang=\"en\"\n+          xml:base=\"http:\/\/xml.xsd.test\/base\">\n+\n+    <message>Hello, World!<\/message>\n+<\/testXMLXSD>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/testXML.xml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<xs:schema xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"\n+           xmlns:xml=\"http:\/\/www.w3.org\/XML\/1998\/namespace\"\n+           targetNamespace=\"http:\/\/xml.xsd.test\/testXMLXSD\"\n+           xmlns=\"http:\/\/xml.xsd.test\/testXMLXSD\"\n+           elementFormDefault=\"qualified\">\n+\n+    <xs:import namespace=\"http:\/\/www.w3.org\/XML\/1998\/namespace\" schemaLocation=\"http:\/\/www.w3.org\/2001\/xml.xsd\">\n+      <xs:annotation>\n+        <xs:documentation>\n+          Get access to the xml: attribute groups for xml:lang\n+          as declared on 'schema' and 'documentation' below\n+        <\/xs:documentation>\n+      <\/xs:annotation>\n+    <\/xs:import>\n+    <!-- Define a root element that uses xml:lang and xml:base attributes -->\n+    <xs:element name=\"testXMLXSD\">\n+        <xs:complexType mixed=\"true\">\n+            <xs:sequence>\n+                <xs:element name=\"message\" type=\"xs:string\"\/>\n+            <\/xs:sequence>\n+            <xs:attribute ref=\"xml:lang\"\/>\n+            <xs:attribute ref=\"xml:base\"\/>\n+        <\/xs:complexType>\n+    <\/xs:element>\n+\n+<\/xs:schema>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/testXML.xsd","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version=\"1.0\"?>\n+<xs:schema xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+           xsi:schemaLocation=\"{{targetNamespace}} {{SCHEMA_LOCATION}}\"\n+           xmlns:xs=\"{{targetNamespace}}\">\n+    <xs:element name=\"example\" type=\"xs:string\" \/>\n+<\/xs:schema>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/testXMLSchema.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\"?>\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http:\/\/www.w3.org\/1999\/xhtml {{SCHEMA_LOCATION}}\"\n+    >\n+    <head>\n+        <title>Test XHTML<\/title>\n+    <\/head>\n+    <frameset cols=\"1*, 1*, 2*\">\n+        <frame src=\"frame1.html\" name=\"left\" \/>\n+        <frame src=\"frame2.html\" name=\"middle\" \/>\n+        <frame src=\"frame3.html\" name=\"right\" \/>\n+    <\/frameset>\n+<\/html>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/xhtml-frameset.xml","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\"?>\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\"\n+    xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http:\/\/www.w3.org\/1999\/xhtml {{SCHEMA_LOCATION}}\"\n+    xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\">\n+    <head>\n+        <title>Test XHTML<\/title>\n+    <\/head>\n+    <body>\n+        <p>Test XHTML<\/p>\n+    <\/body>\n+<\/html>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/xhtml.xml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+<?xml version=\"1.0\"?>\n+<{{rootElement}} xmlns=\"{{targetNamespace}}\"\n+            xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+            xsi:schemaLocation=\"{{targetNamespace}} {{SCHEMA_LOCATION}}\"\n+            xmlns:xsd=\"http:\/\/www.w3.org\/2001\/XMLSchema\">\n+\n+<\/{{rootElement}}>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/jdkcatalog\/xsdtest.xml","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n-import org.testng.annotations.BeforeClass;\n@@ -42,1 +41,1 @@\n- * @bug 6513892\n+ * @bug 6513892 8343001\n@@ -48,6 +47,0 @@\n-    @BeforeClass\n-    public void setup(){\n-        if (System.getSecurityManager() != null)\n-            System.setSecurityManager(null);\n-    }\n-\n@@ -58,0 +51,1 @@\n+            tf.setFeature(\"jdk.xml.enableExtensionFunctions\", true);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/Bug6513892.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @bug 8157830 8228854\n+ * @bug 8157830 8228854 8343001\n@@ -55,1 +55,1 @@\n- * @run testng\/othervm transform.ErrorListenerTest\n+ * @run testng\/othervm -Djdk.xml.enableExtensionFunctions=true transform.ErrorListenerTest\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/ErrorListenerTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.InputStream;\n@@ -28,1 +27,0 @@\n-\n@@ -31,1 +29,0 @@\n-import javax.xml.transform.TransformerConfigurationException;\n@@ -36,1 +33,3 @@\n-\n+import static jaxp.library.JAXPTestUtilities.SRC_DIR;\n+import static jaxp.library.JAXPTestUtilities.assertDoesNotThrow;\n+import static jaxp.library.JAXPTestUtilities.getSystemId;\n@@ -38,0 +37,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -39,0 +39,1 @@\n+import static transform.XSLTFunctionsTest.SP_ENABLE_EXTENSION_FUNCTION_SPEC;\n@@ -42,0 +43,1 @@\n+ * @bug 8343001 8343001\n@@ -44,1 +46,2 @@\n- * @summary Test XSLT shall report TransformerException for unsafe xsl when FEATURE_SECURE_PROCESSING is true.\n+ * @summary Verifies that XSLT reports TransformerException as it processes xsl\n+ * using extension functions while FEATURE_SECURE_PROCESSING is set to true.\n@@ -47,4 +50,8 @@\n-    @Test\n-    public void testSecureProcessing() {\n-        boolean _isSecureMode = System.getSecurityManager() != null;\n-        \/\/ SECURE_PROCESSING == false\n+    \/**\n+     * Test state\n+     *\/\n+    public static enum TestState {\n+        DEFAULT,  \/\/ the default state\n+        SETFSP,   \/\/ set FEATURE_SECURE_PROCESSING\n+        SETPROPERTY; \/\/ set the enalbeExtensionFunctions property\n+    }\n@@ -52,3 +59,49 @@\n-        \/\/ the style sheet\n-        InputStream xslStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xsl\");\n-        StreamSource xslSource = new StreamSource(xslStream);\n+    @DataProvider(name = \"extFunc\")\n+    public Object[][] getExtFuncSettings() throws Exception {\n+        return new Object[][] {\n+            \/\/ by default, Extension Functions are disallowed\n+            { TestState.DEFAULT, true, null, false, TransformerException.class},\n+            \/\/ set FSP=true, Extension Functions are disallowed\n+            { TestState.SETFSP, true, null, false, TransformerException.class},\n+            \/\/ turning off FSP does not enable Extension Functions\n+            { TestState.SETFSP, false, null, false, TransformerException.class},\n+            \/\/ between FSP and the Extension Functions property (jdk.xml.enableExtensionFunctions),\n+            \/\/ the later takes precedence\n+            { TestState.SETPROPERTY, true, SP_ENABLE_EXTENSION_FUNCTION_SPEC, false, TransformerException.class},\n+            { TestState.SETPROPERTY, true, SP_ENABLE_EXTENSION_FUNCTION_SPEC, true, null},\n+        };\n+    }\n+    \/**\n+     * Verifies the effect of FEATURE_SECURE_PROCESSING (FSP) and the precedence\n+     * between FSP and the Extension Functions property.\n+     *\n+     * @param testState the state of the test\n+     * @param fspValue the FSP value to be set\n+     * @param property the Extension Functions property\n+     * @param propertyValue the property value\n+     * @param expectedThrow the expected throw if the specified DTD can not be\n+     *                      resolved.\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test(dataProvider = \"extFunc\")\n+    public void testFSP(TestState testState, boolean fspValue, String property,\n+            boolean propertyValue, Class<Throwable> expectedThrow)\n+            throws Exception {\n+        final TransformerFactory tf = TransformerFactory.newInstance();\n+        switch (testState) {\n+            case DEFAULT:\n+                break;\n+            case SETFSP:\n+                tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, fspValue);\n+                break;\n+            case SETPROPERTY:\n+                tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, fspValue);\n+                tf.setFeature(property, propertyValue);\n+                break;\n+        }\n+        if (expectedThrow == null) {\n+            assertDoesNotThrow(() -> runTransform(tf), \"Unexpected exception.\");\n+        } else {\n+            Assert.assertThrows(expectedThrow, () -> runTransform(tf));\n+        }\n+    }\n@@ -56,3 +109,4 @@\n-        \/\/ the xml source\n-        InputStream xmlStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xml\");\n-        StreamSource xmlSource = new StreamSource(xmlStream);\n+    private void runTransform(TransformerFactory tf)\n+            throws Exception {\n+        StreamSource xslSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xsl\"));\n+        StreamSource xmlSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xml\"));\n@@ -63,72 +117,2 @@\n-\n-        \/\/ the transformer\n-        TransformerFactory transformerFactory = null;\n-        Transformer transformer = null;\n-\n-        \/\/ transform with a non-secure Transformer\n-        \/\/ expect success\n-        String xmlResult;\n-        if (!_isSecureMode) { \/\/ jaxp secure feature can not be turned off when\n-                              \/\/ security manager is present\n-            try {\n-                transformerFactory = TransformerFactory.newInstance();\n-                transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);\n-                transformer = transformerFactory.newTransformer(xslSource);\n-                transformer.transform(xmlSource, xmlResultStream);\n-            } catch (TransformerConfigurationException ex) {\n-                ex.printStackTrace();\n-                Assert.fail(ex.toString());\n-            } catch (TransformerException ex) {\n-                ex.printStackTrace();\n-                Assert.fail(ex.toString());\n-            }\n-\n-            \/\/ expected success\n-            \/\/ and the result is ...\n-            xmlResult = xmlResultString.toString();\n-            System.out.println(\"Transformation result (SECURE_PROCESSING == false) = \\\"\" + xmlResult + \"\\\"\");\n-        }\n-\n-        \/\/ now do same transformation but with SECURE_PROCESSING == true\n-        \/\/ expect Exception\n-        boolean exceptionCaught = false;\n-\n-        \/\/ the style sheet\n-        xslStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xsl\");\n-        xslSource = new StreamSource(xslStream);\n-\n-        \/\/ the xml source\n-        xmlStream = this.getClass().getResourceAsStream(\"SecureProcessingTest.xml\");\n-        xmlSource = new StreamSource(xmlStream);\n-\n-        \/\/ the xml result\n-        xmlResultString = new StringWriter();\n-        xmlResultStream = new StreamResult(xmlResultString);\n-\n-        \/\/ the transformer\n-        transformerFactory = null;\n-        transformer = null;\n-\n-        \/\/ transform with a secure Transformer\n-        try {\n-            transformerFactory = TransformerFactory.newInstance();\n-            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n-            transformer = transformerFactory.newTransformer(xslSource);\n-            transformer.transform(xmlSource, xmlResultStream);\n-        } catch (TransformerConfigurationException ex) {\n-            ex.printStackTrace();\n-            Assert.fail(ex.toString());\n-        } catch (TransformerException ex) {\n-            \/\/ expected failure\n-            System.out.println(\"expected failure: \" + ex.toString());\n-            ex.printStackTrace(System.out);\n-            exceptionCaught = true;\n-        }\n-\n-        \/\/ unexpected success?\n-        if (!exceptionCaught) {\n-            \/\/ and the result is ...\n-            xmlResult = xmlResultString.toString();\n-            System.err.println(\"Transformation result (SECURE_PROCESSING == true) = \\\"\" + xmlResult + \"\\\"\");\n-            Assert.fail(\"SECURITY_PROCESSING == true, expected failure but got result: \\\"\" + xmlResult + \"\\\"\");\n-        }\n+        Transformer transformer = tf.newTransformer(xslSource);\n+        transformer.transform(xmlSource, xmlResultStream);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SecureProcessingTest.java","additions":71,"deletions":87,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.FilePermission;\n@@ -39,0 +38,4 @@\n+import static jaxp.library.JAXPTestUtilities.SRC_DIR;\n+import static jaxp.library.JAXPTestUtilities.assertDoesNotThrow;\n+import static jaxp.library.JAXPTestUtilities.getSystemId;\n+import static jaxp.library.JAXPTestUtilities.getSystemProperty;\n@@ -40,0 +43,1 @@\n+import static org.testng.Assert.assertEquals;\n@@ -42,4 +46,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static jaxp.library.JAXPTestUtilities.clearSystemProperty;\n-import static jaxp.library.JAXPTestUtilities.setSystemProperty;\n-import static jaxp.library.JAXPTestUtilities.getSystemProperty;\n@@ -49,0 +49,1 @@\n+ * @bug 8062518 8153082 8165116 8343001\n@@ -56,0 +57,15 @@\n+    @DataProvider(name = \"propertyName\")\n+    public static Object[][] getSettings() {\n+        return new Object[][] {\n+            \/\/ legacy property name\n+            {ORACLE_ENABLE_EXTENSION_FUNCTION, true, true, null},\n+            {ORACLE_ENABLE_EXTENSION_FUNCTION, true, false, TransformerException.class},\n+            \/\/ legacy system property name\n+            {SP_ENABLE_EXTENSION_FUNCTION, false, true, null},\n+            {SP_ENABLE_EXTENSION_FUNCTION, false, false, TransformerException.class},\n+            \/\/ current property and system property name\n+            {SP_ENABLE_EXTENSION_FUNCTION_SPEC, true, true, null},\n+            {SP_ENABLE_EXTENSION_FUNCTION_SPEC, true, false, TransformerException.class},\n+        };\n+    }\n+\n@@ -89,3 +105,9 @@\n-     * @bug 8161454\n-     * Verifies that the new \/ correct name is supported, as is the old \/ incorrect\n-     * one for compatibility\n+     * @bug 8161454 8343001\n+     * Verifies that legacy property names are continually supported for compatibility.\n+     *\n+     * @param property the property name\n+     * @param isAPIProperty indicates whether the property can be set via the factory\n+     * @param value the property value\n+     * @param expectedThrow the expected throw if the specified DTD can not be\n+     *                      resolved.\n+     * @throws Exception if the test fails\n@@ -93,37 +115,7 @@\n-    @Test\n-    public void testNameChange() {\n-\n-        boolean feature;\n-        TransformerFactory tf = TransformerFactory.newInstance();\n-        feature = tf.getFeature(ORACLE_ENABLE_EXTENSION_FUNCTION);\n-        System.out.println(\"Default setting: \" + feature);\n-        \/\/ The default: true if no SecurityManager, false otherwise\n-        Assert.assertTrue(feature == getDefault());\n-\n-        setSystemProperty(SP_ENABLE_EXTENSION_FUNCTION, getDefaultOpposite());\n-        tf = TransformerFactory.newInstance();\n-        feature = tf.getFeature(ORACLE_ENABLE_EXTENSION_FUNCTION);\n-        System.out.println(\"After setting \" + SP_ENABLE_EXTENSION_FUNCTION + \": \" + feature);\n-        clearSystemProperty(SP_ENABLE_EXTENSION_FUNCTION);\n-        \/\/ old\/incorrect name is still supported\n-        Assert.assertTrue(feature != getDefault());\n-\n-        setSystemProperty(SP_ENABLE_EXTENSION_FUNCTION_SPEC, getDefaultOpposite());\n-        tf = TransformerFactory.newInstance();\n-        feature = tf.getFeature(ORACLE_ENABLE_EXTENSION_FUNCTION);\n-        System.out.println(\"After setting \" + SP_ENABLE_EXTENSION_FUNCTION_SPEC + \": \" + feature);\n-        clearSystemProperty(SP_ENABLE_EXTENSION_FUNCTION_SPEC);\n-        \/\/ new\/correct name is effective\n-        Assert.assertTrue(feature != getDefault());\n-    }\n-\n-    final boolean isSecure;\n-    {\n-        String runSecMngr = getSystemProperty(\"runSecMngr\");\n-        isSecure = runSecMngr != null && runSecMngr.equals(\"true\");\n-    }\n-\n-    \/\/ The default: true if no SecurityManager, false otherwise\n-    private boolean getDefault() {\n-        if (isSecure) {\n-            return false;\n+    @Test(dataProvider = \"propertyName\")\n+    public void testNameChange(String property, boolean isAPIProperty,\n+            boolean value, Class<Throwable> expectedThrow)\n+            throws Exception {\n+        if (expectedThrow == null) {\n+            assertDoesNotThrow(() -> runTransform(property, isAPIProperty, value),\n+                    \"Extension Functions property is set to \" + value + \" but exception is thrown.\");\n@@ -131,1 +123,2 @@\n-            return true;\n+            Assert.assertThrows(expectedThrow,\n+                () -> runTransform(property, isAPIProperty, value));\n@@ -135,6 +128,19 @@\n-    \/\/ Gets a String value that is opposite to the default value\n-    private String getDefaultOpposite() {\n-        if (isSecure) {\n-            return \"true\";\n-        } else {\n-            return \"false\";\n+    private void runTransform(String property, boolean isAPIProperty, boolean value)\n+            throws Exception {\n+        StreamSource xslSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xsl\"));\n+        StreamSource xmlSource = new StreamSource(getSystemId(SRC_DIR + \"\/SecureProcessingTest.xml\"));\n+\n+        \/\/ the xml result\n+        StringWriter xmlResultString = new StringWriter();\n+        StreamResult xmlResultStream = new StreamResult(xmlResultString);\n+\n+        if (!isAPIProperty) {\n+            System.setProperty(property, Boolean.toString(value));\n+        }\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        if (isAPIProperty) {\n+            tf.setFeature(property, value);\n+        }\n+        Transformer transformer = tf.newTransformer(xslSource);\n+        if (!isAPIProperty) {\n+            System.clearProperty(property);\n@@ -142,0 +148,1 @@\n+        transformer.transform(xmlSource, xmlResultStream);\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/XSLTFunctionsTest.java","additions":59,"deletions":52,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+java\/util\/concurrent\/locks\/StampedLock\/OOMEInStampedLock.java 8345266 generic-all\n+\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8288109\n+ * @bug 8288109 8235786\n@@ -32,0 +32,2 @@\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.HttpContext;\n@@ -36,0 +38,1 @@\n+import org.junit.jupiter.api.AfterAll;\n@@ -56,3 +59,5 @@\n-    static final InetAddress LOOPBACK_ADDR = InetAddress.getLoopbackAddress();\n-    static final boolean ENABLE_LOGGING = true;\n-    static final Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n+    private static final InetAddress LOOPBACK_ADDR = InetAddress.getLoopbackAddress();\n+    private static final boolean ENABLE_LOGGING = true;\n+    private static final Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    private static HttpServer server;\n@@ -61,1 +66,1 @@\n-    public static void setup() {\n+    public static void setup() throws Exception {\n@@ -68,0 +73,14 @@\n+        server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR, 0), 10);\n+        server.createContext(\"\/normal\", new AttribHandler());\n+        final HttpContext filteredCtx = server.createContext(\"\/filtered\", new AttribHandler());\n+        filteredCtx.getFilters().add(new AttributeAddingFilter());\n+        server.start();\n+        System.out.println(\"Server started at \" + server.getAddress());\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"Stopping server \" + server.getAddress());\n+            server.stop(0);\n+        }\n@@ -70,0 +89,3 @@\n+    \/*\n+     * Verifies that HttpExchange.setAttribute() allows for null value.\n+     *\/\n@@ -71,8 +93,3 @@\n-    public void testExchangeAttributes() throws Exception {\n-        var handler = new AttribHandler();\n-        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR,0), 10);\n-        server.createContext(\"\/\", handler);\n-        server.start();\n-        try {\n-            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n-            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+    public void testNullAttributeValue() throws Exception {\n+        try (var client = HttpClient.newBuilder().proxy(NO_PROXY).build()) {\n+            var request = HttpRequest.newBuilder(uri(server, \"\/normal\", null)).build();\n@@ -81,2 +98,30 @@\n-        } finally {\n-            server.stop(0);\n+        }\n+    }\n+\n+    \/*\n+     * Verifies that an attribute set on one exchange is accessible to another exchange that\n+     * belongs to the same HttpContext.\n+     *\/\n+    @Test\n+    public void testSharedAttribute() throws Exception {\n+        try (var client = HttpClient.newBuilder().proxy(NO_PROXY).build()) {\n+            final var firstReq = HttpRequest.newBuilder(uri(server, \"\/filtered\", \"firstreq\"))\n+                    .build();\n+            System.out.println(\"issuing request \" + firstReq);\n+            final var firstResp = client.send(firstReq, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, firstResp.statusCode());\n+\n+            \/\/ issue the second request\n+            final var secondReq = HttpRequest.newBuilder(uri(server, \"\/filtered\", \"secondreq\"))\n+                    .build();\n+            System.out.println(\"issuing request \" + secondReq);\n+            final var secondResp = client.send(secondReq, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, secondResp.statusCode());\n+\n+            \/\/ verify that the filter was invoked for both the requests. the filter internally\n+            \/\/ does the setAttribute() and getAttribute() and asserts that the attribute value\n+            \/\/ set by the first exchange was available through the second exchange.\n+            assertTrue(AttributeAddingFilter.filteredFirstReq, \"Filter wasn't invoked for \"\n+                    + firstReq.uri());\n+            assertTrue(AttributeAddingFilter.filteredSecondReq, \"Filter wasn't invoked for \"\n+                    + secondReq.uri());\n@@ -88,1 +133,1 @@\n-    static URI uri(HttpServer server, String path) throws URISyntaxException {\n+    static URI uri(HttpServer server, String path, String query) throws URISyntaxException {\n@@ -94,0 +139,1 @@\n+                .query(query)\n@@ -115,0 +161,50 @@\n+\n+    private static final class AttributeAddingFilter extends Filter {\n+\n+        private static final String ATTR_NAME =\"foo-bar\";\n+        private static final String ATTR_VAL =\"hello-world\";\n+        private static volatile boolean filteredFirstReq;\n+        private static volatile boolean filteredSecondReq;\n+\n+        @Override\n+        public void doFilter(final HttpExchange exchange, final Chain chain) throws IOException {\n+            if (exchange.getRequestURI().getQuery().contains(\"firstreq\")) {\n+                filteredFirstReq = true;\n+                \/\/ add a request attribute through the exchange, for this first request\n+                \/\/ and at the same time verify that the attribute doesn't already exist\n+                final Object attrVal = exchange.getAttribute(ATTR_NAME);\n+                if (attrVal != null) {\n+                    throw new IOException(\"attribute \" + ATTR_NAME + \" with value: \" + attrVal\n+                            + \" unexpectedly present in exchange: \" + exchange.getRequestURI());\n+                }\n+                \/\/ set the value\n+                exchange.setAttribute(ATTR_NAME, ATTR_VAL);\n+                System.out.println(exchange.getRequestURI() + \" set attribute \"\n+                        + ATTR_NAME + \"=\" + ATTR_VAL);\n+            } else if (exchange.getRequestURI().getQuery().contains(\"secondreq\")) {\n+                filteredSecondReq = true;\n+                \/\/ verify the attribute is already set and the value is the expected one.\n+                final Object attrVal = exchange.getAttribute(ATTR_NAME);\n+                if (attrVal == null) {\n+                    throw new IOException(\"attribute \" + ATTR_NAME + \" is missing in exchange: \"\n+                            + exchange.getRequestURI());\n+                }\n+                if (!ATTR_VAL.equals(attrVal)) {\n+                    throw new IOException(\"unexpected value: \" + attrVal + \" for attribute \"\n+                            + ATTR_NAME + \" in exchange: \" + exchange.getRequestURI());\n+                }\n+                System.out.println(exchange.getRequestURI() + \" found attribute \"\n+                        + ATTR_NAME + \"=\" + attrVal);\n+            } else {\n+                \/\/ unexpected request\n+                throw new IOException(\"unexpected request \" + exchange.getRequestURI());\n+            }\n+            \/\/ let the request proceed\n+            chain.doFilter(exchange);\n+        }\n+\n+        @Override\n+        public String description() {\n+            return \"AttributeAddingFilter\";\n+        }\n+    }\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ExchangeAttributeTest.java","additions":113,"deletions":17,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,0 @@\n-import java.util.*;\n-import java.util.concurrent.*;\n-import java.util.logging.*;\n@@ -29,2 +26,1 @@\n-import java.security.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/FileServerHandler.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.security.AccessController;\n@@ -36,1 +35,0 @@\n-import java.security.PrivilegedExceptionAction;\n@@ -362,15 +360,9 @@\n-        return AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<KeyStore>() {\n-                    @Override\n-                    public KeyStore run() throws Exception {\n-                        final String testKeys = System.getProperty(\"test.src\")\n-                                + \"\/\"\n-                                + \"..\/..\/..\/..\/..\/..\/test\/lib\/jdk\/test\/lib\/net\/testkeys\";\n-                        try (final FileInputStream fis = new FileInputStream(testKeys)) {\n-                            final char[] passphrase = \"passphrase\".toCharArray();\n-                            final KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n-                            ks.load(fis, passphrase);\n-                            return ks;\n-                        }\n-                    }\n-                });\n+        final String testKeys = System.getProperty(\"test.src\")\n+                + \"\/\"\n+                + \"..\/..\/..\/..\/..\/..\/test\/lib\/jdk\/test\/lib\/net\/testkeys\";\n+        try (final FileInputStream fis = new FileInputStream(testKeys)) {\n+            final char[] passphrase = \"passphrase\".toCharArray();\n+            final KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+            ks.load(fis, passphrase);\n+            return ks;\n+        }\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HttpsParametersClientAuthTest.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.net.*;\n@@ -28,3 +27,1 @@\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.util.*;\n+\n@@ -32,3 +29,0 @@\n-import javax.security.auth.*;\n-import javax.security.auth.callback.*;\n-import javax.security.auth.login.*;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/LogFilter.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.*;\n@@ -43,2 +42,0 @@\n-import java.security.*;\n-import java.security.cert.*;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/SelCacheTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.util.*;\n@@ -29,2 +28,1 @@\n-import java.security.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/SimpleFileServer.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import javax.security.auth.callback.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test14.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import javax.security.auth.callback.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test2.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -38,1 +37,0 @@\n-import java.util.regex.Pattern.*;\n@@ -41,2 +39,0 @@\n-import java.security.*;\n-import javax.net.ssl.*;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test3.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -40,2 +39,0 @@\n-import java.security.*;\n-import javax.net.ssl.*;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test4.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -40,2 +39,0 @@\n-import java.security.*;\n-import javax.net.ssl.*;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test5.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import javax.security.auth.callback.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test6.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import javax.security.auth.callback.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test7.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import javax.security.auth.callback.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test8.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -40,3 +39,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/TestLogging.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6339483.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6341616.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6526158.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.*;\n@@ -40,3 +39,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6526913.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.util.*;\n@@ -38,3 +37,0 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import javax.net.ssl.*;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6529200.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.*;\n@@ -39,3 +38,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import javax.net.ssl.*;\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6744329.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Tests for FileServerHandler with SecurityManager\n+ * @summary Tests file permission checks during the creation of a `FileServerHandler`\n@@ -248,1 +248,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/RootDirPermissionsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.awt.EventQueue;\n@@ -32,1 +33,0 @@\n-import java.awt.Window;\n@@ -39,1 +39,0 @@\n-import java.io.IOException;\n@@ -45,1 +44,1 @@\n-\/**\n+\/*\n@@ -51,12 +50,0 @@\n-public class AccessibleChoiceTest {\n-    \/\/Declare things used in the test, like buttons and labels here\n-    Frame frame = new Frame(\"window owner\");\n-    Window win = new Window(frame);\n-    Choice choice = new Choice();\n-    Button def = new Button(\"default owner\");\n-    CountDownLatch go = new CountDownLatch(1);\n-\n-    public static void main(final String[] args) throws IOException {\n-        AccessibleChoiceTest app = new AccessibleChoiceTest();\n-        app.test();\n-    }\n@@ -64,1 +51,10 @@\n-    private void test() throws IOException {\n+public class AccessibleChoiceTest {\n+    static Frame frame;\n+    static Choice choice;\n+    static Button button;\n+    static volatile CountDownLatch go;\n+    static volatile Point loc;\n+    static volatile int bWidth;\n+    static volatile int bHeight;\n+\n+    public static void main(final String[] args) throws Exception {\n@@ -66,2 +62,2 @@\n-            init();\n-            start();\n+            createAndShowUI();\n+            test();\n@@ -69,2 +65,3 @@\n-            if (frame != null) frame.dispose();\n-            if (win != null) win.dispose();\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n@@ -74,4 +71,9 @@\n-    public void init() {\n-        win.setLayout (new FlowLayout ());\n-        win.add(def);\n-        def.addFocusListener(new FocusAdapter() {\n+    public static void createAndShowUI() throws Exception {\n+        go = new CountDownLatch(1);\n+        EventQueue.invokeAndWait(() -> {\n+            frame = new Frame(\"Accessible Choice Test Frame\");\n+            choice = new Choice();\n+            button = new Button(\"default owner\");\n+            frame.setLayout(new FlowLayout());\n+            frame.add(button);\n+            button.addFocusListener(new FocusAdapter() {\n@@ -82,3 +84,7 @@\n-        choice.add(\"One\");\n-        choice.add(\"Two\");\n-        win.add(choice);\n+            choice.add(\"One\");\n+            choice.add(\"Two\");\n+            frame.add(choice);\n+            frame.pack();\n+            frame.setLocationRelativeTo(null);\n+            frame.setVisible(true);\n+        });\n@@ -87,7 +93,2 @@\n-    public void start () throws IOException {\n-        frame.setVisible(true);\n-        win.pack();\n-        win.setLocation(100, 200);\n-        win.setVisible(true);\n-\n-        Robot robot = null;\n+    public static void test() throws Exception {\n+        Robot robot;\n@@ -101,1 +102,0 @@\n-        robot.setAutoDelay(150);\n@@ -105,2 +105,8 @@\n-        Point loc = def.getLocationOnScreen();\n-        robot.mouseMove(loc.x+2, loc.y+2);\n+        EventQueue.invokeAndWait(() -> {\n+            loc = button.getLocationOnScreen();\n+            bWidth = button.getWidth();\n+            bHeight = button.getHeight();\n+        });\n+        robot.mouseMove(loc.x + bWidth \/ 2,\n+                        loc.y + bHeight \/ 2);\n+        robot.delay(500);\n@@ -116,1 +122,1 @@\n-        if (!def.isFocusOwner()) {\n+        if (!button.isFocusOwner()) {\n@@ -120,0 +126,2 @@\n+        robot.delay(500);\n+\n@@ -126,1 +134,5 @@\n-        \/\/ Press Down key to select next item in the choice(Motif 2.1)\n+        if (!choice.isFocusOwner()) {\n+            throw new RuntimeException(\"Choice doesn't have focus\");\n+        }\n+\n+        \/\/ Press Down key to select next item in the choice\n@@ -131,2 +143,0 @@\n-        robot.delay(500);\n-\n@@ -135,0 +145,1 @@\n+            robot.delay(500);\n@@ -145,1 +156,1 @@\n-        if (choice.getSelectedItem() != choice.getItem(1)) {\n+        if (!choice.getSelectedItem().equals(choice.getItem(1))) {\n","filename":"test\/jdk\/java\/awt\/Focus\/UnaccessibleChoice\/AccessibleChoiceTest.java","additions":54,"deletions":43,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,0 @@\n-import java.awt.*;\n-import java.awt.datatransfer.*;\n-import java.awt.event.*;\n-import java.util.Properties;\n@@ -32,0 +28,1 @@\n+ * @requires (os.family == \"linux\")\n@@ -33,2 +30,0 @@\n- * @author Jitender(jitender.singh@eng.sun.com) area=AWT\n- * @author dmitriy.ermashov@oracle.com\n@@ -40,1 +35,17 @@\n-public class IndependenceAWTTest {\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.HeadlessException;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.TextField;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n@@ -42,4 +53,10 @@\n-    Frame frame;\n-    Panel panel;\n-    TextField tf1, tf2, tf3;\n-    Clipboard sClip, pClip;\n+public class IndependenceAWTTest {\n+    private static Frame frame;\n+    private static TextField tf1;\n+    private static TextField tf2;\n+    private static TextField tf3;\n+    private static Clipboard systemClip;\n+    private static Clipboard primaryClip;\n+    private static ExtendedRobot robot;\n+    private static volatile Point ttf1Center;\n+    private static volatile Point glideStartLocation;\n@@ -48,1 +65,9 @@\n-        new IndependenceAWTTest().doTest();\n+        try {\n+            robot = new ExtendedRobot();\n+            EventQueue.invokeAndWait(IndependenceAWTTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            test();\n+        } finally {\n+            EventQueue.invokeAndWait(frame::dispose);\n+        }\n@@ -51,3 +76,2 @@\n-    public IndependenceAWTTest() {\n-\n-        frame = new Frame();\n+    private static void createAndShowUI() {\n+        frame = new Frame(\"IndependenceAWTTest\");\n@@ -60,1 +84,1 @@\n-                tf1.setText(\"Clipboards_Independance_Testing\");\n+                tf1.setText(\"Clipboards_Independence_Testing\");\n@@ -68,1 +92,1 @@\n-        panel = new Panel();\n+        Panel panel = new Panel();\n@@ -76,0 +100,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -82,3 +107,1 @@\n-    private void getPrimaryClipboard() {\n-        Properties ps = System.getProperties();\n-        String operSys = ps.getProperty(\"os.name\");\n+    private static void getPrimaryClipboard() {\n@@ -86,7 +109,6 @@\n-            pClip = Toolkit.getDefaultToolkit().getSystemSelection();\n-            if (pClip == null)\n-                if ((operSys.substring(0,3)).equalsIgnoreCase(\"Win\") || operSys.toLowerCase().contains(\"os x\"))\n-                    System.out.println(operSys + \"Operating system does not support system selection \");\n-                else\n-                    throw new RuntimeException(\"Method getSystemSelection() is returning null on X11 platform\");\n-        } catch(HeadlessException e) {\n+            primaryClip = Toolkit.getDefaultToolkit().getSystemSelection();\n+            if (primaryClip == null) {\n+                throw new RuntimeException(\"Method getSystemSelection() is returning null\"\n+                                           + \" on Linux platform\");\n+            }\n+        } catch (HeadlessException e) {\n@@ -98,2 +120,2 @@\n-    public void getClipboardsContent() throws Exception {\n-        sClip = Toolkit.getDefaultToolkit().getSystemClipboard();\n+    private static void getClipboardsContent() throws Exception {\n+        systemClip = Toolkit.getDefaultToolkit().getSystemClipboard();\n@@ -104,1 +126,1 @@\n-        sClip.setContents(content,content);\n+        systemClip.setContents(content, content);\n@@ -106,2 +128,2 @@\n-        tp = pClip.getContents(this);\n-        ts = sClip.getContents(this);\n+        tp = primaryClip.getContents(null);\n+        ts = systemClip.getContents(null);\n@@ -125,1 +147,1 @@\n-    public void compareText (boolean mustEqual) {\n+    private static void compareText (boolean mustEqual) {\n@@ -139,1 +161,1 @@\n-    public void doTest() throws Exception {\n+    private static void test() throws Exception {\n@@ -141,33 +163,32 @@\n-        ExtendedRobot robot = new ExtendedRobot();\n-        robot.waitForIdle(1000);\n-        frame.setLocation(100, 100);\n-        robot.waitForIdle(1000);\n-\n-        if (pClip != null) {\n-            Point ttf1Center = tf1.getLocationOnScreen();\n-            ttf1Center.translate(tf1.getWidth()\/2, tf1.getHeight()\/2);\n-\n-            robot.glide(new Point(0, 0), ttf1Center);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(20);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(20);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(20);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(2000);\n-\n-            getClipboardsContent();\n-            compareText(true);\n-\n-            \/\/Change the text selection to update the contents of primary clipboard\n-            robot.mouseMove(ttf1Center);\n-            robot.mousePress(MouseEvent.BUTTON1_MASK);\n-            robot.delay(200);\n-            robot.mouseMove(ttf1Center.x + 15, ttf1Center.y);\n-            robot.mouseRelease(MouseEvent.BUTTON1_MASK);\n-            robot.waitForIdle(2000);\n-\n-            getClipboardsContent();\n-            compareText(false);\n-        }\n+        robot.waitForIdle(500);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            Point center = tf1.getLocationOnScreen();\n+            center.translate(tf1.getWidth() \/ 2, tf1.getHeight() \/ 2);\n+            ttf1Center = center;\n+\n+            glideStartLocation = frame.getLocationOnScreen();\n+            glideStartLocation.x -= 10;\n+        });\n+\n+        robot.glide(glideStartLocation, ttf1Center);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle(20);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle(500);\n+\n+        getClipboardsContent();\n+        compareText(true);\n+\n+        \/\/Change the text selection to update the contents of primary clipboard\n+        robot.mouseMove(ttf1Center);\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(20);\n+        robot.mouseMove(ttf1Center.x + 15, ttf1Center.y);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle(500);\n+\n+        getClipboardsContent();\n+        compareText(false);\n","filename":"test\/jdk\/java\/awt\/datatransfer\/Independence\/IndependenceAWTTest.java","additions":89,"deletions":68,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,15 @@\n-import javax.swing.*;\n-import java.awt.*;\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @summary To make sure that System & Primary clipboards should behave independently\n+ * @library \/lib\/client\n+ * @build ExtendedRobot\n+ * @run main IndependenceSwingTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.HeadlessException;\n+import java.awt.Point;\n+import java.awt.Toolkit;\n@@ -34,1 +47,0 @@\n-import java.util.Properties;\n@@ -36,10 +48,4 @@\n-\/*\n- * @test\n- * @key headful\n- * @summary To make sure that System & Primary clipboards should behave independently\n- * @author Jitender(jitender.singh@eng.sun.com) area=AWT\n- * @author dmitriy.ermashov@oracle.com\n- * @library \/lib\/client\n- * @build ExtendedRobot\n- * @run main IndependenceSwingTest\n- *\/\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n@@ -48,5 +54,9 @@\n-\n-    JFrame frame;\n-    JPanel panel;\n-    JTextField tf1, tf2, tf3;\n-    Clipboard sClip, pClip;\n+    private static JFrame frame;\n+    private static JTextField tf1;\n+    private static JTextField tf2;\n+    private static JTextField tf3;\n+    private static Clipboard systemClip;\n+    private static Clipboard primaryClip;\n+    private static ExtendedRobot robot;\n+    private static volatile Point ttf1Center;\n+    private static volatile Point glideStartLocation;\n@@ -55,1 +65,9 @@\n-        new IndependenceSwingTest().doTest();\n+        try {\n+            robot = new ExtendedRobot();\n+            SwingUtilities.invokeAndWait(IndependenceSwingTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            test();\n+        } finally {\n+            SwingUtilities.invokeAndWait(frame::dispose);\n+        }\n@@ -58,3 +76,2 @@\n-    public IndependenceSwingTest() {\n-\n-        frame = new JFrame();\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"IndependenceSwingTest\");\n@@ -67,1 +84,1 @@\n-                tf1.setText(\"Clipboards_Independance_Testing\");\n+                tf1.setText(\"Clipboards_Independence_Testing\");\n@@ -75,1 +92,1 @@\n-        panel = new JPanel();\n+        JPanel panel = new JPanel();\n@@ -83,0 +100,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -89,3 +107,1 @@\n-    private void getPrimaryClipboard() {\n-        Properties ps = System.getProperties();\n-        String operSys = ps.getProperty(\"os.name\");\n+    private static void getPrimaryClipboard() {\n@@ -93,7 +109,6 @@\n-            pClip = Toolkit.getDefaultToolkit().getSystemSelection();\n-            if (pClip == null)\n-                if ((operSys.substring(0,3)).equalsIgnoreCase(\"Win\") || operSys.toLowerCase().contains(\"os x\"))\n-                    System.out.println(operSys + \"Operating system does not support system selection \");\n-                else\n-                    throw new RuntimeException(\"Method getSystemSelection() is returning null on X11 platform\");\n-        } catch(HeadlessException e) {\n+            primaryClip = Toolkit.getDefaultToolkit().getSystemSelection();\n+            if (primaryClip == null) {\n+                throw new RuntimeException(\"Method getSystemSelection() is returning null\"\n+                                           + \" on Linux platform\");\n+            }\n+        } catch (HeadlessException e) {\n@@ -105,2 +120,2 @@\n-    public void getClipboardsContent() throws Exception {\n-        sClip = Toolkit.getDefaultToolkit().getSystemClipboard();\n+    private static void getClipboardsContent() throws Exception {\n+        systemClip = Toolkit.getDefaultToolkit().getSystemClipboard();\n@@ -111,1 +126,1 @@\n-        sClip.setContents(content,content);\n+        systemClip.setContents(content, content);\n@@ -113,2 +128,2 @@\n-        tp = pClip.getContents(this);\n-        ts = sClip.getContents(this);\n+        tp = primaryClip.getContents(null);\n+        ts = systemClip.getContents(null);\n@@ -132,1 +147,1 @@\n-    public void compareText (boolean mustEqual) {\n+    private static void compareText (boolean mustEqual) {\n@@ -146,1 +161,1 @@\n-    public void doTest() throws Exception {\n+    private static void test() throws Exception {\n@@ -148,33 +163,32 @@\n-        ExtendedRobot robot = new ExtendedRobot();\n-        robot.waitForIdle(1000);\n-        frame.setLocation(100, 100);\n-        robot.waitForIdle(1000);\n-\n-        if (pClip != null) {\n-            Point ttf1Center = tf1.getLocationOnScreen();\n-            ttf1Center.translate(tf1.getWidth()\/2, tf1.getHeight()\/2);\n-\n-            robot.glide(new Point(0, 0), ttf1Center);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(20);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(20);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(20);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle(2000);\n-\n-            getClipboardsContent();\n-            compareText(true);\n-\n-            \/\/Change the text selection to update the contents of primary clipboard\n-            robot.mouseMove(ttf1Center);\n-            robot.mousePress(MouseEvent.BUTTON1_MASK);\n-            robot.delay(200);\n-            robot.mouseMove(ttf1Center.x + 15, ttf1Center.y);\n-            robot.mouseRelease(MouseEvent.BUTTON1_MASK);\n-            robot.waitForIdle(2000);\n-\n-            getClipboardsContent();\n-            compareText(false);\n-        }\n+        robot.waitForIdle(500);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            Point center = tf1.getLocationOnScreen();\n+            center.translate(tf1.getWidth() \/ 2, tf1.getHeight() \/ 2);\n+            ttf1Center = center;\n+\n+            glideStartLocation = frame.getLocationOnScreen();\n+            glideStartLocation.x -= 10;\n+        });\n+\n+        robot.glide(glideStartLocation, ttf1Center);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle(20);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle(500);\n+\n+        getClipboardsContent();\n+        compareText(true);\n+\n+        \/\/Change the text selection to update the contents of primary clipboard\n+        robot.mouseMove(ttf1Center);\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(20);\n+        robot.mouseMove(ttf1Center.x + 15, ttf1Center.y);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle(500);\n+\n+        getClipboardsContent();\n+        compareText(false);\n","filename":"test\/jdk\/java\/awt\/datatransfer\/Independence\/IndependenceSwingTest.java","additions":89,"deletions":75,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,1 @@\n-            MemorySegment segment = arena.allocate(tuples);;\n+            MemorySegment segment = arena.allocate(tuples);\n@@ -388,1 +388,1 @@\n-            MemorySegment segment = arena.allocate(bytes);;\n+            MemorySegment segment = arena.allocate(bytes);\n@@ -414,1 +414,1 @@\n-            MemorySegment segment = arena.allocate(bytes);;\n+            MemorySegment segment = arena.allocate(bytes, Long.BYTES);\n@@ -448,1 +448,1 @@\n-            MemorySegment segment = arena.allocate(bytes);;\n+            MemorySegment segment = arena.allocate(bytes);\n@@ -461,1 +461,1 @@\n-            MemorySegment segment = arena.allocate(seq);;\n+            MemorySegment segment = arena.allocate(seq);\n@@ -499,1 +499,1 @@\n-            MemorySegment segment = arena.allocate(seq);;\n+            MemorySegment segment = arena.allocate(seq);\n@@ -510,1 +510,1 @@\n-            leaked = arena.allocate(bytes);;\n+            leaked = arena.allocate(bytes);\n@@ -618,1 +618,1 @@\n-            MemorySegment nativeArray = arena.allocate(bytes, 1);;\n+            MemorySegment nativeArray = arena.allocate(bytes, 1);\n@@ -631,1 +631,1 @@\n-            MemorySegment nativeArray = arena.allocate(seq);;\n+            MemorySegment nativeArray = arena.allocate(seq);\n@@ -703,1 +703,1 @@\n-            MemorySegment ms = arena.allocate(4, 1);;\n+            MemorySegment ms = arena.allocate(4, 1);\n@@ -744,1 +744,1 @@\n-            MemorySegment segment = arena.allocate(10, 1);;\n+            MemorySegment segment = arena.allocate(10, 1);\n@@ -783,1 +783,1 @@\n-            MemorySegment segment = arena.allocate(16, 1);;\n+            MemorySegment segment = arena.allocate(16, 1);\n@@ -801,1 +801,1 @@\n-            MemorySegment segment = arena.allocate(16, 1);;\n+            MemorySegment segment = arena.allocate(16, 1);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,1 +176,1 @@\n-            MemorySegment segment = arena.allocate(struct.byteSize() + 1).asSlice(1);\n+            MemorySegment segment = arena.allocate(struct.byteSize() + 1, struct.byteAlignment()).asSlice(1);\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-            var segment = arena.allocate(10).asReadOnly();\n+            var segment = arena.allocate(len).asReadOnly();\n@@ -99,1 +99,1 @@\n-            var segment = arena.allocate(10);\n+            var segment = arena.allocate(len);\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,5 +195,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(),\n-                    new Linker.Option[]{Linker.Option.critical(false), Linker.Option.captureCallState(\"errno\")},\n-                    \"Incompatible linker options: captureCallState, critical\"\n-            },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @modules java.base\/jdk.internal.foreign\n+ * @modules java.base\/jdk.internal.foreign java.base\/jdk.internal.foreign.abi.fallback\n@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -253,1 +254,7 @@\n-        linker.downcallHandle(fd);\n+        if (linker.getClass().equals(FallbackLinker.class)) {\n+            \/\/ The fallback linker does not support empty layouts (FFI_BAD_TYPEDEF)\n+            var iae = expectThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+            assertTrue(iae.getMessage().contains(\"is empty\"));\n+        } else {\n+            linker.downcallHandle(fd);\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -56,0 +57,14 @@\n+    @Test\n+    public void emptySegment() {\n+        for (Charset charset : standardCharsets()) {\n+            for (Arena arena : arenas()) {\n+                try (arena) {\n+                    var segment = arena.allocate(0);\n+                    var e = expectThrows(IndexOutOfBoundsException.class, () ->\n+                            segment.getString(0, charset));\n+                    assertTrue(e.getMessage().contains(\"No null terminator found\"));\n+                }\n+            }\n+        }\n+    }\n+\n@@ -90,1 +105,0 @@\n-\n@@ -201,0 +215,1 @@\n+                        String expected = testString.substring(i);\n@@ -202,1 +217,1 @@\n-                        assertEquals(actual, testString.substring(i));\n+                        assertEquals(actual, expected);\n@@ -252,0 +267,26 @@\n+    \/\/ This test ensures that we do not address outside the segment even though there\n+    \/\/ are odd bytes at the end.\n+    @Test(dataProvider = \"strings\")\n+    public void offBoundaryTrailingBytes(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : standardCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment strSegment = arena.allocateFrom(testString, charset);\n+                    \/\/ Add an odd byte at the end\n+                    MemorySegment inSegment = arena.allocate(strSegment.byteSize() + 1);\n+                    \/\/ Make sure there are no null-terminators so that we will try to scan\n+                    \/\/ the entire segment.\n+                    inSegment.fill((byte) 1);\n+                    for (int i = 0; i < 4; i++) {\n+                        final int offset = i;\n+                        var e = expectThrows(IndexOutOfBoundsException.class, () -> inSegment.getString(offset, charset));\n+                        assertTrue(e.getMessage().contains(\"No null terminator found\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -274,1 +315,1 @@\n-                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        int actual = StringSupport.strlenByte((AbstractMemorySegmentImpl) segment, j, segment.byteSize());\n@@ -277,0 +318,6 @@\n+                    \/\/ Test end offset\n+                    for (int j = 0; j < len - 1; j++) {\n+                        final long toOffset = j;\n+                        expectThrows(IndexOutOfBoundsException.class, () ->\n+                                StringSupport.strlenByte((AbstractMemorySegmentImpl) segment, 0, toOffset));\n+                    }\n@@ -298,1 +345,1 @@\n-                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        int actual = StringSupport.strlenShort((AbstractMemorySegmentImpl) segment, j * Short.BYTES, segment.byteSize());\n@@ -322,1 +369,1 @@\n-                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        int actual = StringSupport.strlenInt((AbstractMemorySegmentImpl) segment, j * Integer.BYTES, segment.byteSize());\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run testng\/othervm\/timeout=3200\n+ * @run testng\/native\/othervm\/timeout=3200\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,2 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName,\n+                                  Consumer<Object> resultCheck, boolean critical) {}\n@@ -68,2 +69,7 @@\n-        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n+        if (testCase.critical()) {\n+            options.add(Linker.Option.critical(false));\n+        }\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(),\n+                options.toArray(Linker.Option[]::new));\n@@ -89,3 +95,8 @@\n-                                          Class<?> expectedExceptionType, String expectedExceptionMessage) {\n-        Linker.Option stl = Linker.Option.captureCallState(\"errno\");\n-        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), stl);\n+                                          Class<?> expectedExceptionType, String expectedExceptionMessage,\n+                                          Linker.Option[] extraOptions) {\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.captureCallState(\"errno\"));\n+        for (Linker.Option extra : extraOptions) {\n+            options.add(extra);\n+        }\n+        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), options.toArray(Linker.Option[]::new));\n@@ -106,20 +117,27 @@\n-        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n-        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n-        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n-\n-        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n-        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                           JAVA_LONG.withName(\"y\"), 42L)));\n-        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                            JAVA_LONG.withName(\"y\"), 42L,\n-                                            JAVA_LONG.withName(\"z\"), 42L)));\n-        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n-        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n-        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n-\n-        if (IS_WINDOWS) {\n-            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n-            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n+        for (boolean critical : new boolean[]{ true, false }) {\n+            cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT),\n+                    \"errno\", o -> {}, critical));\n+            cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT),\n+                    \"errno\", o -> assertEquals((int) o, 42), critical));\n+            cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT),\n+                    \"errno\", o -> assertEquals((double) o, 42.0), critical));\n+\n+            cases.add(structCase(\"SL\", Map.of(JAVA_LONG.withName(\"x\"), 42L), critical));\n+            cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                    JAVA_LONG.withName(\"y\"), 42L), critical));\n+            cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                    JAVA_LONG.withName(\"y\"), 42L,\n+                    JAVA_LONG.withName(\"z\"), 42L), critical));\n+            cases.add(structCase(\"SD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D), critical));\n+            cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                    JAVA_DOUBLE.withName(\"y\"), 42D), critical));\n+            cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                    JAVA_DOUBLE.withName(\"y\"), 42D,\n+                    JAVA_DOUBLE.withName(\"z\"), 42D), critical));\n+\n+            if (IS_WINDOWS) {\n+                cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT),\n+                        \"GetLastError\", o -> {}, critical));\n+                cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT),\n+                        \"WSAGetLastError\", o -> {}, critical));\n+            }\n@@ -131,1 +149,1 @@\n-    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n+    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields, boolean critical) {\n@@ -142,1 +160,2 @@\n-        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT),\n+                \"errno\", check, critical);\n@@ -148,2 +167,2 @@\n-            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\"},\n-            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\"},\n+            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\", new Linker.Option[0]},\n+            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\", new Linker.Option[0]},\n@@ -151,1 +170,3 @@\n-                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\"},\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\", new Linker.Option[0]},\n+            {MemorySegment.ofArray(new byte[(int) Linker.Option.captureStateLayout().byteSize()]), \/\/ misaligned\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\", new Linker.Option[0]},\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":53,"deletions":32,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import java.util.stream.Collectors;\n@@ -54,0 +55,3 @@\n+    static final MemoryLayout CAPTURE_STATE_LAYOUT = Linker.Option.captureStateLayout();\n+    static final VarHandle ERRNO_HANDLE = CAPTURE_STATE_LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n+\n@@ -90,1 +94,1 @@\n-                                String fName, FunctionDescriptor fDesc, boolean readOnly) {}\n+                                String fName, FunctionDescriptor fDesc, boolean readOnly, boolean captureErrno) {}\n@@ -94,1 +98,6 @@\n-        MethodHandle handle = downcallHandle(testCase.fName(), testCase.fDesc(), Linker.Option.critical(true));\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.critical(true));\n+        if (testCase.captureErrno()) {\n+            options.add(Linker.Option.captureCallState(\"errno\"));\n+        }\n+        MethodHandle handle = downcallHandle(testCase.fName(), testCase.fDesc(), options.toArray(Linker.Option[]::new));\n@@ -104,1 +113,4 @@\n-            Object[] args = Stream.of(tvs).map(TestValue::value).toArray();\n+            List<Object> args = Stream.of(tvs).map(TestValue::value).collect(Collectors.toCollection(ArrayList::new));\n+            MemorySegment captureSegment = testCase.captureErrno()\n+                    ? MemorySegment.ofArray(new int[((int) CAPTURE_STATE_LAYOUT.byteSize() + 3) \/ 4])\n+                    : null;\n@@ -107,1 +119,1 @@\n-            args[args.length - 1] = (int) sequence.byteSize();\n+            args.set(args.size() - 1, (int) sequence.byteSize());\n@@ -109,2 +121,2 @@\n-            args[args.length - 2] = sourceSegment.value();\n-            args[args.length - 3] = heapSegment;\n+            args.set(args.size() - 2, sourceSegment.value());\n+            args.set(args.size() - 3, heapSegment);\n@@ -112,0 +124,3 @@\n+            if (testCase.captureErrno()) {\n+                args.add(0, captureSegment);\n+            }\n@@ -113,4 +128,1 @@\n-                Object[] newArgs = new Object[args.length + 1];\n-                newArgs[0] = arena;\n-                System.arraycopy(args, 0, newArgs, 1, args.length);\n-                args = newArgs;\n+                args.add(0, arena);\n@@ -120,1 +132,0 @@\n-\n@@ -127,0 +138,5 @@\n+\n+            if (testCase.captureErrno()) {\n+                int errno = (int) ERRNO_HANDLE.get(captureSegment, 0L);\n+                assertEquals(errno, 42);\n+            }\n@@ -152,8 +168,10 @@\n-        for (HeapSegmentFactory hsf : HeapSegmentFactory.values()) {\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_int\", intDesc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_return_buffer\", L2Desc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_imr\", L3Desc, false));\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void_stack\", stackDesc, false));\n-            \/\/ readOnly\n-            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, true));\n+        for (boolean doCapture : new boolean[]{ true, false }) {\n+            for (HeapSegmentFactory hsf : HeapSegmentFactory.values()) {\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_int\", intDesc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_return_buffer\", L2Desc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_imr\", L3Desc, false, doCapture));\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void_stack\", stackDesc, false, doCapture));\n+                \/\/ readOnly\n+                cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, true, doCapture));\n+            }\n","filename":"test\/jdk\/java\/foreign\/critical\/TestCritical.java","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    errno = 42;\n@@ -62,0 +63,1 @@\n+    errno = 42;\n@@ -74,0 +76,1 @@\n+    errno = 42;\n@@ -87,0 +90,1 @@\n+    errno = 42;\n@@ -97,0 +101,1 @@\n+    errno = 42;\n","filename":"test\/jdk\/java\/foreign\/critical\/libCritical.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -81,1 +81,0 @@\n-            \"--enable-preview\",\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessJarManifest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,1 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -54,0 +53,13 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+            expectedExceptionsMessageRegExp = \".*Heap segment not allowed.*\")\n+    public void testNoHeapCaptureCallState() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"test_args\", FunctionDescriptor.ofVoid(ADDRESS),\n+                Linker.Option.captureCallState(\"errno\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            assert Linker.Option.captureStateLayout().byteAlignment() % 4 == 0;\n+            MemorySegment captureHeap = MemorySegment.ofArray(new int[(int) Linker.Option.captureStateLayout().byteSize() \/ 4]);\n+            MemorySegment segment = arena.allocateFrom(C_CHAR, new byte[]{ 0, 1, 2 });\n+            handle.invoke(captureHeap, segment); \/\/ should throw for captureHeap\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,5 @@\n- * @bug 4129479\n- * @summary Test if available would throw an IOException\n- *           when the stream is closed.\n+ * @bug 4129479 8342086\n+ * @summary Test that available throws an IOException if the stream is\n+ *          closed, and that available works correctly with the NUL\n+ *          device on Windows\n+ * @run junit Available\n@@ -31,1 +33,8 @@\n-import java.io.*;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -34,1 +43,2 @@\n-    public static void main(String args[]) throws Exception {\n+    @Test\n+    void throwAfterClose() throws IOException {\n@@ -39,7 +49,10 @@\n-        try {\n-            fis.available();\n-            throw new Exception\n-                (\"available should throw an exception after stream is closed\");\n-        }\n-        catch (IOException e) {\n-        }\n+        assertThrows(IOException.class, () -> fis.available());\n+    }\n+\n+    @Test\n+    @EnabledOnOs(OS.WINDOWS)\n+    void nulDevice() throws IOException {\n+        File file = new File(\"nul\");\n+        FileInputStream fis = new FileInputStream(file);\n+        int n = fis.available();\n+        assertEquals(0, n, \"available() returned non-zero value\");\n","filename":"test\/jdk\/java\/io\/FileInputStream\/Available.java","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @library \/test\/lib\n+ * @bug 8345294\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED Starvation 100000\n+ *\/\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import jdk.test.lib.thread.VThreadPinner;\n+\n+public class Starvation {\n+    public static void main(String[] args) throws Exception {\n+        int iterations = Integer.parseInt(args[0]);\n+\n+        for (int i = 0; i < iterations; i++) {\n+            var exRef = new AtomicReference<Exception>();\n+            Thread thread =  Thread.startVirtualThread(() -> {\n+                try {\n+                    runTest();\n+                } catch (Exception e) {\n+                    exRef.set(e);\n+                }\n+            });\n+            while (!thread.join(Duration.ofSeconds(1))) {\n+                System.out.format(\"%s iteration %d waiting for %s%n\", Instant.now(), i, thread);\n+            }\n+            Exception ex = exRef.get();\n+            if (ex != null) {\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    static void runTest() throws InterruptedException {\n+        int nprocs = Runtime.getRuntime().availableProcessors();\n+\n+        var threads = new ArrayList<Thread>();\n+        Object lock = new Object();\n+        synchronized (lock) {\n+            for (int i = 0; i < nprocs - 1; i++) {\n+                var started = new CountDownLatch(1);\n+                Thread thread = Thread.startVirtualThread(() -> {\n+                    started.countDown();\n+                    VThreadPinner.runPinned(() -> {\n+                        synchronized (lock) {\n+                        }\n+                    });\n+                });\n+                started.await();\n+                threads.add(thread);\n+            }\n+        }\n+\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Starvation.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -49,1 +49,0 @@\n-        Basic.finalized = true;\n@@ -51,0 +50,1 @@\n+        Basic.finalized = true;\n","filename":"test\/jdk\/java\/lang\/ref\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.IDN;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 7038838\n+ * @summary verify the behaviour of the methods on java.net.IDN class\n+ * @run junit IDNTest\n+ *\/\n+public class IDNTest {\n+\n+    \/*\n+     * Verify that various methods on the IDN class throw a NullPointerException\n+     * for any null parameter.\n+     *\/\n+    @Test\n+    public void testNullPointerException() throws Exception {\n+        assertThrows(NullPointerException.class, () -> IDN.toASCII(null));\n+        assertThrows(NullPointerException.class, () -> IDN.toASCII(null, 0));\n+        assertThrows(NullPointerException.class, () -> IDN.toUnicode(null));\n+        assertThrows(NullPointerException.class, () -> IDN.toUnicode(null, 0));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/IDNTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8272215 8315767\n+ * @bug 8272215 8315767 8332686\n@@ -376,1 +376,12 @@\n-                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"040000000000\")\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"040000000000\"),\n+\n+                \/\/ Empty literals\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"\"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"\"),\n+\n+                \/\/ Blank literals\n+                Arguments.of(InetAddressClass.INET_ADDRESS, \"    \"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"    \"),\n+                Arguments.of(InetAddressClass.INET6_ADDRESS, \"    \"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"    \")\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Test Socket.available()\n+ * @summary Test Socket.getInputStream().available()\n@@ -51,0 +51,4 @@\n+    \/*\n+     * Verifies that the Socket.getInputStream().available() throws an IOException\n+     * if invoked after the socket has been closed.\n+     *\/\n@@ -52,24 +56,28 @@\n-        boolean error = true;\n-        InetAddress addr = InetAddress.getLocalHost();\n-        ServerSocket ss = new ServerSocket(0, 0, addr);\n-        int port = ss.getLocalPort();\n-\n-        Thread t = new Thread(new Thread(\"Close-Available-1\") {\n-            public void run() {\n-                try {\n-                    Socket s = new Socket(addr, port);\n-                    s.close();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        });\n-\n-        t.start();\n-\n-        Socket  soc = ss.accept();\n-        ss.close();\n-\n-        DataInputStream is = new DataInputStream(soc.getInputStream());\n-        is.close();\n-\n+        System.out.println(\"testClose\");\n+        final InetAddress addr = InetAddress.getLoopbackAddress();\n+        final Socket acceptedSocket;\n+        try (final ServerSocket ss = new ServerSocket(0, 0, addr)) {\n+            System.out.println(\"created server socket: \" + ss);\n+            final int port = ss.getLocalPort();\n+            \/\/ start a thread which initiates a socket connection to the server\n+            Thread.ofPlatform().name(\"Close-Available-1\")\n+                    .start(() -> {\n+                        try {\n+                            final Socket s = new Socket(addr, port);\n+                            System.out.println(\"created socket: \" + s);\n+                            s.close();\n+                            System.out.println(\"closed socket: \" + s);\n+                        } catch (Exception e) {\n+                            System.err.println(\"exception in \" + Thread.currentThread().getName()\n+                                    + \": \" + e);\n+                            e.printStackTrace();\n+                        }\n+                    });\n+            \/\/ accept the client connect\n+            acceptedSocket = ss.accept();\n+            System.out.println(ss + \" accepted connection \" + acceptedSocket);\n+        } \/\/ (intentionally) close the ServerSocket\n+\n+        final DataInputStream is = new DataInputStream(acceptedSocket.getInputStream());\n+        is.close(); \/\/ close the inputstream and thus the underlying socket\n+        System.out.println(\"closed inputstream of socket: \" + acceptedSocket);\n@@ -77,4 +85,7 @@\n-            is.available();\n-        }\n-        catch (IOException ex) {\n-            error = false;\n+            final int av = is.available();\n+            \/\/ available() was expected to fail but didn't\n+            throw new AssertionError(\"Socket.getInputStream().available() was expected to fail on \"\n+                    + acceptedSocket + \" but returned \" + av);\n+        } catch (IOException ex) {\n+            \/\/ expected IOException\n+            System.out.println(\"received the expected IOException: \" + ex);\n@@ -82,2 +93,0 @@\n-        if (error)\n-            throw new RuntimeException(\"Available() can be called after stream closed.\");\n@@ -86,2 +95,4 @@\n-    \/\/ Verifies consistency of `available` behaviour when EOF reached, both\n-    \/\/ explicitly and implicitly.\n+    \/*\n+     * Verifies consistency of Socket.getInputStream().available() behaviour when EOF reached, both\n+     * explicitly and implicitly.\n+     *\/\n@@ -90,19 +101,35 @@\n-        InetAddress addr = InetAddress.getLoopbackAddress();\n-        ServerSocket ss = new ServerSocket();\n-        ss.bind(new InetSocketAddress(addr, 0), 0);\n-        int port = ss.getLocalPort();\n-\n-        try (Socket s = new Socket(addr, port)) {\n-            s.getOutputStream().write(0x42);\n-            s.shutdownOutput();\n-\n-            try (Socket soc = ss.accept()) {\n-                ss.close();\n-\n-                InputStream is = soc.getInputStream();\n-                int b = is.read();\n-                assert b == 0x42;\n-                assert !s.isClosed();\n-                if (readUntilEOF) {\n-                    b = is.read();\n-                    assert b == -1;\n+        final InetAddress addr = InetAddress.getLoopbackAddress();\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            ss.bind(new InetSocketAddress(addr, 0), 0);\n+            System.out.println(\"server socket bound: \" + ss);\n+            final int port = ss.getLocalPort();\n+            try (final Socket s = new Socket(addr, port)) {\n+                System.out.println(\"created socket: \" + s);\n+                s.getOutputStream().write(0x42);\n+                s.shutdownOutput();\n+\n+                try (final Socket soc = ss.accept()) {\n+                    System.out.println(\"accepted socket: \" + soc);\n+                    ss.close();\n+                    System.out.println(\"closed server socket: \" + ss);\n+\n+                    final InputStream is = soc.getInputStream();\n+                    int b = is.read();\n+                    assert b == 0x42 : \"unexpected byte read: \" + b;\n+                    assert !s.isClosed() : \"socket \" + s + \" is unexpectedly closed\";\n+                    if (readUntilEOF) {\n+                        b = is.read();\n+                        assert b == -1 : \"unexpected number of bytes read: \" + b;\n+                    }\n+\n+                    int a;\n+                    for (int i = 0; i < 100; i++) {\n+                        a = is.available();\n+                        System.out.print(a + \", \");\n+                        if (a != 0) {\n+                            throw new RuntimeException(\"Unexpected non-zero available: \" + a);\n+                        }\n+                    }\n+                    assert !s.isClosed() : \"socket \" + s + \" is unexpectedly closed\";\n+                    final int more = is.read();\n+                    assert more == -1 : \"unexpected byte read: \" + more;\n@@ -110,10 +137,0 @@\n-\n-                int a;\n-                for (int i = 0; i < 100; i++) {\n-                    a = is.available();\n-                    System.out.print(a + \", \");\n-                    if (a != 0)\n-                        throw new RuntimeException(\"Unexpected non-zero available: \" + a);\n-                }\n-                assert !s.isClosed();\n-                assert is.read() == -1;\n@@ -125,2 +142,4 @@\n-    \/\/ Verifies IOException thrown by `available`, on a closed input stream\n-    \/\/ that may, or may not, have reached EOF prior to closure.\n+    \/*\n+     * Verifies IOException thrown by Socket.getInputStream().available(), on a closed input stream\n+     * that may, or may not, have reached EOF prior to closure.\n+     *\/\n@@ -129,26 +148,32 @@\n-        InetAddress addr = InetAddress.getLoopbackAddress();\n-        ServerSocket ss = new ServerSocket();\n-        ss.bind(new InetSocketAddress(addr, 0), 0);\n-        int port = ss.getLocalPort();\n-\n-        try (Socket s = new Socket(addr, port)) {\n-            s.getOutputStream().write(0x43);\n-            s.shutdownOutput();\n-\n-            try (Socket soc = ss.accept()) {\n-                ss.close();\n-\n-                InputStream is = soc.getInputStream();\n-                int b = is.read();\n-                assert b == 0x43;\n-                assert !s.isClosed();\n-                if (readUntilEOF) {\n-                    b = is.read();\n-                    assert b == -1;\n-                }\n-                is.close();\n-                try {\n-                    b = is.available();\n-                    throw new RuntimeException(\"UNEXPECTED successful read: \" + b);\n-                } catch (IOException expected) {\n-                    System.out.println(\"caught expected IOException:\" + expected);\n+        final InetAddress addr = InetAddress.getLoopbackAddress();\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            ss.bind(new InetSocketAddress(addr, 0), 0);\n+            System.out.println(\"server socket bound: \" + ss);\n+            final int port = ss.getLocalPort();\n+\n+            try (final Socket s = new Socket(addr, port)) {\n+                System.out.println(\"created socket: \" + s);\n+                s.getOutputStream().write(0x43);\n+                s.shutdownOutput();\n+\n+                try (final Socket soc = ss.accept()) {\n+                    System.out.println(\"accepted socket: \" + soc);\n+                    ss.close();\n+                    System.out.println(\"closed server socket: \" + ss);\n+\n+                    final InputStream is = soc.getInputStream();\n+                    int b = is.read();\n+                    assert b == 0x43 : \"unexpected byte read: \" + b;\n+                    assert !s.isClosed() : \"socket \" + s + \" is unexpectedly closed\";\n+                    if (readUntilEOF) {\n+                        b = is.read();\n+                        assert b == -1 : \"unexpected byte read: \" + b;\n+                    }\n+                    is.close();\n+                    System.out.println(\"closed inputstream of socket: \" + soc);\n+                    try {\n+                        b = is.available();\n+                        throw new RuntimeException(\"UNEXPECTED successful read: \" + b);\n+                    } catch (IOException expected) {\n+                        System.out.println(\"caught expected IOException:\" + expected);\n+                    }\n","filename":"test\/jdk\/java\/net\/Socket\/CloseAvailable.java","additions":116,"deletions":91,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.nio.channels.SocketChannel;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8343791\n+ * @summary verifies that `connect()` failures throw the expected exception and leave socket in the expected state\n+ * @library \/test\/lib\n+ * @run junit ConnectFailTest\n+ *\/\n+class ConnectFailTest {\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    @Test\n+    void testUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    \/**\n+     * Verifies that an unbound socket is closed when {@code connect()} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testUnboundSocket(Socket socket) throws IOException {\n+        try (socket) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a bound socket is closed when {@code connect()} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testBoundSocket(Socket socket) throws IOException {\n+        try (socket) {\n+            socket.bind(new InetSocketAddress(0));\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testConnectedSocket(Socket socket) throws Throwable {\n+        try (socket; ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+                assertEquals(\"Already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that an unbound socket is closed when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testUnboundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(UnknownHostException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a bound socket is closed when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testBoundSocketWithUnresolvedAddress(Socket socket) throws IOException {\n+        try (socket) {\n+            socket.bind(new InetSocketAddress(0));\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(UnknownHostException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"sockets\")\n+    void testConnectedSocketWithUnresolvedAddress(Socket socket) throws Throwable {\n+        try (socket; ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertThrows(IOException.class, () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    static List<Socket> sockets() throws Exception {\n+        Socket socket = new Socket();\n+        @SuppressWarnings(\"resource\")\n+        Socket channelSocket = SocketChannel.open().socket();\n+        return List.of(socket, channelSocket);\n+    }\n+\n+    private static ServerSocket createEphemeralServerSocket() throws IOException {\n+        return new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketImpl;\n+import java.net.SocketImplFactory;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @summary verifies that the socket is closed on constructor failures\n+ * @modules java.base\/java.net:+open\n+ * @run junit CtorFailTest\n+ *\/\n+class CtorFailTest {\n+\n+    private static final VarHandle SOCKET_IMPL_FACTORY_HANDLE = createSocketImplFactoryHandle();\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static VarHandle createSocketImplFactoryHandle() {\n+        try {\n+            Field field = Socket.class.getDeclaredField(\"factory\");\n+            field.setAccessible(true);\n+            return MethodHandles\n+                    .privateLookupIn(Socket.class, MethodHandles.lookup())\n+                    .findStaticVarHandle(Socket.class, \"factory\", SocketImplFactory.class);\n+        } catch (NoSuchFieldException | IllegalAccessException exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static void withSocketImplFactory(SocketImplFactory newFactory, Executable executable) throws Throwable {\n+        SocketImplFactory oldFactory = (SocketImplFactory) SOCKET_IMPL_FACTORY_HANDLE.getAndSet(newFactory);\n+        try {\n+            executable.execute();\n+        } finally {\n+            SOCKET_IMPL_FACTORY_HANDLE.set(oldFactory);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"socketImpls\")\n+    @SuppressWarnings(\"resource\")\n+    void test(MockSocketImpl socketImpl) throws Throwable {\n+        withSocketImplFactory(() -> socketImpl, () -> {\n+\n+            \/\/ Trigger the failure\n+            Exception caughtException = assertThrows(Exception.class, () -> {\n+                \/\/ Address and port are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the point where both `SocketImpl#bind()` and `SocketImpl#connect()` are invoked.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                InetAddress serverAddress = InetAddress.getLoopbackAddress();\n+                new Socket(serverAddress, DEAD_SERVER_PORT, null, 0);\n+            });\n+\n+            \/\/ Run verifications\n+            Exception expectedException = socketImpl.bindException != null\n+                    ? socketImpl.bindException\n+                    : socketImpl.connectException;\n+            assertSame(expectedException, caughtException);\n+            assertEquals(1, socketImpl.closeInvocationCounter.get());\n+\n+        });\n+    }\n+\n+    static List<MockSocketImpl> socketImpls() {\n+        String exceptionMessage = \"intentional test failure\";\n+        IOException checkedException = new IOException(exceptionMessage);\n+        IllegalArgumentException uncheckedException = new IllegalArgumentException(exceptionMessage);\n+        return List.of(\n+                new MockSocketImpl(checkedException, null),\n+                new MockSocketImpl(null, checkedException),\n+                new MockSocketImpl(uncheckedException, null),\n+                new MockSocketImpl(null, uncheckedException));\n+    }\n+\n+    private static final class MockSocketImpl extends SocketImpl {\n+\n+        private final AtomicInteger closeInvocationCounter = new AtomicInteger(0);\n+\n+        private final Exception bindException;\n+\n+        private final Exception connectException;\n+\n+        private MockSocketImpl(Exception bindException, Exception connectException) {\n+            this.bindException = bindException;\n+            this.connectException = connectException;\n+        }\n+\n+        @Override\n+        protected void create(boolean stream) {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        protected void bind(InetAddress host, int port) throws IOException {\n+            throwIfPresent(bindException);\n+        }\n+\n+        @Override\n+        protected void connect(SocketAddress address, int timeoutMillis) throws IOException {\n+            throwIfPresent(connectException);\n+        }\n+\n+        private void throwIfPresent(Exception exception) throws IOException {\n+            if (exception != null) {\n+                switch (exception) {\n+                    case IOException error -> throw error;\n+                    case RuntimeException error -> throw error;\n+                    default -> throw new IllegalStateException(\n+                            \"unknown exception type: \" + exception.getClass().getCanonicalName());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            record MockSocket(Exception bindException, Exception connectException, int closeInvocationCounter) {}\n+            return new MockSocket(bindException, connectException, closeInvocationCounter.get()).toString();\n+        }\n+\n+        \/\/ Rest of the `SocketImpl` methods should not be used, hence overriding them to throw `UOE`\n+\n+        @Override\n+        protected void close() {\n+            closeInvocationCounter.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void connect(String host, int port) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void connect(InetAddress address, int port) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void listen(int backlog) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void accept(SocketImpl impl) {\n+            throw new UnsupportedOperationException();\n+\n+        }\n+\n+        @Override\n+        protected InputStream getInputStream() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected OutputStream getOutputStream() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected int available() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void sendUrgentData(int data) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setOption(int optID, Object value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Object getOption(int optID) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CtorFailTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,9 +73,3 @@\n-        AccessController.doPrivileged(new PrivilegedAction() {\n-            public Object run() {\n-                put(\"KeyStore.Pre15KeyStore\", \"EntryMethods$Pre15\");\n-                put(\"KeyStore.Post15KeyStore\", \"EntryMethods$Post15\");\n-                put(\"KeyStore.UnrecoverableKeyStore\",\n-                                        \"EntryMethods$UnrecoverableKS\");\n-                return null;\n-            }\n-        });\n+        put(\"KeyStore.Pre15KeyStore\", \"EntryMethods$Pre15\");\n+        put(\"KeyStore.Post15KeyStore\", \"EntryMethods$Post15\");\n+        put(\"KeyStore.UnrecoverableKeyStore\", \"EntryMethods$UnrecoverableKS\");\n","filename":"test\/jdk\/java\/security\/KeyStore\/EntryMethods.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      8327631 8332424 8334418\n+ *      8327631 8332424 8334418 8344589\n@@ -30,1 +30,1 @@\n- *          (LSR Revision: 2024-06-14) with Locale and Locale.LanguageRange\n+ *          (LSR Revision: 2024-11-19) with Locale and Locale.LanguageRange\n","filename":"test\/jdk\/java\/util\/Locale\/LanguageSubtagRegistryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.StampedLock;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * @test\n+ * @bug 8066859\n+ * @summary An adaptation of OOMEInAQS test for StampedLocks\n+ * @requires vm.gc.G1\n+ * @run main\/othervm -XX:+UseG1GC -XX:-UseGCOverheadLimit -Xmx48M -XX:-UseTLAB OOMEInStampedLock\n+ *\/\n+\n+public class OOMEInStampedLock extends Thread {\n+    static final int NTHREADS = 3;\n+    static final int NREPS = 100;\n+    \/\/ statically allocate\n+    static final StampedLock stampedLock = new StampedLock();\n+    static final Lock wLock = stampedLock.asWriteLock();\n+    static final Lock rLock = stampedLock.asReadLock();\n+    static final CountDownLatch started = new CountDownLatch(1);\n+    static final CountDownLatch filled = new CountDownLatch(1);\n+    static final CountDownLatch canFill = new CountDownLatch(NTHREADS);\n+    static volatile Object data;\n+    static volatile Throwable exception;\n+    static int turn;\n+\n+    \/**\n+     * For each of NTHREADS threads, REPS times: Take turns\n+     * executing. Introduce OOM using fillHeap during runs. In\n+     * addition to testing AQS, the CountDownLatches ensure that\n+     * methods execute at least once before OutOfMemory occurs, to\n+     * avoid uncontrollable impact of OOME during class-loading.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        OOMEInStampedLock[] threads = new OOMEInStampedLock[NTHREADS];\n+        for (int i = 0; i < NTHREADS; ++i)\n+            (threads[i] = new OOMEInStampedLock(i)).start();\n+        started.countDown();\n+        canFill.await();\n+        long t0 = System.nanoTime();\n+        data = fillHeap();\n+        filled.countDown();\n+        long t1 = System.nanoTime();\n+        for (int i = 0; i < NTHREADS; ++i)\n+            threads[i].join();\n+        data = null;  \/\/ free heap before reporting and terminating\n+        System.gc();\n+        Throwable ex = exception;\n+        if (ex != null)\n+            throw ex;\n+        System.out.println(\n+            \"fillHeap time: \" + (t1 - t0) \/ 1000_000 +\n+            \" millis, whole test time: \" + (System.nanoTime() - t0) \/ 1000_000 +\n+            \" millis\"\n+        );\n+    }\n+\n+    final int tid;\n+    OOMEInStampedLock(int tid) {\n+        this.tid = tid;\n+    }\n+\n+    @Override\n+    public void run() {\n+        int id = tid, nextId = (id + 1) % NTHREADS;\n+        final Lock wl = wLock, rl = rLock;\n+        try {\n+            started.await();\n+            for (int i = 0; i < NREPS; i++) {\n+                int t;\n+                rl.lock(); t = turn; rl.unlock();\n+                wl.lock();\n+                try {\n+                    if (turn == t && turn == id)\n+                        turn = nextId;\n+                } finally {\n+                    wl.unlock();\n+                }\n+                if (i == 2) {  \/\/ Subsequent AQS methods encounter OOME\n+                    canFill.countDown();\n+                    filled.await();\n+                }\n+            }\n+            data = null;\n+            System.gc(); \/\/ avoid getting stuck while exiting\n+        } catch (Throwable ex) {\n+            data = null;\n+            System.gc(); \/\/ avoid nested OOME\n+            exception = ex;\n+        }\n+    }\n+\n+    static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/StampedLock\/OOMEInStampedLock.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import javax.naming.Context;\n-import javax.naming.InitialContext;\n-import javax.naming.NamingException;\n-import javax.naming.NoInitialContextException;\n-import java.util.Hashtable;\n-\n-\/*\n- * @test\n- * @bug 8051422\n- * @summary Make sure java.applet.Applet is not used as a source of\n- *          configuration parameters for an InitialContext\n- *\/\n-public class AppletIsNotUsed {\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static void main(String[] args) throws NamingException {\n-\n-        testWith(Context.APPLET);\n-        testWith(\"java.naming.applet\");\n-\n-    }\n-\n-    private static void testWith(String appletProperty) throws NamingException {\n-        Hashtable<Object, Object> env = new Hashtable<>();\n-        \/\/ Deliberately put java.lang.Object rather than java.applet.Applet\n-        \/\/ if an applet was used we would see a ClassCastException down there\n-        env.put(appletProperty, new Object());\n-        \/\/ It's ok to instantiate InitialContext with no parameters\n-        \/\/ and be unaware of it right until you try to use it\n-        Context ctx = new InitialContext(env);\n-        boolean threw = true;\n-        try {\n-            ctx.lookup(\"whatever\");\n-            threw = false;\n-        } catch (NoInitialContextException e) {\n-            String m = e.getMessage();\n-            if (m == null || m.contains(\"applet\"))\n-                throw new RuntimeException(\"The exception message is incorrect\", e);\n-        } catch (Throwable t) {\n-            throw new RuntimeException(\n-                    \"The test was supposed to catch NoInitialContextException\" +\n-                            \" here, but caught: \" + t.getClass().getName(), t);\n-        } finally {\n-            ctx.close();\n-        }\n-\n-        if (!threw)\n-            throw new RuntimeException(\"The test was supposed to catch NoInitialContextException here\");\n-    }\n-}\n","filename":"test\/jdk\/javax\/naming\/InitialContext\/AppletIsNotUsed.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8004502\n- * @summary Sanity check that specifying the APPLET property when creating an\n- *   InitialContext behaves as expected when java.awt.Applet is not present\n- *\/\n-\n-import javax.naming.*;\n-import java.util.Hashtable;\n-\n-public class NoApplet {\n-    @SuppressWarnings(\"deprecation\")\n-    public static void main(String[] args) throws NamingException {\n-        Hashtable<Object,Object> env = new Hashtable<>();\n-        env.put(Context.APPLET, new Object());\n-        Context ctxt = new InitialContext(env);\n-        ctxt.close();\n-    }\n-}\n","filename":"test\/jdk\/javax\/naming\/InitialContext\/NoApplet.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n- * @author Alexander Scherbatiy\n@@ -44,0 +43,1 @@\n+\n@@ -94,0 +94,1 @@\n+        robot.delay(1000);\n","filename":"test\/jdk\/javax\/swing\/Action\/8133039\/bug8133039.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import java.awt.AWTException;\n-import java.awt.BorderLayout;\n-import java.awt.EventQueue;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.event.InputEvent;\n-import java.awt.event.MouseAdapter;\n-import java.awt.event.MouseEvent;\n-import javax.swing.JButton;\n-import javax.swing.JFrame;\n-import javax.swing.SwingUtilities;\n-\n-\/*\n- * @test\n- * @key headful\n- * @bug  8049069\n- * @summary Tests whether right mouse click releases a pressed JButton\n- *\/\n-\n-public class PressedButtonRightClickTest {\n-\n-    private static Robot testRobot;\n-    private static JFrame myFrame;\n-    private static JButton myButton;\n-\n-    public static void main(String[] args) throws Throwable {\n-\n-        SwingUtilities.invokeAndWait(PressedButtonRightClickTest::constructTestUI);\n-\n-        try {\n-            testRobot = new Robot();\n-        } catch (AWTException ex) {\n-            throw new RuntimeException(\"Exception in Robot creation\");\n-        }\n-\n-        testRobot.waitForIdle();\n-        testRobot.delay(500);\n-\n-        \/\/ Method performing auto test operation\n-        try {\n-            test();\n-        } finally {\n-            EventQueue.invokeAndWait(PressedButtonRightClickTest::disposeTestUI);\n-        }\n-    }\n-\n-    private static void test() {\n-        Point loc = myFrame.getLocationOnScreen();\n-\n-        testRobot.mouseMove((loc.x + 100), (loc.y + 100));\n-\n-        \/\/ Press the left mouse button\n-        System.out.println(\"press BUTTON1_DOWN_MASK\");\n-        testRobot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        myButton.setText(\"Left button pressed\");\n-        testRobot.delay(500);\n-\n-        \/\/ Press the right mouse button\n-        System.out.println(\"press BUTTON3_DOWN_MASK\");\n-        testRobot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n-        myButton.setText(\"Left button pressed + Right button pressed\");\n-        testRobot.delay(500);\n-\n-        \/\/ Release the right mouse button\n-        System.out.println(\"release BUTTON3_DOWN_MASK\");\n-        testRobot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n-        myButton.setText(\"Right button released\");\n-        testRobot.waitForIdle();\n-        testRobot.delay(500);\n-\n-        \/\/ Test whether the button is still pressed\n-        boolean pressed = myButton.getModel().isPressed();\n-        System.out.println(\"release BUTTON1_DOWN_MASK\");\n-        testRobot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-        if (!pressed) {\n-            disposeTestUI();\n-            throw new RuntimeException(\"Test Failed!\");\n-        }\n-    }\n-\n-    private static void disposeTestUI() {\n-        myFrame.setVisible(false);\n-        myFrame.dispose();\n-    }\n-\n-    public static void constructTestUI() {\n-        myFrame = new JFrame();\n-        myFrame.setLayout(new BorderLayout());\n-        myButton = new JButton(\"Whatever\");\n-        myButton.addMouseListener(new MouseAdapter() {\n-            @Override\n-            public void mouseClicked(MouseEvent e) {\n-                System.out.println(e);\n-            }\n-\n-            @Override\n-            public void mousePressed(MouseEvent e) {\n-                System.out.println(e);\n-            }\n-\n-            @Override\n-            public void mouseReleased(MouseEvent e) {\n-                System.out.println(e);\n-            }\n-\n-            @Override\n-            public void mouseEntered(MouseEvent e) {\n-                System.out.println(e);\n-            }\n-\n-            @Override\n-            public void mouseExited(MouseEvent e) {\n-                System.out.println(e);\n-            }\n-        });\n-        myFrame.add(myButton, BorderLayout.CENTER);\n-        myFrame.setSize(400, 300);\n-        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n-        myFrame.setLocationRelativeTo(null);\n-        myFrame.setVisible(true);\n-    }\n-}\n-\n","filename":"test\/jdk\/javax\/swing\/JButton\/PressedButtonRightClickTest.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @summary Tests whether any button that extends JButton always\n-            returns true for isArmed()\n+ * @summary Tests whether a button model always returns true for isArmed()\n+ *          when mouse hovers over the button\n@@ -33,1 +33,0 @@\n-import java.awt.Graphics;\n@@ -36,0 +35,1 @@\n+import java.awt.event.MouseAdapter;\n@@ -37,2 +37,2 @@\n-import java.awt.event.MouseListener;\n-import java.awt.event.MouseMotionListener;\n+import java.util.concurrent.CountDownLatch;\n+\n@@ -43,1 +43,3 @@\n-public class bug4323121 {\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class bug4323121 {\n@@ -46,5 +48,8 @@\n-    static testButton button;\n-    static volatile Point pt;\n-    static volatile int buttonW;\n-    static volatile int buttonH;\n-    static volatile boolean failed = false;\n+    static JButton button;\n+\n+    static volatile Point buttonCenter;\n+\n+    private static final CountDownLatch mouseEntered = new CountDownLatch(1);\n+\n+    \/\/ Usage of this flag is thread-safe because of using the mouseEntered latch\n+    private static boolean modelArmed;\n@@ -55,0 +60,1 @@\n+\n@@ -57,0 +63,11 @@\n+                button = new JButton(\"gotcha\");\n+                button.addMouseListener(new MouseAdapter() {\n+                    @Override\n+                    public void mouseEntered(MouseEvent e) {\n+                        if (button.getModel().isArmed()) {\n+                            modelArmed = true;\n+                        }\n+                        mouseEntered.countDown();\n+                    }\n+                });\n+\n@@ -58,1 +75,0 @@\n-                button = new testButton(\"gotcha\");\n@@ -60,0 +76,1 @@\n+\n@@ -65,0 +82,1 @@\n+\n@@ -66,1 +84,1 @@\n-            robot.delay(1000);\n+\n@@ -68,3 +86,3 @@\n-                pt = button.getLocationOnScreen();\n-                buttonW = button.getSize().width;\n-                buttonH = button.getSize().height;\n+                Point location = button.getLocationOnScreen();\n+                buttonCenter = new Point(location.x + button.getWidth() \/ 2,\n+                                         location.y + button.getHeight() \/ 2);\n@@ -72,5 +90,9 @@\n-            robot.mouseMove(pt.x + buttonW \/ 2, pt.y + buttonH \/ 2);\n-            robot.waitForIdle();\n-            if (failed) {\n-                throw new RuntimeException(\"Any created button returns \" +\n-                                    \"true for isArmed()\");\n+\n+            robot.mouseMove(buttonCenter.x, buttonCenter.y);\n+\n+            if (!mouseEntered.await(1, SECONDS)) {\n+                throw new RuntimeException(\"Mouse entered event wasn't received\");\n+            }\n+            if (modelArmed) {\n+                throw new RuntimeException(\"getModel().isArmed() returns true \"\n+                                           + \"when mouse hovers over the button\");\n@@ -79,1 +101,1 @@\n-                SwingUtilities.invokeAndWait(() -> {\n+            SwingUtilities.invokeAndWait(() -> {\n@@ -87,38 +109,0 @@\n-    static class testButton extends JButton implements MouseMotionListener, MouseListener {\n-        public testButton(String label) {\n-            super(label);\n-            addMouseMotionListener(this);\n-            addMouseListener(this);\n-        }\n-\n-        protected void paintComponent(Graphics g) {\n-            super.paintComponent(g);\n-        }\n-\n-        protected void paintBorder(Graphics g) {\n-        }\n-\n-        public void mousePressed(MouseEvent e) {\n-        }\n-\n-        public void mouseDragged(MouseEvent e) {\n-        }\n-\n-        public void mouseMoved(MouseEvent e) {\n-        }\n-\n-        public void mouseReleased(MouseEvent e) {\n-        }\n-\n-        public void mouseEntered(MouseEvent e) {\n-            if (getModel().isArmed()) {\n-                failed = true;\n-            }\n-        }\n-\n-        public void mouseExited(MouseEvent e) {\n-        }\n-\n-        public void mouseClicked(MouseEvent e) {\n-        }\n-    }\n","filename":"test\/jdk\/javax\/swing\/JButton\/bug4323121.java","additions":45,"deletions":61,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4490179\n+ * @bug 4490179 8049069\n","filename":"test\/jdk\/javax\/swing\/JButton\/bug4490179.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    private static Point p = null;\n-    private static Dimension d;\n+    private static volatile Point p = null;\n+    private static volatile Dimension d;\n@@ -87,1 +87,1 @@\n-        frame = new JFrame();\n+        frame = new JFrame(\"bug6559152\");\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/6559152\/bug6559152.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-        PassFailJFrame.addTestWindow(testFrame);\n@@ -130,1 +129,0 @@\n-        PassFailJFrame.addTestWindow(testDialog);\n","filename":"test\/jdk\/javax\/swing\/JFrame\/DefaultCloseOperation.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+\n@@ -60,2 +61,2 @@\n-                changeLAF();\n-                createAndShowGUI();\n+            changeLAF();\n+            createAndShowGUI();\n@@ -65,3 +66,0 @@\n-        Thread.sleep(100);\n-        robot.waitForIdle();\n-\n@@ -69,0 +67,2 @@\n+        robot.waitForIdle();\n+        robot.delay(1000);\n@@ -72,0 +72,1 @@\n+        robot.delay(100);\n@@ -75,0 +76,1 @@\n+        robot.delay(100);\n@@ -78,0 +80,1 @@\n+        robot.delay(100);\n@@ -81,0 +84,1 @@\n+        robot.delay(100);\n@@ -84,0 +88,1 @@\n+        robot.delay(100);\n@@ -87,0 +92,1 @@\n+        robot.delay(100);\n@@ -90,0 +96,1 @@\n+        robot.delay(100);\n@@ -93,0 +100,1 @@\n+        robot.delay(100);\n@@ -96,0 +104,1 @@\n+        robot.delay(100);\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/8033699\/bug8033699.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-            Thread.sleep(100);\n@@ -56,1 +55,1 @@\n-\n+            robot.delay(1000);\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/8075609\/bug8075609.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @author Andrey Pikalev\n@@ -33,4 +32,8 @@\n-import javax.swing.*;\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.*;\n+import java.awt.Dimension;\n+import java.awt.Robot;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.SwingUtilities;\n+import java.awt.event.MouseEvent;\n+\n+import java.util.Date;\n@@ -46,6 +49,1 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-\n-                public void run() {\n-                    createAndShowGUI();\n-                }\n-            });\n+            SwingUtilities.invokeAndWait(() -> createAndShowGUI());\n@@ -54,0 +52,1 @@\n+            robot.delay(1000);\n@@ -55,7 +54,1 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-\n-                @Override\n-                public void run() {\n-                    sbar.pressMouse();\n-                }\n-            });\n+            SwingUtilities.invokeAndWait(() -> sbar.pressMouse());\n@@ -64,0 +57,1 @@\n+            robot.delay(200);\n@@ -65,4 +59,2 @@\n-            int value = getValue();\n-\n-            if (value != 9) {\n-                throw new Error(\"The scrollbar block increment is incorect\");\n+            if (getValue() != 9) {\n+                throw new RuntimeException(\"The scrollbar block increment is incorrect\");\n@@ -78,5 +70,2 @@\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            @Override\n-            public void run() {\n-                result[0] = sbar.getValue();\n-            }\n+        SwingUtilities.invokeAndWait(() -> {\n+            result[0] = sbar.getValue();\n@@ -98,0 +87,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -99,1 +89,1 @@\n-\n+        frame.toFront();\n@@ -114,1 +104,1 @@\n-                    MouseEvent.BUTTON1_MASK,\n+                    MouseEvent.BUTTON1_DOWN_MASK,\n","filename":"test\/jdk\/javax\/swing\/JScrollBar\/4865918\/bug4865918.java","additions":20,"deletions":30,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import javax.swing.plaf.basic.BasicToolBarUI;\n@@ -48,1 +49,1 @@\n-        frame = new JFrame();\n+        frame = new JFrame(\"bug4529206\");\n@@ -67,1 +68,1 @@\n-        javax.swing.plaf.basic.BasicToolBarUI ui = (javax.swing.plaf.basic.BasicToolBarUI) jToolBar1.getUI();\n+        BasicToolBarUI ui = (BasicToolBarUI) jToolBar1.getUI();\n@@ -82,1 +83,1 @@\n-            robot.setAutoWaitForIdle(true);\n+            robot.waitForIdle();\n@@ -86,0 +87,1 @@\n+            robot.waitForIdle();\n@@ -90,2 +92,2 @@\n-                    throw\n-                      new RuntimeException(\"setFloating does not work correctly\");\n+                    throw new RuntimeException(\n+                        \"setFloating does not work correctly\");\n","filename":"test\/jdk\/javax\/swing\/JToolBar\/4529206\/bug4529206.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @author Anton Nashatyrev\n@@ -35,3 +34,9 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.InputEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n@@ -39,1 +44,1 @@\n-public class bug4278839 extends JFrame {\n+public class bug4278839 {\n@@ -50,1 +55,1 @@\n-            robo.setAutoDelay(200);\n+            robo.setAutoDelay(100);\n@@ -52,6 +57,1 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-                @Override\n-                public void run() {\n-                    createAndShowGUI();\n-                }\n-            });\n+            SwingUtilities.invokeAndWait(() -> createAndShowGUI());\n@@ -60,0 +60,1 @@\n+            robo.delay(1000);\n@@ -103,6 +104,2 @@\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-\n-            @Override\n-            public void run() {\n-                result[0] = area.getCaretPosition();\n-            }\n+        SwingUtilities.invokeAndWait(() -> {\n+            result[0] = area.getCaretPosition();\n@@ -111,2 +108,1 @@\n-        int pos = result[0];\n-        return pos;\n+        return result[0];\n@@ -118,5 +114,2 @@\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            @Override\n-            public void run() {\n-                result[0] = new Rectangle(area.getLocationOnScreen(), area.getSize());\n-            }\n+        SwingUtilities.invokeAndWait(() -> {\n+            result[0] = new Rectangle(area.getLocationOnScreen(), area.getSize());\n@@ -128,2 +121,4 @@\n-        robo.mousePress(InputEvent.BUTTON1_MASK);\n-        robo.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robo.waitForIdle();\n+        robo.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robo.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robo.waitForIdle();\n","filename":"test\/jdk\/javax\/swing\/text\/DefaultEditorKit\/4278839\/bug4278839.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8032908 8081392\n+ * @bug 8032908 8081392 8343001\n@@ -31,1 +31,1 @@\n- * @run main\/othervm XSLT\n+ * @run main\/othervm -Djdk.xml.enableExtensionFunctions=true XSLT\n","filename":"test\/jdk\/javax\/xml\/jaxp\/common\/8032908\/XSLT.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8024707\n+ * @bug 8024707 8343001\n@@ -29,1 +29,1 @@\n- * @run main\/othervm XSLT\n+ * @run main\/othervm -Djdk.xml.enableExtensionFunctions=true XSLT\n","filename":"test\/jdk\/javax\/xml\/jaxp\/parsers\/8024707\/XSLT.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 8004476\n+ * @bug 8004476 8343001\n@@ -80,1 +80,1 @@\n-     * by default, extension function is enabled\n+     * As of JDK-8343001, extension function is disabled by default.\n@@ -87,1 +87,0 @@\n-            System.out.println(\"testExtFunc: OK\");\n@@ -91,1 +90,2 @@\n-            fail(ex.getMessage());\n+            \/\/expected since extension function is disallowed\n+            System.out.println(\"testExtFunc: OK\");\n","filename":"test\/jdk\/javax\/xml\/jaxp\/transform\/8004476\/XSLTExFuncTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-import java.lang.classfile.components.ClassRemapper;\n-import java.lang.classfile.components.CodeLocalsShifter;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n@@ -62,1 +62,1 @@\n-import java.lang.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.components.CodeRelabeler;\n@@ -64,1 +64,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.ClassRemapper;\n","filename":"test\/jdk\/jdk\/classfile\/ClassBuildingTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.ArrayList;\n@@ -44,1 +45,1 @@\n-        \"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/snippet-files\/PackageSnippets.java\"})\n+        \"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java\"})\n@@ -55,3 +56,8 @@\n-                    var task = compiler.getTask(null, fileManager, null, List.of(\n-                            \"--enable-preview\",\n-                            \"--source\", String.valueOf(Runtime.version().feature())),\n+                    List<String> flags = List.of(\n+                            \"--source\", String.valueOf(Runtime.version().feature()));\n+                    if (source.contains(\"jdk\/internal\/classfile\/components\")) {\n+                        flags = new ArrayList<>(flags);\n+                        flags.add(\"--add-exports\");\n+                        flags.add(\"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\");\n+                    }\n+                    var task = compiler.getTask(null, fileManager, null, flags,\n","filename":"test\/jdk\/jdk\/classfile\/SnippetsTest.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.classfile.components.CodeStackTracker;\n+import jdk.internal.classfile.components.CodeStackTracker;\n","filename":"test\/jdk\/jdk\/classfile\/StackTrackerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+    java.base\/jdk.internal.classfile.components \\\n","filename":"test\/jdk\/jdk\/classfile\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n","filename":"test\/jdk\/jdk\/classfile\/examples\/AnnotationsExamples.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.classfile.components.CodeStackTracker;\n+import jdk.internal.classfile.components.CodeStackTracker;\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.ByteArrayInputStream;\n@@ -46,1 +45,1 @@\n-import java.lang.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.ClassRemapper;\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+\n+import jdk.internal.loader.Resource;\n+import jdk.internal.loader.URLClassPath;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assumptions.abort;\n+\n+\/*\n+ * @test\n+ * @bug 8344908\n+ * @summary verify that when locating resources, the URLClassPath can function properly\n+ *          without throwing unexpected exceptions when any URL in the classpath is unusable\n+ * @modules java.base\/jdk.internal.loader\n+ * @run junit ClassPathUnusableURLs\n+ *\/\n+public class ClassPathUnusableURLs {\n+\n+    private static final Path SCRATCH_DIR = Path.of(\".\").normalize();\n+    private static final String RESOURCE_NAME = \"foo.txt\";\n+    private static final String SMILEY_EMOJI = \"\\uD83D\\uDE00\";\n+\n+    private static Path ASCII_DIR;\n+    private static Path EMOJI_DIR;\n+    private static Path JAR_FILE_IN_EMOJI_DIR;\n+    private static int NUM_EXPECTED_LOCATED_RESOURCES;\n+\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        try {\n+            EMOJI_DIR = Files.createTempDirectory(SCRATCH_DIR, SMILEY_EMOJI);\n+        } catch (IllegalArgumentException iae) {\n+            iae.printStackTrace(); \/\/ for debug purpose\n+            \/\/ if we can't create a directory with an emoji in its path name,\n+            \/\/ then skip the entire test\n+            abort(\"Skipping test since emoji directory couldn't be created: \" + iae);\n+        }\n+        \/\/ successful creation of the dir, continue with the test\n+        Files.createFile(EMOJI_DIR.resolve(RESOURCE_NAME));\n+\n+        ASCII_DIR = Files.createTempDirectory(SCRATCH_DIR, \"test-urlclasspath\");\n+        Files.createFile(ASCII_DIR.resolve(RESOURCE_NAME));\n+\n+        \/\/ create a jar file containing the resource\n+        JAR_FILE_IN_EMOJI_DIR = Files.createTempDirectory(SCRATCH_DIR, SMILEY_EMOJI)\n+                .resolve(\"foo.jar\");\n+        final Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().putValue(\"Manifest-Version\", \"1.0\");\n+        try (OutputStream fos = Files.newOutputStream(JAR_FILE_IN_EMOJI_DIR);\n+             JarOutputStream jos = new JarOutputStream(fos, manifest)) {\n+\n+            final JarEntry jarEntry = new JarEntry(RESOURCE_NAME);\n+            jos.putNextEntry(jarEntry);\n+            jos.write(\"hello\".getBytes(US_ASCII));\n+            jos.closeEntry();\n+        }\n+        \/\/ Even if the resource is present in more than one classpath element,\n+        \/\/ we expect it to be found by the URLClassPath only in the path which has just ascii\n+        \/\/ characters. URLClassPath currently doesn't have the ability to serve resources\n+        \/\/ from paths containing emoji character(s).\n+        NUM_EXPECTED_LOCATED_RESOURCES = 1;\n+    }\n+\n+    \/**\n+     * Constructs a URLClassPath and then exercises the URLClassPath.findResource()\n+     * and URLClassPath.findResources() methods and expects them to return the expected\n+     * resources.\n+     *\/\n+    @Test\n+    void testFindResource() {\n+        \/\/ start an empty URL classpath\n+        final URLClassPath urlc = new URLClassPath(new URL[0]);\n+        final String[] classpathElements = getClassPathElements();\n+        try {\n+            \/\/ use addFile() to construct classpath\n+            for (final String path : classpathElements) {\n+                urlc.addFile(path);\n+            }\n+            \/\/ findResource()\n+            assertNotNull(urlc.findResource(RESOURCE_NAME), \"findResource() failed to locate\"\n+                    + \" resource: \" + RESOURCE_NAME + \" in classpath: \"\n+                    + Arrays.toString(classpathElements));\n+            \/\/ findResources()\n+            final Enumeration<URL> locatedResources = urlc.findResources(RESOURCE_NAME);\n+            assertNotNull(locatedResources, \"findResources() failed to\"\n+                    + \" locate resource: \" + RESOURCE_NAME + \" in classpath: \"\n+                    + Arrays.toString(classpathElements));\n+            int numFound = 0;\n+            while (locatedResources.hasMoreElements()) {\n+                System.out.println(\"located \" + locatedResources.nextElement()\n+                        + \" for resource \" + RESOURCE_NAME);\n+                numFound++;\n+            }\n+            assertEquals(NUM_EXPECTED_LOCATED_RESOURCES, numFound,\n+                    \"unexpected number of resources located for \" + RESOURCE_NAME);\n+        } finally {\n+            urlc.closeLoaders();\n+        }\n+    }\n+\n+    \/**\n+     * Constructs a URLClassPath and then exercises the URLClassPath.getResource()\n+     * and URLClassPath.getResources() methods and expects them to return the expected\n+     * resources.\n+     *\/\n+    @Test\n+    void testGetResource() {\n+        \/\/ start an empty URL classpath\n+        final URLClassPath urlc = new URLClassPath(new URL[0]);\n+        final String[] classpathElements = getClassPathElements();\n+        try {\n+            \/\/ use addFile() to construct classpath\n+            for (final String path : classpathElements) {\n+                urlc.addFile(path);\n+            }\n+            \/\/ getResource()\n+            assertNotNull(urlc.getResource(RESOURCE_NAME), \"getResource() failed to locate\"\n+                    + \" resource: \" + RESOURCE_NAME + \" in classpath: \"\n+                    + Arrays.toString(classpathElements));\n+            \/\/ getResources()\n+            final Enumeration<Resource> locatedResources = urlc.getResources(RESOURCE_NAME);\n+            assertNotNull(locatedResources, \"getResources() failed to\"\n+                    + \" locate resource: \" + RESOURCE_NAME + \" in classpath: \"\n+                    + Arrays.toString(classpathElements));\n+            int numFound = 0;\n+            while (locatedResources.hasMoreElements()) {\n+                System.out.println(\"located \" + locatedResources.nextElement().getURL()\n+                        + \" for resource \" + RESOURCE_NAME);\n+                numFound++;\n+            }\n+            assertEquals(NUM_EXPECTED_LOCATED_RESOURCES, numFound,\n+                    \"unexpected number of resources located for \" + RESOURCE_NAME);\n+        } finally {\n+            urlc.closeLoaders();\n+        }\n+    }\n+\n+    private static String[] getClassPathElements() {\n+        \/\/ Maintain the order - in context of this test, paths with emojis\n+        \/\/ or those which can't serve the resource should come before the\n+        \/\/ path that can serve the resource.\n+        return new String[]{\n+                \/\/ non-existent path\n+                ASCII_DIR.resolve(\"non-existent\").toString(),\n+                \/\/ existing emoji dir\n+                EMOJI_DIR.toString(),\n+                \/\/ existing jar file in a emoji dir\n+                JAR_FILE_IN_EMOJI_DIR.toString(),\n+                \/\/ existing ascii dir\n+                ASCII_DIR.toString()\n+        };\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/ClassPathUnusableURLs.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+\n+import jdk.internal.loader.URLClassPath;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8341551\n+ * @summary verify the behaviour of URLClassPath in the presence\/absence of\n+ *          sun.misc.URLClassPath.disableJarChecking system property\n+ *\n+ * @modules java.base\/jdk.internal.loader\n+ *\n+ * @comment the following run is expected to run with jar checking enabled\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=false JarCheckTest\n+ *\n+ * @comment the following runs are expected to run with jar checking disabled\n+ * @run junit JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking= JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=true JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=FALSE JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=foo JarCheckTest\n+ *\/\n+public class JarCheckTest {\n+\n+    private static final Path SCRATCH_DIR = Path.of(\".\").normalize();\n+    private static final String SYS_PROP = \"sun.misc.URLClassPath.disableJarChecking\";\n+    private static final String RESOURCE_IN_NORMAL_JAR = \"foo.txt\";\n+    private static final String RESOURCE_IN_NOT_JUST_A_JAR = \"bar.txt\";\n+\n+\n+    private static final boolean jarCheckEnabled = \"false\".equals(System.getProperty(SYS_PROP));\n+    private static Path normalJar;\n+    private static Path notJustAJar; \/\/ JAR file with additional prefixed bytes\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        final Path tmpDir = Files.createTempDirectory(SCRATCH_DIR, \"8341551\");\n+        \/\/ create a normal JAR file\n+        normalJar = tmpDir.resolve(\"normal.jar\");\n+        createJar(normalJar, RESOURCE_IN_NORMAL_JAR, false);\n+\n+        \/\/ now create another JAR file and have its content prefixed with arbitrary bytes\n+        notJustAJar = tmpDir.resolve(\"notjustajar.jar\");\n+        createJar(notJustAJar, RESOURCE_IN_NOT_JUST_A_JAR, true);\n+    }\n+\n+    private static void createJar(final Path targetJarFile, final String entryName,\n+                                  final boolean prefixArbitraryBytes)\n+            throws IOException {\n+\n+        Files.createFile(targetJarFile);\n+        if (prefixArbitraryBytes) {\n+            final byte[] arbitraryBytes = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06};\n+            Files.write(targetJarFile, arbitraryBytes);\n+        }\n+        final Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().putValue(\"Manifest-Version\", \"1.0\");\n+        final OpenOption openOption = prefixArbitraryBytes\n+                ? StandardOpenOption.APPEND\n+                : StandardOpenOption.WRITE;\n+        try (OutputStream fos = Files.newOutputStream(targetJarFile, openOption);\n+             JarOutputStream jos = new JarOutputStream(fos, manifest)) {\n+\n+            final JarEntry jarEntry = new JarEntry(entryName);\n+            jos.putNextEntry(jarEntry);\n+            jos.write(\"hello\".getBytes(US_ASCII));\n+            jos.closeEntry();\n+        }\n+    }\n+\n+    \/*\n+     * Verifies that the URLClassPath always locates a resource from a normal JAR file\n+     * in the classpath and only conditionally locates a resource from a byte prefixed\n+     * JAR file in the classpath.\n+     *\/\n+    @Test\n+    public void testLocateResource() throws Exception {\n+        System.out.println(\"JAR check enabled=\" + jarCheckEnabled);\n+        final URL[] classpath = new URL[]{\n+                new URI(\"jar:\" + normalJar.toUri() + \"!\/\").toURL(),\n+                new URI(\"jar:\" + notJustAJar.toUri() + \"!\/\").toURL()\n+        };\n+        final URLClassPath urlc = new URLClassPath(classpath);\n+        try {\n+            System.out.println(urlc + \" will use classpath: \" + Arrays.toString(classpath));\n+            \/\/ always expected to be found\n+            assertNotNull(urlc.findResource(RESOURCE_IN_NORMAL_JAR),\n+                    \"missing resource \" + RESOURCE_IN_NORMAL_JAR);\n+            \/\/ will be found only if jar check is disabled\n+            final URL resource = urlc.findResource(RESOURCE_IN_NOT_JUST_A_JAR);\n+            if (jarCheckEnabled) {\n+                assertNull(resource, \"unexpectedly found \" + RESOURCE_IN_NOT_JUST_A_JAR\n+                        + \" at \" + resource);\n+            } else {\n+                assertNotNull(resource, \"missing resource \" + RESOURCE_IN_NOT_JUST_A_JAR);\n+            }\n+        } finally {\n+            urlc.closeLoaders();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/JarCheckTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345403\n+ * @summary FloatingDecimal parsing methods (use -Dseed=X to set seed)\n+ * @modules java.base\/jdk.internal.math\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run junit TestRandomFloatingDecimal\n+ * @key randomness\n+ *\/\n+\n+import jdk.internal.math.FloatingDecimal;\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class TestRandomFloatingDecimal {\n+\n+    \/*\n+     * This class relies on the correctness of\n+     *      BigInteger string parsing, both decimal and hexadecimal\n+     *      BigDecimal floatValue() and doubleValue() conversions\n+     * and on the fact that the implementation of the BigDecimal conversions is\n+     * independent of the implementation in FloatingDecimal.\n+     * Hence, the expected values are those computed by BigDecimal,\n+     * while the actual values are those returned by FloatingDecimal.\n+     *\/\n+    private static final int COUNT = 10_000;  \/\/ random samples per test\n+\n+    private static final Random RANDOM = RandomFactory.getRandom();\n+\n+    static Stream<Args> testRandomDecForFloat() {\n+        return Stream.generate(() -> randomDec(false)).limit(COUNT);\n+    }\n+\n+    static Stream<Args> testRandomDecForDouble() {\n+        return Stream.generate(() -> randomDec(true)).limit(COUNT);\n+    }\n+\n+    static Stream<Args> testRandomHexForFloat() {\n+        return Stream.generate(() -> randomHex(false)).limit(COUNT);\n+    }\n+\n+    static Stream<Args> testRandomHexForDouble() {\n+        return Stream.generate(() -> randomHex(true)).limit(COUNT);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomDecForFloat(Args args) {\n+        float expected = args.decimal().floatValue();\n+        float actual = FloatingDecimal.parseFloat(args.s());\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomDecForDouble(Args args) {\n+        double expected = args.decimal().doubleValue();\n+        double actual = FloatingDecimal.parseDouble(args.s());\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomHexForFloat(Args args) {\n+        float expected = args.decimal().floatValue();\n+        float actual = FloatingDecimal.parseFloat(args.s());\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomHexForDouble(Args args) {\n+       double expected = args.decimal().doubleValue();\n+       double actual = FloatingDecimal.parseDouble(args.s());\n+       assertEquals(expected, actual);\n+    }\n+\n+    private record Args(String s, BigDecimal decimal) {}\n+\n+    private static Args randomDec(boolean forDouble) {\n+        StringBuilder sb = new StringBuilder();\n+        int leadingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, leadingWhites);\n+        int signLen = appendRandomSign(sb);\n+        int leadingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, leadingZeros);\n+        int digits = RANDOM.nextInt(forDouble ? 24 : 12) + 1;\n+        appendRandomDecDigits(sb, digits);\n+        int trailingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, trailingZeros);\n+        BigDecimal bd = new BigDecimal(new BigInteger(\n+                sb.substring(\n+                        leadingWhites,\n+                        leadingWhites + signLen + leadingZeros + digits + trailingZeros),\n+                10));\n+\n+        int p = 0;\n+        if (RANDOM.nextInt(8) != 0) {  \/\/ 87.5% chance of point presence\n+            int pointPos = RANDOM.nextInt(leadingZeros + digits + trailingZeros + 1);\n+            sb.insert(leadingWhites + signLen + pointPos, '.');\n+            p = -(leadingZeros + digits + trailingZeros - pointPos);\n+        }\n+        int e = 0;\n+        if (RANDOM.nextInt(4) != 0) {  \/\/ 75% chance of explicit exponent\n+            int emax = forDouble ? 325 : 46;\n+            e = RANDOM.nextInt(-emax, emax);\n+            appendExponent(sb, e, true);\n+        }\n+        appendRandomSuffix(sb);\n+        int trailingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, trailingWhites);\n+        if (e + p >= 0) {\n+            bd = bd .multiply(BigDecimal.TEN.pow(e + p));\n+        } else {\n+            bd = bd .divide(BigDecimal.TEN.pow(-(e + p)));\n+        }\n+        return new Args(sb.toString(), bd);\n+    }\n+\n+    private static Args randomHex(boolean forDouble) {\n+        StringBuilder sb = new StringBuilder();\n+        int leadingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, leadingWhites);\n+        int signLen = appendRandomSign(sb);\n+        appendHexPrefix(sb);\n+        int leadingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, leadingZeros);\n+        int digits = RANDOM.nextInt(forDouble ? 24 : 12) + 1;\n+        appendRandomHexDigits(sb, digits);\n+        int trailingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, trailingZeros);\n+        BigDecimal bd = new BigDecimal(new BigInteger(  \/\/ don't include 0x or 0X\n+                sb.substring(leadingWhites, leadingWhites + signLen) +\n+                sb.substring(\n+                        leadingWhites + signLen + 2,\n+                        leadingWhites + signLen + 2 + leadingZeros + digits + trailingZeros),\n+                0x10));\n+\n+        int p = 0;\n+        if (RANDOM.nextInt(8) != 0) {  \/\/ 87.5% chance of point presence\n+            int pointPos = RANDOM.nextInt(leadingZeros + digits + trailingZeros + 1);\n+            sb.insert(leadingWhites + signLen + 2 + pointPos, '.');\n+            p = -4 * (leadingZeros + digits + trailingZeros - pointPos);\n+        }\n+        int emax = forDouble ? 1075 : 150;\n+        int e = RANDOM.nextInt(-emax, emax);\n+        appendExponent(sb, e, false);\n+        appendRandomSuffix(sb);\n+        int trailingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, trailingWhites);\n+        if (e + p >= 0) {\n+            bd = bd .multiply(BigDecimal.TWO.pow(e + p));\n+        } else {\n+            bd = bd .divide(BigDecimal.TWO.pow(-(e + p)));\n+        }\n+        return new Args(sb.toString(), bd);\n+    }\n+\n+    private static int appendRandomSign(StringBuilder sb) {\n+        return switch (RANDOM.nextInt(4)) {  \/\/ 50% chance of tacit sign\n+            case 0 -> {\n+                sb.append('-');\n+                yield 1;\n+            }\n+            case 1 -> {\n+                sb.append('+');\n+                yield 1;\n+            }\n+            default -> 0;\n+        };\n+    }\n+\n+    private static void appendExponent(StringBuilder sb, int e, boolean forDec) {\n+        if (forDec) {\n+            sb.append(RANDOM.nextBoolean() ? 'e' : 'E');\n+        } else {\n+            sb.append(RANDOM.nextBoolean() ? 'p' : 'P');\n+        }\n+        if (e < 0) {\n+            sb.append('-');\n+        } else if (e == 0) {\n+            appendRandomSign(sb);\n+        } else if (RANDOM.nextBoolean()) {\n+            sb.append('+');\n+        }\n+        appendZeros(sb, RANDOM.nextInt(2));\n+        sb.append(Math.abs(e));\n+    }\n+\n+    private static void appendRandomSuffix(StringBuilder sb) {\n+        switch (RANDOM.nextInt(8)) {  \/\/ 50% chance of no suffix\n+            case 0 -> sb.append('D');\n+            case 1 -> sb.append('F');\n+            case 2 -> sb.append('d');\n+            case 3 -> sb.append('f');\n+        }\n+    }\n+\n+    private static void appendHexPrefix(StringBuilder sb) {\n+        \/* Randomize case of x. *\/\n+        sb.append('0').append(RANDOM.nextBoolean() ? 'x' : 'X');\n+    }\n+\n+    private static void appendZeros(StringBuilder sb, int count) {\n+        sb.repeat('0', count);\n+    }\n+\n+    private static void appendRandomDecDigits(StringBuilder sb, int count) {\n+        sb.append(randomDecDigit(1));\n+        for (; count > 1; --count) {\n+            sb.append(randomDecDigit(0));\n+        }\n+    }\n+\n+    private static void appendRandomHexDigits(StringBuilder sb, int count) {\n+        sb.append(randomHexDigit(1));\n+        for (; count > 1; --count) {\n+            sb.append(randomHexDigit(0));\n+        }\n+    }\n+\n+    private static char randomHexDigit(int min) {\n+        char c = Character.forDigit(RANDOM.nextInt(min, 0x10), 0x10);\n+        \/* Randomize letter case as well. *\/\n+        return RANDOM.nextBoolean() ? Character.toLowerCase(c) : Character.toUpperCase(c);\n+    }\n+\n+    private static char randomDecDigit(int min) {\n+        int c = Character.forDigit(RANDOM.nextInt(min, 10), 10);\n+        return (char) c;\n+    }\n+\n+    private static void appendRandomWhitespace(StringBuilder sb, int count) {\n+        \/* Randomize all whitespace chars. *\/\n+        for (; count > 0; --count) {\n+            sb.append(randomWhitespace());\n+        }\n+    }\n+\n+    private static char randomWhitespace() {\n+        return (char) (RANDOM.nextInt(0x20 + 1));\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/TestRandomFloatingDecimal.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343704\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @compile\/module=java.base jdk\/internal\/ref\/CleanableListTestHelper.java jdk\/internal\/ref\/TestCleanable.java\n+ * @modules java.base\/jdk.internal.ref\n+ * @run testng\/othervm CleanableListTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.internal.ref.CleanableListTestHelper;\n+import jdk.internal.ref.TestCleanable;\n+import jdk.test.lib.RandomFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.Ignore;\n+\n+public class CleanableListTest {\n+\n+    static final int SINGLE_NODE_CAPACITY = CleanableListTestHelper.NODE_CAPACITY;\n+    static final int MULTI_NODE_CAPACITY = CleanableListTestHelper.NODE_CAPACITY * 4;\n+\n+    static final Random RND = RandomFactory.getRandom();\n+    static final int RANDOM_ITERATIONS = 10_000_000;\n+\n+    @Test\n+    public void testSingle() {\n+        CleanableListTestHelper list = new CleanableListTestHelper();\n+        Assert.assertTrue(list.isEmpty());\n+        TestCleanable tc = list.newCleanable();\n+        Assert.assertFalse(list.isEmpty());\n+        Assert.assertTrue(list.remove(tc));\n+        Assert.assertTrue(list.isEmpty());\n+        Assert.assertFalse(list.remove(tc));\n+    }\n+\n+    @Test\n+    public void testSequential_Single() {\n+        doSequential(SINGLE_NODE_CAPACITY);\n+    }\n+\n+    @Test\n+    public void testSequential_Multi() {\n+        doSequential(MULTI_NODE_CAPACITY);\n+    }\n+\n+    private void doSequential(int size) {\n+        CleanableListTestHelper list = new CleanableListTestHelper();\n+        Assert.assertTrue(list.isEmpty());\n+\n+        List<TestCleanable> tcs = new ArrayList<>();\n+        for (int c = 0; c < size; c++) {\n+            tcs.add(list.newCleanable());\n+        }\n+        Assert.assertFalse(list.isEmpty());\n+\n+        for (TestCleanable tc : tcs) {\n+            Assert.assertTrue(list.remove(tc));\n+        }\n+        Assert.assertTrue(list.isEmpty());\n+    }\n+\n+    @Test\n+    public void testRandom_Single() {\n+        doRandom(SINGLE_NODE_CAPACITY);\n+    }\n+\n+    @Test\n+    public void testRandom_Multi() {\n+        doRandom(MULTI_NODE_CAPACITY);\n+    }\n+\n+    private void doRandom(int size) {\n+        CleanableListTestHelper list = new CleanableListTestHelper();\n+        Assert.assertTrue(list.isEmpty());\n+\n+        BitSet bs = new BitSet(size);\n+\n+        List<TestCleanable> tcs = new ArrayList<>();\n+        for (int c = 0; c < size; c++) {\n+            tcs.add(list.newCleanable());\n+            bs.set(c, true);\n+        }\n+        Assert.assertFalse(list.isEmpty());\n+\n+        for (int t = 0; t < RANDOM_ITERATIONS; t++) {\n+            int idx = RND.nextInt(size);\n+            TestCleanable tc = tcs.get(idx);\n+            if (bs.get(idx)) {\n+                Assert.assertTrue(list.remove(tc));\n+                bs.set(idx, false);\n+            } else {\n+                Assert.assertFalse(list.remove(tc));\n+                list.insert(tc);\n+                bs.set(idx, true);\n+            }\n+        }\n+\n+        for (int c = 0; c < size; c++) {\n+            if (bs.get(c)) {\n+                TestCleanable tc = tcs.get(c);\n+                Assert.assertTrue(list.remove(tc));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/CleanableListTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ref;\n+\n+import java.lang.ref.Cleaner;\n+import jdk.internal.ref.PhantomCleanable;\n+import jdk.internal.ref.CleanerImpl;\n+import jdk.internal.ref.CleanerImpl.CleanableList;\n+\n+\/**\n+ * This class provides package-private access to CleanableList internals.\n+ *\/\n+public class CleanableListTestHelper {\n+\n+    public static final int NODE_CAPACITY = CleanableList.NODE_CAPACITY;\n+\n+    final Cleaner cleaner;\n+    final CleanableList list;\n+\n+    public CleanableListTestHelper() {\n+        cleaner = Cleaner.create();\n+        list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n+\n+        \/\/ List contains CleanerCleanable for Cleaner itself.\n+        \/\/ For testing empty list paths, we want to drop it.\n+        list.reset();\n+    }\n+\n+    public TestCleanable newCleanable() {\n+        return new TestCleanable(cleaner);\n+    }\n+\n+    public void insert(PhantomCleanable cl) {\n+        list.insert(cl);\n+    }\n+\n+    public boolean remove(PhantomCleanable cl) {\n+        return list.remove(cl);\n+    }\n+\n+    public boolean isEmpty() {\n+        return list.isEmpty();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/java.base\/jdk\/internal\/ref\/CleanableListTestHelper.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ref;\n+\n+import java.lang.ref.Cleaner;\n+\n+public class TestCleanable extends PhantomCleanable<Object> {\n+    static final Object TARGET = new Object();\n+\n+    public TestCleanable(Cleaner cleaner) {\n+        super(TARGET, cleaner);\n+    }\n+\n+    @Override\n+    protected void performCleanup() {\n+        \/\/ no action\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/java.base\/jdk\/internal\/ref\/TestCleanable.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright Amazon.com Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.jfr.event.gc.detailed;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.GCHelper;\n+\n+\/**\n+ * @test\n+ * @bug 8221507\n+ * @requires vm.hasJFR & vm.gc.Shenandoah\n+ * @key jfr\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -Xmx64m -XX:+UnlockExperimentalVMOptions -XX:ShenandoahRegionSize=1m -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational jdk.jfr.event.gc.detailed.TestShenandoahEvacuationInformationEvent\n+ *\/\n+\n+public class TestShenandoahEvacuationInformationEvent {\n+    private final static String EVENT_NAME = EventNames.ShenandoahEvacuationInformation;\n+\n+    public static void main(String[] args) throws Exception {\n+        final long shenandoahHeapRegionSize = 1024 * 1024;\n+        Recording recording = new Recording();\n+        recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n+        recording.start();\n+        allocate();\n+        recording.stop();\n+\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        Asserts.assertFalse(events.isEmpty(), \"No events found\");\n+        for (RecordedEvent event : events) {\n+            if (!Events.isEventType(event, EVENT_NAME)) {\n+                continue;\n+            }\n+            System.out.println(\"Event: \" + event);\n+\n+            long setRegions = Events.assertField(event, \"cSetRegions\").atLeast(0L).getValue();\n+            long setUsedAfter = Events.assertField(event, \"cSetUsedAfter\").atLeast(0L).getValue();\n+            long setUsedBefore = Events.assertField(event, \"cSetUsedBefore\").atLeast(setUsedAfter).getValue();\n+            long regionsFreed = Events.assertField(event, \"regionsFreed\").atLeast(0L).getValue();\n+            Events.assertField(event, \"collectedOld\").atLeast(0L).getValue();\n+            Events.assertField(event, \"collectedYoung\").atLeast(0L).getValue();\n+\n+            Asserts.assertGreaterThanOrEqual(setRegions, regionsFreed, \"setRegions >= regionsFreed\");\n+            Asserts.assertGreaterThanOrEqual(shenandoahHeapRegionSize * setRegions, setUsedAfter, \"ShenandoahHeapRegionSize * setRegions >= setUsedAfter\");\n+            Asserts.assertGreaterThanOrEqual(shenandoahHeapRegionSize * setRegions, setUsedBefore, \"ShenandoahHeapRegionSize * setRegions >= setUsedBefore\");\n+\n+            int gcId = Events.assertField(event, \"gcId\").getValue();\n+        }\n+    }\n+\n+    \/**\n+     * Allocate memory to trigger garbage collections.\n+     * We want the allocated objects to have different life time, because we want both \"young\" and \"old\" objects.\n+     * This is done by keeping the objects in an array and step the current index by a small random number in the loop.\n+     * The loop will continue until we have allocated a fixed number of bytes.\n+     *\/\n+    private static void allocate() {\n+        DummyObject[] dummys = new DummyObject[6000];\n+\n+        Random r = new Random(0);\n+        long bytesToAllocate = 256 * 1024 * 1024;\n+        int currPos = 0;\n+        while (bytesToAllocate > 0) {\n+            int allocSize = 1000 + (r.nextInt(4000));\n+            bytesToAllocate -= allocSize;\n+            dummys[currPos] = new DummyObject(allocSize);\n+\n+            \/\/ Skip a few positions to get different duration on the objects.\n+            currPos = (currPos + r.nextInt(20)) % dummys.length;\n+        }\n+        for (int c=0; c<dummys.length; c++) {\n+            dummys[c] = null;\n+        }\n+        System.gc();\n+    }\n+\n+    public static class DummyObject {\n+        public byte[] payload;\n+        DummyObject(int size) {\n+            payload = new byte[size];\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestShenandoahEvacuationInformationEvent.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -60,5 +60,0 @@\n-    \/\/TODO: uncomment three lines below after moving functionality to java.awt.Robot\n-    \/\/{\n-    \/\/    syncDelay = AccessController.doPrivileged(new GetIntegerAction(\"java.awt.robotdelay\", DEFAULT_SYNC_DELAY));\n-    \/\/}\n-\n","filename":"test\/jdk\/lib\/client\/ExtendedRobot.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 5057136\n- * @summary Generify sun.security.action.GetPropertyAction and friends\n- * @modules java.base\/sun.security.action\n- *\/\n-\n-import java.security.*;\n-import sun.security.action.*;\n-\n-public class Generify {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        long larg = 1234567890L;\n-\n-        System.setProperty(\"boolean\", \"true\");\n-        System.setProperty(\"integer\", \"9\");\n-        System.setProperty(\"long\", Long.toString(larg));\n-        System.setProperty(\"property\", \"propertyvalue\");\n-\n-        Boolean b = AccessController.doPrivileged\n-                        (new GetBooleanAction(\"boolean\"));\n-        if (b.booleanValue() == true) {\n-            System.out.println(\"boolean test passed\");\n-        } else {\n-            throw new SecurityException(\"boolean test failed\");\n-        }\n-\n-        Integer i = AccessController.doPrivileged\n-                        (new GetIntegerAction(\"integer\"));\n-        if (i.intValue() == 9) {\n-            System.out.println(\"integer test passed\");\n-        } else {\n-            throw new SecurityException(\"integer test failed\");\n-        }\n-\n-        Long l = AccessController.doPrivileged\n-                        (new GetLongAction(\"long\"));\n-        if (l.longValue() == larg) {\n-            System.out.println(\"long test passed\");\n-        } else {\n-            throw new SecurityException(\"long test failed\");\n-        }\n-\n-        String prop = AccessController.doPrivileged\n-                        (new GetPropertyAction(\"property\"));\n-        if (prop.equals(\"propertyvalue\")) {\n-            System.out.println(\"property test passed\");\n-        } else {\n-            throw new SecurityException(\"property test failed\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/action\/Generify.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4173993\n- * @summary Make sure \"null\" is returned if property does not exist (or has\n- * wrong numeric format) and no default has been specified.\n- * @modules java.base\/sun.security.action\n- *\/\n-\n-import sun.security.action.*;\n-\n-public class ReturnNullIfNoDefault {\n-\n-    public static void main(String[] args) throws Exception {\n-        long larg = 1234567890L;\n-\n-        GetLongAction ac = new GetLongAction(\"test\");\n-        if (ac.run() != null)\n-            throw new Exception(\"Returned value is not null\");\n-\n-        ac = new GetLongAction(\"test\", larg);\n-        long ret = ((Long)ac.run()).longValue();\n-        if (ret != larg)\n-            throw new Exception(\"Returned value differs from default\");\n-\n-        System.setProperty(\"test\", Long.toString(larg));\n-        ac = new GetLongAction(\"test\");\n-        ret = ((Long)ac.run()).longValue();\n-        if (ret != larg)\n-            throw new Exception(\"Returned value differs from property\");\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/action\/GetLongAction\/ReturnNullIfNoDefault.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8343622\n+ * @summary KerberosKey created with null key bytes\n+ * @run main\/othervm NullStringToKey\n+ *\/\n+\n+import javax.security.auth.kerberos.KerberosKey;\n+import javax.security.auth.kerberos.KerberosPrincipal;\n+import java.security.Security;\n+import java.util.List;\n+\n+public class NullStringToKey {\n+    public static void main(String[] args) throws Exception {\n+\n+        Security.removeProvider(\"SUN\");\n+        Security.removeProvider(\"SunJCE\");\n+\n+        var name = new KerberosPrincipal(\"me@ME.COM\");\n+        var pass = \"password\".toCharArray();\n+        for (var alg : List.of(\n+                \"aes128-cts-hmac-sha1-96\", \"aes256-cts-hmac-sha1-96\",\n+                \"aes128-cts-hmac-sha256-128\", \"aes256-cts-hmac-sha384-192\")) {\n+            System.out.println(alg);\n+            \/\/ Do not use Utils.runAndCheckException as it might call\n+            \/\/ MessageDigest.getInstance(\"MD5\") at class initialization\n+            \/\/ and we have already removed the SUN provider.\n+            try {\n+                new KerberosKey(name, pass, alg);\n+                throw new RuntimeException(\"Didn't get expected exception\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+                System.out.println(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/NullStringToKey.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,6 +44,6 @@\n-        checkName(\"a\", type, \"R\", \"R\", false, \"a\");\n-        checkName(\"a@R2\", type, \"R\", \"R\", false, \"a\");\n-        checkName(\"a\/b\", type, \"R\", \"R\", false, \"a\", \"b\");\n-        checkName(\"a\/b@R2\", type, \"R\", \"R\", false, \"a\", \"b\");\n-        checkName(\"a\/b\/c\", type, \"R\", \"R\", false, \"a\", \"b\", \"c\");\n-        checkName(\"a\/b\/c@R2\", type, \"R\", \"R\", false, \"a\", \"b\", \"c\");\n+        checkName(\"a\", type, \"R\", \"R\", \"a\");\n+        checkName(\"a@R2\", type, \"R\", \"R\", \"a\");\n+        checkName(\"a\/b\", type, \"R\", \"R\", \"a\", \"b\");\n+        checkName(\"a\/b@R2\", type, \"R\", \"R\", \"a\", \"b\");\n+        checkName(\"a\/b\/c\", type, \"R\", \"R\", \"a\", \"b\", \"c\");\n+        checkName(\"a\/b\/c@R2\", type, \"R\", \"R\", \"a\", \"b\", \"c\");\n@@ -51,3 +51,3 @@\n-        checkName(\"a\\\\\/b\", type, \"R\", \"R\", false, \"a\/b\");\n-        checkName(\"a\\\\\/b\\\\\/c\", type, \"R\", \"R\", false, \"a\/b\/c\");\n-        checkName(\"a\\\\\/b\\\\@R2\", type, \"R\", \"R\", false, \"a\/b@R2\");\n+        checkName(\"a\\\\\/b\", type, \"R\", \"R\", \"a\/b\");\n+        checkName(\"a\\\\\/b\\\\\/c\", type, \"R\", \"R\", \"a\/b\/c\");\n+        checkName(\"a\\\\\/b\\\\@R2\", type, \"R\", \"R\", \"a\/b@R2\");\n@@ -55,6 +55,5 @@\n-        checkName(\"a\", type, \"\", null, false);\n-        checkName(\"a\/\", type, \"R\", null, false);\n-        checkName(\"\/a\", type, \"R\", null, false);\n-        checkName(\"a\/\/b\", type, \"R\", null, false);\n-        checkName(\"a@\", type, null, null, false);\n-        type = PrincipalName.KRB_NT_SRV_HST;\n+        checkName(\"a\", type, \"\", null);\n+        checkName(\"a\/\", type, \"R\", null);\n+        checkName(\"\/a\", type, \"R\", null);\n+        checkName(\"a\/\/b\", type, \"R\", null);\n+        checkName(\"a@\", type, null, null);\n@@ -81,5 +80,5 @@\n-            checkName(\"a\", type, \"R1\", \"R1\", false, \"a\");      \/\/ arg\n-            checkName(\"a@R1\", type, null, \"R1\", false, \"a\");   \/\/ or r in name\n-            checkName(\"a@R2\", type, \"R1\", \"R1\", false, \"a\");   \/\/ arg over r\n-            checkName(\"a\", type, null, null, false);      \/\/ fail if none\n-            checkName(\"a\/b@R1\", type, null, \"R1\", false, \"a\", \"b\");\n+            checkName(\"a\", type, \"R1\", \"R1\", \"a\");      \/\/ arg\n+            checkName(\"a@R1\", type, null, \"R1\", \"a\");   \/\/ or r in name\n+            checkName(\"a@R2\", type, \"R1\", \"R1\", \"a\");   \/\/ arg over r\n+            checkName(\"a\", type, null, null);      \/\/ fail if none\n+            checkName(\"a\/b@R1\", type, null, \"R1\", \"a\", \"b\");\n@@ -88,4 +87,4 @@\n-            checkName(\"a\/b.h\", type, \"R1\", \"R1\", false, \"a\", \"b.h\");    \/\/ arg\n-            checkName(\"a\/b.h@R1\", type, null, \"R1\", false, \"a\", \"b.h\"); \/\/ or r in name\n-            checkName(\"a\/b.h@R1\", type, \"R2\", \"R2\", false, \"a\", \"b.h\"); \/\/ arg over r\n-            checkName(\"a\/b.h\", type, null, null, false);    \/\/ fail if none\n+            checkName(\"a\/b.h\", type, \"R1\", \"R1\", \"a\", \"b.h\");    \/\/ arg\n+            checkName(\"a\/b.h@R1\", type, null, \"R1\", \"a\", \"b.h\"); \/\/ or r in name\n+            checkName(\"a\/b.h@R1\", type, \"R2\", \"R2\", \"a\", \"b.h\"); \/\/ arg over r\n+            checkName(\"a\/b.h\", type, null, null);    \/\/ fail if none\n@@ -100,5 +99,5 @@\n-        checkName(\"a\", type, \"R1\", \"R1\", false, \"a\");      \/\/ arg\n-        checkName(\"a@R1\", type, null, \"R1\", false, \"a\");   \/\/ or r in name\n-        checkName(\"a@R2\", type, \"R1\", \"R1\", false, \"a\");   \/\/ arg over r\n-        checkName(\"a\", type, null, \"R\", true, \"a\");       \/\/ default\n-        checkName(\"a\/b\", type, null, \"R\", true, \"a\", \"b\");\n+        checkName(\"a\", type, \"R1\", \"R1\", \"a\");      \/\/ arg\n+        checkName(\"a@R1\", type, null, \"R1\", \"a\");   \/\/ or r in name\n+        checkName(\"a@R2\", type, \"R1\", \"R1\", \"a\");   \/\/ arg over r\n+        checkName(\"a\", type, null, \"R\", \"a\");       \/\/ default\n+        checkName(\"a\/b\", type, null, \"R\", \"a\", \"b\");\n@@ -106,7 +105,7 @@\n-        checkName(\"a\/b.h3\", type, \"R1\", \"R1\", false, \"a\", \"b.h3\");     \/\/ arg\n-        checkName(\"a\/b.h@R1\", type, null, \"R1\", false, \"a\", \"b.h\");    \/\/ or r in name\n-        checkName(\"a\/b.h3@R2\", type, \"R1\", \"R1\", false, \"a\", \"b.h3\");  \/\/ arg over r\n-        checkName(\"a\/b.h2\", type, \"R1\", \"R1\", false, \"a\", \"b.h2\");     \/\/ arg over map\n-        checkName(\"a\/b.h2@R1\", type, null, \"R1\", false, \"a\", \"b.h2\");  \/\/ r over map\n-        checkName(\"a\/b.h2\", type, null, \"R2\", true, \"a\", \"b.h2\");     \/\/ map\n-        checkName(\"a\/b.h\", type, null, \"R\", true, \"a\", \"b.h\");        \/\/ default\n+        checkName(\"a\/b.h3\", type, \"R1\", \"R1\", \"a\", \"b.h3\");     \/\/ arg\n+        checkName(\"a\/b.h@R1\", type, null, \"R1\", \"a\", \"b.h\");    \/\/ or r in name\n+        checkName(\"a\/b.h3@R2\", type, \"R1\", \"R1\", \"a\", \"b.h3\");  \/\/ arg over r\n+        checkName(\"a\/b.h2\", type, \"R1\", \"R1\", \"a\", \"b.h2\");     \/\/ arg over map\n+        checkName(\"a\/b.h2@R1\", type, null, \"R1\", \"a\", \"b.h2\");  \/\/ r over map\n+        checkName(\"a\/b.h2\", type, null, \"R2\", \"a\", \"b.h2\");     \/\/ map\n+        checkName(\"a\/b.h\", type, null, \"R\", \"a\", \"b.h\");        \/\/ default\n@@ -118,1 +117,1 @@\n-            String realm, boolean deduced, String... parts)\n+            String realm, String... parts)\n@@ -135,3 +134,0 @@\n-        if (deduced != pn.isRealmDeduced()) {\n-            throw new Exception(\"pn.realmDeduced is \" + pn.isRealmDeduced());\n-        }\n","filename":"test\/jdk\/sun\/security\/krb5\/name\/Constructors.java","additions":37,"deletions":41,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,2 @@\n-        var hasAdminPrivileges = detectIfRunningWithAdminPrivileges();\n-        var nmm = adminTest(\"windows-my-localmachine\", hasAdminPrivileges);\n-        var nrm = adminTest(\"windows-root-localmachine\", hasAdminPrivileges);\n+        var nmm = test(\"windows-my-localmachine\");\n+        var nrm = test(\"windows-root-localmachine\");\n@@ -55,20 +54,0 @@\n-    private static boolean detectIfRunningWithAdminPrivileges() {\n-        try {\n-            Process p = Runtime.getRuntime().exec(\"reg query \\\"HKU\\\\S-1-5-19\\\"\");\n-            p.waitFor();\n-            return (p.exitValue() == 0);\n-        }\n-        catch (Exception ex) {\n-            System.out.println(\"Warning: unable to detect admin privileges, assuming none\");\n-            return false;\n-        }\n-    }\n-\n-    private static List<String> adminTest(String type, boolean hasAdminPrivileges) throws Exception {\n-        if (hasAdminPrivileges) {\n-            return test(type);\n-        }\n-        System.out.println(\"Ignoring: \" + type + \" as it requires admin privileges\");\n-        return null;\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/mscapi\/AllTypes.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @modules java.base\/sun.security.provider\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import sun.security.provider.ML_DSA_Impls;\n@@ -37,0 +38,5 @@\n+\n+        \/\/ We only have ML-DSA test for internal functions, which\n+        \/\/ is equivalent to the FIP 204 draft.\n+        ML_DSA_Impls.version = ML_DSA_Impls.Version.DRAFT;\n+\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack, false, null);\n+        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack, false);\n","filename":"test\/jdk\/tools\/jlink\/ImageFileCreatorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"IOException\");\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesExitTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        out.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        out.stdoutShouldNotContain(\"IOException\");\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesWarningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-        analyzer.stdoutShouldContain(\"MyJlinkPatchInteger.class not found in the modules image.\");\n-        analyzer.stdoutShouldContain(\"--patch-module is not supported\");\n+        analyzer.stdoutShouldContain(\"jlink does not support linking from the run-time image\");\n+        analyzer.stdoutShouldContain(\" when running on a patched runtime with --patch-module\");\n@@ -103,1 +103,1 @@\n-        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"IOException\");\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PatchedJDKModuleJlinkTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,6 @@\n-        return MessageFormat.format(getString(key), args);\n+        var str = getString(key);\n+        if (args.length != 0) {\n+            return MessageFormat.format(str, args);\n+        } else {\n+            return str;\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageStringBundle.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.RunnablePackageTest;\n@@ -35,0 +37,1 @@\n+import static jdk.internal.util.OperatingSystem.WINDOWS;\n@@ -116,8 +119,3 @@\n-        var cmd = JPackageCommand.helloAppImage(javaAppDesc)\n-                \/\/ Disable default logic adding `--verbose` option\n-                \/\/ to jpackage command line.\n-                \/\/ It will affect jpackage error messages if the command line is malformed.\n-                .ignoreDefaultVerbose(true)\n-                \/\/ Ignore external runtime as it will interfer\n-                \/\/ with jpackage arguments in this test.\n-                .ignoreDefaultRuntime(true);\n+        var cmd = JPackageCommand.helloAppImage(javaAppDesc);\n+\n+        defaultInit(cmd, expectedErrors);\n@@ -132,0 +130,31 @@\n+        cmd.execute(1);\n+    }\n+\n+    @Test(ifOS = WINDOWS)\n+    public static void testWinService() {\n+\n+        CannedFormattedString[] expectedErrors = new CannedFormattedString[] {\n+            JPackageStringBundle.MAIN.cannedFormattedString(\"error.missing-service-installer\"),\n+            JPackageStringBundle.MAIN.cannedFormattedString(\"error.missing-service-installer.advice\")\n+        };\n+\n+        new PackageTest().configureHelloApp()\n+                .addInitializer(cmd -> {\n+                    defaultInit(cmd, expectedErrors);\n+                    cmd.addArgument(\"--launcher-as-service\");\n+                })\n+                .setExpectedExitCode(1)\n+                .run(RunnablePackageTest.Action.CREATE);\n+    }\n+\n+    private static void defaultInit(JPackageCommand cmd, CannedFormattedString... expectedErrors) {\n+\n+        \/\/ Disable default logic adding `--verbose` option\n+        \/\/ to jpackage command line.\n+        \/\/ It will affect jpackage error messages if the command line is malformed.\n+        cmd.ignoreDefaultVerbose(true);\n+\n+        \/\/ Ignore external runtime as it will interfer\n+        \/\/ with jpackage arguments in this test.\n+        cmd.ignoreDefaultRuntime(true);\n+\n@@ -133,1 +162,1 @@\n-        \/\/ errors in the order they specified.\n+        \/\/ errors in the order they are specified.\n@@ -138,2 +167,0 @@\n-\n-        cmd.execute(1);\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343780\n+ * @summary Test for `@since` in java.scripting module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker java.scripting\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.scripting\/JavaScriptingCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343775\n+ * @summary Test for `@since` in java.security.jgss module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker java.security.jgss\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.security.jgss\/JavaSecurityJgssCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343775\n+ * @summary Test for `@since` in java.security.sasl module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker java.security.sasl\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.security.sasl\/JavaSecuritySaslCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343775\n+ * @summary Test for `@since` in java.smartcardio module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker java.smartcardio\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.smartcardio\/JavaSmartcardioCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343775\n+ * @summary Test for `@since` in java.xml.crypto module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker java.xml.crypto\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.xml.crypto\/JavaXmlCryptoCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343775\n+ * @summary Test for `@since` in jdk.crypto.cryptoki module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.crypto.cryptoki\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.crypto.cryptoki\/JdkCryptoCryptokiCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343780\n+ * @summary Test for `@since` in jdk.dynalik module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.dynalink\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.dynalink\/JdkDynalinkCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343780\n+ * @summary Test for `@since` in jdk.jartool module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.jartool\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.jartool\/JdkJartoolCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343780\n+ * @summary Test for `@since` in jdk.jlink module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.jlink\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.jlink\/JdkJlinkCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343780\n+ * @summary Test for `@since` in jdk.jsobject module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.jsobject\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.jsobject\/JdkJsobjectCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343775\n+ * @summary Test for `@since` in jdk.security.auth module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.security.auth\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.security.auth\/JavaScriptingCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343775\n+ * @summary Test for `@since` in jdk.security.jgss module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker jdk.security.jgss\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/jdk.security.jgss\/JavaScriptingCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 6251738 8226279 8297802 8296546 8305407\n+ * @bug 6251738 8226279 8297802 8305407\n@@ -514,14 +514,0 @@\n-    @Test\n-    public void testSuppressSpecPage(Path base) throws IOException {\n-        Path src = base.resolve(\"src\");\n-        tb.writeJavaFiles(src, \"package p; \/** @spec http:\/\/example.com label *\/ public class C { }\");\n-\n-        javadoc(\"-d\", base.resolve(\"out\").toString(),\n-                \"--source-path\", src.toString(),\n-                \"--no-external-specs-page\",\n-                \"p\");\n-        checkExit(Exit.OK);\n-\n-        checkFiles(false, \"external-specs.html\");\n-    }\n-\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSpecTag\/TestSpecTag.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341495\n+ * @summary Test for crash caused by format specifier in startup script\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jshell\/jdk.internal.jshell.tool\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox\n+ * @build KullaTesting Compiler\n+ * @run testng StartupWithFormatSpecifierTest\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class StartupWithFormatSpecifierTest extends ReplToolTesting {\n+\n+    public void testStartupWithFormatSpecifier() {\n+        Compiler compiler = new Compiler();\n+        String startupScript = \"String.format(\\\"This is a %s.\\\", \\\"test\\\");\";\n+        Path startupFile = compiler.getPath(\"StartupFileOption\/startup.txt\");\n+        compiler.writeToFile(startupFile, startupScript);\n+        test(new String[] { \"--startup\", startupFile.toString() },\n+                (a) -> assertCommandOutputContains(a, \"\/set start\", startupScript)\n+        );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/StartupWithFormatSpecifierTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8345438\n+ * @summary Verify 'return' allowed in a lambda declared in an early construction context\n+ * @enablePreview\n+ *\/\n+public class EarlyLambdaReturn {\n+\n+    public EarlyLambdaReturn() {\n+        Runnable r = () -> {\n+            return;\n+        };\n+        super();\n+        r.run();\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLambdaReturn();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLambdaReturn.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -189,0 +189,23 @@\n+\n+    public static class Inner4 {\n+        Inner4() {\n+            Runnable r = () -> {\n+                class A {\n+                    A() {\n+                        return;         \/\/ this should FAIL\n+                        super();\n+                    }\n+                    A(int x) {\n+                        {\n+                            this();     \/\/ this should FAIL\n+                        }\n+                    }\n+                    A(char x) {\n+                        super();\n+                        this();         \/\/ this should FAIL\n+                    }\n+                }\n+            };\n+            super();\n+        };\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -22,0 +22,3 @@\n+SuperInitFails.java:195:25: compiler.err.return.before.superclass.initialized\n+SuperInitFails.java:200:33: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:205:29: compiler.err.redundant.superclass.init\n@@ -30,1 +33,1 @@\n-SuperInitFails.java:150:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:150:18: compiler.err.call.must.only.appear.in.ctor\n@@ -33,1 +36,1 @@\n-30 errors\n+33 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -457,0 +457,35 @@\n+    \/\/ Lambdas within constructors\n+    public static class Test22 {\n+        public Test22() {\n+            Runnable r = () -> System.out.println();\n+            super();\n+            r.run();\n+        }\n+        public Test22(int x) {\n+            Runnable r = () -> System.out.println();\n+            r.run();\n+            super();\n+        }\n+        public Test22(char x) {\n+            Runnable r = () -> {\n+                class A {\n+                    A() {\n+                        return;\n+                    }\n+                    A(int x) {\n+                        Runnable r2 = () -> {\n+                            return;\n+                        };\n+                        this();\n+                        r2.run();\n+                    }\n+                    A(char x) {\n+                        this(0);\n+                    }\n+                }\n+                return;\n+            };\n+            r.run();\n+            super();\n+        }\n+    }\n@@ -502,0 +537,1 @@\n+        new Test22('x');\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-    char tag();\n+    int tag();\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/AnnotationDefault\/ExpectedValues.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-compiler.err.proc.no.service                            # JavacProcessingEnvironment: no service loader available\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8345248\n@@ -37,0 +38,2 @@\n+import java.util.List;\n+import java.util.Objects;\n@@ -259,0 +262,100 @@\n+\n+    @Test \/\/JDK-8345248:\n+    public void testTransitiveModuleName(Path base) throws Exception {\n+        Path lib = base.resolve(\"lib\");\n+        Path libSrc = lib.resolve(\"src\");\n+        Path transitive = libSrc.resolve(\"transitive\");\n+        tb.writeJavaFiles(transitive,\n+                \"\"\"\n+                module transitive {\n+                }\n+                \"\"\"\n+        );\n+        Path transitiveA = libSrc.resolve(\"transitive.a\");\n+        tb.writeJavaFiles(transitiveA,\n+                \"\"\"\n+                module transitive.a {\n+                }\n+                \"\"\"\n+        );\n+\n+        Path libClasses = lib.resolve(\"classes\");\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--module-source-path\", libSrc.toString())\n+                .files(findJavaFiles(libSrc))\n+                .outdir(libClasses)\n+                .run()\n+                .writeAll();\n+\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                module m {\n+                    requires transitive;\n+                    requires transitive.a;\n+                }\n+                \"\"\"\n+        );\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--module-path\", libClasses.toString())\n+                .sourcepath(src)\n+                .files(findJavaFiles(src))\n+                .outdir(classes)\n+                .run()\n+                .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                module m {\n+                    requires transitive transitive;\n+                    requires transitive transitive.a;\n+                }\n+                \"\"\"\n+        );\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--module-path\", libClasses.toString())\n+                .sourcepath(src)\n+                .files(findJavaFiles(src))\n+                .outdir(classes)\n+                .run()\n+                .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                module m {\n+                    requires transitive transitive transitive;\n+                    requires transitive transitive transitive.a;\n+                }\n+                \"\"\"\n+        );\n+\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .options(\"--module-path\", libClasses.toString(),\n+                         \"-XDrawDiagnostics\")\n+                .sourcepath(src)\n+                .files(findJavaFiles(src))\n+                .outdir(classes)\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+\n+        List<String> expected = List.of(\n+                \"module-info.java:2:25: compiler.err.repeated.modifier\",\n+                \"module-info.java:3:25: compiler.err.repeated.modifier\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new Exception(\"expected: \" + expected +\n+                                \", but got: \" + log);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/modules\/RequiresTransitiveTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8343932\n+ * @summary Error when parsing qualified generic type test pattern in switch\n+ * @compile T8343932.java\n+ *\/\n+public class T8343932 {\n+    abstract sealed class J<T1, T2> permits X.S, A {}\n+    final class A extends J<Integer, Integer> {}\n+\n+    public class X<T> {\n+        final class S<U> extends J<T, U> {\n+            abstract sealed class J<T1, T2> permits XX.SS, AA {}\n+            final class AA extends J<Integer, Integer> {}\n+\n+            public class XX<T> {\n+                final class SS<U> extends J<T, U> {}\n+            }\n+        }\n+\n+        static int test(J<Integer, Integer> ji) {\n+            return switch (ji) {\n+                case A a -> 42;\n+                case X<Integer>.S<Integer> e -> 4200; \/\/ level 1\n+            };\n+        }\n+\n+        static int test(X<Integer>.S<Integer>.J<Integer, Integer> ji) {\n+            return switch (ji) {\n+                case X<Integer>.S<Integer>.AA a -> 42;\n+                case X<Integer>.S<Integer>.XX<Integer>.SS<Integer> e -> 4200; \/\/ level 2\n+            };\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8343932.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8345474\n+ * @summary Translation for instanceof is not triggered when patterns are not used in the compilation unit\n+ * @enablePreview\n+ * @compile T8345474.java\n+ * @run main T8345474\n+ *\/\n+import java.util.List;\n+\n+public class T8345474 {\n+    public static void main(String[] args) {\n+        erasureInstanceofTypeComparisonOperator();\n+    }\n+\n+    public static void erasureInstanceofTypeComparisonOperator() {\n+        List<Short> ls = List.of((short) 42);\n+\n+        assertTrue(ls.get(0) instanceof int);\n+    }\n+\n+    static void assertTrue(boolean actual) {\n+        if (!actual) {\n+            throw new AssertionError(\"Expected: true, but got false\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8345474.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8282823\n+ * @bug 8282823 8343540\n@@ -232,2 +232,2 @@\n-                List.of(\"IUseIntf2P.java:3:8: compiler.err.is.preview: test()\",\n-                        \"IUseIntfDef2P.java:3:8: compiler.err.is.preview: test()\",\n+                List.of(\"IUseIntf2P.java:4:25: compiler.err.is.preview: test()\",\n+                        \"IUseIntfDef2P.java:4:25: compiler.err.is.preview: test()\",\n@@ -235,2 +235,2 @@\n-                        \"UseIntf2P.java:3:8: compiler.err.is.preview: test()\",\n-                        \"UseIntfDef2P.java:3:8: compiler.err.is.preview: test()\",\n+                        \"UseIntf2P.java:4:17: compiler.err.is.preview: test()\",\n+                        \"UseIntfDef2P.java:4:17: compiler.err.is.preview: test()\",\n@@ -238,1 +238,1 @@\n-                        \"UseSubIntfDef12P.java:2:8: compiler.err.is.preview: test()\",\n+                        \"UseSubIntfDef12P.java:3:17: compiler.err.is.preview: test()\",\n@@ -260,2 +260,2 @@\n-                List.of(\"IUseIntf2P.java:3:8: compiler.warn.is.preview: test()\",\n-                        \"IUseIntfDef2P.java:3:8: compiler.warn.is.preview: test()\",\n+                List.of(\"IUseIntf2P.java:4:25: compiler.warn.is.preview: test()\",\n+                        \"IUseIntfDef2P.java:4:25: compiler.warn.is.preview: test()\",\n@@ -263,2 +263,2 @@\n-                        \"UseIntf2P.java:3:8: compiler.warn.is.preview: test()\",\n-                        \"UseIntfDef2P.java:3:8: compiler.warn.is.preview: test()\",\n+                        \"UseIntf2P.java:4:17: compiler.warn.is.preview: test()\",\n+                        \"UseIntfDef2P.java:4:17: compiler.warn.is.preview: test()\",\n@@ -266,1 +266,1 @@\n-                        \"UseSubIntfDef12P.java:2:8: compiler.warn.is.preview: test()\",\n+                        \"UseSubIntfDef12P.java:3:17: compiler.warn.is.preview: test()\",\n@@ -395,1 +395,1 @@\n-                List.of(\"AbstractP.java:3:17: compiler.err.is.preview: test()\",\n+                List.of(\"AbstractP.java:4:26: compiler.err.is.preview: test()\",\n@@ -418,1 +418,1 @@\n-                List.of(\"AbstractP.java:3:17: compiler.warn.is.preview: test()\",\n+                List.of(\"AbstractP.java:4:26: compiler.warn.is.preview: test()\",\n@@ -466,0 +466,407 @@\n+    @Test \/\/JDK-8343540:\n+    public void nonPreviewImplementsPreview(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public interface Preview {\n+                              public static final int FIELD = 0;\n+                              public default void test() {}\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST,\n+                                                             reflective=true)\n+                          public interface ReflectivePreview {\n+                              public default void test() {}\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public interface NonPreviewIntf extends Preview {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public class NonPreview implements Preview {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public class ReflectiveNonPreview implements ReflectivePreview {\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.NonPreview;\n+                          import preview.api.NonPreviewIntf;\n+                          import preview.api.Preview;\n+                          import preview.api.ReflectiveNonPreview;\n+                          public class Test {\n+                              public void test(NonPreview np,\n+                                               Produce<? extends NonPreview> prod) {\n+                                  np.test();\n+                                  acceptRunnable(np::test);\n+                                  accept(NonPreview::test);\n+                                  prod.produce().test();\n+                                  acceptRunnable(prod.produce()::test);\n+                                  int i = np.FIELD;\n+                              }\n+                              public <T1 extends NonPreview,\n+                                      T2 extends Test & NonPreviewIntf,\n+                                      T3 extends T2> void test(T1 t1, T2 t2, T3 t3) {\n+                                  t1.test();\n+                                  t2.test();\n+                                  t3.test();\n+                              }\n+                              public void test(ReflectiveNonPreview np) {\n+                                  np.test();\n+                              }\n+                              public void test(Preview p) {\n+                                  p.test();\n+                                  acceptRunnable(p::test);\n+                                  accept(Preview::test);\n+                              }\n+                              private static class ExtendsNonPreview extends NonPreview {\n+                                  public void test() {} \/\/error\/warning here:\n+                              }\n+                              private static class ImplementsPreview implements Preview {\n+                                  \/\/no error\/warning (already was on Preview after implements)\n+                                  public void test() {}\n+                              }\n+                              private static class ImplicitReceiver extends NonPreview {\n+                                  public void g() {\n+                                      test(); \/\/implicit this - error\/warning\n+                                      int i = FIELD; \/\/implicit this - error\/warning\n+                                  }\n+                              }\n+                              private void acceptRunnable(Runnable r) {}\n+                              private void accept(Accept<NonPreview> accept) {}\n+                              interface Accept<T> {\n+                                  public void accept(T t);\n+                              }\n+                              interface Produce<T> {\n+                                  public T produce();\n+                              }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:4:19: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:26:22: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:34:55: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:9:11: compiler.err.is.preview: test()\",\n+                        \"Test.java:10:24: compiler.err.is.preview: test()\",\n+                        \"Test.java:11:16: compiler.err.is.preview: test()\",\n+                        \"Test.java:12:23: compiler.err.is.preview: test()\",\n+                        \"Test.java:13:24: compiler.err.is.preview: test()\",\n+                        \"Test.java:14:19: compiler.err.is.preview: FIELD\",\n+                        \"Test.java:19:11: compiler.err.is.preview: test()\",\n+                        \"Test.java:20:11: compiler.err.is.preview: test()\",\n+                        \"Test.java:21:11: compiler.err.is.preview: test()\",\n+                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n+                        \"Test.java:29:16: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:32:21: compiler.err.is.preview: test()\",\n+                        \"Test.java:36:21: compiler.err.is.preview: test()\",\n+                        \"Test.java:40:13: compiler.err.is.preview: test()\",\n+                        \"Test.java:41:21: compiler.err.is.preview: FIELD\",\n+                        \"17 errors\",\n+                        \"1 warning\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found\" + log);\n+    }\n+\n+    @Test \/\/JDK-8343540:\n+    public void nonPreviewImplementsPreview2(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public interface Preview {\n+                              public default void test() {}\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public interface NonPreviewIntf extends Preview {\n+                              public default void test() {}\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public class NonPreview implements Preview {\n+                              public void test() {}\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.NonPreview;\n+                          import preview.api.NonPreviewIntf;\n+                          public class Test {\n+                              public void test(NonPreview np1,\n+                                               NonPreviewIntf np2) {\n+                                  np1.test();\n+                                  np2.test();\n+                              }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+    }\n+\n+    @Test \/\/JDK-8343540:\n+    public void nonPreviewImplementsPreview3(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public int field;\n+                              public static void test() {}\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public class NonPreview extends Preview {\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.NonPreview;\n+                          import preview.api.Preview;\n+                          public class Test {\n+                              public void test(NonPreview np, Preview p) {\n+                                  NonPreview.test();\n+                                  Preview.test();\n+                                  int i1 = np.field;\n+                                  int i2 = p.field;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:3:19: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:5:37: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:6:19: compiler.err.is.preview: test()\",\n+                        \"Test.java:7:9: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:8:20: compiler.err.is.preview: field\",\n+                        \"5 errors\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found\" + log);\n+    }\n+\n+    @Test \/\/JDK-8343540:\n+    public void nonPreviewImplementsPreview4(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public int field;\n+                              public static void test() {}\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public class NonPreview extends Preview {\n+                              public int field;\n+                              public static void test() {}\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.NonPreview;\n+                          import preview.api.Preview;\n+                          public class Test {\n+                              public void test(NonPreview np, Preview p) {\n+                                  NonPreview.test();\n+                                  Preview.test();\n+                                  int i1 = np.field;\n+                                  int i2 = p.field;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:3:19: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:5:37: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:7:9: compiler.err.is.preview: preview.api.Preview\",\n+                        \"3 errors\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found\" + log);\n+    }\n+\n+    @Test \/\/JDK-8343540:\n+    public void nonPreviewImplementsPreview5(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public interface Preview {\n+                              public static final int CONST1 = 0;\n+                              public static final int CONST2 = 0;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public interface NonPreviewIntf extends Preview {\n+                              public static final int CONST2 = 0;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package preview.api;\n+                          public class NonPreview implements Preview {\n+                              public static final int CONST2 = 0;\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.NonPreview;\n+                          import preview.api.NonPreviewIntf;\n+                          import preview.api.Preview;\n+                          public class Test {\n+                              public void test() {\n+                                  int i1 = NonPreview.CONST1;\n+                                  int i2 = NonPreviewIntf.CONST1;\n+                                  int i3 = Preview.CONST1;\n+                                  int i4 = NonPreview.CONST2;\n+                                  int i5 = NonPreviewIntf.CONST2;\n+                                  int i6 = Preview.CONST2;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:4:19: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:7:28: compiler.err.is.preview: CONST1\",\n+                        \"Test.java:8:32: compiler.err.is.preview: CONST1\",\n+                        \"Test.java:9:18: compiler.err.is.preview: preview.api.Preview\",\n+                        \"Test.java:12:18: compiler.err.is.preview: preview.api.Preview\",\n+                        \"5 errors\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found\" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":421,"deletions":14,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345145\n+ * @summary javap should not print LineNumberTable\/LocalVariableTable (-l) without disassembled code (-c).\n+ * @compile -g ClassWriterNoLineVariableTableTest.java\n+ * @run junit ClassWriterNoLineVariableTableTest\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ClassWriterNoLineVariableTableTest {\n+    String expectedErrorOutput = \"Warning: bad combination of options: -l without -c, line number and local variable tables will not be printed\";\n+\n+    @Test\n+    public void testJavapWithoutCodeAttribute() {\n+        String output = javap(\"-l\");\n+        assertContains(output, expectedErrorOutput,\n+            \"javap should throw warning, when -l used without -c or -v\");\n+        assertNotContains(output, \"LineNumberTable\",\n+            \"There should be no LineNumberTable output when javap is provided l without -c or -v\");\n+        assertNotContains(output, \"LocalVariableTable\",\n+            \"There should be no LineNumberTable output when javap is provided l without -c or -v\");\n+    }\n+\n+    @ParameterizedTest(name = \"Test javap with fixed option -l and varying option: {0}\")\n+    @ValueSource(strings = {\"-v\", \"-c\"})\n+    public void testJavapWithCodeAttribute(String addedOption) {\n+        String output = javap(\"-l\", addedOption);\n+        assertNotContains(output, expectedErrorOutput,\n+            \"There should be no warning when javap is provided -l and \" + addedOption);\n+        assertContains(output, \"LineNumberTable\",\n+            \"There should be LineNumberTable output when javap is provided -l and \" + addedOption);\n+        assertContains(output, \"LocalVariableTable\",\n+            \"There should be LocalVariableTable output when javap is provided -l and \" + addedOption);\n+    }\n+\n+    private static void assertContains(String actual, String expectedSubstring, String message) {\n+        assertTrue(actual.contains(expectedSubstring),\n+            message + \" - Expected '\" + actual + \"' to contain '\" + expectedSubstring + \"'\");\n+    }\n+\n+    private static void assertNotContains(String actual, String expectedSubstring, String message) {\n+        assertFalse(actual.contains(expectedSubstring),\n+            message + \" - Expected '\" + actual + \"' not to contain '\" + expectedSubstring + \"'\");\n+    }\n+\n+    private String javap(String... args) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter out = new PrintWriter(sw);\n+\n+        String[] fullArgs = new String[args.length + 1];\n+        System.arraycopy(args, 0, fullArgs, 0, args.length);\n+        fullArgs[args.length] = System.getProperty(\"test.classes\") + \"\/RandomLoop8345145.class\";\n+\n+        int rc = com.sun.tools.javap.Main.run(fullArgs, out);\n+        if (rc != 0)\n+            throw new Error(\"javap failed. rc=\" + rc);\n+        out.close();\n+        System.out.println(sw);\n+        return sw.toString();\n+    }\n+}\n+\n+class RandomLoop8345145 {\n+    public void randomLoop() {\n+        int x = 5;\n+        for (int i = 0; i < 10; i++) {\n+            x*=2;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javap\/ClassWriterNoLineVariableTableTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -55,1 +55,1 @@\n-        List<String[]> runArgsList = List.of(new String[]{\"-c\", \"-l\"}, new String[]{\"-v\"}, new String[]{\"-l\"});\n+        List<String[]> runArgsList = List.of(new String[]{\"-c\", \"-l\"}, new String[]{\"-v\"});\n","filename":"test\/langtools\/tools\/javap\/ClassWriterTableIndentTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        int rc = com.sun.tools.javap.Main.run(new String[] { \"-l\", f.getPath() }, out);\n+        int rc = com.sun.tools.javap.Main.run(new String[] { \"-l\", \"-c\", f.getPath() }, out);\n","filename":"test\/langtools\/tools\/javap\/T4459541.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        test(clazz, count, \"-l\");\n+        test(clazz, count, \"-c\", \"-l\");\n","filename":"test\/langtools\/tools\/javap\/T8032814.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    public static final String ShenandoahEvacuationInformation = PREFIX + \"ShenandoahEvacuationInformation\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-                \"--add-opens\", \"--upgrade-module-path\", \"--add-modules\", \"--add-exports\",\n+                \"--add-opens\", \"--upgrade-module-path\", \"--add-modules\", \"--add-exports\", \"--enable-native-access\",\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.BitSet;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(3)\n+public class DoubleBitConversion {\n+\n+    double doubleZero = 0;\n+    double doubleOne = 1;\n+    double doubleNan = Double.NaN;\n+\n+    long longDoubleZero = Double.doubleToLongBits(0);\n+    long longDoubleOne = Double.doubleToLongBits(1);\n+    long longDoubleNaN = Double.doubleToLongBits(Double.NaN);\n+\n+    @Benchmark\n+    public long doubleToRawLongBits_zero() {\n+        return Double.doubleToRawLongBits(doubleZero);\n+    }\n+\n+    @Benchmark\n+    public long doubleToRawLongBits_one() {\n+        return Double.doubleToRawLongBits(doubleOne);\n+    }\n+\n+    @Benchmark\n+    public long doubleToRawLongBits_NaN() {\n+        return Double.doubleToRawLongBits(doubleNan);\n+    }\n+\n+    @Benchmark\n+    public long doubleToLongBits_zero() {\n+        return Double.doubleToLongBits(doubleZero);\n+    }\n+\n+    @Benchmark\n+    public long doubleToLongBits_one() {\n+        return Double.doubleToLongBits(doubleOne);\n+    }\n+\n+    @Benchmark\n+    public long doubleToLongBits_NaN() {\n+        return Double.doubleToLongBits(doubleNan);\n+    }\n+\n+    @Benchmark\n+    public double longBitsToDouble_zero() {\n+        return Double.longBitsToDouble(longDoubleZero);\n+    }\n+\n+    @Benchmark\n+    public double longBitsToDouble_one() {\n+        return Double.longBitsToDouble(longDoubleOne);\n+    }\n+\n+    @Benchmark\n+    public double longBitsToDouble_NaN() {\n+        return Double.longBitsToDouble(longDoubleNaN);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/DoubleBitConversion.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.BitSet;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(3)\n+public class FloatBitConversion {\n+\n+    float floatZero = 0;\n+    float floatOne = 1;\n+    float floatNan = Float.NaN;\n+\n+    int intFloatZero = Float.floatToIntBits(0);\n+    int intFloatOne = Float.floatToIntBits(1);\n+    int intFloatNaN = Float.floatToIntBits(Float.NaN);\n+\n+    @Benchmark\n+    public int floatToRawIntBits_zero() {\n+        return Float.floatToRawIntBits(floatZero);\n+    }\n+\n+    @Benchmark\n+    public int floatToRawIntBits_one() {\n+        return Float.floatToRawIntBits(floatOne);\n+    }\n+\n+    @Benchmark\n+    public int floatToRawIntBits_NaN() {\n+        return Float.floatToRawIntBits(floatNan);\n+    }\n+\n+    @Benchmark\n+    public int floatToIntBits_zero() {\n+        return Float.floatToIntBits(floatZero);\n+    }\n+\n+    @Benchmark\n+    public int floatToIntBits_one() {\n+        return Float.floatToIntBits(floatOne);\n+    }\n+\n+    @Benchmark\n+    public int floatToIntBits_NaN() {\n+        return Float.floatToIntBits(floatNan);\n+    }\n+\n+    @Benchmark\n+    public float intBitsToFloat_zero() {\n+        return Float.intBitsToFloat(intFloatZero);\n+    }\n+\n+    @Benchmark\n+    public float intBitsToFloat_one() {\n+        return Float.intBitsToFloat(intFloatOne);\n+    }\n+\n+    @Benchmark\n+    public float intBitsToFloat_NaN() {\n+        return Float.intBitsToFloat(intFloatNaN);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatBitConversion.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.StringSupport;\n@@ -46,1 +48,0 @@\n-import static jdk.internal.foreign.StringSupport.*;\n@@ -53,1 +54,2 @@\n-@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+                            \"--enable-native-access=ALL-UNNAMED\"})\n@@ -56,4 +58,4 @@\n-    private MemorySegment singleByteSegment;\n-    private MemorySegment singleByteSegmentMisaligned;\n-    private MemorySegment doubleByteSegment;\n-    private MemorySegment quadByteSegment;\n+    private AbstractMemorySegmentImpl singleByteSegment;\n+    private AbstractMemorySegmentImpl singleByteSegmentMisaligned;\n+    private AbstractMemorySegmentImpl doubleByteSegment;\n+    private AbstractMemorySegmentImpl quadByteSegment;\n@@ -67,4 +69,3 @@\n-        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n-        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n-        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n-        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        singleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Integer.BYTES);\n@@ -81,1 +82,1 @@\n-        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+        singleByteSegmentMisaligned = (AbstractMemorySegmentImpl) arena.allocate(singleByteSegment.byteSize() + 1).\n@@ -108,1 +109,1 @@\n-        return chunkedStrlenByte(singleByteSegment, 0);\n+        return StringSupport.strlenByte(singleByteSegment, 0, singleByteSegment.byteSize());\n@@ -113,1 +114,1 @@\n-        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+        return StringSupport.strlenByte(singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n@@ -118,1 +119,1 @@\n-        return chunkedStrlenShort(doubleByteSegment, 0);\n+        return StringSupport.strlenShort(doubleByteSegment, 0, doubleByteSegment.byteSize());\n@@ -123,1 +124,1 @@\n-        return strlenInt(quadByteSegment, 0);\n+        return StringSupport.strlenInt(quadByteSegment, 0, quadByteSegment.byteSize());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\", \"-Djava.library.path=micro\/native\" })\n+@Fork(value = 3, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean register = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return new Target(register);\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        public Target(boolean register) {\n+            if (register) {\n+                CLEANER.register(this, () -> {});\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerChurn.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.ArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx1g\", \"-Xms1g\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Make sure all targets are reachable and available for GC in scalable manner.\n+    \/\/ This exposes the potential GC problem in Cleaner lists.\n+    ArrayList<Target> targets;\n+\n+    @Setup\n+    public void setup() {\n+        targets = new ArrayList<>();\n+        for (int c = 0; c < count; c++) {\n+            targets.add(new Target());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        public Target() {\n+            CLEANER.register(this, () -> {});\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerGC.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.reflect;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark for regression in native method invocation.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class NativeMethodInvoke {\n+\n+    private Method objectHashCode;\n+    private Method threadCurrentThread;\n+\n+    private Object[] objects;\n+\n+    @Setup\n+    public void setup() throws ReflectiveOperationException {\n+        objects = new Object[]{\n+                1, 5L,\n+                5.6d, 23.11f,\n+                Boolean.TRUE, 'd'\n+        };\n+\n+        objectHashCode = Object.class.getDeclaredMethod(\"hashCode\");\n+        threadCurrentThread = Thread.class.getDeclaredMethod(\"currentThread\");\n+    }\n+\n+    @Benchmark\n+    public void objectHashCode(Blackhole bh) throws ReflectiveOperationException {\n+        for (var obj : objects) {\n+            bh.consume(objectHashCode.invoke(obj));\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object threadCurrentThread() throws ReflectiveOperationException {\n+        return threadCurrentThread.invoke(null);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/NativeMethodInvoke.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -50,0 +50,1 @@\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AbstractCorpusBenchmark.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -40,0 +40,1 @@\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RepeatedModelTraversal.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n@@ -29,1 +27,0 @@\n-import java.util.Optional;\n@@ -46,1 +43,1 @@\n-import java.lang.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.ClassRemapper;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}