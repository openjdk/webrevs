{"files":[{"patch":"@@ -1327,0 +1327,4 @@\n+\n+  void after_restore(void) override {\n+    _hrm.after_restore();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,3 @@\n-  _regions(), _heap_mapper(nullptr),\n+  _regions(),\n+  _max_available_regions(0),\n+  _heap_mapper(nullptr),\n@@ -89,0 +91,2 @@\n+  _max_available_regions = (uint) (CRaCMaxHeapSizeBeforeCheckpoint == 0 ? _regions.length() :\n+    CRaCMaxHeapSizeBeforeCheckpoint \/ G1HeapRegion::GrainBytes);\n@@ -93,0 +97,4 @@\n+void G1HeapRegionManager::after_restore() {\n+  _max_available_regions = (uint) _regions.length();\n+}\n+\n@@ -134,1 +142,3 @@\n-  expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers());\n+  if (!expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers())) {\n+    return nullptr;\n+  }\n@@ -165,0 +175,4 @@\n+  assert(_committed_map.num_active() + _committed_map.num_inactive() + num_regions <= _max_available_regions,\n+    \"Expanding over the limit: %d active, %d inactive, %d requested, limit %d\",\n+    _committed_map.num_active(), _committed_map.num_inactive(), num_regions, _max_available_regions);\n+\n@@ -343,2 +357,5 @@\n-    uint to_expand = MIN2(num_regions - expanded, regions.length());\n-    expand(regions.start(), to_expand, pretouch_workers);\n+    uint to_expand = MIN3(num_regions - expanded, regions.length(),\n+      _max_available_regions - _committed_map.num_active() - _committed_map.num_inactive());\n+    if (to_expand > 0) {\n+      expand(regions.start(), to_expand, pretouch_workers);\n+    }\n@@ -368,1 +385,1 @@\n-void G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+bool G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -387,0 +404,6 @@\n+      \/\/ Fail if we're over the limits (were not able to just reactivate)\n+      if (_committed_map.num_active() + _committed_map.num_inactive() + (i - start) + 1 > _max_available_regions) {\n+        log_debug(gc)(\"Cannot expand to regions %u - %u: active %u, inactive %u, max %u\", start, end,\n+         _committed_map.num_active(),  _committed_map.num_inactive(), _max_available_regions);\n+        return false;\n+      }\n@@ -394,0 +417,1 @@\n+  return true;\n@@ -400,4 +424,12 @@\n-    for (uint i = 0; i < reserved_length(); i++) {\n-      if (is_available(i)) {\n-        \/\/ Already in use continue\n-        continue;\n+    if (_committed_map.num_active() + _committed_map.num_inactive() >= _max_available_regions) {\n+      \/\/ We have to use existing inactive region, cannot allocate new one\n+      \/\/ while we have inactive.\n+      for (uint i = 0; i < reserved_length(); i++) {\n+        if (!_committed_map.inactive(i)) {\n+          continue;\n+        }\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -405,5 +437,13 @@\n-      \/\/ Always save the candidate so we can expand later on.\n-      expand_candidate = i;\n-      if (is_on_preferred_index(expand_candidate, preferred_index)) {\n-        \/\/ We have found a candidate on the preferred node, break.\n-        break;\n+    }\n+    if (expand_candidate == UINT_MAX) {\n+      for (uint i = 0; i < reserved_length(); i++) {\n+        if (is_available(i)) {\n+          \/\/ Already in use continue\n+          continue;\n+        }\n+        \/\/ Always save the candidate so we can expand later on.\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -416,0 +456,1 @@\n+    log_debug(gc)(\"No regions left\");\n@@ -418,0 +459,1 @@\n+  log_debug(gc)(\"Candidate is %u\", expand_candidate);\n@@ -419,2 +461,1 @@\n-  expand_exact(expand_candidate, 1, nullptr);\n-  return 1;\n+  return expand_exact(expand_candidate, 1, nullptr) ? 1 : 0;\n@@ -542,1 +583,3 @@\n-      expand_exact(curr_index, 1, pretouch_workers);\n+      if (!expand_exact(curr_index, 1, pretouch_workers)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+  uint _max_available_regions;\n@@ -148,1 +149,1 @@\n-  void expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers);\n+  bool expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers);\n@@ -233,1 +234,1 @@\n-  uint available() const { return max_length() - length(); }\n+  uint available() const { return _max_available_regions - length(); }\n@@ -290,0 +291,2 @@\n+\n+  void after_restore(void);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -529,0 +529,2 @@\n+\n+  virtual void after_restore(void) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+  assert(CRaCMaxHeapSizeBeforeCheckpoint == 0 || CRaCMaxHeapSizeBeforeCheckpoint >= InitialHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n+  assert(CRaCMaxHeapSizeBeforeCheckpoint == 0 || CRaCMaxHeapSizeBeforeCheckpoint <= MaxHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n@@ -168,0 +170,20 @@\n+  if (FLAG_IS_CMDLINE(CRaCMaxHeapSizeBeforeCheckpoint)) {\n+    if (!UseG1GC) {\n+      vm_exit_during_initialization(\"CRaCMaxHeapSizeBeforeCheckpoint can be used only with G1 garbage collector.\");\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint < InitialHeapSize) {\n+      if (FLAG_IS_CMDLINE(InitialHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible initial heap and maximum before checkpoint sizes specified\");\n+      } else {\n+        FLAG_SET_ERGO(InitialHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint > MaxHeapSize) {\n+      if (FLAG_IS_CMDLINE(MaxHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible heap sizes - maximum before checkpoint and absolute maximum - specified\");\n+      } else {\n+        FLAG_SET_ERGO(MaxHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -476,0 +476,2 @@\n+  Universe::heap()->after_restore();\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2007,0 +2007,3 @@\n+  product(size_t, CRaCMaxHeapSizeBeforeCheckpoint, 0, \"Maximum size \"       \\\n+      \"of heap before checkpoint. By default equals to -Xmx.\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        long maxHeapSize = Long.parseLong(analyzer.firstMatch(\"MaxHeapSize.+=\\\\s+(\\\\d+)\",1));\n+        long maxHeapSize = Long.parseLong(analyzer.firstMatch(\"\\\\bMaxHeapSize\\\\b.+=\\\\s+(\\\\d+)\",1));\n","filename":"test\/hotspot\/jtreg\/gc\/TestSmallHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.util.HashMap;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test ContainerOOMETest\n+ * @requires (os.family == \"linux\")\n+ * @requires container.support\n+ * @library \/test\/lib\n+ * @build ContainerOOMETest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n+ *\/\n+public class ContainerOOMETest implements CracTest {\n+    private static final String AFTER_OOME = \"AFTER OOME\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        final String imageName = Common.imageName(\"oome-test\");\n+        CracBuilder builder = new CracBuilder()\n+                .captureOutput(true)\n+                .inDockerImage(imageName)\n+                .dockerOptions(\"-m\", \"256M\")\n+                .runContainerDirectly(true)\n+                \/\/ Without specific request for G1 we would get Serial on 256M\n+                .vmOption(\"-XX:+UseG1GC\")\n+                .vmOption(\"-Xmx4G\")\n+                .vmOption(\"-XX:CRaCMaxHeapSizeBeforeCheckpoint=128M\");\n+        try {\n+            builder.startCheckpoint().outputAnalyzer()\n+                    .shouldHaveExitValue(137) \/\/ checkpoint\n+                    .stderrShouldContain(AFTER_OOME);\n+            builder.clearDockerOptions().clearVmOptions().captureOutput(false);\n+            builder.doRestore();\n+        } finally {\n+            builder.ensureContainerKilled();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try {\n+            lotOfAllocations();\n+            fail(\"Should have OOMEd\");\n+        } catch (OutOfMemoryError error) {\n+            \/\/ ignore the error\n+        }\n+        System.err.println(AFTER_OOME);\n+        Core.checkpointRestore();\n+        lotOfAllocations();\n+    }\n+\n+    private static void lotOfAllocations() {\n+        HashMap<String, String> map = new HashMap<>();\n+        for (int i = 0; i < 10000000; ++i) {\n+            String str = String.valueOf(i);\n+            map.put(str, str);\n+            if (i % 1000000 == 0) {\n+                System.err.println(i + \": \" + Runtime.getRuntime().totalMemory());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContainerOOMETest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -165,1 +165,1 @@\n-    public void clearVmOptions() {\n+    public CracBuilder clearVmOptions() {\n@@ -167,0 +167,1 @@\n+        return this;\n@@ -229,0 +230,6 @@\n+    public CracBuilder clearDockerOptions() {\n+        assertNotNull(dockerOptions);;\n+        this.dockerOptions = null;\n+        return this;\n+    }\n+\n@@ -406,1 +413,3 @@\n-        ensureContainerStarted();\n+        if (!runContainerDirectly) {\n+            ensureContainerStarted();\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}