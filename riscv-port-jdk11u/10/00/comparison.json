{"files":[{"patch":"@@ -133,6 +133,0 @@\n-  # Because RISC-V only has word-sized atomics, it requries libatomic where\n-  # other common architectures do not.  So link libatomic by default.\n-  if test \"x$OPENJDK_TARGET_OS\" = xlinux && test \"x$OPENJDK_TARGET_CPU\" = xriscv64; then\n-    BASIC_JVM_LIBS=\"$BASIC_JVM_LIBS -latomic\"\n-  fi\n-\n","filename":"make\/autoconf\/libraries.m4","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,6 @@\n+#if defined(__clang_major__)\n+#define FULL_COMPILER_ATOMIC_SUPPORT\n+#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ >= 2))\n+#define FULL_COMPILER_ATOMIC_SUPPORT\n+#endif\n+\n@@ -46,0 +52,6 @@\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+    \/\/ If we add add and fetch for sub word and are using older compiler\n+    \/\/ it must be added here due to not using lib atomic.\n+    STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n@@ -57,0 +69,46 @@\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+template<>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest __attribute__((unused)),\n+                                                T compare_value,\n+                                                T exchange_value,\n+                                                atomic_memory_order order) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  uint32_t volatile* aligned_dst = (uint32_t volatile*)(((uintptr_t)dest) & (~((uintptr_t)0x3)));\n+  int shift = 8 * (((uintptr_t)dest) - ((uintptr_t)aligned_dst)); \/\/ 0, 8, 16, 24\n+\n+  uint64_t mask = 0xfful << shift; \/\/ 0x00000000..FF..\n+  uint64_t remask = ~mask;         \/\/ 0xFFFFFFFF..00..\n+\n+  uint64_t w_cv = ((uint64_t)(unsigned char)compare_value) << shift;  \/\/ widen to 64-bit 0x00000000..CC..\n+  uint64_t w_ev = ((uint64_t)(unsigned char)exchange_value) << shift; \/\/ widen to 64-bit 0x00000000..EE..\n+\n+  uint64_t old_value;\n+  uint64_t rc_temp;\n+\n+  __asm__ __volatile__ (\n+    \"1:  lr.w      %0, %2      \\n\\t\"\n+    \"    and       %1, %0, %5  \\n\\t\" \/\/ ignore unrelated bytes and widen to 64-bit 0x00000000..XX..\n+    \"    bne       %1, %3, 2f  \\n\\t\" \/\/ compare 64-bit w_cv\n+    \"    and       %1, %0, %6  \\n\\t\" \/\/ remove old byte\n+    \"    or        %1, %1, %4  \\n\\t\" \/\/ add new byte\n+    \"    sc.w      %1, %1, %2  \\n\\t\" \/\/ store new word\n+    \"    bnez      %1, 1b      \\n\\t\"\n+    \"2:                        \\n\\t\"\n+    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*aligned_dst)\n+    : \/*%3*\/\"r\" (w_cv), \/*%4*\/\"r\" (w_ev), \/*%5*\/\"r\" (mask), \/*%6*\/\"r\" (remask)\n+    : \"memory\" );\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  return (T)((old_value & mask) >> shift);\n+}\n+#endif\n+\n@@ -62,0 +120,6 @@\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+  \/\/ If we add xchg for sub word and are using older compiler\n+  \/\/ it must be added here due to not using lib atomic.\n+  STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n@@ -75,0 +139,5 @@\n+\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+  STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomic_linux_riscv.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"}]}