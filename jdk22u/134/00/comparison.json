{"files":[{"patch":"@@ -3153,0 +3153,4 @@\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n+  assert_different_registers(temp1, temp2, oop, box);\n+\n@@ -3156,1 +3160,1 @@\n-  z_lg(displacedHeader, 0, oop);\n+  z_lg(displacedHeader, hdr_offset, oop);\n@@ -3159,2 +3163,2 @@\n-    load_klass(Z_R1_scratch, oop);\n-    z_l(Z_R1_scratch, Address(Z_R1_scratch, Klass::access_flags_offset()));\n+    load_klass(temp, oop);\n+    z_l(temp, Address(temp, Klass::access_flags_offset()));\n@@ -3162,1 +3166,1 @@\n-    z_nilh(Z_R1_scratch, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n@@ -3169,3 +3173,2 @@\n-  z_lgr(temp, displacedHeader);\n-  z_nill(temp, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+  z_tmll(displacedHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3175,0 +3178,1 @@\n+    \/\/ From loading the markWord, we know that oop != nullptr\n@@ -3186,6 +3190,3 @@\n-    \/\/ Memory Fence (in cmpxchgd)\n-    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-\n-    \/\/ If the compare-and-swap succeeded, then we found an unlocked object and we\n-    \/\/ have now locked it.\n-    z_csg(displacedHeader, box, 0, oop);\n+    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n+    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n+    z_csg(displacedHeader, box, hdr_offset, oop);\n@@ -3195,2 +3196,4 @@\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n+    \/\/ We did not see an unlocked object\n+    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n+    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n+    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n@@ -3201,2 +3204,4 @@\n-    \/\/   z_brne(done);\n-    \/\/   z_release();\n+\n+    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n+    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n+\n@@ -3212,0 +3217,2 @@\n+  bind(object_has_monitor);\n+\n@@ -3214,1 +3221,0 @@\n-  bind(object_has_monitor);\n@@ -3217,1 +3223,1 @@\n-  \/\/\n+\n@@ -3219,1 +3225,0 @@\n-  z_lghi(zero, 0);\n@@ -3221,0 +3226,2 @@\n+  \/\/ Otherwise, register zero is filled with the current owner.\n+  z_lghi(zero, 0);\n@@ -3226,8 +3233,12 @@\n-#ifdef ASSERT\n-  z_brne(done);\n-  \/\/ We've acquired the monitor, check some invariants.\n-  \/\/ Invariant 1: _recursions should be 0.\n-  asm_assert_mem8_is_zero(OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions), monitor_tagged,\n-                          \"monitor->_recursions should be 0\", -1);\n-  z_ltgr(zero, zero); \/\/ Set CR=EQ.\n-#endif\n+\n+  z_bre(done); \/\/ acquired the lock for the first time.\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n+  \/\/ Check if we are already the owner (recursive lock)\n+  z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n+  z_brne(done); \/\/ not a recursive lock\n+\n+  \/\/ Current thread already owns the lock. Just increment recursion count.\n+  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n+  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n@@ -3246,1 +3257,0 @@\n-  Register monitor = temp2;\n@@ -3250,1 +3260,3 @@\n-  Label done, object_has_monitor;\n+  assert_different_registers(temp1, temp2, oop, box);\n+\n+  Label done, object_has_monitor, not_recursive;\n@@ -3265,5 +3277,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    z_lgr(temp, currentHeader);\n-  }\n-  z_nill(currentHeader, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+\n+  z_tmll(currentHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3276,1 +3286,1 @@\n-    \/\/ Check if it is still a light weight lock, this is true if we see\n+    \/\/ Check if it is still a lightweight lock, this is true if we see\n@@ -3280,1 +3290,1 @@\n-    z_csg(currentHeader, displacedHeader, 0, oop);\n+    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n@@ -3285,4 +3295,1 @@\n-    \/\/ don't load currentHead again from stack-top after monitor check, as it is possible\n-    \/\/ some other thread modified it.\n-    \/\/ currentHeader is altered, but it's contents are copied in temp as well\n-    lightweight_unlock(oop, temp, currentHeader, done);\n+    lightweight_unlock(oop, currentHeader, displacedHeader, done);\n@@ -3297,4 +3304,2 @@\n-  z_lg(currentHeader, hdr_offset, oop);    \/\/ CurrentHeader is tagged with monitor_value set.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_brne(done);\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+\n+  z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n@@ -3302,0 +3307,13 @@\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n+  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+\n+  \/\/ Recursive inflated unlock\n+  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n+  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n+  z_bru(done);\n+\n+  bind(not_recursive);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":63,"deletions":45,"binary":false,"changes":108,"status":"modified"}]}