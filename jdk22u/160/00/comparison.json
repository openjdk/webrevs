{"files":[{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -34,0 +35,1 @@\n+ * @library \/test\/lib\n@@ -38,1 +40,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -42,0 +43,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -78,1 +80,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -81,1 +83,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -90,1 +92,1 @@\n-            latch.await();\n+            awaitTrue(started);\n@@ -110,1 +112,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -113,1 +115,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -120,1 +122,1 @@\n-                latch.await();\n+                awaitTrue(started);\n@@ -140,1 +142,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -144,1 +146,1 @@\n-                latch.countDown();\n+                started.set(true);\n@@ -151,2 +153,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -182,1 +184,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -186,1 +188,1 @@\n-                latch.countDown();\n+                started.set(true);\n@@ -193,2 +195,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -224,1 +226,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -227,1 +229,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -234,1 +236,1 @@\n-            latch.await();\n+            awaitTrue(started);\n@@ -254,1 +256,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -257,1 +259,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -264,1 +266,1 @@\n-            latch.await();\n+            awaitTrue(started);\n@@ -284,2 +286,1 @@\n-        var latch = new CountDownLatch(1);\n-        Object lock = new Object();\n+        var started = new AtomicBoolean();\n@@ -288,2 +289,2 @@\n-            synchronized (lock) {\n-                latch.countDown();\n+            VThreadPinner.runPinned(() -> {\n+                started.set(true);\n@@ -293,1 +294,1 @@\n-            }\n+            });\n@@ -296,2 +297,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -317,2 +318,1 @@\n-        var latch = new CountDownLatch(1);\n-        Object lock = new Object();\n+        var started = new AtomicBoolean();\n@@ -321,2 +321,2 @@\n-            synchronized (lock) {\n-                latch.countDown();\n+            VThreadPinner.runPinned(() -> {\n+                started.set(true);\n@@ -326,1 +326,1 @@\n-            }\n+            });\n@@ -329,2 +329,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -345,0 +345,9 @@\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws Exception {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    static final long DURATION_IN_NANOS = Duration.ofMinutes(2).toNanos();\n+    static final long DURATION_IN_NANOS = Duration.ofMinutes(1).toNanos();\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/StressStackOverflow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -58,0 +57,2 @@\n+            var vthreadRef = new AtomicReference<Thread>();\n+\n@@ -60,1 +61,5 @@\n-                    carrierRef.set(Thread.currentThread());\n+                    Thread carrier = Thread.currentThread();\n+                    carrierRef.set(carrier);\n+                    Thread vthread = vthreadRef.get();\n+\n+                    System.err.format(\"%s run task (%s) ...%n\", carrier, vthread);\n@@ -62,0 +67,1 @@\n+                    System.err.format(\"%s task done (%s)%n\", carrier, vthread);\n@@ -66,1 +72,1 @@\n-            var latch = new CountDownLatch(1);\n+            var started = new AtomicBoolean();\n@@ -69,2 +75,2 @@\n-            Thread vthread = builder.start(() -> {\n-                latch.countDown();\n+            Thread vthread = builder.unstarted(() -> {\n+                started.set(true);\n@@ -75,3 +81,2 @@\n-\n-            \/\/ wait for virtual thread to execute\n-            latch.await();\n+            vthreadRef.set(vthread);\n+            vthread.start();\n@@ -80,1 +85,8 @@\n-                long carrierId = carrierRef.get().threadId();\n+                \/\/ wait for virtual thread to start\n+                while (!started.get()) {\n+                    Thread.sleep(10);\n+                }\n+\n+                Thread carrier = carrierRef.get();\n+\n+                long carrierId = carrier.threadId();\n@@ -85,5 +97,7 @@\n-                assertTrue(ti.getThreadState() == Thread.State.WAITING);\n-                assertEquals(vthread.getClass().getName(), ti.getLockInfo().getClassName());\n-                assertTrue(ti.getLockInfo().getIdentityHashCode() == System.identityHashCode(vthread));\n-                assertTrue(ti.getLockOwnerId() == vthreadId);\n-\n+                Thread.State state = ti.getThreadState();\n+                LockInfo lockInfo = ti.getLockInfo();\n+                assertEquals(Thread.State.WAITING, state);\n+                assertNotNull(lockInfo);\n+                assertEquals(vthread.getClass().getName(), lockInfo.getClassName());\n+                assertEquals(System.identityHashCode(vthread), lockInfo.getIdentityHashCode());\n+                assertEquals(vthreadId, ti.getLockOwnerId());\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CarrierThreadWaits.java","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.nio.channels.ClosedSelectorException;\n-import java.nio.channels.Selector;\n@@ -35,0 +33,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -40,1 +39,0 @@\n-        try (Selector sel = Selector.open()) {\n@@ -42,5 +40,5 @@\n-            \/\/ start thread1 and wait for it to park\n-            Thread thread1 = Thread.startVirtualThread(LockSupport::park);\n-            while (thread1.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+        \/\/ start thread1 and wait for it to park\n+        Thread thread1 = Thread.startVirtualThread(LockSupport::park);\n+        while (thread1.getState() != Thread.State.WAITING) {\n+            Thread.sleep(20);\n+        }\n@@ -48,13 +46,14 @@\n-            \/\/ start thread2 to pin the carrier thread\n-            CountDownLatch latch = new CountDownLatch(1);\n-            Thread thread2 = Thread.startVirtualThread(() -> {\n-                latch.countDown();\n-                try {\n-                    sel.select();\n-                } catch (ClosedSelectorException e) {\n-                    \/\/ expected\n-                } catch (IOException ioe) {\n-                    ioe.printStackTrace();\n-                }\n-            });\n-            latch.await();   \/\/ wait for thread2 to run\n+        \/\/ start thread2 to pin the carrier thread\n+        var started = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n+        Thread thread2 = Thread.startVirtualThread(() -> {\n+            started.set(true);\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread2 to start\n+            while (!started.get()) {\n+                Thread.sleep(10);\n+            }\n@@ -76,0 +75,4 @@\n+        } finally {\n+            done.set(true);\n+            thread2.join();\n+            thread1.join();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTraceWhenRunnable.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * @run junit\/othervm JfrEvents\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED JfrEvents\n@@ -34,1 +35,0 @@\n-import java.time.Duration;\n@@ -42,0 +42,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -44,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -45,0 +47,1 @@\n+import java.util.stream.Stream;\n@@ -51,0 +54,2 @@\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner.ThrowingRunnable;\n@@ -52,0 +57,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -55,1 +63,0 @@\n-    private static final Object lock = new Object();\n@@ -88,0 +95,49 @@\n+    \/**\n+     * Arguments for testVirtualThreadPinned to test jdk.VirtualThreadPinned event.\n+     *   [0] label\/description\n+     *   [1] the operation to park\/wait\n+     *   [2] the Thread.State when parked\/waiting\n+     *   [3] the action to unpark\/notify the thread\n+     *\/\n+    static Stream<Arguments> pinnedCases() {\n+        Object lock = new Object();\n+\n+        \/\/ park with native frame on stack\n+        var finish1 = new AtomicBoolean();\n+        var parkWhenPinned = Arguments.of(\n+            \"LockSupport.park when pinned\",\n+            (ThrowingRunnable<Exception>) () -> {\n+                VThreadPinner.runPinned(() -> {\n+                    while (!finish1.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            },\n+            Thread.State.WAITING,\n+                (Consumer<Thread>) t -> {\n+                    finish1.set(true);\n+                    LockSupport.unpark(t);\n+                }\n+        );\n+\n+        \/\/ timed park with native frame on stack\n+        var finish2 = new AtomicBoolean();\n+        var timedParkWhenPinned = Arguments.of(\n+            \"LockSupport.parkNanos when pinned\",\n+            (ThrowingRunnable<Exception>) () -> {\n+                VThreadPinner.runPinned(() -> {\n+                    while (!finish2.get()) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    }\n+                });\n+            },\n+            Thread.State.TIMED_WAITING,\n+            (Consumer<Thread>) t -> {\n+                finish2.set(true);\n+                LockSupport.unpark(t);\n+            }\n+        );\n+\n+        return Stream.of(parkWhenPinned, timedParkWhenPinned);\n+    }\n+\n@@ -91,6 +147,6 @@\n-    @Test\n-    void testVirtualThreadPinned() throws Exception {\n-        Runnable[] parkers = new Runnable[] {\n-            () -> LockSupport.park(),\n-            () -> LockSupport.parkNanos(Duration.ofDays(1).toNanos())\n-        };\n+    @ParameterizedTest\n+    @MethodSource(\"pinnedCases\")\n+    void testVirtualThreadPinned(String label,\n+                                 ThrowingRunnable<Exception> parker,\n+                                 Thread.State expectedState,\n+                                 Consumer<Thread> unparker) throws Exception {\n@@ -102,16 +158,3 @@\n-            try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n-                for (Runnable parker : parkers) {\n-                    \/\/ execute parking task in virtual thread\n-                    var threadRef = new AtomicReference<Thread>();\n-                    executor.submit(() -> {\n-                        threadRef.set(Thread.currentThread());\n-                        synchronized (lock) {\n-                            parker.run();   \/\/ should pin carrier\n-                        }\n-                    });\n-\n-                    \/\/ wait for the task to start and the virtual thread to park\n-                    Thread thread;\n-                    while ((thread = threadRef.get()) == null) {\n-                        Thread.sleep(10);\n-                    }\n+            try {\n+                var exception = new AtomicReference<Throwable>();\n+                var thread = Thread.ofVirtual().start(() -> {\n@@ -119,7 +162,12 @@\n-                        Thread.State state = thread.getState();\n-                        while (state != Thread.State.WAITING && state != Thread.State.TIMED_WAITING) {\n-                            Thread.sleep(10);\n-                            state = thread.getState();\n-                        }\n-                    } finally {\n-                        LockSupport.unpark(thread);\n+                        parker.run();\n+                    } catch (Throwable e) {\n+                        exception.set(e);\n+                    }\n+                });\n+                try {\n+                    \/\/ wait for thread to park\/wait\n+                    Thread.State state = thread.getState();\n+                    while (state != expectedState) {\n+                        assertTrue(state != Thread.State.TERMINATED, thread.toString());\n+                        Thread.sleep(10);\n+                        state = thread.getState();\n@@ -127,0 +175,4 @@\n+                } finally {\n+                    unparker.accept(thread);\n+                    thread.join();\n+                    assertNull(exception.get());\n@@ -135,1 +187,1 @@\n-            \/\/ should have a pinned event for each park\n+            \/\/ should have at least one pinned event\n@@ -137,1 +189,1 @@\n-            assertEquals(parkers.length, pinnedCount);\n+            assertTrue(pinnedCount >= 1, \"Expected one or more events\");\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":86,"deletions":34,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test virtual threads using Object.wait\/notifyAll\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit MonitorWaitNotify\n+ *\/\n+\n+import java.util.concurrent.Semaphore;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MonitorWaitNotify {\n+\n+    \/**\n+     * Test virtual thread waits, notified by platform thread.\n+     *\/\n+    @Test\n+    void testWaitNotify1() throws Exception {\n+        var lock = new Object();\n+        var ready = new Semaphore(0);\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                ready.release();\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        \/\/ thread invokes notify\n+        ready.acquire();\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+        thread.join();\n+    }\n+\n+    \/**\n+     * Test platform thread waits, notified by virtual thread.\n+     *\/\n+    @Test\n+    void testWaitNotify2() throws Exception {\n+        var lock = new Object();\n+        var ready = new Semaphore(0);\n+        var thread = Thread.ofVirtual().start(() -> {\n+            ready.acquireUninterruptibly();\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+        });\n+        synchronized (lock) {\n+            ready.release();\n+            lock.wait();\n+        }\n+        thread.join();\n+    }\n+\n+    \/**\n+     * Test virtual thread waits, notified by another virtual thread.\n+     *\/\n+    @Test\n+    void testWaitNotify3() throws Exception {\n+        \/\/ need at least two carrier threads due to pinning\n+        int previousParallelism = VThreadRunner.ensureParallelism(2);\n+        try {\n+            var lock = new Object();\n+            var ready = new Semaphore(0);\n+            var thread1 = Thread.ofVirtual().start(() -> {\n+                synchronized (lock) {\n+                    ready.release();\n+                    try {\n+                        lock.wait();\n+                    } catch (InterruptedException e) { }\n+                }\n+            });\n+            var thread2 = Thread.ofVirtual().start(() -> {\n+                ready.acquireUninterruptibly();\n+                synchronized (lock) {\n+                    lock.notifyAll();\n+                }\n+            });\n+            thread1.join();\n+            thread2.join();\n+        } finally {\n+            \/\/ restore\n+            VThreadRunner.setParallelism(previousParallelism);\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt status set when calling Object.wait.\n+     *\/\n+    @Test\n+    void testWaitNotify4() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Thread t = Thread.currentThread();\n+            t.interrupt();\n+            Object lock = new Object();\n+            synchronized (lock) {\n+                try {\n+                    lock.wait();\n+                    fail();\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupt status should be cleared\n+                    assertFalse(t.isInterrupted());\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupt when blocked in Object.wait.\n+     *\/\n+    @Test\n+    void testWaitNotify5() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Thread t = Thread.currentThread();\n+            scheduleInterrupt(t, 1000);\n+            Object lock = new Object();\n+            synchronized (lock) {\n+                try {\n+                    lock.wait();\n+                    fail();\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupt status should be cleared\n+                    assertFalse(t.isInterrupted());\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Schedule a thread to be interrupted after a delay.\n+     *\/\n+    private static void scheduleInterrupt(Thread thread, long delay) {\n+        Runnable interruptTask = () -> {\n+            try {\n+                Thread.sleep(delay);\n+                thread.interrupt();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        };\n+        new Thread(interruptTask).start();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Test stack traces in exceptions and stack frames waslked by the StackWalker\n+ * @summary Test stack traces in exceptions and stack frames walked by the StackWalker\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackTraces.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit ThreadAPI\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED ThreadAPI\n@@ -38,1 +38,2 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations ThreadAPI\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations\n+ *     --enable-native-access=ALL-UNNAMED ThreadAPI\n@@ -64,0 +65,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -758,1 +760,1 @@\n-            synchronized (lock) {\n+            VThreadPinner.runPinned(() -> {\n@@ -762,1 +764,1 @@\n-            }\n+            });\n@@ -1139,1 +1141,1 @@\n-     * Test Thread.yield releases thread when not pinned.\n+     * Test Thread.yield releases carrier thread.\n@@ -1167,1 +1169,1 @@\n-     * Test Thread.yield when thread is pinned.\n+     * Test Thread.yield when thread is pinned by native frame.\n@@ -1182,1 +1184,1 @@\n-                synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n@@ -1185,1 +1187,1 @@\n-                }\n+                });\n@@ -1195,1 +1197,1 @@\n-     * Test that Thread.yield does not consume the thread's parking permit.\n+     * Test Thread.yield does not consume the thread's parking permit.\n@@ -1208,1 +1210,1 @@\n-     * Test that Thread.yield does not make available the thread's parking permit.\n+     * Test Thread.yield does not make available the thread's parking permit.\n@@ -1409,1 +1411,1 @@\n-        VThreadRunner.run(() -> {\n+        VThreadPinner.runPinned(() -> {\n@@ -1411,3 +1413,1 @@\n-            synchronized (lock) {\n-                Thread.sleep(1000);\n-            }\n+            Thread.sleep(1000);\n@@ -1427,1 +1427,1 @@\n-                synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n@@ -1429,1 +1429,1 @@\n-                }\n+                });\n@@ -1447,1 +1447,1 @@\n-                synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n@@ -1449,1 +1449,1 @@\n-                }\n+                });\n@@ -1582,2 +1582,1 @@\n-        var exception = new AtomicReference<Throwable>();\n-        Thread.UncaughtExceptionHandler handler = (thread, exc) -> exception.set(exc);\n+        var handler = new CapturingUHE();\n@@ -1592,1 +1591,2 @@\n-        assertTrue(exception.get() instanceof FooException);\n+        assertInstanceOf(FooException.class, handler.exception());\n+        assertEquals(thread, handler.thread());\n@@ -1602,2 +1602,1 @@\n-        var exception = new AtomicReference<Throwable>();\n-        Thread.UncaughtExceptionHandler handler = (thread, exc) -> exception.set(exc);\n+        var handler = new CapturingUHE();\n@@ -1614,1 +1613,1 @@\n-            Thread.setDefaultUncaughtExceptionHandler(savedHandler);\n+            Thread.setDefaultUncaughtExceptionHandler(savedHandler);  \/\/ restore\n@@ -1616,1 +1615,2 @@\n-        assertTrue(exception.get() instanceof FooException);\n+        assertInstanceOf(FooException.class, handler.exception());\n+        assertEquals(thread, handler.thread());\n@@ -1621,1 +1621,1 @@\n-     * Test no UncaughtExceptionHandler set.\n+     * Test Thread and default UncaughtExceptionHandler set.\n@@ -1626,4 +1626,20 @@\n-        Thread thread = Thread.ofVirtual().start(() -> {\n-            throw new FooException();\n-        });\n-        thread.join();\n+        var defaultHandler = new CapturingUHE();\n+        var threadHandler = new CapturingUHE();\n+        Thread.UncaughtExceptionHandler savedHandler = Thread.getDefaultUncaughtExceptionHandler();\n+        Thread.setDefaultUncaughtExceptionHandler(defaultHandler);\n+        Thread thread;\n+        try {\n+            thread = Thread.ofVirtual().start(() -> {\n+                Thread me = Thread.currentThread();\n+                assertTrue(me.getUncaughtExceptionHandler() == me.getThreadGroup());\n+                me.setUncaughtExceptionHandler(threadHandler);\n+                assertTrue(me.getUncaughtExceptionHandler() == threadHandler);\n+                throw new FooException();\n+            });\n+            thread.join();\n+        } finally {\n+            Thread.setDefaultUncaughtExceptionHandler(savedHandler);  \/\/ restore\n+        }\n+        assertInstanceOf(FooException.class, threadHandler.exception());\n+        assertNull(defaultHandler.exception());\n+        assertEquals(thread, threadHandler.thread());\n@@ -1633,0 +1649,19 @@\n+    \/**\n+     * Test no Thread or default UncaughtExceptionHandler set.\n+     *\/\n+    @Test\n+    void testUncaughtExceptionHandler4() throws Exception {\n+        Thread.UncaughtExceptionHandler savedHandler = Thread.getDefaultUncaughtExceptionHandler();\n+        Thread.setDefaultUncaughtExceptionHandler(null);\n+        try {\n+            class FooException extends RuntimeException { }\n+            Thread thread = Thread.ofVirtual().start(() -> {\n+                throw new FooException();\n+            });\n+            thread.join();\n+            assertNull(thread.getUncaughtExceptionHandler());\n+        } finally {\n+            Thread.setDefaultUncaughtExceptionHandler(savedHandler);\n+        }\n+    }\n+\n@@ -2067,1 +2102,1 @@\n-     * Test Thread::getStackTrace on terminated thread.\n+     * Test Thread::getStackTrace on timed-parked thread.\n@@ -2071,0 +2106,66 @@\n+        var thread = Thread.ofVirtual().start(() -> {\n+            LockSupport.parkNanos(Long.MAX_VALUE);\n+        });\n+        await(thread, Thread.State.TIMED_WAITING);\n+        try {\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, \"LockSupport.parkNanos\"));\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getStackTrace on parked thread that is pinned.\n+     *\/\n+    @Test\n+    void testGetStackTrace7() throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n+            });\n+        });\n+        await(thread, Thread.State.WAITING);\n+        try {\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, \"LockSupport.park\"));\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getStackTrace on timed-parked thread that is pinned.\n+     *\/\n+    @Test\n+    void testGetStackTrace8() throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            });\n+        });\n+        await(thread, Thread.State.TIMED_WAITING);\n+        try {\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, \"LockSupport.parkNanos\"));\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getStackTrace on terminated thread.\n+     *\/\n+    @Test\n+    void testGetStackTrace9() throws Exception {\n@@ -2237,1 +2338,1 @@\n-            assertTrue(n == 0);\n+            assertFalse(Arrays.stream(threads, 0, n).anyMatch(Thread::isVirtual));\n@@ -2350,0 +2451,27 @@\n+    \/**\n+     * Thread.UncaughtExceptionHandler that captures the first exception thrown.\n+     *\/\n+    private static class CapturingUHE implements Thread.UncaughtExceptionHandler {\n+        Thread thread;\n+        Throwable exception;\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+            synchronized (this) {\n+                if (thread == null) {\n+                    this.thread = t;\n+                    this.exception = e;\n+                }\n+            }\n+        }\n+        Thread thread() {\n+            synchronized (this) {\n+                return thread;\n+            }\n+        }\n+        Throwable exception() {\n+            synchronized (this) {\n+                return exception;\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":160,"deletions":32,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -29,1 +30,1 @@\n- * @run junit VirtualThreadPinnedEventThrows\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED VirtualThreadPinnedEventThrows\n@@ -34,0 +35,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -37,0 +39,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -85,1 +88,13 @@\n-        Object lock = new Object();\n+        var exception = new AtomicReference<Throwable>();\n+        var done = new AtomicBoolean();\n+        Thread thread = Thread.startVirtualThread(() -> {\n+            try {\n+                VThreadPinner.runPinned(() -> {\n+                    while (!done.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            } catch (Throwable e) {\n+                exception.set(e);\n+            }\n+        });\n@@ -87,8 +102,0 @@\n-            var completed = new AtomicBoolean();\n-            Thread thread = Thread.startVirtualThread(() -> {\n-                synchronized (lock) {\n-                    LockSupport.park();\n-                    completed.set(true);\n-                }\n-            });\n-\n@@ -101,2 +108,2 @@\n-\n-            \/\/ unpark and check that thread completed without exception\n+        } finally {\n+            done.set(true);\n@@ -105,3 +112,0 @@\n-            assertTrue(completed.get());\n-        } finally {\n-            Reference.reachabilityFence(lock);\n@@ -109,0 +113,1 @@\n+        assertNull(exception.get());\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/VirtualThreadPinnedEventThrows.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test virtual threads using Object.wait\/notifyAll\n- * @library \/test\/lib\n- * @run junit WaitNotify\n- *\/\n-\n-import java.util.concurrent.Semaphore;\n-\n-import jdk.test.lib.thread.VThreadRunner;\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class WaitNotify {\n-\n-    \/**\n-     * Test virtual thread waits, notified by platform thread.\n-     *\/\n-    @Test\n-    void testWaitNotify1() throws Exception {\n-        var lock = new Object();\n-        var ready = new Semaphore(0);\n-        var thread = Thread.ofVirtual().start(() -> {\n-            synchronized (lock) {\n-                ready.release();\n-                try {\n-                    lock.wait();\n-                } catch (InterruptedException e) { }\n-            }\n-        });\n-        \/\/ thread invokes notify\n-        ready.acquire();\n-        synchronized (lock) {\n-            lock.notifyAll();\n-        }\n-        thread.join();\n-    }\n-\n-    \/**\n-     * Test platform thread waits, notified by virtual thread.\n-     *\/\n-    @Test\n-    void testWaitNotify2() throws Exception {\n-        var lock = new Object();\n-        var ready = new Semaphore(0);\n-        var thread = Thread.ofVirtual().start(() -> {\n-            ready.acquireUninterruptibly();\n-            synchronized (lock) {\n-                lock.notifyAll();\n-            }\n-        });\n-        synchronized (lock) {\n-            ready.release();\n-            lock.wait();\n-        }\n-        thread.join();\n-    }\n-\n-    \/**\n-     * Test virtual thread waits, notified by another virtual thread.\n-     *\/\n-    @Test\n-    void testWaitNotify3() throws Exception {\n-        var lock = new Object();\n-        var ready = new Semaphore(0);\n-        var thread1 = Thread.ofVirtual().start(() -> {\n-            synchronized (lock) {\n-                ready.release();\n-                try {\n-                    lock.wait();\n-                } catch (InterruptedException e) { }\n-            }\n-        });\n-        var thread2 = Thread.ofVirtual().start(() -> {\n-            ready.acquireUninterruptibly();\n-            synchronized (lock) {\n-                lock.notifyAll();\n-            }\n-        });\n-        thread1.join();\n-        thread2.join();\n-    }\n-\n-    \/**\n-     * Test interrupt status set when calling Object.wait.\n-     *\/\n-    @Test\n-    void testWaitNotify4() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            t.interrupt();\n-            Object lock = new Object();\n-            synchronized (lock) {\n-                try {\n-                    lock.wait();\n-                    fail();\n-                } catch (InterruptedException e) {\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n-                }\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * Test interrupt when blocked in Object.wait.\n-     *\/\n-    @Test\n-    void testWaitNotify5() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            scheduleInterrupt(t, 1000);\n-            Object lock = new Object();\n-            synchronized (lock) {\n-                try {\n-                    lock.wait();\n-                    fail();\n-                } catch (InterruptedException e) {\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n-                }\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * Schedule a thread to be interrupted after a delay.\n-     *\/\n-    private static void scheduleInterrupt(Thread thread, long delay) {\n-        Runnable interruptTask = () -> {\n-            try {\n-                Thread.sleep(delay);\n-                thread.interrupt();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        };\n-        new Thread(interruptTask).start();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/WaitNotify.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -28,1 +28,2 @@\n- * @run main PinALot 500000\n+ * @library \/test\/lib\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED PinALot 500000\n@@ -34,1 +35,2 @@\n- * @run main\/othervm\/timeout=300 PinALot 200000\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 --enable-native-access=ALL-UNNAMED PinALot 200000\n@@ -42,1 +44,1 @@\n-public class PinALot {\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -44,1 +46,1 @@\n-    static final Object lock = new Object();\n+public class PinALot {\n@@ -56,1 +58,1 @@\n-            synchronized (lock) {\n+            VThreadPinner.runPinned(() -> {\n@@ -60,1 +62,1 @@\n-            }\n+            });\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g Skynet\n+ * @run main\/othervm\/timeout=300 -Xmx1500m Skynet\n@@ -38,1 +38,1 @@\n- *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1g Skynet\n+ *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1500m Skynet\n@@ -47,1 +47,1 @@\n- *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1g Skynet\n+ *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1500m Skynet\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -414,1 +414,0 @@\n-            long start = System.currentTimeMillis();\n@@ -416,1 +415,0 @@\n-            long duration = System.currentTimeMillis() - start;\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/SelectWithConsumer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.thread;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicReference;\n+import jdk.test.lib.thread.VThreadRunner.ThrowingRunnable;\n+\n+\/**\n+ * Helper class to allow tests run a task in a virtual thread while pinning its carrier.\n+ *\n+ * It defines the {@code runPinned} method to run a task with a native frame on the stack.\n+ *\/\n+public class VThreadPinner {\n+    private static final Path JAVA_LIBRARY_PATH = Path.of(System.getProperty(\"java.library.path\"));\n+    private static final Path LIB_PATH = JAVA_LIBRARY_PATH.resolve(System.mapLibraryName(\"VThreadPinner\"));\n+\n+    \/\/ method handle to call the native function\n+    private static final MethodHandle INVOKER = invoker();\n+\n+    \/\/ function pointer to call\n+    private static final MemorySegment UPCALL_STUB = upcallStub();\n+\n+    \/**\n+     * Thread local with the task to run.\n+     *\/\n+    private static final ThreadLocal<TaskRunner> TASK_RUNNER = new ThreadLocal<>();\n+\n+    \/**\n+     * Runs a task, capturing any exception or error thrown.\n+     *\/\n+    private static class TaskRunner implements Runnable {\n+        private final ThrowingRunnable<?> task;\n+        private Throwable throwable;\n+\n+        TaskRunner(ThrowingRunnable<?> task) {\n+            this.task = task;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable ex) {\n+                throwable = ex;\n+            }\n+        }\n+\n+        Throwable exception() {\n+            return throwable;\n+        }\n+    }\n+\n+    \/**\n+     * Called by the native function to run the task stashed in the thread local. The\n+     * task runs with the native frame on the stack.\n+     *\/\n+    private static void callback() {\n+        TASK_RUNNER.get().run();\n+    }\n+\n+    \/**\n+     * Runs the given task on a virtual thread pinned to its carrier. If called from a\n+     * virtual thread then it invokes the task directly.\n+     *\/\n+    public static <X extends Throwable> void runPinned(ThrowingRunnable<X> task) throws X {\n+        if (!Thread.currentThread().isVirtual()) {\n+            VThreadRunner.run(() -> runPinned(task));\n+            return;\n+        }\n+        var runner = new TaskRunner(task);\n+        TASK_RUNNER.set(runner);\n+        try {\n+            INVOKER.invoke(UPCALL_STUB);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            TASK_RUNNER.remove();\n+        }\n+        Throwable ex = runner.exception();\n+        if (ex != null) {\n+            if (ex instanceof RuntimeException e)\n+                throw e;\n+            if (ex instanceof Error e)\n+                throw e;\n+            throw (X) ex;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a method handle to the native function void call(void *(*f)(void *)).\n+     *\/\n+    @SuppressWarnings(\"restricted\")\n+    private static MethodHandle invoker() {\n+        Linker abi = Linker.nativeLinker();\n+        try {\n+            SymbolLookup lib = SymbolLookup.libraryLookup(LIB_PATH, Arena.global());\n+            MemorySegment symbol = lib.find(\"call\").orElseThrow();\n+            FunctionDescriptor desc = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS);\n+            return abi.downcallHandle(symbol, desc);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns an upcall stub to use as a function pointer to invoke the callback method.\n+     *\/\n+    @SuppressWarnings(\"restricted\")\n+    private static MemorySegment upcallStub() {\n+        Linker abi = Linker.nativeLinker();\n+        try {\n+            MethodHandle callback = MethodHandles.lookup()\n+                    .findStatic(VThreadPinner.class, \"callback\", MethodType.methodType(void.class));\n+            return abi.upcallStub(callback, FunctionDescriptor.ofVoid(), Arena.global());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadPinner.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * Helper class to support tests running tasks a in virtual thread.\n+ * Helper class to support tests running tasks in a virtual thread.\n@@ -44,2 +44,1 @@\n-     * Represents a task that does not return a result but may throw\n-     * an exception.\n+     * Represents a task that does not return a result but may throw an exception.\n@@ -48,5 +47,2 @@\n-    public interface ThrowingRunnable {\n-        \/**\n-         * Runs this operation.\n-         *\/\n-        void run() throws Exception;\n+    public interface ThrowingRunnable<X extends Throwable> {\n+        void run() throws X;\n@@ -58,1 +54,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -63,1 +58,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -65,5 +60,5 @@\n-    public static void run(String name,\n-                           int characteristics,\n-                           ThrowingRunnable task) throws Exception {\n-        AtomicReference<Exception> exc = new AtomicReference<>();\n-        Runnable target =  () -> {\n+    public static <X extends Throwable> void run(String name,\n+                                                 int characteristics,\n+                                                 ThrowingRunnable<X> task) throws X {\n+        var throwableRef = new AtomicReference<Throwable>();\n+        Runnable target = () -> {\n@@ -72,4 +67,2 @@\n-            } catch (Error e) {\n-                exc.set(new RuntimeException(e));\n-            } catch (Exception e) {\n-                exc.set(e);\n+            } catch (Throwable ex) {\n+                throwableRef.set(ex);\n@@ -87,4 +80,6 @@\n-        while (thread.join(Duration.ofSeconds(10)) == false) {\n-            System.out.println(\"-- \" + thread + \" --\");\n-            for (StackTraceElement e : thread.getStackTrace()) {\n-                System.out.println(\"  \" + e);\n+        try {\n+            while (thread.join(Duration.ofSeconds(10)) == false) {\n+                System.out.println(\"-- \" + thread + \" --\");\n+                for (StackTraceElement e : thread.getStackTrace()) {\n+                    System.out.println(\"  \" + e);\n+                }\n@@ -92,0 +87,2 @@\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n@@ -94,3 +91,7 @@\n-        Exception e = exc.get();\n-        if (e != null) {\n-            throw e;\n+        Throwable ex = throwableRef.get();\n+        if (ex != null) {\n+            if (ex instanceof RuntimeException e)\n+                throw e;\n+            if (ex instanceof Error e)\n+                throw e;\n+            throw (X) ex;\n@@ -103,1 +104,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -107,1 +107,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -109,1 +109,1 @@\n-    public static void run(String name, ThrowingRunnable task) throws Exception {\n+    public static <X extends Throwable> void run(String name, ThrowingRunnable<X> task) throws X {\n@@ -116,1 +116,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -120,1 +119,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -122,1 +121,1 @@\n-    public static void run(int characteristics, ThrowingRunnable task) throws Exception {\n+    public static <X extends Throwable> void run(int characteristics, ThrowingRunnable<X> task) throws X {\n@@ -129,1 +128,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -132,1 +130,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -134,1 +132,1 @@\n-    public static void run(ThrowingRunnable task) throws Exception {\n+    public static <X extends Throwable> void run(ThrowingRunnable<X> task) throws X {\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadRunner.java","additions":33,"deletions":35,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/*\n+ * Call a function with the given function pointer.\n+ *\/\n+EXPORT void call(void *(*f)(void)) {\n+    (*f)();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/libVThreadPinner.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}