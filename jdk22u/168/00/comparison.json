{"files":[{"patch":"@@ -248,0 +248,2 @@\n+  __ push_cont_fastpath(rthread);\n+\n@@ -251,0 +253,2 @@\n+  __ pop_cont_fastpath(rthread);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -246,0 +246,2 @@\n+  __ push_cont_fastpath();\n+\n@@ -250,0 +252,2 @@\n+  __ pop_cont_fastpath();\n+\n","filename":"src\/hotspot\/cpu\/ppc\/upcallLinker_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -270,0 +270,2 @@\n+  __ push_cont_fastpath(xthread);\n+\n@@ -273,0 +275,2 @@\n+  __ pop_cont_fastpath(xthread);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -303,0 +303,2 @@\n+  __ push_cont_fastpath();\n+\n@@ -305,0 +307,2 @@\n+  __ pop_cont_fastpath();\n+\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-  bool interpreted_native_or_deoptimized_on_stack();\n+  bool check_valid_fast_path();\n@@ -1517,1 +1517,4 @@\n-bool FreezeBase::interpreted_native_or_deoptimized_on_stack() {\n+\/\/ There are no interpreted frames if we're not called from the interpreter and we haven't ancountered an i2c\n+\/\/ adapter or called Deoptimization::unpack_frames. As for native frames, upcalls from JNI also go through the\n+\/\/ interpreter (see JavaCalls::call_helper), while the UpcallLinker explicitly sets cont_fastpath.\n+bool FreezeBase::check_valid_fast_path() {\n@@ -1525,2 +1528,2 @@\n-    if (f.is_interpreted_frame() || f.is_native_frame() || f.is_deoptimized_frame()) {\n-      return true;\n+    if (!f.is_compiled_frame() || f.is_deoptimized_frame()) {\n+      return false;\n@@ -1529,1 +1532,1 @@\n-  return false;\n+  return true;\n@@ -1591,5 +1594,1 @@\n-  \/\/ There are no interpreted frames if we're not called from the interpreter and we haven't ancountered an i2c\n-  \/\/ adapter or called Deoptimization::unpack_frames. Calls from native frames also go through the interpreter\n-  \/\/ (see JavaCalls::call_helper).\n-  assert(!current->cont_fastpath()\n-         || (current->cont_fastpath_thread_state() && !freeze.interpreted_native_or_deoptimized_on_stack()), \"\");\n+  assert(!current->cont_fastpath() || freeze.check_valid_fast_path(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -68,2 +69,3 @@\n-                synchronized (GetStackTraceALotWhenPinned.class) {\n-                    if (timed) {\n+                boolean b = timed;\n+                VThreadPinner.runPinned(() -> {\n+                    if (b) {\n@@ -74,1 +76,1 @@\n-                }\n+                });\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}