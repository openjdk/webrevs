{"files":[{"patch":"@@ -1,200 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.glass.events.mac;\n-\n-import java.lang.annotation.Native;\n-import java.util.Map;\n-import com.sun.glass.ui.Window;\n-\n-\/\/ https:\/\/wiki.mozilla.org\/NPAPI:CocoaEventModel\n-\n-\/\/ used by Mac OS X impl for handling an NPAPI event sent from plugin to Glass process\n-public class NpapiEvent {\n-\n-    \/\/ draw\n-    @Native final static public int NPCocoaEventDrawRect            = 1;\n-    \/\/ mouse\n-    @Native final static public int NPCocoaEventMouseDown           = 2;\n-    @Native final static public int NPCocoaEventMouseUp             = 3;\n-    @Native final static public int NPCocoaEventMouseMoved          = 4;\n-    @Native final static public int NPCocoaEventMouseEntered        = 5;\n-    @Native final static public int NPCocoaEventMouseExited         = 6;\n-    @Native final static public int NPCocoaEventMouseDragged        = 7;\n-    \/\/ key\n-    @Native final static public int NPCocoaEventKeyDown             = 8;\n-    @Native final static public int NPCocoaEventKeyUp               = 9;\n-    @Native final static public int NPCocoaEventFlagsChanged        = 10;\n-    \/\/ focus\n-    @Native final static public int NPCocoaEventFocusChanged        = 11;\n-    @Native final static public int NPCocoaEventWindowFocusChanged  = 12;\n-    \/\/ mouse\n-    @Native final static public int NPCocoaEventScrollWheel         = 13;\n-    \/\/ text input\n-    @Native final static public int NPCocoaEventTextInput           = 14;\n-\n-    private native static void _dispatchCocoaNpapiDrawEvent(long windowPtr, int type,\n-            long context, double x, double y, double width, double height);\n-    private native static void _dispatchCocoaNpapiMouseEvent(long windowPtr, int type,\n-            int modifierFlags, double pluginX, double pluginY, int buttonNumber, int clickCount,\n-            double deltaX, double deltaY, double deltaZ);\n-    private native static void _dispatchCocoaNpapiKeyEvent(long windowPtr, int type,\n-            int modifierFlags, String characters, String charactersIgnoringModifiers,\n-            boolean isARepeat, int keyCode, boolean needsKeyTyped);\n-    private native static void _dispatchCocoaNpapiFocusEvent(long windowPtr, int type,\n-            boolean hasFocus);\n-    private native static void _dispatchCocoaNpapiTextInputEvent(long windowPtr, int type,\n-            String text);\n-\n-    final private static boolean getBoolean(Map eventInfo, String key) {\n-        boolean value = false;\n-        {\n-            if (eventInfo.containsKey(key) == true ) {\n-                try {\n-                    value = ((Boolean)eventInfo.get(key)).booleanValue();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-    final private static int getInt(Map eventInfo, String key) {\n-        int value = 0;\n-        {\n-            if (eventInfo.containsKey(key) == true ) {\n-                try {\n-                    value = ((Integer)eventInfo.get(key)).intValue();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-    final private static long getLong(Map eventInfo, String key) {\n-        long value = 0;\n-        {\n-            if (eventInfo.containsKey(key) == true ) {\n-                try {\n-                    value = ((Long)eventInfo.get(key)).longValue();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-    final private static double getDouble(Map eventInfo, String key) {\n-        double value = 0;\n-        {\n-            if (eventInfo.containsKey(key) == true ) {\n-                try {\n-                    value = ((Double)eventInfo.get(key)).doubleValue();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-    final private static String getString(Map eventInfo, String key) {\n-        String value = null;\n-        {\n-            if (eventInfo.containsKey(key) == true ) {\n-                try {\n-                    value = (String)eventInfo.get(key);\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-    public static void dispatchCocoaNpapiEvent(Window window, Map eventInfo) {\n-        final long windowPtr = window.getNativeWindow();\n-        \/\/System.err.println(\">>>>>>>>>>>>>>>>>>>>>>> eventInfo: \"+eventInfo);\n-        int type = ((Integer)eventInfo.get(\"type\")).intValue();\n-        switch (type) {\n-            case NPCocoaEventDrawRect: {\n-                    long context = getLong(eventInfo, \"context\");\n-                    double x = getDouble(eventInfo, \"x\");\n-                    double y = getDouble(eventInfo, \"y\");\n-                    double width = getDouble(eventInfo, \"width\");\n-                    double height = getDouble(eventInfo, \"height\");\n-                    _dispatchCocoaNpapiDrawEvent(windowPtr, type,\n-                            context, x, y, width, height);\n-                }\n-                break;\n-            case NPCocoaEventMouseDown:\n-            case NPCocoaEventMouseUp:\n-            case NPCocoaEventMouseMoved:\n-            case NPCocoaEventMouseEntered:\n-            case NPCocoaEventMouseExited:\n-            case NPCocoaEventMouseDragged:\n-            case NPCocoaEventScrollWheel: {\n-                    int modifierFlags = getInt(eventInfo, \"modifierFlags\");\n-                    double pluginX = getDouble(eventInfo, \"pluginX\");\n-                    double pluginY = getDouble(eventInfo, \"pluginY\");\n-                    int buttonNumber = getInt(eventInfo, \"buttonNumber\");\n-                    int clickCount = getInt(eventInfo, \"clickCount\");\n-                    double deltaX = getDouble(eventInfo, \"deltaX\");\n-                    double deltaY = getDouble(eventInfo, \"deltaY\");\n-                    double deltaZ = getDouble(eventInfo, \"deltaZ\");\n-                    _dispatchCocoaNpapiMouseEvent(windowPtr, type,\n-                            modifierFlags, pluginX, pluginY, buttonNumber, clickCount,\n-                            deltaX, deltaY, deltaZ);\n-                }\n-                break;\n-            case NPCocoaEventKeyDown:\n-            case NPCocoaEventKeyUp:\n-            case NPCocoaEventFlagsChanged: {\n-                    int modifierFlags = getInt(eventInfo, \"modifierFlags\");\n-                    String characters = getString(eventInfo, \"characters\");\n-                    String charactersIgnoringModifiers = getString(eventInfo, \"charactersIgnoringModifiers\");\n-                    boolean isARepeat = getBoolean(eventInfo, \"isARepeat\");\n-                    int keyCode = getInt(eventInfo, \"keyCode\");\n-                    boolean needsKeyTyped = getBoolean(eventInfo, \"needsKeyTyped\");\n-\n-                    _dispatchCocoaNpapiKeyEvent(windowPtr, type,\n-                            modifierFlags, characters, charactersIgnoringModifiers,\n-                            isARepeat, keyCode, needsKeyTyped);\n-                }\n-                break;\n-            case NPCocoaEventFocusChanged:\n-            case NPCocoaEventWindowFocusChanged: {\n-                    boolean hasFocus = getBoolean(eventInfo, \"hasFocus\");\n-                    _dispatchCocoaNpapiFocusEvent(windowPtr, type,\n-                            hasFocus);\n-                }\n-                break;\n-            case NPCocoaEventTextInput: {\n-                    String text = getString(eventInfo, \"text\");\n-                    _dispatchCocoaNpapiTextInputEvent(windowPtr, type,\n-                            text);\n-                }\n-                break;\n-        }\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/events\/mac\/NpapiEvent.java","additions":0,"deletions":200,"binary":false,"changes":200,"status":"deleted"},{"patch":"@@ -586,2 +586,0 @@\n-    public abstract Window createWindow(long parent);\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Application.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -456,6 +456,0 @@\n-    \/** Only used on Mac when run inside a plugin *\/\n-    public int getNativeRemoteLayerId(String serverName) {\n-        Application.checkEventThread();\n-        throw new RuntimeException(\"This operation is not supported on this platform\");\n-    }\n-\n@@ -468,1 +462,1 @@\n-    \/** X coordinate relative to the host (window or applet). *\/\n+    \/** X coordinate relative to the host (window). *\/\n@@ -476,1 +470,1 @@\n-    \/** Y coordinate relative to the host (window or applet). *\/\n+    \/** Y coordinate relative to the host (window). *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -198,1 +198,0 @@\n-    private final long parent;\n@@ -222,9 +221,0 @@\n-    private boolean appletMode = false;\n-\n-    \/\/ This is a workaround for RT-15970: as for embedded windows we don't\n-    \/\/ receive any MOVE notifications from the native platform, we poll\n-    \/\/ the window location on screen from timer and post synthetic events\n-    \/\/ if it has changed\n-    private Timer embeddedLocationTimer = null;\n-    private int lastKnownEmbeddedX = 0;\n-    private int lastKnownEmbeddedY = 0;\n@@ -279,1 +269,0 @@\n-        this.parent = 0L;\n@@ -298,31 +287,0 @@\n-    protected abstract long _createChildWindow(long parent);\n-    \/**\n-     * Constructs a child window of the specified native parent window.\n-     *\/\n-    protected Window(long parent) {\n-        Application.checkEventThread();\n-        this.owner = null;\n-        this.parent = parent;\n-        this.styleMask = Window.UNTITLED;\n-        this.isDecorated = false;\n-\n-        \/\/ Note: we can't always catch screen changes when parent is moved...\n-        this.screen = null; \/\/ should infer from the parent\n-\n-        this.ptr = _createChildWindow(parent);\n-        if (this.ptr == 0L) {\n-            throw new RuntimeException(\"could not create platform window\");\n-        }\n-\n-        if (screen == null) {\n-            screen = Screen.getMainScreen(); \/\/ start with a default\n-\n-            if (PrismSettings.allowHiDPIScaling) {\n-                this.platformScaleX = this.screen.getPlatformScaleX();\n-                this.platformScaleY = this.screen.getPlatformScaleY();\n-                this.outputScaleX = this.screen.getRecommendedOutputScaleX();\n-                this.outputScaleY = this.screen.getRecommendedOutputScaleY();\n-            }\n-        }\n-    }\n-\n@@ -356,5 +314,0 @@\n-    private boolean isChild() {\n-        Application.checkEventThread();\n-        return this.parent != 0L;\n-    }\n-\n@@ -561,13 +514,0 @@\n-    protected abstract int _getEmbeddedX(long ptr);\n-    protected abstract int _getEmbeddedY(long ptr);\n-\n-    private void checkScreenLocation() {\n-        this.x = _getEmbeddedX(ptr);\n-        this.y = _getEmbeddedY(ptr);\n-        if ((this.x != lastKnownEmbeddedX) || (this.y != lastKnownEmbeddedY)) {\n-            lastKnownEmbeddedX = this.x;\n-            lastKnownEmbeddedY = this.y;\n-            handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);\n-        }\n-    }\n-\n@@ -689,3 +629,0 @@\n-                if (parent != 0) {\n-                    embeddedLocationTimer.stop();\n-                }\n@@ -700,7 +637,0 @@\n-                if (parent != 0) {\n-                    final Runnable checkRunnable = () -> checkScreenLocation();\n-                    final Runnable timerRunnable = () -> Application.invokeLater(checkRunnable);\n-                    embeddedLocationTimer =\n-                           Application.GetApplication().createTimer(timerRunnable);\n-                    embeddedLocationTimer.start(16);\n-                }\n@@ -766,1 +696,1 @@\n-        if (!isChild() && event != WindowEvent.FOCUS_GAINED) {\n+        if (event != WindowEvent.FOCUS_GAINED) {\n@@ -770,4 +700,0 @@\n-        if (isChild() && (event < WindowEvent._FOCUS_MIN || event > WindowEvent._FOCUS_MAX)) {\n-            throw new IllegalArgumentException(\"Invalid focus event ID for child window\");\n-        }\n-\n@@ -974,8 +900,0 @@\n-    public boolean getAppletMode() {\n-        return appletMode;\n-    }\n-\n-    public void setAppletMode(boolean appletMode) {\n-        this.appletMode = appletMode;\n-    }\n-\n@@ -1212,6 +1130,0 @@\n-    \/** Only used on Mac when run inside a plugin *\/\n-    public void dispatchNpapiEvent(Map eventInfo) {\n-        Application.checkEventThread();\n-        throw new RuntimeException(\"This operation is not supported on this platform\");\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Window.java","additions":1,"deletions":89,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -385,5 +385,0 @@\n-    @Override\n-    public Window createWindow(long parent) {\n-        return new GtkChildWindow(parent);\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkApplication.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.glass.ui.gtk;\n-\n-import com.sun.glass.ui.Pixels;\n-\n-final class GtkChildWindow extends GtkWindow {\n-\n-    public GtkChildWindow(long parent) {\n-        super(parent);\n-    }\n-\n-    @Override\n-    protected void _enterModal(long ptr) {\n-    }\n-\n-    @Override\n-    protected void _enterModalWithWindow(long dialog, long window) {\n-    }\n-\n-    @Override\n-    protected void _exitModal(long ptr) {\n-    }\n-\n-    @Override\n-    protected boolean _maximize(long ptr, boolean maximize, boolean wasMaximized) {\n-        return true;\n-    }\n-\n-    @Override\n-    protected boolean _minimize(long ptr, boolean minimize) {\n-        return true;\n-    }\n-\n-    @Override\n-    protected void _setEnabled(long ptr, boolean enabled) {\n-    }\n-\n-    @Override\n-    protected void _setFocusable(long ptr, boolean isFocusable) {\n-    }\n-\n-    @Override\n-    protected void _setIcon(long ptr, Pixels pixels) {\n-    }\n-\n-    @Override\n-    protected void _setLevel(long ptr, int level) {\n-    }\n-\n-    @Override\n-    protected void _setAlpha(long ptr, float alpha) {\n-    }\n-\n-    @Override\n-    protected boolean _setMaximumSize(long ptr, int width, int height) {\n-        return true;\n-    }\n-\n-    @Override\n-    protected boolean _setMinimumSize(long ptr, int width, int height) {\n-        return true;\n-    }\n-\n-    @Override\n-    protected boolean _setResizable(long ptr, boolean resizable) {\n-        return true;\n-    }\n-\n-    @Override\n-    protected boolean _setMenubar(long ptr, long menubarPtr) {\n-        return true;\n-    }\n-\n-    @Override\n-    protected boolean _setTitle(long ptr, String title) {\n-        return true;\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkChildWindow.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -40,4 +40,0 @@\n-    protected GtkWindow(long parent) {\n-        super(parent);\n-    }\n-\n@@ -47,3 +43,0 @@\n-    @Override\n-    protected native long _createChildWindow(long parent);\n-\n@@ -181,6 +174,0 @@\n-    @Override\n-    protected native int _getEmbeddedX(long ptr);\n-\n-    @Override\n-    protected native int _getEmbeddedY(long ptr);\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,8 +82,0 @@\n-    \/**\n-     * @inheritDoc\n-     *\/\n-    @Override\n-    public Window createWindow(long parent) {\n-        return new IosWindow(parent);\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/ios\/IosApplication.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-    protected IosWindow(long parent) {\n-        super(parent);\n-    }\n@@ -47,1 +44,0 @@\n-    @Override native protected long _createChildWindow(long parent);\n@@ -89,12 +85,0 @@\n-    @Override\n-    protected int _getEmbeddedX(long ptr) {\n-        \/\/ implement for child windows\n-        return 0;\n-    }\n-\n-    @Override\n-    protected int _getEmbeddedY(long ptr) {\n-        \/\/ implement for child windows\n-        return 0;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/ios\/IosWindow.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -250,11 +250,0 @@\n-    final static long BROWSER_PARENT_ID = -1L;\n-    @Override public Window createWindow(long parent) {\n-        Window window = new MacWindow(parent);\n-        if (parent == BROWSER_PARENT_ID) {\n-            \/\/ Special case: a Mac embedded window, which is a parent to other child Windows.\n-            \/\/ Needs implicit view, with a layer that will be provided to the plugin\n-            window.setView(createView());\n-        }\n-        return window;\n-    }\n-\n@@ -382,5 +371,0 @@\n-    native protected String _getRemoteLayerServerName();\n-    public String getRemoteLayerServerName() {\n-        return _getRemoteLayerServerName();\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacApplication.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -140,12 +140,0 @@\n-    native protected int _getNativeRemoteLayerId(long ptr, String serverName);\n-    @Override public int getNativeRemoteLayerId(String serverName) {\n-        \/\/ used when run inside plugin\n-        return _getNativeRemoteLayerId(getNativeLayer(), serverName);\n-    }\n-\n-    native protected void _hostRemoteLayerId(long ptr, int nativeLayerId);\n-    public void hostRemoteLayerId(int nativeLayerId) {\n-        \/\/ used when run inside plugin\n-        _hostRemoteLayerId(getNativeLayer(), nativeLayerId);\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacView.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.glass.events.mac.NpapiEvent;\n@@ -52,3 +51,0 @@\n-    protected MacWindow(long parent) {\n-        super(parent);\n-    }\n@@ -57,1 +53,0 @@\n-    @Override native protected long _createChildWindow(long parent);\n@@ -124,3 +119,0 @@\n-    @Override native protected int _getEmbeddedX(long ptr);\n-    @Override native protected int _getEmbeddedY(long ptr);\n-\n@@ -150,5 +142,0 @@\n-    @Override\n-    public void dispatchNpapiEvent(Map eventInfo) {\n-        NpapiEvent.dispatchCocoaNpapiEvent(this, eventInfo);\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacWindow.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -158,5 +158,0 @@\n-    @Override\n-    public Window createWindow(long parent) {\n-        return new MonocleWindow(parent);\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/MonocleApplication.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,4 +58,0 @@\n-    MonocleWindow(long parent) {\n-        super(parent);\n-    }\n-\n@@ -170,5 +166,0 @@\n-    @Override\n-    protected long _createChildWindow(long parent) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n@@ -448,7 +439,0 @@\n-    @Override protected int _getEmbeddedX(long ptr) {\n-        return 0;\n-    }\n-    @Override protected int _getEmbeddedY(long ptr) {\n-        return 0;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/MonocleWindow.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -232,4 +232,0 @@\n-    @Override public Window createWindow(long parent) {\n-        return new WinChildWindow(parent);\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinApplication.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.glass.ui.win;\n-\n-import com.sun.glass.ui.Pixels;\n-import com.sun.glass.ui.Screen;\n-import com.sun.glass.ui.View;\n-import com.sun.glass.ui.Window;\n-\n-\/**\n- * MS Windows platform implementation class for child Window.\n- *\/\n-final class WinChildWindow extends WinWindow {\n-    protected WinChildWindow(long parent) {\n-        super(parent);\n-    }\n-\n-    \/\/ Prohibit operations applicable to top-level windows only\n-    @Override protected long _createWindow(long ownerPtr, long screenPtr, int mask) { return 0L; }\n-    @Override protected boolean _setMenubar(long ptr, long menubarPtr) { return false; }\n-    @Override protected boolean _minimize(long ptr, boolean minimize) { return false; }\n-    @Override protected boolean _maximize(long ptr, boolean maximize, boolean wasMaximized) { return false; }\n-    @Override protected boolean _setResizable(long ptr, boolean resizable) { return false; }\n-    @Override protected boolean _setTitle(long ptr, String title) { return false; }\n-    @Override protected void _setLevel(long ptr, int level) {}\n-    @Override protected void _setAlpha(long ptr, float alpha) {}\n-    @Override protected boolean _setMinimumSize(long ptr, int width, int height) { return false; }\n-    @Override protected boolean _setMaximumSize(long ptr, int width, int height) { return false; }\n-    @Override protected void _setIcon(long ptr, Pixels pixels) {}\n-    @Override protected void _enterModal(long ptr) {}\n-    @Override protected void _enterModalWithWindow(long dialog, long window) {}\n-    @Override protected void _exitModal(long ptr) {}\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinChildWindow.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -57,4 +57,0 @@\n-    protected WinWindow(long parent) {\n-        super(parent);\n-    }\n-\n@@ -248,3 +244,0 @@\n-        if (this.getAppletMode()) {\n-            return _setBackground2(ptr, r, g, b);\n-        }\n@@ -257,1 +250,0 @@\n-    @Override native protected long _createChildWindow(long parent);\n@@ -282,2 +274,0 @@\n-    @Override native protected int _getEmbeddedX(long ptr);\n-    @Override native protected int _getEmbeddedY(long ptr);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinWindow.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-            \/\/ SecurityException means some untrusted applet\n+            \/\/ SecurityException means some untrusted app\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/utils\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * applet or application launcher to create the startup parameters for the\n+ * application launcher to create the startup parameters for the\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/ParametersImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-            \/\/ SecurityException means some untrusted applet\n+            \/\/ SecurityException means some untrusted app\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/StyleManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1503,8 +1503,2 @@\n-             * Also in a shared applet-type context, after all references to\n-             * the applet and therefore the font are dropped, the file\n-             * should be removed. This isn't so much an issue so long as\n-             * the VM exists to serve a single FX app, but will be\n-             * important in an app-context model.\n-             * But also fonts that are over-written by new versions\n-             * need to be cleaned up and that applies even in the single\n-             * context.\n+             * Also fonts can be over-written by new versions and\n+             * need to be cleaned up.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/PrismFontFactory.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.tk;\n-\n-import javafx.stage.Stage;\n-import java.util.Map;\n-\n-\/**\n- * Applets must run within a parent window, so this interface will allow the\n- * plugin access to the underlying parent window that all Stages will be created\n- * in.\n- *\/\n-public interface AppletWindow {\n-    \/*\n-     * topStage must be a primary stage and it's backing window a child window\n-     * of this AppletWindow or this method will have no effect.\n-     * The window will do what it can to make sure the given stage is on top of\n-     * the other primary applet stages. In the future we will allow specifying\n-     * Z order but that requires low level changes to Glass to do properly.\n-     *\/\n-    public void setStageOnTop(Stage topStage);\n-\n-    public void setBackgroundColor(int color); \/\/ RGB triplet: 0xRRGGBB\n-    public void setForegroundColor(int color);\n-\n-    public void setVisible(boolean state);\n-\n-    public void setSize(int width, int height);\n-    public int getWidth();\n-    public int getHeight();\n-\n-    public void setPosition(int x, int y);\n-    public int getPositionX();\n-    public int getPositionY();\n-\n-    public float getPlatformScaleX();\n-    public float getPlatformScaleY();\n-\n-    \/\/ returns CARemoteLayer id (only used on Mac)\n-    public int getRemoteLayerId();\n-    \/\/ dispatchEvent (only used on Mac)\n-    public void dispatchEvent(Map eventInfo);\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/AppletWindow.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -120,10 +120,0 @@\n-    @Override\n-    public AppletWindow createAppletWindow(long parent, String serverName) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void closeAppletWindow() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/DummyToolkit.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -224,1 +224,3 @@\n-        \/\/ This is not a doPriviledged check so that applets cannot use this.\n+        \/\/ This is not a doPriviledged check so that applications running\n+        \/\/ with a security manager cannot use this unless they have permission\n+        \/\/ to read system properties.\n@@ -380,18 +382,0 @@\n-    \/**\n-     * Creates an AppletWindow using the provided window pointer as the parent\n-     * window.\n-     *\n-     * @param parent the native parent which will contain the primary stage\n-     * window(s). Used on Windows\/Linux platforms.\n-     *\n-     * @param serverName the name of CARemoteLayerServer which\n-     * will be used to register native layer. Used on Mac platform.\n-     *\/\n-    public abstract AppletWindow createAppletWindow(long parent, String serverName);\n-\n-    \/**\n-     * Perform cleanup in preparation for applet termination, including closing\n-     * the applet window.\n-     *\/\n-    public abstract void closeAppletWindow();\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/Toolkit.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,196 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.tk.quantum;\n-\n-import com.sun.glass.ui.Application;\n-import com.sun.glass.ui.Window;\n-import com.sun.glass.ui.View;\n-import com.sun.javafx.stage.WindowHelper;\n-\n-import com.sun.javafx.tk.AppletWindow;\n-import com.sun.javafx.tk.TKStage;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Map;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import javafx.stage.Stage;\n-\n-\/**\n- * Implementation class for AppletWindow using a Glass Window\n- *\/\n-class GlassAppletWindow implements AppletWindow {\n-    private final Window glassWindow;\n-    private WeakReference<Stage> topStage;\n-    private String serverName;\n-\n-    GlassAppletWindow(long nativeParent, String serverName) {\n-        if (0 == nativeParent) {\n-            if (serverName != null) {\n-                throw new RuntimeException(\"GlassAppletWindow constructor used incorrectly.\");\n-            }\n-            glassWindow = Application.GetApplication().createWindow(null, Window.NORMAL);\n-        } else {\n-            this.serverName = serverName;\n-            glassWindow = Application.GetApplication().createWindow(nativeParent);\n-        }\n-        glassWindow.setAppletMode(true);\n-    }\n-\n-    Window getGlassWindow() {\n-        return glassWindow;\n-    }\n-\n-    @Override\n-    public void setBackgroundColor(final int color) {\n-        Application.invokeLater(() -> {\n-            float RR = (float) ((color >> 16) & 0xff) \/ 255f;\n-            float GG = (float) ((color >> 8) & 0xff) \/ 255f;\n-            float BB = (float) (color & 0xff) \/ 255f;\n-            glassWindow.setBackground(RR, GG, BB);\n-        });\n-    }\n-\n-    @Override\n-    public void setForegroundColor(int color) {\n-        \/\/ Do nothing, foreground color is not supported\n-    }\n-\n-    @Override\n-    public void setVisible(final boolean state) {\n-        Application.invokeLater(() -> glassWindow.setVisible(state));\n-    }\n-\n-    @Override\n-    public void setSize(final int width, final int height) {\n-        Application.invokeLater(() -> glassWindow.setSize(width, height));\n-    }\n-\n-    @Override\n-    public int getWidth() {\n-        final AtomicInteger width = new AtomicInteger(0);\n-        Application.invokeAndWait(() -> width.set(glassWindow.getWidth()));\n-        return width.get();\n-    }\n-\n-    @Override\n-    public int getHeight() {\n-        final AtomicInteger height = new AtomicInteger(0);\n-        Application.invokeAndWait(() -> height.set(glassWindow.getHeight()));\n-        return height.get();\n-    }\n-\n-    @Override\n-    public void setPosition(final int x, final int y) {\n-        Application.invokeLater(() -> glassWindow.setPosition(x, y));\n-    }\n-\n-    @Override\n-    public int getPositionX() {\n-        final AtomicInteger x = new AtomicInteger(0);\n-        Application.invokeAndWait(() -> x.set(glassWindow.getX()));\n-        return x.get();\n-    }\n-\n-    @Override\n-    public int getPositionY() {\n-        final AtomicInteger y = new AtomicInteger(0);\n-        Application.invokeAndWait(() -> y.set(glassWindow.getY()));\n-        return y.get();\n-    }\n-\n-    @Override\n-    public float getPlatformScaleX() {\n-        final AtomicReference<Float> pScale = new AtomicReference<Float>(0.0f);\n-        Application.invokeAndWait(() -> pScale.set(glassWindow.getPlatformScaleX()));\n-        return pScale.get();\n-    }\n-\n-    @Override\n-    public float getPlatformScaleY() {\n-        final AtomicReference<Float> pScale = new AtomicReference<Float>(0.0f);\n-        Application.invokeAndWait(() -> pScale.set(glassWindow.getPlatformScaleY()));\n-        return pScale.get();\n-    }\n-\n-    void dispose() {\n-        QuantumToolkit.runWithRenderLock(() -> {\n-            glassWindow.close();\n-            \/\/TODO - should update glass scene view state\n-            \/\/TODO - doesn't matter because we are disposing\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    public void setStageOnTop(Stage topStage) {\n-        if (null != topStage) {\n-            this.topStage = new WeakReference<Stage>(topStage);\n-        } else {\n-            this.topStage = null;\n-        }\n-    }\n-\n-    @Override\n-    public int getRemoteLayerId() {\n-        final AtomicInteger id = new AtomicInteger(-1);\n-        Application.invokeAndWait(() -> {\n-            View view = glassWindow.getView();\n-            if (view != null) {\n-                id.set(view.getNativeRemoteLayerId(serverName));\n-            }\n-        });\n-        return id.get();\n-    }\n-\n-    @Override\n-    public void dispatchEvent(final Map eventInfo) {\n-        Application.invokeAndWait(() -> glassWindow.dispatchNpapiEvent(eventInfo));\n-    }\n-\n-    \/**\n-     * Call when a child stage becomes visible so we can make sure topStage\n-     * is pushed to the front where it should be.\n-     *\/\n-    void assertStageOrder() {\n-        if (null != topStage) {\n-            Stage ts = topStage.get();\n-            if (null != ts) {\n-                TKStage tsp = WindowHelper.getPeer(ts);\n-                if (tsp instanceof WindowStage && ((WindowStage)tsp).isVisible()) {\n-                    \/\/ call the underlying Glass window toFront to bypass\n-                    \/\/ the check in WindowStage.toFront or we'll create an\n-                    \/\/ infinite loop\n-                    Window pw = ((WindowStage)tsp).getPlatformWindow();\n-                    if (null != pw) {\n-                        pw.toFront();\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassAppletWindow.java","additions":0,"deletions":196,"binary":false,"changes":196,"status":"deleted"},{"patch":"@@ -868,1 +868,1 @@\n-                        if (stage != null && !stage.isApplet()) {\n+                        if (stage != null) {\n@@ -888,1 +888,1 @@\n-                        if (stage != null && !stage.isApplet()) {\n+                        if (stage != null) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,4 +45,2 @@\n- * use of particular time values by multiple applets will cause\n- * confusing results.  For example, if plugin runs two applets\n- * simultaneously, the initTime for those applets will collide\n- * and the results may be undefined.\n+ * use of particular time values by multiple applications would cause\n+ * confusing results. This doesn't happen in practice.\n@@ -50,1 +48,1 @@\n- * To automatically track startup performance in an app or applet,\n+ * To automatically track startup performance in an app,\n@@ -194,1 +192,1 @@\n-     * during the startup of a Java applet or application.  This time is\n+     * during the startup of a Java application.  This time is\n@@ -196,1 +194,1 @@\n-     * time and other events in the system (such as an applet's init time).\n+     * time and other events in the system (such as an app's init time).\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/PerformanceLogger.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-import com.sun.javafx.tk.AppletWindow;\n@@ -594,16 +593,0 @@\n-    @Override  public AppletWindow createAppletWindow(long parent, String serverName) {\n-        GlassAppletWindow parentWindow = new GlassAppletWindow(parent, serverName);\n-        \/\/ Make this the parent window for all future Stages\n-        WindowStage.setAppletWindow(parentWindow);\n-        return parentWindow;\n-    }\n-\n-    @Override public void closeAppletWindow() {\n-        GlassAppletWindow gaw = WindowStage.getAppletWindow();\n-        if (null != gaw) {\n-            gaw.dispose();\n-            WindowStage.setAppletWindow(null);\n-            \/\/ any further strong refs will be in the applet itself\n-        }\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumToolkit.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-    private boolean isAppletStage = false; \/\/ true if this is an embedded applet window\n@@ -90,8 +89,0 @@\n-    private static GlassAppletWindow appletWindow = null;\n-    static void setAppletWindow(GlassAppletWindow aw) {\n-        appletWindow = aw;\n-    }\n-    static GlassAppletWindow getAppletWindow() {\n-        return appletWindow;\n-    }\n-\n@@ -127,4 +118,0 @@\n-        if (appletWindow != null) {\n-            \/\/ this is an embedded applet stage\n-            isAppletStage = true;\n-        }\n@@ -155,44 +142,12 @@\n-            if (isPrimaryStage && (null != appletWindow)) {\n-                platformWindow = app.createWindow(appletWindow.getGlassWindow().getNativeWindow());\n-            } else {\n-                Window ownerWindow = null;\n-                if (owner instanceof WindowStage) {\n-                    ownerWindow = ((WindowStage)owner).platformWindow;\n-                }\n-                boolean resizable = false;\n-                boolean focusable = true;\n-                int windowMask = rtl ? Window.RIGHT_TO_LEFT : 0;\n-                if (isPopupStage) { \/\/ TODO: make it a stage style?\n-                    windowMask |= Window.POPUP;\n-                    if (style == StageStyle.TRANSPARENT) {\n-                        windowMask |= Window.TRANSPARENT;\n-                    }\n-                    focusable = false;\n-                } else {\n-                    switch (style) {\n-                        case UNIFIED:\n-                            if (app.supportsUnifiedWindows()) {\n-                                windowMask |= Window.UNIFIED;\n-                            }\n-                            \/\/ fall through\n-                        case DECORATED:\n-                            windowMask |=\n-                                Window.TITLED | Window.CLOSABLE |\n-                                Window.MINIMIZABLE | Window.MAXIMIZABLE;\n-                            if (ownerWindow != null || modality != Modality.NONE) {\n-                                windowMask &=\n-                                    ~(Window.MINIMIZABLE | Window.MAXIMIZABLE);\n-                            }\n-                            resizable = true;\n-                            break;\n-                        case UTILITY:\n-                            windowMask |=  Window.TITLED | Window.UTILITY | Window.CLOSABLE;\n-                            break;\n-                        default:\n-                            windowMask |=\n-                                    (transparent ? Window.TRANSPARENT : Window.UNTITLED) | Window.CLOSABLE;\n-                            break;\n-                    }\n-                }\n-                if (modality != Modality.NONE) {\n-                    windowMask |= Window.MODAL;\n+\n+            Window ownerWindow = null;\n+            if (owner instanceof WindowStage) {\n+                ownerWindow = ((WindowStage)owner).platformWindow;\n+            }\n+            boolean resizable = false;\n+            boolean focusable = true;\n+            int windowMask = rtl ? Window.RIGHT_TO_LEFT : 0;\n+            if (isPopupStage) { \/\/ TODO: make it a stage style?\n+                windowMask |= Window.POPUP;\n+                if (style == StageStyle.TRANSPARENT) {\n+                    windowMask |= Window.TRANSPARENT;\n@@ -200,6 +155,25 @@\n-                platformWindow =\n-                        app.createWindow(ownerWindow, Screen.getMainScreen(), windowMask);\n-                platformWindow.setResizable(resizable);\n-                platformWindow.setFocusable(focusable);\n-                if (securityDialog) {\n-                    platformWindow.setLevel(Window.Level.FLOATING);\n+                focusable = false;\n+            } else {\n+                switch (style) {\n+                    case UNIFIED:\n+                        if (app.supportsUnifiedWindows()) {\n+                            windowMask |= Window.UNIFIED;\n+                        }\n+                        \/\/ fall through\n+                    case DECORATED:\n+                        windowMask |=\n+                            Window.TITLED | Window.CLOSABLE |\n+                            Window.MINIMIZABLE | Window.MAXIMIZABLE;\n+                        if (ownerWindow != null || modality != Modality.NONE) {\n+                            windowMask &=\n+                                ~(Window.MINIMIZABLE | Window.MAXIMIZABLE);\n+                        }\n+                        resizable = true;\n+                        break;\n+                    case UTILITY:\n+                        windowMask |=  Window.TITLED | Window.UTILITY | Window.CLOSABLE;\n+                        break;\n+                    default:\n+                        windowMask |=\n+                                (transparent ? Window.TRANSPARENT : Window.UNTITLED) | Window.CLOSABLE;\n+                        break;\n@@ -207,12 +181,22 @@\n-                if (fxStage != null && fxStage.getScene() != null) {\n-                    javafx.scene.paint.Paint paint = fxStage.getScene().getFill();\n-                    if (paint instanceof javafx.scene.paint.Color) {\n-                        javafx.scene.paint.Color color = (javafx.scene.paint.Color) paint;\n-                        platformWindow.setBackground((float) color.getRed(), (float) color.getGreen(), (float) color.getBlue());\n-                    } else if (paint instanceof javafx.scene.paint.LinearGradient) {\n-                        javafx.scene.paint.LinearGradient lgradient = (javafx.scene.paint.LinearGradient) paint;\n-                        computeAndSetBackground(lgradient.getStops());\n-                    } else if (paint instanceof javafx.scene.paint.RadialGradient) {\n-                        javafx.scene.paint.RadialGradient rgradient = (javafx.scene.paint.RadialGradient) paint;\n-                        computeAndSetBackground(rgradient.getStops());\n-                    }\n+            }\n+            if (modality != Modality.NONE) {\n+                windowMask |= Window.MODAL;\n+            }\n+            platformWindow =\n+                    app.createWindow(ownerWindow, Screen.getMainScreen(), windowMask);\n+            platformWindow.setResizable(resizable);\n+            platformWindow.setFocusable(focusable);\n+            if (securityDialog) {\n+                platformWindow.setLevel(Window.Level.FLOATING);\n+            }\n+            if (fxStage != null && fxStage.getScene() != null) {\n+                javafx.scene.paint.Paint paint = fxStage.getScene().getFill();\n+                if (paint instanceof javafx.scene.paint.Color) {\n+                    javafx.scene.paint.Color color = (javafx.scene.paint.Color) paint;\n+                    platformWindow.setBackground((float) color.getRed(), (float) color.getGreen(), (float) color.getBlue());\n+                } else if (paint instanceof javafx.scene.paint.LinearGradient) {\n+                    javafx.scene.paint.LinearGradient lgradient = (javafx.scene.paint.LinearGradient) paint;\n+                    computeAndSetBackground(lgradient.getStops());\n+                } else if (paint instanceof javafx.scene.paint.RadialGradient) {\n+                    javafx.scene.paint.RadialGradient rgradient = (javafx.scene.paint.RadialGradient) paint;\n+                    computeAndSetBackground(rgradient.getStops());\n@@ -220,1 +204,0 @@\n-\n@@ -222,0 +205,1 @@\n+\n@@ -335,3 +319,0 @@\n-        if (isAppletStage) {\n-            xSet = ySet = false;\n-        }\n@@ -548,3 +529,0 @@\n-            if (isAppletStage && null != appletWindow) {\n-                appletWindow.assertStageOrder();\n-            }\n@@ -627,4 +605,0 @@\n-    boolean isApplet() {\n-        return isPrimaryStage && null != appletWindow;\n-    }\n-\n@@ -786,3 +760,0 @@\n-        if (isAppletStage && null != appletWindow) {\n-            appletWindow.assertStageOrder();\n-        }\n@@ -794,3 +765,0 @@\n-        if (isAppletStage && null != appletWindow) {\n-            appletWindow.assertStageOrder();\n-        }\n@@ -925,5 +893,0 @@\n-        if (enabled) {\n-            if (isAppletStage && null != appletWindow) {\n-                appletWindow.assertStageOrder();\n-            }\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/WindowStage.java","additions":60,"deletions":97,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -174,2 +174,1 @@\n-        \/\/ Ignore IllegalMonitorStateException, these are thrown from the ThreadPoolExecutor\n-        \/\/ when a browser navigates away from a page hosting an applet that uses\n+        \/\/ Ignore IllegalMonitorStateException which could be thrown from the ThreadPoolExecutor in certain cases when there are\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/concurrent\/Service.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -127,2 +127,2 @@\n-    \/\/ the url of the stylesheet file, or the docbase of an applet. This will\n-    \/\/ be null if the source is not a file or from an applet.\n+    \/\/ the url of the stylesheet file. This will\n+    \/\/ be null if the source is not a file.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/CssParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -438,9 +438,0 @@\n-    if (ctx != NULL && dynamic_cast<WindowContextPlug*>(ctx) && ctx->get_gtk_window()) {\n-        WindowContextPlug* ctx_plug = dynamic_cast<WindowContextPlug*>(ctx);\n-        if (!ctx_plug->embedded_children.empty()) {\n-            \/\/ forward to child\n-            ctx = (WindowContext*) ctx_plug->embedded_children.back();\n-            window = ctx->get_gdk_window();\n-        }\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,42 +98,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_gtk_GtkWindow\n- * Method:    _createChildWindow\n- * Signature: (J)J\n- *\/\n-JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1createChildWindow\n-  (JNIEnv * env, jobject obj , jlong owner)\n-{\n-    (void)env;\n-\n-    GdkWindow *parent_window = NULL;\n-    GtkWidget *parent_widget = NULL;\n-    WindowContextPlug *parent_ctx = NULL;\n-    WindowContext *ctx = NULL;\n-\n-    parent_window = gdk_x11_window_lookup_for_display(\n-                        gdk_display_get_default(),\n-                        (Window)PTR_TO_JLONG(owner));\n-\n-    if (parent_window != NULL) {\n-        parent_ctx = (WindowContextPlug *)g_object_get_data(G_OBJECT(parent_window), GDK_WINDOW_DATA_CONTEXT);\n-        \/\/ HACK: do not use get_gtk_window()\n-        \/\/ the method is intended to return GtkWindow that can be used for FileChooser\n-        \/\/ (OK, that's also a hack, but still...)\n-        if (parent_ctx != NULL) {\n-            parent_widget = GTK_WIDGET(parent_ctx->get_gtk_window());\n-        }\n-    }\n-\n-    if (parent_widget == NULL) {\n-        \/\/ If 'owner' is a bad handle, then the child window is created unparented\n-        ctx = new WindowContextPlug(obj, JLONG_TO_PTR(owner));\n-    } else {\n-        ctx = new WindowContextChild(obj,\n-                        JLONG_TO_PTR(owner),\n-                        parent_ctx->gtk_container,\n-                        parent_ctx);\n-    }\n-\n-    return PTR_TO_JLONG(ctx);\n-}\n-\n@@ -628,35 +586,0 @@\n-\n-\/*\n- * Class:     com_sun_glass_ui_gtk_GtkWindow\n- * Method:    _getEmbeddedX\n- * Signature: (J)I\n- *\/\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1getEmbeddedX\n-  (JNIEnv *env, jobject obj, jlong ptr) {\n-    (void)env;\n-    (void)obj;\n-\n-    if (ptr) {\n-        WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n-        return (jint) ctx->getEmbeddedX();\n-    }\n-    return 0;\n-}\n-\n-\/*\n- * Class:     com_sun_glass_ui_gtk_GtkWindow\n- * Method:    _getEmbeddedY\n- * Signature: (J)I\n- *\/\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1getEmbeddedY\n-  (JNIEnv *env, jobject obj, jlong ptr) {\n-    (void)env;\n-    (void)obj;\n-\n-    if (ptr) {\n-        WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n-        return (jint) ctx->getEmbeddedY();\n-    }\n-    return 0;\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1541,424 +1541,0 @@\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ WindowContextPlug \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-static gboolean plug_configure(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n-    (void)widget;\n-\n-    if (event->type == GDK_CONFIGURE) {\n-        ((WindowContextPlug*)user_data)->process_gtk_configure(&event->configure);\n-    }\n-    return FALSE;\n-}\n-\n-WindowContextPlug::WindowContextPlug(jobject _jwindow, void* _owner) :\n-        WindowContextBase(),\n-        parent()\n-{\n-    jwindow = mainEnv->NewGlobalRef(_jwindow);\n-\n-    gtk_widget = gtk_plug_new((Window)PTR_TO_JLONG(_owner));\n-\n-    g_signal_connect(G_OBJECT(gtk_widget), \"configure-event\", G_CALLBACK(plug_configure), this);\n-\n-    gtk_widget_set_size_request(gtk_widget, 0, 0);\n-    gtk_widget_set_events(gtk_widget, GDK_FILTERED_EVENTS_MASK);\n-    gtk_widget_set_can_focus(GTK_WIDGET(gtk_widget), TRUE);\n-    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n-\n-    gtk_widget_realize(gtk_widget);\n-    gdk_window = gtk_widget_get_window(gtk_widget);\n-    gdk_window_set_events(gdk_window, GDK_FILTERED_EVENTS_MASK);\n-\n-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n-    gdk_window_register_dnd(gdk_window);\n-\n-    gtk_container = gtk_fixed_new();\n-    gtk_container_add (GTK_CONTAINER(gtk_widget), gtk_container);\n-    gtk_widget_realize(gtk_container);\n-}\n-\n-GtkWindow *WindowContextPlug::get_gtk_window() {\n-    return GTK_WINDOW(gtk_widget);\n-}\n-\n-void WindowContextPlug::process_configure(GdkEventConfigure* event) {\n-    (void)event;\n-\n-    \/\/Note: process_gtk_configure is used, so there's no need to handle GDK events\n-}\n-\n-void WindowContextPlug::process_gtk_configure(GdkEventConfigure* event) {\n-    if (jview) {\n-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,\n-                event->width,\n-                event->height);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n-\n-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-            com_sun_glass_events_WindowEvent_RESIZE,\n-            event->width,\n-            event->height);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n-\n-    if (!embedded_children.empty()) {\n-        WindowContextChild* child = embedded_children.back();\n-        child->process_configure(event);\n-    }\n-}\n-\n-bool WindowContextPlug::set_view(jobject view) {\n-    \/\/ probably never called for applet window\n-    if (jview) {\n-        mainEnv->DeleteGlobalRef(jview);\n-    }\n-\n-    if (view) {\n-        gint width, height;\n-        jview = mainEnv->NewGlobalRef(view);\n-        gtk_window_get_size(GTK_WINDOW(gtk_widget), &width, &height);\n-        mainEnv->CallVoidMethod(view, jViewNotifyResize, width, height);\n-        CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)\n-    } else {\n-        jview = NULL;\n-    }\n-    return TRUE;\n-}\n-\n-void WindowContextPlug::window_configure(XWindowChanges *windowChanges,\n-        unsigned int windowChangesMask) {\n-    if (windowChangesMask == 0) {\n-        return;\n-    }\n-\n-    if (windowChangesMask & (CWX | CWY)) {\n-        gint newX, newY;\n-        gtk_window_get_position(GTK_WINDOW(gtk_widget), &newX, &newY);\n-\n-        if (windowChangesMask & CWX) {\n-            newX = windowChanges->x;\n-        }\n-        if (windowChangesMask & CWY) {\n-            newY = windowChanges->y;\n-        }\n-        gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);\n-    }\n-\n-    if (windowChangesMask & (CWWidth | CWHeight)) {\n-        gint newWidth, newHeight;\n-        gtk_window_get_size(GTK_WINDOW(gtk_widget),\n-                &newWidth, &newHeight);\n-\n-        if (windowChangesMask & CWWidth) {\n-            newWidth = windowChanges->width;\n-        }\n-        if (windowChangesMask & CWHeight) {\n-            newHeight = windowChanges->height;\n-        };\n-        gtk_widget_set_size_request(gtk_widget, newWidth, newHeight);\n-    }\n-}\n-\n-void WindowContextPlug::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {\n-    XWindowChanges windowChanges;\n-    unsigned int windowChangesMask = 0;\n-\n-    if (xSet) {\n-        windowChanges.x = x;\n-        windowChangesMask |= CWX;\n-    }\n-\n-    if (ySet) {\n-        windowChanges.y = y;\n-        windowChangesMask |= CWY;\n-    }\n-\n-    if (w > 0) {\n-        windowChanges.width = w;\n-        windowChangesMask |= CWWidth;\n-    } else if (cw > 0) {\n-        windowChanges.width = cw;\n-        windowChangesMask |= CWWidth;\n-    }\n-\n-    if (h > 0) {\n-        windowChanges.height = h;\n-        windowChangesMask |= CWHeight;\n-    } else if (ch > 0) {\n-        windowChanges.height = ch;\n-        windowChangesMask |= CWHeight;\n-    }\n-\n-    window_configure(&windowChanges, windowChangesMask);\n-}\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ WindowContextChild \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-void WindowContextChild::process_mouse_button(GdkEventButton* event) {\n-    WindowContextBase::process_mouse_button(event);\n-   \/\/ gtk_window_set_focus (GTK_WINDOW (gtk_widget_get_ancestor(gtk_widget, GTK_TYPE_WINDOW)), NULL);\n-    gtk_widget_grab_focus(gtk_widget);\n-}\n-\n-static gboolean child_focus_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data)\n-{\n-    (void)widget;\n-\n-    WindowContext *ctx = (WindowContext *)user_data;\n-    ctx->process_focus(&event->focus_change);\n-    return TRUE;\n-}\n-\n-WindowContextChild::WindowContextChild(jobject _jwindow,\n-                                       void* _owner,\n-                                       GtkWidget *parent_widget,\n-                                       WindowContextPlug *parent_ctx) :\n-        WindowContextBase(),\n-        parent(),\n-        full_screen_window(),\n-        view()\n-{\n-    (void)_owner;\n-\n-    jwindow = mainEnv->NewGlobalRef(_jwindow);\n-    gtk_widget = gtk_drawing_area_new();\n-    parent = parent_ctx;\n-\n-    glong xvisualID = (glong) mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n-\n-    if (xvisualID != 0) {\n-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n-        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n-    }\n-\n-    gtk_widget_set_events(gtk_widget, GDK_FILTERED_EVENTS_MASK);\n-    gtk_widget_set_can_focus(GTK_WIDGET(gtk_widget), TRUE);\n-    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n-    gtk_container_add (GTK_CONTAINER(parent_widget), gtk_widget);\n-    gtk_widget_realize(gtk_widget);\n-    gdk_window = gtk_widget_get_window(gtk_widget);\n-    gdk_window_set_events(gdk_window, GDK_FILTERED_EVENTS_MASK);\n-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n-    gdk_window_register_dnd(gdk_window);\n-    g_signal_connect(gtk_widget, \"focus-in-event\", G_CALLBACK(child_focus_callback), this);\n-    g_signal_connect(gtk_widget, \"focus-out-event\", G_CALLBACK(child_focus_callback), this);\n-}\n-\n-void WindowContextChild::set_visible(bool visible) {\n-    std::vector<WindowContextChild*> &embedded_children =\n-            dynamic_cast<WindowContextPlug*>(parent)->embedded_children;\n-\n-    if (visible) {\n-        embedded_children.push_back(this);\n-    } else {\n-        std::vector<WindowContextChild*>::iterator pos\n-                = std::find(embedded_children.begin(), embedded_children.end(), this);\n-        if (pos != embedded_children.end()) {\n-            embedded_children.erase((pos));\n-        }\n-    }\n-\n-    WindowContextBase::set_visible(visible);\n-}\n-\n-GtkWindow *WindowContextChild::get_gtk_window() {\n-    return GTK_WINDOW(gtk_widget_get_ancestor(gtk_widget, GTK_TYPE_WINDOW));\n-}\n-\n-void WindowContextChild::process_configure(GdkEventConfigure* event) {\n-    if (jview) {\n-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,\n-                event->width,\n-                event->height);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n-\n-    gtk_widget_set_size_request(gtk_widget, event->width, event->height);\n-\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-                com_sun_glass_events_WindowEvent_RESIZE,\n-                event->width,\n-                event->height);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n-}\n-\n-bool WindowContextChild::set_view(jobject view) {\n-    if (jview) {\n-        mainEnv->DeleteGlobalRef(jview);\n-    }\n-\n-    if (view) {\n-        gint width, height;\n-        jview = mainEnv->NewGlobalRef(view);\n-        GtkAllocation ws;\n-        gtk_widget_get_allocation(gtk_widget, &ws);\n-        width = ws.width;\n-        height = ws.height;\n-        mainEnv->CallVoidMethod(view, jViewNotifyResize, width, height);\n-        CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)\n-    } else {\n-        jview = NULL;\n-    }\n-    return TRUE;\n-}\n-\n-void WindowContextChild::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {\n-\n-    if (x > 0 || y > 0 || xSet || ySet) {\n-        gint newX, newY;\n-        gdk_window_get_origin(gdk_window, &newX, &newY);\n-        if (jwindow) {\n-            mainEnv->CallVoidMethod(jwindow,\n-                    jWindowNotifyMove,\n-                    newX, newY);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n-\n-    \/\/ As we have no frames, there's no difference between the calls\n-    if ((cw | ch) > 0) {\n-        w = cw; h = ch;\n-    }\n-\n-    if (w > 0 || h > 0) {\n-        gint newWidth, newHeight;\n-        GtkAllocation ws;\n-        gtk_widget_get_allocation(gtk_widget, &ws);\n-        newWidth = ws.width;\n-        newHeight = ws.height;\n-\n-        if (w > 0) {\n-            newWidth = w;\n-        }\n-        if (h > 0) {\n-            newHeight = h;\n-        }\n-        gtk_widget_set_size_request(gtk_widget, newWidth, newHeight);\n-        \/\/ FIXME: hack to set correct size to view\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview,\n-                    jViewNotifyResize,\n-                    newWidth, newHeight);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n-}\n-\n-int WindowContextChild::getEmbeddedX() {\n-    int x;\n-    gdk_window_get_origin(gdk_window, &x, NULL);\n-    return x;\n-}\n-\n-int WindowContextChild::getEmbeddedY() {\n-    int y;\n-    gdk_window_get_origin(gdk_window, NULL, &y);\n-    return y;\n-\n-}\n-\n-void WindowContextChild::restack(bool toFront) {\n-    std::vector<WindowContextChild*> &embedded_children =\n-                dynamic_cast<WindowContextPlug*>(parent)->embedded_children;\n-\n-    std::vector<WindowContextChild*>::iterator pos\n-        = std::find(embedded_children.begin(), embedded_children.end(), this);\n-\n-    embedded_children.erase(pos);\n-    if (toFront) {\n-        embedded_children.push_back(this);\n-    } else {\n-        embedded_children.insert(embedded_children.begin(), this);\n-    }\n-\n-    gdk_window_restack(gdk_window, NULL, toFront ? TRUE : FALSE);\n-}\n-\n-void WindowContextChild::enter_fullscreen() {\n-    if (full_screen_window) {\n-        return;\n-    }\n-\n-    full_screen_window = new WindowContextTop(jwindow, NULL, 0L, UNTITLED,\n-                                                NORMAL, (GdkWMFunction) 0);\n-    int x, y, w, h;\n-    gdk_window_get_origin(gdk_window, &x, &y);\n-#ifdef GLASS_GTK3\n-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);\n-#else\n-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);\n-#endif\n-    full_screen_window->set_bounds(x, y, true, true, w, h, -1, -1);\n-\n-    if (WindowContextBase::sm_grab_window == this) {\n-        ungrab_focus();\n-    }\n-\n-    reparent_children(full_screen_window);\n-\n-    full_screen_window->set_visible(true);\n-    full_screen_window->enter_fullscreen();\n-\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyDelegatePtr, (jlong)full_screen_window);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n-\n-    if (jview) {\n-        this->view = (GlassView*)mainEnv->GetLongField(jview, jViewPtr);\n-\n-        this->view->current_window = full_screen_window;\n-        this->view->embedded_window = this;\n-        full_screen_window->set_view(jview);\n-        this->set_view(NULL);\n-    }\n-}\n-\n-void WindowContextChild::exit_fullscreen() {\n-    if (!full_screen_window) {\n-        return;\n-    }\n-\n-    if (WindowContextBase::sm_grab_window == this) {\n-        ungrab_focus();\n-    }\n-\n-    full_screen_window->reparent_children(this);\n-\n-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyDelegatePtr, (jlong)NULL);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n-\n-    if (this->view) {\n-        this->view->current_window = this;\n-        this->view->embedded_window = NULL;\n-    }\n-    this->set_view(full_screen_window->get_jview());\n-\n-    full_screen_window->detach_from_java();\n-\n-    full_screen_window->set_view(NULL);\n-\n-    full_screen_window->set_visible(false);\n-\n-    destroy_and_delete_ctx(full_screen_window);\n-    full_screen_window = NULL;\n-    this->view = NULL;\n-}\n-\n-void WindowContextChild::process_destroy() {\n-    if (full_screen_window) {\n-        destroy_and_delete_ctx(full_screen_window);\n-    }\n-\n-    std::vector<WindowContextChild*> &embedded_children =\n-            dynamic_cast<WindowContextPlug*>(parent)->embedded_children;\n-\n-    std::vector<WindowContextChild*>::iterator pos\n-                = std::find(embedded_children.begin(), embedded_children.end(), this);\n-    if (pos != embedded_children.end()) {\n-        embedded_children.erase((pos));\n-    }\n-\n-    WindowContextBase::process_destroy();\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":0,"deletions":424,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-class WindowContextChild;\n@@ -168,4 +167,0 @@\n-    virtual int getEmbeddedX() = 0;\n-    virtual int getEmbeddedY() = 0;\n-\n-\n@@ -259,3 +254,0 @@\n-    int getEmbeddedX() { return 0; }\n-    int getEmbeddedY() { return 0; }\n-\n@@ -274,91 +266,0 @@\n-class WindowContextPlug: public WindowContextBase {\n-    WindowContext* parent;\n-public:\n-    bool set_view(jobject);\n-    void set_bounds(int, int, bool, bool, int, int, int, int);\n-    \/\/WindowFrameExtents get_frame_extents() { return WindowFrameExtents{0, 0, 0, 0}; };\n-    WindowFrameExtents get_frame_extents() { WindowFrameExtents ext = {0, 0, 0, 0}; return ext;}\n-\n-    void enter_fullscreen() {}\n-    void exit_fullscreen() {}\n-    void set_resizable(bool) {}\n-    void request_focus() {}\n-    void set_focusable(bool) {}\n-    void set_title(const char*) {}\n-    void set_alpha(double) {}\n-    void set_enabled(bool) {}\n-    void set_minimum_size(int, int) {}\n-    void set_maximum_size(int, int) {}\n-    void set_minimized(bool) {}\n-    void set_maximized(bool) {}\n-    void set_icon(GdkPixbuf*) {}\n-    void restack(bool) {}\n-    void set_modal(bool, WindowContext*) {}\n-    void set_gravity(float, float) {}\n-    void process_property_notify(GdkEventProperty*) {}\n-    void process_configure(GdkEventConfigure*);\n-    void process_gtk_configure(GdkEventConfigure*);\n-\n-    void applyShapeMask(void*, uint width, uint height) {\n-        (void)width;\n-        (void)height;\n-    }\n-    GtkWindow *get_gtk_window(); \/\/ TODO, get window from parent\n-\n-    WindowContextPlug(jobject, void*);\n-    GtkWidget* gtk_container;\n-    std::vector<WindowContextChild *> embedded_children;\n-private:\n-    \/\/HACK: remove once set_bounds is implemented correctly\n-    void window_configure(XWindowChanges *, unsigned int);\n-    WindowContextPlug(WindowContextPlug&);\n-    WindowContextPlug& operator= (const WindowContextPlug&);\n-};\n-\n-class WindowContextChild: public WindowContextBase {\n-    WindowContextPlug* parent;\n-    WindowContextTop* full_screen_window;\n-    GlassView* view; \/\/ not null while in Full Screen\n-public:\n-    void process_mouse_button(GdkEventButton*);\n-    bool set_view(jobject);\n-    void set_bounds(int, int, bool, bool, int, int, int, int);\n-    \/\/WindowFrameExtents get_frame_extents() { return WindowFrameExtents{0, 0, 0, 0}; };\n-    WindowFrameExtents get_frame_extents() { WindowFrameExtents ext = {0, 0, 0, 0}; return ext;}\n-\n-    void enter_fullscreen();\n-    void exit_fullscreen();\n-    void set_resizable(bool) {}\n-    void request_focus() {}\n-    void set_focusable(bool) {}\n-    void set_title(const char*) {}\n-    void set_alpha(double) {}\n-    void set_enabled(bool) {}\n-    void set_minimum_size(int, int) {}\n-    void set_maximum_size(int, int) {}\n-    void set_minimized(bool) {}\n-    void set_maximized(bool) {}\n-    void set_icon(GdkPixbuf*) {}\n-    void restack(bool);\n-    void set_modal(bool, WindowContext*) {}\n-    void set_gravity(float, float) {}\n-    void process_property_notify(GdkEventProperty*) {}\n-    void process_configure(GdkEventConfigure*);\n-    void process_destroy();\n-    void set_visible(bool visible);\n-\n-    int getEmbeddedX();\n-    int getEmbeddedY();\n-\n-    void applyShapeMask(void*, uint width, uint height) {\n-        (void)width;\n-        (void)height;\n-    }\n-    GtkWindow *get_gtk_window(); \/\/ TODO, get window from parent\n-\n-    WindowContextChild(jobject, void*, GtkWidget *parent_widget, WindowContextPlug *parent_context);\n-private:\n-    WindowContextChild(WindowContextChild&);\n-    WindowContextChild& operator= (const WindowContextChild&);\n-};\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":0,"deletions":99,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -972,13 +972,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_ios_IosWindow\n- * Method:    _createChildWindow\n- * Signature: (J)J\n- *\/\n-JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow\n-(JNIEnv *env, jobject jwindow, jlong parent) {\n-    GLASS_LOG(\"Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow\");\n-    \/\/ implementation comes here\n-    return 0L;\n-}\n-\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/ios\/GlassWindow.m","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#import \"RemoteLayerSupport.h\"\n@@ -631,5 +630,0 @@\n-                else\n-                {\n-                    \/\/ 10.6 or earlier: applets are not officially supported on 10.6 and earlier\n-                    \/\/ so they will have limited applet functionality (no active windows)\n-                }\n@@ -1002,29 +996,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_mac_MacApplication\n- * Method:    _getRemoteLayerServerName\n- * Signature: ()Ljava\/lang\/String;\n- *\/\n-JNIEXPORT jstring JNICALL Java_com_sun_glass_ui_mac_MacApplication__1getRemoteLayerServerName\n-(JNIEnv *env, jobject japplication)\n-{\n-    LOG(\"Java_com_sun_glass_ui_mac_MacPasteboard__1getName\");\n-\n-    jstring name = NULL;\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        static mach_port_t remoteLayerServerPort = MACH_PORT_NULL;\n-        if (remoteLayerServerPort == MACH_PORT_NULL)\n-        {\n-            remoteLayerServerPort = RemoteLayerStartServer();\n-        }\n-        NSString *remoteLayerServerName = RemoteLayerGetServerName(remoteLayerServerPort);\n-        name = (*env)->NewStringUTF(env, [remoteLayerServerName UTF8String]);\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-\n-    return name;\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassApplication.m","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import <Cocoa\/Cocoa.h>\n-#import <jni.h>\n-\n-#import \"GlassWindow.h\"\n-#import \"GlassWindow+Java.h\"\n-#import \"GlassWindow+Overrides.h\"\n-\n-@interface GlassEmbeddedWindow (Npapi)\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassEmbeddedWindow+Npapi.h","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,331 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"common.h\"\n-#import \"com_sun_glass_events_mac_NpapiEvent.h\"\n-#import \"com_sun_glass_ui_Window.h\"\n-#import \"com_sun_glass_ui_mac_MacWindow.h\"\n-\n-#import \"GlassMacros.h\"\n-#import \"GlassEmbeddedWindow+Npapi.h\"\n-#import \"GlassNSEvent.h\"\n-#import \"GlassHelper.h\"\n-\n-\/\/#define VERBOSE\n-#ifndef VERBOSE\n-    #define LOG(MSG, ...)\n-#else\n-    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n-#endif\n-\n-#pragma mark --- Internal utilities\n-\n-inline GlassEmbeddedWindow *getGlassEmbeddedWindow(JNIEnv *env, jlong jPtr)\n-{\n-    if (jPtr != 0L)\n-    {\n-        return (GlassEmbeddedWindow*)jlong_to_ptr(jPtr);\n-    }\n-    else\n-    {\n-        return nil;\n-    }\n-}\n-\n-#pragma mark --- GlassEmbeddedWindow (Npapi)\n-\n-@implementation GlassEmbeddedWindow (Npapi)\n-\n-@end\n-\n-#pragma mark --- Java APIs\n-\n-\/*\n- * Class:     com_sun_glass_events_mac_NpapiEvent\n- * Method:    _dispatchCocoaNpapiDrawEvent\n- * Signature: (JIJDDDD)V\n- *\/\n-JNIEXPORT void JNICALL Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiDrawEvent\n-(JNIEnv *env, jclass jNpapiClass, jlong jPtr, jint jType, jlong jContext, jdouble jX, jdouble jY, jdouble jWidth, jdouble jHeight)\n-{\n-    LOG(\"Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiDrawEvent\");\n-\n-    \/\/ NOP, we use layer based architecture, so we will never get draw event\n-    NSLog(@\"WARNING: GlassEmbeddedWindow+Npapi received _dispatchCocoaNpapiDrawEvent\");\n-}\n-\n-\/*\n- * Class:     com_sun_glass_events_mac_NpapiEvent\n- * Method:    _dispatchCocoaNpapiMouseEvent\n- * Signature: (JIIDDIIDDD)V\n- *\/\n-JNIEXPORT void JNICALL Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiMouseEvent\n-(JNIEnv *env, jclass jNpapiClass, jlong jPtr, jint jType, jint jModifierFlags, jdouble jPluginX, jdouble jPluginY, jint jButtonNumber, jint jClickCount, jdouble jDeltaX, jdouble jDeltaY, jdouble jDeltaZ)\n-{\n-    LOG(\"Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiMouseEvent\");\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);\n-        if ((window != nil) && (window->child != nil))\n-        {\n-            NSEventType type = 0;\n-            switch (jType)\n-            {\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventMouseEntered:\n-                    LOG(\"   NSMouseEntered\");\n-                    type = NSMouseEntered;\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventMouseExited:\n-                    LOG(\"   NSMouseExited\");\n-                    type = NSMouseExited;\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventMouseDown:\n-                    LOG(\"   NSLeftMouseDown\");\n-                    if (jButtonNumber == 0) {\n-                        type = NSLeftMouseDown;\n-                    } else if (jButtonNumber == 1) {\n-                        type = NSRightMouseDown;\n-                    } else {\n-                        type = NSOtherMouseDown;\n-                    }\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventMouseUp:\n-                    LOG(\"   NSLeftMouseUp\");\n-                    if (jButtonNumber == 0) {\n-                        type = NSLeftMouseUp;\n-                    } else if (jButtonNumber == 1) {\n-                        type = NSRightMouseUp;\n-                    } else {\n-                        type = NSOtherMouseUp;\n-                    }\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventMouseDragged:\n-                    LOG(\"   NSLeftMouseDragged\");\n-                    if (jButtonNumber == 0) {\n-                        type = NSLeftMouseDragged;\n-                    } else if (jButtonNumber == 1) {\n-                        type = NSRightMouseDragged;\n-                    } else {\n-                        type = NSOtherMouseDragged;\n-                    }\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventMouseMoved:\n-                    LOG(\"   NSMouseMoved\");\n-                    type = NSMouseMoved;\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventScrollWheel:\n-                    LOG(\"   NSScrollWheel\");\n-                    type = NSScrollWheel;\n-                    break;\n-            }\n-\n-            NSEvent *event = nil;\n-            jdouble windowY = [window->child frame].size.height - jPluginY;\n-            if ((type == NSMouseEntered) || (type == NSMouseExited))\n-            {\n-                event = [NSEvent enterExitEventWithType:type\n-                                               location:NSMakePoint((CGFloat)jPluginX, (CGFloat)windowY)\n-                                          modifierFlags:(NSUInteger)jModifierFlags\n-                                              timestamp:[NSDate timeIntervalSinceReferenceDate]\n-                                           windowNumber:[window->child windowNumber]\n-                                                context:nil\n-                                            eventNumber:0\n-                                         trackingNumber:0\n-                                               userData:nil];\n-                [event setValue:window->child forKey:@\"window\"];\n-                LOG(\"   NPAPI mouse event: %s\", [[event description] UTF8String]);\n-            } else if (type != NSScrollWheel) {\n-                NSPoint eventPoint = NSMakePoint((CGFloat)jPluginX, (CGFloat)windowY);\n-                event = [NSEvent mouseEventWithType:type\n-                                           location:eventPoint\n-                                      modifierFlags:(NSUInteger)jModifierFlags\n-                                          timestamp:[NSDate timeIntervalSinceReferenceDate]\n-                                       windowNumber:[window->child windowNumber]\n-                                            context:nil\n-                                        eventNumber:0\n-                                         clickCount:jClickCount\n-                                           pressure:0.0f];\n-                [event setValue:window->child forKey:@\"window\"];\n-                LOG(\"   NPAPI mouse event: %s\", [[event description] UTF8String]);\n-            }\n-            else\n-            {\n-                CGEventRef scrollEvent = CGEventCreateScrollWheelEvent\n-                    (NULL, kCGScrollEventUnitPixel, 3, (int)jDeltaY, (int)jDeltaX, (int)jDeltaZ);\n-                event = [NSEvent eventWithCGEvent:scrollEvent];\n-                NSValue *location = [NSValue valueWithPoint:NSMakePoint((CGFloat)jPluginX, (CGFloat)windowY)];\n-                [event setValue:location forKey:@\"location\"];\n-                [event setValue:[NSNumber numberWithInteger:[window->child windowNumber]] forKey:@\"windowNumber\"];\n-            }\n-\n-            if (event != nil)\n-            {\n-                [window->child sendEvent:event];\n-            }\n-        }\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-}\n-\n-\/*\n- * Class:     com_sun_glass_events_mac_NpapiEvent\n- * Method:    _dispatchCocoaNpapiKeyEvent\n- * Signature: (JIILjava\/lang\/String;Ljava\/lang\/String;ZI)V\n- *\/\n-JNIEXPORT void JNICALL Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiKeyEvent\n-(JNIEnv *env, jclass jNpapiClass, jlong jPtr, jint jType, jint jModifierFlags, jstring jCharacters,\n-    jstring jCharactersIgnoringModifiers, jboolean jIsrepeat, jint jKeyCode, jboolean jNeedsKeyTyped)\n-{\n-    LOG(\"Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiKeyEvent\");\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);\n-        if ((window != nil) && (window->child != nil))\n-        {\n-            NSEventType type = 0;\n-            switch (jType)\n-            {\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventKeyDown:\n-                    type = NSKeyDown;\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventKeyUp:\n-                    type = NSKeyUp;\n-                    break;\n-                case com_sun_glass_events_mac_NpapiEvent_NPCocoaEventFlagsChanged:\n-                    type = NSFlagsChanged;\n-                    break;\n-            }\n-\n-            GlassNSEvent *event = (GlassNSEvent *)[GlassNSEvent keyEventWithType:type\n-                                              location:NSMakePoint(0.0, 0.0)\n-                                         modifierFlags:(NSUInteger)jModifierFlags\n-                                             timestamp:[NSDate timeIntervalSinceReferenceDate]\n-                                          windowNumber:[window->child windowNumber]\n-                                               context:nil\n-                                            characters:[GlassHelper nsStringWithJavaString:jCharacters withEnv:env]\n-                           charactersIgnoringModifiers:[GlassHelper nsStringWithJavaString:jCharactersIgnoringModifiers\n-                                                                                   withEnv:env]\n-                                             isARepeat:(jIsrepeat==JNI_TRUE)\n-                                               keyCode:(unsigned short)jKeyCode];\n-            LOG(\"   NPAPI key event: %s\", [[event description] UTF8String]);\n-            if (event != nil)\n-            {\n-                [event setNeedsKeyTyped:(jNeedsKeyTyped==JNI_TRUE)];\n-                [window->child sendEvent:event];\n-            }\n-        }\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-}\n-\n-\/*\n- * Class:     com_sun_glass_events_mac_NpapiEvent\n- * Method:    _dispatchCocoaNpapiFocusEvent\n- * Signature: (JIZ)V\n- *\/\n-JNIEXPORT void JNICALL Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiFocusEvent\n-(JNIEnv *env, jclass jNpapiClass, jlong jPtr, jint jType, jboolean jHasFocus)\n-{\n-    LOG(\"Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiFocusEvent\");\n-    LOG(\"   jPtr: %p\", jPtr);\n-    LOG(\"   jHasFocus: %d\", jHasFocus);\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);\n-        if ((window != nil) && (window->child != nil))\n-        {\n-            if (jHasFocus == JNI_TRUE)\n-            {\n-                [window->child performSelectorOnMainThread:@selector(makeKeyWindow) withObject:nil waitUntilDone:NO];\n-            }\n-            else\n-            {\n-                [window->child performSelectorOnMainThread:@selector(resignKeyWindow) withObject:nil waitUntilDone:NO];\n-            }\n-        }\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-}\n-\n-\/*\n- * Class:     com_sun_glass_events_mac_NpapiEvent\n- * Method:    _dispatchCocoaNpapiTextInputEvent\n- * Signature: (JILjava\/lang\/String;)V\n- *\/\n-JNIEXPORT void JNICALL Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiTextInputEvent\n-(JNIEnv *env, jclass jNpapiClass, jlong jPtr, jint jType, jstring jText)\n-{\n-    LOG(\"Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiTextInputEvent\");\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);\n-        NSString *chars = [GlassHelper nsStringWithJavaString:jText withEnv:env];\n-        if ((window != nil) && (window->child != nil))\n-        {\n-            unichar *unichars = malloc([chars length] * sizeof(unichar));\n-            [chars getCharacters:unichars range:NSMakeRange(0, [chars length])];\n-\n-            \/\/ Create a key-typed event for each character in the text input event.\n-            \/\/ This is better than sending a text input event because in the NPAPI\n-            \/\/ case there is no in-progress text to display.\n-            for (NSUInteger i = 0; i < [chars length]; i++) {\n-                NSString *singleChar = [NSString stringWithCharacters:&unichars[i] length:1];\n-                GlassNSEvent *event =\n-                (GlassNSEvent *)[GlassNSEvent keyEventWithType:NSKeyDown\n-                                                      location:NSMakePoint(0.0, 0.0)\n-                                                 modifierFlags:0\n-                                                     timestamp:[NSDate timeIntervalSinceReferenceDate]\n-                                                  windowNumber:[window->child windowNumber]\n-                                                       context:nil\n-                                                    characters:singleChar\n-                                   charactersIgnoringModifiers:singleChar\n-                                                     isARepeat:NO\n-                                                       keyCode:0];\n-                [event setSyntheticKeyTyped:YES];\n-                [window->child sendEvent:event];\n-            }\n-            free(unichars);\n-        }\n-\n-        if ([chars length] == 1) {\n-            Java_com_sun_glass_events_mac_NpapiEvent__1dispatchCocoaNpapiKeyEvent(\n-                env, jNpapiClass, jPtr, com_sun_glass_events_mac_NpapiEvent_NPCocoaEventKeyUp,\n-                0, jText, jText, JNI_FALSE, 0, JNI_FALSE);\n-        }\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassEmbeddedWindow+Npapi.m","additions":0,"deletions":331,"binary":false,"changes":331,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import <Cocoa\/Cocoa.h>\n-#import <jni.h>\n-\n-#import \"GlassWindow.h\"\n-#import \"GlassWindow+Java.h\"\n-#import \"GlassWindow+Overrides.h\"\n-\n-@interface GlassEmbeddedWindow (Overrides)\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassEmbeddedWindow+Overrides.h","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"common.h\"\n-#import \"com_sun_glass_events_WindowEvent.h\"\n-#import \"com_sun_glass_ui_Window.h\"\n-#import \"com_sun_glass_ui_Window_Level.h\"\n-#import \"com_sun_glass_ui_mac_MacWindow.h\"\n-\n-#import \"GlassMacros.h\"\n-#import \"GlassWindow.h\"\n-#import \"GlassWindow+Java.h\"\n-#import \"GlassWindow+Overrides.h\"\n-#import \"GlassEmbeddedWindow+Overrides.h\"\n-#import \"GlassView.h\"\n-#import \"GlassView3D.h\"\n-#import \"GlassLayer3D.h\"\n-\n-\/\/#define VERBOSE\n-#ifndef VERBOSE\n-    #define LOG(MSG, ...)\n-#else\n-    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n-#endif\n-\n-#define ALPHA 0.0f\n-\n-\/\/ a special window which is transparent and without shadow so it does not show\n-@implementation GlassEmbeddedWindow (Overrides)\n-\n-- (BOOL)_isParent\n-{\n-    return (self->parent == nil); \/\/ has no parent, so it's the parent itself\n-}\n-\n-- (void)setContentView:(NSView *)aView\n-{\n-    [super setContentView:self->gWindow->view];\n-\n-    \/\/ embed the child layer (offscreen) into the parent layer (offscreen)\n-    if (self->parent != nil)\n-    {\n-        CALayer *layer = [self->gWindow->view layer];\n-        if ([layer isKindOfClass:[CAOpenGLLayer class]] == YES)\n-        {\n-            [((CAOpenGLLayer*)layer) setAsynchronous:NO];\n-        }\n-\n-        if ([layer isKindOfClass:[GlassLayer3D class]] == YES)\n-        {\n-            GlassOffscreen *offscreen = [((GlassLayer3D*)layer) getGlassOffscreen];\n-\n-            layer = [self->parent->gWindow->view layer];\n-            if ([layer isKindOfClass:[GlassLayer3D class]] == YES)\n-            {\n-                [((GlassLayer3D*)layer) hostOffscreen:offscreen];\n-            }\n-        }\n-    }\n-}\n-\n-\/\/ keep the window invisible\n-#pragma mark --- Visibility\n-\n-- (void)setHasShadow:(BOOL)hasShadow\n-{\n-    [super setHasShadow:NO];\n-}\n-\n-- (BOOL)hasShadow\n-{\n-    return NO;\n-}\n-\n-- (void)invalidateShadow\n-{\n-\n-}\n-\n-- (void)setAlphaValue:(CGFloat)windowAlpha\n-{\n-    [super setAlphaValue:ALPHA];\n-}\n-\n-- (CGFloat)alphaValue\n-{\n-    return ALPHA;\n-}\n-\n-- (void)setOpaque:(BOOL)isOpaque\n-{\n-    [super setOpaque:NO];\n-}\n-\n-- (BOOL)isOpaque\n-{\n-    return NO;\n-}\n-\n-#pragma mark --- Mission Control (Expose)\n-\n-- (NSWindowCollectionBehavior)collectionBehavior\n-{\n-    \/\/ make sure we do not show up in MissionControl (was Expose)\n-    return NSWindowCollectionBehaviorTransient;\n-}\n-\n-\/\/ match the child frame with that of parent\n-#pragma mark --- Frame\n-\n-- (void)setFrame:(NSRect)frameRect display:(BOOL)flag\n-{\n-    [super setFrame:frameRect display:flag];\n-    if ([self _isParent] == YES)\n-    {\n-        [self->child setFrame:frameRect display:flag];\n-    }\n-}\n-\n-- (void)setFrame:(NSRect)frameRect display:(BOOL)displayFlag animate:(BOOL)animateFlag\n-{\n-    [super setFrame:frameRect display:displayFlag animate:animateFlag];\n-    if ([self _isParent] == YES)\n-    {\n-        [self->child setFrame:frameRect display:displayFlag animate:animateFlag];\n-    }\n-}\n-\n-- (void)setContentSize:(NSSize)aSize\n-{\n-    [super setContentSize:aSize];\n-    if ([self _isParent] == YES)\n-    {\n-        [self->child setContentSize:aSize];\n-    }\n-}\n-\n-- (void)setFrameOrigin:(NSPoint)aPoint\n-{\n-    [super setFrameOrigin:aPoint];\n-    if ([self _isParent] == YES)\n-    {\n-        [self->child setFrameOrigin:aPoint];\n-    }\n-}\n-\n-- (void)setFrameTopLeftPoint:(NSPoint)aPoint\n-{\n-    [super setFrameTopLeftPoint:aPoint];\n-    if ([self _isParent] == YES)\n-    {\n-        [self->child setFrameTopLeftPoint:aPoint];\n-    }\n-}\n-\n-\/\/ manually track the focus, since the real applet is inside another process window (Browser)\n-\/\/ our own process will not be active and we can't depend on regular native NSWindow behavior\n-\n-#pragma mark --- Focus\n-\n-- (BOOL)isKeyWindow\n-{\n-    return self->isKeyWindow;\n-}\n-\n-- (void)makeKeyWindow\n-{\n-    [super makeKeyWindow];\n-\n-    self->isKeyWindow = YES;\n-    [[NSNotificationCenter defaultCenter] postNotificationName:NSWindowDidBecomeKeyNotification object:nil userInfo:nil];\n-    [[self delegate] windowDidBecomeKey:nil];\n-}\n-\n-- (void)resignKeyWindow\n-{\n-    [super resignKeyWindow];\n-\n-    self->isKeyWindow = NO;\n-    [[NSNotificationCenter defaultCenter] postNotificationName:NSWindowDidResignKeyNotification object:nil userInfo:nil];\n-    [[self delegate] windowDidResignKey:nil];\n-}\n-\n-\/\/#pragma mark --- Debug\n-\/\/\n-\/\/- (void)setBackgroundColor:(NSColor *)color\n-\/\/{\n-\/\/    if ([self _isParent] == NO)\n-\/\/    {\n-\/\/        [super setBackgroundColor:[NSColor greenColor]];\n-\/\/    }\n-\/\/    else\n-\/\/    {\n-\/\/        [super setBackgroundColor:[NSColor redColor]];\n-\/\/    }\n-\/\/}\n-\/\/\n-\/\/- (NSColor *)backgroundColor\n-\/\/{\n-\/\/    if ([self _isParent] == NO)\n-\/\/    {\n-\/\/        return [NSColor greenColor];\n-\/\/    }\n-\/\/    else\n-\/\/    {\n-\/\/        return [NSColor redColor];\n-\/\/    }\n-\/\/}\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassEmbeddedWindow+Overrides.m","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -33,4 +33,0 @@\n-    mach_port_t _serverPort;\n-    CALayer *_remoteLayer;\n-    uint32_t _remoteLayerID;\n-\n@@ -48,3 +44,0 @@\n-- (uint32_t)getRemoteLayerIdForServer:(NSString*)serverName;\n-- (void)hostRemoteLayerId:(uint32_t)layerId;\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayer3D.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#import \"RemoteLayerSupport.h\"\n@@ -43,25 +42,0 @@\n-- (void)_connectToRemoteServer:(NSString*)serverName\n-{\n-    \/\/ SAK: Note that RemoteLayerGetServerPort can return 0\/MACH_PORT_NULL. This is\n-    \/\/ not an error, and means that JRSRenderServer is tracking the port for us.\n-    \/\/ Yes, this is odd, and I've asked Apple to clarify it for us.\n-    self->_serverPort = RemoteLayerGetServerPort(serverName);\n-    self->_remoteLayer = RemoteLayerGetRemoteFromLocal(self->_serverPort, self);\n-    if (self->_remoteLayer != nil)\n-    {\n-        self->_remoteLayerID = RemoteLayerGetIdForRemote(self->_remoteLayer);\n-        if (self->_remoteLayerID != 0)\n-        {\n-            [self->_remoteLayer retain];\n-        }\n-        else\n-        {\n-            NSLog(@\"RemoteLayer ERROR: 0 _remoteLayerID for serverName:%@\", serverName);\n-        }\n-    }\n-    else\n-    {\n-        NSLog(@\"RemoteLayer ERROR: nil remoteLayer for serverName:%@\", serverName);\n-    }\n-}\n-\n@@ -77,4 +51,0 @@\n-        self->_serverPort = MACH_PORT_NULL;\n-        self->_remoteLayer = nil;\n-        self->_remoteLayerID = 0;\n-\n@@ -122,3 +92,0 @@\n-    [self->_remoteLayer dealloc];\n-    self->_remoteLayer = nil;\n-\n@@ -204,30 +171,0 @@\n-- (uint32_t)getRemoteLayerIdForServer:(NSString*)serverName\n-{\n-    if (self->_remoteLayerID == 0)\n-    {\n-        Class JRSRemoteLayer_class = objc_getClass(\"JRSRenderServer\");\n-        if (JRSRemoteLayer_class != nil)\n-        {\n-            [self _connectToRemoteServer:serverName];\n-        }\n-        else\n-        {\n-            NSLog(@\"GlassLayer3D: no remote CALayer server support detected!\");\n-            \/\/ we're running on JDK without remote CALayer server (JRSRemoteLayer.h) support\n-        }\n-    }\n-    return self->_remoteLayerID;\n-}\n-\n-- (void)hostRemoteLayerId:(uint32_t)layerId\n-{\n-    if (layerId > 0)\n-    {\n-        RemoteLayerHostRemoteIdInLocal(layerId, self);\n-    }\n-    else\n-    {\n-        NSLog(@\"GlassLayer3D: invalid remote layer id!\");\n-    }\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayer3D.m","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import <Cocoa\/Cocoa.h>\n-\n-@interface GlassNSEvent : NSEvent {\n-    BOOL m_needsKeyTyped;\n-    BOOL m_isSyntheticKeyTyped;\n-}\n-\n-- (void) setNeedsKeyTyped:(BOOL)inNeedKeyTyped;\n-- (BOOL) needsKeyTyped;\n-- (void) setSyntheticKeyTyped:(BOOL)inSyntheticKeyTyped;\n-- (BOOL) isSyntheticKeyTyped;\n-\n-@end\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassNSEvent.h","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"common.h\"\n-\n-#import \"GlassNSEvent.h\"\n-\n-@implementation GlassNSEvent\n-\n-- (void) setNeedsKeyTyped:(BOOL)inNeedKeyTyped {\n-    m_needsKeyTyped = inNeedKeyTyped;\n-}\n-\n-- (BOOL) needsKeyTyped {\n-    return m_needsKeyTyped;\n-}\n-\n-- (void) setSyntheticKeyTyped:(BOOL)inSyntheticKeyTyped {\n-    m_isSyntheticKeyTyped = inSyntheticKeyTyped;\n-}\n-\n-- (BOOL) isSyntheticKeyTyped {\n-    return m_isSyntheticKeyTyped;\n-}\n-\n-@end\n-\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassNSEvent.m","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -53,5 +53,0 @@\n-@optional\n-\n-- (uint32_t)getRemoteLayerIdForServer:(NSString*)serverName;\n-- (void)hostRemoteLayerId:(uint32_t)layerId;\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView.h","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -390,51 +390,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_mac_MacView\n- * Method:    _getNativeRemoteLayerId\n- * Signature: (JLjava\/lang\/String;)I\n- *\/\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacView__1getNativeRemoteLayerId\n-(JNIEnv *env, jobject jView, jlong jPtr, jstring jServerString)\n-{\n-    LOG(\"Java_com_sun_glass_ui_mac_MacView__1_getNativeLayerId\");\n-    LOG(\"   layer: %p\", jPtr);\n-    if (!jPtr) return 0;\n-\n-    jint layerId = 0;\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        NSView<GlassView> *view = getGlassView(env, jPtr);\n-        layerId = (jint)[view getRemoteLayerIdForServer:[GlassHelper nsStringWithJavaString:jServerString withEnv:env]];\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-\n-    LOG(\"   layerId: %d\", layerId);\n-    return layerId;\n-}\n-\n-\/*\n- * Class:     com_sun_glass_ui_mac_MacView\n- * Method:    _hostRemoteLayerId\n- * Signature: (JI)V\n- *\/\n-JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacView__1hostRemoteLayerId\n-(JNIEnv *env, jobject jView, jlong jPtr, jint jRemoteLayerId)\n-{\n-    LOG(\"Java_com_sun_glass_ui_mac_MacView__1hostRemoteLayerId\");\n-    if (!jPtr) return;\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        if (jRemoteLayerId > 0)\n-        {\n-            NSView<GlassView> *view = getGlassView(env, jPtr);\n-            [view hostRemoteLayerId:(uint32_t)jRemoteLayerId];\n-        }\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView.m","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"GlassView3D.h\"\n-\n-@interface GlassView3D (Remote)\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView3D+Remote.h","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"GlassView3D+Remote.h\"\n-\n-#import \"GlassLayer3D.h\"\n-\n-@implementation GlassView3D (Remote)\n-\n-- (uint32_t)getRemoteLayerIdForServer:(NSString*)serverName\n-{\n-    GlassLayer3D *view = (GlassLayer3D*)[self layer];\n-    return [view getRemoteLayerIdForServer:serverName];\n-}\n-\n-- (void)hostRemoteLayerId:(uint32_t)layerId\n-{\n-    GlassLayer3D *view = (GlassLayer3D*)[self layer];\n-    [view hostRemoteLayerId:layerId];\n-}\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView3D+Remote.m","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -42,1 +42,0 @@\n-#import \"GlassNSEvent.h\"\n@@ -692,10 +691,0 @@\n-    \/\/ Short circuit here: If this is a synthetic key-typed from a text event\n-    \/\/ post it and return.\n-    if ([theEvent isKindOfClass:[GlassNSEvent class]]) {\n-        if ([(GlassNSEvent *)theEvent isSyntheticKeyTyped]) {\n-            SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_TYPED);\n-            (*env)->DeleteLocalRef(env, jKeyChars);\n-            return;\n-        }\n-    }\n-\n@@ -710,10 +699,0 @@\n-        \/\/ In the applet case, FireFox always sends a text input event after every\n-        \/\/ key-pressed, which gets turned into a TYPED event for simple key strokes.\n-        \/\/ The NPAPI support code will send a boolean to let us know if we need to\n-        \/\/ generate the TYPED, or if we should expect the input method support to do it.\n-        BOOL sendKeyTyped = YES;\n-\n-        if ([theEvent isKindOfClass:[GlassNSEvent class]]) {\n-            sendKeyTyped = [(GlassNSEvent *)theEvent needsKeyTyped];\n-        }\n-\n@@ -722,14 +701,4 @@\n-        if (sendKeyTyped) {\n-            if (jKeyCode < com_sun_glass_events_KeyEvent_VK_PAGE_UP ||\n-                jKeyCode > com_sun_glass_events_KeyEvent_VK_DOWN)\n-            {\n-                SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_TYPED);\n-            }\n-\n-            \/\/ Quirk in Firefox: If we have to generate a key-typed and this\n-            \/\/ event is a repeat we will also need to generate a fake RELEASE event\n-            \/\/ because we won't see a key-release.\n-            if ([theEvent isARepeat] &&\n-                [[self->nsView window] isKindOfClass:[GlassEmbeddedWindow class]]) {\n-                SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_RELEASE);\n-            }\n+        if (jKeyCode < com_sun_glass_events_KeyEvent_VK_PAGE_UP ||\n+            jKeyCode > com_sun_glass_events_KeyEvent_VK_DOWN)\n+        {\n+            SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_TYPED);\n@@ -1209,2 +1178,1 @@\n-    if ([window isKindOfClass:[GlassEmbeddedWindow class]] == NO\n-        && !((GlassWindow*) window)->isResizable) {\n+    if (!((GlassWindow*) window)->isResizable) {\n@@ -1237,106 +1205,3 @@\n-    if ([[self->nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == NO)\n-    {\n-        [[self->nsView window] toggleFullScreen:self];\n-        \/\/ wait until the operation is complete\n-        [GlassApplication enterFullScreenExitingLoop];\n-        return;\n-    }\n-\n-    NSScreen *screen = [[self->nsView window] screen];\n-\n-    NSRect frameInWindowScreenCoords = [self->nsView bounds];\n-    frameInWindowScreenCoords = [self->parentWindow convertRectToScreen:frameInWindowScreenCoords];\n-    NSPoint pointInPrimaryScreenCoords = frameInWindowScreenCoords.origin;\n-\n-    \/\/ Convert to local screen\n-    frameInWindowScreenCoords.origin.x -= screen.frame.origin.x;\n-    frameInWindowScreenCoords.origin.y -= screen.frame.origin.y;\n-\n-    @try\n-    {\n-        \/\/ 0. Retain the view while it's in the FS mode\n-        [self->nsView retain];\n-\n-        \/\/ 1.\n-        self->fullscreenHost = [[GlassHostView alloc] initWithFrame:[self->nsView bounds]];\n-        [self->fullscreenHost setAutoresizesSubviews:YES];\n-\n-        \/\/ 2.\n-        self->fullscreenWindow = [[GlassFullscreenWindow alloc] initWithContentRect:frameInWindowScreenCoords\n-                                                                       withHostView:self->fullscreenHost\n-                                                                           withView:self->nsView withScreen:screen\n-                                                                          withPoint:pointInPrimaryScreenCoords];\n-\n-        \/\/ 3.\n-\n-        [self->parentWindow disableFlushWindow];\n-        {\n-            \/\/ handle plugin case\n-            if ([[self->nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == YES)\n-            {\n-                GlassEmbeddedWindow *window = (GlassEmbeddedWindow*)self->parentWindow;\n-                [window setFullscreenWindow:self->fullscreenWindow];\n-            }\n-\n-            \/\/ 4.\n-            [self->nsView retain];\n-            {\n-                [self->nsView removeFromSuperviewWithoutNeedingDisplay];\n-                [self->fullscreenHost addSubview:self->nsView];\n-            }\n-            [self->nsView release];\n-\n-            if ([[self->parentWindow delegate] isKindOfClass:[GlassWindow class]] == YES)\n-            {\n-                GlassWindow *window = (GlassWindow*)[self->parentWindow delegate];\n-                [window setFullscreenWindow:self->fullscreenWindow];\n-            }\n-\n-            \/\/ 5.\n-            [self->fullscreenWindow setInitialFirstResponder:self->nsView];\n-            [self->fullscreenWindow makeFirstResponder:self->nsView];\n-\n-            \/\/ This trick allows an applet to display a focused window. This is harmless otherwise.\n-            \/\/ If we don't do this, we end up with a literally empty full screen background and no content shown whatsoever.\n-            [[NSRunningApplication currentApplication] activateWithOptions:(NSApplicationActivateIgnoringOtherApps | NSApplicationActivateAllWindows)];\n-\n-            [self->fullscreenWindow makeKeyAndOrderFront:self->nsView];\n-            [self->fullscreenWindow orderFrontRegardless];\n-            [self->fullscreenWindow makeMainWindow];\n-        }\n-\n-        \/\/ 6.\n-\n-        NSRect screenFrame = [screen frame];\n-        NSRect fullscreenFrame = [screen frame];\n-        if (keepRatio == YES)\n-        {\n-            CGFloat ratioWidth = (frameInWindowScreenCoords.size.width\/screenFrame.size.width);\n-            CGFloat ratioHeight = (frameInWindowScreenCoords.size.height\/screenFrame.size.height);\n-            if (ratioWidth > ratioHeight)\n-            {\n-                CGFloat ratio = (frameInWindowScreenCoords.size.width\/frameInWindowScreenCoords.size.height);\n-                fullscreenFrame.size.height = fullscreenFrame.size.width \/ ratio;\n-                fullscreenFrame.origin.y += (screenFrame.size.height - fullscreenFrame.size.height) \/ 2.0f;\n-            }\n-            else\n-            {\n-                CGFloat ratio = (frameInWindowScreenCoords.size.height\/frameInWindowScreenCoords.size.width);\n-                fullscreenFrame.size.width = fullscreenFrame.size.height \/ ratio;\n-                fullscreenFrame.origin.x += (screenFrame.size.width - fullscreenFrame.size.width) \/ 2.0f;\n-            }\n-        }\n-\n-        \/\/ 7.\n-        \/\/[self->fullscreenWindow setBackgroundColor:[NSColor whiteColor]]; \/\/ debug\n-        [self->fullscreenWindow setFrame:frameInWindowScreenCoords display:YES animate:animate];\n-\n-        \/\/ 8.\n-        [self->fullscreenWindow toggleFullScreen:self->fullscreenWindow];\n-    }\n-    @catch (NSException *e)\n-    {\n-        NSLog(@\"enterFullscreenWithAnimate caught exception: %@\", e);\n-    }\n-\n-    [self sendJavaFullScreenEvent:YES withNativeWidget:NO];\n+    [[self->nsView window] toggleFullScreen:self];\n+    \/\/ wait until the operation is complete\n+    [GlassApplication enterFullScreenExitingLoop];\n@@ -1374,7 +1239,0 @@\n-            \/\/ handle plugin case\n-            if ([[self->nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == YES)\n-            {\n-                GlassEmbeddedWindow *window = (GlassEmbeddedWindow*)[self->nsView window];\n-                [window setFullscreenWindow:nil];\n-            }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewDelegate.m","additions":8,"deletions":150,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-- (id)_initWithContentRect:(NSRect)contentRect styleMask:(NSUInteger)windowStyle screen:(NSScreen *)screen jwindow:(jobject)jwindow jIsChild:(jboolean)jIsChild;\n+- (id)_initWithContentRect:(NSRect)contentRect styleMask:(NSUInteger)windowStyle screen:(NSScreen *)screen jwindow:(jobject)jwindow;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow+Java.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-- (id)_initWithContentRect:(NSRect)contentRect styleMask:(NSUInteger)windowStyle screen:(NSScreen *)screen jwindow:(jobject)jwindow jIsChild:(jboolean)jIsChild\n+- (id)_initWithContentRect:(NSRect)contentRect styleMask:(NSUInteger)windowStyle screen:(NSScreen *)screen jwindow:(jobject)jwindow\n@@ -119,12 +119,5 @@\n-    if (jIsChild == JNI_FALSE) {\n-        if (windowStyle & (NSUtilityWindowMask | NSNonactivatingPanelMask)) {\n-            self->nsWindow = [[GlassWindow_Panel alloc] initWithDelegate:self\n-                                                               frameRect:contentRect\n-                                                               styleMask:windowStyle\n-                                                                  screen:screen];\n-        } else {\n-            self->nsWindow = [[GlassWindow_Normal alloc] initWithDelegate:self\n-                                                                frameRect:contentRect\n-                                                                styleMask:windowStyle\n-                                                                   screen:screen];\n-        }\n+    if (windowStyle & (NSUtilityWindowMask | NSNonactivatingPanelMask)) {\n+        self->nsWindow = [[GlassWindow_Panel alloc] initWithDelegate:self\n+                                                           frameRect:contentRect\n+                                                           styleMask:windowStyle\n+                                                              screen:screen];\n@@ -132,10 +125,4 @@\n-        GlassEmbeddedWindow *ewindow = [[GlassEmbeddedWindow alloc] initWithDelegate:self\n-                                                             frameRect:contentRect\n-                                                             styleMask:windowStyle\n-                                                                screen:screen];\n-        if (ewindow) {\n-            ewindow->parent = nil;\n-            ewindow->child = nil;\n-\n-            self->nsWindow = ewindow;\n-        }\n+        self->nsWindow = [[GlassWindow_Normal alloc] initWithDelegate:self\n+                                                            frameRect:contentRect\n+                                                            styleMask:windowStyle\n+                                                               screen:screen];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow+Java.m","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -107,25 +107,0 @@\n-\/\/ invisible window for hosting another GlassEmbeddedWindow or remote View representing plugin content\n-@interface GlassEmbeddedWindow : GlassWindow_Normal\n-{\n-@public\n-\n-    NSWindow            *fullscreenWindow;\n-\n-    BOOL                isKeyWindow;\n-\n-    GlassEmbeddedWindow *parent;\n-    GlassEmbeddedWindow *child;\n-}\n-\n-- (id)initWithDelegate:(GlassWindow*)delegate\n-             frameRect:(NSRect)rect\n-             styleMask:(NSUInteger)styleMask\n-                screen:(NSScreen*)screen;\n-\n-+ (BOOL)exists:(GlassEmbeddedWindow*)window;\n-\n-- (void)setFullscreenWindow:(NSWindow*)fsWindow;\n-\n-@end\n-\n-extern GlassEmbeddedWindow *getGlassEmbeddedWindow(JNIEnv *env, jlong jPtr);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.h","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#import \"GlassEmbeddedWindow+Overrides.h\"\n@@ -86,2 +85,0 @@\n-#define BROWSER_PARENT_ID -1L\n-\n@@ -378,82 +375,0 @@\n-@end\n-\n-#pragma mark --- GlassEmbeddedWindow\n-\n-static NSMutableArray * embeddedWindowsList = nil;\n-\n-@implementation GlassEmbeddedWindow\n-\n-- (id)initWithDelegate:(GlassWindow*)delegate\n-             frameRect:(NSRect)rect\n-             styleMask:(NSUInteger)styleMask\n-                screen:(NSScreen*)screen\n-{\n-    self = [super initWithDelegate:delegate frameRect:rect styleMask:styleMask screen:screen];\n-    if (self == nil) {\n-        return nil;\n-    }\n-\n-    if (embeddedWindowsList == nil) {\n-        embeddedWindowsList = [[NSMutableArray alloc] initWithCapacity: 4];\n-    }\n-    [embeddedWindowsList addObject:self]; \/\/ retains 'self'\n-\n-    return self;\n-}\n-\n-- (void)close\n-{\n-    if (embeddedWindowsList) {\n-        [embeddedWindowsList removeObject:self]; \/\/ releases 'self'\n-        if ([embeddedWindowsList count] == 0) {\n-            [embeddedWindowsList release];\n-            embeddedWindowsList = nil;\n-        }\n-    }\n-    [super close];\n-}\n-\n-+ (BOOL)exists:(GlassEmbeddedWindow*)window\n-{\n-    if (embeddedWindowsList && window) {\n-        return [embeddedWindowsList indexOfObjectIdenticalTo:window] != NSNotFound;\n-    }\n-    return NO;\n-}\n-\n-- (void)setFullscreenWindow:(NSWindow*)fsWindow\n-{\n-    if (self->parent != nil)\n-    {\n-        BOOL fullscreen = (fsWindow != nil);\n-\n-        CALayer *layer = [self->gWindow->view layer];\n-        if ([layer isKindOfClass:[GlassLayer3D class]] == YES)\n-        {\n-            [((CAOpenGLLayer*)layer) setAsynchronous:fullscreen];\n-\n-            layer = [self->parent->gWindow->view layer];\n-            if ([layer isKindOfClass:[GlassLayer3D class]] == YES)\n-            {\n-                [((CAOpenGLLayer*)layer) setAsynchronous:!fullscreen];\n-            }\n-        }\n-\n-        self->fullscreenWindow = fsWindow;\n-    }\n-}\n-\n-- (void)sendEvent:(NSEvent *)theEvent\n-{\n-    BOOL fullscreen = (self->fullscreenWindow != nil);\n-    if (fullscreen == NO)\n-    {\n-        [super sendEvent:theEvent];\n-    }\n-    else\n-    {\n-        [self->fullscreenWindow sendEvent:theEvent];\n-    }\n-}\n-\n-\n@@ -465,1 +380,1 @@\n-static jlong _createWindowCommonDo(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask, jboolean jIsChild)\n+static jlong _createWindowCommonDo(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask)\n@@ -520,1 +435,1 @@\n-        window = [[GlassWindow alloc] _initWithContentRect:NSMakeRect(x, y, w, h) styleMask:styleMask screen:screen jwindow:jWindow jIsChild:jIsChild];\n+        window = [[GlassWindow alloc] _initWithContentRect:NSMakeRect(x, y, w, h) styleMask:styleMask screen:screen jwindow:jWindow];\n@@ -535,1 +450,1 @@\n-        if (jIsChild == JNI_FALSE)\n+        if (jOwnerPtr != 0L)\n@@ -537,15 +452,1 @@\n-            if (jOwnerPtr != 0L)\n-            {\n-                window->owner = getGlassWindow(env, jOwnerPtr)->nsWindow; \/\/ not retained (use weak reference?)\n-            }\n-        }\n-        else\n-        {\n-            if ((jOwnerPtr != 0L) && (jOwnerPtr != BROWSER_PARENT_ID))\n-            {\n-                GlassEmbeddedWindow *parent = getGlassEmbeddedWindow(env, jOwnerPtr);\n-                GlassEmbeddedWindow *ewindow = (GlassEmbeddedWindow*)window->nsWindow;\n-                parent->child = ewindow; \/\/ not retained (use weak reference?)\n-\n-                ewindow->parent = parent; \/\/ not retained (use weak reference?)\n-            }\n+            window->owner = getGlassWindow(env, jOwnerPtr)->nsWindow; \/\/ not retained (use weak reference?)\n@@ -590,16 +491,0 @@\n-        if (jIsChild == JNI_TRUE && jOwnerPtr != 0L && jOwnerPtr != BROWSER_PARENT_ID\n-            && [window->nsWindow isKindOfClass:[GlassEmbeddedWindow class]])\n-        {\n-            GlassEmbeddedWindow* parent = ((GlassEmbeddedWindow*)window->nsWindow)->parent;\n-            if ([GlassEmbeddedWindow exists:parent])\n-            {\n-                window->isLocationAssigned = YES;\n-                NSScreen *pscreen = [[NSScreen screens] objectAtIndex:0];\n-                NSRect screenFrame = pscreen.frame;\n-                NSRect frameRect = parent.frame;\n-                int invy = (int)round(screenFrame.size.height - frameRect.size.height - frameRect.origin.y);\n-                [window _setBounds:(int)round(frameRect.origin.x)\n-                                 y:invy\n-                              xSet:YES ySet:YES w:0 h:0 cw:0 ch:0];\n-            }\n-        }\n@@ -615,1 +500,1 @@\n-(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask, jboolean jIsChild)\n+(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask)\n@@ -625,1 +510,1 @@\n-        value = _createWindowCommonDo(env, jWindowRef, jOwnerPtr, jScreenPtr, jStyleMask, jIsChild);\n+        value = _createWindowCommonDo(env, jWindowRef, jOwnerPtr, jScreenPtr, jStyleMask);\n@@ -748,32 +633,1 @@\n-    return _createWindowCommon(env, jWindow, jOwnerPtr, jScreenPtr, jStyleMask, JNI_FALSE);\n-}\n-\n-\/*\n- * Class:     com_sun_glass_ui_mac_MacWindow\n- * Method:    _createChildWindow\n- * Signature: (J)J\n- *\/\n-JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_mac_MacWindow__1createChildWindow\n-(JNIEnv *env, jobject jWindow, jlong jOwnerPtr)\n-{\n-    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1createChildWindow\");\n-    LOG(\"   owner: %p\", jOwnerPtr);\n-\n-    jlong jScreenPtr = 0L;\n-    jint jStyleMask = NSBorderlessWindowMask;\n-    if (jOwnerPtr == BROWSER_PARENT_ID)\n-    {\n-        LOG(\"       case PARENT (PLUGIN)\");\n-        \/\/ special case: embedded window for plugin (the container which will hold the child window)\n-    }\n-    else\n-    {\n-        LOG(\"       case CHILD (EMBEDDED)\");\n-        \/\/ special case: embedded window for plugin (the actual plugin window with remote layer)\n-        \/\/ jOwnerPtr must be a valid GlassEmbeddedWindow instance\n-        if (![GlassEmbeddedWindow exists:(GlassEmbeddedWindow*)jlong_to_ptr(jOwnerPtr)]) {\n-            return (jlong)0;\n-        }\n-    }\n-\n-    return _createWindowCommon(env, jWindow, jOwnerPtr, jScreenPtr, jStyleMask, JNI_TRUE);\n+    return _createWindowCommon(env, jWindow, jOwnerPtr, jScreenPtr, jStyleMask);\n@@ -1592,55 +1446,0 @@\n-\n-\/*\n- * Class:     com_sun_glass_ui_mac_MacWindow\n- * Method:    _getEmbeddedX\n- * Signature: (J)I\n- *\/\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedX\n-(JNIEnv *env, jobject jWindow, jlong jPtr)\n-{\n-    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedX\");\n-    if (!jPtr) return 0;\n-\n-    jint x = 0;\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);\n-        x = (int)round([window frame].origin.x);\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-\n-    return x;\n-}\n-\n-\/*\n- * Class:     com_sun_glass_ui_mac_MacWindow\n- * Method:    _getEmbeddedY\n- * Signature: (J)I\n- *\/\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedY\n-(JNIEnv *env, jobject jWindow, jlong jPtr)\n-{\n-    LOG(\"Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedY\");\n-    if (!jPtr) return 0;\n-\n-    jint y = 0;\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);\n-        NSRect frameRect = [window frame];\n-\n-        \/\/ flip y coordinate\n-        NSScreen *screen = [[NSScreen screens] objectAtIndex:0];\n-        NSRect screenFrame = screen.frame;\n-        y = (int)round(screenFrame.size.height - frameRect.size.height - frameRect.origin.y);\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-\n-    return y;\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.m","additions":7,"deletions":208,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef RemoteLayerSupport_h\n-#define RemoteLayerSupport_h\n-\n-#import <Foundation\/Foundation.h>\n-#import <objc\/runtime.h>            \/\/ neeeded for objc_getClass\n-\n-mach_port_t RemoteLayerStartServer(void);\n-NSString* RemoteLayerGetServerName(mach_port_t serverPort);\n-mach_port_t RemoteLayerGetServerPort(NSString *theServerName);\n-id RemoteLayerGetRemoteFromLocal(mach_port_t renderServerPort, id localLayer);\n-uint32_t RemoteLayerGetIdForRemote(id remoteLayer);\n-void RemoteLayerHostRemoteIdInLocal(uint32_t remoteId, id localLayer);\n-\n-#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/RemoteLayerSupport.h","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"RemoteLayerSupport.h\"\n-\n-@interface NSObject (JRSRenderServer)\n-\n-@property(readonly) uint32_t layerID;\n-\n-- (NSObject*)createRemoteLayerBoundTo:(mach_port_t)serverPort;\n-- (void)hostRemoteLayer:(uint32_t)layerID;\n-+ (mach_port_t)startRenderServer;\n-+ (NSString *)sendRenderServer:(mach_port_t)serverPort;\n-+ (mach_port_t)recieveRenderServer:(NSString *)serverName;\n-\n-@end\n-\n-mach_port_t RemoteLayerStartServer()\n-{\n-    mach_port_t theResult = MACH_PORT_NULL;\n-    {\n-        \/\/ Use reflection here so we don't have a dependency on JRSRemoteLayer.h\n-        Class JRSRemoteLayer_class = objc_getClass(\"JRSRenderServer\");\n-        SEL startRenderServer_SEL = @selector(startRenderServer);\n-        NSMethodSignature *startRenderServer_sig = [JRSRemoteLayer_class methodSignatureForSelector:startRenderServer_SEL];\n-        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:startRenderServer_sig];\n-        [invocation setSelector:startRenderServer_SEL];\n-        [invocation setTarget:JRSRemoteLayer_class];\n-        [invocation invoke];\n-        [invocation getReturnValue:&theResult];\n-    }\n-    return theResult;\n-}\n-\n-NSString* RemoteLayerGetServerName(mach_port_t serverPort)\n-{\n-    NSString *name = nil;\n-\n-    \/\/ If there's no serverPort JRSRenderServer is handling communications with\n-    \/\/ the Safari remote CA server. We still need a name, so don't call sendRenderServer:\n-    \/\/ and instead create a placeholder name.\n-    if (serverPort) {\n-        \/\/ Use reflection here so we don't have a dependency on JRSRemoteLayer.h\n-        Class JRSRemoteLayer_class = objc_getClass(\"JRSRenderServer\");\n-        SEL sendRenderServer_SEL = @selector(sendRenderServer:);\n-        NSMethodSignature *sendRenderServer_sig = [JRSRemoteLayer_class methodSignatureForSelector:sendRenderServer_SEL];\n-        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sendRenderServer_sig];\n-        [invocation setSelector:sendRenderServer_SEL];\n-        [invocation setTarget:JRSRemoteLayer_class];\n-        [invocation setArgument:&serverPort atIndex:2];\n-        [invocation invoke];\n-        [invocation getReturnValue:&name];\n-    } else {\n-        name = [NSString stringWithFormat:@\"PlaceHolderServerName-%d\", getpid()];\n-    }\n-\n-    return name;\n-}\n-\n-mach_port_t RemoteLayerGetServerPort(NSString *serverName)\n-{\n-    mach_port_t port = MACH_PORT_NULL;\n-    {\n-        \/\/ Use reflection here so we don't have a dependency on JRSRemoteLayer.h\n-        Class JRSRemoteLayer_class = objc_getClass(\"JRSRenderServer\");\n-        SEL recieveRenderServer_SEL = @selector(recieveRenderServer:);\n-        NSMethodSignature *receiveRenderServer_sig = [JRSRemoteLayer_class methodSignatureForSelector:recieveRenderServer_SEL];\n-        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:receiveRenderServer_sig];\n-        [invocation setSelector:recieveRenderServer_SEL];\n-        [invocation setTarget:JRSRemoteLayer_class];\n-        [invocation setArgument:&serverName atIndex:2];\n-        [invocation invoke];\n-        [invocation getReturnValue:&port];\n-    }\n-    return port;\n-}\n-\n-id RemoteLayerGetRemoteFromLocal(mach_port_t serverPort, id localLayer)\n-{\n-    id remoteLayer = nil;\n-    {\n-        \/\/ Use reflection here so we don't have a dependency on JRSRemoteLayer.h\n-        \/\/ remoteLayer = [localLayer reateRemoteLayerBoundTo:(mach_port_t)serverPort];\n-        SEL createRemoteLayer_SEL = @selector(createRemoteLayerBoundTo:);\n-        NSMethodSignature *createRemoteLayer_sig = [localLayer methodSignatureForSelector:createRemoteLayer_SEL];\n-        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:createRemoteLayer_sig];\n-        [invocation setSelector:createRemoteLayer_SEL];\n-        [invocation setArgument:&serverPort atIndex:2];\n-        [invocation invokeWithTarget:localLayer];\n-        [invocation getReturnValue:&remoteLayer];\n-    }\n-    return remoteLayer;\n-}\n-\n-uint32_t RemoteLayerGetIdForRemote(id remoteLayer)\n-{\n-    uint32_t layerID = 0;\n-    {\n-        \/\/ Use reflection here so we don't have a dependency on JRSRemoteLayer.h\n-        \/\/ layerID = [remoteLayer layerID];\n-        SEL layerID_SEL = @selector(layerID);\n-        NSMethodSignature *layerID_sig = [remoteLayer methodSignatureForSelector:layerID_SEL];\n-        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:layerID_sig];\n-        [invocation setSelector:layerID_SEL];\n-        [invocation invokeWithTarget:remoteLayer];\n-        [invocation getReturnValue:&layerID];\n-\n-        \/\/ what is the purpose of these 2 calls below?\n-        CFRetain(remoteLayer);\n-        [remoteLayer release]; \/\/ GC\n-    }\n-    return layerID;\n-}\n-\n-void RemoteLayerHostRemoteIdInLocal(uint32_t remoteId, id localLayer)\n-{\n-    \/\/ Use reflection here so we don't have a dependency on JRSRemoteLayer.h\n-    \/\/ - (void) hostRemoteLayer:(uint32_t)layerID;\n-    SEL createRemoteLayer_SEL = @selector(hostRemoteLayer:);\n-    NSMethodSignature *hostRemoteLayer_sig = [localLayer methodSignatureForSelector:createRemoteLayer_SEL];\n-    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:hostRemoteLayer_sig];\n-    [invocation setSelector:createRemoteLayer_SEL];\n-    [invocation setArgument:&remoteId atIndex:2];\n-    [invocation invokeWithTarget:localLayer];\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/RemoteLayerSupport.m","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -50,2 +50,0 @@\n-unsigned int GlassApplication::sm_mouseLLHookCounter = 0;\n-HHOOK GlassApplication::sm_hMouseLLHook = NULL;\n@@ -204,45 +202,0 @@\n-LRESULT CALLBACK GlassApplication::MouseLLHook(int nCode, WPARAM wParam, LPARAM lParam)\n-{\n-    if (nCode >= 0) {\n-        switch (wParam) {\n-            case WM_LBUTTONDOWN:\n-            case WM_RBUTTONDOWN:\n-            case WM_MBUTTONDOWN:\n-            case WM_NCLBUTTONDOWN:\n-            case WM_NCMBUTTONDOWN:\n-            case WM_NCRBUTTONDOWN:\n-            case WM_NCXBUTTONDOWN:\n-            case WM_MOUSEACTIVATE:\n-                {\n-                    POINT pt = ((MSLLHOOKSTRUCT*)lParam)->pt;\n-                    HWND hwnd = ::GetAncestor(::WindowFromPoint(pt), GA_ROOT);\n-\n-                    BaseWnd *pWindow = BaseWnd::FromHandle(hwnd);\n-                    if (!pWindow) {\n-                        \/\/ A click on a non-Glass, supposedly browser window\n-                        GlassWindow::ResetGrab();\n-                    }\n-                }\n-                break;\n-        }\n-    }\n-    return ::CallNextHookEx(GlassApplication::sm_hMouseLLHook, nCode, wParam, lParam);\n-}\n-\n-void GlassApplication::InstallMouseLLHook()\n-{\n-    if (++GlassApplication::sm_mouseLLHookCounter == 1) {\n-        GlassApplication::sm_hMouseLLHook =\n-            ::SetWindowsHookEx(WH_MOUSE_LL,\n-                    (HOOKPROC)GlassApplication::MouseLLHook,\n-                    GlassApplication::GetHInstance(), 0);\n-    }\n-}\n-\n-void GlassApplication::UninstallMouseLLHook()\n-{\n-    if (--GlassApplication::sm_mouseLLHookCounter == 0) {\n-        ::UnhookWindowsHookEx(GlassApplication::sm_hMouseLLHook);\n-    }\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassApplication.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -99,4 +99,0 @@\n-    \/* Maintains a counter. Must be balanced with UninstallMouseLLHook. *\/\n-    static void InstallMouseLLHook();\n-    static void UninstallMouseLLHook();\n-\n@@ -139,3 +135,0 @@\n-    static unsigned int sm_mouseLLHookCounter;\n-    static HHOOK sm_hMouseLLHook;\n-    static LRESULT CALLBACK MouseLLHook(int nCode, WPARAM wParam, LPARAM lParam);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassApplication.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    if (pWindow && !pWindow->IsChild()) {\n+    if (pWindow) {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassView.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-GlassWindow::GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, bool isChild, HWND parentOrOwner)\n+GlassWindow::GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, HWND parentOrOwner)\n@@ -80,1 +80,0 @@\n-    m_parent(isChild ? parentOrOwner : NULL),\n@@ -102,3 +101,0 @@\n-    if (isChild) {\n-        GlassApplication::InstallMouseLLHook();\n-    }\n@@ -117,4 +113,0 @@\n-    if (IsChild()) {\n-        GlassApplication::UninstallMouseLLHook();\n-    }\n-\n@@ -443,5 +435,0 @@\n-                if (IsChild()) {\n-                    \/\/ Synthesize the event\n-                    HandleActivateEvent(m_focusEvent ? m_focusEvent : com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n-                    m_focusEvent = 0;\n-                }\n@@ -453,4 +440,0 @@\n-                if (IsChild()) {\n-                    \/\/ Synthesize the event\n-                    HandleActivateEvent(com_sun_glass_events_WindowEvent_FOCUS_LOST);\n-                }\n@@ -507,3 +490,0 @@\n-            if (IsChild() && !IsFocused() && IsFocusable()) {\n-                RequestFocus(com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n-            }\n@@ -982,28 +962,3 @@\n-    if (!IsChild()) {\n-        ASSERT(event == com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n-        \/\/ The event will be delivered as a part of WM_ACTIVATE message handling\n-        return ::SetForegroundWindow(GetHWND()) != FALSE;\n-    }\n-\n-    if (event == com_sun_glass_events_WindowEvent_FOCUS_LOST) {\n-        if (IsFocused()) {\n-            ::SetFocus(NULL);\n-        }\n-\n-        return true;\n-    }\n-\n-    \/\/ First try to activate the toplevel window\n-    HWND toplevel = ::GetAncestor(GetHWND(), GA_ROOT);\n-    if (::GetForegroundWindow() != toplevel && !::SetForegroundWindow(toplevel)) {\n-        \/\/ We're unable to bring our top-level window to foreground.\n-        \/\/ But since it anyway becomes active, we (or the plugin) won't receive\n-        \/\/ any subsequent notifications. So let's pretend we got the focus -\n-        \/\/IGNORE: return false;\n-        \/\/We'll anyway get a reasonable response from the ::SetFocus() later\n-    }\n-\n-    m_focusEvent = event; \/\/ reset upon WM_SETFOCUS\n-\n-    \/\/ If we request focus from 'nowhere', the SetFocus may still return NULL I guess\n-    return ::SetFocus(GetHWND()) != NULL || ::GetLastError() == 0;\n+    ASSERT(event == com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n+    \/\/ The event will be delivered as a part of WM_ACTIVATE message handling\n+    return ::SetForegroundWindow(GetHWND()) != FALSE;\n@@ -1069,3 +1024,0 @@\n-    if (IsChild()) {\n-        return FALSE;\n-    }\n@@ -1116,1 +1068,1 @@\n-    if (IsChild() || !IsInFullScreenMode()) {\n+    if (!IsInFullScreenMode()) {\n@@ -1280,1 +1232,0 @@\n-                false,\n@@ -1313,49 +1264,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_win_WinWindow\n- * Method:    _createChildWindow\n- * Signature: (J)J\n- *\/\n-JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_win_WinWindow__1createChildWindow\n-    (JNIEnv *env, jobject jThis, jlong parentPtr)\n-{\n-    ENTER_MAIN_THREAD_AND_RETURN(jlong)\n-    {\n-        \/\/ Check that the 'parent' isn't a garbage value\n-        if (!::IsWindow((HWND)parent)) {\n-            return (jlong)0;\n-        }\n-\n-        DWORD dwStyle;\n-        DWORD dwExStyle;\n-\n-        dwStyle = WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_CHILD;\n-        dwExStyle = WS_EX_NOINHERITLAYOUT;\n-\n-        GlassWindow *pWindow =\n-            new GlassWindow(jThis, false, false, false, true, parent);\n-\n-        HWND hWnd = pWindow->Create(dwStyle, dwExStyle, NULL, parent);\n-\n-        if (!hWnd) {\n-            delete pWindow;\n-        } else {\n-            HMONITOR toMonitor = ::MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);\n-            env->CallVoidMethod(jThis, midNotifyMoveToAnotherScreen,\n-                                GlassScreen::GetJavaMonitor(env, toMonitor));\n-            CheckAndClearException(env);\n-            pWindow->SetMonitor(toMonitor);\n-        }\n-\n-        return (jlong)hWnd;\n-    }\n-    DECL_jobject(jThis);\n-    JNIEnv *env;\n-    HWND parent;\n-    LEAVE_MAIN_THREAD;\n-\n-    ARG(jThis) = jThis;\n-    ARG(env) = env;\n-    ARG(parent) = (HWND)parentPtr;\n-\n-    return PERFORM_AND_RETURN();\n-}\n@@ -1974,42 +1876,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_win_WinWindow\n- * Method:    _getEmbeddedX\n- * Signature: (J)I\n- *\/\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinWindow__1getEmbeddedX\n-    (JNIEnv *env, jobject jThis, jlong ptr)\n-{\n-    ENTER_MAIN_THREAD_AND_RETURN(jint)\n-    {\n-        GlassWindow *pWindow = GlassWindow::FromHandle(hWnd);\n-        HWND delegateHWnd = pWindow ? pWindow->GetDelegateWindow() : 0;\n-        RECT rect = {0};\n-        ::MapWindowPoints(delegateHWnd ? delegateHWnd : hWnd, (HWND)NULL, (LPPOINT)&rect, (sizeof(RECT)\/sizeof(POINT)));\n-        return rect.left;\n-    }\n-    LEAVE_MAIN_THREAD_WITH_hWnd;\n-\n-    return PERFORM_AND_RETURN();\n-}\n-\n-\/*\n- * Class:     com_sun_glass_ui_win_WinWindow\n- * Method:    _getEmbeddedY\n- * Signature: (J)I\n- *\/\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinWindow__1getEmbeddedY\n-    (JNIEnv *env, jobject jThis, jlong ptr)\n-{\n-    ENTER_MAIN_THREAD_AND_RETURN(jint)\n-    {\n-        GlassWindow *pWindow = GlassWindow::FromHandle(hWnd);\n-        HWND delegateHWnd = pWindow ? pWindow->GetDelegateWindow() : 0;\n-        RECT rect = {0};\n-        ::MapWindowPoints(delegateHWnd ? delegateHWnd : hWnd, (HWND)NULL, (LPPOINT)&rect, (sizeof(RECT)\/sizeof(POINT)));\n-        return rect.top;\n-    }\n-    LEAVE_MAIN_THREAD_WITH_hWnd;\n-\n-    return PERFORM_AND_RETURN();\n-}\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":5,"deletions":145,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, bool isChild, HWND parentOrOwner);\n+    GlassWindow(jobject jrefThis, bool isTransparent, bool isDecorated, bool isUnified, HWND parentOrOwner);\n@@ -100,2 +100,0 @@\n-    bool IsChild() { return m_parent != NULL; }\n-\n@@ -149,1 +147,0 @@\n-    const HWND m_parent; \/\/ != NULL for child windows only\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,11 +138,0 @@\n-    @Override\n-    public AppletWindow createAppletWindow(long parent, String serverName) {\n-        \/\/ unsupported\n-        return null;\n-    }\n-\n-    @Override\n-    public void closeAppletWindow() {\n-        \/\/ unsupported\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubToolkit.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-        \/\/ Note that this is needed when running as an applet or a web start app.\n+        \/\/ Note that this is needed when running with a security manager\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/NetworkContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                \/\/ when running as an applet or a web start app.\n+                \/\/ when running with a security manager\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/URLs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}