{"files":[{"patch":"@@ -624,0 +624,1 @@\n+    Modules\/websockets\/WebSocketChannel.h\n@@ -2214,0 +2215,2 @@\n+    platform\/network\/SocketStreamHandle.h\n+    platform\/network\/SocketStreamHandleClient.h\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Headers.cmake","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+#if PLATFORM(JAVA)\n+#include \"WebSocketChannel.h\"\n+#endif\n@@ -55,0 +58,1 @@\n+#if !PLATFORM(JAVA)\n@@ -56,0 +60,2 @@\n+#endif\n+    return WebSocketChannel::create(document, client, provider);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/websockets\/ThreadableWebSocketChannel.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -281,8 +281,1 @@\n-#if PLATFORM(JAVA)\n-    if (!m_channel) {\n-        String message;\n-        message = \"WebSocket connection error invalid WebSocketChannel\"_s;\n-        context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, message);\n-        return {};\n-    }\n-#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/websockets\/WebSocket.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#if PLATFORM(JAVA)\n@@ -32,0 +33,1 @@\n+#include \"config.h\"\n@@ -34,0 +36,18 @@\n+#include \"Blob.h\"\n+#include \"CookieJar.h\"\n+#include \"Document.h\"\n+#include \"DocumentLoader.h\"\n+#include \"ExceptionCode.h\"\n+#include \"FileReaderLoader.h\"\n+#include \"Frame.h\"\n+#include \"FrameDestructionObserverInlines.h\"\n+#include \"FrameLoader.h\"\n+#include \"InspectorInstrumentation.h\"\n+#include \"Logging.h\"\n+#include \"NetworkingContext.h\"\n+#include \"Page.h\"\n+#include \"ProgressTracker.h\"\n+#include \"ResourceRequest.h\"\n+#include \"ScriptExecutionContext.h\"\n+#include \"SocketProvider.h\"\n+#include \"SocketStreamError.h\"\n@@ -35,1 +55,3 @@\n-#include \"SocketStreamHandleImpl.h\"\n+#include \"UserContentProvider.h\"\n+#include \"WebSocketChannelClient.h\"\n+#include \"WebSocketHandshake.h\"\n@@ -37,21 +59,0 @@\n-#include <WebCore\/Blob.h>\n-#include <WebCore\/CookieJar.h>\n-#include <WebCore\/Document.h>\n-#include <WebCore\/DocumentLoader.h>\n-#include <WebCore\/ExceptionCode.h>\n-#include <WebCore\/FileReaderLoader.h>\n-#include <WebCore\/FrameDestructionObserverInlines.h>\n-#include <WebCore\/FrameLoader.h>\n-#include <WebCore\/LegacyWebSocketInspectorInstrumentation.h>\n-#include <WebCore\/LocalFrame.h>\n-#include <WebCore\/Logging.h>\n-#include <WebCore\/NetworkingContext.h>\n-#include <WebCore\/Page.h>\n-#include <WebCore\/ProgressTracker.h>\n-#include <WebCore\/ResourceRequest.h>\n-#include <WebCore\/ScriptExecutionContext.h>\n-#include <WebCore\/SocketProvider.h>\n-#include <WebCore\/SocketStreamError.h>\n-#include <WebCore\/UserContentProvider.h>\n-#include <WebCore\/WebSocketChannelClient.h>\n-#include <WebCore\/WebSocketHandshake.h>\n@@ -108,1 +109,1 @@\n-        LegacyWebSocketInspectorInstrumentation::didCreateWebSocket(m_document.get(), m_progressIdentifier, validatedURL->url);\n+        InspectorInstrumentation::didCreateWebSocket(m_document.get(), m_progressIdentifier, validatedURL->url);\n@@ -117,2 +118,3 @@\n-    bool shouldAcceptInsecureCertificates = false;\n-    m_handle = SocketStreamHandleImpl::create(m_handshake->url(), *this, page->sessionID(), partition, { }, frame->loader().networkingContext(), shouldAcceptInsecureCertificates);\n+    \/\/ m_handle = m_socketProvider->createSocketStreamHandle(m_handshake->url(), *this, identifier(), page->sessionID(), partition, frame->loader().networkingContext());\n+    \/\/ JDK-8094172: JavaFX needs Page instance\n+    m_handle = m_socketProvider->createSocketStreamHandle(m_handshake->url(), *this, identifier(), page->sessionID(), page, partition, frame->loader().networkingContext());\n@@ -224,1 +226,1 @@\n-        LegacyWebSocketInspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_progressIdentifier, reason);\n+        InspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_progressIdentifier, reason);\n@@ -255,1 +257,1 @@\n-        LegacyWebSocketInspectorInstrumentation::didCloseWebSocket(m_document.get(), m_progressIdentifier);\n+        InspectorInstrumentation::didCloseWebSocket(m_document.get(), m_progressIdentifier);\n@@ -280,1 +282,1 @@\n-    if (m_progressIdentifier && UNLIKELY(LegacyWebSocketInspectorInstrumentation::hasFrontends())) {\n+    if (m_progressIdentifier && UNLIKELY(InspectorInstrumentation::hasFrontends())) {\n@@ -286,1 +288,1 @@\n-        LegacyWebSocketInspectorInstrumentation::willSendWebSocketHandshakeRequest(m_document.get(), m_progressIdentifier, m_handshake->clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));\n+        InspectorInstrumentation::willSendWebSocketHandshakeRequest(m_document.get(), m_progressIdentifier, m_handshake->clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));\n@@ -305,1 +307,1 @@\n-        LegacyWebSocketInspectorInstrumentation::didCloseWebSocket(m_document.get(), m_progressIdentifier);\n+        InspectorInstrumentation::didCloseWebSocket(m_document.get(), m_progressIdentifier);\n@@ -381,1 +383,1 @@\n-        LegacyWebSocketInspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_progressIdentifier, message);\n+        InspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_progressIdentifier, message);\n@@ -468,1 +470,1 @@\n-                LegacyWebSocketInspectorInstrumentation::didReceiveWebSocketHandshakeResponse(m_document.get(), m_progressIdentifier, m_handshake->serverHandshakeResponse());\n+                InspectorInstrumentation::didReceiveWebSocketHandshakeResponse(m_document.get(), m_progressIdentifier, m_handshake->serverHandshakeResponse());\n@@ -602,1 +604,1 @@\n-    LegacyWebSocketInspectorInstrumentation::didReceiveWebSocketFrame(m_document.get(), m_progressIdentifier, frame);\n+    InspectorInstrumentation::didReceiveWebSocketFrame(m_document.get(), m_progressIdentifier, frame);\n@@ -830,1 +832,1 @@\n-        didFail(AbortError);\n+        didFail(ExceptionCode::AbortError);\n@@ -840,1 +842,1 @@\n-    LegacyWebSocketInspectorInstrumentation::didSendWebSocketFrame(m_document.get(), m_progressIdentifier, frame);\n+    InspectorInstrumentation::didSendWebSocketFrame(m_document.get(), m_progressIdentifier, frame);\n@@ -865,0 +867,1 @@\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/websockets\/WebSocketChannel.cpp","additions":38,"deletions":35,"binary":false,"changes":73,"previous_filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebKitLegacy\/WebCoreSupport\/WebSocketChannel.cpp","status":"copied"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (C) 2011, 2012 Google Inc.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are\n+ * met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ * notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above\n+ * copyright notice, this list of conditions and the following disclaimer\n+ * in the documentation and\/or other materials provided with the\n+ * distribution.\n+ *     * Neither the name of Google Inc. nor the names of its\n+ * contributors may be used to endorse or promote products derived from\n+ * this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+#pragma once\n+#if PLATFORM(JAVA)\n+#include \"ExceptionCode.h\"\n+#include \"FileReaderLoaderClient.h\"\n+#include \"SocketStreamHandleClient.h\"\n+#include \"ThreadableWebSocketChannel.h\"\n+#include \"Timer.h\"\n+#include \"WebSocketChannelInspector.h\"\n+#include \"WebSocketDeflateFramer.h\"\n+#include \"WebSocketFrame.h\"\n+#include \"WebSocketHandshake.h\"\n+#include <wtf\/Deque.h>\n+#include <wtf\/Forward.h>\n+#include <wtf\/ObjectIdentifier.h>\n+#include <wtf\/RefCounted.h>\n+#include <wtf\/TypeCasts.h>\n+#include <wtf\/Vector.h>\n+#include <wtf\/text\/CString.h>\n+\n+namespace WebCore {\n+\n+class Blob;\n+class Document;\n+class FileReaderLoader;\n+class ResourceRequest;\n+class ResourceResponse;\n+class SocketProvider;\n+class SocketStreamHandle;\n+class SocketStreamError;\n+class WebSocketChannelClient;\n+class WebSocketChannel;\n+using WebSocketChannelIdentifier = AtomicObjectIdentifier<WebSocketChannel>;\n+\n+class WebSocketChannel final : public RefCounted<WebSocketChannel>, public SocketStreamHandleClient, public ThreadableWebSocketChannel, public FileReaderLoaderClient\n+{\n+    WTF_MAKE_FAST_ALLOCATED;\n+public:\n+    static Ref<WebSocketChannel> create(Document& document, WebSocketChannelClient& client, SocketProvider& provider) { return adoptRef(*new WebSocketChannel(document, client, provider)); }\n+    virtual ~WebSocketChannel();\n+\n+    bool send(const uint8_t* data, int length);\n+\n+    \/\/ ThreadableWebSocketChannel functions.\n+    ConnectStatus connect(const URL&, const String& protocol) final;\n+    String subprotocol() final;\n+    String extensions() final;\n+    ThreadableWebSocketChannel::SendResult send(CString&&) final;\n+    ThreadableWebSocketChannel::SendResult send(const JSC::ArrayBuffer&, unsigned byteOffset, unsigned byteLength) final;\n+    ThreadableWebSocketChannel::SendResult send(Blob&) final;\n+    unsigned bufferedAmount() const final;\n+    void close(int code, const String& reason) final; \/\/ Start closing handshake.\n+    void fail(String&& reason) final;\n+    void disconnect() final;\n+\n+    void suspend() final;\n+    void resume() final;\n+\n+    \/\/ SocketStreamHandleClient functions.\n+    void didOpenSocketStream(SocketStreamHandle&) final;\n+    void didCloseSocketStream(SocketStreamHandle&) final;\n+    void didReceiveSocketStreamData(SocketStreamHandle&, const uint8_t*, size_t) final;\n+    void didFailToReceiveSocketStreamData(SocketStreamHandle&) final;\n+    void didUpdateBufferedAmount(SocketStreamHandle&, size_t bufferedAmount) final;\n+    void didFailSocketStream(SocketStreamHandle&, const SocketStreamError&) final;\n+\n+    enum CloseEventCode {\n+        CloseEventCodeNotSpecified = -1,\n+        CloseEventCodeNormalClosure = 1000,\n+        CloseEventCodeGoingAway = 1001,\n+        CloseEventCodeProtocolError = 1002,\n+        CloseEventCodeUnsupportedData = 1003,\n+        CloseEventCodeFrameTooLarge = 1004,\n+        CloseEventCodeNoStatusRcvd = 1005,\n+        CloseEventCodeAbnormalClosure = 1006,\n+        CloseEventCodeInvalidFramePayloadData = 1007,\n+        CloseEventCodePolicyViolation = 1008,\n+        CloseEventCodeMessageTooBig = 1009,\n+        CloseEventCodeMandatoryExt = 1010,\n+        CloseEventCodeInternalError = 1011,\n+        CloseEventCodeTLSHandshake = 1015,\n+        CloseEventCodeMinimumUserDefined = 3000,\n+        CloseEventCodeMaximumUserDefined = 4999\n+    };\n+\n+    \/\/ FileReaderLoaderClient functions.\n+    void didStartLoading() override;\n+    void didReceiveData() override;\n+    void didFinishLoading() override;\n+    void didFail(ExceptionCode errorCode) override;\n+\n+    WebSocketChannelIdentifier progressIdentifier() const final { return m_progressIdentifier; }\n+    bool hasCreatedHandshake() const final { return !!m_handshake; }\n+    bool isConnected() const final { return m_handshake->mode() == WebSocketHandshake::Mode::Connected; }\n+    ResourceRequest clientHandshakeRequest(const CookieGetter&) const final;\n+    const ResourceResponse& serverHandshakeResponse() const final;\n+\n+    using RefCounted<WebSocketChannel>::ref;\n+    using RefCounted<WebSocketChannel>::deref;\n+\n+    Document* document();\n+\n+private:\n+    WEBCORE_EXPORT WebSocketChannel(Document&, WebSocketChannelClient&, SocketProvider&);\n+\n+    void refThreadableWebSocketChannel() override { ref(); }\n+    void derefThreadableWebSocketChannel() override { deref(); }\n+\n+    bool appendToBuffer(const uint8_t* data, size_t len);\n+    void skipBuffer(size_t len);\n+    bool processBuffer();\n+    void resumeTimerFired();\n+    void startClosingHandshake(int code, const String& reason);\n+    void closingTimerFired();\n+\n+    bool processFrame();\n+\n+    \/\/ It is allowed to send a Blob as a binary frame if hybi-10 protocol is in use. Sending a Blob\n+    \/\/ can be delayed because it must be read asynchronously. Other types of data (String or\n+    \/\/ ArrayBuffer) may also be blocked by preceding sending request of a Blob.\n+    \/\/\n+    \/\/ To address this situation, messages to be sent need to be stored in a queue. Whenever a new\n+    \/\/ data frame is going to be sent, it first must go to the queue. Items in the queue are processed\n+    \/\/ in the order they were put into the queue. Sending request of a Blob blocks further processing\n+    \/\/ until the Blob is completely read and sent to the socket stream.\n+    enum QueuedFrameType {\n+        QueuedFrameTypeString,\n+        QueuedFrameTypeVector,\n+        QueuedFrameTypeBlob\n+    };\n+    struct QueuedFrame {\n+        WTF_MAKE_STRUCT_FAST_ALLOCATED;\n+\n+        WebSocketFrame::OpCode opCode;\n+        QueuedFrameType frameType;\n+        \/\/ Only one of the following items is used, according to the value of frameType.\n+        CString stringData;\n+        Vector<uint8_t> vectorData;\n+        RefPtr<Blob> blobData;\n+    };\n+    void enqueueTextFrame(CString&&);\n+    void enqueueRawFrame(WebSocketFrame::OpCode, const uint8_t* data, size_t dataLength);\n+    void enqueueBlobFrame(WebSocketFrame::OpCode, Blob&);\n+\n+    void processOutgoingFrameQueue();\n+    void abortOutgoingFrameQueue();\n+\n+    enum OutgoingFrameQueueStatus {\n+        \/\/ It is allowed to put a new item into the queue.\n+        OutgoingFrameQueueOpen,\n+        \/\/ Close frame has already been put into the queue but may not have been sent yet;\n+        \/\/ m_handle->close() will be called as soon as the queue is cleared. It is not\n+        \/\/ allowed to put a new item into the queue.\n+        OutgoingFrameQueueClosing,\n+        \/\/ Close frame has been sent or the queue was aborted. It is not allowed to put\n+        \/\/ a new item to the queue.\n+        OutgoingFrameQueueClosed\n+    };\n+\n+    \/\/ If you are going to send a hybi-10 frame, you need to use the outgoing frame queue\n+    \/\/ instead of call sendFrame() directly.\n+    void sendFrame(WebSocketFrame::OpCode, const uint8_t* data, size_t dataLength, Function<void(bool)> completionHandler);\n+\n+    enum BlobLoaderStatus {\n+        BlobLoaderNotStarted,\n+        BlobLoaderStarted,\n+        BlobLoaderFinished,\n+        BlobLoaderFailed\n+    };\n+\n+    WeakPtr<Document, WeakPtrImplWithEventTargetData> m_document;\n+    WeakPtr<WebSocketChannelClient> m_client;\n+    std::unique_ptr<WebSocketHandshake> m_handshake;\n+    RefPtr<SocketStreamHandle> m_handle;\n+    Vector<uint8_t> m_buffer;\n+\n+    Timer m_resumeTimer;\n+    bool m_suspended { false };\n+    bool m_closing { false };\n+    bool m_receivedClosingHandshake { false };\n+    bool m_allowCookies { true };\n+    Timer m_closingTimer;\n+    bool m_closed { false };\n+    bool m_shouldDiscardReceivedData { false };\n+    unsigned m_unhandledBufferedAmount { 0 };\n+\n+    WebSocketChannelIdentifier m_progressIdentifier;\n+\n+    \/\/ Private members only for hybi-10 protocol.\n+    bool m_hasContinuousFrame { false };\n+    WebSocketFrame::OpCode m_continuousFrameOpCode;\n+    Vector<uint8_t> m_continuousFrameData;\n+    unsigned short m_closeEventCode { CloseEventCodeAbnormalClosure };\n+    String m_closeEventReason;\n+\n+    Deque<std::unique_ptr<QueuedFrame>> m_outgoingFrameQueue;\n+    OutgoingFrameQueueStatus m_outgoingFrameQueueStatus { OutgoingFrameQueueOpen };\n+\n+    \/\/ FIXME: Load two or more Blobs simultaneously for better performance.\n+    std::unique_ptr<FileReaderLoader> m_blobLoader;\n+    BlobLoaderStatus m_blobLoaderStatus { BlobLoaderNotStarted };\n+\n+    WebSocketDeflateFramer m_deflateFramer;\n+    Ref<SocketProvider> m_socketProvider;\n+};\n+\n+} \/\/ namespace WebCore\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/websockets\/WebSocketChannel.h","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -459,0 +459,1 @@\n+Modules\/websockets\/WebSocketChannel.cpp\n@@ -1959,0 +1960,1 @@\n+page\/SocketProvider.cpp\n@@ -2461,0 +2463,2 @@\n+platform\/network\/SocketStreamHandle.cpp\n+platform\/network\/SocketStreamHandleImpl.cpp\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Sources.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+platform\/network\/java\/SocketStreamHandleImplJava.cpp\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/SourcesJava.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1793,0 +1793,4 @@\n+               _Java_com_sun_webkit_network_SocketStreamHandle_twkDidClose\n+               _Java_com_sun_webkit_network_SocketStreamHandle_twkDidFail\n+               _Java_com_sun_webkit_network_SocketStreamHandle_twkDidOpen\n+               _Java_com_sun_webkit_network_SocketStreamHandle_twkDidReceiveData\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/mapfile-macosx","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (C) 2016 Apple Inc. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS\n+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+#include \"config.h\"\n+#if PLATFORM(JAVA)\n+#include \"SocketProvider.h\"\n+\n+#include \"SocketStreamHandleImpl.h\"\n+#include \"ThreadableWebSocketChannel.h\"\n+\n+namespace WebCore {\n+\n+#if PLATFORM(JAVA)\n+Ref<SocketStreamHandle> SocketProvider::createSocketStreamHandle(const URL& url, SocketStreamHandleClient& client, WebSocketIdentifier, PAL::SessionID sessionID, Page* page, const String& credentialPartition, const StorageSessionProvider* provider)\n+{\n+    return SocketStreamHandleImpl::create(url, client, sessionID, page, credentialPartition, { }, provider);\n+}\n+#else\n+Ref<SocketStreamHandle> SocketProvider::createSocketStreamHandle(const URL& url, SocketStreamHandleClient& client, WebSocketIdentifier, PAL::SessionID sessionID, const String& credentialPartition, const StorageSessionProvider* provider)\n+{\n+    static const auto shouldAcceptInsecureCertificates = false;\n+    return SocketStreamHandleImpl::create(url, client, sessionID, credentialPartition, { }, provider, shouldAcceptInsecureCertificates);\n+}\n+#endif\n+\n+RefPtr<ThreadableWebSocketChannel> SocketProvider::createWebSocketChannel(Document&, WebSocketChannelClient&)\n+{\n+    return nullptr;\n+}\n+\n+}\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/SocketProvider.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -28,1 +28,2 @@\n-#include <wtf\/Ref.h>\n+#include \"WebSocketIdentifier.h\"\n+#include <pal\/SessionID.h>\n@@ -30,0 +31,1 @@\n+#include <wtf\/text\/WTFString.h>\n@@ -35,0 +37,6 @@\n+class ScriptExecutionContext;\n+class StorageSessionProvider;\n+class ScriptExecutionContext;\n+class SocketStreamHandle;\n+class SocketStreamHandleClient;\n+class Page;\n@@ -39,0 +47,1 @@\n+#if !PLATFORM(JAVA)\n@@ -40,0 +49,8 @@\n+#endif\n+    static Ref<SocketProvider> create() { return adoptRef(*new SocketProvider); }\n+#if PLATFORM(JAVA)\n+    virtual Ref<SocketStreamHandle> createSocketStreamHandle(const URL&, SocketStreamHandleClient&, WebSocketIdentifier, PAL::SessionID, Page*, const String& credentialPartition, const StorageSessionProvider*);\n+#else\n+    virtual Ref<SocketStreamHandle> createSocketStreamHandle(const URL&, SocketStreamHandleClient&, WebSocketIdentifier, PAL::SessionID, const String& credentialPartition, const StorageSessionProvider*);\n+#endif\n+    virtual RefPtr<ThreadableWebSocketChannel> createWebSocketChannel(Document&, WebSocketChannelClient&);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/SocketProvider.h","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"config.h\"\n+#if PLATFORM(JAVA)\n@@ -33,0 +35,1 @@\n+#include \"CookieRequestHeaderFieldProxy.h\"\n@@ -34,1 +37,0 @@\n-#include <WebCore\/CookieRequestHeaderFieldProxy.h>\n@@ -85,0 +87,1 @@\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/SocketStreamHandle.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"previous_filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebKitLegacy\/WebCoreSupport\/SocketStreamHandle.cpp","status":"copied"},{"patch":"@@ -33,1 +33,1 @@\n-\n+#if PLATFORM(JAVA)\n@@ -75,0 +75,1 @@\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/SocketStreamHandle.h","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebKitLegacy\/WebCoreSupport\/SocketStreamHandle.h","status":"copied"},{"patch":"@@ -34,1 +34,1 @@\n-\n+#if PLATFORM(JAVA)\n@@ -53,0 +53,1 @@\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/SocketStreamHandleClient.h","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebKitLegacy\/WebCoreSupport\/SocketStreamHandleClient.h","status":"copied"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"config.h\"\n@@ -28,1 +29,1 @@\n-#if PLATFORM(COCOA)\n+#if PLATFORM(JAVA)\n@@ -30,0 +31,2 @@\n+#include \"CookieRequestHeaderFieldProxy.h\"\n+#include \"NetworkStorageSession.h\"\n@@ -31,3 +34,1 @@\n-#include <WebCore\/CookieRequestHeaderFieldProxy.h>\n-#include <WebCore\/NetworkStorageSession.h>\n-#include <WebCore\/StorageSessionProvider.h>\n+#include \"StorageSessionProvider.h\"\n@@ -190,1 +191,1 @@\n-#endif \/\/ PLATFORM(COCOA)\n+#endif \/\/ #if PLATFORM(JAVA)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/SocketStreamHandleImpl.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"previous_filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebKitLegacy\/WebCoreSupport\/SocketStreamHandleImpl.cpp","status":"copied"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import java.net.URL;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.web.WebEngine;\n+import javafx.scene.web.WebView;\n+import javafx.stage.Stage;\n+\n+public class WebSocketTestApp extends Application {\n+\n+    @Override\n+    public void start(Stage primaryStage) throws Exception {\n+\n+        VBox instructions =  new VBox(\n+                new Label(\" This test is for manual websocket callback test , please follow below steps\"),\n+                new Label(\" \"),\n+                new Label(\" STEPS:\"),\n+                new Label(\"  1. Click on RunTest button\"),\n+                new Label(\" \"),\n+                new Label(\"  2. Expected behaviour: Data received from server message should appear on webview\"));\n+\n+        Button loadButton = new Button(\"RunTest\");\n+\n+        Button passButton = new Button(\"Pass\");\n+        passButton.setOnAction(e -> {\n+            Platform.exit();\n+        });\n+\n+        Button failButton = new Button(\"Fail\");\n+        failButton.setOnAction(e -> {\n+            Platform.exit();\n+            throw new AssertionError(\"!Unable to receive message data from server, something is wrong\");\n+        });\n+\n+        WebView webView = new WebView();\n+        WebEngine webEngine = webView.getEngine();\n+\n+        loadButton.setOnAction(e -> {\n+            URL url = this.getClass().getResource(\"websocket.html\");\n+            System.out.println(url);\n+            webView.getEngine().load(url.toString());\n+        });\n+\n+        HBox buttons = new HBox(20, passButton, failButton);\n+        HBox run_test = new HBox(20, loadButton);\n+        buttons.setPadding(new Insets(10));\n+        VBox rootNode = new VBox(20, new HBox(instructions), webView, buttons);\n+        instructions.getChildren().add(run_test);\n+        rootNode.setPadding(new Insets(10));\n+        Scene scene = new Scene(rootNode, 1000, 600);\n+        primaryStage.setScene(scene);\n+        primaryStage.show();\n+    }\n+\n+    public static void main(String[] args) {\n+        launch(args);\n+    }\n+}\n","filename":"tests\/manual\/web\/WebSocketTestApp.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+<!DOCTYPE html>\n+<html>\n+    <body>\n+        <p id=\"message\"> <\/p>\n+        <script>\n+            let socket = new WebSocket(\"wss:\/\/echo.websocket.org\/\");\n+            let messageElement = document.getElementById(\"message\");\n+\n+            socket.onopen = function(e) {\n+                messageElement.textContent = \"[open] Connection established\";\n+                socket.send(\"Test WebSocket\");\n+                alert(\"[open] Connection established\");\n+            };\n+\n+            socket.onmessage = function(event) {\n+                messageElement.textContent = '[message] Data received from server!';\n+                alert('[message] Data received from server!');\n+            };\n+\n+            socket.onerror = function(event) {\n+                messageElement.textContent = \"ERROR!\";\n+                alert(\"ERROR!\");\n+            };\n+        <\/script>\n+    <\/body>\n+<\/html>\n+\n","filename":"tests\/manual\/web\/websocket.html","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"}]}