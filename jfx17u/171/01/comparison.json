{"files":[{"patch":"@@ -351,0 +351,1 @@\n+    protected abstract void _updateViewSize(long ptr);\n@@ -372,0 +373,4 @@\n+            \/\/ View size update (especially notifyResize event) has to happen\n+            \/\/ after we call view.setWindow(this); otherwise with UI scaling different than\n+            \/\/ 100% some platforms might display scenes wrong after Window was shown.\n+            _updateViewSize(this.ptr);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Window.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+    \/\/ empty - not needed by this implementation\n+    @Override\n+    protected void _updateViewSize(long ptr) {}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+    \/\/ empty - not needed by this implementation\n+    @Override\n+    protected void _updateViewSize(long ptr) {}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/ios\/IosWindow.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+    \/\/ empty - not needed by this implementation\n+    @Override protected void _updateViewSize(long ptr) {}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacWindow.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,0 +182,4 @@\n+    \/\/ empty - not needed by this implementation\n+    @Override\n+    protected void _updateViewSize(long ptr) {}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/MonocleWindow.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -252,0 +252,1 @@\n+    @Override native protected void _updateViewSize(long ptr);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinWindow.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1300,4 +1300,0 @@\n-        \/\/ The condition below may be restricted to WS_POPUP windows\n-        if (::IsWindowVisible(hWnd)) {\n-            pWindow->NotifyViewSize(hWnd);\n-        }\n@@ -1314,0 +1310,22 @@\n+\/**\n+ * Class:     com_sun_glass_ui_win_WinWindow\n+ * Method:    _updateViewSize\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinWindow__1updateViewSize\n+    (JNIEnv * env, jobject jThis, jlong ptr)\n+{\n+    ENTER_MAIN_THREAD()\n+    {\n+        GlassWindow *pWindow = GlassWindow::FromHandle(hWnd);\n+\n+        \/\/ The condition below may be restricted to WS_POPUP windows\n+        if (::IsWindowVisible(hWnd)) {\n+            pWindow->NotifyViewSize(hWnd);\n+        }\n+    }\n+    LEAVE_MAIN_THREAD_WITH_hWnd;\n+\n+    PERFORM();\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javafx.application.Platform;\n+import javafx.event.ActionEvent;\n+import javafx.geometry.Pos;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.WindowEvent;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import test.util.Util;\n+\n+public class SetSceneScalingTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Robot robot;\n+\n+    TestApp app;\n+\n+\n+    public abstract class TestApp {\n+        protected CountDownLatch shownLatch = new CountDownLatch(1);\n+        protected CountDownLatch buttonLatch;\n+        protected Stage stage;\n+        protected Button button;\n+\n+        private final int WIDTH = 400;\n+        private final int HEIGHT = 400;\n+\n+        protected void testButtonClick() {\n+            robot.mouseMove((int)(stage.getX() + stage.getScene().getX()) + (WIDTH \/ 2),\n+                            (int)(stage.getY() + stage.getScene().getY()) + (HEIGHT \/ 2));\n+            robot.mousePress(MouseButton.PRIMARY);\n+            robot.mouseRelease(MouseButton.PRIMARY);\n+        }\n+\n+        protected Scene createTestScene() {\n+            buttonLatch = new CountDownLatch(1);\n+\n+            button = new Button(\"I should be centered\");\n+            button.setOnAction((ActionEvent e) -> buttonLatch.countDown());\n+\n+            VBox box = new VBox(button);\n+            box.setAlignment(Pos.CENTER);\n+            return new Scene(box);\n+        }\n+\n+        protected abstract void test() throws Exception;\n+        protected abstract void sceneShowSetup();\n+\n+        public void runTest() throws Exception {\n+            start();\n+\n+            Assert.assertNotNull(stage);\n+            Assert.assertNotNull(button);\n+\n+            test();\n+        }\n+\n+        public void start() {\n+            Util.runAndWait(() -> {\n+                stage = new Stage(StageStyle.UNDECORATED);\n+                stage.setOnShown(e -> Platform.runLater(() -> shownLatch.countDown()));\n+                stage.setWidth(WIDTH);\n+                stage.setHeight(HEIGHT);\n+                stage.setAlwaysOnTop(true);\n+\n+                sceneShowSetup();\n+            });\n+\n+            Util.waitForLatch(shownLatch, 5, \"Stage not shown\");\n+        }\n+\n+        public void hideStage() {\n+            stage.hide();\n+        }\n+    }\n+\n+    public class TestSetSceneShowApp extends TestApp {\n+        @Override\n+        protected void test() throws Exception {\n+            Platform.runLater(() -> testButtonClick());\n+            Assert.assertTrue(buttonLatch.await(3, TimeUnit.SECONDS));\n+        }\n+\n+        @Override\n+        public void sceneShowSetup() {\n+            stage.setScene(createTestScene());\n+            stage.show();\n+        }\n+    }\n+\n+    public class TestShowSetSceneApp extends TestApp {\n+        @Override\n+        protected void test() throws Exception {\n+            Platform.runLater(() -> testButtonClick());\n+            Assert.assertTrue(buttonLatch.await(3, TimeUnit.SECONDS));\n+        }\n+\n+        @Override\n+        public void sceneShowSetup() {\n+            stage.show();\n+            stage.setScene(createTestScene());\n+        }\n+    }\n+\n+    public class TestSecondSetSceneApp extends TestApp {\n+        @Override\n+        protected void test() throws Exception {\n+            \/\/ Test that everything is okay for start\n+            Platform.runLater(() -> testButtonClick());\n+            Assert.assertTrue(buttonLatch.await(3, TimeUnit.SECONDS));\n+\n+            \/\/ Recreate scene and set it\n+            Util.runAndWait(() -> stage.setScene(createTestScene()));\n+\n+            \/\/ retest - if DPI scaling is mishandled the button should\n+            \/\/ NOT be where it was (and thus, the test fails)\n+            Platform.runLater(() -> testButtonClick());\n+            Assert.assertTrue(buttonLatch.await(3, TimeUnit.SECONDS));\n+        }\n+\n+        @Override\n+        public void sceneShowSetup() {\n+            stage.setScene(createTestScene());\n+            stage.show();\n+        }\n+    }\n+\n+\n+    @BeforeClass\n+    public static void initFX() {\n+        Platform.setImplicitExit(false);\n+        Util.startup(startupLatch, startupLatch::countDown);\n+\n+        Util.runAndWait(() -> robot = new Robot());\n+    }\n+\n+    @After\n+    public void cleanupTest() {\n+        if (app != null) {\n+            Platform.runLater(() -> app.hideStage());\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void teardownFX() {\n+        Util.shutdown();\n+    }\n+\n+\n+    @Test\n+    public void testSetSceneAndShow() throws Exception {\n+        app = new TestSetSceneShowApp();\n+        app.runTest();\n+    }\n+\n+    @Test\n+    public void testShowAndSetScene() throws Exception {\n+        app = new TestShowSetSceneApp();\n+        app.runTest();\n+    }\n+\n+    @Test\n+    public void testSecondSetScene() throws Exception {\n+        app = new TestSecondSetSceneApp();\n+        app.runTest();\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/SetSceneScalingTest.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -40,0 +40,2 @@\n+\n+import javafx.application.Application;\n@@ -41,1 +43,2 @@\n-import junit.framework.AssertionFailedError;\n+import javafx.stage.Stage;\n+\n@@ -44,0 +47,2 @@\n+import junit.framework.AssertionFailedError;\n+\n@@ -48,2 +53,3 @@\n-\n-    \/\/ Test timeout value in milliseconds\n+    \/** Default startup timeout value in seconds *\/\n+    public static final int STARTUP_TIMEOUT = 15;\n+    \/** Test timeout value in milliseconds *\/\n@@ -297,0 +303,96 @@\n+\n+    \/**\n+     * Launches an FX application, at the same time ensuring that it has been\n+     * actually launched within {@link #STARTUP_TIMEOUT} (15 seconds).\n+     * <p>\n+     * The application being started must call {@link CountdownLatch#countDown()} once to signal\n+     * its successful start (for example, by setting a handler for {@link javafx.stage.WindowEvent.WINDOW_SHOWN} event\n+     * on its primary Stage).\n+     *\n+     * @param startupLatch - a latch used to communicate successful start of the application\n+     * @param applicationClass - application to launch\n+     * @param args - command line arguments\n+     *\/\n+    public static <T extends Application> void launch (\n+            CountDownLatch startupLatch,\n+            Class<T> applicationClass,\n+            String... args) {\n+        launch(startupLatch, STARTUP_TIMEOUT, applicationClass, args);\n+    }\n+\n+    \/**\n+     * Launches an FX application, at the same time ensuring that it has been\n+     * actually launched within the specified time.\n+     * <p>\n+     * The application being started must call {@link java.util.concurrent.CountdownLatch#countDown()} once to signal\n+     * its successful start (for example, by setting a handler for {@link javafx.stage.WindowEvent.WINDOW_SHOWN} event\n+     * on its primary Stage).\n+     *\n+     * @param startupLatch - a latch used to communicate successful start of the application\n+     * @param timeoutSeconds - timeout in seconds after which the test fails\n+     * @param applicationClass - application to launch\n+     * @param args - command line arguments\n+     *\/\n+    public static <T extends Application> void launch (\n+            CountDownLatch startupLatch,\n+            int timeoutSeconds,\n+            Class<T> applicationClass,\n+            String... args) {\n+\n+        new Thread(() -> {\n+            Application.launch(applicationClass, args);\n+        }).start();\n+\n+        String msg = \"Failed to launch FX application \" + applicationClass + \" within \" + timeoutSeconds + \" sec.\";\n+        try {\n+            Assert.assertTrue(msg, startupLatch.await(timeoutSeconds, TimeUnit.SECONDS));\n+        } catch (InterruptedException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Starts the JavaFX runtime, invoking the specified Runnable on the JavaFX application thread.\n+     * This Runnable must call {@link java.util.concurrent.CountDownLatch#countDown()} once to signal\n+     * its successful start, otherwise an exception will be thrown when no such signal is received\n+     * within {@link #STARTUP_TIMEOUT} (15 seconds).\n+     *\n+     * @param startupLatch - a latch used to communicate successful start of the application\n+     * @param r - code to invoke on the application thread.\n+     *\/\n+    public static void startup(CountDownLatch startupLatch, Runnable r) {\n+        Platform.startup(r);\n+        try {\n+            String msg = \"Timeout waiting for FX runtime to start\";\n+            Assert.assertTrue(msg, startupLatch.await(STARTUP_TIMEOUT, TimeUnit.SECONDS));\n+        } catch (InterruptedException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    \/**\n+     * This synchronous method first hides all the specified stages (ignoring any\n+     * null Stages) in the platform thread, then calls {@link Platform.exit()}.\n+     *\/\n+    public static void shutdown(Stage... stages) {\n+        runAndWait(() -> {\n+            for (Stage s : stages) {\n+                if (s != null) {\n+                    s.hide();\n+                }\n+            }\n+            Platform.exit();\n+        });\n+    }\n+\n+    \/**\n+     * Calls CountDownLatch.await() with the specified timeout (in seconds).\n+     * Throws an exception if await() returns false or the process gets interrupted.\n+     *\/\n+    public static void waitForLatch(CountDownLatch latch, int seconds, String msg) {\n+        try {\n+            Assert.assertTrue(\"Timeout: \" + msg, latch.await(seconds, TimeUnit.SECONDS));\n+        } catch (InterruptedException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n","filename":"tests\/system\/src\/test\/java\/test\/util\/Util.java","additions":105,"deletions":3,"binary":false,"changes":108,"status":"modified"}]}