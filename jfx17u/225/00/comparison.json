{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## GNU Glib v2.78.1\n+## GNU Glib v2.80.4\n@@ -6,1 +6,1 @@\n-You are receiving a copy of GNU Glib, Version: 2.78.1 in either source or\n+You are receiving a copy of GNU Glib, Version: 2.80.4 in either source or\n@@ -8,1 +8,1 @@\n-Oracle license do NOT apply to the GNU Glib, Version: 2.78.1; it is\n+Oracle license do NOT apply to the GNU Glib, Version: 2.80.4; it is\n@@ -42,2 +42,2 @@\n-Copyright 2018  Emmanuele Bassi\n-Copyright (C) 2000 Sebastian Wilhelmi; University of Karlsruhe\n+Copyright (C) 2018  Emmanuele Bassi\n+Copyright (C) 1998-2001 Sebastian Wilhelmi; University of Karlsruhe\n@@ -48,2 +48,2 @@\n-Copyright (C) 2011 Collabora Ltd.\n-Copyright (C) 1998-2012 Red Hat, Inc.\n+Copyright (C) 2009-2024 Collabora Ltd.\n+Copyright (C) 1998-2022 Red Hat, Inc.\n@@ -51,2 +51,3 @@\n-Copyright Red Hat Inc., 2000\n-Copyright 2020 Frederic Martinsons\n+Copyright (C) 2023 Luca Bacci\n+Copyright (C) Red Hat Inc., 2000\n+Copyright (C) 2020 Frederic Martinsons\n@@ -54,0 +55,1 @@\n+Copyright (C) 2023 GNOME Foundation Inc.\n@@ -58,3 +60,2 @@\n-Copyright 2001 Hans Breuer\n-Copyright 2000-2004 Tor Lillqvist\n-Copyright 2000-2005 Red Hat, Inc.\n+Copyright (C) 2001 Hans Breuer\n+Copyright (C) 1998-2004 Tor Lillqvist\n@@ -63,6 +64,5 @@\n-Copyright 1998 Owen Taylor\n-Copyright 1998 Owen Taylor and Tor Lillqvist\n-Copyright 1999-2000 Tor Lillqvist and Craig Setera\n-Copyright 2001-2003 Andrew Lanoix\n-Copyright 2009-2018  Collabora Ltd.\n-Copyright 2009  Nokia Corporation\n+Copyright (C) 1998 Owen Taylor\n+Copyright (C) 1998 Owen Taylor and Tor Lillqvist\n+Copyright (C) 1999-2000 Tor Lillqvist and Craig Setera\n+Copyright (C) 2001-2003 Andrew Lanoix\n+Copyright (C) 2009  Nokia Corporation\n@@ -72,1 +72,14 @@\n-Copyright 2005 Matthias Clasen\n+Copyright (C) 2003-2007 Matthias Clasen\n+Copyright (C) 2006 Padraig O'Briain\n+Copyright (C) 2007 Lennart Poettering\n+Copyright (C) 2018-2022 Endless OS Foundation, LLC\n+Copyright (C) 2018 Peter Wu\n+Copyright (C) 2019 Ting-Wei Lan\n+Copyright (C) 2019 Sebastian Schwarz\n+Copyright (C) 2020 Matt Rose\n+Copyright (C) 2021 Casper Dik\n+Copyright (C) 2022 Alexander Richardson\n+Copyright (C) 2022 Ray Strode\n+Copyright (C) 2022 Thomas Haller\n+Copyright (C) 2003-2023 Sebastian Wilhelmi\n+Copyright (C) 2023 CaiJingLong\n@@ -74,1 +87,0 @@\n-Copyright (C) 2003  Matthias Clasen\n@@ -80,2 +92,2 @@\n- Copyright 1991, 92, 95, 96, 97, 98, 99 Free Software Foundation, Inc.\n-Copyright 2017-2019 Руслан Ижбулатов\n+Copyright (C) 1991, 92, 95, 96, 97, 98, 99 Free Software Foundation, Inc.\n+Copyright (C) 2017-2019 Руслан Ижбулатов\n@@ -83,3 +95,1 @@\n-Copyright 1998-2001 Sebastian Wilhelmi; University of Karlsruhe\n-Copyright (C) 2003 Sebastian Wilhelmi\n-Copyright © 2020 Endless Mobile, Inc.\n+Copyright (C) 2018-2020 Endless Mobile, Inc.\n@@ -88,3 +98,0 @@\n-Copyright © 2020 Red Hat, Inc.\n-Copyright (C) 2018 Endless Mobile, Inc.\n-Copyright (C) 2022 Endless OS Foundation, LLC\n@@ -92,1 +99,0 @@\n-Copyright (C) 1998-1999  Tor Lillqvist\n@@ -96,0 +102,1 @@\n+Copyright (C) 2006 Dave Benson\n@@ -606,1 +613,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -627,1 +634,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -657,1 +664,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -660,2 +667,0 @@\n-iconv library implemented with Win32 API.\n-\n@@ -667,1 +672,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -676,61 +681,0 @@\n----------------------------------\n-The below license applies to the following files:\n-glib\/glib\/gcharset.c (guess_category_value())\n-\n-Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n-\n-The following is (partly) taken from the gettext package.\n-\n----------------------------------\n-The below license applies to the following files:\n-glib\/glib\/gchecksum.c (sha256_sum_init())\n-\n-Copyright (C) 2006 Dave Benson\n-\n-Adapted from the SHA256 implementation in gsk\/src\/hash\/gskhash.c.\n-Released under the terms of the GNU Lesser General Public License\n-\n----------------------------------\n-The below license applies to the following files:\n-glib\/glib\/gpoll.c (poll())\n-\n-Copyright (C) 1994-1997 Free Software Foundation, Inc.\n-\n-The following implementation of poll() comes from the GNU C Library.\n-\n----------------------------------\n-The below license applies to the following files:\n-glib\/glib\/gfileutils.c\n-\n-Copyright (C) 1991,92,93,94,95,96,97,98,99 Free Software Foundation, Inc.\n-\n-get_tmp_file based on the mkstemp implementation from the GNU C library.\n-\n----------------------------------\n-The below license applies to the following files:\n-glib\/glib\/gmarkup.c\n-\n-Copyright (C) 1999-2003 Free Software Foundation, Inc.\n-\n-Partially based on code from printf-parser.c\n-\n----------------------------------\n-The below license applies to the following files:\n-glib\/glib\/gstrfuncs.c (g_parse_long_long())\n-\n-Copyright (C) 1991-2002 Free Software Foundation, Inc.\n-\n-This code is based on on the strtol(3) code from GNU libc released under\n-the GNU Lesser General Public License.\n-\n----------------------------------\n-The below license applies to the following files:\n-glib\/glib\/gunicollate.c\n-\n-Copyright (C) 1995-2001 Free Software Foundation, Inc.\n-\n-Written by Ulrich Drepper <drepper@cygnus.com>, 1995.\n-\n-utf8_encode() is taken (with modification) from GNU\n-libc's strxfrm routine.\n-\n","filename":"modules\/javafx.media\/src\/main\/legal\/glib.md","additions":40,"deletions":96,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## GStreamer v1.22.6\n+## GStreamer v1.24.6\n@@ -6,1 +6,1 @@\n-You are receiving a copy of GStreamer, Version: 1.22.6 in either source or\n+You are receiving a copy of GStreamer, Version: 1.24.6 in either source or\n@@ -8,1 +8,1 @@\n-Oracle license do NOT apply to the GStreamer, Version: 1.22.6; it is\n+Oracle license do NOT apply to the GStreamer, Version: 1.24.6; it is\n@@ -66,3 +66,1 @@\n-Copyright 2005 Jan Schmidt <thaytan@mad.scientist.com>\n-Copyright 2002-2003 Scott Wheeler <wheeler@kde.org> (portions from taglib)\n-Copyright 2006-2008 Tim-Philipp Müller <tim centricular net>\n+Copyright (C) 2002-2003 Scott Wheeler <wheeler@kde.org> (portions from taglib)\n@@ -100,1 +98,0 @@\n-Copyright 2005 David Schleef <ds@schleef.org>\n@@ -106,0 +103,1 @@\n+Copyright (C) 2023 Netflix Inc.\n@@ -107,1 +105,0 @@\n-Copyright (C) 2008 Jan Schmidt <jan.schmidt@sun.com>\n@@ -671,1 +668,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -714,1 +711,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n@@ -725,1 +722,1 @@\n-The below license applies to the following files:\n+The below applies to the following file(s):\n","filename":"modules\/javafx.media\/src\/main\/legal\/gstreamer.md","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define GLIB_BINARY_AGE 7801\n+#define GLIB_BINARY_AGE 8004\n@@ -54,1 +54,1 @@\n-#define GLIB_MICRO_VERSION 1\n+#define GLIB_MICRO_VERSION 4\n@@ -57,1 +57,1 @@\n-#define GLIB_MINOR_VERSION 78\n+#define GLIB_MINOR_VERSION 80\n@@ -708,1 +708,1 @@\n-#define PACKAGE_STRING \"glib 2.78.1\"\n+#define PACKAGE_STRING \"glib 2.80.4\"\n@@ -717,1 +717,1 @@\n-#define PACKAGE_VERSION \"2.78.1\"\n+#define PACKAGE_VERSION \"2.80.4\"\n@@ -832,3 +832,0 @@\n-\/* defines how to decorate public symbols while building *\/\n-#define _GLIB_EXTERN __attribute__((visibility(\"default\"))) extern\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/osx\/config.h","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -116,2 +116,2 @@\n-#define GLIB_MINOR_VERSION 78\n-#define GLIB_MICRO_VERSION 1\n+#define GLIB_MINOR_VERSION 80\n+#define GLIB_MICRO_VERSION 4\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/osx\/glibconfig.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#define GLIB_BINARY_AGE 7801\n+#define GLIB_BINARY_AGE 8004\n@@ -53,1 +53,1 @@\n-#define GLIB_MICRO_VERSION 1\n+#define GLIB_MICRO_VERSION 4\n@@ -56,1 +56,1 @@\n-#define GLIB_MINOR_VERSION 78\n+#define GLIB_MINOR_VERSION 80\n@@ -695,1 +695,1 @@\n-#define PACKAGE_STRING \"glib 2.78.1\"\n+#define PACKAGE_STRING \"glib 2.80.4\"\n@@ -704,1 +704,1 @@\n-#define PACKAGE_VERSION \"2.78.1\"\n+#define PACKAGE_VERSION \"2.80.4\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/win32\/vs100\/config.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,501 +46,507 @@\n-g_bytes_compare\t@45\tNONAME\n-g_bytes_get_data\t@46\tNONAME\n-g_bytes_get_type\t@47\tNONAME\n-g_bytes_new\t@48\tNONAME\n-g_bytes_new_take\t@49\tNONAME\n-g_bytes_ref\t@50\tNONAME\n-g_bytes_unref\t@51\tNONAME\n-g_cclosure_marshal_VOID__VOID\t@52\tNONAME\n-g_cclosure_marshal_generic\t@53\tNONAME\n-g_checksum_free\t@54\tNONAME\n-g_checksum_get_string\t@55\tNONAME\n-g_checksum_new\t@56\tNONAME\n-g_checksum_update\t@57\tNONAME\n-g_clear_error\t@58\tNONAME\n-g_cond_broadcast\t@59\tNONAME\n-g_cond_clear\t@60\tNONAME\n-g_cond_init\t@61\tNONAME\n-g_cond_signal\t@62\tNONAME\n-g_cond_wait\t@63\tNONAME\n-g_cond_wait_until\t@64\tNONAME\n-g_convert\t@65\tNONAME\n-g_datalist_id_get_data\t@66\tNONAME\n-g_datalist_id_set_data_full\t@67\tNONAME\n-g_datalist_init\t@68\tNONAME\n-g_date_free\t@69\tNONAME\n-g_date_get_day\t@70\tNONAME\n-g_date_get_julian\t@71\tNONAME\n-g_date_get_month\t@72\tNONAME\n-g_date_get_type\t@73\tNONAME\n-g_date_get_year\t@74\tNONAME\n-g_date_new_dmy\t@75\tNONAME\n-g_date_time_add\t@76\tNONAME\n-g_date_time_add_minutes\t@77\tNONAME\n-g_date_time_add_seconds\t@78\tNONAME\n-g_date_time_compare\t@79\tNONAME\n-g_date_time_get_day_of_month\t@80\tNONAME\n-g_date_time_get_hour\t@81\tNONAME\n-g_date_time_get_microsecond\t@82\tNONAME\n-g_date_time_get_minute\t@83\tNONAME\n-g_date_time_get_month\t@84\tNONAME\n-g_date_time_get_second\t@85\tNONAME\n-g_date_time_get_type\t@86\tNONAME\n-g_date_time_get_utc_offset\t@87\tNONAME\n-g_date_time_get_year\t@88\tNONAME\n-g_date_time_get_ymd\t@89\tNONAME\n-g_date_time_new\t@90\tNONAME\n-g_date_time_new_from_unix_local\t@91\tNONAME\n-g_date_time_new_from_unix_utc\t@92\tNONAME\n-g_date_time_new_local\t@93\tNONAME\n-g_date_time_new_now_local\t@94\tNONAME\n-g_date_time_new_now_utc\t@95\tNONAME\n-g_date_time_new_utc\t@96\tNONAME\n-g_date_time_to_local\t@97\tNONAME\n-g_date_time_to_unix\t@98\tNONAME\n-g_date_time_unref\t@99\tNONAME\n-g_date_valid\t@100\tNONAME\n-g_date_valid_dmy\t@101\tNONAME\n-g_dgettext\t@102\tNONAME\n-g_dir_close\t@103\tNONAME\n-g_dir_open\t@104\tNONAME\n-g_dir_read_name\t@105\tNONAME\n-g_enum_get_value\t@106\tNONAME\n-g_enum_get_value_by_name\t@107\tNONAME\n-g_enum_get_value_by_nick\t@108\tNONAME\n-g_enum_register_static\t@109\tNONAME\n-g_error_free\t@110\tNONAME\n-g_error_get_type\t@111\tNONAME\n-g_error_new\t@112\tNONAME\n-g_error_new_literal\t@113\tNONAME\n-g_file_set_contents\t@114\tNONAME\n-g_file_test\t@115\tNONAME\n-g_filename_to_uri\t@116\tNONAME\n-g_flags_get_first_value\t@117\tNONAME\n-g_flags_get_value_by_name\t@118\tNONAME\n-g_flags_get_value_by_nick\t@119\tNONAME\n-g_flags_register_static\t@120\tNONAME\n-g_free\t@121\tNONAME\n-g_get_charset\t@122\tNONAME\n-g_get_current_dir\t@123\tNONAME\n-g_get_current_time\t@124\tNONAME\n-g_get_monotonic_time\t@125\tNONAME\n-g_get_prgname\t@126\tNONAME\n-g_get_real_time\t@127\tNONAME\n-g_get_user_cache_dir\t@128\tNONAME\n-g_get_user_data_dir\t@129\tNONAME\n-g_getenv\t@130\tNONAME\n-g_gtype_get_type\t@131\tNONAME\n-g_hash_table_contains\t@132\tNONAME\n-g_hash_table_destroy\t@133\tNONAME\n-g_hash_table_foreach\t@134\tNONAME\n-g_hash_table_foreach_remove\t@135\tNONAME\n-g_hash_table_get_keys\t@136\tNONAME\n-g_hash_table_get_values\t@137\tNONAME\n-g_hash_table_insert\t@138\tNONAME\n-g_hash_table_iter_init\t@139\tNONAME\n-g_hash_table_iter_next\t@140\tNONAME\n-g_hash_table_lookup\t@141\tNONAME\n-g_hash_table_new\t@142\tNONAME\n-g_hash_table_new_full\t@143\tNONAME\n-g_hash_table_ref\t@144\tNONAME\n-g_hash_table_remove\t@145\tNONAME\n-g_hash_table_replace\t@146\tNONAME\n-g_hash_table_size\t@147\tNONAME\n-g_hash_table_unref\t@148\tNONAME\n-g_hook_alloc\t@149\tNONAME\n-g_hook_destroy_link\t@150\tNONAME\n-g_hook_get\t@151\tNONAME\n-g_hook_insert_before\t@152\tNONAME\n-g_hook_list_clear\t@153\tNONAME\n-g_hook_list_init\t@154\tNONAME\n-g_hook_list_marshal\t@155\tNONAME\n-g_hook_ref\t@156\tNONAME\n-g_hook_unref\t@157\tNONAME\n-g_initially_unowned_get_type\t@158\tNONAME\n-g_int_equal\t@159\tNONAME\n-g_int_hash\t@160\tNONAME\n-g_intern_static_string\t@161\tNONAME\n-g_intern_string\t@162\tNONAME\n-g_key_file_free\t@163\tNONAME\n-g_key_file_get_comment\t@164\tNONAME\n-g_key_file_get_groups\t@165\tNONAME\n-g_key_file_get_keys\t@166\tNONAME\n-g_key_file_get_value\t@167\tNONAME\n-g_key_file_has_group\t@168\tNONAME\n-g_key_file_load_from_file\t@169\tNONAME\n-g_key_file_new\t@170\tNONAME\n-g_key_file_remove_group\t@171\tNONAME\n-g_key_file_remove_key\t@172\tNONAME\n-g_key_file_set_comment\t@173\tNONAME\n-g_key_file_set_string\t@174\tNONAME\n-g_key_file_set_value\t@175\tNONAME\n-g_key_file_to_data\t@176\tNONAME\n-g_list_alloc\t@177\tNONAME\n-g_list_append\t@178\tNONAME\n-g_list_concat\t@179\tNONAME\n-g_list_copy\t@180\tNONAME\n-g_list_copy_deep\t@181\tNONAME\n-g_list_delete_link\t@182\tNONAME\n-g_list_find\t@183\tNONAME\n-g_list_find_custom\t@184\tNONAME\n-g_list_foreach\t@185\tNONAME\n-g_list_free\t@186\tNONAME\n-g_list_free_full\t@187\tNONAME\n-g_list_index\t@188\tNONAME\n-g_list_insert\t@189\tNONAME\n-g_list_insert_before\t@190\tNONAME\n-g_list_insert_sorted\t@191\tNONAME\n-g_list_last\t@192\tNONAME\n-g_list_length\t@193\tNONAME\n-g_list_nth_data\t@194\tNONAME\n-g_list_position\t@195\tNONAME\n-g_list_prepend\t@196\tNONAME\n-g_list_remove\t@197\tNONAME\n-g_list_remove_link\t@198\tNONAME\n-g_list_reverse\t@199\tNONAME\n-g_list_sort\t@200\tNONAME\n-g_locale_to_utf8\t@201\tNONAME\n-g_log\t@202\tNONAME\n-g_log_default_handler\t@203\tNONAME\n-g_log_set_default_handler\t@204\tNONAME\n-g_log_set_handler\t@205\tNONAME\n-g_main_context_get_thread_default\t@206\tNONAME\n-g_main_context_new\t@207\tNONAME\n-g_main_context_unref\t@208\tNONAME\n-g_main_loop_is_running\t@209\tNONAME\n-g_main_loop_new\t@210\tNONAME\n-g_main_loop_quit\t@211\tNONAME\n-g_main_loop_run\t@212\tNONAME\n-g_main_loop_unref\t@213\tNONAME\n-g_malloc\t@214\tNONAME\n-g_malloc0\t@215\tNONAME\n-g_malloc0_n\t@216\tNONAME\n-g_malloc_n\t@217\tNONAME\n-g_mapped_file_ref\t@218\tNONAME\n-g_mapped_file_unref\t@219\tNONAME\n-g_markup_parse_context_ref\t@220\tNONAME\n-g_markup_parse_context_unref\t@221\tNONAME\n-g_memdup\t@222\tNONAME\n-g_memdup2\t@223\tNONAME\n-g_mkdir_with_parents\t@224\tNONAME\n-g_module_close\t@225\tNONAME\n-g_module_error\t@226\tNONAME\n-g_module_make_resident\t@227\tNONAME\n-g_module_open\t@228\tNONAME\n-g_module_supported\t@229\tNONAME\n-g_module_symbol\t@230\tNONAME\n-g_mutex_clear\t@231\tNONAME\n-g_mutex_init\t@232\tNONAME\n-g_mutex_lock\t@233\tNONAME\n-g_mutex_unlock\t@234\tNONAME\n-g_node_children_foreach\t@235\tNONAME\n-g_node_destroy\t@236\tNONAME\n-g_node_insert_before\t@237\tNONAME\n-g_node_new\t@238\tNONAME\n-g_node_nth_child\t@239\tNONAME\n-g_object_add_weak_pointer\t@240\tNONAME\n-g_object_class_find_property\t@241\tNONAME\n-g_object_class_install_properties\t@242\tNONAME\n-g_object_class_install_property\t@243\tNONAME\n-g_object_class_list_properties\t@244\tNONAME\n-g_object_force_floating\t@245\tNONAME\n-g_object_freeze_notify\t@246\tNONAME\n-g_object_get\t@247\tNONAME\n-g_object_get_property\t@248\tNONAME\n-g_object_interface_install_property\t@249\tNONAME\n-g_object_is_floating\t@250\tNONAME\n-g_object_new\t@251\tNONAME\n-g_object_new_with_properties\t@252\tNONAME\n-g_object_notify\t@253\tNONAME\n-g_object_notify_by_pspec\t@254\tNONAME\n-g_object_ref\t@255\tNONAME\n-g_object_ref_sink\t@256\tNONAME\n-g_object_remove_weak_pointer\t@257\tNONAME\n-g_object_set\t@258\tNONAME\n-g_object_set_property\t@259\tNONAME\n-g_object_thaw_notify\t@260\tNONAME\n-g_object_unref\t@261\tNONAME\n-g_once_impl\t@262\tNONAME\n-g_once_init_enter\t@263\tNONAME\n-g_once_init_leave\t@264\tNONAME\n-g_option_group_ref\t@265\tNONAME\n-g_option_group_unref\t@266\tNONAME\n-g_param_spec_boolean\t@267\tNONAME\n-g_param_spec_boxed\t@268\tNONAME\n-g_param_spec_double\t@269\tNONAME\n-g_param_spec_enum\t@270\tNONAME\n-g_param_spec_flags\t@271\tNONAME\n-g_param_spec_float\t@272\tNONAME\n-g_param_spec_gtype\t@273\tNONAME\n-g_param_spec_int\t@274\tNONAME\n-g_param_spec_int64\t@275\tNONAME\n-g_param_spec_internal\t@276\tNONAME\n-g_param_spec_object\t@277\tNONAME\n-g_param_spec_ref\t@278\tNONAME\n-g_param_spec_sink\t@279\tNONAME\n-g_param_spec_string\t@280\tNONAME\n-g_param_spec_uint\t@281\tNONAME\n-g_param_spec_uint64\t@282\tNONAME\n-g_param_spec_unref\t@283\tNONAME\n-g_param_type_register_static\t@284\tNONAME\n-g_param_value_set_default\t@285\tNONAME\n-g_param_value_validate\t@286\tNONAME\n-g_param_values_cmp\t@287\tNONAME\n-g_path_get_basename\t@288\tNONAME\n-g_path_get_dirname\t@289\tNONAME\n-g_path_is_absolute\t@290\tNONAME\n-g_pointer_type_register_static\t@291\tNONAME\n-g_print\t@292\tNONAME\n-g_printerr\t@293\tNONAME\n-g_private_get\t@294\tNONAME\n-g_private_set\t@295\tNONAME\n-g_propagate_error\t@296\tNONAME\n-g_ptr_array_add\t@297\tNONAME\n-g_ptr_array_find_with_equal_func\t@298\tNONAME\n-g_ptr_array_foreach\t@299\tNONAME\n-g_ptr_array_free\t@300\tNONAME\n-g_ptr_array_new_full\t@301\tNONAME\n-g_ptr_array_new_with_free_func\t@302\tNONAME\n-g_ptr_array_remove_fast\t@303\tNONAME\n-g_ptr_array_remove_index\t@304\tNONAME\n-g_ptr_array_set_size\t@305\tNONAME\n-g_ptr_array_sort\t@306\tNONAME\n-g_qsort_with_data\t@307\tNONAME\n-g_quark_from_static_string\t@308\tNONAME\n-g_quark_from_string\t@309\tNONAME\n-g_quark_to_string\t@310\tNONAME\n-g_quark_try_string\t@311\tNONAME\n-g_queue_clear\t@312\tNONAME\n-g_queue_clear_full\t@313\tNONAME\n-g_queue_delete_link\t@314\tNONAME\n-g_queue_find\t@315\tNONAME\n-g_queue_find_custom\t@316\tNONAME\n-g_queue_foreach\t@317\tNONAME\n-g_queue_free\t@318\tNONAME\n-g_queue_get_length\t@319\tNONAME\n-g_queue_init\t@320\tNONAME\n-g_queue_is_empty\t@321\tNONAME\n-g_queue_new\t@322\tNONAME\n-g_queue_peek_nth\t@323\tNONAME\n-g_queue_pop_head\t@324\tNONAME\n-g_queue_push_head\t@325\tNONAME\n-g_queue_push_tail\t@326\tNONAME\n-g_queue_remove\t@327\tNONAME\n-g_queue_sort\t@328\tNONAME\n-g_random_int\t@329\tNONAME\n-g_realloc\t@330\tNONAME\n-g_realloc_n\t@331\tNONAME\n-g_rec_mutex_clear\t@332\tNONAME\n-g_rec_mutex_init\t@333\tNONAME\n-g_rec_mutex_lock\t@334\tNONAME\n-g_rec_mutex_unlock\t@335\tNONAME\n-g_rename\t@336\tNONAME\n-g_rw_lock_init\t@337\tNONAME\n-g_rw_lock_reader_lock\t@338\tNONAME\n-g_rw_lock_reader_unlock\t@339\tNONAME\n-g_rw_lock_writer_lock\t@340\tNONAME\n-g_rw_lock_writer_unlock\t@341\tNONAME\n-g_set_error\t@342\tNONAME\n-g_set_error_literal\t@343\tNONAME\n-g_signal_connect_data\t@344\tNONAME\n-g_signal_emit\t@345\tNONAME\n-g_signal_handler_disconnect\t@346\tNONAME\n-g_signal_handlers_destroy\t@347\tNONAME\n-g_signal_handlers_disconnect_matched\t@348\tNONAME\n-g_signal_new\t@349\tNONAME\n-g_slice_alloc\t@350\tNONAME\n-g_slice_alloc0\t@351\tNONAME\n-g_slice_copy\t@352\tNONAME\n-g_slice_free1\t@353\tNONAME\n-g_slist_append\t@354\tNONAME\n-g_slist_concat\t@355\tNONAME\n-g_slist_delete_link\t@356\tNONAME\n-g_slist_foreach\t@357\tNONAME\n-g_slist_free\t@358\tNONAME\n-g_slist_insert_before\t@359\tNONAME\n-g_slist_prepend\t@360\tNONAME\n-g_slist_remove\t@361\tNONAME\n-g_slist_reverse\t@362\tNONAME\n-g_snprintf\t@363\tNONAME\n-g_source_add_poll\t@364\tNONAME\n-g_source_attach\t@365\tNONAME\n-g_source_destroy\t@366\tNONAME\n-g_source_new\t@367\tNONAME\n-g_source_ref\t@368\tNONAME\n-g_source_remove\t@369\tNONAME\n-g_source_set_callback\t@370\tNONAME\n-g_source_set_dispose_function\t@371\tNONAME\n-g_source_set_name\t@372\tNONAME\n-g_source_set_priority\t@373\tNONAME\n-g_source_unref\t@374\tNONAME\n-g_spawn_close_pid\t@375\tNONAME\n-g_stat\t@376\tNONAME\n-g_str_equal\t@377\tNONAME\n-g_str_has_prefix\t@378\tNONAME\n-g_str_has_suffix\t@379\tNONAME\n-g_str_hash\t@380\tNONAME\n-g_strchomp\t@381\tNONAME\n-g_strchug\t@382\tNONAME\n-g_strcmp0\t@383\tNONAME\n-g_strconcat\t@384\tNONAME\n-g_strdelimit\t@385\tNONAME\n-g_strdup\t@386\tNONAME\n-g_strdup_printf\t@387\tNONAME\n-g_strdup_value_contents\t@388\tNONAME\n-g_strdup_vprintf\t@389\tNONAME\n-g_strdupv\t@390\tNONAME\n-g_strerror\t@391\tNONAME\n-g_strfreev\t@392\tNONAME\n-g_string_append\t@393\tNONAME\n-g_string_append_len\t@394\tNONAME\n-g_string_append_printf\t@395\tNONAME\n-g_string_free\t@396\tNONAME\n-g_string_insert_c\t@397\tNONAME\n-g_string_insert_len\t@398\tNONAME\n-g_string_new\t@399\tNONAME\n-g_string_set_size\t@400\tNONAME\n-g_string_sized_new\t@401\tNONAME\n-g_string_truncate\t@402\tNONAME\n-g_strjoin\t@403\tNONAME\n-g_strlcat\t@404\tNONAME\n-g_strlcpy\t@405\tNONAME\n-g_strndup\t@406\tNONAME\n-g_strrstr\t@407\tNONAME\n-g_strsplit\t@408\tNONAME\n-g_strsplit_set\t@409\tNONAME\n-g_strstr_len\t@410\tNONAME\n-g_strtod\t@411\tNONAME\n-g_strv_get_type\t@412\tNONAME\n-g_strv_length\t@413\tNONAME\n-g_thread_get_type\t@414\tNONAME\n-g_thread_join\t@415\tNONAME\n-g_thread_new\t@416\tNONAME\n-g_thread_pool_free\t@417\tNONAME\n-g_thread_pool_new\t@418\tNONAME\n-g_thread_pool_push\t@419\tNONAME\n-g_thread_pool_set_max_threads\t@420\tNONAME\n-g_thread_pool_set_max_unused_threads\t@421\tNONAME\n-g_thread_self\t@422\tNONAME\n-g_thread_try_new\t@423\tNONAME\n-g_thread_yield\t@424\tNONAME\n-g_time_zone_new\t@425\tNONAME\n-g_time_zone_new_identifier\t@426\tNONAME\n-g_time_zone_unref\t@427\tNONAME\n-g_timeout_add_full\t@428\tNONAME\n-g_timer_destroy\t@429\tNONAME\n-g_timer_elapsed\t@430\tNONAME\n-g_timer_new\t@431\tNONAME\n-g_timer_start\t@432\tNONAME\n-g_tree_destroy\t@433\tNONAME\n-g_tree_insert\t@434\tNONAME\n-g_tree_new_with_data\t@435\tNONAME\n-g_tree_search\t@436\tNONAME\n-g_try_malloc\t@437\tNONAME\n-g_try_malloc0_n\t@438\tNONAME\n-g_try_malloc_n\t@439\tNONAME\n-g_try_realloc\t@440\tNONAME\n-g_try_realloc_n\t@441\tNONAME\n-g_type_add_class_private\t@442\tNONAME\n-g_type_add_instance_private\t@443\tNONAME\n-g_type_add_interface_static\t@444\tNONAME\n-g_type_check_class_cast\t@445\tNONAME\n-g_type_check_instance_cast\t@446\tNONAME\n-g_type_check_instance_is_a\t@447\tNONAME\n-g_type_check_instance_is_fundamentally_a\t@448\tNONAME\n-g_type_check_value\t@449\tNONAME\n-g_type_check_value_holds\t@450\tNONAME\n-g_type_class_add_private\t@451\tNONAME\n-g_type_class_adjust_private_offset\t@452\tNONAME\n-g_type_class_get_private\t@453\tNONAME\n-g_type_class_peek\t@454\tNONAME\n-g_type_class_peek_parent\t@455\tNONAME\n-g_type_class_ref\t@456\tNONAME\n-g_type_class_unref\t@457\tNONAME\n-g_type_from_name\t@458\tNONAME\n-g_type_fundamental\t@459\tNONAME\n-g_type_fundamental_next\t@460\tNONAME\n-g_type_get_qdata\t@461\tNONAME\n-g_type_init\t@462\tNONAME\n-g_type_instance_get_private\t@463\tNONAME\n-g_type_interface_add_prerequisite\t@464\tNONAME\n-g_type_interface_peek\t@465\tNONAME\n-g_type_interfaces\t@466\tNONAME\n-g_type_is_a\t@467\tNONAME\n-g_type_name\t@468\tNONAME\n-g_type_parent\t@469\tNONAME\n-g_type_qname\t@470\tNONAME\n-g_type_register_fundamental\t@471\tNONAME\n-g_type_register_static\t@472\tNONAME\n-g_type_register_static_simple\t@473\tNONAME\n-g_type_set_qdata\t@474\tNONAME\n-g_type_value_table_peek\t@475\tNONAME\n-g_unlink\t@476\tNONAME\n-g_uri_escape_string\t@477\tNONAME\n-g_uri_unescape_segment\t@478\tNONAME\n-g_uri_unescape_string\t@479\tNONAME\n-g_utf16_to_utf8\t@480\tNONAME\n-g_utf8_strchr\t@481\tNONAME\n-g_utf8_to_utf16\t@482\tNONAME\n-g_utf8_validate\t@483\tNONAME\n-g_value_array_append\t@484\tNONAME\n-g_value_array_get_nth\t@485\tNONAME\n-g_value_array_get_type\t@486\tNONAME\n-g_value_array_new\t@487\tNONAME\n-g_value_copy\t@488\tNONAME\n-g_value_dup_boxed\t@489\tNONAME\n-g_value_dup_object\t@490\tNONAME\n-g_value_dup_string\t@491\tNONAME\n-g_value_get_boolean\t@492\tNONAME\n-g_value_get_boxed\t@493\tNONAME\n-g_value_get_double\t@494\tNONAME\n-g_value_get_enum\t@495\tNONAME\n-g_value_get_flags\t@496\tNONAME\n-g_value_get_float\t@497\tNONAME\n-g_value_get_gtype\t@498\tNONAME\n-g_value_get_int\t@499\tNONAME\n-g_value_get_int64\t@500\tNONAME\n-g_value_get_long\t@501\tNONAME\n-g_value_get_object\t@502\tNONAME\n-g_value_get_pointer\t@503\tNONAME\n-g_value_get_string\t@504\tNONAME\n-g_value_get_uchar\t@505\tNONAME\n-g_value_get_uint\t@506\tNONAME\n-g_value_get_uint64\t@507\tNONAME\n-g_value_get_ulong\t@508\tNONAME\n-g_value_init\t@509\tNONAME\n-g_value_peek_pointer\t@510\tNONAME\n-g_value_register_transform_func\t@511\tNONAME\n-g_value_reset\t@512\tNONAME\n-g_value_set_boolean\t@513\tNONAME\n-g_value_set_boxed\t@514\tNONAME\n-g_value_set_double\t@515\tNONAME\n-g_value_set_enum\t@516\tNONAME\n-g_value_set_flags\t@517\tNONAME\n-g_value_set_float\t@518\tNONAME\n-g_value_set_gtype\t@519\tNONAME\n-g_value_set_int\t@520\tNONAME\n-g_value_set_int64\t@521\tNONAME\n-g_value_set_long\t@522\tNONAME\n-g_value_set_object\t@523\tNONAME\n-g_value_set_pointer\t@524\tNONAME\n-g_value_set_static_boxed\t@525\tNONAME\n-g_value_set_static_string\t@526\tNONAME\n-g_value_set_string\t@527\tNONAME\n-g_value_set_uchar\t@528\tNONAME\n-g_value_set_uint\t@529\tNONAME\n-g_value_set_uint64\t@530\tNONAME\n-g_value_set_ulong\t@531\tNONAME\n-g_value_take_boxed\t@532\tNONAME\n-g_value_take_object\t@533\tNONAME\n-g_value_take_string\t@534\tNONAME\n-g_value_transform\t@535\tNONAME\n-g_value_type_compatible\t@536\tNONAME\n-g_value_unset\t@537\tNONAME\n-g_vasprintf\t@538\tNONAME\n-g_warn_message\t@539\tNONAME\n-g_weak_ref_clear\t@540\tNONAME\n-g_weak_ref_get\t@541\tNONAME\n-g_weak_ref_init\t@542\tNONAME\n-g_weak_ref_set\t@543\tNONAME\n-g_win32_error_message\t@544\tNONAME\n-g_win32_get_package_installation_directory_of_module\t@545\tNONAME\n+g_byte_array_set_size\t@45\tNONAME\n+g_bytes_compare\t@46\tNONAME\n+g_bytes_get_data\t@47\tNONAME\n+g_bytes_get_type\t@48\tNONAME\n+g_bytes_new\t@49\tNONAME\n+g_bytes_new_take\t@50\tNONAME\n+g_bytes_ref\t@51\tNONAME\n+g_bytes_unref\t@52\tNONAME\n+g_cclosure_marshal_VOID__VOID\t@53\tNONAME\n+g_cclosure_marshal_generic\t@54\tNONAME\n+g_checksum_free\t@55\tNONAME\n+g_checksum_get_string\t@56\tNONAME\n+g_checksum_new\t@57\tNONAME\n+g_checksum_update\t@58\tNONAME\n+g_clear_error\t@59\tNONAME\n+g_cond_broadcast\t@60\tNONAME\n+g_cond_clear\t@61\tNONAME\n+g_cond_init\t@62\tNONAME\n+g_cond_signal\t@63\tNONAME\n+g_cond_wait\t@64\tNONAME\n+g_cond_wait_until\t@65\tNONAME\n+g_convert\t@66\tNONAME\n+g_datalist_id_get_data\t@67\tNONAME\n+g_datalist_id_set_data_full\t@68\tNONAME\n+g_datalist_init\t@69\tNONAME\n+g_date_free\t@70\tNONAME\n+g_date_get_day\t@71\tNONAME\n+g_date_get_julian\t@72\tNONAME\n+g_date_get_month\t@73\tNONAME\n+g_date_get_type\t@74\tNONAME\n+g_date_get_year\t@75\tNONAME\n+g_date_new_dmy\t@76\tNONAME\n+g_date_time_add\t@77\tNONAME\n+g_date_time_add_minutes\t@78\tNONAME\n+g_date_time_add_seconds\t@79\tNONAME\n+g_date_time_compare\t@80\tNONAME\n+g_date_time_get_day_of_month\t@81\tNONAME\n+g_date_time_get_hour\t@82\tNONAME\n+g_date_time_get_microsecond\t@83\tNONAME\n+g_date_time_get_minute\t@84\tNONAME\n+g_date_time_get_month\t@85\tNONAME\n+g_date_time_get_second\t@86\tNONAME\n+g_date_time_get_type\t@87\tNONAME\n+g_date_time_get_utc_offset\t@88\tNONAME\n+g_date_time_get_year\t@89\tNONAME\n+g_date_time_get_ymd\t@90\tNONAME\n+g_date_time_new\t@91\tNONAME\n+g_date_time_new_from_unix_local\t@92\tNONAME\n+g_date_time_new_from_unix_utc\t@93\tNONAME\n+g_date_time_new_local\t@94\tNONAME\n+g_date_time_new_now_local\t@95\tNONAME\n+g_date_time_new_now_utc\t@96\tNONAME\n+g_date_time_new_utc\t@97\tNONAME\n+g_date_time_to_local\t@98\tNONAME\n+g_date_time_to_unix\t@99\tNONAME\n+g_date_time_unref\t@100\tNONAME\n+g_date_valid\t@101\tNONAME\n+g_date_valid_dmy\t@102\tNONAME\n+g_dgettext\t@103\tNONAME\n+g_dir_close\t@104\tNONAME\n+g_dir_open\t@105\tNONAME\n+g_dir_read_name\t@106\tNONAME\n+g_enum_get_value\t@107\tNONAME\n+g_enum_get_value_by_name\t@108\tNONAME\n+g_enum_get_value_by_nick\t@109\tNONAME\n+g_enum_register_static\t@110\tNONAME\n+g_error_free\t@111\tNONAME\n+g_error_get_type\t@112\tNONAME\n+g_error_new\t@113\tNONAME\n+g_error_new_literal\t@114\tNONAME\n+g_file_set_contents\t@115\tNONAME\n+g_file_test\t@116\tNONAME\n+g_filename_to_uri\t@117\tNONAME\n+g_flags_get_first_value\t@118\tNONAME\n+g_flags_get_value_by_name\t@119\tNONAME\n+g_flags_get_value_by_nick\t@120\tNONAME\n+g_flags_register_static\t@121\tNONAME\n+g_free\t@122\tNONAME\n+g_get_charset\t@123\tNONAME\n+g_get_current_dir\t@124\tNONAME\n+g_get_current_time\t@125\tNONAME\n+g_get_monotonic_time\t@126\tNONAME\n+g_get_prgname\t@127\tNONAME\n+g_get_real_time\t@128\tNONAME\n+g_get_user_cache_dir\t@129\tNONAME\n+g_get_user_data_dir\t@130\tNONAME\n+g_getenv\t@131\tNONAME\n+g_gtype_get_type\t@132\tNONAME\n+g_hash_table_contains\t@133\tNONAME\n+g_hash_table_destroy\t@134\tNONAME\n+g_hash_table_foreach\t@135\tNONAME\n+g_hash_table_foreach_remove\t@136\tNONAME\n+g_hash_table_get_keys\t@137\tNONAME\n+g_hash_table_get_values\t@138\tNONAME\n+g_hash_table_insert\t@139\tNONAME\n+g_hash_table_iter_init\t@140\tNONAME\n+g_hash_table_iter_next\t@141\tNONAME\n+g_hash_table_lookup\t@142\tNONAME\n+g_hash_table_new\t@143\tNONAME\n+g_hash_table_new_full\t@144\tNONAME\n+g_hash_table_ref\t@145\tNONAME\n+g_hash_table_remove\t@146\tNONAME\n+g_hash_table_replace\t@147\tNONAME\n+g_hash_table_size\t@148\tNONAME\n+g_hash_table_unref\t@149\tNONAME\n+g_hook_alloc\t@150\tNONAME\n+g_hook_destroy_link\t@151\tNONAME\n+g_hook_get\t@152\tNONAME\n+g_hook_insert_before\t@153\tNONAME\n+g_hook_list_clear\t@154\tNONAME\n+g_hook_list_init\t@155\tNONAME\n+g_hook_list_marshal\t@156\tNONAME\n+g_hook_ref\t@157\tNONAME\n+g_hook_unref\t@158\tNONAME\n+g_initially_unowned_get_type\t@159\tNONAME\n+g_int_equal\t@160\tNONAME\n+g_int_hash\t@161\tNONAME\n+g_intern_static_string\t@162\tNONAME\n+g_intern_string\t@163\tNONAME\n+g_key_file_free\t@164\tNONAME\n+g_key_file_get_comment\t@165\tNONAME\n+g_key_file_get_groups\t@166\tNONAME\n+g_key_file_get_keys\t@167\tNONAME\n+g_key_file_get_value\t@168\tNONAME\n+g_key_file_has_group\t@169\tNONAME\n+g_key_file_load_from_file\t@170\tNONAME\n+g_key_file_new\t@171\tNONAME\n+g_key_file_remove_group\t@172\tNONAME\n+g_key_file_remove_key\t@173\tNONAME\n+g_key_file_set_comment\t@174\tNONAME\n+g_key_file_set_string\t@175\tNONAME\n+g_key_file_set_value\t@176\tNONAME\n+g_key_file_to_data\t@177\tNONAME\n+g_list_alloc\t@178\tNONAME\n+g_list_append\t@179\tNONAME\n+g_list_concat\t@180\tNONAME\n+g_list_copy\t@181\tNONAME\n+g_list_copy_deep\t@182\tNONAME\n+g_list_delete_link\t@183\tNONAME\n+g_list_find\t@184\tNONAME\n+g_list_find_custom\t@185\tNONAME\n+g_list_foreach\t@186\tNONAME\n+g_list_free\t@187\tNONAME\n+g_list_free_full\t@188\tNONAME\n+g_list_index\t@189\tNONAME\n+g_list_insert\t@190\tNONAME\n+g_list_insert_before\t@191\tNONAME\n+g_list_insert_sorted\t@192\tNONAME\n+g_list_last\t@193\tNONAME\n+g_list_length\t@194\tNONAME\n+g_list_nth_data\t@195\tNONAME\n+g_list_position\t@196\tNONAME\n+g_list_prepend\t@197\tNONAME\n+g_list_remove\t@198\tNONAME\n+g_list_remove_link\t@199\tNONAME\n+g_list_reverse\t@200\tNONAME\n+g_list_sort\t@201\tNONAME\n+g_locale_to_utf8\t@202\tNONAME\n+g_log\t@203\tNONAME\n+g_log_default_handler\t@204\tNONAME\n+g_log_set_default_handler\t@205\tNONAME\n+g_log_set_handler\t@206\tNONAME\n+g_main_context_get_thread_default\t@207\tNONAME\n+g_main_context_new\t@208\tNONAME\n+g_main_context_unref\t@209\tNONAME\n+g_main_loop_is_running\t@210\tNONAME\n+g_main_loop_new\t@211\tNONAME\n+g_main_loop_quit\t@212\tNONAME\n+g_main_loop_run\t@213\tNONAME\n+g_main_loop_unref\t@214\tNONAME\n+g_malloc\t@215\tNONAME\n+g_malloc0\t@216\tNONAME\n+g_malloc0_n\t@217\tNONAME\n+g_malloc_n\t@218\tNONAME\n+g_mapped_file_ref\t@219\tNONAME\n+g_mapped_file_unref\t@220\tNONAME\n+g_markup_parse_context_ref\t@221\tNONAME\n+g_markup_parse_context_unref\t@222\tNONAME\n+g_memdup\t@223\tNONAME\n+g_memdup2\t@224\tNONAME\n+g_mkdir_with_parents\t@225\tNONAME\n+g_module_close\t@226\tNONAME\n+g_module_error\t@227\tNONAME\n+g_module_make_resident\t@228\tNONAME\n+g_module_open\t@229\tNONAME\n+g_module_supported\t@230\tNONAME\n+g_module_symbol\t@231\tNONAME\n+g_mutex_clear\t@232\tNONAME\n+g_mutex_init\t@233\tNONAME\n+g_mutex_lock\t@234\tNONAME\n+g_mutex_unlock\t@235\tNONAME\n+g_node_children_foreach\t@236\tNONAME\n+g_node_destroy\t@237\tNONAME\n+g_node_insert_before\t@238\tNONAME\n+g_node_new\t@239\tNONAME\n+g_node_nth_child\t@240\tNONAME\n+g_object_add_weak_pointer\t@241\tNONAME\n+g_object_class_find_property\t@242\tNONAME\n+g_object_class_install_properties\t@243\tNONAME\n+g_object_class_install_property\t@244\tNONAME\n+g_object_class_list_properties\t@245\tNONAME\n+g_object_force_floating\t@246\tNONAME\n+g_object_freeze_notify\t@247\tNONAME\n+g_object_get\t@248\tNONAME\n+g_object_get_property\t@249\tNONAME\n+g_object_interface_install_property\t@250\tNONAME\n+g_object_is_floating\t@251\tNONAME\n+g_object_new\t@252\tNONAME\n+g_object_new_with_properties\t@253\tNONAME\n+g_object_notify\t@254\tNONAME\n+g_object_notify_by_pspec\t@255\tNONAME\n+g_object_ref\t@256\tNONAME\n+g_object_ref_sink\t@257\tNONAME\n+g_object_remove_weak_pointer\t@258\tNONAME\n+g_object_set\t@259\tNONAME\n+g_object_set_property\t@260\tNONAME\n+g_object_thaw_notify\t@261\tNONAME\n+g_object_unref\t@262\tNONAME\n+g_once_impl\t@263\tNONAME\n+g_once_init_enter\t@264\tNONAME\n+g_once_init_enter_pointer\t@265\tNONAME\n+g_once_init_leave\t@266\tNONAME\n+g_once_init_leave_pointer\t@267\tNONAME\n+g_option_group_ref\t@268\tNONAME\n+g_option_group_unref\t@269\tNONAME\n+g_param_spec_boolean\t@270\tNONAME\n+g_param_spec_boxed\t@271\tNONAME\n+g_param_spec_double\t@272\tNONAME\n+g_param_spec_enum\t@273\tNONAME\n+g_param_spec_flags\t@274\tNONAME\n+g_param_spec_float\t@275\tNONAME\n+g_param_spec_gtype\t@276\tNONAME\n+g_param_spec_int\t@277\tNONAME\n+g_param_spec_int64\t@278\tNONAME\n+g_param_spec_internal\t@279\tNONAME\n+g_param_spec_object\t@280\tNONAME\n+g_param_spec_ref\t@281\tNONAME\n+g_param_spec_sink\t@282\tNONAME\n+g_param_spec_string\t@283\tNONAME\n+g_param_spec_uint\t@284\tNONAME\n+g_param_spec_uint64\t@285\tNONAME\n+g_param_spec_unref\t@286\tNONAME\n+g_param_type_register_static\t@287\tNONAME\n+g_param_value_set_default\t@288\tNONAME\n+g_param_value_validate\t@289\tNONAME\n+g_param_values_cmp\t@290\tNONAME\n+g_path_get_basename\t@291\tNONAME\n+g_path_get_dirname\t@292\tNONAME\n+g_path_is_absolute\t@293\tNONAME\n+g_pointer_type_register_static\t@294\tNONAME\n+g_print\t@295\tNONAME\n+g_printerr\t@296\tNONAME\n+g_private_get\t@297\tNONAME\n+g_private_set\t@298\tNONAME\n+g_propagate_error\t@299\tNONAME\n+g_ptr_array_add\t@300\tNONAME\n+g_ptr_array_find_with_equal_func\t@301\tNONAME\n+g_ptr_array_foreach\t@302\tNONAME\n+g_ptr_array_free\t@303\tNONAME\n+g_ptr_array_new_full\t@304\tNONAME\n+g_ptr_array_new_with_free_func\t@305\tNONAME\n+g_ptr_array_remove_fast\t@306\tNONAME\n+g_ptr_array_remove_index\t@307\tNONAME\n+g_ptr_array_set_size\t@308\tNONAME\n+g_ptr_array_sized_new\t@309\tNONAME\n+g_ptr_array_sort\t@310\tNONAME\n+g_qsort_with_data\t@311\tNONAME\n+g_quark_from_static_string\t@312\tNONAME\n+g_quark_from_string\t@313\tNONAME\n+g_quark_to_string\t@314\tNONAME\n+g_quark_try_string\t@315\tNONAME\n+g_queue_clear\t@316\tNONAME\n+g_queue_clear_full\t@317\tNONAME\n+g_queue_delete_link\t@318\tNONAME\n+g_queue_find\t@319\tNONAME\n+g_queue_find_custom\t@320\tNONAME\n+g_queue_foreach\t@321\tNONAME\n+g_queue_free\t@322\tNONAME\n+g_queue_get_length\t@323\tNONAME\n+g_queue_init\t@324\tNONAME\n+g_queue_is_empty\t@325\tNONAME\n+g_queue_new\t@326\tNONAME\n+g_queue_peek_head\t@327\tNONAME\n+g_queue_peek_nth\t@328\tNONAME\n+g_queue_pop_head\t@329\tNONAME\n+g_queue_push_head\t@330\tNONAME\n+g_queue_push_tail\t@331\tNONAME\n+g_queue_remove\t@332\tNONAME\n+g_queue_sort\t@333\tNONAME\n+g_random_int\t@334\tNONAME\n+g_realloc\t@335\tNONAME\n+g_realloc_n\t@336\tNONAME\n+g_rec_mutex_clear\t@337\tNONAME\n+g_rec_mutex_init\t@338\tNONAME\n+g_rec_mutex_lock\t@339\tNONAME\n+g_rec_mutex_unlock\t@340\tNONAME\n+g_rename\t@341\tNONAME\n+g_rw_lock_init\t@342\tNONAME\n+g_rw_lock_reader_lock\t@343\tNONAME\n+g_rw_lock_reader_unlock\t@344\tNONAME\n+g_rw_lock_writer_lock\t@345\tNONAME\n+g_rw_lock_writer_unlock\t@346\tNONAME\n+g_set_error\t@347\tNONAME\n+g_set_error_literal\t@348\tNONAME\n+g_signal_connect_data\t@349\tNONAME\n+g_signal_emit\t@350\tNONAME\n+g_signal_handler_disconnect\t@351\tNONAME\n+g_signal_handlers_destroy\t@352\tNONAME\n+g_signal_handlers_disconnect_matched\t@353\tNONAME\n+g_signal_new\t@354\tNONAME\n+g_signal_new_class_handler\t@355\tNONAME\n+g_slice_alloc\t@356\tNONAME\n+g_slice_alloc0\t@357\tNONAME\n+g_slice_copy\t@358\tNONAME\n+g_slice_free1\t@359\tNONAME\n+g_slist_append\t@360\tNONAME\n+g_slist_concat\t@361\tNONAME\n+g_slist_delete_link\t@362\tNONAME\n+g_slist_foreach\t@363\tNONAME\n+g_slist_free\t@364\tNONAME\n+g_slist_insert_before\t@365\tNONAME\n+g_slist_prepend\t@366\tNONAME\n+g_slist_remove\t@367\tNONAME\n+g_slist_reverse\t@368\tNONAME\n+g_snprintf\t@369\tNONAME\n+g_source_add_poll\t@370\tNONAME\n+g_source_attach\t@371\tNONAME\n+g_source_destroy\t@372\tNONAME\n+g_source_new\t@373\tNONAME\n+g_source_ref\t@374\tNONAME\n+g_source_remove\t@375\tNONAME\n+g_source_set_callback\t@376\tNONAME\n+g_source_set_dispose_function\t@377\tNONAME\n+g_source_set_name\t@378\tNONAME\n+g_source_set_priority\t@379\tNONAME\n+g_source_unref\t@380\tNONAME\n+g_spawn_close_pid\t@381\tNONAME\n+g_stat\t@382\tNONAME\n+g_str_equal\t@383\tNONAME\n+g_str_has_prefix\t@384\tNONAME\n+g_str_has_suffix\t@385\tNONAME\n+g_str_hash\t@386\tNONAME\n+g_strchomp\t@387\tNONAME\n+g_strchug\t@388\tNONAME\n+g_strcmp0\t@389\tNONAME\n+g_strconcat\t@390\tNONAME\n+g_strdelimit\t@391\tNONAME\n+g_strdup\t@392\tNONAME\n+g_strdup_printf\t@393\tNONAME\n+g_strdup_value_contents\t@394\tNONAME\n+g_strdup_vprintf\t@395\tNONAME\n+g_strdupv\t@396\tNONAME\n+g_strerror\t@397\tNONAME\n+g_strfreev\t@398\tNONAME\n+g_string_append\t@399\tNONAME\n+g_string_append_len\t@400\tNONAME\n+g_string_append_printf\t@401\tNONAME\n+g_string_free\t@402\tNONAME\n+g_string_insert_c\t@403\tNONAME\n+g_string_insert_len\t@404\tNONAME\n+g_string_new\t@405\tNONAME\n+g_string_set_size\t@406\tNONAME\n+g_string_sized_new\t@407\tNONAME\n+g_string_truncate\t@408\tNONAME\n+g_strjoin\t@409\tNONAME\n+g_strlcat\t@410\tNONAME\n+g_strlcpy\t@411\tNONAME\n+g_strndup\t@412\tNONAME\n+g_strrstr\t@413\tNONAME\n+g_strsplit\t@414\tNONAME\n+g_strsplit_set\t@415\tNONAME\n+g_strstr_len\t@416\tNONAME\n+g_strtod\t@417\tNONAME\n+g_strv_get_type\t@418\tNONAME\n+g_strv_length\t@419\tNONAME\n+g_thread_get_type\t@420\tNONAME\n+g_thread_join\t@421\tNONAME\n+g_thread_new\t@422\tNONAME\n+g_thread_pool_free\t@423\tNONAME\n+g_thread_pool_new\t@424\tNONAME\n+g_thread_pool_push\t@425\tNONAME\n+g_thread_pool_set_max_threads\t@426\tNONAME\n+g_thread_pool_set_max_unused_threads\t@427\tNONAME\n+g_thread_self\t@428\tNONAME\n+g_thread_try_new\t@429\tNONAME\n+g_thread_yield\t@430\tNONAME\n+g_time_zone_new\t@431\tNONAME\n+g_time_zone_new_identifier\t@432\tNONAME\n+g_time_zone_unref\t@433\tNONAME\n+g_timeout_add_full\t@434\tNONAME\n+g_timer_destroy\t@435\tNONAME\n+g_timer_elapsed\t@436\tNONAME\n+g_timer_new\t@437\tNONAME\n+g_timer_start\t@438\tNONAME\n+g_tree_destroy\t@439\tNONAME\n+g_tree_insert\t@440\tNONAME\n+g_tree_new_with_data\t@441\tNONAME\n+g_tree_search\t@442\tNONAME\n+g_try_malloc\t@443\tNONAME\n+g_try_malloc0_n\t@444\tNONAME\n+g_try_malloc_n\t@445\tNONAME\n+g_try_realloc\t@446\tNONAME\n+g_try_realloc_n\t@447\tNONAME\n+g_type_add_class_private\t@448\tNONAME\n+g_type_add_instance_private\t@449\tNONAME\n+g_type_add_interface_static\t@450\tNONAME\n+g_type_check_class_cast\t@451\tNONAME\n+g_type_check_instance_cast\t@452\tNONAME\n+g_type_check_instance_is_a\t@453\tNONAME\n+g_type_check_instance_is_fundamentally_a\t@454\tNONAME\n+g_type_check_value\t@455\tNONAME\n+g_type_check_value_holds\t@456\tNONAME\n+g_type_class_add_private\t@457\tNONAME\n+g_type_class_adjust_private_offset\t@458\tNONAME\n+g_type_class_get_private\t@459\tNONAME\n+g_type_class_peek\t@460\tNONAME\n+g_type_class_peek_parent\t@461\tNONAME\n+g_type_class_ref\t@462\tNONAME\n+g_type_class_unref\t@463\tNONAME\n+g_type_from_name\t@464\tNONAME\n+g_type_fundamental\t@465\tNONAME\n+g_type_fundamental_next\t@466\tNONAME\n+g_type_get_qdata\t@467\tNONAME\n+g_type_init\t@468\tNONAME\n+g_type_instance_get_private\t@469\tNONAME\n+g_type_interface_add_prerequisite\t@470\tNONAME\n+g_type_interface_peek\t@471\tNONAME\n+g_type_interfaces\t@472\tNONAME\n+g_type_is_a\t@473\tNONAME\n+g_type_name\t@474\tNONAME\n+g_type_parent\t@475\tNONAME\n+g_type_qname\t@476\tNONAME\n+g_type_register_fundamental\t@477\tNONAME\n+g_type_register_static\t@478\tNONAME\n+g_type_register_static_simple\t@479\tNONAME\n+g_type_set_qdata\t@480\tNONAME\n+g_type_value_table_peek\t@481\tNONAME\n+g_unlink\t@482\tNONAME\n+g_uri_escape_string\t@483\tNONAME\n+g_uri_unescape_segment\t@484\tNONAME\n+g_uri_unescape_string\t@485\tNONAME\n+g_utf16_to_utf8\t@486\tNONAME\n+g_utf8_strchr\t@487\tNONAME\n+g_utf8_to_utf16\t@488\tNONAME\n+g_utf8_validate\t@489\tNONAME\n+g_value_array_append\t@490\tNONAME\n+g_value_array_get_nth\t@491\tNONAME\n+g_value_array_get_type\t@492\tNONAME\n+g_value_array_new\t@493\tNONAME\n+g_value_copy\t@494\tNONAME\n+g_value_dup_boxed\t@495\tNONAME\n+g_value_dup_object\t@496\tNONAME\n+g_value_dup_string\t@497\tNONAME\n+g_value_get_boolean\t@498\tNONAME\n+g_value_get_boxed\t@499\tNONAME\n+g_value_get_double\t@500\tNONAME\n+g_value_get_enum\t@501\tNONAME\n+g_value_get_flags\t@502\tNONAME\n+g_value_get_float\t@503\tNONAME\n+g_value_get_gtype\t@504\tNONAME\n+g_value_get_int\t@505\tNONAME\n+g_value_get_int64\t@506\tNONAME\n+g_value_get_long\t@507\tNONAME\n+g_value_get_object\t@508\tNONAME\n+g_value_get_pointer\t@509\tNONAME\n+g_value_get_string\t@510\tNONAME\n+g_value_get_uchar\t@511\tNONAME\n+g_value_get_uint\t@512\tNONAME\n+g_value_get_uint64\t@513\tNONAME\n+g_value_get_ulong\t@514\tNONAME\n+g_value_init\t@515\tNONAME\n+g_value_peek_pointer\t@516\tNONAME\n+g_value_register_transform_func\t@517\tNONAME\n+g_value_reset\t@518\tNONAME\n+g_value_set_boolean\t@519\tNONAME\n+g_value_set_boxed\t@520\tNONAME\n+g_value_set_double\t@521\tNONAME\n+g_value_set_enum\t@522\tNONAME\n+g_value_set_flags\t@523\tNONAME\n+g_value_set_float\t@524\tNONAME\n+g_value_set_gtype\t@525\tNONAME\n+g_value_set_int\t@526\tNONAME\n+g_value_set_int64\t@527\tNONAME\n+g_value_set_long\t@528\tNONAME\n+g_value_set_object\t@529\tNONAME\n+g_value_set_pointer\t@530\tNONAME\n+g_value_set_static_boxed\t@531\tNONAME\n+g_value_set_static_string\t@532\tNONAME\n+g_value_set_string\t@533\tNONAME\n+g_value_set_uchar\t@534\tNONAME\n+g_value_set_uint\t@535\tNONAME\n+g_value_set_uint64\t@536\tNONAME\n+g_value_set_ulong\t@537\tNONAME\n+g_value_take_boxed\t@538\tNONAME\n+g_value_take_object\t@539\tNONAME\n+g_value_take_string\t@540\tNONAME\n+g_value_transform\t@541\tNONAME\n+g_value_type_compatible\t@542\tNONAME\n+g_value_unset\t@543\tNONAME\n+g_vasprintf\t@544\tNONAME\n+g_warn_message\t@545\tNONAME\n+g_weak_ref_clear\t@546\tNONAME\n+g_weak_ref_get\t@547\tNONAME\n+g_weak_ref_init\t@548\tNONAME\n+g_weak_ref_set\t@549\tNONAME\n+g_win32_error_message\t@550\tNONAME\n+g_win32_get_package_installation_directory_of_module\t@551\tNONAME\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/win32\/vs100\/glib-lite.def","additions":507,"deletions":501,"binary":false,"changes":1008,"status":"modified"},{"patch":"@@ -122,2 +122,2 @@\n-#define GLIB_MINOR_VERSION 78\n-#define GLIB_MICRO_VERSION 1\n+#define GLIB_MINOR_VERSION 80\n+#define GLIB_MICRO_VERSION 4\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/win32\/vs100\/glibconfig.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-#ifndef G_OS_WIN32\n+#ifndef __GI_SCANNER__\n+# ifndef G_OS_WIN32\n@@ -147,1 +148,2 @@\n-#endif\n+# endif \/* !G_OS_WIN32 *\/\n+#endif \/* !__GI_SCANNER__ *\/\n@@ -171,0 +173,1 @@\n+#ifndef __GI_SCANNER__\n@@ -173,1 +176,1 @@\n-#ifdef G_OS_WIN32\n+# ifdef G_OS_WIN32\n@@ -175,1 +178,1 @@\n-#else\n+# else\n@@ -177,1 +180,1 @@\n-#endif\n+# endif \/* !G_OS_WIN32 *\/\n@@ -180,0 +183,1 @@\n+#endif \/* !__GI_SCANNER__ *\/\n@@ -295,1 +299,1 @@\n-                                         GTimeVal       *timeval);\n+                                         GTimeVal       *abs_time);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/deprecated\/gthread.h","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,125 +38,0 @@\n-\/**\n- * SECTION:arcbox\n- * @Title: Atomically reference counted data\n- * @Short_description: Allocated memory with atomic reference counting semantics\n- *\n- * An \"atomically reference counted box\", or \"ArcBox\", is an opaque wrapper\n- * data type that is guaranteed to be as big as the size of a given data type,\n- * and which augments the given data type with thread safe reference counting\n- * semantics for its memory management.\n- *\n- * ArcBox is useful if you have a plain old data type, like a structure\n- * typically placed on the stack, and you wish to provide additional API\n- * to use it on the heap; or if you want to implement a new type to be\n- * passed around by reference without necessarily implementing copy\/free\n- * semantics or your own reference counting.\n- *\n- * The typical use is:\n- *\n- * |[<!-- language=\"C\" -->\n- * typedef struct {\n- *   char *name;\n- *   char *address;\n- *   char *city;\n- *   char *state;\n- *   int age;\n- * } Person;\n- *\n- * Person *\n- * person_new (void)\n- * {\n- *   return g_atomic_rc_box_new0 (Person);\n- * }\n- * ]|\n- *\n- * Every time you wish to acquire a reference on the memory, you should\n- * call g_atomic_rc_box_acquire(); similarly, when you wish to release a reference\n- * you should call g_atomic_rc_box_release():\n- *\n- * |[<!-- language=\"C\" -->\n- * \/\/ Add a Person to the Database; the Database acquires ownership\n- * \/\/ of the Person instance\n- * void\n- * add_person_to_database (Database *db, Person *p)\n- * {\n- *   db->persons = g_list_prepend (db->persons, g_atomic_rc_box_acquire (p));\n- * }\n- *\n- * \/\/ Removes a Person from the Database; the reference acquired by\n- * \/\/ add_person_to_database() is released here\n- * void\n- * remove_person_from_database (Database *db, Person *p)\n- * {\n- *   db->persons = g_list_remove (db->persons, p);\n- *   g_atomic_rc_box_release (p);\n- * }\n- * ]|\n- *\n- * If you have additional memory allocated inside the structure, you can\n- * use g_atomic_rc_box_release_full(), which takes a function pointer, which\n- * will be called if the reference released was the last:\n- *\n- * |[<!-- language=\"C\" -->\n- * void\n- * person_clear (Person *p)\n- * {\n- *   g_free (p->name);\n- *   g_free (p->address);\n- *   g_free (p->city);\n- *   g_free (p->state);\n- * }\n- *\n- * void\n- * remove_person_from_database (Database *db, Person *p)\n- * {\n- *   db->persons = g_list_remove (db->persons, p);\n- *   g_atomic_rc_box_release_full (p, (GDestroyNotify) person_clear);\n- * }\n- * ]|\n- *\n- * If you wish to transfer the ownership of a reference counted data\n- * type without increasing the reference count, you can use g_steal_pointer():\n- *\n- * |[<!-- language=\"C\" -->\n- *   Person *p = g_atomic_rc_box_new (Person);\n- *\n- *   fill_person_details (p);\n- *\n- *   add_person_to_database (db, g_steal_pointer (&p));\n- * ]|\n- *\n- * ## Thread safety\n- *\n- * The reference counting operations on data allocated using g_atomic_rc_box_alloc(),\n- * g_atomic_rc_box_new(), and g_atomic_rc_box_dup() are guaranteed to be atomic, and thus\n- * can be safely be performed by different threads. It is important to note that\n- * only the reference acquisition and release are atomic; changes to the content\n- * of the data are your responsibility.\n- *\n- * ## Automatic pointer clean up\n- *\n- * If you want to add g_autoptr() support to your plain old data type through\n- * reference counting, you can use the G_DEFINE_AUTOPTR_CLEANUP_FUNC() and\n- * g_atomic_rc_box_release():\n- *\n- * |[<!-- language=\"C\" -->\n- * G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, g_atomic_rc_box_release)\n- * ]|\n- *\n- * If you need to clear the contents of the data, you will need to use an\n- * ancillary function that calls g_rc_box_release_full():\n- *\n- * |[<!-- language=\"C\" -->\n- * static void\n- * my_data_struct_release (MyDataStruct *data)\n- * {\n- *   \/\/ my_data_struct_clear() is defined elsewhere\n- *   g_atomic_rc_box_release_full (data, (GDestroyNotify) my_data_struct_clear);\n- * }\n- *\n- * G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, my_data_struct_release)\n- * ]|\n- *\n- * Since: 2.58\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/garcbox.c","additions":0,"deletions":125,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -50,47 +50,0 @@\n-\/**\n- * SECTION:arrays\n- * @title: Arrays\n- * @short_description: arrays of arbitrary elements which grow\n- *     automatically as elements are added\n- *\n- * Arrays are similar to standard C arrays, except that they grow\n- * automatically as elements are added.\n- *\n- * Array elements can be of any size (though all elements of one array\n- * are the same size), and the array can be automatically cleared to\n- * '0's and zero-terminated.\n- *\n- * To create a new array use g_array_new().\n- *\n- * To add elements to an array with a cost of O(n) at worst, use\n- * g_array_append_val(), g_array_append_vals(), g_array_prepend_val(),\n- * g_array_prepend_vals(), g_array_insert_val() and g_array_insert_vals().\n- *\n- * To access an element of an array in O(1) (to read it or to write it),\n- * use g_array_index().\n- *\n- * To set the size of an array, use g_array_set_size().\n- *\n- * To free an array, use g_array_unref() or g_array_free().\n- *\n- * All the sort functions are internally calling a quick-sort (or similar)\n- * function with an average cost of O(n log(n)) and a worst case\n- * cost of O(n^2).\n- *\n- * Here is an example that stores integers in a #GArray:\n- * |[<!-- language=\"C\" -->\n- *   GArray *garray;\n- *   gint i;\n- *   \/\/ We create a new array to store gint values.\n- *   \/\/ We don't want it zero-terminated or cleared to 0's.\n- *   garray = g_array_new (FALSE, FALSE, sizeof (gint));\n- *   for (i = 0; i < 10000; i++)\n- *     g_array_append_val (garray, i);\n- *   for (i = 0; i < 10000; i++)\n- *     if (g_array_index (garray, gint, i) != i)\n- *       g_print (\"ERROR: got %d instead of %d\\n\",\n- *                g_array_index (garray, gint, i), i);\n- *   g_array_free (garray, TRUE);\n- * ]|\n- *\/\n-\n@@ -933,0 +886,1 @@\n+  g_return_val_if_fail (index_ <= G_MAXUINT - length, NULL);\n@@ -1122,0 +1076,1 @@\n+      g_assert (want_alloc >= g_array_elt_len (array, want_len));\n@@ -1134,48 +1089,0 @@\n-\/**\n- * SECTION:arrays_pointer\n- * @title: Pointer Arrays\n- * @short_description: arrays of pointers to any type of data, which\n- *     grow automatically as new elements are added\n- *\n- * Pointer Arrays are similar to Arrays but are used only for storing\n- * pointers.\n- *\n- * If you remove elements from the array, elements at the end of the\n- * array are moved into the space previously occupied by the removed\n- * element. This means that you should not rely on the index of particular\n- * elements remaining the same. You should also be careful when deleting\n- * elements while iterating over the array.\n- *\n- * To create a pointer array, use g_ptr_array_new().\n- *\n- * To add elements to a pointer array, use g_ptr_array_add().\n- *\n- * To remove elements from a pointer array, use g_ptr_array_remove(),\n- * g_ptr_array_remove_index() or g_ptr_array_remove_index_fast().\n- *\n- * To access an element of a pointer array, use g_ptr_array_index().\n- *\n- * To set the size of a pointer array, use g_ptr_array_set_size().\n- *\n- * To free a pointer array, use g_ptr_array_free().\n- *\n- * An example using a #GPtrArray:\n- * |[<!-- language=\"C\" -->\n- *   GPtrArray *array;\n- *   gchar *string1 = \"one\";\n- *   gchar *string2 = \"two\";\n- *   gchar *string3 = \"three\";\n- *\n- *   array = g_ptr_array_new ();\n- *   g_ptr_array_add (array, (gpointer) string1);\n- *   g_ptr_array_add (array, (gpointer) string2);\n- *   g_ptr_array_add (array, (gpointer) string3);\n- *\n- *   if (g_ptr_array_index (array, 0) != (gpointer) string1)\n- *     g_print (\"ERROR: got %p instead of %p\\n\",\n- *              g_ptr_array_index (array, 0), string1);\n- *\n- *   g_ptr_array_free (array, TRUE);\n- * ]|\n- *\/\n-\n@@ -2205,0 +2112,1 @@\n+  g_return_val_if_fail (index_ <= G_MAXUINT - length, NULL);\n@@ -2782,39 +2690,0 @@\n-\/**\n- * SECTION:arrays_byte\n- * @title: Byte Arrays\n- * @short_description: arrays of bytes\n- *\n- * #GByteArray is a mutable array of bytes based on #GArray, to provide arrays\n- * of bytes which grow automatically as elements are added.\n- *\n- * To create a new #GByteArray use g_byte_array_new(). To add elements to a\n- * #GByteArray, use g_byte_array_append(), and g_byte_array_prepend().\n- *\n- * To set the size of a #GByteArray, use g_byte_array_set_size().\n- *\n- * To free a #GByteArray, use g_byte_array_free().\n- *\n- * An example for using a #GByteArray:\n- * |[<!-- language=\"C\" -->\n- *   GByteArray *gbarray;\n- *   gint i;\n- *\n- *   gbarray = g_byte_array_new ();\n- *   for (i = 0; i < 10000; i++)\n- *     g_byte_array_append (gbarray, (guint8*) \"abcd\", 4);\n- *\n- *   for (i = 0; i < 10000; i++)\n- *     {\n- *       g_assert (gbarray->data[4*i] == 'a');\n- *       g_assert (gbarray->data[4*i+1] == 'b');\n- *       g_assert (gbarray->data[4*i+2] == 'c');\n- *       g_assert (gbarray->data[4*i+3] == 'd');\n- *     }\n- *\n- *   g_byte_array_free (gbarray, TRUE);\n- * ]|\n- *\n- * See #GBytes if you are interested in an immutable object representing a\n- * sequence of bytes.\n- *\/\n-\n@@ -2916,1 +2785,1 @@\n- * Returns: the new #GByteArray\n+ * Returns: (transfer full): the new #GByteArray\n@@ -2980,1 +2849,1 @@\n- * Returns: The passed in #GByteArray\n+ * Returns: (transfer full): The passed in #GByteArray\n@@ -3016,1 +2885,1 @@\n- * Returns: the #GByteArray\n+ * Returns: (transfer none): the #GByteArray\n@@ -3037,1 +2906,1 @@\n- * Returns: the #GByteArray\n+ * Returns: (transfer none): the #GByteArray\n@@ -3056,1 +2925,1 @@\n- * Returns: the #GByteArray\n+ * Returns: (transfer none): the #GByteArray\n@@ -3075,1 +2944,1 @@\n- * Returns: the #GByteArray\n+ * Returns: (transfer none): the #GByteArray\n@@ -3096,1 +2965,1 @@\n- * Returns: the #GByteArray\n+ * Returns: (transfer none): the #GByteArray\n@@ -3116,1 +2985,1 @@\n- * Returns: the #GByteArray\n+ * Returns: (transfer none): the #GByteArray\n@@ -3127,0 +2996,1 @@\n+  g_return_val_if_fail (index_ <= G_MAXUINT - length, NULL);\n@@ -3135,1 +3005,1 @@\n- * @compare_func: comparison function\n+ * @compare_func: (scope call): comparison function\n@@ -3158,1 +3028,1 @@\n- * @compare_func: comparison function\n+ * @compare_func: (scope call): comparison function\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/garray.c","additions":14,"deletions":144,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -40,50 +40,0 @@\n-\n-\/**\n- * SECTION:async_queues\n- * @title: Asynchronous Queues\n- * @short_description: asynchronous communication between threads\n- * @see_also: #GThreadPool\n- *\n- * Often you need to communicate between different threads. In general\n- * it's safer not to do this by shared memory, but by explicit message\n- * passing. These messages only make sense asynchronously for\n- * multi-threaded applications though, as a synchronous operation could\n- * as well be done in the same thread.\n- *\n- * Asynchronous queues are an exception from most other GLib data\n- * structures, as they can be used simultaneously from multiple threads\n- * without explicit locking and they bring their own builtin reference\n- * counting. This is because the nature of an asynchronous queue is that\n- * it will always be used by at least 2 concurrent threads.\n- *\n- * For using an asynchronous queue you first have to create one with\n- * g_async_queue_new(). #GAsyncQueue structs are reference counted,\n- * use g_async_queue_ref() and g_async_queue_unref() to manage your\n- * references.\n- *\n- * A thread which wants to send a message to that queue simply calls\n- * g_async_queue_push() to push the message to the queue.\n- *\n- * A thread which is expecting messages from an asynchronous queue\n- * simply calls g_async_queue_pop() for that queue. If no message is\n- * available in the queue at that point, the thread is now put to sleep\n- * until a message arrives. The message will be removed from the queue\n- * and returned. The functions g_async_queue_try_pop() and\n- * g_async_queue_timeout_pop() can be used to only check for the presence\n- * of messages or to only wait a certain time for messages respectively.\n- *\n- * For almost every function there exist two variants, one that locks\n- * the queue and one that doesn't. That way you can hold the queue lock\n- * (acquire it with g_async_queue_lock() and release it with\n- * g_async_queue_unlock()) over multiple queue accessing instructions.\n- * This can be necessary to ensure the integrity of the queue, but should\n- * only be used when really necessary, as it can make your life harder\n- * if used unwisely. Normally you should only use the locking function\n- * variants (those without the _unlocked suffix).\n- *\n- * In many cases, it may be more convenient to use #GThreadPool when\n- * you need to distribute work to a set of worker threads instead of\n- * using #GAsyncQueue manually. #GThreadPool uses a GAsyncQueue\n- * internally.\n- *\/\n-\n@@ -114,1 +64,1 @@\n- * g_async_queue_new:\n+ * g_async_queue_new: (constructor)\n@@ -118,1 +68,1 @@\n- * Returns: a new #GAsyncQueue. Free with g_async_queue_unref()\n+ * Returns: (transfer full): a new #GAsyncQueue. Free with g_async_queue_unref()\n@@ -127,1 +77,1 @@\n- * g_async_queue_new_full:\n+ * g_async_queue_new_full: (constructor)\n@@ -134,1 +84,1 @@\n- * Returns: a new #GAsyncQueue. Free with g_async_queue_unref()\n+ * Returns: (transfer full): a new #GAsyncQueue. Free with g_async_queue_unref()\n@@ -161,1 +111,1 @@\n- * Returns: the @queue that was passed in (since 2.6)\n+ * Returns: (transfer full): the @queue that was passed in (since 2.6)\n@@ -215,1 +165,1 @@\n- * @queue: a #GAsyncQueue.\n+ * @queue: (transfer full): a #GAsyncQueue.\n@@ -329,1 +279,1 @@\n- * @func: the #GCompareDataFunc is used to sort @queue\n+ * @func: (scope call): the #GCompareDataFunc is used to sort @queue\n@@ -370,1 +320,1 @@\n- * @func: the #GCompareDataFunc is used to sort @queue\n+ * @func: (scope call): the #GCompareDataFunc is used to sort @queue\n@@ -725,1 +675,1 @@\n- * @func: the #GCompareDataFunc is used to sort @queue\n+ * @func: (scope call): the #GCompareDataFunc is used to sort @queue\n@@ -769,1 +719,1 @@\n- * @func: the #GCompareDataFunc is used to sort @queue\n+ * @func: (scope call): the #GCompareDataFunc is used to sort @queue\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gasyncqueue.c","additions":10,"deletions":60,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -26,43 +26,0 @@\n-\/**\n- * SECTION:atomic_operations\n- * @title: Atomic Operations\n- * @short_description: basic atomic integer and pointer operations\n- * @see_also: #GMutex\n- *\n- * The following is a collection of compiler macros to provide atomic\n- * access to integer and pointer-sized values.\n- *\n- * The macros that have 'int' in the name will operate on pointers to\n- * #gint and #guint.  The macros with 'pointer' in the name will operate\n- * on pointers to any pointer-sized value, including #gsize.  There is\n- * no support for 64bit operations on platforms with 32bit pointers\n- * because it is not generally possible to perform these operations\n- * atomically.\n- *\n- * The get, set and exchange operations for integers and pointers\n- * nominally operate on #gint and #gpointer, respectively.  Of the\n- * arithmetic operations, the 'add' operation operates on (and returns)\n- * signed integer values (#gint and #gssize) and the 'and', 'or', and\n- * 'xor' operations operate on (and return) unsigned integer values\n- * (#guint and #gsize).\n- *\n- * All of the operations act as a full compiler and (where appropriate)\n- * hardware memory barrier.  Acquire and release or producer and\n- * consumer barrier semantics are not available through this API.\n- *\n- * It is very important that all accesses to a particular integer or\n- * pointer be performed using only this API and that different sizes of\n- * operation are not mixed or used on overlapping memory regions.  Never\n- * read or assign directly from or to a value -- always use this API.\n- *\n- * For simple reference counting purposes you should use\n- * g_atomic_int_inc() and g_atomic_int_dec_and_test().  Other uses that\n- * fall outside of simple reference counting patterns are prone to\n- * subtle bugs and occasionally undefined behaviour.  It is also worth\n- * noting that since all of these operations require global\n- * synchronisation of the entire machine, they can be quite slow.  In\n- * the case of performing multiple atomic operations it can often be\n- * faster to simply acquire a mutex lock around the critical area,\n- * perform the operations normally and then release the lock.\n- **\/\n-\n@@ -541,0 +498,4 @@\n+ * In GLib 2.80, the return type was changed from #gssize to #gintptr to add\n+ * support for platforms with 128-bit pointers. This should not affect existing\n+ * code.\n+ *\n@@ -545,1 +506,1 @@\n-gssize\n+gintptr\n@@ -568,0 +529,4 @@\n+ * In GLib 2.80, the return type was changed from #gsize to #guintptr to add\n+ * support for platforms with 128-bit pointers. This should not affect existing\n+ * code.\n+ *\n@@ -572,1 +537,1 @@\n-gsize\n+guintptr\n@@ -595,0 +560,4 @@\n+ * In GLib 2.80, the return type was changed from #gsize to #guintptr to add\n+ * support for platforms with 128-bit pointers. This should not affect existing\n+ * code.\n+ *\n@@ -599,1 +568,1 @@\n-gsize\n+guintptr\n@@ -622,0 +591,4 @@\n+ * In GLib 2.80, the return type was changed from #gsize to #guintptr to add\n+ * support for platforms with 128-bit pointers. This should not affect existing\n+ * code.\n+ *\n@@ -626,1 +599,1 @@\n-gsize\n+guintptr\n@@ -823,1 +796,1 @@\n-gssize\n+gintptr\n@@ -834,1 +807,1 @@\n-gsize\n+guintptr\n@@ -845,1 +818,1 @@\n-gsize\n+guintptr\n@@ -856,1 +829,1 @@\n-gsize\n+guintptr\n@@ -1127,1 +1100,1 @@\n-gssize\n+gintptr\n@@ -1131,2 +1104,2 @@\n-  gssize *ptr = atomic;\n-  gssize oldval;\n+  gintptr *ptr = atomic;\n+  gintptr oldval;\n@@ -1142,1 +1115,1 @@\n-gsize\n+guintptr\n@@ -1146,2 +1119,2 @@\n-  gsize *ptr = atomic;\n-  gsize oldval;\n+  guintptr *ptr = atomic;\n+  guintptr oldval;\n@@ -1157,1 +1130,1 @@\n-gsize\n+guintptr\n@@ -1161,2 +1134,2 @@\n-  gsize *ptr = atomic;\n-  gsize oldval;\n+  guintptr *ptr = atomic;\n+  guintptr oldval;\n@@ -1172,1 +1145,1 @@\n-gsize\n+guintptr\n@@ -1176,2 +1149,2 @@\n-  gsize *ptr = atomic;\n-  gsize oldval;\n+  guintptr *ptr = atomic;\n+  guintptr oldval;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gatomic.c","additions":36,"deletions":63,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-gssize                  g_atomic_pointer_add                  (volatile void  *atomic,\n+gintptr                 g_atomic_pointer_add                  (volatile void  *atomic,\n@@ -89,1 +89,1 @@\n-gsize                   g_atomic_pointer_and                  (volatile void  *atomic,\n+guintptr                g_atomic_pointer_and                  (volatile void  *atomic,\n@@ -92,1 +92,1 @@\n-gsize                   g_atomic_pointer_or                   (volatile void  *atomic,\n+guintptr                g_atomic_pointer_or                   (volatile void  *atomic,\n@@ -95,1 +95,1 @@\n-gsize                   g_atomic_pointer_xor                  (volatile void  *atomic,\n+guintptr                g_atomic_pointer_xor                  (volatile void  *atomic,\n@@ -283,1 +283,1 @@\n-    (gssize) __atomic_fetch_add ((atomic), (val), __ATOMIC_SEQ_CST);         \\\n+    (gintptr) __atomic_fetch_add ((atomic), (val), __ATOMIC_SEQ_CST);        \\\n@@ -287,1 +287,1 @@\n-    gsize *gapa_atomic = (gsize *) (atomic);                                 \\\n+    guintptr *gapa_atomic = (guintptr *) (atomic);                           \\\n@@ -289,1 +289,1 @@\n-    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gsize));                    \\\n+    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (guintptr));                 \\\n@@ -292,1 +292,1 @@\n-    (gsize) __atomic_fetch_and (gapa_atomic, (val), __ATOMIC_SEQ_CST);       \\\n+    (guintptr) __atomic_fetch_and (gapa_atomic, (val), __ATOMIC_SEQ_CST);    \\\n@@ -296,1 +296,1 @@\n-    gsize *gapo_atomic = (gsize *) (atomic);                                 \\\n+    guintptr *gapo_atomic = (guintptr *) (atomic);                           \\\n@@ -298,1 +298,1 @@\n-    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gsize));                    \\\n+    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (guintptr));                 \\\n@@ -301,1 +301,1 @@\n-    (gsize) __atomic_fetch_or (gapo_atomic, (val), __ATOMIC_SEQ_CST);        \\\n+    (guintptr) __atomic_fetch_or (gapo_atomic, (val), __ATOMIC_SEQ_CST);     \\\n@@ -305,1 +305,1 @@\n-    gsize *gapx_atomic = (gsize *) (atomic);                                 \\\n+    guintptr *gapx_atomic = (guintptr *) (atomic);                           \\\n@@ -307,1 +307,1 @@\n-    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gsize));                    \\\n+    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (guintptr));                 \\\n@@ -310,1 +310,1 @@\n-    (gsize) __atomic_fetch_xor (gapx_atomic, (val), __ATOMIC_SEQ_CST);       \\\n+    (guintptr) __atomic_fetch_xor (gapx_atomic, (val), __ATOMIC_SEQ_CST);    \\\n@@ -377,1 +377,1 @@\n-    *(atomic) = (glib_typeof (*(atomic))) (gsize) (newval);                  \\\n+    *(atomic) = (glib_typeof (*(atomic))) (guintptr) (newval);               \\\n@@ -386,1 +386,1 @@\n-    *(atomic) = (gpointer) (gsize) (newval);                                         \\\n+    *(atomic) = (gpointer) (guintptr) (newval);                              \\\n@@ -501,1 +501,1 @@\n-    (gssize) __sync_fetch_and_add ((atomic), (val));                         \\\n+    (gintptr) __sync_fetch_and_add ((atomic), (val));                        \\\n@@ -508,1 +508,1 @@\n-    (gsize) __sync_fetch_and_and ((atomic), (val));                          \\\n+    (guintptr) __sync_fetch_and_and ((atomic), (val));                       \\\n@@ -515,1 +515,1 @@\n-    (gsize) __sync_fetch_and_or ((atomic), (val));                           \\\n+    (guintptr) __sync_fetch_and_or ((atomic), (val));                        \\\n@@ -522,1 +522,1 @@\n-    (gsize) __sync_fetch_and_xor ((atomic), (val));                          \\\n+    (guintptr) __sync_fetch_and_xor ((atomic), (val));                       \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gatomic.h","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -34,24 +34,0 @@\n-\n-\/**\n- * SECTION:base64\n- * @title: Base64 Encoding\n- * @short_description: encodes and decodes data in Base64 format\n- *\n- * Base64 is an encoding that allows a sequence of arbitrary bytes to be\n- * encoded as a sequence of printable ASCII characters. For the definition\n- * of Base64, see\n- * [RFC 1421](http:\/\/www.ietf.org\/rfc\/rfc1421.txt)\n- * or\n- * [RFC 2045](http:\/\/www.ietf.org\/rfc\/rfc2045.txt).\n- * Base64 is most commonly used as a MIME transfer encoding\n- * for email.\n- *\n- * GLib supports incremental encoding using g_base64_encode_step() and\n- * g_base64_encode_close(). Incremental decoding can be done with\n- * g_base64_decode_step(). To encode or decode data in one go, use\n- * g_base64_encode() or g_base64_decode(). To avoid memory allocation when\n- * decoding, you can use g_base64_decode_inplace().\n- *\n- * Support for Base64 encoding has been added in GLib 2.12.\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gbase64.c","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -183,0 +183,6 @@\n+G_ALWAYS_INLINE static inline guint\n+bit_lock_contended_class (gpointer address)\n+{\n+  return ((gsize) address) % G_N_ELEMENTS (g_bit_lock_contended);\n+}\n+\n@@ -235,1 +241,1 @@\n-        guint class = ((gsize) address_nonvolatile) % G_N_ELEMENTS (g_bit_lock_contended);\n+        guint class = bit_lock_contended_class (address_nonvolatile);\n@@ -252,1 +258,1 @@\n-      guint class = ((gsize) address_nonvolatile) % G_N_ELEMENTS (g_bit_lock_contended);\n+      guint class = bit_lock_contended_class (address_nonvolatile);\n@@ -345,0 +351,4 @@\n+  \/* Warning: unlocking may allow another thread to proceed and destroy the\n+   * memory that @address points to. We thus must not dereference it anymore.\n+   *\/\n+\n@@ -346,1 +356,1 @@\n-    guint class = ((gsize) address_nonvolatile) % G_N_ELEMENTS (g_bit_lock_contended);\n+    guint class = bit_lock_contended_class (address_nonvolatile);\n@@ -396,0 +406,25 @@\n+G_ALWAYS_INLINE static inline gpointer\n+pointer_bit_lock_mask_ptr (gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr)\n+{\n+  guintptr x_ptr;\n+  guintptr x_preserve_ptr;\n+  guintptr lock_mask;\n+\n+  x_ptr = (guintptr) ptr;\n+\n+  if (preserve_mask != 0)\n+    {\n+      x_preserve_ptr = (guintptr) preserve_ptr;\n+      x_ptr = (x_preserve_ptr & preserve_mask) | (x_ptr & ~preserve_mask);\n+    }\n+\n+  if (lock_bit == G_MAXUINT)\n+    return (gpointer) x_ptr;\n+\n+  lock_mask = (guintptr) (1u << lock_bit);\n+  if (set)\n+    return (gpointer) (x_ptr | lock_mask);\n+  else\n+    return (gpointer) (x_ptr & ~lock_mask);\n+}\n+\n@@ -397,1 +432,1 @@\n- * g_pointer_bit_lock:\n+ * g_pointer_bit_lock_and_get:\n@@ -400,0 +435,4 @@\n+ * @out_ptr: (out) (optional): returns the set pointer atomically.\n+ *   This is the value after setting the lock, it thus always has the\n+ *   lock bit set, while previously @address had the lockbit unset.\n+ *   You may also use g_pointer_bit_lock_mask_ptr() to clear the lock bit.\n@@ -407,4 +446,1 @@\n- * While @address has a `volatile` qualifier, this is a historical\n- * artifact and the argument passed to it should not be `volatile`.\n- *\n- * Since: 2.30\n+ * Since: 2.80\n@@ -413,2 +449,3 @@\n-(g_pointer_bit_lock) (volatile void *address,\n-                      gint           lock_bit)\n+(g_pointer_bit_lock_and_get) (gpointer address,\n+                              guint lock_bit,\n+                              guintptr *out_ptr)\n@@ -416,1 +453,3 @@\n-  void *address_nonvolatile = (void *) address;\n+  guint class = bit_lock_contended_class (address);\n+  guintptr mask;\n+  guintptr v;\n@@ -420,10 +459,1 @@\n-  {\n-#ifdef USE_ASM_GOTO\n- retry:\n-    __asm__ volatile goto (\"lock bts %1, (%0)\\n\"\n-                           \"jc %l[contended]\"\n-                           : \/* no output *\/\n-                           : \"r\" (address), \"r\" ((gsize) lock_bit)\n-                           : \"cc\", \"memory\"\n-                           : contended);\n-    return;\n+  mask = 1u << lock_bit;\n@@ -431,1 +461,2 @@\n- contended:\n+#ifdef USE_ASM_GOTO\n+  if (G_LIKELY (!out_ptr))\n@@ -433,6 +464,1 @@\n-      gsize *pointer_address = address_nonvolatile;\n-      gsize mask = 1u << lock_bit;\n-      gsize v;\n-\n-      v = (gsize) g_atomic_pointer_get (pointer_address);\n-      if (v & mask)\n+      while (TRUE)\n@@ -440,5 +466,16 @@\n-          guint class = ((gsize) address_nonvolatile) % G_N_ELEMENTS (g_bit_lock_contended);\n-\n-          g_atomic_int_add (&g_bit_lock_contended[class], +1);\n-          g_futex_wait (g_futex_int_address (address_nonvolatile), v);\n-          g_atomic_int_add (&g_bit_lock_contended[class], -1);\n+          __asm__ volatile goto (\"lock bts %1, (%0)\\n\"\n+                                 \"jc %l[contended]\"\n+                                 : \/* no output *\/\n+                                 : \"r\"(address), \"r\"((gsize) lock_bit)\n+                                 : \"cc\", \"memory\"\n+                                 : contended);\n+          return;\n+\n+        contended:\n+          v = (guintptr) g_atomic_pointer_get ((gpointer *) address);\n+          if (v & mask)\n+            {\n+              g_atomic_int_add (&g_bit_lock_contended[class], +1);\n+              g_futex_wait (g_futex_int_address (address), v);\n+              g_atomic_int_add (&g_bit_lock_contended[class], -1);\n+            }\n@@ -447,5 +484,1 @@\n-    goto retry;\n-#else\n-  gsize *pointer_address = address_nonvolatile;\n-  gsize mask = 1u << lock_bit;\n-  gsize v;\n+#endif\n@@ -453,2 +486,2 @@\n- retry:\n-  v = g_atomic_pointer_or (pointer_address, mask);\n+retry:\n+  v = g_atomic_pointer_or ((gpointer *) address, mask);\n@@ -458,2 +491,0 @@\n-      guint class = ((gsize) address_nonvolatile) % G_N_ELEMENTS (g_bit_lock_contended);\n-\n@@ -461,1 +492,1 @@\n-      g_futex_wait (g_futex_int_address (address_nonvolatile), (guint) v);\n+      g_futex_wait (g_futex_int_address (address), (guint) v);\n@@ -463,1 +494,0 @@\n-\n@@ -466,2 +496,26 @@\n-#endif\n-  }\n+\n+  if (out_ptr)\n+    *out_ptr = (v | mask);\n+}\n+\n+\/**\n+ * g_pointer_bit_lock:\n+ * @address: (not nullable): a pointer to a #gpointer-sized value\n+ * @lock_bit: a bit value between 0 and 31\n+ *\n+ * This is equivalent to g_bit_lock, but working on pointers (or other\n+ * pointer-sized values).\n+ *\n+ * For portability reasons, you may only lock on the bottom 32 bits of\n+ * the pointer.\n+ *\n+ * While @address has a `volatile` qualifier, this is a historical\n+ * artifact and the argument passed to it should not be `volatile`.\n+ *\n+ * Since: 2.30\n+ **\/\n+void\n+(g_pointer_bit_lock) (volatile void *address,\n+                      gint lock_bit)\n+{\n+  g_pointer_bit_lock_and_get ((gpointer *) address, (guint) lock_bit, NULL);\n@@ -508,1 +562,1 @@\n-    gsize *pointer_address = address_nonvolatile;\n+    gpointer *pointer_address = address_nonvolatile;\n@@ -510,1 +564,1 @@\n-    gsize v;\n+    guintptr v;\n@@ -516,1 +570,1 @@\n-    return ~v & mask;\n+    return (~(gsize) v & mask) != 0;\n@@ -552,1 +606,1 @@\n-    gsize *pointer_address = address_nonvolatile;\n+    gpointer *pointer_address = address_nonvolatile;\n@@ -558,0 +612,4 @@\n+    \/* Warning: unlocking may allow another thread to proceed and destroy the\n+     * memory that @address points to. We thus must not dereference it anymore.\n+     *\/\n+\n@@ -559,1 +617,2 @@\n-      guint class = ((gsize) address_nonvolatile) % G_N_ELEMENTS (g_bit_lock_contended);\n+      guint class = bit_lock_contended_class (address_nonvolatile);\n+\n@@ -565,0 +624,87 @@\n+\n+\/**\n+ * g_pointer_bit_lock_mask_ptr:\n+ * @ptr: (nullable): the pointer to mask\n+ * @lock_bit: the bit to set\/clear. If set to `G_MAXUINT`, the\n+ *   lockbit is taken from @preserve_ptr or @ptr (depending on @preserve_mask).\n+ * @set: whether to set (lock) the bit or unset (unlock). This\n+ *   has no effect, if @lock_bit is set to `G_MAXUINT`.\n+ * @preserve_mask: if non-zero, a bit-mask for @preserve_ptr. The\n+ *   @preserve_mask bits from @preserve_ptr are set in the result.\n+ *   Note that the @lock_bit bit will be always set according to @set,\n+ *   regardless of @preserve_mask and @preserve_ptr (unless @lock_bit is\n+ *   `G_MAXUINT`).\n+ * @preserve_ptr: (nullable): if @preserve_mask is non-zero, the bits\n+ *   from this pointer are set in the result.\n+ *\n+ * This mangles @ptr as g_pointer_bit_lock() and g_pointer_bit_unlock()\n+ * do.\n+ *\n+ * Returns: the mangled pointer.\n+ *\n+ * Since: 2.80\n+ **\/\n+gpointer\n+g_pointer_bit_lock_mask_ptr (gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr)\n+{\n+  g_return_val_if_fail (lock_bit < 32u || lock_bit == G_MAXUINT, ptr);\n+\n+  return pointer_bit_lock_mask_ptr (ptr, lock_bit, set, preserve_mask, preserve_ptr);\n+}\n+\n+\/**\n+ * g_pointer_bit_unlock_and_set:\n+ * @address: (not nullable): a pointer to a #gpointer-sized value\n+ * @lock_bit: a bit value between 0 and 31\n+ * @ptr: the new pointer value to set\n+ * @preserve_mask: if non-zero, those bits of the current pointer in @address\n+ *   are preserved.\n+ *   Note that the @lock_bit bit will be always set according to @set,\n+ *   regardless of @preserve_mask and the currently set value in @address.\n+ *\n+ * This is equivalent to g_pointer_bit_unlock() and atomically setting\n+ * the pointer value.\n+ *\n+ * Note that the lock bit will be cleared from the pointer. If the unlocked\n+ * pointer that was set is not identical to @ptr, an assertion fails. In other\n+ * words, @ptr must have @lock_bit unset. This also means, you usually can\n+ * only use this on the lowest bits.\n+ *\n+ * Since: 2.80\n+ **\/\n+void (g_pointer_bit_unlock_and_set) (void *address,\n+                                     guint lock_bit,\n+                                     gpointer ptr,\n+                                     guintptr preserve_mask)\n+{\n+  gpointer *pointer_address = address;\n+  guint class = bit_lock_contended_class (address);\n+  gpointer ptr2;\n+\n+  g_return_if_fail (lock_bit < 32u);\n+\n+  if (preserve_mask != 0)\n+    {\n+      gpointer old_ptr = g_atomic_pointer_get ((gpointer *) address);\n+\n+    again:\n+      ptr2 = pointer_bit_lock_mask_ptr (ptr, lock_bit, FALSE, preserve_mask, old_ptr);\n+      if (!g_atomic_pointer_compare_and_exchange_full (pointer_address, old_ptr, ptr2, &old_ptr))\n+        goto again;\n+    }\n+  else\n+    {\n+      ptr2 = pointer_bit_lock_mask_ptr (ptr, lock_bit, FALSE, 0, NULL);\n+      g_atomic_pointer_set (pointer_address, ptr2);\n+    }\n+\n+  if (g_atomic_int_get (&g_bit_lock_contended[class]) > 0)\n+    g_futex_wake (g_futex_int_address (address));\n+\n+  \/* It makes no sense, if unlocking mangles the pointer. Assert against\n+   * that.\n+   *\n+   * Note that based on @preserve_mask, the pointer also gets mangled, which\n+   * can make sense for the caller. We don't assert for that. *\/\n+  g_return_if_fail (ptr == pointer_bit_lock_mask_ptr (ptr, lock_bit, FALSE, 0, NULL));\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gbitlock.c","additions":197,"deletions":51,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+\n+GLIB_AVAILABLE_IN_2_80\n+void      g_pointer_bit_lock_and_get      (gpointer address,\n+                                           guint lock_bit,\n+                                           guintptr *out_ptr);\n+\n@@ -54,0 +60,13 @@\n+GLIB_AVAILABLE_IN_2_80\n+gpointer  g_pointer_bit_lock_mask_ptr     (gpointer ptr,\n+                                           guint lock_bit,\n+                                           gboolean set,\n+                                           guintptr preserve_mask,\n+                                           gpointer preserve_ptr);\n+\n+GLIB_AVAILABLE_IN_2_80\n+void g_pointer_bit_unlock_and_set         (void *address,\n+                                           guint lock_bit,\n+                                           gpointer ptr,\n+                                           guintptr preserve_mask);\n+\n@@ -62,0 +81,6 @@\n+#define g_pointer_bit_lock_and_get(address, lock_bit, out_ptr)     \\\n+  (G_GNUC_EXTENSION ({                                             \\\n+    G_STATIC_ASSERT (sizeof *(address) == sizeof (gpointer));      \\\n+    g_pointer_bit_lock_and_get ((address), (lock_bit), (out_ptr)); \\\n+  }))\n+\n@@ -74,0 +99,6 @@\n+#define g_pointer_bit_unlock_and_set(address, lock_bit, ptr, preserve_mask)       \\\n+  (G_GNUC_EXTENSION ({                                                            \\\n+    G_STATIC_ASSERT (sizeof *(address) == sizeof (gpointer));                     \\\n+    g_pointer_bit_unlock_and_set ((address), (lock_bit), (ptr), (preserve_mask)); \\\n+  }))\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gbitlock.h","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-  if (g_once_init_enter (&alias_table))\n+  if (g_once_init_enter_pointer (&alias_table))\n@@ -507,1 +507,1 @@\n-      g_once_init_leave (&alias_table, table);\n+      g_once_init_leave_pointer (&alias_table, table);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gcharset.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,3 +36,1 @@\n- * SECTION:checksum\n- * @title: Data Checksums\n- * @short_description: computes the checksum for data\n+ * GChecksum:\n@@ -40,1 +38,1 @@\n- * GLib provides a generic API for computing checksums (or \"digests\")\n+ * GLib provides a generic API for computing checksums (or ‘digests’)\n@@ -45,8 +43,2 @@\n- * GLib supports incremental checksums using the GChecksum data\n- * structure, by calling g_checksum_update() as long as there's data\n- * available and then using g_checksum_get_string() or\n- * g_checksum_get_digest() to compute the checksum and return it either\n- * as a string in hexadecimal form, or as a raw sequence of bytes. To\n- * compute the checksum for binary blobs and NUL-terminated strings in\n- * one go, use the convenience functions g_compute_checksum_for_data()\n- * and g_compute_checksum_for_string(), respectively.\n+ * To create a new `GChecksum`, use [ctor@GLib.Checksum.new]. To free\n+ * a `GChecksum`, use [method@GLib.Checksum.free].\n@@ -54,1 +46,10 @@\n- * Support for checksums has been added in GLib 2.16\n+ * GLib supports incremental checksums using the `GChecksum` data\n+ * structure, by calling [method@GLib.Checksum.update] as long as there’s data\n+ * available and then using [method@GLib.Checksum.get_string] or\n+ * [method@GLib.Checksum.get_digest] to compute the checksum and return it\n+ * either as a string in hexadecimal form, or as a raw sequence of bytes. To\n+ * compute the checksum for binary blobs and nul-terminated strings in\n+ * one go, use the convenience functions [func@GLib.compute_checksum_for_data]\n+ * and [func@GLib.compute_checksum_for_string], respectively.\n+ *\n+ * Since: 2.16\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gchecksum.c","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -57,10 +57,0 @@\n-\/**\n- * GChecksum:\n- *\n- * An opaque structure representing a checksumming operation.\n- *\n- * To create a new GChecksum, use g_checksum_new(). To free\n- * a GChecksum, use g_checksum_free().\n- *\n- * Since: 2.16\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gchecksum.h","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-#elif defined (_MSC_VER) && (_MSC_VER >= 1500)\n-\/* Visual studio 2008 and later has _Pragma *\/\n+#elif defined (_MSC_VER)\n@@ -113,22 +112,0 @@\n-#elif defined (_MSC_VER)\n-\n-#define G_HAS_CONSTRUCTORS 1\n-\n-\/* Pre Visual studio 2008 must use #pragma section *\/\n-#define G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA 1\n-#define G_DEFINE_DESTRUCTOR_NEEDS_PRAGMA 1\n-\n-#define G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(_func) \\\n-  section(\".CRT$XCU\",read)\n-#define G_DEFINE_CONSTRUCTOR(_func) \\\n-  static void _func(void); \\\n-  static int _func ## _wrapper(void) { _func(); return 0; } \\\n-  __declspec(allocate(\".CRT$XCU\")) static int (*p)(void) = _func ## _wrapper;\n-\n-#define G_DEFINE_DESTRUCTOR_PRAGMA_ARGS(_func) \\\n-  section(\".CRT$XCU\",read)\n-#define G_DEFINE_DESTRUCTOR(_func) \\\n-  static void _func(void); \\\n-  static int _func ## _constructor(void) { atexit (_func); return 0; } \\\n-  __declspec(allocate(\".CRT$XCU\")) static int (* _array ## _func)(void) = _func ## _constructor;\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gconstructor.h","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright © 2023 Luca Bacci\n+ *\n+ * SPDX-License-Identifier: LGPL-2.1-or-later\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n+ *\/\n+\n+#include \"gconstructor.h\"\n+\n+#ifdef _WIN32\n+#include <windows.h>\n+#endif\n+\n+#ifdef _WIN32\n+\n+#ifdef __cplusplus\n+\/* const defaults to static (internal visibility) in C++,\n+ * but we want extern instead *\/\n+#define G_EXTERN_CONST extern const\n+#else\n+\/* Using extern const in C is perfectly valid, but triggers\n+ * a warning in GCC and CLANG, therefore we avoid it *\/\n+#define G_EXTERN_CONST const\n+#endif\n+\n+#ifdef _MSC_VER\n+\n+#define G_HAS_TLS_CALLBACKS 1\n+\n+#define G_DEFINE_TLS_CALLBACK(func) \\\n+__pragma (section (\".CRT$XLCE\", long, read))                                \\\n+                                                                            \\\n+static void NTAPI func (PVOID, DWORD, PVOID);                               \\\n+                                                                            \\\n+G_BEGIN_DECLS                                                               \\\n+__declspec (allocate (\".CRT$XLCE\"))                                         \\\n+G_EXTERN_CONST PIMAGE_TLS_CALLBACK _ptr_##func = func;                      \\\n+G_END_DECLS                                                                 \\\n+                                                                            \\\n+__pragma (comment (linker, \"\/INCLUDE:\" G_MSVC_SYMBOL_PREFIX \"_tls_used\"))   \\\n+__pragma (comment (linker, \"\/INCLUDE:\" G_MSVC_SYMBOL_PREFIX \"_ptr_\" #func))\n+\n+#else\n+\n+#define G_HAS_TLS_CALLBACKS 1\n+\n+#define G_DEFINE_TLS_CALLBACK(func) \\\n+static void NTAPI func (PVOID, DWORD, PVOID);          \\\n+                                                       \\\n+G_BEGIN_DECLS                                          \\\n+__attribute__ ((section (\".CRT$XLCE\")))                \\\n+G_EXTERN_CONST PIMAGE_TLS_CALLBACK _ptr_##func = func; \\\n+G_END_DECLS\n+\n+#endif \/* _MSC_VER *\/\n+\n+#endif \/* _WIN32 *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gconstructorprivate.h","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -59,99 +59,0 @@\n-\/**\n- * SECTION:conversions\n- * @title: Character Set Conversion\n- * @short_description: convert strings between different character sets\n- *\n- * The g_convert() family of function wraps the functionality of iconv().\n- * In addition to pure character set conversions, GLib has functions to\n- * deal with the extra complications of encodings for file names.\n- *\n- * ## File Name Encodings\n- *\n- * Historically, UNIX has not had a defined encoding for file names:\n- * a file name is valid as long as it does not have path separators\n- * in it (\"\/\"). However, displaying file names may require conversion:\n- * from the character set in which they were created, to the character\n- * set in which the application operates. Consider the Spanish file name\n- * \"Presentacion.sxi\". If the application which created it uses\n- * ISO-8859-1 for its encoding,\n- * |[\n- * Character:  P  r  e  s  e  n  t  a  c  i  o  n  .  s  x  i\n- * Hex code:   50 72 65 73 65 6e 74 61 63 69 f3 6e 2e 73 78 69\n- * ]|\n- * However, if the application use UTF-8, the actual file name on\n- * disk would look like this:\n- * |[\n- * Character:  P  r  e  s  e  n  t  a  c  i  o  n  .  s  x  i\n- * Hex code:   50 72 65 73 65 6e 74 61 63 69 c3 b3 6e 2e 73 78 69\n- * ]|\n- * GLib uses UTF-8 for its strings, and GUI toolkits like GTK that use\n- * GLib do the same thing. If you get a file name from the file system,\n- * for example, from readdir() or from g_dir_read_name(), and you wish\n- * to display the file name to the user, you  will need to convert it\n- * into UTF-8. The opposite case is when the user types the name of a\n- * file they wish to save: the toolkit will give you that string in\n- * UTF-8 encoding, and you will need to convert it to the character\n- * set used for file names before you can create the file with open()\n- * or fopen().\n- *\n- * By default, GLib assumes that file names on disk are in UTF-8\n- * encoding. This is a valid assumption for file systems which\n- * were created relatively recently: most applications use UTF-8\n- * encoding for their strings, and that is also what they use for\n- * the file names they create. However, older file systems may\n- * still contain file names created in \"older\" encodings, such as\n- * ISO-8859-1. In this case, for compatibility reasons, you may want\n- * to instruct GLib to use that particular encoding for file names\n- * rather than UTF-8. You can do this by specifying the encoding for\n- * file names in the [`G_FILENAME_ENCODING`][G_FILENAME_ENCODING]\n- * environment variable. For example, if your installation uses\n- * ISO-8859-1 for file names, you can put this in your `~\/.profile`:\n- * |[\n- * export G_FILENAME_ENCODING=ISO-8859-1\n- * ]|\n- * GLib provides the functions g_filename_to_utf8() and\n- * g_filename_from_utf8() to perform the necessary conversions.\n- * These functions convert file names from the encoding specified\n- * in `G_FILENAME_ENCODING` to UTF-8 and vice-versa. This\n- * [diagram][file-name-encodings-diagram] illustrates how\n- * these functions are used to convert between UTF-8 and the\n- * encoding for file names in the file system.\n- *\n- * ## Conversion between file name encodings # {#file-name-encodings-diagram)\n- *\n- * ![](file-name-encodings.png)\n- *\n- * ## Checklist for Application Writers\n- *\n- * This section is a practical summary of the detailed\n- * things to do to make sure your applications process file\n- * name encodings correctly.\n- *\n- * 1. If you get a file name from the file system from a function\n- *    such as readdir() or gtk_file_chooser_get_filename(), you do\n- *    not need to do any conversion to pass that file name to\n- *    functions like open(), rename(), or fopen() -- those are \"raw\"\n- *    file names which the file system understands.\n- *\n- * 2. If you need to display a file name, convert it to UTF-8 first\n- *    by using g_filename_to_utf8(). If conversion fails, display a\n- *    string like \"Unknown file name\". Do not convert this string back\n- *    into the encoding used for file names if you wish to pass it to\n- *    the file system; use the original file name instead.\n- *\n- *    For example, the document window of a word processor could display\n- *    \"Unknown file name\" in its title bar but still let the user save\n- *    the file, as it would keep the raw file name internally. This\n- *    can happen if the user has not set the `G_FILENAME_ENCODING`\n- *    environment variable even though they have files whose names are\n- *    not encoded in UTF-8.\n- *\n- * 3. If your user interface lets the user type a file name for saving\n- *    or renaming, convert it to the encoding used for file names in\n- *    the file system by using g_filename_from_utf8(). Pass the converted\n- *    file name to functions like fopen(). If conversion fails, ask the\n- *    user to enter a different file name. This can happen if the user\n- *    types Japanese characters when `G_FILENAME_ENCODING` is set to\n- *    `ISO-8859-1`, for example.\n- *\/\n-\n@@ -175,1 +76,10 @@\n-  else\n+\n+#if defined(__FreeBSD__) && defined(ICONV_SET_ILSEQ_INVALID)\n+  \/* On FreeBSD request GNU iconv compatible handling of characters that cannot\n+   * be repesented in the destination character set.\n+   * See https:\/\/cgit.freebsd.org\/src\/commit\/?id=7c5b23111c5fd1992047922d4247c4a1ce1bb6c3\n+   *\/\n+  int value = 1;\n+  if (iconvctl (*cd, ICONV_SET_ILSEQ_INVALID, &value) != 0)\n+    return FALSE;\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gconvert.c","additions":10,"deletions":100,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gutilsprivate.h\"\n@@ -51,73 +52,0 @@\n-\/**\n- * SECTION:datasets\n- * @title: Datasets\n- * @short_description: associate groups of data elements with\n- *                     particular memory locations\n- *\n- * Datasets associate groups of data elements with particular memory\n- * locations. These are useful if you need to associate data with a\n- * structure returned from an external library. Since you cannot modify\n- * the structure, you use its location in memory as the key into a\n- * dataset, where you can associate any number of data elements with it.\n- *\n- * There are two forms of most of the dataset functions. The first form\n- * uses strings to identify the data elements associated with a\n- * location. The second form uses #GQuark identifiers, which are\n- * created with a call to g_quark_from_string() or\n- * g_quark_from_static_string(). The second form is quicker, since it\n- * does not require looking up the string in the hash table of #GQuark\n- * identifiers.\n- *\n- * There is no function to create a dataset. It is automatically\n- * created as soon as you add elements to it.\n- *\n- * To add data elements to a dataset use g_dataset_id_set_data(),\n- * g_dataset_id_set_data_full(), g_dataset_set_data() and\n- * g_dataset_set_data_full().\n- *\n- * To get data elements from a dataset use g_dataset_id_get_data() and\n- * g_dataset_get_data().\n- *\n- * To iterate over all data elements in a dataset use\n- * g_dataset_foreach() (not thread-safe).\n- *\n- * To remove data elements from a dataset use\n- * g_dataset_id_remove_data() and g_dataset_remove_data().\n- *\n- * To destroy a dataset, use g_dataset_destroy().\n- **\/\n-\n-\/**\n- * SECTION:datalist\n- * @title: Keyed Data Lists\n- * @short_description: lists of data elements which are accessible by a\n- *                     string or GQuark identifier\n- *\n- * Keyed data lists provide lists of arbitrary data elements which can\n- * be accessed either with a string or with a #GQuark corresponding to\n- * the string.\n- *\n- * The #GQuark methods are quicker, since the strings have to be\n- * converted to #GQuarks anyway.\n- *\n- * Data lists are used for associating arbitrary data with #GObjects,\n- * using g_object_set_data() and related functions.\n- *\n- * To create a datalist, use g_datalist_init().\n- *\n- * To add data elements to a datalist use g_datalist_id_set_data(),\n- * g_datalist_id_set_data_full(), g_datalist_set_data() and\n- * g_datalist_set_data_full().\n- *\n- * To get data elements from a datalist use g_datalist_id_get_data()\n- * and g_datalist_get_data().\n- *\n- * To iterate over all data elements in a datalist use\n- * g_datalist_foreach() (not thread-safe).\n- *\n- * To remove data elements from a datalist use\n- * g_datalist_id_remove_data() and g_datalist_remove_data().\n- *\n- * To remove all data elements from a datalist, use g_datalist_clear().\n- **\/\n-\n@@ -129,1 +57,1 @@\n- * See also: [Keyed data lists][glib-Keyed-Data-Lists].\n+ * See also: [Keyed data lists](datalist-and-dataset.html).\n@@ -143,0 +71,3 @@\n+#define G_DATALIST_CLEAN_POINTER(ptr) \\\n+  ((GData *) ((gpointer) (((guintptr) (ptr)) & ~((guintptr) G_DATALIST_FLAGS_MASK_INTERNAL))))\n+\n@@ -144,2 +75,2 @@\n-#define G_DATALIST_GET_POINTER(datalist)            \\\n-  ((GData*) ((gsize) g_atomic_pointer_get (datalist) & ~(gsize) G_DATALIST_FLAGS_MASK_INTERNAL))\n+#define G_DATALIST_GET_POINTER(datalist) \\\n+  G_DATALIST_CLEAN_POINTER (g_atomic_pointer_get (datalist))\n@@ -151,1 +82,1 @@\n-    _newv = (gpointer) (((gsize) _oldv & G_DATALIST_FLAGS_MASK_INTERNAL) | (gsize) pointer);     \\\n+    _newv = (gpointer) (((guintptr) _oldv & ((guintptr) G_DATALIST_FLAGS_MASK_INTERNAL)) | (guintptr) pointer); \\\n@@ -180,1 +111,0 @@\n-static inline void  g_datalist_clear_i    (GData    **datalist);\n@@ -210,2 +140,2 @@\n-static void\n-g_datalist_lock (GData **datalist)\n+G_ALWAYS_INLINE static inline GData *\n+g_datalist_lock_and_get (GData **datalist)\n@@ -213,1 +143,4 @@\n-  g_pointer_bit_lock ((void **)datalist, DATALIST_LOCK_BIT);\n+  guintptr ptr;\n+\n+  g_pointer_bit_lock_and_get ((void **) datalist, DATALIST_LOCK_BIT, &ptr);\n+  return G_DATALIST_CLEAN_POINTER (ptr);\n@@ -222,3 +155,0 @@\n-\/* Called with the datalist lock held, or the dataset global\n- * lock for dataset lists\n- *\/\n@@ -226,1 +156,1 @@\n-g_datalist_clear_i (GData **datalist)\n+g_datalist_unlock_and_set (GData **datalist, gpointer ptr)\n@@ -228,2 +158,118 @@\n-  GData *data;\n-  guint i;\n+  g_pointer_bit_unlock_and_set ((void **) datalist, DATALIST_LOCK_BIT, ptr, G_DATALIST_FLAGS_MASK_INTERNAL);\n+}\n+\n+static gboolean\n+datalist_append (GData **data, GQuark key_id, gpointer new_data, GDestroyNotify destroy_func)\n+{\n+  gboolean reallocated;\n+  GData *d;\n+\n+  d = *data;\n+  if (!d)\n+    {\n+      d = g_malloc (G_STRUCT_OFFSET (GData, data) + 2u * sizeof (GDataElt));\n+      d->len = 0;\n+      d->alloc = 2u;\n+      *data = d;\n+      reallocated = TRUE;\n+    }\n+  else if (d->len == d->alloc)\n+    {\n+      d->alloc = d->alloc * 2u;\n+#if G_ENABLE_DEBUG\n+      \/* d->alloc is always a power of two. It thus overflows the first time\n+       * when going to (G_MAXUINT32+1), or when requesting 2^31+1 elements.\n+       *\n+       * This is not handled, and we just crash. That's because we track the GData\n+       * in a linear list, which horribly degrades long before we add 2 billion entries.\n+       * Don't ever try to do that. *\/\n+      g_assert (d->alloc > d->len);\n+#endif\n+      d = g_realloc (d, G_STRUCT_OFFSET (GData, data) + d->alloc * sizeof (GDataElt));\n+      *data = d;\n+      reallocated = TRUE;\n+    }\n+  else\n+    reallocated = FALSE;\n+\n+  d->data[d->len] = (GDataElt){\n+    .key = key_id,\n+    .data = new_data,\n+    .destroy = destroy_func,\n+  };\n+  d->len++;\n+\n+  return reallocated;\n+}\n+\n+static void\n+datalist_remove (GData *data, guint32 idx)\n+{\n+#if G_ENABLE_DEBUG\n+  g_assert (idx < data->len);\n+#endif\n+\n+  \/* g_data_remove_internal() relies on the fact, that this function removes\n+   * the entry similar to g_array_remove_index_fast(). That is, the entries up\n+   * to @idx are left unchanged, and the last entry is moved to position @idx.\n+   * *\/\n+\n+  data->len--;\n+\n+  if (idx != data->len)\n+    data->data[idx] = data->data[data->len];\n+}\n+\n+static gboolean\n+datalist_shrink (GData **data, GData **d_to_free)\n+{\n+  guint32 alloc_by_4;\n+  guint32 v;\n+  GData *d;\n+\n+  d = *data;\n+\n+  alloc_by_4 = d->alloc \/ 4u;\n+\n+  if (G_LIKELY (d->len > alloc_by_4))\n+    {\n+      \/* No shrinking *\/\n+      return FALSE;\n+    }\n+\n+  if (d->len == 0)\n+    {\n+      \/* The list became empty. We drop the allocated memory altogether. *\/\n+\n+      \/* The caller will free the buffer after releasing the lock, to minimize\n+       * the time we hold the lock. Transfer it out. *\/\n+      *d_to_free = d;\n+      *data = NULL;\n+      return TRUE;\n+    }\n+\n+  \/* If the buffer is filled not more than 25%. Shrink to double the current length. *\/\n+\n+  v = d->len;\n+  if (v != alloc_by_4)\n+    {\n+      \/* d->alloc is a power of two. Usually, we remove one element at a\n+       * time, then we will just reach reach a quarter of that.\n+       *\n+       * However, with g_datalist_id_remove_multiple(), len can be smaller\n+       * at once. In that case, find first the next power of two. *\/\n+      v = g_nearest_pow (v);\n+    }\n+  v *= 2u;\n+\n+#if G_ENABLE_DEBUG\n+  g_assert (v > d->len);\n+  g_assert (v <= d->alloc \/ 2u);\n+#endif\n+\n+  d->alloc = v;\n+  d = g_realloc (d, G_STRUCT_OFFSET (GData, data) + (v * sizeof (GDataElt)));\n+  *d_to_free = NULL;\n+  *data = d;\n+  return TRUE;\n+}\n@@ -231,2 +277,4 @@\n-  data = G_DATALIST_GET_POINTER (datalist);\n-  G_DATALIST_SET_POINTER (datalist, NULL);\n+static GDataElt *\n+datalist_find (GData *data, GQuark key_id, guint32 *out_idx)\n+{\n+  guint32 i;\n@@ -236,1 +284,0 @@\n-      G_UNLOCK (g_dataset_global);\n@@ -239,4 +286,1 @@\n-          if (data->data[i].data && data->data[i].destroy)\n-            data->data[i].destroy (data->data[i].data);\n-        }\n-      G_LOCK (g_dataset_global);\n+          GDataElt *data_elt = &data->data[i];\n@@ -244,1 +288,7 @@\n-      g_free (data);\n+          if (data_elt->key == key_id)\n+            {\n+              if (out_idx)\n+                *out_idx = i;\n+              return data_elt;\n+            }\n+        }\n@@ -246,1 +296,3 @@\n-\n+  if (out_idx)\n+    *out_idx = G_MAXUINT32;\n+  return NULL;\n@@ -265,1 +317,1 @@\n-  g_datalist_lock (datalist);\n+  data = g_datalist_lock_and_get (datalist);\n@@ -267,2 +319,5 @@\n-  data = G_DATALIST_GET_POINTER (datalist);\n-  G_DATALIST_SET_POINTER (datalist, NULL);\n+  if (!data)\n+    {\n+      g_datalist_unlock (datalist);\n+      return;\n+    }\n@@ -270,1 +325,1 @@\n-  g_datalist_unlock (datalist);\n+  g_datalist_unlock_and_set (datalist, NULL);\n@@ -272,1 +327,1 @@\n-  if (data)\n+  for (i = 0; i < data->len; i++)\n@@ -274,7 +329,2 @@\n-      for (i = 0; i < data->len; i++)\n-        {\n-          if (data->data[i].data && data->data[i].destroy)\n-            data->data[i].destroy (data->data[i].data);\n-        }\n-\n-      g_free (data);\n+      if (data->data[i].data && data->data[i].destroy)\n+        data->data[i].destroy (data->data[i].data);\n@@ -282,0 +332,2 @@\n+\n+  g_free (data);\n@@ -309,1 +361,6 @@\n-      if (G_DATALIST_GET_POINTER(&dataset->datalist) == NULL)\n+      GData *data;\n+      guint i;\n+\n+      data = G_DATALIST_GET_POINTER (&dataset->datalist);\n+\n+      if (!data)\n@@ -318,1 +375,12 @@\n-      g_datalist_clear_i (&dataset->datalist);\n+      G_DATALIST_SET_POINTER (&dataset->datalist, NULL);\n+\n+      G_UNLOCK (g_dataset_global);\n+\n+      for (i = 0; i < data->len; i++)\n+        {\n+          if (data->data[i].data && data->data[i].destroy)\n+            data->data[i].destroy (data->data[i].data);\n+        }\n+      g_free (data);\n+\n+      G_LOCK (g_dataset_global);\n@@ -355,2 +423,4 @@\n-  GData *d, *old_d;\n-  GDataElt old, *data, *data_last, *data_end;\n+  GData *d;\n+  GData *new_d = NULL;\n+  GDataElt old, *data;\n+  guint32 idx;\n@@ -358,1 +428,1 @@\n-  g_datalist_lock (datalist);\n+  d = g_datalist_lock_and_get (datalist);\n@@ -360,1 +430,1 @@\n-  d = G_DATALIST_GET_POINTER (datalist);\n+  data = datalist_find (d, key_id, &idx);\n@@ -364,7 +434,1 @@\n-      if (d)\n-  {\n-    data = d->data;\n-    data_last = data + d->len - 1;\n-    while (data <= data_last)\n-      {\n-        if (data->key == key_id)\n+      if (data)\n@@ -372,0 +436,2 @@\n+          GData *d_to_free;\n+\n@@ -373,15 +439,0 @@\n-      if (data != data_last)\n-        *data = *data_last;\n-      d->len--;\n-\n-      \/* We don't bother to shrink, but if all data are now gone\n-       * we at least free the memory\n-                   *\/\n-      if (d->len == 0)\n-        {\n-          G_DATALIST_SET_POINTER (datalist, NULL);\n-          g_free (d);\n-          \/* datalist may be situated in dataset, so must not be\n-           * unlocked after we free it\n-           *\/\n-          g_datalist_unlock (datalist);\n@@ -389,5 +440,13 @@\n-          \/* the dataset destruction *must* be done\n-           * prior to invocation of the data destroy function\n-           *\/\n-          if (dataset)\n-      g_dataset_destroy_internal (dataset);\n+          datalist_remove (d, idx);\n+          if (datalist_shrink (&d, &d_to_free))\n+            {\n+              g_datalist_unlock_and_set (datalist, d);\n+\n+              \/* the dataset destruction *must* be done\n+               * prior to invocation of the data destroy function\n+               *\/\n+              if (dataset && !d)\n+                g_dataset_destroy_internal (dataset);\n+\n+              if (d_to_free)\n+                g_free (d_to_free);\n@@ -396,1 +455,0 @@\n-        {\n@@ -398,1 +456,0 @@\n-        }\n@@ -400,16 +457,16 @@\n-      \/* We found and removed an old value\n-       * the GData struct *must* already be unlinked\n-       * when invoking the destroy function.\n-       * we use (new_data==NULL && new_destroy_func!=NULL) as\n-       * a special hint combination to \"steal\"\n-       * data without destroy notification\n-       *\/\n-      if (old.destroy && !new_destroy_func)\n-        {\n-          if (dataset)\n-      G_UNLOCK (g_dataset_global);\n-          old.destroy (old.data);\n-          if (dataset)\n-      G_LOCK (g_dataset_global);\n-          old.data = NULL;\n-        }\n+          \/* We found and removed an old value\n+           * the GData struct *must* already be unlinked\n+           * when invoking the destroy function.\n+           * we use (new_data==NULL && new_destroy_func!=NULL) as\n+           * a special hint combination to \"steal\"\n+           * data without destroy notification\n+           *\/\n+          if (old.destroy && !new_destroy_func)\n+            {\n+              if (dataset)\n+                G_UNLOCK (g_dataset_global);\n+              old.destroy (old.data);\n+              if (dataset)\n+                G_LOCK (g_dataset_global);\n+              old.data = NULL;\n+            }\n@@ -417,5 +474,2 @@\n-      return old.data;\n-    }\n-        data++;\n-      }\n-  }\n+          return old.data;\n+        }\n@@ -425,16 +479,1 @@\n-      old.data = NULL;\n-      if (d)\n-  {\n-    data = d->data;\n-    data_end = data + d->len;\n-    while (data < data_end)\n-      {\n-        if (data->key == key_id)\n-    {\n-      if (!data->destroy)\n-        {\n-          data->data = new_data;\n-          data->destroy = new_destroy_func;\n-          g_datalist_unlock (datalist);\n-        }\n-      else\n+      if (data)\n@@ -442,3 +481,11 @@\n-          old = *data;\n-          data->data = new_data;\n-          data->destroy = new_destroy_func;\n+          if (!data->destroy)\n+            {\n+              data->data = new_data;\n+              data->destroy = new_destroy_func;\n+              g_datalist_unlock (datalist);\n+            }\n+          else\n+            {\n+              old = *data;\n+              data->data = new_data;\n+              data->destroy = new_destroy_func;\n@@ -446,1 +493,1 @@\n-          g_datalist_unlock (datalist);\n+              g_datalist_unlock (datalist);\n@@ -448,9 +495,11 @@\n-          \/* We found and replaced an old value\n-           * the GData struct *must* already be unlinked\n-           * when invoking the destroy function.\n-           *\/\n-          if (dataset)\n-      G_UNLOCK (g_dataset_global);\n-          old.destroy (old.data);\n-          if (dataset)\n-      G_LOCK (g_dataset_global);\n+              \/* We found and replaced an old value\n+               * the GData struct *must* already be unlinked\n+               * when invoking the destroy function.\n+               *\/\n+              if (dataset)\n+                G_UNLOCK (g_dataset_global);\n+              old.destroy (old.data);\n+              if (dataset)\n+                G_LOCK (g_dataset_global);\n+            }\n+          return NULL;\n@@ -458,5 +507,0 @@\n-      return NULL;\n-    }\n-        data++;\n-      }\n-  }\n@@ -465,19 +509,2 @@\n-      old_d = d;\n-      if (d == NULL)\n-  {\n-    d = g_malloc (sizeof (GData));\n-    d->len = 0;\n-    d->alloc = 1;\n-  }\n-      else if (d->len == d->alloc)\n-  {\n-    d->alloc = d->alloc * 2;\n-    d = g_realloc (d, sizeof (GData) + (d->alloc - 1) * sizeof (GDataElt));\n-  }\n-      if (old_d != d)\n-  G_DATALIST_SET_POINTER (datalist, d);\n-\n-      d->data[d->len].key = key_id;\n-      d->data[d->len].data = new_data;\n-      d->data[d->len].destroy = new_destroy_func;\n-      d->len++;\n+      if (datalist_append (&d, key_id, new_data, new_destroy_func))\n+        new_d = d;\n@@ -486,0 +513,3 @@\n+  if (new_d)\n+    g_datalist_unlock_and_set (datalist, new_d);\n+  else\n@@ -498,0 +528,6 @@\n+  GDataElt *old;\n+  GDataElt *old_to_free = NULL;\n+  GData *d_to_free;\n+  gsize found_keys;\n+  gsize i_keys;\n+  guint32 i_data;\n@@ -499,1 +535,1 @@\n-  g_datalist_lock (datalist);\n+  d = g_datalist_lock_and_get (datalist);\n@@ -501,3 +537,1 @@\n-  d = G_DATALIST_GET_POINTER (datalist);\n-\n-  if (d)\n+  if (!d)\n@@ -505,2 +539,3 @@\n-      GDataElt *old, *data, *data_end;\n-      gsize found_keys;\n+      g_datalist_unlock (datalist);\n+      return;\n+    }\n@@ -508,6 +543,15 @@\n-      \/* Allocate an array of GDataElt to hold copies of the elements\n-       * that are removed from the datalist. Allow enough space for all\n-       * the keys; if a key is not found, the corresponding element of\n-       * old is not populated, so we initialize them all to NULL to\n-       * detect that case. *\/\n-      old = g_newa0 (GDataElt, n_keys);\n+  \/* Allocate an array of GDataElt to hold copies of the elements\n+   * that are removed from the datalist. Allow enough space for all\n+   * the keys; if a key is not found, the corresponding element of\n+   * old is not populated, so we initialize them all to NULL to\n+   * detect that case.\n+   *\n+   * At most allocate 400 bytes on the stack. Especially since we call\n+   * out to external code, we don't know how much stack we can use. *\/\n+  if (n_keys <= 400u \/ sizeof (GDataElt))\n+    old = g_newa0 (GDataElt, n_keys);\n+  else\n+    {\n+      old_to_free = g_new0 (GDataElt, n_keys);\n+      old = old_to_free;\n+    }\n@@ -515,3 +559,6 @@\n-      data = d->data;\n-      data_end = data + d->len;\n-      found_keys = 0;\n+  i_data = 0;\n+  found_keys = 0;\n+  while (i_data < d->len && found_keys < n_keys)\n+    {\n+      GDataElt *data = &d->data[i_data];\n+      gboolean remove = FALSE;\n@@ -519,1 +566,1 @@\n-      while (data < data_end && found_keys < n_keys)\n+      for (i_keys = 0; i_keys < n_keys; i_keys++)\n@@ -521,13 +568,1 @@\n-          gboolean remove = FALSE;\n-\n-          for (gsize i = 0; i < n_keys; i++)\n-            {\n-              if (data->key == keys[i])\n-                {\n-                  old[i] = *data;\n-                  remove = TRUE;\n-                  break;\n-                }\n-            }\n-\n-          if (remove)\n+          if (data->key == keys[i_keys])\n@@ -535,2 +570,3 @@\n-              GDataElt *data_last = data_end - 1;\n-\n+              \/* We must invoke the destroy notifications in the order of @keys.\n+               * Hence, build up the list @old at index @i_keys. *\/\n+              old[i_keys] = *data;\n@@ -538,20 +574,2 @@\n-\n-              if (data < data_last)\n-                *data = *data_last;\n-\n-              data_end--;\n-              d->len--;\n-\n-              \/* We don't bother to shrink, but if all data are now gone\n-               * we at least free the memory\n-               *\/\n-              if (d->len == 0)\n-                {\n-                  G_DATALIST_SET_POINTER (datalist, NULL);\n-                  g_free (d);\n-                  break;\n-                }\n-            }\n-          else\n-            {\n-              data++;\n+              remove = TRUE;\n+              break;\n@@ -561,1 +579,1 @@\n-      if (found_keys > 0)\n+      if (!remove)\n@@ -563,1 +581,3 @@\n-          g_datalist_unlock (datalist);\n+          i_data++;\n+          continue;\n+        }\n@@ -565,8 +585,11 @@\n-          for (gsize i = 0; i < n_keys; i++)\n-            {\n-              \/* If keys[i] was not found, then old[i].destroy is NULL.\n-               * Call old[i].destroy() only if keys[i] was found, and\n-               * is associated with a destroy notifier: *\/\n-              if (old[i].destroy)\n-                old[i].destroy (old[i].data);\n-            }\n+      datalist_remove (d, i_data);\n+    }\n+\n+  if (found_keys > 0 && datalist_shrink (&d, &d_to_free))\n+    {\n+      g_datalist_unlock_and_set (datalist, d);\n+      if (d_to_free)\n+        g_free (d_to_free);\n+    }\n+  else\n+    g_datalist_unlock (datalist);\n@@ -574,1 +597,6 @@\n-          return;\n+  if (found_keys > 0)\n+    {\n+      for (i_keys = 0; i_keys < n_keys; i_keys++)\n+        {\n+          if (old[i_keys].destroy)\n+            old[i_keys].destroy (old[i_keys].data);\n@@ -578,1 +606,2 @@\n-  g_datalist_unlock (datalist);\n+  if (G_UNLIKELY (old_to_free))\n+    g_free (old_to_free);\n@@ -776,1 +805,1 @@\n- * @n_keys: length of @keys, must be <= 16\n+ * @n_keys: length of @keys.\n@@ -783,0 +812,4 @@\n+ * Before 2.80, @n_keys had to be not larger than 16. Now it can be larger, but\n+ * note that GData does a linear search, so an excessive number of keys will\n+ * perform badly.\n+ *\n@@ -790,2 +823,0 @@\n-  g_return_if_fail (n_keys <= 16);\n-\n@@ -867,0 +898,107 @@\n+\/*< private >\n+ * g_datalist_id_update_atomic:\n+ * @datalist: the data list\n+ * @key_id: the key to add.\n+ * @callback: (scope call): callback to update (set, remove, steal, update) the\n+ *   data.\n+ * @user_data: the user data for @callback.\n+ *\n+ * Will call @callback while holding the lock on @datalist. Be careful to not\n+ * end up calling into another data-list function, because the lock is not\n+ * reentrant and deadlock will happen.\n+ *\n+ * The callback receives the current data and destroy function. If @key_id is\n+ * currently not in @datalist, they will be %NULL. The callback can update\n+ * those pointers, and @datalist will be updated with the result. Note that if\n+ * callback modifies a received data, then it MUST steal it and take ownership\n+ * on it. Possibly by freeing it with the provided destroy function.\n+ *\n+ * The point is to atomically access the entry, while holding a lock\n+ * of @datalist. Without this, the user would have to hold their own mutex\n+ * while handling @key_id entry.\n+ *\n+ * The return value of @callback is not used, except it becomes the return\n+ * value of the function. This is an alternative to returning a result via\n+ * @user_data.\n+ *\n+ * Returns: the value returned by @callback.\n+ *\n+ * Since: 2.80\n+ *\/\n+gpointer\n+g_datalist_id_update_atomic (GData **datalist,\n+                             GQuark key_id,\n+                             GDataListUpdateAtomicFunc callback,\n+                             gpointer user_data)\n+{\n+  GData *d;\n+  GDataElt *data;\n+  gpointer new_data;\n+  gpointer result;\n+  GDestroyNotify new_destroy;\n+  guint32 idx;\n+  gboolean to_unlock = TRUE;\n+\n+  d = g_datalist_lock_and_get (datalist);\n+\n+  data = datalist_find (d, key_id, &idx);\n+\n+  if (data)\n+    {\n+      new_data = data->data;\n+      new_destroy = data->destroy;\n+    }\n+  else\n+    {\n+      new_data = NULL;\n+      new_destroy = NULL;\n+    }\n+\n+  result = callback (key_id, &new_data, &new_destroy, user_data);\n+\n+  if (data && !new_data)\n+    {\n+      GData *d_to_free;\n+\n+      \/* Remove. The callback indicates to drop the entry.\n+       *\n+       * The old data->data was stolen by callback(). *\/\n+      datalist_remove (d, idx);\n+      if (datalist_shrink (&d, &d_to_free))\n+        {\n+          g_datalist_unlock_and_set (datalist, d);\n+          if (d_to_free)\n+            g_free (d_to_free);\n+          to_unlock = FALSE;\n+        }\n+    }\n+  else if (data)\n+    {\n+      \/* Update. The callback may have provided new pointers to an existing\n+       * entry.\n+       *\n+       * The old data was stolen by callback(). We only update the pointers and\n+       * are done. *\/\n+      data->data = new_data;\n+      data->destroy = new_destroy;\n+    }\n+  else if (!data && !new_data)\n+    {\n+      \/* Absent. No change. The entry didn't exist and still does not. *\/\n+    }\n+  else\n+    {\n+      \/* Add. Add a new entry that didn't exist previously. *\/\n+      if (datalist_append (&d, key_id, new_data, new_destroy))\n+        {\n+          g_datalist_unlock_and_set (datalist, d);\n+          to_unlock = FALSE;\n+        }\n+    }\n+\n+  if (to_unlock)\n+    g_datalist_unlock (datalist);\n+\n+  return result;\n+}\n+\n@@ -977,1 +1115,1 @@\n-  GDataElt *data, *data_end;\n+  GDataElt *data;\n@@ -979,1 +1117,1 @@\n-  g_datalist_lock (datalist);\n+  d = g_datalist_lock_and_get (datalist);\n@@ -981,16 +1119,3 @@\n-  d = G_DATALIST_GET_POINTER (datalist);\n-  if (d)\n-    {\n-      data = d->data;\n-      data_end = data + d->len;\n-      do\n-        {\n-          if (data->key == key_id)\n-            {\n-              val = data->data;\n-              break;\n-            }\n-          data++;\n-        }\n-      while (data < data_end);\n-    }\n+  data = datalist_find (d, key_id, NULL);\n+  if (data)\n+    val = data->data;\n@@ -1046,1 +1171,4 @@\n-  GDataElt *data, *data_end;\n+  GDataElt *data;\n+  GData *d_to_free = NULL;\n+  gboolean set_d = FALSE;\n+  guint32 idx;\n@@ -1054,1 +1182,1 @@\n-  g_datalist_lock (datalist);\n+  d = g_datalist_lock_and_get (datalist);\n@@ -1056,2 +1184,2 @@\n-  d = G_DATALIST_GET_POINTER (datalist);\n-  if (d)\n+  data = datalist_find (d, key_id, &idx);\n+  if (data)\n@@ -1059,3 +1187,2 @@\n-      data = d->data;\n-      data_end = data + d->len - 1;\n-      while (data <= data_end)\n+      val = data->data;\n+      if (val == oldval)\n@@ -1063,1 +1190,3 @@\n-          if (data->key == key_id)\n+          if (old_destroy)\n+            *old_destroy = data->destroy;\n+          if (newval != NULL)\n@@ -1065,27 +1194,8 @@\n-              val = data->data;\n-              if (val == oldval)\n-                {\n-                  if (old_destroy)\n-                    *old_destroy = data->destroy;\n-                  if (newval != NULL)\n-                    {\n-                      data->data = newval;\n-                      data->destroy = destroy;\n-                    }\n-                  else\n-                   {\n-                     if (data != data_end)\n-                       *data = *data_end;\n-                     d->len--;\n-\n-                     \/* We don't bother to shrink, but if all data are now gone\n-                      * we at least free the memory\n-                      *\/\n-                     if (d->len == 0)\n-                       {\n-                         G_DATALIST_SET_POINTER (datalist, NULL);\n-                         g_free (d);\n-                       }\n-                   }\n-                }\n-              break;\n+              data->data = newval;\n+              data->destroy = destroy;\n+            }\n+          else\n+            {\n+              datalist_remove (d, idx);\n+              if (datalist_shrink (&d, &d_to_free))\n+                set_d = TRUE;\n@@ -1093,1 +1203,0 @@\n-          data++;\n@@ -1099,11 +1208,1 @@\n-      GData *old_d;\n-\n-      \/* insert newval *\/\n-      old_d = d;\n-      if (d == NULL)\n-  {\n-          d = g_malloc (sizeof (GData));\n-          d->len = 0;\n-          d->alloc = 1;\n-        }\n-      else if (d->len == d->alloc)\n+      if (datalist_append (&d, key_id, newval, destroy))\n@@ -1111,2 +1210,1 @@\n-          d->alloc = d->alloc * 2;\n-          d = g_realloc (d, sizeof (GData) + (d->alloc - 1) * sizeof (GDataElt));\n+          set_d = TRUE;\n@@ -1114,7 +1212,0 @@\n-      if (old_d != d)\n-        G_DATALIST_SET_POINTER (datalist, d);\n-\n-      d->data[d->len].key = key_id;\n-      d->data[d->len].data = newval;\n-      d->data[d->len].destroy = destroy;\n-      d->len++;\n@@ -1123,0 +1214,3 @@\n+  if (set_d)\n+    g_datalist_unlock_and_set (datalist, d);\n+  else\n@@ -1125,0 +1219,3 @@\n+  if (d_to_free)\n+    g_free (d_to_free);\n+\n@@ -1149,3 +1246,1 @@\n-  g_datalist_lock (datalist);\n-\n-  d = G_DATALIST_GET_POINTER (datalist);\n+  d = g_datalist_lock_and_get (datalist);\n@@ -1158,0 +1253,6 @@\n+    \/* Here we intentionally compare by strings, instead of calling\n+     * g_quark_try_string() first.\n+     *\n+     * See commit 1cceda49b60b ('Make g_datalist_get_data not look up the\n+     * quark').\n+     *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdataset.c","additions":461,"deletions":360,"binary":false,"changes":821,"status":"modified"},{"patch":"@@ -41,0 +41,23 @@\n+\/*< private >\n+ * GDataListUpdateAtomicFunc:\n+ * @key_id: ID of the entry to update\n+ * @data: (inout) (nullable) (not optional): the existing data corresponding\n+ *   to @key_id, and return location for the new value for it\n+ * @destroy_notify: (inout) (nullable) (not optional): the existing destroy\n+ *   notify function for @data, and return location for the destroy notify\n+ *   function for the new value for it\n+ * @user_data: user data passed in to [func@GLib.datalist_id_update_atomic]\n+ *\n+ * Callback from [func@GLib.datalist_id_update_atomic].\n+ *\n+ * Since: 2.80\n+ *\/\n+typedef gpointer (*GDataListUpdateAtomicFunc) (GQuark key_id,\n+                                               gpointer *data,\n+                                               GDestroyNotify *destroy_notify,\n+                                               gpointer user_data);\n+\n+gpointer g_datalist_id_update_atomic (GData **datalist,\n+                                      GQuark key_id,\n+                                      GDataListUpdateAtomicFunc callback,\n+                                      gpointer user_data);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdatasetprivate.h","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -63,3 +63,11 @@\n- * SECTION:date\n- * @title: Date and Time Functions\n- * @short_description: calendrical calculations and miscellaneous time stuff\n+ * GDate:\n+ * @julian_days: the Julian representation of the date\n+ * @julian: this bit is set if @julian_days is valid\n+ * @dmy: this is set if @day, @month and @year are valid\n+ * @day: the day of the day-month-year representation of the date,\n+ *   as a number between 1 and 31\n+ * @month: the month of the day-month-year representation of the date,\n+ *   as a number between 1 and 12\n+ * @year: the year of the day-month-year representation of the date\n+ *\n+ * `GDate` is a struct for calendrical calculations.\n@@ -67,1 +75,1 @@\n- * The #GDate data structure represents a day between January 1, Year 1,\n+ * The `GDate` data structure represents a day between January 1, Year 1,\n@@ -69,2 +77,2 @@\n- * to the year 65535 or so, but g_date_set_parse() only parses up to the\n- * year 8000 or so - just count on \"a few thousand\"). #GDate is meant to\n+ * to the year 65535 or so, but [method@GLib.Date.set_parse] only parses up to the\n+ * year 8000 or so - just count on \"a few thousand\"). `GDate` is meant to\n@@ -74,1 +82,1 @@\n- * the calendar to match time periods or locations. #GDate does not store\n+ * the calendar to match time periods or locations. `GDate` does not store\n@@ -77,1 +85,1 @@\n- * The #GDate implementation has several nice features; it is only a\n+ * The `GDate` implementation has several nice features; it is only a\n@@ -87,19 +95,17 @@\n- * #GDate is simple to use. First you need a \"blank\" date; you can get a\n- * dynamically allocated date from g_date_new(), or you can declare an\n- * automatic variable or array and initialize it by\n- * calling g_date_clear(). A cleared date is safe; it's safe to call\n- * g_date_set_dmy() and the other mutator functions to initialize the\n- * value of a cleared date. However, a cleared date is initially\n- * invalid, meaning that it doesn't represent a day that exists.\n- * It is undefined to call any of the date calculation routines on an\n- * invalid date. If you obtain a date from a user or other\n- * unpredictable source, you should check its validity with the\n- * g_date_valid() predicate. g_date_valid() is also used to check for\n- * errors with g_date_set_parse() and other functions that can\n- * fail. Dates can be invalidated by calling g_date_clear() again.\n- *\n- * It is very important to use the API to access the #GDate\n- * struct. Often only the day-month-year or only the Julian\n- * representation is valid. Sometimes neither is valid. Use the API.\n- *\n- * GLib also features #GDateTime which represents a precise time.\n+ * `GDate` is simple to use. First you need a \"blank\" date; you can get a\n+ * dynamically allocated date from [ctor@GLib.Date.new], or you can declare an\n+ * automatic variable or array and initialize it by calling [method@GLib.Date.clear].\n+ * A cleared date is safe; it's safe to call [method@GLib.Date.set_dmy] and the other\n+ * mutator functions to initialize the value of a cleared date. However, a cleared date\n+ * is initially invalid, meaning that it doesn't represent a day that exists.\n+ * It is undefined to call any of the date calculation routines on an invalid date.\n+ * If you obtain a date from a user or other unpredictable source, you should check\n+ * its validity with the [method@GLib.Date.valid] predicate. [method@GLib.Date.valid]\n+ * is also used to check for errors with [method@GLib.Date.set_parse] and other functions\n+ * that can fail. Dates can be invalidated by calling [method@GLib.Date.clear] again.\n+ *\n+ * It is very important to use the API to access the `GDate` struct. Often only the\n+ * day-month-year or only the Julian representation is valid. Sometimes neither is valid.\n+ * Use the API.\n+ *\n+ * GLib also features `GDateTime` which represents a precise time.\n@@ -134,24 +140,0 @@\n-\/**\n- * GDate:\n- * @julian_days: the Julian representation of the date\n- * @julian: this bit is set if @julian_days is valid\n- * @dmy: this is set if @day, @month and @year are valid\n- * @day: the day of the day-month-year representation of the date,\n- *   as a number between 1 and 31\n- * @month: the day of the day-month-year representation of the date,\n- *   as a number between 1 and 12\n- * @year: the day of the day-month-year representation of the date\n- *\n- * Represents a day between January 1, Year 1 and a few thousand years in\n- * the future. None of its members should be accessed directly.\n- *\n- * If the `GDate` is obtained from g_date_new(), it will be safe\n- * to mutate but invalid and thus not safe for calendrical computations.\n- *\n- * If it's declared on the stack, it will contain garbage so must be\n- * initialized with g_date_clear(). g_date_clear() makes the date invalid\n- * but safe. An invalid date doesn't represent a day, it's \"empty.\" A date\n- * becomes valid after you set it to a Julian day or you set a day, month,\n- * and year.\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdate.c","additions":33,"deletions":51,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -41,9 +41,0 @@\n-\/* GDate\n- *\n- * Date calculations (not time for now, to be resolved). These are a\n- * mutant combination of Steffen Beyer's DateCalc routines\n- * (http:\/\/www.perl.com\/CPAN\/authors\/id\/STBEY\/) and Jon Trowbridge's\n- * date routines (written for in-house software).  Written by Havoc\n- * Pennington <hp@pobox.com>\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdate.h","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright 2023 GNOME Foundation Inc.\n+ *\n+ * SPDX-License-Identifier: LGPL-2.1-or-later\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n+ *\n+ * Authors:\n+ *  - Philip Withnall <pwithnall@gnome.org>\n+ *\/\n+\n+#include \"glib.h\"\n+#include \"gdatetime-private.h\"\n+\n+\/**\n+ * _g_era_date_compare:\n+ * @date1: first date\n+ * @date2: second date\n+ *\n+ * Compare two #GEraDates for ordering, taking into account negative and\n+ * positive infinity.\n+ *\n+ * Returns: strcmp()-style integer, `<0` indicates `date1 < date2`, `0`\n+ *   indicates `date1 == date2`, `>0` indicates `date1 > date2`\n+ * Since: 2.80\n+ *\/\n+int\n+_g_era_date_compare (const GEraDate *date1,\n+                     const GEraDate *date2)\n+{\n+  if (date1->type == G_ERA_DATE_SET &&\n+      date2->type == G_ERA_DATE_SET)\n+    {\n+      if (date1->year != date2->year)\n+        return date1->year - date2->year;\n+      if (date1->month != date2->month)\n+        return date1->month - date2->month;\n+      return date1->day - date2->day;\n+    }\n+\n+  if (date1->type == date2->type)\n+    return 0;\n+\n+  if (date1->type == G_ERA_DATE_MINUS_INFINITY || date2->type == G_ERA_DATE_PLUS_INFINITY)\n+    return -1;\n+  if (date1->type == G_ERA_DATE_PLUS_INFINITY || date2->type == G_ERA_DATE_MINUS_INFINITY)\n+    return 1;\n+\n+  g_assert_not_reached ();\n+}\n+\n+static gboolean\n+parse_era_date (const char *str,\n+                const char *endptr,\n+                GEraDate   *out_date)\n+{\n+  const char *str_endptr = NULL;\n+  int year_multiplier;\n+  guint64 year, month, day;\n+\n+  year_multiplier = (str[0] == '-') ? -1 : 1;\n+  if (str[0] == '-' || str[0] == '+')\n+    str++;\n+\n+  year = g_ascii_strtoull (str, (gchar **) &str_endptr, 10);\n+  g_assert (str_endptr <= endptr);\n+  if (str_endptr == endptr || *str_endptr != '\/' || year > G_MAXINT)\n+    return FALSE;\n+  str = str_endptr + 1;\n+\n+  month = g_ascii_strtoull (str, (gchar **) &str_endptr, 10);\n+  g_assert (str_endptr <= endptr);\n+  if (str_endptr == endptr || *str_endptr != '\/' || month < 1 || month > 12)\n+    return FALSE;\n+  str = str_endptr + 1;\n+\n+  day = g_ascii_strtoull (str, (gchar **) &str_endptr, 10);\n+  g_assert (str_endptr <= endptr);\n+  if (str_endptr != endptr || day < 1 || day > 31)\n+    return FALSE;\n+\n+  \/* Success *\/\n+  out_date->type = G_ERA_DATE_SET;\n+  out_date->year = year_multiplier * year;\n+  out_date->month = month;\n+  out_date->day = day;\n+\n+  return TRUE;\n+}\n+\n+\/**\n+ * _g_era_description_segment_ref:\n+ * @segment: a #GEraDescriptionSegment\n+ *\n+ * Increase the ref count of @segment.\n+ *\n+ * Returns: (transfer full): @segment\n+ * Since: 2.80\n+ *\/\n+GEraDescriptionSegment *\n+_g_era_description_segment_ref (GEraDescriptionSegment *segment)\n+{\n+  g_atomic_ref_count_inc (&segment->ref_count);\n+  return segment;\n+}\n+\n+\/**\n+ * _g_era_description_segment_unref:\n+ * @segment: (transfer full): a #GEraDescriptionSegment to unref\n+ *\n+ * Decreases the ref count of @segment.\n+ *\n+ * Since: 2.80\n+ *\/\n+void\n+_g_era_description_segment_unref (GEraDescriptionSegment *segment)\n+{\n+  if (g_atomic_ref_count_dec (&segment->ref_count))\n+    {\n+      g_free (segment->era_format);\n+      g_free (segment->era_name);\n+      g_free (segment);\n+    }\n+}\n+\n+\/**\n+ * _g_era_description_parse:\n+ * @desc: an `ERA` description string from `nl_langinfo()`\n+ *\n+ * Parse an ERA description string. See [`nl_langinfo(3)`](man:nl_langinfo(3)).\n+ *\n+ * Example description string for th_TH.UTF-8:\n+ * ```\n+ * +:1:-543\/01\/01:+*:พ.ศ.:%EC %Ey\n+ * ```\n+ *\n+ * @desc must be in UTF-8, so all conversion from the locale encoding must\n+ * happen before this function is called. The resulting `era_name` and\n+ * `era_format` in the returned segments will be in UTF-8.\n+ *\n+ * Returns: (transfer full) (nullable) (element-type GEraDescriptionSegment):\n+ *   array of one or more parsed era segments, or %NULL if parsing failed\n+ * Since: 2.80\n+ *\/\n+GPtrArray *\n+_g_era_description_parse (const char *desc)\n+{\n+  GPtrArray *segments = g_ptr_array_new_with_free_func ((GDestroyNotify) _g_era_description_segment_unref);\n+\n+  for (const char *p = desc; *p != '\\0';)\n+    {\n+      const char *next_colon, *endptr = NULL;\n+      GEraDescriptionSegment *segment = NULL;\n+      char direction;\n+      guint64 offset;\n+      GEraDate start_date, end_date;\n+      char *era_name = NULL, *era_format = NULL;\n+\n+      \/* direction *\/\n+      direction = *p++;\n+      if (direction != '+' && direction != '-')\n+        goto error;\n+\n+      if (*p++ != ':')\n+        goto error;\n+\n+      \/* offset *\/\n+      next_colon = strchr (p, ':');\n+      if (next_colon == NULL)\n+        goto error;\n+\n+      offset = g_ascii_strtoull (p, (gchar **) &endptr, 10);\n+      if (endptr != next_colon)\n+        goto error;\n+      p = next_colon + 1;\n+\n+      \/* start_date *\/\n+      next_colon = strchr (p, ':');\n+      if (next_colon == NULL)\n+        goto error;\n+\n+      if (!parse_era_date (p, next_colon, &start_date))\n+        goto error;\n+      p = next_colon + 1;\n+\n+      \/* end_date *\/\n+      next_colon = strchr (p, ':');\n+      if (next_colon == NULL)\n+        goto error;\n+\n+      if (strncmp (p, \"-*\", 2) == 0)\n+        end_date.type = G_ERA_DATE_MINUS_INFINITY;\n+      else if (strncmp (p, \"+*\", 2) == 0)\n+        end_date.type = G_ERA_DATE_PLUS_INFINITY;\n+      else if (!parse_era_date (p, next_colon, &end_date))\n+        goto error;\n+      p = next_colon + 1;\n+\n+      \/* era_name *\/\n+      next_colon = strchr (p, ':');\n+      if (next_colon == NULL)\n+        goto error;\n+\n+      if (next_colon - p == 0)\n+        goto error;\n+      era_name = g_strndup (p, next_colon - p);\n+      p = next_colon + 1;\n+\n+      \/* era_format; either the final field in the segment (followed by a\n+       * semicolon) or the description (followed by nul) *\/\n+      next_colon = strchr (p, ';');\n+      if (next_colon == NULL)\n+        next_colon = p + strlen (p);\n+\n+      if (next_colon - p == 0)\n+        {\n+          g_free (era_name);\n+          goto error;\n+        }\n+      era_format = g_strndup (p, next_colon - p);\n+      if (*next_colon == ';')\n+        p = next_colon + 1;\n+      else\n+        p = next_colon;\n+\n+      \/* Successfully parsed that segment. *\/\n+      segment = g_new0 (GEraDescriptionSegment, 1);\n+      g_atomic_ref_count_init (&segment->ref_count);\n+      segment->offset = offset;\n+      segment->start_date = start_date;\n+      segment->end_date = end_date;\n+      segment->direction_multiplier =\n+          ((_g_era_date_compare (&segment->start_date, &segment->end_date) <= 0) ? 1 : -1) *\n+          ((direction == '-') ? -1 : 1);\n+      segment->era_name = g_steal_pointer (&era_name);\n+      segment->era_format = g_steal_pointer (&era_format);\n+\n+      g_ptr_array_add (segments, g_steal_pointer (&segment));\n+    }\n+\n+  return g_steal_pointer (&segments);\n+\n+error:\n+  g_ptr_array_unref (segments);\n+  return NULL;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdatetime-private.c","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright 2023 GNOME Foundation Inc.\n+ *\n+ * SPDX-License-Identifier: LGPL-2.1-or-later\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n+ *\n+ * Authors:\n+ *  - Philip Withnall <pwithnall@gnome.org>\n+ *\/\n+\n+#pragma once\n+\n+#include \"glib.h\"\n+\n+G_BEGIN_DECLS\n+\n+\/**\n+ * GEraDate:\n+ * @type: the type of date\n+ * @year: year of the date, in the Gregorian calendar\n+ * @month: month of the date, in the Gregorian calendar\n+ * @day: day of the date, in the Gregorian calendar\n+ *\n+ * A date from a #GEraDescriptionSegment.\n+ *\n+ * If @type is %G_ERA_DATE_SET, @year, @month and @day are valid. Otherwise,\n+ * they are undefined.\n+ *\n+ * Since: 2.80\n+ *\/\n+typedef struct {\n+  enum {\n+    G_ERA_DATE_SET,\n+    G_ERA_DATE_PLUS_INFINITY,\n+    G_ERA_DATE_MINUS_INFINITY,\n+  } type;\n+  int year;\n+  int month;\n+  int day;\n+} GEraDate;\n+\n+int _g_era_date_compare (const GEraDate *date1,\n+                         const GEraDate *date2);\n+\n+\/**\n+ * GEraDescriptionSegment:\n+ * @ref_count: reference count\n+ * @direction_multiplier: `-1` or `1` depending on the order of @start_date and\n+ *   @end_date\n+ * @offset: offset of the first year in the era\n+ * @start_date: start date (in the Gregorian calendar) of the era\n+ * @end_date: end date (in the Gregorian calendar) of the era\n+ * @era_name: (not nullable): name of the era\n+ * @era_format: (not nullable): format string to use for `%EY`\n+ *\n+ * A segment of an `ERA` description string, describing a single era. See\n+ * [`nl_langinfo(3)`](man:nl_langinfo(3)).\n+ *\n+ * Since: 2.80\n+ *\/\n+typedef struct {\n+  gatomicrefcount ref_count;\n+  int direction_multiplier;\n+  guint64 offset;\n+  GEraDate start_date;  \/* inclusive *\/\n+  GEraDate end_date;  \/* inclusive *\/\n+  char *era_name;  \/* UTF-8 encoded *\/\n+  char *era_format;  \/* UTF-8 encoded *\/\n+} GEraDescriptionSegment;\n+\n+GPtrArray *_g_era_description_parse (const char *desc);\n+\n+GEraDescriptionSegment *_g_era_description_segment_ref (GEraDescriptionSegment *segment);\n+void _g_era_description_segment_unref (GEraDescriptionSegment *segment);\n+\n+G_END_DECLS\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdatetime-private.h","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -8,0 +8,1 @@\n+ * Copyright 2023 GNOME Foundation Inc.\n@@ -29,0 +30,1 @@\n+ *          Philip Withnall <pwithnall@gnome.org>\n@@ -57,0 +59,1 @@\n+#include <locale.h>\n@@ -71,0 +74,1 @@\n+#include \"gdatetime-private.h\"\n@@ -92,33 +96,0 @@\n-\/**\n- * SECTION:date-time\n- * @title: GDateTime\n- * @short_description: a structure representing Date and Time\n- * @see_also: #GTimeZone\n- *\n- * #GDateTime is a structure that combines a Gregorian date and time\n- * into a single structure.  It provides many conversion and methods to\n- * manipulate dates and times.  Time precision is provided down to\n- * microseconds and the time can range (proleptically) from 0001-01-01\n- * 00:00:00 to 9999-12-31 23:59:59.999999.  #GDateTime follows POSIX\n- * time in the sense that it is oblivious to leap seconds.\n- *\n- * #GDateTime is an immutable object; once it has been created it cannot\n- * be modified further.  All modifiers will create a new #GDateTime.\n- * Nearly all such functions can fail due to the date or time going out\n- * of range, in which case %NULL will be returned.\n- *\n- * #GDateTime is reference counted: the reference count is increased by calling\n- * g_date_time_ref() and decreased by calling g_date_time_unref(). When the\n- * reference count drops to 0, the resources allocated by the #GDateTime\n- * structure are released.\n- *\n- * Many parts of the API may produce non-obvious results.  As an\n- * example, adding two months to January 31st will yield March 31st\n- * whereas adding one month and then one month again will yield either\n- * March 28th or March 29th.  Also note that adding 24 hours is not\n- * always the same as adding one day (since days containing daylight\n- * savings time transitions are either 23 or 25 hours in length).\n- *\n- * #GDateTime is available since GLib 2.26.\n- *\/\n-\n@@ -590,0 +561,25 @@\n+\/* FIXME: It doesn’t seem to be possible to use ERA on 64-bit big-endian platforms with glibc\n+ * in a POSIX-compliant way right now.\n+ * See https:\/\/gitlab.gnome.org\/GNOME\/glib\/-\/issues\/3225 *\/\n+#if defined(HAVE_LANGINFO_ERA) && (G_BYTE_ORDER == G_LITTLE_ENDIAN || GLIB_SIZEOF_VOID_P == 4)\n+\n+#define PREFERRED_ERA_DATE_TIME_FMT nl_langinfo (ERA_D_T_FMT)\n+#define PREFERRED_ERA_DATE_FMT nl_langinfo (ERA_D_FMT)\n+#define PREFERRED_ERA_TIME_FMT nl_langinfo (ERA_T_FMT)\n+\n+#define ERA_DESCRIPTION nl_langinfo (ERA)\n+#define ERA_DESCRIPTION_IS_LOCALE TRUE\n+#define ERA_DESCRIPTION_N_SEGMENTS (int) (gintptr) nl_langinfo (_NL_TIME_ERA_NUM_ENTRIES)\n+\n+#else  \/* if !HAVE_LANGINFO_ERA *\/\n+\n+#define PREFERRED_ERA_DATE_TIME_FMT PREFERRED_DATE_TIME_FMT\n+#define PREFERRED_ERA_DATE_FMT PREFERRED_DATE_FMT\n+#define PREFERRED_ERA_TIME_FMT PREFERRED_TIME_FMT\n+\n+#define ERA_DESCRIPTION NULL\n+#define ERA_DESCRIPTION_IS_LOCALE FALSE\n+#define ERA_DESCRIPTION_N_SEGMENTS 0\n+\n+#endif  \/* !HAVE_LANGINFO_ERA *\/\n+\n@@ -1043,3 +1039,0 @@\n-  GDateTime *datetime;\n-  GTimeZone *local;\n-\n@@ -1050,0 +1043,29 @@\n+  return g_date_time_new_from_unix_local_usec (t * USEC_PER_SECOND);\n+}\n+\n+\/**\n+ * g_date_time_new_from_unix_local_usec: (constructor)\n+ * @usecs: the Unix time in microseconds\n+ *\n+ * Creates a [struct@GLib.DateTime] corresponding to the given Unix time @t in the\n+ * local time zone.\n+ *\n+ * Unix time is the number of microseconds that have elapsed since 1970-01-01\n+ * 00:00:00 UTC, regardless of the local time offset.\n+ *\n+ * This call can fail (returning `NULL`) if @t represents a time outside\n+ * of the supported range of #GDateTime.\n+ *\n+ * You should release the return value by calling [method@GLib.DateTime.unref]\n+ * when you are done with it.\n+ *\n+ * Returns: (transfer full) (nullable): a new [struct@GLib.DateTime], or `NULL`\n+ *\n+ * Since: 2.80\n+ **\/\n+GDateTime *\n+g_date_time_new_from_unix_local_usec (gint64 usecs)\n+{\n+  GDateTime *datetime;\n+  GTimeZone *local;\n+\n@@ -1051,1 +1073,1 @@\n-  datetime = g_date_time_new_from_unix (local, t * USEC_PER_SECOND);\n+  datetime = g_date_time_new_from_unix (local, usecs);\n@@ -1079,3 +1101,0 @@\n-  GDateTime *datetime;\n-  GTimeZone *utc;\n-\n@@ -1086,0 +1105,28 @@\n+  return g_date_time_new_from_unix_utc_usec (t * USEC_PER_SECOND);\n+}\n+\n+\/**\n+ * g_date_time_new_from_unix_utc_usec: (constructor)\n+ * @usecs: the Unix time in microseconds\n+ *\n+ * Creates a [struct@GLib.DateTime] corresponding to the given Unix time @t in UTC.\n+ *\n+ * Unix time is the number of microseconds that have elapsed since 1970-01-01\n+ * 00:00:00 UTC.\n+ *\n+ * This call can fail (returning `NULL`) if @t represents a time outside\n+ * of the supported range of #GDateTime.\n+ *\n+ * You should release the return value by calling [method@GLib.DateTime.unref]\n+ * when you are done with it.\n+ *\n+ * Returns: (transfer full) (nullable): a new [struct@GLib.DateTime], or `NULL`\n+ *\n+ * Since: 2.80\n+ **\/\n+GDateTime *\n+g_date_time_new_from_unix_utc_usec (gint64 usecs)\n+{\n+  GDateTime *datetime;\n+  GTimeZone *utc;\n+\n@@ -1087,1 +1134,1 @@\n-  datetime = g_date_time_new_from_unix (utc, t * USEC_PER_SECOND);\n+  datetime = g_date_time_new_from_unix (utc, usecs);\n@@ -2581,0 +2628,21 @@\n+\/**\n+ * g_date_time_to_unix_usec:\n+ * @datetime: a #GDateTime\n+ *\n+ * Gives the Unix time corresponding to @datetime, in microseconds.\n+ *\n+ * Unix time is the number of microseconds that have elapsed since 1970-01-01\n+ * 00:00:00 UTC, regardless of the time zone associated with @datetime.\n+ *\n+ * Returns: the Unix time corresponding to @datetime\n+ *\n+ * Since: 2.80\n+ **\/\n+gint64\n+g_date_time_to_unix_usec (GDateTime *datetime)\n+{\n+  g_return_val_if_fail (datetime != NULL, 0);\n+\n+  return INSTANT_TO_UNIX_USECS (g_date_time_to_instant (datetime));\n+}\n+\n@@ -2861,0 +2929,3 @@\n+ *\n+ * This needs external locking, so must only be called from within\n+ * format_number().\n@@ -2902,0 +2973,128 @@\n+\/* Look up the era which contains @datetime, in the ERA description from libc\n+ * which corresponds to the currently set LC_TIME locale. The ERA is parsed and\n+ * cached the first time this function is called (or when LC_TIME changes).\n+ * See nl_langinfo(3).\n+ *\n+ * The return value is (transfer full). *\/\n+static GEraDescriptionSegment *\n+date_time_lookup_era (GDateTime *datetime,\n+                      gboolean   locale_is_utf8)\n+{\n+  static GMutex era_mutex;\n+  static GPtrArray *static_era_description = NULL;  \/* (mutex era_mutex) (element-type GEraDescriptionSegment) *\/\n+  static const char *static_era_description_locale = NULL;  \/* (mutex era_mutex) *\/\n+  const char *current_lc_time = setlocale (LC_TIME, NULL);\n+  GPtrArray *local_era_description;  \/* (element-type GEraDescriptionSegment) *\/\n+  GEraDate datetime_date;\n+\n+  g_mutex_lock (&era_mutex);\n+\n+  if (static_era_description_locale != current_lc_time)\n+    {\n+      const char *era_description_str;\n+      size_t era_description_str_len;\n+      char *tmp = NULL;\n+\n+      era_description_str = ERA_DESCRIPTION;\n+      if (era_description_str != NULL)\n+        {\n+          \/* FIXME: glibc 2.37 seems to return the era segments nul-separated rather\n+           * than semicolon-separated (which is what nl_langinfo(3) specifies).\n+           * Fix that up before sending it to the parsing code.\n+           * See https:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=31030*\/\n+            {\n+              \/* Work out the length of the whole description string, regardless\n+               * of whether it uses nuls or semicolons as separators. *\/\n+              int n_entries = ERA_DESCRIPTION_N_SEGMENTS;\n+              const char *s = era_description_str;\n+\n+              for (int i = 1; i < n_entries; i++)\n+                {\n+                  const char *next_semicolon = strchr (s, ';');\n+                  const char *next_nul = strchr (s, '\\0');\n+\n+                  if (next_semicolon != NULL && next_semicolon < next_nul)\n+                    s = next_semicolon + 1;\n+                  else\n+                    s = next_nul + 1;\n+                }\n+\n+              era_description_str_len = strlen (s) + (s - era_description_str);\n+\n+              \/* Replace all the nuls with semicolons. *\/\n+              era_description_str = tmp = g_memdup2 (era_description_str, era_description_str_len + 1);\n+              s = era_description_str;\n+\n+              for (int i = 1; i < n_entries; i++)\n+                {\n+                  char *next_nul = strchr (s, '\\0');\n+\n+                  if ((size_t) (next_nul - era_description_str) >= era_description_str_len)\n+                    break;\n+\n+                  *next_nul = ';';\n+                  s = next_nul + 1;\n+                }\n+            }\n+\n+          \/* Convert from the LC_TIME encoding to UTF-8 if needed. *\/\n+          if (!locale_is_utf8 && ERA_DESCRIPTION_IS_LOCALE)\n+            {\n+              char *tmp2 = NULL;\n+              era_description_str = tmp2 = g_locale_to_utf8 (era_description_str, -1, NULL, NULL, NULL);\n+              g_free (tmp);\n+              tmp = g_steal_pointer (&tmp2);\n+            }\n+\n+          g_clear_pointer (&static_era_description, g_ptr_array_unref);\n+\n+          if (era_description_str != NULL)\n+            static_era_description = _g_era_description_parse (era_description_str);\n+          if (static_era_description == NULL)\n+            g_warning (\"Could not parse ERA description: %s\", era_description_str);\n+        }\n+      else\n+        {\n+          g_clear_pointer (&static_era_description, g_ptr_array_unref);\n+        }\n+\n+      g_free (tmp);\n+\n+      static_era_description_locale = current_lc_time;\n+    }\n+\n+  if (static_era_description == NULL)\n+    {\n+      g_mutex_unlock (&era_mutex);\n+      return NULL;\n+    }\n+\n+  local_era_description = g_ptr_array_ref (static_era_description);\n+  g_mutex_unlock (&era_mutex);\n+\n+  \/* Search through the eras and see if one matches. *\/\n+  datetime_date.type = G_ERA_DATE_SET;\n+  datetime_date.year = g_date_time_get_year (datetime);\n+  datetime_date.month = g_date_time_get_month (datetime);\n+  datetime_date.day = g_date_time_get_day_of_month (datetime);\n+\n+  for (unsigned int i = 0; i < local_era_description->len; i++)\n+    {\n+      GEraDescriptionSegment *segment = g_ptr_array_index (local_era_description, i);\n+\n+      if ((_g_era_date_compare (&segment->start_date, &datetime_date) <= 0 &&\n+           _g_era_date_compare (&datetime_date, &segment->end_date) <= 0) ||\n+          (_g_era_date_compare (&segment->end_date, &datetime_date) <= 0 &&\n+           _g_era_date_compare (&datetime_date, &segment->start_date) <= 0))\n+        {\n+          \/* @datetime is within this era segment. *\/\n+          g_ptr_array_unref (local_era_description);\n+          return _g_era_description_segment_ref (segment);\n+        }\n+    }\n+\n+  g_ptr_array_unref (local_era_description);\n+\n+  return NULL;\n+}\n+\n@@ -2915,0 +3114,3 @@\n+#ifdef HAVE_LANGINFO_OUTDIGIT\n+  static GMutex alt_digits_mutex;\n+#endif\n@@ -2922,1 +3124,6 @@\n-      static gsize initialised;\n+      static char *alt_digits_locale = NULL;\n+      const char *current_ctype_locale = setlocale (LC_CTYPE, NULL);\n+\n+      \/* Lock so we can initialise (or re-initialise, if the locale has changed)\n+       * and hold access to the digits buffer until done formatting. *\/\n+      g_mutex_lock (&alt_digits_mutex);\n@@ -2924,1 +3131,1 @@\n-      if G_UNLIKELY (g_once_init_enter (&initialised))\n+      if (g_strcmp0 (alt_digits_locale, current_ctype_locale) != 0)\n@@ -2931,1 +3138,2 @@\n-          g_once_init_leave (&initialised, TRUE);\n+          g_free (alt_digits_locale);\n+          alt_digits_locale = g_strdup (current_ctype_locale);\n@@ -2948,0 +3156,5 @@\n+#ifdef HAVE_LANGINFO_OUTDIGIT\n+  if (use_alt_digits)\n+    g_mutex_unlock (&alt_digits_mutex);\n+#endif\n+\n@@ -3021,0 +3234,1 @@\n+               gboolean     do_strup,\n@@ -3025,0 +3239,1 @@\n+  char *tmp = NULL;\n@@ -3028,0 +3243,2 @@\n+      if (do_strup)\n+        s = tmp = g_utf8_strup (s, -1);\n@@ -3035,0 +3252,6 @@\n+      if (do_strup)\n+        {\n+          tmp = g_utf8_strup (utf8, utf8_len);\n+          g_free (utf8);\n+          utf8 = g_steal_pointer (&tmp);\n+        }\n@@ -3039,0 +3262,2 @@\n+  g_free (tmp);\n+\n@@ -3055,0 +3280,1 @@\n+  gboolean alt_era = FALSE;\n@@ -3056,0 +3282,1 @@\n+  gboolean mod_case = FALSE;\n@@ -3058,0 +3285,1 @@\n+  const gchar *mod = \"\";\n@@ -3060,0 +3288,1 @@\n+  char *tmp = NULL;\n@@ -3078,0 +3307,1 @@\n+      alt_era = FALSE;\n@@ -3079,0 +3309,1 @@\n+      mod_case = FALSE;\n@@ -3092,1 +3323,1 @@\n-          if (!string_append (outstr, name, name_is_utf8))\n+          if (!string_append (outstr, name, mod_case, name_is_utf8))\n@@ -3103,1 +3334,1 @@\n-          if (!string_append (outstr, name, name_is_utf8))\n+          if (!string_append (outstr, name, mod_case, name_is_utf8))\n@@ -3117,1 +3348,1 @@\n-          if (!string_append (outstr, name, name_is_utf8))\n+          if (!string_append (outstr, name, mod_case, name_is_utf8))\n@@ -3131,1 +3362,1 @@\n-          if (!string_append (outstr, name, name_is_utf8))\n+          if (!string_append (outstr, name, mod_case, name_is_utf8))\n@@ -3137,1 +3368,7 @@\n-            if (g_strcmp0 (PREFERRED_DATE_TIME_FMT, \"\") == 0)\n+            const char *subformat = alt_era ? PREFERRED_ERA_DATE_TIME_FMT : PREFERRED_DATE_TIME_FMT;\n+\n+            \/* Fallback *\/\n+            if (alt_era && g_strcmp0 (subformat, \"\") == 0)\n+              subformat = PREFERRED_DATE_TIME_FMT;\n+\n+            if (g_strcmp0 (subformat, \"\") == 0)\n@@ -3139,1 +3376,1 @@\n-            if (!g_date_time_format_locale (datetime, PREFERRED_DATE_TIME_FMT,\n+            if (!g_date_time_format_locale (datetime, subformat,\n@@ -3145,0 +3382,11 @@\n+          if (alt_era)\n+            {\n+              GEraDescriptionSegment *era = date_time_lookup_era (datetime, locale_is_utf8);\n+              if (era != NULL)\n+                {\n+                  g_string_append (outstr, era->era_name);\n+                  _g_era_description_segment_unref (era);\n+                  break;\n+                }\n+            }\n+\n@@ -3184,1 +3432,1 @@\n-          if (!string_append (outstr, name, name_is_utf8))\n+          if (!string_append (outstr, name, mod_case, name_is_utf8))\n@@ -3221,0 +3469,3 @@\n+    goto next_mod;\n+        case 'E':\n+          alt_era = TRUE;\n@@ -3223,1 +3474,3 @@\n-          if (!format_ampm (datetime, outstr, locale_is_utf8, TRUE))\n+          if (!format_ampm (datetime, outstr, locale_is_utf8,\n+                            mod_case && g_strcmp0 (mod, \"#\") == 0 ? FALSE\n+                                                                  : TRUE))\n@@ -3227,1 +3480,3 @@\n-          if (!format_ampm (datetime, outstr, locale_is_utf8, FALSE))\n+          if (!format_ampm (datetime, outstr, locale_is_utf8,\n+                            mod_case && g_strcmp0 (mod, \"^\") == 0 ? TRUE\n+                                                                  : FALSE))\n@@ -3274,1 +3529,7 @@\n-            if (g_strcmp0 (PREFERRED_DATE_FMT, \"\") == 0)\n+            const char *subformat = alt_era ? PREFERRED_ERA_DATE_FMT : PREFERRED_DATE_FMT;\n+\n+            \/* Fallback *\/\n+            if (alt_era && g_strcmp0 (subformat, \"\") == 0)\n+              subformat = PREFERRED_DATE_FMT;\n+\n+            if (g_strcmp0 (subformat, \"\") == 0)\n@@ -3276,1 +3537,1 @@\n-      if (!g_date_time_format_locale (datetime, PREFERRED_DATE_FMT,\n+      if (!g_date_time_format_locale (datetime, subformat,\n@@ -3283,1 +3544,7 @@\n-            if (g_strcmp0 (PREFERRED_TIME_FMT, \"\") == 0)\n+            const char *subformat = alt_era ? PREFERRED_ERA_TIME_FMT : PREFERRED_TIME_FMT;\n+\n+            \/* Fallback *\/\n+            if (alt_era && g_strcmp0 (subformat, \"\") == 0)\n+              subformat = PREFERRED_TIME_FMT;\n+\n+            if (g_strcmp0 (subformat, \"\") == 0)\n@@ -3285,1 +3552,1 @@\n-      if (!g_date_time_format_locale (datetime, PREFERRED_TIME_FMT,\n+      if (!g_date_time_format_locale (datetime, subformat,\n@@ -3291,0 +3558,20 @@\n+          if (alt_era)\n+            {\n+              GEraDescriptionSegment *era = date_time_lookup_era (datetime, locale_is_utf8);\n+              if (era != NULL)\n+                {\n+                  int delta = g_date_time_get_year (datetime) - era->start_date.year;\n+\n+                  \/* Both these years are in the Gregorian calendar (CE\/BCE),\n+                   * which has no year zero. So take one from the delta if they\n+                   * cross across where year zero would be. *\/\n+                  if ((g_date_time_get_year (datetime) < 0) != (era->start_date.year < 0))\n+                    delta -= 1;\n+\n+                  format_number (outstr, alt_digits, pad_set ? pad : \"0\", 2,\n+                                 era->offset + delta * era->direction_multiplier);\n+                  _g_era_description_segment_unref (era);\n+                  break;\n+                }\n+            }\n+\n@@ -3295,0 +3582,17 @@\n+          if (alt_era)\n+            {\n+              GEraDescriptionSegment *era = date_time_lookup_era (datetime, locale_is_utf8);\n+              if (era != NULL)\n+                {\n+                  if (!g_date_time_format_utf8 (datetime, era->era_format,\n+                                                outstr, locale_is_utf8))\n+                    {\n+                      _g_era_description_segment_unref (era);\n+                      return FALSE;\n+                    }\n+\n+                  _g_era_description_segment_unref (era);\n+                  break;\n+                }\n+            }\n+\n@@ -3308,0 +3612,2 @@\n+          if (mod_case && g_strcmp0 (mod, \"#\") == 0)\n+            tz = tmp = g_utf8_strdown (tz, -1);\n@@ -3309,0 +3615,1 @@\n+          g_free (tmp);\n@@ -3330,0 +3637,8 @@\n+    goto next_mod;\n+        case '^':\n+          mod_case = TRUE;\n+          mod = \"^\";\n+          goto next_mod;\n+        case '#':\n+          mod_case = TRUE;\n+          mod = \"#\";\n@@ -3426,2 +3741,3 @@\n- * conversion specifier by one or more modifier characters. The\n- * following modifiers are supported for many of the numeric\n+ * conversion specifier by one or more modifier characters.\n+ *\n+ * The following modifiers are supported for many of the numeric\n@@ -3438,0 +3754,7 @@\n+ * The following modifiers are supported for many of the alphabetic conversions:\n+ *\n+ * - `^`: Use upper case if possible. This is a gnulib `strftime()` extension.\n+ *   Since: 2.80\n+ * - `#`: Use opposite case if possible. This is a gnulib `strftime()`\n+ *   extension. Since: 2.80\n+ *\n@@ -3446,0 +3769,16 @@\n+ * Since GLib 2.80, when `E` is used with `%c`, `%C`, `%x`, `%X`, `%y` or `%Y`,\n+ * the date is formatted using an alternate era representation specific to the\n+ * locale. This is typically used for the Thai solar calendar or Japanese era\n+ * names, for example.\n+ *\n+ * - `%Ec`: the preferred date and time representation for the current locale,\n+ *   using the alternate era representation\n+ * - `%EC`: the name of the era\n+ * - `%Ex`: the preferred date representation for the current locale without\n+ *   the time, using the alternate era representation\n+ * - `%EX`: the preferred time representation for the current locale without\n+ *   the date, using the alternate era representation\n+ * - `%Ey`: the year since the beginning of the era denoted by the `%EC`\n+ *   specifier\n+ * - `%EY`: the full alternative year representation\n+ *\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdatetime.c","additions":398,"deletions":59,"binary":false,"changes":457,"status":"modified"},{"patch":"@@ -94,1 +94,25 @@\n- * An opaque structure that represents a date and time, including a time zone.\n+ * `GDateTime` is a structure that combines a Gregorian date and time\n+ * into a single structure.\n+ *\n+ * `GDateTime` provides many conversion and methods to manipulate dates and times.\n+ * Time precision is provided down to microseconds and the time can range\n+ * (proleptically) from 0001-01-01 00:00:00 to 9999-12-31 23:59:59.999999.\n+ * `GDateTime` follows POSIX time in the sense that it is oblivious to leap\n+ * seconds.\n+ *\n+ * `GDateTime` is an immutable object; once it has been created it cannot\n+ * be modified further. All modifiers will create a new `GDateTime`.\n+ * Nearly all such functions can fail due to the date or time going out\n+ * of range, in which case %NULL will be returned.\n+ *\n+ * `GDateTime` is reference counted: the reference count is increased by calling\n+ * [method@GLib.DateTime.ref] and decreased by calling [method@GLib.DateTime.unref].\n+ * When the reference count drops to 0, the resources allocated by the `GDateTime`\n+ * structure are released.\n+ *\n+ * Many parts of the API may produce non-obvious results. As an\n+ * example, adding two months to January 31st will yield March 31st\n+ * whereas adding one month and then one month again will yield either\n+ * March 28th or March 29th.  Also note that adding 24 hours is not\n+ * always the same as adding one day (since days containing daylight\n+ * savings time transitions are either 23 or 25 hours in length).\n@@ -117,0 +141,5 @@\n+GLIB_AVAILABLE_IN_2_80\n+GDateTime *             g_date_time_new_from_unix_local_usec            (gint64          usecs);\n+GLIB_AVAILABLE_IN_2_80\n+GDateTime *             g_date_time_new_from_unix_utc_usec              (gint64          usecs);\n+\n@@ -244,0 +273,3 @@\n+GLIB_AVAILABLE_IN_2_80\n+gint64                  g_date_time_to_unix_usec                        (GDateTime      *datetime);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdatetime.h","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  gatomicrefcount ref_count;\n@@ -98,1 +99,0 @@\n-  GDir dir;\n@@ -100,0 +100,2 @@\n+  GDir *dir;\n+  _WDIR *wdirp;\n@@ -102,0 +104,2 @@\n+#else\n+  DIR *dirp;\n@@ -111,1 +115,1 @@\n-  dir.wdirp = _wopendir (wpath);\n+  wdirp = _wopendir (wpath);\n@@ -116,1 +120,1 @@\n-  if (dir.wdirp == NULL)\n+  if (wdirp == NULL)\n@@ -118,0 +122,6 @@\n+\n+  dir = g_new0 (GDir, 1);\n+  g_atomic_ref_count_init (&dir->ref_count);\n+  dir->wdirp = wdirp;\n+\n+  return g_steal_pointer (&dir);\n@@ -119,1 +129,1 @@\n-  dir.dirp = opendir (path);\n+  dirp = opendir (path);\n@@ -121,1 +131,1 @@\n-  if (dir.dirp == NULL)\n+  if (dirp == NULL)\n@@ -123,1 +133,0 @@\n-#endif\n@@ -125,1 +134,2 @@\n-  return g_memdup2 (&dir, sizeof dir);\n+  return g_dir_new_from_dirp (dirp);\n+#endif\n@@ -129,1 +139,1 @@\n- * g_dir_open:\n+ * g_dir_open: (constructor)\n@@ -141,1 +151,1 @@\n- * Returns: a newly allocated #GDir on success, %NULL on failure.\n+ * Returns: (transfer full): a newly allocated #GDir on success, %NULL on failure.\n@@ -196,1 +206,2 @@\n-  dir = g_new (GDir, 1);\n+  dir = g_new0 (GDir, 1);\n+  g_atomic_ref_count_init (&dir->ref_count);\n@@ -296,0 +307,10 @@\n+static void\n+g_dir_actually_close (GDir *dir)\n+{\n+#ifdef G_OS_WIN32\n+  g_clear_pointer (&dir->wdirp, _wclosedir);\n+#else\n+  g_clear_pointer (&dir->dirp, closedir);\n+#endif\n+}\n+\n@@ -298,1 +319,1 @@\n- * @dir: a #GDir* created by g_dir_open()\n+ * @dir: (transfer full): a #GDir* created by g_dir_open()\n@@ -300,1 +321,8 @@\n- * Closes the directory and deallocates all related resources.\n+ * Closes the directory immediately and decrements the reference count.\n+ *\n+ * Once the reference count reaches zero, the `GDir` structure itself will be\n+ * freed. Prior to GLib 2.80, `GDir` was not reference counted.\n+ *\n+ * It is an error to call any of the `GDir` methods other than\n+ * [method@GLib.Dir.ref] and [method@GLib.Dir.unref] on a `GDir` after calling\n+ * [method@GLib.Dir.close] on it.\n@@ -307,6 +335,50 @@\n-#ifdef G_OS_WIN32\n-  _wclosedir (dir->wdirp);\n-#else\n-  closedir (dir->dirp);\n-#endif\n-  g_free (dir);\n+  g_dir_actually_close (dir);\n+  g_dir_unref (dir);\n+}\n+\n+\/**\n+ * g_dir_ref:\n+ * @dir: (transfer none): a `GDir`\n+ *\n+ * Increment the reference count of `dir`.\n+ *\n+ * Returns: (transfer full): the same pointer as `dir`\n+ * Since: 2.80\n+ *\/\n+GDir *\n+g_dir_ref (GDir *dir)\n+{\n+  g_return_val_if_fail (dir != NULL, NULL);\n+\n+  g_atomic_ref_count_inc (&dir->ref_count);\n+  return dir;\n+}\n+\n+\/**\n+ * g_dir_unref:\n+ * @dir: (transfer full): a `GDir`\n+ *\n+ * Decrements the reference count of `dir`.\n+ *\n+ * Once the reference count reaches zero, the directory will be closed and all\n+ * resources associated with it will be freed. If [method@GLib.Dir.close] is\n+ * called when the reference count is greater than zero, the directory is closed\n+ * but the `GDir` structure will not be freed until its reference count reaches\n+ * zero.\n+ *\n+ * It is an error to call any of the `GDir` methods other than\n+ * [method@GLib.Dir.ref] and [method@GLib.Dir.unref] on a `GDir` after calling\n+ * [method@GLib.Dir.close] on it.\n+ *\n+ * Since: 2.80\n+ *\/\n+void\n+g_dir_unref (GDir *dir)\n+{\n+  g_return_if_fail (dir != NULL);\n+\n+  if (g_atomic_ref_count_dec (&dir->ref_count))\n+    {\n+      g_dir_actually_close (dir);\n+      g_free (dir);\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdir.c","additions":90,"deletions":18,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+GLIB_AVAILABLE_IN_2_80\n+GDir *                   g_dir_ref             (GDir        *dir);\n+GLIB_AVAILABLE_IN_2_80\n+void                     g_dir_unref           (GDir        *dir);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdir.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,475 +27,0 @@\n-\/**\n- * SECTION:error_reporting\n- * @Title: Error Reporting\n- * @Short_description: a system for reporting errors\n- *\n- * GLib provides a standard method of reporting errors from a called\n- * function to the calling code. (This is the same problem solved by\n- * exceptions in other languages.) It's important to understand that\n- * this method is both a data type (the #GError struct) and a [set of\n- * rules][gerror-rules]. If you use #GError incorrectly, then your code will not\n- * properly interoperate with other code that uses #GError, and users\n- * of your API will probably get confused. In most cases, [using #GError is\n- * preferred over numeric error codes][gerror-comparison], but there are\n- * situations where numeric error codes are useful for performance.\n- *\n- * First and foremost: #GError should only be used to report recoverable\n- * runtime errors, never to report programming errors. If the programmer\n- * has screwed up, then you should use g_warning(), g_return_if_fail(),\n- * g_assert(), g_error(), or some similar facility. (Incidentally,\n- * remember that the g_error() function should only be used for\n- * programming errors, it should not be used to print any error\n- * reportable via #GError.)\n- *\n- * Examples of recoverable runtime errors are \"file not found\" or\n- * \"failed to parse input.\" Examples of programming errors are \"NULL\n- * passed to strcmp()\" or \"attempted to free the same pointer twice.\"\n- * These two kinds of errors are fundamentally different: runtime errors\n- * should be handled or reported to the user, programming errors should\n- * be eliminated by fixing the bug in the program. This is why most\n- * functions in GLib and GTK do not use the #GError facility.\n- *\n- * Functions that can fail take a return location for a #GError as their\n- * last argument. On error, a new #GError instance will be allocated and\n- * returned to the caller via this argument. For example:\n- * |[<!-- language=\"C\" -->\n- * gboolean g_file_get_contents (const gchar  *filename,\n- *                               gchar       **contents,\n- *                               gsize        *length,\n- *                               GError      **error);\n- * ]|\n- * If you pass a non-%NULL value for the `error` argument, it should\n- * point to a location where an error can be placed. For example:\n- * |[<!-- language=\"C\" -->\n- * gchar *contents;\n- * GError *err = NULL;\n- *\n- * g_file_get_contents (\"foo.txt\", &contents, NULL, &err);\n- * g_assert ((contents == NULL && err != NULL) || (contents != NULL && err == NULL));\n- * if (err != NULL)\n- *   {\n- *     \/\/ Report error to user, and free error\n- *     g_assert (contents == NULL);\n- *     fprintf (stderr, \"Unable to read file: %s\\n\", err->message);\n- *     g_error_free (err);\n- *   }\n- * else\n- *   {\n- *     \/\/ Use file contents\n- *     g_assert (contents != NULL);\n- *   }\n- * ]|\n- * Note that `err != NULL` in this example is a reliable indicator\n- * of whether g_file_get_contents() failed. Additionally,\n- * g_file_get_contents() returns a boolean which\n- * indicates whether it was successful.\n- *\n- * Because g_file_get_contents() returns %FALSE on failure, if you\n- * are only interested in whether it failed and don't need to display\n- * an error message, you can pass %NULL for the @error argument:\n- * |[<!-- language=\"C\" -->\n- * if (g_file_get_contents (\"foo.txt\", &contents, NULL, NULL)) \/\/ ignore errors\n- *   \/\/ no error occurred\n- *   ;\n- * else\n- *   \/\/ error\n- *   ;\n- * ]|\n- *\n- * The #GError object contains three fields: @domain indicates the module\n- * the error-reporting function is located in, @code indicates the specific\n- * error that occurred, and @message is a user-readable error message with\n- * as many details as possible. Several functions are provided to deal\n- * with an error received from a called function: g_error_matches()\n- * returns %TRUE if the error matches a given domain and code,\n- * g_propagate_error() copies an error into an error location (so the\n- * calling function will receive it), and g_clear_error() clears an\n- * error location by freeing the error and resetting the location to\n- * %NULL. To display an error to the user, simply display the @message,\n- * perhaps along with additional context known only to the calling\n- * function (the file being opened, or whatever - though in the\n- * g_file_get_contents() case, the @message already contains a filename).\n- *\n- * Since error messages may be displayed to the user, they need to be valid\n- * UTF-8 (all GTK widgets expect text to be UTF-8). Keep this in mind in\n- * particular when formatting error messages with filenames, which are in\n- * the 'filename encoding', and need to be turned into UTF-8 using\n- * g_filename_to_utf8(), g_filename_display_name() or g_utf8_make_valid().\n- *\n- * Note, however, that many error messages are too technical to display to the\n- * user in an application, so prefer to use g_error_matches() to categorize errors\n- * from called functions, and build an appropriate error message for the context\n- * within your application. Error messages from a #GError are more appropriate\n- * to be printed in system logs or on the command line. They are typically\n- * translated.\n- *\n- * When implementing a function that can report errors, the basic\n- * tool is g_set_error(). Typically, if a fatal error occurs you\n- * want to g_set_error(), then return immediately. g_set_error()\n- * does nothing if the error location passed to it is %NULL.\n- * Here's an example:\n- * |[<!-- language=\"C\" -->\n- * gint\n- * foo_open_file (GError **error)\n- * {\n- *   gint fd;\n- *   int saved_errno;\n- *\n- *   g_return_val_if_fail (error == NULL || *error == NULL, -1);\n- *\n- *   fd = open (\"file.txt\", O_RDONLY);\n- *   saved_errno = errno;\n- *\n- *   if (fd < 0)\n- *     {\n- *       g_set_error (error,\n- *                    FOO_ERROR,                 \/\/ error domain\n- *                    FOO_ERROR_BLAH,            \/\/ error code\n- *                    \"Failed to open file: %s\", \/\/ error message format string\n- *                    g_strerror (saved_errno));\n- *       return -1;\n- *     }\n- *   else\n- *     return fd;\n- * }\n- * ]|\n- *\n- * Things are somewhat more complicated if you yourself call another\n- * function that can report a #GError. If the sub-function indicates\n- * fatal errors in some way other than reporting a #GError, such as\n- * by returning %TRUE on success, you can simply do the following:\n- * |[<!-- language=\"C\" -->\n- * gboolean\n- * my_function_that_can_fail (GError **err)\n- * {\n- *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);\n- *\n- *   if (!sub_function_that_can_fail (err))\n- *     {\n- *       \/\/ assert that error was set by the sub-function\n- *       g_assert (err == NULL || *err != NULL);\n- *       return FALSE;\n- *     }\n- *\n- *   \/\/ otherwise continue, no error occurred\n- *   g_assert (err == NULL || *err == NULL);\n- * }\n- * ]|\n- *\n- * If the sub-function does not indicate errors other than by\n- * reporting a #GError (or if its return value does not reliably indicate\n- * errors) you need to create a temporary #GError\n- * since the passed-in one may be %NULL. g_propagate_error() is\n- * intended for use in this case.\n- * |[<!-- language=\"C\" -->\n- * gboolean\n- * my_function_that_can_fail (GError **err)\n- * {\n- *   GError *tmp_error;\n- *\n- *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);\n- *\n- *   tmp_error = NULL;\n- *   sub_function_that_can_fail (&tmp_error);\n- *\n- *   if (tmp_error != NULL)\n- *     {\n- *       \/\/ store tmp_error in err, if err != NULL,\n- *       \/\/ otherwise call g_error_free() on tmp_error\n- *       g_propagate_error (err, tmp_error);\n- *       return FALSE;\n- *     }\n- *\n- *   \/\/ otherwise continue, no error occurred\n- * }\n- * ]|\n- *\n- * Error pileups are always a bug. For example, this code is incorrect:\n- * |[<!-- language=\"C\" -->\n- * gboolean\n- * my_function_that_can_fail (GError **err)\n- * {\n- *   GError *tmp_error;\n- *\n- *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);\n- *\n- *   tmp_error = NULL;\n- *   sub_function_that_can_fail (&tmp_error);\n- *   other_function_that_can_fail (&tmp_error);\n- *\n- *   if (tmp_error != NULL)\n- *     {\n- *       g_propagate_error (err, tmp_error);\n- *       return FALSE;\n- *     }\n- * }\n- * ]|\n- * @tmp_error should be checked immediately after sub_function_that_can_fail(),\n- * and either cleared or propagated upward. The rule is: after each error,\n- * you must either handle the error, or return it to the calling function.\n- *\n- * Note that passing %NULL for the error location is the equivalent\n- * of handling an error by always doing nothing about it. So the\n- * following code is fine, assuming errors in sub_function_that_can_fail()\n- * are not fatal to my_function_that_can_fail():\n- * |[<!-- language=\"C\" -->\n- * gboolean\n- * my_function_that_can_fail (GError **err)\n- * {\n- *   GError *tmp_error;\n- *\n- *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);\n- *\n- *   sub_function_that_can_fail (NULL); \/\/ ignore errors\n- *\n- *   tmp_error = NULL;\n- *   other_function_that_can_fail (&tmp_error);\n- *\n- *   if (tmp_error != NULL)\n- *     {\n- *       g_propagate_error (err, tmp_error);\n- *       return FALSE;\n- *     }\n- * }\n- * ]|\n- *\n- * Note that passing %NULL for the error location ignores errors;\n- * it's equivalent to\n- * `try { sub_function_that_can_fail (); } catch (...) {}`\n- * in C++. It does not mean to leave errors unhandled; it means\n- * to handle them by doing nothing.\n- *\n- * Error domains and codes are conventionally named as follows:\n- *\n- * - The error domain is called <NAMESPACE>_<MODULE>_ERROR,\n- *   for example %G_SPAWN_ERROR or %G_THREAD_ERROR:\n- *   |[<!-- language=\"C\" -->\n- *   #define G_SPAWN_ERROR g_spawn_error_quark ()\n- *\n- *   G_DEFINE_QUARK (g-spawn-error-quark, g_spawn_error)\n- *   ]|\n- *\n- * - The quark function for the error domain is called\n- *   <namespace>_<module>_error_quark,\n- *   for example g_spawn_error_quark() or g_thread_error_quark().\n- *\n- * - The error codes are in an enumeration called\n- *   <Namespace><Module>Error;\n- *   for example, #GThreadError or #GSpawnError.\n- *\n- * - Members of the error code enumeration are called\n- *   <NAMESPACE>_<MODULE>_ERROR_<CODE>,\n- *   for example %G_SPAWN_ERROR_FORK or %G_THREAD_ERROR_AGAIN.\n- *\n- * - If there's a \"generic\" or \"unknown\" error code for unrecoverable\n- *   errors it doesn't make sense to distinguish with specific codes,\n- *   it should be called <NAMESPACE>_<MODULE>_ERROR_FAILED,\n- *   for example %G_SPAWN_ERROR_FAILED. In the case of error code\n- *   enumerations that may be extended in future releases, you should\n- *   generally not handle this error code explicitly, but should\n- *   instead treat any unrecognized error code as equivalent to\n- *   FAILED.\n- *\n- * ## Comparison of #GError and traditional error handling # {#gerror-comparison}\n- *\n- * #GError has several advantages over traditional numeric error codes:\n- * importantly, tools like\n- * [gobject-introspection](https:\/\/developer.gnome.org\/gi\/stable\/) understand\n- * #GErrors and convert them to exceptions in bindings; the message includes\n- * more information than just a code; and use of a domain helps prevent\n- * misinterpretation of error codes.\n- *\n- * #GError has disadvantages though: it requires a memory allocation, and\n- * formatting the error message string has a performance overhead. This makes it\n- * unsuitable for use in retry loops where errors are a common case, rather than\n- * being unusual. For example, using %G_IO_ERROR_WOULD_BLOCK means hitting these\n- * overheads in the normal control flow. String formatting overhead can be\n- * eliminated by using g_set_error_literal() in some cases.\n- *\n- * These performance issues can be compounded if a function wraps the #GErrors\n- * returned by the functions it calls: this multiplies the number of allocations\n- * and string formatting operations. This can be partially mitigated by using\n- * g_prefix_error().\n- *\n- * ## Rules for use of #GError # {#gerror-rules}\n- *\n- * Summary of rules for use of #GError:\n- *\n- * - Do not report programming errors via #GError.\n- *\n- * - The last argument of a function that returns an error should\n- *   be a location where a #GError can be placed (i.e. `GError **error`).\n- *   If #GError is used with varargs, the `GError**` should be the last\n- *   argument before the `...`.\n- *\n- * - The caller may pass %NULL for the `GError**` if they are not interested\n- *   in details of the exact error that occurred.\n- *\n- * - If %NULL is passed for the `GError**` argument, then errors should\n- *   not be returned to the caller, but your function should still\n- *   abort and return if an error occurs. That is, control flow should\n- *   not be affected by whether the caller wants to get a #GError.\n- *\n- * - If a #GError is reported, then your function by definition had a\n- *   fatal failure and did not complete whatever it was supposed to do.\n- *   If the failure was not fatal, then you handled it and you should not\n- *   report it. If it was fatal, then you must report it and discontinue\n- *   whatever you were doing immediately.\n- *\n- * - If a #GError is reported, out parameters are not guaranteed to\n- *   be set to any defined value.\n- *\n- * - A `GError*` must be initialized to %NULL before passing its address\n- *   to a function that can report errors.\n- *\n- * - #GError structs must not be stack-allocated.\n- *\n- * - \"Piling up\" errors is always a bug. That is, if you assign a\n- *   new #GError to a `GError*` that is non-%NULL, thus overwriting\n- *   the previous error, it indicates that you should have aborted\n- *   the operation instead of continuing. If you were able to continue,\n- *   you should have cleared the previous error with g_clear_error().\n- *   g_set_error() will complain if you pile up errors.\n- *\n- * - By convention, if you return a boolean value indicating success\n- *   then %TRUE means success and %FALSE means failure. Avoid creating\n- *   functions which have a boolean return value and a #GError parameter,\n- *   but where the boolean does something other than signal whether the\n- *   #GError is set.  Among other problems, it requires C callers to allocate\n- *   a temporary error.  Instead, provide a `gboolean *` out parameter.\n- *   There are functions in GLib itself such as g_key_file_has_key() that\n- *   are hard to use because of this. If %FALSE is returned, the error must\n- *   be set to a non-%NULL value.  One exception to this is that in situations\n- *   that are already considered to be undefined behaviour (such as when a\n- *   g_return_val_if_fail() check fails), the error need not be set.\n- *   Instead of checking separately whether the error is set, callers\n- *   should ensure that they do not provoke undefined behaviour, then\n- *   assume that the error will be set on failure.\n- *\n- * - A %NULL return value is also frequently used to mean that an error\n- *   occurred. You should make clear in your documentation whether %NULL\n- *   is a valid return value in non-error cases; if %NULL is a valid value,\n- *   then users must check whether an error was returned to see if the\n- *   function succeeded.\n- *\n- * - When implementing a function that can report errors, you may want\n- *   to add a check at the top of your function that the error return\n- *   location is either %NULL or contains a %NULL error (e.g.\n- *   `g_return_if_fail (error == NULL || *error == NULL);`).\n- *\n- * ## Extended #GError Domains # {#gerror-extended-domains}\n- *\n- * Since GLib 2.68 it is possible to extend the #GError type. This is\n- * done with the G_DEFINE_EXTENDED_ERROR() macro. To create an\n- * extended #GError type do something like this in the header file:\n- * |[<!-- language=\"C\" -->\n- * typedef enum\n- * {\n- *   MY_ERROR_BAD_REQUEST,\n- * } MyError;\n- * #define MY_ERROR (my_error_quark ())\n- * GQuark my_error_quark (void);\n- * int\n- * my_error_get_parse_error_id (GError *error);\n- * const char *\n- * my_error_get_bad_request_details (GError *error);\n- * ]|\n- * and in implementation:\n- * |[<!-- language=\"C\" -->\n- * typedef struct\n- * {\n- *   int parse_error_id;\n- *   char *bad_request_details;\n- * } MyErrorPrivate;\n- *\n- * static void\n- * my_error_private_init (MyErrorPrivate *priv)\n- * {\n- *   priv->parse_error_id = -1;\n- *   \/\/ No need to set priv->bad_request_details to NULL,\n- *   \/\/ the struct is initialized with zeros.\n- * }\n- *\n- * static void\n- * my_error_private_copy (const MyErrorPrivate *src_priv, MyErrorPrivate *dest_priv)\n- * {\n- *   dest_priv->parse_error_id = src_priv->parse_error_id;\n- *   dest_priv->bad_request_details = g_strdup (src_priv->bad_request_details);\n- * }\n- *\n- * static void\n- * my_error_private_clear (MyErrorPrivate *priv)\n- * {\n- *   g_free (priv->bad_request_details);\n- * }\n- *\n- * \/\/ This defines the my_error_get_private and my_error_quark functions.\n- * G_DEFINE_EXTENDED_ERROR (MyError, my_error)\n- *\n- * int\n- * my_error_get_parse_error_id (GError *error)\n- * {\n- *   MyErrorPrivate *priv = my_error_get_private (error);\n- *   g_return_val_if_fail (priv != NULL, -1);\n- *   return priv->parse_error_id;\n- * }\n- *\n- * const char *\n- * my_error_get_bad_request_details (GError *error)\n- * {\n- *   MyErrorPrivate *priv = my_error_get_private (error);\n- *   g_return_val_if_fail (priv != NULL, NULL);\n- *   g_return_val_if_fail (error->code != MY_ERROR_BAD_REQUEST, NULL);\n- *   return priv->bad_request_details;\n- * }\n- *\n- * static void\n- * my_error_set_bad_request (GError     **error,\n- *                           const char  *reason,\n- *                           int          error_id,\n- *                           const char  *details)\n- * {\n- *   MyErrorPrivate *priv;\n- *   g_set_error (error, MY_ERROR, MY_ERROR_BAD_REQUEST, \"Invalid request: %s\", reason);\n- *   if (error != NULL && *error != NULL)\n- *     {\n- *       priv = my_error_get_private (error);\n- *       g_return_val_if_fail (priv != NULL, NULL);\n- *       priv->parse_error_id = error_id;\n- *       priv->bad_request_details = g_strdup (details);\n- *     }\n- * }\n- * ]|\n- * An example of use of the error could be:\n- * |[<!-- language=\"C\" -->\n- * gboolean\n- * send_request (GBytes *request, GError **error)\n- * {\n- *   ParseFailedStatus *failure = validate_request (request);\n- *   if (failure != NULL)\n- *     {\n- *       my_error_set_bad_request (error, failure->reason, failure->error_id, failure->details);\n- *       parse_failed_status_free (failure);\n- *       return FALSE;\n- *     }\n- *\n- *   return send_one (request, error);\n- * }\n- * ]|\n- *\n- * Please note that if you are a library author and your library\n- * exposes an existing error domain, then you can't make this error\n- * domain an extended one without breaking ABI. This is because\n- * earlier it was possible to create an error with this error domain\n- * on the stack and then copy it with g_error_copy(). If the new\n- * version of your library makes the error domain an extended one,\n- * then g_error_copy() called by code that allocated the error on the\n- * stack will try to copy more data than it used to, which will lead\n- * to undefined behavior. You must not stack-allocate errors with an\n- * extended error domain, and it is bad practice to stack-allocate any\n- * other #GErrors.\n- *\n- * Extended error domains in unloadable plugins\/modules are not\n- * supported.\n- *\/\n-\n@@ -584,3 +109,3 @@\n- * @error_type_init: function initializing fields of the private error data\n- * @error_type_copy: function copying fields of the private error data\n- * @error_type_clear: function freeing fields of the private error data\n+ * @error_type_init: (scope forever): function initializing fields of the private error data\n+ * @error_type_copy: (scope forever): function copying fields of the private error data\n+ * @error_type_clear: (scope forever): function freeing fields of the private error data\n@@ -637,3 +162,3 @@\n- * @error_type_init: function initializing fields of the private error data\n- * @error_type_copy: function copying fields of the private error data\n- * @error_type_clear: function freeing fields of the private error data\n+ * @error_type_init: (scope forever): function initializing fields of the private error data\n+ * @error_type_copy: (scope forever): function copying fields of the private error data\n+ * @error_type_clear: (scope forever): function freeing fields of the private error data\n@@ -1115,1 +640,1 @@\n- * @err: (allow-none): a return location for a #GError, or %NULL\n+ * @err: (inout) (nullable) (optional): a return location for a #GError, or %NULL\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gerror.c","additions":7,"deletions":482,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -62,37 +62,0 @@\n-\/**\n- * SECTION:fileutils\n- * @title: File Utilities\n- * @short_description: various file-related functions\n- *\n- * Do not use these APIs unless you are porting a POSIX application to Windows.\n- * A more high-level file access API is provided as GIO - see the documentation\n- * for #GFile.\n- *\n- * There is a group of functions which wrap the common POSIX functions\n- * dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),\n- * g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these\n- * wrappers is to make it possible to handle file names with any Unicode\n- * characters in them on Windows without having to use ifdefs and the\n- * wide character API in the application code.\n- *\n- * On some Unix systems, these APIs may be defined as identical to their POSIX\n- * counterparts. For this reason, you must check for and include the necessary\n- * header files (such as `fcntl.h`) before using functions like g_creat(). You\n- * must also define the relevant feature test macros.\n- *\n- * The pathname argument should be in the GLib file name encoding.\n- * On POSIX this is the actual on-disk encoding which might correspond\n- * to the locale settings of the process (or the `G_FILENAME_ENCODING`\n- * environment variable), or not.\n- *\n- * On Windows the GLib file name encoding is UTF-8. Note that the\n- * Microsoft C library does not use UTF-8, but has separate APIs for\n- * current system code page and wide characters (UTF-16). The GLib\n- * wrappers call the wide character API if present (on modern Windows\n- * systems), otherwise convert to\/from the system code page.\n- *\n- * Another group of functions allows to open and read directories\n- * in the GLib file name encoding. These are g_dir_open(),\n- * g_dir_read_name(), g_dir_rewind(), g_dir_close().\n- *\/\n-\n@@ -762,0 +725,1 @@\n+              char *display_size = g_format_size_full (total_allocated, G_FORMAT_SIZE_LONG_FORMAT);\n@@ -766,3 +730,6 @@\n-                           g_dngettext (GETTEXT_PACKAGE, \"Could not allocate %lu byte to read file '%s'\", \"Could not allocate %lu bytes to read file '%s'\", (gulong)total_allocated),\n-                           (gulong) total_allocated,\n-         display_filename);\n+                           \/* Translators: the first %s contains the file size\n+                            * (already formatted with units), and the second %s\n+                            * contains the file name *\/\n+                           _(\"Could not allocate %s to read file '%s'\"),\n+                           display_size,\n+                           display_filename);\n@@ -770,0 +737,1 @@\n+              g_free (display_size);\n@@ -847,0 +815,12 @@\n+  if ((G_MAXOFFSET >= G_MAXSIZE) && (stat_buf->st_size > (goffset) (G_MAXSIZE - 1)))\n+    {\n+      display_filename = g_filename_display_name (filename);\n+      g_set_error (error,\n+                   G_FILE_ERROR,\n+                   G_FILE_ERROR_FAILED,\n+                   _(\"File '%s' is too large\"),\n+                   display_filename);\n+      g_free (display_filename);\n+      goto error;\n+    }\n+\n@@ -854,0 +834,1 @@\n+      char *display_size = g_format_size_full (alloc_size, G_FORMAT_SIZE_LONG_FORMAT);\n@@ -858,3 +839,6 @@\n-                           g_dngettext (GETTEXT_PACKAGE, \"Could not allocate %lu byte to read file '%s'\", \"Could not allocate %lu bytes to read file '%s'\", (gulong)alloc_size),\n-                   (gulong) alloc_size,\n-       display_filename);\n+                   \/* Translators: the first %s contains the file size\n+                    * (already formatted with units), and the second %s\n+                    * contains the file name *\/\n+                   _(\"Could not allocate %s to read file '%s'\"),\n+                   display_size,\n+                   display_filename);\n@@ -862,0 +846,1 @@\n+      g_free (display_size);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gfileutils.c","additions":28,"deletions":43,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -471,0 +471,51 @@\n+\n+\/**\n+ * SECTION:i18n\n+ * @title: Internationalization\n+ * @short_description: gettext support macros\n+ * @see_also: the gettext manual\n+ *\n+ * GLib doesn't force any particular localization method upon its users.\n+ * But since GLib itself is localized using the gettext() mechanism, it seems\n+ * natural to offer the de-facto standard gettext() support macros in an\n+ * easy-to-use form.\n+ *\n+ * In order to use these macros in an application, you must include\n+ * `<glib\/gi18n.h>`. For use in a library, you must include\n+ * `<glib\/gi18n-lib.h>`\n+ * after defining the %GETTEXT_PACKAGE macro suitably for your library:\n+ * |[<!-- language=\"C\" -->\n+ * #define GETTEXT_PACKAGE \"gtk20\"\n+ * #include <glib\/gi18n-lib.h>\n+ * ]|\n+ * For an application, note that you also have to call bindtextdomain(),\n+ * bind_textdomain_codeset(), textdomain() and setlocale() early on in your\n+ * main() to make gettext() work. For example:\n+ * |[<!-- language=\"C\" -->\n+ * #include <glib\/gi18n.h>\n+ * #include <locale.h>\n+ *\n+ * int\n+ * main (int argc, char **argv)\n+ * {\n+ *   setlocale (LC_ALL, \"\");\n+ *   bindtextdomain (GETTEXT_PACKAGE, DATADIR \"\/locale\");\n+ *   bind_textdomain_codeset (GETTEXT_PACKAGE, \"UTF-8\");\n+ *   textdomain (GETTEXT_PACKAGE);\n+ *\n+ *   \/\/ Rest of your application.\n+ * }\n+ * ]|\n+ * where `DATADIR` is as typically provided by automake or Meson.\n+ *\n+ * For a library, you only have to call bindtextdomain() and\n+ * bind_textdomain_codeset() in your initialization function. If your library\n+ * doesn't have an initialization function, you can call the functions before\n+ * the first translated message.\n+ *\n+ * The\n+ * [gettext manual](http:\/\/www.gnu.org\/software\/gettext\/manual\/gettext.html#Maintainers)\n+ * covers details of how to integrate gettext into a project’s build system and\n+ * workflow.\n+ *\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ggettext.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -66,59 +66,0 @@\n-\/**\n- * SECTION:hash_tables\n- * @title: Hash Tables\n- * @short_description: associations between keys and values so that\n- *     given a key the value can be found quickly\n- *\n- * A #GHashTable provides associations between keys and values which is\n- * optimized so that given a key, the associated value can be found,\n- * inserted or removed in amortized O(1). All operations going through\n- * each element take O(n) time (list all keys\/values, table resize, etc.).\n- *\n- * Note that neither keys nor values are copied when inserted into the\n- * #GHashTable, so they must exist for the lifetime of the #GHashTable.\n- * This means that the use of static strings is OK, but temporary\n- * strings (i.e. those created in buffers and those returned by GTK\n- * widgets) should be copied with g_strdup() before being inserted.\n- *\n- * If keys or values are dynamically allocated, you must be careful to\n- * ensure that they are freed when they are removed from the\n- * #GHashTable, and also when they are overwritten by new insertions\n- * into the #GHashTable. It is also not advisable to mix static strings\n- * and dynamically-allocated strings in a #GHashTable, because it then\n- * becomes difficult to determine whether the string should be freed.\n- *\n- * To create a #GHashTable, use g_hash_table_new().\n- *\n- * To insert a key and value into a #GHashTable, use\n- * g_hash_table_insert().\n- *\n- * To look up a value corresponding to a given key, use\n- * g_hash_table_lookup() and g_hash_table_lookup_extended().\n- *\n- * g_hash_table_lookup_extended() can also be used to simply\n- * check if a key is present in the hash table.\n- *\n- * To remove a key and value, use g_hash_table_remove().\n- *\n- * To call a function for each key and value pair use\n- * g_hash_table_foreach() or use an iterator to iterate over the\n- * key\/value pairs in the hash table, see #GHashTableIter. The iteration order\n- * of a hash table is not defined, and you must not rely on iterating over\n- * keys\/values in the same order as they were inserted.\n- *\n- * To destroy a #GHashTable use g_hash_table_destroy().\n- *\n- * A common use-case for hash tables is to store information about a\n- * set of keys, without associating any particular value with each\n- * key. GHashTable optimizes one way of doing so: If you store only\n- * key-value pairs where key == value, then GHashTable does not\n- * allocate memory to store the values, which can be a considerable\n- * space saving, if your set is large. The functions\n- * g_hash_table_add() and g_hash_table_contains() are designed to be\n- * used when using #GHashTable this way.\n- *\n- * #GHashTable is not designed to be statically initialised with keys and\n- * values known at compile time. To build a static hash table, use a tool such\n- * as [gperf](https:\/\/www.gnu.org\/software\/gperf\/).\n- *\/\n-\n@@ -1032,1 +973,1 @@\n- * Returns: a new #GHashTable\n+ * Returns: (transfer full): a new #GHashTable\n@@ -1065,1 +1006,1 @@\n- * Returns: a new #GHashTable\n+ * Returns: (transfer full): a new #GHashTable\n@@ -1168,1 +1109,1 @@\n- * @key: (out) (optional): a location to store the key\n+ * @key: (out) (optional) (nullable): a location to store the key\n@@ -1221,1 +1162,1 @@\n- * Returns: the #GHashTable associated with @iter.\n+ * Returns: (transfer none): the #GHashTable associated with @iter.\n@@ -1465,1 +1406,1 @@\n- * Returns: the passed in #GHashTable\n+ * Returns: (transfer full): the passed in #GHashTable\n@@ -1481,1 +1422,1 @@\n- * @hash_table: a valid #GHashTable\n+ * @hash_table: (transfer full): a valid #GHashTable\n@@ -2086,1 +2027,1 @@\n- * @func: the function to call for each key\/value pair\n+ * @func: (scope call): the function to call for each key\/value pair\n@@ -2114,1 +2055,1 @@\n- * @func: the function to call for each key\/value pair\n+ * @func: (scope call): the function to call for each key\/value pair\n@@ -2141,1 +2082,1 @@\n- * @func: the function to call for each key\/value pair\n+ * @func: (scope call): the function to call for each key\/value pair\n@@ -2192,1 +2133,1 @@\n- * @predicate: function to test the key\/value pairs for a certain property\n+ * @predicate: (scope call): function to test the key\/value pairs for a certain property\n@@ -2619,0 +2560,44 @@\n+\/**\n+ * g_uint_equal:\n+ * @v1: (not nullable): a pointer to a #guint key\n+ * @v2: (not nullable): a pointer to a #guint key to compare with @v1\n+ *\n+ * Compares the two #guint values being pointed to and returns\n+ * %TRUE if they are equal.\n+ * It can be passed to g_hash_table_new() as the @key_equal_func\n+ * parameter, when using non-%NULL pointers to integers as keys in a\n+ * #GHashTable.\n+ *\n+ * Note that this function acts on pointers to #guint, not on #guint\n+ * directly: if your hash table's keys are of the form\n+ * `GUINT_TO_POINTER (n)`, use g_direct_equal() instead.\n+ *\n+ * Returns: %TRUE if the two keys match.\n+ *\/\n+gboolean\n+g_uint_equal (gconstpointer v1,\n+              gconstpointer v2)\n+{\n+  return *((const guint *) v1) == *((const guint *) v2);\n+}\n+\n+\/**\n+ * g_uint_hash:\n+ * @v: (not nullable): a pointer to a #guint key\n+ *\n+ * Converts a pointer to a #guint to a hash value.\n+ * It can be passed to g_hash_table_new() as the @hash_func parameter,\n+ * when using non-%NULL pointers to integer values as keys in a #GHashTable.\n+ *\n+ * Note that this function acts on pointers to #guint, not on #guint\n+ * directly: if your hash table's keys are of the form\n+ * `GUINT_TO_POINTER (n)`, use g_direct_hash() instead.\n+ *\n+ * Returns: a hash value corresponding to the key.\n+ *\/\n+guint\n+g_uint_hash (gconstpointer v)\n+{\n+  return *(const guint *) v;\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ghash.c","additions":54,"deletions":69,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -40,3 +40,1 @@\n- * SECTION:hmac\n- * @title: Secure HMAC Digests\n- * @short_description: computes the HMAC for data\n+ * GHmac:\n@@ -56,0 +54,5 @@\n+ *\n+ * To create a new `GHmac`, use [ctor@GLib.Hmac.new]. To free a `GHmac`, use\n+ * [method@GLib.Hmac.unref].\n+ *\n+ * Since: 2.30\n@@ -67,1 +70,1 @@\n- * g_hmac_new:\n+ * g_hmac_new: (constructor)\n@@ -89,1 +92,1 @@\n- * Returns: the newly created #GHmac, or %NULL.\n+ * Returns: (nullable) (transfer full): the newly created #GHmac, or %NULL.\n@@ -180,1 +183,1 @@\n- * Returns: the copy of the passed #GHmac. Use g_hmac_unref()\n+ * Returns: (transfer full): the copy of the passed #GHmac. Use g_hmac_unref()\n@@ -209,1 +212,1 @@\n- * Returns: the passed in #GHmac.\n+ * Returns: (transfer full): the passed in #GHmac.\n@@ -225,1 +228,1 @@\n- * @hmac: a #GHmac\n+ * @hmac: (transfer full): a #GHmac\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ghmac.c","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,9 +33,0 @@\n-\/**\n- * GHmac:\n- *\n- * An opaque structure representing a HMAC operation.\n- * To create a new GHmac, use g_hmac_new(). To free\n- * a GHmac, use g_hmac_unref().\n- *\n- * Since: 2.30\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ghmac.h","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,10 +41,0 @@\n-\/**\n- * SECTION:hooks\n- * @title: Hook Functions\n- * @short_description: support for manipulating lists of hook functions\n- *\n- * The #GHookList, #GHook and their related functions provide support for\n- * lists of hook functions. Functions can be added and removed from the lists,\n- * and the list of hook functions can be invoked.\n- *\/\n-\n@@ -600,1 +590,1 @@\n- * @marshaller: the function to call for each #GHook\n+ * @marshaller: (scope call): the function to call for each #GHook\n@@ -650,1 +640,1 @@\n- * @marshaller: the function to call for each #GHook\n+ * @marshaller: (scope call): the function to call for each #GHook\n@@ -808,1 +798,1 @@\n- * @func: the function to call for each #GHook, which should return\n+ * @func: (scope call): the function to call for each #GHook, which should return\n@@ -985,1 +975,1 @@\n- * @func: the comparison function used to sort the #GHook elements\n+ * @func: (scope call): the comparison function used to sort the #GHook elements\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ghook.c","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -62,0 +62,18 @@\n+\/**\n+ * SECTION:ghostutils\n+ * @short_description: Internet hostname utilities\n+ *\n+ * Functions for manipulating internet hostnames; in particular, for\n+ * converting between Unicode and ASCII-encoded forms of\n+ * Internationalized Domain Names (IDNs).\n+ *\n+ * The\n+ * [Internationalized Domain Names for Applications (IDNA)](http:\/\/www.ietf.org\/rfc\/rfc3490.txt)\n+ * standards allow for the use\n+ * of Unicode domain names in applications, while providing\n+ * backward-compatibility with the old ASCII-only DNS, by defining an\n+ * ASCII-Compatible Encoding of any given Unicode name, which can be\n+ * used with non-IDN-aware applications and protocols. (For example,\n+ * \"Παν語.org\" maps to \"xn--4wa8awb4637h.org\".)\n+ **\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ghostutils.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -47,5 +47,1 @@\n- * SECTION:iochannels\n- * @title: IO Channels\n- * @short_description: portable support for using files, pipes and sockets\n- * @see_also: g_io_add_watch(), g_io_add_watch_full(), g_source_remove(),\n- *     #GMainLoop\n+ * GIOChannel:\n@@ -53,1 +49,1 @@\n- * The #GIOChannel data type aims to provide a portable method for\n+ * The `GIOChannel` data type aims to provide a portable method for\n@@ -55,2 +51,2 @@\n- * into the [main event loop][glib-The-Main-Event-Loop]. Currently,\n- * full support is available on UNIX platforms, support for Windows\n+ * into the main event loop (see [struct@GLib.MainContext]). Currently,\n+ * full support is available on UNIX platforms; support for Windows\n@@ -59,2 +55,2 @@\n- * To create a new #GIOChannel on UNIX systems use\n- * g_io_channel_unix_new(). This works for plain file descriptors,\n+ * To create a new `GIOChannel` on UNIX systems use\n+ * [ctor@GLib.IOChannel.unix_new]. This works for plain file descriptors,\n@@ -62,1 +58,1 @@\n- * file in a system independent manner using g_io_channel_new_file().\n+ * file in a system independent manner using [ctor@GLib.IOChannel.new_file].\n@@ -64,4 +60,4 @@\n- * Once a #GIOChannel has been created, it can be used in a generic\n- * manner with the functions g_io_channel_read_chars(),\n- * g_io_channel_write_chars(), g_io_channel_seek_position(), and\n- * g_io_channel_shutdown().\n+ * Once a `GIOChannel` has been created, it can be used in a generic\n+ * manner with the functions [method@GLib.IOChannel.read_chars],\n+ * [method@GLib.IOChannel.write_chars], [method@GLib.IOChannel.seek_position],\n+ * and [method@GLib.IOChannel.shutdown].\n@@ -69,4 +65,4 @@\n- * To add a #GIOChannel to the [main event loop][glib-The-Main-Event-Loop],\n- * use g_io_add_watch() or g_io_add_watch_full(). Here you specify which\n- * events you are interested in on the #GIOChannel, and provide a\n- * function to be called whenever these events occur.\n+ * To add a `GIOChannel` to the main event loop, use [func@GLib.io_add_watch] or\n+ * [func@GLib.io_add_watch_full]. Here you specify which events you are\n+ * interested in on the `GIOChannel`, and provide a function to be called\n+ * whenever these events occur.\n@@ -74,2 +70,2 @@\n- * #GIOChannel instances are created with an initial reference count of 1.\n- * g_io_channel_ref() and g_io_channel_unref() can be used to\n+ * `GIOChannel` instances are created with an initial reference count of 1.\n+ * [method@GLib.IOChannel.ref] and [method@GLib.IOChannel.unref] can be used to\n@@ -77,15 +73,4 @@\n- * reference count falls to 0, the #GIOChannel is freed. (Though it\n- * isn't closed automatically, unless it was created using\n- * g_io_channel_new_file().) Using g_io_add_watch() or\n- * g_io_add_watch_full() increments a channel's reference count.\n- *\n- * The new functions g_io_channel_read_chars(),\n- * g_io_channel_read_line(), g_io_channel_read_line_string(),\n- * g_io_channel_read_to_end(), g_io_channel_write_chars(),\n- * g_io_channel_seek_position(), and g_io_channel_flush() should not be\n- * mixed with the deprecated functions g_io_channel_read(),\n- * g_io_channel_write(), and g_io_channel_seek() on the same channel.\n- **\/\n-\n-\/**\n- * GIOChannel:\n+ * reference count falls to 0, the `GIOChannel` is freed. (Though it\n+ * isn’t closed automatically, unless it was created using\n+ * [ctor@GLib.IOChannel.new_file].) Using [func@GLib.io_add_watch] or\n+ * [func@GLib.io_add_watch_full] increments a channel’s reference count.\n@@ -93,3 +78,7 @@\n- * A data structure representing an IO Channel. The fields should be\n- * considered private and should only be accessed with the following\n- * functions.\n+ * The new functions [method@GLib.IOChannel.read_chars],\n+ * [method@GLib.IOChannel.read_line], [method@GLib.IOChannel.read_line_string],\n+ * [method@GLib.IOChannel.read_to_end], [method@GLib.IOChannel.write_chars],\n+ * [method@GLib.IOChannel.seek_position], and [method@GLib.IOChannel.flush]\n+ * should not be mixed with the deprecated functions\n+ * [method@GLib.IOChannel.read], [method@GLib.IOChannel.write], and\n+ * [method@GLib.IOChannel.seek] on the same channel.\n@@ -108,1 +97,1 @@\n- * @io_seek: (optional) seeks the channel.  This is called from\n+ * @io_seek: (optional): seeks the channel.  This is called from\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/giochannel.c","additions":29,"deletions":40,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1664,1 +1664,1 @@\n-        \/* Fall through *\/\n+        G_GNUC_FALLTHROUGH;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/giowin32.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,3 +77,3 @@\n- * SECTION:gkeyfile\n- * @title: Key-value file parser\n- * @short_description: parses .ini-like config files\n+ * GKeyFile:\n+ *\n+ * `GKeyFile` parses .ini-like config files.\n@@ -81,1 +81,1 @@\n- * #GKeyFile lets you parse, edit or create files containing groups of\n+ * `GKeyFile` lets you parse, edit or create files containing groups of\n@@ -85,2 +85,1 @@\n- * and the\n- * [Icon Theme Specification](http:\/\/freedesktop.org\/Standards\/icon-theme-spec).\n+ * and the [Icon Theme Specification](http:\/\/freedesktop.org\/Standards\/icon-theme-spec).\n@@ -90,2 +89,2 @@\n- * here is a quick summary: Key files\n- * consists of groups of key-value pairs, interspersed with comments.\n+ * here is a quick summary: Key files consists of groups of key-value pairs, interspersed\n+ * with comments.\n@@ -93,1 +92,1 @@\n- * |[\n+ * ```txt\n@@ -106,1 +105,0 @@\n- * Welcome[be@latin]=Hello\n@@ -113,1 +111,1 @@\n- * ]|\n+ * ```\n@@ -121,9 +119,7 @@\n- * Key-value pairs generally have the form `key=value`, with the\n- * exception of localized strings, which have the form\n- * `key[locale]=value`, with a locale identifier of the\n- * form `lang_COUNTRY@MODIFIER` where `COUNTRY` and `MODIFIER`\n- * are optional.\n- * Space before and after the '=' character are ignored. Newline, tab,\n- * carriage return and backslash characters in value are escaped as \\n,\n- * \\t, \\r, and \\\\\\\\, respectively. To preserve leading spaces in values,\n- * these can also be escaped as \\s.\n+ * Key-value pairs generally have the form `key=value`, with the exception\n+ * of localized strings, which have the form `key[locale]=value`, with a\n+ * locale identifier of the form `lang_COUNTRY@MODIFIER` where `COUNTRY`\n+ * and `MODIFIER` are optional. Space before and after the '=' character\n+ * are ignored. Newline, tab, carriage return and backslash characters in\n+ * value are escaped as `\\n`, `\\t`, `\\r`, and `\\\\\\\\`, respectively. To preserve\n+ * leading spaces in values, these can also be escaped as `\\s`.\n@@ -156,4 +152,3 @@\n- * groups in key files may contain the same\n- * key multiple times; the last entry wins. Key files may also contain\n- * multiple groups with the same name; they are merged together.\n- * Another difference is that keys and group names in key files are not\n+ * groups in key files may contain the same key multiple times; the last entry wins.\n+ * Key files may also contain multiple groups with the same name; they are merged\n+ * together. Another difference is that keys and group names in key files are not\n@@ -164,1 +159,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -187,1 +182,1 @@\n- * ]|\n+ * ```\n@@ -191,1 +186,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -214,1 +209,1 @@\n- * ]|\n+ * ```\n@@ -502,6 +497,0 @@\n-\/**\n- * GKeyFile:\n- *\n- * The GKeyFile struct contains only private data\n- * and should not be accessed directly.\n- *\/\n@@ -4434,1 +4423,0 @@\n-        g_clear_error (error);\n@@ -4457,15 +4445,0 @@\n-                      \/* FIXME: This should be a fatal error, but there was a\n-                       * bug which prevented that being reported for a long\n-                       * time, so a lot of applications and in-the-field key\n-                       * files use invalid escape sequences without anticipating\n-                       * problems. For now (GLib 2.78), message about it; in\n-                       * future, the behaviour may become fatal again.\n-                       *\n-                       * The previous behaviour was to set the #GError but not\n-                       * return failure from the function, so the caller could\n-                       * explicitly check for invalid escapes, but also ignore\n-                       * the error if they want. This is not how #GError is\n-                       * meant to be used, but the #GKeyFile code is very old.\n-                       *\n-                       * See https:\/\/gitlab.gnome.org\/GNOME\/glib\/-\/issues\/3098 *\/\n-                      g_clear_error (error);\n@@ -4476,0 +4449,1 @@\n+                      goto error;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gkeyfile.c","additions":24,"deletions":50,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#ifndef __GI_SCANNER__\n+\n@@ -116,0 +118,2 @@\n+\n+#endif \/* __GI_SCANNER__ *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-autocleanups.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gconstructorprivate.h\"\n@@ -455,3 +456,4 @@\n-#elif defined(G_HAS_CONSTRUCTORS) \/* && G_PLATFORM_WIN32 && GLIB_STATIC_COMPILATION *\/\n-#ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA\n-#pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(glib_init_ctor)\n+#else\n+\n+#ifndef G_HAS_CONSTRUCTORS\n+#error static compilation on Windows requires constructor support\n@@ -459,2 +461,3 @@\n-#ifdef G_DEFINE_DESTRUCTOR_NEEDS_PRAGMA\n-#pragma G_DEFINE_DESTRUCTOR_PRAGMA_ARGS(glib_init_dtor)\n+\n+#ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA\n+#pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(glib_priv_constructor)\n@@ -463,1 +466,3 @@\n-G_DEFINE_CONSTRUCTOR (glib_init_ctor)\n+static gboolean tls_callback_invoked;\n+\n+G_DEFINE_CONSTRUCTOR (glib_priv_constructor)\n@@ -466,1 +471,1 @@\n-glib_init_ctor (void)\n+glib_priv_constructor (void)\n@@ -469,0 +474,3 @@\n+\n+  if (!tls_callback_invoked)\n+    g_critical (\"TLS callback not invoked\");\n@@ -471,1 +479,5 @@\n-G_DEFINE_DESTRUCTOR (glib_init_dtor)\n+#ifndef G_HAS_TLS_CALLBACKS\n+#error static compilation on Windows requires TLS callbacks support\n+#endif\n+\n+G_DEFINE_TLS_CALLBACK (glib_priv_tls_callback)\n@@ -473,2 +485,4 @@\n-static void\n-glib_init_dtor (void)\n+static void NTAPI\n+glib_priv_tls_callback (LPVOID hinstance,\n+                        DWORD  reason,\n+                        LPVOID reserved)\n@@ -476,1 +490,18 @@\n-  glib_win32_deinit (FALSE);\n+  switch (reason)\n+    {\n+    case DLL_PROCESS_ATTACH:\n+      glib_dll = hinstance;\n+      tls_callback_invoked = TRUE;\n+      break;\n+    case DLL_THREAD_DETACH:\n+#ifdef THREADS_WIN32\n+      g_thread_win32_thread_detach ();\n+#endif\n+      break;\n+    case DLL_PROCESS_DETACH:\n+      glib_win32_deinit (reserved == NULL);\n+      break;\n+\n+    default:\n+      break;\n+    }\n@@ -479,2 +510,0 @@\n-#else \/* G_PLATFORM_WIN32 && GLIB_STATIC_COMPILATION && !G_HAS_CONSTRUCTORS *\/\n-#error Your platform\/compiler is missing constructor support\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-init.c","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"gutilsprivate.h\"\n+#include \"gdatasetprivate.h\"\n@@ -38,1 +40,1 @@\n-GLibPrivateVTable *\n+const GLibPrivateVTable *\n@@ -41,1 +43,1 @@\n-  static GLibPrivateVTable table = {\n+  static const GLibPrivateVTable table = {\n@@ -74,0 +76,4 @@\n+\n+    g_set_prgname_once,\n+\n+    g_datalist_id_update_atomic,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-private.c","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gdatasetprivate.h\"\n@@ -40,1 +41,1 @@\n- * Private macro defined if the AddressSanitizer is in use.\n+ * Private macro defined if the AddressSanitizer is in use by GLib itself.\n@@ -46,0 +47,48 @@\n+\/* If GLib itself is not compiled with ASAN sanitizer we may still want to\n+ * control it in case it's linked by the loading application, so we need to\n+ * do this check dynamically.\n+ * However MinGW doesn't support weak attribute properly (even if it advertises\n+ * it), so we ignore it in such case since it's not convenient to go through\n+ * dlsym().\n+ * Under MSVC we could use alternatename, but it doesn't seem to be as reliable\n+ * as we'd like: https:\/\/stackoverflow.com\/a\/11529277\/210151 and\n+ * https:\/\/devblogs.microsoft.com\/oldnewthing\/20200731-00\/?p=104024\n+ *\/\n+#elif defined (G_OS_UNIX) && !defined (__APPLE__) && g_macro__has_attribute (weak)\n+\n+#define HAS_DYNAMIC_ASAN_LOADING\n+\n+void __lsan_enable (void) __attribute__ ((weak));\n+void __lsan_disable (void) __attribute__ ((weak));\n+void __lsan_ignore_object (const void *p) __attribute__ ((weak));\n+\n+#endif\n+\n+\/**\n+ * G_CONTAINER_OF:\n+ * @ptr: a pointer to a member @field of type @type.\n+ * @type: the type of the container in which @field is embedded.\n+ * @field: the name of the field in @type.\n+ *\n+ * Casts away constness of @ptr.\n+ *\n+ * Returns: a pointer to the container, so that \"&(@container)->field == (@ptr)\" holds.\n+ *\/\n+#define G_CONTAINER_OF(ptr, type, field) ((type *) G_STRUCT_MEMBER_P (ptr, -G_STRUCT_OFFSET (type, field)))\n+\n+\/*\n+ * g_leak_sanitizer_is_supported:\n+ *\n+ * Checks at runtime if LeakSanitizer is currently supported by the running\n+ * binary. This may imply that GLib itself is not compiled with sanitizer\n+ * but that the loading program is.\n+ *\/\n+static inline gboolean\n+g_leak_sanitizer_is_supported (void)\n+{\n+#if defined (_GLIB_ADDRESS_SANITIZER)\n+  return TRUE;\n+#elif defined (HAS_DYNAMIC_ASAN_LOADING)\n+  return __lsan_enable != NULL && __lsan_ignore_object != NULL;\n+#else\n+  return FALSE;\n@@ -47,0 +96,1 @@\n+}\n@@ -60,1 +110,1 @@\n-#ifdef _GLIB_ADDRESS_SANITIZER\n+#if defined (_GLIB_ADDRESS_SANITIZER)\n@@ -63,0 +113,3 @@\n+#elif defined (HAS_DYNAMIC_ASAN_LOADING)\n+  if (p != NULL && __lsan_ignore_object != NULL)\n+    __lsan_ignore_object (p);\n@@ -76,1 +129,0 @@\n-#ifdef _GLIB_ADDRESS_SANITIZER\n@@ -79,0 +131,3 @@\n+  if (!g_leak_sanitizer_is_supported ())\n+    return;\n+\n@@ -86,1 +141,0 @@\n-#endif\n@@ -101,1 +155,1 @@\n-#ifdef _GLIB_ADDRESS_SANITIZER\n+#if defined (_GLIB_ADDRESS_SANITIZER)\n@@ -103,0 +157,3 @@\n+#elif defined (HAS_DYNAMIC_ASAN_LOADING)\n+  if (__lsan_disable != NULL)\n+    __lsan_disable ();\n@@ -115,1 +172,1 @@\n-#ifdef _GLIB_ADDRESS_SANITIZER\n+#if defined (_GLIB_ADDRESS_SANITIZER)\n@@ -117,0 +174,3 @@\n+#elif defined (HAS_DYNAMIC_ASAN_LOADING)\n+  if (__lsan_enable != NULL)\n+    __lsan_enable ();\n@@ -120,0 +180,2 @@\n+#undef HAS_DYNAMIC_ASAN_LOADING\n+\n@@ -230,0 +292,8 @@\n+  \/* See gutils.c *\/\n+  gboolean (* g_set_prgname_once) (const gchar *prgname);\n+\n+  gpointer (*g_datalist_id_update_atomic) (GData **datalist,\n+                                           GQuark key_id,\n+                                           GDataListUpdateAtomicFunc callback,\n+                                           gpointer user_data);\n+\n@@ -234,1 +304,1 @@\n-GLibPrivateVTable *glib__private__ (void);\n+const GLibPrivateVTable *glib__private__ (void);\n@@ -257,0 +327,13 @@\n+gboolean g_uint_equal (gconstpointer v1, gconstpointer v2);\n+guint g_uint_hash (gconstpointer v);\n+\n+#if defined(__GNUC__)\n+#define G_THREAD_LOCAL __thread\n+#else\n+#undef G_THREAD_LOCAL\n+#endif\n+\n+\/* Convenience wrapper to call private g_datalist_id_update_atomic() function. *\/\n+#define _g_datalist_id_update_atomic(datalist, key_id, callback, user_data) \\\n+  (GLIB_PRIVATE_CALL (g_datalist_id_update_atomic) ((datalist), (key_id), (callback), (user_data)))\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-private.h","additions":90,"deletions":7,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,16 @@\n- * Copyright (C) 2011 Red Hat, Inc.\n+ * Copyright 2000-2022 Red Hat, Inc.\n+ * Copyright 2006-2007 Matthias Clasen\n+ * Copyright 2006 Padraig O'Briain\n+ * Copyright 2007 Lennart Poettering\n+ * Copyright 2018-2022 Endless OS Foundation, LLC\n+ * Copyright 2018 Peter Wu\n+ * Copyright 2019 Ting-Wei Lan\n+ * Copyright 2019 Sebastian Schwarz\n+ * Copyright 2020 Matt Rose\n+ * Copyright 2021 Casper Dik\n+ * Copyright 2022 Alexander Richardson\n+ * Copyright 2022 Ray Strode\n+ * Copyright 2022 Thomas Haller\n+ * Copyright 2023-2024 Collabora Ltd.\n+ * Copyright 2023 Sebastian Wilhelmi\n+ * Copyright 2023 CaiJingLong\n@@ -30,0 +45,4 @@\n+#include <dirent.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdlib.h>   \/* for fdwalk *\/\n@@ -33,0 +52,14 @@\n+#include <unistd.h>\n+\n+#if defined(__linux__) || defined(__DragonFly__)\n+#include <sys\/syscall.h>  \/* for syscall and SYS_getdents64 *\/\n+#endif\n+\n+#ifdef HAVE_SYS_RESOURCE_H\n+#include <sys\/resource.h>\n+#endif \/* HAVE_SYS_RESOURCE_H *\/\n+\n+#if defined(__APPLE__) && defined(HAVE_LIBPROC_H)\n+#include <libproc.h>\n+#include <sys\/proc_info.h>\n+#endif\n@@ -46,15 +79,0 @@\n-\/**\n- * SECTION:gunix\n- * @title: UNIX-specific utilities and integration\n- * @short_description: pipes, signal handling\n- * @include: glib-unix.h\n- *\n- * Most of GLib is intended to be portable; in contrast, this set of\n- * functions is designed for programs which explicitly target UNIX,\n- * or are using it to build higher level abstractions which would be\n- * conditionally compiled if the platform matches %G_OS_UNIX.\n- *\n- * To use these functions, you must explicitly include the\n- * \"glib-unix.h\" header.\n- *\/\n-\n@@ -90,0 +108,3 @@\n+ * Since GLib 2.80, the constants %G_UNIX_PIPE_END_READ and\n+ * %G_UNIX_PIPE_END_WRITE can be used as mnemonic indexes in @fds.\n+ *\n@@ -521,0 +542,385 @@\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static int\n+set_cloexec (void *data, gint fd)\n+{\n+  if (fd >= GPOINTER_TO_INT (data))\n+    fcntl (fd, F_SETFD, FD_CLOEXEC);\n+\n+  return 0;\n+}\n+\n+\/* fdwalk()-compatible callback to close a fd for non-compliant\n+ * implementations of fdwalk() that potentially pass already\n+ * closed fds.\n+ *\n+ * It is not an error to pass an invalid fd to this function.\n+ *\n+ * This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)).\n+ *\/\n+G_GNUC_UNUSED static int\n+close_func_with_invalid_fds (void *data, int fd)\n+{\n+  \/* We use close and not g_close here because on some platforms, we\n+   * don't know how to close only valid, open file descriptors, so we\n+   * have to pass bad fds to close too. g_close warns if given a bad\n+   * fd.\n+   *\n+   * This function returns no error, because there is nothing that the caller\n+   * could do with that information. That is even the case for EINTR. See\n+   * g_close() about the specialty of EINTR and why that is correct.\n+   * If g_close() ever gets extended to handle EINTR specially, then this place\n+   * should get updated to do the same handling.\n+   *\/\n+  if (fd >= GPOINTER_TO_INT (data))\n+    close (fd);\n+\n+  return 0;\n+}\n+\n+#ifdef __linux__\n+struct linux_dirent64\n+{\n+  guint64        d_ino;    \/* 64-bit inode number *\/\n+  guint64        d_off;    \/* 64-bit offset to next structure *\/\n+  unsigned short d_reclen; \/* Size of this dirent *\/\n+  unsigned char  d_type;   \/* File type *\/\n+  char           d_name[]; \/* Filename (null-terminated) *\/\n+};\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static gint\n+filename_to_fd (const char *p)\n+{\n+  char c;\n+  int fd = 0;\n+  const int cutoff = G_MAXINT \/ 10;\n+  const int cutlim = G_MAXINT % 10;\n+\n+  if (*p == '\\0')\n+    return -1;\n+\n+  while ((c = *p++) != '\\0')\n+    {\n+      if (c < '0' || c > '9')\n+        return -1;\n+      c -= '0';\n+\n+      \/* Check for overflow. *\/\n+      if (fd > cutoff || (fd == cutoff && c > cutlim))\n+        return -1;\n+\n+      fd = fd * 10 + c;\n+    }\n+\n+  return fd;\n+}\n+#endif\n+\n+static int safe_fdwalk_with_invalid_fds (int (*cb)(void *data, int fd), void *data);\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static int\n+safe_fdwalk (int (*cb)(void *data, int fd), void *data)\n+{\n+#if 0\n+  \/* Use fdwalk function provided by the system if it is known to be\n+   * async-signal safe.\n+   *\n+   * Currently there are no operating systems known to provide a safe\n+   * implementation, so this section is not used for now.\n+   *\/\n+  return fdwalk (cb, data);\n+#else\n+  \/* Fallback implementation of fdwalk. It should be async-signal safe, but it\n+   * may fail on non-Linux operating systems. See safe_fdwalk_with_invalid_fds\n+   * for a slower alternative.\n+   *\/\n+\n+#ifdef __linux__\n+  gint fd;\n+  gint res = 0;\n+\n+  \/* Avoid use of opendir\/closedir since these are not async-signal-safe. *\/\n+  int dir_fd = open (\"\/proc\/self\/fd\", O_RDONLY | O_DIRECTORY);\n+  if (dir_fd >= 0)\n+    {\n+      \/* buf needs to be aligned correctly to receive linux_dirent64.\n+       * C11 has _Alignof for this purpose, but for now a\n+       * union serves the same purpose. *\/\n+      union\n+      {\n+        char buf[4096];\n+        struct linux_dirent64 alignment;\n+      } u;\n+      int pos, nread;\n+      struct linux_dirent64 *de;\n+\n+      while ((nread = syscall (SYS_getdents64, dir_fd, u.buf, sizeof (u.buf))) > 0)\n+        {\n+          for (pos = 0; pos < nread; pos += de->d_reclen)\n+            {\n+              de = (struct linux_dirent64 *) (u.buf + pos);\n+\n+              fd = filename_to_fd (de->d_name);\n+              if (fd < 0 || fd == dir_fd)\n+                  continue;\n+\n+              if ((res = cb (data, fd)) != 0)\n+                  break;\n+            }\n+        }\n+\n+      g_close (dir_fd, NULL);\n+      return res;\n+    }\n+\n+  \/* If \/proc is not mounted or not accessible we fail here and rely on\n+   * safe_fdwalk_with_invalid_fds to fall back to the old\n+   * rlimit trick. *\/\n+\n+#endif\n+\n+#if defined(__sun__) && defined(F_PREVFD) && defined(F_NEXTFD)\n+\/*\n+ * Solaris 11.4 has a signal-safe way which allows\n+ * us to find all file descriptors in a process.\n+ *\n+ * fcntl(fd, F_NEXTFD, maxfd)\n+ * - returns the first allocated file descriptor <= maxfd  > fd.\n+ *\n+ * fcntl(fd, F_PREVFD)\n+ * - return highest allocated file descriptor < fd.\n+ *\/\n+  gint fd;\n+  gint res = 0;\n+\n+  open_max = fcntl (INT_MAX, F_PREVFD); \/* find the maximum fd *\/\n+  if (open_max < 0) \/* No open files *\/\n+    return 0;\n+\n+  for (fd = -1; (fd = fcntl (fd, F_NEXTFD, open_max)) != -1; )\n+    if ((res = cb (data, fd)) != 0 || fd == open_max)\n+      break;\n+\n+  return res;\n+#endif\n+\n+  return safe_fdwalk_with_invalid_fds (cb, data);\n+#endif\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static int\n+safe_fdwalk_with_invalid_fds (int (*cb)(void *data, int fd), void *data)\n+{\n+  \/* Fallback implementation of fdwalk. It should be async-signal safe, but it\n+   * may be slow, especially on systems allowing very high number of open file\n+   * descriptors.\n+   *\/\n+  gint open_max = -1;\n+  gint fd;\n+  gint res = 0;\n+\n+#if 0 && defined(HAVE_SYS_RESOURCE_H)\n+  struct rlimit rl;\n+\n+  \/* Use getrlimit() function provided by the system if it is known to be\n+   * async-signal safe.\n+   *\n+   * Currently there are no operating systems known to provide a safe\n+   * implementation, so this section is not used for now.\n+   *\/\n+  if (getrlimit (RLIMIT_NOFILE, &rl) == 0 && rl.rlim_max != RLIM_INFINITY)\n+    open_max = rl.rlim_max;\n+#endif\n+#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__APPLE__)\n+  \/* Use sysconf() function provided by the system if it is known to be\n+   * async-signal safe.\n+   *\n+   * FreeBSD: sysconf() is included in the list of async-signal safe functions\n+   * found in https:\/\/man.freebsd.org\/sigaction(2).\n+   *\n+   * OpenBSD: sysconf() is included in the list of async-signal safe functions\n+   * found in https:\/\/man.openbsd.org\/sigaction.2.\n+   *\n+   * Apple: sysconf() is included in the list of async-signal safe functions\n+   * found in https:\/\/opensource.apple.com\/source\/xnu\/xnu-517.12.7\/bsd\/man\/man2\/sigaction.2\n+   *\/\n+  if (open_max < 0)\n+    open_max = sysconf (_SC_OPEN_MAX);\n+#endif\n+  \/* Hardcoded fallback: the default process hard limit in Linux as of 2020 *\/\n+  if (open_max < 0)\n+    open_max = 4096;\n+\n+#if defined(__APPLE__) && defined(HAVE_LIBPROC_H)\n+  \/* proc_pidinfo isn't documented as async-signal-safe but looking at the implementation\n+   * in the darwin tree here:\n+   *\n+   * https:\/\/opensource.apple.com\/source\/Libc\/Libc-498\/darwin\/libproc.c.auto.html\n+   *\n+   * It's just a thin wrapper around a syscall, so it's probably okay.\n+   *\/\n+  {\n+    char buffer[4096 * PROC_PIDLISTFD_SIZE];\n+    ssize_t buffer_size;\n+\n+    buffer_size = proc_pidinfo (getpid (), PROC_PIDLISTFDS, 0, buffer, sizeof (buffer));\n+\n+    if (buffer_size > 0 &&\n+        sizeof (buffer) >= (size_t) buffer_size &&\n+        (buffer_size % PROC_PIDLISTFD_SIZE) == 0)\n+      {\n+        const struct proc_fdinfo *fd_info = (const struct proc_fdinfo *) buffer;\n+        size_t number_of_fds = (size_t) buffer_size \/ PROC_PIDLISTFD_SIZE;\n+\n+        for (size_t i = 0; i < number_of_fds; i++)\n+          if ((res = cb (data, fd_info[i].proc_fd)) != 0)\n+            break;\n+\n+        return res;\n+      }\n+  }\n+#endif\n+\n+  for (fd = 0; fd < open_max; fd++)\n+      if ((res = cb (data, fd)) != 0)\n+          break;\n+\n+  return res;\n+}\n+\n+\/**\n+ * g_fdwalk_set_cloexec:\n+ * @lowfd: Minimum fd to act on, which must be non-negative\n+ *\n+ * Mark every file descriptor equal to or greater than @lowfd to be closed\n+ * at the next `execve()` or similar, as if via the `FD_CLOEXEC` flag.\n+ *\n+ * Typically @lowfd will be 3, to leave standard input, standard output\n+ * and standard error open after exec.\n+ *\n+ * This is the same as Linux `close_range (lowfd, ~0U, CLOSE_RANGE_CLOEXEC)`,\n+ * but portable to other OSs and to older versions of Linux.\n+ *\n+ * This function is async-signal safe, making it safe to call from a\n+ * signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is\n+ * non-negative.\n+ * See [`signal(7)`](man:signal(7)) and\n+ * [`signal-safety(7)`](man:signal-safety(7)) for more details.\n+ *\n+ * Returns: 0 on success, -1 with errno set on error\n+ * Since: 2.80\n+ *\/\n+int\n+g_fdwalk_set_cloexec (int lowfd)\n+{\n+  int ret;\n+\n+  g_return_val_if_fail (lowfd >= 0, (errno = EINVAL, -1));\n+\n+#if defined(HAVE_CLOSE_RANGE) && defined(CLOSE_RANGE_CLOEXEC)\n+  \/* close_range() is available in Linux since kernel 5.9, and on FreeBSD at\n+   * around the same time. It was designed for use in async-signal-safe\n+   * situations: https:\/\/bugs.python.org\/issue38061\n+   *\n+   * The `CLOSE_RANGE_CLOEXEC` flag was added in Linux 5.11, and is not yet\n+   * present in FreeBSD.\n+   *\n+   * Handle ENOSYS in case it’s supported in libc but not the kernel; if so,\n+   * fall back to safe_fdwalk(). Handle EINVAL in case `CLOSE_RANGE_CLOEXEC`\n+   * is not supported. *\/\n+  ret = close_range (lowfd, G_MAXUINT, CLOSE_RANGE_CLOEXEC);\n+  if (ret == 0 || !(errno == ENOSYS || errno == EINVAL))\n+    return ret;\n+#endif  \/* HAVE_CLOSE_RANGE *\/\n+\n+  ret = safe_fdwalk (set_cloexec, GINT_TO_POINTER (lowfd));\n+\n+  return ret;\n+}\n+\n+\/**\n+ * g_closefrom:\n+ * @lowfd: Minimum fd to close, which must be non-negative\n+ *\n+ * Close every file descriptor equal to or greater than @lowfd.\n+ *\n+ * Typically @lowfd will be 3, to leave standard input, standard output\n+ * and standard error open.\n+ *\n+ * This is the same as Linux `close_range (lowfd, ~0U, 0)`,\n+ * but portable to other OSs and to older versions of Linux.\n+ * Equivalently, it is the same as BSD `closefrom (lowfd)`, but portable,\n+ * and async-signal-safe on all OSs.\n+ *\n+ * This function is async-signal safe, making it safe to call from a\n+ * signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is\n+ * non-negative.\n+ * See [`signal(7)`](man:signal(7)) and\n+ * [`signal-safety(7)`](man:signal-safety(7)) for more details.\n+ *\n+ * Returns: 0 on success, -1 with errno set on error\n+ * Since: 2.80\n+ *\/\n+int\n+g_closefrom (int lowfd)\n+{\n+  int ret;\n+\n+  g_return_val_if_fail (lowfd >= 0, (errno = EINVAL, -1));\n+\n+#if defined(HAVE_CLOSE_RANGE)\n+  \/* close_range() is available in Linux since kernel 5.9, and on FreeBSD at\n+   * around the same time. It was designed for use in async-signal-safe\n+   * situations: https:\/\/bugs.python.org\/issue38061\n+   *\n+   * Handle ENOSYS in case it’s supported in libc but not the kernel; if so,\n+   * fall back to safe_fdwalk(). *\/\n+  ret = close_range (lowfd, G_MAXUINT, 0);\n+  if (ret == 0 || errno != ENOSYS)\n+    return ret;\n+#endif  \/* HAVE_CLOSE_RANGE *\/\n+\n+#if defined(__FreeBSD__) || defined(__OpenBSD__) || \\\n+  (defined(__sun__) && defined(F_CLOSEFROM))\n+  \/* Use closefrom function provided by the system if it is known to be\n+   * async-signal safe.\n+   *\n+   * FreeBSD: closefrom is included in the list of async-signal safe functions\n+   * found in https:\/\/man.freebsd.org\/sigaction(2).\n+   *\n+   * OpenBSD: closefrom is not included in the list, but a direct system call\n+   * should be safe to use.\n+   *\n+   * In Solaris as of 11.3 SRU 31, closefrom() is also a direct system call.\n+   * On such systems, F_CLOSEFROM is defined.\n+   *\/\n+  (void) closefrom (lowfd);\n+  return 0;\n+#elif defined(__DragonFly__)\n+  \/* It is unclear whether closefrom function included in DragonFlyBSD libc_r\n+   * is safe to use because it calls a lot of library functions. It is also\n+   * unclear whether libc_r itself is still being used. Therefore, we do a\n+   * direct system call here ourselves to avoid possible issues.\n+   *\/\n+  (void) syscall (SYS_closefrom, lowfd);\n+  return 0;\n+#elif defined(F_CLOSEM)\n+  \/* NetBSD and AIX have a special fcntl command which does the same thing as\n+   * closefrom. NetBSD also includes closefrom function, which seems to be a\n+   * simple wrapper of the fcntl command.\n+   *\/\n+  return fcntl (lowfd, F_CLOSEM);\n+#else\n+  ret = safe_fdwalk (close_func_with_invalid_fds, GINT_TO_POINTER (lowfd));\n+\n+  return ret;\n+#endif\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-unix.c","additions":422,"deletions":16,"binary":false,"changes":438,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2023 Collabora Ltd.\n@@ -36,0 +37,1 @@\n+#include <glib\/gstdio.h>\n@@ -123,0 +125,212 @@\n+\/**\n+ * GUnixPipe:\n+ * @fds: A pair of file descriptors, each negative if closed or not yet opened.\n+ *  The file descriptor with index %G_UNIX_PIPE_END_READ is readable.\n+ *  The file descriptor with index %G_UNIX_PIPE_END_WRITE is writable.\n+ *\n+ * A Unix pipe. The advantage of this type over `int[2]` is that it can\n+ * be closed automatically when it goes out of scope, using `g_auto(GUnixPipe)`,\n+ * on compilers that support that feature.\n+ *\n+ * Since: 2.80\n+ *\/\n+GLIB_AVAILABLE_TYPE_IN_2_80\n+typedef struct {\n+  int fds[2];\n+} GUnixPipe;\n+\n+\/**\n+ * GUnixPipeEnd:\n+ * @G_UNIX_PIPE_END_READ: The readable file descriptor 0\n+ * @G_UNIX_PIPE_END_WRITE: The writable file descriptor 1\n+ *\n+ * Mnemonic constants for the ends of a Unix pipe.\n+ *\n+ * Since: 2.80\n+ *\/\n+GLIB_AVAILABLE_TYPE_IN_2_80\n+typedef enum\n+{\n+  G_UNIX_PIPE_END_READ = 0,\n+  G_UNIX_PIPE_END_WRITE = 1\n+} GUnixPipeEnd;\n+\n+\/**\n+ * G_UNIX_PIPE_INIT:\n+ *\n+ * Initializer for a #GUnixPipe that has not yet been opened.\n+ * Both of its file descriptors are initialized to `-1` (invalid),\n+ * the same as if they had been closed.\n+ *\n+ * Since: 2.80\n+ *\/\n+#define G_UNIX_PIPE_INIT { { -1, -1 } } GLIB_AVAILABLE_MACRO_IN_2_80\n+\n+\/* Suppress \"Not available before\" warnings when declaring the\n+ * implementations *\/\n+G_GNUC_BEGIN_IGNORE_DEPRECATIONS\n+\n+\/**\n+ * g_unix_pipe_open:\n+ * @self: A pair of file descriptors\n+ * @flags: Flags to pass to g_unix_open_pipe(), typically `O_CLOEXEC`\n+ * @error: Used to report an error on failure\n+ *\n+ * Open a pipe. This is the same as g_unix_open_pipe(), but uses the\n+ * #GUnixPipe data structure.\n+ *\n+ * Returns: %TRUE on success\n+ *\n+ * Since: 2.80\n+ *\/\n+GLIB_AVAILABLE_STATIC_INLINE_IN_2_80\n+static inline gboolean\n+g_unix_pipe_open (GUnixPipe *self,\n+                  int flags,\n+                  GError **error)\n+{\n+  return g_unix_open_pipe (self->fds, flags, error);\n+}\n+\n+\/**\n+ * g_unix_pipe_get:\n+ * @self: A pair of file descriptors\n+ * @end: One of the ends of the pipe\n+ *\n+ * Return one of the ends of the pipe. It remains owned by @self.\n+ *\n+ * This function is async-signal safe (see [`signal(7)`](man:signal(7)) and\n+ * [`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a\n+ * signal handler or a #GSpawnChildSetupFunc.\n+ *\n+ * This function preserves the value of `errno`.\n+ *\n+ * Returns: a non-negative file descriptor owned by @self, which must not\n+ *  be closed by the caller, or a negative number if the corresponding\n+ *  end of the pipe was already closed or stolen\n+ *\n+ * Since: 2.80\n+ *\/\n+GLIB_AVAILABLE_STATIC_INLINE_IN_2_80\n+static inline int\n+g_unix_pipe_get (GUnixPipe *self,\n+                 GUnixPipeEnd end)\n+{\n+  return self->fds[end];\n+}\n+\n+\/**\n+ * g_unix_pipe_steal:\n+ * @self: A pair of file descriptors\n+ * @end: One of the ends of the pipe\n+ *\n+ * Return one of the ends of the pipe. It becomes owned by the caller,\n+ * and the file descriptor in the data structure is set to `-1`,\n+ * similar to g_steal_fd().\n+ *\n+ * This function is async-signal safe (see [`signal(7)`](man:signal(7)) and\n+ * [`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a\n+ * signal handler or a #GSpawnChildSetupFunc.\n+ *\n+ * This function preserves the value of `errno`.\n+ *\n+ * Returns: a non-negative file descriptor, which becomes owned by the\n+ *  caller and must be closed by the caller if required, or a negative\n+ *  number if the corresponding end of the pipe was already closed or stolen\n+ *\n+ * Since: 2.80\n+ *\/\n+GLIB_AVAILABLE_STATIC_INLINE_IN_2_80\n+static inline int\n+g_unix_pipe_steal (GUnixPipe *self,\n+                   GUnixPipeEnd end)\n+{\n+  return g_steal_fd (&self->fds[end]);\n+}\n+\n+\/**\n+ * g_unix_pipe_close:\n+ * @self: A pair of file descriptors\n+ * @end: One of the ends of the pipe\n+ * @error: Optionally used to report an error on failure\n+ *\n+ * Close one of the ends of the pipe and set the relevant member of @fds\n+ * to `-1` before returning, equivalent to g_clear_fd().\n+ *\n+ * Like g_close(), if closing the file descriptor fails, the error is\n+ * stored in both %errno and @error. If this function succeeds,\n+ * %errno is undefined.\n+ *\n+ * This function is async-signal safe if @error is %NULL and the relevant\n+ * member of @fds is either negative or a valid open file descriptor.\n+ * This makes it safe to call from a signal handler or a #GSpawnChildSetupFunc\n+ * under those conditions.\n+ * See [`signal(7)`](man:signal(7)) and\n+ * [`signal-safety(7)`](man:signal-safety(7)) for more details.\n+ *\n+ * To close both file descriptors and ignore any errors, use\n+ * g_unix_pipe_clear() instead.\n+ *\n+ * Returns: %TRUE on success\n+ *\n+ * Since: 2.80\n+ *\/\n+GLIB_AVAILABLE_STATIC_INLINE_IN_2_80\n+static inline gboolean\n+g_unix_pipe_close (GUnixPipe *self,\n+                   GUnixPipeEnd end,\n+                   GError **error)\n+{\n+  return g_clear_fd (&self->fds[end], error);\n+}\n+\n+\/**\n+ * g_unix_pipe_clear:\n+ * @self: a #GUnixPipe\n+ *\n+ * Close both ends of the pipe, unless they have already been closed or\n+ * stolen. Any errors are ignored: use g_unix_pipe_close() or g_clear_fd()\n+ * if error-handling is required.\n+ *\n+ * This function is async-signal safe if @error is %NULL and each member\n+ * of @fds are either negative or a valid open file descriptor.\n+ * As a result, it is safe to call this function or use `g_auto(GUnixPipe)`\n+ * (on compilers that support it) in a signal handler or a\n+ * #GSpawnChildSetupFunc, as long as those conditions are ensured to be true.\n+ * See [`signal(7)`](man:signal(7)) and\n+ * [`signal-safety(7)`](man:signal-safety(7)) for more details.\n+ *\n+ * This function preserves the value of `errno`.\n+ *\n+ * Since: 2.80\n+ *\/\n+GLIB_AVAILABLE_STATIC_INLINE_IN_2_80\n+static inline void\n+g_unix_pipe_clear (GUnixPipe *self)\n+{\n+  \/* Don't overwrite thread-local errno if closing the fd fails *\/\n+  int errsv = errno;\n+\n+  if (!g_unix_pipe_close (self, G_UNIX_PIPE_END_READ, NULL))\n+    {\n+      \/* ignore *\/\n+    }\n+\n+  if (!g_unix_pipe_close (self, G_UNIX_PIPE_END_WRITE, NULL))\n+    {\n+      \/* ignore *\/\n+    }\n+\n+  errno = errsv;\n+}\n+\n+G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (GUnixPipe, g_unix_pipe_clear)\n+\n+GLIB_AVAILABLE_IN_2_80\n+int g_closefrom (int lowfd);\n+\n+GLIB_AVAILABLE_IN_2_80\n+int g_fdwalk_set_cloexec (int lowfd);\n+\n+G_GNUC_END_IGNORE_DEPRECATIONS\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-unix.h","additions":214,"deletions":0,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -953,0 +953,34 @@\n+\n+#if GLIB_VERSION_MIN_REQUIRED >= GLIB_VERSION_2_80\n+#define GLIB_DEPRECATED_IN_2_80 GLIB_DEPRECATED\n+#define GLIB_DEPRECATED_IN_2_80_FOR(f) GLIB_DEPRECATED_FOR (f)\n+#define GLIB_DEPRECATED_MACRO_IN_2_80 GLIB_DEPRECATED_MACRO\n+#define GLIB_DEPRECATED_MACRO_IN_2_80_FOR(f) GLIB_DEPRECATED_MACRO_FOR (f)\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_80 GLIB_DEPRECATED_ENUMERATOR\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_80_FOR(f) GLIB_DEPRECATED_ENUMERATOR_FOR (f)\n+#define GLIB_DEPRECATED_TYPE_IN_2_80 GLIB_DEPRECATED_TYPE\n+#define GLIB_DEPRECATED_TYPE_IN_2_80_FOR(f) GLIB_DEPRECATED_TYPE_FOR (f)\n+#else\n+#define GLIB_DEPRECATED_IN_2_80 _GLIB_EXTERN\n+#define GLIB_DEPRECATED_IN_2_80_FOR(f) _GLIB_EXTERN\n+#define GLIB_DEPRECATED_MACRO_IN_2_80\n+#define GLIB_DEPRECATED_MACRO_IN_2_80_FOR(f)\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_80\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_80_FOR(f)\n+#define GLIB_DEPRECATED_TYPE_IN_2_80\n+#define GLIB_DEPRECATED_TYPE_IN_2_80_FOR(f)\n+#endif\n+\n+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_80\n+#define GLIB_AVAILABLE_IN_2_80 GLIB_UNAVAILABLE (2, 80)\n+#define GLIB_AVAILABLE_STATIC_INLINE_IN_2_80 GLIB_UNAVAILABLE_STATIC_INLINE (2, 80)\n+#define GLIB_AVAILABLE_MACRO_IN_2_80 GLIB_UNAVAILABLE_MACRO (2, 80)\n+#define GLIB_AVAILABLE_ENUMERATOR_IN_2_80 GLIB_UNAVAILABLE_ENUMERATOR (2, 80)\n+#define GLIB_AVAILABLE_TYPE_IN_2_80 GLIB_UNAVAILABLE_TYPE (2, 80)\n+#else\n+#define GLIB_AVAILABLE_IN_2_80 _GLIB_EXTERN\n+#define GLIB_AVAILABLE_STATIC_INLINE_IN_2_80\n+#define GLIB_AVAILABLE_MACRO_IN_2_80\n+#define GLIB_AVAILABLE_ENUMERATOR_IN_2_80\n+#define GLIB_AVAILABLE_TYPE_IN_2_80\n+#endif\n\\ No newline at end of file\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-visibility.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -39,84 +39,0 @@\n-\/**\n- * SECTION:linked_lists_double\n- * @title: Doubly-Linked Lists\n- * @short_description: linked lists that can be iterated over in both directions\n- *\n- * The #GList structure and its associated functions provide a standard\n- * doubly-linked list data structure. The benefit of this data-structure\n- * is to provide insertion\/deletion operations in O(1) complexity where\n- * access\/search operations are in O(n). The benefit of #GList over\n- * #GSList (singly linked list) is that the worst case on access\/search\n- * operations is divided by two which comes at a cost in space as we need\n- * to retain two pointers in place of one.\n- *\n- * Each element in the list contains a piece of data, together with\n- * pointers which link to the previous and next elements in the list.\n- * Using these pointers it is possible to move through the list in both\n- * directions (unlike the singly-linked [GSList][glib-Singly-Linked-Lists],\n- * which only allows movement through the list in the forward direction).\n- *\n- * The double linked list does not keep track of the number of items\n- * and does not keep track of both the start and end of the list. If\n- * you want fast access to both the start and the end of the list,\n- * and\/or the number of items in the list, use a\n- * [GQueue][glib-Double-ended-Queues] instead.\n- *\n- * The data contained in each element can be either integer values, by\n- * using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],\n- * or simply pointers to any type of data.\n- *\n- * List elements are allocated from the [slice allocator][glib-Memory-Slices],\n- * which is more efficient than allocating elements individually.\n- *\n- * Note that most of the #GList functions expect to be passed a pointer\n- * to the first element in the list. The functions which insert\n- * elements return the new start of the list, which may have changed.\n- *\n- * There is no function to create a #GList. %NULL is considered to be\n- * a valid, empty list so you simply set a #GList* to %NULL to initialize\n- * it.\n- *\n- * To add elements, use g_list_append(), g_list_prepend(),\n- * g_list_insert() and g_list_insert_sorted().\n- *\n- * To visit all elements in the list, use a loop over the list:\n- * |[<!-- language=\"C\" -->\n- * GList *l;\n- * for (l = list; l != NULL; l = l->next)\n- *   {\n- *     \/\/ do something with l->data\n- *   }\n- * ]|\n- *\n- * To call a function for each element in the list, use g_list_foreach().\n- *\n- * To loop over the list and modify it (e.g. remove a certain element)\n- * a while loop is more appropriate, for example:\n- * |[<!-- language=\"C\" -->\n- * GList *l = list;\n- * while (l != NULL)\n- *   {\n- *     GList *next = l->next;\n- *     if (should_be_removed (l))\n- *       {\n- *         \/\/ possibly free l->data\n- *         list = g_list_delete_link (list, l);\n- *       }\n- *     l = next;\n- *   }\n- * ]|\n- *\n- * To remove elements, use g_list_remove().\n- *\n- * To navigate in a list, use g_list_first(), g_list_last(),\n- * g_list_next(), g_list_previous().\n- *\n- * To find elements in the list use g_list_nth(), g_list_nth_data(),\n- * g_list_find() and g_list_find_custom().\n- *\n- * To find the index of an element use g_list_position() and\n- * g_list_index().\n- *\n- * To free the entire list, use g_list_free() or g_list_free_full().\n- *\/\n-\n@@ -746,1 +662,1 @@\n- * @func: a copy function used to copy every element in the list\n+ * @func: (scope call): a copy function used to copy every element in the list\n@@ -943,1 +859,1 @@\n- * @func: the function to call for each element.\n+ * @func: (scope call): the function to call for each element.\n@@ -1103,1 +1019,1 @@\n- * @func: the function to call with each element's data\n+ * @func: (scope call): the function to call with each element's data\n@@ -1189,1 +1105,1 @@\n- * @func: the function to compare elements in the list. It should\n+ * @func: (scope call): the function to compare elements in the list. It should\n@@ -1216,1 +1132,1 @@\n- * @func: the function to compare elements in the list. It should\n+ * @func: (scope call): the function to compare elements in the list. It should\n@@ -1311,1 +1227,1 @@\n- * @compare_func: the comparison function used to sort the #GList.\n+ * @compare_func: (scope call): the comparison function used to sort the #GList.\n@@ -1345,1 +1261,1 @@\n- * @compare_func: comparison function\n+ * @compare_func: (scope call): comparison function\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glist.c","additions":7,"deletions":91,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+#define g_macro__has_attribute___weak__ G_GNUC_CHECK_VERSION (2, 8)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmacros.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -130,128 +130,0 @@\n-\/**\n- * SECTION:main\n- * @title: The Main Event Loop\n- * @short_description: manages all available sources of events\n- *\n- * The main event loop manages all the available sources of events for\n- * GLib and GTK applications. These events can come from any number of\n- * different types of sources such as file descriptors (plain files,\n- * pipes or sockets) and timeouts. New types of event sources can also\n- * be added using g_source_attach().\n- *\n- * To allow multiple independent sets of sources to be handled in\n- * different threads, each source is associated with a #GMainContext.\n- * A #GMainContext can only be running in a single thread, but\n- * sources can be added to it and removed from it from other threads. All\n- * functions which operate on a #GMainContext or a built-in #GSource are\n- * thread-safe.\n- *\n- * Each event source is assigned a priority. The default priority,\n- * %G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.\n- * Values greater than 0 denote lower priorities. Events from high priority\n- * sources are always processed before events from lower priority sources: if\n- * several sources are ready to dispatch, the ones with equal-highest priority\n- * will be dispatched on the current #GMainContext iteration, and the rest wait\n- * until a subsequent #GMainContext iteration when they have the highest\n- * priority of the sources which are ready for dispatch.\n- *\n- * Idle functions can also be added, and assigned a priority. These will\n- * be run whenever no events with a higher priority are ready to be dispatched.\n- *\n- * The #GMainLoop data type represents a main event loop. A GMainLoop is\n- * created with g_main_loop_new(). After adding the initial event sources,\n- * g_main_loop_run() is called. This continuously checks for new events from\n- * each of the event sources and dispatches them. Finally, the processing of\n- * an event from one of the sources leads to a call to g_main_loop_quit() to\n- * exit the main loop, and g_main_loop_run() returns.\n- *\n- * It is possible to create new instances of #GMainLoop recursively.\n- * This is often used in GTK applications when showing modal dialog\n- * boxes. Note that event sources are associated with a particular\n- * #GMainContext, and will be checked and dispatched for all main\n- * loops associated with that GMainContext.\n- *\n- * GTK contains wrappers of some of these functions, e.g. gtk_main(),\n- * gtk_main_quit() and gtk_events_pending().\n- *\n- * ## Creating new source types\n- *\n- * One of the unusual features of the #GMainLoop functionality\n- * is that new types of event source can be created and used in\n- * addition to the builtin type of event source. A new event source\n- * type is used for handling GDK events. A new source type is created\n- * by \"deriving\" from the #GSource structure. The derived type of\n- * source is represented by a structure that has the #GSource structure\n- * as a first element, and other elements specific to the new source\n- * type. To create an instance of the new source type, call\n- * g_source_new() passing in the size of the derived structure and\n- * a table of functions. These #GSourceFuncs determine the behavior of\n- * the new source type.\n- *\n- * New source types basically interact with the main context\n- * in two ways. Their prepare function in #GSourceFuncs can set a timeout\n- * to determine the maximum amount of time that the main loop will sleep\n- * before checking the source again. In addition, or as well, the source\n- * can add file descriptors to the set that the main context checks using\n- * g_source_add_poll().\n- *\n- * ## Customizing the main loop iteration\n- *\n- * Single iterations of a #GMainContext can be run with\n- * g_main_context_iteration(). In some cases, more detailed control\n- * of exactly how the details of the main loop work is desired, for\n- * instance, when integrating the #GMainLoop with an external main loop.\n- * In such cases, you can call the component functions of\n- * g_main_context_iteration() directly. These functions are\n- * g_main_context_prepare(), g_main_context_query(),\n- * g_main_context_check() and g_main_context_dispatch().\n- *\n- * If the event loop thread releases #GMainContext ownership until the results\n- * required by g_main_context_check() are ready you must create a context with\n- * the flag %G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING or else you'll lose\n- * g_source_attach() notifications. This happens for instance when you integrate\n- * the GLib event loop into implementations that follow the proactor pattern\n- * (i.e. in these contexts the `poll()` implementation will reclaim the thread for\n- * other tasks until the results are ready). One example of the proactor pattern\n- * is the Boost.Asio library.\n- *\n- * ## State of a Main Context # {#mainloop-states}\n- *\n- * The operation of these functions can best be seen in terms\n- * of a state diagram, as shown in this image.\n- *\n- * ![](mainloop-states.gif)\n- *\n- * On UNIX, the GLib mainloop is incompatible with fork(). Any program\n- * using the mainloop must either exec() or exit() from the child\n- * without returning to the mainloop.\n- *\n- * ## Memory management of sources # {#mainloop-memory-management}\n- *\n- * There are two options for memory management of the user data passed to a\n- * #GSource to be passed to its callback on invocation. This data is provided\n- * in calls to g_timeout_add(), g_timeout_add_full(), g_idle_add(), etc. and\n- * more generally, using g_source_set_callback(). This data is typically an\n- * object which 'owns' the timeout or idle callback, such as a widget or a\n- * network protocol implementation. In many cases, it is an error for the\n- * callback to be invoked after this owning object has been destroyed, as that\n- * results in use of freed memory.\n- *\n- * The first, and preferred, option is to store the source ID returned by\n- * functions such as g_timeout_add() or g_source_attach(), and explicitly\n- * remove that source from the main context using g_source_remove() when the\n- * owning object is finalized. This ensures that the callback can only be\n- * invoked while the object is still alive.\n- *\n- * The second option is to hold a strong reference to the object in the\n- * callback, and to release it in the callback's #GDestroyNotify. This ensures\n- * that the object is kept alive until after the source is finalized, which is\n- * guaranteed to be after it is invoked for the final time. The #GDestroyNotify\n- * is another callback passed to the 'full' variants of #GSource functions (for\n- * example, g_timeout_add_full()). It is called when the source is finalized,\n- * and is designed for releasing references like this.\n- *\n- * One important caveat of this second approach is that it will keep the object\n- * alive indefinitely if the main loop is stopped before the #GSource is\n- * invoked, which may be undesirable.\n- *\/\n-\n@@ -278,0 +150,1 @@\n+  GList link;\n@@ -322,1 +195,1 @@\n-  GList *source_lists;\n+  GQueue source_lists;\n@@ -672,1 +545,2 @@\n-  for (sl_iter = context->source_lists; sl_iter; sl_iter = sl_iter->next)\n+  sl_iter = context->source_lists.head;\n+  while (sl_iter != NULL)\n@@ -675,0 +549,1 @@\n+      sl_iter = sl_iter->next;\n@@ -677,1 +552,0 @@\n-  g_list_free (context->source_lists);\n@@ -766,1 +640,1 @@\n-  context->sources = g_hash_table_new (NULL, NULL);\n+  context->sources = g_hash_table_new (g_uint_hash, g_uint_equal);\n@@ -775,2 +649,0 @@\n-  context->source_lists = NULL;\n-\n@@ -818,1 +690,1 @@\n-  if (g_once_init_enter (&default_main_context))\n+  if (g_once_init_enter_pointer (&default_main_context))\n@@ -831,1 +703,1 @@\n-      g_once_init_leave (&default_main_context, context);\n+      g_once_init_leave_pointer (&default_main_context, context);\n@@ -1140,1 +1012,1 @@\n-  iter->current_list = iter->context->source_lists;\n+  iter->current_list = iter->context->source_lists.head;\n@@ -1190,1 +1062,1 @@\n-  GList *iter, *last;\n+  GList *iter;\n@@ -1193,2 +1065,1 @@\n-  last = NULL;\n-  for (iter = context->source_lists; iter != NULL; last = iter, iter = iter->next)\n+  for (iter = context->source_lists.head; iter; iter = iter->next)\n@@ -1207,0 +1078,1 @@\n+          source_list->link.data = source_list;\n@@ -1208,3 +1080,3 @@\n-    context->source_lists = g_list_insert_before (context->source_lists,\n-              iter,\n-              source_list);\n+          g_queue_insert_before_link (&context->source_lists,\n+                                      iter,\n+                                      &source_list->link);\n@@ -1219,0 +1091,1 @@\n+  source_list->link.data = source_list;\n@@ -1220,0 +1093,1 @@\n+  g_queue_push_tail_link (&context->source_lists, &source_list->link);\n@@ -1221,10 +1095,0 @@\n-  if (!last)\n-    context->source_lists = g_list_append (NULL, source_list);\n-  else\n-    {\n-      \/* This just appends source_list to the end of\n-       * context->source_lists without having to walk the list again.\n-       *\/\n-      last = g_list_append (last, source_list);\n-      (void) last;\n-    }\n@@ -1302,1 +1166,1 @@\n-      context->source_lists = g_list_remove (context->source_lists, source_list);\n+      g_queue_unlink (&context->source_lists, &source_list->link);\n@@ -1320,1 +1184,1 @@\n-  while (id == 0 || g_hash_table_contains (context->sources, GUINT_TO_POINTER (id)));\n+  while (id == 0 || g_hash_table_contains (context->sources, &id));\n@@ -1326,1 +1190,1 @@\n-  g_hash_table_insert (context->sources, GUINT_TO_POINTER (id), source);\n+  g_hash_table_add (context->sources, &source->source_id);\n@@ -2139,2 +2003,2 @@\n- * Any time before the current monotonic time (including 0) is an\n- * indication that the source will fire immediately.\n+ * Any time before or equal to the current monotonic time (including 0)\n+ * is an indication that the source will fire immediately.\n@@ -2426,1 +2290,1 @@\n-          g_hash_table_remove (context->sources, GUINT_TO_POINTER (source->source_id));\n+    g_hash_table_remove (context->sources, &source->source_id);\n@@ -2539,1 +2403,2 @@\n-  GSource *source;\n+  GSource *source = NULL;\n+  gconstpointer ptr;\n@@ -2547,1 +2412,7 @@\n-  source = g_hash_table_lookup (context->sources, GUINT_TO_POINTER (source_id));\n+  ptr = g_hash_table_lookup (context->sources, &source_id);\n+  if (ptr)\n+    {\n+      source = G_CONTAINER_OF (ptr, GSource, source_id);\n+      if (SOURCE_DESTROYED (source))\n+        source = NULL;\n+    }\n@@ -2550,3 +2421,0 @@\n-  if (source && SOURCE_DESTROYED (source))\n-    source = NULL;\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmain.c","additions":32,"deletions":164,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -41,54 +41,0 @@\n-\/**\n- * SECTION:markup\n- * @Title: Simple XML Subset Parser\n- * @Short_description: parses a subset of XML\n- * @See_also: [XML Specification](http:\/\/www.w3.org\/TR\/REC-xml\/)\n- *\n- * The \"GMarkup\" parser is intended to parse a simple markup format\n- * that's a subset of XML. This is a small, efficient, easy-to-use\n- * parser. It should not be used if you expect to interoperate with\n- * other applications generating full-scale XML, and must not be used if you\n- * expect to parse untrusted input. However, it's very\n- * useful for application data files, config files, etc. where you\n- * know your application will be the only one writing the file.\n- * Full-scale XML parsers should be able to parse the subset used by\n- * GMarkup, so you can easily migrate to full-scale XML at a later\n- * time if the need arises.\n- *\n- * GMarkup is not guaranteed to signal an error on all invalid XML;\n- * the parser may accept documents that an XML parser would not.\n- * However, XML documents which are not well-formed (which is a\n- * weaker condition than being valid. See the\n- * [XML specification](http:\/\/www.w3.org\/TR\/REC-xml\/)\n- * for definitions of these terms.) are not considered valid GMarkup\n- * documents.\n- *\n- * Simplifications to XML include:\n- *\n- * - Only UTF-8 encoding is allowed\n- *\n- * - No user-defined entities\n- *\n- * - Processing instructions, comments and the doctype declaration\n- *   are \"passed through\" but are not interpreted in any way\n- *\n- * - No DTD or validation\n- *\n- * The markup format does support:\n- *\n- * - Elements\n- *\n- * - Attributes\n- *\n- * - 5 standard entities: &amp; &lt; &gt; &quot; &apos;\n- *\n- * - Character references\n- *\n- * - Sections marked as CDATA\n-\n- * ## An example parser # {#example}\n- *\n- * Here is an example for a markup parser:\n- * [markup-example.c](https:\/\/gitlab.gnome.org\/GNOME\/glib\/-\/blob\/HEAD\/glib\/tests\/markup-example.c)\n- *\/\n-\n@@ -1942,1 +1888,1 @@\n- * Returns: the element stack, which must not be modified\n+ * Returns: (element-type utf8): the element stack, which must not be modified\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmarkup.c","additions":1,"deletions":55,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -80,30 +80,0 @@\n-\/**\n- * SECTION:memory\n- * @Short_Description: general memory-handling\n- * @Title: Memory Allocation\n- *\n- * These functions provide support for allocating and freeing memory.\n- *\n- * If any call to allocate memory using functions g_new(), g_new0(), g_renew(),\n- * g_malloc(), g_malloc0(), g_malloc0_n(), g_realloc(), and g_realloc_n()\n- * fails, the application is terminated. This also means that there is no\n- * need to check if the call succeeded. On the other hand, the `g_try_...()` family\n- * of functions returns %NULL on failure that can be used as a check\n- * for unsuccessful memory allocation. The application is not terminated\n- * in this case.\n- *\n- * As all GLib functions and data structures use `g_malloc()` internally, unless\n- * otherwise specified, any allocation failure will result in the application\n- * being terminated.\n- *\n- * It's important to match g_malloc() (and wrappers such as g_new()) with\n- * g_free(), g_slice_alloc() (and wrappers such as g_slice_new()) with\n- * g_slice_free(), plain malloc() with free(), and (if you're using C++)\n- * new with delete and new[] with delete[]. Otherwise bad things can happen,\n- * since these allocators may use different memory pools (and new\/delete call\n- * constructors and destructors).\n- *\n- * Since GLib 2.46 g_malloc() is hardcoded to always use the system malloc\n- * implementation.\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmem.c","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,140 +31,0 @@\n-\/**\n- * SECTION:messages\n- * @Title: Message Output and Debugging Functions\n- * @Short_description: functions to output messages and help debug applications\n- *\n- * These functions provide support for outputting messages.\n- *\n- * The g_return family of macros (g_return_if_fail(),\n- * g_return_val_if_fail(), g_return_if_reached(),\n- * g_return_val_if_reached()) should only be used for programming\n- * errors, a typical use case is checking for invalid parameters at\n- * the beginning of a public function. They should not be used if\n- * you just mean \"if (error) return\", they should only be used if\n- * you mean \"if (bug in program) return\". The program behavior is\n- * generally considered undefined after one of these checks fails.\n- * They are not intended for normal control flow, only to give a\n- * perhaps-helpful warning before giving up.\n- *\n- * Structured logging output is supported using g_log_structured(). This differs\n- * from the traditional g_log() API in that log messages are handled as a\n- * collection of key-value pairs representing individual pieces of information,\n- * rather than as a single string containing all the information in an arbitrary\n- * format.\n- *\n- * The convenience macros g_info(), g_message(), g_debug(), g_warning() and g_error()\n- * will use the traditional g_log() API unless you define the symbol\n- * %G_LOG_USE_STRUCTURED before including `glib.h`. But note that even messages\n- * logged through the traditional g_log() API are ultimatively passed to\n- * g_log_structured(), so that all log messages end up in same destination.\n- * If %G_LOG_USE_STRUCTURED is defined, g_test_expect_message() will become\n- * ineffective for the wrapper macros g_warning() and friends (see\n- * [Testing for Messages][testing-for-messages]).\n- *\n- * The support for structured logging was motivated by the following needs (some\n- * of which were supported previously; others weren't):\n- *  * Support for multiple logging levels.\n- *  * Structured log support with the ability to add `MESSAGE_ID`s (see\n- *    g_log_structured()).\n- *  * Moving the responsibility for filtering log messages from the program to\n- *    the log viewer - instead of libraries and programs installing log handlers\n- *    (with g_log_set_handler()) which filter messages before output, all log\n- *    messages are outputted, and the log viewer program (such as `journalctl`)\n- *    must filter them. This is based on the idea that bugs are sometimes hard\n- *    to reproduce, so it is better to log everything possible and then use\n- *    tools to analyse the logs than it is to not be able to reproduce a bug to\n- *    get additional log data. Code which uses logging in performance-critical\n- *    sections should compile out the g_log_structured() calls in\n- *    release builds, and compile them in in debugging builds.\n- *  * A single writer function which handles all log messages in a process, from\n- *    all libraries and program code; rather than multiple log handlers with\n- *    poorly defined interactions between them. This allows a program to easily\n- *    change its logging policy by changing the writer function, for example to\n- *    log to an additional location or to change what logging output fallbacks\n- *    are used. The log writer functions provided by GLib are exposed publicly\n- *    so they can be used from programs' log writers. This allows log writer\n- *    policy and implementation to be kept separate.\n- *  * If a library wants to add standard information to all of its log messages\n- *    (such as library state) or to redact private data (such as passwords or\n- *    network credentials), it should use a wrapper function around its\n- *    g_log_structured() calls or implement that in the single log writer\n- *    function.\n- *  * If a program wants to pass context data from a g_log_structured() call to\n- *    its log writer function so that, for example, it can use the correct\n- *    server connection to submit logs to, that user data can be passed as a\n- *    zero-length #GLogField to g_log_structured_array().\n- *  * Color output needed to be supported on the terminal, to make reading\n- *    through logs easier.\n- *\n- * ## Using Structured Logging ## {#using-structured-logging}\n- *\n- * To use structured logging (rather than the old-style logging), either use\n- * the g_log_structured() and g_log_structured_array() functions; or define\n- * `G_LOG_USE_STRUCTURED` before including any GLib header, and use the\n- * g_message(), g_debug(), g_error() (etc.) macros.\n- *\n- * You do not need to define `G_LOG_USE_STRUCTURED` to use g_log_structured(),\n- * but it is a good idea to avoid confusion.\n- *\n- * ## Log Domains ## {#log-domains}\n- *\n- * Log domains may be used to broadly split up the origins of log messages.\n- * Typically, there are one or a few log domains per application or library.\n- * %G_LOG_DOMAIN should be used to define the default log domain for the current\n- * compilation unit - it is typically defined at the top of a source file, or in\n- * the preprocessor flags for a group of source files.\n- *\n- * Log domains must be unique, and it is recommended that they are the\n- * application or library name, optionally followed by a hyphen and a sub-domain\n- * name. For example, `bloatpad` or `bloatpad-io`.\n- *\n- * ## Debug Message Output ## {#debug-message-output}\n- *\n- * The default log functions (g_log_default_handler() for the old-style API and\n- * g_log_writer_default() for the structured API) both drop debug and\n- * informational messages by default, unless the log domains of those messages\n- * are listed in the `G_MESSAGES_DEBUG` environment variable (or it is set to\n- * `all`).\n- *\n- * It is recommended that custom log writer functions re-use the\n- * `G_MESSAGES_DEBUG` environment variable, rather than inventing a custom one,\n- * so that developers can re-use the same debugging techniques and tools across\n- * projects. Since GLib 2.68, this can be implemented by dropping messages\n- * for which g_log_writer_default_would_drop() returns %TRUE.\n- *\n- * ## Testing for Messages ## {#testing-for-messages}\n- *\n- * With the old g_log() API, g_test_expect_message() and\n- * g_test_assert_expected_messages() could be used in simple cases to check\n- * whether some code under test had emitted a given log message. These\n- * functions have been deprecated with the structured logging API, for several\n- * reasons:\n- *  * They relied on an internal queue which was too inflexible for many use\n- *    cases, where messages might be emitted in several orders, some\n- *    messages might not be emitted deterministically, or messages might be\n- *    emitted by unrelated log domains.\n- *  * They do not support structured log fields.\n- *  * Examining the log output of code is a bad approach to testing it, and\n- *    while it might be necessary for legacy code which uses g_log(), it should\n- *    be avoided for new code using g_log_structured().\n- *\n- * They will continue to work as before if g_log() is in use (and\n- * %G_LOG_USE_STRUCTURED is not defined). They will do nothing if used with the\n- * structured logging API.\n- *\n- * Examining the log output of code is discouraged: libraries should not emit to\n- * `stderr` during defined behaviour, and hence this should not be tested. If\n- * the log emissions of a library during undefined behaviour need to be tested,\n- * they should be limited to asserting that the library aborts and prints a\n- * suitable error message before aborting. This should be done with\n- * g_test_trap_assert_stderr().\n- *\n- * If it is really necessary to test the structured log messages emitted by a\n- * particular piece of code - and the code cannot be restructured to be more\n- * suitable to more conventional unit testing - you should write a custom log\n- * writer function (see g_log_set_writer_func()) which appends all log messages\n- * to a queue. When you want to check the log messages, examine and clear the\n- * queue, ignoring irrelevant log messages (for example, from log domains other\n- * than the one under test).\n- *\/\n-\n@@ -207,0 +67,4 @@\n+#ifdef HAVE_SYSLOG_H\n+#include <syslog.h>\n+#endif\n+\n@@ -263,1 +127,1 @@\n- * [Using Structured Logging][using-structured-logging].\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -270,1 +134,1 @@\n- *     fatal and recursion flags)\n+ *   fatal and recursion flags)\n@@ -272,1 +136,1 @@\n- * @user_data: user data, set in g_log_set_handler()\n+ * @user_data: user data, set in [func@GLib.log_set_handler]\n@@ -276,1 +140,1 @@\n- * The default log handler, g_log_default_handler(), automatically appends a\n+ * The default log handler, [func@GLib.log_default_handler], automatically appends a\n@@ -283,1 +147,1 @@\n- * [Using Structured Logging][using-structured-logging].\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -290,2 +154,2 @@\n- * @G_LOG_LEVEL_ERROR: log level for errors, see g_error().\n- *     This level is also used for messages produced by g_assert().\n+ * @G_LOG_LEVEL_ERROR: log level for errors, see [func@GLib.error].\n+ *   This level is also used for messages produced by [func@GLib.assert].\n@@ -293,7 +157,6 @@\n- *     g_critical().\n- *     This level is also used for messages produced by g_return_if_fail()\n- *     and g_return_val_if_fail().\n- * @G_LOG_LEVEL_WARNING: log level for warnings, see g_warning()\n- * @G_LOG_LEVEL_MESSAGE: log level for messages, see g_message()\n- * @G_LOG_LEVEL_INFO: log level for informational messages, see g_info()\n- * @G_LOG_LEVEL_DEBUG: log level for debug messages, see g_debug()\n+ *   [func@GLib.critical]. This level is also used for messages produced by\n+ *   [func@GLib.return_if_fail] and [func@GLib.return_val_if_fail].\n+ * @G_LOG_LEVEL_WARNING: log level for warnings, see [func@GLib.warning]\n+ * @G_LOG_LEVEL_MESSAGE: log level for messages, see [func@GLib.message]\n+ * @G_LOG_LEVEL_INFO: log level for informational messages, see [func@GLib.info]\n+ * @G_LOG_LEVEL_DEBUG: log level for debug messages, see [func@GLib.debug]\n@@ -305,1 +168,1 @@\n- * levels using g_log_set_handler() and g_log_set_fatal_mask().\n+ * levels using [func@GLib.log_set_handler] and [func@GLib.log_set_fatal_mask].\n@@ -311,1 +174,1 @@\n- * Log levels below 1<<G_LOG_LEVEL_USER_SHIFT are used by GLib.\n+ * Log levels below `1<<G_LOG_LEVEL_USER_SHIFT` are used by GLib.\n@@ -317,2 +180,2 @@\n- * @...: format string, followed by parameters to insert\n- *     into the format string (as with printf())\n+ * @...: format string, followed by parameters to insert into the format string\n+ *   (as with `printf()`)\n@@ -322,1 +185,1 @@\n- * If g_log_default_handler() is used as the log handler function, a new-line\n+ * If [func@GLib.log_default_handler] is used as the log handler function, a new-line\n@@ -326,3 +189,3 @@\n- * If structured logging is enabled, this will use g_log_structured();\n- * otherwise it will use g_log(). See\n- * [Using Structured Logging][using-structured-logging].\n+ * If structured logging is enabled, this will use [func@GLib.log_structured];\n+ * otherwise it will use [func@GLib.log]. See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -333,2 +196,4 @@\n- * @...: format string, followed by parameters to insert\n- *     into the format string (as with printf())\n+ * @...: format string, followed by parameters to insert into the format string\n+ *   (as with `printf()`)\n+ *\n+ * A convenience function\/macro to log a warning message.\n@@ -336,2 +201,1 @@\n- * A convenience function\/macro to log a warning message. The message should\n- * typically *not* be translated to the user's language.\n+ * The message should typically *not* be translated to the user’s language.\n@@ -339,1 +203,1 @@\n- * This is not intended for end user error reporting. Use of #GError is\n+ * This is not intended for end user error reporting. Use of [type@GLib.Error] is\n@@ -349,1 +213,1 @@\n- * parameters) then you should use %G_LOG_LEVEL_CRITICAL instead.\n+ * parameters) then you should use [flags@GLib.LogLevelFlags.LEVEL_CRITICAL] instead.\n@@ -351,1 +215,1 @@\n- * g_warn_if_reached() and g_warn_if_fail() log at %G_LOG_LEVEL_WARNING.\n+ * [func@GLib.warn_if_reached] and func@GLib.warn_if_fail] log at [flags@GLib.LogLevelFlags.LEVEL_WARNING].\n@@ -357,3 +221,3 @@\n- * |[\n- *   G_DEBUG=fatal-warnings gdb .\/my-program\n- * ]|\n+ * ```\n+ * G_DEBUG=fatal-warnings gdb .\/my-program\n+ * ```\n@@ -364,1 +228,1 @@\n- * If g_log_default_handler() is used as the log handler function,\n+ * If [func@GLib.log_default_handler] is used as the log handler function,\n@@ -368,3 +232,3 @@\n- * If structured logging is enabled, this will use g_log_structured();\n- * otherwise it will use g_log(). See\n- * [Using Structured Logging][using-structured-logging].\n+ * If structured logging is enabled, this will use [func@GLib.log_structured];\n+ * otherwise it will use [func@GLib.log]. See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -375,2 +239,2 @@\n- * @...: format string, followed by parameters to insert\n- *     into the format string (as with printf())\n+ * @...: format string, followed by parameters to insert into the format string\n+ *   (as with `printf()`)\n@@ -378,1 +242,1 @@\n- * Logs a \"critical warning\" (%G_LOG_LEVEL_CRITICAL).\n+ * Logs a ‘critical warning’ ([flags@GLib.LogLevelFlags.LEVEL_CRITICAL]).\n@@ -385,2 +249,2 @@\n- * g_return_if_fail(), g_return_val_if_fail(), g_return_if_reached() and\n- * g_return_val_if_reached() log at %G_LOG_LEVEL_CRITICAL.\n+ * [func@GLib.return_if_fail], [func@GLib.return_val_if_fail], [func@GLib.return_if_reached] and\n+ * [func@GLib.return_val_if_reached] log at [flags@GLib.LogLevelFlags.LEVEL_CRITICAL].\n@@ -392,3 +256,3 @@\n- * |[\n- *   G_DEBUG=fatal-warnings gdb .\/my-program\n- * ]|\n+ * ```\n+ * G_DEBUG=fatal-warnings gdb .\/my-program\n+ * ```\n@@ -396,1 +260,1 @@\n- * You can also use g_log_set_always_fatal().\n+ * You can also use [func@GLib.log_set_always_fatal].\n@@ -402,1 +266,1 @@\n- * user's language.\n+ * user’s language.\n@@ -404,1 +268,1 @@\n- * If g_log_default_handler() is used as the log handler function, a new-line\n+ * If [func@GLib.log_default_handler] is used as the log handler function, a new-line\n@@ -408,3 +272,3 @@\n- * If structured logging is enabled, this will use g_log_structured();\n- * otherwise it will use g_log(). See\n- * [Using Structured Logging][using-structured-logging].\n+ * If structured logging is enabled, this will use [func@GLib.log_structured];\n+ * otherwise it will use [func@GLib.log]. See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -415,2 +279,2 @@\n- * @...: format string, followed by parameters to insert\n- *     into the format string (as with printf())\n+ * @...: format string, followed by parameters to insert into the format string\n+ *   (as with `printf()`)\n@@ -418,2 +282,1 @@\n- * A convenience function\/macro to log an error message. The message should\n- * typically *not* be translated to the user's language.\n+ * A convenience function\/macro to log an error message.\n@@ -421,1 +284,3 @@\n- * This is not intended for end user error reporting. Use of #GError is\n+ * The message should typically *not* be translated to the user’s language.\n+ *\n+ * This is not intended for end user error reporting. Use of [type@GLib.Error] is\n@@ -425,1 +290,1 @@\n- * Error messages are always fatal, resulting in a call to G_BREAKPOINT()\n+ * Error messages are always fatal, resulting in a call to [func@GLib.BREAKPOINT]\n@@ -427,1 +292,1 @@\n- * result in a core dump; don't use it for errors you expect.\n+ * result in a core dump; don’t use it for errors you expect.\n@@ -431,1 +296,1 @@\n- * If g_log_default_handler() is used as the log handler function, a new-line\n+ * If [func@GLib.log_default_handler] is used as the log handler function, a new-line\n@@ -435,3 +300,3 @@\n- * If structured logging is enabled, this will use g_log_structured();\n- * otherwise it will use g_log(). See\n- * [Using Structured Logging][using-structured-logging].\n+ * If structured logging is enabled, this will use [func@GLib.log_structured];\n+ * otherwise it will use [func@GLib.log]. See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -442,2 +307,4 @@\n- * @...: format string, followed by parameters to insert\n- *     into the format string (as with printf())\n+ * @...: format string, followed by parameters to insert into the format string\n+ *   (as with `printf()`)\n+ *\n+ * A convenience function\/macro to log an informational message.\n@@ -445,1 +312,1 @@\n- * A convenience function\/macro to log an informational message. Seldom used.\n+ * Seldom used.\n@@ -447,1 +314,1 @@\n- * If g_log_default_handler() is used as the log handler function, a new-line\n+ * If [func@GLib.log_default_handler] is used as the log handler function, a new-line\n@@ -451,3 +318,4 @@\n- * Such messages are suppressed by the g_log_default_handler() and\n- * g_log_writer_default() unless the `G_MESSAGES_DEBUG` environment variable is\n- * set appropriately.\n+ * Such messages are suppressed by the [func@GLib.log_default_handler] and\n+ * [func@GLib.log_writer_default] unless the `G_MESSAGES_DEBUG` environment variable is\n+ * set appropriately. If you need to set the allowed domains at runtime, use\n+ * [func@GLib.log_writer_default_set_debug_domains].\n@@ -455,3 +323,3 @@\n- * If structured logging is enabled, this will use g_log_structured();\n- * otherwise it will use g_log(). See\n- * [Using Structured Logging][using-structured-logging].\n+ * If structured logging is enabled, this will use [func@GLib.log_structured];\n+ * otherwise it will use [func@GLib.log]. See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -464,2 +332,4 @@\n- * @...: format string, followed by parameters to insert\n- *     into the format string (as with printf())\n+ * @...: format string, followed by parameters to insert into the format string\n+ *   (as with `printf()`)\n+ *\n+ * A convenience function\/macro to log a debug message.\n@@ -467,2 +337,1 @@\n- * A convenience function\/macro to log a debug message. The message should\n- * typically *not* be translated to the user's language.\n+ * The message should typically *not* be translated to the user’s language.\n@@ -470,1 +339,1 @@\n- * If g_log_default_handler() is used as the log handler function, a new-line\n+ * If [func@GLib.log_default_handler] is used as the log handler function, a new-line\n@@ -474,3 +343,4 @@\n- * Such messages are suppressed by the g_log_default_handler() and\n- * g_log_writer_default() unless the `G_MESSAGES_DEBUG` environment variable is\n- * set appropriately.\n+ * Such messages are suppressed by the [func@GLib.log_default_handler] and\n+ * [func@GLib.log_writer_default] unless the `G_MESSAGES_DEBUG` environment variable is\n+ * set appropriately. If you need to set the allowed domains at runtime, use\n+ * [func@GLib.log_writer_default_set_debug_domains].\n@@ -478,3 +348,3 @@\n- * If structured logging is enabled, this will use g_log_structured();\n- * otherwise it will use g_log(). See\n- * [Using Structured Logging][using-structured-logging].\n+ * If structured logging is enabled, this will use [func@GLib.log_structured];\n+ * otherwise it will use [func@GLib.log]. See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -569,21 +439,0 @@\n-static gchar *fatal_msg_ptr = fatal_msg_buf;\n-\n-#undef write\n-static inline int\n-dowrite (int          fd,\n-   const void  *buf,\n-   unsigned int len)\n-{\n-  if (win32_keep_fatal_message)\n-    {\n-      memcpy (fatal_msg_ptr, buf, len);\n-      fatal_msg_ptr += len;\n-      *fatal_msg_ptr = 0;\n-      return len;\n-    }\n-\n-  write (fd, buf, len);\n-\n-  return len;\n-}\n-#define write(fd, buf, len) dowrite(fd, buf, len)\n@@ -708,2 +557,2 @@\n- * @fatal_mask: the mask containing bits set for each level\n- *     of error which is to be fatal\n+ * @fatal_mask: the mask containing bits set for each level of error which is\n+ *   to be fatal\n@@ -712,0 +561,1 @@\n+ *\n@@ -714,1 +564,1 @@\n- * %G_LOG_LEVEL_ERROR is always fatal.\n+ * [flags@GLib.LogLevelFlags.LEVEL_ERROR] is always fatal.\n@@ -723,2 +573,2 @@\n- * Structured log messages (using g_log_structured() and\n- * g_log_structured_array()) are fatal only if the default log writer is used;\n+ * Structured log messages (using [func@GLib.log_structured] and\n+ * [func@GLib.log_structured_array]) are fatal only if the default log writer is used;\n@@ -726,1 +576,1 @@\n- * are fatal. See [Using Structured Logging][using-structured-logging].\n+ * are fatal. See [Using Structured Logging](logging.html#using-structured-logging).\n@@ -758,1 +608,0 @@\n- * %G_LOG_LEVEL_ERROR is always fatal.\n@@ -760,2 +609,4 @@\n- * This has no effect on structured log messages (using g_log_structured() or\n- * g_log_structured_array()). To change the fatal behaviour for specific log\n+ * [flags@GLib.LogLevelFlags.LEVEL_ERROR] is always fatal.\n+ *\n+ * This has no effect on structured log messages (using [func@GLib.log_structured] or\n+ * [func@GLib.log_structured_array]). To change the fatal behaviour for specific log\n@@ -763,2 +614,2 @@\n- * g_log_set_writer_func(). See\n- * [Using Structured Logging][using-structured-logging].\n+ * [func@GLib.log_set_writer_func]. See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -767,3 +618,3 @@\n- * %G_LOG_LEVEL_CRITICAL.  You should typically not set\n- * %G_LOG_LEVEL_WARNING, %G_LOG_LEVEL_MESSAGE, %G_LOG_LEVEL_INFO or\n- * %G_LOG_LEVEL_DEBUG as fatal except inside of test programs.\n+ * [flags@GLib.LogLevelFlags.LEVEL_CRITICAL].  You should typically not set\n+ * [flags@GLib.LogLevelFlags.LEVEL_WARNING], [flags@GLib.LogLevelFlags.LEVEL_MESSAGE], [flags@GLib.LogLevelFlags.LEVEL_INFO] or\n+ * [flags@GLib.LogLevelFlags.LEVEL_DEBUG] as fatal except inside of test programs.\n@@ -805,1 +656,1 @@\n- * @log_domain: (nullable): the log domain, or %NULL for the default \"\"\n+ * @log_domain: (nullable): the log domain, or `NULL` for the default `\"\"`\n@@ -809,2 +660,2 @@\n- *    the log levels with the %G_LOG_FLAG_FATAL and\n- *    %G_LOG_FLAG_RECURSION bit flags.\n+ *    the log levels with the [flags@GLib.LogLevelFlags.FLAG_FATAL] and\n+ *    [flags@GLib.LogLevelFlags.FLAG_RECURSION] bit flags.\n@@ -817,1 +668,1 @@\n- * must be combined with the %G_LOG_FLAG_FATAL and %G_LOG_FLAG_RECURSION\n+ * must be combined with the [flags@GLib.LogLevelFlags.FLAG_FATAL] and [flags@GLib.LogLevelFlags.FLAG_RECURSION]\n@@ -820,1 +671,1 @@\n- * Note that since the %G_LOG_LEVEL_ERROR log level is always fatal, if\n+ * Note that since the [flags@GLib.LogLevelFlags.LEVEL_ERROR] log level is always fatal, if\n@@ -822,1 +673,1 @@\n- * %G_LOG_FLAG_FATAL.\n+ * [flags@GLib.LogLevelFlags.FLAG_FATAL].\n@@ -825,1 +676,1 @@\n- * [Using Structured Logging][using-structured-logging].\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -830,1 +681,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -833,1 +684,1 @@\n- * ]|\n+ * ```\n@@ -837,1 +688,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -840,1 +691,1 @@\n- * ]|\n+ * ```\n@@ -844,1 +695,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -847,1 +698,1 @@\n- * ]|\n+ * ```\n@@ -862,1 +713,1 @@\n- * @log_domain: (nullable): the log domain, or %NULL for the default \"\"\n+ * @log_domain: (nullable): the log domain, or `NULL` for the default `\"\"`\n@@ -866,2 +717,2 @@\n- *   the log levels with the %G_LOG_FLAG_FATAL and\n- *   %G_LOG_FLAG_RECURSION bit flags.\n+ *   the log levels with the [flags@GLib.LogLevelFlags.FLAG_FATAL] and\n+ *   [flags@GLib.LogLevelFlags.FLAG_RECURSION] bit flags.\n@@ -870,1 +721,1 @@\n- * @destroy: destroy notify for @user_data, or %NULL\n+ * @destroy: destroy notify for @user_data, or `NULL`\n@@ -872,1 +723,1 @@\n- * Like g_log_set_handler(), but takes a destroy notify for the @user_data.\n+ * Like [func@GLib.log_set_handler], but takes a destroy notify for the @user_data.\n@@ -875,1 +726,1 @@\n- * [Using Structured Logging][using-structured-logging].\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -877,1 +728,1 @@\n- * Returns: the id of the new handler\n+ * Returns: the ID of the new handler\n@@ -926,2 +777,3 @@\n- * and log level combination. By default, GLib uses\n- * g_log_default_handler() as default log handler.\n+ * and log level combination.\n+ *\n+ * By default, GLib uses [func@GLib.log_default_handler] as default log handler.\n@@ -930,1 +782,1 @@\n- * [Using Structured Logging][using-structured-logging].\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -973,1 +825,1 @@\n- * g_log_structured() or g_log_structured_array()). To change the fatal\n+ * [func@GLib.log_structured] or [func@GLib.log_structured_array]). To change the fatal\n@@ -975,2 +827,2 @@\n- * writer function using g_log_set_writer_func().See\n- * [Using Structured Logging][using-structured-logging].\n+ * writer function using [func@GLib.log_set_writer_func].See\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -993,2 +845,2 @@\n- * @handler_id: the id of the handler, which was returned\n- *     in g_log_set_handler()\n+ * @handler_id: the ID of the handler, which was returned\n+ *   in [func@GLib.log_set_handler]\n@@ -999,1 +851,1 @@\n- * [Using Structured Logging][using-structured-logging].\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -1182,1 +1034,1 @@\n- * @use_stderr: If %TRUE, use `stderr` for log messages that would\n+ * @use_stderr: If `TRUE`, use `stderr` for log messages that would\n@@ -1185,4 +1037,2 @@\n- * Configure whether the built-in log functions\n- * (g_log_default_handler() for the old-style API, and both\n- * g_log_writer_default() and g_log_writer_standard_streams() for the\n- * structured API) will output all log messages to `stderr`.\n+ * Configure whether the built-in log functions will output all log messages to\n+ * `stderr`.\n@@ -1190,2 +1040,6 @@\n- * By default, log messages of levels %G_LOG_LEVEL_INFO and\n- * %G_LOG_LEVEL_DEBUG are sent to `stdout`, and other log messages are\n+ * The built-in log functions are [func@GLib.log_default_handler] for the\n+ * old-style API, and both [func@GLib.log_writer_default] and\n+ * [func@GLib.log_writer_standard_streams] for the structured API.\n+ *\n+ * By default, log messages of levels [flags@GLib.LogLevelFlags.LEVEL_INFO] and\n+ * [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are sent to `stdout`, and other log messages are\n@@ -1272,2 +1126,2 @@\n- * @log_domain: (nullable): the log domain, or %NULL for the default \"\"\n- * application domain\n+ * @log_domain: (nullable): the log domain, or `NULL` for the default `\"\"`\n+ *   application domain\n@@ -1275,1 +1129,1 @@\n- * @format: the message format. See the printf() documentation\n+ * @format: the message format. See the `printf()` documentation\n@@ -1280,2 +1134,2 @@\n- * If the log level has been set as fatal, G_BREAKPOINT() is called\n- * to terminate the program. See the documentation for G_BREAKPOINT() for\n+ * If the log level has been set as fatal, [func@GLib.BREAKPOINT] is called\n+ * to terminate the program. See the documentation for [func@GLib.BREAKPOINT] for\n@@ -1284,1 +1138,1 @@\n- * If g_log_default_handler() is used as the log handler function, a new-line\n+ * If [func@GLib.log_default_handler] is used as the log handler function, a new-line\n@@ -1288,2 +1142,2 @@\n- * If [structured logging is enabled][using-structured-logging] this will\n- * output via the structured log writer function (see g_log_set_writer_func()).\n+ * If [structured logging is enabled](logging.html#using-structured-logging) this will\n+ * output via the structured log writer function (see [func@GLib.log_set_writer_func]).\n@@ -1432,1 +1286,1 @@\n- * @log_domain: (nullable): the log domain, usually %G_LOG_DOMAIN, or %NULL\n+ * @log_domain: (nullable): the log domain, usually `G_LOG_DOMAIN`, or `NULL`\n@@ -1434,1 +1288,1 @@\n- * @log_level: the log level, either from #GLogLevelFlags\n+ * @log_level: the log level, either from [type@GLib.LogLevelFlags]\n@@ -1441,2 +1295,2 @@\n- * If the log level has been set as fatal, G_BREAKPOINT() is called\n- * to terminate the program. See the documentation for G_BREAKPOINT() for\n+ * If the log level has been set as fatal, [func@GLib.BREAKPOINT] is called\n+ * to terminate the program. See the documentation for [func@GLib.BREAKPOINT] for\n@@ -1445,1 +1299,1 @@\n- * If g_log_default_handler() is used as the log handler function, a new-line\n+ * If [func@GLib.log_default_handler] is used as the log handler function, a new-line\n@@ -1449,2 +1303,2 @@\n- * If [structured logging is enabled][using-structured-logging] this will\n- * output via the structured log writer function (see g_log_set_writer_func()).\n+ * If [structured logging is enabled](logging.html#using-structured-logging) this will\n+ * output via the structured log writer function (see [func@GLib.log_set_writer_func]).\n@@ -1488,0 +1342,19 @@\n+#ifdef HAVE_SYSLOG_H\n+static int\n+str_to_syslog_facility (const gchar *syslog_facility_str)\n+{\n+  int syslog_facility = LOG_USER;\n+\n+  if (g_strcmp0 (syslog_facility_str, \"auth\") == 0)\n+    {\n+      syslog_facility = LOG_AUTH;\n+    }\n+  else if (g_strcmp0 (syslog_facility_str, \"daemon\") == 0)\n+    {\n+      syslog_facility = LOG_DAEMON;\n+    }\n+\n+  return syslog_facility;\n+}\n+#endif\n+\n@@ -1617,2 +1490,2 @@\n- * @log_domain: log domain, usually %G_LOG_DOMAIN\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_domain: log domain, usually `G_LOG_DOMAIN`\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -1621,1 +1494,1 @@\n- *    by the key \"MESSAGE\", followed by a printf()-style message format,\n+ *    by the key `MESSAGE`, followed by a `printf()`-style message format,\n@@ -1627,5 +1500,5 @@\n- * using g_log_set_writer_func(). If the message is fatal (i.e. its log level\n- * is %G_LOG_LEVEL_ERROR), the program will be aborted by calling\n- * G_BREAKPOINT() at the end of this function. If the log writer returns\n- * %G_LOG_WRITER_UNHANDLED (failure), no other fallback writers will be tried.\n- * See the documentation for #GLogWriterFunc for information on chaining\n+ * using [func@GLib.log_set_writer_func]. If the message is fatal (i.e. its log level\n+ * is [flags@GLib.LogLevelFlags.LEVEL_ERROR]), the program will be aborted by calling\n+ * [func@GLib.BREAKPOINT] at the end of this function. If the log writer returns\n+ * [enum@GLib.LogWriterOutput.UNHANDLED] (failure), no other fallback writers will be tried.\n+ * See the documentation for [type@GLib.LogWriterFunc] for information on chaining\n@@ -1634,2 +1507,2 @@\n- * The structured data is provided as key-value pairs, where keys are UTF-8\n- * strings, and values are arbitrary pointers typically pointing to UTF-8\n+ * The structured data is provided as key–value pairs, where keys are UTF-8\n+ * strings, and values are arbitrary pointers — typically pointing to UTF-8\n@@ -1637,1 +1510,1 @@\n- * structured data, use g_log_structured_array(). The keys for structured data\n+ * structured data, use [func@GLib.log_structured_array]. The keys for structured data\n@@ -1645,1 +1518,1 @@\n- * `\"GLIB_DOMAIN\"`) must be passed as NUL-terminated UTF-8 strings until GLib\n+ * `\"GLIB_DOMAIN\"`) must be passed as nul-terminated UTF-8 strings until GLib\n@@ -1648,1 +1521,1 @@\n- * non-NUL-terminated UTF-8 strings can be passed with their correct length.\n+ * non-nul-terminated UTF-8 strings can be passed with their correct length.\n@@ -1667,2 +1540,2 @@\n- * the logging macros, G_DEBUG_HERE(), g_message(), g_warning(), g_critical(),\n- * g_error(), etc, if the symbols `G_LOG_USE_STRUCTURED` is defined before including\n+ * the logging macros, [func@GLib.DEBUG_HERE], [func@GLib.message], [func@GLib.warning], [func@GLib.critical],\n+ * [func@GLib.error], etc, if the symbol `G_LOG_USE_STRUCTURED` is defined before including\n@@ -1673,1 +1546,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -1679,1 +1552,1 @@\n- * ]|\n+ * ```\n@@ -1688,2 +1561,2 @@\n- * this logging call, you must use g_log_structured_array() and pass the pointer\n- * as a field with #GLogField.length set to zero, otherwise it will be\n+ * this logging call, you must use [func@GLib.log_structured_array] and pass the pointer\n+ * as a field with `GLogField.length` set to zero, otherwise it will be\n@@ -1694,1 +1567,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -1702,1 +1575,1 @@\n- * ]|\n+ * ```\n@@ -1707,1 +1580,1 @@\n- * field for which printf()-style formatting is supported.\n+ * field for which `printf()`-style formatting is supported.\n@@ -1821,2 +1694,2 @@\n- * @log_domain: (nullable): log domain, usually %G_LOG_DOMAIN\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_domain: (nullable): log domain, usually `G_LOG_DOMAIN`\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -1824,1 +1697,1 @@\n- * @fields: a dictionary (#GVariant of the type %G_VARIANT_TYPE_VARDICT)\n+ * @fields: a dictionary ([type@GLib.Variant] of the type `G_VARIANT_TYPE_VARDICT`)\n@@ -1827,2 +1700,1 @@\n- * Log a message with structured data, accepting the data within a #GVariant. This\n- * version is especially useful for use in other languages, via introspection.\n+ * Log a message with structured data, accepting the data within a [type@GLib.Variant].\n@@ -1830,1 +1702,3 @@\n- * The only mandatory item in the @fields dictionary is the \"MESSAGE\" which must\n+ * This version is especially useful for use in other languages, via introspection.\n+ *\n+ * The only mandatory item in the @fields dictionary is the `\"MESSAGE\"` which must\n@@ -1833,2 +1707,2 @@\n- * The values in the @fields dictionary are likely to be of type String\n- * (%G_VARIANT_TYPE_STRING). Array of bytes (%G_VARIANT_TYPE_BYTESTRING) is also\n+ * The values in the @fields dictionary are likely to be of type `G_VARIANT_TYPE_STRING`.\n+ * Array of bytes (`G_VARIANT_TYPE_BYTESTRING`) is also\n@@ -1837,2 +1711,2 @@\n- * %G_MAXSSIZE. Otherwise it will be truncated to this size. For other types\n- * g_variant_print() will be used to convert the value into a string.\n+ * `G_MAXSSIZE`. Otherwise it will be truncated to this size. For other types\n+ * [method@GLib.Variant.print] will be used to convert the value into a string.\n@@ -1840,1 +1714,1 @@\n- * For more details on its usage and about the parameters, see g_log_structured().\n+ * For more details on its usage and about the parameters, see [func@GLib.log_structured].\n@@ -1844,1 +1718,0 @@\n-\n@@ -1938,1 +1811,1 @@\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -1940,1 +1813,1 @@\n- * @fields: (array length=n_fields): key-value pairs of structured data to add\n+ * @fields: (array length=n_fields): key–value pairs of structured data to add\n@@ -1944,3 +1817,5 @@\n- * Log a message with structured data. The message will be passed through to the\n- * log writer set by the application using g_log_set_writer_func(). If the\n- * message is fatal (i.e. its log level is %G_LOG_LEVEL_ERROR), the program will\n+ * Log a message with structured data.\n+ *\n+ * The message will be passed through to the log writer set by the application\n+ * using [func@GLib.log_set_writer_func]. If the\n+ * message is fatal (i.e. its log level is [flags@GLib.LogLevelFlags.LEVEL_ERROR]), the program will\n@@ -1949,1 +1824,1 @@\n- * See g_log_structured() for more documentation.\n+ * See [func@GLib.log_structured] for more documentation.\n@@ -2048,1 +1923,1 @@\n- * @func: log writer function, which must not be %NULL\n+ * @func: log writer function, which must not be `NULL`\n@@ -2050,2 +1925,2 @@\n- * @user_data_free: (destroy func): function to free @user_data once it's\n- *    finished with, if non-%NULL\n+ * @user_data_free: (destroy func): function to free @user_data once it’s\n+ *    finished with, if non-`NULL`\n@@ -2054,2 +1929,4 @@\n- * message. Each program should set a writer function, or the default writer\n- * (g_log_writer_default()) will be used.\n+ * message.\n+ *\n+ * Each program should set a writer function, or the default writer\n+ * ([func@GLib.log_writer_default]) will be used.\n@@ -2057,1 +1934,1 @@\n- * Libraries **must not** call this function only programs are allowed to\n+ * Libraries **must not** call this function — only programs are allowed to\n@@ -2092,3 +1969,2 @@\n- * Check whether the given @output_fd file descriptor supports ANSI color\n- * escape sequences. If so, they can safely be used when formatting log\n- * messages.\n+ * Check whether the given @output_fd file descriptor supports\n+ * [ANSI color escape sequences](https:\/\/en.wikipedia.org\/wiki\/ANSI_escape_code).\n@@ -2096,1 +1972,3 @@\n- * Returns: %TRUE if ANSI color escapes are supported, %FALSE otherwise\n+ * If so, they can safely be used when formatting log messages.\n+ *\n+ * Returns: `TRUE` if ANSI color escapes are supported, `FALSE` otherwise\n@@ -2171,0 +2049,7 @@\n+#ifdef HAVE_SYSLOG_H\n+static gboolean syslog_opened = FALSE;\n+#ifndef __linux__\n+G_LOCK_DEFINE_STATIC (syslog_opened);\n+#endif\n+#endif\n+\n@@ -2204,1 +2089,1 @@\n- * Invalid file descriptors are accepted and return %FALSE, which allows for\n+ * Invalid file descriptors are accepted and return `FALSE`, which allows for\n@@ -2206,3 +2091,3 @@\n- * |[<!-- language=\"C\" -->\n- *   is_journald = g_log_writer_is_journald (fileno (stderr));\n- * ]|\n+ * ```c\n+ * is_journald = g_log_writer_is_journald (fileno (stderr));\n+ * ```\n@@ -2210,1 +2095,1 @@\n- * Returns: %TRUE if @output_fd points to the journal, %FALSE otherwise\n+ * Returns: `TRUE` if @output_fd points to the journal, `FALSE` otherwise\n@@ -2227,1 +2112,1 @@\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -2229,1 +2114,1 @@\n- * @fields: (array length=n_fields): key-value pairs of structured data forming\n+ * @fields: (array length=n_fields): key–value pairs of structured data forming\n@@ -2232,2 +2117,3 @@\n- * @use_color: %TRUE to use ANSI color escape sequences when formatting the\n- *    message, %FALSE to not\n+ * @use_color: `TRUE` to use\n+ *   [ANSI color escape sequences](https:\/\/en.wikipedia.org\/wiki\/ANSI_escape_code)\n+ *   when formatting the message, `FALSE` to not\n@@ -2236,1 +2122,3 @@\n- * terminal (or elsewhere). This will include the values of all fields it knows\n+ * terminal (or elsewhere).\n+ *\n+ * This will include the values of all fields it knows\n@@ -2238,1 +2126,1 @@\n- * documentation for g_log_structured()). It does not include values from\n+ * documentation for [func@GLib.log_structured]). It does not include values from\n@@ -2357,0 +2245,107 @@\n+\/**\n+ * g_log_writer_syslog:\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n+ *    level\n+ * @fields: (array length=n_fields): key–value pairs of structured data forming\n+ *    the log message\n+ * @n_fields: number of elements in the @fields array\n+ * @user_data: user data passed to [func@GLib.log_set_writer_func]\n+ *\n+ * Format a structured log message and send it to the syslog daemon. Only fields\n+ * which are understood by this function are included in the formatted string\n+ * which is printed.\n+ *\n+ * Log facility will be defined via the SYSLOG_FACILITY field and accepts the following\n+ * values: \"auth\", \"daemon\", and \"user\". If SYSLOG_FACILITY is not specified, LOG_USER\n+ * facility will be used.\n+ *\n+ * This is suitable for use as a [type@GLib.LogWriterFunc].\n+ *\n+ * If syslog is not supported, this function is still defined, but will always\n+ * return [enum@GLib.LogWriterOutput.UNHANDLED].\n+ *\n+ * Returns: [enum@GLib.LogWriterOutput.HANDLED] on success, [enum@GLib.LogWriterOutput.UNHANDLED] otherwise\n+ * Since: 2.80\n+ *\/\n+GLogWriterOutput\n+g_log_writer_syslog (GLogLevelFlags   log_level,\n+                     const GLogField *fields,\n+                     gsize            n_fields,\n+                     gpointer         user_data)\n+{\n+#ifdef HAVE_SYSLOG_H\n+  gsize i;\n+  const char *message = NULL;\n+  const char *log_domain = NULL;\n+  int syslog_facility = 0;\n+  int syslog_level;\n+  gssize message_length = -1;\n+  gssize log_domain_length = -1;\n+  GString *gstring;\n+\n+  g_return_val_if_fail (fields != NULL, G_LOG_WRITER_UNHANDLED);\n+  g_return_val_if_fail (n_fields > 0, G_LOG_WRITER_UNHANDLED);\n+\n+\/* As not all man pages provide sufficient information about the thread safety\n+ * of the openlog() routine or even describe alternative routines like logopen_r()\n+ * intended for multi-threaded applications, use locking on non-Linux platforms till\n+ * the situation can be cleared. See the following links for more information:\n+ * FreeBSD: https:\/\/man.freebsd.org\/cgi\/man.cgi?query=openlog\n+ * NetBSD: https:\/\/man.netbsd.org\/openlog.3\n+ * POSIX: https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799.2008edition\/functions\/openlog.html#\n+ *\/\n+#ifndef __linux__\n+  G_LOCK (syslog_opened);\n+#endif\n+\n+  if (!syslog_opened)\n+    {\n+      openlog (NULL, 0, 0);\n+      syslog_opened = TRUE;\n+    }\n+\n+#ifndef __linux__\n+  G_UNLOCK (syslog_opened);\n+#endif\n+\n+  for (i = 0; i < n_fields; i++)\n+    {\n+      const GLogField *field = &fields[i];\n+\n+      if (g_strcmp0 (field->key, \"MESSAGE\") == 0)\n+        {\n+          message = field->value;\n+          message_length = field->length;\n+        }\n+      else if (g_strcmp0 (field->key, \"GLIB_DOMAIN\") == 0)\n+        {\n+          log_domain = field->value;\n+          log_domain_length = field->length;\n+        }\n+      else if (g_strcmp0 (field->key, \"SYSLOG_FACILITY\") == 0)\n+        {\n+          syslog_facility = str_to_syslog_facility (field->value);\n+        }\n+    }\n+\n+  gstring = g_string_new (NULL);\n+\n+  if (log_domain != NULL)\n+    {\n+      g_string_append_len (gstring, log_domain, log_domain_length);\n+      g_string_append (gstring, \": \");\n+    }\n+\n+  g_string_append_len (gstring, message, message_length);\n+\n+  syslog_level = atoi (log_level_to_priority (log_level));\n+  syslog (syslog_level | syslog_facility, \"%s\", gstring->str);\n+\n+  g_string_free (gstring, TRUE);\n+\n+  return G_LOG_WRITER_HANDLED;\n+#else\n+  return G_LOG_WRITER_UNHANDLED;\n+#endif \/* HAVE_SYSLOG_H *\/\n+}\n+\n@@ -2450,1 +2445,1 @@\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -2452,1 +2447,1 @@\n- * @fields: (array length=n_fields): key-value pairs of structured data forming\n+ * @fields: (array length=n_fields): key–value pairs of structured data forming\n@@ -2455,1 +2450,1 @@\n- * @user_data: user data passed to g_log_set_writer_func()\n+ * @user_data: user data passed to [func@GLib.log_set_writer_func]\n@@ -2458,1 +2453,3 @@\n- * of key-value pairs. All fields are sent to the journal, but if a field has\n+ * of key–value pairs.\n+ *\n+ * All fields are sent to the journal, but if a field has\n@@ -2462,1 +2459,1 @@\n- * This is suitable for use as a #GLogWriterFunc.\n+ * This is suitable for use as a [type@GLib.LogWriterFunc].\n@@ -2465,1 +2462,1 @@\n- * defined, but will always return %G_LOG_WRITER_UNHANDLED.\n+ * defined, but will always return [enum@GLib.LogWriterOutput.UNHANDLED].\n@@ -2467,1 +2464,1 @@\n- * Returns: %G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise\n+ * Returns: [enum@GLib.LogWriterOutput.HANDLED] on success, [enum@GLib.LogWriterOutput.UNHANDLED] otherwise\n@@ -2490,2 +2487,2 @@\n-   * conversion is necessary and we don't need to care about the current\n-   * locale's character set.\n+   * conversion is necessary and we don’t need to care about the current\n+   * locale’s character set.\n@@ -2561,1 +2558,1 @@\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -2563,1 +2560,1 @@\n- * @fields: (array length=n_fields): key-value pairs of structured data forming\n+ * @fields: (array length=n_fields): key–value pairs of structured data forming\n@@ -2566,1 +2563,1 @@\n- * @user_data: user data passed to g_log_set_writer_func()\n+ * @user_data: user data passed to [func@GLib.log_set_writer_func]\n@@ -2569,1 +2566,3 @@\n- * depending on its log level. %G_LOG_LEVEL_INFO and %G_LOG_LEVEL_DEBUG messages\n+ * depending on its log level.\n+ *\n+ * [flags@GLib.LogLevelFlags.LEVEL_INFO] and [flags@GLib.LogLevelFlags.LEVEL_DEBUG] messages\n@@ -2571,1 +2570,1 @@\n- * g_log_writer_default_set_use_stderr();\n+ * [func@GLib.log_writer_default_set_use_stderr];\n@@ -2576,2 +2575,3 @@\n- * If the output stream supports ANSI color escape sequences, they will be used\n- * in the output.\n+ * If the output stream supports\n+ * [ANSI color escape sequences](https:\/\/en.wikipedia.org\/wiki\/ANSI_escape_code),\n+ * they will be used in the output.\n@@ -2581,1 +2581,1 @@\n- * This is suitable for use as a #GLogWriterFunc.\n+ * This is suitable for use as a [type@GLib.LogWriterFunc].\n@@ -2583,1 +2583,2 @@\n- * Returns: %G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise\n+ * Returns: [enum@GLib.LogWriterOutput.HANDLED] on success,\n+ *   [enum@GLib.LogWriterOutput.UNHANDLED] otherwise\n@@ -2593,1 +2594,1 @@\n-  gchar *out = NULL;  \/* in the current locale's character set *\/\n+  gchar *out = NULL;  \/* in the current locale’s character set *\/\n@@ -2629,0 +2630,52 @@\n+static gboolean\n+domain_found (const gchar *domains,\n+              const char  *log_domain)\n+{\n+  guint len;\n+  const gchar *found;\n+\n+  len = strlen (log_domain);\n+\n+  for (found = strstr (domains, log_domain); found;\n+       found = strstr (found + 1, log_domain))\n+    {\n+      if ((found == domains || found[-1] == ' ')\n+          && (found[len] == 0 || found[len] == ' '))\n+        return TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n+static struct {\n+  GRWLock lock;\n+  gchar *domains;\n+  gboolean domains_set;\n+} g_log_global;\n+\n+\/**\n+ * g_log_writer_default_set_debug_domains:\n+ * @domains: (nullable) (transfer none): `NULL`-terminated array with domains to be printed.\n+ *   `NULL` or an array with no values means none. Array with a single value `\"all\"` means all.\n+ *\n+ * Reset the list of domains to be logged, that might be initially set by the\n+ * `G_MESSAGES_DEBUG` environment variable.\n+ *\n+ * This function is thread-safe.\n+ *\n+ * Since: 2.80\n+ *\/\n+void\n+g_log_writer_default_set_debug_domains (const gchar * const *domains)\n+{\n+  g_rw_lock_writer_lock (&g_log_global.lock);\n+\n+  g_free (g_log_global.domains);\n+  g_log_global.domains = domains ?\n+      g_strjoinv (\" \", (gchar **)domains) : NULL;\n+\n+  g_log_global.domains_set = TRUE;\n+\n+  g_rw_lock_writer_unlock (&g_log_global.lock);\n+}\n+\n@@ -2646,1 +2699,0 @@\n-      const gchar *domains;\n@@ -2649,1 +2701,7 @@\n-      domains = g_getenv (\"G_MESSAGES_DEBUG\");\n+      g_rw_lock_reader_lock (&g_log_global.lock);\n+\n+      if (G_UNLIKELY (!g_log_global.domains_set))\n+        {\n+          g_log_global.domains = g_strdup (g_getenv (\"G_MESSAGES_DEBUG\"));\n+          g_log_global.domains_set = TRUE;\n+        }\n@@ -2652,2 +2710,5 @@\n-          domains == NULL)\n-        return TRUE;\n+          g_log_global.domains == NULL)\n+        {\n+          g_rw_lock_reader_unlock (&g_log_global.lock);\n+          return TRUE;\n+        }\n@@ -2667,3 +2728,8 @@\n-      if (strcmp (domains, \"all\") != 0 &&\n-          (log_domain == NULL || !strstr (domains, log_domain)))\n-        return TRUE;\n+      if (strcmp (g_log_global.domains, \"all\") != 0 &&\n+          (log_domain == NULL || !domain_found (g_log_global.domains, log_domain)))\n+        {\n+          g_rw_lock_reader_unlock (&g_log_global.lock);\n+          return TRUE;\n+        }\n+\n+      g_rw_lock_reader_unlock (&g_log_global.lock);\n@@ -2678,1 +2744,1 @@\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -2681,1 +2747,1 @@\n- * Check whether g_log_writer_default() and g_log_default_handler() would\n+ * Check whether [func@GLib.log_writer_default] and [func@GLib.log_default_handler] would\n@@ -2684,1 +2750,1 @@\n- * As with g_log_default_handler(), this function drops debug and informational\n+ * As with [func@GLib.log_default_handler], this function drops debug and informational\n@@ -2686,1 +2752,1 @@\n- * `G_MESSAGES_DEBUG` environment variable.\n+ * `G_MESSAGES_DEBUG` environment variable, or by [func@GLib.log_writer_default_set_debug_domains].\n@@ -2691,3 +2757,3 @@\n- * |[<!-- language=\"C\" -->\n- *   if (g_log_writer_default_would_drop (log_level, log_domain))\n- *     return G_LOG_WRITER_HANDLED;\n+ * ```c\n+ * if (g_log_writer_default_would_drop (log_level, log_domain))\n+ *   return G_LOG_WRITER_HANDLED;\n@@ -2699,4 +2765,4 @@\n- * |[<!-- language=\"C\" -->\n- *   if (!g_log_writer_default_would_drop (G_LOG_LEVEL_DEBUG, G_LOG_DOMAIN))\n- *     {\n- *       gchar *result = expensive_computation (my_object);\n+ * ```c\n+ * if (!g_log_writer_default_would_drop (G_LOG_LEVEL_DEBUG, G_LOG_DOMAIN))\n+ *   {\n+ *     g_autofree gchar *result = expensive_computation (my_object);\n@@ -2704,4 +2770,3 @@\n- *       g_debug (\"my_object result: %s\", result);\n- *       g_free (result);\n- *     }\n- * ]|\n+ *     g_debug (\"my_object result: %s\", result);\n+ *   }\n+ * ```\n@@ -2709,2 +2774,2 @@\n- * Returns: %TRUE if the log message would be dropped by GLib's\n- *  default log handlers\n+ * Returns: `TRUE` if the log message would be dropped by GLib’s\n+ *   default log handlers\n@@ -2722,1 +2787,1 @@\n- * @log_level: log level, either from #GLogLevelFlags, or a user-defined\n+ * @log_level: log level, either from [type@GLib.LogLevelFlags], or a user-defined\n@@ -2724,1 +2789,1 @@\n- * @fields: (array length=n_fields): key-value pairs of structured data forming\n+ * @fields: (array length=n_fields): key–value pairs of structured data forming\n@@ -2727,1 +2792,1 @@\n- * @user_data: user data passed to g_log_set_writer_func()\n+ * @user_data: user data passed to [func@GLib.log_set_writer_func]\n@@ -2730,1 +2795,3 @@\n- * for the platform. On Linux, this is typically the systemd journal, falling\n+ * for the platform.\n+ *\n+ * On Linux, this is typically the systemd journal, falling\n@@ -2738,2 +2805,2 @@\n- * This is suitable for use as a #GLogWriterFunc, and is the default writer used\n- * if no other is set using g_log_set_writer_func().\n+ * This is suitable for use as a [type@GLib.LogWriterFunc], and is the default writer used\n+ * if no other is set using [func@GLib.log_set_writer_func].\n@@ -2741,1 +2808,1 @@\n- * As with g_log_default_handler(), this function drops debug and informational\n+ * As with [func@GLib.log_default_handler], this function drops debug and informational\n@@ -2743,1 +2810,1 @@\n- * `G_MESSAGES_DEBUG` environment variable.\n+ * `G_MESSAGES_DEBUG` environment variable, or set at runtime by [func@GLib.log_writer_default_set_debug_domains].\n@@ -2745,2 +2812,2 @@\n- * g_log_writer_default() uses the mask set by g_log_set_always_fatal() to\n- * determine which messages are fatal. When using a custom writer func instead it is\n+ * [func@GLib.log_writer_default] uses the mask set by [func@GLib.log_set_always_fatal] to\n+ * determine which messages are fatal. When using a custom writer function instead it is\n@@ -2749,1 +2816,2 @@\n- * Returns: %G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise\n+ * Returns: [enum@GLib.LogWriterOutput.HANDLED] on success,\n+ *   [enum@GLib.LogWriterOutput.UNHANDLED] otherwise\n@@ -2880,2 +2948,2 @@\n- * Note that this should not be used to conditionalise calls to g_debug() or\n- * other logging functions; it should only be used from %GLogWriterFunc\n+ * Note that this should not be used to conditionalise calls to [func@GLib.debug] or\n+ * other logging functions; it should only be used from [type@GLib.LogWriterFunc]\n@@ -2884,2 +2952,2 @@\n- * Note also that the value of this does not depend on `G_MESSAGES_DEBUG`; see\n- * the docs for g_log_set_debug_enabled().\n+ * Note also that the value of this does not depend on `G_MESSAGES_DEBUG`, nor\n+ * [func@GLib.log_writer_default_set_debug_domains]; see the docs for [func@GLib.log_set_debug_enabled].\n@@ -2887,1 +2955,1 @@\n- * Returns: %TRUE if debug output is enabled, %FALSE otherwise\n+ * Returns: `TRUE` if debug output is enabled, `FALSE` otherwise\n@@ -2899,1 +2967,1 @@\n- * @enabled: %TRUE to enable debug output, %FALSE otherwise\n+ * @enabled: `TRUE` to enable debug output, `FALSE` otherwise\n@@ -2902,2 +2970,4 @@\n- * This value interacts disjunctively with `G_MESSAGES_DEBUG` — if either of\n- * them would allow a debug message to be outputted, it will be.\n+ *\n+ * This value interacts disjunctively with `G_MESSAGES_DEBUG` and\n+ * [func@GLib.log_writer_default_set_debug_domains] — if any of them would allow\n+ * a debug message to be outputted, it will be.\n@@ -2922,2 +2992,2 @@\n- * Internal function used to print messages from the public g_return_if_fail()\n- * and g_return_val_if_fail() macros.\n+ * Internal function used to print messages from the public [func@GLib.return_if_fail]\n+ * and [func@GLib.return_val_if_fail] macros.\n@@ -2945,2 +3015,2 @@\n- * Internal function used to print messages from the public g_warn_if_reached()\n- * and g_warn_if_fail() macros.\n+ * Internal function used to print messages from the public [func@GLib.warn_if_reached]\n+ * and [func@GLib.warn_if_fail] macros.\n@@ -2999,1 +3069,1 @@\n- * @pattern: a glob-style [pattern][glib-Glob-style-pattern-matching]\n+ * @pattern: a glob-style pattern (see [type@GLib.PatternSpec])\n@@ -3002,2 +3072,3 @@\n- * with text matching @pattern, is expected to be logged. When this\n- * message is logged, it will not be printed, and the test case will\n+ * with text matching @pattern, is expected to be logged.\n+ *\n+ * When this message is logged, it will not be printed, and the test case will\n@@ -3006,3 +3077,3 @@\n- * This API may only be used with the old logging API (g_log() without\n- * %G_LOG_USE_STRUCTURED defined). It will not work with the structured logging\n- * API. See [Testing for Messages][testing-for-messages].\n+ * This API may only be used with the old logging API ([func@GLib.log] without\n+ * `G_LOG_USE_STRUCTURED` defined). It will not work with the structured logging\n+ * API. See [Testing for Messages](logging.html#testing-for-messages).\n@@ -3010,1 +3081,1 @@\n- * Use g_test_assert_expected_messages() to assert that all\n+ * Use [func@GLib.test_assert_expected_messages] to assert that all\n@@ -3015,1 +3086,1 @@\n- * the same order as the calls to g_test_expect_message().)\n+ * the same order as the calls to [func@GLib.test_expect_message].)\n@@ -3019,9 +3090,9 @@\n- * |[<!-- language=\"C\" -->\n- *   \/\/ g_main_context_push_thread_default() should fail if the\n- *   \/\/ context is already owned by another thread.\n- *   g_test_expect_message (G_LOG_DOMAIN,\n- *                          G_LOG_LEVEL_CRITICAL,\n- *                          \"assertion*acquired_context*failed\");\n- *   g_main_context_push_thread_default (bad_context);\n- *   g_test_assert_expected_messages ();\n- * ]|\n+ * ```c\n+ * \/\/ g_main_context_push_thread_default() should fail if the\n+ * \/\/ context is already owned by another thread.\n+ * g_test_expect_message (G_LOG_DOMAIN,\n+ *                        G_LOG_LEVEL_CRITICAL,\n+ *                        \"assertion*acquired_context*failed\");\n+ * g_main_context_push_thread_default (bad_context);\n+ * g_test_assert_expected_messages ();\n+ * ```\n@@ -3029,3 +3100,3 @@\n- * Note that you cannot use this to test g_error() messages, since\n- * g_error() intentionally never returns even if the program doesn't\n- * abort; use g_test_trap_subprocess() in this case.\n+ * Note that you cannot use this to test [func@GLib.error] messages, since\n+ * [func@GLib.error] intentionally never returns even if the program doesn’t\n+ * abort; use [func@GLib.test_trap_subprocess] in this case.\n@@ -3033,2 +3104,2 @@\n- * If messages at %G_LOG_LEVEL_DEBUG are emitted, but not explicitly\n- * expected via g_test_expect_message() then they will be ignored.\n+ * If messages at [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are emitted, but not explicitly\n+ * expected via [func@GLib.test_expect_message] then they will be ignored.\n@@ -3084,1 +3155,1 @@\n- * g_test_expect_message() have been seen and suppressed.\n+ * [func@GLib.test_expect_message] have been seen and suppressed.\n@@ -3086,3 +3157,3 @@\n- * This API may only be used with the old logging API (g_log() without\n- * %G_LOG_USE_STRUCTURED defined). It will not work with the structured logging\n- * API. See [Testing for Messages][testing-for-messages].\n+ * This API may only be used with the old logging API ([func@GLib.log] without\n+ * `G_LOG_USE_STRUCTURED` defined). It will not work with the structured logging\n+ * API. See [Testing for Messages](logging.html#testing-for-messages).\n@@ -3090,2 +3161,2 @@\n- * If messages at %G_LOG_LEVEL_DEBUG are emitted, but not explicitly\n- * expected via g_test_expect_message() then they will be ignored.\n+ * If messages at [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are emitted, but not explicitly\n+ * expected via [func@GLib.test_expect_message] then they will be ignored.\n@@ -3207,2 +3278,2 @@\n- * @log_domain: (nullable): the log domain of the message, or %NULL for the\n- * default \"\" application domain\n+ * @log_domain: (nullable): the log domain of the message, or `NULL` for the\n+ *   default `\"\"` application domain\n@@ -3211,1 +3282,1 @@\n- * @unused_data: (nullable): data passed from g_log() which is unused\n+ * @unused_data: (nullable): data passed from [func@GLib.log] which is unused\n@@ -3213,1 +3284,1 @@\n- * The default log handler set up by GLib; g_log_set_default_handler()\n+ * The default log handler set up by GLib; [func@GLib.log_set_default_handler]\n@@ -3215,0 +3286,1 @@\n+ *\n@@ -3216,2 +3288,2 @@\n- * domain and log level combination. It outputs the message to stderr\n- * or stdout and if the log level is fatal it calls G_BREAKPOINT(). It automatically\n+ * domain and log level combination. It outputs the message to `stderr`\n+ * or `stdout` and if the log level is fatal it calls [func@GLib.BREAKPOINT]. It automatically\n@@ -3224,7 +3296,7 @@\n- * - `G_MESSAGES_PREFIXED`: A :-separated list of log levels for which\n- *   messages should be prefixed by the program name and PID of the\n- *   application.\n- *\n- * - `G_MESSAGES_DEBUG`: A space-separated list of log domains for\n- *   which debug and informational messages are printed. By default\n- *   these messages are not printed.\n+ *   - `G_MESSAGES_PREFIXED`: A `:`-separated list of log levels for which\n+ *     messages should be prefixed by the program name and PID of the\n+ *     application.\n+ *   - `G_MESSAGES_DEBUG`: A space-separated list of log domains for\n+ *     which debug and informational messages are printed. By default\n+ *     these messages are not printed. If you need to set the allowed\n+ *     domains at runtime, use [func@GLib.log_writer_default_set_debug_domains].\n@@ -3232,4 +3304,5 @@\n- * stderr is used for levels %G_LOG_LEVEL_ERROR, %G_LOG_LEVEL_CRITICAL,\n- * %G_LOG_LEVEL_WARNING and %G_LOG_LEVEL_MESSAGE. stdout is used for\n- * the rest, unless stderr was requested by\n- * g_log_writer_default_set_use_stderr().\n+ * `stderr` is used for levels [flags@GLib.LogLevelFlags.LEVEL_ERROR],\n+ * [flags@GLib.LogLevelFlags.LEVEL_CRITICAL], [flags@GLib.LogLevelFlags.LEVEL_WARNING] and\n+ * [flags@GLib.LogLevelFlags.LEVEL_MESSAGE]. `stdout` is used for\n+ * the rest, unless `stderr` was requested by\n+ * [func@GLib.log_writer_default_set_use_stderr].\n@@ -3238,1 +3311,1 @@\n- * [Using Structured Logging][using-structured-logging].\n+ * [Using Structured Logging](logging.html#using-structured-logging).\n@@ -3289,1 +3362,1 @@\n- * @func: (nullable): the new print handler or %NULL to\n+ * @func: (nullable): the new print handler or `NULL` to\n@@ -3293,1 +3366,1 @@\n- * default GLib handler if %NULL.\n+ * default GLib handler if `NULL`.\n@@ -3295,1 +3368,1 @@\n- * Any messages passed to g_print() will be output via\n+ * Any messages passed to [func@GLib.print] will be output via\n@@ -3297,1 +3370,1 @@\n- * the encoded message to stdout. By providing your own handler\n+ * the encoded message to `stdout`. By providing your own handler\n@@ -3302,1 +3375,1 @@\n- * #GPrintFunc, and never returns %NULL. If no custom\n+ * [type@GLib.PrintFunc], and never returns `NULL`. If no custom\n@@ -3305,2 +3378,2 @@\n- * decorate its output and\/or to write to stderr\n- * in all platforms. Before GLib 2.76, this was %NULL.\n+ * decorate its output and\/or to write to `stderr`\n+ * in all platforms. Before GLib 2.76, this was `NULL`.\n@@ -3382,1 +3455,1 @@\n- * @format: the message format. See the printf() documentation\n+ * @format: the message format. See the `printf()` documentation\n@@ -3386,1 +3459,2 @@\n- * The default print handler outputs the encoded message to stdout, without\n+ *\n+ * The default print handler outputs the encoded message to `stdout`, without\n@@ -3390,1 +3464,1 @@\n- * g_print() should not be used from within libraries for debugging\n+ * This function should not be used from within libraries for debugging\n@@ -3393,2 +3467,2 @@\n- * use g_log(), g_log_structured(), or the convenience macros g_message(),\n- * g_warning() and g_error().\n+ * use [func@GLib.log], [func@GLib.log_structured], or the convenience macros\n+ * [func@GLib.message], [func@GLib.warning] and [func@GLib.error].\n@@ -3418,2 +3492,2 @@\n- * @func: (nullable): he new error message handler or %NULL\n- *  to reset to the default\n+ * @func: (nullable): he new error message handler or `NULL`\n+ *   to reset to the default\n@@ -3422,1 +3496,1 @@\n- * or resets it to the default GLib handler if %NULL.\n+ * or resets it to the default GLib handler if `NULL`.\n@@ -3424,1 +3498,1 @@\n- * Any messages passed to g_printerr() will be output via\n+ * Any messages passed to [func@GLib.printerr] will be output via\n@@ -3426,1 +3500,1 @@\n- * message to stderr. By providing your own handler you can\n+ * message to `stderr`. By providing your own handler you can\n@@ -3431,1 +3505,1 @@\n- * #GPrintFunc, and never returns %NULL. If no custom error\n+ * [type@GLib.PrintFunc], and never returns `NULL`. If no custom error\n@@ -3434,2 +3508,2 @@\n- * its output and\/or to write to stderr in all platforms.\n- * Before GLib 2.76, this was %NULL.\n+ * its output and\/or to write to `stderr` in all platforms.\n+ * Before GLib 2.76, this was `NULL`.\n@@ -3448,1 +3522,1 @@\n- * @format: the message format. See the printf() documentation\n+ * @format: the message format. See the `printf()` documentation\n@@ -3452,1 +3526,2 @@\n- * The default handler outputs the encoded message to stderr, without appending\n+ *\n+ * The default handler outputs the encoded message to `stderr`, without appending\n@@ -3456,3 +3531,3 @@\n- * g_printerr() should not be used from within libraries.\n- * Instead g_log() or g_log_structured() should be used, or the convenience\n- * macros g_message(), g_warning() and g_error().\n+ * This function should not be used from within libraries.\n+ * Instead [func@GLib.log] or [func@GLib.log_structured] should be used, or the convenience\n+ * macros [func@GLib.message], [func@GLib.warning] and [func@GLib.error].\n@@ -3482,1 +3557,1 @@\n- * @format: the format string. See the printf() documentation\n+ * @format: the format string. See the `printf()` documentation\n@@ -3486,1 +3561,9 @@\n- * of the sprintf() function.\n+ * of the `sprintf()` function.\n+ *\n+ * If @format or @args are invalid, `0` is returned. This could happen if, for\n+ * example, @format contains an `%lc` or `%ls` placeholder and @args contains a\n+ * wide character which cannot be represented in multibyte encoding. `0`\n+ * can also be returned legitimately if, for example, @format is `%s` and @args\n+ * is an empty string. The caller is responsible for differentiating these two\n+ * return cases if necessary. It is recommended to not use `%lc` or `%ls`\n+ * placeholders in any case, as their behaviour is locale-dependent.\n@@ -3488,1 +3571,1 @@\n- * Returns: the maximum space needed to store the formatted string\n+ * Returns: the maximum space needed to store the formatted string, or `0` on error\n@@ -3495,1 +3578,6 @@\n-  return _g_vsnprintf (&c, 1, format, args) + 1;\n+  int count = _g_vsnprintf (&c, 1, format, args);\n+\n+  if (count < 0)\n+    return 0;\n+\n+  return count + 1;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmessages.c","additions":598,"deletions":510,"binary":false,"changes":1108,"status":"modified"},{"patch":"@@ -232,0 +232,5 @@\n+GLIB_AVAILABLE_IN_2_80\n+GLogWriterOutput g_log_writer_syslog           (GLogLevelFlags   log_level,\n+                                                const GLogField *fields,\n+                                                gsize            n_fields,\n+                                                gpointer         user_data);\n@@ -253,0 +258,3 @@\n+GLIB_AVAILABLE_IN_2_80\n+void            g_log_writer_default_set_debug_domains (const gchar * const *domains);\n+\n@@ -547,0 +555,3 @@\n+ * Unlike g_return_if_fail(), the expression is always evaluated, even if\n+ * checks and assertions are disabled.\n+ *\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmessages.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,37 +42,0 @@\n-\/**\n- * SECTION:trees-nary\n- * @title: N-ary Trees\n- * @short_description: trees of data with any number of branches\n- *\n- * The #GNode struct and its associated functions provide a N-ary tree\n- * data structure, where nodes in the tree can contain arbitrary data.\n- *\n- * To create a new tree use g_node_new().\n- *\n- * To insert a node into a tree use g_node_insert(),\n- * g_node_insert_before(), g_node_append() and g_node_prepend().\n- *\n- * To create a new node and insert it into a tree use\n- * g_node_insert_data(), g_node_insert_data_after(),\n- * g_node_insert_data_before(), g_node_append_data()\n- * and g_node_prepend_data().\n- *\n- * To reverse the children of a node use g_node_reverse_children().\n- *\n- * To find a node use g_node_get_root(), g_node_find(),\n- * g_node_find_child(), g_node_child_index(), g_node_child_position(),\n- * g_node_first_child(), g_node_last_child(), g_node_nth_child(),\n- * g_node_first_sibling(), g_node_prev_sibling(), g_node_next_sibling()\n- * or g_node_last_sibling().\n- *\n- * To get information about a node or tree use G_NODE_IS_LEAF(),\n- * G_NODE_IS_ROOT(), g_node_depth(), g_node_n_nodes(),\n- * g_node_n_children(), g_node_is_ancestor() or g_node_max_height().\n- *\n- * To traverse a tree, calling a function for each node visited in the\n- * traversal, use g_node_traverse() or g_node_children_foreach().\n- *\n- * To remove a node or subtree from a tree use g_node_unlink() or\n- * g_node_destroy().\n- **\/\n-\n@@ -173,2 +136,2 @@\n- * @copy_func: the function which is called to copy the data inside each node,\n- *   or %NULL to use the original data.\n+ * @copy_func: (scope call): the function which is called to copy the data\n+ *   inside each node, or %NULL to use the original data.\n@@ -815,1 +778,1 @@\n- * @func: the function to call for each visited #GNode\n+ * @func: (scope call): the function to call for each visited #GNode\n@@ -1238,1 +1201,1 @@\n- * @func: the function to call for each visited node\n+ * @func: (scope call): the function to call for each visited node\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gnode.c","additions":4,"deletions":41,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-      dest->limbs = (mp_limb_t *) malloc (1);\n+      dest->limbs = (mp_limb_t *) malloc (sizeof (mp_limb_t));\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gnulib\/vasnprintf.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -22,160 +22,0 @@\n-\/**\n- * SECTION:goptioncontext\n- * @Short_description: parses commandline options\n- * @Title: Commandline option parser\n- *\n- * The GOption commandline parser is intended to be a simpler replacement\n- * for the popt library. It supports short and long commandline options,\n- * as shown in the following example:\n- *\n- * `testtreemodel -r 1 --max-size 20 --rand --display=:1.0 -vb -- file1 file2`\n- *\n- * The example demonstrates a number of features of the GOption\n- * commandline parser:\n- *\n- * - Options can be single letters, prefixed by a single dash.\n- *\n- * - Multiple short options can be grouped behind a single dash.\n- *\n- * - Long options are prefixed by two consecutive dashes.\n- *\n- * - Options can have an extra argument, which can be a number, a string or\n- *   a filename. For long options, the extra argument can be appended with\n- *   an equals sign after the option name, which is useful if the extra\n- *   argument starts with a dash, which would otherwise cause it to be\n- *   interpreted as another option.\n- *\n- * - Non-option arguments are returned to the application as rest arguments.\n- *\n- * - An argument consisting solely of two dashes turns off further parsing,\n- *   any remaining arguments (even those starting with a dash) are returned\n- *   to the application as rest arguments.\n- *\n- * Another important feature of GOption is that it can automatically\n- * generate nicely formatted help output. Unless it is explicitly turned\n- * off with g_option_context_set_help_enabled(), GOption will recognize\n- * the `--help`, `-?`, `--help-all` and `--help-groupname` options\n- * (where `groupname` is the name of a #GOptionGroup) and write a text\n- * similar to the one shown in the following example to stdout.\n- *\n- * |[\n- * Usage:\n- *   testtreemodel [OPTION...] - test tree model performance\n- *\n- * Help Options:\n- *   -h, --help               Show help options\n- *   --help-all               Show all help options\n- *   --help-gtk               Show GTK Options\n- *\n- * Application Options:\n- *   -r, --repeats=N          Average over N repetitions\n- *   -m, --max-size=M         Test up to 2^M items\n- *   --display=DISPLAY        X display to use\n- *   -v, --verbose            Be verbose\n- *   -b, --beep               Beep when done\n- *   --rand                   Randomize the data\n- * ]|\n- *\n- * GOption groups options in #GOptionGroups, which makes it easy to\n- * incorporate options from multiple sources. The intended use for this is\n- * to let applications collect option groups from the libraries it uses,\n- * add them to their #GOptionContext, and parse all options by a single call\n- * to g_option_context_parse(). See gtk_get_option_group() for an example.\n- *\n- * If an option is declared to be of type string or filename, GOption takes\n- * care of converting it to the right encoding; strings are returned in\n- * UTF-8, filenames are returned in the GLib filename encoding. Note that\n- * this only works if setlocale() has been called before\n- * g_option_context_parse().\n- *\n- * Here is a complete example of setting up GOption to parse the example\n- * commandline above and produce the example help output.\n- * |[<!-- language=\"C\" -->\n- * static gint repeats = 2;\n- * static gint max_size = 8;\n- * static gboolean verbose = FALSE;\n- * static gboolean beep = FALSE;\n- * static gboolean randomize = FALSE;\n- *\n- * static GOptionEntry entries[] =\n- * {\n- *   { \"repeats\", 'r', 0, G_OPTION_ARG_INT, &repeats, \"Average over N repetitions\", \"N\" },\n- *   { \"max-size\", 'm', 0, G_OPTION_ARG_INT, &max_size, \"Test up to 2^M items\", \"M\" },\n- *   { \"verbose\", 'v', 0, G_OPTION_ARG_NONE, &verbose, \"Be verbose\", NULL },\n- *   { \"beep\", 'b', 0, G_OPTION_ARG_NONE, &beep, \"Beep when done\", NULL },\n- *   { \"rand\", 0, 0, G_OPTION_ARG_NONE, &randomize, \"Randomize the data\", NULL },\n- *   G_OPTION_ENTRY_NULL\n- * };\n- *\n- * int\n- * main (int argc, char *argv[])\n- * {\n- *   GError *error = NULL;\n- *   GOptionContext *context;\n- *\n- *   context = g_option_context_new (\"- test tree model performance\");\n- *   g_option_context_add_main_entries (context, entries, GETTEXT_PACKAGE);\n- *   g_option_context_add_group (context, gtk_get_option_group (TRUE));\n- *   if (!g_option_context_parse (context, &argc, &argv, &error))\n- *     {\n- *       g_print (\"option parsing failed: %s\\n\", error->message);\n- *       exit (1);\n- *     }\n- *\n- *   ...\n- *\n- * }\n- * ]|\n- *\n- * On UNIX systems, the argv that is passed to main() has no particular\n- * encoding, even to the extent that different parts of it may have\n- * different encodings.  In general, normal arguments and flags will be\n- * in the current locale and filenames should be considered to be opaque\n- * byte strings.  Proper use of %G_OPTION_ARG_FILENAME vs\n- * %G_OPTION_ARG_STRING is therefore important.\n- *\n- * Note that on Windows, filenames do have an encoding, but using\n- * #GOptionContext with the argv as passed to main() will result in a\n- * program that can only accept commandline arguments with characters\n- * from the system codepage.  This can cause problems when attempting to\n- * deal with filenames containing Unicode characters that fall outside\n- * of the codepage.\n- *\n- * A solution to this is to use g_win32_get_command_line() and\n- * g_option_context_parse_strv() which will properly handle full Unicode\n- * filenames.  If you are using #GApplication, this is done\n- * automatically for you.\n- *\n- * The following example shows how you can use #GOptionContext directly\n- * in order to correctly deal with Unicode filenames on Windows:\n- *\n- * |[<!-- language=\"C\" -->\n- * int\n- * main (int argc, char **argv)\n- * {\n- *   GError *error = NULL;\n- *   GOptionContext *context;\n- *   gchar **args;\n- *\n- * #ifdef G_OS_WIN32\n- *   args = g_win32_get_command_line ();\n- * #else\n- *   args = g_strdupv (argv);\n- * #endif\n- *\n- *   \/\/ set up context\n- *\n- *   if (!g_option_context_parse_strv (context, &args, &error))\n- *     {\n- *       \/\/ error happened\n- *     }\n- *\n- *   ...\n- *\n- *   g_strfreev (args);\n- *\n- *   ...\n- * }\n- * ]|\n- *\/\n-\n@@ -198,0 +38,1 @@\n+#include \"gutilsprivate.h\"\n@@ -331,1 +172,1 @@\n- * g_option_context_new:\n+ * g_option_context_new: (constructor)\n@@ -356,1 +197,1 @@\n- * Returns: a newly created #GOptionContext, which must be\n+ * Returns: (transfer full): a newly created #GOptionContext, which must be\n@@ -384,1 +225,1 @@\n- * @context: a #GOptionContext\n+ * @context: (transfer full): a #GOptionContext\n@@ -1976,4 +1817,1 @@\n-      if (prgname)\n-  g_set_prgname (prgname);\n-      else\n-  g_set_prgname (\"<unknown>\");\n+      g_set_prgname_once (prgname ? prgname : \"<unknown>\");\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/goption.c","additions":5,"deletions":167,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -18,3 +18,1 @@\n- * SECTION:gpathbuf\n- * @Title: GPathBuf\n- * @Short_description: A mutable path builder\n+ * GPathBuf:\n@@ -26,1 +24,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -37,1 +35,1 @@\n- * ]|\n+ * ```\n@@ -41,1 +39,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -51,1 +49,1 @@\n- * ]|\n+ * ```\n@@ -53,1 +51,1 @@\n- * `GPathBuf` is available since GLib 2.76.\n+ * Since: 2.76\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gpathbuf.c","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -19,7 +19,0 @@\n-\/**\n- * GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n- *\n- * A mutable path builder.\n- *\n- * Since: 2.76\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gpathbuf.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,8 +34,7 @@\n- * SECTION:patterns\n- * @title: Glob-style pattern matching\n- * @short_description: matches strings against patterns containing '*'\n- *                     (wildcard) and '?' (joker)\n- *\n- * The g_pattern_match* functions match a string\n- * against a pattern containing '*' and '?' wildcards with similar\n- * semantics as the standard glob() function: '*' matches an arbitrary,\n+ * GPatternSpec:\n+ *\n+ * A `GPatternSpec` struct is the 'compiled' form of a glob-style pattern.\n+ *\n+ * The [func@GLib.pattern_match_simple] and [method@GLib.PatternSpec.match] functions\n+ * match a string against a pattern containing '*' and '?' wildcards with similar\n+ * semantics as the standard `glob()` function: '*' matches an arbitrary,\n@@ -44,1 +43,1 @@\n- * Note that in contrast to glob(), the '\/' character can be matched by\n+ * Note that in contrast to `glob()`, the '\/' character can be matched by\n@@ -48,4 +47,4 @@\n- * When multiple strings must be matched against the same pattern, it\n- * is better to compile the pattern to a #GPatternSpec using\n- * g_pattern_spec_new() and use g_pattern_match_string() instead of\n- * g_pattern_match_simple(). This avoids the overhead of repeated\n+ * When multiple strings must be matched against the same pattern, it is better\n+ * to compile the pattern to a [struct@GLib.PatternSpec] using\n+ * [ctor@GLib.PatternSpec.new] and use [method@GLib.PatternSpec.match_string]\n+ * instead of [func@GLib.pattern_match_simple]. This avoids the overhead of repeated\n@@ -53,7 +52,0 @@\n- **\/\n-\n-\/**\n- * GPatternSpec:\n- *\n- * A GPatternSpec struct is the 'compiled' form of a pattern. This\n- * structure is opaque and its fields cannot be accessed directly.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gpattern.c","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @...: the arguments to insert in the output.\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @...: the arguments to insert in the output\n@@ -37,1 +37,1 @@\n- * An implementation of the standard printf() function which supports\n+ * An implementation of the standard `printf()` function which supports\n@@ -40,1 +40,1 @@\n- * As with the standard printf(), this does not automatically append a trailing\n+ * As with the standard `printf()`, this does not automatically append a trailing\n@@ -46,1 +46,1 @@\n- * Returns: the number of bytes printed.\n+ * Returns: the number of bytes printed\n@@ -66,4 +66,4 @@\n- * @file: (not nullable): the stream to write to.\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @...: the arguments to insert in the output.\n+ * @file: (not nullable): the stream to write to\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @...: the arguments to insert in the output\n@@ -71,1 +71,1 @@\n- * An implementation of the standard fprintf() function which supports\n+ * An implementation of the standard `fprintf()` function which supports\n@@ -76,1 +76,1 @@\n- * Returns: the number of bytes printed.\n+ * Returns: the number of bytes printed\n@@ -98,5 +98,5 @@\n- *          is up to the caller to ensure that the allocated buffer is large\n- *          enough to hold the formatted result\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @...: the arguments to insert in the output.\n+ *   is up to the caller to ensure that the allocated buffer is large\n+ *   enough to hold the formatted result.\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @...: the arguments to insert in the output\n@@ -104,1 +104,1 @@\n- * An implementation of the standard sprintf() function which supports\n+ * An implementation of the standard `sprintf()` function which supports\n@@ -107,1 +107,1 @@\n- * Note that it is usually better to use g_snprintf(), to avoid the\n+ * Note that it is usually better to use [func@GLib.snprintf], to avoid the\n@@ -112,1 +112,1 @@\n- * See also g_strdup_printf().\n+ * See also [func@GLib.strdup_printf].\n@@ -114,1 +114,1 @@\n- * Returns: the number of bytes printed.\n+ * Returns: the number of bytes printed\n@@ -135,1 +135,1 @@\n- * @string: the buffer to hold the output.\n+ * @string: the buffer to hold the output\n@@ -137,4 +137,4 @@\n- *     terminating nul character).\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @...: the arguments to insert in the output.\n+ *   terminating nul character)\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @...: the arguments to insert in the output\n@@ -146,1 +146,1 @@\n- * See also g_strdup_printf().\n+ * See also [func@GLib.strdup_printf].\n@@ -155,1 +155,1 @@\n- * traditional snprintf(), which returns the length of the output string.\n+ * traditional `snprintf()`, which returns the length of the output string.\n@@ -161,1 +161,1 @@\n- *     was large enough.\n+ *   was large enough\n@@ -181,3 +181,3 @@\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @args: the list of arguments to insert in the output.\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @args: the list of arguments to insert in the output\n@@ -185,1 +185,1 @@\n- * An implementation of the standard vprintf() function which supports\n+ * An implementation of the standard `vprintf()` function which supports\n@@ -190,1 +190,1 @@\n- * Returns: the number of bytes printed.\n+ * Returns: the number of bytes printed\n@@ -205,4 +205,4 @@\n- * @file: (not nullable): the stream to write to.\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @args: the list of arguments to insert in the output.\n+ * @file: (not nullable): the stream to write to\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @args: the list of arguments to insert in the output\n@@ -210,1 +210,1 @@\n- * An implementation of the standard fprintf() function which supports\n+ * An implementation of the standard `fprintf()` function which supports\n@@ -215,1 +215,1 @@\n- * Returns: the number of bytes printed.\n+ * Returns: the number of bytes printed\n@@ -231,4 +231,4 @@\n- * @string: the buffer to hold the output.\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @args: the list of arguments to insert in the output.\n+ * @string: the buffer to hold the output\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @args: the list of arguments to insert in the output\n@@ -236,1 +236,1 @@\n- * An implementation of the standard vsprintf() function which supports\n+ * An implementation of the standard `vsprintf()` function which supports\n@@ -241,1 +241,1 @@\n- * Returns: the number of bytes printed.\n+ * Returns: the number of bytes printed\n@@ -258,1 +258,1 @@\n- * @string: the buffer to hold the output.\n+ * @string: the buffer to hold the output\n@@ -260,4 +260,4 @@\n- *     terminating nul character).\n- * @format: a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @args: the list of arguments to insert in the output.\n+ *   terminating nul character)\n+ * @format: a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @args: the list of arguments to insert in the output\n@@ -265,1 +265,1 @@\n- * A safer form of the standard vsprintf() function. The output is guaranteed\n+ * A safer form of the standard `vsprintf()` function. The output is guaranteed\n@@ -269,1 +269,1 @@\n- * See also g_strdup_vprintf().\n+ * See also [func@GLib.strdup_vprintf].\n@@ -276,1 +276,1 @@\n- * The return value of g_vsnprintf() conforms to the vsnprintf() function\n+ * The return value of `g_vsnprintf()` conforms to the `vsnprintf()` function\n@@ -278,1 +278,1 @@\n- * vsnprintf(), which returns the length of the output string.\n+ * `vsnprintf()`, which returns the length of the output string.\n@@ -284,1 +284,1 @@\n- *  was large enough.\n+ *  was large enough\n@@ -300,7 +300,8 @@\n- * @string: (not optional) (nullable): the return location for the newly-allocated string,\n- *   which will be %NULL if (and only if) this function fails\n- * @format: (not nullable): a standard printf() format string, but notice\n- *          [string precision pitfalls][string-precision]\n- * @args: the list of arguments to insert in the output.\n- *\n- * An implementation of the GNU vasprintf() function which supports\n+ * @string: (out) (not optional) (nullable): the return location for the\n+ *   newly-allocated string, which will be `NULL` if (and only if)\n+ *   this function fails\n+ * @format: (not nullable): a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n+ * @args: the list of arguments to insert in the output\n+ *\n+ * An implementation of the GNU `vasprintf()` function which supports\n@@ -308,1 +309,1 @@\n- * This function is similar to g_vsprintf(), except that it allocates a\n+ * This function is similar to [func@GLib.vsprintf], except that it allocates a\n@@ -312,1 +313,1 @@\n- * The returned value in @string is guaranteed to be non-NULL, unless\n+ * The returned value in @string is guaranteed to be non-`NULL`, unless\n@@ -318,1 +319,1 @@\n- * Returns: the number of bytes printed, or `-1` on failure\n+ * Returns: the number of bytes printed, or -1 on failure\n@@ -362,0 +363,2 @@\n+    char c;\n+    int max_len;\n@@ -365,1 +368,12 @@\n-    *string = g_new (gchar, g_printf_string_upper_bound (format, args));\n+    max_len = _g_vsnprintf (&c, 1, format, args);\n+    if (max_len < 0)\n+      {\n+        \/* This can happen if @format contains `%ls` or `%lc` and @args contains\n+         * something not representable in the current locale’s encoding (which\n+         * should be UTF-8, but ymmv). Basically: don’t use `%ls` or `%lc`. *\/\n+        va_end (args2);\n+        *string = NULL;\n+        return -1;\n+      }\n+\n+    *string = g_new (gchar, (size_t) max_len + 1);\n@@ -370,5 +384,2 @@\n-    if (len < 0)\n-      {\n-        g_free (*string);\n-        *string = NULL;\n-      }\n+    \/* _g_vsprintf() should have exactly the same failure modes as _g_vsnprintf() *\/\n+    g_assert (len >= 0);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gprintf.c","additions":83,"deletions":72,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n- * @compare_func: function to compare elements\n+ * @compare_func: (scope call): function to compare elements\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gqsort.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"glib-private.h\"\n@@ -70,4 +71,4 @@\n- * SECTION:quarks\n- * @title: Quarks\n- * @short_description: a 2-way association between a string and a\n- *     unique integer identifier\n+ * GQuark:\n+ *\n+ * A GQuark is a non-zero integer which uniquely identifies a\n+ * particular string.\n@@ -75,2 +76,3 @@\n- * Quarks are associations between strings and integer identifiers.\n- * Given either the string or the #GQuark identifier it is possible to\n+ * A GQuark value of zero is associated to `NULL`.\n+ *\n+ * Given either the string or the `GQuark` identifier it is possible to\n@@ -79,2 +81,2 @@\n- * Quarks are used for both [datasets][glib-Datasets] and\n- * [keyed data lists][glib-Keyed-Data-Lists].\n+ * Quarks are used for both\n+ * [datasets and keyed data lists](datalist-and-dataset.html).\n@@ -82,2 +84,2 @@\n- * To create a new quark from a string, use g_quark_from_string() or\n- * g_quark_from_static_string().\n+ * To create a new quark from a string, use [func@GLib.quark_from_string]\n+ * or [func@GLib.quark_from_static_string].\n@@ -85,2 +87,2 @@\n- * To find the string corresponding to a given #GQuark, use\n- * g_quark_to_string().\n+ * To find the string corresponding to a given `GQuark`, use\n+ * [func@GLib.quark_to_string].\n@@ -88,2 +90,2 @@\n- * To find the #GQuark corresponding to a given string, use\n- * g_quark_try_string().\n+ * To find the `GQuark` corresponding to a given string, use\n+ * [func@GLib.quark_try_string].\n@@ -92,2 +94,2 @@\n- * is string interning, using g_intern_string() or\n- * g_intern_static_string(). An interned string is a canonical\n+ * is string interning, using [func@GLib.intern_string] or\n+ * [func@GLib.intern_static_string]. An interned string is a canonical\n@@ -96,8 +98,1 @@\n- * pointer comparison, rather than using strcmp().\n- *\/\n-\n-\/**\n- * GQuark:\n- *\n- * A GQuark is a non-zero integer which uniquely identifies a\n- * particular string. A GQuark value of zero is associated to %NULL.\n+ * pointer comparison, rather than using `strcmp()`.\n@@ -304,0 +299,1 @@\n+      g_ignore_leak (g_atomic_pointer_get (&quarks));\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gquark.c","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -27,29 +27,0 @@\n-\/**\n- * SECTION:queue\n- * @Title: Double-ended Queues\n- * @Short_description: double-ended queue data structure\n- *\n- * The #GQueue structure and its associated functions provide a standard\n- * queue data structure. Internally, GQueue uses the same data structure\n- * as #GList to store elements with the same complexity over\n- * insertion\/deletion (O(1)) and access\/search (O(n)) operations.\n- *\n- * The data contained in each element can be either integer values, by\n- * using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],\n- * or simply pointers to any type of data.\n- *\n- * As with all other GLib data structures, #GQueue is not thread-safe.\n- * For a thread-safe queue, use #GAsyncQueue.\n- *\n- * To create a new GQueue, use g_queue_new().\n- *\n- * To initialize a statically-allocated GQueue, use %G_QUEUE_INIT or\n- * g_queue_init().\n- *\n- * To add elements, use g_queue_push_head(), g_queue_push_head_link(),\n- * g_queue_push_tail() and g_queue_push_tail_link().\n- *\n- * To remove elements, use g_queue_pop_head() and g_queue_pop_tail().\n- *\n- * To free the entire queue, use g_queue_free().\n- *\/\n@@ -259,1 +230,1 @@\n- * @func: the function to call for each element's data\n+ * @func: (scope call): the function to call for each element's data\n@@ -313,1 +284,1 @@\n- * @func: a #GCompareFunc to call for each element. It should return 0\n+ * @func: (scope call): a #GCompareFunc to call for each element. It should return 0\n@@ -340,1 +311,1 @@\n- * @compare_func: the #GCompareDataFunc used to sort @queue. This function\n+ * @compare_func: (scope call): the #GCompareDataFunc used to sort @queue. This function\n@@ -1168,1 +1139,1 @@\n- * @func: the #GCompareDataFunc used to compare elements in the queue. It is\n+ * @func: (scope call): the #GCompareDataFunc used to compare elements in the queue. It is\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gqueue.c","additions":4,"deletions":33,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -65,51 +65,0 @@\n-\/**\n- * SECTION:random_numbers\n- * @title: Random Numbers\n- * @short_description: pseudo-random number generator\n- *\n- * The following functions allow you to use a portable, fast and good\n- * pseudo-random number generator (PRNG).\n- *\n- * Do not use this API for cryptographic purposes such as key\n- * generation, nonces, salts or one-time pads.\n- *\n- * This PRNG is suitable for non-cryptographic use such as in games\n- * (shuffling a card deck, generating levels), generating data for\n- * a test suite, etc. If you need random data for cryptographic\n- * purposes, it is recommended to use platform-specific APIs such\n- * as `\/dev\/random` on UNIX, or CryptGenRandom() on Windows.\n- *\n- * GRand uses the Mersenne Twister PRNG, which was originally\n- * developed by Makoto Matsumoto and Takuji Nishimura. Further\n- * information can be found at\n- * [this page](http:\/\/www.math.sci.hiroshima-u.ac.jp\/~m-mat\/MT\/emt.html).\n- *\n- * If you just need a random number, you simply call the g_random_*\n- * functions, which will create a globally used #GRand and use the\n- * according g_rand_* functions internally. Whenever you need a\n- * stream of reproducible random numbers, you better create a\n- * #GRand yourself and use the g_rand_* functions directly, which\n- * will also be slightly faster. Initializing a #GRand with a\n- * certain seed will produce exactly the same series of random\n- * numbers on all platforms. This can thus be used as a seed for\n- * e.g. games.\n- *\n- * The g_rand*_range functions will return high quality equally\n- * distributed random numbers, whereas for example the\n- * `(g_random_int()%max)` approach often\n- * doesn't yield equally distributed numbers.\n- *\n- * GLib changed the seeding algorithm for the pseudo-random number\n- * generator Mersenne Twister, as used by #GRand. This was necessary,\n- * because some seeds would yield very bad pseudo-random streams.\n- * Also the pseudo-random integers generated by g_rand*_int_range()\n- * will have a slightly better equal distribution with the new\n- * version of GLib.\n- *\n- * The original seeding and generation algorithms, as found in\n- * GLib 2.0.x, can be used instead of the new ones by setting the\n- * environment variable `G_RANDOM_VERSION` to the value of '2.0'.\n- * Use the GLib-2.0 algorithms only if you have sequences of numbers\n- * generated with Glib-2.0 that you need to reproduce exactly.\n- *\/\n-\n@@ -173,1 +122,1 @@\n- * g_rand_new_with_seed:\n+ * g_rand_new_with_seed: (constructor)\n@@ -178,1 +127,1 @@\n- * Returns: the new #GRand\n+ * Returns: (transfer full): the new #GRand\n@@ -189,1 +138,1 @@\n- * g_rand_new_with_seed_array:\n+ * g_rand_new_with_seed_array: (constructor)\n@@ -196,1 +145,1 @@\n- * Returns: the new #GRand\n+ * Returns: (transfer full): the new #GRand\n@@ -210,1 +159,1 @@\n- * g_rand_new:\n+ * g_rand_new: (constructor)\n@@ -218,1 +167,1 @@\n- * Returns: the new #GRand\n+ * Returns: (transfer full): the new #GRand\n@@ -313,1 +262,1 @@\n- * Returns: the new #GRand\n+ * Returns: (transfer full): the new #GRand\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/grand.c","additions":7,"deletions":58,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -37,130 +37,0 @@\n-\/**\n- * SECTION:rcbox\n- * @Title: Reference counted data\n- * @Short_description: Allocated memory with reference counting semantics\n- *\n- * A \"reference counted box\", or \"RcBox\", is an opaque wrapper data type\n- * that is guaranteed to be as big as the size of a given data type, and\n- * which augments the given data type with reference counting semantics\n- * for its memory management.\n- *\n- * RcBox is useful if you have a plain old data type, like a structure\n- * typically placed on the stack, and you wish to provide additional API\n- * to use it on the heap; or if you want to implement a new type to be\n- * passed around by reference without necessarily implementing copy\/free\n- * semantics or your own reference counting.\n- *\n- * The typical use is:\n- *\n- * |[<!-- language=\"C\" -->\n- * typedef struct {\n- *   char *name;\n- *   char *address;\n- *   char *city;\n- *   char *state;\n- *   int age;\n- * } Person;\n- *\n- * Person *\n- * person_new (void)\n- * {\n- *   return g_rc_box_new0 (Person);\n- * }\n- * ]|\n- *\n- * Every time you wish to acquire a reference on the memory, you should\n- * call g_rc_box_acquire(); similarly, when you wish to release a reference\n- * you should call g_rc_box_release():\n- *\n- * |[<!-- language=\"C\" -->\n- * \/\/ Add a Person to the Database; the Database acquires ownership\n- * \/\/ of the Person instance\n- * void\n- * add_person_to_database (Database *db, Person *p)\n- * {\n- *   db->persons = g_list_prepend (db->persons, g_rc_box_acquire (p));\n- * }\n- *\n- * \/\/ Removes a Person from the Database; the reference acquired by\n- * \/\/ add_person_to_database() is released here\n- * void\n- * remove_person_from_database (Database *db, Person *p)\n- * {\n- *   db->persons = g_list_remove (db->persons, p);\n- *   g_rc_box_release (p);\n- * }\n- * ]|\n- *\n- * If you have additional memory allocated inside the structure, you can\n- * use g_rc_box_release_full(), which takes a function pointer, which\n- * will be called if the reference released was the last:\n- *\n- * |[<!-- language=\"C\" -->\n- * void\n- * person_clear (Person *p)\n- * {\n- *   g_free (p->name);\n- *   g_free (p->address);\n- *   g_free (p->city);\n- *   g_free (p->state);\n- * }\n- *\n- * void\n- * remove_person_from_database (Database *db, Person *p)\n- * {\n- *   db->persons = g_list_remove (db->persons, p);\n- *   g_rc_box_release_full (p, (GDestroyNotify) person_clear);\n- * }\n- * ]|\n- *\n- * If you wish to transfer the ownership of a reference counted data\n- * type without increasing the reference count, you can use g_steal_pointer():\n- *\n- * |[<!-- language=\"C\" -->\n- *   Person *p = g_rc_box_new (Person);\n- *\n- *   \/\/ fill_person_details() is defined elsewhere\n- *   fill_person_details (p);\n- *\n- *   \/\/ add_person_to_database_no_ref() is defined elsewhere; it adds\n- *   \/\/ a Person to the Database without taking a reference\n- *   add_person_to_database_no_ref (db, g_steal_pointer (&p));\n- * ]|\n- *\n- * ## Thread safety\n- *\n- * The reference counting operations on data allocated using g_rc_box_alloc(),\n- * g_rc_box_new(), and g_rc_box_dup() are not thread safe; it is your code's\n- * responsibility to ensure that references are acquired are released on the\n- * same thread.\n- *\n- * If you need thread safe reference counting, see the [atomic reference counted\n- * data][arcbox] API.\n- *\n- * ## Automatic pointer clean up\n- *\n- * If you want to add g_autoptr() support to your plain old data type through\n- * reference counting, you can use the G_DEFINE_AUTOPTR_CLEANUP_FUNC() and\n- * g_rc_box_release():\n- *\n- * |[<!-- language=\"C\" -->\n- * G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, g_rc_box_release)\n- * ]|\n- *\n- * If you need to clear the contents of the data, you will need to use an\n- * ancillary function that calls g_rc_box_release_full():\n- *\n- * |[<!-- language=\"C\" -->\n- * static void\n- * my_data_struct_release (MyDataStruct *data)\n- * {\n- *   \/\/ my_data_struct_clear() is defined elsewhere\n- *   g_rc_box_release_full (data, (GDestroyNotify) my_data_struct_clear);\n- * }\n- *\n- * G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, my_data_struct_release)\n- * ]|\n- *\n- * Since: 2.58\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/grcbox.c","additions":0,"deletions":130,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -21,23 +21,0 @@\n-\/**\n- * SECTION:refcount\n- * @Title: Reference counting\n- * @Short_description: Reference counting types and functions\n- *\n- * Reference counting is a garbage collection mechanism that is based on\n- * assigning a counter to a data type, or any memory area; the counter is\n- * increased whenever a new reference to that data type is acquired, and\n- * decreased whenever the reference is released. Once the last reference\n- * is released, the resources associated to that data type are freed.\n- *\n- * GLib uses reference counting in many of its data types, and provides\n- * the #grefcount and #gatomicrefcount types to implement safe and atomic\n- * reference counting semantics in new data types.\n- *\n- * It is important to note that #grefcount and #gatomicrefcount should be\n- * considered completely opaque types; you should always use the provided\n- * API to increase and decrease the counters, and you should never check\n- * their content directly, or compare their content with other values.\n- *\n- * Since: 2.58\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/grefcount.c","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -57,9 +57,0 @@\n-\/**\n- * SECTION:scanner\n- * @title: Lexical Scanner\n- * @short_description: a general purpose lexical scanner\n- *\n- * The #GScanner and its associated functions provide a\n- * general purpose lexical scanner.\n- *\/\n-\n@@ -199,1 +190,1 @@\n- * The data structure representing a lexical scanner.\n+ * `GScanner` provides a general-purpose lexical scanner.\n@@ -907,1 +898,1 @@\n- * @func: the function to call for each symbol\/value pair\n+ * @func: (scope call): the function to call for each symbol\/value pair\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gscanner.c","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2802,2 +2802,1 @@\n- { 0x2ff0,    12, G_UNICODE_SCRIPT_COMMON },\n- { 0x3000,     5, G_UNICODE_SCRIPT_COMMON },\n+ { 0x2ff0,    21, G_UNICODE_SCRIPT_COMMON },\n@@ -2827,0 +2826,1 @@\n+ { 0x31ef,     1, G_UNICODE_SCRIPT_COMMON },\n@@ -3344,0 +3344,1 @@\n+ { 0x2ebf0,   622, G_UNICODE_SCRIPT_HAN },\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gscripttable.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,48 +28,0 @@\n-\/**\n- * SECTION:sequence\n- * @title: Sequences\n- * @short_description: scalable lists\n- *\n- * The #GSequence data structure has the API of a list, but is\n- * implemented internally with a balanced binary tree. This means that\n- * most of the operations  (access, search, insertion, deletion, ...) on\n- * #GSequence are O(log(n)) in average and O(n) in worst case for time\n- * complexity. But, note that maintaining a balanced sorted list of n\n- * elements is done in time O(n log(n)).\n- * The data contained in each element can be either integer values, by using\n- * of the [Type Conversion Macros][glib-Type-Conversion-Macros], or simply\n- * pointers to any type of data.\n- *\n- * A #GSequence is accessed through \"iterators\", represented by a\n- * #GSequenceIter. An iterator represents a position between two\n- * elements of the sequence. For example, the \"begin\" iterator\n- * represents the gap immediately before the first element of the\n- * sequence, and the \"end\" iterator represents the gap immediately\n- * after the last element. In an empty sequence, the begin and end\n- * iterators are the same.\n- *\n- * Some methods on #GSequence operate on ranges of items. For example\n- * g_sequence_foreach_range() will call a user-specified function on\n- * each element with the given range. The range is delimited by the\n- * gaps represented by the passed-in iterators, so if you pass in the\n- * begin and end iterators, the range in question is the entire\n- * sequence.\n- *\n- * The function g_sequence_get() is used with an iterator to access the\n- * element immediately following the gap that the iterator represents.\n- * The iterator is said to \"point\" to that element.\n- *\n- * Iterators are stable across most operations on a #GSequence. For\n- * example an iterator pointing to some element of a sequence will\n- * continue to point to that element even after the sequence is sorted.\n- * Even moving an element to another sequence using for example\n- * g_sequence_move_range() will not invalidate the iterators pointing\n- * to it. The only operation that will invalidate an iterator is when\n- * the element it points to is removed from any sequence.\n- *\n- * To sort the data, either use g_sequence_insert_sorted() or\n- * g_sequence_insert_sorted_iter() to add data to the #GSequence or, if\n- * you want to add a large amount of data, it is more efficient to call\n- * g_sequence_sort() or g_sequence_sort_iter() after doing unsorted\n- * insertions.\n- *\/\n@@ -306,1 +258,1 @@\n- * @func: a #GFunc\n+ * @func: (scope call): a #GFunc\n@@ -348,1 +300,1 @@\n- * @func: the function to call for each item in @seq\n+ * @func: (scope call): the function to call for each item in @seq\n@@ -678,1 +630,1 @@\n- * @cmp_func: the function used to sort the sequence\n+ * @cmp_func: (scope call): the function used to sort the sequence\n@@ -710,1 +662,1 @@\n- * @cmp_func: the function used to compare items in the sequence\n+ * @cmp_func: (scope call): the function used to compare items in the sequence\n@@ -752,1 +704,1 @@\n- * @cmp_func: the function used to compare items in the sequence\n+ * @cmp_func: (scope call): the function used to compare items in the sequence\n@@ -793,1 +745,1 @@\n- * @cmp_func: the function used to compare items in the sequence\n+ * @cmp_func: (scope call): the function used to compare items in the sequence\n@@ -837,1 +789,1 @@\n- * @cmp_func: the function used to compare items in the sequence\n+ * @cmp_func: (scope call): the function used to compare items in the sequence\n@@ -881,1 +833,1 @@\n- * @cmp_func: the function used to compare iterators in the sequence\n+ * @cmp_func: (scope call): the function used to compare iterators in the sequence\n@@ -935,1 +887,1 @@\n- * @iter_cmp: the function used to compare iterators in the sequence\n+ * @iter_cmp: (scope call): the function used to compare iterators in the sequence\n@@ -1000,1 +952,1 @@\n- * @iter_cmp: the function used to compare iterators in the sequence\n+ * @iter_cmp: (scope call): the function used to compare iterators in the sequence\n@@ -1067,1 +1019,1 @@\n- * @iter_cmp: the function used to compare iterators in the sequence\n+ * @iter_cmp: (scope call): the function used to compare iterators in the sequence\n@@ -1125,1 +1077,1 @@\n- * @iter_cmp: the function used to compare iterators in the sequence\n+ * @iter_cmp: (scope call): the function used to compare iterators in the sequence\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gsequence.c","additions":12,"deletions":60,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -36,14 +36,0 @@\n-\/**\n- * SECTION:shell\n- * @title: Shell-related Utilities\n- * @short_description: shell-like commandline handling\n- *\n- * GLib provides the functions g_shell_quote() and g_shell_unquote()\n- * to handle shell-like quoting in strings. The function g_shell_parse_argv()\n- * parses a string similar to the way a POSIX shell (\/bin\/sh) would.\n- *\n- * Note that string handling in shells has many obscure and historical\n- * corner-cases which these functions do not necessarily reproduce. They\n- * are good enough in practice, though.\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gshell.c","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,59 +33,0 @@\n-\/**\n- * SECTION:memory_slices\n- * @title: Memory Slices\n- * @short_description: efficient way to allocate groups of equal-sized\n- *     chunks of memory\n- *\n- * GSlice was a space-efficient and multi-processing scalable way to allocate\n- * equal sized pieces of memory. Since GLib 2.76, its implementation has been\n- * removed and it calls g_malloc() and g_free_sized(), because the performance\n- * of the system-default allocators has improved on all platforms since GSlice\n- * was written.\n- *\n- * The GSlice APIs have not been deprecated, as they are widely in use and doing\n- * so would be very disruptive for little benefit.\n- *\n- * New code should be written using g_new()\/g_malloc() and g_free_sized() or\n- * g_free(). There is no particular benefit in porting existing code away from\n- * g_slice_new()\/g_slice_free() unless it’s being rewritten anyway.\n- *\n- * Here is an example for using the slice allocator:\n- * |[<!-- language=\"C\" -->\n- * gchar *mem[10000];\n- * gint i;\n- *\n- * \/\/ Allocate 10000 blocks.\n- * for (i = 0; i < 10000; i++)\n- *   {\n- *     mem[i] = g_slice_alloc (50);\n- *\n- *     \/\/ Fill in the memory with some junk.\n- *     for (j = 0; j < 50; j++)\n- *       mem[i][j] = i * j;\n- *   }\n- *\n- * \/\/ Now free all of the blocks.\n- * for (i = 0; i < 10000; i++)\n- *   g_slice_free1 (50, mem[i]);\n- * ]|\n- *\n- * And here is an example for using the using the slice allocator\n- * with data structures:\n- * |[<!-- language=\"C\" -->\n- * GRealArray *array;\n- *\n- * \/\/ Allocate one block, using the g_slice_new() macro.\n- * array = g_slice_new (GRealArray);\n- *\n- * \/\/ We can now use array just like a normal pointer to a structure.\n- * array->data            = NULL;\n- * array->len             = 0;\n- * array->alloc           = 0;\n- * array->zero_terminated = (zero_terminated ? 1 : 0);\n- * array->clear           = (clear ? 1 : 0);\n- * array->elt_size        = elt_size;\n- *\n- * \/\/ We can free the block, so it can be reused.\n- * g_slice_free (GRealArray, array);\n- * ]|\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gslice.c","additions":0,"deletions":59,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+#ifndef __GI_SCANNER__\n@@ -114,0 +115,1 @@\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gslice.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,51 +38,0 @@\n-\/**\n- * SECTION:linked_lists_single\n- * @title: Singly-Linked Lists\n- * @short_description: linked lists that can be iterated in one direction\n- *\n- * The #GSList structure and its associated functions provide a\n- * standard singly-linked list data structure. The benefit of this\n- * data-structure is to provide insertion\/deletion operations in O(1)\n- * complexity where access\/search operations are in O(n). The benefit\n- * of #GSList over #GList (doubly linked list) is that they are lighter\n- * in space as they only need to retain one pointer but it double the\n- * cost of the worst case access\/search operations.\n- *\n- * Each element in the list contains a piece of data, together with a\n- * pointer which links to the next element in the list. Using this\n- * pointer it is possible to move through the list in one direction\n- * only (unlike the [double-linked lists][glib-Doubly-Linked-Lists],\n- * which allow movement in both directions).\n- *\n- * The data contained in each element can be either integer values, by\n- * using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],\n- * or simply pointers to any type of data.\n- *\n- * List elements are allocated from the [slice allocator][glib-Memory-Slices],\n- * which is more efficient than allocating elements individually.\n- *\n- * Note that most of the #GSList functions expect to be passed a\n- * pointer to the first element in the list. The functions which insert\n- * elements return the new start of the list, which may have changed.\n- *\n- * There is no function to create a #GSList. %NULL is considered to be\n- * the empty list so you simply set a #GSList* to %NULL.\n- *\n- * To add elements, use g_slist_append(), g_slist_prepend(),\n- * g_slist_insert() and g_slist_insert_sorted().\n- *\n- * To remove elements, use g_slist_remove().\n- *\n- * To find elements in the list use g_slist_last(), g_slist_next(),\n- * g_slist_nth(), g_slist_nth_data(), g_slist_find() and\n- * g_slist_find_custom().\n- *\n- * To find the index of an element use g_slist_position() and\n- * g_slist_index().\n- *\n- * To call a function for each element in the list use\n- * g_slist_foreach().\n- *\n- * To free the entire list, use g_slist_free().\n- **\/\n-\n@@ -575,1 +524,1 @@\n- * @func: a copy function used to copy every element in the list\n+ * @func: (scope call): a copy function used to copy every element in the list\n@@ -731,1 +680,1 @@\n- * @func: the function to call for each element.\n+ * @func: (scope call): the function to call for each element.\n@@ -871,1 +820,1 @@\n- * @func: the function to call with each element's data\n+ * @func: (scope call): the function to call with each element's data\n@@ -950,1 +899,1 @@\n- * @func: the function to compare elements in the list.\n+ * @func: (scope call): the function to compare elements in the list.\n@@ -971,1 +920,1 @@\n- * @func: the function to compare elements in the list.\n+ * @func: (scope call): the function to compare elements in the list.\n@@ -1056,1 +1005,1 @@\n- * @compare_func: the comparison function used to sort the #GSList.\n+ * @compare_func: (scope call): the comparison function used to sort the #GSList.\n@@ -1077,1 +1026,1 @@\n- * @compare_func: comparison function\n+ * @compare_func: (scope call): comparison function\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gslist.c","additions":7,"deletions":58,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-#ifdef __APPLE__\n+#if defined(__APPLE__) && defined(HAVE_LIBPROC_H)\n@@ -113,61 +113,0 @@\n-\/**\n- * SECTION:spawn\n- * @Short_description: process launching\n- * @Title: Spawning Processes\n- *\n- * GLib supports spawning of processes with an API that is more\n- * convenient than the bare UNIX fork() and exec().\n- *\n- * The g_spawn family of functions has synchronous (g_spawn_sync())\n- * and asynchronous variants (g_spawn_async(), g_spawn_async_with_pipes()),\n- * as well as convenience variants that take a complete shell-like\n- * commandline (g_spawn_command_line_sync(), g_spawn_command_line_async()).\n- *\n- * See #GSubprocess in GIO for a higher-level API that provides\n- * stream interfaces for communication with child processes.\n- *\n- * An example of using g_spawn_async_with_pipes():\n- * |[<!-- language=\"C\" -->\n- * const gchar * const argv[] = { \"my-favourite-program\", \"--args\", NULL };\n- * gint child_stdout, child_stderr;\n- * GPid child_pid;\n- * g_autoptr(GError) error = NULL;\n- *\n- * \/\/ Spawn child process.\n- * g_spawn_async_with_pipes (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL,\n- *                           NULL, &child_pid, NULL, &child_stdout,\n- *                           &child_stderr, &error);\n- * if (error != NULL)\n- *   {\n- *     g_error (\"Spawning child failed: %s\", error->message);\n- *     return;\n- *   }\n- *\n- * \/\/ Add a child watch function which will be called when the child process\n- * \/\/ exits.\n- * g_child_watch_add (child_pid, child_watch_cb, NULL);\n- *\n- * \/\/ You could watch for output on @child_stdout and @child_stderr using\n- * \/\/ #GUnixInputStream or #GIOChannel here.\n- *\n- * static void\n- * child_watch_cb (GPid     pid,\n- *                 gint     status,\n- *                 gpointer user_data)\n- * {\n- *   g_message (\"Child %\" G_PID_FORMAT \" exited %s\", pid,\n- *              g_spawn_check_wait_status (status, NULL) ? \"normally\" : \"abnormally\");\n- *\n- *   \/\/ Free any resources associated with the child here, such as I\/O channels\n- *   \/\/ on its stdout and stderr FDs. If you have no code to put in the\n- *   \/\/ child_watch_cb() callback, you can remove it and the g_child_watch_add()\n- *   \/\/ call, but you must also remove the G_SPAWN_DO_NOT_REAP_CHILD flag,\n- *   \/\/ otherwise the child process will stay around as a zombie until this\n- *   \/\/ process exits.\n- *\n- *   g_spawn_close_pid (pid);\n- * }\n- * ]|\n- *\/\n-\n-\n@@ -266,17 +205,0 @@\n-\/* Avoids a danger in threaded situations (calling close()\n- * on a file descriptor twice, and another thread has\n- * re-opened it since the first close)\n- *\n- * This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)).\n- *\/\n-static void\n-close_and_invalidate (gint *fd)\n-{\n-  if (*fd < 0)\n-    return;\n-\n-  g_close (*fd, NULL);\n-  *fd = -1;\n-}\n-\n@@ -487,2 +409,1 @@\n-              close_and_invalidate (&outpipe);\n-              outpipe = -1;\n+              g_clear_fd (&outpipe, NULL);\n@@ -506,2 +427,1 @@\n-              close_and_invalidate (&errpipe);\n-              errpipe = -1;\n+              g_clear_fd (&errpipe, NULL);\n@@ -519,5 +439,2 @@\n-\n-  if (outpipe >= 0)\n-    close_and_invalidate (&outpipe);\n-  if (errpipe >= 0)\n-    close_and_invalidate (&errpipe);\n+  g_clear_fd (&outpipe, NULL);\n+  g_clear_fd (&errpipe, NULL);\n@@ -1280,2 +1197,2 @@\n-static int\n-set_cloexec (void *data, gint fd)\n+static void\n+set_cloexec (int fd)\n@@ -1283,4 +1200,1 @@\n-  if (fd >= GPOINTER_TO_INT (data))\n-    fcntl (fd, F_SETFD, FD_CLOEXEC);\n-\n-  return 0;\n+  fcntl (fd, F_SETFD, FD_CLOEXEC);\n@@ -1351,331 +1265,0 @@\n-\/* fdwalk()-compatible callback to close a fd for non-compliant\n- * implementations of fdwalk() that potentially pass already\n- * closed fds.\n- *\n- * It is not an error to pass an invalid fd to this function.\n- *\n- * This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)).\n- *\/\n-G_GNUC_UNUSED static int\n-close_func_with_invalid_fds (void *data, int fd)\n-{\n-  \/* We use close and not g_close here because on some platforms, we\n-   * don't know how to close only valid, open file descriptors, so we\n-   * have to pass bad fds to close too. g_close warns if given a bad\n-   * fd.\n-   *\n-   * This function returns no error, because there is nothing that the caller\n-   * could do with that information. That is even the case for EINTR. See\n-   * g_close() about the specialty of EINTR and why that is correct.\n-   * If g_close() ever gets extended to handle EINTR specially, then this place\n-   * should get updated to do the same handling.\n-   *\/\n-  if (fd >= GPOINTER_TO_INT (data))\n-    close (fd);\n-\n-  return 0;\n-}\n-\n-#ifdef __linux__\n-struct linux_dirent64\n-{\n-  guint64        d_ino;    \/* 64-bit inode number *\/\n-  guint64        d_off;    \/* 64-bit offset to next structure *\/\n-  unsigned short d_reclen; \/* Size of this dirent *\/\n-  unsigned char  d_type;   \/* File type *\/\n-  char           d_name[]; \/* Filename (null-terminated) *\/\n-};\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static gint\n-filename_to_fd (const char *p)\n-{\n-  char c;\n-  int fd = 0;\n-  const int cutoff = G_MAXINT \/ 10;\n-  const int cutlim = G_MAXINT % 10;\n-\n-  if (*p == '\\0')\n-    return -1;\n-\n-  while ((c = *p++) != '\\0')\n-    {\n-      if (c < '0' || c > '9')\n-        return -1;\n-      c -= '0';\n-\n-      \/* Check for overflow. *\/\n-      if (fd > cutoff || (fd == cutoff && c > cutlim))\n-        return -1;\n-\n-      fd = fd * 10 + c;\n-    }\n-\n-  return fd;\n-}\n-#endif\n-\n-static int safe_fdwalk_with_invalid_fds (int (*cb)(void *data, int fd), void *data);\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static int\n-safe_fdwalk (int (*cb)(void *data, int fd), void *data)\n-{\n-#if 0\n-  \/* Use fdwalk function provided by the system if it is known to be\n-   * async-signal safe.\n-   *\n-   * Currently there are no operating systems known to provide a safe\n-   * implementation, so this section is not used for now.\n-   *\/\n-  return fdwalk (cb, data);\n-#else\n-  \/* Fallback implementation of fdwalk. It should be async-signal safe, but it\n-   * may fail on non-Linux operating systems. See safe_fdwalk_with_invalid_fds\n-   * for a slower alternative.\n-   *\/\n-\n-#ifdef __linux__\n-  gint fd;\n-  gint res = 0;\n-\n-  \/* Avoid use of opendir\/closedir since these are not async-signal-safe. *\/\n-  int dir_fd = open (\"\/proc\/self\/fd\", O_RDONLY | O_DIRECTORY);\n-  if (dir_fd >= 0)\n-    {\n-      \/* buf needs to be aligned correctly to receive linux_dirent64.\n-       * C11 has _Alignof for this purpose, but for now a\n-       * union serves the same purpose. *\/\n-      union\n-      {\n-        char buf[4096];\n-        struct linux_dirent64 alignment;\n-      } u;\n-      int pos, nread;\n-      struct linux_dirent64 *de;\n-\n-      while ((nread = syscall (SYS_getdents64, dir_fd, u.buf, sizeof (u.buf))) > 0)\n-        {\n-          for (pos = 0; pos < nread; pos += de->d_reclen)\n-            {\n-              de = (struct linux_dirent64 *) (u.buf + pos);\n-\n-              fd = filename_to_fd (de->d_name);\n-              if (fd < 0 || fd == dir_fd)\n-                  continue;\n-\n-              if ((res = cb (data, fd)) != 0)\n-                  break;\n-            }\n-        }\n-\n-      g_close (dir_fd, NULL);\n-      return res;\n-    }\n-\n-  \/* If \/proc is not mounted or not accessible we fail here and rely on\n-   * safe_fdwalk_with_invalid_fds to fall back to the old\n-   * rlimit trick. *\/\n-\n-#endif\n-\n-#if defined(__sun__) && defined(F_PREVFD) && defined(F_NEXTFD)\n-\/*\n- * Solaris 11.4 has a signal-safe way which allows\n- * us to find all file descriptors in a process.\n- *\n- * fcntl(fd, F_NEXTFD, maxfd)\n- * - returns the first allocated file descriptor <= maxfd  > fd.\n- *\n- * fcntl(fd, F_PREVFD)\n- * - return highest allocated file descriptor < fd.\n- *\/\n-  gint fd;\n-  gint res = 0;\n-\n-  open_max = fcntl (INT_MAX, F_PREVFD); \/* find the maximum fd *\/\n-  if (open_max < 0) \/* No open files *\/\n-    return 0;\n-\n-  for (fd = -1; (fd = fcntl (fd, F_NEXTFD, open_max)) != -1; )\n-    if ((res = cb (data, fd)) != 0 || fd == open_max)\n-      break;\n-\n-  return res;\n-#endif\n-\n-  return safe_fdwalk_with_invalid_fds (cb, data);\n-#endif\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static int\n-safe_fdwalk_with_invalid_fds (int (*cb)(void *data, int fd), void *data)\n-{\n-  \/* Fallback implementation of fdwalk. It should be async-signal safe, but it\n-   * may be slow, especially on systems allowing very high number of open file\n-   * descriptors.\n-   *\/\n-  gint open_max = -1;\n-  gint fd;\n-  gint res = 0;\n-\n-#if 0 && defined(HAVE_SYS_RESOURCE_H)\n-  struct rlimit rl;\n-\n-  \/* Use getrlimit() function provided by the system if it is known to be\n-   * async-signal safe.\n-   *\n-   * Currently there are no operating systems known to provide a safe\n-   * implementation, so this section is not used for now.\n-   *\/\n-  if (getrlimit (RLIMIT_NOFILE, &rl) == 0 && rl.rlim_max != RLIM_INFINITY)\n-    open_max = rl.rlim_max;\n-#endif\n-#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__APPLE__)\n-  \/* Use sysconf() function provided by the system if it is known to be\n-   * async-signal safe.\n-   *\n-   * FreeBSD: sysconf() is included in the list of async-signal safe functions\n-   * found in https:\/\/man.freebsd.org\/sigaction(2).\n-   *\n-   * OpenBSD: sysconf() is included in the list of async-signal safe functions\n-   * found in https:\/\/man.openbsd.org\/sigaction.2.\n-   *\n-   * Apple: sysconf() is included in the list of async-signal safe functions\n-   * found in https:\/\/opensource.apple.com\/source\/xnu\/xnu-517.12.7\/bsd\/man\/man2\/sigaction.2\n-   *\/\n-  if (open_max < 0)\n-    open_max = sysconf (_SC_OPEN_MAX);\n-#endif\n-  \/* Hardcoded fallback: the default process hard limit in Linux as of 2020 *\/\n-  if (open_max < 0)\n-    open_max = 4096;\n-\n-#if defined(__APPLE__)\n-  \/* proc_pidinfo isn't documented as async-signal-safe but looking at the implementation\n-   * in the darwin tree here:\n-   *\n-   * https:\/\/opensource.apple.com\/source\/Libc\/Libc-498\/darwin\/libproc.c.auto.html\n-   *\n-   * It's just a thin wrapper around a syscall, so it's probably okay.\n-   *\/\n-  {\n-    char buffer[4096 * PROC_PIDLISTFD_SIZE];\n-    ssize_t buffer_size;\n-\n-    buffer_size = proc_pidinfo (getpid (), PROC_PIDLISTFDS, 0, buffer, sizeof (buffer));\n-\n-    if (buffer_size > 0 &&\n-        sizeof (buffer) >= (size_t) buffer_size &&\n-        (buffer_size % PROC_PIDLISTFD_SIZE) == 0)\n-      {\n-        const struct proc_fdinfo *fd_info = (const struct proc_fdinfo *) buffer;\n-        size_t number_of_fds = (size_t) buffer_size \/ PROC_PIDLISTFD_SIZE;\n-\n-        for (size_t i = 0; i < number_of_fds; i++)\n-          if ((res = cb (data, fd_info[i].proc_fd)) != 0)\n-            break;\n-\n-        return res;\n-      }\n-  }\n-#endif\n-\n-  for (fd = 0; fd < open_max; fd++)\n-      if ((res = cb (data, fd)) != 0)\n-          break;\n-\n-  return res;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static int\n-safe_fdwalk_set_cloexec (int lowfd)\n-{\n-  int ret;\n-\n-#if defined(HAVE_CLOSE_RANGE) && defined(CLOSE_RANGE_CLOEXEC)\n-  \/* close_range() is available in Linux since kernel 5.9, and on FreeBSD at\n-   * around the same time. It was designed for use in async-signal-safe\n-   * situations: https:\/\/bugs.python.org\/issue38061\n-   *\n-   * The `CLOSE_RANGE_CLOEXEC` flag was added in Linux 5.11, and is not yet\n-   * present in FreeBSD.\n-   *\n-   * Handle ENOSYS in case it’s supported in libc but not the kernel; if so,\n-   * fall back to safe_fdwalk(). Handle EINVAL in case `CLOSE_RANGE_CLOEXEC`\n-   * is not supported. *\/\n-  ret = close_range (lowfd, G_MAXUINT, CLOSE_RANGE_CLOEXEC);\n-  if (ret == 0 || !(errno == ENOSYS || errno == EINVAL))\n-    return ret;\n-#endif  \/* HAVE_CLOSE_RANGE *\/\n-\n-  ret = safe_fdwalk (set_cloexec, GINT_TO_POINTER (lowfd));\n-\n-  return ret;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)).\n- *\n- * On failure, `-1` will be returned and errno will be set. *\/\n-static int\n-safe_closefrom (int lowfd)\n-{\n-  int ret;\n-\n-#if defined(HAVE_CLOSE_RANGE)\n-  \/* close_range() is available in Linux since kernel 5.9, and on FreeBSD at\n-   * around the same time. It was designed for use in async-signal-safe\n-   * situations: https:\/\/bugs.python.org\/issue38061\n-   *\n-   * Handle ENOSYS in case it’s supported in libc but not the kernel; if so,\n-   * fall back to safe_fdwalk(). *\/\n-  ret = close_range (lowfd, G_MAXUINT, 0);\n-  if (ret == 0 || errno != ENOSYS)\n-    return ret;\n-#endif  \/* HAVE_CLOSE_RANGE *\/\n-\n-#if defined(__FreeBSD__) || defined(__OpenBSD__) || \\\n-  (defined(__sun__) && defined(F_CLOSEFROM))\n-  \/* Use closefrom function provided by the system if it is known to be\n-   * async-signal safe.\n-   *\n-   * FreeBSD: closefrom is included in the list of async-signal safe functions\n-   * found in https:\/\/man.freebsd.org\/sigaction(2).\n-   *\n-   * OpenBSD: closefrom is not included in the list, but a direct system call\n-   * should be safe to use.\n-   *\n-   * In Solaris as of 11.3 SRU 31, closefrom() is also a direct system call.\n-   * On such systems, F_CLOSEFROM is defined.\n-   *\/\n-  (void) closefrom (lowfd);\n-  return 0;\n-#elif defined(__DragonFly__)\n-  \/* It is unclear whether closefrom function included in DragonFlyBSD libc_r\n-   * is safe to use because it calls a lot of library functions. It is also\n-   * unclear whether libc_r itself is still being used. Therefore, we do a\n-   * direct system call here ourselves to avoid possible issues.\n-   *\/\n-  (void) syscall (SYS_closefrom, lowfd);\n-  return 0;\n-#elif defined(F_CLOSEM)\n-  \/* NetBSD and AIX have a special fcntl command which does the same thing as\n-   * closefrom. NetBSD also includes closefrom function, which seems to be a\n-   * simple wrapper of the fcntl command.\n-   *\/\n-  return fcntl (lowfd, F_CLOSEM);\n-#else\n-  ret = safe_fdwalk (close_func_with_invalid_fds, GINT_TO_POINTER (lowfd));\n-\n-  return ret;\n-#endif\n-}\n-\n@@ -1813,1 +1396,1 @@\n-      set_cloexec (GINT_TO_POINTER(0), stdin_fd);\n+      set_cloexec (stdin_fd);\n@@ -1825,1 +1408,1 @@\n-      close_and_invalidate (&read_null);\n+      g_clear_fd (&read_null, NULL);\n@@ -1851,1 +1434,1 @@\n-      set_cloexec (GINT_TO_POINTER(0), stdout_fd);\n+      set_cloexec (stdout_fd);\n@@ -1862,1 +1445,1 @@\n-      close_and_invalidate (&write_null);\n+      g_clear_fd (&write_null, NULL);\n@@ -1883,1 +1466,1 @@\n-      set_cloexec (GINT_TO_POINTER(0), stderr_fd);\n+      set_cloexec (stderr_fd);\n@@ -1894,1 +1477,1 @@\n-      close_and_invalidate (&write_null);\n+      g_clear_fd (&write_null, NULL);\n@@ -1908,2 +1491,2 @@\n-          set_cloexec (GINT_TO_POINTER (0), 3);\n-          if (safe_closefrom (4) < 0)\n+          set_cloexec (3);\n+          if (g_closefrom (4) < 0)\n@@ -1915,1 +1498,1 @@\n-          if (safe_fdwalk_set_cloexec (3) < 0)\n+          if (g_fdwalk_set_cloexec (3) < 0)\n@@ -1922,1 +1505,1 @@\n-      set_cloexec (GINT_TO_POINTER (0), child_err_report_fd);\n+      set_cloexec (child_err_report_fd);\n@@ -1985,1 +1568,1 @@\n-              close_and_invalidate (&source_fds[i]);\n+              g_clear_fd (&source_fds[i], NULL);\n@@ -2231,0 +1814,2 @@\n+  for (i = 0; i < n_fds; i++)\n+    duped_source_fds[i] = -1;  \/* initialise in case dupfd_cloexec() fails below *\/\n@@ -2275,1 +1860,1 @@\n-    close_and_invalidate (&parent_close_fds [i]);\n+    g_clear_fd (&parent_close_fds[i], NULL);\n@@ -2280,1 +1865,1 @@\n-        close_and_invalidate (&duped_source_fds[i]);\n+        g_clear_fd (&duped_source_fds[i], NULL);\n@@ -2293,0 +1878,10 @@\n+static gboolean\n+source_fds_collide_with_pipe (const GUnixPipe  *pipefd,\n+                              const int        *source_fds,\n+                              gsize             n_fds,\n+                              GError          **error)\n+{\n+  return (_g_spawn_invalid_source_fd (pipefd->fds[G_UNIX_PIPE_END_READ], source_fds, n_fds, error) ||\n+          _g_spawn_invalid_source_fd (pipefd->fds[G_UNIX_PIPE_END_WRITE], source_fds, n_fds, error));\n+}\n+\n@@ -2321,3 +1916,3 @@\n-  gint child_err_report_pipe[2] = { -1, -1 };\n-  gint child_pid_report_pipe[2] = { -1, -1 };\n-  guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;\n+  GUnixPipe child_err_report_pipe = G_UNIX_PIPE_INIT;\n+  GUnixPipe child_pid_report_pipe = G_UNIX_PIPE_INIT;\n+  guint pipe_flags = cloexec_pipes ? O_CLOEXEC : 0;\n@@ -2332,3 +1927,3 @@\n-  gint stdin_pipe[2] = { -1, -1 };\n-  gint stdout_pipe[2] = { -1, -1 };\n-  gint stderr_pipe[2] = { -1, -1 };\n+  GUnixPipe stdin_pipe = G_UNIX_PIPE_INIT;\n+  GUnixPipe stdout_pipe = G_UNIX_PIPE_INIT;\n+  GUnixPipe stderr_pipe = G_UNIX_PIPE_INIT;\n@@ -2347,1 +1942,1 @@\n-      if (!g_unix_open_pipe (stdin_pipe, pipe_flags, error))\n+      if (!g_unix_pipe_open (&stdin_pipe, pipe_flags, error))\n@@ -2349,2 +1944,1 @@\n-      if (_g_spawn_invalid_source_fd (stdin_pipe[0], source_fds, n_fds, error) ||\n-          _g_spawn_invalid_source_fd (stdin_pipe[1], source_fds, n_fds, error))\n+      if (source_fds_collide_with_pipe (&stdin_pipe, source_fds, n_fds, error))\n@@ -2352,2 +1946,2 @@\n-      child_close_fds[n_child_close_fds++] = stdin_pipe[1];\n-      stdin_fd = stdin_pipe[0];\n+      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stdin_pipe, G_UNIX_PIPE_END_WRITE);\n+      stdin_fd = g_unix_pipe_get (&stdin_pipe, G_UNIX_PIPE_END_READ);\n@@ -2358,1 +1952,1 @@\n-      if (!g_unix_open_pipe (stdout_pipe, pipe_flags, error))\n+      if (!g_unix_pipe_open (&stdout_pipe, pipe_flags, error))\n@@ -2360,2 +1954,1 @@\n-      if (_g_spawn_invalid_source_fd (stdout_pipe[0], source_fds, n_fds, error) ||\n-          _g_spawn_invalid_source_fd (stdout_pipe[1], source_fds, n_fds, error))\n+      if (source_fds_collide_with_pipe (&stdout_pipe, source_fds, n_fds, error))\n@@ -2363,2 +1956,2 @@\n-      child_close_fds[n_child_close_fds++] = stdout_pipe[0];\n-      stdout_fd = stdout_pipe[1];\n+      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stdout_pipe, G_UNIX_PIPE_END_READ);\n+      stdout_fd = g_unix_pipe_get (&stdout_pipe, G_UNIX_PIPE_END_WRITE);\n@@ -2369,1 +1962,1 @@\n-      if (!g_unix_open_pipe (stderr_pipe, pipe_flags, error))\n+      if (!g_unix_pipe_open (&stderr_pipe, pipe_flags, error))\n@@ -2371,2 +1964,1 @@\n-      if (_g_spawn_invalid_source_fd (stderr_pipe[0], source_fds, n_fds, error) ||\n-          _g_spawn_invalid_source_fd (stderr_pipe[1], source_fds, n_fds, error))\n+      if (source_fds_collide_with_pipe (&stderr_pipe, source_fds, n_fds, error))\n@@ -2374,2 +1966,2 @@\n-      child_close_fds[n_child_close_fds++] = stderr_pipe[0];\n-      stderr_fd = stderr_pipe[1];\n+      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stderr_pipe, G_UNIX_PIPE_END_READ);\n+      stderr_fd = g_unix_pipe_get (&stderr_pipe, G_UNIX_PIPE_END_WRITE);\n@@ -2513,1 +2105,1 @@\n-  if (!g_unix_open_pipe (child_err_report_pipe, pipe_flags, error))\n+  if (!g_unix_pipe_open (&child_err_report_pipe, pipe_flags, error))\n@@ -2515,2 +2107,1 @@\n-  if (_g_spawn_invalid_source_fd (child_err_report_pipe[0], source_fds, n_fds, error) ||\n-      _g_spawn_invalid_source_fd (child_err_report_pipe[1], source_fds, n_fds, error))\n+  if (source_fds_collide_with_pipe (&child_err_report_pipe, source_fds, n_fds, error))\n@@ -2521,1 +2112,1 @@\n-      if (!g_unix_open_pipe (child_pid_report_pipe, pipe_flags, error))\n+      if (!g_unix_pipe_open (&child_pid_report_pipe, pipe_flags, error))\n@@ -2523,2 +2114,1 @@\n-      if (_g_spawn_invalid_source_fd (child_pid_report_pipe[0], source_fds, n_fds, error) ||\n-          _g_spawn_invalid_source_fd (child_pid_report_pipe[1], source_fds, n_fds, error))\n+      if (source_fds_collide_with_pipe (&child_pid_report_pipe, source_fds, n_fds, error))\n@@ -2563,2 +2153,2 @@\n-      close_and_invalidate (&child_err_report_pipe[0]);\n-      close_and_invalidate (&child_pid_report_pipe[0]);\n+      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n+      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n@@ -2569,1 +2159,1 @@\n-             close_and_invalidate (&child_close_fds[i]);\n+             g_clear_fd (&child_close_fds[i], NULL);\n@@ -2586,2 +2176,2 @@\n-              write_all (child_pid_report_pipe[1], &grandchild_pid,\n-                         sizeof(grandchild_pid));\n+              write_all (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE),\n+                         &grandchild_pid, sizeof(grandchild_pid));\n@@ -2589,1 +2179,1 @@\n-              write_err_and_exit (child_err_report_pipe[1],\n+              write_err_and_exit (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n@@ -2594,2 +2184,2 @@\n-              close_and_invalidate (&child_pid_report_pipe[1]);\n-              do_exec (child_err_report_pipe[1],\n+              g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+              do_exec (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n@@ -2620,2 +2210,3 @@\n-              write_all (child_pid_report_pipe[1], &grandchild_pid, sizeof(grandchild_pid));\n-              close_and_invalidate (&child_pid_report_pipe[1]);\n+              write_all (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE),\n+                         &grandchild_pid, sizeof(grandchild_pid));\n+              g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n@@ -2631,1 +2222,1 @@\n-          do_exec (child_err_report_pipe[1],\n+          do_exec (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n@@ -2663,2 +2254,2 @@\n-      close_and_invalidate (&child_err_report_pipe[1]);\n-      close_and_invalidate (&child_pid_report_pipe[1]);\n+      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n@@ -2682,1 +2273,1 @@\n-      if (!read_ints (child_err_report_pipe[0],\n+      if (!read_ints (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_READ),\n@@ -2763,1 +2354,1 @@\n-          if (!read_ints (child_pid_report_pipe[0],\n+          if (!read_ints (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_READ),\n@@ -2786,2 +2377,2 @@\n-      close_and_invalidate (&child_err_report_pipe[0]);\n-      close_and_invalidate (&child_pid_report_pipe[0]);\n+      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n+      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n@@ -2801,3 +2392,3 @@\n-  close_and_invalidate (&stdin_pipe[0]);\n-  close_and_invalidate (&stdout_pipe[1]);\n-  close_and_invalidate (&stderr_pipe[1]);\n+  g_unix_pipe_close (&stdin_pipe, G_UNIX_PIPE_END_READ, NULL);\n+  g_unix_pipe_close (&stdout_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+  g_unix_pipe_close (&stderr_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n@@ -2806,1 +2397,1 @@\n-    *stdin_pipe_out = g_steal_fd (&stdin_pipe[1]);\n+    *stdin_pipe_out = g_unix_pipe_steal (&stdin_pipe, G_UNIX_PIPE_END_WRITE);\n@@ -2809,1 +2400,1 @@\n-    *stdout_pipe_out = g_steal_fd (&stdout_pipe[0]);\n+    *stdout_pipe_out = g_unix_pipe_steal (&stdout_pipe, G_UNIX_PIPE_END_READ);\n@@ -2812,1 +2403,1 @@\n-    *stderr_pipe_out = g_steal_fd (&stderr_pipe[0]);\n+    *stderr_pipe_out = g_unix_pipe_steal (&stderr_pipe, G_UNIX_PIPE_END_READ);\n@@ -2836,11 +2427,5 @@\n-  close_and_invalidate (&stdin_pipe[0]);\n-  close_and_invalidate (&stdin_pipe[1]);\n-  close_and_invalidate (&stdout_pipe[0]);\n-  close_and_invalidate (&stdout_pipe[1]);\n-  close_and_invalidate (&stderr_pipe[0]);\n-  close_and_invalidate (&stderr_pipe[1]);\n-\n-  close_and_invalidate (&child_err_report_pipe[0]);\n-  close_and_invalidate (&child_err_report_pipe[1]);\n-  close_and_invalidate (&child_pid_report_pipe[0]);\n-  close_and_invalidate (&child_pid_report_pipe[1]);\n+  g_unix_pipe_clear (&stdin_pipe);\n+  g_unix_pipe_clear (&stdout_pipe);\n+  g_unix_pipe_clear (&stderr_pipe);\n+  g_unix_pipe_clear (&child_err_report_pipe);\n+  g_unix_pipe_clear (&child_pid_report_pipe);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gspawn.c","additions":84,"deletions":499,"binary":false,"changes":583,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#if defined(G_OS_UNIX) && !defined(G_STDIO_WRAP_ON_UNIX)\n+#if defined(G_OS_UNIX) && !defined(G_STDIO_WRAP_ON_UNIX) && !defined(__GI_SCANNER__)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstdio.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,39 +60,0 @@\n-\n-\/**\n- * SECTION:string_utils\n- * @title: String Utility Functions\n- * @short_description: various string-related functions\n- *\n- * This section describes a number of utility functions for creating,\n- * duplicating, and manipulating strings.\n- *\n- * Note that the functions g_printf(), g_fprintf(), g_sprintf(),\n- * g_vprintf(), g_vfprintf(), g_vsprintf() and g_vasprintf()\n- * are declared in the header `gprintf.h` which is not included in `glib.h`\n- * (otherwise using `glib.h` would drag in `stdio.h`), so you'll have to\n- * explicitly include `<glib\/gprintf.h>` in order to use the GLib\n- * printf() functions.\n- *\n- * ## String precision pitfalls # {#string-precision}\n- *\n- * While you may use the printf() functions to format UTF-8 strings,\n- * notice that the precision of a \\%Ns parameter is interpreted\n- * as the number of bytes, not characters to print. On top of that,\n- * the GNU libc implementation of the printf() functions has the\n- * \"feature\" that it checks that the string given for the \\%Ns\n- * parameter consists of a whole number of characters in the current\n- * encoding. So, unless you are sure you are always going to be in an\n- * UTF-8 locale or your know your text is restricted to ASCII, avoid\n- * using \\%Ns. If your intention is to format strings for a\n- * certain number of columns, then \\%Ns is not a correct solution\n- * anyway, since it fails to take wide characters (see g_unichar_iswide())\n- * into account.\n- *\n- * Note also that there are various printf() parameters which are platform\n- * dependent. GLib provides platform independent macros for these parameters\n- * which should be used instead. A common example is %G_GUINT64_FORMAT, which\n- * should be used instead of `%llu` or similar parameters for formatting\n- * 64-bit integers. These macros are all named `G_*_FORMAT`; see\n- * [Basic Types][glib-Basic-Types].\n- *\/\n-\n@@ -105,1 +66,1 @@\n- * Unlike the standard C library isalnum() function, this only\n+ * Unlike the standard C library `isalnum()` function, this only\n@@ -107,3 +68,3 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to cast to #guchar before\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to cast to `guchar` before\n@@ -112,1 +73,1 @@\n- * Returns: %TRUE if @c is an ASCII alphanumeric character\n+ * Returns: true if @c is an ASCII alphanumeric character\n@@ -121,1 +82,1 @@\n- * Unlike the standard C library isalpha() function, this only\n+ * Unlike the standard C library `isalpha()` function, this only\n@@ -123,3 +84,3 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to cast to #guchar before\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to cast to `guchar` before\n@@ -128,1 +89,1 @@\n- * Returns: %TRUE if @c is an ASCII alphabetic character\n+ * Returns: true if @c is an ASCII alphabetic character\n@@ -137,1 +98,1 @@\n- * Unlike the standard C library iscntrl() function, this only\n+ * Unlike the standard C library `iscntrl()` function, this only\n@@ -139,3 +100,3 @@\n- * locale, returning %FALSE for all non-ASCII characters. Also,\n- * unlike the standard library function, this takes a char, not\n- * an int, so don't call it on %EOF, but no need to cast to #guchar\n+ * locale, returning false for all non-ASCII characters. Also,\n+ * unlike the standard library function, this takes a `char`, not\n+ * an `int`, so don't call it on `EOF`, but no need to cast to `guchar`\n@@ -144,1 +105,1 @@\n- * Returns: %TRUE if @c is an ASCII control character.\n+ * Returns: true if @c is an ASCII control character\n@@ -153,3 +114,3 @@\n- * Unlike the standard C library isdigit() function, this takes\n- * a char, not an int, so don't call it  on %EOF, but no need to\n- * cast to #guchar before passing a possibly non-ASCII character in.\n+ * Unlike the standard C library `isdigit()` function, this takes\n+ * a `char`, not an `int`, so don't call it  on `EOF`, but no need to\n+ * cast to `guchar` before passing a possibly non-ASCII character in.\n@@ -157,1 +118,1 @@\n- * Returns: %TRUE if @c is an ASCII digit.\n+ * Returns: true if @c is an ASCII digit\n@@ -166,1 +127,1 @@\n- * Unlike the standard C library isgraph() function, this only\n+ * Unlike the standard C library `isgraph()` function, this only\n@@ -168,3 +129,3 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to cast to #guchar before\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to cast to `guchar` before\n@@ -173,1 +134,1 @@\n- * Returns: %TRUE if @c is an ASCII printing character other than space.\n+ * Returns: true if @c is an ASCII printing character other than space\n@@ -182,1 +143,1 @@\n- * Unlike the standard C library islower() function, this only\n+ * Unlike the standard C library `islower()` function, this only\n@@ -184,4 +145,4 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to worry about casting\n- * to #guchar before passing a possibly non-ASCII character in.\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to worry about casting\n+ * to `guchar` before passing a possibly non-ASCII character in.\n@@ -189,1 +150,1 @@\n- * Returns: %TRUE if @c is an ASCII lower case letter\n+ * Returns: true if @c is an ASCII lower case letter\n@@ -198,1 +159,1 @@\n- * Unlike the standard C library isprint() function, this only\n+ * Unlike the standard C library `isprint()` function, this only\n@@ -200,3 +161,3 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to cast to #guchar before\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to cast to `guchar` before\n@@ -205,1 +166,1 @@\n- * Returns: %TRUE if @c is an ASCII printing character.\n+ * Returns: true if @c is an ASCII printing character\n@@ -214,1 +175,1 @@\n- * Unlike the standard C library ispunct() function, this only\n+ * Unlike the standard C library `ispunct()` function, this only\n@@ -216,3 +177,3 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to cast to #guchar before\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to cast to `guchar` before\n@@ -221,1 +182,1 @@\n- * Returns: %TRUE if @c is an ASCII punctuation character.\n+ * Returns: true if @c is an ASCII punctuation character\n@@ -230,1 +191,1 @@\n- * Unlike the standard C library isspace() function, this only\n+ * Unlike the standard C library `isspace()` function, this only\n@@ -232,3 +193,3 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to cast to #guchar before\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to cast to `guchar` before\n@@ -237,1 +198,1 @@\n- * Returns: %TRUE if @c is an ASCII white-space character\n+ * Returns: true if @c is an ASCII white-space character\n@@ -246,1 +207,1 @@\n- * Unlike the standard C library isupper() function, this only\n+ * Unlike the standard C library `isupper()` function, this only\n@@ -248,4 +209,4 @@\n- * returning %FALSE for all non-ASCII characters. Also, unlike\n- * the standard library function, this takes a char, not an int,\n- * so don't call it on %EOF, but no need to worry about casting\n- * to #guchar before passing a possibly non-ASCII character in.\n+ * returning false for all non-ASCII characters. Also, unlike\n+ * the standard library function, this takes a `char`, not an `int`,\n+ * so don't call it on `EOF`, but no need to worry about casting\n+ * to `guchar` before passing a possibly non-ASCII character in.\n@@ -253,1 +214,1 @@\n- * Returns: %TRUE if @c is an ASCII upper case letter\n+ * Returns: true if @c is an ASCII upper case letter\n@@ -262,3 +223,3 @@\n- * Unlike the standard C library isxdigit() function, this takes\n- * a char, not an int, so don't call it on %EOF, but no need to\n- * cast to #guchar before passing a possibly non-ASCII character in.\n+ * Unlike the standard C library `isxdigit()` function, this takes\n+ * a `char`, not an `int`, so don't call it on `EOF`, but no need to\n+ * cast to `guchar` before passing a possibly non-ASCII character in.\n@@ -266,1 +227,1 @@\n- * Returns: %TRUE if @c is an ASCII hexadecimal-digit character.\n+ * Returns: true if @c is an ASCII hexadecimal-digit character\n@@ -272,1 +233,1 @@\n- * A good size for a buffer to be passed into g_ascii_dtostr().\n+ * A good size for a buffer to be passed into [func@GLib.ascii_dtostr].\n@@ -277,2 +238,2 @@\n- * |[<!-- language=\"C\" -->\n- *   char buf[G_ASCII_DTOSTR_BUF_SIZE];\n+ * ```C\n+ * char buf[G_ASCII_DTOSTR_BUF_SIZE];\n@@ -280,2 +241,2 @@\n- *   fprintf (out, \"value=%s\\n\", g_ascii_dtostr (buf, sizeof (buf), value));\n- * ]|\n+ * fprintf (out, \"value=%s\\n\", g_ascii_dtostr (buf, sizeof (buf), value));\n+ * ```\n@@ -289,1 +250,2 @@\n- * See g_strchomp() and g_strchug().\n+ *\n+ * See [func@GLib.strchomp] and [func@GLib.strchug].\n@@ -297,1 +259,1 @@\n- * The standard delimiters, used in g_strdelimit().\n+ * The standard delimiters, used in [func@GLib.strdelimit].\n@@ -348,3 +310,1 @@\n- * Duplicates a string. If @str is %NULL it returns %NULL.\n- * The returned string should be freed with g_free()\n- * when no longer needed.\n+ * Duplicates a string. If @str is `NULL` it returns `NULL`.\n@@ -374,2 +334,2 @@\n- * @mem: the memory to copy.\n- * @byte_size: the number of bytes to copy.\n+ * @mem: the memory to copy\n+ * @byte_size: the number of bytes to copy\n@@ -378,1 +338,1 @@\n- * from @mem. If @mem is %NULL it returns %NULL.\n+ * from @mem. If @mem is `NULL` it returns `NULL`.\n@@ -380,5 +340,5 @@\n- * Returns: a pointer to the newly-allocated copy of the memory, or %NULL if @mem\n- *  is %NULL.\n- * Deprecated: 2.68: Use g_memdup2() instead, as it accepts a #gsize argument\n- *     for @byte_size, avoiding the possibility of overflow in a #gsize → #guint\n- *     conversion\n+ * Returns: (transfer full) (nullable): a pointer to the newly-allocated copy of the memory\n+ *\n+ * Deprecated: 2.68: Use [func@GLib.memdup2] instead, as it accepts a gsize argument\n+ *   for @byte_size, avoiding the possibility of overflow in a `gsize` → `guint`\n+ *   conversion\n@@ -405,2 +365,2 @@\n- * @mem: (nullable): the memory to copy.\n- * @byte_size: the number of bytes to copy.\n+ * @mem: (nullable): the memory to copy\n+ * @byte_size: the number of bytes to copy\n@@ -409,1 +369,4 @@\n- * from @mem. If @mem is %NULL it returns %NULL.\n+ * from @mem. If @mem is `NULL` it returns `NULL`.\n+ *\n+ * This replaces [func@GLib.memdup], which was prone to integer overflows when\n+ * converting the argument from a `gsize` to a `guint`.\n@@ -411,2 +374,1 @@\n- * This replaces g_memdup(), which was prone to integer overflows when\n- * converting the argument from a #gsize to a #guint.\n+ * Returns: (transfer full) (nullable): a pointer to the newly-allocated copy of the memory\n@@ -414,2 +376,0 @@\n- * Returns: (nullable): a pointer to the newly-allocated copy of the memory,\n- *    or %NULL if @mem is %NULL.\n@@ -437,1 +397,1 @@\n- * @str: the string to duplicate\n+ * @str: (nullable): the string to duplicate\n@@ -443,2 +403,1 @@\n- * %NULL it returns %NULL. The returned value should be freed when no longer\n- * needed.\n+ * `NULL` it returns `NULL`.\n@@ -447,1 +406,1 @@\n- * use g_utf8_strncpy() instead.\n+ * use [func@GLib.utf8_strncpy] instead.\n@@ -449,2 +408,2 @@\n- * Returns: a newly-allocated buffer containing the first @n bytes\n- *     of @str, nul-terminated\n+ * Returns: (nullable): a newly-allocated buffer containing the first\n+ *    @n bytes of @str\n@@ -476,1 +435,0 @@\n- * The returned string should be freed when no longer needed.\n@@ -478,1 +436,1 @@\n- * Returns: a newly-allocated string filled the @fill_char\n+ * Returns: a newly-allocated string filled with @fill_char\n@@ -495,2 +453,2 @@\n- * @dest: destination buffer.\n- * @src: source string.\n+ * @dest: destination buffer\n+ * @src: source string\n@@ -503,1 +461,1 @@\n- * Returns: a pointer to the trailing nul byte in `dest`.\n+ * Returns: a pointer to the trailing nul byte in `dest`\n@@ -529,2 +487,2 @@\n- * @format: (not nullable): a standard printf() format string, but notice\n- *     [string precision pitfalls][string-precision]\n+ * @format: (not nullable): a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n@@ -533,1 +491,1 @@\n- * Similar to the standard C vsprintf() function but safer, since it\n+ * Similar to the standard C `vsprintf()` function but safer, since it\n@@ -535,2 +493,1 @@\n- * the result. The returned string should be freed with g_free() when\n- * no longer needed.\n+ * the result.\n@@ -542,1 +499,1 @@\n- * See also g_vasprintf(), which offers the same functionality, but\n+ * See also [func@GLib.vasprintf], which offers the same functionality, but\n@@ -545,1 +502,2 @@\n- * Returns: a newly-allocated string holding the result\n+ * Returns: (nullable) (transfer full): a newly-allocated string holding the\n+ *   result\n@@ -560,2 +518,2 @@\n- * @format: (not nullable): a standard printf() format string, but notice\n- *     [string precision pitfalls][string-precision]\n+ * @format: (not nullable): a standard `printf()` format string, but notice\n+ *   [string precision pitfalls](string-utils.html#string-precision-pitfalls)\n@@ -564,1 +522,1 @@\n- * Similar to the standard C sprintf() function but safer, since it\n+ * Similar to the standard C `sprintf()` function but safer, since it\n@@ -566,2 +524,1 @@\n- * the result. The returned string should be freed with g_free() when no\n- * longer needed.\n+ * the result.\n@@ -573,1 +530,2 @@\n- * Returns: a newly-allocated string holding the result\n+ * Returns: (nullable) (transfer full): a newly-allocated string holding the\n+ *   result\n@@ -591,2 +549,2 @@\n- * @string1: the first string to add, which must not be %NULL\n- * @...: a %NULL-terminated list of strings to append to the string\n+ * @string1: the first string to add, which must not be `NULL`\n+ * @...: a `NULL`-terminated list of strings to append to the string\n@@ -594,2 +552,1 @@\n- * Concatenates all of the given strings into one long string. The\n- * returned string should be freed with g_free() when no longer needed.\n+ * Concatenates all of the given strings into one long string.\n@@ -597,2 +554,2 @@\n- * The variable argument list must end with %NULL. If you forget the %NULL,\n- * g_strconcat() will start appending random memory junk to your string.\n+ * The variable argument list must end with `NULL`. If you forget the `NULL`,\n+ * `g_strconcat()` will start appending random memory junk to your string.\n@@ -646,3 +603,5 @@\n- * @nptr:    the string to convert to a numeric value.\n- * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the\n- *           character after the last character used in the conversion.\n+ * @nptr: the string to convert to a numeric value\n+ * @endptr: (out) (transfer none) (optional): if non-`NULL`, it returns the\n+ *   character after the last character used in the conversion\n+ *\n+ * Converts a string to a floating point value.\n@@ -650,2 +609,1 @@\n- * Converts a string to a #gdouble value.\n- * It calls the standard strtod() function to handle the conversion, but\n+ * It calls the standard `strtod()` function to handle the conversion, but\n@@ -653,1 +611,1 @@\n- * again with g_ascii_strtod(), and returns the best match.\n+ * again with [func@GLib.ascii_strtod], and returns the best match.\n@@ -656,1 +614,1 @@\n- * numbers not for human consumption is to use g_ascii_strtod(). Only when\n+ * numbers not for human consumption is to use [func@GLib.ascii_strtod]. Only when\n@@ -662,1 +620,1 @@\n- * Returns: the #gdouble value.\n+ * Returns: the converted value\n@@ -699,3 +657,3 @@\n- * @nptr:    the string to convert to a numeric value.\n- * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the\n- *           character after the last character used in the conversion.\n+ * @nptr: the string to convert to a numeric value\n+ * @endptr: (out) (transfer none) (optional): if non-`NULL`, it returns the\n+ *   character after the last character used in the conversion\n@@ -703,1 +661,1 @@\n- * Converts a string to a #gdouble value.\n+ * Converts a string to a floating point value.\n@@ -705,1 +663,1 @@\n- * This function behaves like the standard strtod() function\n+ * This function behaves like the standard `strtod()` function\n@@ -714,1 +672,1 @@\n- * locale-sensitive system strtod() function.\n+ * locale-sensitive system `strtod()` function.\n@@ -716,2 +674,2 @@\n- * To convert from a #gdouble to a string in a locale-insensitive\n- * way, use g_ascii_dtostr().\n+ * To convert from a gdouble to a string in a locale-insensitive\n+ * way, use [func@GLib.ascii_dtostr].\n@@ -719,4 +677,4 @@\n- * If the correct value would cause overflow, plus or minus %HUGE_VAL\n- * is returned (according to the sign of the value), and %ERANGE is\n- * stored in %errno. If the correct value would cause underflow,\n- * zero is returned and %ERANGE is stored in %errno.\n+ * If the correct value would cause overflow, plus or minus `HUGE_VAL`\n+ * is returned (according to the sign of the value), and `ERANGE` is\n+ * stored in `errno`. If the correct value would cause underflow,\n+ * zero is returned and `ERANGE` is stored in `errno`.\n@@ -724,1 +682,1 @@\n- * This function resets %errno before calling strtod() so that\n+ * This function resets `errno` before calling `strtod()` so that\n@@ -727,1 +685,1 @@\n- * Returns: the #gdouble value.\n+ * Returns: the converted value\n@@ -908,3 +866,3 @@\n- * @buffer: A buffer to place the resulting string in\n- * @buf_len: The length of the buffer.\n- * @d: The #gdouble to convert\n+ * @buffer: a buffer to place the resulting string in\n+ * @buf_len: the length of the buffer\n+ * @d: the value to convert\n@@ -912,1 +870,1 @@\n- * Converts a #gdouble to a string, using the '.' as\n+ * Converts a `gdouble` to a string, using the '.' as\n@@ -916,1 +874,1 @@\n- * the string back using g_ascii_strtod() gives the same machine-number\n+ * the string back using [func@GLib.ascii_strtod] gives the same machine-number\n@@ -919,1 +877,1 @@\n- * be larger than %G_ASCII_DTOSTR_BUF_SIZE bytes, including the terminating\n+ * be larger than [const@GLib.ASCII_DTOSTR_BUF_SIZE] bytes, including the terminating\n@@ -922,1 +880,1 @@\n- * Returns: The pointer to the buffer with the converted string.\n+ * Returns: the pointer to the buffer with the converted string\n@@ -944,3 +902,3 @@\n- * @buffer: A buffer to place the resulting string in\n- * @buf_len: The length of the buffer.\n- * @format: The printf()-style format to use for the\n+ * @buffer: a buffer to place the resulting string in\n+ * @buf_len: the length of the buffer\n+ * @format: the `printf()`-style format to use for the\n@@ -948,1 +906,1 @@\n- * @d: The #gdouble to convert\n+ * @d: the value to convert\n@@ -950,1 +908,1 @@\n- * Converts a #gdouble to a string, using the '.' as\n+ * Converts a `gdouble` to a string, using the '.' as\n@@ -952,1 +910,1 @@\n- * a printf()-style format string. Allowed conversion\n+ * a `printf()`-style format string. Allowed conversion\n@@ -956,1 +914,1 @@\n- * starting with `%`, expecting a #gdouble argument.\n+ * starting with `%`, expecting a `gdouble` argument.\n@@ -961,1 +919,1 @@\n- * string, use g_ascii_dtostr().\n+ * string, use [func@GLib.ascii_dtostr].\n@@ -963,1 +921,1 @@\n- * Returns: The pointer to the buffer with the converted string.\n+ * Returns: the pointer to the buffer with the converted string\n@@ -1204,4 +1162,4 @@\n- * @nptr:    the string to convert to a numeric value.\n- * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the\n- *           character after the last character used in the conversion.\n- * @base:    to be used for the conversion, 2..36 or 0\n+ * @nptr: the string to convert to a numeric value\n+ * @endptr: (out) (transfer none) (optional): if non-`NULL`, it returns the\n+ *   character after the last character used in the conversion\n+ * @base: to be used for the conversion, 2..36 or 0\n@@ -1209,2 +1167,3 @@\n- * Converts a string to a #guint64 value.\n- * This function behaves like the standard strtoull() function\n+ * Converts a string to a `guint64` value.\n+ *\n+ * This function behaves like the standard `strtoull()` function\n@@ -1216,1 +1175,1 @@\n- * the negation of the parsed number, unless that would overflow a #guint64.\n+ * the negation of the parsed number, unless that would overflow a `guint64`.\n@@ -1218,1 +1177,1 @@\n- * never result in a low return value, as the input could have a leading `-`.\n+ * result in a low return value, as the input could have a leading `-`.\n@@ -1223,1 +1182,1 @@\n- * locale-sensitive system strtoull() function.\n+ * locale-sensitive system `strtoull()` function.\n@@ -1225,1 +1184,1 @@\n- * If the correct value would cause overflow, %G_MAXUINT64\n+ * If the correct value would cause overflow, [const@GLib.MAXUINT64]\n@@ -1230,1 +1189,1 @@\n- * @nptr (if @endptr is non-%NULL).\n+ * @nptr (if @endptr is non-`NULL`).\n@@ -1232,1 +1191,1 @@\n- * Returns: the #guint64 value or zero on error.\n+ * Returns: the converted value, or zero on error\n@@ -1256,4 +1215,6 @@\n- * @nptr:    the string to convert to a numeric value.\n- * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the\n- *           character after the last character used in the conversion.\n- * @base:    to be used for the conversion, 2..36 or 0\n+ * @nptr: the string to convert to a numeric value\n+ * @endptr: (out) (transfer none) (optional): if non-`NULL`, it returns the\n+ *   character after the last character used in the conversion\n+ * @base: to be used for the conversion, 2..36 or 0\n+ *\n+ * Converts a string to a `gint64` value.\n@@ -1261,2 +1222,1 @@\n- * Converts a string to a #gint64 value.\n- * This function behaves like the standard strtoll() function\n+ * This function behaves like the standard `strtoll()` function\n@@ -1270,1 +1230,1 @@\n- * locale-sensitive system strtoll() function.\n+ * locale-sensitive system `strtoll()` function.\n@@ -1272,2 +1232,2 @@\n- * If the correct value would cause overflow, %G_MAXINT64 or %G_MININT64\n- * is returned, and `ERANGE` is stored in `errno`.\n+ * If the correct value would cause overflow, [const@GLib.MAXINT64] or\n+ * [const@GLib.MININT64] is returned, and `ERANGE` is stored in `errno`.\n@@ -1277,1 +1237,1 @@\n- * (if @endptr is non-%NULL).\n+ * (if @endptr is non-`NULL`).\n@@ -1279,1 +1239,1 @@\n- * Returns: the #gint64 value or zero on error.\n+ * Returns: the converted value, or zero on error\n@@ -1315,2 +1275,1 @@\n- * @errnum: the system error number. See the standard C %errno\n- *     documentation\n+ * @errnum: the system error number. See the standard C `errno` documentation\n@@ -1319,1 +1278,3 @@\n- * such process\". Unlike strerror(), this always returns a string in\n+ * such process\".\n+ *\n+ * Unlike `strerror()`, this always returns a string in\n@@ -1321,1 +1282,2 @@\n- * the lifetime of the process.\n+ * the lifetime of the process. If the error code is unknown, it returns a\n+ * string like “Unknown error <code\\>”.\n@@ -1325,1 +1287,1 @@\n- * The value of %errno will not be changed by this function. However, it may\n+ * The value of `errno` will not be changed by this function. However, it may\n@@ -1328,2 +1290,2 @@\n- * |[\n- *   int saved_errno;\n+ * ```C\n+ * int saved_errno;\n@@ -1331,2 +1293,2 @@\n- *   ret = read (blah);\n- *   saved_errno = errno;\n+ * ret = read (blah);\n+ * saved_errno = errno;\n@@ -1334,2 +1296,2 @@\n- *   g_strerror (saved_errno);\n- * ]|\n+ * g_strerror (saved_errno);\n+ * ```\n@@ -1337,2 +1299,1 @@\n- * Returns: a UTF-8 string describing the error code. If the error code\n- *     is unknown, it returns a string like \"Unknown error: <code>\".\n+ * Returns: the string describing the error code\n@@ -1415,1 +1376,3 @@\n- * You should use this function in preference to strsignal(), because it\n+ * If the signal is unknown, it returns “unknown signal (<signum\\>)”.\n+ *\n+ * You should use this function in preference to `strsignal()`, because it\n@@ -1417,1 +1380,1 @@\n- * the strsignal() function.\n+ * the `strsignal()` function.\n@@ -1419,2 +1382,1 @@\n- * Returns: a UTF-8 string describing the signal. If the signal is unknown,\n- *     it returns \"unknown signal (<signum>)\".\n+ * Returns: the string describing the signal\n@@ -1482,2 +1444,2 @@\n- * Portability wrapper that calls strlcpy() on systems which have it,\n- * and emulates strlcpy() otherwise. Copies @src to @dest; @dest is\n+ * Portability wrapper that calls `strlcpy()` on systems which have it,\n+ * and emulates `strlcpy()` otherwise. Copies @src to @dest; @dest is\n@@ -1489,2 +1451,2 @@\n- * strncpy(), this function doesn't pad @dest (so it's often faster). It\n- * returns the size of the attempted result, strlen (src), so if\n+ * `strncpy()`, this function doesn't pad @dest (so it's often faster). It\n+ * returns the size of the attempted result, `strlen (src)`, so if\n@@ -1493,2 +1455,2 @@\n- * Caveat: strlcpy() is supposedly more secure than strcpy() or strncpy(),\n- * but if you really want to avoid screwups, g_strdup() is an even better\n+ * Caveat: `strlcpy()` is supposedly more secure than `strcpy()` or `strncpy()`,\n+ * but if you really want to avoid screwups, [func@GLib.strdup] is an even better\n@@ -1540,1 +1502,1 @@\n- *     inside @dest)\n+ *   inside @dest)\n@@ -1542,1 +1504,1 @@\n- * Portability wrapper that calls strlcat() on systems which have it,\n+ * Portability wrapper that calls `strlcat()` on systems which have it,\n@@ -1547,1 +1509,1 @@\n- * At most @dest_size - 1 characters will be copied. Unlike strncat(),\n+ * At most @dest_size - 1 characters will be copied. Unlike `strncat()`,\n@@ -1553,2 +1515,2 @@\n- * Caveat: this is supposedly a more secure alternative to strcat() or\n- * strncat(), but for real security g_strconcat() is harder to mess up.\n+ * Caveat: this is supposedly a more secure alternative to `strcat()` or\n+ * `strncat()`, but for real security [func@GLib.strconcat] is harder to mess up.\n@@ -1556,3 +1518,3 @@\n- * Returns: size of attempted result, which is MIN (dest_size, strlen\n- *     (original dest)) + strlen (src), so if retval >= dest_size,\n- *     truncation occurred.\n+ * Returns: size of attempted result, which is `MIN (dest_size, strlen\n+ *   (original dest)) + strlen (src)`, so if @retval >= @dest_size,\n+ *   truncation occurred\n@@ -1600,1 +1562,1 @@\n- * @len: length of @str in bytes, or -1 if @str is nul-terminated\n+ * @len: length of @str in bytes, or `-1` if @str is nul-terminated\n@@ -1602,1 +1564,2 @@\n- * Converts all upper case ASCII letters to lower case ASCII letters.\n+ * Converts all upper case ASCII letters to lower case ASCII letters, with\n+ * semantics that exactly match [func@GLib.ascii_tolower].\n@@ -1604,4 +1567,3 @@\n- * Returns: a newly-allocated string, with all the upper case\n- *     characters in @str converted to lower case, with semantics that\n- *     exactly match g_ascii_tolower(). (Note that this is unlike the\n- *     old g_strdown(), which modified the string in place.)\n+ * Returns: a newly-allocated string, with all the upper case characters in\n+ *   @str converted to lower case. (Note that this is unlike the old\n+ *   [func@GLib.strdown], which modified the string in place.)\n@@ -1618,1 +1580,3 @@\n-    len = (gssize) strlen (str);\n+    result = g_strdup (str);\n+  else\n+    result = g_strndup (str, (gsize) len);\n@@ -1620,1 +1584,0 @@\n-  result = g_strndup (str, (gsize) len);\n@@ -1630,1 +1593,1 @@\n- * @len: length of @str in bytes, or -1 if @str is nul-terminated\n+ * @len: length of @str in bytes, or `-1` if @str is nul-terminated\n@@ -1632,1 +1595,2 @@\n- * Converts all lower case ASCII letters to upper case ASCII letters.\n+ * Converts all lower case ASCII letters to upper case ASCII letters, with\n+ * semantics that exactly match [func@GLib.ascii_toupper].\n@@ -1634,4 +1598,3 @@\n- * Returns: a newly allocated string, with all the lower case\n- *     characters in @str converted to upper case, with semantics that\n- *     exactly match g_ascii_toupper(). (Note that this is unlike the\n- *     old g_strup(), which modified the string in place.)\n+ * Returns: a newly-allocated string, with all the lower case characters\n+ *   in @str converted to upper case. (Note that this is unlike the old\n+ *   [func@GLib.strup], which modified the string in place.)\n@@ -1648,1 +1611,3 @@\n-    len = (gssize) strlen (str);\n+    result = g_strdup (str);\n+  else\n+    result = g_strndup (str, (gsize) len);\n@@ -1650,1 +1615,0 @@\n-  result = g_strndup (str, (gsize) len);\n@@ -1664,1 +1628,1 @@\n- * Returns: %TRUE if @str is ASCII\n+ * Returns: true if @str is ASCII\n@@ -1682,1 +1646,1 @@\n- * @string: the string to convert.\n+ * @string: the string to convert\n@@ -1688,3 +1652,3 @@\n- * Deprecated:2.2: This function is totally broken for the reasons discussed\n- * in the g_strncasecmp() docs - use g_ascii_strdown() or g_utf8_strdown()\n- * instead.\n+ * Deprecated: 2.2: This function is totally broken for the reasons discussed\n+ *   in the [func@GLib.strncasecmp] docs — use [func@GLib.ascii_strdown] or\n+ *   [func@GLib.utf8_strdown] instead.\n@@ -1719,3 +1683,3 @@\n- * Deprecated:2.2: This function is totally broken for the reasons\n- *     discussed in the g_strncasecmp() docs - use g_ascii_strup()\n- *     or g_utf8_strup() instead.\n+ * Deprecated: 2.2: This function is totally broken for the reasons discussed\n+ *   in the [func@GLib.strncasecmp] docs — use [func@GLib.ascii_strup] or\n+ *   [func@GLib.utf8_strup] instead.\n@@ -1749,1 +1713,1 @@\n- * Note that g_strreverse() doesn't work on UTF-8 strings\n+ * Note that `g_strreverse()` doesn't work on UTF-8 strings\n@@ -1751,1 +1715,1 @@\n- * g_utf8_strreverse().\n+ * [func@GLib.utf8_strreverse].\n@@ -1753,1 +1717,1 @@\n- * Returns: the same pointer passed in as @string\n+ * Returns: the @string, reversed in place\n@@ -1786,1 +1750,2 @@\n- * Convert a character to ASCII lower case.\n+ * Convert a character to ASCII lower case. If the character is not an\n+ * ASCII upper case letter, it is returned unchanged.\n@@ -1788,1 +1753,1 @@\n- * Unlike the standard C library tolower() function, this only\n+ * Unlike the standard C library `tolower()` function, this only\n@@ -1793,1 +1758,1 @@\n- * don't call it on %EOF but no need to worry about casting to #guchar\n+ * don't call it on `EOF` but no need to worry about casting to `guchar`\n@@ -1796,2 +1761,1 @@\n- * Returns: the result of converting @c to lower case. If @c is\n- *     not an ASCII upper case letter, @c is returned unchanged.\n+ * Returns: the result of the conversion\n@@ -1809,1 +1773,2 @@\n- * Convert a character to ASCII upper case.\n+ * Convert a character to ASCII upper case. If the character is not an\n+ * ASCII lower case letter, it is returned unchanged.\n@@ -1811,1 +1776,1 @@\n- * Unlike the standard C library toupper() function, this only\n+ * Unlike the standard C library `toupper()` function, this only\n@@ -1816,1 +1781,1 @@\n- * don't call it on %EOF but no need to worry about casting to #guchar\n+ * don't call it on `EOF` but no need to worry about casting to `guchar`\n@@ -1819,2 +1784,1 @@\n- * Returns: the result of converting @c to upper case. If @c is not\n- *    an ASCII lower case letter, @c is returned unchanged.\n+ * Returns: the result of the conversion\n@@ -1832,2 +1796,5 @@\n- * Determines the numeric value of a character as a decimal digit.\n- * Differs from g_unichar_digit_value() because it takes a char, so\n+ * Determines the numeric value of a character as a decimal digit. If the\n+ * character is not a decimal digit according to [func@GLib.ascii_isdigit],\n+ * `-1` is returned.\n+ *\n+ * Differs from [func@GLib.unichar_digit_value] because it takes a char, so\n@@ -1836,2 +1803,1 @@\n- * Returns: If @c is a decimal digit (according to g_ascii_isdigit()),\n- *    its numeric value. Otherwise, -1.\n+ * Returns: the numerical value of @c if it is a decimal digit, `-1` otherwise\n@@ -1849,1 +1815,1 @@\n- * @c: an ASCII character.\n+ * @c: an ASCII character\n@@ -1851,4 +1817,3 @@\n- * Determines the numeric value of a character as a hexadecimal\n- * digit. Differs from g_unichar_xdigit_value() because it takes\n- * a char, so there's no worry about sign extension if characters\n- * are signed.\n+ * Determines the numeric value of a character as a hexadecimal digit. If the\n+ * character is not a hex digit according to [func@GLib.ascii_isxdigit],\n+ * `-1` is returned.\n@@ -1856,2 +1821,7 @@\n- * Returns: If @c is a hex digit (according to g_ascii_isxdigit()),\n- *     its numeric value. Otherwise, -1.\n+ * Differs from [func@GLib.unichar_xdigit_value] because it takes a char, so\n+ * there's no worry about sign extension if characters are signed.\n+ *\n+ * Differs from [func@GLib.unichar_xdigit_value] because it takes a char, so\n+ * there's no worry about sign extension if characters are signed.\n+ *\n+ * Returns: the numerical value of @c if it is a hex digit, `-1` otherwise\n@@ -1876,1 +1846,1 @@\n- * Unlike the BSD strcasecmp() function, this only recognizes standard\n+ * Unlike the BSD `strcasecmp()` function, this only recognizes standard\n@@ -1888,1 +1858,1 @@\n- * Both @s1 and @s2 must be non-%NULL.\n+ * Both @s1 and @s2 must be non-`NULL`.\n@@ -1891,1 +1861,1 @@\n- *     or a positive value if @s1 > @s2.\n+ *   or a positive value if @s1 > @s2\n@@ -1925,1 +1895,1 @@\n- * Unlike the BSD strcasecmp() function, this only recognizes standard\n+ * Unlike the BSD `strncasecmp()` function, this only recognizes standard\n@@ -1929,1 +1899,1 @@\n- * The same warning as in g_ascii_strcasecmp() applies: Use this\n+ * The same warning as in [func@GLib.ascii_strcasecmp] applies: Use this\n@@ -1934,1 +1904,1 @@\n- *     or a positive value if @s1 > @s2.\n+ *   or a positive value if @s1 > @s2\n@@ -1964,2 +1934,2 @@\n- * @s1: a string\n- * @s2: a string to compare with @s1\n+ * @s1: string to compare with @s2\n+ * @s2: string to compare with @s1\n@@ -1968,1 +1938,1 @@\n- * strcasecmp() function on platforms which support it.\n+ * `strcasecmp()` function on platforms which support it.\n@@ -1971,1 +1941,1 @@\n- *     or a positive value if @s1 > @s2.\n+ *   or a positive value if @s1 > @s2\n@@ -1973,2 +1943,2 @@\n- * Deprecated:2.2: See g_strncasecmp() for a discussion of why this\n- *     function is deprecated and how to replace it.\n+ * Deprecated: 2.2: See [func@GLib.strncasecmp] for a discussion of why this\n+ *   function is deprecated and how to replace it.\n@@ -2009,2 +1979,2 @@\n- * @s1: a string\n- * @s2: a string to compare with @s1\n+ * @s1: string to compare with @s2\n+ * @s2: string to compare with @s1\n@@ -2014,2 +1984,2 @@\n- * strncasecmp() function on platforms which support it. It is similar\n- * to g_strcasecmp() except it only compares the first @n characters of\n+ * `strncasecmp()` function on platforms which support it. It is similar\n+ * to [func@GLib.strcasecmp] except it only compares the first @n characters of\n@@ -2019,16 +1989,16 @@\n- *     or a positive value if @s1 > @s2.\n- *\n- * Deprecated:2.2: The problem with g_strncasecmp() is that it does\n- *     the comparison by calling toupper()\/tolower(). These functions\n- *     are locale-specific and operate on single bytes. However, it is\n- *     impossible to handle things correctly from an internationalization\n- *     standpoint by operating on bytes, since characters may be multibyte.\n- *     Thus g_strncasecmp() is broken if your string is guaranteed to be\n- *     ASCII, since it is locale-sensitive, and it's broken if your string\n- *     is localized, since it doesn't work on many encodings at all,\n- *     including UTF-8, EUC-JP, etc.\n- *\n- *     There are therefore two replacement techniques: g_ascii_strncasecmp(),\n- *     which only works on ASCII and is not locale-sensitive, and\n- *     g_utf8_casefold() followed by strcmp() on the resulting strings,\n- *     which is good for case-insensitive sorting of UTF-8.\n+ *   or a positive value if @s1 > @s2\n+ *\n+ * Deprecated: 2.2: The problem with `g_strncasecmp()` is that it does\n+ *   the comparison by calling `toupper()`\/`tolower()`. These functions\n+ *   are locale-specific and operate on single bytes. However, it is\n+ *   impossible to handle things correctly from an internationalization\n+ *   standpoint by operating on bytes, since characters may be multibyte.\n+ *   Thus `g_strncasecmp()` is broken if your string is guaranteed to be\n+ *   ASCII, since it is locale-sensitive, and it's broken if your string\n+ *   is localized, since it doesn't work on many encodings at all,\n+ *   including UTF-8, EUC-JP, etc.\n+ *\n+ *   There are therefore two replacement techniques: [func@GLib.ascii_strncasecmp],\n+ *   which only works on ASCII and is not locale-sensitive, and\n+ *   [func@GLib.utf8_casefold] followed by `strcmp()` on the resulting strings,\n+ *   which is good for case-insensitive sorting of UTF-8.\n@@ -2072,2 +2042,2 @@\n- * @delimiters: (nullable): a string containing the current delimiters,\n- *     or %NULL to use the standard delimiters defined in %G_STR_DELIMITERS\n+ * @delimiters: (nullable): a string containing the current delimiters, or\n+ *   `NULL` to use the standard delimiters defined in [const@GLib.STR_DELIMITERS]\n@@ -2083,0 +2053,3 @@\n+ * ```C\n+ * g_ascii_strup (g_strdelimit (str, \"abc\", '?'))\n+ * ```\n@@ -2084,11 +2057,6 @@\n- * |[<!-- language=\"C\" -->\n- *   g_ascii_strup (g_strdelimit (str, \"abc\", '?'))\n- * ]|\n- *\n- * In order to modify a copy, you may use g_strdup():\n- *\n- * |[<!-- language=\"C\" -->\n- *   reformatted = g_strdelimit (g_strdup (const_str), \"abc\", '?');\n- *   ...\n- *   g_free (reformatted);\n- * ]|\n+ * In order to modify a copy, you may use [func@GLib.strdup]:\n+ * ```C\n+ * reformatted = g_strdelimit (g_strdup (const_str), \"abc\", '?');\n+ * …\n+ * g_free (reformatted);\n+ * ```\n@@ -2130,0 +2098,3 @@\n+ * ```C\n+ * g_ascii_strup (g_strcanon (str, \"abc\", '?'))\n+ * ```\n@@ -2131,11 +2102,6 @@\n- * |[<!-- language=\"C\" -->\n- *   g_ascii_strup (g_strcanon (str, \"abc\", '?'))\n- * ]|\n- *\n- * In order to modify a copy, you may use g_strdup():\n- *\n- * |[<!-- language=\"C\" -->\n- *   reformatted = g_strcanon (g_strdup (const_str), \"abc\", '?');\n- *   ...\n- *   g_free (reformatted);\n- * ]|\n+ * In order to modify a copy, you may use [func@GLib.strdup]:\n+ * ```C\n+ * reformatted = g_strcanon (g_strdup (const_str), \"abc\", '?');\n+ * …\n+ * g_free (reformatted);\n+ * ```\n@@ -2170,1 +2136,1 @@\n- * This function does the reverse conversion of g_strescape().\n+ * This function does the reverse conversion of [func@GLib.strescape].\n@@ -2173,1 +2139,1 @@\n- *     character compressed\n+ *   character compressed\n@@ -2254,1 +2220,1 @@\n- * g_strcompress() does the reverse conversion.\n+ * [func@GLib.strcompress] does the reverse conversion.\n@@ -2256,2 +2222,1 @@\n- * Returns: a newly-allocated copy of @source with certain\n- *     characters escaped. See above.\n+ * Returns: a newly-allocated copy of @source with special characters escaped\n@@ -2358,1 +2323,1 @@\n- * Also see g_strchomp() and g_strstrip().\n+ * Also see [func@GLib.strchomp] and [func@GLib.strstrip].\n@@ -2360,1 +2325,1 @@\n- * Returns: @string\n+ * Returns: the modified @string\n@@ -2389,1 +2354,1 @@\n- * Also see g_strchug() and g_strstrip().\n+ * Also see [func@GLib.strchug] and [func@GLib.strstrip].\n@@ -2391,1 +2356,1 @@\n- * Returns: @string\n+ * Returns: the modified @string\n@@ -2416,4 +2381,4 @@\n- *     the string. The delimiter is not included in any of the resulting\n- *     strings, unless @max_tokens is reached.\n- * @max_tokens: the maximum number of pieces to split @string into.\n- *     If this is less than 1, the string is split completely.\n+ *   the string. The delimiter is not included in any of the resulting\n+ *   strings, unless @max_tokens is reached.\n+ * @max_tokens: the maximum number of pieces to split @string into\n+ *   If this is less than 1, the string is split completely\n@@ -2425,3 +2390,2 @@\n- * As an example, the result of g_strsplit (\":a:bc::d:\", \":\", -1) is a\n- * %NULL-terminated vector containing the six strings \"\", \"a\", \"bc\", \"\", \"d\"\n- * and \"\".\n+ * As an example, the result of `g_strsplit (\":a:bc::d:\", \":\", -1)` is an array\n+ * containing the six strings \"\", \"a\", \"bc\", \"\", \"d\" and \"\".\n@@ -2430,2 +2394,2 @@\n- * vector, not a vector containing a single string. The reason for this\n- * special case is that being able to represent an empty vector is typically\n+ * array, not an array containing a single string. The reason for this\n+ * special case is that being able to represent an empty array is typically\n@@ -2434,1 +2398,1 @@\n- * before calling g_strsplit().\n+ * before calling `g_strsplit()`.\n@@ -2436,2 +2400,2 @@\n- * Returns: (transfer full): a newly-allocated %NULL-terminated array of\n- *    strings. Use g_strfreev() to free it.\n+ * Returns: (transfer full): a newly-allocated array of strings, freed with\n+ *   [func@GLib.strfreev]\n@@ -2488,6 +2452,5 @@\n- * @string: The string to be tokenized\n- * @delimiters: A nul-terminated string containing bytes that are used\n- *     to split the string (it can accept an empty string, which will result\n- *     in no string splitting).\n- * @max_tokens: The maximum number of tokens to split @string into.\n- *     If this is less than 1, the string is split completely\n+ * @string: a string to split\n+ * @delimiters: a string containing characters that are used to split the\n+ *   string. Can be empty, which will result in no string splitting\n+ * @max_tokens: the maximum number of tokens to split @string into.\n+ *   If this is less than 1, the string is split completely\n@@ -2496,1 +2459,1 @@\n- * in @delimiter. A token is the (possibly empty) longest string that does not\n+ * in @delimiters. A token is the (possibly empty) longest string that does not\n@@ -2500,3 +2463,2 @@\n- * For example the result of g_strsplit_set (\"abc:def\/ghi\", \":\/\", -1) is a\n- * %NULL-terminated vector containing the three strings \"abc\", \"def\",\n- * and \"ghi\".\n+ * For example, the result of g_strsplit_set (\"abc:def\/ghi\", \":\/\", -1) is an\n+ * array containing the three strings \"abc\", \"def\", and \"ghi\".\n@@ -2504,2 +2466,2 @@\n- * The result of g_strsplit_set (\":def\/ghi:\", \":\/\", -1) is a %NULL-terminated\n- * vector containing the four strings \"\", \"def\", \"ghi\", and \"\".\n+ * The result of g_strsplit_set (\":def\/ghi:\", \":\/\", -1) is an array containing\n+ * the four strings \"\", \"def\", \"ghi\", and \"\".\n@@ -2508,2 +2470,2 @@\n- * vector, not a vector containing a single string. The reason for this\n- * special case is that being able to represent an empty vector is typically\n+ * array, not an array containing a single string. The reason for this\n+ * special case is that being able to represent an empty array is typically\n@@ -2512,1 +2474,1 @@\n- * before calling g_strsplit_set().\n+ * before calling `g_strsplit_set()`.\n@@ -2517,2 +2479,2 @@\n- * Returns: (transfer full): a newly-allocated %NULL-terminated array of\n- *    strings. Use g_strfreev() to free it.\n+ * Returns: (transfer full): a newly-allocated array of strings. Use\n+ *   [func@GLib.strfreev] to free it.\n@@ -2592,1 +2554,1 @@\n- * g_auto().\n+ * `g_auto()`.\n@@ -2597,1 +2559,2 @@\n- * @str_array: (nullable): a %NULL-terminated array of strings to free\n+ * @str_array: (array zero-terminated=1) (nullable) (transfer full): an\n+ *   array of strings to free\n@@ -2599,2 +2562,1 @@\n- * Frees a %NULL-terminated array of strings, as well as each\n- * string it contains.\n+ * Frees an array of strings, as well as each string it contains.\n@@ -2602,1 +2564,1 @@\n- * If @str_array is %NULL, this function simply returns.\n+ * If @str_array is `NULL`, this function simply returns.\n@@ -2620,1 +2582,1 @@\n- * @str_array: (nullable): a %NULL-terminated array of strings\n+ * @str_array: (array zero-terminated=1) (nullable): an array of strings to copy\n@@ -2622,4 +2584,2 @@\n- * Copies %NULL-terminated array of strings. The copy is a deep copy;\n- * the new array should be freed by first freeing each string, then\n- * the array itself. g_strfreev() does this for you. If called\n- * on a %NULL value, g_strdupv() simply returns %NULL.\n+ * Copies an array of strings. The copy is a deep copy; each string is also\n+ * copied.\n@@ -2627,1 +2587,4 @@\n- * Returns: (nullable): a new %NULL-terminated array of strings.\n+ * If called on a `NULL` value, `g_strdupv()` simply returns `NULL`.\n+ *\n+ * Returns: (array zero-terminated=1) (nullable) (transfer full): a\n+ *   newly-allocated array of strings. Use [func@GLib.strfreev] to free it.\n@@ -2659,3 +2622,2 @@\n- * @separator: (nullable): a string to insert between each of the\n- *     strings, or %NULL\n- * @str_array: a %NULL-terminated array of strings to join\n+ * @separator: (nullable): a string to insert between each of the strings\n+ * @str_array: (array zero-terminated=1): an array of strings to join\n@@ -2663,3 +2625,2 @@\n- * Joins a number of strings together to form one long string, with the\n- * optional @separator inserted between each of them. The returned string\n- * should be freed with g_free().\n+ * Joins an array of strings together to form one long string, with the\n+ * optional @separator inserted between each of them.\n@@ -2672,1 +2633,1 @@\n- *     together, with @separator between them\n+ *   together, with @separator between them\n@@ -2716,3 +2677,2 @@\n- * @separator: (nullable): a string to insert between each of the\n- *     strings, or %NULL\n- * @...: a %NULL-terminated list of strings to join\n+ * @separator: (nullable): a string to insert between each of the strings\n+ * @...: a `NULL`-terminated list of strings to join\n@@ -2721,2 +2681,1 @@\n- * optional @separator inserted between each of them. The returned string\n- * should be freed with g_free().\n+ * optional @separator inserted between each of them.\n@@ -2725,1 +2684,1 @@\n- *     together, with @separator between them\n+ *   together, with @separator between them\n@@ -2786,3 +2745,3 @@\n- * @haystack: a nul-terminated string\n- * @haystack_len: the maximum length of @haystack in bytes. A length of -1\n- *     can be used to mean \"search the entire string\", like `strstr()`.\n+ * @haystack: a string to search in\n+ * @haystack_len: the maximum length of @haystack in bytes, or `-1` to\n+ *   search it entirely\n@@ -2795,2 +2754,4 @@\n- * Returns: a pointer to the found occurrence, or\n- *    %NULL if not found.\n+ * A length of `-1` can be used to mean “search the entire string”, like\n+ * `strstr()`.\n+ *\n+ * Returns: a pointer to the found occurrence, or `NULL` if not found\n@@ -2842,2 +2803,2 @@\n- * @haystack: a nul-terminated string\n- * @needle: the nul-terminated string to search for\n+ * @haystack: a string to search in\n+ * @needle: the string to search for\n@@ -2848,2 +2809,1 @@\n- * Returns: a pointer to the found occurrence, or\n- *    %NULL if not found.\n+ * Returns: a pointer to the found occurrence, or `NULL` if not found\n@@ -2891,4 +2851,4 @@\n- * @haystack: a nul-terminated string\n- * @haystack_len: the maximum length of @haystack in bytes. A length of -1\n- *     can be used to mean \"search the entire string\", like g_strrstr().\n- * @needle: the nul-terminated string to search for\n+ * @haystack: a string to search in\n+ * @haystack_len: the maximum length of @haystack in bytes. A length of `-1`\n+ *   can be used to mean \"search the entire string\", like [func@GLib.strrstr]\n+ * @needle: the string to search for\n@@ -2900,2 +2860,1 @@\n- * Returns: a pointer to the found occurrence, or\n- *    %NULL if not found.\n+ * Returns: a pointer to the found occurrence, or `NULL` if not found\n@@ -2947,2 +2906,2 @@\n- * @str: a nul-terminated string\n- * @suffix: the nul-terminated suffix to look for\n+ * @str: a string to look in\n+ * @suffix: the suffix to look for\n@@ -2950,1 +2909,1 @@\n- * Looks whether the string @str ends with @suffix.\n+ * Looks whether a string ends with @suffix.\n@@ -2952,1 +2911,1 @@\n- * Returns: %TRUE if @str end with @suffix, %FALSE otherwise.\n+ * Returns: true if @str ends with @suffix, false otherwise\n@@ -2976,2 +2935,2 @@\n- * @str: a nul-terminated string\n- * @prefix: the nul-terminated prefix to look for\n+ * @str: a string to look in\n+ * @prefix: the prefix to look for\n@@ -2981,1 +2940,1 @@\n- * Returns: %TRUE if @str begins with @prefix, %FALSE otherwise.\n+ * Returns: true if @str begins with @prefix, false otherwise\n@@ -2996,1 +2955,1 @@\n- * @str_array: a %NULL-terminated array of strings\n+ * @str_array: (array zero-terminated=1): an array of strings\n@@ -2998,2 +2957,1 @@\n- * Returns the length of the given %NULL-terminated\n- * string array @str_array. @str_array must not be %NULL.\n+ * Returns the length of an array of strings. @str_array must not be `NULL`.\n@@ -3001,1 +2959,1 @@\n- * Returns: length of @str_array.\n+ * Returns: length of @str_array\n@@ -3105,1 +3063,1 @@\n- * @string: a string\n+ * @string: a string to tokenize\n@@ -3108,2 +3066,2 @@\n- * @ascii_alternates: (out) (transfer full) (array zero-terminated=1): a\n- *   return location for ASCII alternates\n+ * @ascii_alternates: (out) (optional) (transfer full) (array zero-terminated=1):\n+ *   a return location for ASCII alternates\n@@ -3111,1 +3069,1 @@\n- * Tokenises @string and performs folding on each token.\n+ * Tokenizes @string and performs folding on each token.\n@@ -3116,1 +3074,1 @@\n- * g_unichar_isalnum() or g_unichar_ismark().\n+ * [func@GLib.unichar_isalnum] or [func@GLib.unichar_ismark].\n@@ -3119,1 +3077,1 @@\n- * @ascii_alternates is non-%NULL and some of the returned tokens\n+ * @ascii_alternates is non-`NULL` and some of the returned tokens\n@@ -3193,1 +3151,1 @@\n- * @accept_alternates: %TRUE to accept ASCII alternates\n+ * @accept_alternates: if true, ASCII alternates are accepted\n@@ -3198,2 +3156,2 @@\n- * This function calls g_str_tokenize_and_fold() on both\n- * @search_term and @potential_hit.  ASCII alternates are never taken\n+ * This function calls [func@GLib.str_tokenize_and_fold] on both\n+ * @search_term and @potential_hit. ASCII alternates are never taken\n@@ -3207,1 +3165,1 @@\n- * faster to call g_str_tokenize_and_fold() on each string in\n+ * faster to call `g_str_tokenize_and_fold()` on each string in\n@@ -3209,1 +3167,1 @@\n- * call g_str_tokenize_and_fold() on the search term and\n+ * call `g_str_tokenize_and_fold()` on the search term and\n@@ -3218,1 +3176,1 @@\n- * Returns: %TRUE if @potential_hit is a hit\n+ * Returns: true if @potential_hit is a hit\n@@ -3268,2 +3226,2 @@\n- * @strv: a %NULL-terminated array of strings\n- * @str: a string\n+ * @strv: (array zero-terminated=1): an array of strings to search in\n+ * @str: the string to search for\n@@ -3271,1 +3229,2 @@\n- * Checks if @strv contains @str. @strv must not be %NULL.\n+ * Checks if an array of strings contains the string @str according to\n+ * [func@GLib.str_equal]. @strv must not be `NULL`.\n@@ -3273,1 +3232,1 @@\n- * Returns: %TRUE if @str is an element of @strv, according to g_str_equal().\n+ * Returns: true if @str is an element of @strv\n@@ -3295,2 +3254,2 @@\n- * @strv1: a %NULL-terminated array of strings\n- * @strv2: another %NULL-terminated array of strings\n+ * @strv1: (array zero-terminated=1): an array of strings to compare to @strv2\n+ * @strv2: (array zero-terminated=1): an array of strings to compare to @strv1\n@@ -3298,3 +3257,2 @@\n- * Checks if @strv1 and @strv2 contain exactly the same elements in exactly the\n- * same order. Elements are compared using g_str_equal(). To match independently\n- * of order, sort the arrays first (using g_qsort_with_data() or similar).\n+ * Checks if two arrays of strings contain exactly the same elements in\n+ * exactly the same order.\n@@ -3302,2 +3260,3 @@\n- * Two empty arrays are considered equal. Neither @strv1 not @strv2 may be\n- * %NULL.\n+ * Elements are compared using [func@GLib.str_equal]. To match independently\n+ * of order, sort the arrays first (using [func@GLib.qsort_with_data]\n+ * or similar).\n@@ -3305,1 +3264,8 @@\n- * Returns: %TRUE if @strv1 and @strv2 are equal\n+ * Elements are compared using [func@GLib.str_equal]. To match independently\n+ * of order, sort the arrays first (using [func@GLib.qsort_with_data]\n+ * or similar).\n+ *\n+ * Two empty arrays are considered equal. Neither @strv1 nor @strv2 may be\n+ * `NULL`.\n+ *\n+ * Returns: true if @strv1 and @strv2 are equal\n@@ -3341,1 +3307,1 @@\n- * @str: a string\n+ * @str: a string to convert\n@@ -3361,1 +3327,1 @@\n- * Parsing failures result in an error with the %G_NUMBER_PARSER_ERROR\n+ * Parsing failures result in an error with the `G_NUMBER_PARSER_ERROR`\n@@ -3363,2 +3329,2 @@\n- * %G_NUMBER_PARSER_ERROR_INVALID. If the parsed number is out of\n- * bounds - %G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.\n+ * [error@GLib.NumberParserError.INVALID]. If the parsed number is out of\n+ * bounds - [error@GLib.NumberParserError.OUT_OF_BOUNDS].\n@@ -3366,1 +3332,1 @@\n- * See g_ascii_strtoll() if you have more complex needs such as\n+ * See [func@GLib.ascii_strtoll] if you have more complex needs such as\n@@ -3370,1 +3336,1 @@\n- * Returns: %TRUE if @str was a number, otherwise %FALSE.\n+ * Returns: true if @str was a number, false otherwise\n@@ -3463,1 +3429,1 @@\n- * Parsing failures result in an error with the %G_NUMBER_PARSER_ERROR\n+ * Parsing failures result in an error with the `G_NUMBER_PARSER_ERROR`\n@@ -3465,2 +3431,2 @@\n- * %G_NUMBER_PARSER_ERROR_INVALID. If the parsed number is out of\n- * bounds - %G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.\n+ * [error@GLib.NumberParserError.INVALID]. If the parsed number is out of\n+ * bounds - [error@GLib.NumberParserError.OUT_OF_BOUNDS].\n@@ -3468,1 +3434,1 @@\n- * See g_ascii_strtoull() if you have more complex needs such as\n+ * See [func@GLib.ascii_strtoull] if you have more complex needs such as\n@@ -3472,1 +3438,1 @@\n- * Returns: %TRUE if @str was a number, otherwise %FALSE.\n+ * Returns: true if @str was a number, false otherwise\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstrfuncs.c","additions":434,"deletions":468,"binary":false,"changes":902,"status":"modified"},{"patch":"@@ -415,2 +415,2 @@\n- * @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.\n- * @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.\n+ * @G_NUMBER_PARSER_ERROR_INVALID: string was not a valid number\n+ * @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: string was a number, but out of bounds\n@@ -459,2 +459,3 @@\n- * @str_pointer: (inout) (not optional) (nullable): a pointer to either a string or %NULL\n- * @new_str: (nullable): a string to assign to @str_pointer, or %NULL\n+ * @str_pointer: (inout) (not optional) (nullable): a pointer to either\n+ *   a string or `NULL`\n+ * @new_str: (nullable): a string to assign to @str_pointer\n@@ -462,2 +463,2 @@\n- * Updates a pointer to a string to a copy of @new_str. The previous string\n- * pointed to by @str_pointer will be freed with g_free().\n+ * Updates a pointer to a string to a copy of @new_str and returns whether the\n+ * string was changed.\n@@ -465,1 +466,6 @@\n- * @str_pointer must not be %NULL, but can point to a %NULL value.\n+ * If @new_str matches the previous string, this function is a no-op. If\n+ * @new_str is different, a copy of it will be assigned to @str_pointer and\n+ * the previous string pointed to by @str_pointer will be freed with\n+ * [func@GLib.free].\n+ *\n+ * @str_pointer must not be `NULL`, but can point to a `NULL` value.\n@@ -468,6 +474,6 @@\n- * |[\n- *   void\n- *   foo_set_bar (Foo        *foo,\n- *                const char *new_bar)\n- *   {\n- *     g_return_if_fail (IS_FOO (foo));\n+ * ```C\n+ * void\n+ * foo_set_bar (Foo        *foo,\n+ *              const char *new_bar)\n+ * {\n+ *   g_return_if_fail (IS_FOO (foo));\n@@ -475,4 +481,4 @@\n- *     if (g_set_str (&foo->bar, new_bar))\n- *       g_object_notify (foo, \"bar\");\n- *   }\n- * ]|\n+ *   if (g_set_str (&foo->bar, new_bar))\n+ *     g_object_notify (foo, \"bar\");\n+ * }\n+ * ```\n@@ -480,1 +486,1 @@\n- * Returns: %TRUE if the value of @str_pointer changed, %FALSE otherwise\n+ * Returns: true if the value of @str_pointer changed, false otherwise\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstrfuncs.h","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -45,19 +45,0 @@\n-\/**\n- * SECTION:strings\n- * @title: Strings\n- * @short_description: text buffers which grow automatically\n- *     as text is added\n- *\n- * A #GString is an object that handles the memory management of a C\n- * string for you.  The emphasis of #GString is on text, typically\n- * UTF-8.  Crucially, the \"str\" member of a #GString is guaranteed to\n- * have a trailing nul character, and it is therefore always safe to\n- * call functions such as strchr() or g_strdup() on it.\n- *\n- * However, a #GString can also hold arbitrary binary data, because it\n- * has a \"len\" member, which includes any possible embedded nul\n- * characters in the data.  Conceptually then, #GString is like a\n- * #GByteArray with the addition of many convenience methods for text,\n- * and a guaranteed nul terminator.\n- *\/\n-\n@@ -74,1 +55,10 @@\n- * The GString struct contains the public fields of a GString.\n+ * A `GString` is an object that handles the memory management of a C string.\n+ *\n+ * The emphasis of `GString` is on text, typically UTF-8. Crucially, the \"str\" member\n+ * of a `GString` is guaranteed to have a trailing nul character, and it is therefore\n+ * always safe to call functions such as `strchr()` or `strdup()` on it.\n+ *\n+ * However, a `GString` can also hold arbitrary binary data, because it has a \"len\" member,\n+ * which includes any possible embedded nul characters in the data. Conceptually then,\n+ * `GString` is like a `GByteArray` with the addition of many convenience methods for\n+ * text, and a guaranteed nul terminator.\n@@ -1239,0 +1229,4 @@\n+  else\n+    {\n+      g_critical (\"Failed to append to string: invalid format\/args passed to g_vasprintf()\");\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstring.c","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -45,3 +45,3 @@\n- * SECTION:string_chunks\n- * @title: String Chunks\n- * @short_description: efficient storage of groups of strings\n+ * GStringChunk:\n+ *\n+ * `GStringChunk` provides efficient storage of groups of strings\n@@ -50,1 +50,1 @@\n- * allocated in blocks, and as strings are added to the #GStringChunk\n+ * allocated in blocks, and as strings are added to the `GStringChunk`\n@@ -55,2 +55,2 @@\n- * efficient than using g_strdup() since fewer calls to malloc() are\n- * needed, and less memory is wasted in memory allocation overheads.\n+ * efficient than using [func@GLib.strdup] since fewer calls to `malloc()`\n+ * are needed, and less memory is wasted in memory allocation overheads.\n@@ -58,1 +58,1 @@\n- * By adding strings with g_string_chunk_insert_const() it is also\n+ * By adding strings with [method@GLib.StringChunk.insert_const] it is also\n@@ -61,1 +61,1 @@\n- * To create a new #GStringChunk use g_string_chunk_new().\n+ * To create a new `GStringChunk` use [func@GLib.StringChunk.new].\n@@ -63,1 +63,1 @@\n- * To add strings to a #GStringChunk use g_string_chunk_insert().\n+ * To add strings to a `GStringChunk` use [method@GLib.StringChunk.insert].\n@@ -65,3 +65,2 @@\n- * To add strings to a #GStringChunk, but without duplicating strings\n- * which are already in the #GStringChunk, use\n- * g_string_chunk_insert_const().\n+ * To add strings to a `GStringChunk`, but without duplicating strings\n+ * which are already in the `GStringChunk`, use [method@GLib.StringChunk.insert_const].\n@@ -69,2 +68,2 @@\n- * To free the entire #GStringChunk use g_string_chunk_free(). It is\n- * not possible to free individual strings.\n+ * To free the entire `GStringChunk` use [method@GLib.StringChunk.free].\n+ * It is not possible to free individual strings.\n@@ -73,6 +72,0 @@\n-\/**\n- * GStringChunk:\n- *\n- * An opaque data structure representing String Chunks.\n- * It should only be accessed by using the following functions.\n- *\/\n@@ -89,1 +82,1 @@\n- * g_string_chunk_new:\n+ * g_string_chunk_new: (constructor)\n@@ -97,1 +90,1 @@\n- * Returns: a new #GStringChunk\n+ * Returns: (transfer full): a new #GStringChunk\n@@ -118,1 +111,1 @@\n- * @chunk: a #GStringChunk\n+ * @chunk: (transfer full): a #GStringChunk\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstringchunk.c","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -70,187 +70,0 @@\n-\/**\n- * SECTION:testing\n- * @title: Testing\n- * @short_description: a test framework\n- *\n- * GLib provides a framework for writing and maintaining unit tests\n- * in parallel to the code they are testing. The API is designed according\n- * to established concepts found in the other test frameworks (JUnit, NUnit,\n- * RUnit), which in turn is based on smalltalk unit testing concepts.\n- *\n- * - Test case: Tests (test methods) are grouped together with their\n- *   fixture into test cases.\n- *\n- * - Fixture: A test fixture consists of fixture data and setup and\n- *   teardown methods to establish the environment for the test\n- *   functions. We use fresh fixtures, i.e. fixtures are newly set\n- *   up and torn down around each test invocation to avoid dependencies\n- *   between tests.\n- *\n- * - Test suite: Test cases can be grouped into test suites, to allow\n- *   subsets of the available tests to be run. Test suites can be\n- *   grouped into other test suites as well.\n- *\n- * The API is designed to handle creation and registration of test suites\n- * and test cases implicitly. A simple call like\n- * |[<!-- language=\"C\" -->\n- *   g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);\n- *\n- *   g_test_add_func (\"\/misc\/assertions\", test_assertions);\n- * ]|\n- * creates a test suite called \"misc\" with a single test case named\n- * \"assertions\", which consists of running the test_assertions function.\n- *\n- * g_test_init() should be called before calling any other test functions.\n- *\n- * In addition to the traditional g_assert_true(), the test framework provides\n- * an extended set of assertions for comparisons: g_assert_cmpfloat(),\n- * g_assert_cmpfloat_with_epsilon(), g_assert_cmpint(), g_assert_cmpuint(),\n- * g_assert_cmphex(), g_assert_cmpstr(), g_assert_cmpmem() and\n- * g_assert_cmpvariant(). The\n- * advantage of these variants over plain g_assert_true() is that the assertion\n- * messages can be more elaborate, and include the values of the compared\n- * entities.\n- *\n- * Note that g_assert() should not be used in unit tests, since it is a no-op\n- * when compiling with `G_DISABLE_ASSERT`. Use g_assert() in production code,\n- * and g_assert_true() in unit tests.\n- *\n- * A full example of creating a test suite with two tests using fixtures:\n- * |[<!-- language=\"C\" -->\n- * #include <glib.h>\n- * #include <locale.h>\n- *\n- * typedef struct {\n- *   MyObject *obj;\n- *   OtherObject *helper;\n- * } MyObjectFixture;\n- *\n- * static void\n- * my_object_fixture_set_up (MyObjectFixture *fixture,\n- *                           gconstpointer user_data)\n- * {\n- *   fixture->obj = my_object_new ();\n- *   my_object_set_prop1 (fixture->obj, \"some-value\");\n- *   my_object_do_some_complex_setup (fixture->obj, user_data);\n- *\n- *   fixture->helper = other_object_new ();\n- * }\n- *\n- * static void\n- * my_object_fixture_tear_down (MyObjectFixture *fixture,\n- *                              gconstpointer user_data)\n- * {\n- *   g_clear_object (&fixture->helper);\n- *   g_clear_object (&fixture->obj);\n- * }\n- *\n- * static void\n- * test_my_object_test1 (MyObjectFixture *fixture,\n- *                       gconstpointer user_data)\n- * {\n- *   g_assert_cmpstr (my_object_get_property (fixture->obj), ==, \"initial-value\");\n- * }\n- *\n- * static void\n- * test_my_object_test2 (MyObjectFixture *fixture,\n- *                       gconstpointer user_data)\n- * {\n- *   my_object_do_some_work_using_helper (fixture->obj, fixture->helper);\n- *   g_assert_cmpstr (my_object_get_property (fixture->obj), ==, \"updated-value\");\n- * }\n- *\n- * int\n- * main (int argc, char *argv[])\n- * {\n- *   setlocale (LC_ALL, \"\");\n- *\n- *   g_test_init (&argc, &argv, NULL);\n- *\n- *   \/\/ Define the tests.\n- *   g_test_add (\"\/my-object\/test1\", MyObjectFixture, \"some-user-data\",\n- *               my_object_fixture_set_up, test_my_object_test1,\n- *               my_object_fixture_tear_down);\n- *   g_test_add (\"\/my-object\/test2\", MyObjectFixture, \"some-user-data\",\n- *               my_object_fixture_set_up, test_my_object_test2,\n- *               my_object_fixture_tear_down);\n- *\n- *   return g_test_run ();\n- * }\n- * ]|\n- *\n- * ## Integrating GTest in your project\n- *\n- * If you are using the [Meson](http:\/\/mesonbuild.com) build system, you will\n- * typically use the provided `test()` primitive to call the test binaries,\n- * e.g.:\n- *\n- * |[<!-- language=\"plain\" -->\n- *   test(\n- *     'foo',\n- *     executable('foo', 'foo.c', dependencies: deps),\n- *     env: [\n- *       'G_TEST_SRCDIR=@0@'.format(meson.current_source_dir()),\n- *       'G_TEST_BUILDDIR=@0@'.format(meson.current_build_dir()),\n- *     ],\n- *   )\n- *\n- *   test(\n- *     'bar',\n- *     executable('bar', 'bar.c', dependencies: deps),\n- *     env: [\n- *       'G_TEST_SRCDIR=@0@'.format(meson.current_source_dir()),\n- *       'G_TEST_BUILDDIR=@0@'.format(meson.current_build_dir()),\n- *     ],\n- *   )\n- * ]|\n- *\n- * If you are using Autotools, you're strongly encouraged to use the Automake\n- * [TAP](https:\/\/testanything.org\/) harness; GLib provides template files for\n- * easily integrating with it:\n- *\n- *   - [glib-tap.mk](https:\/\/gitlab.gnome.org\/GNOME\/glib\/blob\/glib-2-58\/glib-tap.mk)\n- *   - [tap-test](https:\/\/gitlab.gnome.org\/GNOME\/glib\/blob\/glib-2-58\/tap-test)\n- *   - [tap-driver.sh](https:\/\/gitlab.gnome.org\/GNOME\/glib\/blob\/glib-2-58\/tap-driver.sh)\n- *\n- * You can copy these files in your own project's root directory, and then\n- * set up your `Makefile.am` file to reference them, for instance:\n- *\n- * |[<!-- language=\"plain\" -->\n- * include $(top_srcdir)\/glib-tap.mk\n- *\n- * # test binaries\n- * test_programs = \\\n- *   foo \\\n- *   bar\n- *\n- * # data distributed in the tarball\n- * dist_test_data = \\\n- *   foo.data.txt \\\n- *   bar.data.txt\n- *\n- * # data not distributed in the tarball\n- * test_data = \\\n- *   blah.data.txt\n- * ]|\n- *\n- * Make sure to distribute the TAP files, using something like the following\n- * in your top-level `Makefile.am`:\n- *\n- * |[<!-- language=\"plain\" -->\n- * EXTRA_DIST += \\\n- *   tap-driver.sh \\\n- *   tap-test\n- * ]|\n- *\n- * `glib-tap.mk` will be distributed implicitly due to being included in a\n- * `Makefile.am`. All three files should be added to version control.\n- *\n- * If you don't have access to the Autotools TAP harness, you can use the\n- * [gtester][gtester] and [gtester-report][gtester-report] tools, and use\n- * the [glib.mk](https:\/\/gitlab.gnome.org\/GNOME\/glib\/blob\/glib-2-58\/glib.mk)\n- * Automake template provided by GLib. Note, however, that since GLib 2.62,\n- * [gtester][gtester] and [gtester-report][gtester-report] have been deprecated\n- * in favour of using TAP. The `--tap` argument to tests is enabled by default\n- * as of GLib 2.62.\n- *\/\n-\n@@ -1105,1 +918,1 @@\n-  if (g_once_init_enter (&g_default_print_func))\n+  if (g_once_init_enter_pointer (&g_default_print_func))\n@@ -1107,2 +920,2 @@\n-      g_once_init_leave (&g_default_print_func,\n-                         g_set_print_handler (g_test_print_handler));\n+      g_once_init_leave_pointer (&g_default_print_func,\n+                                 g_set_print_handler (g_test_print_handler));\n@@ -1847,2 +1660,2 @@\n-  if (!g_get_prgname() && !no_g_set_prgname)\n-    g_set_prgname ((*argv)[0]);\n+  if (!g_get_prgname () && !no_g_set_prgname)\n+    g_set_prgname_once ((*argv)[0]);\n@@ -3074,6 +2887,7 @@\n- * This function enqueus a callback @destroy_func to be executed\n- * during the next test case teardown phase. This is most useful\n- * to auto destruct allocated test resources at the end of a test run.\n- * Resources are released in reverse queue order, that means enqueueing\n- * callback A before callback B will cause B() to be called before\n- * A() during teardown.\n+ * Enqueues a callback @destroy_func to be executed during the next test case\n+ * teardown phase.\n+ *\n+ * This is most useful to auto destroy allocated test resources at the end of a\n+ * test run. Resources are released in reverse queue order, that means\n+ * enqueueing callback `A` before callback `B` will cause `B()` to be called\n+ * before `A()` during teardown.\n@@ -3114,0 +2928,3 @@\n+static gboolean test_should_run (const char *test_path,\n+                                 const char *cmp_path);\n+\n@@ -3115,1 +2932,3 @@\n-test_case_run (GTestCase *tc)\n+test_case_run (GTestCase  *tc,\n+               const char *test_run_name,\n+               const char *path)\n@@ -3117,1 +2936,1 @@\n-  gchar *old_base = g_strdup (test_uri_base);\n+  gchar *old_base = NULL;\n@@ -3120,0 +2939,1 @@\n+  gboolean free_test_data = TRUE;\n@@ -3121,0 +2941,1 @@\n+  old_base = g_strdup (test_uri_base);\n@@ -3124,1 +2945,7 @@\n-  if (++test_run_count <= test_startup_skip_count)\n+  if (!test_should_run (test_run_name, path))\n+    {\n+      \/* Silently skip the test and return success. This happens if it’s a\n+       * \/subprocess path. *\/\n+      success = G_TEST_RUN_SKIPPED;\n+    }\n+  else if (++test_run_count <= test_startup_skip_count)\n@@ -3171,0 +2998,1 @@\n+              free_test_data = FALSE;\n@@ -3188,0 +3016,7 @@\n+  \/* In case the test didn’t run (due to being skipped or an error), the test\n+   * data may still need to be freed, as the client’s main() function may have\n+   * passed ownership of it into g_test_add_data_func_full() with a\n+   * #GDestroyNotify. *\/\n+  if (free_test_data && tc->fixture_size == 0 && tc->fixture_teardown != NULL)\n+    tc->fixture_teardown (tc->test_data, tc->test_data);\n+\n@@ -3253,5 +3088,4 @@\n-      if (test_should_run (test_run_name, path))\n-        {\n-          if (!test_case_run (tc))\n-            n_bad++;\n-        }\n+\n+      if (!test_case_run (tc, test_run_name, path))\n+        n_bad++;\n+\n@@ -4039,0 +3873,26 @@\n+ *\n+ * This is equivalent to calling g_test_trap_subprocess_with_envp() with `envp`\n+ * set to %NULL. See the documentation for that function for full details.\n+ *\n+ * Since: 2.38\n+ *\/\n+void\n+g_test_trap_subprocess (const char           *test_path,\n+                        guint64               usec_timeout,\n+                        GTestSubprocessFlags  test_flags)\n+{\n+  g_test_trap_subprocess_with_envp (test_path, NULL, usec_timeout, test_flags);\n+}\n+\n+\/**\n+ * g_test_trap_subprocess_with_envp:\n+ * @test_path: (nullable): Test to run in a subprocess\n+ * @envp: (array zero-terminated=1) (nullable) (element-type filename): Environment\n+ *   to run the test in, or %NULL to inherit the parent’s environment. This must\n+ *   be in the GLib filename encoding.\n+ * @usec_timeout: Timeout for the subprocess test in micro seconds.\n+ * @test_flags:   Flags to modify subprocess behaviour.\n+ *\n+ * Respawns the test program to run only @test_path in a subprocess with the\n+ * given @envp environment.\n+ *\n@@ -4052,0 +3912,2 @@\n+ * If @envp is %NULL, the parent process’ environment will be inherited.\n+ *\n@@ -4094,0 +3956,18 @@\n+ *   static void\n+ *   test_different_username (void)\n+ *   {\n+ *     if (g_test_subprocess ())\n+ *       {\n+ *         \/\/ Code under test goes here\n+ *         g_message (\"Username is now simulated as %s\", g_getenv (\"USER\"));\n+ *         return;\n+ *       }\n+ *\n+ *     \/\/ Reruns this same test in a subprocess\n+ *     g_autoptr(GStrv) envp = g_get_environ ();\n+ *     envp = g_environ_setenv (g_steal_pointer (&envp), \"USER\", \"charlie\", TRUE);\n+ *     g_test_trap_subprocess_with_envp (NULL, envp, 0, G_TEST_SUBPROCESS_DEFAULT);\n+ *     g_test_trap_assert_passed ();\n+ *     g_test_trap_assert_stdout (\"Username is now simulated as charlie\");\n+ *   }\n+ *\n@@ -4099,1 +3979,1 @@\n- *     g_test_add_func (\"\/myobject\/create_large_object\",\n+ *     g_test_add_func (\"\/myobject\/create-large-object\",\n@@ -4101,0 +3981,2 @@\n+ *     g_test_add_func (\"\/myobject\/different-username\",\n+ *                      test_different_username);\n@@ -4105,1 +3987,1 @@\n- * Since: 2.38\n+ * Since: 2.80\n@@ -4108,3 +3990,4 @@\n-g_test_trap_subprocess (const char           *test_path,\n-                        guint64               usec_timeout,\n-                        GTestSubprocessFlags  test_flags)\n+g_test_trap_subprocess_with_envp (const char           *test_path,\n+                                  const char * const   *envp,\n+                                  guint64               usec_timeout,\n+                                  GTestSubprocessFlags  test_flags)\n@@ -4169,1 +4052,1 @@\n-                                 NULL, flags,\n+                                 (char **) envp, flags,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtestutils.c","additions":95,"deletions":212,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -518,0 +518,5 @@\n+GLIB_AVAILABLE_IN_2_80\n+void     g_test_trap_subprocess_with_envp (const char           *test_path,\n+                                           const char * const   *envp,\n+                                           guint64               usec_timeout,\n+                                           GTestSubprocessFlags  test_flags);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtestutils.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -427,22 +427,0 @@\n-  \/* In static compilation, DllMain doesn't exist and so DLL_THREAD_DETACH\n-   * case is never called and thread destroy notifications are not triggered.\n-   * To ensure that notifications are correctly triggered in static\n-   * compilation mode, we call directly the \"detach\" function here right\n-   * before terminating the thread.\n-   * As all win32 threads initialized through the glib API are run through\n-   * the same proxy function g_thread_win32_proxy() which calls systematically\n-   * g_system_thread_exit() when finishing, we obtain the same behavior as\n-   * with dynamic compilation.\n-   *\n-   * WARNING: unfortunately this mechanism cannot work with threads created\n-   * directly from the Windows API using CreateThread() or _beginthread\/ex().\n-   * It only works with threads created by using the glib API with\n-   * g_system_thread_new(). If users need absolutely to use a thread NOT\n-   * created with glib API under Windows and in static compilation mode, they\n-   * should not use glib functions within their thread or they may encounter\n-   * memory leaks when the thread finishes.\n-   *\/\n-#ifdef GLIB_STATIC_COMPILATION\n-  g_thread_win32_thread_detach ();\n-#endif\n-\n@@ -596,1 +574,1 @@\n-   infosize = sizeof (info) \/ sizeof (DWORD);\n+   infosize = sizeof (info) \/ sizeof (ULONG_PTR);\n@@ -604,1 +582,2 @@\n-   __except (EXCEPTION_EXECUTE_HANDLER)\n+   __except (GetExceptionCode () == EXCEPTION_SET_THREAD_NAME ?\n+             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)\n@@ -608,4 +587,1 @@\n-   \/* Without a debugger we *must* have an exception handler,\n-    * otherwise raising an exception will crash the process.\n-    *\/\n-   if ((!IsDebuggerPresent ()) && (SetThreadName_VEH_handle == NULL))\n+   if ((!IsDebuggerPresent ()) || (SetThreadName_VEH_handle == NULL))\n@@ -684,1 +660,6 @@\n-  SetThreadName_VEH_handle = AddVectoredExceptionHandler (1, &SetThreadName_VEH);\n+  \/* Set the handler as last to not interfere with ASAN runtimes.\n+   * Many ASAN implementations (currently all three of GCC, CLANG\n+   * and MSVC) install a Vectored Exception Handler that must be\n+   * first in the sequence to work well\n+   *\/\n+  SetThreadName_VEH_handle = AddVectoredExceptionHandler (0, &SetThreadName_VEH);\n@@ -686,3 +667,2 @@\n-    {\n-      \/* This is bad, but what can we do? *\/\n-    }\n+    g_critical (\"%s failed with error code %u\",\n+                \"AddVectoredExceptionHandler\", (unsigned int) GetLastError ());\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthread-win32.c","additions":12,"deletions":32,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+\n+#if defined(THREADS_POSIX) && defined(HAVE_PTHREAD_GETAFFINITY_NP)\n+#include <pthread.h>\n@@ -51,0 +54,1 @@\n+#endif \/* G_OS_UNIX *\/\n@@ -65,98 +69,0 @@\n-\/**\n- * SECTION:threads\n- * @title: Threads\n- * @short_description: portable support for threads, mutexes, locks,\n- *     conditions and thread private data\n- * @see_also: #GThreadPool, #GAsyncQueue\n- *\n- * Threads act almost like processes, but unlike processes all threads\n- * of one process share the same memory. This is good, as it provides\n- * easy communication between the involved threads via this shared\n- * memory, and it is bad, because strange things (so called\n- * \"Heisenbugs\") might happen if the program is not carefully designed.\n- * In particular, due to the concurrent nature of threads, no\n- * assumptions on the order of execution of code running in different\n- * threads can be made, unless order is explicitly forced by the\n- * programmer through synchronization primitives.\n- *\n- * The aim of the thread-related functions in GLib is to provide a\n- * portable means for writing multi-threaded software. There are\n- * primitives for mutexes to protect the access to portions of memory\n- * (#GMutex, #GRecMutex and #GRWLock). There is a facility to use\n- * individual bits for locks (g_bit_lock()). There are primitives\n- * for condition variables to allow synchronization of threads (#GCond).\n- * There are primitives for thread-private data - data that every\n- * thread has a private instance of (#GPrivate). There are facilities\n- * for one-time initialization (#GOnce, g_once_init_enter()). Finally,\n- * there are primitives to create and manage threads (#GThread).\n- *\n- * The GLib threading system used to be initialized with g_thread_init().\n- * This is no longer necessary. Since version 2.32, the GLib threading\n- * system is automatically initialized at the start of your program,\n- * and all thread-creation functions and synchronization primitives\n- * are available right away.\n- *\n- * Note that it is not safe to assume that your program has no threads\n- * even if you don't call g_thread_new() yourself. GLib and GIO can\n- * and will create threads for their own purposes in some cases, such\n- * as when using g_unix_signal_source_new() or when using GDBus.\n- *\n- * Originally, UNIX did not have threads, and therefore some traditional\n- * UNIX APIs are problematic in threaded programs. Some notable examples\n- * are\n- *\n- * - C library functions that return data in statically allocated\n- *   buffers, such as strtok() or strerror(). For many of these,\n- *   there are thread-safe variants with a _r suffix, or you can\n- *   look at corresponding GLib APIs (like g_strsplit() or g_strerror()).\n- *\n- * - The functions setenv() and unsetenv() manipulate the process\n- *   environment in a not thread-safe way, and may interfere with getenv()\n- *   calls in other threads. Note that getenv() calls may be hidden behind\n- *   other APIs. For example, GNU gettext() calls getenv() under the\n- *   covers. In general, it is best to treat the environment as readonly.\n- *   If you absolutely have to modify the environment, do it early in\n- *   main(), when no other threads are around yet.\n- *\n- * - The setlocale() function changes the locale for the entire process,\n- *   affecting all threads. Temporary changes to the locale are often made\n- *   to change the behavior of string scanning or formatting functions\n- *   like scanf() or printf(). GLib offers a number of string APIs\n- *   (like g_ascii_formatd() or g_ascii_strtod()) that can often be\n- *   used as an alternative. Or you can use the uselocale() function\n- *   to change the locale only for the current thread.\n- *\n- * - The fork() function only takes the calling thread into the child's\n- *   copy of the process image. If other threads were executing in critical\n- *   sections they could have left mutexes locked which could easily\n- *   cause deadlocks in the new child. For this reason, you should\n- *   call exit() or exec() as soon as possible in the child and only\n- *   make signal-safe library calls before that.\n- *\n- * - The daemon() function uses fork() in a way contrary to what is\n- *   described above. It should not be used with GLib programs.\n- *\n- * GLib itself is internally completely thread-safe (all global data is\n- * automatically locked), but individual data structure instances are\n- * not automatically locked for performance reasons. For example,\n- * you must coordinate accesses to the same #GHashTable from multiple\n- * threads. The two notable exceptions from this rule are #GMainLoop\n- * and #GAsyncQueue, which are thread-safe and need no further\n- * application-level locking to be accessed from multiple threads.\n- * Most refcounting functions such as g_object_ref() are also thread-safe.\n- *\n- * A common use for #GThreads is to move a long-running blocking operation out\n- * of the main thread and into a worker thread. For GLib functions, such as\n- * single GIO operations, this is not necessary, and complicates the code.\n- * Instead, the '..._async()' version of the function should be used from the main\n- * thread, eliminating the need for locking and synchronisation between multiple\n- * threads. If an operation does need to be moved to a worker thread, consider\n- * using g_task_run_in_thread(), or a #GThreadPool. #GThreadPool is often a\n- * better choice than #GThread, as it handles thread reuse and task queueing;\n- * #GTask uses this internally.\n- *\n- * However, if multiple blocking operations need to be performed in sequence,\n- * and it is not possible to use #GTask for them, moving them to a worker thread\n- * can clarify the code.\n- *\/\n-\n@@ -239,0 +145,14 @@\n+\/**\n+ * G_AUTO_LOCK:\n+ * @name: the name of the lock\n+ *\n+ * Works like [func@GLib.MUTEX_AUTO_LOCK], but for a lock defined with\n+ * [func@GLib.LOCK_DEFINE].\n+ *\n+ * This feature is only supported on GCC and clang. This macro is not defined on\n+ * other compilers and should not be used in programs that are intended to be\n+ * portable to those compilers.\n+ *\n+ * Since: 2.80\n+ *\/\n+\n@@ -666,1 +586,1 @@\n- * @location: (not nullable): location of a static initializable variable\n+ * @location: (inout) (not optional): location of a static initializable variable\n@@ -723,1 +643,1 @@\n- * g_once_init_leave:\n+ * g_once_init_enter_pointer:\n@@ -725,0 +645,48 @@\n+ *    containing `NULL`\n+ *\n+ * This functions behaves in the same way as g_once_init_enter(), but can\n+ * can be used to initialize pointers (or #guintptr) instead of #gsize.\n+ *\n+ * |[<!-- language=\"C\" -->\n+ *   static MyStruct *interesting_struct = NULL;\n+ *\n+ *   if (g_once_init_enter_pointer (&interesting_struct))\n+ *     {\n+ *       MyStruct *setup_value = allocate_my_struct (); \/\/ initialization code here\n+ *\n+ *       g_once_init_leave_pointer (&interesting_struct, g_steal_pointer (&setup_value));\n+ *     }\n+ *\n+ *   \/\/ use interesting_struct here\n+ * ]|\n+ *\n+ * Returns: %TRUE if the initialization section should be entered,\n+ *     %FALSE and blocks otherwise\n+ *\n+ * Since: 2.80\n+ *\/\n+gboolean\n+(g_once_init_enter_pointer) (gpointer location)\n+{\n+  gpointer *value_location = (gpointer *) location;\n+  gboolean need_init = FALSE;\n+  g_mutex_lock (&g_once_mutex);\n+  if (g_atomic_pointer_get (value_location) == 0)\n+    {\n+      if (!g_slist_find (g_once_init_list, (void *) value_location))\n+        {\n+          need_init = TRUE;\n+          g_once_init_list = g_slist_prepend (g_once_init_list, (void *) value_location);\n+        }\n+      else\n+        do\n+          g_cond_wait (&g_once_cond, &g_once_mutex);\n+        while (g_slist_find (g_once_init_list, (void *) value_location));\n+    }\n+  g_mutex_unlock (&g_once_mutex);\n+  return need_init;\n+}\n+\n+\/**\n+ * g_once_init_leave:\n+ * @location: (inout) (not optional): location of a static initializable variable\n@@ -758,0 +726,36 @@\n+\/**\n+ * g_once_init_leave_pointer:\n+ * @location: (not nullable): location of a static initializable variable\n+ *    containing `NULL`\n+ * @result: new non-`NULL` value for `*location`\n+ *\n+ * Counterpart to g_once_init_enter_pointer(). Expects a location of a static\n+ * `NULL`-initialized initialization variable, and an initialization value\n+ * other than `NULL`. Sets the variable to the initialization value, and\n+ * releases concurrent threads blocking in g_once_init_enter_pointer() on this\n+ * initialization variable.\n+ *\n+ * This functions behaves in the same way as g_once_init_leave(), but\n+ * can be used to initialize pointers (or #guintptr) instead of #gsize.\n+ *\n+ * Since: 2.80\n+ *\/\n+void\n+(g_once_init_leave_pointer) (gpointer location,\n+                             gpointer result)\n+{\n+  gpointer *value_location = (gpointer *) location;\n+  gpointer old_value;\n+\n+  g_return_if_fail (result != 0);\n+\n+  old_value = g_atomic_pointer_exchange (value_location, result);\n+  g_return_if_fail (old_value == 0);\n+\n+  g_mutex_lock (&g_once_mutex);\n+  g_return_if_fail (g_once_init_list != NULL);\n+  g_once_init_list = g_slist_remove (g_once_init_list, (void *) value_location);\n+  g_cond_broadcast (&g_once_cond);\n+  g_mutex_unlock (&g_once_mutex);\n+}\n+\n@@ -1089,0 +1093,14 @@\n+#elif defined(_SC_NPROCESSORS_ONLN) && defined(THREADS_POSIX) && defined(HAVE_PTHREAD_GETAFFINITY_NP)\n+  {\n+    int ncores = MIN (sysconf (_SC_NPROCESSORS_ONLN), CPU_SETSIZE);\n+    cpu_set_t cpu_mask;\n+    CPU_ZERO (&cpu_mask);\n+\n+    int af_count = 0;\n+    int err = pthread_getaffinity_np (pthread_self (), sizeof (cpu_mask), &cpu_mask);\n+    if (!err)\n+      af_count = CPU_COUNT (&cpu_mask);\n+\n+    int count = (af_count > 0) ? af_count : ncores;\n+    return count;\n+  }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthread.c","additions":118,"deletions":100,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+#ifdef g_autoptr\n+#define G_AUTO_LOCK(name) G_MUTEX_AUTO_LOCK (&G_LOCK_NAME (name), g__##name##_locker)\n+#endif \/* g_autoptr *\/\n+\n@@ -239,0 +243,6 @@\n+GLIB_AVAILABLE_IN_2_80\n+gboolean g_once_init_enter_pointer              (void *location);\n+GLIB_AVAILABLE_IN_2_80\n+void g_once_init_leave_pointer                  (void *location,\n+                                                 gpointer result);\n+\n@@ -271,0 +281,13 @@\n+# define g_once_init_enter_pointer(location)                   \\\n+  (G_GNUC_EXTENSION ({                                         \\\n+    G_STATIC_ASSERT (sizeof *(location) == sizeof (gpointer)); \\\n+    (void) (0 ? (gpointer) * (location) : NULL);               \\\n+    (!g_atomic_pointer_get (location) &&                       \\\n+     g_once_init_enter_pointer (location));                    \\\n+  })) GLIB_AVAILABLE_MACRO_IN_2_80\n+# define g_once_init_leave_pointer(location, result)                        \\\n+  (G_GNUC_EXTENSION ({                                                      \\\n+    G_STATIC_ASSERT (sizeof *(location) == sizeof (gpointer));              \\\n+    0 ? (void) (*(location) = (result)) : (void) 0;                         \\\n+    g_once_init_leave_pointer ((location), (gpointer) (guintptr) (result)); \\\n+  })) GLIB_AVAILABLE_MACRO_IN_2_80\n@@ -276,0 +299,6 @@\n+# define g_once_init_enter_pointer(location) \\\n+  (g_once_init_enter_pointer((location))) \\\n+  GLIB_AVAILABLE_MACRO_IN_2_80\n+# define g_once_init_leave_pointer(location, result) \\\n+  (g_once_init_leave_pointer((location), (gpointer) (guintptr) (result))) \\\n+  GLIB_AVAILABLE_MACRO_IN_2_80\n@@ -317,1 +346,1 @@\n- *   if (cond)\n+ *   if (condition)\n@@ -328,0 +357,4 @@\n+ * Note that it is common for the declared variable to not be used in the scope,\n+ * which causes some compilers to warn. That can be avoided by using\n+ * `G_GNUC_UNUSED` or, since 2.80, [func@GLib.MUTEX_AUTO_LOCK].\n+ *\n@@ -356,0 +389,43 @@\n+\/**\n+ * G_MUTEX_AUTO_LOCK:\n+ * @mutex: a [type@GLib.Mutex]\n+ * @var: a variable name to be declared\n+ *\n+ * Declare a [type@GLib.MutexLocker] variable with `g_autoptr()` and lock the\n+ * mutex. The mutex will be unlocked automatically when leaving the scope. The\n+ * variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it is\n+ * not used in the scope.\n+ *\n+ * This feature is only supported on GCC and clang. This macro is not defined on\n+ * other compilers and should not be used in programs that are intended to be\n+ * portable to those compilers.\n+ *\n+ * Note that this should be used in a place where it is allowed to declare a\n+ * variable, which could be before any statement in the case\n+ * `-Wdeclaration-after-statement` is used, or C standard prior to C99.\n+ *\n+ * ```c\n+ * {\n+ *   G_MUTEX_AUTO_LOCK (&obj->mutex, locker);\n+ *\n+ *   obj->stuff_with_lock ();\n+ *   if (condition)\n+ *     {\n+ *       \/\/ No need to unlock\n+ *       return;\n+ *     }\n+ *\n+ *   \/\/ Unlock before end of scope\n+ *   g_clear_pointer (&locker, g_mutex_locker_free);\n+ *   obj->stuff_without_lock ();\n+ * }\n+ * ```\n+ *\n+ * Since: 2.80.0\n+ *\/\n+#ifdef g_autoptr\n+#define G_MUTEX_AUTO_LOCK(mutex, var)                   \\\n+  GLIB_AVAILABLE_MACRO_IN_2_80 g_autoptr (GMutexLocker) \\\n+  G_GNUC_UNUSED var = g_mutex_locker_new (mutex)\n+#endif \/* g_autoptr *\/\n+\n@@ -392,1 +468,1 @@\n- *   if (cond)\n+ *   if (condition)\n@@ -403,0 +479,4 @@\n+ * Note that it is common for the declared variable to not be used in the scope,\n+ * which causes some compilers to warn. That can be avoided by using\n+ * `G_GNUC_UNUSED` or, since 2.80, [func@GLib.REC_MUTEX_AUTO_LOCK].\n+ *\n@@ -435,0 +515,43 @@\n+\/**\n+ * G_REC_MUTEX_AUTO_LOCK:\n+ * @mutex: a [type@GLib.RecMutex]\n+ * @var: a variable name to be declared\n+ *\n+ * Declare a [type@GLib.RecMutexLocker] variable with `g_autoptr()` and lock the\n+ * mutex. The mutex will be unlocked automatically when leaving the scope. The\n+ * variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it is\n+ * not used in the scope.\n+ *\n+ * This feature is only supported on GCC and clang. This macro is not defined on\n+ * other compilers and should not be used in programs that are intended to be\n+ * portable to those compilers.\n+ *\n+ * Note that this should be used in a place where it is allowed to declare a\n+ * variable, which could be before any statement in the case\n+ * `-Wdeclaration-after-statement` is used, or C standard prior to C99.\n+ *\n+ * ```c\n+ * {\n+ *   G_REC_MUTEX_AUTO_LOCK (&obj->rec_mutex, locker);\n+ *\n+ *   obj->stuff_with_lock ();\n+ *   if (condition)\n+ *     {\n+ *       \/\/ No need to unlock\n+ *       return;\n+ *     }\n+ *\n+ *   \/\/ Unlock before end of scope\n+ *   g_clear_pointer (&locker, g_rec_mutex_locker_free);\n+ *   obj->stuff_without_lock ();\n+ * }\n+ * ```\n+ *\n+ * Since: 2.80.0\n+ *\/\n+#ifdef g_autoptr\n+#define G_REC_MUTEX_AUTO_LOCK(mutex, var)                  \\\n+  GLIB_AVAILABLE_MACRO_IN_2_80 g_autoptr (GRecMutexLocker) \\\n+  G_GNUC_UNUSED var = g_rec_mutex_locker_new (mutex)\n+#endif \/* g_autoptr *\/\n+\n@@ -498,1 +621,1 @@\n- *   if (cond)\n+ *   if (condition)\n@@ -513,0 +636,4 @@\n+ * Note that it is common for the declared variable to not be used in the scope,\n+ * which causes some compilers to warn. That can be avoided by using\n+ * `G_GNUC_UNUSED` or, since 2.80, [func@GLib.RW_LOCK_WRITER_AUTO_LOCK].\n+ *\n@@ -546,0 +673,43 @@\n+\/**\n+ * G_RW_LOCK_WRITER_AUTO_LOCK:\n+ * @mutex: a [type@GLib.RWLock]\n+ * @var: a variable name to be declared\n+ *\n+ * Declare a [type@GLib.RWLockWriterLocker] variable with `g_autoptr()` and lock\n+ * for writing. The mutex will be unlocked automatically when leaving the scope.\n+ * The variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it\n+ * is not used in the scope.\n+ *\n+ * This feature is only supported on GCC and clang. This macro is not defined on\n+ * other compilers and should not be used in programs that are intended to be\n+ * portable to those compilers.\n+ *\n+ * Note that this should be used in a place where it is allowed to declare a\n+ * variable, which could be before any statement in the case\n+ * `-Wdeclaration-after-statement` is used, or C standard prior to C99.\n+ *\n+ * ```c\n+ * {\n+ *   G_RW_LOCK_WRITER_AUTO_LOCK (&obj->rw_lock, locker);\n+ *\n+ *   obj->stuff_with_lock ();\n+ *   if (condition)\n+ *     {\n+ *       \/\/ No need to unlock\n+ *       return;\n+ *     }\n+ *\n+ *   \/\/ Unlock before end of scope\n+ *   g_clear_pointer (&locker, g_rw_lock_writer_locker_free);\n+ *   obj->stuff_without_lock ();\n+ * }\n+ * ```\n+ *\n+ * Since: 2.80.0\n+ *\/\n+#ifdef g_autoptr\n+#define G_RW_LOCK_WRITER_AUTO_LOCK(mutex, var)                 \\\n+  GLIB_AVAILABLE_MACRO_IN_2_80 g_autoptr (GRWLockWriterLocker) \\\n+  G_GNUC_UNUSED var = g_rw_lock_writer_locker_new (mutex)\n+#endif \/* g_autoptr *\/\n+\n@@ -601,0 +771,43 @@\n+\/**\n+ * G_RW_LOCK_READER_AUTO_LOCK:\n+ * @mutex: a [type@GLib.RWLock]\n+ * @var: a variable name to be declared\n+ *\n+ * Declare a [type@GLib.RWLockReaderLocker] variable with `g_autoptr()` and lock\n+ * for reading. The mutex will be unlocked automatically when leaving the scope.\n+ * The variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it\n+ * is not used in the scope.\n+ *\n+ * This feature is only supported on GCC and clang. This macro is not defined on\n+ * other compilers and should not be used in programs that are intended to be\n+ * portable to those compilers.\n+ *\n+ * Note that this should be used in a place where it is allowed to declare a\n+ * variable, which could be before any statement in the case\n+ * `-Wdeclaration-after-statement` is used, or C standard prior to C99.\n+ *\n+ * ```c\n+ * {\n+ *   G_RW_LOCK_READER_AUTO_LOCK (&obj->rw_lock, locker);\n+ *\n+ *   obj->stuff_with_lock ();\n+ *   if (condition)\n+ *     {\n+ *       \/\/ No need to unlock\n+ *       return;\n+ *     }\n+ *\n+ *   \/\/ Unlock before end of scope\n+ *   g_clear_pointer (&locker, g_rw_lock_reader_locker_free);\n+ *   obj->stuff_without_lock ();\n+ * }\n+ * ```\n+ *\n+ * Since: 2.80.0\n+ *\/\n+#ifdef g_autoptr\n+#define G_RW_LOCK_READER_AUTO_LOCK(mutex, var)                 \\\n+  GLIB_AVAILABLE_MACRO_IN_2_80 g_autoptr (GRWLockReaderLocker) \\\n+  G_GNUC_UNUSED var = g_rw_lock_reader_locker_new (mutex)\n+#endif \/* g_autoptr *\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthread.h","additions":216,"deletions":3,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -40,37 +40,0 @@\n-\/**\n- * SECTION:thread_pools\n- * @title: Thread Pools\n- * @short_description: pools of threads to execute work concurrently\n- * @see_also: #GThread\n- *\n- * Sometimes you wish to asynchronously fork out the execution of work\n- * and continue working in your own thread. If that will happen often,\n- * the overhead of starting and destroying a thread each time might be\n- * too high. In such cases reusing already started threads seems like a\n- * good idea. And it indeed is, but implementing this can be tedious\n- * and error-prone.\n- *\n- * Therefore GLib provides thread pools for your convenience. An added\n- * advantage is, that the threads can be shared between the different\n- * subsystems of your program, when they are using GLib.\n- *\n- * To create a new thread pool, you use g_thread_pool_new().\n- * It is destroyed by g_thread_pool_free().\n- *\n- * If you want to execute a certain task within a thread pool,\n- * you call g_thread_pool_push().\n- *\n- * To get the current number of running threads you call\n- * g_thread_pool_get_num_threads(). To get the number of still\n- * unprocessed tasks you call g_thread_pool_unprocessed(). To control\n- * the maximal number of threads for a thread pool, you use\n- * g_thread_pool_get_max_threads() and g_thread_pool_set_max_threads().\n- *\n- * Finally you can control the number of unused threads, that are kept\n- * alive by GLib for future use. The current number can be fetched with\n- * g_thread_pool_get_num_unused_threads(). The maximal number can be\n- * controlled by g_thread_pool_get_max_unused_threads() and\n- * g_thread_pool_set_max_unused_threads(). All currently unused threads\n- * can be stopped by calling g_thread_pool_stop_unused_threads().\n- *\/\n-\n@@ -88,3 +51,26 @@\n- * The #GThreadPool struct represents a thread pool. It has three\n- * public read-only members, but the underlying struct is bigger,\n- * so you must not copy this struct.\n+ * The `GThreadPool` struct represents a thread pool.\n+ *\n+ * A thread pool is useful when you wish to asynchronously fork out the execution of work\n+ * and continue working in your own thread. If that will happen often, the overhead of starting\n+ * and destroying a thread each time might be too high. In such cases reusing already started\n+ * threads seems like a good idea. And it indeed is, but implementing this can be tedious\n+ * and error-prone.\n+ *\n+ * Therefore GLib provides thread pools for your convenience. An added advantage is, that the\n+ * threads can be shared between the different subsystems of your program, when they are using GLib.\n+ *\n+ * To create a new thread pool, you use [func@GLib.ThreadPool.new].\n+ * It is destroyed by [method@GLib.ThreadPool.free].\n+ *\n+ * If you want to execute a certain task within a thread pool, use [method@GLib.ThreadPool.push].\n+ *\n+ * To get the current number of running threads you call [method@GLib.ThreadPool.get_num_threads].\n+ * To get the number of still unprocessed tasks you call [method@GLib.ThreadPool.unprocessed].\n+ * To control the maximum number of threads for a thread pool, you use\n+ * [method@GLib.ThreadPool.get_max_threads]. and [method@GLib.ThreadPool.set_max_threads].\n+ *\n+ * Finally you can control the number of unused threads, that are kept alive by GLib for future use.\n+ * The current number can be fetched with [func@GLib.ThreadPool.get_num_unused_threads].\n+ * The maximum number can be controlled by [func@GLib.ThreadPool.get_max_unused_threads] and\n+ * [func@GLib.ThreadPool.set_max_unused_threads]. All currently unused threads\n+ * can be stopped by calling [func@GLib.ThreadPool.stop_unused_threads].\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthreadpool.c","additions":26,"deletions":40,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -59,11 +59,0 @@\n-\/**\n- * SECTION:timers\n- * @title: Timers\n- * @short_description: keep track of elapsed time\n- *\n- * #GTimer records a start time, and counts microseconds elapsed since\n- * that time. This is done somewhat differently on different platforms,\n- * and can be tricky to get exactly right, so #GTimer provides a\n- * portable\/convenient interface.\n- **\/\n-\n@@ -73,2 +62,6 @@\n- * Opaque datatype that records a start time.\n- **\/\n+ * `GTimer` records a start time, and counts microseconds elapsed since\n+ * that time.\n+ *\n+ * This is done somewhat differently on different platforms, and can be\n+ * tricky to get exactly right, so `GTimer` provides a portable\/convenient interface.\n+ *\/\n@@ -84,1 +77,1 @@\n- * g_timer_new:\n+ * g_timer_new: (constructor)\n@@ -89,1 +82,1 @@\n- * Returns: a new #GTimer.\n+ * Returns: (transfer full): a new #GTimer.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtimer.c","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -56,4 +56,3 @@\n- * SECTION:timezone\n- * @title: GTimeZone\n- * @short_description: a structure representing a time zone\n- * @see_also: #GDateTime\n+ * GTimeZone:\n+ *\n+ * A `GTimeZone` represents a time zone, at no particular point in time.\n@@ -61,2 +60,1 @@\n- * #GTimeZone is a structure that represents a time zone, at no\n- * particular point in time.  It is refcounted and immutable.\n+ * The `GTimeZone` struct is refcounted and immutable.\n@@ -64,4 +62,4 @@\n- * Each time zone has an identifier (for example, 'Europe\/London') which is\n- * platform dependent. See g_time_zone_new() for information on the identifier\n- * formats. The identifier of a time zone can be retrieved using\n- * g_time_zone_get_identifier().\n+ * Each time zone has an identifier (for example, ‘Europe\/London’) which is\n+ * platform dependent. See [ctor@GLib.TimeZone.new] for information on the\n+ * identifier formats. The identifier of a time zone can be retrieved using\n+ * [method@GLib.TimeZone.get_identifier].\n@@ -69,6 +67,6 @@\n- * A time zone contains a number of intervals.  Each interval has\n- * an abbreviation to describe it (for example, 'PDT'), an offset to UTC and a\n- * flag indicating if the daylight savings time is in effect during that\n- * interval.  A time zone always has at least one interval - interval 0. Note\n- * that interval abbreviations are not the same as time zone identifiers\n- * (apart from 'UTC'), and cannot be passed to g_time_zone_new().\n+ * A time zone contains a number of intervals. Each interval has an abbreviation\n+ * to describe it (for example, ‘PDT’), an offset to UTC and a flag indicating\n+ * if the daylight savings time is in effect during that interval. A time zone\n+ * always has at least one interval — interval 0. Note that interval abbreviations\n+ * are not the same as time zone identifiers (apart from ‘UTC’), and cannot be\n+ * passed to [ctor@GLib.TimeZone.new].\n@@ -87,9 +85,0 @@\n- * #GTimeZone is available since GLib 2.26.\n- *\/\n-\n-\/**\n- * GTimeZone:\n- *\n- * #GTimeZone is an opaque structure whose members cannot be accessed\n- * directly.\n- *\n@@ -97,1 +86,1 @@\n- **\/\n+ *\/\n@@ -106,0 +95,2 @@\n+#ifdef G_OS_UNIX\n+\n@@ -118,0 +109,2 @@\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtimezone.c","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -37,3 +37,4 @@\n- * SECTION:trash_stack\n- * @title: Trash Stacks\n- * @short_description: maintain a stack of unused allocated memory chunks\n+ * GTrashStack:\n+ * @next: pointer to the previous element of the stack,\n+ *     gets stored in the first `sizeof (gpointer)`\n+ *     bytes of the element\n@@ -41,1 +42,1 @@\n- * A #GTrashStack is an efficient way to keep a stack of unused allocated\n+ * A `GTrashStack` is an efficient way to keep a stack of unused allocated\n@@ -43,1 +44,1 @@\n- * a #gpointer. This allows the stack to be maintained without any space\n+ * a `gpointer`. This allows the stack to be maintained without any space\n@@ -46,1 +47,1 @@\n- * There is no function to create a #GTrashStack. A %NULL #GTrashStack*\n+ * There is no function to create a `GTrashStack`. A `NULL` `GTrashStack*`\n@@ -49,11 +50,2 @@\n- * There is no longer any good reason to use #GTrashStack.  If you have\n- * extra pieces of memory, free() them and allocate them again later.\n- *\n- * Deprecated: 2.48: #GTrashStack is deprecated without replacement\n- *\/\n-\n-\/**\n- * GTrashStack:\n- * @next: pointer to the previous element of the stack,\n- *     gets stored in the first `sizeof (gpointer)`\n- *     bytes of the element\n+ * Each piece of memory that is pushed onto the stack is cast to a\n+ * `GTrashStack*`.\n@@ -61,2 +53,2 @@\n- * Each piece of memory that is pushed onto the stack\n- * is cast to a GTrashStack*.\n+ * There is no longer any good reason to use `GTrashStack`.  If you have\n+ * extra pieces of memory, `free()` them and allocate them again later.\n@@ -64,1 +56,1 @@\n- * Deprecated: 2.48: #GTrashStack is deprecated without replacement\n+ * Deprecated: 2.48: `GTrashStack` is deprecated without replacement\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtrashstack.c","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,32 +39,0 @@\n-\/**\n- * SECTION:trees-binary\n- * @title: Balanced Binary Trees\n- * @short_description: a sorted collection of key\/value pairs optimized\n- *                     for searching and traversing in order\n- *\n- * The #GTree structure and its associated functions provide a sorted\n- * collection of key\/value pairs optimized for searching and traversing\n- * in order. This means that most of the operations  (access, search,\n- * insertion, deletion, ...) on #GTree are O(log(n)) in average and O(n)\n- * in worst case for time complexity. But, note that maintaining a\n- * balanced sorted #GTree of n elements is done in time O(n log(n)).\n- *\n- * To create a new #GTree use g_tree_new().\n- *\n- * To insert a key\/value pair into a #GTree use g_tree_insert()\n- * (O(n log(n))).\n- *\n- * To remove a key\/value pair use g_tree_remove() (O(n log(n))).\n- *\n- * To look up the value corresponding to a given key, use\n- * g_tree_lookup() and g_tree_lookup_extended().\n- *\n- * To find out the number of nodes in a #GTree, use g_tree_nnodes(). To\n- * get the height of a #GTree, use g_tree_height().\n- *\n- * To traverse a #GTree, calling a function for each node visited in\n- * the traversal, use g_tree_foreach().\n- *\n- * To destroy a #GTree, use g_tree_destroy().\n- **\/\n-\n@@ -160,1 +128,1 @@\n- * g_tree_new:\n+ * g_tree_new: (constructor)\n@@ -1163,1 +1131,1 @@\n- * @func: the function to call for each node visited.\n+ * @func: (scope call): the function to call for each node visited.\n@@ -1202,1 +1170,1 @@\n- * @func: the function to call for each node visited.\n+ * @func: (scope call): the function to call for each node visited.\n@@ -1243,1 +1211,1 @@\n- * @traverse_func: the function to call for each node visited. If this\n+ * @traverse_func: (scope call): the function to call for each node visited. If this\n@@ -1303,1 +1271,1 @@\n- * @search_func: a function used to search the #GTree\n+ * @search_func: (scope call): a function used to search the #GTree\n@@ -1337,1 +1305,1 @@\n- * @search_func: a function used to search the #GTree\n+ * @search_func: (scope call): a function used to search the #GTree\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtree.c","additions":6,"deletions":38,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-#define G_UNICODE_DATA_VERSION \"15.0.0\"\n+#define G_UNICODE_DATA_VERSION \"15.1.0\"\n@@ -21,1 +21,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -151,1 +151,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -281,1 +281,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -411,1 +411,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -541,1 +541,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -671,3 +671,3 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n+    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n+    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n@@ -781,1 +781,1 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_NUMERIC,\n@@ -801,1 +801,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -931,1 +931,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -1003,1 +1003,1 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n@@ -1044,1 +1044,1 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -1061,1 +1061,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -1191,1 +1191,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -1321,1 +1321,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -1451,1 +1451,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -1581,1 +1581,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -1711,1 +1711,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n@@ -1840,1 +1840,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_BEFORE,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_BEFORE,\n@@ -1968,1 +1968,1 @@\n-     G_UNICODE_BREAK_COMPLEX_CONTEXT, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n+    G_UNICODE_BREAK_COMPLEX_CONTEXT, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n@@ -2098,1 +2098,1 @@\n-     G_UNICODE_BREAK_HANGUL_L_JAMO, G_UNICODE_BREAK_HANGUL_L_JAMO,\n+    G_UNICODE_BREAK_HANGUL_L_JAMO, G_UNICODE_BREAK_HANGUL_L_JAMO,\n@@ -2228,1 +2228,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -2358,1 +2358,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -2488,1 +2488,1 @@\n-     G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_ALPHABETIC,\n@@ -2618,1 +2618,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -2748,1 +2748,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -2878,1 +2878,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -3008,1 +3008,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -3138,1 +3138,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -3268,1 +3268,0 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -3270,24 +3269,0 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -3295,0 +3270,17 @@\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -3302,5 +3294,4 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_VIRAMA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN,\n@@ -3308,6 +3299,7 @@\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_AFTER,\n-    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_AFTER,\n@@ -3315,5 +3307,5 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -3324,5 +3316,5 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -3362,20 +3354,19 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n@@ -3388,0 +3379,1 @@\n+    G_UNICODE_BREAK_VIRAMA_FINAL, G_UNICODE_BREAK_VIRAMA_FINAL,\n@@ -3396,1 +3388,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -3525,1 +3517,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -3655,1 +3647,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -3785,1 +3777,1 @@\n-     G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n@@ -3904,1 +3896,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -4034,1 +4026,1 @@\n-     G_UNICODE_BREAK_AMBIGUOUS, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_AMBIGUOUS, G_UNICODE_BREAK_ALPHABETIC,\n@@ -4164,1 +4156,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -4294,1 +4286,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -4424,1 +4416,1 @@\n-     G_UNICODE_BREAK_AMBIGUOUS, G_UNICODE_BREAK_AMBIGUOUS,\n+    G_UNICODE_BREAK_AMBIGUOUS, G_UNICODE_BREAK_AMBIGUOUS,\n@@ -4554,1 +4546,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -4684,1 +4676,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -4814,1 +4806,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -4944,1 +4936,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -5074,1 +5066,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -5204,1 +5196,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -5334,1 +5326,1 @@\n-     G_UNICODE_BREAK_QUOTATION, G_UNICODE_BREAK_QUOTATION,\n+    G_UNICODE_BREAK_QUOTATION, G_UNICODE_BREAK_QUOTATION,\n@@ -5458,1 +5450,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -5584,2 +5576,2 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC\n@@ -5588,1 +5580,1 @@\n-     G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_CLOSE_PUNCTUATION,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_CLOSE_PUNCTUATION,\n@@ -5739,1 +5731,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -5858,1 +5850,1 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -5877,1 +5869,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -6007,1 +5999,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -6137,1 +6129,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -6267,1 +6259,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -6397,1 +6389,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -6526,1 +6518,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -6656,1 +6648,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -6785,1 +6777,1 @@\n-     G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n+    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n@@ -6850,25 +6842,17 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -6881,12 +6865,13 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n+    G_UNICODE_BREAK_VIRAMA, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -6895,1 +6880,1 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -6914,21 +6899,21 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -6945,17 +6930,15 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n-    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n@@ -7011,0 +6994,1 @@\n+    G_UNICODE_BREAK_COMPLEX_CONTEXT, G_UNICODE_BREAK_UNKNOWN,\n@@ -7022,1 +7006,1 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n@@ -7025,1 +7009,0 @@\n-    G_UNICODE_BREAK_COMPLEX_CONTEXT, G_UNICODE_BREAK_ALPHABETIC,\n@@ -7031,0 +7014,1 @@\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -7033,2 +7017,1 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AFTER,\n-    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_ALPHABETIC,\n@@ -7044,1 +7027,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n@@ -7174,1 +7157,1 @@\n-     G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -7304,1 +7287,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -7434,1 +7417,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -7564,1 +7547,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -7694,1 +7677,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -7824,1 +7807,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -7954,1 +7937,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8084,1 +8067,1 @@\n-     G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8214,1 +8197,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8344,1 +8327,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8474,1 +8457,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8604,1 +8587,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8734,1 +8717,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8864,1 +8847,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -8994,1 +8977,1 @@\n-     G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -9124,1 +9107,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -9254,1 +9237,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -9384,1 +9367,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -9514,1 +9497,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -9644,1 +9627,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -9774,1 +9757,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -9904,1 +9887,1 @@\n-     G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10034,1 +10017,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10164,1 +10147,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10294,1 +10277,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10424,1 +10407,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10554,1 +10537,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10684,1 +10667,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10814,1 +10797,1 @@\n-     G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -10944,1 +10927,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11074,1 +11057,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11204,1 +11187,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11334,1 +11317,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11464,1 +11447,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11594,1 +11577,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11724,1 +11707,1 @@\n-     G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11854,1 +11837,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -11984,1 +11967,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -12114,1 +12097,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -12244,1 +12227,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -12374,1 +12357,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -12504,1 +12487,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -12634,1 +12617,1 @@\n-     G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -12764,1 +12747,1 @@\n-     G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n+    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE, G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,\n@@ -12894,1 +12877,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -13024,1 +13007,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -13154,1 +13137,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -13284,1 +13267,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_EXCLAMATION,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_EXCLAMATION,\n@@ -13419,1 +13402,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -13549,1 +13532,1 @@\n-     G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n@@ -13679,1 +13662,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -13809,1 +13792,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -13939,1 +13922,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -14069,1 +14052,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -14199,1 +14182,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -14329,1 +14312,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -14459,1 +14442,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -14589,1 +14572,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -14717,1 +14700,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -14846,1 +14829,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -14976,1 +14959,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -15106,1 +15089,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -15236,1 +15219,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -15341,42 +15324,7 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN\n-  },\n-  { \/* page 272, index 118 *\/\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -15394,0 +15342,7 @@\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN\n+  },\n+  { \/* page 272, index 118 *\/\n@@ -15395,0 +15350,19 @@\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AKSARA_PRE_BASE,\n+    G_UNICODE_BREAK_AKSARA_PRE_BASE, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n@@ -15401,24 +15375,5 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AFTER,\n-    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_VIRAMA, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_UNKNOWN,\n@@ -15426,0 +15381,19 @@\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -15429,1 +15403,1 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_NON_BREAKING_GLUE,\n@@ -15460,1 +15434,1 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_NUMERIC,\n@@ -15468,1 +15442,1 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_UNKNOWN,\n@@ -15496,1 +15470,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -15624,1 +15598,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -15753,1 +15727,0 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -15755,27 +15728,19 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n@@ -15783,1 +15748,1 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AFTER,\n@@ -15791,1 +15756,1 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_VIRAMA,\n@@ -15793,1 +15758,1 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_UNKNOWN,\n@@ -15799,3 +15764,3 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n@@ -15883,1 +15848,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -16012,1 +15977,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -16140,1 +16105,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -16268,1 +16233,1 @@\n-     G_UNICODE_BREAK_COMPLEX_CONTEXT, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n+    G_UNICODE_BREAK_COMPLEX_CONTEXT, G_UNICODE_BREAK_COMPLEX_CONTEXT,\n@@ -16398,1 +16363,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -16528,24 +16493,16 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n@@ -16559,2 +16516,2 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_VIRAMA, G_UNICODE_BREAK_AKSARA_PRE_BASE,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AKSARA_PRE_BASE,\n@@ -16567,6 +16524,6 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_UNKNOWN,\n@@ -16658,1 +16615,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -16786,1 +16743,1 @@\n-     G_UNICODE_BREAK_BEFORE, G_UNICODE_BREAK_BEFORE, G_UNICODE_BREAK_BEFORE,\n+    G_UNICODE_BREAK_BEFORE, G_UNICODE_BREAK_BEFORE, G_UNICODE_BREAK_BEFORE,\n@@ -16914,1 +16871,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -17043,1 +17000,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -17173,1 +17130,0 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -17285,10 +17241,11 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -17296,2 +17253,2 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AFTER,\n+    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -17300,1 +17257,1 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN\n+    G_UNICODE_BREAK_UNKNOWN\n@@ -17303,26 +17260,18 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_COMBINING_MARK,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_AKSARA_PRE_BASE, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n+    G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA, G_UNICODE_BREAK_AKSARA,\n@@ -17336,2 +17285,1 @@\n-    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_AFTER,\n-    G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_VIRAMA, G_UNICODE_BREAK_AFTER, G_UNICODE_BREAK_AFTER,\n@@ -17343,6 +17291,6 @@\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_NUMERIC, G_UNICODE_BREAK_NUMERIC,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_AKSARA_START,\n+    G_UNICODE_BREAK_AKSARA_START, G_UNICODE_BREAK_UNKNOWN,\n@@ -17391,1 +17339,1 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n@@ -17399,0 +17347,1 @@\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n@@ -17413,1 +17362,0 @@\n-    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_POSTFIX,\n@@ -17415,1 +17363,1 @@\n-    G_UNICODE_BREAK_POSTFIX, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_POSTFIX, G_UNICODE_BREAK_POSTFIX,\n@@ -17424,0 +17372,1 @@\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_UNKNOWN,\n@@ -17429,2 +17378,1 @@\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n-    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AFTER\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_AFTER\n@@ -17433,1 +17381,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -17563,1 +17511,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -17692,1 +17640,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -17822,1 +17770,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -17952,1 +17900,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -18082,1 +18030,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -18212,1 +18160,0 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -18236,0 +18183,1 @@\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_OPEN_PUNCTUATION,\n@@ -18342,1 +18290,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -18472,1 +18420,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -18602,1 +18550,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -18731,1 +18679,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -18861,1 +18809,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -18991,1 +18939,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -19121,1 +19069,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -19251,1 +19199,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -19381,1 +19329,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -19511,1 +19459,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -19641,1 +19589,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -19774,1 +19722,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -19904,1 +19852,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -20034,1 +19982,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -20164,1 +20112,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -20294,1 +20242,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -20424,1 +20372,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -20554,1 +20502,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -20684,1 +20632,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -20814,1 +20762,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -20944,1 +20892,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -21074,1 +21022,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -21204,1 +21152,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -21333,1 +21281,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -21463,1 +21411,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -21593,1 +21541,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -21723,1 +21671,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -21853,1 +21801,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -21983,1 +21931,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -22113,1 +22061,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -22243,1 +22191,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -22373,1 +22321,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_UNKNOWN,\n@@ -22503,1 +22451,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_ALPHABETIC,\n@@ -22633,1 +22581,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -22763,1 +22711,1 @@\n-     G_UNICODE_BREAK_AMBIGUOUS, G_UNICODE_BREAK_AMBIGUOUS,\n+    G_UNICODE_BREAK_AMBIGUOUS, G_UNICODE_BREAK_AMBIGUOUS,\n@@ -22893,1 +22841,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -23023,1 +22971,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -23153,1 +23101,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -23283,1 +23231,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -23413,1 +23361,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -23543,1 +23491,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -23673,1 +23621,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -23803,1 +23751,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -23933,1 +23881,1 @@\n-     G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n+    G_UNICODE_BREAK_ALPHABETIC, G_UNICODE_BREAK_ALPHABETIC,\n@@ -24063,1 +24011,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -24193,1 +24141,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -24323,1 +24271,1 @@\n-     G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n+    G_UNICODE_BREAK_IDEOGRAPHIC, G_UNICODE_BREAK_IDEOGRAPHIC,\n@@ -24453,1 +24401,1 @@\n-     G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_UNKNOWN, G_UNICODE_BREAK_COMBINING_MARK,\n@@ -24583,1 +24531,1 @@\n-     G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n+    G_UNICODE_BREAK_COMBINING_MARK, G_UNICODE_BREAK_COMBINING_MARK,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunibreak.h","additions":474,"deletions":526,"binary":false,"changes":1000,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-#define G_UNICODE_DATA_VERSION \"15.0.0\"\n+#define G_UNICODE_DATA_VERSION \"15.1.0\"\n@@ -19,1 +19,1 @@\n-     G_UNICODE_CONTROL, G_UNICODE_CONTROL, G_UNICODE_CONTROL,\n+    G_UNICODE_CONTROL, G_UNICODE_CONTROL, G_UNICODE_CONTROL,\n@@ -137,1 +137,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -267,1 +267,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -397,1 +397,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -525,1 +525,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n@@ -655,1 +655,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -775,1 +775,1 @@\n-     G_UNICODE_FORMAT, G_UNICODE_FORMAT, G_UNICODE_FORMAT, G_UNICODE_FORMAT,\n+    G_UNICODE_FORMAT, G_UNICODE_FORMAT, G_UNICODE_FORMAT, G_UNICODE_FORMAT,\n@@ -880,1 +880,1 @@\n-     G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n+    G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n@@ -981,1 +981,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -1087,1 +1087,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -1186,1 +1186,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_NON_SPACING_MARK,\n@@ -1282,1 +1282,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_NON_SPACING_MARK, G_UNICODE_SPACING_MARK,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_NON_SPACING_MARK, G_UNICODE_SPACING_MARK,\n@@ -1375,1 +1375,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_SPACING_MARK,\n@@ -1471,1 +1471,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -1564,1 +1564,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -1662,1 +1662,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -1771,1 +1771,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -1885,1 +1885,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -1973,1 +1973,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -2078,1 +2078,1 @@\n-     G_UNICODE_DASH_PUNCTUATION, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_DASH_PUNCTUATION, G_UNICODE_OTHER_LETTER,\n@@ -2166,1 +2166,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -2256,1 +2256,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -2352,1 +2352,1 @@\n-     G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n+    G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n@@ -2444,1 +2444,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -2537,1 +2537,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -2642,1 +2642,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -2744,1 +2744,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -2855,1 +2855,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -2985,1 +2985,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -3115,1 +3115,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -3241,1 +3241,1 @@\n-     G_UNICODE_SPACE_SEPARATOR, G_UNICODE_SPACE_SEPARATOR,\n+    G_UNICODE_SPACE_SEPARATOR, G_UNICODE_SPACE_SEPARATOR,\n@@ -3356,1 +3356,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -3460,1 +3460,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -3549,1 +3549,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -3637,1 +3637,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -3725,1 +3725,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -3813,1 +3813,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -3906,1 +3906,1 @@\n-     G_UNICODE_MATH_SYMBOL, G_UNICODE_MATH_SYMBOL, G_UNICODE_MATH_SYMBOL,\n+    G_UNICODE_MATH_SYMBOL, G_UNICODE_MATH_SYMBOL, G_UNICODE_MATH_SYMBOL,\n@@ -3999,1 +3999,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -4087,1 +4087,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n@@ -4216,1 +4216,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -4316,1 +4316,1 @@\n-     G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n+    G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n@@ -4419,1 +4419,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -4503,2 +4503,2 @@\n-    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n-    G_UNICODE_UNASSIGNED\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL\n@@ -4507,1 +4507,1 @@\n-     G_UNICODE_SPACE_SEPARATOR, G_UNICODE_OTHER_PUNCTUATION,\n+    G_UNICODE_SPACE_SEPARATOR, G_UNICODE_OTHER_PUNCTUATION,\n@@ -4607,1 +4607,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -4686,1 +4686,1 @@\n-    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_SYMBOL,\n@@ -4695,1 +4695,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -4783,1 +4783,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -4871,1 +4871,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -4959,1 +4959,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -5048,1 +5048,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -5157,1 +5157,1 @@\n-     G_UNICODE_MODIFIER_SYMBOL, G_UNICODE_MODIFIER_SYMBOL,\n+    G_UNICODE_MODIFIER_SYMBOL, G_UNICODE_MODIFIER_SYMBOL,\n@@ -5281,1 +5281,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -5378,1 +5378,1 @@\n-     G_UNICODE_DECIMAL_NUMBER, G_UNICODE_DECIMAL_NUMBER,\n+    G_UNICODE_DECIMAL_NUMBER, G_UNICODE_DECIMAL_NUMBER,\n@@ -5481,1 +5481,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -5580,1 +5580,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -5694,1 +5694,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -5782,1 +5782,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -5870,1 +5870,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -5963,1 +5963,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -6052,1 +6052,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -6156,1 +6156,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_PUNCTUATION,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_PUNCTUATION,\n@@ -6263,1 +6263,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -6351,1 +6351,1 @@\n-     G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n+    G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n@@ -6447,1 +6447,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -6535,1 +6535,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -6625,1 +6625,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n@@ -6739,1 +6739,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -6840,1 +6840,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -6937,1 +6937,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -7025,1 +7025,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -7113,1 +7113,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_NON_SPACING_MARK,\n@@ -7206,1 +7206,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -7296,1 +7296,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -7401,1 +7401,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -7491,1 +7491,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -7579,1 +7579,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -7671,1 +7671,1 @@\n-     G_UNICODE_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -7769,1 +7769,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -7870,1 +7870,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -7965,1 +7965,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -8056,1 +8056,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -8154,1 +8154,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -8248,1 +8248,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -8346,1 +8346,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -8438,1 +8438,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -8540,1 +8540,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -8632,1 +8632,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_NON_SPACING_MARK,\n@@ -8731,1 +8731,1 @@\n-     G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n+    G_UNICODE_OTHER_PUNCTUATION, G_UNICODE_OTHER_PUNCTUATION,\n@@ -8820,1 +8820,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -8919,1 +8919,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -9012,1 +9012,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -9101,1 +9101,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -9195,1 +9195,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -9283,1 +9283,1 @@\n-     G_UNICODE_LETTER_NUMBER, G_UNICODE_LETTER_NUMBER,\n+    G_UNICODE_LETTER_NUMBER, G_UNICODE_LETTER_NUMBER,\n@@ -9390,1 +9390,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -9478,1 +9478,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -9566,1 +9566,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -9655,1 +9655,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -9743,1 +9743,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -9835,1 +9835,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -9927,1 +9927,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -10026,1 +10026,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -10117,1 +10117,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -10205,1 +10205,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -10293,1 +10293,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -10381,1 +10381,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -10471,1 +10471,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -10559,1 +10559,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -10647,1 +10647,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -10735,1 +10735,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -10834,1 +10834,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -10922,1 +10922,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -11014,1 +11014,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -11102,1 +11102,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -11190,1 +11190,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n@@ -11319,1 +11319,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -11448,1 +11448,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -11578,1 +11578,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -11708,1 +11708,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -11819,1 +11819,1 @@\n-     G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n+    G_UNICODE_LOWERCASE_LETTER, G_UNICODE_LOWERCASE_LETTER,\n@@ -11913,1 +11913,1 @@\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -12017,1 +12017,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -12108,1 +12108,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -12198,1 +12198,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -12288,1 +12288,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -12376,1 +12376,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -12465,1 +12465,1 @@\n-     G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n+    G_UNICODE_UPPERCASE_LETTER, G_UNICODE_UPPERCASE_LETTER,\n@@ -12567,1 +12567,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -12655,1 +12655,1 @@\n-     G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_NUMBER, G_UNICODE_OTHER_NUMBER,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_OTHER_NUMBER, G_UNICODE_OTHER_NUMBER,\n@@ -12743,1 +12743,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -12831,1 +12831,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -12919,1 +12919,1 @@\n-     G_UNICODE_OTHER_NUMBER, G_UNICODE_OTHER_NUMBER, G_UNICODE_OTHER_NUMBER,\n+    G_UNICODE_OTHER_NUMBER, G_UNICODE_OTHER_NUMBER, G_UNICODE_OTHER_NUMBER,\n@@ -13007,1 +13007,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -13095,1 +13095,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -13184,1 +13184,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -13272,1 +13272,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -13360,1 +13360,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -13448,1 +13448,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -13536,1 +13536,1 @@\n-     G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n+    G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL, G_UNICODE_OTHER_SYMBOL,\n@@ -13625,1 +13625,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -13713,1 +13713,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -13801,1 +13801,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -13889,1 +13889,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -13977,1 +13977,1 @@\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -14057,0 +14057,88 @@\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER\n+  },\n+  { \/* page 750, index 144 *\/\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n+    G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED, G_UNICODE_UNASSIGNED,\n@@ -14064,2 +14152,2 @@\n-  { \/* page 762, index 144 *\/\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+  { \/* page 762, index 145 *\/\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -14152,2 +14240,2 @@\n-  { \/* page 787, index 145 *\/\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+  { \/* page 787, index 146 *\/\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -14240,2 +14328,2 @@\n-  { \/* page 803, index 146 *\/\n-     G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n+  { \/* page 803, index 147 *\/\n+    G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER, G_UNICODE_OTHER_LETTER,\n@@ -14328,2 +14416,2 @@\n-  { \/* page 3584, index 147 *\/\n-     G_UNICODE_UNASSIGNED, G_UNICODE_FORMAT, G_UNICODE_UNASSIGNED,\n+  { \/* page 3584, index 148 *\/\n+    G_UNICODE_UNASSIGNED, G_UNICODE_FORMAT, G_UNICODE_UNASSIGNED,\n@@ -14408,2 +14496,2 @@\n-  { \/* page 3585, index 148 *\/\n-     G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n+  { \/* page 3585, index 149 *\/\n+    G_UNICODE_NON_SPACING_MARK, G_UNICODE_NON_SPACING_MARK,\n@@ -14536,2 +14624,2 @@\n-  { \/* page 4095, index 149 *\/\n-     G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE,\n+  { \/* page 4095, index 150 *\/\n+    G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE,\n@@ -14624,2 +14712,2 @@\n-  { \/* page 4351, index 150 *\/\n-     G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE,\n+  { \/* page 4351, index 151 *\/\n+    G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE, G_UNICODE_PRIVATE_USE,\n@@ -15464,3 +15552,3 @@\n-  G_UNICODE_UNASSIGNED + G_UNICODE_MAX_TABLE_INDEX,\n-  G_UNICODE_UNASSIGNED + G_UNICODE_MAX_TABLE_INDEX,\n-  G_UNICODE_UNASSIGNED + G_UNICODE_MAX_TABLE_INDEX,\n+  G_UNICODE_OTHER_LETTER + G_UNICODE_MAX_TABLE_INDEX,\n+  G_UNICODE_OTHER_LETTER + G_UNICODE_MAX_TABLE_INDEX,\n+  144 \/* page 750 *\/,\n@@ -15478,1 +15566,1 @@\n-  144 \/* page 762 *\/,\n+  145 \/* page 762 *\/,\n@@ -15503,1 +15591,1 @@\n-  145 \/* page 787 *\/,\n+  146 \/* page 787 *\/,\n@@ -15519,1 +15607,1 @@\n-  146 \/* page 803 *\/\n+  147 \/* page 803 *\/\n@@ -15524,2 +15612,2 @@\n-  147 \/* page 3584 *\/,\n-  148 \/* page 3585 *\/,\n+  148 \/* page 3584 *\/,\n+  149 \/* page 3585 *\/,\n@@ -16035,1 +16123,1 @@\n-  149 \/* page 4095 *\/,\n+  150 \/* page 4095 *\/,\n@@ -16291,1 +16379,1 @@\n-  150 \/* page 4351 *\/\n+  151 \/* page 4351 *\/\n@@ -16296,1 +16384,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16327,1 +16415,1 @@\n-     0x0101, 0x0100, 0x0103, 0x0102, 0x0105, 0x0104, 0x0107, 0x0106, 0x0109,\n+    0x0101, 0x0100, 0x0103, 0x0102, 0x0105, 0x0104, 0x0107, 0x0106, 0x0109,\n@@ -16358,1 +16446,1 @@\n-     0x0201, 0x0200, 0x0203, 0x0202, 0x0205, 0x0204, 0x0207, 0x0206, 0x0209,\n+    0x0201, 0x0200, 0x0203, 0x0202, 0x0205, 0x0204, 0x0207, 0x0206, 0x0209,\n@@ -16389,1 +16477,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16420,1 +16508,1 @@\n-     0x0450, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457, 0x0458,\n+    0x0450, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457, 0x0458,\n@@ -16451,1 +16539,1 @@\n-     0x0501, 0x0500, 0x0503, 0x0502, 0x0505, 0x0504, 0x0507, 0x0506, 0x0509,\n+    0x0501, 0x0500, 0x0503, 0x0502, 0x0505, 0x0504, 0x0507, 0x0506, 0x0509,\n@@ -16482,1 +16570,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16513,1 +16601,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16544,1 +16632,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16575,1 +16663,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16606,1 +16694,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16637,1 +16725,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16668,1 +16756,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16699,1 +16787,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16730,1 +16818,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16761,1 +16849,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16792,1 +16880,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16823,1 +16911,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16854,1 +16942,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16885,1 +16973,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16916,1 +17004,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16947,1 +17035,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -16978,1 +17066,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17009,1 +17097,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17040,1 +17128,1 @@\n-     0x1e01, 0x1e00, 0x1e03, 0x1e02, 0x1e05, 0x1e04, 0x1e07, 0x1e06, 0x1e09,\n+    0x1e01, 0x1e00, 0x1e03, 0x1e02, 0x1e05, 0x1e04, 0x1e07, 0x1e06, 0x1e09,\n@@ -17071,1 +17159,1 @@\n-     0x1f08, 0x1f09, 0x1f0a, 0x1f0b, 0x1f0c, 0x1f0d, 0x1f0e, 0x1f0f, 0x1f00,\n+    0x1f08, 0x1f09, 0x1f0a, 0x1f0b, 0x1f0c, 0x1f0d, 0x1f0e, 0x1f0f, 0x1f00,\n@@ -17106,1 +17194,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17137,1 +17225,1 @@\n-     0x2c30, 0x2c31, 0x2c32, 0x2c33, 0x2c34, 0x2c35, 0x2c36, 0x2c37, 0x2c38,\n+    0x2c30, 0x2c31, 0x2c32, 0x2c33, 0x2c34, 0x2c35, 0x2c36, 0x2c37, 0x2c38,\n@@ -17168,1 +17256,1 @@\n-     0x10a0, 0x10a1, 0x10a2, 0x10a3, 0x10a4, 0x10a5, 0x10a6, 0x10a7, 0x10a8,\n+    0x10a0, 0x10a1, 0x10a2, 0x10a3, 0x10a4, 0x10a5, 0x10a6, 0x10a7, 0x10a8,\n@@ -17199,1 +17287,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17230,1 +17318,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17261,1 +17349,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17292,1 +17380,1 @@\n-     0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008,\n+    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008,\n@@ -17323,1 +17411,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17354,1 +17442,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17385,1 +17473,1 @@\n-     0x100000f, 0x1000016, 0x100001d, 0x1000024, 0x100002d, 0x1000036,\n+    0x100000f, 0x1000016, 0x100001d, 0x1000024, 0x100002d, 0x1000036,\n@@ -17417,1 +17505,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17448,1 +17536,1 @@\n-     0x10428, 0x10429, 0x1042a, 0x1042b, 0x1042c, 0x1042d, 0x1042e, 0x1042f,\n+    0x10428, 0x10429, 0x1042a, 0x1042b, 0x1042c, 0x1042d, 0x1042e, 0x1042f,\n@@ -17481,1 +17569,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17513,1 +17601,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17545,1 +17633,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17576,1 +17664,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17607,1 +17695,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17638,1 +17726,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17669,1 +17757,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17700,1 +17788,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17731,1 +17819,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17762,1 +17850,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17794,1 +17882,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17825,1 +17913,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17856,1 +17944,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17887,1 +17975,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17918,1 +18006,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17949,1 +18037,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -17980,1 +18068,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -18012,1 +18100,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -18043,1 +18131,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -18074,1 +18162,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -18105,1 +18193,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -18136,1 +18224,1 @@\n-     0x1e922, 0x1e923, 0x1e924, 0x1e925, 0x1e926, 0x1e927, 0x1e928, 0x1e929,\n+    0x1e922, 0x1e923, 0x1e924, 0x1e925, 0x1e926, 0x1e927, 0x1e928, 0x1e929,\n@@ -18168,1 +18256,1 @@\n-     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n@@ -20235,2 +20323,1 @@\n-{0x2FF0, 0x2FFB},\n-{0x3000, 0x303E},\n+{0x2FF0, 0x303E},\n@@ -20242,1 +20329,1 @@\n-{0x31F0, 0x321E},\n+{0x31EF, 0x321E},\n@@ -20322,0 +20409,1 @@\n+{0x2EBF0, 0x2EE5D},\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunichartables.h","additions":324,"deletions":236,"binary":false,"changes":560,"status":"modified"},{"patch":"@@ -207,0 +207,5 @@\n+ * @G_UNICODE_BREAK_AKSARA: Aksara (AK). Since: 2.80\n+ * @G_UNICODE_BREAK_AKSARA_PRE_BASE (AP). Since: 2.80\n+ * @G_UNICODE_BREAK_AKSARA_START (AS). Since: 2.80\n+ * @G_UNICODE_BREAK_VIRAMA_FINAL (VF). Since: 2.80\n+ * @G_UNICODE_BREAK_VIRAMA (VI). Since: 2.80\n@@ -210,1 +215,1 @@\n- * Since new unicode versions may add new types here, applications should be ready\n+ * Since new Unicode versions may add new types here, applications should be ready\n@@ -260,1 +265,6 @@\n-  G_UNICODE_BREAK_ZERO_WIDTH_JOINER\n+  G_UNICODE_BREAK_ZERO_WIDTH_JOINER,\n+  G_UNICODE_BREAK_AKSARA,\n+  G_UNICODE_BREAK_AKSARA_PRE_BASE,\n+  G_UNICODE_BREAK_AKSARA_START,\n+  G_UNICODE_BREAK_VIRAMA_FINAL,\n+  G_UNICODE_BREAK_VIRAMA\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunicode.h","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -404,0 +404,2 @@\n+  g_return_val_if_fail (str_norm != NULL, NULL);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunicollate.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -24,1 +24,1 @@\n-     0, 0, 61, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63, 64, 0, 0, 0,\n+    0, 0, 61, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63, 64, 0, 0, 0,\n@@ -38,1 +38,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -51,1 +51,1 @@\n-     378, 379, 380, 381, 382, 0, 383, 384, 385, 386, 387, 388, 389, 0, 0, 390,\n+    378, 379, 380, 381, 382, 0, 383, 384, 385, 386, 387, 388, 389, 0, 0, 390,\n@@ -65,1 +65,1 @@\n-     0, 0, 0, 0, 0, 0, 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 0, 0, 191, 0, 90,\n+    0, 0, 0, 0, 0, 0, 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 0, 0, 191, 0, 90,\n@@ -79,1 +79,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -92,1 +92,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -105,1 +105,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -118,1 +118,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -131,1 +131,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -144,1 +144,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -157,1 +157,1 @@\n-     0, 0, 0, 0, 0, 228, 0, 229, 0, 230, 0, 231, 0, 232, 0, 0, 0, 233, 0, 0,\n+    0, 0, 0, 0, 0, 228, 0, 229, 0, 230, 0, 231, 0, 232, 0, 0, 0, 233, 0, 0,\n@@ -170,1 +170,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -183,1 +183,1 @@\n-     108, 109, 249, 250, 251, 252, 253, 254, 110, 111, 255, 256, 257, 258,\n+    108, 109, 249, 250, 251, 252, 253, 254, 110, 111, 255, 256, 257, 258,\n@@ -198,1 +198,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -211,1 +211,1 @@\n-     0, 0, 0, 297, 0, 0, 0, 0, 298, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 297, 0, 0, 0, 0, 298, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -225,1 +225,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -239,1 +239,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -252,1 +252,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -265,1 +265,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -278,1 +278,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -291,1 +291,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -304,1 +304,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunicomp.h","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -22,37 +22,0 @@\n-\/**\n- * SECTION:unicode\n- * @Title: Unicode Manipulation\n- * @Short_description: functions operating on Unicode characters and\n- *     UTF-8 strings\n- * @See_also: g_locale_to_utf8(), g_locale_from_utf8()\n- *\n- * This section describes a number of functions for dealing with\n- * Unicode characters and strings. There are analogues of the\n- * traditional `ctype.h` character classification and case conversion\n- * functions, UTF-8 analogues of some string utility functions,\n- * functions to perform normalization, case conversion and collation\n- * on UTF-8 strings and finally functions to convert between the UTF-8,\n- * UTF-16 and UCS-4 encodings of Unicode.\n- *\n- * The implementations of the Unicode functions in GLib are based\n- * on the Unicode Character Data tables, which are available from\n- * [www.unicode.org](http:\/\/www.unicode.org\/).\n- *\n- *  * Unicode 4.0 was added in GLib 2.8\n- *  * Unicode 4.1 was added in GLib 2.10\n- *  * Unicode 5.0 was added in GLib 2.12\n- *  * Unicode 5.1 was added in GLib 2.16.3\n- *  * Unicode 6.0 was added in GLib 2.30\n- *  * Unicode 6.1 was added in GLib 2.32\n- *  * Unicode 6.2 was added in GLib 2.36\n- *  * Unicode 6.3 was added in GLib 2.40\n- *  * Unicode 7.0 was added in GLib 2.42\n- *  * Unicode 8.0 was added in GLib 2.48\n- *  * Unicode 9.0 was added in GLib 2.50.1\n- *  * Unicode 10.0 was added in GLib 2.54\n- *  * Unicode 11.10 was added in GLib 2.58\n- *  * Unicode 12.0 was added in GLib 2.62\n- *  * Unicode 12.1 was added in GLib 2.62\n- *  * Unicode 13.0 was added in GLib 2.66\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunidecomp.c","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-     230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230,\n+    230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230,\n@@ -34,1 +34,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -47,1 +47,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -61,1 +61,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 230, 230, 230, 230,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 230, 230, 230, 230,\n@@ -75,1 +75,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0,\n@@ -89,1 +89,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230,\n@@ -104,1 +104,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -117,1 +117,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -130,1 +130,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -143,1 +143,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -156,1 +156,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -169,1 +169,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -182,1 +182,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -196,1 +196,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -209,1 +209,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -222,1 +222,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0,\n@@ -235,1 +235,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -248,1 +248,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -261,1 +261,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230,\n@@ -275,1 +275,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -288,1 +288,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -302,1 +302,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -317,1 +317,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -331,1 +331,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -344,1 +344,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -358,1 +358,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -371,1 +371,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -385,1 +385,1 @@\n-     0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -399,1 +399,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -412,1 +412,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -425,1 +425,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -438,1 +438,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -451,1 +451,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -465,1 +465,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -478,1 +478,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -491,1 +491,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -504,1 +504,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 230, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 230, 0, 0, 0, 0, 0, 0, 0,\n@@ -517,1 +517,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -530,1 +530,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -543,1 +543,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -557,1 +557,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -570,1 +570,1 @@\n-     230, 230, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    230, 230, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -583,1 +583,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -596,1 +596,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -609,1 +609,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -622,1 +622,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -635,1 +635,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -648,1 +648,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -661,1 +661,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -674,1 +674,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -687,1 +687,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -700,1 +700,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -713,1 +713,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -726,1 +726,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -739,1 +739,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -752,1 +752,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -765,1 +765,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -778,1 +778,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -791,1 +791,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -805,1 +805,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -818,1 +818,1 @@\n-     230, 230, 230, 230, 230, 230, 230, 0, 230, 230, 230, 230, 230, 230, 230,\n+    230, 230, 230, 230, 230, 230, 230, 0, 230, 230, 230, 230, 230, 230, 230,\n@@ -832,1 +832,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -845,1 +845,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -858,1 +858,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -871,1 +871,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -884,1 +884,1 @@\n-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunidecomp.h","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -32,3 +32,1 @@\n- * SECTION:guri\n- * @short_description: URI-handling utilities\n- * @include: glib.h\n+ * GUri:\n@@ -36,1 +34,1 @@\n- * The #GUri type and related functions can be used to parse URIs into\n+ * The `GUri` type and related functions can be used to parse URIs into\n@@ -39,1 +37,54 @@\n- * Note that #GUri scope is to help manipulate URIs in various applications,\n+ * Since `GUri` only represents absolute URIs, all `GUri`s will have a\n+ * URI scheme, so [method@GLib.Uri.get_scheme] will always return a non-`NULL`\n+ * answer. Likewise, by definition, all URIs have a path component, so\n+ * [method@GLib.Uri.get_path] will always return a non-`NULL` string (which may\n+ * be empty).\n+ *\n+ * If the URI string has an\n+ * [‘authority’ component](https:\/\/tools.ietf.org\/html\/rfc3986#section-3) (that\n+ * is, if the scheme is followed by `:\/\/` rather than just `:`), then the\n+ * `GUri` will contain a hostname, and possibly a port and ‘userinfo’.\n+ * Additionally, depending on how the `GUri` was constructed\/parsed (for example,\n+ * using the `G_URI_FLAGS_HAS_PASSWORD` and `G_URI_FLAGS_HAS_AUTH_PARAMS` flags),\n+ * the userinfo may be split out into a username, password, and\n+ * additional authorization-related parameters.\n+ *\n+ * Normally, the components of a `GUri` will have all `%`-encoded\n+ * characters decoded. However, if you construct\/parse a `GUri` with\n+ * `G_URI_FLAGS_ENCODED`, then the `%`-encoding will be preserved instead in\n+ * the userinfo, path, and query fields (and in the host field if also\n+ * created with `G_URI_FLAGS_NON_DNS`). In particular, this is necessary if\n+ * the URI may contain binary data or non-UTF-8 text, or if decoding\n+ * the components might change the interpretation of the URI.\n+ *\n+ * For example, with the encoded flag:\n+ *\n+ * ```c\n+ * g_autoptr(GUri) uri = g_uri_parse (\"http:\/\/host\/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue\", G_URI_FLAGS_ENCODED, &err);\n+ * g_assert_cmpstr (g_uri_get_query (uri), ==, \"query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue\");\n+ * ```\n+ *\n+ * While the default `%`-decoding behaviour would give:\n+ *\n+ * ```c\n+ * g_autoptr(GUri) uri = g_uri_parse (\"http:\/\/host\/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue\", G_URI_FLAGS_NONE, &err);\n+ * g_assert_cmpstr (g_uri_get_query (uri), ==, \"query=http:\/\/host\/path?param=value\");\n+ * ```\n+ *\n+ * During decoding, if an invalid UTF-8 string is encountered, parsing will fail\n+ * with an error indicating the bad string location:\n+ *\n+ * ```c\n+ * g_autoptr(GUri) uri = g_uri_parse (\"http:\/\/host\/path?query=http%3A%2F%2Fhost%2Fpath%3Fbad%3D%00alue\", G_URI_FLAGS_NONE, &err);\n+ * g_assert_error (err, G_URI_ERROR, G_URI_ERROR_BAD_QUERY);\n+ * ```\n+ *\n+ * You should pass `G_URI_FLAGS_ENCODED` or `G_URI_FLAGS_ENCODED_QUERY` if you\n+ * need to handle that case manually. In particular, if the query string\n+ * contains `=` characters that are `%`-encoded, you should let\n+ * [func@GLib.Uri.parse_params] do the decoding once of the query.\n+ *\n+ * `GUri` is immutable once constructed, and can safely be accessed from\n+ * multiple threads. Its reference counting is atomic.\n+ *\n+ * Note that the scope of `GUri` is to help manipulate URIs in various applications,\n@@ -41,1 +92,1 @@\n- * it doesn't intend to cover web browser needs, and doesn't implement the\n+ * it doesn't intend to cover web browser needs, and doesn’t implement the\n@@ -45,1 +96,1 @@\n- * #GUri is not suitable for formatting URIs for display to the user for making\n+ * `GUri` is not suitable for formatting URIs for display to the user for making\n@@ -48,1 +99,1 @@\n- * ## Relative and absolute URIs # {#relative-absolute-uris}\n+ * ## Relative and absolute URIs\n@@ -68,1 +119,1 @@\n- * resolved relative to a base URI using g_uri_parse_relative().\n+ * resolved relative to a base URI using [method@GLib.Uri.parse_relative].\n@@ -73,1 +124,1 @@\n- * A #GUri instance is always an absolute URI. A string may be an absolute URI\n+ * A `GUri` instance is always an absolute URI. A string may be an absolute URI\n@@ -79,2 +130,2 @@\n- * The most minimalist APIs for parsing URIs are g_uri_split() and\n- * g_uri_split_with_user(). These split a URI into its component\n+ * The most minimalist APIs for parsing URIs are [func@GLib.Uri.split] and\n+ * [func@GLib.Uri.split_with_user]. These split a URI into its component\n@@ -82,4 +133,4 @@\n- * g_uri_split() treats the ‘userinfo’ component of the URI as a\n- * single element, while g_uri_split_with_user() can (depending on the\n- * #GUriFlags you pass) treat it as containing a username, password,\n- * and authentication parameters. Alternatively, g_uri_split_network()\n+ * [func@GLib.Uri.split] treats the ‘userinfo’ component of the URI as a\n+ * single element, while [func@GLib.Uri.split_with_user] can (depending on the\n+ * [flags@GLib.UriFlags] you pass) treat it as containing a username, password,\n+ * and authentication parameters. Alternatively, [func@GLib.Uri.split_network]\n@@ -90,2 +141,2 @@\n- * g_uri_parse() is similar to g_uri_split(), but instead of returning\n- * individual strings, it returns a #GUri structure (and it requires\n+ * [func@GLib.Uri.parse] is similar to [func@GLib.Uri.split], but instead of\n+ * returning individual strings, it returns a `GUri` structure (and it requires\n@@ -94,5 +145,5 @@\n- * g_uri_resolve_relative() and g_uri_parse_relative() allow you to\n- * resolve a relative URI relative to a base URI.\n- * g_uri_resolve_relative() takes two strings and returns a string,\n- * and g_uri_parse_relative() takes a #GUri and a string and returns a\n- * #GUri.\n+ * [func@GLib.Uri.resolve_relative] and [method@GLib.Uri.parse_relative] allow\n+ * you to resolve a relative URI relative to a base URI.\n+ * [func@GLib.Uri.resolve_relative] takes two strings and returns a string,\n+ * and [method@GLib.Uri.parse_relative] takes a `GUri` and a string and returns a\n+ * `GUri`.\n@@ -100,1 +151,1 @@\n- * All of the parsing functions take a #GUriFlags argument describing\n+ * All of the parsing functions take a [flags@GLib.UriFlags] argument describing\n@@ -104,1 +155,1 @@\n- * use g_uri_peek_scheme() on the URI string to check the scheme\n+ * use [func@GLib.Uri.peek_scheme] on the URI string to check the scheme\n@@ -107,3 +158,3 @@\n- * For example, you might want to use %G_URI_PARAMS_WWW_FORM when parsing the\n- * params for a web URI, so compare the result of g_uri_peek_scheme() against\n- * `http` and `https`.\n+ * For example, you might want to use `G_URI_PARAMS_WWW_FORM` when parsing the\n+ * params for a web URI, so compare the result of [func@GLib.Uri.peek_scheme]\n+ * against `http` and `https`.\n@@ -113,1 +164,1 @@\n- * g_uri_join() and g_uri_join_with_user() can be used to construct\n+ * [func@GLib.Uri.join] and [func@GLib.Uri.join_with_user] can be used to construct\n@@ -115,1 +166,1 @@\n- * inverse of g_uri_split() and g_uri_split_with_user().\n+ * inverse of [func@GLib.Uri.split] and [func@GLib.Uri.split_with_user].\n@@ -117,2 +168,2 @@\n- * Similarly, g_uri_build() and g_uri_build_with_user() can be used to\n- * construct a #GUri from a set of component strings.\n+ * Similarly, [func@GLib.Uri.build] and [func@GLib.Uri.build_with_user] can be\n+ * used to construct a `GUri` from a set of component strings.\n@@ -121,1 +172,1 @@\n- * #GUriFlags argument. In particular, it is important to keep in mind\n+ * [flags@GLib.UriFlags] argument. In particular, it is important to keep in mind\n@@ -123,1 +174,1 @@\n- * you must pass the %G_URI_FLAGS_ENCODED flag.\n+ * you must pass the `G_URI_FLAGS_ENCODED` flag.\n@@ -129,3 +180,3 @@\n- * interpretation of path separators on Windows). #GUri does not\n- * implement these rules. Use g_filename_from_uri() and\n- * g_filename_to_uri() if you want to properly convert between\n+ * interpretation of path separators on Windows). `GUri` does not\n+ * implement these rules. Use [func@GLib.filename_from_uri] and\n+ * [func@GLib.filename_to_uri] if you want to properly convert between\n@@ -137,4 +188,4 @@\n- * URIs usefully requires scheme-specific knowledge that #GUri does\n- * not have. #GUri can help with normalization if you use the various\n- * encoded #GUriFlags as well as %G_URI_FLAGS_SCHEME_NORMALIZE however\n- * it is not comprehensive.\n+ * URIs usefully requires scheme-specific knowledge that `GUri` does\n+ * not have. `GUri` can help with normalization if you use the various\n+ * encoded [flags@GLib.UriFlags] as well as `G_URI_FLAGS_SCHEME_NORMALIZE`\n+ * however it is not comprehensive.\n@@ -147,60 +198,0 @@\n-\n-\/**\n- * GUri:\n- *\n- * A parsed absolute URI.\n- *\n- * Since #GUri only represents absolute URIs, all #GUris will have a\n- * URI scheme, so g_uri_get_scheme() will always return a non-%NULL\n- * answer. Likewise, by definition, all URIs have a path component, so\n- * g_uri_get_path() will always return a non-%NULL string (which may be empty).\n- *\n- * If the URI string has an\n- * [‘authority’ component](https:\/\/tools.ietf.org\/html\/rfc3986#section-3) (that\n- * is, if the scheme is followed by `:\/\/` rather than just `:`), then the\n- * #GUri will contain a hostname, and possibly a port and ‘userinfo’.\n- * Additionally, depending on how the #GUri was constructed\/parsed (for example,\n- * using the %G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS flags),\n- * the userinfo may be split out into a username, password, and\n- * additional authorization-related parameters.\n- *\n- * Normally, the components of a #GUri will have all `%`-encoded\n- * characters decoded. However, if you construct\/parse a #GUri with\n- * %G_URI_FLAGS_ENCODED, then the `%`-encoding will be preserved instead in\n- * the userinfo, path, and query fields (and in the host field if also\n- * created with %G_URI_FLAGS_NON_DNS). In particular, this is necessary if\n- * the URI may contain binary data or non-UTF-8 text, or if decoding\n- * the components might change the interpretation of the URI.\n- *\n- * For example, with the encoded flag:\n- *\n- * |[<!-- language=\"C\" -->\n- *   g_autoptr(GUri) uri = g_uri_parse (\"http:\/\/host\/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue\", G_URI_FLAGS_ENCODED, &err);\n- *   g_assert_cmpstr (g_uri_get_query (uri), ==, \"query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue\");\n- * ]|\n- *\n- * While the default `%`-decoding behaviour would give:\n- *\n- * |[<!-- language=\"C\" -->\n- *   g_autoptr(GUri) uri = g_uri_parse (\"http:\/\/host\/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue\", G_URI_FLAGS_NONE, &err);\n- *   g_assert_cmpstr (g_uri_get_query (uri), ==, \"query=http:\/\/host\/path?param=value\");\n- * ]|\n- *\n- * During decoding, if an invalid UTF-8 string is encountered, parsing will fail\n- * with an error indicating the bad string location:\n- *\n- * |[<!-- language=\"C\" -->\n- *   g_autoptr(GUri) uri = g_uri_parse (\"http:\/\/host\/path?query=http%3A%2F%2Fhost%2Fpath%3Fbad%3D%00alue\", G_URI_FLAGS_NONE, &err);\n- *   g_assert_error (err, G_URI_ERROR, G_URI_ERROR_BAD_QUERY);\n- * ]|\n- *\n- * You should pass %G_URI_FLAGS_ENCODED or %G_URI_FLAGS_ENCODED_QUERY if you\n- * need to handle that case manually. In particular, if the query string\n- * contains `=` characters that are `%`-encoded, you should let\n- * g_uri_parse_params() do the decoding once of the query.\n- *\n- * #GUri is immutable once constructed, and can safely be accessed from\n- * multiple threads. Its reference counting is atomic.\n- *\n- * Since: 2.66\n- *\/\n@@ -1075,1 +1066,1 @@\n- * [absolute or relative URI][relative-absolute-uris]) according to @flags, and\n+ * [absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and\n@@ -1142,1 +1133,1 @@\n- * [absolute or relative URI][relative-absolute-uris]) according to @flags, and\n+ * [absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and\n@@ -1194,1 +1185,1 @@\n- * Parses @uri_string (which must be an [absolute URI][relative-absolute-uris])\n+ * Parses @uri_string (which must be an [absolute URI](#relative-and-absolute-uris))\n@@ -1263,1 +1254,1 @@\n- * [absolute URI][relative-absolute-uris], i.e. it does not need to be resolved\n+ * [absolute URI](#relative-and-absolute-uris), i.e. it does not need to be resolved\n@@ -1401,1 +1392,1 @@\n- * valid [absolute URI][relative-absolute-uris], it will be discarded, and an\n+ * valid [absolute URI](#relative-and-absolute-uris), it will be discarded, and an\n@@ -1427,1 +1418,1 @@\n- * [relative URI][relative-absolute-uris], resolves it relative to @base_uri.\n+ * [relative URI](#relative-and-absolute-uris), resolves it relative to @base_uri.\n@@ -1558,1 +1549,1 @@\n- * [relative URI][relative-absolute-uris], resolves it relative to\n+ * [relative URI](#relative-and-absolute-uris), resolves it relative to\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/guri.c","additions":99,"deletions":108,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -82,8 +82,0 @@\n-\/**\n- * SECTION:misc_utils\n- * @title: Miscellaneous Utility Functions\n- * @short_description: a selection of portable utility functions\n- *\n- * These are portable utility functions.\n- *\/\n-\n@@ -674,1 +666,1 @@\n-  if (g_once_init_enter (&entry))\n+  if (g_once_init_enter_pointer (&entry))\n@@ -683,1 +675,1 @@\n-        gchar *logname;\n+        const char *logname;\n@@ -688,1 +680,1 @@\n-        \/* This reurns the maximum length *\/\n+        \/* This returns the maximum length *\/\n@@ -697,1 +689,1 @@\n-        logname = (gchar *) g_getenv (\"LOGNAME\");\n+        logname = g_getenv (\"LOGNAME\");\n@@ -798,1 +790,1 @@\n-      g_once_init_leave (&entry, &e);\n+      g_once_init_leave_pointer (&entry, &e);\n@@ -1076,1 +1068,1 @@\n-  if (g_once_init_enter (&hostname))\n+  if (g_once_init_enter_pointer (&hostname))\n@@ -1133,1 +1125,1 @@\n-      g_once_init_leave (&hostname, failed ? g_strdup (\"localhost\") : utmp);\n+      g_once_init_leave_pointer (&hostname, failed ? g_strdup (\"localhost\") : utmp);\n@@ -1139,1 +1131,0 @@\n-G_LOCK_DEFINE_STATIC (g_prgname);\n@@ -1161,7 +1152,1 @@\n-  const gchar* retval;\n-\n-  G_LOCK (g_prgname);\n-  retval = g_prgname;\n-  G_UNLOCK (g_prgname);\n-\n-  return retval;\n+  return g_atomic_pointer_get (&g_prgname);\n@@ -1190,4 +1175,21 @@\n-  GQuark qprgname = g_quark_from_string (prgname);\n-  G_LOCK (g_prgname);\n-  g_prgname = g_quark_to_string (qprgname);\n-  G_UNLOCK (g_prgname);\n+  prgname = g_intern_string (prgname);\n+  g_atomic_pointer_set (&g_prgname, prgname);\n+}\n+\n+\/**\n+ * g_set_prgname_once:\n+ * @prgname: the name of the program.\n+ *\n+ * If g_get_prgname() is not set, this is the same as setting\n+ * the name via g_set_prgname() and %TRUE is returned. Otherwise,\n+ * does nothing and returns %FALSE. This is thread-safe.\n+ *\n+ * Returns: whether g_prgname was initialized by the call.\n+ *\/\n+gboolean\n+g_set_prgname_once (const gchar *prgname)\n+{\n+  \/* if @prgname is NULL, then this has the same effect as calling\n+   * (g_get_prgname()==NULL). *\/\n+  prgname = g_intern_string (prgname);\n+  return g_atomic_pointer_compare_and_exchange (&g_prgname, NULL, prgname);\n@@ -1196,1 +1198,0 @@\n-G_LOCK_DEFINE_STATIC (g_application_name);\n@@ -1218,1 +1219,1 @@\n-  gchar* retval;\n+  const char *retval;\n@@ -1220,3 +1221,1 @@\n-  G_LOCK (g_application_name);\n-  retval = g_application_name;\n-  G_UNLOCK (g_application_name);\n+  retval = g_atomic_pointer_get (&g_application_name);\n@@ -1224,2 +1223,2 @@\n-  if (retval == NULL)\n-    return g_get_prgname ();\n+  if (retval)\n+    return retval;\n@@ -1227,1 +1226,1 @@\n-  return retval;\n+  return g_get_prgname ();\n@@ -1251,1 +1250,1 @@\n-  gboolean already_set = FALSE;\n+  char *name;\n@@ -1253,6 +1252,3 @@\n-  G_LOCK (g_application_name);\n-  if (g_application_name)\n-    already_set = TRUE;\n-  else\n-    g_application_name = g_strdup (application_name);\n-  G_UNLOCK (g_application_name);\n+  g_return_if_fail (application_name);\n+\n+  name = g_strdup (application_name);\n@@ -1260,2 +1256,5 @@\n-  if (already_set)\n-    g_warning (\"g_set_application_name() called multiple times\");\n+  if (!g_atomic_pointer_compare_and_exchange (&g_application_name, NULL, name))\n+    {\n+      g_warning (\"g_set_application_name() called multiple times\");\n+      g_free (name);\n+    }\n@@ -1887,0 +1886,1 @@\n+      g_free (data_dir);\n@@ -3008,12 +3008,12 @@\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 kb\" *\/\n-      { KILOBYTE_FACTOR, N_(\"kb\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Mb\" *\/\n-      { MEGABYTE_FACTOR, N_(\"Mb\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Gb\" *\/\n-      { GIGABYTE_FACTOR, N_(\"Gb\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Tb\" *\/\n-      { TERABYTE_FACTOR, N_(\"Tb\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Pb\" *\/\n-      { PETABYTE_FACTOR, N_(\"Pb\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Eb\" *\/\n-      { EXABYTE_FACTOR,  N_(\"Eb\") }\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 kbit\" *\/\n+      { KILOBYTE_FACTOR, N_(\"kbit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Mbit\" *\/\n+      { MEGABYTE_FACTOR, N_(\"Mbit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Gbit\" *\/\n+      { GIGABYTE_FACTOR, N_(\"Gbit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Tbit\" *\/\n+      { TERABYTE_FACTOR, N_(\"Tbit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Pbit\" *\/\n+      { PETABYTE_FACTOR, N_(\"Pbit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Ebit\" *\/\n+      { EXABYTE_FACTOR,  N_(\"Ebit\") }\n@@ -3022,12 +3022,12 @@\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Kib\" *\/\n-      { KIBIBYTE_FACTOR, N_(\"Kib\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Mib\" *\/\n-      { MEBIBYTE_FACTOR, N_(\"Mib\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Gib\" *\/\n-      { GIBIBYTE_FACTOR, N_(\"Gib\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Tib\" *\/\n-      { TEBIBYTE_FACTOR, N_(\"Tib\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Pib\" *\/\n-      { PEBIBYTE_FACTOR, N_(\"Pib\") },\n-      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Eib\" *\/\n-      { EXBIBYTE_FACTOR, N_(\"Eib\") }\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Kibit\" *\/\n+      { KIBIBYTE_FACTOR, N_(\"Kibit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Mibit\" *\/\n+      { MEBIBYTE_FACTOR, N_(\"Mibit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Gibit\" *\/\n+      { GIBIBYTE_FACTOR, N_(\"Gibit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Tibit\" *\/\n+      { TEBIBYTE_FACTOR, N_(\"Tibit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Pibit\" *\/\n+      { PEBIBYTE_FACTOR, N_(\"Pibit\") },\n+      \/* Translators: A unit symbol for size formatting, showing for example: \"13.0 Eibit\" *\/\n+      { EXBIBYTE_FACTOR, N_(\"Eibit\") }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gutils.c","additions":68,"deletions":68,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+gboolean g_set_prgname_once (const gchar *prgname);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gutilsprivate.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,8 +52,0 @@\n-\/**\n- * GVariant:\n- *\n- * #GVariant is an opaque data structure and can only be accessed\n- * using the following functions.\n- *\n- * Since: 2.24\n- **\/\n@@ -646,2 +638,8 @@\n-       * details on the alignment format. *\/\n-      if (posix_memalign (&aligned_data, MAX (sizeof (void *), alignment + 1),\n+       * details on the alignment format.\n+       *\n+       * While calling posix_memalign() with aligned_size==0 is safe on glibc,\n+       * POSIX specifies that the behaviour is implementation-defined, so avoid\n+       * that and leave aligned_data==NULL in that case.\n+       * See https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/posix_memalign.html *\/\n+      if (aligned_size != 0 &&\n+          posix_memalign (&aligned_data, MAX (sizeof (void *), alignment + 1),\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvariant-core.c","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2479,1 +2479,1 @@\n- * The format is described [here][gvariant-text].\n+ * The format is described [here](gvariant-text-format.html).\n@@ -2499,1 +2499,1 @@\n- * g_variant_unref().\n+ * [method@GLib.Variant.unref].\n@@ -2504,2 +2504,3 @@\n- * Officially, the language understood by the parser is \"any string\n- * produced by g_variant_print()\".\n+ * Officially, the language understood by the parser is “any string\n+ * produced by [method@GLib.Variant.print]”. This explicitly includes\n+ * `g_variant_print()`’s annotated types like `int64 -1000`.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvariant-parser.c","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -765,1 +765,2 @@\n-  if (index_ > value.checked_offsets_up_to &&\n+  if (offsets.array != NULL &&\n+      index_ > value.checked_offsets_up_to &&\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvariant-serialiser.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,4 +39,1 @@\n- * SECTION:gvariant\n- * @title: GVariant\n- * @short_description: strongly typed value datatype\n- * @see_also: GVariantType\n+ * GVariant:\n@@ -44,1 +41,1 @@\n- * #GVariant is a variant datatype; it can contain one or more values\n+ * `GVariant` is a variant datatype; it can contain one or more values\n@@ -47,1 +44,1 @@\n- * A #GVariant may contain simple types, like an integer, or a boolean value;\n+ * A `GVariant` may contain simple types, like an integer, or a boolean value;\n@@ -49,1 +46,1 @@\n- * value pairs. A #GVariant is also immutable: once it's been created neither\n+ * value pairs. A `GVariant` is also immutable: once it’s been created neither\n@@ -52,2 +49,3 @@\n- * GVariant is useful whenever data needs to be serialized, for example when\n- * sending method parameters in D-Bus, or when saving settings using GSettings.\n+ * `GVariant` is useful whenever data needs to be serialized, for example when\n+ * sending method parameters in D-Bus, or when saving settings using\n+ * [`GSettings`](..\/gio\/class.Settings.html).\n@@ -55,1 +53,1 @@\n- * When creating a new #GVariant, you pass the data you want to store in it\n+ * When creating a new `GVariant`, you pass the data you want to store in it\n@@ -58,1 +56,1 @@\n- * For instance, if you want to create a #GVariant holding an integer value you\n+ * For instance, if you want to create a `GVariant` holding an integer value you\n@@ -61,3 +59,3 @@\n- * |[<!-- language=\"C\" -->\n- *   GVariant *v = g_variant_new (\"u\", 40);\n- * ]|\n+ * ```c\n+ * GVariant *v = g_variant_new (\"u\", 40);\n+ * ```\n@@ -65,2 +63,2 @@\n- * The string \"u\" in the first argument tells #GVariant that the data passed to\n- * the constructor (40) is going to be an unsigned integer.\n+ * The string `u` in the first argument tells `GVariant` that the data passed to\n+ * the constructor (`40`) is going to be an unsigned integer.\n@@ -68,2 +66,2 @@\n- * More advanced examples of #GVariant in use can be found in documentation for\n- * [GVariant format strings][gvariant-format-strings-pointers].\n+ * More advanced examples of `GVariant` in use can be found in documentation for\n+ * [`GVariant` format strings](gvariant-format-strings.html#pointers).\n@@ -73,1 +71,1 @@\n- * The type system used by #GVariant is #GVariantType.\n+ * The type system used by `GVariant` is [type@GLib.VariantType].\n@@ -75,4 +73,4 @@\n- * #GVariant instances always have a type and a value (which are given\n- * at construction time).  The type and value of a #GVariant instance\n- * can never change other than by the #GVariant itself being\n- * destroyed.  A #GVariant cannot contain a pointer.\n+ * `GVariant` instances always have a type and a value (which are given\n+ * at construction time).  The type and value of a `GVariant` instance\n+ * can never change other than by the `GVariant` itself being\n+ * destroyed.  A `GVariant` cannot contain a pointer.\n@@ -80,3 +78,3 @@\n- * #GVariant is reference counted using g_variant_ref() and\n- * g_variant_unref().  #GVariant also has floating reference counts --\n- * see g_variant_ref_sink().\n+ * `GVariant` is reference counted using [method@GLib.Variant.ref] and\n+ * [method@GLib.Variant.unref].  `GVariant` also has floating reference counts —\n+ * see [method@GLib.Variant.ref_sink].\n@@ -84,1 +82,1 @@\n- * #GVariant is completely threadsafe.  A #GVariant instance can be\n+ * `GVariant` is completely threadsafe.  A `GVariant` instance can be\n@@ -88,1 +86,1 @@\n- * #GVariant is heavily optimised for dealing with data in serialized\n+ * `GVariant` is heavily optimised for dealing with data in serialized\n@@ -92,1 +90,1 @@\n- * Serialized #GVariant data can also be sent over the network.\n+ * Serialized `GVariant` data can also be sent over the network.\n@@ -94,5 +92,5 @@\n- * #GVariant is largely compatible with D-Bus.  Almost all types of\n- * #GVariant instances can be sent over D-Bus.  See #GVariantType for\n- * exceptions.  (However, #GVariant's serialization format is not the same\n- * as the serialization format of a D-Bus message body: use #GDBusMessage,\n- * in the gio library, for those.)\n+ * `GVariant` is largely compatible with D-Bus.  Almost all types of\n+ * `GVariant` instances can be sent over D-Bus.  See [type@GLib.VariantType] for\n+ * exceptions.  (However, `GVariant`’s serialization format is not the same\n+ * as the serialization format of a D-Bus message body: use\n+ * [GDBusMessage](..\/gio\/class.DBusMessage.html), in the GIO library, for those.)\n@@ -100,2 +98,2 @@\n- * For space-efficiency, the #GVariant serialization format does not\n- * automatically include the variant's length, type or endianness,\n+ * For space-efficiency, the `GVariant` serialization format does not\n+ * automatically include the variant’s length, type or endianness,\n@@ -104,1 +102,1 @@\n- * %G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)\n+ * `G_VARIANT_TYPE_VARIANT` which occupies the whole length of the file)\n@@ -109,2 +107,2 @@\n- * A #GVariant's size is limited mainly by any lower level operating\n- * system constraints, such as the number of bits in #gsize.  For\n+ * A `GVariant`’s size is limited mainly by any lower level operating\n+ * system constraints, such as the number of bits in `gsize`.  For\n@@ -112,1 +110,2 @@\n- * with #GMappedFile, and call g_variant_new_from_data() on it.\n+ * with [struct@GLib.MappedFile], and call [ctor@GLib.Variant.new_from_data] on\n+ * it.\n@@ -114,1 +113,1 @@\n- * For convenience to C programmers, #GVariant features powerful\n+ * For convenience to C programmers, `GVariant` features powerful\n@@ -118,2 +117,2 @@\n- * There is a Python-inspired text language for describing #GVariant\n- * values.  #GVariant includes a printer for this language and a parser\n+ * There is a Python-inspired text language for describing `GVariant`\n+ * values.  `GVariant` includes a printer for this language and a parser\n@@ -124,1 +123,1 @@\n- * #GVariant tries to be quite efficient with respect to memory use.\n+ * `GVariant` tries to be quite efficient with respect to memory use.\n@@ -129,1 +128,1 @@\n- * The memory allocated by #GVariant can be grouped into 4 broad\n+ * The memory allocated by `GVariant` can be grouped into 4 broad\n@@ -132,1 +131,1 @@\n- * #GVariant structure itself.\n+ * `GVariant` structure itself.\n@@ -136,1 +135,1 @@\n- * This is the memory that is used for storing GVariant data in\n+ * This is the memory that is used for storing `GVariant` data in\n@@ -143,1 +142,1 @@\n- * use their \"natural\" size.  Strings (including object path and\n+ * use their ‘natural’ size.  Strings (including object path and\n@@ -147,1 +146,1 @@\n- * Maybe types use no space at all to represent the null value and\n+ * ‘Maybe’ types use no space at all to represent the null value and\n@@ -173,2 +172,2 @@\n- * If we add an item \"width\" that maps to the int32 value of 500 then\n- * we will use 4 byte to store the int32 (so 6 for the variant\n+ * If we add an item ‘width’ that maps to the int32 value of 500 then\n+ * we will use 4 bytes to store the int32 (so 6 for the variant\n@@ -176,1 +175,1 @@\n- * aligned to 8 after the 6 bytes of the string, so that's 2 extra\n+ * aligned to 8 after the 6 bytes of the string, so that’s 2 extra\n@@ -181,1 +180,1 @@\n- * If we add another entry, \"title\" that maps to a nullable string\n+ * If we add another entry, ‘title’ that maps to a nullable string\n@@ -188,1 +187,1 @@\n- * After the 14 bytes of the first item, that's 2 bytes required.\n+ * After the 14 bytes of the first item, that’s 2 bytes required.\n@@ -195,1 +194,1 @@\n- * For each GVariant type that currently exists in the program a type\n+ * For each `GVariant` type that currently exists in the program a type\n@@ -199,3 +198,3 @@\n- * Continuing with the above example, if a #GVariant exists with the\n- * type \"a{sv}\" then a type information struct will exist for\n- * \"a{sv}\", \"{sv}\", \"s\", and \"v\".  Multiple uses of the same type\n+ * Continuing with the above example, if a `GVariant` exists with the\n+ * type `a{sv}` then a type information struct will exist for\n+ * `a{sv}`, `{sv}`, `s`, and `v`.  Multiple uses of the same type\n@@ -205,1 +204,1 @@\n- * #GVariant.\n+ * `GVariant`.\n@@ -213,1 +212,1 @@\n- * Array type info structures are 6 * sizeof (void *), plus the\n+ * Array type info structures are `6 * sizeof (void *)`, plus the\n@@ -215,2 +214,2 @@\n- * on 32-bit systems, the cache entry for \"a{sv}\" would require 30\n- * bytes of memory (plus malloc overhead).\n+ * on 32-bit systems, the cache entry for `a{sv}` would require 30\n+ * bytes of memory (plus allocation overhead).\n@@ -218,2 +217,2 @@\n- * Tuple type info structures are 6 * sizeof (void *), plus 4 *\n- * sizeof (void *) for each item in the tuple, plus the memory\n+ * Tuple type info structures are `6 * sizeof (void *)`, plus `4 *\n+ * sizeof (void *)` for each item in the tuple, plus the memory\n@@ -222,1 +221,1 @@\n- * writable memory in the size of 14 * sizeof (void *) (plus type\n+ * writable memory in the size of `14 * sizeof (void *)` (plus type\n@@ -224,1 +223,1 @@\n- * \"{sv}\" would require 61 bytes of memory (plus malloc overhead).\n+ * `{sv}` would require 61 bytes of memory (plus allocation overhead).\n@@ -226,1 +225,1 @@\n- * This means that in total, for our \"a{sv}\" example, 91 bytes of\n+ * This means that in total, for our `a{sv}` example, 91 bytes of\n@@ -229,1 +228,1 @@\n- * The type information cache, additionally, uses a #GHashTable to\n+ * The type information cache, additionally, uses a [struct@GLib.HashTable] to\n@@ -241,1 +240,1 @@\n- * #GVariant uses an internal buffer management structure to deal\n+ * `GVariant` uses an internal buffer management structure to deal\n@@ -245,2 +244,2 @@\n- * #GVariant.  This may involve a g_free() or a g_slice_free() or\n- * even g_mapped_file_unref().\n+ * `GVariant`.  This may involve a [func@GLib.free] or\n+ * even [method@GLib.MappedFile.unref].\n@@ -250,1 +249,1 @@\n- * is 4 * (void *).  On 32-bit systems, that's 16 bytes.\n+ * is `4 * (void *)`.  On 32-bit systems, that’s 16 bytes.\n@@ -254,2 +253,2 @@\n- * The size of a #GVariant structure is 6 * (void *).  On 32-bit\n- * systems, that's 24 bytes.\n+ * The size of a `GVariant` structure is `6 * (void *)`.  On 32-bit\n+ * systems, that’s 24 bytes.\n@@ -257,2 +256,2 @@\n- * #GVariant structures only exist if they are explicitly created\n- * with API calls.  For example, if a #GVariant is constructed out of\n+ * `GVariant` structures only exist if they are explicitly created\n+ * with API calls.  For example, if a `GVariant` is constructed out of\n@@ -263,1 +262,1 @@\n- * only 1 #GVariant instance exists -- the one referring to the\n+ * only 1 `GVariant` instance exists — the one referring to the\n@@ -267,2 +266,2 @@\n- * #GVariant instances will exist for those values only for as long\n- * as they are in use (ie: until you call g_variant_unref()).  The\n+ * `GVariant` instances will exist for those values only for as long\n+ * as they are in use (ie: until you call [method@GLib.Variant.unref]).  The\n@@ -279,3 +278,3 @@\n- * bytes for the #GVariant instance, or a total of 160 bytes, plus\n- * malloc overhead.  If we were to use g_variant_get_child_value() to\n- * access the two dictionary entries, we would use an additional 48\n+ * bytes for the `GVariant` instance, or a total of 160 bytes, plus\n+ * allocation overhead.  If we were to use [method@GLib.Variant.get_child_value]\n+ * to access the two dictionary entries, we would use an additional 48\n@@ -286,0 +285,2 @@\n+ *\n+ * Since: 2.24\n@@ -967,1 +968,1 @@\n- * [GVariant format strings][gvariant-format-strings-pointers].\n+ * [`GVariant` format strings](gvariant-format-strings.html#pointers).\n@@ -3998,1 +3999,5 @@\n-  dict = g_slice_alloc (sizeof (struct heap_dict));\n+  \/* We actually want to treat the allocation as a `struct heap_dict`, but the\n+   * compiler will warn if it’s not at least as big as `struct GVariantDict`. *\/\n+  G_STATIC_ASSERT (sizeof (GVariantDict) >= sizeof (struct heap_dict));\n+\n+  dict = g_malloc (sizeof (GVariantDict));\n@@ -4066,1 +4071,1 @@\n- * section on [GVariant format strings][gvariant-format-strings-pointers].\n+ * section on [`GVariant` format strings](gvariant-format-strings.html#pointers).\n@@ -4351,1 +4356,1 @@\n-      g_slice_free (struct heap_dict, (struct heap_dict *) dict);\n+      g_free_sized (dict, sizeof (GVariantDict));\n@@ -5526,1 +5531,1 @@\n- * [GVariant format strings][gvariant-format-strings-pointers].\n+ * [`GVariant` format strings](gvariant-format-strings.html#pointers).\n@@ -5580,1 +5585,1 @@\n- * [GVariant format strings][gvariant-format-strings-pointers].\n+ * [`GVariant` format strings](gvariant-format-strings.html#pointers).\n@@ -5675,1 +5680,1 @@\n- * [GVariant format strings][gvariant-format-strings-pointers].\n+ * [`GVariant` format strings](gvariant-format-strings.html#pointers).\n@@ -5748,1 +5753,1 @@\n- * [GVariant format strings][gvariant-format-strings-pointers].\n+ * [`GVariant` format strings](gvariant-format-strings.html#pointers).\n@@ -5847,1 +5852,1 @@\n- * [GVariant format strings][gvariant-format-strings-pointers].\n+ * [`GVariant` format strings](gvariant-format-strings.html#pointers).\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvariant.c","additions":96,"deletions":91,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -35,4 +35,1 @@\n- * SECTION:gvarianttype\n- * @title: GVariantType\n- * @short_description: introduction to the GVariant type system\n- * @see_also: #GVariantType, #GVariant\n+ * GVariantType:\n@@ -40,1 +37,3 @@\n- * This section introduces the GVariant type system. It is based, in\n+ * A type in the [type@GLib.Variant] type system.\n+ *\n+ * This section introduces the [type@GLib.Variant] type system. It is based, in\n@@ -45,1 +44,1 @@\n- * information that is useful when working with GVariant.\n+ * information that is useful when working with [type@GLib.Variant].\n@@ -48,4 +47,4 @@\n- * introduction of maybe (or \"nullable\") types.  Any type in GVariant can be\n- * converted to a maybe type, in which case, \"nothing\" (or \"null\") becomes a\n- * valid value.  Maybe types have been added by introducing the\n- * character \"m\" to type strings.\n+ * introduction of maybe (or ‘nullable’) types.  Any type in [type@GLib.Variant]\n+ * can be converted to a maybe type, in which case, `nothing` (or `null`)\n+ * becomes a valid value.  Maybe types have been added by introducing the\n+ * character `m` to type strings.\n@@ -53,2 +52,2 @@\n- * The second major change is that the GVariant type system supports the\n- * concept of \"indefinite types\" -- types that are less specific than\n+ * The second major change is that the [type@GLib.Variant] type system supports\n+ * the concept of ‘indefinite types’ — types that are less specific than\n@@ -56,4 +55,4 @@\n- * of \"an array of any type\" in GVariant, where the D-Bus type system\n- * would require you to speak of \"an array of integers\" or \"an array of\n- * strings\".  Indefinite types have been added by introducing the\n- * characters \"*\", \"?\" and \"r\" to type strings.\n+ * of ‘an array of any type’ in [type@GLib.Variant], where the D-Bus type system\n+ * would require you to speak of ‘an array of integers’ or ‘an array of\n+ * strings’.  Indefinite types have been added by introducing the\n+ * characters `*`, `?` and `r` to type strings.\n@@ -65,2 +64,2 @@\n- * Just as in D-Bus, GVariant types are described with strings (\"type\n- * strings\").  Subject to the differences mentioned above, these strings\n+ * Just as in D-Bus, [type@GLib.Variant] types are described with strings (‘type\n+ * strings’).  Subject to the differences mentioned above, these strings\n@@ -69,1 +68,1 @@\n- * strings appear nowhere in its interface.  Instead, \"signatures\"\n+ * strings appear nowhere in its interface.  Instead, ‘signatures’\n@@ -71,5 +70,5 @@\n- * message.  GVariant deals with single values directly so GVariant type\n- * strings always describe the type of exactly one value.  This means\n- * that a D-Bus signature string is generally not a valid GVariant type\n- * string -- except in the case that it is the signature of a message\n- * containing exactly one argument.\n+ * message.  [type@GLib.Variant] deals with single values directly so\n+ * [type@GLib.Variant] type strings always describe the type of exactly one\n+ * value.  This means that a D-Bus signature string is generally not a valid\n+ * [type@GLib.Variant] type string — except in the case that it is the signature\n+ * of a message containing exactly one argument.\n@@ -81,7 +80,7 @@\n- * g_variant_get_type() will never return an indefinite type, but\n- * calling g_variant_is_of_type() with an indefinite type may return\n- * %TRUE.  For example, you cannot have a value that represents \"an\n- * array of no particular type\", but you can have an \"array of integers\"\n- * which certainly matches the type of \"an array of no particular type\",\n- * since \"array of integers\" is a subtype of \"array of no particular\n- * type\".\n+ * [method@GLib.Variant.get_type] will never return an indefinite type, but\n+ * calling [method@GLib.Variant.is_of_type] with an indefinite type may return\n+ * true.  For example, you cannot have a value that represents ‘an\n+ * array of no particular type’, but you can have an ‘array of integers’\n+ * which certainly matches the type of ‘an array of no particular type’,\n+ * since ‘array of integers’ is a subtype of ‘array of no particular\n+ * type’.\n@@ -92,4 +91,8 @@\n- * the type of #GtkBin can exist (since #GtkBin is an abstract class),\n- * but a #GtkWindow can certainly be instantiated, and you would say\n- * that the #GtkWindow is a #GtkBin (since #GtkWindow is a subclass of\n- * #GtkBin).\n+ * the type of [`GtkWidget`](https:\/\/docs.gtk.org\/gtk4\/class.Widget.html) can\n+ * exist (since `GtkWidget` is an abstract class), but a [`GtkWindow`](https:\/\/docs.gtk.org\/gtk4\/class.Window.html)\n+ * can certainly be instantiated, and you would say that a `GtkWindow` is a\n+ * `GtkWidget` (since `GtkWindow` is a subclass of `GtkWidget`).\n+ *\n+ * Two types may not be compared by value; use [method@GLib.VariantType.equal]\n+ * or [method@GLib.VariantType.is_subtype_of]  May be copied using\n+ * [method@GLib.VariantType.copy] and freed using [method@GLib.VariantType.free].\n@@ -99,1 +102,1 @@\n- * A GVariant type string can be any of the following:\n+ * A [type@GLib.Variant] type string can be any of the following:\n@@ -102,10 +105,6 @@\n- *\n- * - \"v\", \"r\" or \"*\"\n- *\n- * - one of the characters 'a' or 'm', followed by another type string\n- *\n- * - the character '(', followed by a concatenation of zero or more other\n- *   type strings, followed by the character ')'\n- *\n- * - the character '{', followed by a basic type string (see below),\n- *   followed by another type string, followed by the character '}'\n+ * - `v`, `r` or `*`\n+ * - one of the characters `a` or `m`, followed by another type string\n+ * - the character `(`, followed by a concatenation of zero or more other\n+ *   type strings, followed by the character `)`\n+ * - the character `{`, followed by a basic type string (see below),\n+ *   followed by another type string, followed by the character `}`\n@@ -114,10 +113,11 @@\n- * g_variant_type_is_basic()) and is always a single character in length.\n- * The valid basic type strings are \"b\", \"y\", \"n\", \"q\", \"i\", \"u\", \"x\", \"t\",\n- * \"h\", \"d\", \"s\", \"o\", \"g\" and \"?\".\n- *\n- * The above definition is recursive to arbitrary depth. \"aaaaai\" and\n- * \"(ui(nq((y)))s)\" are both valid type strings, as is\n- * \"a(aa(ui)(qna{ya(yd)}))\". In order to not hit memory limits, #GVariant\n- * imposes a limit on recursion depth of 65 nested containers. This is the\n- * limit in the D-Bus specification (64) plus one to allow a #GDBusMessage to\n- * be nested in a top-level tuple.\n+ * [method@GLib.VariantType.is_basic]) and is always a single character in\n+ * length. The valid basic type strings are `b`, `y`, `n`, `q`, `i`, `u`, `x`,\n+ * `t`, `h`, `d`, `s`, `o`, `g` and `?`.\n+ *\n+ * The above definition is recursive to arbitrary depth. `aaaaai` and\n+ * `(ui(nq((y)))s)` are both valid type strings, as is\n+ * `a(aa(ui)(qna{ya(yd)}))`. In order to not hit memory limits,\n+ * [type@GLib.Variant] imposes a limit on recursion depth of 65 nested\n+ * containers. This is the limit in the D-Bus specification (64) plus one to\n+ * allow a [`GDBusMessage`](..\/gio\/class.DBusMessage.html) to be nested in\n+ * a top-level tuple.\n@@ -126,9 +126,10 @@\n- * - `b`: the type string of %G_VARIANT_TYPE_BOOLEAN; a boolean value.\n- * - `y`: the type string of %G_VARIANT_TYPE_BYTE; a byte.\n- * - `n`: the type string of %G_VARIANT_TYPE_INT16; a signed 16 bit integer.\n- * - `q`: the type string of %G_VARIANT_TYPE_UINT16; an unsigned 16 bit integer.\n- * - `i`: the type string of %G_VARIANT_TYPE_INT32; a signed 32 bit integer.\n- * - `u`: the type string of %G_VARIANT_TYPE_UINT32; an unsigned 32 bit integer.\n- * - `x`: the type string of %G_VARIANT_TYPE_INT64; a signed 64 bit integer.\n- * - `t`: the type string of %G_VARIANT_TYPE_UINT64; an unsigned 64 bit integer.\n- * - `h`: the type string of %G_VARIANT_TYPE_HANDLE; a signed 32 bit value\n+ *\n+ * - `b`: the type string of `G_VARIANT_TYPE_BOOLEAN`; a boolean value.\n+ * - `y`: the type string of `G_VARIANT_TYPE_BYTE`; a byte.\n+ * - `n`: the type string of `G_VARIANT_TYPE_INT16`; a signed 16 bit integer.\n+ * - `q`: the type string of `G_VARIANT_TYPE_UINT16`; an unsigned 16 bit integer.\n+ * - `i`: the type string of `G_VARIANT_TYPE_INT32`; a signed 32 bit integer.\n+ * - `u`: the type string of `G_VARIANT_TYPE_UINT32`; an unsigned 32 bit integer.\n+ * - `x`: the type string of `G_VARIANT_TYPE_INT64`; a signed 64 bit integer.\n+ * - `t`: the type string of `G_VARIANT_TYPE_UINT64`; an unsigned 64 bit integer.\n+ * - `h`: the type string of `G_VARIANT_TYPE_HANDLE`; a signed 32 bit value\n@@ -137,1 +138,1 @@\n- * - `d`: the type string of %G_VARIANT_TYPE_DOUBLE; a double precision\n+ * - `d`: the type string of `G_VARIANT_TYPE_DOUBLE`; a double precision\n@@ -139,2 +140,2 @@\n- * - `s`: the type string of %G_VARIANT_TYPE_STRING; a string.\n- * - `o`: the type string of %G_VARIANT_TYPE_OBJECT_PATH; a string in the form\n+ * - `s`: the type string of `G_VARIANT_TYPE_STRING`; a string.\n+ * - `o`: the type string of `G_VARIANT_TYPE_OBJECT_PATH`; a string in the form\n@@ -142,1 +143,1 @@\n- * - `g`: the type string of %G_VARIANT_TYPE_SIGNATURE; a string in the form of\n+ * - `g`: the type string of `G_VARIANT_TYPE_SIGNATURE`; a string in the form of\n@@ -144,1 +145,1 @@\n- * - `?`: the type string of %G_VARIANT_TYPE_BASIC; an indefinite type that\n+ * - `?`: the type string of `G_VARIANT_TYPE_BASIC`; an indefinite type that\n@@ -146,1 +147,1 @@\n- * - `v`: the type string of %G_VARIANT_TYPE_VARIANT; a container type that\n+ * - `v`: the type string of `G_VARIANT_TYPE_VARIANT`; a container type that\n@@ -149,1 +150,1 @@\n- *   type; the type string \"ai\", for example, is the type of an array of\n+ *   type; the type string `ai`, for example, is the type of an array of\n@@ -151,2 +152,2 @@\n- * - `m`: used as a prefix on another type string to mean a \"maybe\", or\n- *   \"nullable\", version of that type; the type string \"ms\", for example,\n+ * - `m`: used as a prefix on another type string to mean a ‘maybe’, or\n+ *   ‘nullable’, version of that type; the type string `ms`, for example,\n@@ -156,1 +157,1 @@\n- *   create a tuple type; the type string \"(is)\", for example, is the type of\n+ *   create a tuple type; the type string `(is)`, for example, is the type of\n@@ -158,1 +159,1 @@\n- * - `r`: the type string of %G_VARIANT_TYPE_TUPLE; an indefinite type that is\n+ * - `r`: the type string of `G_VARIANT_TYPE_TUPLE`; an indefinite type that is\n@@ -162,1 +163,1 @@\n- *   an array to form a dictionary; the type string \"a{sd}\", for example, is\n+ *   an array to form a dictionary; the type string `a{sd}`, for example, is\n@@ -169,1 +170,1 @@\n- * - `*`: the type string of %G_VARIANT_TYPE_ANY; the indefinite type that is\n+ * - `*`: the type string of `G_VARIANT_TYPE_ANY`; the indefinite type that is\n@@ -172,1 +173,1 @@\n- *   to mean \"any number of items\".\n+ *   to mean ‘any number of items’.\n@@ -175,3 +176,3 @@\n- * itself, an indefinite type. For example, the type string \"a*\"\n- * (corresponding to %G_VARIANT_TYPE_ARRAY) is an indefinite type\n- * that is a supertype of every array type. \"(*s)\" is a supertype\n+ * itself, an indefinite type. For example, the type string `a*`\n+ * (corresponding to `G_VARIANT_TYPE_ARRAY`) is an indefinite type\n+ * that is a supertype of every array type. `(*s)` is a supertype\n@@ -181,1 +182,1 @@\n- * \"a{?*}\" is an indefinite type that is a supertype of all arrays\n+ * `a{?*}` is an indefinite type that is a supertype of all arrays\n@@ -184,1 +185,1 @@\n- * so this type string corresponds to %G_VARIANT_TYPE_DICTIONARY. Note\n+ * so this type string corresponds to `G_VARIANT_TYPE_DICTIONARY`. Note\n@@ -186,1 +187,3 @@\n- * be a basic type, \"{**}\" is not a valid type string.\n+ * be a basic type, `{**}` is not a valid type string.\n+ *\n+ * Since: 2.24\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvarianttype.c","additions":88,"deletions":85,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -34,9 +34,0 @@\n-\/**\n- * GVariantType:\n- *\n- * A type in the GVariant type system.\n- *\n- * Two types may not be compared by value; use g_variant_type_equal() or\n- * g_variant_type_is_subtype_of().  May be copied using\n- * g_variant_type_copy() and freed using g_variant_type_free().\n- **\/\n@@ -378,1 +369,1 @@\n-const GVariantType *            g_variant_type_checked_                 (const gchar *);\n+const GVariantType *            g_variant_type_checked_                 (const gchar *type_string);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvarianttype.h","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,22 +31,0 @@\n-\/**\n- * SECTION:version\n- * @Title: Version Information\n- * @Short_description: variables and functions to check the GLib version\n- *\n- * GLib provides version information, primarily useful in configure\n- * checks for builds that have a configure script. Applications will\n- * not typically use the features described here.\n- *\n- * The GLib headers annotate deprecated APIs in a way that produces\n- * compiler warnings if these deprecated APIs are used. The warnings\n- * can be turned off by defining the macro %GLIB_DISABLE_DEPRECATION_WARNINGS\n- * before including the glib.h header.\n- *\n- * GLib also provides support for building applications against\n- * defined subsets of deprecated or new GLib APIs. Define the macro\n- * %GLIB_VERSION_MIN_REQUIRED to specify up to what version of GLib\n- * you want to receive warnings about deprecated APIs. Define the\n- * macro %GLIB_VERSION_MAX_ALLOWED to specify the newest version of\n- * GLib whose API you want to use.\n- *\/\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gversion.c","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,3 +41,1 @@\n- * SECTION:gwakeup\n- * @title: GWakeup\n- * @short_description: portable cross-thread event signal mechanism\n+ * GWakeup:\n@@ -45,1 +43,1 @@\n- * #GWakeup is a simple and portable way of signaling events between\n+ * `GWakeup` is a simple and portable way of signaling events between\n@@ -62,1 +60,1 @@\n- **\/\n+ *\/\n@@ -127,1 +125,1 @@\n-\/**\n+\/*< private >\n@@ -173,1 +171,1 @@\n-\/**\n+\/*< private >\n@@ -193,1 +191,1 @@\n-\/**\n+\/*< private >\n@@ -232,1 +230,1 @@\n-\/**\n+\/*< private >\n@@ -273,1 +271,1 @@\n-\/**\n+\/*< private >\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gwakeup.c","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-#if defined(__BIONIC__) || defined(__NetBSD__)\n+#if defined(__BIONIC__) || defined(__NetBSD__) || defined(__FreeBSD__)\n@@ -185,1 +185,1 @@\n-#if defined(__BIONIC__) || defined(__NetBSD__)\n+#if defined(__BIONIC__) || defined(__NetBSD__) || defined(__FreeBSD__)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gmodule\/gmodule-dl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -953,0 +953,34 @@\n+\n+#if GLIB_VERSION_MIN_REQUIRED >= GLIB_VERSION_2_80\n+#define GMODULE_DEPRECATED_IN_2_80 GMODULE_DEPRECATED\n+#define GMODULE_DEPRECATED_IN_2_80_FOR(f) GMODULE_DEPRECATED_FOR (f)\n+#define GMODULE_DEPRECATED_MACRO_IN_2_80 GLIB_DEPRECATED_MACRO\n+#define GMODULE_DEPRECATED_MACRO_IN_2_80_FOR(f) GLIB_DEPRECATED_MACRO_FOR (f)\n+#define GMODULE_DEPRECATED_ENUMERATOR_IN_2_80 GLIB_DEPRECATED_ENUMERATOR\n+#define GMODULE_DEPRECATED_ENUMERATOR_IN_2_80_FOR(f) GLIB_DEPRECATED_ENUMERATOR_FOR (f)\n+#define GMODULE_DEPRECATED_TYPE_IN_2_80 GLIB_DEPRECATED_TYPE\n+#define GMODULE_DEPRECATED_TYPE_IN_2_80_FOR(f) GLIB_DEPRECATED_TYPE_FOR (f)\n+#else\n+#define GMODULE_DEPRECATED_IN_2_80 _GMODULE_EXTERN\n+#define GMODULE_DEPRECATED_IN_2_80_FOR(f) _GMODULE_EXTERN\n+#define GMODULE_DEPRECATED_MACRO_IN_2_80\n+#define GMODULE_DEPRECATED_MACRO_IN_2_80_FOR(f)\n+#define GMODULE_DEPRECATED_ENUMERATOR_IN_2_80\n+#define GMODULE_DEPRECATED_ENUMERATOR_IN_2_80_FOR(f)\n+#define GMODULE_DEPRECATED_TYPE_IN_2_80\n+#define GMODULE_DEPRECATED_TYPE_IN_2_80_FOR(f)\n+#endif\n+\n+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_80\n+#define GMODULE_AVAILABLE_IN_2_80 GMODULE_UNAVAILABLE (2, 80)\n+#define GMODULE_AVAILABLE_STATIC_INLINE_IN_2_80 GLIB_UNAVAILABLE_STATIC_INLINE (2, 80)\n+#define GMODULE_AVAILABLE_MACRO_IN_2_80 GLIB_UNAVAILABLE_MACRO (2, 80)\n+#define GMODULE_AVAILABLE_ENUMERATOR_IN_2_80 GLIB_UNAVAILABLE_ENUMERATOR (2, 80)\n+#define GMODULE_AVAILABLE_TYPE_IN_2_80 GLIB_UNAVAILABLE_TYPE (2, 80)\n+#else\n+#define GMODULE_AVAILABLE_IN_2_80 _GMODULE_EXTERN\n+#define GMODULE_AVAILABLE_STATIC_INLINE_IN_2_80\n+#define GMODULE_AVAILABLE_MACRO_IN_2_80\n+#define GMODULE_AVAILABLE_ENUMERATOR_IN_2_80\n+#define GMODULE_AVAILABLE_TYPE_IN_2_80\n+#endif\n\\ No newline at end of file\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gmodule\/gmodule-visibility.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -55,78 +55,0 @@\n-\/**\n- * SECTION:modules\n- * @title: Dynamic Loading of Modules\n- * @short_description: portable method for dynamically loading 'plug-ins'\n- *\n- * These functions provide a portable way to dynamically load object files\n- * (commonly known as 'plug-ins'). The current implementation supports all\n- * systems that provide an implementation of dlopen() (e.g. Linux\/Sun), as\n- * well as Windows platforms via DLLs.\n- *\n- * A program which wants to use these functions must be linked to the\n- * libraries output by the command `pkg-config --libs gmodule-2.0`.\n- *\n- * To use them you must first determine whether dynamic loading\n- * is supported on the platform by calling g_module_supported().\n- * If it is, you can open a module with g_module_open(),\n- * find the module's symbols (e.g. function names) with g_module_symbol(),\n- * and later close the module with g_module_close().\n- * g_module_name() will return the file name of a currently opened module.\n- *\n- * If any of the above functions fail, the error status can be found with\n- * g_module_error().\n- *\n- * The #GModule implementation features reference counting for opened modules,\n- * and supports hook functions within a module which are called when the\n- * module is loaded and unloaded (see #GModuleCheckInit and #GModuleUnload).\n- *\n- * If your module introduces static data to common subsystems in the running\n- * program, e.g. through calling\n- * `g_quark_from_static_string (\"my-module-stuff\")`,\n- * it must ensure that it is never unloaded, by calling g_module_make_resident().\n- *\n- * Example: Calling a function defined in a GModule\n- * |[<!-- language=\"C\" -->\n- * \/\/ the function signature for 'say_hello'\n- * typedef void (* SayHelloFunc) (const char *message);\n- *\n- * gboolean\n- * just_say_hello (const char *filename, GError **error)\n- * {\n- *   SayHelloFunc  say_hello;\n- *   GModule      *module;\n- *\n- *   module = g_module_open (filename, G_MODULE_BIND_LAZY);\n- *   if (!module)\n- *     {\n- *       g_set_error (error, FOO_ERROR, FOO_ERROR_BLAH,\n- *                    \"%s\", g_module_error ());\n- *       return FALSE;\n- *     }\n- *\n- *   if (!g_module_symbol (module, \"say_hello\", (gpointer *)&say_hello))\n- *     {\n- *       g_set_error (error, SAY_ERROR, SAY_ERROR_OPEN,\n- *                    \"%s: %s\", filename, g_module_error ());\n- *       if (!g_module_close (module))\n- *         g_warning (\"%s: %s\", filename, g_module_error ());\n- *       return FALSE;\n- *     }\n- *\n- *   if (say_hello == NULL)\n- *     {\n- *       g_set_error (error, SAY_ERROR, SAY_ERROR_OPEN,\n- *                    \"symbol say_hello is NULL\");\n- *       if (!g_module_close (module))\n- *         g_warning (\"%s: %s\", filename, g_module_error ());\n- *       return FALSE;\n- *     }\n- *\n- *   \/\/ call our function in the module\n- *   say_hello (\"Hello world!\");\n- *\n- *   if (!g_module_close (module))\n- *     g_warning (\"%s: %s\", filename, g_module_error ());\n- *   return TRUE;\n- *  }\n- * ]|\n- *\/\n@@ -519,1 +441,3 @@\n- * is incremented. If not, the module is searched in the following order:\n+ * is incremented. If not, the module is searched using @file_name.\n+ *\n+ * Since 2.76, the search order\/behavior is as follows:\n@@ -530,4 +454,9 @@\n- * At the end of all this, we would have a file path that we can access on\n- * disk, and it is opened as a module. If not, @file_name is opened as\n- * a module verbatim in the hopes that the system implementation will somehow\n- * be able to access it.\n+ * If, at the end of all this, we have a file path that we can access on disk,\n+ * it is opened as a module. If not, @file_name is attempted to be opened as a\n+ * module verbatim in the hopes that the system implementation will somehow be\n+ * able to access it. If that is not possible, %NULL is returned.\n+ *\n+ * Note that this behaviour was different prior to 2.76, but there is some\n+ * overlap in functionality. If backwards compatibility is an issue, kindly\n+ * consult earlier #GModule documentation for the prior search order\/behavior\n+ * of @file_name.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gmodule\/gmodule.c","additions":12,"deletions":83,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -24,3 +24,1 @@\n- * SECTION:gbinding\n- * @Title: GBinding\n- * @Short_Description: Bind two object properties\n+ * GBinding:\n@@ -28,2 +26,1 @@\n- * #GBinding is the representation of a binding between a property on a\n- * #GObject instance (or source) and another property on another #GObject\n+ * `GObject` instance (or source) and another property on another `GObject`\n@@ -35,1 +32,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -39,1 +36,1 @@\n- * ]|\n+ * ```\n@@ -42,1 +39,1 @@\n- * every time g_object_set() or the specific accessor changes the value of\n+ * every time [method@GObject.set] or the specific accessor changes the value of\n@@ -46,1 +43,1 @@\n- * of two #GObject instances, so that if either property changes, the\n+ * of two `GObject` instances, so that if either property changes, the\n@@ -49,1 +46,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -53,1 +50,1 @@\n- * ]|\n+ * ```\n@@ -62,1 +59,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -69,1 +66,1 @@\n- * ]|\n+ * ```\n@@ -83,1 +80,1 @@\n- * |[\n+ * ```\n@@ -87,1 +84,1 @@\n- * ]|\n+ * ```\n@@ -90,1 +87,1 @@\n- * can be avoided if the objects emit the #GObject::notify signal only\n+ * can be avoided if the objects emit the `GObject::notify` signal only\n@@ -92,3 +89,3 @@\n- * using the #GObject::notify signal, so it is susceptible to all the\n- * various ways of blocking a signal emission, like g_signal_stop_emission()\n- * or g_signal_handler_block().\n+ * using the `GObject::notify` signal, so it is susceptible to all the\n+ * various ways of blocking a signal emission, like [func@GObject.signal_stop_emission]\n+ * or [func@GObject.signal_handler_block].\n@@ -97,1 +94,1 @@\n- * either one of the #GObject instances it refers to are finalized, or when\n+ * either one of the `GObject` instances it refers to are finalized, or when\n@@ -101,1 +98,1 @@\n- * g_binding_unbind() to explicitly release a binding between the source\n+ * [method@GObject.Binding.unbind] to explicitly release a binding between the source\n@@ -105,1 +102,1 @@\n- * #GBinding is available since GObject 2.26\n+ * Since: 2.26\n@@ -126,1 +123,1 @@\n-  static gsize static_g_define_type_id = 0;\n+  static GType static_g_define_type_id = 0;\n@@ -128,1 +125,1 @@\n-  if (g_once_init_enter (&static_g_define_type_id))\n+  if (g_once_init_enter_pointer (&static_g_define_type_id))\n@@ -139,1 +136,1 @@\n-      g_once_init_leave (&static_g_define_type_id, g_define_type_id);\n+      g_once_init_leave_pointer (&static_g_define_type_id, g_define_type_id);\n@@ -892,3 +889,1 @@\n-                                   g_param_spec_object (\"source\",\n-                                                        P_(\"Source\"),\n-                                                        P_(\"The source of the binding\"),\n+                                   g_param_spec_object (\"source\", NULL, NULL,\n@@ -907,3 +902,1 @@\n-                                   g_param_spec_object (\"target\",\n-                                                        P_(\"Target\"),\n-                                                        P_(\"The target of the binding\"),\n+                                   g_param_spec_object (\"target\", NULL, NULL,\n@@ -926,3 +919,1 @@\n-                                   g_param_spec_string (\"source-property\",\n-                                                        P_(\"Source Property\"),\n-                                                        P_(\"The property on the source to bind\"),\n+                                   g_param_spec_string (\"source-property\", NULL, NULL,\n@@ -945,3 +936,1 @@\n-                                   g_param_spec_string (\"target-property\",\n-                                                        P_(\"Target Property\"),\n-                                                        P_(\"The property on the target to bind\"),\n+                                   g_param_spec_string (\"target-property\", NULL, NULL,\n@@ -960,3 +949,1 @@\n-                                   g_param_spec_flags (\"flags\",\n-                                                       P_(\"Flags\"),\n-                                                       P_(\"The binding flags\"),\n+                                   g_param_spec_flags (\"flags\", NULL, NULL,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gbinding.c","additions":27,"deletions":40,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -41,8 +41,0 @@\n-\/**\n- * GBinding:\n- *\n- * GBinding is an opaque structure whose members\n- * cannot be accessed directly.\n- *\n- * Since: 2.26\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gbinding.h","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,29 +36,0 @@\n-\n-\/**\n- * SECTION:gboxed\n- * @short_description: A mechanism to wrap opaque C structures registered\n- *     by the type system\n- * @see_also: #GParamSpecBoxed, g_param_spec_boxed()\n- * @title: Boxed Types\n- *\n- * #GBoxed is a generic wrapper mechanism for arbitrary C structures.\n- *\n- * The only thing the type system needs to know about the structures is how to\n- * copy them (a #GBoxedCopyFunc) and how to free them (a #GBoxedFreeFunc);\n- * beyond that, they are treated as opaque chunks of memory.\n- *\n- * Boxed types are useful for simple value-holder structures like rectangles or\n- * points. They can also be used for wrapping structures defined in non-#GObject\n- * based libraries. They allow arbitrary structures to be handled in a uniform\n- * way, allowing uniform copying (or referencing) and freeing (or unreferencing)\n- * of them, and uniform representation of the type of the contained structure.\n- * In turn, this allows any type which can be boxed to be set as the data in a\n- * #GValue, which allows for polymorphic handling of a much wider range of data\n- * types, and hence usage of such types as #GObject property values.\n- *\n- * #GBoxed is designed so that reference counted types can be boxed. Use the\n- * type's 'ref' function as the #GBoxedCopyFunc, and its 'unref' function as the\n- * #GBoxedFreeFunc. For example, for #GBytes, the #GBoxedCopyFunc is\n- * g_bytes_ref(), and the #GBoxedFreeFunc is g_bytes_unref().\n- *\/\n-\n@@ -173,0 +144,3 @@\n+G_DEFINE_BOXED_TYPE (GHmac, g_hmac, g_hmac_ref, g_hmac_unref)\n+G_DEFINE_BOXED_TYPE (GDir, g_dir, g_dir_ref, g_dir_unref)\n+G_DEFINE_BOXED_TYPE (GRand, g_rand, g_rand_copy, g_rand_free)\n@@ -188,0 +162,4 @@\n+#ifndef GSTREAMER_LITE\n+G_DEFINE_BOXED_TYPE (GStrvBuilder, g_strv_builder, g_strv_builder_ref, g_strv_builder_unref);\n+#endif \/\/ GSTREAMER_LITE\n+\n@@ -192,1 +170,1 @@\n-  static gsize static_g_define_type_id = 0;\n+  static GType static_g_define_type_id = 0;\n@@ -194,1 +172,1 @@\n-  if (g_once_init_enter (&static_g_define_type_id))\n+  if (g_once_init_enter_pointer (&static_g_define_type_id))\n@@ -201,1 +179,1 @@\n-      g_once_init_leave (&static_g_define_type_id, g_define_type_id);\n+      g_once_init_leave_pointer (&static_g_define_type_id, g_define_type_id);\n@@ -287,2 +265,2 @@\n- * @boxed_copy: Boxed structure copy function.\n- * @boxed_free: Boxed structure free function.\n+ * @boxed_copy: (scope forever): Boxed structure copy function.\n+ * @boxed_free: (scope forever): Boxed structure free function.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gboxed.c","additions":12,"deletions":34,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -42,3 +42,5 @@\n- * SECTION:gclosure\n- * @short_description: Functions as first-class objects\n- * @title: Closures\n+ * GClosure:\n+ * @in_marshal: Indicates whether the closure is currently being invoked with\n+ *   g_closure_invoke()\n+ * @is_invalid: Indicates whether the closure has been invalidated by\n+ *   g_closure_invalidate()\n@@ -46,1 +48,1 @@\n- * A #GClosure represents a callback supplied by the programmer.\n+ * A `GClosure` represents a callback supplied by the programmer.\n@@ -1192,1 +1194,1 @@\n-  closure = g_closure_new_simple (sizeof (GClosure), (gpointer) itype);\n+  closure = g_closure_new_simple (sizeof (GClosure), GTYPE_TO_POINTER (itype));\n@@ -1692,317 +1694,0 @@\n-\n-\/**\n- * g_cclosure_marshal_VOID__VOID:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 1\n- * @param_values: a #GValue array holding only the instance\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__BOOLEAN:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gboolean parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gboolean arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__CHAR:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gchar parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gchar arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__UCHAR:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #guchar parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, guchar arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__INT:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gint parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__UINT:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #guint parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, guint arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__LONG:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #glong parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, glong arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__ULONG:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gulong parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gulong arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__ENUM:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the enumeration parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter denotes an enumeration type..\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__FLAGS:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the flags parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter denotes a flags type.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__FLOAT:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gfloat parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gfloat arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__DOUBLE:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gdouble parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gdouble arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__STRING:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gchar* parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, const gchar *arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__PARAM:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #GParamSpec* parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, GParamSpec *arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__BOXED:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #GBoxed* parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, GBoxed *arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__POINTER:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #gpointer parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, gpointer arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__OBJECT:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #GObject* parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, GObject *arg1, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__VARIANT:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding the instance and the #GVariant* parameter\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, GVariant *arg1, gpointer user_data)`.\n- *\n- * Since: 2.26\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_VOID__UINT_POINTER:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: ignored\n- * @n_param_values: 3\n- * @param_values: a #GValue array holding instance, arg1 and arg2\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `void (*callback) (gpointer instance, guint arg1, gpointer arg2, gpointer user_data)`.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_BOOLEAN__FLAGS:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: a #GValue which can store the returned #gboolean\n- * @n_param_values: 2\n- * @param_values: a #GValue array holding instance and arg1\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `gboolean (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter\n- * denotes a flags type.\n- *\/\n-\n-\/**\n- * g_cclosure_marshal_BOOL__FLAGS:\n- *\n- * Another name for g_cclosure_marshal_BOOLEAN__FLAGS().\n- *\/\n-\/**\n- * g_cclosure_marshal_STRING__OBJECT_POINTER:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: a #GValue, which can store the returned string\n- * @n_param_values: 3\n- * @param_values: a #GValue array holding instance, arg1 and arg2\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `gchar* (*callback) (gpointer instance, GObject *arg1, gpointer arg2, gpointer user_data)`.\n- *\/\n-\/**\n- * g_cclosure_marshal_BOOLEAN__OBJECT_BOXED_BOXED:\n- * @closure: the #GClosure to which the marshaller belongs\n- * @return_value: a #GValue, which can store the returned string\n- * @n_param_values: 3\n- * @param_values: a #GValue array holding instance, arg1 and arg2\n- * @invocation_hint: the invocation hint given as the last argument\n- *  to g_closure_invoke()\n- * @marshal_data: additional data specified when registering the marshaller\n- *\n- * A marshaller for a #GCClosure with a callback of type\n- * `gboolean (*callback) (gpointer instance, GBoxed *arg1, GBoxed *arg2, gpointer user_data)`.\n- *\n- * Since: 2.26\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gclosure.c","additions":7,"deletions":322,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -172,9 +172,1 @@\n-\/**\n- * GClosure:\n- * @in_marshal: Indicates whether the closure is currently being invoked with\n- *  g_closure_invoke()\n- * @is_invalid: Indicates whether the closure has been invalidated by\n- *  g_closure_invalidate()\n- *\n- * A #GClosure represents a callback supplied by the programmer.\n- *\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gclosure.h","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,37 +34,0 @@\n-\/**\n- * SECTION:enumerations_flags\n- * @short_description: Enumeration and flags types\n- * @title: Enumeration and Flag Types\n- * @see_also:#GParamSpecEnum, #GParamSpecFlags, g_param_spec_enum(),\n- * g_param_spec_flags()\n- *\n- * The GLib type system provides fundamental types for enumeration and\n- * flags types. (Flags types are like enumerations, but allow their\n- * values to be combined by bitwise or). A registered enumeration or\n- * flags type associates a name and a nickname with each allowed\n- * value, and the methods g_enum_get_value_by_name(),\n- * g_enum_get_value_by_nick(), g_flags_get_value_by_name() and\n- * g_flags_get_value_by_nick() can look up values by their name or\n- * nickname.  When an enumeration or flags type is registered with the\n- * GLib type system, it can be used as value type for object\n- * properties, using g_param_spec_enum() or g_param_spec_flags().\n- *\n- * GObject ships with a utility called [glib-mkenums][glib-mkenums],\n- * that can construct suitable type registration functions from C enumeration\n- * definitions.\n- *\n- * Example of how to get a string representation of an enum value:\n- * |[<!-- language=\"C\" -->\n- * GEnumClass *enum_class;\n- * GEnumValue *enum_value;\n- *\n- * enum_class = g_type_class_ref (MAMAN_TYPE_MY_ENUM);\n- * enum_value = g_enum_get_value (enum_class, MAMAN_MY_ENUM_FOO);\n- *\n- * g_print (\"Name: %s\\n\", enum_value->value_name);\n- *\n- * g_type_class_unref (enum_class);\n- * ]|\n- *\/\n-\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/genums.c","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -323,2 +323,2 @@\n-  static gsize g_define_type__static = 0; \\\n-  if (g_once_init_enter (&g_define_type__static)) { \\\n+  static _g_type_once_init_type g_define_type__static = 0; \\\n+  if (_g_type_once_init_enter (&g_define_type__static)) { \\\n@@ -330,1 +330,1 @@\n-    g_once_init_leave (&g_define_type__static, g_define_type); \\\n+    _g_type_once_init_leave (&g_define_type__static, g_define_type); \\\n@@ -366,2 +366,2 @@\n-  static gsize g_define_type__static = 0; \\\n-  if (g_once_init_enter (&g_define_type__static)) { \\\n+  static _g_type_once_init_type g_define_type__static = 0; \\\n+  if (_g_type_once_init_enter (&g_define_type__static)) { \\\n@@ -373,1 +373,1 @@\n-    g_once_init_leave (&g_define_type__static, g_define_type); \\\n+    _g_type_once_init_leave (&g_define_type__static, g_define_type); \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/genums.h","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -341,0 +341,36 @@\n+\/**\n+ * G_TYPE_HMAC:\n+ *\n+ * The #GType for a boxed type holding a #GHmac.\n+ *\n+ * Since: 2.80\n+ *\/\n+#define G_TYPE_HMAC (g_hmac_get_type ())\n+\n+\/**\n+ * G_TYPE_DIR:\n+ *\n+ * The #GType for a boxed type holding a #GDir.\n+ *\n+ * Since: 2.80\n+ *\/\n+#define G_TYPE_DIR (g_dir_get_type ())\n+\n+\/**\n+ * G_TYPE_RAND:\n+ *\n+ * The #GType for a boxed type holding a #GRand.\n+ *\n+ * Since: 2.80\n+ *\/\n+#define G_TYPE_RAND (g_rand_get_type ())\n+\n+\/**\n+ * G_TYPE_STRV_BUILDER:\n+ *\n+ * The #GType for a boxed type holding a #GStrvBuilder.\n+ *\n+ * Since: 2.80\n+ *\/\n+#define G_TYPE_STRV_BUILDER (g_strv_builder_get_type ())\n+\n@@ -408,0 +444,8 @@\n+GOBJECT_AVAILABLE_IN_2_80\n+GType   g_hmac_get_type (void) G_GNUC_CONST;\n+GOBJECT_AVAILABLE_IN_2_80\n+GType   g_dir_get_type (void) G_GNUC_CONST;\n+GOBJECT_AVAILABLE_IN_2_80\n+GType   g_rand_get_type (void) G_GNUC_CONST;\n+GOBJECT_AVAILABLE_IN_2_80\n+GType   g_strv_builder_get_type (void) G_GNUC_CONST;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/glib-types.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#ifndef __GI_SCANNER__\n+\n@@ -34,0 +36,2 @@\n+\n+#endif \/* __GI_SCANNER__ *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gobject-autocleanups.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -953,0 +953,34 @@\n+\n+#if GLIB_VERSION_MIN_REQUIRED >= GLIB_VERSION_2_80\n+#define GOBJECT_DEPRECATED_IN_2_80 GOBJECT_DEPRECATED\n+#define GOBJECT_DEPRECATED_IN_2_80_FOR(f) GOBJECT_DEPRECATED_FOR (f)\n+#define GOBJECT_DEPRECATED_MACRO_IN_2_80 GLIB_DEPRECATED_MACRO\n+#define GOBJECT_DEPRECATED_MACRO_IN_2_80_FOR(f) GLIB_DEPRECATED_MACRO_FOR (f)\n+#define GOBJECT_DEPRECATED_ENUMERATOR_IN_2_80 GLIB_DEPRECATED_ENUMERATOR\n+#define GOBJECT_DEPRECATED_ENUMERATOR_IN_2_80_FOR(f) GLIB_DEPRECATED_ENUMERATOR_FOR (f)\n+#define GOBJECT_DEPRECATED_TYPE_IN_2_80 GLIB_DEPRECATED_TYPE\n+#define GOBJECT_DEPRECATED_TYPE_IN_2_80_FOR(f) GLIB_DEPRECATED_TYPE_FOR (f)\n+#else\n+#define GOBJECT_DEPRECATED_IN_2_80 _GOBJECT_EXTERN\n+#define GOBJECT_DEPRECATED_IN_2_80_FOR(f) _GOBJECT_EXTERN\n+#define GOBJECT_DEPRECATED_MACRO_IN_2_80\n+#define GOBJECT_DEPRECATED_MACRO_IN_2_80_FOR(f)\n+#define GOBJECT_DEPRECATED_ENUMERATOR_IN_2_80\n+#define GOBJECT_DEPRECATED_ENUMERATOR_IN_2_80_FOR(f)\n+#define GOBJECT_DEPRECATED_TYPE_IN_2_80\n+#define GOBJECT_DEPRECATED_TYPE_IN_2_80_FOR(f)\n+#endif\n+\n+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_80\n+#define GOBJECT_AVAILABLE_IN_2_80 GOBJECT_UNAVAILABLE (2, 80)\n+#define GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_80 GLIB_UNAVAILABLE_STATIC_INLINE (2, 80)\n+#define GOBJECT_AVAILABLE_MACRO_IN_2_80 GLIB_UNAVAILABLE_MACRO (2, 80)\n+#define GOBJECT_AVAILABLE_ENUMERATOR_IN_2_80 GLIB_UNAVAILABLE_ENUMERATOR (2, 80)\n+#define GOBJECT_AVAILABLE_TYPE_IN_2_80 GLIB_UNAVAILABLE_TYPE (2, 80)\n+#else\n+#define GOBJECT_AVAILABLE_IN_2_80 _GOBJECT_EXTERN\n+#define GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_80\n+#define GOBJECT_AVAILABLE_MACRO_IN_2_80\n+#define GOBJECT_AVAILABLE_ENUMERATOR_IN_2_80\n+#define GOBJECT_AVAILABLE_TYPE_IN_2_80\n+#endif\n\\ No newline at end of file\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gobject-visibility.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,4 +41,1 @@\n- * SECTION:objects\n- * @title: GObject\n- * @short_description: The base object type\n- * @see_also: #GParamSpecObject, g_param_spec_object()\n+ * GObject:\n@@ -46,1 +43,3 @@\n- * GObject is the fundamental type providing the common attributes and\n+ * The base object type.\n+ *\n+ * `GObject` is the fundamental type providing the common attributes and\n@@ -48,1 +47,1 @@\n- * based on GObject.  The GObject class provides methods for object\n+ * based on GObject. The `GObject` class provides methods for object\n@@ -50,61 +49,1 @@\n- * support.  Signals are described in detail [here][gobject-Signals].\n- *\n- * For a tutorial on implementing a new GObject class, see [How to define and\n- * implement a new GObject][howto-gobject]. For a list of naming conventions for\n- * GObjects and their methods, see the [GType conventions][gtype-conventions].\n- * For the high-level concepts behind GObject, read [Instantiatable classed types:\n- * Objects][gtype-instantiatable-classed].\n- *\n- * ## Floating references # {#floating-ref}\n- *\n- * **Note**: Floating references are a C convenience API and should not be\n- * used in modern GObject code. Language bindings in particular find the\n- * concept highly problematic, as floating references are not identifiable\n- * through annotations, and neither are deviations from the floating reference\n- * behavior, like types that inherit from #GInitiallyUnowned and still return\n- * a full reference from g_object_new().\n- *\n- * GInitiallyUnowned is derived from GObject. The only difference between\n- * the two is that the initial reference of a GInitiallyUnowned is flagged\n- * as a \"floating\" reference. This means that it is not specifically\n- * claimed to be \"owned\" by any code portion. The main motivation for\n- * providing floating references is C convenience. In particular, it\n- * allows code to be written as:\n- *\n- * |[<!-- language=\"C\" -->\n- * container = create_container ();\n- * container_add_child (container, create_child());\n- * ]|\n- *\n- * If container_add_child() calls g_object_ref_sink() on the passed-in child,\n- * no reference of the newly created child is leaked. Without floating\n- * references, container_add_child() can only g_object_ref() the new child,\n- * so to implement this code without reference leaks, it would have to be\n- * written as:\n- *\n- * |[<!-- language=\"C\" -->\n- * Child *child;\n- * container = create_container ();\n- * child = create_child ();\n- * container_add_child (container, child);\n- * g_object_unref (child);\n- * ]|\n- *\n- * The floating reference can be converted into an ordinary reference by\n- * calling g_object_ref_sink(). For already sunken objects (objects that\n- * don't have a floating reference anymore), g_object_ref_sink() is equivalent\n- * to g_object_ref() and returns a new reference.\n- *\n- * Since floating references are useful almost exclusively for C convenience,\n- * language bindings that provide automated reference and memory ownership\n- * maintenance (such as smart pointers or garbage collection) should not\n- * expose floating references in their API. The best practice for handling\n- * types that have initially floating references is to immediately sink those\n- * references after g_object_new() returns, by checking if the #GType\n- * inherits from #GInitiallyUnowned. For instance:\n- *\n- * |[<!-- language=\"C\" -->\n- * GObject *res = g_object_new_with_properties (gtype,\n- *                                              n_props,\n- *                                              prop_names,\n- *                                              prop_values);\n+ * support. Signals are described in detail [here][gobject-Signals].\n@@ -112,3 +51,6 @@\n- * \/\/ or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))\n- * if (G_IS_INITIALLY_UNOWNED (res))\n- *   g_object_ref_sink (res);\n+ * For a tutorial on implementing a new `GObject` class, see [How to define and\n+ * implement a new GObject](tutorial.html#how-to-define-and-implement-a-new-gobject).\n+ * For a list of naming conventions for GObjects and their methods, see the\n+ * [GType conventions](concepts.html#conventions). For the high-level concepts\n+ * behind GObject, read\n+ * [Instantiatable classed types: Objects](concepts.html#instantiatable-classed-types-objects).\n@@ -116,21 +58,7 @@\n- * return res;\n- * ]|\n- *\n- * Some object implementations may need to save an objects floating state\n- * across certain code portions (an example is #GtkMenu), to achieve this,\n- * the following sequence can be used:\n- *\n- * |[<!-- language=\"C\" -->\n- * \/\/ save floating state\n- * gboolean was_floating = g_object_is_floating (object);\n- * g_object_ref_sink (object);\n- * \/\/ protected code portion\n- *\n- * ...\n- *\n- * \/\/ restore floating state\n- * if (was_floating)\n- *   g_object_force_floating (object);\n- * else\n- *   g_object_unref (object); \/\/ release previously acquired reference\n- * ]|\n+ * Since GLib 2.72, all `GObject`s are guaranteed to be aligned to at least the\n+ * alignment of the largest basic GLib type (typically this is `guint64` or\n+ * `gdouble`). If you need larger alignment for an element in a `GObject`, you\n+ * should allocate it on the heap (aligned), or arrange for your `GObject` to be\n+ * appropriately padded. This guarantee applies to the `GObject` (or derived)\n+ * struct, the `GObjectClass` (or derived) struct, and any private data allocated\n+ * by `G_ADD_PRIVATE()`.\n@@ -177,0 +105,2 @@\n+#define _OPTIONAL_BIT_LOCK               3\n+\n@@ -180,0 +110,27 @@\n+#define OPTIONAL_FLAG_LOCK               (1 << 3) \/* _OPTIONAL_BIT_LOCK *\/\n+#define OPTIONAL_FLAG_EVER_HAD_WEAK_REF  (1 << 4) \/* whether on the object ever g_weak_ref_set() was called. *\/\n+\n+\/* We use g_bit_lock(), which only supports one lock per integer.\n+ *\n+ * Hence, while we have locks for different purposes, internally they all\n+ * map to the same bit lock (_OPTIONAL_BIT_LOCK).\n+ *\n+ * This means you cannot take a lock (object_bit_lock()) while already holding\n+ * another bit lock. There is an assert against that with G_ENABLE_DEBUG\n+ * builds (_object_bit_is_locked).\n+ *\n+ * In the past, we had different global mutexes per topic. Now we have one\n+ * per-object mutex for several topics. The downside is that we are not as\n+ * parallel as possible. The alternative would be to add individual locking\n+ * integers to GObjectPrivate. But increasing memory usage for more parallelism\n+ * (per-object!) is not worth it. *\/\n+#define OPTIONAL_BIT_LOCK_WEAK_REFS      1\n+#define OPTIONAL_BIT_LOCK_NOTIFY         2\n+#define OPTIONAL_BIT_LOCK_TOGGLE_REFS    3\n+#define OPTIONAL_BIT_LOCK_CLOSURE_ARRAY  4\n+\n+#if SIZEOF_INT == 4 && GLIB_SIZEOF_VOID_P >= 8\n+#define HAVE_OPTIONAL_FLAGS_IN_GOBJECT 1\n+#else\n+#define HAVE_OPTIONAL_FLAGS_IN_GOBJECT 0\n+#endif\n@@ -181,2 +138,13 @@\n-#if SIZEOF_INT == 4 && GLIB_SIZEOF_VOID_P == 8\n-#define HAVE_OPTIONAL_FLAGS\n+\/* For now we only create a private struct if we don't have optional flags in\n+ * GObject. Currently we don't need it otherwise. In the future we might\n+ * always add a private struct. *\/\n+#define HAVE_PRIVATE (!HAVE_OPTIONAL_FLAGS_IN_GOBJECT)\n+\n+#if HAVE_PRIVATE\n+typedef struct {\n+#if !HAVE_OPTIONAL_FLAGS_IN_GOBJECT\n+  guint optional_flags; \/* (atomic) *\/\n+#endif\n+} GObjectPrivate;\n+\n+static int GObject_private_offset;\n@@ -191,1 +159,1 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n+#if HAVE_OPTIONAL_FLAGS_IN_GOBJECT\n@@ -242,0 +210,2 @@\n+static inline void object_set_optional_flags (GObject *object,\n+                                              guint flags);\n@@ -245,1 +215,0 @@\n-static void                weak_locations_free_unlocked (GSList **weak_locations);\n@@ -258,10 +227,4 @@\n-G_LOCK_DEFINE_STATIC (closure_array_mutex);\n-G_LOCK_DEFINE_STATIC (weak_refs_mutex);\n-G_LOCK_DEFINE_STATIC (toggle_refs_mutex);\n-static GQuark               quark_closure_array = 0;\n-static GQuark               quark_weak_refs = 0;\n-static GQuark               quark_toggle_refs = 0;\n-static GQuark               quark_notify_queue;\n-#ifndef HAVE_OPTIONAL_FLAGS\n-static GQuark               quark_in_construction;\n-#endif\n+static GQuark             quark_closure_array = 0;\n+static GQuark             quark_weak_notifies = 0;\n+static GQuark             quark_toggle_refs = 0;\n+static GQuark             quark_notify_queue;\n@@ -269,1 +232,1 @@\n-static gulong               gobject_signals[LAST_SIGNAL] = { 0, };\n+static gulong             gobject_signals[LAST_SIGNAL] = { 0, };\n@@ -271,3 +234,364 @@\n-\/* qdata pointing to GSList<GWeakRef *>, protected by weak_locations_lock *\/\n-static GQuark               quark_weak_locations = 0;\n-static GRWLock              weak_locations_lock;\n+static GQuark             quark_weak_locations = 0;\n+\n+#if HAVE_PRIVATE\n+G_ALWAYS_INLINE static inline GObjectPrivate *\n+g_object_get_instance_private (GObject *object)\n+{\n+  return G_STRUCT_MEMBER_P (object, GObject_private_offset);\n+}\n+#endif\n+\n+G_ALWAYS_INLINE static inline guint *\n+object_get_optional_flags_p (GObject *object)\n+{\n+#if HAVE_OPTIONAL_FLAGS_IN_GOBJECT\n+  return &(((GObjectReal *) object)->optional_flags);\n+#else\n+  return &g_object_get_instance_private (object)->optional_flags;\n+#endif\n+}\n+\n+\/*****************************************************************************\/\n+\n+\/* For GWeakRef, we need to take a lock per-object. However, in various cases\n+ * we cannot take a strong reference on the object to keep it alive. So the\n+ * mutex cannot be in the object itself, because when we want to release the\n+ * lock, we can no longer access object.\n+ *\n+ * Instead, the mutex is on the WeakRefData, which is itself ref-counted\n+ * and has a separate lifetime from the object. *\/\n+typedef struct\n+{\n+  \/* This is both an atomic ref-count and bit 30 (WEAK_REF_DATA_LOCK_BIT) is\n+   * used for g_bit_lock(). *\/\n+  gint atomic_field;\n+\n+  guint16 len;\n+\n+  \/* Only relevant when len > 1. In that case, it's the allocated size of\n+   * \"list.many\" array.  *\/\n+  guint16 alloc;\n+\n+  \/* Only relevant when len > 0. In that case, either \"one\" or \"many\" union\n+   * field is in use. *\/\n+  union\n+  {\n+    GWeakRef *one;\n+    GWeakRef **many;\n+  } list;\n+} WeakRefData;\n+\n+\/* We choose bit 30, and not bit 31. Bit 31 would be the sign for gint, so it\n+ * a bit awkward to use. Note that it probably also would work fine.\n+ *\n+ * But 30 is ok, because it still leaves us space for 2^30-1 references, which\n+ * is more than we ever need. *\/\n+#define WEAK_REF_DATA_LOCK_BIT 30\n+\n+static void weak_ref_data_clear_list (WeakRefData *wrdata, GObject *object);\n+\n+static WeakRefData *\n+weak_ref_data_ref (WeakRefData *wrdata)\n+{\n+  gint ref;\n+\n+#if G_ENABLE_DEBUG\n+  g_assert (wrdata);\n+#endif\n+\n+  ref = g_atomic_int_add (&wrdata->atomic_field, 1);\n+\n+#if G_ENABLE_DEBUG\n+  \/* Overflow is almost impossible to happen, because the user would need to\n+   * spawn that many operating system threads, that all call\n+   * g_weak_ref_{set,get}() in parallel.\n+   *\n+   * Still, assert in debug mode. *\/\n+  g_assert (ref < G_MAXINT32);\n+\n+  \/* the real ref-count would be the following: *\/\n+  ref = (ref + 1) & ~(1 << WEAK_REF_DATA_LOCK_BIT);\n+\n+  \/* assert that the ref-count is still in the valid range. *\/\n+  g_assert (ref > 0 && ref < (1 << WEAK_REF_DATA_LOCK_BIT));\n+#endif\n+  (void) ref;\n+\n+  return wrdata;\n+}\n+\n+static void\n+weak_ref_data_unref (WeakRefData *wrdata)\n+{\n+  if (!wrdata)\n+    return;\n+\n+  \/* Note that we also use WEAK_REF_DATA_LOCK_BIT on \"atomic_field\" as a bit\n+   * lock. However, we will always keep the @wrdata alive (having a reference)\n+   * while holding a lock (otherwise, we couldn't unlock anymore). Thus, at the\n+   * point when we decrement the ref-count to zero, we surely also have the\n+   * @wrdata unlocked.\n+   *\n+   * This means, using \"aomit_field\" both as ref-count and the lock bit is\n+   * fine. *\/\n+\n+  if (!g_atomic_int_dec_and_test (&wrdata->atomic_field))\n+    return;\n+\n+#if G_ENABLE_DEBUG\n+  \/* We expect that the list of weak locations is empty at this point.\n+   * During g_object_unref() (_object_unref_clear_weak_locations()) it\n+   * should have been cleared.\n+   *\n+   * Calling weak_ref_data_clear_list() should be unnecessary. *\/\n+  g_assert (wrdata->len == 0);\n+#endif\n+\n+  g_free_sized (wrdata, sizeof (WeakRefData));\n+}\n+\n+static void\n+weak_ref_data_lock (WeakRefData *wrdata)\n+{\n+  \/* Note that while holding a _weak_ref_lock() on the @weak_ref, we MUST not acquire a\n+   * weak_ref_data_lock() on the @wrdata. The other way around! *\/\n+  if (wrdata)\n+    g_bit_lock (&wrdata->atomic_field, WEAK_REF_DATA_LOCK_BIT);\n+}\n+\n+static void\n+weak_ref_data_unlock (WeakRefData *wrdata)\n+{\n+  if (wrdata)\n+    g_bit_unlock (&wrdata->atomic_field, WEAK_REF_DATA_LOCK_BIT);\n+}\n+\n+static gpointer\n+weak_ref_data_get_or_create_cb (GQuark key_id,\n+                                gpointer *data,\n+                                GDestroyNotify *destroy_notify,\n+                                gpointer user_data)\n+{\n+  WeakRefData *wrdata = *data;\n+  GObject *object = user_data;\n+\n+  if (!wrdata)\n+    {\n+      wrdata = g_new (WeakRefData, 1);\n+\n+      \/* The initial ref-count is 1. This one is owned by the GData until the\n+       * object gets destroyed.\n+       *\n+       * The WEAK_REF_DATA_LOCK_BIT bit is of course initially unset.  *\/\n+      wrdata->atomic_field = 1;\n+      wrdata->len = 0;\n+      \/* Other fields are left uninitialized. They are only considered with a positive @len. *\/\n+\n+      *data = wrdata;\n+      *destroy_notify = (GDestroyNotify) weak_ref_data_unref;\n+\n+      \/* Mark the @object that it was ever involved with GWeakRef. This flag\n+       * will stick until @object gets destroyed, just like the WeakRefData\n+       * also won't be freed for the remainder of the life of @object. *\/\n+      object_set_optional_flags (object, OPTIONAL_FLAG_EVER_HAD_WEAK_REF);\n+    }\n+\n+  return wrdata;\n+}\n+\n+static WeakRefData *\n+weak_ref_data_get_or_create (GObject *object)\n+{\n+  if (!object)\n+    return NULL;\n+\n+  return _g_datalist_id_update_atomic (&object->qdata,\n+                                       quark_weak_locations,\n+                                       weak_ref_data_get_or_create_cb,\n+                                       object);\n+}\n+\n+static WeakRefData *\n+weak_ref_data_get (GObject *object)\n+{\n+  return g_datalist_id_get_data (&object->qdata, quark_weak_locations);\n+}\n+\n+static WeakRefData *\n+weak_ref_data_get_surely (GObject *object)\n+{\n+  WeakRefData *wrdata;\n+\n+  \/* The \"surely\" part is about that we expect to have a WeakRefData.\n+   *\n+   * Note that once a GObject gets a WeakRefData (during g_weak_ref_set() and\n+   * weak_ref_data_get_or_create()), it sticks and is not freed until the\n+   * object gets destroyed.\n+   *\n+   * Maybe we could release the unused WeakRefData in g_weak_ref_set(), but\n+   * then we would always need to take a reference during weak_ref_data_get().\n+   * That is likely not worth it. *\/\n+\n+  wrdata = weak_ref_data_get (object);\n+#if G_ENABLE_DEBUG\n+  g_assert (wrdata);\n+#endif\n+  return wrdata;\n+}\n+\n+static gint32\n+weak_ref_data_list_find (WeakRefData *wrdata, GWeakRef *weak_ref)\n+{\n+  if (wrdata->len == 1u)\n+    {\n+      if (wrdata->list.one == weak_ref)\n+        return 0;\n+    }\n+  else\n+    {\n+      guint16 i;\n+\n+      for (i = 0; i < wrdata->len; i++)\n+        {\n+          if (wrdata->list.many[i] == weak_ref)\n+            return i;\n+        }\n+    }\n+\n+  return -1;\n+}\n+\n+static gboolean\n+weak_ref_data_list_add (WeakRefData *wrdata, GWeakRef *weak_ref)\n+{\n+  if (wrdata->len == 0u)\n+    wrdata->list.one = weak_ref;\n+  else\n+    {\n+      if (wrdata->len == 1u)\n+        {\n+          GWeakRef *weak_ref2 = wrdata->list.one;\n+\n+          wrdata->alloc = 4u;\n+          wrdata->list.many = g_new (GWeakRef *, wrdata->alloc);\n+          wrdata->list.many[0] = weak_ref2;\n+        }\n+      else if (wrdata->len == wrdata->alloc)\n+        {\n+          guint16 alloc;\n+\n+          alloc = wrdata->alloc * 2u;\n+          if (G_UNLIKELY (alloc < wrdata->len))\n+            {\n+              if (wrdata->len == G_MAXUINT16)\n+                return FALSE;\n+              alloc = G_MAXUINT16;\n+            }\n+          wrdata->list.many = g_renew (GWeakRef *, wrdata->list.many, alloc);\n+          wrdata->alloc = alloc;\n+        }\n+\n+      wrdata->list.many[wrdata->len] = weak_ref;\n+    }\n+\n+  wrdata->len++;\n+  return TRUE;\n+}\n+\n+static GWeakRef *\n+weak_ref_data_list_remove (WeakRefData *wrdata, guint16 idx, gboolean allow_shrink)\n+{\n+  GWeakRef *weak_ref;\n+\n+#if G_ENABLE_DEBUG\n+  g_assert (idx < wrdata->len);\n+#endif\n+\n+  wrdata->len--;\n+\n+  if (wrdata->len == 0u)\n+    {\n+      weak_ref = wrdata->list.one;\n+    }\n+  else\n+    {\n+      weak_ref = wrdata->list.many[idx];\n+\n+      if (wrdata->len == 1u)\n+        {\n+          GWeakRef *weak_ref2 = wrdata->list.many[idx == 0 ? 1 : 0];\n+\n+          g_free (wrdata->list.many);\n+          wrdata->list.one = weak_ref2;\n+        }\n+      else\n+        {\n+          wrdata->list.many[idx] = wrdata->list.many[wrdata->len];\n+\n+          if (allow_shrink && G_UNLIKELY (wrdata->len <= wrdata->alloc \/ 4u))\n+            {\n+              \/* Shrink the buffer. When 75% are empty, shrink it to 50%. *\/\n+              if (wrdata->alloc == G_MAXUINT16)\n+                wrdata->alloc = ((guint32) G_MAXUINT16 + 1u) \/ 2u;\n+              else\n+                wrdata->alloc \/= 2u;\n+              wrdata->list.many = g_renew (GWeakRef *, wrdata->list.many, wrdata->alloc);\n+            }\n+        }\n+    }\n+\n+  return weak_ref;\n+}\n+\n+static gboolean\n+weak_ref_data_has (GObject *object, WeakRefData *wrdata, WeakRefData **out_new_wrdata)\n+{\n+  WeakRefData *wrdata2;\n+\n+  \/* Check whether @object has @wrdata as WeakRefData. Note that an GObject's\n+   * WeakRefData never changes (until destruction, once it's allocated).\n+   *\n+   * If you thus hold a reference to a @wrdata, you can check that the @object\n+   * is still the same as the object where we got the @wrdata originally from.\n+   *\n+   * You couldn't do this check by using pointer equality of the GObject pointers,\n+   * when you cannot hold strong references on the objects involved. Because then\n+   * the object pointer might be dangling (and even destroyed and recreated as another\n+   * object at the same memory location).\n+   *\n+   * Basically, weak_ref_data_has() is to compare for equality of two GObject pointers,\n+   * when we cannot hold a strong reference on both. Instead, we earlier took a reference\n+   * on the @wrdata and compare that instead.\n+   *\/\n+\n+  if (!object)\n+    {\n+      \/* If @object is NULL, then it does have a NULL @wrdata, and we return\n+       * TRUE in the case.  That's a convenient special case for some callers.\n+       *\n+       * In other words, weak_ref_data_has(NULL, NULL, out_new_wrdata) is TRUE.\n+       *\/\n+#if G_ENABLE_DEBUG\n+      g_assert (!out_new_wrdata);\n+#endif\n+      return !wrdata;\n+    }\n+\n+  if (!wrdata)\n+    {\n+      \/* We only call this function with an @object that was previously\n+       * registered as GWeakRef.\n+       *\n+       * That means, our @object will have a wrdata, and the result of the\n+       * evaluation will be %FALSE. *\/\n+      if (out_new_wrdata)\n+        *out_new_wrdata = weak_ref_data_ref (weak_ref_data_get (object));\n+#if G_ENABLE_DEBUG\n+      g_assert (out_new_wrdata\n+                    ? *out_new_wrdata\n+                    : weak_ref_data_get (object));\n+#endif\n+      return FALSE;\n+    }\n+\n+  wrdata2 = weak_ref_data_get_surely (object);\n@@ -275,1 +599,53 @@\n-G_LOCK_DEFINE_STATIC(notify_lock);\n+  if (wrdata == wrdata2)\n+    {\n+      if (out_new_wrdata)\n+        *out_new_wrdata = NULL;\n+      return TRUE;\n+    }\n+\n+  if (out_new_wrdata)\n+    *out_new_wrdata = weak_ref_data_ref (wrdata2);\n+  return FALSE;\n+}\n+\n+\/*****************************************************************************\/\n+\n+#if defined(G_ENABLE_DEBUG) && defined(G_THREAD_LOCAL)\n+\/* Using this thread-local global is sufficient to guard the per-object\n+ * locking, because while the current thread holds a lock on one object, it\n+ * never calls out to another object (because doing so would would be prone to\n+ * deadlock). *\/\n+static G_THREAD_LOCAL guint _object_bit_is_locked;\n+#endif\n+\n+static void\n+object_bit_lock (GObject *object, guint lock_bit)\n+{\n+#if defined(G_ENABLE_DEBUG) && defined(G_THREAD_LOCAL)\n+  \/* all object_bit_lock() really use the same bit\/mutex. The \"lock_bit\" argument\n+   * only exists for asserting. object_bit_lock() is not re-entrant (also not with\n+   * different \"lock_bit\" values). *\/\n+  g_assert (lock_bit > 0);\n+  g_assert (_object_bit_is_locked == 0);\n+  _object_bit_is_locked = lock_bit;\n+#endif\n+\n+  g_bit_lock ((gint *) object_get_optional_flags_p (object), _OPTIONAL_BIT_LOCK);\n+}\n+\n+static void\n+object_bit_unlock (GObject *object, guint lock_bit)\n+{\n+#if defined(G_ENABLE_DEBUG) && defined(G_THREAD_LOCAL)\n+  \/* All lock_bit map to the same mutex. We cannot use two different locks on\n+   * the same integer. Assert against that. *\/\n+  g_assert (lock_bit > 0);\n+  g_assert (_object_bit_is_locked == lock_bit);\n+  _object_bit_is_locked = 0;\n+#endif\n+\n+  \/* Warning: after unlock, @object may be a dangling pointer (destroyed on\n+   * another thread) and must not be touched anymore. *\/\n+\n+  g_bit_unlock ((gint *) object_get_optional_flags_p (object), _OPTIONAL_BIT_LOCK);\n+}\n@@ -284,1 +660,1 @@\n-  g_slice_free (GObjectNotifyQueue, nqueue);\n+  g_free_sized (nqueue, sizeof (GObjectNotifyQueue));\n@@ -287,3 +663,2 @@\n-static GObjectNotifyQueue*\n-g_object_notify_queue_freeze (GObject  *object,\n-                              gboolean  conditional)\n+static GObjectNotifyQueue *\n+g_object_notify_queue_create_queue_frozen (GObject *object)\n@@ -293,1 +668,18 @@\n-  G_LOCK(notify_lock);\n+  nqueue = g_new0 (GObjectNotifyQueue, 1);\n+\n+  *nqueue = (GObjectNotifyQueue){\n+    .freeze_count = 1,\n+  };\n+\n+  g_datalist_id_set_data_full (&object->qdata, quark_notify_queue,\n+                               nqueue, g_object_notify_queue_free);\n+\n+  return nqueue;\n+}\n+\n+static GObjectNotifyQueue *\n+g_object_notify_queue_freeze (GObject *object)\n+{\n+  GObjectNotifyQueue *nqueue;\n+\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n@@ -297,9 +689,2 @@\n-      if (conditional)\n-        {\n-          G_UNLOCK(notify_lock);\n-          return NULL;\n-        }\n-\n-      nqueue = g_slice_new0 (GObjectNotifyQueue);\n-      g_datalist_id_set_data_full (&object->qdata, quark_notify_queue,\n-                                   nqueue, g_object_notify_queue_free);\n+      nqueue = g_object_notify_queue_create_queue_frozen (object);\n+      goto out;\n@@ -316,1 +701,2 @@\n-  G_UNLOCK(notify_lock);\n+out:\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n@@ -323,1 +709,2 @@\n-                            GObjectNotifyQueue *nqueue)\n+                            GObjectNotifyQueue *nqueue,\n+                            gboolean take_ref)\n@@ -329,1 +716,7 @@\n-  G_LOCK(notify_lock);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n+\n+  if (!nqueue)\n+    {\n+      \/* Caller didn't look up the queue yet. Do it now. *\/\n+      nqueue = g_datalist_id_get_data (&object->qdata, quark_notify_queue);\n+    }\n@@ -332,1 +725,1 @@\n-  if (G_UNLIKELY (nqueue->freeze_count == 0))\n+  if (G_UNLIKELY (!nqueue || nqueue->freeze_count == 0))\n@@ -334,1 +727,1 @@\n-      G_UNLOCK (notify_lock);\n+      object_bit_unlock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n@@ -343,1 +736,1 @@\n-      G_UNLOCK (notify_lock);\n+      object_bit_unlock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n@@ -355,1 +748,1 @@\n-  G_UNLOCK(notify_lock);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n@@ -358,1 +751,9 @@\n-    G_OBJECT_GET_CLASS (object)->dispatch_properties_changed (object, n_pspecs, pspecs);\n+    {\n+      if (take_ref)\n+        g_object_ref (object);\n+\n+      G_OBJECT_GET_CLASS (object)->dispatch_properties_changed (object, n_pspecs, pspecs);\n+\n+      if (take_ref)\n+        g_object_unref (object);\n+    }\n@@ -362,1 +763,1 @@\n-static void\n+static gboolean\n@@ -365,1 +766,2 @@\n-                           GParamSpec         *pspec)\n+                           GParamSpec         *pspec,\n+                           gboolean            in_init)\n@@ -367,1 +769,28 @@\n-  G_LOCK(notify_lock);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n+\n+  if (!nqueue)\n+    {\n+      \/* We are called without an nqueue. Figure out whether a notification\n+       * should be queued. *\/\n+      nqueue = g_datalist_id_get_data (&object->qdata, quark_notify_queue);\n+\n+      if (!nqueue)\n+        {\n+          if (!in_init)\n+            {\n+              \/* We don't have a notify queue and are not in_init. The event\n+               * is not to be queued. The caller will dispatch directly. *\/\n+              object_bit_unlock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n+              return FALSE;\n+            }\n+\n+          \/* We are \"in_init\", but did not freeze the queue in g_object_init\n+           * yet. Instead, we gained a notify handler in instance init, so now\n+           * we need to freeze just-in-time.\n+           *\n+           * Note that this freeze will be balanced at the end of object\n+           * initialization.\n+           *\/\n+          nqueue = g_object_notify_queue_create_queue_frozen (object);\n+        }\n+    }\n@@ -377,1 +806,3 @@\n-  G_UNLOCK(notify_lock);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_NOTIFY);\n+\n+  return TRUE;\n@@ -475,0 +906,25 @@\n+\n+#if HAVE_PRIVATE\n+  GObject_private_offset =\n+      g_type_add_instance_private (G_TYPE_OBJECT, sizeof (GObjectPrivate));\n+#endif\n+}\n+\n+\/* Initialize the global GParamSpecPool; this function needs to be\n+ * called whenever we access the GParamSpecPool and we cannot guarantee\n+ * that g_object_do_class_init() has been called: for instance, by the\n+ * interface property API.\n+ *\n+ * To avoid yet another global lock, we use atomic pointer checks: the\n+ * first caller of this function will win the race. Any other access to\n+ * the GParamSpecPool is done under its own mutex.\n+ *\/\n+static inline void\n+g_object_init_pspec_pool (void)\n+{\n+  if (G_UNLIKELY (g_atomic_pointer_get (&pspec_pool) == NULL))\n+    {\n+      GParamSpecPool *pool = g_param_spec_pool_new (TRUE);\n+      if (!g_atomic_pointer_compare_and_exchange (&pspec_pool, NULL, pool))\n+        g_param_spec_pool_free (pool);\n+    }\n@@ -522,1 +978,0 @@\n-  \/* read the comment about typedef struct CArray; on why not to change this quark *\/\n@@ -524,2 +979,1 @@\n-\n-  quark_weak_refs = g_quark_from_static_string (\"GObject-weak-references\");\n+  quark_weak_notifies = g_quark_from_static_string (\"GObject-weak-notifies\");\n@@ -529,4 +983,2 @@\n-#ifndef HAVE_OPTIONAL_FLAGS\n-  quark_in_construction = g_quark_from_static_string (\"GObject-in-construction\");\n-#endif\n-  pspec_pool = g_param_spec_pool_new (TRUE);\n+\n+  g_object_init_pspec_pool ();\n@@ -588,0 +1040,4 @@\n+\n+#if HAVE_PRIVATE\n+  g_type_class_adjust_private_offset (class, &GObject_private_offset);\n+#endif\n@@ -598,0 +1054,2 @@\n+  g_object_init_pspec_pool ();\n+\n@@ -822,1 +1280,1 @@\n- *     g_param_spec_int (\"foo\", \"Foo\", \"Foo\",\n+ *     g_param_spec_int (\"foo\", NULL, NULL,\n@@ -828,1 +1286,1 @@\n- *     g_param_spec_string (\"bar\", \"Bar\", \"Bar\",\n+ *     g_param_spec_string (\"bar\", NULL, NULL,\n@@ -1024,0 +1482,2 @@\n+  g_object_init_pspec_pool ();\n+\n@@ -1149,4 +1609,4 @@\n- *          pointer to an array of pointers to #GParamSpec\n- *          structures. The paramspecs are owned by GLib, but the\n- *          array should be freed with g_free() when you are done with\n- *          it.\n+ *   pointer to an array of pointers to #GParamSpec\n+ *   structures. The paramspecs are owned by GLib, but the\n+ *   array should be freed with g_free() when you are done with\n+ *   it.\n@@ -1164,0 +1624,2 @@\n+  g_object_init_pspec_pool ();\n+\n@@ -1176,21 +1638,1 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n-  GObjectReal *real = (GObjectReal *)object;\n-  return (guint)g_atomic_int_get (&real->optional_flags);\n-#else\n-  return 0;\n-#endif\n-}\n-\n-\/* Variant of object_get_optional_flags for when\n- * we know that we have exclusive access (during\n- * construction)\n- *\/\n-static inline guint\n-object_get_optional_flags_X (GObject *object)\n-{\n-#ifdef HAVE_OPTIONAL_FLAGS\n-  GObjectReal *real = (GObjectReal *)object;\n-  return real->optional_flags;\n-#else\n-  return 0;\n-#endif\n+  return g_atomic_int_get (object_get_optional_flags_p (object));\n@@ -1199,1 +1641,0 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n@@ -1204,2 +1645,1 @@\n-  GObjectReal *real = (GObjectReal *)object;\n-  g_atomic_int_or (&real->optional_flags, flags);\n+  g_atomic_int_or (object_get_optional_flags_p (object), flags);\n@@ -1208,14 +1648,0 @@\n-\/* Variant for when we have exclusive access\n- * (during construction)\n- *\/\n-static inline void\n-object_set_optional_flags_X (GObject *object,\n-                             guint flags)\n-{\n-  GObjectReal *real = (GObjectReal *)object;\n-  real->optional_flags |= flags;\n-}\n-\n-\/* Variant for when we have exclusive access\n- * (during construction)\n- *\/\n@@ -1223,1 +1649,1 @@\n-object_unset_optional_flags_X (GObject *object,\n+object_unset_optional_flags (GObject *object,\n@@ -1226,2 +1652,1 @@\n-  GObjectReal *real = (GObjectReal *)object;\n-  real->optional_flags &= ~flags;\n+  g_atomic_int_and (object_get_optional_flags_p (object), ~flags);\n@@ -1229,1 +1654,0 @@\n-#endif\n@@ -1234,1 +1658,0 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n@@ -1236,3 +1659,0 @@\n-#else\n-  return TRUE;\n-#endif\n@@ -1244,1 +1664,0 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n@@ -1247,14 +1666,0 @@\n-#else\n-  return TRUE;\n-#endif\n-}\n-\n-static inline gboolean\n-_g_object_has_notify_handler_X (GObject *object)\n-{\n-#ifdef HAVE_OPTIONAL_FLAGS\n-  return CLASS_NEEDS_NOTIFY (G_OBJECT_GET_CLASS (object)) ||\n-         (object_get_optional_flags_X (object) & OPTIONAL_FLAG_HAS_NOTIFY_HANDLER) != 0;\n-#else\n-  return TRUE;\n-#endif\n@@ -1267,1 +1672,0 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n@@ -1272,1 +1676,0 @@\n-#endif\n@@ -1278,1 +1681,0 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n@@ -1280,3 +1682,0 @@\n-#else\n-  return g_datalist_id_get_data (&object->qdata, quark_in_construction) != NULL;\n-#endif\n@@ -1288,5 +1687,1 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n-  object_set_optional_flags_X (object, OPTIONAL_FLAG_IN_CONSTRUCTION);\n-#else\n-  g_datalist_id_set_data (&object->qdata, quark_in_construction, object);\n-#endif\n+  object_set_optional_flags (object, OPTIONAL_FLAG_IN_CONSTRUCTION);\n@@ -1298,5 +1693,1 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n-  object_unset_optional_flags_X (object, OPTIONAL_FLAG_IN_CONSTRUCTION);\n-#else\n-  g_datalist_id_set_data (&object->qdata, quark_in_construction, NULL);\n-#endif\n+  object_unset_optional_flags (object, OPTIONAL_FLAG_IN_CONSTRUCTION);\n@@ -1315,1 +1706,1 @@\n-      g_object_notify_queue_freeze (object, FALSE);\n+      g_object_notify_queue_freeze (object);\n@@ -1362,0 +1753,3 @@\n+\n+  \/* GWeakNotify and GClosure can call into user code *\/\n+  g_datalist_id_set_data (&object->qdata, quark_weak_notifies, NULL);\n@@ -1363,2 +1757,0 @@\n-  g_datalist_id_set_data (&object->qdata, quark_weak_refs, NULL);\n-  g_datalist_id_set_data (&object->qdata, quark_weak_locations, NULL);\n@@ -1442,0 +1834,2 @@\n+  WeakRefData *wrdata;\n+\n@@ -1446,0 +1840,1 @@\n+\n@@ -1449,0 +1844,9 @@\n+\n+  if ((object_get_optional_flags (object) & OPTIONAL_FLAG_EVER_HAD_WEAK_REF))\n+    {\n+      wrdata = weak_ref_data_get_surely (object);\n+      weak_ref_data_lock (wrdata);\n+      weak_ref_data_clear_list (wrdata, object);\n+      weak_ref_data_unlock (wrdata);\n+    }\n+\n@@ -1472,1 +1876,1 @@\n-  if (G_UNLIKELY (g_atomic_int_get (&object->ref_count) == 0))\n+  if (G_UNLIKELY (g_atomic_int_get (&object->ref_count) <= 0))\n@@ -1482,3 +1886,1 @@\n-  g_object_ref (object);\n-  g_object_notify_queue_freeze (object, FALSE);\n-  g_object_unref (object);\n+  g_object_notify_queue_freeze (object);\n@@ -1491,1 +1893,0 @@\n-  #ifdef HAVE_OPTIONAL_FLAGS\n@@ -1493,1 +1894,0 @@\n-#endif\n@@ -1502,1 +1902,0 @@\n-#ifdef HAVE_OPTIONAL_FLAGS\n@@ -1508,4 +1907,0 @@\n-#else\n-  needs_notify = TRUE;\n-  in_init = object_in_construction (object);\n-#endif\n@@ -1515,23 +1910,1 @@\n-      GObjectNotifyQueue *nqueue;\n-      gboolean need_thaw = TRUE;\n-\n-      \/* conditional freeze: only increase freeze count if already frozen *\/\n-      nqueue = g_object_notify_queue_freeze (object, TRUE);\n-      if (in_init && !nqueue)\n-        {\n-          \/* We did not freeze the queue in g_object_init, but\n-           * we gained a notify handler in instance init, so\n-           * now we need to freeze just-in-time\n-           *\/\n-          nqueue = g_object_notify_queue_freeze (object, FALSE);\n-          need_thaw = FALSE;\n-        }\n-\n-      if (nqueue != NULL)\n-        {\n-          \/* we're frozen, so add to the queue and release our freeze *\/\n-          g_object_notify_queue_add (object, nqueue, pspec);\n-          if (need_thaw)\n-            g_object_notify_queue_thaw (object, nqueue);\n-        }\n-      else\n+      if (!g_object_notify_queue_add (object, NULL, pspec, in_init))\n@@ -1631,1 +2004,1 @@\n- *     properties[PROP_FOO] = g_param_spec_int (\"foo\", \"Foo\", \"The foo\",\n+ *     properties[PROP_FOO] = g_param_spec_int (\"foo\", NULL, NULL,\n@@ -1677,2 +2050,0 @@\n-  GObjectNotifyQueue *nqueue;\n-\n@@ -1682,1 +2053,1 @@\n-  if (G_UNLIKELY (g_atomic_int_get (&object->ref_count) == 0))\n+  if (G_UNLIKELY (g_atomic_int_get (&object->ref_count) <= 0))\n@@ -1692,11 +2063,1 @@\n-\n-  g_object_ref (object);\n-\n-  \/* FIXME: Freezing is the only way to get at the notify queue.\n-   * So we freeze once and then thaw twice.\n-   *\/\n-  nqueue = g_object_notify_queue_freeze (object, FALSE);\n-  g_object_notify_queue_thaw (object, nqueue);\n-  g_object_notify_queue_thaw (object, nqueue);\n-\n-  g_object_unref (object);\n+  g_object_notify_queue_thaw (object, NULL, TRUE);\n@@ -1713,1 +2074,1 @@\n-  if (g_once_init_enter (&enable_diagnostic))\n+  if (g_once_init_enter_pointer (&enable_diagnostic))\n@@ -1720,1 +2081,1 @@\n-      g_once_init_leave (&enable_diagnostic, value);\n+      g_once_init_leave_pointer (&enable_diagnostic, value);\n@@ -1846,1 +2207,1 @@\n-    g_object_notify_queue_add (object, nqueue, pspec);\n+    g_object_notify_queue_add (object, nqueue, pspec, FALSE);\n@@ -2205,1 +2566,1 @@\n-      if ((newly_constructed && _g_object_has_notify_handler_X (object)) ||\n+      if ((newly_constructed && _g_object_has_notify_handler (object)) ||\n@@ -2213,1 +2574,1 @@\n-            nqueue = g_object_notify_queue_freeze (object, FALSE);\n+            nqueue = g_object_notify_queue_freeze (object);\n@@ -2228,1 +2589,1 @@\n-    g_object_notify_queue_thaw (object, nqueue);\n+    g_object_notify_queue_thaw (object, nqueue, FALSE);\n@@ -2255,1 +2616,1 @@\n-      if (_g_object_has_notify_handler_X (object))\n+      if (_g_object_has_notify_handler (object))\n@@ -2262,1 +2623,1 @@\n-            nqueue = g_object_notify_queue_freeze (object, FALSE);\n+            nqueue = g_object_notify_queue_freeze (object);\n@@ -2306,1 +2667,1 @@\n-    g_object_notify_queue_thaw (object, nqueue);\n+    g_object_notify_queue_thaw (object, nqueue, FALSE);\n@@ -2625,1 +2986,1 @@\n-      GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object, FALSE);\n+      GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object);\n@@ -2636,1 +2997,1 @@\n-      g_object_notify_queue_thaw (object, nqueue);\n+      g_object_notify_queue_thaw (object, nqueue, FALSE);\n@@ -2713,1 +3074,1 @@\n-    nqueue = g_object_notify_queue_freeze (object, FALSE);\n+    nqueue = g_object_notify_queue_freeze (object);\n@@ -2726,1 +3087,1 @@\n-    g_object_notify_queue_thaw (object, nqueue);\n+    g_object_notify_queue_thaw (object, nqueue, FALSE);\n@@ -2754,1 +3115,1 @@\n-    nqueue = g_object_notify_queue_freeze (object, FALSE);\n+    nqueue = g_object_notify_queue_freeze (object);\n@@ -2792,1 +3153,1 @@\n-    g_object_notify_queue_thaw (object, nqueue);\n+    g_object_notify_queue_thaw (object, nqueue, FALSE);\n@@ -3318,2 +3679,2 @@\n-  G_LOCK (weak_refs_mutex);\n-  wstack = g_datalist_id_remove_no_notify (&object->qdata, quark_weak_refs);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_WEAK_REFS);\n+  wstack = g_datalist_id_remove_no_notify (&object->qdata, quark_weak_notifies);\n@@ -3334,2 +3695,2 @@\n-  g_datalist_id_set_data_full (&object->qdata, quark_weak_refs, wstack, weak_refs_notify);\n-  G_UNLOCK (weak_refs_mutex);\n+  g_datalist_id_set_data_full (&object->qdata, quark_weak_notifies, wstack, weak_refs_notify);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_WEAK_REFS);\n@@ -3357,2 +3718,2 @@\n-  G_LOCK (weak_refs_mutex);\n-  wstack = g_datalist_id_get_data (&object->qdata, quark_weak_refs);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_WEAK_REFS);\n+  wstack = g_datalist_id_get_data (&object->qdata, quark_weak_notifies);\n@@ -3375,1 +3736,1 @@\n-  G_UNLOCK (weak_refs_mutex);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_WEAK_REFS);\n@@ -3441,1 +3802,1 @@\n-        (void *) ((gsize) oldvalue | OBJECT_FLOATING_FLAG),\n+        (void *) ((guintptr) oldvalue | OBJECT_FLOATING_FLAG),\n@@ -3449,1 +3810,1 @@\n-        (void *) ((gsize) oldvalue & ~(gsize) OBJECT_FLOATING_FLAG),\n+        (void *) ((guintptr) oldvalue & ~(gsize) OBJECT_FLOATING_FLAG),\n@@ -3587,1 +3948,0 @@\n-  GObject *object;\n@@ -3595,3 +3955,6 @@\n-static void\n-toggle_refs_notify (GObject *object,\n-        gboolean is_last_ref)\n+G_ALWAYS_INLINE static inline gboolean\n+toggle_refs_check_and_ref_or_deref (GObject *object,\n+                                    gboolean is_ref,\n+                                    gint *old_ref,\n+                                    GToggleNotify *toggle_notify,\n+                                    gpointer *toggle_data)\n@@ -3599,1 +3962,3 @@\n-  ToggleRefStack tstack, *tstackptr;\n+  const gint ref_curr = is_ref ? 1 : 2;\n+  const gint ref_next = is_ref ? 2 : 1;\n+  gboolean success;\n@@ -3601,6 +3966,32 @@\n-  G_LOCK (toggle_refs_mutex);\n-  \/* If another thread removed the toggle reference on the object, while\n-   * we were waiting here, there's nothing to notify.\n-   * So let's check again if the object has toggle reference and in case return.\n-   *\/\n-  if (!OBJECT_HAS_TOGGLE_REF (object))\n+#if G_ENABLE_DEBUG\n+  g_assert (ref_curr == *old_ref);\n+#endif\n+\n+  *toggle_notify = NULL;\n+  *toggle_data = NULL;\n+\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_TOGGLE_REFS);\n+\n+  \/* @old_ref is mainly an (out) parameter. On failure to compare-and-exchange,\n+   * we MUST return the new value which the caller will use for retry.*\/\n+\n+  success = g_atomic_int_compare_and_exchange_full ((int *) &object->ref_count,\n+                                                    ref_curr,\n+                                                    ref_next,\n+                                                    old_ref);\n+\n+  \/* Note that if we are called during g_object_unref (@is_ref set to FALSE),\n+   * then we drop the ref count from 2 to 1 and give up our reference. We thus\n+   * no longer hold a strong reference and another thread may race against\n+   * destroying the object.\n+   *\n+   * After this point with is_ref=FALSE and success=TRUE, @object must no\n+   * longer be accessed.\n+   *\n+   * The exception is here. While we still hold the object lock, we know that\n+   * @object could not be destroyed, because g_object_unref() also needs to\n+   * acquire the same lock during g_object_notify_queue_freeze(). Thus, we know\n+   * object cannot yet be destroyed and we can access it until the unlock\n+   * below. *\/\n+\n+  if (success && OBJECT_HAS_TOGGLE_REF (object))\n@@ -3608,2 +3999,13 @@\n-      G_UNLOCK (toggle_refs_mutex);\n-      return;\n+      ToggleRefStack *tstackptr;\n+\n+      tstackptr = g_datalist_id_get_data (&object->qdata, quark_toggle_refs);\n+\n+      if (tstackptr->n_toggle_refs != 1)\n+        {\n+          g_critical (\"Unexpected number of toggle-refs. g_object_add_toggle_ref() must be paired with g_object_remove_toggle_ref()\");\n+        }\n+      else\n+        {\n+          *toggle_notify = tstackptr->toggle_refs[0].notify;\n+          *toggle_data = tstackptr->toggle_refs[0].data;\n+        }\n@@ -3612,3 +4014,1 @@\n-  tstackptr = g_datalist_id_get_data (&object->qdata, quark_toggle_refs);\n-  tstack = *tstackptr;\n-  G_UNLOCK (toggle_refs_mutex);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_TOGGLE_REFS);\n@@ -3616,5 +4016,1 @@\n-  \/* Reentrancy here is not as tricky as it seems, because a toggle reference\n-   * will only be notified when there is exactly one of them.\n-   *\/\n-  g_assert (tstack.n_toggle_refs == 1);\n-  tstack.toggle_refs[0].notify (tstack.toggle_refs[0].data, tstack.object, is_last_ref);\n+  return success;\n@@ -3660,0 +4056,7 @@\n+ * Note that if you unref the object on another thread, then @notify might\n+ * still be invoked after g_object_remove_toggle_ref(), and the object argument\n+ * might be a dangling pointer. If the object is destroyed on other threads,\n+ * you must take care of that yourself.\n+ *\n+ * A g_object_add_toggle_ref() must be released with g_object_remove_toggle_ref().\n+ *\n@@ -3676,1 +4079,1 @@\n-  G_LOCK (toggle_refs_mutex);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_TOGGLE_REFS);\n@@ -3688,1 +4091,0 @@\n-      tstack->object = object;\n@@ -3701,1 +4103,1 @@\n-  G_UNLOCK (toggle_refs_mutex);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_TOGGLE_REFS);\n@@ -3716,0 +4118,5 @@\n+ * Note that if you unref the object on another thread, then @notify might\n+ * still be invoked after g_object_remove_toggle_ref(), and the object argument\n+ * might be a dangling pointer. If the object is destroyed on other threads,\n+ * you must take care of that yourself.\n+ *\n@@ -3729,1 +4136,1 @@\n-  G_LOCK (toggle_refs_mutex);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_TOGGLE_REFS);\n@@ -3745,1 +4152,52 @@\n-              g_datalist_unset_flags (&object->qdata, OBJECT_HAS_TOGGLE_REF_FLAG);\n+              {\n+                g_datalist_unset_flags (&object->qdata, OBJECT_HAS_TOGGLE_REF_FLAG);\n+                g_datalist_id_set_data_full (&object->qdata, quark_toggle_refs, NULL, NULL);\n+              }\n+\n+            break;\n+          }\n+    }\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_TOGGLE_REFS);\n+\n+  if (found_one)\n+    g_object_unref (object);\n+  else\n+    g_critical (\"%s: couldn't find toggle ref %p(%p)\", G_STRFUNC, notify, data);\n+}\n+\n+\/* Internal implementation of g_object_ref() which doesn't call out to user code.\n+ * @out_toggle_notify and @out_toggle_data *must* be provided, and if non-`NULL`\n+ * values are returned, then the caller *must* call that toggle notify function\n+ * as soon as it is safe to do so. It may call (or be) user-provided code so should\n+ * only be called once all locks are released. *\/\n+static gpointer\n+object_ref (GObject *object,\n+            GToggleNotify *out_toggle_notify,\n+            gpointer *out_toggle_data)\n+{\n+  GToggleNotify toggle_notify;\n+  gpointer toggle_data;\n+  gint old_ref;\n+\n+  old_ref = g_atomic_int_get (&object->ref_count);\n+\n+retry:\n+  toggle_notify = NULL;\n+  toggle_data = NULL;\n+  if (old_ref > 1 && old_ref < G_MAXINT)\n+    {\n+      \/* Fast-path. We have apparently more than 1 references already. No\n+       * special handling for toggle references, just increment the ref count. *\/\n+      if (!g_atomic_int_compare_and_exchange_full ((int *) &object->ref_count,\n+                                                   old_ref, old_ref + 1, &old_ref))\n+        goto retry;\n+    }\n+  else if (old_ref == 1)\n+    {\n+      \/* With ref count 1, check whether we need to emit a toggle notification. *\/\n+      if (!toggle_refs_check_and_ref_or_deref (object, TRUE, &old_ref, &toggle_notify, &toggle_data))\n+        goto retry;\n+    }\n+  else\n+    {\n+      gboolean object_already_finalized = TRUE;\n@@ -3747,2 +4205,4 @@\n-            break;\n-          }\n+      *out_toggle_notify = NULL;\n+      *out_toggle_data = NULL;\n+      g_return_val_if_fail (!object_already_finalized, NULL);\n+      return NULL;\n@@ -3750,1 +4210,0 @@\n-  G_UNLOCK (toggle_refs_mutex);\n@@ -3752,4 +4211,5 @@\n-  if (found_one)\n-    g_object_unref (object);\n-  else\n-    g_critical (\"%s: couldn't find toggle ref %p(%p)\", G_STRFUNC, notify, data);\n+  TRACE (GOBJECT_OBJECT_REF (object, G_TYPE_FROM_INSTANCE (object), old_ref));\n+\n+  *out_toggle_notify = toggle_notify;\n+  *out_toggle_data = toggle_data;\n+  return object;\n@@ -3775,2 +4235,2 @@\n-  gint old_val;\n-  gboolean object_already_finalized;\n+  GToggleNotify toggle_notify;\n+  gpointer toggle_data;\n@@ -3780,6 +4240,1 @@\n-  old_val = g_atomic_int_add (&object->ref_count, 1);\n-  object_already_finalized = (old_val <= 0);\n-  g_return_val_if_fail (!object_already_finalized, NULL);\n-\n-  if (old_val == 1 && OBJECT_HAS_TOGGLE_REF (object))\n-    toggle_refs_notify (object, FALSE);\n+  object = object_ref (object, &toggle_notify, &toggle_data);\n@@ -3787,1 +4242,2 @@\n-  TRACE (GOBJECT_OBJECT_REF(object,G_TYPE_FROM_INSTANCE(object),old_val));\n+  if (toggle_notify)\n+    toggle_notify (toggle_data, object, FALSE);\n@@ -3792,0 +4248,55 @@\n+static gboolean\n+_object_unref_clear_weak_locations (GObject *object, gint *p_old_ref, gboolean do_unref)\n+{\n+  WeakRefData *wrdata;\n+  gboolean success;\n+\n+  \/* Fast path, for objects that never had a GWeakRef registered. *\/\n+  if (!(object_get_optional_flags (object) & OPTIONAL_FLAG_EVER_HAD_WEAK_REF))\n+    {\n+      \/* The caller previously just checked atomically that the ref-count was\n+       * one.\n+       *\n+       * At this point still, @object never ever had a GWeakRef registered.\n+       * That means, nobody else holds a strong reference and also nobody else\n+       * can hold a weak reference, to race against obtaining another\n+       * reference. We are good to proceed. *\/\n+      if (do_unref)\n+        {\n+          if (!g_atomic_int_compare_and_exchange ((gint *) &object->ref_count, 1, 0))\n+            {\n+#if G_ENABLE_DEBUG\n+              g_assert_not_reached ();\n+#endif\n+            }\n+        }\n+      return TRUE;\n+    }\n+\n+  \/* Slow path. We must obtain a lock on the @wrdata, to atomically release\n+   * weak references and check that the ref count is as expected. *\/\n+\n+  wrdata = weak_ref_data_get_surely (object);\n+\n+  weak_ref_data_lock (wrdata);\n+\n+  if (do_unref)\n+    {\n+      success = g_atomic_int_compare_and_exchange_full ((gint *) &object->ref_count,\n+                                                        1, 0,\n+                                                        p_old_ref);\n+    }\n+  else\n+    {\n+      *p_old_ref = g_atomic_int_get ((gint *) &object->ref_count);\n+      success = (*p_old_ref == 1);\n+    }\n+\n+  if (success)\n+    weak_ref_data_clear_list (wrdata, object);\n+\n+  weak_ref_data_unlock (wrdata);\n+\n+  return success;\n+}\n+\n@@ -3809,0 +4320,4 @@\n+  GToggleNotify toggle_notify;\n+  gpointer toggle_data;\n+  GObjectNotifyQueue *nqueue;\n+  GType obj_gtype;\n@@ -3812,6 +4327,15 @@\n-  \/* here we want to atomically do: if (ref_count>1) { ref_count--; return; } *\/\n-  old_ref = g_atomic_int_get (&object->ref_count);\n- retry_atomic_decrement1:\n-  while (old_ref > 1)\n-    {\n-      \/* valid if last 2 refs are owned by this call to unref and the toggle_ref *\/\n+  \/* obj_gtype will be needed for TRACE(GOBJECT_OBJECT_UNREF()) later. Note\n+   * that we issue the TRACE() after decrementing the ref-counter. If at that\n+   * point the reference counter does not reach zero, somebody else can race\n+   * and destroy the object.\n+   *\n+   * This means, TRACE() can be called with a dangling object pointer. This\n+   * could only be avoided, by emitting the TRACE before doing the actual\n+   * unref, but at that point we wouldn't know the correct \"old_ref\" value.\n+   * Maybe this should change.\n+   *\n+   * Anyway. At that later point we can also no longer safely get the GType for\n+   * the TRACE(). Do it now.\n+   *\/\n+  obj_gtype = G_TYPE_FROM_INSTANCE (object);\n+  (void) obj_gtype;\n@@ -3819,4 +4343,1 @@\n-      if (!g_atomic_int_compare_and_exchange_full ((int *)&object->ref_count,\n-                                                   old_ref, old_ref - 1,\n-                                                   &old_ref))\n-        continue;\n+  old_ref = g_atomic_int_get (&object->ref_count);\n@@ -3824,1 +4345,1 @@\n-      TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));\n+retry_beginning:\n@@ -3826,6 +4347,6 @@\n-      \/* if we went from 2->1 we need to notify toggle refs if any *\/\n-      if (old_ref == 2 && OBJECT_HAS_TOGGLE_REF (object))\n-        {\n-          \/* The last ref being held in this case is owned by the toggle_ref *\/\n-          toggle_refs_notify (object, TRUE);\n-        }\n+  if (old_ref > 2)\n+    {\n+      \/* We have many references. If we can decrement the ref counter, we are done. *\/\n+      if (!g_atomic_int_compare_and_exchange_full ((int *) &object->ref_count,\n+                                                   old_ref, old_ref - 1, &old_ref))\n+        goto retry_beginning;\n@@ -3833,0 +4354,2 @@\n+      \/* Beware: object might be a dangling pointer. *\/\n+      TRACE (GOBJECT_OBJECT_UNREF (object, obj_gtype, old_ref));\n@@ -3836,0 +4359,1 @@\n+  if (old_ref == 2)\n@@ -3837,6 +4361,2 @@\n-      GSList **weak_locations;\n-      GObjectNotifyQueue *nqueue;\n-\n-      \/* The only way that this object can live at this point is if\n-       * there are outstanding weak references already established\n-       * before we got here.\n+      \/* We are about to return the second-to-last reference. In that case we\n+       * might need to notify a toggle reference.\n@@ -3844,4 +4364,4 @@\n-       * If there were not already weak references then no more can be\n-       * established at this time, because the other thread would have\n-       * to hold a strong ref in order to call\n-       * g_object_add_weak_pointer() and then we wouldn't be here.\n+       * Note that a g_object_add_toggle_ref() MUST always be released\n+       * via g_object_remove_toggle_ref(). Thus, if we are here with\n+       * an old_ref of 2, then at most one of the references can be\n+       * a toggle reference.\n@@ -3849,5 +4369,1 @@\n-       * Other GWeakRef's (weak locations) instead may still be added\n-       * before the object is finalized, but in such case we'll unset\n-       * them as part of the qdata removal.\n-       *\/\n-      weak_locations = g_datalist_id_get_data (&object->qdata, quark_weak_locations);\n+       * We need to take a lock, to avoid races. *\/\n@@ -3855,3 +4371,2 @@\n-      if (weak_locations != NULL)\n-        {\n-          g_rw_lock_writer_lock (&weak_locations_lock);\n+      if (!toggle_refs_check_and_ref_or_deref (object, FALSE, &old_ref, &toggle_notify, &toggle_data))\n+        goto retry_beginning;\n@@ -3859,10 +4374,6 @@\n-          \/* It is possible that one of the weak references beat us to\n-           * the lock. Make sure the refcount is still what we expected\n-           * it to be.\n-           *\/\n-          old_ref = g_atomic_int_get (&object->ref_count);\n-          if (old_ref != 1)\n-            {\n-              g_rw_lock_writer_unlock (&weak_locations_lock);\n-              goto retry_atomic_decrement1;\n-            }\n+      \/* Beware: object might be a dangling pointer. *\/\n+      TRACE (GOBJECT_OBJECT_UNREF (object, obj_gtype, old_ref));\n+      if (toggle_notify)\n+        toggle_notify (toggle_data, object, TRUE);\n+      return;\n+    }\n@@ -3870,6 +4381,3 @@\n-          \/* We got the lock first, so the object will definitely die\n-           * now. Clear out all the weak references, if they're still set.\n-           *\/\n-          weak_locations = g_datalist_id_remove_no_notify (&object->qdata,\n-                                                           quark_weak_locations);\n-          g_clear_pointer (&weak_locations, weak_locations_free_unlocked);\n+  if (G_UNLIKELY (old_ref != 1))\n+    {\n+      gboolean object_already_finalized = TRUE;\n@@ -3877,2 +4385,3 @@\n-          g_rw_lock_writer_unlock (&weak_locations_lock);\n-        }\n+      g_return_if_fail (!object_already_finalized);\n+      return;\n+    }\n@@ -3880,1 +4389,9 @@\n-      \/* freeze the notification queue, so we don't accidentally emit\n+  \/* We only have one reference left. Proceed to (maybe) clear weak locations. *\/\n+  if (!_object_unref_clear_weak_locations (object, &old_ref, FALSE))\n+    goto retry_beginning;\n+\n+  \/* At this point, we checked with an atomic read that we only hold only one\n+   * reference. Weak locations are cleared (and toggle references are not to\n+   * be considered in this case). Proceed with dispose().\n+   *\n+   * First, freeze the notification queue, so we don't accidentally emit\n@@ -3883,8 +4400,11 @@\n-       * The notification queue stays frozen unless the instance acquires\n-       * a reference during dispose(), in which case we thaw it and\n-       * dispatch all the notifications. If the instance gets through\n-       * to finalize(), the notification queue gets automatically\n-       * drained when g_object_finalize() is reached and\n-       * the qdata is cleared.\n-       *\/\n-      nqueue = g_object_notify_queue_freeze (object, FALSE);\n+   * The notification queue stays frozen unless the instance acquires a\n+   * reference during dispose(), in which case we thaw it and dispatch all the\n+   * notifications. If the instance gets through to finalize(), the\n+   * notification queue gets automatically drained when g_object_finalize() is\n+   * reached and the qdata is cleared.\n+   *\n+   * Important: Note that g_object_notify_queue_freeze() takes a object_bit_lock(),\n+   * which happens to be the same lock that is also taken by toggle_refs_check_and_ref(),\n+   * that is very important. See also the code comment in toggle_refs_check_and_ref().\n+   *\/\n+  nqueue = g_object_notify_queue_freeze (object);\n@@ -3892,2 +4412,1 @@\n-      \/* we are about to remove the last reference *\/\n-      TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 1));\n+  TRACE (GOBJECT_OBJECT_DISPOSE (object, G_TYPE_FROM_INSTANCE (object), 1));\n@@ -3895,1 +4414,5 @@\n-      TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 1));\n+  TRACE (GOBJECT_OBJECT_DISPOSE_END (object, G_TYPE_FROM_INSTANCE (object), 1));\n+\n+  \/* Must re-fetch old-ref. _object_unref_clear_weak_locations() relies on\n+   * that.  *\/\n+  old_ref = g_atomic_int_get (&object->ref_count);\n@@ -3897,2 +4420,3 @@\n-      \/* may have been re-referenced meanwhile *\/\n-      old_ref = g_atomic_int_get ((int *)&object->ref_count);\n+retry_decrement:\n+  \/* Here, old_ref is 1 if we just come from dispose(). If the object was resurrected,\n+   * we can hit `goto retry_decrement` and be here with a larger old_ref. *\/\n@@ -3900,1 +4424,1 @@\n-      while (old_ref > 1)\n+  if (old_ref > 1 && nqueue)\n@@ -3902,1 +4426,14 @@\n-          \/* valid if last 2 refs are owned by this call to unref and the toggle_ref *\/\n+      \/* If the object was resurrected, we need to unfreeze the notify\n+       * queue. *\/\n+      g_object_notify_queue_thaw (object, nqueue, FALSE);\n+      nqueue = NULL;\n+\n+      \/* Note at this point, @old_ref might be wrong.\n+       *\n+       * Also note that _object_unref_clear_weak_locations() requires that we\n+       * atomically checked that @old_ref is 1. However, as @old_ref is larger\n+       * than 1, that will not be called. Instead, all other code paths below,\n+       * handle the possibility of a bogus @old_ref.\n+       *\n+       * No need to re-fetch. *\/\n+    }\n@@ -3904,1 +4441,3 @@\n-          if (!g_atomic_int_compare_and_exchange_full ((int *)&object->ref_count,\n+  if (old_ref > 2)\n+    {\n+      if (!g_atomic_int_compare_and_exchange_full ((int *) &object->ref_count,\n@@ -3907,3 +4446,1 @@\n-            continue;\n-\n-          TRACE (GOBJECT_OBJECT_UNREF (object, G_TYPE_FROM_INSTANCE (object), old_ref));\n+        goto retry_decrement;\n@@ -3911,10 +4448,4 @@\n-          \/* emit all notifications that have been queued during dispose() *\/\n-          g_object_notify_queue_thaw (object, nqueue);\n-\n-          \/* if we went from 2->1 we need to notify toggle refs if any *\/\n-          if (old_ref == 2 && OBJECT_HAS_TOGGLE_REF (object) &&\n-              g_atomic_int_get ((int *)&object->ref_count) == 1)\n-            {\n-              \/* The last ref being held in this case is owned by the toggle_ref *\/\n-              toggle_refs_notify (object, TRUE);\n-            }\n+      \/* Beware: object might be a dangling pointer. *\/\n+      TRACE (GOBJECT_OBJECT_UNREF (object, obj_gtype, old_ref));\n+      return;\n+    }\n@@ -3922,0 +4453,14 @@\n+  if (old_ref == 2)\n+    {\n+      \/* If the object was resurrected and the current ref-count is 2, then we\n+       * are about to drop the ref-count to 1. We may need to emit a toggle\n+       * notification. Take a lock and check for that.\n+       *\n+       * In that case, we need a lock to get the toggle notification. *\/\n+      if (!toggle_refs_check_and_ref_or_deref (object, FALSE, &old_ref, &toggle_notify, &toggle_data))\n+        goto retry_decrement;\n+\n+      \/* Beware: object might be a dangling pointer. *\/\n+      TRACE (GOBJECT_OBJECT_UNREF (object, obj_gtype, old_ref));\n+      if (toggle_notify)\n+        toggle_notify (toggle_data, object, TRUE);\n@@ -3925,5 +4470,4 @@\n-      \/* we are still in the process of taking away the last ref *\/\n-      g_datalist_id_set_data (&object->qdata, quark_closure_array, NULL);\n-      g_signal_handlers_destroy (object);\n-      g_datalist_id_set_data (&object->qdata, quark_weak_refs, NULL);\n-      g_datalist_id_set_data (&object->qdata, quark_weak_locations, NULL);\n+  \/* old_ref is (atomically!) checked to be 1, we are about to drop the\n+   * reference count to zero in _object_unref_clear_weak_locations(). *\/\n+  if (!_object_unref_clear_weak_locations (object, &old_ref, TRUE))\n+    goto retry_decrement;\n@@ -3931,3 +4475,1 @@\n-      \/* decrement the last reference *\/\n-      old_ref = g_atomic_int_add (&object->ref_count, -1);\n-      g_return_if_fail (old_ref > 0);\n+  TRACE (GOBJECT_OBJECT_UNREF (object, obj_gtype, old_ref));\n@@ -3935,1 +4477,1 @@\n-      TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));\n+  \/* The object is almost gone. Finalize. *\/\n@@ -3937,4 +4479,5 @@\n-      \/* may have been re-referenced meanwhile *\/\n-      if (G_LIKELY (old_ref == 1))\n-  {\n-    TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));\n+      g_datalist_id_set_data (&object->qdata, quark_closure_array, NULL);\n+      g_signal_handlers_destroy (object);\n+  g_datalist_id_set_data (&object->qdata, quark_weak_notifies, NULL);\n+\n+  TRACE (GOBJECT_OBJECT_FINALIZE (object, G_TYPE_FROM_INSTANCE (object)));\n@@ -3942,1 +4485,1 @@\n-    TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));\n+  TRACE (GOBJECT_OBJECT_FINALIZE_END (object, G_TYPE_FROM_INSTANCE (object)));\n@@ -3957,10 +4500,1 @@\n-          g_type_free_instance ((GTypeInstance*) object);\n-        }\n-      else\n-        {\n-          \/* The instance acquired a reference between dispose() and\n-           * finalize(), so we need to thaw the notification queue\n-           *\/\n-          g_object_notify_queue_thaw (object, nqueue);\n-    }\n-}\n+  g_type_free_instance ((GTypeInstance *) object);\n@@ -4654,18 +5188,0 @@\n-\/* don't change this structure without supplying an accessor for\n- * watched closures, e.g.:\n- * GSList* g_object_list_watched_closures (GObject *object)\n- * {\n- *   CArray *carray;\n- *   g_return_val_if_fail (G_IS_OBJECT (object), NULL);\n- *   carray = g_object_get_data (object, \"GObject-closure-array\");\n- *   if (carray)\n- *     {\n- *       GSList *slist = NULL;\n- *       guint i;\n- *       for (i = 0; i < carray->n_closures; i++)\n- *         slist = g_slist_prepend (slist, carray->closures[i]);\n- *       return slist;\n- *     }\n- *   return NULL;\n- * }\n- *\/\n@@ -4681,1 +5197,1 @@\n-  G_LOCK (closure_array_mutex);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_CLOSURE_ARRAY);\n@@ -4689,1 +5205,1 @@\n-  G_UNLOCK (closure_array_mutex);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_CLOSURE_ARRAY);\n@@ -4692,1 +5208,1 @@\n-  G_UNLOCK (closure_array_mutex);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_CLOSURE_ARRAY);\n@@ -4748,1 +5264,1 @@\n-  G_LOCK (closure_array_mutex);\n+  object_bit_lock (object, OPTIONAL_BIT_LOCK_CLOSURE_ARRAY);\n@@ -4764,1 +5280,1 @@\n-  G_UNLOCK (closure_array_mutex);\n+  object_bit_unlock (object, OPTIONAL_BIT_LOCK_CLOSURE_ARRAY);\n@@ -4917,0 +5433,197 @@\n+#define WEAK_REF_LOCK_BIT 0\n+\n+static GObject *\n+_weak_ref_clean_pointer (gpointer ptr)\n+{\n+  \/* Drop the lockbit WEAK_REF_LOCK_BIT from @ptr (if set). *\/\n+  return g_pointer_bit_lock_mask_ptr (ptr, WEAK_REF_LOCK_BIT, FALSE, 0, NULL);\n+}\n+\n+static void\n+_weak_ref_lock (GWeakRef *weak_ref, GObject **out_object)\n+{\n+  \/* Note that while holding a _weak_ref_lock() on the @weak_ref, we MUST not acquire a\n+   * weak_ref_data_lock() on the @wrdata. The other way around! *\/\n+\n+  if (out_object)\n+    {\n+      guintptr ptr;\n+\n+      g_pointer_bit_lock_and_get (&weak_ref->priv.p, WEAK_REF_LOCK_BIT, &ptr);\n+      *out_object = _weak_ref_clean_pointer ((gpointer) ptr);\n+    }\n+  else\n+    g_pointer_bit_lock (&weak_ref->priv.p, WEAK_REF_LOCK_BIT);\n+}\n+\n+static void\n+_weak_ref_unlock (GWeakRef *weak_ref)\n+{\n+  g_pointer_bit_unlock (&weak_ref->priv.p, WEAK_REF_LOCK_BIT);\n+}\n+\n+static void\n+_weak_ref_unlock_and_set (GWeakRef *weak_ref, GObject *object)\n+{\n+  g_pointer_bit_unlock_and_set (&weak_ref->priv.p, WEAK_REF_LOCK_BIT, object, 0);\n+}\n+\n+static void\n+weak_ref_data_clear_list (WeakRefData *wrdata, GObject *object)\n+{\n+  while (wrdata->len > 0u)\n+    {\n+      GWeakRef *weak_ref;\n+      gpointer ptr;\n+\n+      \/* pass \"allow_shrink=FALSE\", so we don't reallocate needlessly. We\n+       * anyway are about to clear the entire list. *\/\n+      weak_ref = weak_ref_data_list_remove (wrdata, wrdata->len - 1u, FALSE);\n+\n+      \/* Fast-path. Most likely @weak_ref is currently not locked, so we can\n+       * just atomically set the pointer to NULL. *\/\n+      ptr = g_atomic_pointer_get (&weak_ref->priv.p);\n+#if G_ENABLE_DEBUG\n+      g_assert (G_IS_OBJECT (_weak_ref_clean_pointer (ptr)));\n+      g_assert (!object || object == _weak_ref_clean_pointer (ptr));\n+#endif\n+      if (G_LIKELY (ptr == _weak_ref_clean_pointer (ptr)))\n+        {\n+          \/* The pointer is unlocked. Try an atomic compare-and-exchange... *\/\n+          if (g_atomic_pointer_compare_and_exchange (&weak_ref->priv.p, ptr, NULL))\n+            {\n+              \/* Done. Go to the next. *\/\n+              continue;\n+            }\n+        }\n+\n+      \/* The @weak_ref is locked. Acquire the lock to set the pointer to NULL. *\/\n+      _weak_ref_lock (weak_ref, NULL);\n+      _weak_ref_unlock_and_set (weak_ref, NULL);\n+    }\n+}\n+\n+static void\n+_weak_ref_set (GWeakRef *weak_ref,\n+               GObject *new_object,\n+               gboolean called_by_init)\n+{\n+  WeakRefData *old_wrdata;\n+  WeakRefData *new_wrdata;\n+  GObject *old_object;\n+\n+  new_wrdata = weak_ref_data_get_or_create (new_object);\n+\n+#if G_ENABLE_DEBUG\n+  g_assert (!new_object || object_get_optional_flags (new_object) & OPTIONAL_FLAG_EVER_HAD_WEAK_REF);\n+#endif\n+\n+  if (called_by_init)\n+    {\n+      \/* The caller is g_weak_ref_init(). We know that the weak_ref should be\n+       * NULL. We thus set @old_wrdata to NULL without checking.\n+       *\n+       * Also important, the caller ensured that @new_object is not NULL. So we\n+       * are expected to set @weak_ref from NULL to a non-NULL @new_object. *\/\n+      old_wrdata = NULL;\n+#if G_ENABLE_DEBUG\n+      g_assert (new_object);\n+#endif\n+    }\n+  else\n+    {\n+      \/* We must get a wrdata object @old_wrdata for the current @old_object. *\/\n+      _weak_ref_lock (weak_ref, &old_object);\n+\n+      if (old_object == new_object)\n+        {\n+          \/* Already set. We are done. *\/\n+          _weak_ref_unlock (weak_ref);\n+          return;\n+        }\n+\n+      old_wrdata = old_object\n+                       ? weak_ref_data_ref (weak_ref_data_get (old_object))\n+                       : NULL;\n+      _weak_ref_unlock (weak_ref);\n+    }\n+\n+  \/* We need a lock on @old_wrdata, @new_wrdata and @weak_ref. We need to take\n+   * these locks in a certain order to avoid deadlock. We sort them by pointer\n+   * value.\n+   *\n+   * Note that @old_wrdata or @new_wrdata may be NULL, which is handled\n+   * correctly.\n+   *\n+   * Note that @old_wrdata and @new_wrdata are never identical at this point.\n+   *\/\n+  if (new_wrdata && old_wrdata && (((guintptr) (gpointer) old_wrdata) < ((guintptr) ((gpointer) new_wrdata))))\n+    {\n+      weak_ref_data_lock (old_wrdata);\n+      weak_ref_data_lock (new_wrdata);\n+    }\n+  else\n+    {\n+      weak_ref_data_lock (new_wrdata);\n+      weak_ref_data_lock (old_wrdata);\n+    }\n+  _weak_ref_lock (weak_ref, &old_object);\n+\n+  if (!weak_ref_data_has (old_object, old_wrdata, NULL))\n+    {\n+      \/* A race. @old_object no longer has the expected @old_wrdata after\n+       * getting all the locks. *\/\n+      if (old_object)\n+        {\n+          \/* We lost the race and find a different object set. It's fine, our\n+           * action was lost in the race and we are done. No need to retry. *\/\n+          weak_ref_data_unlock (old_wrdata);\n+          weak_ref_data_unlock (new_wrdata);\n+          _weak_ref_unlock (weak_ref);\n+          weak_ref_data_unref (old_wrdata);\n+          return;\n+        }\n+\n+      \/* @old_object is NULL after a race. We didn't expect that, but it's\n+       * fine. Proceed to set @new_object... *\/\n+    }\n+\n+  if (old_object)\n+    {\n+      gint32 idx;\n+\n+      idx = weak_ref_data_list_find (old_wrdata, weak_ref);\n+      if (idx < 0)\n+        g_critical (\"unexpected missing GWeakRef data\");\n+      else\n+        weak_ref_data_list_remove (old_wrdata, idx, TRUE);\n+    }\n+\n+  weak_ref_data_unlock (old_wrdata);\n+\n+  if (new_object)\n+    {\n+#if G_ENABLE_DEBUG\n+      g_assert (weak_ref_data_list_find (new_wrdata, weak_ref) < 0);\n+#endif\n+      if (g_atomic_int_get (&new_object->ref_count) < 1)\n+        {\n+          g_critical (\"calling g_weak_ref_set() with already destroyed object\");\n+          new_object = NULL;\n+        }\n+      else\n+        {\n+          if (!weak_ref_data_list_add (new_wrdata, weak_ref))\n+            {\n+              g_critical (\"Too many GWeakRef registered\");\n+              new_object = NULL;\n+            }\n+        }\n+    }\n+\n+  _weak_ref_unlock_and_set (weak_ref, new_object);\n+  weak_ref_data_unlock (new_wrdata);\n+\n+  weak_ref_data_unref (old_wrdata);\n+}\n+\n@@ -4937,1 +5650,1 @@\n-                 gpointer  object)\n+                 gpointer object)\n@@ -4939,1 +5652,2 @@\n-  weak_ref->priv.p = NULL;\n+  g_return_if_fail (weak_ref);\n+  g_return_if_fail (object == NULL || G_IS_OBJECT (object));\n@@ -4941,1 +5655,8 @@\n-  g_weak_ref_set (weak_ref, object);\n+  g_atomic_pointer_set (&weak_ref->priv.p, NULL);\n+  if (object)\n+    {\n+      \/* We give a hint that the weak_ref is currently NULL. Unlike\n+       * g_weak_ref_set(), we then don't need the extra lock just to\n+       * find out that we have no object. *\/\n+      _weak_ref_set (weak_ref, object, TRUE);\n+    }\n@@ -4988,3 +5709,5 @@\n-  gpointer object_or_null;\n-\n-  g_return_val_if_fail (weak_ref!= NULL, NULL);\n+  WeakRefData *wrdata;\n+  WeakRefData *new_wrdata;\n+  GToggleNotify toggle_notify = NULL;\n+  gpointer toggle_data = NULL;\n+  GObject *object;\n@@ -4992,1 +5715,1 @@\n-  g_rw_lock_reader_lock (&weak_locations_lock);\n+  g_return_val_if_fail (weak_ref, NULL);\n@@ -4994,1 +5717,17 @@\n-  object_or_null = weak_ref->priv.p;\n+  \/* We cannot take the strong reference on @object yet. Otherwise,\n+   * _object_unref_clear_weak_locations() might have just taken the lock on\n+   * @wrdata, see that the ref-count is 1 and plan to proceed clearing weak\n+   * locations. If we then take a strong reference here, the object becomes\n+   * alive and well, but _object_unref_clear_weak_locations() would proceed and\n+   * clear the @weak_ref.\n+   *\n+   * We avoid that, by can only taking the strong reference when having a lock\n+   * on @wrdata, so we are in sync with _object_unref_clear_weak_locations().\n+   *\n+   * But first we must get a reference to the @wrdata.\n+   *\/\n+  _weak_ref_lock (weak_ref, &object);\n+  wrdata = object\n+               ? weak_ref_data_ref (weak_ref_data_get (object))\n+               : NULL;\n+  _weak_ref_unlock (weak_ref);\n@@ -4996,2 +5735,5 @@\n-  if (object_or_null != NULL)\n-    g_object_ref (object_or_null);\n+  if (!wrdata)\n+    {\n+      \/* There is no @wrdata and no object. We are done. *\/\n+      return NULL;\n+    }\n@@ -4999,1 +5741,1 @@\n-  g_rw_lock_reader_unlock (&weak_locations_lock);\n+retry:\n@@ -5001,2 +5743,8 @@\n-  return object_or_null;\n-}\n+  \/* Now proceed to get the strong reference. This time with acquiring a lock\n+   * on the per-object @wrdata and on @weak_ref.\n+   *\n+   * As the order in which locks are taken is important, we previously had to\n+   * get a _weak_ref_lock(), to obtain the @wrdata. Now we have to lock on the\n+   * @wrdata first, and the @weak_ref again. *\/\n+  weak_ref_data_lock (wrdata);\n+  _weak_ref_lock (weak_ref, &object);\n@@ -5004,4 +5752,1 @@\n-static void\n-weak_locations_free_unlocked (GSList **weak_locations)\n-{\n-  if (*weak_locations)\n+  if (!object)\n@@ -5009,3 +5754,11 @@\n-      GSList *weak_location;\n-\n-      for (weak_location = *weak_locations; weak_location;)\n+      \/* Object is gone in the meantime. That is fine. *\/\n+      new_wrdata = NULL;\n+    }\n+  else\n+    {\n+      \/* Check that @object still refers to the same object as before. We do\n+       * that by comparing the @wrdata object. A GObject keeps its (unique!)\n+       * wrdata instance until the end, and since @wrdata is still alive,\n+       * @object is the same as before, if-and-only-if its @wrdata is the same.\n+       *\/\n+      if (weak_ref_data_has (object, wrdata, &new_wrdata))\n@@ -5013,4 +5766,10 @@\n-          GWeakRef *weak_ref_location = weak_location->data;\n-\n-          weak_ref_location->priv.p = NULL;\n-          weak_location = g_slist_delete_link (weak_location, weak_location);\n+          \/* We are (still) good. Take a strong ref while holding the necessary locks. *\/\n+          object = object_ref (object, &toggle_notify, &toggle_data);\n+        }\n+      else\n+        {\n+          \/* The @object changed and has no longer the same @wrdata. In this\n+           * case, we need to start over.\n+           *\n+           * Note that @new_wrdata references the wrdata of the now current\n+           * @object. We will use that during the retry. *\/\n@@ -5020,2 +5779,3 @@\n-  g_free (weak_locations);\n-}\n+  _weak_ref_unlock (weak_ref);\n+  weak_ref_data_unlock (wrdata);\n+  weak_ref_data_unref (wrdata);\n@@ -5023,4 +5783,9 @@\n-static void\n-weak_locations_free (gpointer data)\n-{\n-  GSList **weak_locations = data;\n+  if (new_wrdata)\n+    {\n+      \/* There was a race. The object changed. Retry, with @new_wrdata. *\/\n+      wrdata = new_wrdata;\n+      goto retry;\n+    }\n+\n+  if (toggle_notify)\n+    toggle_notify (toggle_data, object, FALSE);\n@@ -5028,3 +5793,1 @@\n-  g_rw_lock_writer_lock (&weak_locations_lock);\n-  weak_locations_free_unlocked (weak_locations);\n-  g_rw_lock_writer_unlock (&weak_locations_lock);\n+  return object;\n@@ -5048,1 +5811,1 @@\n-                gpointer  object)\n+                gpointer object)\n@@ -5050,4 +5813,0 @@\n-  GSList **weak_locations;\n-  GObject *new_object;\n-  GObject *old_object;\n-\n@@ -5057,65 +5816,1 @@\n-  new_object = object;\n-\n-  g_rw_lock_writer_lock (&weak_locations_lock);\n-\n-  \/* We use the extra level of indirection here so that if we have ever\n-   * had a weak pointer installed at any point in time on this object,\n-   * we can see that there is a non-NULL value associated with the\n-   * weak-pointer quark and know that this value will not change at any\n-   * point in the object's lifetime.\n-   *\n-   * Both properties are important for reducing the amount of times we\n-   * need to acquire locks and for decreasing the duration of time the\n-   * lock is held while avoiding some rather tricky races.\n-   *\n-   * Specifically: we can avoid having to do an extra unconditional lock\n-   * in g_object_unref() without worrying about some extremely tricky\n-   * races.\n-   *\/\n-\n-  old_object = weak_ref->priv.p;\n-  if (new_object != old_object)\n-    {\n-      weak_ref->priv.p = new_object;\n-\n-      \/* Remove the weak ref from the old object *\/\n-      if (old_object != NULL)\n-        {\n-          weak_locations = g_datalist_id_get_data (&old_object->qdata, quark_weak_locations);\n-          if (weak_locations == NULL)\n-            {\n-#ifndef G_DISABLE_ASSERT\n-              gboolean in_weak_refs_notify =\n-                  g_datalist_id_get_data (&old_object->qdata, quark_weak_refs) == NULL;\n-              g_assert (in_weak_refs_notify);\n-#endif \/* G_DISABLE_ASSERT *\/\n-            }\n-          else\n-            {\n-              *weak_locations = g_slist_remove (*weak_locations, weak_ref);\n-\n-              if (!*weak_locations)\n-                {\n-                  weak_locations_free_unlocked (weak_locations);\n-                  g_datalist_id_remove_no_notify (&old_object->qdata, quark_weak_locations);\n-                }\n-            }\n-        }\n-\n-      \/* Add the weak ref to the new object *\/\n-      if (new_object != NULL)\n-        {\n-          weak_locations = g_datalist_id_get_data (&new_object->qdata, quark_weak_locations);\n-\n-          if (weak_locations == NULL)\n-            {\n-              weak_locations = g_new0 (GSList *, 1);\n-              g_datalist_id_set_data_full (&new_object->qdata, quark_weak_locations,\n-                                           weak_locations, weak_locations_free);\n-            }\n-\n-          *weak_locations = g_slist_prepend (*weak_locations, weak_ref);\n-        }\n-    }\n-\n-  g_rw_lock_writer_unlock (&weak_locations_lock);\n+  _weak_ref_set (weak_ref, object, FALSE);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gobject.c","additions":1272,"deletions":577,"binary":false,"changes":1849,"status":"modified"},{"patch":"@@ -251,16 +251,1 @@\n-\/**\n- * GObject:\n- *\n- * The base object type.\n- *\n- * All the fields in the 'GObject' structure are private to the implementation\n- * and should never be accessed directly.\n- *\n- * Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n- * alignment of the largest basic GLib type (typically this is #guint64 or\n- * #gdouble). If you need larger alignment for an element in a #GObject, you\n- * should allocate it on the heap (aligned), or arrange for your #GObject to be\n- * appropriately padded. This guarantee applies to the #GObject (or derived)\n- * struct, the #GObjectClass (or derived) struct, and any private data allocated\n- * by G_ADD_PRIVATE().\n- *\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gobject.h","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,6 +34,6 @@\n- * SECTION:gparamspec\n- * @short_description: Metadata for parameter specifications\n- * @see_also: g_object_class_install_property(), g_object_set(),\n- *     g_object_get(), g_object_set_property(), g_object_get_property(),\n- *     g_value_register_transform_func()\n- * @title: GParamSpec\n+ * GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n+ * @g_type_instance: private `GTypeInstance` portion\n+ * @name: name of this parameter: always an interned string\n+ * @flags: `GParamFlags` flags for this parameter\n+ * @value_type: the `GValue` type for this parameter\n+ * @owner_type: `GType` type that uses (introduces) this parameter\n@@ -41,2 +41,1 @@\n- * #GParamSpec is an object structure that encapsulates the metadata\n- * required to specify parameters, such as e.g. #GObject properties.\n+ * `GParamSpec` encapsulates the metadata required to specify parameters, such as `GObject` properties.\n@@ -44,1 +43,1 @@\n- * ## Parameter names # {#canonical-parameter-names}\n+ * ## Parameter names\n@@ -49,1 +48,1 @@\n- * for signal naming (see g_signal_new()).\n+ * for signal naming (see [func@GObject.signal_new]).\n@@ -51,1 +50,1 @@\n- * When creating and looking up a #GParamSpec, either separator can be\n+ * When creating and looking up a `GParamSpec`, either separator can be\n@@ -56,1 +55,0 @@\n-\n@@ -260,1 +258,1 @@\n-  gsize oldvalue;\n+  guintptr oldvalue;\n@@ -280,1 +278,1 @@\n-  gsize oldvalue;\n+  guintptr oldvalue;\n@@ -1003,1 +1001,4 @@\n-  pool->hash_table = g_hash_table_new (param_spec_pool_hash, param_spec_pool_equals);\n+  pool->hash_table = g_hash_table_new_full (param_spec_pool_hash,\n+                                            param_spec_pool_equals,\n+                                            (GDestroyNotify) g_param_spec_unref,\n+                                            NULL);\n@@ -1008,0 +1009,18 @@\n+\/**\n+ * g_param_spec_pool_free:\n+ * @pool: (transfer full): a #GParamSpecPool\n+ *\n+ * Frees the resources allocated by a #GParamSpecPool.\n+ *\n+ * Since: 2.80\n+ *\/\n+void\n+g_param_spec_pool_free (GParamSpecPool *pool)\n+{\n+  g_mutex_lock (&pool->mutex);\n+  g_hash_table_unref (pool->hash_table);\n+  g_mutex_unlock (&pool->mutex);\n+  g_mutex_clear (&pool->mutex);\n+  g_free (pool);\n+}\n+\n@@ -1062,3 +1081,1 @@\n-      if (g_hash_table_remove (pool->hash_table, pspec))\n-        g_param_spec_unref (pspec);\n-      else\n+      if (!g_hash_table_remove (pool->hash_table, pspec))\n@@ -1243,1 +1260,1 @@\n-  data[1] = (gpointer) owner_type;\n+  data[1] = GTYPE_TO_POINTER (owner_type);\n@@ -1382,1 +1399,1 @@\n-  data[1] = (gpointer) owner_type;\n+  data[1] = GTYPE_TO_POINTER (owner_type);\n@@ -1638,1 +1655,1 @@\n-  if (g_once_init_enter (&priv->default_value.g_type))\n+  if (g_once_init_enter_pointer (&priv->default_value.g_type))\n@@ -1648,1 +1665,1 @@\n-      g_once_init_leave (&priv->default_value.g_type, pspec->value_type);\n+      g_once_init_leave_pointer (&priv->default_value.g_type, pspec->value_type);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gparam.c","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -206,11 +206,1 @@\n-\/**\n- * GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n- * @g_type_instance: private #GTypeInstance portion\n- * @name: name of this parameter: always an interned string\n- * @flags: #GParamFlags flags for this parameter\n- * @value_type: the #GValue type for this parameter\n- * @owner_type: #GType type that uses (introduces) this parameter\n- *\n- * All other fields of the GParamSpec struct are private and\n- * should not be used directly.\n- *\/\n+\n@@ -456,1 +446,2 @@\n-\n+GOBJECT_AVAILABLE_IN_2_80\n+void            g_param_spec_pool_free          (GParamSpecPool *pool);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gparam.h","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,23 +40,0 @@\n-\/**\n- * SECTION:param_value_types\n- * @short_description: Standard Parameter and Value Types\n- * @see_also: #GParamSpec, #GValue, g_object_class_install_property().\n- * @title: Parameters and Values\n- *\n- * #GValue provides an abstract container structure which can be\n- * copied, transformed and compared while holding a value of any\n- * (derived) type, which is registered as a #GType with a\n- * #GTypeValueTable in its #GTypeInfo structure.  Parameter\n- * specifications for most value types can be created as #GParamSpec\n- * derived instances, to implement e.g. #GObject properties which\n- * operate on #GValue containers.\n- *\n- * Parameter names need to start with a letter (a-z or A-Z). Subsequent\n- * characters can be letters, numbers or a '-'.\n- * All other characters are replaced by a '-' during construction.\n- *\n- * See also #GValue for more information.\n- *\n- *\/\n-\n-\n@@ -1044,1 +1021,1 @@\n-    value->data[0].v_pointer = g_value_array_new (aspec->fixed_n_elements);\n+    value_array = value->data[0].v_pointer = g_value_array_new (aspec->fixed_n_elements);\n@@ -1248,1 +1225,1 @@\n-  value->data[0].v_pointer = GSIZE_TO_POINTER (tspec->is_a_type);\n+  value->data[0].v_pointer = GTYPE_TO_POINTER (tspec->is_a_type);\n@@ -1256,1 +1233,1 @@\n-  GType gtype = GPOINTER_TO_SIZE (value->data[0].v_pointer);\n+  GType gtype = GPOINTER_TO_TYPE (value->data[0].v_pointer);\n@@ -1267,1 +1244,1 @@\n-  GType gtype = GPOINTER_TO_SIZE (value->data[0].v_pointer);\n+  GType gtype = GPOINTER_TO_TYPE (value->data[0].v_pointer);\n@@ -1272,1 +1249,1 @@\n-      value->data[0].v_pointer = GSIZE_TO_POINTER (tspec->is_a_type);\n+      value->data[0].v_pointer = GTYPE_TO_POINTER (tspec->is_a_type);\n@@ -1284,2 +1261,2 @@\n-  GType p1 = GPOINTER_TO_SIZE (value1->data[0].v_pointer);\n-  GType p2 = GPOINTER_TO_SIZE (value2->data[0].v_pointer);\n+  GType p1 = GPOINTER_TO_TYPE (value1->data[0].v_pointer);\n+  GType p2 = GPOINTER_TO_TYPE (value2->data[0].v_pointer);\n@@ -1873,4 +1850,4 @@\n-           gint8    minimum,\n-           gint8    maximum,\n-           gint8    default_value,\n-           GParamFlags  flags)\n+                   gint8        minimum,\n+                   gint8        maximum,\n+                   gint8        default_value,\n+                   GParamFlags  flags)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gparamspecs.c","additions":11,"deletions":34,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -42,93 +42,0 @@\n-\/**\n- * SECTION:signals\n- * @short_description: A means for customization of object behaviour\n- *     and a general purpose notification mechanism\n- * @title: Signals\n- *\n- * The basic concept of the signal system is that of the emission\n- * of a signal. Signals are introduced per-type and are identified\n- * through strings. Signals introduced for a parent type are available\n- * in derived types as well, so basically they are a per-type facility\n- * that is inherited.\n- *\n- * A signal emission mainly involves invocation of a certain set of\n- * callbacks in precisely defined manner. There are two main categories\n- * of such callbacks, per-object ones and user provided ones.\n- * (Although signals can deal with any kind of instantiatable type, I'm\n- * referring to those types as \"object types\" in the following, simply\n- * because that is the context most users will encounter signals in.)\n- * The per-object callbacks are most often referred to as \"object method\n- * handler\" or \"default (signal) handler\", while user provided callbacks are\n- * usually just called \"signal handler\".\n- *\n- * The object method handler is provided at signal creation time (this most\n- * frequently happens at the end of an object class' creation), while user\n- * provided handlers are frequently connected and disconnected to\/from a\n- * certain signal on certain object instances.\n- *\n- * A signal emission consists of five stages, unless prematurely stopped:\n- *\n- * 1. Invocation of the object method handler for %G_SIGNAL_RUN_FIRST signals\n- *\n- * 2. Invocation of normal user-provided signal handlers (where the @after\n- *    flag is not set)\n- *\n- * 3. Invocation of the object method handler for %G_SIGNAL_RUN_LAST signals\n- *\n- * 4. Invocation of user provided signal handlers (where the @after flag is set)\n- *\n- * 5. Invocation of the object method handler for %G_SIGNAL_RUN_CLEANUP signals\n- *\n- * The user-provided signal handlers are called in the order they were\n- * connected in.\n- *\n- * All handlers may prematurely stop a signal emission, and any number of\n- * handlers may be connected, disconnected, blocked or unblocked during\n- * a signal emission.\n- *\n- * There are certain criteria for skipping user handlers in stages 2 and 4\n- * of a signal emission.\n- *\n- * First, user handlers may be blocked. Blocked handlers are omitted during\n- * callback invocation, to return from the blocked state, a handler has to\n- * get unblocked exactly the same amount of times it has been blocked before.\n- *\n- * Second, upon emission of a %G_SIGNAL_DETAILED signal, an additional\n- * @detail argument passed in to g_signal_emit() has to match the detail\n- * argument of the signal handler currently subject to invocation.\n- * Specification of no detail argument for signal handlers (omission of the\n- * detail part of the signal specification upon connection) serves as a\n- * wildcard and matches any detail argument passed in to emission.\n- *\n- * While the @detail argument is typically used to pass an object property name\n- * (as with #GObject::notify), no specific format is mandated for the detail\n- * string, other than that it must be non-empty.\n- *\n- * ## Memory management of signal handlers # {#signal-memory-management}\n- *\n- * If you are connecting handlers to signals and using a #GObject instance as\n- * your signal handler user data, you should remember to pair calls to\n- * g_signal_connect() with calls to g_signal_handler_disconnect() or\n- * g_signal_handlers_disconnect_by_func(). While signal handlers are\n- * automatically disconnected when the object emitting the signal is finalised,\n- * they are not automatically disconnected when the signal handler user data is\n- * destroyed. If this user data is a #GObject instance, using it from a\n- * signal handler after it has been finalised is an error.\n- *\n- * There are two strategies for managing such user data. The first is to\n- * disconnect the signal handler (using g_signal_handler_disconnect() or\n- * g_signal_handlers_disconnect_by_func()) when the user data (object) is\n- * finalised; this has to be implemented manually. For non-threaded programs,\n- * g_signal_connect_object() can be used to implement this automatically.\n- * Currently, however, it is unsafe to use in threaded programs.\n- *\n- * The second is to hold a strong reference on the user data until after the\n- * signal is disconnected for other reasons. This can be implemented\n- * automatically using g_signal_connect_data().\n- *\n- * The first approach is recommended, as the second approach can result in\n- * effective memory leaks of the user data if the signal handler is never\n- * disconnected for some reason.\n- *\/\n-\n-\n@@ -491,2 +398,0 @@\n-      hlbsa = g_bsearch_array_insert (hlbsa, &g_signal_hlbsa_bconfig, &key);\n-      g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);\n@@ -494,6 +399,1 @@\n-  else\n-    {\n-      GBSearchArray *o = hlbsa;\n-\n-      hlbsa = g_bsearch_array_insert (o, &g_signal_hlbsa_bconfig, &key);\n-      if (hlbsa != o)\n+  hlbsa = g_bsearch_array_insert (hlbsa, &g_signal_hlbsa_bconfig, &key);\n@@ -501,1 +401,0 @@\n-    }\n@@ -1338,2 +1237,2 @@\n-        g_critical (G_STRLOC \": unable to look up signal \\\"%s\\\" for invalid type id '%\"G_GSIZE_FORMAT\"'\",\n-                   name, itype);\n+        g_critical (G_STRLOC \": unable to look up signal \\\"%s\\\" for invalid type id '%\"G_GUINTPTR_FORMAT\"'\",\n+                   name, (guintptr) itype);\n@@ -1393,2 +1292,2 @@\n-        g_critical (G_STRLOC \": unable to list signals for invalid type id '%\"G_GSIZE_FORMAT\"'\",\n-                   itype);\n+        g_critical (G_STRLOC \": unable to list signals for invalid type id '%\"G_GUINTPTR_FORMAT\"'\",\n+                   (guintptr) itype);\n@@ -1479,1 +1378,1 @@\n- * @accumulator: (nullable): the accumulator for this signal; may be %NULL.\n+ * @accumulator: (nullable) (scope forever): the accumulator for this signal; may be %NULL.\n@@ -1552,1 +1451,1 @@\n- * @class_handler: (nullable): a #GCallback which acts as class implementation of\n+ * @class_handler: (nullable) (scope forever): a #GCallback which acts as class implementation of\n@@ -1555,1 +1454,1 @@\n- * @accumulator: (nullable): the accumulator for this signal; may be %NULL.\n+ * @accumulator: (nullable) (scope forever): the accumulator for this signal; may be %NULL.\n@@ -1692,1 +1591,1 @@\n- * @accumulator: (nullable): the accumulator for this signal; may be %NULL\n+ * @accumulator: (nullable) (scope forever): the accumulator for this signal; may be %NULL\n@@ -1953,1 +1852,1 @@\n- * @accumulator: (nullable): the accumulator for this signal; may be %NULL.\n+ * @accumulator: (nullable) (scope forever): the accumulator for this signal; may be %NULL.\n@@ -2119,1 +2018,1 @@\n- * @class_handler: the handler.\n+ * @class_handler: (scope forever): the handler.\n@@ -2149,2 +2048,2 @@\n-    g_critical (\"%s: signal name '%s' is invalid for type id '%\"G_GSIZE_FORMAT\"'\",\n-                G_STRLOC, signal_name, instance_type);\n+    g_critical (\"%s: signal name '%s' is invalid for type id '%\"G_GUINTPTR_FORMAT\"'\",\n+                G_STRLOC, signal_name, (guintptr) instance_type);\n@@ -2156,1 +2055,1 @@\n- * @instance_and_params: (array) the argument list of the signal emission.\n+ * @instance_and_params: (array): the argument list of the signal emission.\n@@ -2424,1 +2323,4 @@\n- * Returns: the handler ID (always greater than 0 for successful connections)\n+ * This function cannot fail. If the given signal doesn’t exist, a critical\n+ * warning is emitted.\n+ *\n+ * Returns: the handler ID (always greater than 0)\n@@ -2489,1 +2391,4 @@\n- * Returns: the handler ID (always greater than 0 for successful connections)\n+ * This function cannot fail. If the given signal doesn’t exist, a critical\n+ * warning is emitted.\n+ *\n+ * Returns: the handler ID (always greater than 0)\n@@ -2585,1 +2490,4 @@\n- * Returns: the handler ID (always greater than 0 for successful connections)\n+ * This function cannot fail. If the given signal doesn’t exist, a critical\n+ * warning is emitted.\n+ *\n+ * Returns: the handler ID (always greater than 0)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gsignal.c","additions":26,"deletions":118,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n- * Connects a #GCallback function to a signal for a particular object.\n+ * Connects a [type@GObject.Callback] function to a signal for a particular object.\n@@ -505,1 +505,2 @@\n- * The handler will be called synchronously, before the default handler of the signal. g_signal_emit() will not return control until all handlers are called.\n+ * The handler will be called synchronously, before the default handler of the signal.\n+ * [func@GObject.signal_emit] will not return control until all handlers are called.\n@@ -507,1 +508,1 @@\n- * See [memory management of signal handlers][signal-memory-management] for\n+ * See [memory management of signal handlers](signals.html#Memory_management_of_signal_handlers) for\n@@ -510,1 +511,4 @@\n- * Returns: the handler ID, of type #gulong (always greater than 0 for successful connections)\n+ * This function cannot fail. If the given signal doesn’t exist, a critical\n+ * warning is emitted.\n+ *\n+ * Returns: the handler ID, of type `gulong` (always greater than 0)\n@@ -527,1 +531,4 @@\n- * Returns: the handler ID, of type #gulong (always greater than 0 for successful connections)\n+ * This function cannot fail. If the given signal doesn’t exist, a critical\n+ * warning is emitted.\n+ *\n+ * Returns: the handler ID, of type `gulong` (always greater than 0)\n@@ -565,1 +572,4 @@\n- * Returns: the handler ID, of type #gulong (always greater than 0 for successful connections)\n+ * This function cannot fail. If the given signal doesn’t exist, a critical\n+ * warning is emitted.\n+ *\n+ * Returns: the handler ID, of type `gulong` (always greater than 0)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gsignal.h","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  if (g_once_init_enter (&etype))\n+  if (g_once_init_enter_pointer (&etype))\n@@ -51,1 +51,1 @@\n-      g_once_init_leave (&etype, type_id);\n+      g_once_init_leave_pointer (&etype, type_id);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gsourceclosure.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,59 +47,0 @@\n-\/**\n- * SECTION:gtype\n- * @short_description: The GLib Runtime type identification and\n- *     management system\n- * @title:Type Information\n- *\n- * The GType API is the foundation of the GObject system. It provides the\n- * facilities for registering and managing all fundamental data types,\n- * user-defined object and interface types.\n- *\n- * For type creation and registration purposes, all types fall into one of\n- * two categories: static or dynamic.  Static types are never loaded or\n- * unloaded at run-time as dynamic types may be.  Static types are created\n- * with g_type_register_static() that gets type specific information passed\n- * in via a #GTypeInfo structure.\n- *\n- * Dynamic types are created with g_type_register_dynamic() which takes a\n- * #GTypePlugin structure instead. The remaining type information (the\n- * #GTypeInfo structure) is retrieved during runtime through #GTypePlugin\n- * and the g_type_plugin_*() API.\n- *\n- * These registration functions are usually called only once from a\n- * function whose only purpose is to return the type identifier for a\n- * specific class.  Once the type (or class or interface) is registered,\n- * it may be instantiated, inherited, or implemented depending on exactly\n- * what sort of type it is.\n- *\n- * There is also a third registration function for registering fundamental\n- * types called g_type_register_fundamental() which requires both a #GTypeInfo\n- * structure and a #GTypeFundamentalInfo structure but it is seldom used\n- * since most fundamental types are predefined rather than user-defined.\n- *\n- * Type instance and class structs are limited to a total of 64 KiB,\n- * including all parent types. Similarly, type instances' private data\n- * (as created by G_ADD_PRIVATE()) are limited to a total of\n- * 64 KiB. If a type instance needs a large static buffer, allocate it\n- * separately (typically by using #GArray or #GPtrArray) and put a pointer\n- * to the buffer in the structure.\n- *\n- * As mentioned in the [GType conventions][gtype-conventions], type names must\n- * be at least three characters long. There is no upper length limit. The first\n- * character must be a letter (a–z or A–Z) or an underscore (‘_’). Subsequent\n- * characters can be letters, numbers or any of ‘-_+’.\n- *\n- * # Runtime Debugging\n- *\n- * When 'G_ENABLE_DEBUG' is defined during compilation, the GObject library\n- * supports an environment variable 'GOBJECT_DEBUG' that can be set to a\n- * combination of flags to trigger debugging messages about\n- * object bookkeeping and signal emissions during runtime.\n- *\n- * The currently supported flags are:\n- *  - 'objects': Tracks all #GObject instances in a global hash table called\n- *    'debug_objects_ht', and prints the still-alive objects on exit.\n- *  - 'instance-count': Tracks the number of instances of every #GType and makes\n- *    it available via the g_type_get_instance_count() function.\n- *  - 'signals': Currently unused.\n- *\/\n-\n@@ -158,0 +99,3 @@\n+\/* Make sure G_TYPE_IS_*() macros still end up inlined *\/\n+#define g_type_test_flags(t,f) _g_type_test_flags(t,f)\n+\n@@ -166,0 +110,1 @@\n+  G_TYPE_FLAG_ABSTRACT | \\\n@@ -167,0 +112,1 @@\n+  G_TYPE_FLAG_DEPRECATED | \\\n@@ -201,0 +147,2 @@\n+static inline gboolean                  _g_type_test_flags              (GType                   type,\n+                                                                         guint                   flags);\n@@ -255,0 +203,1 @@\n+  guint        is_abstract : 1;\n@@ -256,0 +205,1 @@\n+  guint        is_deprecated : 1;\n@@ -475,1 +425,1 @@\n-    type = (GType) node;\n+    type = GPOINTER_TO_TYPE (node);\n@@ -485,0 +435,1 @@\n+      node->is_abstract = (type_flags & G_TYPE_FLAG_ABSTRACT) != 0;\n@@ -486,0 +437,1 @@\n+      node->is_deprecated = (type_flags & G_TYPE_FLAG_DEPRECATED) != 0;\n@@ -501,0 +453,1 @@\n+      node->is_abstract = (type_flags & G_TYPE_FLAG_ABSTRACT) != 0;\n@@ -502,0 +455,1 @@\n+      node->is_deprecated = (type_flags & G_TYPE_FLAG_DEPRECATED) != 0;\n@@ -504,0 +458,2 @@\n+      node->is_deprecated |= pnode->is_deprecated;\n+\n@@ -544,1 +500,1 @@\n-           (gpointer) type);\n+           GTYPE_TO_POINTER (type));\n@@ -576,2 +532,0 @@\n-  type_flags &= TYPE_FUNDAMENTAL_FLAG_MASK;\n-\n@@ -581,1 +535,1 @@\n-  finfo->type_flags = type_flags;\n+  finfo->type_flags = type_flags & TYPE_FUNDAMENTAL_FLAG_MASK;\n@@ -1866,1 +1820,1 @@\n-  if (g_once_init_enter (&enable_diagnostic))\n+  if (g_once_init_enter_pointer (&enable_diagnostic))\n@@ -1873,1 +1827,1 @@\n-      g_once_init_leave (&enable_diagnostic, value);\n+      g_once_init_leave_pointer (&enable_diagnostic, value);\n@@ -2791,1 +2745,1 @@\n-      g_critical (\"attempt to register fundamental type '%s' with invalid type id (%\" G_GSIZE_FORMAT \")\",\n+      g_critical (\"attempt to register fundamental type '%s' with invalid type id (%\" G_GUINTPTR_FORMAT \")\",\n@@ -2793,1 +2747,1 @@\n-      type_id);\n+      (guintptr) type_id);\n@@ -3514,1 +3468,1 @@\n-  type = (GType) g_hash_table_lookup (static_type_nodes_ht, name);\n+  type = GPOINTER_TO_TYPE (g_hash_table_lookup (static_type_nodes_ht, name));\n@@ -3943,0 +3897,2 @@\n+  node->is_abstract = (flags & G_TYPE_FLAG_ABSTRACT) != 0;\n+  node->is_deprecated |= (flags & G_TYPE_FLAG_DEPRECATED) != 0;\n@@ -4019,2 +3975,2 @@\n-gboolean\n-g_type_test_flags (GType type,\n+static inline gboolean\n+_g_type_test_flags (GType type,\n@@ -4031,2 +3987,2 @@\n-          if (flags & G_TYPE_FLAG_CLASSED)\n-            result |= node->is_classed;\n+          if ((flags & G_TYPE_FLAG_CLASSED) && !node->is_classed)\n+            return FALSE;\n@@ -4034,2 +3990,2 @@\n-          if (flags & G_TYPE_FLAG_INSTANTIATABLE)\n-            result |= node->is_instantiatable;\n+          if ((flags & G_TYPE_FLAG_INSTANTIATABLE) && !node->is_instantiatable)\n+            return FALSE;\n@@ -4037,2 +3993,2 @@\n-          if (flags & G_TYPE_FLAG_FINAL)\n-            result |= node->is_final;\n+          if ((flags & G_TYPE_FLAG_FINAL) && !node->is_final)\n+            return FALSE;\n@@ -4040,1 +3996,7 @@\n-          return result;\n+          if ((flags & G_TYPE_FLAG_ABSTRACT) && !node->is_abstract)\n+            return FALSE;\n+\n+          if ((flags & G_TYPE_FLAG_DEPRECATED) && !node->is_deprecated)\n+            return FALSE;\n+\n+          return TRUE;\n@@ -4070,0 +4032,7 @@\n+gboolean\n+(g_type_test_flags) (GType type,\n+                     guint flags)\n+{\n+  return _g_type_test_flags (type, flags);\n+}\n+\n@@ -4445,1 +4414,1 @@\n-    g_critical (G_STRLOC \": type id '%\" G_GSIZE_FORMAT \"' is invalid\", type);\n+    g_critical (G_STRLOC \": type id '%\" G_GUINTPTR_FORMAT \"' is invalid\", (guintptr) type);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtype.c","additions":48,"deletions":79,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -424,1 +424,3 @@\n-#if     GLIB_SIZEOF_SIZE_T != GLIB_SIZEOF_LONG || !defined (G_CXX_STD_VERSION)\n+#if     GLIB_SIZEOF_VOID_P > GLIB_SIZEOF_SIZE_T\n+typedef guintptr                        GType;\n+#elif     GLIB_SIZEOF_SIZE_T != GLIB_SIZEOF_LONG || !defined (G_CXX_STD_VERSION)\n@@ -426,1 +428,1 @@\n-#else   \/* for historic reasons, C++ links against gulong GTypes *\/\n+#else   \/* for historic reasons, C++ on non-Morello\/CHERI systems links against gulong GTypes *\/\n@@ -2012,2 +2014,2 @@\n- *   static gsize static_g_define_type_id = 0;\n- *   if (g_once_init_enter (&static_g_define_type_id))\n+ *   static GType static_g_define_type_id = 0;\n+ *   if (g_once_init_enter_pointer (&static_g_define_type_id))\n@@ -2033,1 +2035,1 @@\n- *       g_once_init_leave (&static_g_define_type_id, g_define_type_id);\n+ *       g_once_init_leave_pointer (&static_g_define_type_id, g_define_type_id);\n@@ -2268,0 +2270,10 @@\n+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_80\n+#define _g_type_once_init_type GType\n+#define _g_type_once_init_enter g_once_init_enter_pointer\n+#define _g_type_once_init_leave g_once_init_leave_pointer\n+#else  \/* if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_80 *\/\n+#define _g_type_once_init_type gsize\n+#define _g_type_once_init_enter g_once_init_enter\n+#define _g_type_once_init_leave g_once_init_leave\n+#endif  \/* GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_80 *\/\n+\n@@ -2289,1 +2301,1 @@\n-  static gsize static_g_define_type_id = 0;\n+  static _g_type_once_init_type static_g_define_type_id = 0;\n@@ -2294,1 +2306,1 @@\n-  if (g_once_init_enter (&static_g_define_type_id)) \\\n+  if (_g_type_once_init_enter (&static_g_define_type_id)) \\\n@@ -2297,2 +2309,2 @@\n-      g_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n-    }                                   \\\n+      _g_type_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n+    } \\\n@@ -2337,2 +2349,2 @@\n-  static gsize static_g_define_type_id = 0; \\\n-  if (g_once_init_enter (&static_g_define_type_id)) \\\n+  static _g_type_once_init_type static_g_define_type_id = 0; \\\n+  if (_g_type_once_init_enter (&static_g_define_type_id)) \\\n@@ -2463,2 +2475,2 @@\n-  static gsize static_g_define_type_id = 0; \\\n-  if (g_once_init_enter (&static_g_define_type_id)) \\\n+  static _g_type_once_init_type static_g_define_type_id = 0; \\\n+  if (_g_type_once_init_enter (&static_g_define_type_id)) \\\n@@ -2467,1 +2479,1 @@\n-      g_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n+      _g_type_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n@@ -2500,2 +2512,2 @@\n-  static gsize static_g_define_type_id = 0; \\\n-  if (g_once_init_enter (&static_g_define_type_id)) \\\n+  static _g_type_once_init_type static_g_define_type_id = 0; \\\n+  if (_g_type_once_init_enter (&static_g_define_type_id)) \\\n@@ -2504,1 +2516,1 @@\n-      g_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n+      _g_type_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n@@ -2553,2 +2565,2 @@\n-  static gsize static_g_define_type_id = 0; \\\n-  if (g_once_init_enter (&static_g_define_type_id)) \\\n+  static _g_type_once_init_type static_g_define_type_id = 0; \\\n+  if (_g_type_once_init_enter (&static_g_define_type_id)) \\\n@@ -2557,1 +2569,1 @@\n-      g_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n+      _g_type_once_init_leave (&static_g_define_type_id, g_define_type_id); \\\n@@ -2701,0 +2713,21 @@\n+\/**\n+ * GPOINTER_TO_TYPE:\n+ * @p: The pointer to convert to a #GType\n+ *\n+ * This macro should be used instead of GPOINTER_TO_SIZE() to ensure\n+ * portability since #GType is not guaranteed to be the same as #gsize.\n+ *\n+ * Since: 2.80\n+ *\/\n+#define GPOINTER_TO_TYPE(p) ((GType) (guintptr) (p)) GOBJECT_AVAILABLE_MACRO_IN_2_80\n+\/**\n+ * GTYPE_TO_POINTER:\n+ * @t: The #GType to convert to a pointer\n+ *\n+ * This macro should be used instead of GSIZE_TO_POINTER() to ensure\n+ * portability since #GType is not guaranteed to be the same as #gsize.\n+ *\n+ * Since: 2.80\n+ *\/\n+#define GTYPE_TO_POINTER(t) ((gpointer) (guintptr) (t)) GOBJECT_AVAILABLE_MACRO_IN_2_80\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtype.h","additions":53,"deletions":20,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -29,4 +29,2 @@\n- * SECTION:gtypemodule\n- * @short_description: Type loading modules\n- * @see_also: #GTypePlugin, #GModule\n- * @title: GTypeModule\n+ * GTypeModule:\n+ * @name: the name of the module\n@@ -34,1 +32,1 @@\n- * #GTypeModule provides a simple implementation of the #GTypePlugin\n+ * `GTypeModule` provides a simple implementation of the `GTypePlugin`\n@@ -37,1 +35,1 @@\n- * The model of #GTypeModule is a dynamically loaded module which\n+ * The model of `GTypeModule` is a dynamically loaded module which\n@@ -41,1 +39,2 @@\n- * using g_type_module_register_type() and g_type_module_add_interface().\n+ * using [method@GObject.TypeModule.register_type] and\n+ * [method@GObject.TypeModule.add_interface].\n@@ -47,1 +46,1 @@\n- * would lead to the caller's code being unloaded before g_object_unref()\n+ * would lead to the caller's code being unloaded before `g_object_unref()`\n@@ -54,5 +53,5 @@\n- * g_type_module_use() and g_type_module_unuse(). Typically, when loading\n- * a module for the first type, g_type_module_use() will be used to load\n- * it so that it can initialize its types. At some later point, when the\n- * module no longer needs to be loaded except for the type\n- * implementations it contains, g_type_module_unuse() is called.\n+ * [method@GObject.TypeModule.use] and [method@GObject.TypeModule.unuse].\n+ * Typically, when loading a module for the first type, `g_type_module_use()`\n+ * will be used to load it so that it can initialize its types. At some later\n+ * point, when the module no longer needs to be loaded except for the type\n+ * implementations it contains, `g_type_module_unuse()` is called.\n@@ -60,1 +59,1 @@\n- * #GTypeModule does not actually provide any implementation of module\n+ * `GTypeModule` does not actually provide any implementation of module\n@@ -62,2 +61,2 @@\n- * derive from #GTypeModule and implement the load and unload functions\n- * in #GTypeModuleClass.\n+ * derive from `GTypeModule` and implement the load and unload functions\n+ * in `GTypeModuleClass`.\n@@ -119,0 +118,4 @@\n+  \/* in case a subclass does not chain-up to parent in dispose() *\/\n+  g_assert (module->type_infos == NULL);\n+  g_assert (module->interface_infos == NULL);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtypemodule.c","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -43,7 +43,0 @@\n-\/**\n- * GTypeModule:\n- * @name: the name of the module\n- *\n- * The members of the GTypeModule structure should not\n- * be accessed directly, except for the @name field.\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtypemodule.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n- * SECTION:gtypeplugin\n- * @short_description: An interface for dynamically loadable types\n- * @see_also: #GTypeModule and g_type_register_dynamic().\n- * @title: GTypePlugin\n+ * GTypePlugin:\n@@ -39,1 +36,1 @@\n- *    |[<!-- language=\"C\" -->\n+ *    ```c\n@@ -44,3 +41,3 @@\n- *    ]|\n- *    where @new_type_plugin is an implementation of the\n- *    #GTypePlugin interface.\n+ *    ```\n+ *    where `new_type_plugin` is an implementation of the\n+ *    `GTypePlugin` interface.\n@@ -49,3 +46,3 @@\n- *    g_type_class_ref() or through g_type_create_instance() (this is\n- *    being called by g_object_new()) or through one of the above done on\n- *    a type derived from @new_type_id.\n+ *    [func@GObject.TypeClass.ref] or through [func@GObject.type_create_instance]\n+ *    (this is being called by [ctor@GObject.Object.new]) or through one of the above\n+ *    done on a type derived from `new_type_id`.\n@@ -53,3 +50,3 @@\n- * 3. This causes the type system to load the type's implementation by\n- *    calling g_type_plugin_use() and g_type_plugin_complete_type_info()\n- *    on @new_type_plugin.\n+ * 3. This causes the type system to load the type's implementation by calling\n+ *    [method@GObject.TypePlugin.use] and [method@GObject.TypePlugin.complete_type_info]\n+ *    on `new_type_plugin`.\n@@ -57,3 +54,3 @@\n- * 4. At some point the type's implementation isn't required anymore,\n- *    e.g. after g_type_class_unref() or g_type_free_instance() (called\n- *    when the reference count of an instance drops to zero).\n+ * 4. At some point the type's implementation isn't required anymore, e.g. after\n+ *    [method@GObject.TypeClass.unref] or [func@GObject.type_free_instance]\n+ *    (called when the reference count of an instance drops to zero).\n@@ -62,2 +59,2 @@\n- *    from g_type_plugin_complete_type_info() and then it calls\n- *    g_type_plugin_unuse() on @new_type_plugin.\n+ *    from [method@GObject.TypePlugin.complete_type_info] and then it calls\n+ *    [method@GObject.TypePlugin.unuse] on `new_type_plugin`.\n@@ -67,1 +64,1 @@\n- * So basically, you need to implement a #GTypePlugin type that\n+ * So basically, you need to implement a `GTypePlugin` type that\n@@ -70,1 +67,1 @@\n- * g_type_plugin_complete_type_info() call. Later, maybe after\n+ * [method@GObject.TypePlugin.complete_type_info] call. Later, maybe after\n@@ -73,2 +70,2 @@\n- * g_type_plugin_use() and g_type_plugin_complete_type_info() again\n- * when the type is needed again.\n+ * [method@GObject.TypePlugin.use] and [method@GObject.TypePlugin.complete_type_info]\n+ * again when the type is needed again.\n@@ -76,2 +73,2 @@\n- * #GTypeModule is an implementation of #GTypePlugin that already\n- * implements most of this except for the actual module loading and\n+ * [class@GObject.TypeModule] is an implementation of `GTypePlugin` that\n+ * already implements most of this except for the actual module loading and\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtypeplugin.c","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -83,6 +83,0 @@\n-\/**\n- * GTypePlugin:\n- *\n- * The GTypePlugin typedef is used as a placeholder\n- * for objects that implement the GTypePlugin interface.\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtypeplugin.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,116 +34,0 @@\n-\/**\n- * SECTION:generic_values\n- * @short_description: A polymorphic type that can hold values of any\n- *     other type\n- * @see_also: The fundamental types which all support #GValue\n- *     operations and thus can be used as a type initializer for\n- *     g_value_init() are defined by a separate interface.  See the\n- *     [standard values API][gobject-Standard-Parameter-and-Value-Types]\n- *     for details\n- * @title: Generic values\n- *\n- * The #GValue structure is basically a variable container that consists\n- * of a type identifier and a specific value of that type.\n- *\n- * The type identifier within a #GValue structure always determines the\n- * type of the associated value.\n- *\n- * To create an undefined #GValue structure, simply create a zero-filled\n- * #GValue structure. To initialize the #GValue, use the g_value_init()\n- * function. A #GValue cannot be used until it is initialized. Before\n- * destruction you must always use g_value_unset() to make sure allocated\n- * memory is freed.\n- *\n- * The basic type operations (such as freeing and copying) are determined\n- * by the #GTypeValueTable associated with the type ID stored in the #GValue.\n- * Other #GValue operations (such as converting values between types) are\n- * provided by this interface.\n- *\n- * The code in the example program below demonstrates #GValue's\n- * features.\n- *\n- * |[<!-- language=\"C\" -->\n- * #include <glib-object.h>\n- *\n- * static void\n- * int2string (const GValue *src_value,\n- *             GValue       *dest_value)\n- * {\n- *   if (g_value_get_int (src_value) == 42)\n- *     g_value_set_static_string (dest_value, \"An important number\");\n- *   else\n- *     g_value_set_static_string (dest_value, \"What's that?\");\n- * }\n- *\n- * int\n- * main (int   argc,\n- *       char *argv[])\n- * {\n- *   \/\/ GValues must be initialized\n- *   GValue a = G_VALUE_INIT;\n- *   GValue b = G_VALUE_INIT;\n- *   const gchar *message;\n- *\n- *   \/\/ The GValue starts empty\n- *   g_assert (!G_VALUE_HOLDS_STRING (&a));\n- *\n- *   \/\/ Put a string in it\n- *   g_value_init (&a, G_TYPE_STRING);\n- *   g_assert (G_VALUE_HOLDS_STRING (&a));\n- *   g_value_set_static_string (&a, \"Hello, world!\");\n- *   g_printf (\"%s\\n\", g_value_get_string (&a));\n- *\n- *   \/\/ Reset it to its pristine state\n- *   g_value_unset (&a);\n- *\n- *   \/\/ It can then be reused for another type\n- *   g_value_init (&a, G_TYPE_INT);\n- *   g_value_set_int (&a, 42);\n- *\n- *   \/\/ Attempt to transform it into a GValue of type STRING\n- *   g_value_init (&b, G_TYPE_STRING);\n- *\n- *   \/\/ An INT is transformable to a STRING\n- *   g_assert (g_value_type_transformable (G_TYPE_INT, G_TYPE_STRING));\n- *\n- *   g_value_transform (&a, &b);\n- *   g_printf (\"%s\\n\", g_value_get_string (&b));\n- *\n- *   \/\/ Attempt to transform it again using a custom transform function\n- *   g_value_register_transform_func (G_TYPE_INT, G_TYPE_STRING, int2string);\n- *   g_value_transform (&a, &b);\n- *   g_printf (\"%s\\n\", g_value_get_string (&b));\n- *   return 0;\n- * }\n- * ]|\n- *\n- * See also [gobject-Standard-Parameter-and-Value-Types] for more information on\n- * validation of #GValue.\n- *\n- * For letting a #GValue own (and memory manage) arbitrary types or pointers,\n- * they need to become a [boxed type][gboxed]. The example below shows how\n- * the pointer `mystruct` of type `MyStruct` is used as a [boxed type][gboxed].\n- *\n- * |[<!-- language=\"C\" -->\n- * typedef struct { ... } MyStruct;\n- * G_DEFINE_BOXED_TYPE (MyStruct, my_struct, my_struct_copy, my_struct_free)\n- *\n- * \/\/ These two lines normally go in a public header. By GObject convention,\n- * \/\/ the naming scheme is NAMESPACE_TYPE_NAME:\n- * #define MY_TYPE_STRUCT (my_struct_get_type ())\n- * GType my_struct_get_type (void);\n- *\n- * void\n- * foo ()\n- * {\n- *   GValue *value = g_new0 (GValue, 1);\n- *   g_value_init (value, MY_TYPE_STRUCT);\n- *   g_value_set_boxed (value, mystruct);\n- *   \/\/ [... your code ....]\n- *   g_value_unset (value);\n- *   g_free (value);\n- * }\n- * ]|\n- *\/\n-\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gvalue.c","additions":0,"deletions":116,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -33,5 +33,3 @@\n- * SECTION:value_arrays\n- * @short_description: A container structure to maintain an array of\n- *     generic values\n- * @see_also: #GValue, #GParamSpecValueArray, g_param_spec_value_array()\n- * @title: Value arrays\n+ * GValueArray:\n+ * @n_values: number of values contained in the array\n+ * @values: array of values\n@@ -39,4 +37,1 @@\n- * The prime purpose of a #GValueArray is for it to be used as an\n- * object property that holds an array of values. A #GValueArray wraps\n- * an array of #GValue elements in order for it to be used as a boxed\n- * type through %G_TYPE_VALUE_ARRAY.\n+ * A `GValueArray` is a container structure to hold an array of generic values.\n@@ -44,5 +39,4 @@\n- * #GValueArray is deprecated in favour of #GArray since GLib 2.32. It\n- * is possible to create a #GArray that behaves like a #GValueArray by\n- * using the size of #GValue as the element size, and by setting\n- * g_value_unset() as the clear function using g_array_set_clear_func(),\n- * for instance, the following code:\n+ * The prime purpose of a `GValueArray` is for it to be used as an\n+ * object property that holds an array of values. A `GValueArray` wraps\n+ * an array of `GValue` elements in order for it to be used as a boxed\n+ * type through `G_TYPE_VALUE_ARRAY`.\n@@ -50,1 +44,7 @@\n- * |[<!-- language=\"C\" -->\n+ * `GValueArray` is deprecated in favour of `GArray` since GLib 2.32.\n+ * It is possible to create a `GArray` that behaves like a `GValueArray`\n+ * by using the size of `GValue` as the element size, and by setting\n+ * [method@GObject.Value.unset] as the clear function using\n+ * [func@GLib.Array.set_clear_func], for instance, the following code:\n+ *\n+ * ```c\n@@ -52,1 +52,1 @@\n- * ]|\n+ * ```\n@@ -56,1 +56,1 @@\n- * |[<!-- language=\"C\" -->\n+ * ```c\n@@ -59,1 +59,1 @@\n- * ]|\n+ * ```\n@@ -61,1 +61,1 @@\n- * Deprecated: 2.32: Use #GArray instead, if possible for the given use case,\n+ * Deprecated: 2.32: Use `GArray` instead, if possible for the given use case,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gvaluearray.c","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -44,7 +44,0 @@\n-\/**\n- * GValueArray:\n- * @n_values: number of values contained in the array\n- * @values: array of values\n- *\n- * A #GValueArray contains an array of #GValue elements.\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gvaluearray.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -21,11 +21,1 @@\n-\/**\n- * SECTION:value_collection\n- * @Short_description: Converting varargs to generic values\n- * @Title: Varargs Value Collection\n- *\n- * The macros in this section provide the varargs parsing support needed\n- * in variadic GObject functions such as g_object_new() or g_object_set().\n- *\n- * They currently support the collection of integral types, floating point\n- * types and pointers.\n- *\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gvaluecollector.h","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1162,0 +1162,35 @@\n+\/**\n+ * g_value_steal_string:\n+ * @value: a valid #GValue of type %G_TYPE_STRING\n+ *\n+ * Steal ownership on contents of a %G_TYPE_STRING #GValue.\n+ * As a result of this operation the value's contents will be reset to %NULL.\n+ *\n+ * The purpose of this call is to provide a way to avoid an extra copy\n+ * when some object have been serialized into string through #GValue API.\n+ *\n+ * NOTE: for safety and compatibility purposes, if #GValue contains\n+ * static string, or an interned one, this function will return a copy\n+ * of the string. Otherwise the transfer notation would be ambiguous.\n+ *\n+ * Returns: (nullable) (transfer full): string content of @value;\n+ *  Should be freed with g_free() when no longer needed.\n+ *\n+ * Since: 2.80\n+ *\/\n+gchar*\n+g_value_steal_string (GValue *value)\n+{\n+  gchar *ret;\n+\n+  g_return_val_if_fail (G_VALUE_HOLDS_STRING (value), NULL);\n+\n+  ret = value->data[0].v_pointer;\n+  value->data[0].v_pointer = NULL;\n+\n+  if (value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS)\n+    return g_strdup (ret);\n+\n+  return ret;\n+}\n+\n@@ -1211,1 +1246,1 @@\n-  value->data[0].v_pointer = GSIZE_TO_POINTER (v_gtype);\n+  value->data[0].v_pointer = GTYPE_TO_POINTER (v_gtype);\n@@ -1230,1 +1265,1 @@\n-  return GPOINTER_TO_SIZE (value->data[0].v_pointer);\n+  return GPOINTER_TO_TYPE (value->data[0].v_pointer);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gvaluetypes.c","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -266,0 +266,2 @@\n+GOBJECT_AVAILABLE_IN_2_80\n+gchar*            g_value_steal_string  (GValue *value);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gvaluetypes.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -21,0 +21,3 @@\n+#ifndef GSTREAMER_LITE\n+#include <gst\/audio\/gstdsd.h>\n+#endif \/\/ GSTREAMER_LITE\n@@ -241,0 +244,205 @@\n+#ifndef GSTREAMER_LITE\n+\/* Notes about what the \"rate\" means in DSD:\n+ *\n+ * In DSD, \"sample formats\" don't actually exist. There is only the DSD bit;\n+ * this is what could be considered the closest equivalent to a \"sample format\".\n+ * But since it is impractical to deal with individual bits in software, the\n+ * bits are typically grouped into words (8\/16\/32 bit words). These are the\n+ * DSDU8, DSDU16LE etc. \"grouping formats\".\n+ *\n+ * The \"rate\" in DSD information refers to the number of DSD _bytes_ per second\n+ * (not bits per second, because, as said, per-bit handling in software does\n+ * not usually make sense). ALSA however interprets \"rate\" as the number of\n+ * DSD _words_ per minute. If the word format is DSDU8, then there's no difference.\n+ * But if for example it is DSDU16LE, then ALSA's rate is half of the rate\n+ * from GstDsdInfo. For this reason, before setting the rate in the ALSA\n+ * hw params, it is essential to divide the rate from the DSD info by the\n+ * word length (in bytes).\n+ *\/\n+\n+typedef struct\n+{\n+  snd_pcm_format_t alsa_format;\n+  const char *gstreamer_format_name;\n+} DsdFormatInfo;\n+\n+static GstCaps *\n+gst_alsa_detect_dsd_formats (GstObject * obj, snd_pcm_hw_params_t * hw_params)\n+{\n+  snd_pcm_format_mask_t *mask;\n+  GValue format_list_value = G_VALUE_INIT;\n+  gint table_idx;\n+  gboolean dsd_is_supported = FALSE;\n+  GstCaps *caps = NULL;\n+\n+  const DsdFormatInfo format_table[] = {\n+    {SND_PCM_FORMAT_DSD_U8, \"DSDU8\"},\n+    {SND_PCM_FORMAT_DSD_U16_LE, \"DSDU16LE\"},\n+    {SND_PCM_FORMAT_DSD_U16_BE, \"DSDU16BE\"},\n+    {SND_PCM_FORMAT_DSD_U32_LE, \"DSDU32LE\"},\n+    {SND_PCM_FORMAT_DSD_U32_BE, \"DSDU32BE\"}\n+  };\n+  const gint format_table_size = sizeof (format_table) \/ sizeof (DsdFormatInfo);\n+\n+  g_value_init (&format_list_value, GST_TYPE_LIST);\n+\n+  snd_pcm_format_mask_malloc (&mask);\n+  snd_pcm_hw_params_get_format_mask (hw_params, mask);\n+\n+  for (table_idx = 0; table_idx < format_table_size; ++table_idx) {\n+    const DsdFormatInfo *format_info = &(format_table[table_idx]);\n+    gboolean format_supported = snd_pcm_format_mask_test (mask,\n+        format_info->alsa_format);\n+\n+    GST_DEBUG_OBJECT (obj, \"%s supported: %s\",\n+        format_info->gstreamer_format_name, format_supported ? \"yes\" : \"no\");\n+\n+    if (format_supported) {\n+      GValue format_value = G_VALUE_INIT;\n+\n+      g_value_init (&format_value, G_TYPE_STRING);\n+      g_value_set_string (&format_value, format_info->gstreamer_format_name);\n+      gst_value_list_append_and_take_value (&format_list_value, &format_value);\n+\n+      dsd_is_supported = TRUE;\n+    }\n+  }\n+\n+  if (dsd_is_supported) {\n+    GstStructure *structure;\n+    structure = gst_structure_new_empty (\"audio\/x-dsd\");\n+\n+    \/* As a small optimization, if we only support exactly one\n+     * format, store it directly instead of an 1-item list. *\/\n+\n+    if (gst_value_list_get_size (&format_list_value) == 1) {\n+      const GValue *supported_format_value =\n+          gst_value_list_get_value (&format_list_value, 0);\n+\n+      gst_structure_set_value (structure, \"format\", supported_format_value);\n+      g_value_unset (&format_list_value);\n+    } else\n+      gst_structure_take_value (structure, \"format\", &format_list_value);\n+\n+    caps = gst_caps_new_full (structure, NULL);\n+  } else {\n+    g_value_unset (&format_list_value);\n+  }\n+\n+  snd_pcm_format_mask_free (mask);\n+\n+  return caps;\n+}\n+\n+static GstCaps *\n+gst_alsa_detect_dsd_rates (GstObject * obj, snd_pcm_t * handle,\n+    snd_pcm_hw_params_t * hw_params, GstCaps * in_caps)\n+{\n+  GstCaps *caps = NULL;\n+  guint min_rate, max_rate;\n+  gint err, dir, caps_idx;\n+  int cur_dsd_multiplier;\n+  gboolean keep_testing_rates;\n+  GValue rate_list_value = G_VALUE_INIT;\n+  GValue rate_value = G_VALUE_INIT;\n+\n+  GST_LOG_OBJECT (obj, \"probing DSD sample rates ...\");\n+\n+  g_value_init (&rate_list_value, GST_TYPE_LIST);\n+  g_value_init (&rate_value, G_TYPE_INT);\n+\n+  if ((err = snd_pcm_hw_params_get_rate_min (hw_params, &min_rate, &dir)) < 0)\n+    goto min_rate_err;\n+\n+  if ((err = snd_pcm_hw_params_get_rate_max (hw_params, &max_rate, &dir)) < 0)\n+    goto max_rate_err;\n+\n+  \/* In DSD, valid rates are an integer multiple of 44100 (DSD-44x) or\n+   * 48000 (DSD-48x), and those multipliers must themselves be a power of\n+   * 2. For example, \"DSD64-44x\" means 64*44100 = 2822400 bits per second.\n+   * In software, we use bytes, so DSD64-44x equals 2822400\/8 = 352800 bytes\n+   * per second. DSD64 is the lowest valid rate. The next higher valid rate\n+   * would be DSD128-4x, and DSD256-44x after that etc. DSD200-44x is not\n+   * valid, for example. For this reason, it makes sense to check for the\n+   * individual valid rates that lie within the range defined by min_rate\n+   * and max_rate. *\/\n+\n+  cur_dsd_multiplier = ((gint64) min_rate) * 8 \/ 44100;\n+  \/* Multipliers below 64 are not valid. If the hardware can't handle\n+   * at least DSD64-44x, we can't play DSD, so this is a good starting\n+   * point for the rate tests below. *\/\n+  if (cur_dsd_multiplier < 64)\n+    cur_dsd_multiplier = 64;\n+\n+  keep_testing_rates = TRUE;\n+  while (keep_testing_rates) {\n+    const int rates_to_test[] = {\n+      GST_DSD_MAKE_DSD_RATE_44x (cur_dsd_multiplier),\n+      GST_DSD_MAKE_DSD_RATE_48x (cur_dsd_multiplier)\n+    };\n+    const gchar *rates_desc[] = { \"44x\", \"48x\" };\n+\n+    int i;\n+\n+    for (i = 0; i < G_N_ELEMENTS (rates_to_test); ++i) {\n+      int rate_to_test = rates_to_test[i];\n+      if (rate_to_test > max_rate) {\n+        keep_testing_rates = FALSE;\n+        break;\n+      }\n+\n+      if (snd_pcm_hw_params_test_rate (handle, hw_params, rate_to_test, 0) == 0) {\n+        GST_DEBUG_OBJECT (obj,\n+            \"DSD%d-%s available (equals rate of %d DSD bytes per second)\",\n+            cur_dsd_multiplier, rates_desc[i], rate_to_test);\n+        g_value_set_int (&rate_value, rate_to_test);\n+        gst_value_list_append_value (&rate_list_value, &rate_value);\n+      }\n+    }\n+\n+    cur_dsd_multiplier *= 2;\n+  }\n+\n+  caps = gst_caps_make_writable (in_caps);\n+\n+  if (gst_value_list_get_size (&rate_list_value) == 1) {\n+    \/* As a small optimization, if we only support exactly one\n+     * rate, store it directly instead of an 1-item list. *\/\n+\n+    const GValue *supported_rate_value =\n+        gst_value_list_get_value (&rate_list_value, 0);\n+\n+    for (caps_idx = 0; caps_idx < gst_caps_get_size (caps); ++caps_idx) {\n+      GstStructure *structure = gst_caps_get_structure (caps, caps_idx);\n+      gst_structure_set_value (structure, \"rate\", supported_rate_value);\n+    }\n+  } else {\n+    for (caps_idx = 0; caps_idx < gst_caps_get_size (caps); ++caps_idx) {\n+      GstStructure *structure = gst_caps_get_structure (caps, caps_idx);\n+      gst_structure_set_value (structure, \"rate\", &rate_list_value);\n+    }\n+  }\n+\n+finish:\n+  g_value_unset (&rate_list_value);\n+  g_value_unset (&rate_value);\n+  return caps;\n+\n+  \/* ERRORS *\/\n+min_rate_err:\n+  {\n+    GST_ERROR_OBJECT (obj, \"failed to query minimum sample rate: %s\",\n+        snd_strerror (err));\n+    gst_caps_unref (in_caps);\n+    goto finish;\n+  }\n+max_rate_err:\n+  {\n+    GST_ERROR_OBJECT (obj, \"failed to query maximum sample rate: %s\",\n+        snd_strerror (err));\n+    gst_caps_unref (in_caps);\n+    goto finish;\n+  }\n+}\n+#endif \/\/ GSTREAMER_LITE\n+\n@@ -517,0 +725,3 @@\n+#ifndef GSTREAMER_LITE\n+  GstCaps *dsd_caps;\n+#endif \/\/ GSTREAMER_LITE\n@@ -525,0 +736,2 @@\n+  \/* Try detecting PCM *\/\n+\n@@ -530,1 +743,1 @@\n-    GST_INFO_OBJECT (obj, \"no formats in native endianness detected\");\n+    GST_INFO_OBJECT (obj, \"no PCM formats in native endianness detected\");\n@@ -536,1 +749,2 @@\n-    if (caps == NULL)\n+    if (caps == NULL) {\n+      GST_ERROR_OBJECT (obj, \"failed to detect PCM formats\");\n@@ -538,0 +752,1 @@\n+    }\n@@ -540,1 +755,2 @@\n-  if (!(caps = gst_alsa_detect_rates (obj, hw_params, caps)))\n+  if (!(caps = gst_alsa_detect_rates (obj, hw_params, caps))) {\n+    GST_ERROR_OBJECT (obj, \"failed to detect PCM rates\");\n@@ -542,0 +758,1 @@\n+  }\n@@ -543,1 +760,2 @@\n-  if (!(caps = gst_alsa_detect_channels (obj, hw_params, caps)))\n+  if (!(caps = gst_alsa_detect_channels (obj, hw_params, caps))) {\n+    GST_ERROR_OBJECT (obj, \"failed to detect PCM channels\");\n@@ -545,0 +763,24 @@\n+  }\n+\n+  \/* Try detecting DSD *\/\n+#ifndef GSTREAMER_LITE\n+  dsd_caps = gst_alsa_detect_dsd_formats (obj, hw_params);\n+  if (dsd_caps != NULL) {\n+    GST_INFO_OBJECT (obj, \"DSD support detected\");\n+\n+    if (!(dsd_caps =\n+            gst_alsa_detect_dsd_rates (obj, handle, hw_params, dsd_caps))) {\n+      GST_ERROR_OBJECT (obj, \"failed to detect DSD rates\");\n+      goto subroutine_error;\n+    }\n+\n+    if (!(dsd_caps = gst_alsa_detect_channels (obj, hw_params, dsd_caps))) {\n+      GST_ERROR_OBJECT (obj, \"failed to detect DSD channels\");\n+      goto subroutine_error;\n+    }\n+\n+    gst_caps_append (caps, dsd_caps);\n+  } else {\n+    GST_INFO_OBJECT (obj, \"DSD support not detected\");\n+  }\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/ext\/alsa\/gstalsa.c","additions":246,"deletions":4,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+#ifndef GSTREAMER_LITE\n+#include <gst\/audio\/gstdsd.h>\n+#endif \/\/ GSTREAMER_LITE\n@@ -117,0 +120,7 @@\n+#ifndef GSTREAMER_LITE\n+        GST_DSD_MEDIA_TYPE \", \"\n+        \"format = (string) \" GST_DSD_FORMATS_ALL \", \"\n+        \"layout = (string) interleaved, \"\n+        \"reversed-bytes = (gboolean) false, \"\n+        \"rate = (int) [ 1, MAX ], \" \"channels = (int) [ 1, MAX ]; \"\n+#endif \/\/ GSTREAMER_LITE\n@@ -828,0 +838,23 @@\n+#ifndef GSTREAMER_LITE\n+    case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD:\n+      switch (GST_AUDIO_RING_BUFFER_SPEC_DSD_FORMAT (spec)) {\n+        case GST_DSD_FORMAT_U8:\n+          alsa->format = SND_PCM_FORMAT_DSD_U8;\n+          break;\n+        case GST_DSD_FORMAT_U16LE:\n+          alsa->format = SND_PCM_FORMAT_DSD_U16_LE;\n+          break;\n+        case GST_DSD_FORMAT_U16BE:\n+          alsa->format = SND_PCM_FORMAT_DSD_U16_BE;\n+          break;\n+        case GST_DSD_FORMAT_U32LE:\n+          alsa->format = SND_PCM_FORMAT_DSD_U32_LE;\n+          break;\n+        case GST_DSD_FORMAT_U32BE:\n+          alsa->format = SND_PCM_FORMAT_DSD_U32_BE;\n+          break;\n+        default:\n+          goto error;\n+      }\n+      break;\n+#endif \/\/ GSTREAMER_LITE\n@@ -851,0 +884,5 @@\n+#ifndef GSTREAMER_LITE\n+  if ((spec->type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW ||\n+          spec->type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD) &&\n+      alsa->channels < 9)\n+#else \/\/ GSTREAMER_LITE\n@@ -852,0 +890,1 @@\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/ext\/alsa\/gstalsasink.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n- * will consume a lot of memory over time. The \"max-buffers\" property can be\n- * used to limit the queue size. The \"drop\" property controls whether the\n+ * will consume a lot of memory over time. The \"max-buffers\", \"max-time\" and \"max-bytes\"\n+ * properties can be used to limit the queue size. The \"drop\" property controls whether the\n@@ -75,0 +75,1 @@\n+#include \"gstapputils.h\"\n@@ -115,3 +116,3 @@\n-  guint num_buffers;\n-  guint num_events;\n-  guint max_buffers;\n+  guint64 max_buffers;\n+  GstClockTime max_time;\n+  guint64 max_bytes;\n@@ -121,0 +122,1 @@\n+  GstQueueStatusInfo queue_status_info;\n@@ -158,0 +160,1 @@\n+  SIGNAL_PROPOSE_ALLOCATION,\n@@ -162,1 +165,1 @@\n-#define DEFAULT_PROP_EOS    TRUE\n+#define DEFAULT_PROP_EOS          TRUE\n@@ -165,1 +168,3 @@\n-#define DEFAULT_PROP_DROP   FALSE\n+#define DEFAULT_PROP_MAX_TIME     0\n+#define DEFAULT_PROP_MAX_BYTES    0\n+#define DEFAULT_PROP_DROP         FALSE\n@@ -179,0 +184,2 @@\n+  PROP_MAX_TIME,\n+  PROP_MAX_BYTES,\n@@ -215,0 +222,2 @@\n+static gboolean gst_app_sink_propose_allocation (GstBaseSink * bsink,\n+    GstQuery * query);\n@@ -255,0 +264,5 @@\n+  \/**\n+   * GstAppSink:max-buffers:\n+   *\n+   * Maximum amount of buffers in the queue (0 = unlimited).\n+   *\/\n@@ -261,0 +275,26 @@\n+  \/**\n+   * GstAppSink:max-time:\n+   *\n+   * Maximum total duration of data in the queue (0 = unlimited)\n+   *\n+   * Since: 1.24\n+   *\/\n+  g_object_class_install_property (gobject_class, PROP_MAX_TIME,\n+      g_param_spec_uint64 (\"max-time\", \"Max time\",\n+          \"The maximum total duration to queue internally (in ns, 0 = unlimited)\",\n+          0, G_MAXUINT64, DEFAULT_PROP_MAX_TIME,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n+\n+  \/**\n+   * GstAppSink:max-bytes:\n+   *\n+   * Maximum amount of bytes in the queue (0 = unlimited)\n+   *\n+   * Since: 1.24\n+   *\/\n+  g_object_class_install_property (gobject_class, PROP_MAX_BYTES,\n+      g_param_spec_uint64 (\"max-bytes\", \"Max bytes\",\n+          \"The maximum amount of bytes to queue internally (0 = unlimited)\",\n+          0, G_MAXUINT64, DEFAULT_PROP_MAX_BYTES,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n+\n@@ -270,0 +310,1 @@\n+\n@@ -271,1 +312,1 @@\n-   * GstAppSink::wait-on-eos:\n+   * GstAppSink:wait-on-eos:\n@@ -338,0 +379,16 @@\n+  \/**\n+   * GstAppSink::propose-allocation:\n+   * @appsink: the appsink element that emitted the signal\n+   * @query: the allocation query\n+   *\n+   * Signal that a new propose_allocation query is available.\n+   *\n+   * This signal is emitted from the streaming thread and only when the\n+   * \"emit-signals\" property is %TRUE.\n+   *\n+   * Since: 1.24\n+   *\/\n+  gst_app_sink_signals[SIGNAL_PROPOSE_ALLOCATION] =\n+      g_signal_new_class_handler (\"propose-allocation\",\n+      G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST, NULL, NULL, NULL, NULL,\n+      G_TYPE_BOOLEAN, 1, GST_TYPE_QUERY | G_SIGNAL_TYPE_STATIC_SCOPE);\n@@ -389,1 +446,1 @@\n-   * Returns: (nullable): a #GstSample or NULL when the appsink is stopped or EOS.\n+   * Returns: (nullable) (transfer full): a #GstSample or %NULL when the appsink is stopped or EOS.\n@@ -409,1 +466,1 @@\n-   * the \"drop\" and \"max-buffers\" properties.\n+   * the \"drop\" and \"max-buffers\" \/ \"max-bytes\" \/ \"max-time\" set of properties.\n@@ -414,1 +471,1 @@\n-   * Returns: (nullable): a #GstSample or NULL when the appsink is stopped or EOS.\n+   * Returns: (nullable) (transfer full): a #GstSample or %NULL when the appsink is stopped or EOS.\n@@ -446,1 +503,2 @@\n-   * Returns: (nullable): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.\n+   * Returns: (nullable) (transfer full): a #GstSample or %NULL when the appsink\n+   * is stopped or EOS or the timeout expires.\n@@ -470,1 +528,1 @@\n-   * the \"drop\" and \"max-buffers\" properties.\n+   * the \"drop\" and \"max-buffers\" \/ \"max-bytes\" \/ \"max-time\" set of properties.\n@@ -502,1 +560,1 @@\n-   * the \"drop\" and \"max-buffers\" properties.\n+   * the \"drop\" and \"max-buffers\" \/ \"max-bytes\" \/ \"max-time\" set of properties.\n@@ -542,0 +600,1 @@\n+  basesink_class->propose_allocation = gst_app_sink_propose_allocation;\n@@ -564,0 +623,2 @@\n+  priv->max_bytes = DEFAULT_PROP_MAX_BYTES;\n+  priv->max_time = DEFAULT_PROP_MAX_TIME;\n@@ -633,0 +694,6 @@\n+    case PROP_MAX_TIME:\n+      gst_app_sink_set_max_time (appsink, g_value_get_uint64 (value));\n+      break;\n+    case PROP_MAX_BYTES:\n+      gst_app_sink_set_max_bytes (appsink, g_value_get_uint64 (value));\n+      break;\n@@ -675,0 +742,6 @@\n+    case PROP_MAX_TIME:\n+      g_value_set_uint64 (value, gst_app_sink_get_max_time (appsink));\n+      break;\n+    case PROP_MAX_BYTES:\n+      g_value_set_uint64 (value, gst_app_sink_get_max_bytes (appsink));\n+      break;\n@@ -753,2 +826,3 @@\n-  priv->num_buffers = 0;\n-  priv->num_events = 0;\n+\n+  gst_queue_status_info_reset (&priv->queue_status_info);\n+\n@@ -817,0 +891,1 @@\n+\n@@ -818,1 +893,2 @@\n-  priv->num_events++;\n+  gst_queue_status_info_push_event (&priv->queue_status_info);\n+\n@@ -853,2 +929,3 @@\n-      \/* wait until all buffers are consumed or we're flushing.\n-       * Otherwise we might signal EOS before all buffers are\n+\n+      \/* Wait until all buffers are consumed, or we're flushing.\n+       * Otherwise, we might signal EOS before all buffers are\n@@ -857,1 +934,2 @@\n-      while (priv->num_buffers > 0 && !priv->flushing && priv->wait_on_eos) {\n+      while (priv->queue_status_info.queued_buffers > 0 && !priv->flushing\n+          && priv->wait_on_eos) {\n@@ -923,1 +1001,4 @@\n-    priv->num_events++;\n+    gst_queue_status_info_push_event (&priv->queue_status_info);\n+\n+    if ((priv->wait_status & APP_WAITING))\n+      g_cond_signal (&priv->cond);\n@@ -1001,1 +1082,0 @@\n-    priv->num_buffers--;\n@@ -1005,2 +1085,0 @@\n-    priv->num_events--;\n-\n@@ -1031,0 +1109,4 @@\n+  \/* We don't have last\/current segment differentiation in appsink, so pass last_segment twice *\/\n+  gst_queue_status_info_pop (&priv->queue_status_info, obj,\n+      &priv->last_segment, &priv->last_segment, GST_OBJECT_CAST (appsink));\n+\n@@ -1078,2 +1160,3 @@\n-  GST_DEBUG_OBJECT (appsink, \"pushing render buffer\/list %p on queue (%d)\",\n-      data, priv->num_buffers);\n+  GST_DEBUG_OBJECT (appsink,\n+      \"pushing render buffer\/list %p on queue (%\" G_GUINT64_FORMAT \")\", data,\n+      priv->queue_status_info.queued_buffers);\n@@ -1081,1 +1164,2 @@\n-  while (priv->max_buffers > 0 && priv->num_buffers >= priv->max_buffers) {\n+  while (gst_queue_status_info_is_full (&priv->queue_status_info,\n+          priv->max_buffers, priv->max_bytes, priv->max_time)) {\n@@ -1091,2 +1175,7 @@\n-      GST_DEBUG_OBJECT (appsink, \"waiting for free space, length %d >= %d\",\n-          priv->num_buffers, priv->max_buffers);\n+      GST_DEBUG_OBJECT (appsink,\n+          \"waiting for free space: have %\" G_GUINT64_FORMAT \"  buffers (max %\"\n+          G_GUINT64_FORMAT \"), %\" G_GUINT64_FORMAT \" bytes (max %\"\n+          G_GUINT64_FORMAT \"), %\" G_GUINT64_FORMAT \" time (max %\"\n+          G_GUINT64_FORMAT \")\", priv->queue_status_info.queued_buffers,\n+          priv->max_buffers, priv->queue_status_info.queued_bytes,\n+          priv->max_bytes, priv->queue_status_info.queued_time, priv->max_time);\n@@ -1115,1 +1204,2 @@\n-  priv->num_buffers++;\n+  gst_queue_status_info_push (&priv->queue_status_info, data,\n+      &priv->last_segment, GST_OBJECT_CAST (appsink));\n@@ -1218,1 +1308,1 @@\n-      while (priv->num_buffers > 0 || priv->preroll_buffer) {\n+      while (priv->queue_status_info.queued_buffers > 0 || priv->preroll_buffer) {\n@@ -1349,1 +1439,1 @@\n-  if (priv->is_eos && priv->num_buffers == 0) {\n+  if (priv->is_eos && priv->queue_status_info.queued_buffers == 0) {\n@@ -1417,0 +1507,35 @@\n+#define GST_APP_SINK_GET_PROPERTY(prop_name)               \\\n+G_STMT_START {                                             \\\n+  GstAppSinkPrivate *priv;                                 \\\n+  guint result;                                            \\\n+                                                           \\\n+  g_return_val_if_fail (GST_IS_APP_SINK (appsink), 0);     \\\n+                                                           \\\n+  priv = appsink->priv;                                    \\\n+                                                           \\\n+  g_mutex_lock (&priv->mutex);                             \\\n+  result = priv->prop_name;                                \\\n+  g_mutex_unlock (&priv->mutex);                           \\\n+                                                           \\\n+  return result;                                           \\\n+} G_STMT_END\n+\n+#define GST_APP_SINK_SET_PROPERTY(prop_name, value)        \\\n+G_STMT_START {                                             \\\n+  GstAppSinkPrivate *priv;                                 \\\n+                                                           \\\n+  g_return_if_fail (GST_IS_APP_SINK (appsink));            \\\n+                                                           \\\n+  priv = appsink->priv;                                    \\\n+                                                           \\\n+  g_mutex_lock (&priv->mutex);                             \\\n+                                                           \\\n+  if (value != priv->prop_name) {                          \\\n+    priv->prop_name = value;                               \\\n+    \/* signal the change *\/                                \\\n+    g_cond_signal (&priv->cond);                           \\\n+  }                                                        \\\n+                                                           \\\n+  g_mutex_unlock (&priv->mutex);                           \\\n+} G_STMT_END\n+\n@@ -1424,1 +1549,2 @@\n- * elements until a sample is pulled from @appsink.\n+ * elements until a sample is pulled from @appsink, unless 'drop' is set, in which\n+ * case new buffers will be discarded.\n@@ -1429,3 +1555,2 @@\n-  GstAppSinkPrivate *priv;\n-\n-  g_return_if_fail (GST_IS_APP_SINK (appsink));\n+  GST_APP_SINK_SET_PROPERTY (max_buffers, max);\n+}\n@@ -1433,1 +1558,17 @@\n-  priv = appsink->priv;\n+\/**\n+ * gst_app_sink_set_max_time:\n+ * @appsink: a #GstAppSink\n+ * @max: the maximum total duration to queue\n+ *\n+ * Set the maximum total duration that can be queued in @appsink. After this\n+ * amount of buffers are queued in appsink, any more buffers will block upstream\n+ * elements until a sample is pulled from @appsink, unless 'drop' is set, in which\n+ * case new buffers will be discarded.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_app_sink_set_max_time (GstAppSink * appsink, GstClockTime max)\n+{\n+  GST_APP_SINK_SET_PROPERTY (max_time, max);\n+}\n@@ -1435,7 +1576,16 @@\n-  g_mutex_lock (&priv->mutex);\n-  if (max != priv->max_buffers) {\n-    priv->max_buffers = max;\n-    \/* signal the change *\/\n-    g_cond_signal (&priv->cond);\n-  }\n-  g_mutex_unlock (&priv->mutex);\n+\/**\n+ * gst_app_sink_set_max_bytes:\n+ * @appsink: a #GstAppSink\n+ * @max: the maximum total size of buffers to queue, in bytes\n+ *\n+ * Set the maximum total size that can be queued in @appsink. After this\n+ * amount of buffers are queued in appsink, any more buffers will block upstream\n+ * elements until a sample is pulled from @appsink, unless 'drop' is set, in which\n+ * case new buffers will be discarded.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_app_sink_set_max_bytes (GstAppSink * appsink, guint64 max)\n+{\n+  GST_APP_SINK_SET_PROPERTY (max_bytes, max);\n@@ -1455,6 +1605,2 @@\n-  guint result;\n-  GstAppSinkPrivate *priv;\n-\n-  g_return_val_if_fail (GST_IS_APP_SINK (appsink), 0);\n-\n-  priv = appsink->priv;\n+  GST_APP_SINK_GET_PROPERTY (max_buffers);\n+}\n@@ -1462,3 +1608,15 @@\n-  g_mutex_lock (&priv->mutex);\n-  result = priv->max_buffers;\n-  g_mutex_unlock (&priv->mutex);\n+\/**\n+ * gst_app_sink_get_max_time:\n+ * @appsink: a #GstAppSink\n+ *\n+ * Get the maximum total duration that can be queued in @appsink.\n+ *\n+ * Returns: The maximum total duration that can be queued.\n+ *\n+ * Since: 1.24\n+ *\/\n+GstClockTime\n+gst_app_sink_get_max_time (GstAppSink * appsink)\n+{\n+  GST_APP_SINK_GET_PROPERTY (max_time);\n+}\n@@ -1466,1 +1624,14 @@\n-  return result;\n+\/**\n+ * gst_app_sink_get_max_bytes:\n+ * @appsink: a #GstAppSink\n+ *\n+ * Get the maximum total size, in bytes, that can be queued in @appsink.\n+ *\n+ * Returns: The maximum amount of bytes that can be queued\n+ *\n+ * Since: 1.24\n+ *\/\n+guint64\n+gst_app_sink_get_max_bytes (GstAppSink * appsink)\n+{\n+  GST_APP_SINK_GET_PROPERTY (max_bytes);\n@@ -1469,0 +1640,3 @@\n+#undef GST_APP_SINK_GET_PROPERTY\n+#undef GST_APP_SINK_SET_PROPERTY\n+\n@@ -1475,1 +1649,1 @@\n- * buffers is reached.\n+ * data is reached, that is, when any configured limit is hit (max-buffers, max-time or max-bytes).\n@@ -1500,1 +1674,1 @@\n- * buffers is reached.\n+ * data is reached (meaning max buffers, time or bytes limit, whichever is hit first).\n@@ -1923,1 +2097,2 @@\n-    if (priv->num_buffers > 0 || priv->num_events > 0)\n+    if (priv->queue_status_info.queued_buffers > 0\n+        || priv->queue_status_info.num_events > 0)\n@@ -2077,0 +2252,29 @@\n+\n+static gboolean\n+gst_app_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)\n+{\n+  gboolean ret = FALSE;\n+  GstAppSink *appsink = GST_APP_SINK_CAST (bsink);\n+  GstAppSinkPrivate *priv = appsink->priv;\n+  Callbacks *callbacks = NULL;\n+  gboolean emit;\n+\n+  g_mutex_lock (&priv->mutex);\n+  emit = priv->emit_signals;\n+  if (priv->callbacks)\n+    callbacks = callbacks_ref (priv->callbacks);\n+  g_mutex_unlock (&priv->mutex);\n+\n+  if (callbacks && callbacks->callbacks.propose_allocation) {\n+    ret =\n+        callbacks->callbacks.propose_allocation (appsink, query,\n+        callbacks->user_data);\n+  } else if (emit) {\n+    g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_PROPOSE_ALLOCATION], 0,\n+        query, &ret);\n+  }\n+\n+  g_clear_pointer (&callbacks, callbacks_unref);\n+\n+  return ret;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/app\/gstappsink.c","additions":261,"deletions":57,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -70,0 +70,6 @@\n+  * @propose_allocation: Called when the propose_allocation query is available.\n+ *       This callback is called from the streaming thread.\n+ *       The allocation query can be retrieved with\n+ *       gst_app_sink_propose_allocation() either from this callback\n+ *       or from any other thread.\n+ *       Since: 1.24\n@@ -75,4 +81,5 @@\n-  void          (*eos)              (GstAppSink *appsink, gpointer user_data);\n-  GstFlowReturn (*new_preroll)      (GstAppSink *appsink, gpointer user_data);\n-  GstFlowReturn (*new_sample)       (GstAppSink *appsink, gpointer user_data);\n-  gboolean      (*new_event)        (GstAppSink *appsink, gpointer user_data);\n+  void          (*eos)                  (GstAppSink *appsink, gpointer user_data);\n+  GstFlowReturn (*new_preroll)          (GstAppSink *appsink, gpointer user_data);\n+  GstFlowReturn (*new_sample)           (GstAppSink *appsink, gpointer user_data);\n+  gboolean      (*new_event)            (GstAppSink *appsink, gpointer user_data);\n+  gboolean      (*propose_allocation)   (GstAppSink *appsink, GstQuery *query, gpointer user_data);\n@@ -81,1 +88,1 @@\n-  gpointer     _gst_reserved[GST_PADDING - 1];\n+  gpointer     _gst_reserved[GST_PADDING - 2];\n@@ -100,3 +107,3 @@\n-  void          (*eos)              (GstAppSink *appsink);\n-  GstFlowReturn (*new_preroll)      (GstAppSink *appsink);\n-  GstFlowReturn (*new_sample)       (GstAppSink *appsink);\n+  void          (*eos)                (GstAppSink *appsink);\n+  GstFlowReturn (*new_preroll)        (GstAppSink *appsink);\n+  GstFlowReturn (*new_sample)         (GstAppSink *appsink);\n@@ -106,4 +113,4 @@\n-  GstSample *   (*pull_preroll)      (GstAppSink *appsink);\n-  GstSample *   (*pull_sample)       (GstAppSink *appsink);\n-  GstSample *   (*try_pull_preroll)  (GstAppSink *appsink, GstClockTime timeout);\n-  GstSample *   (*try_pull_sample)   (GstAppSink *appsink, GstClockTime timeout);\n+  GstSample *   (*pull_preroll)       (GstAppSink *appsink);\n+  GstSample *   (*pull_sample)        (GstAppSink *appsink);\n+  GstSample *   (*try_pull_preroll)   (GstAppSink *appsink, GstClockTime timeout);\n+  GstSample *   (*try_pull_sample)    (GstAppSink *appsink, GstClockTime timeout);\n@@ -117,1 +124,0 @@\n-  GstMiniObject * (*try_pull_object) (GstAppSink *appsink, GstClockTime timeout);\n@@ -119,0 +125,1 @@\n+  GstMiniObject * (*try_pull_object)    (GstAppSink *appsink, GstClockTime timeout);\n@@ -147,0 +154,12 @@\n+GST_APP_API\n+void            gst_app_sink_set_max_time (GstAppSink *appsink, GstClockTime max);\n+\n+GST_APP_API\n+GstClockTime    gst_app_sink_get_max_time (GstAppSink *appsink);\n+\n+GST_APP_API\n+void            gst_app_sink_set_max_bytes (GstAppSink *appsink, guint64 max);\n+\n+GST_APP_API\n+guint64         gst_app_sink_get_max_bytes (GstAppSink *appsink);\n+\n@@ -194,1 +213,0 @@\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/app\/gstappsink.h","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,250 @@\n+\/* GStreamer\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+#include \"gstapputils.h\"\n+\n+void\n+gst_queue_status_info_reset (GstQueueStatusInfo * info)\n+{\n+  g_return_if_fail (info != NULL);\n+\n+  info->queued_bytes = 0;\n+  info->queued_buffers = 0;\n+  info->queued_time = 0;\n+  info->num_events = 0;\n+  info->last_in_running_time = GST_CLOCK_TIME_NONE;\n+  info->last_out_running_time = GST_CLOCK_TIME_NONE;\n+}\n+\n+gboolean\n+gst_queue_status_info_is_full (const GstQueueStatusInfo * info,\n+    guint64 max_buffers, guint64 max_bytes, GstClockTime max_time)\n+{\n+  g_return_val_if_fail (info != NULL, FALSE);\n+\n+  return (max_buffers > 0 && info->queued_buffers >= max_buffers)\n+      || (max_bytes > 0 && info->queued_bytes >= max_bytes)\n+      || (max_time > 0 && info->queued_time >= max_time);\n+}\n+\n+void\n+gst_queue_status_info_push_event (GstQueueStatusInfo * info)\n+{\n+  g_return_if_fail (info != NULL);\n+\n+  info->num_events++;\n+}\n+\n+\/* Update the currently queued bytes\/buffers\/time information for the item\n+ * that was just added to the queue.\n+ *\/\n+void\n+gst_queue_status_info_push (GstQueueStatusInfo * info, GstMiniObject * item,\n+    GstSegment * last_segment, GstObject * log_context)\n+{\n+  GstClockTime start_buffer_ts = GST_CLOCK_TIME_NONE;\n+  GstClockTime end_buffer_ts = GST_CLOCK_TIME_NONE;\n+  guint buf_size = 0;\n+  guint n_buffers = 0;\n+\n+  g_return_if_fail (info != NULL);\n+\n+  if (GST_IS_EVENT (item)) {\n+    info->num_events++;\n+    return;\n+  }\n+\n+  if (GST_IS_BUFFER (item)) {\n+    GstBuffer *buf = GST_BUFFER_CAST (item);\n+\n+    buf_size = gst_buffer_get_size (buf);\n+    n_buffers = 1;\n+\n+    start_buffer_ts = end_buffer_ts = GST_BUFFER_DTS_OR_PTS (buf);\n+    if (end_buffer_ts != GST_CLOCK_TIME_NONE\n+        && GST_BUFFER_DURATION_IS_VALID (buf))\n+      end_buffer_ts += GST_BUFFER_DURATION (buf);\n+  } else if (GST_IS_BUFFER_LIST (item)) {\n+    GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (item);\n+    guint i;\n+\n+    n_buffers = gst_buffer_list_length (buffer_list);\n+\n+    for (i = 0; i < n_buffers; i++) {\n+      GstBuffer *tmp = gst_buffer_list_get (buffer_list, i);\n+      GstClockTime ts = GST_BUFFER_DTS_OR_PTS (tmp);\n+\n+      buf_size += gst_buffer_get_size (tmp);\n+\n+      if (ts != GST_CLOCK_TIME_NONE) {\n+        if (start_buffer_ts == GST_CLOCK_TIME_NONE)\n+          start_buffer_ts = ts;\n+        end_buffer_ts = ts;\n+        if (GST_BUFFER_DURATION_IS_VALID (tmp))\n+          end_buffer_ts += GST_BUFFER_DURATION (tmp);\n+      }\n+    }\n+  }\n+\n+  info->queued_bytes += buf_size;\n+  info->queued_buffers += n_buffers;\n+\n+  \/* Update time level if working on a TIME segment *\/\n+  if (last_segment->format == GST_FORMAT_TIME\n+      && end_buffer_ts != GST_CLOCK_TIME_NONE) {\n+    \/* Clip to the last segment boundaries *\/\n+    if (last_segment->stop != -1 && end_buffer_ts > last_segment->stop)\n+      end_buffer_ts = last_segment->stop;\n+    else if (last_segment->start > end_buffer_ts)\n+      end_buffer_ts = last_segment->start;\n+\n+    info->last_in_running_time =\n+        gst_segment_to_running_time (last_segment, GST_FORMAT_TIME,\n+        end_buffer_ts);\n+\n+    \/* If this is the only buffer then we can directly update the queued time\n+     * here. This is especially useful if this was the first buffer because\n+     * otherwise we would have to wait until it is actually unqueued to know\n+     * the queued duration *\/\n+    if (info->queued_buffers == 1) {\n+      if (last_segment->stop != -1 && start_buffer_ts > last_segment->stop)\n+        start_buffer_ts = last_segment->stop;\n+      else if (last_segment->start > start_buffer_ts)\n+        start_buffer_ts = last_segment->start;\n+\n+      info->last_out_running_time =\n+          gst_segment_to_running_time (last_segment, GST_FORMAT_TIME,\n+          start_buffer_ts);\n+    }\n+\n+    GST_TRACE_OBJECT (log_context,\n+        \"Last in running time %\" GST_TIME_FORMAT \", last out running time %\"\n+        GST_TIME_FORMAT, GST_TIME_ARGS (info->last_in_running_time),\n+        GST_TIME_ARGS (info->last_out_running_time));\n+\n+    if (info->last_out_running_time != GST_CLOCK_TIME_NONE\n+        && info->last_in_running_time != GST_CLOCK_TIME_NONE) {\n+      if (info->last_out_running_time > info->last_in_running_time) {\n+        info->queued_time = 0;\n+      } else {\n+        info->queued_time =\n+            info->last_in_running_time - info->last_out_running_time;\n+      }\n+    }\n+  }\n+\n+  GST_DEBUG_OBJECT (log_context,\n+      \"Currently queued: %\" G_GUINT64_FORMAT \" bytes, %\" G_GUINT64_FORMAT\n+      \" buffers, %\" GST_TIME_FORMAT, info->queued_bytes, info->queued_buffers,\n+      GST_TIME_ARGS (info->queued_time));\n+}\n+\n+void\n+gst_queue_status_info_pop (GstQueueStatusInfo * info, GstMiniObject * item,\n+    GstSegment * current_segment, GstSegment * last_segment,\n+    GstObject * log_context)\n+{\n+  guint buf_size = 0;\n+  guint n_buffers = 0;\n+  GstClockTime end_buffer_ts = GST_CLOCK_TIME_NONE;\n+\n+  g_return_if_fail (info != NULL);\n+\n+  if (GST_IS_EVENT (item)) {\n+    info->num_events--;\n+    return;\n+  }\n+\n+  if (GST_IS_BUFFER (item)) {\n+    GstBuffer *buf = GST_BUFFER_CAST (item);\n+    buf_size = gst_buffer_get_size (buf);\n+    n_buffers = 1;\n+\n+    end_buffer_ts = GST_BUFFER_DTS_OR_PTS (buf);\n+    if (end_buffer_ts != GST_CLOCK_TIME_NONE\n+        && GST_BUFFER_DURATION_IS_VALID (buf))\n+      end_buffer_ts += GST_BUFFER_DURATION (buf);\n+\n+    GST_LOG_OBJECT (log_context, \"have buffer %p of size %u\", buf, buf_size);\n+  } else if (GST_IS_BUFFER_LIST (item)) {\n+    GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (item);\n+    guint i;\n+\n+    n_buffers = gst_buffer_list_length (buffer_list);\n+\n+    for (i = 0; i < n_buffers; i++) {\n+      GstBuffer *tmp = gst_buffer_list_get (buffer_list, i);\n+      GstClockTime ts = GST_BUFFER_DTS_OR_PTS (tmp);\n+\n+      buf_size += gst_buffer_get_size (tmp);\n+      \/* Update to the last buffer's timestamp that is known *\/\n+      if (ts != GST_CLOCK_TIME_NONE) {\n+        end_buffer_ts = ts;\n+        if (GST_BUFFER_DURATION_IS_VALID (tmp))\n+          end_buffer_ts += GST_BUFFER_DURATION (tmp);\n+      }\n+    }\n+  }\n+\n+  info->queued_bytes -= buf_size;\n+  info->queued_buffers -= n_buffers;\n+\n+  \/* Update time level if working on a TIME segment *\/\n+  if ((current_segment->format == GST_FORMAT_TIME\n+          || (current_segment->format == GST_FORMAT_UNDEFINED\n+              && last_segment->format == GST_FORMAT_TIME))\n+      && end_buffer_ts != GST_CLOCK_TIME_NONE) {\n+    const GstSegment *segment =\n+        current_segment->format ==\n+        GST_FORMAT_TIME ? current_segment : last_segment;\n+\n+    \/* Clip to the current segment boundaries *\/\n+    if (segment->stop != -1 && end_buffer_ts > segment->stop)\n+      end_buffer_ts = segment->stop;\n+    else if (segment->start > end_buffer_ts)\n+      end_buffer_ts = segment->start;\n+\n+    info->last_out_running_time =\n+        gst_segment_to_running_time (segment, GST_FORMAT_TIME, end_buffer_ts);\n+\n+    GST_TRACE_OBJECT (log_context,\n+        \"Last in running time %\" GST_TIME_FORMAT \", last out running time %\"\n+        GST_TIME_FORMAT, GST_TIME_ARGS (info->last_in_running_time),\n+        GST_TIME_ARGS (info->last_out_running_time));\n+\n+    \/* If timestamps on both sides are known, calculate the current\n+     * fill level in time and consider the queue empty if the output\n+     * running time is lower than the input one (i.e. some kind of reset\n+     * has happened).\n+     *\/\n+    if (info->last_out_running_time != GST_CLOCK_TIME_NONE\n+        && info->last_in_running_time != GST_CLOCK_TIME_NONE) {\n+      if (info->last_out_running_time > info->last_in_running_time) {\n+        info->queued_time = 0;\n+      } else {\n+        info->queued_time =\n+            info->last_in_running_time - info->last_out_running_time;\n+      }\n+    }\n+  }\n+\n+  GST_DEBUG_OBJECT (log_context,\n+      \"Currently queued: %\" G_GUINT64_FORMAT \" bytes, %\" G_GUINT64_FORMAT\n+      \" buffers, %\" GST_TIME_FORMAT, info->queued_bytes,\n+      info->queued_buffers, GST_TIME_ARGS (info->queued_time));\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/app\/gstapputils.c","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/* GStreamer\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+#ifndef _GST_APP_UTILS_H_\n+#define _GST_APP_UTILS_H_\n+\n+#include <gst\/gst.h>\n+\n+typedef struct _GstQueueStatusInfo\n+{\n+  guint64 queued_bytes, queued_buffers;\n+  \/* Used to calculate the current time level *\/\n+  GstClockTime last_in_running_time, last_out_running_time;\n+  \/* Updated based on the above whenever they change *\/\n+  GstClockTime queued_time;\n+  guint num_events;\n+} GstQueueStatusInfo;\n+\n+void gst_queue_status_info_reset (GstQueueStatusInfo * info);\n+\n+gboolean gst_queue_status_info_is_full (const GstQueueStatusInfo * info,\n+    guint64 max_buffers, guint64 max_bytes, GstClockTime max_time);\n+\n+void gst_queue_status_info_push (GstQueueStatusInfo * info,\n+    GstMiniObject * item, GstSegment * last_segment, GstObject * log_context);\n+\n+void gst_queue_status_info_push_event (GstQueueStatusInfo * info);\n+\n+void gst_queue_status_info_pop (GstQueueStatusInfo * info, GstMiniObject * item,\n+    GstSegment * current_segment, GstSegment * last_segment,\n+    GstObject * log_context);\n+\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/app\/gstapputils.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-    g_slice_free1 (buffer->n_planes * sizeof (gpointer), buffer->planes);\n+    g_free (buffer->planes);\n@@ -42,1 +42,1 @@\n-    g_slice_free1 (buffer->n_planes * sizeof (GstMapInfo), buffer->map_infos);\n+    g_free (buffer->map_infos);\n@@ -153,3 +153,2 @@\n-      buffer->planes = g_slice_alloc (buffer->n_planes * sizeof (gpointer));\n-      buffer->map_infos =\n-          g_slice_alloc (buffer->n_planes * sizeof (GstMapInfo));\n+      buffer->planes = g_new (gpointer, buffer->n_planes);\n+      buffer->map_infos = g_new (GstMapInfo, buffer->n_planes);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-buffer.c","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  g_slice_free (GstAudioChannelMixer, mix);\n+  g_free (mix);\n@@ -149,2 +149,2 @@\n-    { {\n-    GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+    {{\n+                GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n@@ -152,4 +152,4 @@\n-    GST_AUDIO_CHANNEL_POSITION_MONO}},\n-        \/* front center: 2 <-> 1 *\/\n-    { {\n-    GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+            GST_AUDIO_CHANNEL_POSITION_MONO}},\n+    \/* front center: 2 <-> 1 *\/\n+    {{\n+                GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n@@ -157,4 +157,4 @@\n-    GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER}},\n-        \/* rear: 2 <-> 1 *\/\n-    { {\n-    GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+            GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER}},\n+    \/* rear: 2 <-> 1 *\/\n+    {{\n+                GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n@@ -162,2 +162,2 @@\n-    GST_AUDIO_CHANNEL_POSITION_REAR_CENTER}}, { {\n-    GST_AUDIO_CHANNEL_POSITION_INVALID}}\n+            GST_AUDIO_CHANNEL_POSITION_REAR_CENTER}}, {{\n+            GST_AUDIO_CHANNEL_POSITION_INVALID}}\n@@ -836,2 +836,0 @@\n-  g_return_val_if_fail (in_channels > 0 && in_channels <= 64, NULL);\n-  g_return_val_if_fail (out_channels > 0 && out_channels <= 64, NULL);\n@@ -839,1 +837,1 @@\n-  mix = g_slice_new0 (GstAudioChannelMixer);\n+  mix = g_new0 (GstAudioChannelMixer, 1);\n@@ -998,2 +996,0 @@\n-  g_return_val_if_fail (in_channels > 0 && in_channels <= 64, NULL);\n-  g_return_val_if_fail (out_channels > 0 && out_channels <= 64, NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-channel-mixer.c","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -225,1 +225,0 @@\n-  g_return_val_if_fail (channels <= 64, FALSE);\n@@ -233,0 +232,2 @@\n+  g_return_val_if_fail (channels <= 64, FALSE);\n+\n@@ -457,0 +458,1 @@\n+  g_return_val_if_fail (channels <= 64, FALSE);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-channels.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  chain = g_slice_new0 (AudioChain);\n+  chain = g_new0 (AudioChain, 1);\n@@ -232,1 +232,1 @@\n-  g_slice_free (AudioChain, chain);\n+  g_free (chain);\n@@ -1350,1 +1350,1 @@\n-  convert = g_slice_new0 (GstAudioConverter);\n+  convert = g_new0 (GstAudioConverter, 1);\n@@ -1484,1 +1484,1 @@\n-  g_slice_free (GstAudioConverter, convert);\n+  g_free (convert);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-converter.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+#ifdef GSTREAMER_LITE\n+#include \"gst\/glib-compat-private.h\"\n+#endif \/\/ GSTREAMER_LITE\n+\n@@ -64,1 +68,1 @@\n-  return g_slice_dup (GstAudioInfo, info);\n+  return g_memdup2 (info, sizeof (GstAudioInfo));\n@@ -77,1 +81,1 @@\n-  g_slice_free (GstAudioInfo, info);\n+  g_free (info);\n@@ -96,1 +100,1 @@\n-  info = g_slice_new (GstAudioInfo);\n+  info = g_new (GstAudioInfo, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-info.c","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-  quant = g_slice_new0 (GstAudioQuantize);\n+  quant = g_new0 (GstAudioQuantize, 1);\n@@ -493,1 +493,1 @@\n-  g_slice_free (GstAudioQuantize, quant);\n+  g_free (quant);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-quantize.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-    GST_WARNING (\"can't find exact taps\");                              \\\n+    GST_DEBUG (\"can't find exact taps\");                                \\\n@@ -1369,1 +1369,1 @@\n-  resampler = g_slice_new0 (GstAudioResampler);\n+  resampler = g_new0 (GstAudioResampler, 1);\n@@ -1637,1 +1637,1 @@\n-  g_slice_free (GstAudioResampler, resampler);\n+  g_free (resampler);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-resampler.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include <gst\/audio\/gstdsd.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1736,0 +1736,1 @@\n+#define ABSDIFF(a, b) ((a) > (b) ? (a) - (b) : (b) - (a))\n@@ -1772,0 +1773,3 @@\n+      GstClockTime expected_time = gst_util_uint64_scale_int (sink->next_sample,\n+          GST_SECOND, rate);\n+\n@@ -1773,3 +1777,6 @@\n-        \/* discont candidate *\/\n-        sink->priv->discont_time = time;\n-      } else if (time - sink->priv->discont_time >= sink->priv->discont_wait) {\n+        if (ABSDIFF (expected_time, time) >= sink->priv->discont_wait)\n+          discont = TRUE;\n+        else\n+          sink->priv->discont_time = expected_time;\n+      } else if (ABSDIFF (time,\n+              sink->priv->discont_time) >= sink->priv->discont_wait) {\n@@ -1813,0 +1820,2 @@\n+#undef ABSDIFF\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiobasesink.c","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -48,4 +48,0 @@\n-\/* This function is public in >= 1.23, but internal in 1.22 *\/\n-G_GNUC_INTERNAL\n-    void __gst_audio_ring_buffer_set_errored (GstAudioRingBuffer * buf);\n-\n@@ -1236,1 +1232,1 @@\n-    __gst_audio_ring_buffer_set_errored (ringbuffer);\n+    gst_audio_ring_buffer_set_errored (ringbuffer);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiobasesrc.c","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -960,1 +960,1 @@\n-  dec->priv->agg = ! !res;\n+  dec->priv->agg = !!res;\n@@ -1426,1 +1426,4 @@\n-  if (G_LIKELY (priv->frames.length))\n+  if (G_LIKELY (buf))\n+    buf = gst_buffer_make_writable (buf);\n+\n+  if (G_LIKELY (priv->frames.length)) {\n@@ -1428,1 +1431,12 @@\n-  else\n+    if (G_LIKELY (buf)) {\n+      \/* propagate RESYNC flag to output buffer *\/\n+      if (GST_BUFFER_FLAG_IS_SET (priv->frames.head->data,\n+              GST_BUFFER_FLAG_RESYNC))\n+        GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_RESYNC);\n+      if (is_subframe) {\n+        priv->frames.head->data =\n+            gst_buffer_make_writable (priv->frames.head->data);\n+        GST_BUFFER_FLAG_UNSET (priv->frames.head->data, GST_BUFFER_FLAG_RESYNC);\n+      }\n+    }\n+  } else\n@@ -1480,1 +1494,2 @@\n-              diff > (gint64) dec->priv->tolerance)) {\n+              diff > (gint64) dec->priv->tolerance ||\n+              GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_RESYNC))) {\n@@ -1504,1 +1519,0 @@\n-  buf = gst_buffer_make_writable (buf);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiodecoder.c","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1157,6 +1157,3 @@\n-      const guint8 *data;\n-\n-      data = gst_adapter_map (priv->adapter, priv->offset + need);\n-      buf =\n-          gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY,\n-          (gpointer) data, priv->offset + need, priv->offset, need, NULL, NULL);\n+      buf = gst_adapter_get_buffer (priv->adapter, priv->offset + need);\n+      buf = gst_buffer_make_writable (buf);\n+      gst_buffer_resize (buf, priv->offset, -1);\n@@ -1189,1 +1186,0 @@\n-      gst_adapter_unmap (priv->adapter);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudioencoder.c","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-#include <string.h>\n-\n@@ -37,0 +35,3 @@\n+#include <string.h>\n+#include <gst\/base\/base.h>\n+\n@@ -330,1 +331,1 @@\n-    g_slice_free1 (ameta->info.channels * sizeof (gsize), ameta->offsets);\n+    g_free (ameta->offsets);\n@@ -354,0 +355,105 @@\n+static gboolean\n+gst_audio_meta_serialize (const GstMeta * meta, GstByteArrayInterface * data,\n+    guint8 * version)\n+{\n+  GstAudioMeta *ameta = (GstAudioMeta *) meta;\n+\n+  \/* Position is limited to 64 *\/\n+  gint n_position = ameta->info.channels > 64 ? 0 : ameta->info.channels;\n+\n+  gsize size = 28 + n_position * 4 + ameta->info.channels * 8;\n+  guint8 *ptr = gst_byte_array_interface_append (data, size);\n+  if (ptr == NULL)\n+    return FALSE;\n+\n+  GstByteWriter bw;\n+  gboolean success = TRUE;\n+  gst_byte_writer_init_with_data (&bw, ptr, size, FALSE);\n+  success &= gst_byte_writer_put_int32_le (&bw, ameta->info.finfo->format);\n+  success &= gst_byte_writer_put_int32_le (&bw, ameta->info.flags);\n+  success &= gst_byte_writer_put_int32_le (&bw, ameta->info.layout);\n+  success &= gst_byte_writer_put_int32_le (&bw, ameta->info.rate);\n+  success &= gst_byte_writer_put_int32_le (&bw, ameta->info.channels);\n+  for (int i = 0; i < n_position; i++)\n+    success &= gst_byte_writer_put_int32_le (&bw, ameta->info.position[i]);\n+  success &= gst_byte_writer_put_uint64_le (&bw, ameta->samples);\n+  for (int i = 0; i < ameta->info.channels; i++)\n+    success &= gst_byte_writer_put_uint64_le (&bw, ameta->offsets[i]);\n+  g_assert (success);\n+\n+  return TRUE;\n+}\n+\n+static GstMeta *\n+gst_audio_meta_deserialize (const GstMetaInfo * info, GstBuffer * buffer,\n+    const guint8 * data, gsize size, guint8 version)\n+{\n+  GstAudioMeta *ameta = NULL;\n+  gint32 format;\n+  gint32 flags;\n+  gint32 layout;\n+  gint32 rate;\n+  gint32 channels;\n+\n+  if (version != 0)\n+    return NULL;\n+\n+  GstByteReader br;\n+  gboolean success = TRUE;\n+  gst_byte_reader_init (&br, data, size);\n+  success &= gst_byte_reader_get_int32_le (&br, &format);\n+  success &= gst_byte_reader_get_int32_le (&br, &flags);\n+  success &= gst_byte_reader_get_int32_le (&br, &layout);\n+  success &= gst_byte_reader_get_int32_le (&br, &rate);\n+  success &= gst_byte_reader_get_int32_le (&br, &channels);\n+\n+  if (!success)\n+    return NULL;\n+\n+  \/* Position is limited to 64 *\/\n+  gint n_position = channels > 64 ? 0 : channels;\n+  gint32 *position = g_new (gint32, n_position);\n+  guint64 *offsets64 = g_new (guint64, channels);\n+  guint64 samples = 0;\n+\n+  for (int i = 0; i < n_position; i++)\n+    success &= gst_byte_reader_get_int32_le (&br, &position[i]);\n+  success &= gst_byte_reader_get_uint64_le (&br, &samples);\n+  for (int i = 0; i < channels; i++)\n+    success &= gst_byte_reader_get_uint64_le (&br, &offsets64[i]);\n+\n+  if (!success) {\n+    g_free (position);\n+    g_free (offsets64);\n+    return NULL;\n+  }\n+#if GLIB_SIZEOF_SIZE_T != 8\n+  gsize *offsets = g_new (gsize, channels);\n+  for (int i = 0; i < channels; i++) {\n+    if (offsets64[i] > G_MAXSIZE) {\n+      g_free (offsets64);\n+      g_free (offsets);\n+      g_free (position);\n+      return NULL;\n+    }\n+    offsets[i] = offsets64[i];\n+  }\n+  g_free (offsets64);\n+#else\n+  gsize *offsets = (gsize *) offsets64;\n+#endif\n+\n+  GstAudioInfo audio_info;\n+  gst_audio_info_set_format (&audio_info, format, rate, channels,\n+      (channels > 64) ? NULL : position);\n+  audio_info.flags = flags;\n+  audio_info.layout = layout;\n+\n+  ameta = gst_buffer_add_audio_meta (buffer, &audio_info, samples, offsets);\n+\n+  g_free (offsets);\n+  g_free (position);\n+\n+  return (GstMeta *) ameta;\n+}\n+\n@@ -416,1 +522,1 @@\n-      meta->offsets = g_slice_alloc (info->channels * sizeof (gsize));\n+      meta->offsets = g_new (gsize, info->channels);\n@@ -485,5 +591,10 @@\n-    const GstMetaInfo *meta = gst_meta_register (GST_AUDIO_META_API_TYPE,\n-        \"GstAudioMeta\", sizeof (GstAudioMeta),\n-        gst_audio_meta_init,\n-        gst_audio_meta_free,\n-        gst_audio_meta_transform);\n+    GstMetaInfo *info = gst_meta_info_new (GST_AUDIO_META_API_TYPE,\n+        \"GstAudioMeta\", sizeof (GstAudioMeta));\n+\n+    info->init_func = gst_audio_meta_init;\n+    info->free_func = gst_audio_meta_free;\n+    info->transform_func = gst_audio_meta_transform;\n+    info->serialize_func = gst_audio_meta_serialize;\n+    info->deserialize_func = gst_audio_meta_deserialize;\n+    const GstMetaInfo *meta = gst_meta_info_register (info);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiometa.c","additions":120,"deletions":9,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -173,0 +173,3 @@\n+ * Since 1.24 it can be serialized using gst_meta_serialize() and\n+ * gst_meta_deserialize().\n+ *\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiometa.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+#ifndef GSTREAMER_LITE\n+#include <gst\/audio\/gstdsd.h>\n+#endif \/\/ GSTREAMER_LITE\n@@ -316,0 +319,56 @@\n+#ifndef GSTREAMER_LITE\n+  } else if (g_str_equal (mimetype, GST_DSD_MEDIA_TYPE)) {\n+\n+    \/* Notes about what the \"rate\" means in DSD:\n+     *\n+     * In DSD, \"sample formats\" don't actually exist. There is only the DSD bit;\n+     * this is what could be considered the closest equivalent to a \"sample format\".\n+     * But since it is impractical to deal with individual bits in software, the\n+     * bits are typically grouped into words (8\/16\/32 bit words). These are the\n+     * DSDU8, DSDU16LE etc. \"grouping formats\".\n+     *\n+     * The \"rate\" in DSD information refers to the number of DSD _bytes_ per second\n+     * (not bits per second, because, as said, per-bit handling in software does\n+     * not usually make sense). The way the GstAudioRingBuffer works however requires\n+     * the rate to be interpreted as the number of DSD _words_ per minute. This is\n+     * in part because that's how ALSA uses the rate.\n+     *\n+     * If the word format is DSDU8, then there's no difference to just using the\n+     * original byte rate. But if for example it is DSDU16LE, then the ringbuffer's\n+     * rate needs to be half of the rate from GstDsdInfo. For this reason, it is\n+     * essential to divide the rate from the DSD info by the word length (in bytes).\n+     *\n+     * Furthermore, the BPF is set to the stride (= format width * num channels).\n+     * The GstAudioRingBuffer can only handle interleaved DSD. This means that\n+     * there is a \"stride\", that is, the DSD word of channel #1 is stored first,\n+     * followed by the DSD word of channel #2 etc. and then again we get a DSD\n+     * word from channel #1, and so forth. This is similar to how interleaved\n+     * PCM works. The stride is then the size (in bytes) of the DSD words for\n+     * each channel that are played at the same time. Using this as the BPF is\n+     * very important. Otherweise, timestamp and duration figures can be off,\n+     * the segment sizes may not be an integer multiple of the DSD stride, etc.\n+     *\/\n+\n+    GstDsdInfo dsd_info;\n+    guint format_width;\n+\n+    if (!gst_dsd_info_from_caps (&dsd_info, caps))\n+      goto parse_error;\n+\n+    format_width = gst_dsd_format_get_width (dsd_info.format);\n+\n+    info.rate = dsd_info.rate \/ format_width;\n+    info.channels = dsd_info.channels;\n+    info.bpf = format_width * dsd_info.channels;\n+\n+    GST_INFO (\"using DSD word rate %d instead of DSD byte rate %d \"\n+        \"for ringbuffer\", info.rate, dsd_info.rate);\n+\n+    memcpy (info.position, dsd_info.positions,\n+        sizeof (GstAudioChannelPosition) * dsd_info.channels);\n+\n+    GST_AUDIO_RING_BUFFER_SPEC_DSD_FORMAT (spec) =\n+        GST_DSD_INFO_FORMAT (&dsd_info);\n+\n+    spec->type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD;\n+#endif \/\/ GSTREAMER_LITE\n@@ -636,1 +695,1 @@\n-  buf->timestamps = g_slice_alloc0 (sizeof (GstClockTime) * spec->segtotal);\n+  buf->timestamps = g_new0 (GstClockTime, spec->segtotal);\n@@ -658,6 +717,13 @@\n-  if (buf->spec.type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW) {\n-    gst_audio_format_info_fill_silence (buf->spec.info.finfo, buf->empty_seg,\n-        segsize);\n-  } else {\n-    \/* FIXME, non-raw formats get 0 as the empty sample *\/\n-    memset (buf->empty_seg, 0, segsize);\n+  switch (buf->spec.type) {\n+    case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW:\n+      gst_audio_format_info_fill_silence (buf->spec.info.finfo, buf->empty_seg,\n+          segsize);\n+      break;\n+#ifndef GSTREAMER_LITE\n+    case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD:\n+      memset (buf->empty_seg, GST_DSD_SILENCE_PATTERN_BYTE, segsize);\n+      break;\n+#endif \/\/ GSTREAMER_LITE\n+    default:\n+      \/* FIXME, non-raw formats get 0 as the empty sample *\/\n+      memset (buf->empty_seg, 0, segsize);\n@@ -665,0 +731,1 @@\n+\n@@ -730,1 +797,1 @@\n-    g_slice_free1 (sizeof (GstClockTime) * buf->spec.segtotal, buf->timestamps);\n+    g_free (buf->timestamps);\n@@ -1039,4 +1106,2 @@\n-G_GNUC_INTERNAL\n-    void __gst_audio_ring_buffer_set_errored (GstAudioRingBuffer * buf);\n-\n-\/* __gst_audio_ring_buffer_set_errored:\n+\/**\n+ * gst_audio_ring_buffer_set_errored:\n@@ -1049,1 +1114,1 @@\n- * Since: 1.24 (internal in 1.22)\n+ * Since: 1.24\n@@ -1052,1 +1117,1 @@\n-__gst_audio_ring_buffer_set_errored (GstAudioRingBuffer * buf)\n+gst_audio_ring_buffer_set_errored (GstAudioRingBuffer * buf)\n@@ -2089,0 +2154,5 @@\n+  if (channels == 1) {\n+    GST_LOG_OBJECT (buf, \"single channel, no need to reorder\");\n+    return;\n+  }\n+\n@@ -2125,1 +2195,7 @@\n- * Set a new timestamp on the buffer.\n+ * Set a new timestamp on the buffer representing the time of the first sample\n+ * in the ringbuffer segment. The timestamp is used by the #GstAudioSrc base\n+ * class to set the timestamps on output buffers. Timestamps are\n+ * expected to be taken directly from the pipeline clock and are\n+ * actual clock timestamps. #GstAudioSrc will convert to running time\n+ * by subtracting the base time, but otherwise does not adjust the\n+ * outgoing timestamps if provided.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudioringbuffer.c","additions":91,"deletions":15,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+#ifndef GSTREAMER_LITE\n+#include <gst\/audio\/gstdsdformat.h>\n+#endif \/\/ GSTREAMER_LITE\n+\n@@ -91,0 +95,1 @@\n+ * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD: samples in DSD format (Since: 1.24)\n@@ -110,1 +115,2 @@\n-  GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC\n+  GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC,\n+  GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD\n@@ -124,0 +130,1 @@\n+ * @dsd_format: the #GstDsdFormat (Since: 1.24)\n@@ -126,0 +133,4 @@\n+ *\n+ * When @type is GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD, the @dsd_format\n+ * is valid (otherwise it is unused). Also, when DSD is the sample type,\n+ * only the rate, channels, position, and bpf fields in @info are populated.\n@@ -155,2 +166,11 @@\n-  \/*< private >*\/\n-  gpointer _gst_reserved[GST_PADDING];\n+#ifndef GSTREAMER_LITE\n+  \/* Union preserves padded struct size for backwards compat\n+   * Consumer code should use the accessor macros for fields *\/\n+  union {\n+    struct { \/* < skip > *\/\n+      GstDsdFormat  dsd_format;\n+    } abi;\n+    \/*< private >*\/\n+    gpointer _gst_reserved[GST_PADDING];\n+  } ABI;\n+#endif \/\/ GSTREAMER_LITE\n@@ -159,0 +179,11 @@\n+#define GST_AUDIO_RING_BUFFER_SPEC_FORMAT_TYPE(spec)   ((spec)->type)\n+#define GST_AUDIO_RING_BUFFER_SPEC_INFO(spec)          ((spec)->info)\n+#define GST_AUDIO_RING_BUFFER_SPEC_LATENCY_TIME(spec)  ((spec)->latency_time)\n+#define GST_AUDIO_RING_BUFFER_SPEC_BUFFER_TIME(spec)   ((spec)->buffer_time)\n+#define GST_AUDIO_RING_BUFFER_SPEC_SEGSIZE(spec)       ((spec)->segsize)\n+#define GST_AUDIO_RING_BUFFER_SPEC_SEGTOTAL(spec)      ((spec)->segtotal)\n+#define GST_AUDIO_RING_BUFFER_SPEC_SEGLATENCY(spec)    ((spec)->seglatency)\n+#ifndef GSTREAMER_LITE\n+#define GST_AUDIO_RING_BUFFER_SPEC_DSD_FORMAT(spec)    ((spec)->ABI.abi.dsd_format)\n+#endif \/\/ GSTREAMER_LITE\n+\n@@ -356,0 +387,3 @@\n+\n+GST_AUDIO_API\n+void            gst_audio_ring_buffer_set_errored     (GstAudioRingBuffer *buf);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudioringbuffer.h","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+#ifndef GSTREAMER_LITE\n+#include <gst\/audio\/gstdsd.h>\n+#endif \/\/ GSTREAMER_LITE\n@@ -432,6 +435,14 @@\n-  if (buf->spec.type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW) {\n-    gst_audio_format_info_fill_silence (buf->spec.info.finfo, buf->memory,\n-        buf->size);\n-  } else {\n-    \/* FIXME, non-raw formats get 0 as the empty sample *\/\n-    memset (buf->memory, 0, buf->size);\n+  switch (buf->spec.type) {\n+    case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW:\n+      gst_audio_format_info_fill_silence (buf->spec.info.finfo, buf->memory,\n+          buf->size);\n+      break;\n+#ifndef GSTREAMER_LITE\n+    case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD:\n+      memset (buf->memory, GST_DSD_SILENCE_PATTERN_BYTE, buf->size);\n+      break;\n+#endif \/\/ GSTREAMER_LITE\n+    default:\n+      \/* FIXME, non-raw formats get 0 as the empty sample *\/\n+      memset (buf->memory, 0, buf->size);\n+      break;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiosink.c","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-kiss_fft_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)\n+kiss_fft_f32_alloc (int nfft, int inverse_fft, void *mem, size_t *lenmem)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/fft\/kiss_fft_f32.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-kiss_fftr_f32_alloc (int nfft, int inverse_fft, void *mem, size_t * lenmem)\n+kiss_fftr_f32_alloc (int nfft, int inverse_fft, void *mem, size_t *lenmem)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/fft\/kiss_fftr_f32.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2475,1 +2475,2 @@\n-  guint8 profile = -1, chroma_format = -1, level = -1;\n+  guint8 profile = -1, chroma_format = -1, level = -1, color_primaries =\n+      -1, color_transfer = -1, color_matrix = -1;\n@@ -2543,5 +2544,10 @@\n-  \/* optional but all or nothing *\/\n-  g_string_append_printf (codec_string, \".%02u.%02u.%02u.%02u.%02u\",\n-      chroma_format, gst_video_color_primaries_to_iso (cinfo.primaries),\n-      gst_video_transfer_function_to_iso (cinfo.transfer),\n-      gst_video_color_matrix_to_iso (cinfo.matrix), video_full_range);\n+  \/* optional but all or nothing. Include them if any parameter differs from the default value *\/\n+  color_primaries = gst_video_color_primaries_to_iso (cinfo.primaries);\n+  color_transfer = gst_video_transfer_function_to_iso (cinfo.transfer);\n+  color_matrix = gst_video_color_matrix_to_iso (cinfo.matrix);\n+  if (chroma_format != 1 || color_primaries != 1 || color_transfer != 1\n+      || color_matrix != 1 || video_full_range) {\n+    g_string_append_printf (codec_string, \".%02u.%02u.%02u.%02u.%02u\",\n+        chroma_format, color_primaries, color_transfer, color_matrix,\n+        video_full_range);\n+  }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/codec-utils.c","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  {\"video\/x-ivf\", \"Indeo video format (IVF)\", AVIS_CONTAINER, \"ivf\"},\n@@ -156,0 +157,1 @@\n+  {\"audio\/x-ffmpeg-parsed-musepack\", \"Musepack (MPC)\", FLAG_AUDIO, \"mpc\"},\n@@ -207,0 +209,1 @@\n+  {\"video\/x-ffvhuff\", \"FFmpeg Huffman YUV variant\", FLAG_VIDEO, \"\"},\n@@ -769,8 +772,10 @@\n-        gst_structure_get_int (s, \"layer\", &layer);\n-        switch (layer) {\n-          case 1:\n-          case 2:\n-          case 3:\n-            return g_strdup_printf (\"MPEG-1 Layer %d (MP%d)\", layer, layer);\n-          default:\n-            break;\n+        if (gst_structure_get_int (s, \"layer\", &layer)) {\n+          switch (layer) {\n+            case 1:\n+            case 2:\n+            case 3:\n+              return g_strdup_printf (\"MPEG-1 Layer %d (MP%d)\", layer, layer);\n+            default:\n+              break;\n+          }\n+          GST_WARNING (\"Unexpected MPEG-1 layer in %\" GST_PTR_FORMAT, caps);\n@@ -778,1 +783,0 @@\n-        GST_WARNING (\"Unexpected MPEG-1 layer in %\" GST_PTR_FORMAT, caps);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/descriptions.c","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1053,1 +1053,1 @@\n-  GstBuffer *inbuf;\n+  GstBuffer *inbuf, *databuf;\n@@ -1056,1 +1056,0 @@\n-  gpointer adata;\n@@ -1168,1 +1167,1 @@\n-    if (!(adata = (gpointer) gst_adapter_map (scope->priv->adapter, sbpf)))\n+    if (!(databuf = gst_adapter_get_buffer (scope->priv->adapter, sbpf)))\n@@ -1185,3 +1184,3 @@\n-    gst_buffer_replace_all_memory (inbuf,\n-        gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY, adata, sbpf, 0,\n-            sbpf, NULL, NULL));\n+    gst_buffer_remove_all_memory (inbuf);\n+    gst_buffer_copy_into (inbuf, databuf, GST_BUFFER_COPY_MEMORY, 0, sbpf);\n+    gst_buffer_unref (databuf);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstaudiovisualizer.c","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -696,1 +696,1 @@\n- * Returns: (transfer none): the stream ID of this stream. If you wish to\n+ * Returns: (transfer none) (nullable): the stream ID of this stream. If you wish to\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer-types.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+  SIGNAL_LOAD_SERIALIZED_INFO,\n@@ -218,0 +219,17 @@\n+static GstDiscovererInfo *load_serialized_info (GstDiscoverer * dc,\n+    gchar * uri);\n+\n+static gboolean\n+_gst_discoverer_info_accumulator (GSignalInvocationHint * ihint,\n+    GValue * return_accu, const GValue * handler_return, gpointer dummy)\n+{\n+  GstDiscovererInfo *info;\n+\n+  info = g_value_get_object (handler_return);\n+  GST_DEBUG (\"got discoverer info %\" GST_PTR_FORMAT, info);\n+\n+  g_value_set_object (return_accu, info);\n+\n+  \/* stop emission if we have a discoverer info *\/\n+  return (info == NULL);\n+}\n@@ -230,0 +248,2 @@\n+  klass->load_serialize_info = load_serialized_info;\n+\n@@ -326,0 +346,20 @@\n+\n+  \/**\n+   * GstDiscoverer::load-serialized-info:\n+   * @discoverer: the #GstDiscoverer\n+   * @uri: THe URI to load the serialized info for\n+   *\n+   * Retrieves information about a URI from and external source of information,\n+   * like a cache file. This is used by the discoverer to speed up the\n+   * discovery.\n+   *\n+   * Returns: (nullable) (transfer full): The #GstDiscovererInfo representing\n+   * @uri, or %NULL if no information\n+   *\n+   * Since: 1.24\n+   *\/\n+  gst_discoverer_signals[SIGNAL_LOAD_SERIALIZED_INFO] =\n+      g_signal_new (\"load-serialized-info\", G_TYPE_FROM_CLASS (klass),\n+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstDiscovererClass,\n+          load_serialize_info), _gst_discoverer_info_accumulator, NULL, NULL,\n+      GST_TYPE_DISCOVERER_INFO, 1, G_TYPE_STRING);\n@@ -647,1 +687,1 @@\n-  ps = g_slice_new0 (PrivateStream);\n+  ps = g_new0 (PrivateStream, 1);\n@@ -725,1 +765,1 @@\n-  g_slice_free (PrivateStream, ps);\n+  g_free (ps);\n@@ -791,1 +831,1 @@\n-  g_slice_free (PrivateStream, ps);\n+  g_free (ps);\n@@ -1326,1 +1366,2 @@\n-      handle_current_async (dc);\n+      if (dc->priv->processing)\n+        handle_current_async (dc);\n@@ -1828,0 +1869,2 @@\n+    } else {\n+      g_free (cachefile);\n@@ -1834,0 +1877,2 @@\n+  } else {\n+    g_free (cachefile);\n@@ -1839,0 +1884,16 @@\n+static GstDiscovererInfo *\n+load_serialized_info (GstDiscoverer * dc, gchar * uri)\n+{\n+  GstDiscovererInfo *res = NULL;\n+\n+  if (dc->priv->use_cache) {\n+    gchar *cachefile = _serialized_info_get_path (dc, uri);\n+\n+    if (cachefile) {\n+      res = _get_info_from_cachefile (dc, cachefile);\n+    }\n+  }\n+\n+  return res;\n+}\n+\n@@ -1844,1 +1905,0 @@\n-  gchar *cachefile = NULL;\n@@ -1849,4 +1909,0 @@\n-  if (dc->priv->use_cache) {\n-    cachefile = _serialized_info_get_path (dc, uri);\n-    if (cachefile)\n-      dc->priv->current_info = _get_info_from_cachefile (dc, cachefile);\n@@ -1854,4 +1910,1 @@\n-    if (dc->priv->current_info) {\n-      \/* Make sure the URI is exactly what the user passed in *\/\n-      g_free (dc->priv->current_info->uri);\n-      dc->priv->current_info->uri = uri;\n+  GST_DEBUG (\"Setting up\");\n@@ -1859,3 +1912,6 @@\n-      dc->priv->current_info->cachefile = cachefile;\n-      dc->priv->processing = FALSE;\n-      dc->priv->target_state = GST_STATE_NULL;\n+  g_signal_emit (dc, gst_discoverer_signals[SIGNAL_LOAD_SERIALIZED_INFO], 0,\n+      uri, &dc->priv->current_info);\n+  if (dc->priv->current_info) {\n+    \/* Make sure the URI is exactly what the user passed in *\/\n+    g_free (dc->priv->current_info->uri);\n+    dc->priv->current_info->uri = uri;\n@@ -1863,3 +1919,2 @@\n-      return TRUE;\n-    }\n-  }\n+    dc->priv->processing = FALSE;\n+    dc->priv->target_state = GST_STATE_NULL;\n@@ -1867,1 +1922,2 @@\n-  GST_DEBUG (\"Setting up\");\n+    return TRUE;\n+  }\n@@ -1872,1 +1928,2 @@\n-  dc->priv->current_info->cachefile = cachefile;\n+  if (dc->priv->use_cache)\n+    dc->priv->current_info->cachefile = _serialized_info_get_path (dc, uri);\n@@ -2042,2 +2099,2 @@\n-\n-    handle_current_async (dc);\n+    if (dc->priv->processing)\n+      handle_current_async (dc);\n@@ -2190,5 +2247,8 @@\n-    nextv = gst_discoverer_info_to_variant_recurse (ninfo, flags);\n-\n-    stream_variant =\n-        g_variant_new (\"(yvv)\", 'n', common_stream_variant,\n-        g_variant_new (\"v\", nextv));\n+    if (ninfo) {\n+      nextv = gst_discoverer_info_to_variant_recurse (ninfo, flags);\n+      stream_variant =\n+          g_variant_new (\"(yvv)\", 'n', common_stream_variant,\n+          g_variant_new (\"v\", nextv));\n+    } else {\n+      stream_variant = g_variant_new (\"(yv)\", 'n', common_stream_variant);\n+    }\n@@ -2335,1 +2395,1 @@\n-  GVariant *specific = g_variant_get_child_value (variant, 2);\n+  GVariant *specific = NULL;\n@@ -2338,0 +2398,3 @@\n+  if (g_variant_n_children (variant) > 2)\n+    specific = g_variant_get_child_value (variant, 2);\n+\n@@ -2399,1 +2462,2 @@\n-  g_variant_unref (specific);\n+  if (specific)\n+    g_variant_unref (specific);\n@@ -2665,1 +2729,3 @@\n-      GST_DISCOVERER_OK, NULL);\n+      GST_DISCOVERER_OK\n+      || gst_discoverer_info_get_result (info) ==\n+      GST_DISCOVERER_MISSING_PLUGINS, NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer.c","additions":97,"deletions":31,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -389,2 +389,16 @@\n-\n-  gpointer _reserved[GST_PADDING];\n+  \/**\n+   * GstDiscovererClass::load_serialize_info:\n+   * @dc: the #GstDiscoverer\n+   * @uri: the uri to load the info from\n+   *\n+   * Loads the serialized info from the given uri.\n+   *\n+   * Returns: (transfer full): the #GstDiscovererInfo or %NULL if it could not be loaded\n+   *\n+   * Since: 1.24\n+   *\/\n+  GstDiscovererInfo *\n+  (*load_serialize_info)          (GstDiscoverer *dc,\n+                                   gchar *uri);\n+\n+  gpointer _reserved[GST_PADDING - 1];\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer.h","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -124,5 +124,5 @@\n-  GST_MISSING_TYPE_URISOURCE, \"urisource\"}, {\n-  GST_MISSING_TYPE_URISINK, \"urisink\"}, {\n-  GST_MISSING_TYPE_ELEMENT, \"element\"}, {\n-  GST_MISSING_TYPE_DECODER, \"decoder\"}, {\n-  GST_MISSING_TYPE_ENCODER, \"encoder\"}\n+      GST_MISSING_TYPE_URISOURCE, \"urisource\"}, {\n+      GST_MISSING_TYPE_URISINK, \"urisink\"}, {\n+      GST_MISSING_TYPE_ELEMENT, \"element\"}, {\n+      GST_MISSING_TYPE_DECODER, \"decoder\"}, {\n+      GST_MISSING_TYPE_ENCODER, \"encoder\"}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/missing-plugins.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -259,0 +259,10 @@\n+    case GST_MAKE_FOURCC ('F', 'F', 'V', 'H'):\n+      caps = gst_caps_new_empty_simple (\"video\/x-ffvhuff\");\n+      if (strf) {\n+        gst_caps_set_simple (caps, \"bpp\",\n+            G_TYPE_INT, (int) strf->bit_cnt, NULL);\n+      }\n+      if (codec_name)\n+        *codec_name = g_strdup (\"FFmpeg Huffman YUV variant\");\n+      break;\n+\n@@ -374,0 +384,4 @@\n+    case GST_MAKE_FOURCC ('h', 'e', 'v', 'c'):\n+    case GST_MAKE_FOURCC ('H', 'E', 'V', 'C'):\n+    case GST_MAKE_FOURCC ('h', 'e', 'v', '1'):\n+    case GST_MAKE_FOURCC ('H', 'E', 'V', '1'):\n@@ -1041,18 +1055,18 @@\n-  0x00001, GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT}, {\n-  0x00002, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT}, {\n-  0x00004, GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER}, {\n-  0x00008, GST_AUDIO_CHANNEL_POSITION_LFE1}, {\n-  0x00010, GST_AUDIO_CHANNEL_POSITION_REAR_LEFT}, {\n-  0x00020, GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT}, {\n-  0x00040, GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER}, {\n-  0x00080, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER}, {\n-  0x00100, GST_AUDIO_CHANNEL_POSITION_REAR_CENTER}, {\n-  0x00200, GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT}, {\n-  0x00400, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT}, {\n-  0x00800, GST_AUDIO_CHANNEL_POSITION_TOP_CENTER}, {\n-  0x01000, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT}, {\n-  0x02000, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER}, {\n-  0x04000, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT}, {\n-  0x08000, GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT}, {\n-  0x10000, GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER}, {\n-  0x20000, GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT}\n+      0x00001, GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT}, {\n+      0x00002, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT}, {\n+      0x00004, GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER}, {\n+      0x00008, GST_AUDIO_CHANNEL_POSITION_LFE1}, {\n+      0x00010, GST_AUDIO_CHANNEL_POSITION_REAR_LEFT}, {\n+      0x00020, GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT}, {\n+      0x00040, GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER}, {\n+      0x00080, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER}, {\n+      0x00100, GST_AUDIO_CHANNEL_POSITION_REAR_CENTER}, {\n+      0x00200, GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT}, {\n+      0x00400, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT}, {\n+      0x00800, GST_AUDIO_CHANNEL_POSITION_TOP_CENTER}, {\n+      0x01000, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT}, {\n+      0x02000, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER}, {\n+      0x04000, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT}, {\n+      0x08000, GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT}, {\n+      0x10000, GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER}, {\n+      0x20000, GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/riff\/riff-media.c","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -895,1 +895,1 @@\n-  flush = ! !(flags & GST_SEEK_FLAG_FLUSH);\n+  flush = !!(flags & GST_SEEK_FLAG_FLUSH);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/gsttagdemux.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,3 +316,3 @@\n-  \"TORY\", \"TDOR\"}, {\n-  \"TYER\", \"TDRC\"},\n-      \/* 2.2.x frames *\/\n+      \"TORY\", \"TDOR\"}, {\n+      \"TYER\", \"TDRC\"},\n+  \/* 2.2.x frames *\/\n@@ -320,57 +320,57 @@\n-  \"BUF\", \"RBUF\"}, {\n-  \"CNT\", \"PCNT\"}, {\n-  \"COM\", \"COMM\"}, {\n-  \"CRA\", \"AENC\"}, {\n-  \"ETC\", \"ETCO\"}, {\n-  \"GEO\", \"GEOB\"}, {\n-  \"IPL\", \"TIPL\"}, {\n-  \"MCI\", \"MCDI\"}, {\n-  \"MLL\", \"MLLT\"}, {\n-  \"PIC\", \"APIC\"}, {\n-  \"POP\", \"POPM\"}, {\n-  \"REV\", \"RVRB\"}, {\n-  \"SLT\", \"SYLT\"}, {\n-  \"STC\", \"SYTC\"}, {\n-  \"TAL\", \"TALB\"}, {\n-  \"TBP\", \"TBPM\"}, {\n-  \"TCM\", \"TCOM\"}, {\n-  \"TCO\", \"TCON\"}, {\n-  \"TCR\", \"TCOP\"}, {\n-  \"TDA\", \"TDAT\"}, {             \/* obsolete, but we need to parse it anyway *\/\n-  \"TDY\", \"TDLY\"}, {\n-  \"TEN\", \"TENC\"}, {\n-  \"TFT\", \"TFLT\"}, {\n-  \"TKE\", \"TKEY\"}, {\n-  \"TLA\", \"TLAN\"}, {\n-  \"TLE\", \"TLEN\"}, {\n-  \"TMT\", \"TMED\"}, {\n-  \"TOA\", \"TOAL\"}, {\n-  \"TOF\", \"TOFN\"}, {\n-  \"TOL\", \"TOLY\"}, {\n-  \"TOR\", \"TDOR\"}, {\n-  \"TOT\", \"TOAL\"}, {\n-  \"TP1\", \"TPE1\"}, {\n-  \"TP2\", \"TPE2\"}, {\n-  \"TP3\", \"TPE3\"}, {\n-  \"TP4\", \"TPE4\"}, {\n-  \"TPA\", \"TPOS\"}, {\n-  \"TPB\", \"TPUB\"}, {\n-  \"TRC\", \"TSRC\"}, {\n-  \"TRD\", \"TDRC\"}, {\n-  \"TRK\", \"TRCK\"}, {\n-  \"TSS\", \"TSSE\"}, {\n-  \"TT1\", \"TIT1\"}, {\n-  \"TT2\", \"TIT2\"}, {\n-  \"TT3\", \"TIT3\"}, {\n-  \"TXT\", \"TOLY\"}, {\n-  \"TXX\", \"TXXX\"}, {\n-  \"TYE\", \"TDRC\"}, {\n-  \"UFI\", \"UFID\"}, {\n-  \"ULT\", \"USLT\"}, {\n-  \"WAF\", \"WOAF\"}, {\n-  \"WAR\", \"WOAR\"}, {\n-  \"WAS\", \"WOAS\"}, {\n-  \"WCM\", \"WCOM\"}, {\n-  \"WCP\", \"WCOP\"}, {\n-  \"WPB\", \"WPUB\"}, {\n-  \"WXX\", \"WXXX\"}\n+      \"BUF\", \"RBUF\"}, {\n+      \"CNT\", \"PCNT\"}, {\n+      \"COM\", \"COMM\"}, {\n+      \"CRA\", \"AENC\"}, {\n+      \"ETC\", \"ETCO\"}, {\n+      \"GEO\", \"GEOB\"}, {\n+      \"IPL\", \"TIPL\"}, {\n+      \"MCI\", \"MCDI\"}, {\n+      \"MLL\", \"MLLT\"}, {\n+      \"PIC\", \"APIC\"}, {\n+      \"POP\", \"POPM\"}, {\n+      \"REV\", \"RVRB\"}, {\n+      \"SLT\", \"SYLT\"}, {\n+      \"STC\", \"SYTC\"}, {\n+      \"TAL\", \"TALB\"}, {\n+      \"TBP\", \"TBPM\"}, {\n+      \"TCM\", \"TCOM\"}, {\n+      \"TCO\", \"TCON\"}, {\n+      \"TCR\", \"TCOP\"}, {\n+      \"TDA\", \"TDAT\"}, {         \/* obsolete, but we need to parse it anyway *\/\n+      \"TDY\", \"TDLY\"}, {\n+      \"TEN\", \"TENC\"}, {\n+      \"TFT\", \"TFLT\"}, {\n+      \"TKE\", \"TKEY\"}, {\n+      \"TLA\", \"TLAN\"}, {\n+      \"TLE\", \"TLEN\"}, {\n+      \"TMT\", \"TMED\"}, {\n+      \"TOA\", \"TOAL\"}, {\n+      \"TOF\", \"TOFN\"}, {\n+      \"TOL\", \"TOLY\"}, {\n+      \"TOR\", \"TDOR\"}, {\n+      \"TOT\", \"TOAL\"}, {\n+      \"TP1\", \"TPE1\"}, {\n+      \"TP2\", \"TPE2\"}, {\n+      \"TP3\", \"TPE3\"}, {\n+      \"TP4\", \"TPE4\"}, {\n+      \"TPA\", \"TPOS\"}, {\n+      \"TPB\", \"TPUB\"}, {\n+      \"TRC\", \"TSRC\"}, {\n+      \"TRD\", \"TDRC\"}, {\n+      \"TRK\", \"TRCK\"}, {\n+      \"TSS\", \"TSSE\"}, {\n+      \"TT1\", \"TIT1\"}, {\n+      \"TT2\", \"TIT2\"}, {\n+      \"TT3\", \"TIT3\"}, {\n+      \"TXT\", \"TOLY\"}, {\n+      \"TXX\", \"TXXX\"}, {\n+      \"TYE\", \"TDRC\"}, {\n+      \"UFI\", \"UFID\"}, {\n+      \"ULT\", \"USLT\"}, {\n+      \"WAF\", \"WOAF\"}, {\n+      \"WAR\", \"WOAR\"}, {\n+      \"WAS\", \"WOAS\"}, {\n+      \"WCM\", \"WCOM\"}, {\n+      \"WCP\", \"WCOP\"}, {\n+      \"WPB\", \"WPUB\"}, {\n+      \"WXX\", \"WXXX\"}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/id3v2.c","additions":60,"deletions":60,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -31,0 +31,22 @@\n+#ifndef GST_DISABLE_GST_DEBUG\n+#define GST_CAT_DEFAULT ensure_debug_category()\n+static GstDebugCategory *\n+ensure_debug_category (void)\n+{\n+  static gsize cat_gonce = 0;\n+\n+  if (g_once_init_enter (&cat_gonce)) {\n+    gsize cat_done;\n+\n+    cat_done = (gsize) _gst_debug_category_new (\"video-frame-converter\", 0,\n+        \"video-frame-converter object\");\n+\n+    g_once_init_leave (&cat_gonce, cat_done);\n+  }\n+\n+  return (GstDebugCategory *) cat_gonce;\n+}\n+#else\n+#define ensure_debug_category() \/* NOOP *\/\n+#endif \/* GST_DISABLE_GST_DEBUG *\/\n+\n@@ -412,1 +434,1 @@\n- * Returns: The converted #GstSample, or %NULL if an error happened (in which case @err\n+ * Returns: (nullable) (transfer full): The converted #GstSample, or %NULL if an error happened (in which case @err\n@@ -582,1 +604,1 @@\n-  g_slice_free (GstVideoConvertSampleContext, ctx);\n+  g_free (ctx);\n@@ -841,1 +863,1 @@\n-  ctx = g_slice_new0 (GstVideoConvertSampleContext);\n+  ctx = g_new0 (GstVideoConvertSampleContext, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/convertframe.c","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <gst\/base\/base.h>\n@@ -34,0 +35,6 @@\n+static gboolean\n+default_map (GstVideoMeta * meta, guint plane, GstMapInfo * info,\n+    gpointer * data, gint * stride, GstMapFlags flags);\n+static gboolean\n+default_unmap (GstVideoMeta * meta, guint plane, GstMapInfo * info);\n+\n@@ -137,0 +144,104 @@\n+static gboolean\n+video_meta_serialize (const GstMeta * meta, GstByteArrayInterface * data,\n+    guint8 * version)\n+{\n+  GstVideoMeta *vmeta = (GstVideoMeta *) meta;\n+\n+  if (vmeta->map != default_map || vmeta->unmap != default_unmap) {\n+    GST_WARNING (\"Cannot serialize video meta with custom map\/unmap functions\");\n+    return FALSE;\n+  }\n+\n+  gsize size = 36 + vmeta->n_planes * 16;\n+  guint8 *ptr = gst_byte_array_interface_append (data, size);\n+  if (ptr == NULL)\n+    return FALSE;\n+\n+  GstByteWriter bw;\n+  gboolean success = TRUE;\n+  gst_byte_writer_init_with_data (&bw, ptr, size, FALSE);\n+  success &= gst_byte_writer_put_int32_le (&bw, vmeta->flags);\n+  success &= gst_byte_writer_put_int32_le (&bw, vmeta->format);\n+  success &= gst_byte_writer_put_uint32_le (&bw, vmeta->width);\n+  success &= gst_byte_writer_put_uint32_le (&bw, vmeta->height);\n+  success &= gst_byte_writer_put_uint32_le (&bw, vmeta->n_planes);\n+  for (int n = 0; n < vmeta->n_planes; n++)\n+    success &= gst_byte_writer_put_uint64_le (&bw, vmeta->offset[n]);\n+  for (int n = 0; n < vmeta->n_planes; n++)\n+    success &= gst_byte_writer_put_int32_le (&bw, vmeta->stride[n]);\n+  success &= gst_byte_writer_put_uint32_le (&bw, vmeta->alignment.padding_top);\n+  success &=\n+      gst_byte_writer_put_uint32_le (&bw, vmeta->alignment.padding_bottom);\n+  success &= gst_byte_writer_put_uint32_le (&bw, vmeta->alignment.padding_left);\n+  success &=\n+      gst_byte_writer_put_uint32_le (&bw, vmeta->alignment.padding_right);\n+  for (int n = 0; n < vmeta->n_planes; n++)\n+    success &=\n+        gst_byte_writer_put_uint32_le (&bw, vmeta->alignment.stride_align[n]);\n+  g_assert (success);\n+\n+  return TRUE;\n+}\n+\n+static GstMeta *\n+video_meta_deserialize (const GstMetaInfo * info, GstBuffer * buffer,\n+    const guint8 * data, gsize size, guint8 version)\n+{\n+  GstVideoMeta *vmeta = NULL;\n+  gint32 flags;\n+  gint32 format;\n+  guint width;\n+  guint height;\n+  guint n_planes;\n+  GstVideoAlignment align;\n+  guint64 offset64[GST_VIDEO_MAX_PLANES];\n+  gint32 stride[GST_VIDEO_MAX_PLANES];\n+\n+  if (version != 0)\n+    return NULL;\n+\n+  GstByteReader br;\n+  gboolean success = TRUE;\n+  gst_byte_reader_init (&br, data, size);\n+  success &= gst_byte_reader_get_int32_le (&br, &flags);\n+  success &= gst_byte_reader_get_int32_le (&br, &format);\n+  success &= gst_byte_reader_get_uint32_le (&br, &width);\n+  success &= gst_byte_reader_get_uint32_le (&br, &height);\n+  success &= gst_byte_reader_get_uint32_le (&br, &n_planes);\n+\n+  if (!success || n_planes > GST_VIDEO_MAX_PLANES)\n+    return NULL;\n+\n+  for (int n = 0; n < n_planes; n++)\n+    success &= gst_byte_reader_get_uint64_le (&br, &offset64[n]);\n+  for (int n = 0; n < n_planes; n++)\n+    success &= gst_byte_reader_get_int32_le (&br, &stride[n]);\n+  success &= gst_byte_reader_get_uint32_le (&br, &align.padding_top);\n+  success &= gst_byte_reader_get_uint32_le (&br, &align.padding_bottom);\n+  success &= gst_byte_reader_get_uint32_le (&br, &align.padding_left);\n+  success &= gst_byte_reader_get_uint32_le (&br, &align.padding_right);\n+  for (int n = 0; n < n_planes; n++)\n+    success &= gst_byte_reader_get_uint32_le (&br, &align.stride_align[n]);\n+\n+  if (!success)\n+    return NULL;\n+\n+#if GLIB_SIZEOF_SIZE_T != 8\n+  gsize offset[GST_VIDEO_MAX_PLANES];\n+  for (int i = 0; i < n_planes; i++) {\n+    if (offset64[i] > G_MAXSIZE)\n+      return NULL;\n+    offset[i] = offset64[i];\n+  }\n+#else\n+  gsize *offset = (gsize *) offset64;\n+#endif\n+\n+  vmeta =\n+      gst_buffer_add_video_meta_full (buffer, flags, format, width, height,\n+      n_planes, offset, stride);\n+  gst_video_meta_set_alignment (vmeta, align);\n+\n+  return (GstMeta *) vmeta;\n+}\n+\n@@ -144,4 +255,8 @@\n-    const GstMetaInfo *meta =\n-        gst_meta_register (GST_VIDEO_META_API_TYPE, \"GstVideoMeta\",\n-        sizeof (GstVideoMeta), (GstMetaInitFunction) gst_video_meta_init,\n-        (GstMetaFreeFunction) NULL, gst_video_meta_transform);\n+    GstMetaInfo *info = gst_meta_info_new (GST_VIDEO_META_API_TYPE,\n+        \"GstVideoMeta\",\n+        sizeof (GstVideoMeta));\n+    info->init_func = gst_video_meta_init;\n+    info->transform_func = gst_video_meta_transform;\n+    info->serialize_func = video_meta_serialize;\n+    info->deserialize_func = video_meta_deserialize;\n+    const GstMetaInfo *meta = gst_meta_info_register (info);\n@@ -313,2 +428,2 @@\n-    guint height, guint n_planes, gsize offset[GST_VIDEO_MAX_PLANES],\n-    gint stride[GST_VIDEO_MAX_PLANES])\n+    guint height, guint n_planes, const gsize offset[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES])\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideometa.c","additions":121,"deletions":6,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -77,0 +77,3 @@\n+ *\n+ * Since 1.24 it can be serialized using gst_meta_serialize() and\n+ * gst_meta_deserialize().\n@@ -119,2 +122,2 @@\n-                                                guint n_planes, gsize offset[GST_VIDEO_MAX_PLANES],\n-                                                gint stride[GST_VIDEO_MAX_PLANES]);\n+                                                guint n_planes, const gsize offset[GST_VIDEO_MAX_PLANES],\n+                                                const gint stride[GST_VIDEO_MAX_PLANES]);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideometa.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  g_slice_free (GstVideoCodecFrame, frame);\n+  g_free (frame);\n@@ -175,1 +175,1 @@\n-    g_slice_free (GstVideoMasteringDisplayInfo, state->mastering_display_info);\n+    g_free (state->mastering_display_info);\n@@ -177,2 +177,2 @@\n-    g_slice_free (GstVideoContentLightLevel, state->content_light_level);\n-  g_slice_free (GstVideoCodecState, state);\n+    g_free (state->content_light_level);\n+  g_free (state);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideoutils.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1097,1 +1097,1 @@\n-  result = g_slice_new (GstVideoChromaResample);\n+  result = g_new (GstVideoChromaResample, 1);\n@@ -1147,1 +1147,1 @@\n-  g_slice_free (GstVideoChromaResample, resample);\n+  g_free (resample);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-chroma.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-  result = g_slice_new0 (GstLineCache);\n+  result = g_new0 (GstLineCache, 1);\n@@ -548,1 +548,1 @@\n-  g_slice_free (GstLineCache, cache);\n+  g_free (cache);\n@@ -612,1 +612,1 @@\n-  GST_DEBUG (\"no lines\");\n+  GST_LOG (\"no lines\");\n@@ -676,2 +676,2 @@\n-  GST_DEBUG (\"stride %d, n_lines %d\", stride, n_lines);\n-  alloc = g_slice_new0 (ConverterAlloc);\n+  GST_LOG (\"stride %d, n_lines %d\", stride, n_lines);\n+  alloc = g_new0 (ConverterAlloc, 1);\n@@ -694,1 +694,1 @@\n-  g_slice_free (ConverterAlloc, alloc);\n+  g_free (alloc);\n@@ -715,1 +715,1 @@\n-  GST_DEBUG (\"get temp line %d (%p %d)\", idx, alloc, alloc->idx);\n+  GST_LOG (\"get temp line %d (%p %d)\", idx, alloc, alloc->idx);\n@@ -729,1 +729,1 @@\n-  GST_DEBUG (\"get temp line %d (%p %d)\", idx, alloc, alloc->idx);\n+  GST_LOG (\"get temp line %d (%p %d)\", idx, alloc, alloc->idx);\n@@ -871,1 +871,1 @@\n-  GST_DEBUG (\"chain unpack line format %s, pstride %d, identity_unpack %d\",\n+  GST_LOG (\"chain unpack line format %s, pstride %d, identity_unpack %d\",\n@@ -891,1 +891,1 @@\n-    GST_DEBUG (\"chain upsample\");\n+    GST_LOG (\"chain upsample\");\n@@ -1001,8 +1001,4 @@\n-  GST_DEBUG (\"[%f %f %f %f]\", s->dm[0][0], s->dm[0][1], s->dm[0][2],\n-      s->dm[0][3]);\n-  GST_DEBUG (\"[%f %f %f %f]\", s->dm[1][0], s->dm[1][1], s->dm[1][2],\n-      s->dm[1][3]);\n-  GST_DEBUG (\"[%f %f %f %f]\", s->dm[2][0], s->dm[2][1], s->dm[2][2],\n-      s->dm[2][3]);\n-  GST_DEBUG (\"[%f %f %f %f]\", s->dm[3][0], s->dm[3][1], s->dm[3][2],\n-      s->dm[3][3]);\n+  GST_LOG (\"[%f %f %f %f]\", s->dm[0][0], s->dm[0][1], s->dm[0][2], s->dm[0][3]);\n+  GST_LOG (\"[%f %f %f %f]\", s->dm[1][0], s->dm[1][1], s->dm[1][2], s->dm[1][3]);\n+  GST_LOG (\"[%f %f %f %f]\", s->dm[2][0], s->dm[2][1], s->dm[2][2], s->dm[2][3]);\n+  GST_LOG (\"[%f %f %f %f]\", s->dm[3][0], s->dm[3][1], s->dm[3][2], s->dm[3][3]);\n@@ -1020,1 +1016,1 @@\n-  GST_DEBUG (\"[%6d %6d %6d %6d]\", s->im[0][0], s->im[0][1], s->im[0][2],\n+  GST_LOG (\"[%6d %6d %6d %6d]\", s->im[0][0], s->im[0][1], s->im[0][2],\n@@ -1022,1 +1018,1 @@\n-  GST_DEBUG (\"[%6d %6d %6d %6d]\", s->im[1][0], s->im[1][1], s->im[1][2],\n+  GST_LOG (\"[%6d %6d %6d %6d]\", s->im[1][0], s->im[1][1], s->im[1][2],\n@@ -1024,1 +1020,1 @@\n-  GST_DEBUG (\"[%6d %6d %6d %6d]\", s->im[2][0], s->im[2][1], s->im[2][2],\n+  GST_LOG (\"[%6d %6d %6d %6d]\", s->im[2][0], s->im[2][1], s->im[2][2],\n@@ -1026,1 +1022,1 @@\n-  GST_DEBUG (\"[%6d %6d %6d %6d]\", s->im[3][0], s->im[3][1], s->im[3][2],\n+  GST_LOG (\"[%6d %6d %6d %6d]\", s->im[3][0], s->im[3][1], s->im[3][2],\n@@ -1350,1 +1346,1 @@\n-      GST_DEBUG (\"use fast AYUV -> RGB matrix\");\n+      GST_LOG (\"use fast AYUV -> RGB matrix\");\n@@ -1353,1 +1349,1 @@\n-      GST_DEBUG (\"use 8bit table\");\n+      GST_LOG (\"use 8bit table\");\n@@ -1359,1 +1355,1 @@\n-      GST_DEBUG (\"use 8bit matrix\");\n+      GST_LOG (\"use 8bit matrix\");\n@@ -1380,1 +1376,1 @@\n-    GST_DEBUG (\"use 16bit matrix\");\n+    GST_LOG (\"use 16bit matrix\");\n@@ -1520,1 +1516,1 @@\n-    GST_DEBUG (\"gamma decode already set up\");\n+    GST_LOG (\"gamma decode already set up\");\n@@ -1522,1 +1518,1 @@\n-    GST_DEBUG (\"gamma decode 8->16: %d\", func);\n+    GST_LOG (\"gamma decode 8->16: %d\", func);\n@@ -1530,1 +1526,1 @@\n-    GST_DEBUG (\"gamma decode 16->16: %d\", func);\n+    GST_LOG (\"gamma decode 16->16: %d\", func);\n@@ -1554,1 +1550,1 @@\n-    GST_DEBUG (\"gamma encode already set up\");\n+    GST_LOG (\"gamma encode already set up\");\n@@ -1558,1 +1554,1 @@\n-    GST_DEBUG (\"gamma encode 16->8: %d\", func);\n+    GST_LOG (\"gamma encode 16->8: %d\", func);\n@@ -1568,1 +1564,1 @@\n-    GST_DEBUG (\"gamma encode 16->16: %d\", func);\n+    GST_LOG (\"gamma encode 16->16: %d\", func);\n@@ -1596,1 +1592,1 @@\n-      GST_DEBUG (\"chain RGB convert\");\n+      GST_LOG (\"chain RGB convert\");\n@@ -1617,1 +1613,1 @@\n-    GST_DEBUG (\"chain gamma decode\");\n+    GST_LOG (\"chain gamma decode\");\n@@ -1638,1 +1634,1 @@\n-  GST_DEBUG (\"chain hscale %d->%d, taps %d, method %d\",\n+  GST_LOG (\"chain hscale %d->%d, taps %d, method %d\",\n@@ -1683,1 +1679,1 @@\n-  GST_DEBUG (\"chain vscale %d->%d, taps %d, method %d, backlog %d\",\n+  GST_LOG (\"chain vscale %d->%d, taps %d, method %d, backlog %d\",\n@@ -1706,1 +1702,1 @@\n-  GST_DEBUG (\"in pixels %d <> out pixels %d\", s0, s3);\n+  GST_LOG (\"in pixels %d <> out pixels %d\", s0, s3);\n@@ -1713,1 +1709,1 @@\n-    GST_DEBUG (\"%d <> %d\", s1, s2);\n+    GST_LOG (\"%d <> %d\", s1, s2);\n@@ -1756,1 +1752,1 @@\n-  GST_DEBUG (\"matrix %d -> %d (%d)\", convert->in_info.colorimetry.matrix,\n+  GST_LOG (\"matrix %d -> %d (%d)\", convert->in_info.colorimetry.matrix,\n@@ -1758,1 +1754,1 @@\n-  GST_DEBUG (\"bits %d -> %d (%d)\", convert->unpack_bits, convert->pack_bits,\n+  GST_LOG (\"bits %d -> %d (%d)\", convert->unpack_bits, convert->pack_bits,\n@@ -1760,1 +1756,1 @@\n-  GST_DEBUG (\"primaries %d -> %d (%d)\", convert->in_info.colorimetry.primaries,\n+  GST_LOG (\"primaries %d -> %d (%d)\", convert->in_info.colorimetry.primaries,\n@@ -1783,1 +1779,1 @@\n-    GST_DEBUG (\"to XYZ matrix\");\n+    GST_LOG (\"to XYZ matrix\");\n@@ -1785,1 +1781,1 @@\n-    GST_DEBUG (\"current matrix\");\n+    GST_LOG (\"current matrix\");\n@@ -1802,1 +1798,1 @@\n-    GST_DEBUG (\"to RGB matrix\");\n+    GST_LOG (\"to RGB matrix\");\n@@ -1811,1 +1807,1 @@\n-    GST_DEBUG (\"current matrix\");\n+    GST_LOG (\"current matrix\");\n@@ -1828,1 +1824,1 @@\n-      GST_DEBUG (\"to RGB matrix\");\n+      GST_LOG (\"to RGB matrix\");\n@@ -1830,1 +1826,1 @@\n-      GST_DEBUG (\"current matrix\");\n+      GST_LOG (\"current matrix\");\n@@ -1833,1 +1829,1 @@\n-      GST_DEBUG (\"to YUV matrix\");\n+      GST_LOG (\"to YUV matrix\");\n@@ -1835,1 +1831,1 @@\n-      GST_DEBUG (\"current matrix\");\n+      GST_LOG (\"current matrix\");\n@@ -1871,1 +1867,1 @@\n-    GST_DEBUG (\"chain conversion\");\n+    GST_LOG (\"chain conversion\");\n@@ -1957,1 +1953,1 @@\n-  GST_DEBUG (\"chain alpha mode %d\", convert->alpha_mode);\n+  GST_LOG (\"chain alpha mode %d\", convert->alpha_mode);\n@@ -1979,1 +1975,1 @@\n-    GST_DEBUG (\"chain gamma encode\");\n+    GST_LOG (\"chain gamma encode\");\n@@ -2008,1 +2004,1 @@\n-      GST_DEBUG (\"chain YUV convert\");\n+      GST_LOG (\"chain YUV convert\");\n@@ -2034,1 +2030,1 @@\n-    GST_DEBUG (\"chain downsample\");\n+    GST_LOG (\"chain downsample\");\n@@ -2061,1 +2057,1 @@\n-  GST_DEBUG (\"method %d, target-quantization %d\", method, target_quant);\n+  GST_LOG (\"method %d, target-quantization %d\", method, target_quant);\n@@ -2095,1 +2091,1 @@\n-    GST_DEBUG (\"chain dither\");\n+    GST_LOG (\"chain dither\");\n@@ -2119,1 +2115,1 @@\n-  GST_DEBUG (\"chain pack line format %s, pstride %d, identity_pack %d (%d %d)\",\n+  GST_LOG (\"chain pack line format %s, pstride %d, identity_pack %d (%d %d)\",\n@@ -2163,1 +2159,1 @@\n-      GST_DEBUG (\"looking at cache %p, %d lines, %d backlog\", cache,\n+      GST_LOG (\"looking at cache %p, %d lines, %d backlog\", cache,\n@@ -2167,1 +2163,1 @@\n-        GST_DEBUG (\"cache %p, needs %d lines\", prev, prev->n_lines);\n+        GST_LOG (\"cache %p, needs %d lines\", prev, prev->n_lines);\n@@ -2346,1 +2342,1 @@\n-  convert = g_slice_new0 (GstVideoConverter);\n+  convert = g_new0 (GstVideoConverter, 1);\n@@ -2694,1 +2690,1 @@\n-  g_slice_free (GstVideoConverter, convert);\n+  g_free (convert);\n@@ -2852,1 +2848,1 @@\n-  GST_DEBUG (\"site: %d->%d, w_sub: %d->%d, h_sub: %d->%d\", in_info->chroma_site,\n+  GST_LOG (\"site: %d->%d, w_sub: %d->%d, h_sub: %d->%d\", in_info->chroma_site,\n@@ -2938,1 +2934,1 @@\n-  GST_DEBUG (\"get dest line %d %p\", cline, line);\n+  GST_LOG (\"get dest line %d %p\", cline, line);\n@@ -2965,1 +2961,1 @@\n-    GST_DEBUG (\"unpack line %d (%u) %p\", in_line, cline, tmpline);\n+    GST_LOG (\"unpack line %d (%u) %p\", in_line, cline, tmpline);\n@@ -2971,1 +2967,1 @@\n-    GST_DEBUG (\"get src line %d (%u) %p\", in_line, cline, tmpline);\n+    GST_LOG (\"get src line %d (%u) %p\", in_line, cline, tmpline);\n@@ -2999,1 +2995,1 @@\n-    GST_DEBUG (\"doing upsample %d-%d %p\", start_line, start_line + n_lines - 1,\n+    GST_LOG (\"doing upsample %d-%d %p\", start_line, start_line + n_lines - 1,\n@@ -3023,1 +3019,1 @@\n-    GST_DEBUG (\"to RGB line %d %p\", in_line, destline);\n+    GST_LOG (\"to RGB line %d %p\", in_line, destline);\n@@ -3029,1 +3025,1 @@\n-    GST_DEBUG (\"gamma decode line %d %p->%p\", in_line, lines[0], destline);\n+    GST_LOG (\"gamma decode line %d %p->%p\", in_line, lines[0], destline);\n@@ -3048,1 +3044,1 @@\n-  GST_DEBUG (\"hresample line %d %p->%p\", in_line, lines[0], destline);\n+  GST_LOG (\"hresample line %d %p->%p\", in_line, lines[0], destline);\n@@ -3073,1 +3069,1 @@\n-  GST_DEBUG (\"vresample line %d %d-%d %p->%p\", in_line, sline,\n+  GST_LOG (\"vresample line %d %d-%d %p->%p\", in_line, sline,\n@@ -3110,1 +3106,1 @@\n-      GST_DEBUG (\"8->16 line %d %p->%p\", in_line, srcline, destline);\n+      GST_LOG (\"8->16 line %d %p->%p\", in_line, srcline, destline);\n@@ -3116,1 +3112,1 @@\n-      GST_DEBUG (\"matrix line %d %p\", in_line, srcline);\n+      GST_LOG (\"matrix line %d %p\", in_line, srcline);\n@@ -3122,1 +3118,1 @@\n-      GST_DEBUG (\"16->8 line %d %p->%p\", in_line, srcline, destline);\n+      GST_LOG (\"16->8 line %d %p->%p\", in_line, srcline, destline);\n@@ -3127,1 +3123,1 @@\n-      GST_DEBUG (\"matrix line %d %p\", in_line, destline);\n+      GST_LOG (\"matrix line %d %p\", in_line, destline);\n@@ -3147,1 +3143,1 @@\n-  GST_DEBUG (\"alpha line %d %p\", in_line, destline);\n+  GST_LOG (\"alpha line %d %p\", in_line, destline);\n@@ -3169,1 +3165,1 @@\n-    GST_DEBUG (\"gamma encode line %d %p->%p\", in_line, lines[0], destline);\n+    GST_LOG (\"gamma encode line %d %p->%p\", in_line, lines[0], destline);\n@@ -3173,1 +3169,1 @@\n-    GST_DEBUG (\"to YUV line %d %p\", in_line, destline);\n+    GST_LOG (\"to YUV line %d %p\", in_line, destline);\n@@ -3200,1 +3196,1 @@\n-    GST_DEBUG (\"downsample line %d %d-%d %p\", in_line, start_line,\n+    GST_LOG (\"downsample line %d %d-%d %p\", in_line, start_line,\n@@ -3223,1 +3219,1 @@\n-    GST_DEBUG (\"Dither line %d %p\", in_line, destline);\n+    GST_LOG (\"Dither line %d %p\", in_line, destline);\n@@ -3261,1 +3257,1 @@\n-      GST_DEBUG (\"pack line %d %p (%p)\", i + task->out_y, lines[0], l);\n+      GST_LOG (\"pack line %d %p (%p)\", i + task->out_y, lines[0], l);\n@@ -3292,1 +3288,1 @@\n-    GST_DEBUG (\"setup interlaced frame\");\n+    GST_LOG (\"setup interlaced frame\");\n@@ -3297,1 +3293,1 @@\n-    GST_DEBUG (\"setup progressive frame\");\n+    GST_LOG (\"setup progressive frame\");\n@@ -7252,0 +7248,2 @@\n+    case GST_VIDEO_FORMAT_A422:\n+    case GST_VIDEO_FORMAT_A444:\n@@ -7292,0 +7290,1 @@\n+    case GST_VIDEO_FORMAT_RBGA:\n@@ -7341,0 +7340,2 @@\n+    case GST_VIDEO_FORMAT_GBR_16BE:\n+    case GST_VIDEO_FORMAT_GBR_16LE:\n@@ -7351,0 +7352,12 @@\n+    case GST_VIDEO_FORMAT_A444_12BE:\n+    case GST_VIDEO_FORMAT_A444_12LE:\n+    case GST_VIDEO_FORMAT_A422_12BE:\n+    case GST_VIDEO_FORMAT_A422_12LE:\n+    case GST_VIDEO_FORMAT_A420_12BE:\n+    case GST_VIDEO_FORMAT_A420_12LE:\n+    case GST_VIDEO_FORMAT_A444_16BE:\n+    case GST_VIDEO_FORMAT_A444_16LE:\n+    case GST_VIDEO_FORMAT_A422_16BE:\n+    case GST_VIDEO_FORMAT_A422_16LE:\n+    case GST_VIDEO_FORMAT_A420_16BE:\n+    case GST_VIDEO_FORMAT_A420_16LE:\n@@ -7371,0 +7384,4 @@\n+    case GST_VIDEO_FORMAT_NV12_10LE40_4L4:\n+    case GST_VIDEO_FORMAT_DMA_DRM:\n+    case GST_VIDEO_FORMAT_MT2110T:\n+    case GST_VIDEO_FORMAT_MT2110R:\n@@ -7437,1 +7454,1 @@\n-        GST_DEBUG (\"%s only with nearest resampling\",\n+        GST_LOG (\"%s only with nearest resampling\",\n@@ -7570,3 +7587,3 @@\n-      GST_DEBUG (\"plane %d: %dx%d -> %dx%d\", i, iw, ih, ow, oh);\n-      GST_DEBUG (\"plane %d: pstride %d\", i, pstride);\n-      GST_DEBUG (\"plane %d: in_x %d, in_y %d\", i, convert->fin_x[i],\n+      GST_LOG (\"plane %d: %dx%d -> %dx%d\", i, iw, ih, ow, oh);\n+      GST_LOG (\"plane %d: pstride %d\", i, pstride);\n+      GST_LOG (\"plane %d: in_x %d, in_y %d\", i, convert->fin_x[i],\n@@ -7574,1 +7591,1 @@\n-      GST_DEBUG (\"plane %d: out_x %d, out_y %d\", i, convert->fout_x[i],\n+      GST_LOG (\"plane %d: out_x %d, out_y %d\", i, convert->fout_x[i],\n@@ -7592,1 +7609,1 @@\n-        GST_DEBUG (\"plane %d fill %02x\", i, convert->ffill[i]);\n+        GST_LOG (\"plane %d fill %02x\", i, convert->ffill[i]);\n@@ -7596,1 +7613,1 @@\n-        GST_DEBUG (\"plane %d -> %d (comp %d)\", i, convert->fsplane[i], comp);\n+        GST_LOG (\"plane %d -> %d (comp %d)\", i, convert->fsplane[i], comp);\n@@ -7608,1 +7625,1 @@\n-          GST_DEBUG (\"plane %d: copy\", i);\n+          GST_LOG (\"plane %d: copy\", i);\n@@ -7612,1 +7629,1 @@\n-          GST_DEBUG (\"plane %d: vertical halve\", i);\n+          GST_LOG (\"plane %d: vertical halve\", i);\n@@ -7616,1 +7633,1 @@\n-          GST_DEBUG (\"plane %d: vertical double\", i);\n+          GST_LOG (\"plane %d: vertical double\", i);\n@@ -7619,1 +7636,1 @@\n-          GST_DEBUG (\"plane %d: vertical scale\", i);\n+          GST_LOG (\"plane %d: vertical scale\", i);\n@@ -7626,1 +7643,1 @@\n-          GST_DEBUG (\"plane %d: horizontal halve\", i);\n+          GST_LOG (\"plane %d: horizontal halve\", i);\n@@ -7630,1 +7647,1 @@\n-          GST_DEBUG (\"plane %d: horizontal double\", i);\n+          GST_LOG (\"plane %d: horizontal double\", i);\n@@ -7633,1 +7650,1 @@\n-          GST_DEBUG (\"plane %d: horizontal scale\", i);\n+          GST_LOG (\"plane %d: horizontal scale\", i);\n@@ -7640,1 +7657,1 @@\n-          GST_DEBUG (\"plane %d: horizontal\/vertical halve\", i);\n+          GST_LOG (\"plane %d: horizontal\/vertical halve\", i);\n@@ -7644,1 +7661,1 @@\n-          GST_DEBUG (\"plane %d: horizontal\/vertical double\", i);\n+          GST_LOG (\"plane %d: horizontal\/vertical double\", i);\n@@ -7647,1 +7664,1 @@\n-          GST_DEBUG (\"plane %d: horizontal\/vertical scale\", i);\n+          GST_LOG (\"plane %d: horizontal\/vertical scale\", i);\n@@ -8205,1 +8222,1 @@\n-  GST_DEBUG (\"alpha copy %d, set %d, mult %d\", need_copy, need_set, need_mult);\n+  GST_LOG (\"alpha copy %d, set %d, mult %d\", need_copy, need_set, need_mult);\n@@ -8256,1 +8273,1 @@\n-      GST_DEBUG (\"using fastpath\");\n+      GST_LOG (\"using fastpath\");\n@@ -8274,1 +8291,1 @@\n-  GST_DEBUG (\"no fastpath found\");\n+  GST_LOG (\"no fastpath found\");\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-converter.c","additions":119,"deletions":102,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-  dither = g_slice_new0 (GstVideoDither);\n+  dither = g_new0 (GstVideoDither, 1);\n@@ -405,1 +405,1 @@\n-      g_slice_free (GstVideoDither, dither);\n+      g_free (dither);\n@@ -477,1 +477,1 @@\n-  g_slice_free (GstVideoDither, dither);\n+  g_free (dither);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-dither.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3259,0 +3259,104 @@\n+#define PACK_GBR_16LE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_16LE, 1, pack_GBR_16LE\n+static void\n+unpack_GBR_16LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  int i;\n+  const guint16 *sg = GET_G_LINE (y);\n+  const guint16 *sb = GET_B_LINE (y);\n+  const guint16 *sr = GET_R_LINE (y);\n+  guint16 *d = dest, G, B, R;\n+\n+  sg += x;\n+  sb += x;\n+  sr += x;\n+\n+  for (i = 0; i < width; i++) {\n+    G = GST_READ_UINT16_LE (sg + i);\n+    B = GST_READ_UINT16_LE (sb + i);\n+    R = GST_READ_UINT16_LE (sr + i);\n+\n+    d[i * 4 + 0] = 0xffff;\n+    d[i * 4 + 1] = R;\n+    d[i * 4 + 2] = G;\n+    d[i * 4 + 3] = B;\n+  }\n+}\n+\n+static void\n+pack_GBR_16LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  int i;\n+  guint16 *restrict dg = GET_G_LINE (y);\n+  guint16 *restrict db = GET_B_LINE (y);\n+  guint16 *restrict dr = GET_R_LINE (y);\n+  guint16 G, B, R;\n+  const guint16 *restrict s = src;\n+\n+  for (i = 0; i < width; i++) {\n+    G = (s[i * 4 + 2]);\n+    B = (s[i * 4 + 3]);\n+    R = (s[i * 4 + 1]);\n+\n+    GST_WRITE_UINT16_LE (dg + i, G);\n+    GST_WRITE_UINT16_LE (db + i, B);\n+    GST_WRITE_UINT16_LE (dr + i, R);\n+  }\n+}\n+\n+#define PACK_GBR_16BE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_16BE, 1, pack_GBR_16BE\n+static void\n+unpack_GBR_16BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  int i;\n+  const guint16 *restrict sg = GET_G_LINE (y);\n+  const guint16 *restrict sb = GET_B_LINE (y);\n+  const guint16 *restrict sr = GET_R_LINE (y);\n+  guint16 *restrict d = dest, G, B, R;\n+\n+  sg += x;\n+  sb += x;\n+  sr += x;\n+\n+  for (i = 0; i < width; i++) {\n+    G = GST_READ_UINT16_BE (sg + i);\n+    B = GST_READ_UINT16_BE (sb + i);\n+    R = GST_READ_UINT16_BE (sr + i);\n+\n+    d[i * 4 + 0] = 0xffff;\n+    d[i * 4 + 1] = R;\n+    d[i * 4 + 2] = G;\n+    d[i * 4 + 3] = B;\n+  }\n+}\n+\n+static void\n+pack_GBR_16BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  int i;\n+  guint16 *restrict dg = GET_G_LINE (y);\n+  guint16 *restrict db = GET_B_LINE (y);\n+  guint16 *restrict dr = GET_R_LINE (y);\n+  guint16 G, B, R;\n+  const guint16 *restrict s = src;\n+\n+  for (i = 0; i < width; i++) {\n+    G = s[i * 4 + 2];\n+    B = s[i * 4 + 3];\n+    R = s[i * 4 + 1];\n+\n+    GST_WRITE_UINT16_BE (dg + i, G);\n+    GST_WRITE_UINT16_BE (db + i, B);\n+    GST_WRITE_UINT16_BE (dr + i, R);\n+  }\n+}\n+\n@@ -4257,1 +4361,1 @@\n-#define PACK_A444_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A444_10LE, 1, pack_A444_10LE\n+#define PACK_A444 GST_VIDEO_FORMAT_AYUV, unpack_A444, 1, pack_A444\n@@ -4259,1 +4363,1 @@\n-unpack_A444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+unpack_A444 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4264,5 +4368,5 @@\n-  guint16 *restrict sa = GET_A_LINE (y);\n-  guint16 *restrict sy = GET_Y_LINE (y);\n-  guint16 *restrict su = GET_U_LINE (y);\n-  guint16 *restrict sv = GET_V_LINE (y);\n-  guint16 *restrict d = dest, A, Y, U, V;\n+  guint8 *restrict sa = GET_A_LINE (y);\n+  guint8 *restrict sy = GET_Y_LINE (y);\n+  guint8 *restrict su = GET_U_LINE (y);\n+  guint8 *restrict sv = GET_V_LINE (y);\n+  guint8 *restrict d = dest, A, Y, U, V;\n@@ -4276,11 +4380,4 @@\n-    A = GST_READ_UINT16_LE (sa + i) << 6;\n-    Y = GST_READ_UINT16_LE (sy + i) << 6;\n-    U = GST_READ_UINT16_LE (su + i) << 6;\n-    V = GST_READ_UINT16_LE (sv + i) << 6;\n-\n-    if (!(flags & GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {\n-      A |= (A >> 10);\n-      Y |= (Y >> 10);\n-      U |= (U >> 10);\n-      V |= (V >> 10);\n-    }\n+    A = sa[i];\n+    Y = sy[i];\n+    U = su[i];\n+    V = sv[i];\n@@ -4296,1 +4393,1 @@\n-pack_A444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+pack_A444 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4302,6 +4399,6 @@\n-  guint16 *restrict da = GET_A_LINE (y);\n-  guint16 *restrict dy = GET_Y_LINE (y);\n-  guint16 *restrict du = GET_U_LINE (y);\n-  guint16 *restrict dv = GET_V_LINE (y);\n-  guint16 A, Y, U, V;\n-  const guint16 *restrict s = src;\n+  guint8 *restrict da = GET_A_LINE (y);\n+  guint8 *restrict dy = GET_Y_LINE (y);\n+  guint8 *restrict du = GET_U_LINE (y);\n+  guint8 *restrict dv = GET_V_LINE (y);\n+  guint8 A, Y, U, V;\n+  const guint8 *restrict s = src;\n@@ -4310,4 +4407,4 @@\n-    A = (s[i * 4 + 0]) >> 6;\n-    Y = (s[i * 4 + 1]) >> 6;\n-    U = (s[i * 4 + 2]) >> 6;\n-    V = (s[i * 4 + 3]) >> 6;\n+    A = (s[i * 4 + 0]);\n+    Y = (s[i * 4 + 1]);\n+    U = (s[i * 4 + 2]);\n+    V = (s[i * 4 + 3]);\n@@ -4315,4 +4412,4 @@\n-    GST_WRITE_UINT16_LE (da + i, A);\n-    GST_WRITE_UINT16_LE (dy + i, Y);\n-    GST_WRITE_UINT16_LE (du + i, U);\n-    GST_WRITE_UINT16_LE (dv + i, V);\n+    da[i] = A;\n+    dy[i] = Y;\n+    du[i] = U;\n+    dv[i] = V;\n@@ -4322,1 +4419,0 @@\n-#define PACK_A444_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A444_10BE, 1, pack_A444_10BE\n@@ -4324,1 +4420,1 @@\n-unpack_A444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+unpack_A444_16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4329,4 +4425,4 @@\n-  const guint16 *restrict sa = GET_A_LINE (y);\n-  const guint16 *restrict sy = GET_Y_LINE (y);\n-  const guint16 *restrict su = GET_U_LINE (y);\n-  const guint16 *restrict sv = GET_V_LINE (y);\n+  guint16 *restrict sa = GET_A_LINE (y);\n+  guint16 *restrict sy = GET_Y_LINE (y);\n+  guint16 *restrict su = GET_U_LINE (y);\n+  guint16 *restrict sv = GET_V_LINE (y);\n@@ -4341,4 +4437,11 @@\n-    A = GST_READ_UINT16_BE (sa + i) << 6;\n-    Y = GST_READ_UINT16_BE (sy + i) << 6;\n-    U = GST_READ_UINT16_BE (su + i) << 6;\n-    V = GST_READ_UINT16_BE (sv + i) << 6;\n+    if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+      A = GST_READ_UINT16_LE (sa + i) << (16 - info->bits);\n+      Y = GST_READ_UINT16_LE (sy + i) << (16 - info->bits);\n+      U = GST_READ_UINT16_LE (su + i) << (16 - info->bits);\n+      V = GST_READ_UINT16_LE (sv + i) << (16 - info->bits);\n+    } else {\n+      A = GST_READ_UINT16_BE (sa + i) << (16 - info->bits);\n+      Y = GST_READ_UINT16_BE (sy + i) << (16 - info->bits);\n+      U = GST_READ_UINT16_BE (su + i) << (16 - info->bits);\n+      V = GST_READ_UINT16_BE (sv + i) << (16 - info->bits);\n+    }\n@@ -4347,4 +4450,4 @@\n-      A |= (A >> 10);\n-      Y |= (Y >> 10);\n-      U |= (U >> 10);\n-      V |= (V >> 10);\n+      A |= (A >> info->bits);\n+      Y |= (Y >> info->bits);\n+      U |= (U >> info->bits);\n+      V |= (V >> info->bits);\n@@ -4361,1 +4464,1 @@\n-pack_A444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+pack_A444_16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4375,53 +4478,15 @@\n-    A = s[i * 4 + 0] >> 6;\n-    Y = s[i * 4 + 1] >> 6;\n-    U = s[i * 4 + 2] >> 6;\n-    V = s[i * 4 + 3] >> 6;\n-\n-    GST_WRITE_UINT16_BE (da + i, A);\n-    GST_WRITE_UINT16_BE (dy + i, Y);\n-    GST_WRITE_UINT16_BE (du + i, U);\n-    GST_WRITE_UINT16_BE (dv + i, V);\n-  }\n-}\n-\n-#define PACK_A420_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A420_10LE, 1, pack_A420_10LE\n-static void\n-unpack_A420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n-    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n-    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n-{\n-  int i;\n-  gint uv = GET_UV_420 (y, flags);\n-  const guint16 *restrict sa = GET_A_LINE (y);\n-  const guint16 *restrict sy = GET_Y_LINE (y);\n-  const guint16 *restrict su = GET_U_LINE (uv);\n-  const guint16 *restrict sv = GET_V_LINE (uv);\n-  guint16 *restrict d = dest, A, Y, U, V;\n-\n-  sa += x;\n-  sy += x;\n-  su += x >> 1;\n-  sv += x >> 1;\n-\n-  for (i = 0; i < width; i++) {\n-    A = GST_READ_UINT16_LE (sa + i) << 6;\n-    Y = GST_READ_UINT16_LE (sy + i) << 6;\n-    U = GST_READ_UINT16_LE (su + (i >> 1)) << 6;\n-    V = GST_READ_UINT16_LE (sv + (i >> 1)) << 6;\n-\n-    if (!(flags & GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {\n-      A |= (A >> 10);\n-      Y |= (Y >> 10);\n-      U |= (U >> 10);\n-      V |= (V >> 10);\n-    }\n-\n-    d[i * 4 + 0] = A;\n-    d[i * 4 + 1] = Y;\n-    d[i * 4 + 2] = U;\n-    d[i * 4 + 3] = V;\n-\n-    if (x & 1) {\n-      x = 0;\n-      su++;\n-      sv++;\n+    A = (s[i * 4 + 0]) >> (16 - info->bits);\n+    Y = (s[i * 4 + 1]) >> (16 - info->bits);\n+    U = (s[i * 4 + 2]) >> (16 - info->bits);\n+    V = (s[i * 4 + 3]) >> (16 - info->bits);\n+\n+    if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+      GST_WRITE_UINT16_LE (da + i, A);\n+      GST_WRITE_UINT16_LE (dy + i, Y);\n+      GST_WRITE_UINT16_LE (du + i, U);\n+      GST_WRITE_UINT16_LE (dv + i, V);\n+    } else {\n+      GST_WRITE_UINT16_BE (da + i, A);\n+      GST_WRITE_UINT16_BE (dy + i, Y);\n+      GST_WRITE_UINT16_BE (du + i, U);\n+      GST_WRITE_UINT16_BE (dv + i, V);\n@@ -4432,36 +4497,6 @@\n-static void\n-pack_A420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n-    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n-    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n-    gint y, gint width)\n-{\n-  int i;\n-  gint uv = GET_UV_420 (y, flags);\n-  guint16 *restrict da = GET_A_LINE (y);\n-  guint16 *restrict dy = GET_Y_LINE (y);\n-  guint16 *restrict du = GET_U_LINE (uv);\n-  guint16 *restrict dv = GET_V_LINE (uv);\n-  guint16 A0, Y0, A1, Y1, U, V;\n-  const guint16 *restrict s = src;\n-\n-  if (IS_CHROMA_LINE_420 (y, flags)) {\n-    for (i = 0; i < width - 1; i += 2) {\n-      A0 = s[i * 4 + 0] >> 6;\n-      Y0 = s[i * 4 + 1] >> 6;\n-      A1 = s[i * 4 + 4] >> 6;\n-      Y1 = s[i * 4 + 5] >> 6;\n-      U = s[i * 4 + 2] >> 6;\n-      V = s[i * 4 + 3] >> 6;\n-\n-      GST_WRITE_UINT16_LE (da + i + 0, A0);\n-      GST_WRITE_UINT16_LE (dy + i + 0, Y0);\n-      GST_WRITE_UINT16_LE (da + i + 1, A1);\n-      GST_WRITE_UINT16_LE (dy + i + 1, Y1);\n-      GST_WRITE_UINT16_LE (du + (i >> 1), U);\n-      GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n-    }\n-    if (i == width - 1) {\n-      A0 = s[i * 4 + 0] >> 6;\n-      Y0 = s[i * 4 + 1] >> 6;\n-      U = s[i * 4 + 2] >> 6;\n-      V = s[i * 4 + 3] >> 6;\n+#define PACK_A444_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A444_16, 1, pack_A444_16\n+#define PACK_A444_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A444_16, 1, pack_A444_16\n+#define PACK_A444_12BE GST_VIDEO_FORMAT_AYUV64, unpack_A444_16, 1, pack_A444_16\n+#define PACK_A444_12LE GST_VIDEO_FORMAT_AYUV64, unpack_A444_16, 1, pack_A444_16\n+#define PACK_A444_16BE GST_VIDEO_FORMAT_AYUV64, unpack_A444_16, 1, pack_A444_16\n+#define PACK_A444_16LE GST_VIDEO_FORMAT_AYUV64, unpack_A444_16, 1, pack_A444_16\n@@ -4469,16 +4504,0 @@\n-      GST_WRITE_UINT16_LE (da + i, A0);\n-      GST_WRITE_UINT16_LE (dy + i, Y0);\n-      GST_WRITE_UINT16_LE (du + (i >> 1), U);\n-      GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n-    }\n-  } else {\n-    for (i = 0; i < width; i++) {\n-      A0 = s[i * 4 + 0] >> 6;\n-      Y0 = s[i * 4 + 1] >> 6;\n-      GST_WRITE_UINT16_LE (da + i, A0);\n-      GST_WRITE_UINT16_LE (dy + i, Y0);\n-    }\n-  }\n-}\n-\n-#define PACK_A420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A420_10BE, 1, pack_A420_10BE\n@@ -4486,1 +4505,1 @@\n-unpack_A420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+unpack_A420_16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4504,5 +4523,11 @@\n-    A = GST_READ_UINT16_BE (sa + i) << 6;\n-    Y = GST_READ_UINT16_BE (sy + i) << 6;\n-    U = GST_READ_UINT16_BE (su + (i >> 1)) << 6;\n-    V = GST_READ_UINT16_BE (sv + (i >> 1)) << 6;\n-\n+    if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+      A = GST_READ_UINT16_LE (sa + i) << (16 - info->bits);\n+      Y = GST_READ_UINT16_LE (sy + i) << (16 - info->bits);\n+      U = GST_READ_UINT16_LE (su + (i >> 1)) << (16 - info->bits);\n+      V = GST_READ_UINT16_LE (sv + (i >> 1)) << (16 - info->bits);\n+    } else {\n+      A = GST_READ_UINT16_BE (sa + i) << (16 - info->bits);\n+      Y = GST_READ_UINT16_BE (sy + i) << (16 - info->bits);\n+      U = GST_READ_UINT16_BE (su + (i >> 1)) << (16 - info->bits);\n+      V = GST_READ_UINT16_BE (sv + (i >> 1)) << (16 - info->bits);\n+    }\n@@ -4510,4 +4535,4 @@\n-      A |= (A >> 10);\n-      Y |= (Y >> 10);\n-      U |= (U >> 10);\n-      V |= (V >> 10);\n+      A |= (A >> info->bits);\n+      Y |= (Y >> info->bits);\n+      U |= (U >> info->bits);\n+      V |= (V >> info->bits);\n@@ -4520,1 +4545,0 @@\n-\n@@ -4530,1 +4554,1 @@\n-pack_A420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+pack_A420_16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4545,14 +4569,23 @@\n-    for (i = 0; i < width - 1; i += 2) {\n-      A0 = s[i * 4 + 0] >> 6;\n-      Y0 = s[i * 4 + 1] >> 6;\n-      A1 = s[i * 4 + 4] >> 6;\n-      Y1 = s[i * 4 + 5] >> 6;\n-      U = s[i * 4 + 2] >> 6;\n-      V = s[i * 4 + 3] >> 6;\n-\n-      GST_WRITE_UINT16_BE (da + i + 0, A0);\n-      GST_WRITE_UINT16_BE (dy + i + 0, Y0);\n-      GST_WRITE_UINT16_BE (da + i + 1, A1);\n-      GST_WRITE_UINT16_BE (dy + i + 1, Y1);\n-      GST_WRITE_UINT16_BE (du + (i >> 1), U);\n-      GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+    for (i = 0; i < width - 1; i += 2) {\n+      A0 = s[i * 4 + 0] >> (16 - info->bits);\n+      Y0 = s[i * 4 + 1] >> (16 - info->bits);\n+      A1 = s[i * 4 + 4] >> (16 - info->bits);\n+      Y1 = s[i * 4 + 5] >> (16 - info->bits);\n+      U = s[i * 4 + 2] >> (16 - info->bits);\n+      V = s[i * 4 + 3] >> (16 - info->bits);\n+\n+      if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+        GST_WRITE_UINT16_LE (da + i + 0, A0);\n+        GST_WRITE_UINT16_LE (dy + i + 0, Y0);\n+        GST_WRITE_UINT16_LE (da + i + 1, A1);\n+        GST_WRITE_UINT16_LE (dy + i + 1, Y1);\n+        GST_WRITE_UINT16_LE (du + (i >> 1), U);\n+        GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n+      } else {\n+        GST_WRITE_UINT16_BE (da + i + 0, A0);\n+        GST_WRITE_UINT16_BE (dy + i + 0, Y0);\n+        GST_WRITE_UINT16_BE (da + i + 1, A1);\n+        GST_WRITE_UINT16_BE (dy + i + 1, Y1);\n+        GST_WRITE_UINT16_BE (du + (i >> 1), U);\n+        GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+      }\n@@ -4561,9 +4594,15 @@\n-      A0 = s[i * 4 + 0] >> 6;\n-      Y0 = s[i * 4 + 1] >> 6;\n-      U = s[i * 4 + 2] >> 6;\n-      V = s[i * 4 + 3] >> 6;\n-\n-      GST_WRITE_UINT16_BE (da + i, A0);\n-      GST_WRITE_UINT16_BE (dy + i, Y0);\n-      GST_WRITE_UINT16_BE (du + (i >> 1), U);\n-      GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+      A0 = s[i * 4 + 0] >> (16 - info->bits);\n+      Y0 = s[i * 4 + 1] >> (16 - info->bits);\n+      U = s[i * 4 + 2] >> (16 - info->bits);\n+      V = s[i * 4 + 3] >> (16 - info->bits);\n+      if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+        GST_WRITE_UINT16_LE (da + i, A0);\n+        GST_WRITE_UINT16_LE (dy + i, Y0);\n+        GST_WRITE_UINT16_LE (du + (i >> 1), U);\n+        GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n+      } else {\n+        GST_WRITE_UINT16_BE (da + i, A0);\n+        GST_WRITE_UINT16_BE (dy + i, Y0);\n+        GST_WRITE_UINT16_BE (du + (i >> 1), U);\n+        GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+      }\n@@ -4573,4 +4612,9 @@\n-      A0 = s[i * 4 + 0] >> 6;\n-      Y0 = s[i * 4 + 1] >> 6;\n-      GST_WRITE_UINT16_BE (da + i, A0);\n-      GST_WRITE_UINT16_BE (dy + i, Y0);\n+      A0 = s[i * 4 + 0] >> (16 - info->bits);\n+      Y0 = s[i * 4 + 1] >> (16 - info->bits);\n+      if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+        GST_WRITE_UINT16_LE (da + i, A0);\n+        GST_WRITE_UINT16_LE (dy + i, Y0);\n+      } else {\n+        GST_WRITE_UINT16_BE (da + i, A0);\n+        GST_WRITE_UINT16_BE (dy + i, Y0);\n+      }\n@@ -4581,1 +4625,8 @@\n-#define PACK_A422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A422_10LE, 1, pack_A422_10LE\n+#define PACK_A420_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A420_16, 1, pack_A420_16\n+#define PACK_A420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A420_16, 1, pack_A420_16\n+#define PACK_A420_12LE GST_VIDEO_FORMAT_AYUV64, unpack_A420_16, 1, pack_A420_16\n+#define PACK_A420_12BE GST_VIDEO_FORMAT_AYUV64, unpack_A420_16, 1, pack_A420_16\n+#define PACK_A420_16LE GST_VIDEO_FORMAT_AYUV64, unpack_A420_16, 1, pack_A420_16\n+#define PACK_A420_16BE GST_VIDEO_FORMAT_AYUV64, unpack_A420_16, 1, pack_A420_16\n+\n+#define PACK_A422 GST_VIDEO_FORMAT_AYUV, unpack_A422, 1, pack_A422\n@@ -4583,1 +4634,1 @@\n-unpack_A422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+unpack_A422 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4588,5 +4639,5 @@\n-  const guint16 *restrict sa = GET_A_LINE (y);\n-  const guint16 *restrict sy = GET_Y_LINE (y);\n-  const guint16 *restrict su = GET_U_LINE (y);\n-  const guint16 *restrict sv = GET_V_LINE (y);\n-  guint16 *restrict d = dest, A, Y, U, V;\n+  const guint8 *restrict sa = GET_A_LINE (y);\n+  const guint8 *restrict sy = GET_Y_LINE (y);\n+  const guint8 *restrict su = GET_U_LINE (y);\n+  const guint8 *restrict sv = GET_V_LINE (y);\n+  guint8 *restrict d = dest, A, Y, U, V;\n@@ -4600,11 +4651,4 @@\n-    A = GST_READ_UINT16_LE (sa + i) << 6;\n-    Y = GST_READ_UINT16_LE (sy + i) << 6;\n-    U = GST_READ_UINT16_LE (su + (i >> 1)) << 6;\n-    V = GST_READ_UINT16_LE (sv + (i >> 1)) << 6;\n-\n-    if (!(flags & GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {\n-      A |= (A >> 10);\n-      Y |= (Y >> 10);\n-      U |= (U >> 10);\n-      V |= (V >> 10);\n-    }\n+    A = sa[i];\n+    Y = sy[i];\n+    U = su[(i >> 1)];\n+    V = sv[(i >> 1)];\n@@ -4626,1 +4670,1 @@\n-pack_A422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+pack_A422 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4632,6 +4676,6 @@\n-  guint16 *restrict da = GET_A_LINE (y);\n-  guint16 *restrict dy = GET_Y_LINE (y);\n-  guint16 *restrict du = GET_U_LINE (y);\n-  guint16 *restrict dv = GET_V_LINE (y);\n-  guint16 A0, Y0, A1, Y1, U, V;\n-  const guint16 *restrict s = src;\n+  guint8 *restrict da = GET_A_LINE (y);\n+  guint8 *restrict dy = GET_Y_LINE (y);\n+  guint8 *restrict du = GET_U_LINE (y);\n+  guint8 *restrict dv = GET_V_LINE (y);\n+  guint8 A0, Y0, A1, Y1, U, V;\n+  const guint8 *restrict s = src;\n@@ -4640,6 +4684,6 @@\n-    A0 = s[i * 4 + 0] >> 6;\n-    Y0 = s[i * 4 + 1] >> 6;\n-    A1 = s[i * 4 + 4] >> 6;\n-    Y1 = s[i * 4 + 5] >> 6;\n-    U = s[i * 4 + 2] >> 6;\n-    V = s[i * 4 + 3] >> 6;\n+    A0 = s[i * 4 + 0];\n+    Y0 = s[i * 4 + 1];\n+    A1 = s[i * 4 + 4];\n+    Y1 = s[i * 4 + 5];\n+    U = s[i * 4 + 2];\n+    V = s[i * 4 + 3];\n@@ -4647,6 +4691,6 @@\n-    GST_WRITE_UINT16_LE (da + i + 0, A0);\n-    GST_WRITE_UINT16_LE (dy + i + 0, Y0);\n-    GST_WRITE_UINT16_LE (da + i + 1, A1);\n-    GST_WRITE_UINT16_LE (dy + i + 1, Y1);\n-    GST_WRITE_UINT16_LE (du + (i >> 1), U);\n-    GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n+    da[i + 0] = A0;\n+    dy[i + 0] = Y0;\n+    da[i + 1] = A1;\n+    dy[i + 1] = Y1;\n+    du[i >> 1] = U;\n+    dv[i >> 1] = V;\n@@ -4655,4 +4699,4 @@\n-    A0 = s[i * 4 + 0] >> 6;\n-    Y0 = s[i * 4 + 1] >> 6;\n-    U = s[i * 4 + 2] >> 6;\n-    V = s[i * 4 + 3] >> 6;\n+    A0 = s[i * 4 + 0];\n+    Y0 = s[i * 4 + 1];\n+    U = s[i * 4 + 2];\n+    V = s[i * 4 + 3];\n@@ -4660,4 +4704,4 @@\n-    GST_WRITE_UINT16_LE (da + i, A0);\n-    GST_WRITE_UINT16_LE (dy + i, Y0);\n-    GST_WRITE_UINT16_LE (du + (i >> 1), U);\n-    GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n+    da[i + 0] = A0;\n+    dy[i + 0] = Y0;\n+    du[i >> 1] = U;\n+    dv[i >> 1] = V;\n@@ -4667,1 +4711,0 @@\n-#define PACK_A422_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A422_10BE, 1, pack_A422_10BE\n@@ -4669,1 +4712,1 @@\n-unpack_A422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+unpack_A422_16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4686,4 +4729,11 @@\n-    A = GST_READ_UINT16_BE (sa + i) << 6;\n-    Y = GST_READ_UINT16_BE (sy + i) << 6;\n-    U = GST_READ_UINT16_BE (su + (i >> 1)) << 6;\n-    V = GST_READ_UINT16_BE (sv + (i >> 1)) << 6;\n+    if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+      A = GST_READ_UINT16_LE (sa + i) << (16 - info->bits);\n+      Y = GST_READ_UINT16_LE (sy + i) << (16 - info->bits);\n+      U = GST_READ_UINT16_LE (su + (i >> 1)) << (16 - info->bits);\n+      V = GST_READ_UINT16_LE (sv + (i >> 1)) << (16 - info->bits);\n+    } else {\n+      A = GST_READ_UINT16_BE (sa + i) << (16 - info->bits);\n+      Y = GST_READ_UINT16_BE (sy + i) << (16 - info->bits);\n+      U = GST_READ_UINT16_BE (su + (i >> 1)) << (16 - info->bits);\n+      V = GST_READ_UINT16_BE (sv + (i >> 1)) << (16 - info->bits);\n+    }\n@@ -4692,4 +4742,4 @@\n-      A |= (A >> 10);\n-      Y |= (Y >> 10);\n-      U |= (U >> 10);\n-      V |= (V >> 10);\n+      A |= (A >> info->bits);\n+      Y |= (Y >> info->bits);\n+      U |= (U >> info->bits);\n+      V |= (V >> info->bits);\n@@ -4712,1 +4762,1 @@\n-pack_A422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+pack_A422_16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4726,13 +4776,22 @@\n-    A0 = s[i * 4 + 0] >> 6;\n-    Y0 = s[i * 4 + 1] >> 6;\n-    A1 = s[i * 4 + 4] >> 6;\n-    Y1 = s[i * 4 + 5] >> 6;\n-    U = s[i * 4 + 2] >> 6;\n-    V = s[i * 4 + 3] >> 6;\n-\n-    GST_WRITE_UINT16_BE (da + i + 0, A0);\n-    GST_WRITE_UINT16_BE (dy + i + 0, Y0);\n-    GST_WRITE_UINT16_BE (da + i + 1, A1);\n-    GST_WRITE_UINT16_BE (dy + i + 1, Y1);\n-    GST_WRITE_UINT16_BE (du + (i >> 1), U);\n-    GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+    A0 = s[i * 4 + 0] >> (16 - info->bits);\n+    Y0 = s[i * 4 + 1] >> (16 - info->bits);\n+    A1 = s[i * 4 + 4] >> (16 - info->bits);\n+    Y1 = s[i * 4 + 5] >> (16 - info->bits);\n+    U = s[i * 4 + 2] >> (16 - info->bits);\n+    V = s[i * 4 + 3] >> (16 - info->bits);\n+\n+    if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+      GST_WRITE_UINT16_LE (da + i + 0, A0);\n+      GST_WRITE_UINT16_LE (dy + i + 0, Y0);\n+      GST_WRITE_UINT16_LE (da + i + 1, A1);\n+      GST_WRITE_UINT16_LE (dy + i + 1, Y1);\n+      GST_WRITE_UINT16_LE (du + (i >> 1), U);\n+      GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n+    } else {\n+      GST_WRITE_UINT16_BE (da + i + 0, A0);\n+      GST_WRITE_UINT16_BE (dy + i + 0, Y0);\n+      GST_WRITE_UINT16_BE (da + i + 1, A1);\n+      GST_WRITE_UINT16_BE (dy + i + 1, Y1);\n+      GST_WRITE_UINT16_BE (du + (i >> 1), U);\n+      GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+    }\n@@ -4740,0 +4799,1 @@\n+\n@@ -4741,4 +4801,4 @@\n-    A0 = s[i * 4 + 0] >> 6;\n-    Y0 = s[i * 4 + 1] >> 6;\n-    U = s[i * 4 + 2] >> 6;\n-    V = s[i * 4 + 3] >> 6;\n+    A0 = s[i * 4 + 0] >> (16 - info->bits);\n+    Y0 = s[i * 4 + 1] >> (16 - info->bits);\n+    U = s[i * 4 + 2] >> (16 - info->bits);\n+    V = s[i * 4 + 3] >> (16 - info->bits);\n@@ -4746,4 +4806,11 @@\n-    GST_WRITE_UINT16_BE (da + i, A0);\n-    GST_WRITE_UINT16_BE (dy + i, Y0);\n-    GST_WRITE_UINT16_BE (du + (i >> 1), U);\n-    GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+    if (info->flags & GST_VIDEO_FORMAT_FLAG_LE) {\n+      GST_WRITE_UINT16_LE (da + i, A0);\n+      GST_WRITE_UINT16_LE (dy + i, Y0);\n+      GST_WRITE_UINT16_LE (du + (i >> 1), U);\n+      GST_WRITE_UINT16_LE (dv + (i >> 1), V);\n+    } else {\n+      GST_WRITE_UINT16_BE (da + i, A0);\n+      GST_WRITE_UINT16_BE (dy + i, Y0);\n+      GST_WRITE_UINT16_BE (du + (i >> 1), U);\n+      GST_WRITE_UINT16_BE (dv + (i >> 1), V);\n+    }\n@@ -4753,0 +4820,8 @@\n+#define PACK_A422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A422_16, 1, pack_A422_16\n+#define PACK_A422_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A422_16, 1, pack_A422_16\n+#define PACK_A422_12LE GST_VIDEO_FORMAT_AYUV64, unpack_A422_16, 1, pack_A422_16\n+#define PACK_A422_12BE GST_VIDEO_FORMAT_AYUV64, unpack_A422_16, 1, pack_A422_16\n+#define PACK_A422_16LE GST_VIDEO_FORMAT_AYUV64, unpack_A422_16, 1, pack_A422_16\n+#define PACK_A422_16BE GST_VIDEO_FORMAT_AYUV64, unpack_A422_16, 1, pack_A422_16\n+\n+\/* Helpers for the most common tile format *\/\n@@ -4783,3 +4858,3 @@\n-#define PACK_NV12_TILED GST_VIDEO_FORMAT_AYUV, unpack_NV12_TILED, 1, pack_NV12_TILED\n-static void\n-unpack_NV12_TILED (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+static inline void\n+unpack_TILED (GstVideoFormat inner_format,\n+    const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4799,1 +4874,1 @@\n-  tile_finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);\n+  tile_finfo = gst_video_format_get_info (inner_format);\n@@ -4824,1 +4899,1 @@\n-    \/* the number of bytes left to unpack *\/\n+    \/* the number of pixels left to unpack *\/\n@@ -4836,2 +4911,3 @@\n-static void\n-pack_NV12_TILED (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+static inline void\n+pack_TILED (GstVideoFormat inner_format,\n+    const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n@@ -4852,1 +4928,1 @@\n-  tile_finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);\n+  tile_finfo = gst_video_format_get_info (inner_format);\n@@ -4884,0 +4960,21 @@\n+#define PACK_NV12_TILED GST_VIDEO_FORMAT_AYUV, unpack_NV12_TILED, 1, pack_NV12_TILED\n+static void\n+unpack_NV12_TILED (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  unpack_TILED (GST_VIDEO_FORMAT_NV12, info, flags, dest, data, stride,\n+      x, y, width);\n+}\n+\n+static void\n+pack_NV12_TILED (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  pack_TILED (GST_VIDEO_FORMAT_NV12, info, flags, src, sstride, data, stride,\n+      chroma_site, y, width);\n+}\n+\n+\n@@ -6893,0 +6990,352 @@\n+#define PACK_NV12_10LE40_TILED  GST_VIDEO_FORMAT_AYUV64, unpack_NV12_10LE40_TILED, 1, pack_NV12_10LE40_TILED\n+static void\n+unpack_NV12_10LE40_TILED (const GstVideoFormatInfo * info,\n+    GstVideoPackFlags flags, gpointer dest,\n+    const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  unpack_TILED (GST_VIDEO_FORMAT_NV12_10LE40, info, flags, dest, data, stride,\n+      x, y, width);\n+}\n+\n+static void\n+pack_NV12_10LE40_TILED (const GstVideoFormatInfo * info,\n+    GstVideoPackFlags flags, const gpointer src, gint sstride,\n+    gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  pack_TILED (GST_VIDEO_FORMAT_NV12_10LE40, info, flags, src, sstride, data,\n+      stride, chroma_site, y, width);\n+}\n+\n+#define PACK_MT2110T_TILED  GST_VIDEO_FORMAT_AYUV64, unpack_MT2110T, 1, pack_MT2110T\n+\n+static void\n+unpack_MT2110T (const GstVideoFormatInfo * info,\n+    GstVideoPackFlags flags, gpointer dest,\n+    const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  const gsize TILE_SIZE = 640;\n+  guint16 *restrict d = dest;\n+\n+  \/* TODO not supported yet *\/\n+  g_assert (x == 0);\n+\n+  \/* Position in the partition grid *\/\n+  guint ty = y \/ 32;\n+  guint tx;\n+\n+  \/* Vertical position within the tile *\/\n+  gint tile_y = y % 32;\n+\n+  \/* Tiles are split into partitions of 16 bytes of lower 2bit and 64 bytes\n+   * of higher 8 bits. It contains 64 pixels, so 4 lines per parititons. The\n+   * chroma tiles have half the number of parititons. *\/\n+  gint partition_luma = tile_y \/ 4;\n+  gint partition_chroma = partition_luma \/ 2;\n+  gint partition_line_luma = tile_y % 4;\n+  gint partition_line_chroma = (tile_y \/ 2) % 4;\n+  gint partition_skip_luma = partition_luma * 80;\n+  gint partition_skip_chroma = partition_chroma * 80;\n+\n+  for (tx = 0; tx < (width \/ 16); tx++) {\n+    const guint8 *y_tile = data[0];\n+    const guint8 *uv_tile = data[1];\n+    gsize offset;\n+    gint tile_x;\n+    gint num_pixels = MIN (16, width - (tx * 16));\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[0]),\n+        GST_VIDEO_TILE_Y_TILES (stride[0])) * TILE_SIZE;\n+    y_tile = y_tile + offset + partition_skip_luma;\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[1]),\n+        GST_VIDEO_TILE_Y_TILES (stride[1])) * (TILE_SIZE \/ 2);\n+    uv_tile = uv_tile + offset + partition_skip_chroma;\n+\n+    for (tile_x = 0; tile_x < num_pixels; tile_x++) {\n+      guint high_i = partition_line_luma * 16 + tile_x;\n+      guint low_i = tile_x;\n+      guint low_shift = partition_line_luma * 2;\n+      guint low_mask = 0x03 << low_shift;\n+      guint low_y = (y_tile[low_i] & low_mask) >> low_shift;\n+      guint16 Y = (y_tile[16 + high_i] << 2) | low_y;\n+\n+      high_i = partition_line_chroma * 16 + GST_ROUND_DOWN_2 (tile_x);\n+      low_i = GST_ROUND_DOWN_2 (tile_x);\n+      low_shift = partition_line_chroma * 2;\n+      low_mask = 0x03 << low_shift;\n+      guint low_u = (uv_tile[low_i] & low_mask) >> low_shift;\n+      guint low_v = (uv_tile[low_i + 1] & low_mask) >> low_shift;\n+      guint16 U = (uv_tile[16 + high_i] << 2) | low_u;\n+      guint16 V = (uv_tile[16 + high_i + 1] << 2) | low_v;\n+\n+      d[0] = 0xffff;\n+      d[1] = Y << 6;\n+      d[2] = U << 6;\n+      d[3] = V << 6;\n+      d += 4;\n+    }\n+  }\n+}\n+\n+static void\n+pack_MT2110T (const GstVideoFormatInfo * info,\n+    GstVideoPackFlags flags, const gpointer src, gint sstride,\n+    gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  const gsize TILE_SIZE = 640;\n+  const guint16 *restrict s = src;\n+\n+  \/* Position in the partition grid *\/\n+  guint ty = y \/ 32;\n+  guint tx;\n+\n+  \/* Vertical position within the tile *\/\n+  gint tile_y = y % 32;\n+\n+  \/* Tiles are split into paritions of 16 bytes of lower 2bit and 64 bytes\n+   * of higher 8 bits. It contains 64 pixels, so 4 lines per parititons. The\n+   * chroma tiles have half the number of parititons. *\/\n+  gint partition_luma = tile_y \/ 4;\n+  gint partition_chroma = partition_luma \/ 2;\n+  gint partition_line_luma = tile_y % 4;\n+  gint partition_line_chroma = (tile_y \/ 2) % 4;\n+  gint partition_skip_luma = partition_luma * 80;\n+  gint partition_skip_chroma = partition_chroma * 80;\n+\n+  for (tx = 0; tx < (width \/ 16); tx++) {\n+    guint8 *y_tile = data[0];\n+    guint8 *uv_tile = data[1];\n+    gsize offset;\n+    gint tile_x;\n+    gint num_pixels = MIN (16, width - (tx * 16));\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[0]),\n+        GST_VIDEO_TILE_Y_TILES (stride[0])) * TILE_SIZE;\n+    y_tile = y_tile + offset + partition_skip_luma;\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[1]),\n+        GST_VIDEO_TILE_Y_TILES (stride[1])) * (TILE_SIZE \/ 2);\n+    uv_tile = uv_tile + offset + partition_skip_chroma;\n+\n+    for (tile_x = 0; tile_x < num_pixels; tile_x++) {\n+      const guint16 Y = s[1] >> 6;\n+      const guint16 U = s[2] >> 6;\n+      const guint16 V = s[3] >> 6;\n+\n+      guint high_i = partition_line_luma * 16 + tile_x;\n+      guint low_i = tile_x;\n+      guint low_shift = partition_line_luma * 2;\n+      guint low_mask = 0x03 << low_shift;\n+\n+      y_tile[low_i] = (y_tile[low_i] & ~low_mask) | ((Y & 0x03) << low_shift);\n+      y_tile[16 + high_i] = Y >> 2;\n+\n+      if (IS_CHROMA_LINE_420 (y, flags) && (tile_x & 1) == 0) {\n+        high_i = partition_line_chroma * 16 + GST_ROUND_DOWN_2 (tile_x);\n+        low_i = GST_ROUND_DOWN_2 (tile_x);\n+        low_shift = partition_line_chroma * 2;\n+        low_mask = 0x03 << low_shift;\n+\n+        uv_tile[low_i] =\n+            (uv_tile[low_i] & ~low_mask) | ((U & 0x03) << low_shift);\n+        uv_tile[low_i + 1] =\n+            (uv_tile[low_i + 1] & ~low_mask) | ((V & 0x03) << low_shift);\n+        uv_tile[16 + high_i] = U >> 2;\n+        uv_tile[16 + high_i + 1] = V >> 2;\n+      }\n+\n+      s += 4;\n+    }\n+  }\n+}\n+\n+#define PACK_MT2110R_TILED  GST_VIDEO_FORMAT_AYUV64, unpack_MT2110R, 1, pack_MT2110R\n+\n+static void\n+unpack_MT2110R (const GstVideoFormatInfo * info,\n+    GstVideoPackFlags flags, gpointer dest,\n+    const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  const gsize TILE_SIZE = 640;\n+  guint16 *restrict d = dest;\n+\n+  \/* TODO not supported yet *\/\n+  g_assert (x == 0);\n+\n+  \/* Position in the partition grid *\/\n+  guint ty = y \/ 32;\n+  guint tx;\n+\n+  \/* Vertical position within the tile *\/\n+  gint tile_y = y % 32;\n+\n+  \/* Tiles are split into partitions of 16 bytes of lower 2bit and 64 bytes\n+   * of higher 8 bits. It contains 64 pixels, so 4 lines per parititons. The\n+   * chroma tiles have half the number of parititons. *\/\n+  gint partition_luma = tile_y \/ 4;\n+  gint partition_chroma = partition_luma \/ 2;\n+  gint partition_line_luma = tile_y % 4;\n+  gint partition_line_chroma = (tile_y \/ 2) % 4;\n+  gint partition_skip_luma = partition_luma * 80;\n+  gint partition_skip_chroma = partition_chroma * 80;\n+\n+  for (tx = 0; tx < (width \/ 16); tx++) {\n+    const guint8 *y_tile = data[0];\n+    const guint8 *uv_tile = data[1];\n+    gsize offset;\n+    gint tile_x;\n+    gint num_pixels = MIN (16, width - (tx * 16));\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[0]),\n+        GST_VIDEO_TILE_Y_TILES (stride[0])) * TILE_SIZE;\n+    y_tile = y_tile + offset + partition_skip_luma;\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[1]),\n+        GST_VIDEO_TILE_Y_TILES (stride[1])) * (TILE_SIZE \/ 2);\n+    uv_tile = uv_tile + offset + partition_skip_chroma;\n+\n+    for (tile_x = 0; tile_x < num_pixels; tile_x++) {\n+      guint high_i = partition_line_luma * 16 + tile_x;\n+      guint low_i = partition_line_luma * 4 + tile_x \/ 4;\n+      guint low_shift = tile_x % 4 * 2;\n+      guint low_mask = 0x03 << low_shift;\n+      guint low_y = (y_tile[low_i] & low_mask) >> low_shift;\n+      guint16 Y = (y_tile[16 + high_i] << 2) | low_y;\n+\n+      high_i = partition_line_chroma * 16 + GST_ROUND_DOWN_2 (tile_x);\n+      low_i = partition_line_chroma * 4 + tile_x \/ 4;\n+      low_shift = GST_ROUND_DOWN_2 (tile_x % 4) * 2;\n+      low_mask = 0x03 << low_shift;\n+      guint low_u = (uv_tile[low_i] & low_mask) >> low_shift;\n+      guint low_v = (uv_tile[low_i] & (low_mask << 2)) >> (low_shift + 2);\n+      guint16 U = (uv_tile[16 + high_i] << 2) | low_u;\n+      guint16 V = (uv_tile[16 + high_i + 1] << 2) | low_v;\n+\n+      d[0] = 0xffff;\n+      d[1] = Y << 6;\n+      d[2] = U << 6;\n+      d[3] = V << 6;\n+      d += 4;\n+    }\n+  }\n+}\n+\n+static void\n+pack_MT2110R (const GstVideoFormatInfo * info,\n+    GstVideoPackFlags flags, const gpointer src, gint sstride,\n+    gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  const gsize TILE_SIZE = 640;\n+  const guint16 *restrict s = src;\n+\n+  \/* Position in the partition grid *\/\n+  guint ty = y \/ 32;\n+  guint tx;\n+\n+  \/* Vertical position within the tile *\/\n+  gint tile_y = y % 32;\n+\n+  \/* Tiles are split into paritions of 16 bytes of lower 2bit and 64 bytes\n+   * of higher 8 bits. It contains 64 pixels, so 4 lines per parititons. The\n+   * chroma tiles have half the number of parititons. *\/\n+  gint partition_luma = tile_y \/ 4;\n+  gint partition_chroma = partition_luma \/ 2;\n+  gint partition_line_luma = tile_y % 4;\n+  gint partition_line_chroma = (tile_y \/ 2) % 4;\n+  gint partition_skip_luma = partition_luma * 80;\n+  gint partition_skip_chroma = partition_chroma * 80;\n+\n+  for (tx = 0; tx < (width \/ 16); tx++) {\n+    guint8 *y_tile = data[0];\n+    guint8 *uv_tile = data[1];\n+    gsize offset;\n+    gint tile_x;\n+    gint num_pixels = MIN (16, width - (tx * 16));\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[0]),\n+        GST_VIDEO_TILE_Y_TILES (stride[0])) * TILE_SIZE;\n+    y_tile = y_tile + offset + partition_skip_luma;\n+\n+    offset = gst_video_tile_get_index (info->tile_mode, tx, ty,\n+        GST_VIDEO_TILE_X_TILES (stride[1]),\n+        GST_VIDEO_TILE_Y_TILES (stride[1])) * (TILE_SIZE \/ 2);\n+    uv_tile = uv_tile + offset + partition_skip_chroma;\n+\n+    for (tile_x = 0; tile_x < num_pixels; tile_x++) {\n+      const guint16 Y = s[1] >> 6;\n+      const guint16 U = s[2] >> 6;\n+      const guint16 V = s[3] >> 6;\n+\n+      guint high_i = partition_line_luma * 16 + tile_x;\n+      guint low_i = partition_line_luma * 4 + tile_x \/ 4;\n+      guint low_shift = tile_x % 4 * 2;\n+      guint low_mask = 0x03 << low_shift;\n+\n+      y_tile[low_i] = (y_tile[low_i] & ~low_mask) | ((Y & 0x03) << low_shift);\n+      y_tile[16 + high_i] = Y >> 2;\n+\n+      if (IS_CHROMA_LINE_420 (y, flags) && (tile_x & 1) == 0) {\n+        high_i = partition_line_chroma * 16 + GST_ROUND_DOWN_2 (tile_x);\n+        low_i = partition_line_chroma * 4 + tile_x \/ 4;\n+        low_shift = GST_ROUND_DOWN_2 (tile_x % 4) * 2;\n+        low_mask = 0x0f << low_shift;\n+\n+        uv_tile[low_i] = (uv_tile[low_i] & ~(low_mask)) |\n+            ((U & 0x03) << low_shift) | ((V & 0x03) << (low_shift + 2));\n+        uv_tile[16 + high_i] = U >> 2;\n+        uv_tile[16 + high_i + 1] = V >> 2;\n+      }\n+\n+      s += 4;\n+    }\n+  }\n+}\n+\n+#define PACK_RBGA GST_VIDEO_FORMAT_ARGB, unpack_RBGA, 1, pack_RBGA\n+static void\n+unpack_RBGA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  const guint8 *restrict s = GET_LINE (y);\n+\n+  s += x * 4;\n+\n+#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n+  video_orc_unpack_RBGA_le (dest, s, width);\n+#else\n+  video_orc_unpack_RBGA_be (dest, s, width);\n+#endif\n+}\n+\n+static void\n+pack_RBGA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  guint8 *restrict d = GET_LINE (y);\n+\n+#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n+  video_orc_pack_RBGA_le (d, src, width);\n+#else\n+  video_orc_pack_RBGA_be (d, src, width);\n+#endif\n+}\n+\n@@ -6962,0 +7411,1 @@\n+#define OFFS0213          { 0, 2, 1, 3 }\n@@ -6987,5 +7437,6 @@\n-#define TILE_4x4(mode) GST_VIDEO_TILE_MODE_ ##mode, 2, 2, { {4, 4, 4, 16}, {4, 4, 4, 16}, }\n-#define TILE_16x32s(mode) GST_VIDEO_TILE_MODE_ ##mode, 4, 5, { {16, 32, 16, 512}, {16, 16, 16, 256}, }\n-#define TILE_32x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 5, 5, { {32, 32, 32, 1024}, {32, 32, 32, 1024}, }\n-#define TILE_64x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 6, 5, { {64, 32, 64, 2048}, {64, 32, 64, 2048}, }\n-#define TILE_8x128(mode) GST_VIDEO_TILE_MODE_ ##mode, 3, 7, { {8, 128, 8, 1024}, {8, 128, 8, 1024}, }\n+#define TILE_4x4(mode) GST_VIDEO_TILE_MODE_ ##mode, 2, 2, { {4, 4, 4, 16}, {2, 4, 4, 16}, }\n+#define TILE_16x32s(mode) GST_VIDEO_TILE_MODE_ ##mode, 4, 5, { {16, 32, 16, 512}, {8, 16, 16, 256}, }\n+#define TILE_32x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 5, 5, { {32, 32, 32, 1024}, {16, 32, 32, 1024}, }\n+#define TILE_64x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 6, 5, { {64, 32, 64, 2048}, {32, 32, 64, 2048}, }\n+#define TILE_8x128(mode) GST_VIDEO_TILE_MODE_ ##mode, 3, 7, { {8, 128, 8, 1024}, {4, 128, 8, 1024}, }\n+#define TILE_10bit_16x32s(mode) GST_VIDEO_TILE_MODE_ ##mode, 4, 5, { {16, 32, 20, 640}, {8, 16, 20, 320}, }\n@@ -6993,0 +7444,1 @@\n+#define TILE_10bit_4x4(mode) GST_VIDEO_TILE_MODE_ ##mode, 2, 2, { {4, 4, 5, 20}, {2, 4, 5, 20}, }\n@@ -7300,0 +7752,45 @@\n+  MAKE_YUV_T_FORMAT (NV12_10LE40_4L4, \"raw video\",\n+      GST_MAKE_FOURCC ('M', 'H', '2', '1'), DPTH10_10_10, PSTR0, PLANE011,\n+      OFFS001, SUB420, PACK_NV12_10LE40_TILED, TILE_10bit_4x4 (LINEAR)),\n+  {0x00000000, {GST_VIDEO_FORMAT_DMA_DRM, \"DMA_DRM\", \"DMA DRM video\",\n+          GST_VIDEO_FORMAT_FLAG_COMPLEX, DPTH0, PSTR0, PLANE_NA, OFFS0}},\n+  MAKE_YUV_ST_FORMAT (MT2110T, \"raw video\",\n+      GST_MAKE_FOURCC ('M', 'T', '2', 'T'), DPTH10_10_10, PSTR0, PLANE011,\n+      OFFS001, SUB420, PACK_MT2110T_TILED, TILE_10bit_16x32s (LINEAR)),\n+  MAKE_YUV_ST_FORMAT (MT2110R, \"raw video\",\n+      GST_MAKE_FOURCC ('M', 'T', '2', 'R'), DPTH10_10_10, PSTR0, PLANE011,\n+      OFFS001, SUB420, PACK_MT2110R_TILED, TILE_10bit_16x32s (LINEAR)),\n+  MAKE_YUVA_FORMAT (A422, \"raw video\", GST_MAKE_FOURCC ('A', '4', '2', '2'),\n+      DPTH8888, PSTR1111, PLANE0123, OFFS0, SUB4224, PACK_A422),\n+  MAKE_YUVA_FORMAT (A444, \"raw video\", GST_MAKE_FOURCC ('A', '4', '4', '4'),\n+      DPTH8888, PSTR1111, PLANE0123, OFFS0, SUB4444, PACK_A444),\n+  MAKE_YUVA_LE_FORMAT (A444_12LE, \"raw video\", 0x00000000, DPTH12_12_12_12,\n+      PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_12LE),\n+  MAKE_YUVA_FORMAT (A444_12BE, \"raw video\", 0x00000000, DPTH12_12_12_12,\n+      PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_12BE),\n+  MAKE_YUVA_LE_FORMAT (A422_12LE, \"raw video\", 0x00000000, DPTH12_12_12_12,\n+      PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_12LE),\n+  MAKE_YUVA_FORMAT (A422_12BE, \"raw video\", 0x00000000, DPTH12_12_12_12,\n+      PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_12BE),\n+  MAKE_YUVA_LE_FORMAT (A420_12LE, \"raw video\", 0x00000000, DPTH12_12_12_12,\n+      PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_12LE),\n+  MAKE_YUVA_FORMAT (A420_12BE, \"raw video\", 0x00000000, DPTH12_12_12_12,\n+      PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_12BE),\n+  MAKE_YUVA_LE_FORMAT (A444_16LE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_16LE),\n+  MAKE_YUVA_FORMAT (A444_16BE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_16BE),\n+  MAKE_YUVA_LE_FORMAT (A422_16LE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_16LE),\n+  MAKE_YUVA_FORMAT (A422_16BE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_16BE),\n+  MAKE_YUVA_LE_FORMAT (A420_16LE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_16LE),\n+  MAKE_YUVA_FORMAT (A420_16BE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_16BE),\n+  MAKE_RGB_LE_FORMAT (GBR_16LE, \"raw video\", DPTH16_16_16, PSTR222, PLANE201,\n+      OFFS0, SUB444, PACK_GBR_16LE),\n+  MAKE_RGB_FORMAT (GBR_16BE, \"raw video\", DPTH16_16_16, PSTR222, PLANE201,\n+      OFFS0, SUB444, PACK_GBR_16BE),\n+  MAKE_RGBA_FORMAT (RBGA, \"raw video\", DPTH8888, PSTR4444, PLANE0, OFFS0213,\n+      SUB4444, PACK_RBGA),\n@@ -7586,0 +8083,1 @@\n+\n@@ -7749,2 +8247,2 @@\n-static gpointer\n-generate_raw_video_formats (gpointer data)\n+static struct RawVideoFormats *\n+generate_video_formats (const gchar * formats)\n@@ -7762,1 +8260,1 @@\n-  tmp = g_strdup (GST_VIDEO_FORMATS_ALL);\n+  tmp = g_strdup (formats);\n@@ -7783,0 +8281,12 @@\n+static gpointer\n+generate_raw_video_formats (gpointer data)\n+{\n+  return generate_video_formats (GST_VIDEO_FORMATS_ALL);\n+}\n+\n+static gpointer\n+generate_any_video_formats (gpointer data)\n+{\n+  return generate_video_formats (GST_VIDEO_FORMATS_ANY);\n+}\n+\n@@ -7807,0 +8317,27 @@\n+\/**\n+ * gst_video_formats_any:\n+ * @len: (out): the number of elements in the returned array\n+ *\n+ * Return all the raw video formats supported by GStreamer including\n+ * special opaque formats such as %GST_VIDEO_FORMAT_DMA_DRM for which\n+ * no software conversion exists. This should be use for passthrough\n+ * template cpas.\n+ *\n+ * Returns: (transfer none) (array length=len): an array of #GstVideoFormat\n+ * Since: 1.24\n+ *\/\n+const GstVideoFormat *\n+gst_video_formats_any (guint * len)\n+{\n+  static GOnce any_video_formats_once = G_ONCE_INIT;\n+  struct RawVideoFormats *all;\n+\n+  g_return_val_if_fail (len, NULL);\n+\n+  g_once (&any_video_formats_once, generate_any_video_formats, NULL);\n+\n+  all = any_video_formats_once.retval;\n+  *len = all->n;\n+  return all->formats;\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-format.c","additions":822,"deletions":285,"binary":false,"changes":1107,"status":"modified"},{"patch":"@@ -148,0 +148,24 @@\n+ * @GST_VIDEO_FORMAT_NV12_10LE40_4L4: @GST_VIDEO_FORMAT_NV12_10LE40 with 4x4 pixels tiles (5 bytes per tile row) (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_DMA_DRM: DMA DRM special format. It's only used with\n+ *                            memory:DMABuf #GstCapsFeatures, where an extra\n+ *                            parameter (drm-format) is required to define the\n+ *                            image format and its memory layout.\n+ * @GST_VIDEO_FORMAT_MT2110T : Mediatek 10bit NV12 little endian with 16x32 tiles in linear order, tiled 2 bits (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_MT2110R : Mediatek 10bit NV12 little endian with 16x32 tiles in linear order, raster 2 bits (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A422: planar 4:4:2:2 YUV, 8 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A444: planar 4:4:4:4 YUV, 8 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A444_12LE: planar 4:4:4:4 YUV, 12 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A444_12BE: planar 4:4:4:4 YUV, 12 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A422_12LE: planar 4:4:2:2 YUV, 12 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A422_12BE: planar 4:4:2:2 YUV, 12 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A420_12LE: planar 4:4:2:0 YUV, 12 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A420_12BE: planar 4:4:2:0 YUV, 12 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A444_16LE: planar 4:4:4:4 YUV, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A444_16BE: planar 4:4:4:4 YUV, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A422_16LE: planar 4:4:2:2 YUV, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A422_16BE: planar 4:4:2:2 YUV, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A420_16LE: planar 4:4:2:0 YUV, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_A420_16BE: planar 4:4:2:0 YUV, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_GBR_16LE: planar 4:4:4 RGB, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_GBR_16BE: planar 4:4:4 RGB, 16 bits per channel (Since: 1.24)\n+ * @GST_VIDEO_FORMAT_RBGA: packed RGB with alpha, 8 bits per channel (Since: 1.24)\n@@ -403,0 +427,195 @@\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_NV12_10LE40_4L4:\n+   *\n+   *  @GST_VIDEO_FORMAT_NV12_10LE40 with 4x4 pixels tiles (5 bytes\n+   *  per tile row). This format is produced by Verisilicon\/Hantro decoders.\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_NV12_10LE40_4L4,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_DMA_DRM:\n+   *\n+   * @GST_VIDEO_FORMAT_DMA_DRM represent the DMA DRM special format. It's\n+   * only used with memory:DMABuf #GstCapsFeatures, where an extra\n+   * parameter (drm-format) is required to define the image format and\n+   * its memory layout.\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_DMA_DRM,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_MT2110T:\n+   *\n+   * Mediatek 10bit NV12 little endian with 16x32 tiles in linear order, tile 2\n+   * bits.\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_MT2110T,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_MT2110R:\n+   *\n+   * Mediatek 10bit NV12 little endian with 16x32 tiles in linear order, raster\n+   * 2 bits.\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_MT2110R,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A422:\n+   *\n+   * planar 4:4:2:2 YUV, 8 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A422,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A444:\n+   *\n+   * planar 4:4:4:4 YUV, 8 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A444,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A444_12LE:\n+   *\n+   * planar 4:4:4:4 YUV, 12 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A444_12LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A444_12BE:\n+   *\n+   * planar 4:4:4:4 YUV, 12 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A444_12BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A422_12LE:\n+   *\n+   * planar 4:4:2:2 YUV, 12 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A422_12LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A422_12BE:\n+   *\n+   * planar 4:4:2:2 YUV, 12 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A422_12BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A420_12LE:\n+   *\n+   * planar 4:4:2:0 YUV, 12 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A420_12LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A420_12BE:\n+   *\n+   * planar 4:4:2:0 YUV, 12 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A420_12BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A444_16LE:\n+   *\n+   * planar 4:4:4:4 YUV, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A444_16LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A444_16BE:\n+   *\n+   * planar 4:4:4:4 YUV, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A444_16BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A422_16LE:\n+   *\n+   * planar 4:4:2:2 YUV, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A422_16LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A422_16BE:\n+   *\n+   * planar 4:4:2:2 YUV, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A422_16BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A420_16LE:\n+   *\n+   * planar 4:4:2:0 YUV, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A420_16LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_A420_16BE:\n+   *\n+   * planar 4:4:2:0 YUV, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_A420_16BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_GBR_16LE:\n+   *\n+   * planar 4:4:4 RGB, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_GBR_16LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_GBR_16BE:\n+   *\n+   * planar 4:4:4 RGB, 16 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_GBR_16BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_RBGA:\n+   *\n+   * packed RGB with alpha, 8 bits per channel\n+   *\n+   * Since: 1.24\n+   *\/\n+  GST_VIDEO_FORMAT_RBGA,\n@@ -850,1 +1069,1 @@\n- * GST_VIDEO_FORMATS_ALL:\n+ * GST_VIDEO_FORMATS_ALL_STR:\n@@ -852,1 +1071,1 @@\n- * List of all video formats, for use in template caps strings.\n+ * Declare all video formats as a string.\n@@ -867,0 +1086,2 @@\n+ *\n+ * Since: 1.24\n@@ -869,12 +1090,18 @@\n-#define GST_VIDEO_FORMATS_ALL \"{ ABGR64_BE, BGRA64_BE, AYUV64, ARGB64_BE, ARGB64, \" \\\n-    \"RGBA64_BE, ABGR64_LE, BGRA64_LE, ARGB64_LE, RGBA64_LE, GBRA_12BE, GBRA_12LE, Y412_BE, \" \\\n-    \"Y412_LE, A444_10BE, GBRA_10BE, A444_10LE, GBRA_10LE, A422_10BE, A422_10LE, \" \\\n-    \"A420_10BE, A420_10LE, Y410, RGB10A2_LE, BGR10A2_LE, GBRA, ABGR, VUYA, BGRA, \" \\\n-    \"AYUV, ARGB, RGBA, A420, AV12, Y444_16BE, Y444_16LE, v216, P016_BE, P016_LE, Y444_12BE, \" \\\n-    \"GBR_12BE, Y444_12LE, GBR_12LE, I422_12BE, I422_12LE, Y212_BE, Y212_LE, I420_12BE, \" \\\n-    \"I420_12LE, P012_BE, P012_LE, Y444_10BE, GBR_10BE, Y444_10LE, GBR_10LE, r210, \" \\\n-    \"I422_10BE, I422_10LE, NV16_10LE32, Y210, v210, UYVP, I420_10BE, I420_10LE, \" \\\n-    \"P010_10BE, P010_10LE, NV12_10LE32, NV12_10LE40, NV12_10BE_8L128, Y444, RGBP, GBR, BGRP, NV24, xBGR, BGRx, \" \\\n-    \"xRGB, RGBx, BGR, IYU2, v308, RGB, Y42B, NV61, NV16, VYUY, UYVY, YVYU, YUY2, I420, \" \\\n-    \"YV12, NV21, NV12, NV12_8L128, NV12_64Z32, NV12_4L4, NV12_32L32, NV12_16L32S, Y41B, IYU1, YVU9, YUV9, RGB16, \" \\\n-    \"BGR16, RGB15, BGR15, RGB8P, GRAY16_BE, GRAY16_LE, GRAY10_LE32, GRAY8 }\"\n+#define GST_VIDEO_FORMATS_ALL_STR \"A444_16BE, A444_16LE, AYUV64, ARGB64, \" \\\n+    \"RGBA64_BE, ARGB64_BE, BGRA64_BE, ABGR64_BE, RGBA64_LE, ARGB64_LE, \" \\\n+    \"BGRA64_LE, ABGR64_LE, A422_16BE, A422_16LE, A420_16BE, A420_16LE, \" \\\n+    \"A444_12BE, GBRA_12BE, A444_12LE, GBRA_12LE, Y412_BE, Y412_LE, A422_12BE, \" \\\n+    \"A422_12LE, A420_12BE, A420_12LE, A444_10BE, GBRA_10BE, A444_10LE, \" \\\n+    \"GBRA_10LE, A422_10BE, A422_10LE, A420_10BE, A420_10LE, Y410, BGR10A2_LE, \" \\\n+    \"RGB10A2_LE, A444, GBRA, AYUV, VUYA, RGBA, RBGA, ARGB, BGRA, ABGR, A422, \" \\\n+    \"A420, AV12, Y444_16BE, GBR_16BE, Y444_16LE, GBR_16LE, v216, P016_BE, \" \\\n+    \"P016_LE, Y444_12BE, GBR_12BE, Y444_12LE, GBR_12LE, I422_12BE, I422_12LE, \" \\\n+    \"Y212_BE, Y212_LE, I420_12BE, I420_12LE, P012_BE, P012_LE, Y444_10BE, \" \\\n+    \"GBR_10BE, Y444_10LE, GBR_10LE, r210, I422_10BE, I422_10LE, NV16_10LE32, \" \\\n+    \"Y210, UYVP, v210, I420_10BE, I420_10LE, P010_10BE, MT2110R, MT2110T, \" \\\n+    \"NV12_10BE_8L128, NV12_10LE40_4L4, P010_10LE, NV12_10LE40, NV12_10LE32, \" \\\n+    \"Y444, BGRP, GBR, RGBP, NV24, v308, IYU2, RGBx, xRGB, BGRx, xBGR, RGB, \" \\\n+    \"BGR, Y42B, NV16, NV61, YUY2, YVYU, UYVY, VYUY, I420, YV12, NV12, NV21, \" \\\n+    \"NV12_16L32S, NV12_32L32, NV12_4L4, NV12_64Z32, NV12_8L128, Y41B, IYU1, \" \\\n+    \"YUV9, YVU9, BGR16, RGB16, BGR15, RGB15, RGB8P, GRAY16_BE, GRAY16_LE, \" \\\n+    \"GRAY10_LE32, GRAY8\"\n@@ -882,12 +1109,18 @@\n-#define GST_VIDEO_FORMATS_ALL \"{ ABGR64_LE, BGRA64_LE, AYUV64, ARGB64_LE, ARGB64, \" \\\n-    \"RGBA64_LE, ABGR64_BE, BGRA64_BE, ARGB64_BE, RGBA64_BE, GBRA_12LE, GBRA_12BE, Y412_LE, \" \\\n-    \"Y412_BE, A444_10LE, GBRA_10LE, A444_10BE, GBRA_10BE, A422_10LE, A422_10BE, \" \\\n-    \"A420_10LE, A420_10BE, RGB10A2_LE, BGR10A2_LE, Y410, GBRA, ABGR, VUYA, BGRA, \" \\\n-    \"AYUV, ARGB, RGBA, A420, AV12, Y444_16LE, Y444_16BE, v216, P016_LE, P016_BE, Y444_12LE, \" \\\n-    \"GBR_12LE, Y444_12BE, GBR_12BE, I422_12LE, I422_12BE, Y212_LE, Y212_BE, I420_12LE, \" \\\n-    \"I420_12BE, P012_LE, P012_BE, Y444_10LE, GBR_10LE, Y444_10BE, GBR_10BE, r210, \" \\\n-    \"I422_10LE, I422_10BE, NV16_10LE32, Y210, v210, UYVP, I420_10LE, I420_10BE, \" \\\n-    \"P010_10LE, NV12_10LE32, NV12_10LE40, P010_10BE, NV12_10BE_8L128, Y444, RGBP, GBR, BGRP, NV24, xBGR, BGRx, \" \\\n-    \"xRGB, RGBx, BGR, IYU2, v308, RGB, Y42B, NV61, NV16, VYUY, UYVY, YVYU, YUY2, I420, \" \\\n-    \"YV12, NV21, NV12, NV12_8L128, NV12_64Z32, NV12_4L4, NV12_32L32, NV12_16L32S, Y41B, IYU1, YVU9, YUV9, RGB16, \" \\\n-    \"BGR16, RGB15, BGR15, RGB8P, GRAY16_LE, GRAY16_BE, GRAY10_LE32, GRAY8 }\"\n+#define GST_VIDEO_FORMATS_ALL_STR \"A444_16LE, A444_16BE, AYUV64, RGBA64_LE, \" \\\n+    \"ARGB64, ARGB64_LE, BGRA64_LE, ABGR64_LE, RGBA64_BE, ARGB64_BE, BGRA64_BE, \" \\\n+    \"ABGR64_BE, A422_16LE, A422_16BE, A420_16LE, A420_16BE, A444_12LE, \" \\\n+    \"GBRA_12LE, A444_12BE, GBRA_12BE, Y412_LE, Y412_BE, A422_12LE, A422_12BE, \" \\\n+    \"A420_12LE, A420_12BE, A444_10LE, GBRA_10LE, A444_10BE, GBRA_10BE, \" \\\n+    \"A422_10LE, A422_10BE, A420_10LE, A420_10BE, BGR10A2_LE, RGB10A2_LE, Y410, \" \\\n+    \"A444, GBRA, AYUV, VUYA, RGBA, RBGA, ARGB, BGRA, ABGR, A422, A420, AV12, \" \\\n+    \"Y444_16LE, GBR_16LE, Y444_16BE, GBR_16BE, v216, P016_LE, P016_BE, \" \\\n+    \"Y444_12LE, GBR_12LE, Y444_12BE, GBR_12BE, I422_12LE, I422_12BE, Y212_LE, \" \\\n+    \"Y212_BE, I420_12LE, I420_12BE, P012_LE, P012_BE, Y444_10LE, GBR_10LE, \" \\\n+    \"Y444_10BE, GBR_10BE, r210, I422_10LE, I422_10BE, NV16_10LE32, Y210, UYVP, \" \\\n+    \"v210, I420_10LE, I420_10BE, P010_10LE, NV12_10LE40, NV12_10LE32, \" \\\n+    \"P010_10BE, MT2110R, MT2110T, NV12_10BE_8L128, NV12_10LE40_4L4, Y444, \" \\\n+    \"BGRP, GBR, RGBP, NV24, v308, IYU2, RGBx, xRGB, BGRx, xBGR, RGB, BGR, \" \\\n+    \"Y42B, NV16, NV61, YUY2, YVYU, UYVY, VYUY, I420, YV12, NV12, NV21, \" \\\n+    \"NV12_16L32S, NV12_32L32, NV12_4L4, NV12_64Z32, NV12_8L128, Y41B, IYU1, \" \\\n+    \"YUV9, YVU9, BGR16, RGB16, BGR15, RGB15, RGB8P, GRAY16_LE, GRAY16_BE, \" \\\n+    \"GRAY10_LE32, GRAY8\"\n@@ -896,0 +1129,43 @@\n+\/**\n+ * GST_VIDEO_FORMATS_ANY_STR:\n+ *\n+ * This is similar to %GST_VIDEO_FORMATS_ALL_STR but includes formats like\n+ * DMA_DRM for which no software converter exists. This should be used for\n+ * passthrough template caps.\n+ *\n+ * Since: 1.24\n+ *\/\n+#define GST_VIDEO_FORMATS_ANY_STR \"DMA_DRM, \" GST_VIDEO_FORMATS_ALL_STR\n+\n+\/**\n+ * GST_VIDEO_FORMATS_ALL:\n+ *\n+ * List of all video formats, for use in template caps strings.\n+ *\n+ * Formats are sorted by decreasing \"quality\", using these criteria by priority:\n+ *   - number of components\n+ *   - depth\n+ *   - subsampling factor of the width\n+ *   - subsampling factor of the height\n+ *   - number of planes\n+ *   - native endianness preferred\n+ *   - pixel stride\n+ *   - poffset\n+ *   - prefer non-complex formats\n+ *   - prefer YUV formats over RGB ones\n+ *   - prefer I420 over YV12\n+ *   - format name\n+ *\/\n+#define GST_VIDEO_FORMATS_ALL \"{ \" GST_VIDEO_FORMATS_ALL_STR \" }\"\n+\n+\/**\n+ * GST_VIDEO_FORMATS_ANY:\n+ *\n+ * This is similar to %GST_VIDEO_FORMATS_ALL but includes formats like DMA_DRM\n+ * that do not have a software converter. This should be used for passthrough\n+ * template caps.\n+ *\n+ * Since: 1.24\n+ *\/\n+#define GST_VIDEO_FORMATS_ANY \"{ \" GST_VIDEO_FORMATS_ANY_STR \" }\"\n+\n@@ -899,0 +1175,3 @@\n+GST_VIDEO_API\n+const GstVideoFormat * gst_video_formats_any (guint * len);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-format.h","additions":305,"deletions":26,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    GstDebugCategory *c;\n+    GstDebugCategory *c = NULL;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-frame.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+#ifdef GSTREAMER_LITE\n+#include \"gst\/glib-compat-private.h\"\n+#endif \/\/ GSTREAMER_LITE\n+\n@@ -73,1 +77,1 @@\n-  return g_slice_dup (GstVideoInfo, info);\n+  return g_memdup2 (info, sizeof (GstVideoInfo));\n@@ -88,1 +92,1 @@\n-  g_slice_free (GstVideoInfo, info);\n+  g_free (info);\n@@ -109,1 +113,1 @@\n-  info = g_slice_new (GstVideoInfo);\n+  info = g_new (GstVideoInfo, 1);\n@@ -608,0 +612,4 @@\n+  if (info == other)\n+    return TRUE;\n+  if (info->finfo == NULL || other->finfo == NULL)\n+    return FALSE;\n@@ -828,0 +836,1 @@\n+    case GST_VIDEO_FORMAT_RBGA:\n@@ -1012,0 +1021,26 @@\n+    case GST_VIDEO_FORMAT_A422:\n+      info->stride[0] = GST_ROUND_UP_4 (width);\n+      info->stride[1] = GST_ROUND_UP_8 (width) \/ 2;\n+      info->stride[2] = info->stride[1];\n+      info->stride[3] = info->stride[0];\n+      info->offset[0] = 0;\n+      info->offset[1] = info->stride[0] * GST_ROUND_UP_2 (height);\n+      info->offset[2] = info->offset[1] +\n+          info->stride[1] * GST_ROUND_UP_2 (height);\n+      info->offset[3] =\n+          info->offset[2] + info->stride[2] * GST_ROUND_UP_2 (height);\n+      info->size = info->offset[3] + info->stride[0] * GST_ROUND_UP_2 (height);\n+      break;\n+    case GST_VIDEO_FORMAT_A444:\n+      info->stride[0] = GST_ROUND_UP_4 (width);\n+      info->stride[1] = info->stride[0];\n+      info->stride[2] = info->stride[0];\n+      info->stride[3] = info->stride[0];\n+      info->offset[0] = 0;\n+      info->offset[1] = info->stride[0] * GST_ROUND_UP_2 (height);\n+      info->offset[2] = info->offset[1] +\n+          info->stride[1] * GST_ROUND_UP_2 (height);\n+      info->offset[3] =\n+          info->offset[2] + info->stride[2] * GST_ROUND_UP_2 (height);\n+      info->size = info->offset[3] + info->stride[0] * GST_ROUND_UP_2 (height);\n+      break;\n@@ -1061,0 +1096,2 @@\n+    case GST_VIDEO_FORMAT_GBR_16LE:\n+    case GST_VIDEO_FORMAT_GBR_16BE:\n@@ -1099,0 +1136,1 @@\n+    case GST_VIDEO_FORMAT_NV12_10LE40_4L4:\n@@ -1119,1 +1157,1 @@\n-          GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 0);\n+          GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 1);\n@@ -1138,0 +1176,4 @@\n+    case GST_VIDEO_FORMAT_A420_12LE:\n+    case GST_VIDEO_FORMAT_A420_12BE:\n+    case GST_VIDEO_FORMAT_A420_16LE:\n+    case GST_VIDEO_FORMAT_A420_16BE:\n@@ -1153,0 +1195,4 @@\n+    case GST_VIDEO_FORMAT_A422_12LE:\n+    case GST_VIDEO_FORMAT_A422_12BE:\n+    case GST_VIDEO_FORMAT_A422_16LE:\n+    case GST_VIDEO_FORMAT_A422_16BE:\n@@ -1167,0 +1213,4 @@\n+    case GST_VIDEO_FORMAT_A444_12LE:\n+    case GST_VIDEO_FORMAT_A444_12BE:\n+    case GST_VIDEO_FORMAT_A444_16LE:\n+    case GST_VIDEO_FORMAT_A444_16BE:\n@@ -1269,0 +1319,14 @@\n+    case GST_VIDEO_FORMAT_MT2110T:\n+    case GST_VIDEO_FORMAT_MT2110R:\n+    {\n+      const gsize tile_size = GST_VIDEO_FORMAT_INFO_TILE_SIZE (info->finfo, 0);\n+      gint n_tile_x = GST_ROUND_UP_16 (info->width) \/ 16;\n+      gint n_tile_y = GST_ROUND_UP_32 (info->height) \/ 32;\n+\n+      info->stride[0] = GST_VIDEO_TILE_MAKE_STRIDE (n_tile_x, n_tile_y);\n+      info->stride[1] = info->stride[0];\n+      info->offset[0] = 0;\n+      info->offset[1] = tile_size * n_tile_x * n_tile_y;\n+      info->size = info->offset[1] + info->offset[1] \/ 2;\n+      break;\n+    }\n@@ -1270,0 +1334,1 @@\n+    case GST_VIDEO_FORMAT_DMA_DRM:\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-info.c","additions":69,"deletions":4,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -49,13 +49,13 @@\n-  \"mono\", GST_VIDEO_MULTIVIEW_MODE_MONO}, {\n-  \"left\", GST_VIDEO_MULTIVIEW_MODE_LEFT}, {\n-  \"right\", GST_VIDEO_MULTIVIEW_MODE_RIGHT}, {\n-  \"side-by-side\", GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE}, {\n-  \"side-by-side-quincunx\", GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX}, {\n-  \"column-interleaved\", GST_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED}, {\n-  \"row-interleaved\", GST_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED}, {\n-  \"top-bottom\", GST_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM}, {\n-  \"checkerboard\", GST_VIDEO_MULTIVIEW_MODE_CHECKERBOARD}, {\n-  \"frame-by-frame\", GST_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME}, {\n-  \"multiview-frame-by-frame\",\n-        GST_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME}, {\n-  \"separated\", GST_VIDEO_MULTIVIEW_MODE_SEPARATED}\n+      \"mono\", GST_VIDEO_MULTIVIEW_MODE_MONO}, {\n+      \"left\", GST_VIDEO_MULTIVIEW_MODE_LEFT}, {\n+      \"right\", GST_VIDEO_MULTIVIEW_MODE_RIGHT}, {\n+      \"side-by-side\", GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE}, {\n+      \"side-by-side-quincunx\", GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX}, {\n+      \"column-interleaved\", GST_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED}, {\n+      \"row-interleaved\", GST_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED}, {\n+      \"top-bottom\", GST_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM}, {\n+      \"checkerboard\", GST_VIDEO_MULTIVIEW_MODE_CHECKERBOARD}, {\n+      \"frame-by-frame\", GST_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME}, {\n+        \"multiview-frame-by-frame\",\n+      GST_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME}, {\n+      \"separated\", GST_VIDEO_MULTIVIEW_MODE_SEPARATED}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-multiview.c","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -237,0 +237,8 @@\n+void video_orc_unpack_RBGA_le (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n);\n+void video_orc_unpack_RBGA_be (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n);\n+void video_orc_pack_RBGA_le (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n);\n+void video_orc_pack_RBGA_be (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n);\n@@ -14281,0 +14289,1020 @@\n+\/* video_orc_unpack_RBGA_le *\/\n+#ifdef DISABLE_ORC\n+void\n+video_orc_unpack_RBGA_le (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  int i;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) d1;\n+  ptr4 = (orc_union32 *) s1;\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shrul *\/\n+    var48.i = ((orc_uint32) var44.i) >> 24;\n+    \/* 10: shll *\/\n+    var49.i = ((orc_uint32) var45.i) << 8;\n+    \/* 11: shll *\/\n+    var50.i = ((orc_uint32) var47.i) << 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+#else\n+static void\n+_backup_video_orc_unpack_RBGA_le (OrcExecutor * ORC_RESTRICT ex)\n+{\n+  int i;\n+  int n = ex->n;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) ex->arrays[0];\n+  ptr4 = (orc_union32 *) ex->arrays[4];\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shrul *\/\n+    var48.i = ((orc_uint32) var44.i) >> 24;\n+    \/* 10: shll *\/\n+    var49.i = ((orc_uint32) var45.i) << 8;\n+    \/* 11: shll *\/\n+    var50.i = ((orc_uint32) var47.i) << 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+void\n+video_orc_unpack_RBGA_le (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  OrcExecutor _ex, *ex = &_ex;\n+  static volatile int p_inited = 0;\n+  static OrcCode *c = 0;\n+  void (*func) (OrcExecutor *);\n+\n+  if (!p_inited) {\n+    orc_once_mutex_lock ();\n+    if (!p_inited) {\n+      OrcProgram *p;\n+\n+#if 1\n+      static const orc_uint8 bc[] = {\n+        1, 9, 24, 118, 105, 100, 101, 111, 95, 111, 114, 99, 95, 117, 110, 112,\n+        97, 99, 107, 95, 82, 66, 71, 65, 95, 108, 101, 11, 4, 4, 12, 4,\n+        4, 14, 4, 0, 0, 0, 255, 14, 4, 255, 0, 0, 0, 14, 4, 0,\n+        0, 255, 0, 14, 4, 0, 255, 0, 0, 14, 4, 24, 0, 0, 0, 14,\n+        4, 8, 0, 0, 0, 14, 4, 16, 0, 0, 0, 20, 4, 20, 4, 20,\n+        4, 20, 4, 20, 4, 20, 4, 113, 32, 4, 106, 33, 32, 16, 106, 34,\n+        32, 17, 106, 35, 32, 18, 106, 36, 32, 19, 126, 33, 33, 20, 124, 34,\n+        34, 21, 124, 36, 36, 22, 123, 37, 33, 34, 123, 37, 37, 35, 123, 0,\n+        37, 36, 2, 0,\n+      };\n+      p = orc_program_new_from_static_bytecode (bc);\n+      orc_program_set_backup_function (p, _backup_video_orc_unpack_RBGA_le);\n+#else\n+      p = orc_program_new ();\n+      orc_program_set_name (p, \"video_orc_unpack_RBGA_le\");\n+      orc_program_set_backup_function (p, _backup_video_orc_unpack_RBGA_le);\n+      orc_program_add_destination (p, 4, \"d1\");\n+      orc_program_add_source (p, 4, \"s1\");\n+      orc_program_add_constant (p, 4, 0xff000000, \"c1\");\n+      orc_program_add_constant (p, 4, 0x000000ff, \"c2\");\n+      orc_program_add_constant (p, 4, 0x00ff0000, \"c3\");\n+      orc_program_add_constant (p, 4, 0x0000ff00, \"c4\");\n+      orc_program_add_constant (p, 4, 0x00000018, \"c5\");\n+      orc_program_add_constant (p, 4, 0x00000008, \"c6\");\n+      orc_program_add_constant (p, 4, 0x00000010, \"c7\");\n+      orc_program_add_temporary (p, 4, \"t1\");\n+      orc_program_add_temporary (p, 4, \"t2\");\n+      orc_program_add_temporary (p, 4, \"t3\");\n+      orc_program_add_temporary (p, 4, \"t4\");\n+      orc_program_add_temporary (p, 4, \"t5\");\n+      orc_program_add_temporary (p, 4, \"t6\");\n+\n+      orc_program_append_2 (p, \"loadl\", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_C1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_C2,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_C3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_C4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shrul\", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C5,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shll\", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C6,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shll\", 0, ORC_VAR_T5, ORC_VAR_T5, ORC_VAR_C7,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T2, ORC_VAR_T3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T6, ORC_VAR_T4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_D1, ORC_VAR_T6, ORC_VAR_T5,\n+          ORC_VAR_D1);\n+#endif\n+\n+      orc_program_compile (p);\n+      c = orc_program_take_code (p);\n+      orc_program_free (p);\n+    }\n+    p_inited = TRUE;\n+    orc_once_mutex_unlock ();\n+  }\n+  ex->arrays[ORC_VAR_A2] = c;\n+  ex->program = 0;\n+\n+  ex->n = n;\n+  ex->arrays[ORC_VAR_D1] = d1;\n+  ex->arrays[ORC_VAR_S1] = (void *) s1;\n+\n+  func = c->exec;\n+  func (ex);\n+}\n+#endif\n+\n+\n+\/* video_orc_unpack_RBGA_be *\/\n+#ifdef DISABLE_ORC\n+void\n+video_orc_unpack_RBGA_be (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  int i;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) d1;\n+  ptr4 = (orc_union32 *) s1;\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shll *\/\n+    var48.i = ((orc_uint32) var44.i) << 24;\n+    \/* 10: shrul *\/\n+    var49.i = ((orc_uint32) var45.i) >> 8;\n+    \/* 11: shrul *\/\n+    var50.i = ((orc_uint32) var47.i) >> 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+#else\n+static void\n+_backup_video_orc_unpack_RBGA_be (OrcExecutor * ORC_RESTRICT ex)\n+{\n+  int i;\n+  int n = ex->n;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) ex->arrays[0];\n+  ptr4 = (orc_union32 *) ex->arrays[4];\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shll *\/\n+    var48.i = ((orc_uint32) var44.i) << 24;\n+    \/* 10: shrul *\/\n+    var49.i = ((orc_uint32) var45.i) >> 8;\n+    \/* 11: shrul *\/\n+    var50.i = ((orc_uint32) var47.i) >> 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+void\n+video_orc_unpack_RBGA_be (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  OrcExecutor _ex, *ex = &_ex;\n+  static volatile int p_inited = 0;\n+  static OrcCode *c = 0;\n+  void (*func) (OrcExecutor *);\n+\n+  if (!p_inited) {\n+    orc_once_mutex_lock ();\n+    if (!p_inited) {\n+      OrcProgram *p;\n+\n+#if 1\n+      static const orc_uint8 bc[] = {\n+        1, 9, 24, 118, 105, 100, 101, 111, 95, 111, 114, 99, 95, 117, 110, 112,\n+        97, 99, 107, 95, 82, 66, 71, 65, 95, 98, 101, 11, 4, 4, 12, 4,\n+        4, 14, 4, 255, 0, 0, 0, 14, 4, 0, 0, 0, 255, 14, 4, 0,\n+        255, 0, 0, 14, 4, 0, 0, 255, 0, 14, 4, 24, 0, 0, 0, 14,\n+        4, 8, 0, 0, 0, 14, 4, 16, 0, 0, 0, 20, 4, 20, 4, 20,\n+        4, 20, 4, 20, 4, 20, 4, 113, 32, 4, 106, 33, 32, 16, 106, 34,\n+        32, 17, 106, 35, 32, 18, 106, 36, 32, 19, 124, 33, 33, 20, 126, 34,\n+        34, 21, 126, 36, 36, 22, 123, 37, 33, 34, 123, 37, 37, 35, 123, 0,\n+        37, 36, 2, 0,\n+      };\n+      p = orc_program_new_from_static_bytecode (bc);\n+      orc_program_set_backup_function (p, _backup_video_orc_unpack_RBGA_be);\n+#else\n+      p = orc_program_new ();\n+      orc_program_set_name (p, \"video_orc_unpack_RBGA_be\");\n+      orc_program_set_backup_function (p, _backup_video_orc_unpack_RBGA_be);\n+      orc_program_add_destination (p, 4, \"d1\");\n+      orc_program_add_source (p, 4, \"s1\");\n+      orc_program_add_constant (p, 4, 0x000000ff, \"c1\");\n+      orc_program_add_constant (p, 4, 0xff000000, \"c2\");\n+      orc_program_add_constant (p, 4, 0x0000ff00, \"c3\");\n+      orc_program_add_constant (p, 4, 0x00ff0000, \"c4\");\n+      orc_program_add_constant (p, 4, 0x00000018, \"c5\");\n+      orc_program_add_constant (p, 4, 0x00000008, \"c6\");\n+      orc_program_add_constant (p, 4, 0x00000010, \"c7\");\n+      orc_program_add_temporary (p, 4, \"t1\");\n+      orc_program_add_temporary (p, 4, \"t2\");\n+      orc_program_add_temporary (p, 4, \"t3\");\n+      orc_program_add_temporary (p, 4, \"t4\");\n+      orc_program_add_temporary (p, 4, \"t5\");\n+      orc_program_add_temporary (p, 4, \"t6\");\n+\n+      orc_program_append_2 (p, \"loadl\", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_C1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_C2,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_C3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_C4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shll\", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C5,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shrul\", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C6,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shrul\", 0, ORC_VAR_T5, ORC_VAR_T5, ORC_VAR_C7,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T2, ORC_VAR_T3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T6, ORC_VAR_T4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_D1, ORC_VAR_T6, ORC_VAR_T5,\n+          ORC_VAR_D1);\n+#endif\n+\n+      orc_program_compile (p);\n+      c = orc_program_take_code (p);\n+      orc_program_free (p);\n+    }\n+    p_inited = TRUE;\n+    orc_once_mutex_unlock ();\n+  }\n+  ex->arrays[ORC_VAR_A2] = c;\n+  ex->program = 0;\n+\n+  ex->n = n;\n+  ex->arrays[ORC_VAR_D1] = d1;\n+  ex->arrays[ORC_VAR_S1] = (void *) s1;\n+\n+  func = c->exec;\n+  func (ex);\n+}\n+#endif\n+\n+\n+\/* video_orc_pack_RBGA_le *\/\n+#ifdef DISABLE_ORC\n+void\n+video_orc_pack_RBGA_le (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  int i;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) d1;\n+  ptr4 = (orc_union32 *) s1;\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shll *\/\n+    var48.i = ((orc_uint32) var44.i) << 24;\n+    \/* 10: shrul *\/\n+    var49.i = ((orc_uint32) var45.i) >> 8;\n+    \/* 11: shrul *\/\n+    var50.i = ((orc_uint32) var47.i) >> 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+#else\n+static void\n+_backup_video_orc_pack_RBGA_le (OrcExecutor * ORC_RESTRICT ex)\n+{\n+  int i;\n+  int n = ex->n;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) ex->arrays[0];\n+  ptr4 = (orc_union32 *) ex->arrays[4];\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shll *\/\n+    var48.i = ((orc_uint32) var44.i) << 24;\n+    \/* 10: shrul *\/\n+    var49.i = ((orc_uint32) var45.i) >> 8;\n+    \/* 11: shrul *\/\n+    var50.i = ((orc_uint32) var47.i) >> 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+void\n+video_orc_pack_RBGA_le (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  OrcExecutor _ex, *ex = &_ex;\n+  static volatile int p_inited = 0;\n+  static OrcCode *c = 0;\n+  void (*func) (OrcExecutor *);\n+\n+  if (!p_inited) {\n+    orc_once_mutex_lock ();\n+    if (!p_inited) {\n+      OrcProgram *p;\n+\n+#if 1\n+      static const orc_uint8 bc[] = {\n+        1, 9, 22, 118, 105, 100, 101, 111, 95, 111, 114, 99, 95, 112, 97, 99,\n+        107, 95, 82, 66, 71, 65, 95, 108, 101, 11, 4, 4, 12, 4, 4, 14,\n+        4, 255, 0, 0, 0, 14, 4, 0, 255, 0, 0, 14, 4, 0, 0, 255,\n+        0, 14, 4, 0, 0, 0, 255, 14, 4, 24, 0, 0, 0, 14, 4, 8,\n+        0, 0, 0, 14, 4, 16, 0, 0, 0, 20, 4, 20, 4, 20, 4, 20,\n+        4, 20, 4, 20, 4, 113, 32, 4, 106, 33, 32, 16, 106, 34, 32, 17,\n+        106, 35, 32, 18, 106, 36, 32, 19, 124, 33, 33, 20, 126, 34, 34, 21,\n+        126, 36, 36, 22, 123, 37, 33, 34, 123, 37, 37, 35, 123, 0, 37, 36,\n+        2, 0,\n+      };\n+      p = orc_program_new_from_static_bytecode (bc);\n+      orc_program_set_backup_function (p, _backup_video_orc_pack_RBGA_le);\n+#else\n+      p = orc_program_new ();\n+      orc_program_set_name (p, \"video_orc_pack_RBGA_le\");\n+      orc_program_set_backup_function (p, _backup_video_orc_pack_RBGA_le);\n+      orc_program_add_destination (p, 4, \"d1\");\n+      orc_program_add_source (p, 4, \"s1\");\n+      orc_program_add_constant (p, 4, 0x000000ff, \"c1\");\n+      orc_program_add_constant (p, 4, 0x0000ff00, \"c2\");\n+      orc_program_add_constant (p, 4, 0x00ff0000, \"c3\");\n+      orc_program_add_constant (p, 4, 0xff000000, \"c4\");\n+      orc_program_add_constant (p, 4, 0x00000018, \"c5\");\n+      orc_program_add_constant (p, 4, 0x00000008, \"c6\");\n+      orc_program_add_constant (p, 4, 0x00000010, \"c7\");\n+      orc_program_add_temporary (p, 4, \"t1\");\n+      orc_program_add_temporary (p, 4, \"t2\");\n+      orc_program_add_temporary (p, 4, \"t3\");\n+      orc_program_add_temporary (p, 4, \"t4\");\n+      orc_program_add_temporary (p, 4, \"t5\");\n+      orc_program_add_temporary (p, 4, \"t6\");\n+\n+      orc_program_append_2 (p, \"loadl\", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_C1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_C2,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_C3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_C4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shll\", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C5,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shrul\", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C6,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shrul\", 0, ORC_VAR_T5, ORC_VAR_T5, ORC_VAR_C7,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T2, ORC_VAR_T3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T6, ORC_VAR_T4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_D1, ORC_VAR_T6, ORC_VAR_T5,\n+          ORC_VAR_D1);\n+#endif\n+\n+      orc_program_compile (p);\n+      c = orc_program_take_code (p);\n+      orc_program_free (p);\n+    }\n+    p_inited = TRUE;\n+    orc_once_mutex_unlock ();\n+  }\n+  ex->arrays[ORC_VAR_A2] = c;\n+  ex->program = 0;\n+\n+  ex->n = n;\n+  ex->arrays[ORC_VAR_D1] = d1;\n+  ex->arrays[ORC_VAR_S1] = (void *) s1;\n+\n+  func = c->exec;\n+  func (ex);\n+}\n+#endif\n+\n+\n+\/* video_orc_pack_RBGA_be *\/\n+#ifdef DISABLE_ORC\n+void\n+video_orc_pack_RBGA_be (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  int i;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) d1;\n+  ptr4 = (orc_union32 *) s1;\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shrul *\/\n+    var48.i = ((orc_uint32) var44.i) >> 24;\n+    \/* 10: shll *\/\n+    var49.i = ((orc_uint32) var45.i) << 8;\n+    \/* 11: shll *\/\n+    var50.i = ((orc_uint32) var47.i) << 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+#else\n+static void\n+_backup_video_orc_pack_RBGA_be (OrcExecutor * ORC_RESTRICT ex)\n+{\n+  int i;\n+  int n = ex->n;\n+  orc_union32 *ORC_RESTRICT ptr0;\n+  const orc_union32 *ORC_RESTRICT ptr4;\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var38;\n+#else\n+  orc_union32 var38;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var39;\n+#else\n+  orc_union32 var39;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var40;\n+#else\n+  orc_union32 var40;\n+#endif\n+#if defined(__APPLE__) && __GNUC__ == 4 && __GNUC_MINOR__ == 2 && defined (__i386__)\n+  volatile orc_union32 var41;\n+#else\n+  orc_union32 var41;\n+#endif\n+  orc_union32 var42;\n+  orc_union32 var43;\n+  orc_union32 var44;\n+  orc_union32 var45;\n+  orc_union32 var46;\n+  orc_union32 var47;\n+  orc_union32 var48;\n+  orc_union32 var49;\n+  orc_union32 var50;\n+  orc_union32 var51;\n+  orc_union32 var52;\n+\n+  ptr0 = (orc_union32 *) ex->arrays[0];\n+  ptr4 = (orc_union32 *) ex->arrays[4];\n+\n+  \/* 1: loadpl *\/\n+  var38.i = 0xff000000;         \/* -16777216 or 2.11371e-314f *\/\n+  \/* 3: loadpl *\/\n+  var39.i = 0x00ff0000;         \/* 16711680 or 8.25667e-317f *\/\n+  \/* 5: loadpl *\/\n+  var40.i = 0x0000ff00;         \/* 65280 or 3.22526e-319f *\/\n+  \/* 7: loadpl *\/\n+  var41.i = 0x000000ff;         \/* 255 or 1.25987e-321f *\/\n+\n+  for (i = 0; i < n; i++) {\n+    \/* 0: loadl *\/\n+    var43 = ptr4[i];\n+    \/* 2: andl *\/\n+    var44.i = var43.i & var38.i;\n+    \/* 4: andl *\/\n+    var45.i = var43.i & var39.i;\n+    \/* 6: andl *\/\n+    var46.i = var43.i & var40.i;\n+    \/* 8: andl *\/\n+    var47.i = var43.i & var41.i;\n+    \/* 9: shrul *\/\n+    var48.i = ((orc_uint32) var44.i) >> 24;\n+    \/* 10: shll *\/\n+    var49.i = ((orc_uint32) var45.i) << 8;\n+    \/* 11: shll *\/\n+    var50.i = ((orc_uint32) var47.i) << 16;\n+    \/* 12: orl *\/\n+    var51.i = var48.i | var49.i;\n+    \/* 13: orl *\/\n+    var52.i = var51.i | var46.i;\n+    \/* 14: orl *\/\n+    var42.i = var52.i | var50.i;\n+    \/* 15: storel *\/\n+    ptr0[i] = var42;\n+  }\n+\n+}\n+\n+void\n+video_orc_pack_RBGA_be (guint8 * ORC_RESTRICT d1,\n+    const guint8 * ORC_RESTRICT s1, int n)\n+{\n+  OrcExecutor _ex, *ex = &_ex;\n+  static volatile int p_inited = 0;\n+  static OrcCode *c = 0;\n+  void (*func) (OrcExecutor *);\n+\n+  if (!p_inited) {\n+    orc_once_mutex_lock ();\n+    if (!p_inited) {\n+      OrcProgram *p;\n+\n+#if 1\n+      static const orc_uint8 bc[] = {\n+        1, 9, 22, 118, 105, 100, 101, 111, 95, 111, 114, 99, 95, 112, 97, 99,\n+        107, 95, 82, 66, 71, 65, 95, 98, 101, 11, 4, 4, 12, 4, 4, 14,\n+        4, 0, 0, 0, 255, 14, 4, 0, 0, 255, 0, 14, 4, 0, 255, 0,\n+        0, 14, 4, 255, 0, 0, 0, 14, 4, 24, 0, 0, 0, 14, 4, 8,\n+        0, 0, 0, 14, 4, 16, 0, 0, 0, 20, 4, 20, 4, 20, 4, 20,\n+        4, 20, 4, 20, 4, 113, 32, 4, 106, 33, 32, 16, 106, 34, 32, 17,\n+        106, 35, 32, 18, 106, 36, 32, 19, 126, 33, 33, 20, 124, 34, 34, 21,\n+        124, 36, 36, 22, 123, 37, 33, 34, 123, 37, 37, 35, 123, 0, 37, 36,\n+        2, 0,\n+      };\n+      p = orc_program_new_from_static_bytecode (bc);\n+      orc_program_set_backup_function (p, _backup_video_orc_pack_RBGA_be);\n+#else\n+      p = orc_program_new ();\n+      orc_program_set_name (p, \"video_orc_pack_RBGA_be\");\n+      orc_program_set_backup_function (p, _backup_video_orc_pack_RBGA_be);\n+      orc_program_add_destination (p, 4, \"d1\");\n+      orc_program_add_source (p, 4, \"s1\");\n+      orc_program_add_constant (p, 4, 0xff000000, \"c1\");\n+      orc_program_add_constant (p, 4, 0x00ff0000, \"c2\");\n+      orc_program_add_constant (p, 4, 0x0000ff00, \"c3\");\n+      orc_program_add_constant (p, 4, 0x000000ff, \"c4\");\n+      orc_program_add_constant (p, 4, 0x00000018, \"c5\");\n+      orc_program_add_constant (p, 4, 0x00000008, \"c6\");\n+      orc_program_add_constant (p, 4, 0x00000010, \"c7\");\n+      orc_program_add_temporary (p, 4, \"t1\");\n+      orc_program_add_temporary (p, 4, \"t2\");\n+      orc_program_add_temporary (p, 4, \"t3\");\n+      orc_program_add_temporary (p, 4, \"t4\");\n+      orc_program_add_temporary (p, 4, \"t5\");\n+      orc_program_add_temporary (p, 4, \"t6\");\n+\n+      orc_program_append_2 (p, \"loadl\", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_C1,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T3, ORC_VAR_T1, ORC_VAR_C2,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T4, ORC_VAR_T1, ORC_VAR_C3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"andl\", 0, ORC_VAR_T5, ORC_VAR_T1, ORC_VAR_C4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shrul\", 0, ORC_VAR_T2, ORC_VAR_T2, ORC_VAR_C5,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shll\", 0, ORC_VAR_T3, ORC_VAR_T3, ORC_VAR_C6,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"shll\", 0, ORC_VAR_T5, ORC_VAR_T5, ORC_VAR_C7,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T2, ORC_VAR_T3,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_T6, ORC_VAR_T6, ORC_VAR_T4,\n+          ORC_VAR_D1);\n+      orc_program_append_2 (p, \"orl\", 0, ORC_VAR_D1, ORC_VAR_T6, ORC_VAR_T5,\n+          ORC_VAR_D1);\n+#endif\n+\n+      orc_program_compile (p);\n+      c = orc_program_take_code (p);\n+      orc_program_free (p);\n+    }\n+    p_inited = TRUE;\n+    orc_once_mutex_unlock ();\n+  }\n+  ex->arrays[ORC_VAR_A2] = c;\n+  ex->program = 0;\n+\n+  ex->n = n;\n+  ex->arrays[ORC_VAR_D1] = d1;\n+  ex->arrays[ORC_VAR_S1] = (void *) s1;\n+\n+  func = c->exec;\n+  func (ex);\n+}\n+#endif\n+\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-orc-dist.c","additions":1028,"deletions":0,"binary":false,"changes":1028,"status":"modified"},{"patch":"@@ -146,0 +146,4 @@\n+void video_orc_unpack_RBGA_le (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, int n);\n+void video_orc_unpack_RBGA_be (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, int n);\n+void video_orc_pack_RBGA_le (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, int n);\n+void video_orc_pack_RBGA_be (guint8 * ORC_RESTRICT d1, const guint8 * ORC_RESTRICT s1, int n);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-orc-dist.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1025,0 +1025,88 @@\n+.function video_orc_unpack_RBGA_le\n+.dest 4 argb guint8\n+.source 4 rbga guint8\n+.temp 4 t\n+.temp 4 a\n+.temp 4 r\n+.temp 4 g\n+.temp 4 b\n+.temp 4 t2\n+\n+loadl t, rbga\n+andl a, t, 0xff000000\n+andl r, t, 0xff\n+andl g, t, 0xff0000\n+andl b, t, 0xff00\n+shrul a, a, 24\n+shll r, r, 8\n+shll b, b, 16\n+orl t2, a, r\n+orl t2, t2, g\n+orl argb, t2, b\n+\n+.function video_orc_unpack_RBGA_be\n+.dest 4 argb guint8\n+.source 4 rbga guint8\n+.temp 4 t\n+.temp 4 a\n+.temp 4 r\n+.temp 4 g\n+.temp 4 b\n+.temp 4 t2\n+\n+loadl t, rbga\n+andl a, t, 0xff\n+andl r, t, 0xff000000\n+andl g, t, 0xff00\n+andl b, t, 0xff0000\n+shll a, a, 24\n+shrul r, r, 8\n+shrul b, b, 16\n+orl t2, a, r\n+orl t2, t2, g\n+orl argb, t2, b\n+\n+.function video_orc_pack_RBGA_le\n+.dest 4 rbga guint8\n+.source 4 argb guint8\n+.temp 4 t\n+.temp 4 a\n+.temp 4 r\n+.temp 4 g\n+.temp 4 b\n+.temp 4 t2\n+\n+loadl t, argb\n+andl a, t, 0xff\n+andl r, t, 0xff00\n+andl g, t, 0xff0000\n+andl b, t, 0xff000000\n+shll a, a, 24\n+shrul r, r, 8\n+shrul b, b, 16\n+orl t2, a, r\n+orl t2, t2, g\n+orl rbga, t2, b\n+\n+.function video_orc_pack_RBGA_be\n+.dest 4 rbga guint8\n+.source 4 argb guint8\n+.temp 4 t\n+.temp 4 a\n+.temp 4 r\n+.temp 4 g\n+.temp 4 b\n+.temp 4 t2\n+\n+loadl t, argb\n+andl a, t, 0xff000000\n+andl r, t, 0xff0000\n+andl g, t, 0xff00\n+andl b, t, 0xff\n+shrul a, a, 24\n+shll r, r, 8\n+shll b, b, 16\n+orl t2, a, r\n+orl t2, t2, g\n+orl rbga, t2, b\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-orc.orc","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-  g_slice_free (GstVideoOverlayComposition, comp);\n+  g_free (comp);\n@@ -349,1 +349,1 @@\n-  comp = g_slice_new0 (GstVideoOverlayComposition);\n+  comp = g_new0 (GstVideoOverlayComposition, 1);\n@@ -652,1 +652,1 @@\n-  g_slice_free (GstVideoOverlayRectangle, rect);\n+  g_free (rect);\n@@ -729,1 +729,1 @@\n-  rect = g_slice_new0 (GstVideoOverlayRectangle);\n+  rect = g_new0 (GstVideoOverlayRectangle, 1);\n@@ -1056,1 +1056,1 @@\n-      if (! !(rect->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)) {\n+      if (!!(rect->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)) {\n@@ -1204,1 +1204,1 @@\n-      (! !(rectangle->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)\n+      (!!(rectangle->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)\n@@ -1207,2 +1207,2 @@\n-      (! !(rectangle->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)\n-      && ! !(flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA));\n+      (!!(rectangle->flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)\n+      && !!(flags & GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA));\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-overlay-composition.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+#ifndef GSTREAMER_LITE\n+#include <gst\/video\/video-info-dma.h>\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/videoorientation.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+ * This is required if the input channels are unpositioned and no standard layout can be determined.\n+ * If an empty mix matrix is specified, a (potentially truncated) identity matrix will be generated.\n+ *\n@@ -76,2 +79,0 @@\n- * > If an empty mix matrix is specified, a (potentially truncated)\n- * > identity matrix will be generated.\n@@ -217,0 +218,8 @@\n+  \/**\n+   * GstAudioConvert:mix-matrix:\n+   *\n+   * Transformation matrix for input\/output channels.\n+   * Required if the input channels are unpositioned and no standard layout can be determined.\n+   * Setting an empty matrix like \\\"< >\\\" will generate an identity matrix.\"\n+   *\n+   *\/\n@@ -220,1 +229,1 @@\n-          \"Transformation matrix for input\/output channels\",\n+          \"Transformation matrix for input\/output channels.\",\n@@ -313,1 +322,1 @@\n-  GST_INFO_OBJECT (base, \"unit_size = %\" G_GSIZE_FORMAT, *size);\n+  GST_DEBUG_OBJECT (base, \"unit_size = %\" G_GSIZE_FORMAT, *size);\n@@ -319,1 +328,1 @@\n-    GST_INFO_OBJECT (base, \"failed to parse caps to get unit_size\");\n+    GST_WARNING_OBJECT (base, \"failed to parse caps to get unit_size\");\n@@ -348,2 +357,3 @@\n-  \/* Only remove the channels and channel-mask for non-NONE layouts,\n-   * or if a mix matrix was manually specified *\/\n+  \/* Only remove the channels and channel-mask if a (empty) mix matrix was manually specified,\n+   * if no channel-mask is specified, for non-NONE channel layouts or for a single channel layout\n+   *\/\n@@ -1009,1 +1019,2 @@\n-        this->mix_matrix_is_set = FALSE;\n+        g_value_copy (value, &this->mix_matrix);\n+        this->mix_matrix_is_set = TRUE;\n@@ -1020,1 +1031,2 @@\n-          g_warning (\"Empty mix matrix's first row\");\n+          g_warning (\"Empty mix matrix's first row.\");\n+          this->mix_matrix_is_set = FALSE;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/audioconvert\/gstaudioconvert.c","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1050,2 +1050,2 @@\n-\/* disabled because it happily typefinds \/dev\/urandom as audio\/x-flac, and\n- * because I yet have to see header-less flac in the wild *\/\n+  \/* disabled because it happily typefinds \/dev\/urandom as audio\/x-flac, and\n+   * because I yet have to see header-less flac in the wild *\/\n@@ -2076,3 +2076,0 @@\n-  \/* If bigger than maximum allowed blocksize, refuse *\/\n-  if (blocksize > 131072)\n-    return;\n@@ -2091,0 +2088,2 @@\n+\n+    \/\/ ID_LARGE\n@@ -2097,0 +2096,4 @@\n+\n+    \/\/ ID_ODD_SIZE only affects how much of the chunk is valid. The next one\n+    \/\/ still starts at an even position, so it's ignored here.\n+\n@@ -2102,13 +2105,11 @@\n-    if ((data[0] & 0x20) == 0) {\n-      switch (data[0] & 0x0f) {\n-        case 0xa:              \/* ID_WV_BITSTREAM  *\/\n-        case 0xc:              \/* ID_WVX_BITSTREAM *\/\n-          ++count_wv;\n-          break;\n-        case 0xb:              \/* ID_WVC_BITSTREAM *\/\n-          ++count_wvc;\n-          break;\n-        default:\n-          break;\n-      }\n-      if (count_wv >= 5 || count_wvc >= 5)\n+\n+    switch (data[0] & 0x3f) {\n+      case 0xa:                \/* ID_WV_BITSTREAM  *\/\n+      case 0xc:                \/* ID_WVX_BITSTREAM *\/\n+      case 0x2c:               \/* ID_WVX_NEW_BITSTREAM *\/\n+        ++count_wv;\n+        break;\n+      case 0xb:                \/* ID_WVC_BITSTREAM *\/\n+        ++count_wvc;\n+        break;\n+      default:\n@@ -2117,0 +2118,3 @@\n+    if (count_wv >= 5 || count_wvc >= 5)\n+      break;\n+\n@@ -4867,18 +4871,18 @@\n-    \"\\001vorbis\", 7, OGG_AUDIO}, {\n-    \"\\200theora\", 7, OGG_VIDEO}, {\n-    \"fLaC\", 4, OGG_AUDIO}, {\n-    \"\\177FLAC\", 5, OGG_AUDIO}, {\n-    \"Speex\", 5, OGG_AUDIO}, {\n-    \"CMML\\0\\0\\0\\0\", 8, OGG_OTHER}, {\n-    \"PCM     \", 8, OGG_AUDIO}, {\n-    \"Annodex\", 7, OGG_ANNODEX}, {\n-    \"fishead\", 7, OGG_SKELETON}, {\n-    \"AnxData\", 7, OGG_ANNODEX}, {\n-    \"CELT    \", 8, OGG_AUDIO}, {\n-    \"\\200kate\\0\\0\\0\", 8, OGG_KATE}, {\n-    \"BBCD\\0\", 5, OGG_VIDEO}, {\n-    \"OVP80\\1\\1\", 7, OGG_VIDEO}, {\n-    \"OpusHead\", 8, OGG_AUDIO}, {\n-    \"\\001audio\\0\\0\\0\", 9, OGG_AUDIO}, {\n-    \"\\001video\\0\\0\\0\", 9, OGG_VIDEO}, {\n-    \"\\001text\\0\\0\\0\", 9, OGG_OTHER}\n+        \"\\001vorbis\", 7, OGG_AUDIO}, {\n+        \"\\200theora\", 7, OGG_VIDEO}, {\n+        \"fLaC\", 4, OGG_AUDIO}, {\n+        \"\\177FLAC\", 5, OGG_AUDIO}, {\n+        \"Speex\", 5, OGG_AUDIO}, {\n+        \"CMML\\0\\0\\0\\0\", 8, OGG_OTHER}, {\n+        \"PCM     \", 8, OGG_AUDIO}, {\n+        \"Annodex\", 7, OGG_ANNODEX}, {\n+        \"fishead\", 7, OGG_SKELETON}, {\n+        \"AnxData\", 7, OGG_ANNODEX}, {\n+        \"CELT    \", 8, OGG_AUDIO}, {\n+        \"\\200kate\\0\\0\\0\", 8, OGG_KATE}, {\n+        \"BBCD\\0\", 5, OGG_VIDEO}, {\n+        \"OVP80\\1\\1\", 7, OGG_VIDEO}, {\n+        \"OpusHead\", 8, OGG_AUDIO}, {\n+        \"\\001audio\\0\\0\\0\", 9, OGG_AUDIO}, {\n+        \"\\001video\\0\\0\\0\", 9, OGG_VIDEO}, {\n+        \"\\001text\\0\\0\\0\", 9, OGG_OTHER}\n@@ -5511,0 +5515,693 @@\n+\/*** audio\/x-brstm ***\/\n+\n+static GstStaticCaps brstm_caps = GST_STATIC_CAPS (\"audio\/x-brstm\");\n+\n+#define BRSTM_CAPS (gst_static_caps_get(&brstm_caps))\n+static void\n+brstm_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 8);\n+\n+  if (data) {\n+    if (GST_READ_UINT32_LE (data) != GST_MAKE_FOURCC ('R', 'S', 'T', 'M'))\n+      return;\n+    if (GST_READ_UINT32_LE (data + 4) != 0xfffe\n+        && GST_READ_UINT32_LE (data + 4) != 0xfeff)\n+      return;\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, BRSTM_CAPS);\n+  }\n+}\n+\n+\/*** audio\/x-bfstm ***\/\n+\n+static GstStaticCaps bfstm_caps = GST_STATIC_CAPS (\"audio\/x-bfstm\");\n+\n+#define BFSTM_CAPS (gst_static_caps_get(&bfstm_caps))\n+static void\n+bfstm_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 8);\n+\n+  if (data) {\n+    if (GST_READ_UINT32_LE (data) != GST_MAKE_FOURCC ('F', 'S', 'T', 'M') &&\n+        GST_READ_UINT32_LE (data) != GST_MAKE_FOURCC ('C', 'S', 'T', 'M'))\n+      return;\n+    if (GST_READ_UINT32_LE (data + 4) != 0xfffe\n+        && GST_READ_UINT32_LE (data + 4) != 0xfeff)\n+      return;\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, BFSTM_CAPS);\n+  }\n+}\n+\n+\/*** audio\/x-dsf ***\/\n+\n+static GstStaticCaps dsf_caps = GST_STATIC_CAPS (\"audio\/x-dsf\");\n+\n+#define DSF_CAPS (gst_static_caps_get(&dsf_caps))\n+static void\n+dsf_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 12);\n+\n+  if (data) {\n+    if (memcmp (data, \"DSD \", 4) != 0)\n+      return;\n+    if (GST_READ_UINT64_BE (data + 4) == 28)\n+      return;\n+\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DSF_CAPS);\n+  }\n+}\n+\n+\/*** video\/x-ea ***\/\n+\n+static GstStaticCaps ea_caps = GST_STATIC_CAPS (\"video\/x-ea\");\n+\n+#define EA_CAPS (gst_static_caps_get(&ea_caps))\n+static void\n+ea_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 8);\n+\n+  if (data) {\n+    static const guint32 ea_fourccs[] = {\n+      GST_MAKE_FOURCC ('I', 'S', 'N', 'h'),\n+      GST_MAKE_FOURCC ('S', 'C', 'H', 'l'),\n+      GST_MAKE_FOURCC ('S', 'E', 'A', 'D'),\n+      GST_MAKE_FOURCC ('S', 'H', 'E', 'N'),\n+      GST_MAKE_FOURCC ('k', 'V', 'G', 'T'),\n+      GST_MAKE_FOURCC ('M', 'A', 'D', 'k'),\n+      GST_MAKE_FOURCC ('M', 'P', 'C', 'h'),\n+      GST_MAKE_FOURCC ('M', 'V', 'h', 'd'),\n+      GST_MAKE_FOURCC ('M', 'V', 'I', 'h'),\n+      GST_MAKE_FOURCC ('A', 'V', 'P', '6'),\n+    };\n+\n+    guint32 fourcc = GST_READ_UINT32_LE (data);\n+    gboolean found = FALSE;\n+\n+    for (gsize i = 0; i < G_N_ELEMENTS (ea_fourccs); i++) {\n+      if (fourcc == ea_fourccs[i]) {\n+        found = TRUE;\n+        break;\n+      }\n+    }\n+    if (!found)\n+      return;\n+\n+    guint32 size = GST_READ_UINT32_LE (data + 4);\n+    gboolean big_endian = size > 0x000fffff;\n+    if (big_endian)\n+      size = GUINT32_SWAP_LE_BE (size);\n+    if (size > 0xfffff || size < 8)\n+      return;\n+\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, EA_CAPS);\n+  }\n+}\n+\n+\/*** video\/x-film-cpk ***\/\n+\n+static GstStaticCaps film_cpk_caps = GST_STATIC_CAPS (\"video\/x-film-cpk\");\n+\n+#define FILM_CPK_CAPS (gst_static_caps_get(&film_cpk_caps))\n+static void\n+film_cpk_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 20);\n+\n+  if (data) {\n+    if (GST_READ_UINT32_LE (data) != GST_MAKE_FOURCC ('F', 'I', 'L', 'M'))\n+      return;\n+    if (GST_READ_UINT32_LE (data + 16) != GST_MAKE_FOURCC ('F', 'D', 'S', 'C'))\n+      return;\n+\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, FILM_CPK_CAPS);\n+  }\n+}\n+\n+\/*** application\/gxf ***\/\n+\n+static GstStaticCaps gxf_caps = GST_STATIC_CAPS (\"application\/gxf\");\n+\n+#define GXF_CAPS (gst_static_caps_get(&gxf_caps))\n+static void\n+gxf_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 16);\n+\n+  if (data) {\n+    if (memcmp (data, \"\\x00\\x00\\x00\\x00\\x01\\xbc\", 6) != 0)\n+      return;\n+    if (memcmp (data + 10, \"\\x00\\x00\\x00\\x00\\xe1\\xe2\", 6) != 0)\n+      return;\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, GXF_CAPS);\n+  }\n+}\n+\n+\/*** application\/x-iff ***\/\n+\n+static GstStaticCaps iff_caps = GST_STATIC_CAPS (\"application\/x-iff\");\n+\n+#define IFF_CAPS (gst_static_caps_get(&iff_caps))\n+static void\n+iff_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 16);\n+\n+  if (data) {\n+    if (GST_READ_UINT32_LE (data) == GST_MAKE_FOURCC ('F', 'O', 'R', 'M') &&\n+        (GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('8', 'S', 'V', 'X')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('1', '6', 'S',\n+                'V')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('M', 'A', 'U',\n+                'D')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('P', 'B', 'M',\n+                ' ')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('A', 'C', 'B',\n+                'M')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('D', 'E', 'E',\n+                'P')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('I', 'L', 'B',\n+                'M')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('R', 'G', 'B',\n+                '8')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('A', 'N', 'I',\n+                'M')\n+            || GST_READ_UINT32_LE (data + 8) == GST_MAKE_FOURCC ('R', 'G', 'B',\n+                'N'))) {\n+      gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, IFF_CAPS);\n+      return;\n+    }\n+\n+    if (GST_READ_UINT32_LE (data) == GST_MAKE_FOURCC ('F', 'R', 'M', '8')\n+        && GST_READ_UINT32_LE (data + 12) == GST_MAKE_FOURCC ('D', 'S', 'D',\n+            ' ')) {\n+      gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, IFF_CAPS);\n+      return;\n+    }\n+  }\n+}\n+\n+\/*** video\/x-idcin ***\/\n+\n+static GstStaticCaps idcin_caps = GST_STATIC_CAPS (\"video\/x-idcin\");\n+\n+#define IDCIN_CAPS (gst_static_caps_get(&idcin_caps))\n+static void\n+idcin_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 20 + 64 * 1024 + 4);\n+  if (!data)\n+    return;\n+\n+  \/\/ See ffmpeg\/libavformat\/idcin.c:idcin_probe() for details\n+\n+  guint number, sample_rate;\n+  guint w, h;\n+  gint i;\n+\n+  w = GST_READ_UINT32_LE (data);\n+  if (w == 0 || w > 1024)\n+    return;\n+\n+  h = GST_READ_UINT32_LE (data + 4);\n+  if (h == 0 || h > 1024)\n+    return;\n+\n+  sample_rate = GST_READ_UINT32_LE (data + 8);\n+  if (sample_rate && (sample_rate < 8000 || sample_rate > 48000))\n+    return;\n+\n+  number = GST_READ_UINT32_LE (data + 12);\n+  if (number > 2 || (sample_rate && !number))\n+    return;\n+\n+  number = GST_READ_UINT32_LE (data + 16);\n+  if (number > 2 || (sample_rate && !number))\n+    return;\n+\n+  i = 20 + 64 * 1024;\n+  if (GST_READ_UINT32_LE (data + i) == 1)\n+    i += 768;\n+\n+  data = gst_type_find_peek (tf, 0, 20 + 64 * 1024 + 768 + 12);\n+  if (!data)\n+    return;\n+\n+  if (GST_READ_UINT32_LE (data + i + 8) != w * h)\n+    return;\n+\n+  gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, IDCIN_CAPS);\n+}\n+\n+\/*** video\/x-idcin ***\/\n+\n+static GstStaticCaps mm_caps = GST_STATIC_CAPS (\"application\/x-mm\");\n+\n+#define MM_CAPS (gst_static_caps_get(&mm_caps))\n+static void\n+mm_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 24 + 6);\n+  if (!data)\n+    return;\n+\n+  \/\/ See ffmpeg\/libavformat\/mm.c:probe() for details\n+  gint len, type, fps, w, h;\n+\n+  if (GST_READ_UINT16_LE (&data[0]) != 0x00)\n+    return;\n+  len = GST_READ_UINT32_LE (&data[2]);\n+  if (len != 22 && len != 24)\n+    return;\n+  fps = GST_READ_UINT16_LE (&data[8]);\n+  w = GST_READ_UINT16_LE (&data[12]);\n+  h = GST_READ_UINT16_LE (&data[14]);\n+  if (!fps || fps > 60 || !w || w > 2048 || !h || h > 2048)\n+    return;\n+  type = GST_READ_UINT16_LE (&data[len]);\n+  if (!type || type > 0x31)\n+    return;\n+\n+  gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, MM_CAPS);\n+}\n+\n+\/*** video\/x-ipmovie ***\/\n+\n+static GstStaticCaps ipmovie_caps = GST_STATIC_CAPS (\"video\/x-ipmovie\");\n+\n+#define IPMOVIE_CAPS (gst_static_caps_get(&ipmovie_caps))\n+static void\n+ipmovie_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data;\n+  guint64 length;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 4096)\n+    length = 4096;\n+\n+  static const char signature[] = \"Interplay MVE File\\x1A\\0\\x1A\";\n+  if (length < sizeof (signature))\n+    return;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  for (gsize i = 0; i < length - sizeof (signature); i++) {\n+    if (memcmp (data + i, signature, sizeof (signature)) != 0) {\n+      gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, IPMOVIE_CAPS);\n+      return;\n+    }\n+  }\n+}\n+\n+\/*** application\/vnd.smaf ***\/\n+\n+static GstStaticCaps mmf_caps = GST_STATIC_CAPS (\"application\/vnd.smaf\");\n+\n+#define MMF_CAPS (gst_static_caps_get(&mmf_caps))\n+static void\n+mmf_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data = gst_type_find_peek (tf, 0, 12);\n+  if (!data)\n+    return;\n+\n+  if (data[0] == 'M' && data[1] == 'M' &&\n+      data[2] == 'M' && data[3] == 'D' &&\n+      data[8] == 'C' && data[9] == 'N' && data[10] == 'T' && data[11] == 'I')\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, MMF_CAPS);\n+}\n+\n+\/*** video\/x-nsv ***\/\n+\n+static GstStaticCaps nsv_caps = GST_STATIC_CAPS (\"video\/x-nsv\");\n+\n+#define NSV_CAPS (gst_static_caps_get(&nsv_caps))\n+static void\n+nsv_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  static const guint8 marker[4] = { 'N', 'S', 'V', 's', };\n+  const guint8 *data;\n+  guint64 length;\n+  gsize i;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 4096)\n+    length = 4096;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 4)\n+    return;\n+\n+  if (data[0] == 'N' && data[1] == 'S' &&\n+      data[2] == 'V' && (data[3] == 'f' || data[3] == 's')) {\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, NSV_CAPS);\n+    return;\n+  }\n+\n+  if (length < 24)\n+    return;\n+\n+  for (i = 1; i < length - 23; i++) {\n+    if (memcmp (&data[i], marker, sizeof (marker)) == 0) {\n+      gsize offset = i + 23;\n+      if (offset < length) {\n+        guint32 vsize = GST_READ_UINT24_LE (&data[i + 19]) >> 4;\n+        guint32 asize = GST_READ_UINT16_LE (&data[i + 22]) >> 4;\n+        offset += asize + vsize;\n+        if (offset + 1 < length && GST_READ_UINT16_LE (&data[offset]) == 0xBEEF) {\n+          gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, NSV_CAPS);\n+          return;\n+        }\n+      }\n+      gst_type_find_suggest (tf, GST_TYPE_FIND_MINIMUM, NSV_CAPS);\n+      return;\n+    }\n+  }\n+}\n+\n+\/*** application\/x-nut ***\/\n+\n+static GstStaticCaps nut_caps = GST_STATIC_CAPS (\"application\/x-nut\");\n+\n+#define NUT_CAPS (gst_static_caps_get(&nut_caps))\n+static void\n+nut_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  guint64 marker = (0x7A561F5F04ADULL + (((guint64) ('N' << 8) + 'M') << 48));\n+  const guint8 *data;\n+  guint64 length;\n+  gsize i;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 4096)\n+    length = 4096;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 8)\n+    return;\n+\n+  for (i = 0; i < length - 8; i++) {\n+    if (GST_READ_UINT64_BE (&data[i]) == marker) {\n+      gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, NUT_CAPS);\n+      return;\n+    }\n+  }\n+}\n+\n+\/*** application\/x-pxstr ***\/\n+\n+static GstStaticCaps pxstr_caps = GST_STATIC_CAPS (\"application\/x-pxstr\");\n+\n+#define PXSTR_CAPS (gst_static_caps_get(&pxstr_caps))\n+static void\n+pxstr_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  static const guint8 sync_header[] =\n+      { 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0x00\n+  };\n+  static const gsize raw_cd_sector_size = 2352;\n+  const guint8 *data;\n+  guint64 length;\n+  int n_vid = 0, n_aud = 0;\n+  gsize i;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > raw_cd_sector_size * 5)\n+    length = raw_cd_sector_size * 5;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 12)\n+    return;\n+\n+  if (GST_READ_UINT32_LE (data) == GST_MAKE_FOURCC ('R', 'I', 'F', 'F')\n+      && GST_READ_UINT32_LE (&data[8]) == GST_MAKE_FOURCC ('C', 'D', 'X', 'A')) {\n+    length -= 0x2C;\n+    data = &data[0x2C];\n+  }\n+\n+  \/\/ minimum CD sector size\n+  if (length < raw_cd_sector_size)\n+    return;\n+\n+  for (i = 0; i < length;) {\n+    if (length - i > 0x25)\n+      break;\n+\n+    if (memcmp (&data[i], sync_header, sizeof (sync_header)) != 0)\n+      return;\n+\n+    if (data[i + 0x11] >= 32)\n+      return;\n+\n+    switch (data[i + 0x12] & 0x0E) {\n+        \/* data and video *\/\n+      case 0x08:\n+      case 0x02:{\n+        gint16 current_sector = (gint16) GST_READ_UINT16_LE (&data[i + 0x1C]);\n+        gint16 sector_count = (gint16) GST_READ_UINT16_LE (&data[i + 0x1E]);\n+        gint16 frame_size = (gint16) GST_READ_UINT16_LE (&data[i + 0x24]);\n+\n+        if (!(frame_size > 0\n+                && current_sector < sector_count\n+                && sector_count * 0x780 >= frame_size))\n+          return;\n+\n+        n_vid++;\n+        break;\n+      }\n+        \/* audio *\/\n+      case 0x04:{\n+        if (data[i + 0x13] & 0x2A)\n+          return;\n+        n_aud++;\n+        break;\n+      }\n+      default:\n+        if (data[i + 0x12] & 0x0E)\n+          return;\n+        break;\n+    }\n+    i += raw_cd_sector_size;\n+  }\n+\n+  if (n_aud + n_vid > 3)\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, PXSTR_CAPS);\n+  else if (n_aud + n_vid)\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MINIMUM, PXSTR_CAPS);\n+}\n+\n+\/*** application\/x-smk ***\/\n+\n+static GstStaticCaps smk_caps = GST_STATIC_CAPS (\"application\/x-smk\");\n+\n+#define SMK_CAPS (gst_static_caps_get(&smk_caps))\n+static void\n+smk_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data;\n+  guint64 length;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 12)\n+    length = 12;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 12)\n+    return;\n+\n+  if (GST_READ_UINT32_LE (data) != GST_MAKE_FOURCC ('S', 'M', 'K', '2')\n+      && GST_READ_UINT32_LE (data) != GST_MAKE_FOURCC ('S', 'M', 'K', '4')) {\n+    return;\n+  }\n+\n+  if (GST_READ_UINT32_LE (&data[4]) > 32768\n+      || GST_READ_UINT32_LE (&data[8]) > 32768) {\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MINIMUM, SMK_CAPS);\n+  } else {\n+    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SMK_CAPS);\n+  }\n+}\n+\n+\/*** application\/x-sol ***\/\n+\n+static GstStaticCaps sol_caps = GST_STATIC_CAPS (\"application\/x-sol\");\n+\n+#define SOL_CAPS (gst_static_caps_get(&sol_caps))\n+static void\n+sol_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data;\n+  guint64 length;\n+  guint16 magic;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 8)\n+    length = 8;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 8)\n+    return;\n+\n+  magic = (guint16) GST_READ_UINT32_LE (data);\n+  if (magic != 0x0b8d && magic != 0x0c0d && magic != 0x0c8d)\n+    return;\n+\n+  if (GST_READ_UINT32_BE (&data[4]) != GST_MAKE_FOURCC ('S', 'O', 'L', 0))\n+    return;\n+\n+  gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SOL_CAPS);\n+}\n+\n+\/*** application\/x-vmd ***\/\n+\n+static GstStaticCaps vmd_caps = GST_STATIC_CAPS (\"application\/x-vmd\");\n+\n+#define VMD_CAPS (gst_static_caps_get(&vmd_caps))\n+static void\n+vmd_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data;\n+  guint64 length;\n+  int w, h, rate;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 806)\n+    length = 806;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 806)\n+    return;\n+\n+  if (GST_READ_UINT16_LE (data) != 0x0330 - 2)\n+    return;\n+\n+  w = GST_READ_UINT16_LE (&data[12]);\n+  h = GST_READ_UINT16_LE (&data[14]);\n+  rate = GST_READ_UINT16_LE (&data[804]);\n+  if ((!w || w > 2048 || !h || h > 2048)\n+      && rate != 22050)\n+    return;\n+  gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, VMD_CAPS);\n+}\n+\n+\/*** application\/x-wc3movie ***\/\n+\n+static GstStaticCaps wc3movie_caps = GST_STATIC_CAPS (\"application\/x-wc3movie\");\n+\n+#define WC3MOVIE_CAPS (gst_static_caps_get(&wc3movie_caps))\n+static void\n+wc3movie_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data;\n+  guint64 length;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 12)\n+    length = 12;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 12)\n+    return;\n+\n+  if (GST_READ_UINT32_LE (data) != GST_MAKE_FOURCC ('F', 'O', 'R', 'M')\n+      || GST_READ_UINT32_LE (&data[8]) != GST_MAKE_FOURCC ('M', 'O', 'V', 'E'))\n+    return;\n+\n+  gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, WC3MOVIE_CAPS);\n+}\n+\n+\/*** application\/x-wsaud ***\/\n+\n+static GstStaticCaps wsaud_caps = GST_STATIC_CAPS (\"application\/x-wsaud\");\n+\n+#define WSAUD_CAPS (gst_static_caps_get(&wsaud_caps))\n+static void\n+wsaud_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data;\n+  guint64 length;\n+  int rate;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 20)\n+    length = 20;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 20)\n+    return;\n+\n+  rate = GST_READ_UINT16_LE (data);\n+  if (rate < 8000 || rate > 48000)\n+    return;\n+\n+  if (data[10] & 0xfc)\n+    return;\n+\n+  if (data[11] != 99 && data[11] != 1)\n+    return;\n+\n+  if (GST_READ_UINT32_LE (&data[16]) != 0x0000DEAF)\n+    return;\n+\n+  gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, WSAUD_CAPS);\n+}\n+\n+\/*** application\/x-wsvqa ***\/\n+\n+static GstStaticCaps wsvqa_caps = GST_STATIC_CAPS (\"application\/x-wsvqa\");\n+\n+#define WSVQA_CAPS (gst_static_caps_get(&wsvqa_caps))\n+static void\n+wsvqa_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  const guint8 *data;\n+  guint64 length;\n+\n+  length = gst_type_find_get_length (tf);\n+  if (length == 0 || length > 12)\n+    length = 12;\n+\n+  data = gst_type_find_peek (tf, 0, length);\n+  if (!data)\n+    return;\n+\n+  if (length < 12)\n+    return;\n+\n+  if (GST_READ_UINT32_BE (data) != GST_MAKE_FOURCC ('F', 'O', 'R', 'M')\n+      || GST_READ_UINT32_BE (&data[8]) != GST_MAKE_FOURCC ('W', 'V', 'Q', 'A'))\n+    return;\n+\n+  gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, WSVQA_CAPS);\n+}\n+\n@@ -6212,1 +6909,42 @@\n-#endif \/\/ GSTREAMER_LITE\n\\ No newline at end of file\n+GST_TYPE_FIND_REGISTER_DEFINE (brstm, \"audio\/x-brstm\", GST_RANK_SECONDARY,\n+    brstm_type_find, \"brstm\", BRSTM_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (bfstm, \"audio\/x-bfstm\", GST_RANK_SECONDARY,\n+    bfstm_type_find, \"bfstm,bcstm\", BFSTM_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (dsf, \"audio\/x-dsf\", GST_RANK_PRIMARY,\n+    dsf_type_find, NULL, DSF_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (ea, \"video\/x-ea\", GST_RANK_SECONDARY,\n+    ea_type_find, NULL, EA_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (film_cpk, \"video\/x-film-cpk\", GST_RANK_SECONDARY,\n+    film_cpk_type_find, \"cpk\", FILM_CPK_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (gxf, \"application\/gxf\", GST_RANK_SECONDARY,\n+    gxf_type_find, NULL, GXF_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (iff, \"application\/x-iff\", GST_RANK_SECONDARY,\n+    iff_type_find, NULL, IFF_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (ipmovie, \"application\/x-ipmovie\",\n+    GST_RANK_SECONDARY, ipmovie_type_find, NULL, IPMOVIE_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (idcin, \"video\/x-idcin\", GST_RANK_MARGINAL,\n+    idcin_type_find, NULL, IDCIN_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (mm, \"application\/x-mm\", GST_RANK_MARGINAL,\n+    mm_type_find, NULL, MM_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (mmf, \"application\/vnd.smaf\", GST_RANK_SECONDARY,\n+    mmf_type_find, \"mmf\", MMF_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (nsv, \"video\/x-nsv\", GST_RANK_MARGINAL,\n+    nsv_type_find, \"nsv\", NSV_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (nut, \"application\/x-nut\", GST_RANK_MARGINAL,\n+    nut_type_find, \"nut\", NUT_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (pxstr, \"application\/x-pxstr\", GST_RANK_MARGINAL,\n+    pxstr_type_find, \"pxstr\", PXSTR_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (smk, \"application\/x-smk\", GST_RANK_MARGINAL,\n+    smk_type_find, \"smk\", SMK_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (sol, \"application\/x-sol\", GST_RANK_MARGINAL,\n+    sol_type_find, \"sol\", SOL_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (vmd, \"application\/x-vmd\", GST_RANK_MARGINAL,\n+    vmd_type_find, \"vmd\", VMD_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (wc3movie, \"application\/x-wc3movie\",\n+    GST_RANK_MARGINAL, wc3movie_type_find, \"wc3movie\", WC3MOVIE_CAPS, NULL,\n+    NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (wsaud, \"application\/x-wsaud\", GST_RANK_MARGINAL,\n+    wsaud_type_find, \"wsaud\", WSAUD_CAPS, NULL, NULL);\n+GST_TYPE_FIND_REGISTER_DEFINE (wsvqa, \"application\/x-wsvqa\", GST_RANK_MARGINAL,\n+    wsvqa_type_find, \"wsvqa\", WSVQA_CAPS, NULL, NULL);\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctions.c","additions":775,"deletions":37,"binary":false,"changes":812,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  g_slice_free (GstTypeFindData, sw_data);\n+  g_free (sw_data);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctionsdata.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  GST_TYPE_FIND_REGISTER (fourxm, plugin);\n@@ -57,0 +58,1 @@\n+  GST_TYPE_FIND_REGISTER (xwma, plugin);\n@@ -60,0 +62,1 @@\n+  GST_TYPE_FIND_REGISTER (avs, plugin);\n@@ -212,0 +215,7 @@\n+  GST_TYPE_FIND_REGISTER (brstm, plugin);\n+  GST_TYPE_FIND_REGISTER (bfstm, plugin);\n+  GST_TYPE_FIND_REGISTER (dsf, plugin);\n+  GST_TYPE_FIND_REGISTER (ea, plugin);\n+  GST_TYPE_FIND_REGISTER (film_cpk, plugin);\n+  GST_TYPE_FIND_REGISTER (gxf, plugin);\n+  GST_TYPE_FIND_REGISTER (iff, plugin);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctionsplugin.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+GST_TYPE_FIND_REGISTER_DECLARE (fourxm);\n+GST_TYPE_FIND_REGISTER_DECLARE (xwma);\n@@ -47,0 +49,1 @@\n+GST_TYPE_FIND_REGISTER_DECLARE (avs);\n@@ -94,0 +97,1 @@\n+GST_TYPE_FIND_REGISTER_DECLARE (yuv4mpeg);\n@@ -198,0 +202,20 @@\n+GST_TYPE_FIND_REGISTER_DECLARE (brstm);\n+GST_TYPE_FIND_REGISTER_DECLARE (bfstm);\n+GST_TYPE_FIND_REGISTER_DECLARE (dsf);\n+GST_TYPE_FIND_REGISTER_DECLARE (ea);\n+GST_TYPE_FIND_REGISTER_DECLARE (film_cpk);\n+GST_TYPE_FIND_REGISTER_DECLARE (gxf);\n+GST_TYPE_FIND_REGISTER_DECLARE (iff);\n+GST_TYPE_FIND_REGISTER_DECLARE (idcin);\n+GST_TYPE_FIND_REGISTER_DECLARE (ipmovie);\n+GST_TYPE_FIND_REGISTER_DECLARE (mm);\n+GST_TYPE_FIND_REGISTER_DECLARE (mmf);\n+GST_TYPE_FIND_REGISTER_DECLARE (nsv);\n+GST_TYPE_FIND_REGISTER_DECLARE (nut);\n+GST_TYPE_FIND_REGISTER_DECLARE (pxstr);\n+GST_TYPE_FIND_REGISTER_DECLARE (smk);\n+GST_TYPE_FIND_REGISTER_DECLARE (sol);\n+GST_TYPE_FIND_REGISTER_DECLARE (vmd);\n+GST_TYPE_FIND_REGISTER_DECLARE (wc3movie);\n+GST_TYPE_FIND_REGISTER_DECLARE (wsaud);\n+GST_TYPE_FIND_REGISTER_DECLARE (wsvqa);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctionsplugin.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  GstTypeFindData *sw_data = g_slice_new (GstTypeFindData);             \\\n+  GstTypeFindData *sw_data = g_new (GstTypeFindData, 1);             \\\n@@ -84,0 +84,4 @@\n+TYPE_FIND_REGISTER_RIFF_DEFINE (fourxm, \"video\/x-4xm\", GST_RANK_PRIMARY,\n+    NULL, \"4XMV\");\n+TYPE_FIND_REGISTER_RIFF_DEFINE (xwma, \"audio\/x-xwma\", GST_RANK_PRIMARY,\n+    NULL, \"XWMA\");\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctionsriff.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  GstTypeFindData *sw_data = g_slice_new (GstTypeFindData);             \\\n+  GstTypeFindData *sw_data = g_new (GstTypeFindData, 1);             \\\n@@ -180,0 +180,4 @@\n+TYPE_FIND_REGISTER_START_WITH_DEFINE (avs, \"video\/x-avs\",\n+    GST_RANK_SECONDARY, NULL, \"wW\\x10\\x00\", 4, GST_TYPE_FIND_LIKELY);\n+TYPE_FIND_REGISTER_START_WITH_DEFINE (yuv4mpeg, \"application\/x-yuv4mpeg\",\n+    GST_RANK_MARGINAL, NULL, \"YUV4MPEG2\", 9, GST_TYPE_FIND_MAXIMUM);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctionsstartwith.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,2 +65,1 @@\n-\/* the volume factor is a range from 0.0 to (arbitrary) VOLUME_MAX_DOUBLE = 10.0\n- * we map 1.0 to VOLUME_UNITY_INT*\n+\/* we map VOLUME_UNITY_INT* to volume = 1.0\n@@ -76,1 +75,0 @@\n-#define VOLUME_MAX_DOUBLE            10.0\n@@ -85,0 +83,2 @@\n+#define VOLUME_MAX_INT64             G_MAXINT64\n+#define VOLUME_MIN_INT64             G_MININT64\n@@ -103,1 +103,2 @@\n-  PROP_VOLUME\n+  PROP_VOLUME,\n+  PROP_VOLUME_FULL_RANGE\n@@ -147,0 +148,2 @@\n+static void volume_process_int32_via_double_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes);\n@@ -153,0 +156,2 @@\n+static void volume_process_int24_via_float_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes);\n@@ -159,0 +164,2 @@\n+static void volume_process_int16_via_float_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes);\n@@ -165,0 +172,2 @@\n+static void volume_process_int8_via_float_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes);\n@@ -188,1 +197,6 @@\n-        self->process = volume_process_int32_clamp;\n+        \/* Fixed-point multiplication only supports small subset of volumes *\/\n+        if (self->current_vol_i32 > VOLUME_MAX_INT32) {\n+          self->process = volume_process_int32_via_double_with_clamp;\n+        } else {\n+          self->process = volume_process_int32_clamp;\n+        }\n@@ -197,1 +211,6 @@\n-        self->process = volume_process_int24_clamp;\n+        \/* Fixed-point multiplication only supports small subset of volumes *\/\n+        if (self->current_vol_i24 > VOLUME_MAX_INT24) {\n+          self->process = volume_process_int24_via_float_with_clamp;\n+        } else {\n+          self->process = volume_process_int24_clamp;\n+        }\n@@ -206,1 +225,6 @@\n-        self->process = volume_process_int16_clamp;\n+        \/* Fixed-point multiplication only supports small subset of volumes *\/\n+        if (self->current_vol_i16 > VOLUME_MAX_INT16) {\n+          self->process = volume_process_int16_via_float_with_clamp;\n+        } else {\n+          self->process = volume_process_int16_clamp;\n+        }\n@@ -215,1 +239,6 @@\n-        self->process = volume_process_int8_clamp;\n+        \/* Fixed-point multiplication only supports small subset of volumes *\/\n+        if (self->current_vol_i8 > VOLUME_MAX_INT8) {\n+          self->process = volume_process_int8_via_float_with_clamp;\n+        } else {\n+          self->process = volume_process_int8_clamp;\n+        }\n@@ -259,10 +288,43 @@\n-    self->current_vol_i8 =\n-        (gint) ((gdouble) volume * (gdouble) VOLUME_UNITY_INT8);\n-    self->current_vol_i16 =\n-        (gint) ((gdouble) volume * (gdouble) VOLUME_UNITY_INT16);\n-    self->current_vol_i24 =\n-        (gint) ((gdouble) volume * (gdouble) VOLUME_UNITY_INT24);\n-    self->current_vol_i32 =\n-        (gint) ((gdouble) volume * (gdouble) VOLUME_UNITY_INT32);\n-\n-    passthrough = (self->current_vol_i16 == VOLUME_UNITY_INT16);\n+    gdouble current_fp_vol_i8 = (gdouble) volume * (gdouble) VOLUME_UNITY_INT8;\n+    gdouble current_fp_vol_i16 =\n+        (gdouble) volume * (gdouble) VOLUME_UNITY_INT16;\n+    gdouble current_fp_vol_i24 =\n+        (gdouble) volume * (gdouble) VOLUME_UNITY_INT24;\n+    gdouble current_fp_vol_i32 =\n+        (gdouble) volume * (gdouble) VOLUME_UNITY_INT32;\n+\n+    \/* Perform \"saturating\" FP->int conversion.\n+     * We want to be able to tell when current_fp_vol_i32 is *larger* than\n+     * VOLUME_MAX_INT32, *and* don't have UB on FP->int cast overflow,\n+     * `2 * VOLUME_MAX_INT32` achieves both of these points.\n+     *\/\n+    self->current_vol_i8 = (glong) (CLAMP (current_fp_vol_i8, (gdouble) 0,\n+            (gdouble) 2 * VOLUME_MAX_INT32));\n+    self->current_vol_i16 = (glong) (CLAMP (current_fp_vol_i16, (gdouble) 0,\n+            (gdouble) 2 * VOLUME_MAX_INT32));\n+    self->current_vol_i24 = (glong) (CLAMP (current_fp_vol_i24, (gdouble) 0,\n+            (gdouble) 2 * VOLUME_MAX_INT32));\n+    self->current_vol_i32 = (glong) (CLAMP (current_fp_vol_i32, (gdouble) 0,\n+            (gdouble) 2 * VOLUME_MAX_INT32));\n+\n+    switch (GST_AUDIO_INFO_FORMAT (info)) {\n+      case GST_AUDIO_FORMAT_F32:\n+      case GST_AUDIO_FORMAT_F64:\n+        passthrough = (self->current_volume == 1.0);\n+        break;\n+      case GST_AUDIO_FORMAT_S8:\n+        passthrough = (self->current_vol_i8 == VOLUME_UNITY_INT8);\n+        break;\n+      case GST_AUDIO_FORMAT_S16:\n+        passthrough = (self->current_vol_i16 == VOLUME_UNITY_INT16);\n+        break;\n+      case GST_AUDIO_FORMAT_S24:\n+        passthrough = (self->current_vol_i24 == VOLUME_UNITY_INT24);\n+        break;\n+      case GST_AUDIO_FORMAT_S32:\n+        passthrough = (self->current_vol_i32 == VOLUME_UNITY_INT32);\n+        break;\n+      default:\n+        passthrough = FALSE;\n+        break;\n+    }\n@@ -326,0 +388,17 @@\n+  \/**\n+   * GstVolume:volume-full-range:\n+   *\n+   * The volume-full-range factor is a range from 0.0 to G_MAXDOUBLE so\n+   * it is *very* inclusive, e.g. gain of +48 dB is very reasonable. This\n+   * property allows setting higher value than the #GstVolume:volume property.\n+   *\n+   * Since: 1.24\n+   *\/\n+  \/* This property has been exposed as another property to keep the backward compatibility\n+   * when using #GstDirectControlBinding with GstDirectControlBinding:absolute set to FALSE. *\/\n+  g_object_class_install_property (gobject_class, PROP_VOLUME_FULL_RANGE,\n+      g_param_spec_double (\"volume-full-range\", \"Volume\",\n+          \"volume factor with a full range of values, 1.0=100%\", 0.0,\n+          G_MAXDOUBLE, DEFAULT_PROP_VOLUME,\n+          G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));\n+\n@@ -328,1 +407,1 @@\n-          0.0, VOLUME_MAX_DOUBLE, DEFAULT_PROP_VOLUME,\n+          0.0, 10.0, DEFAULT_PROP_VOLUME,\n@@ -444,0 +523,20 @@\n+\/\/ TODO: Add ORC implementation for this\n+static void\n+volume_process_int32_via_double_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes)\n+{\n+  gint32 *data = (gint32 *) bytes;\n+  guint i;\n+  guint num_samples = n_bytes \/ sizeof (gint32);\n+  \/* Cast between the 32-bit integer and 32-bit floating point is lossy,\n+   * but not between 64-bit floating point, so use it instead. *\/\n+  \/* WARNING: (gint32)((gfloat)VOLUME_MAX_INT32)) is UB! *\/\n+  gdouble vol = self->current_volume;\n+  gdouble val;\n+\n+  for (i = 0; i < num_samples; i++) {\n+    val = *data * vol;\n+    *data++ = (gint32) CLAMP (val, VOLUME_MIN_INT32, VOLUME_MAX_INT32);\n+  }\n+}\n+\n@@ -467,0 +566,1 @@\n+\/* NOTE: does not sign-extend, result is an 24-bit unsigned integer! *\/\n@@ -477,0 +577,1 @@\n+\/* NOTE: does not sign-extend, result is an 24-bit unsigned integer! *\/\n@@ -486,0 +587,3 @@\n+#define sign_extend_i24(_x)                                                    \\\n+  (((gint32)(((guint32)(_x)) << (32 - 24))) >> (32 - 24))\n+\n@@ -532,0 +636,24 @@\n+static void\n+volume_process_int24_via_float_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes)\n+{\n+  gint8 *data = (gint8 *) bytes;        \/* treat the data as a byte stream *\/\n+  guint i, num_samples;\n+  guint32 samp;\n+  gfloat vol = self->current_volume;\n+  gfloat val;\n+\n+  num_samples = n_bytes \/ (sizeof (gint8) * 3);\n+  for (i = 0; i < num_samples; i++) {\n+    samp = get_unaligned_i24 (data);    \/* NOT SIGN-EXTENDED!!! *\/\n+\n+    val = (gfloat) (sign_extend_i24 (samp));\n+    val *= vol;\n+    \/* NOTE: we *MUST* first cast FP to int, and only then to unsigned. *\/\n+    samp = (guint32) ((gint32) CLAMP (val, VOLUME_MIN_INT24, VOLUME_MAX_INT24));\n+\n+    \/* write the value back into the stream *\/\n+    write_unaligned_u24 (data, samp);\n+  }\n+}\n+\n@@ -575,0 +703,17 @@\n+\/\/ TODO: Add ORC implementation for this\n+static void\n+volume_process_int16_via_float_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes)\n+{\n+  gint16 *data = (gint16 *) bytes;\n+  guint i;\n+  guint num_samples = n_bytes \/ sizeof (gint16);\n+  gfloat vol = self->current_volume;\n+  gfloat val;\n+\n+  for (i = 0; i < num_samples; i++) {\n+    val = *data * vol;\n+    *data++ = (gint16) CLAMP (val, VOLUME_MIN_INT16, VOLUME_MAX_INT16);\n+  }\n+}\n+\n@@ -623,0 +768,18 @@\n+\/\/ TODO: Add ORC implementation for this\n+static void\n+volume_process_int8_via_float_with_clamp (GstVolume * self,\n+    gpointer bytes, guint n_bytes)\n+{\n+  gint8 *data = (gint8 *) bytes;\n+  guint i;\n+  guint num_samples = n_bytes \/ sizeof (gint8);\n+  gfloat vol = self->current_volume;\n+  gfloat val;\n+\n+  for (i = 0; i < num_samples; i++) {\n+    val = *data;\n+    val *= vol;\n+    *data++ = (gint8) CLAMP (val, VOLUME_MIN_INT8, VOLUME_MAX_INT8);\n+  }\n+}\n+\n@@ -839,0 +1002,5 @@\n+    case PROP_VOLUME_FULL_RANGE:\n+      GST_OBJECT_LOCK (self);\n+      self->volume = g_value_get_double (value);\n+      GST_OBJECT_UNLOCK (self);\n+      break;\n@@ -858,0 +1026,11 @@\n+      GST_OBJECT_LOCK (self);\n+      if (self->volume > 10.0) {\n+        GST_WARNING_OBJECT (object,\n+            \"Volume is greater than its max value 10.0, reporting as 10.0\");\n+        g_value_set_double (value, 10.0);\n+      } else {\n+        g_value_set_double (value, self->volume);\n+      }\n+      GST_OBJECT_UNLOCK (self);\n+      break;\n+    case PROP_VOLUME_FULL_RANGE:\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/volume\/gstvolume.c","additions":198,"deletions":19,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -55,4 +55,4 @@\n-  gint   current_vol_i32;\n-  gint   current_vol_i24; \/* the _i(nt) values get synchronized with the *\/\n-  gint   current_vol_i16; \/* the _i(nt) values get synchronized with the *\/\n-  gint   current_vol_i8;   \/* the _i(nt) values get synchronized with the *\/\n+  gint64 current_vol_i32;\n+  gint64 current_vol_i24; \/* the _i(nt) values get synchronized with the *\/\n+  gint64 current_vol_i16; \/* the _i(nt) values get synchronized with the *\/\n+  gint64 current_vol_i8;  \/* the _i(nt) values get synchronized with the *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/volume\/gstvolume.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -307,0 +307,10 @@\n+#define FOURCC_SHQ0     GST_MAKE_FOURCC('S','H','Q','0')\n+#define FOURCC_SHQ1     GST_MAKE_FOURCC('S','H','Q','1')\n+#define FOURCC_SHQ2     GST_MAKE_FOURCC('S','H','Q','2')\n+#define FOURCC_SHQ3     GST_MAKE_FOURCC('S','H','Q','3')\n+#define FOURCC_SHQ4     GST_MAKE_FOURCC('S','H','Q','4')\n+#define FOURCC_SHQ5     GST_MAKE_FOURCC('S','H','Q','5')\n+#define FOURCC_SHQ6     GST_MAKE_FOURCC('S','H','Q','6')\n+#define FOURCC_SHQ7     GST_MAKE_FOURCC('S','H','Q','7')\n+#define FOURCC_SHQ8     GST_MAKE_FOURCC('S','H','Q','8')\n+#define FOURCC_SHQ9     GST_MAKE_FOURCC('S','H','Q','9')\n@@ -428,0 +438,3 @@\n+#define FOURCC_sbgp     GST_MAKE_FOURCC('s','b','g','p')\n+#define FOURCC_sgpd     GST_MAKE_FOURCC('s','g','p','d')\n+#define FOURCC_seig     GST_MAKE_FOURCC('s','e','i','g')\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/fourcc.h","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -245,0 +245,5 @@\n+  \/* sample groups *\/\n+  GPtrArray *track_group_properties;\n+  GPtrArray *fragment_group_properties;\n+  GPtrArray *sample_to_group_map;\n+\n@@ -399,0 +404,2 @@\n+static void qtdemux_check_if_is_gapless_audio (GstQTDemux * qtdemux);\n+\n@@ -487,0 +494,5 @@\n+  g_free (qtdemux->cenc_aux_info_sizes);\n+  g_mutex_clear (&qtdemux->expose_lock);\n+\n+  g_ptr_array_free (qtdemux->active_streams, TRUE);\n+  g_ptr_array_free (qtdemux->old_streams, TRUE);\n@@ -496,6 +508,3 @@\n-  if (qtdemux->adapter) {\n-    g_object_unref (G_OBJECT (qtdemux->adapter));\n-    qtdemux->adapter = NULL;\n-  }\n-  gst_tag_list_unref (qtdemux->tag_list);\n-  gst_flow_combiner_free (qtdemux->flowcombiner);\n+  g_clear_object (&qtdemux->adapter);\n+  gst_clear_tag_list (&qtdemux->tag_list);\n+  g_clear_pointer (&qtdemux->flowcombiner, gst_flow_combiner_unref);\n@@ -513,7 +522,0 @@\n-  g_free (qtdemux->cenc_aux_info_sizes);\n-  qtdemux->cenc_aux_info_sizes = NULL;\n-  g_mutex_clear (&qtdemux->expose_lock);\n-\n-  g_ptr_array_free (qtdemux->active_streams, TRUE);\n-  g_ptr_array_free (qtdemux->old_streams, TRUE);\n-\n@@ -684,1 +686,6 @@\n-    *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux->duration);\n+    \/* If this is single-stream audio media with gapless data,\n+     * report the duration of the valid subset of the overall data. *\/\n+    if (qtdemux->gapless_audio_info.type != GAPLESS_AUDIO_INFO_TYPE_NONE)\n+      *duration = qtdemux->gapless_audio_info.valid_duration;\n+    else\n+      *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux->duration);\n@@ -1175,0 +1182,4 @@\n+    \/* raw audio streams can be ignored as we can seek anywhere within them *\/\n+    if (str->subtype == FOURCC_soun && str->need_clip)\n+      continue;\n+\n@@ -1457,2 +1468,2 @@\n-    before = ! !(flags & GST_SEEK_FLAG_SNAP_BEFORE);\n-    after = ! !(flags & GST_SEEK_FLAG_SNAP_AFTER);\n+    before = !!(flags & GST_SEEK_FLAG_SNAP_BEFORE);\n+    after = !!(flags & GST_SEEK_FLAG_SNAP_AFTER);\n@@ -1538,2 +1549,2 @@\n-  flush = ! !(flags & GST_SEEK_FLAG_FLUSH);\n-  instant_rate_change = ! !(flags & GST_SEEK_FLAG_INSTANT_RATE_CHANGE);\n+  flush = !!(flags & GST_SEEK_FLAG_FLUSH);\n+  instant_rate_change = !!(flags & GST_SEEK_FLAG_INSTANT_RATE_CHANGE);\n@@ -1686,1 +1697,1 @@\n-      instant_rate_change = ! !(flags & GST_SEEK_FLAG_INSTANT_RATE_CHANGE);\n+      instant_rate_change = !!(flags & GST_SEEK_FLAG_INSTANT_RATE_CHANGE);\n@@ -2037,1 +2048,2 @@\n-  if (hard || qtdemux->upstream_format_is_time) {\n+  if (hard || qtdemux->upstream_format_is_time\n+      || qtdemux->variant == VARIANT_MSE_BYTESTREAM) {\n@@ -2090,0 +2102,5 @@\n+    qtdemux->gapless_audio_info.type = GAPLESS_AUDIO_INFO_TYPE_NONE;\n+    qtdemux->gapless_audio_info.num_start_padding_pcm_frames = 0;\n+    qtdemux->gapless_audio_info.num_end_padding_pcm_frames = 0;\n+    qtdemux->gapless_audio_info.num_valid_pcm_frames = 0;\n+\n@@ -2145,0 +2162,2 @@\n+  } else if (qtdemux->variant == VARIANT_MSE_BYTESTREAM) {\n+    \/* Do nothing *\/\n@@ -2637,0 +2656,6 @@\n+      if (info->fragment_group_properties)\n+        g_ptr_array_free (info->fragment_group_properties, TRUE);\n+      if (info->track_group_properties)\n+        g_ptr_array_free (info->track_group_properties, TRUE);\n+      if (info->sample_to_group_map)\n+        g_ptr_array_free (info->sample_to_group_map, FALSE);\n@@ -3311,1 +3336,1 @@\n-    GST_WARNING_OBJECT (qtdemux,\n+    GST_INFO_OBJECT (qtdemux,\n@@ -3398,1 +3423,1 @@\n-    gboolean has_tfdt)\n+    gboolean has_tfdt, guint trun_node_total)\n@@ -3442,0 +3467,11 @@\n+\n+    if (qtdemux->variant == VARIANT_MSS_FRAGMENTED\n+        && data_offset <= moof_length\n+        && *base_offset == -1 && trun_node_total == 1) {\n+      \/* MSS spec states that, if only one TrunBox is specified, then the\n+       * DataOffset field MUST be the sum of the lengths of the MoofBox and all\n+       * the fields in the MdatBox field *\/\n+      GST_WARNING_OBJECT (qtdemux,\n+          \"trun offset is less than the moof size, assuming offset is after moof\");\n+      data_offset = moof_length + 8;\n+    }\n@@ -3843,0 +3879,1 @@\n+  GstStructure *properties = NULL;\n@@ -3850,3 +3887,258 @@\n-  \/* Currently, cenc properties for groups of samples are not supported, so\n-   * simply return a copy of the default sample properties *\/\n-  return gst_structure_copy (info->default_properties);\n+  \/* First check if the sample is associated with the 'seig' sample group. *\/\n+  if (info->sample_to_group_map\n+      && sample_index < info->sample_to_group_map->len)\n+    properties = g_ptr_array_index (info->sample_to_group_map, sample_index);\n+\n+  \/* If not, use the default properties for this sample. *\/\n+  if (!properties)\n+    properties = info->default_properties;\n+\n+  return gst_structure_copy (properties);\n+}\n+\n+static gboolean\n+qtdemux_parse_sbgp (GstQTDemux * qtdemux, QtDemuxStream * stream,\n+    GstByteReader * br, guint32 group, GPtrArray ** sample_to_group_array,\n+    GstStructure * default_properties, GPtrArray * tack_properties_array,\n+    GPtrArray * group_properties_array)\n+{\n+  guint32 flags = 0;\n+  guint8 version = 0;\n+  guint32 count = 0;\n+  const guint8 *grouping_type_data = NULL;\n+  guint32 grouping_type = 0;\n+\n+  g_return_val_if_fail (qtdemux != NULL, FALSE);\n+  g_return_val_if_fail (stream != NULL, FALSE);\n+  g_return_val_if_fail (br != NULL, FALSE);\n+  g_return_val_if_fail (*sample_to_group_array == NULL, FALSE);\n+  g_return_val_if_fail (group_properties_array != NULL, FALSE);\n+\n+  if (!gst_byte_reader_get_uint32_be (br, &flags))\n+    return FALSE;\n+\n+  if (!gst_byte_reader_get_data (br, 4, &grouping_type_data))\n+    return FALSE;\n+\n+  grouping_type = QT_FOURCC (grouping_type_data);\n+  if (grouping_type != group) {\n+    \/* There may be other groups, so just log this... *\/\n+    GST_DEBUG_OBJECT (qtdemux, \"Unsupported grouping type: '%\"\n+        GST_FOURCC_FORMAT \"'\", GST_FOURCC_ARGS (grouping_type));\n+    return FALSE;\n+  }\n+\n+  version = (flags >> 24);\n+  if (version > 0) {\n+    GST_WARNING_OBJECT (qtdemux, \"Unsupported 'sbgp' box version: %hhu\",\n+        version);\n+    return FALSE;\n+  }\n+\n+  if (!gst_byte_reader_get_uint32_be (br, &count))\n+    return FALSE;\n+\n+  GST_LOG_OBJECT (qtdemux, \"flags: %08x, type: '%\" GST_FOURCC_FORMAT\n+      \"', count: %u\", flags, GST_FOURCC_ARGS (grouping_type), count);\n+\n+  if (count > 0)\n+    *sample_to_group_array = g_ptr_array_sized_new (count);\n+\n+  while (count--) {\n+    guint32 samples;\n+    guint32 index;\n+    GstStructure *properties = NULL;\n+\n+    if (!gst_byte_reader_get_uint32_be (br, &samples))\n+      goto error;\n+\n+    if (!gst_byte_reader_get_uint32_be (br, &index))\n+      goto error;\n+\n+    if (index > 0x10000) {\n+      \/* Index is referring the current fragment. *\/\n+      index -= 0x10001;\n+      if (index < group_properties_array->len)\n+        properties = g_ptr_array_index (group_properties_array, index);\n+      else\n+        GST_ERROR_OBJECT (qtdemux, \"invalid group index %u\", index);\n+    } else if (index > 0) {\n+      \/* Index is referring to the whole track. *\/\n+      index--;\n+      if (index < tack_properties_array->len)\n+        properties = g_ptr_array_index (tack_properties_array, index);\n+      else\n+        GST_ERROR_OBJECT (qtdemux, \"invalid group index %u\", index);\n+    } else {\n+      \/* If zero, then this range of samples does not belong to this group,\n+         perhaps to another one or to none at all. *\/\n+    }\n+\n+    GST_DEBUG_OBJECT (qtdemux, \"assigning group '%\" GST_FOURCC_FORMAT\n+        \"' index %i for the next %i samples: %\" GST_PTR_FORMAT,\n+        GST_FOURCC_ARGS (grouping_type), index, samples, properties);\n+\n+    while (samples--)\n+      g_ptr_array_add (*sample_to_group_array, properties);\n+  }\n+\n+  return TRUE;\n+\n+error:\n+  g_ptr_array_free (*sample_to_group_array, TRUE);\n+  *sample_to_group_array = NULL;\n+  return FALSE;\n+}\n+\n+static gboolean\n+qtdemux_parse_sgpd (GstQTDemux * qtdemux, QtDemuxStream * stream,\n+    GstByteReader * br, guint32 group, GPtrArray ** properties)\n+{\n+  guint32 flags = 0;\n+  guint8 version = 0;\n+  guint32 default_length = 0;\n+  guint32 count = 0;\n+  const guint8 *grouping_type_data = NULL;\n+  guint32 grouping_type = 0;\n+  const guint32 min_entry_size = 20;\n+\n+  g_return_val_if_fail (qtdemux != NULL, FALSE);\n+  g_return_val_if_fail (stream != NULL, FALSE);\n+  g_return_val_if_fail (br != NULL, FALSE);\n+  g_return_val_if_fail (*properties == NULL, FALSE);\n+\n+  if (!gst_byte_reader_get_uint32_be (br, &flags))\n+    return FALSE;\n+\n+  if (!gst_byte_reader_get_data (br, 4, &grouping_type_data))\n+    return FALSE;\n+\n+  grouping_type = QT_FOURCC (grouping_type_data);\n+  if (grouping_type != group) {\n+    GST_WARNING_OBJECT (qtdemux, \"Unhandled grouping type: '%\"\n+        GST_FOURCC_FORMAT \"'\", GST_FOURCC_ARGS (grouping_type));\n+    return FALSE;\n+  }\n+\n+  version = (flags >> 24);\n+  if (version == 1) {\n+    if (!gst_byte_reader_get_uint32_be (br, &default_length))\n+      return FALSE;\n+  } else if (version > 1) {\n+    GST_WARNING_OBJECT (qtdemux, \"Unsupported 'sgpd' box version: %hhu\",\n+        version);\n+    return FALSE;\n+  }\n+\n+  if (!gst_byte_reader_get_uint32_be (br, &count))\n+    return FALSE;\n+\n+  GST_LOG_OBJECT (qtdemux, \"flags: %08x, type: '%\" GST_FOURCC_FORMAT\n+      \"', count: %u\", flags, GST_FOURCC_ARGS (grouping_type), count);\n+\n+  if (count)\n+    *properties = g_ptr_array_sized_new (count);\n+\n+  for (guint32 index = 0; index < count; index++) {\n+    GstStructure *props = NULL;\n+    guint32 length = default_length;\n+    const guint8 *entry_data = NULL;\n+    guint8 is_encrypted = 0;\n+    guint8 iv_size = 0;\n+    guint8 constant_iv_size = 0;\n+    const guint8 *kid = NULL;\n+    guint8 crypt_byte_block = 0;\n+    guint8 skip_byte_block = 0;\n+    const guint8 *constant_iv = NULL;\n+    GstBuffer *kid_buf;\n+\n+    if (version == 1 && length == 0) {\n+      if (!gst_byte_reader_get_uint32_be (br, &length))\n+        goto error;\n+    }\n+\n+    if (G_UNLIKELY (length < min_entry_size)) {\n+      GST_ERROR_OBJECT (qtdemux, \"Invalid entry size: %u\", length);\n+      goto error;\n+    }\n+\n+    if (!gst_byte_reader_get_data (br, length, &entry_data))\n+      goto error;\n+\n+    \/* Follows tenc format... *\/\n+    is_encrypted = QT_UINT8 (entry_data + 2);\n+    iv_size = QT_UINT8 (entry_data + 3);\n+    kid = (entry_data + 4);\n+\n+    if (stream->protection_scheme_type == FOURCC_cbcs) {\n+      guint8 possible_pattern_info;\n+\n+      if (iv_size == 0) {\n+        if (G_UNLIKELY (length < min_entry_size + 1)) {\n+          GST_ERROR_OBJECT (qtdemux, \"Invalid entry size: %u\", length);\n+          goto error;\n+        }\n+\n+        constant_iv_size = QT_UINT8 (entry_data + 20);\n+        if (G_UNLIKELY (constant_iv_size != 8 && constant_iv_size != 16)) {\n+          GST_ERROR_OBJECT (qtdemux,\n+              \"constant IV size should be 8 or 16, not %hhu\", constant_iv_size);\n+          goto error;\n+        }\n+\n+        if (G_UNLIKELY (length < min_entry_size + 1 + constant_iv_size)) {\n+          GST_ERROR_OBJECT (qtdemux, \"Invalid entry size: %u\", length);\n+          goto error;\n+        }\n+\n+        constant_iv = (entry_data + 21);\n+      }\n+\n+      possible_pattern_info = QT_UINT8 (entry_data + 1);\n+      crypt_byte_block = (possible_pattern_info >> 4) & 0x0f;\n+      skip_byte_block = possible_pattern_info & 0x0f;\n+    }\n+\n+    kid_buf = gst_buffer_new_memdup (kid, 16);\n+\n+    props = gst_structure_new (\"application\/x-cenc\",\n+        \"iv_size\", G_TYPE_UINT, iv_size,\n+        \"encrypted\", G_TYPE_BOOLEAN, is_encrypted == 1,\n+        \"kid\", GST_TYPE_BUFFER, kid_buf, NULL);\n+\n+    gst_buffer_unref (kid_buf);\n+\n+    if (stream->protection_scheme_type == FOURCC_cbcs) {\n+      if (crypt_byte_block != 0 || skip_byte_block != 0) {\n+        gst_structure_set (props,\n+            \"crypt_byte_block\", G_TYPE_UINT, crypt_byte_block,\n+            \"skip_byte_block\", G_TYPE_UINT, skip_byte_block, NULL);\n+      }\n+\n+      if (constant_iv != NULL) {\n+        GstBuffer *constant_iv_buf = gst_buffer_new_memdup (\n+            (guint8 *) constant_iv, constant_iv_size);\n+        gst_structure_set (props,\n+            \"constant_iv_size\", G_TYPE_UINT, constant_iv_size,\n+            \"iv\", GST_TYPE_BUFFER, constant_iv_buf, NULL);\n+        gst_buffer_unref (constant_iv_buf);\n+      }\n+\n+      gst_structure_set (props, \"cipher-mode\", G_TYPE_STRING, \"cbcs\", NULL);\n+    } else {\n+      gst_structure_set (props, \"cipher-mode\", G_TYPE_STRING, \"cenc\", NULL);\n+    }\n+\n+    GST_INFO_OBJECT (qtdemux, \"properties for group '%\"\n+        GST_FOURCC_FORMAT \"' at index %u: %\" GST_PTR_FORMAT,\n+        GST_FOURCC_ARGS (grouping_type), index, props);\n+\n+    g_ptr_array_add (*properties, props);\n+  }\n+\n+  return TRUE;\n+\n+error:\n+  g_ptr_array_free (*properties, TRUE);\n+  *properties = NULL;\n+  return FALSE;\n@@ -4208,0 +4500,1 @@\n+    guint trun_node_total = 0;\n@@ -4219,0 +4512,49 @@\n+    \/* Sample grouping support *\/\n+    if (stream != NULL && stream->protected\n+        && (stream->protection_scheme_type == FOURCC_cenc\n+            || stream->protection_scheme_type == FOURCC_cbcs)) {\n+      QtDemuxCencSampleSetInfo *info = stream->protection_scheme_info;\n+      GNode *sgpd_node;\n+      GstByteReader sgpd_data;\n+\n+      if (info->fragment_group_properties) {\n+        g_ptr_array_free (info->fragment_group_properties, TRUE);\n+        info->fragment_group_properties = NULL;\n+      }\n+\n+      if (info->sample_to_group_map) {\n+        g_ptr_array_free (info->sample_to_group_map, FALSE);\n+        info->sample_to_group_map = NULL;\n+      }\n+\n+      \/* Check if sample grouping information is present for this segment. *\/\n+      \/* However look only for 'seig' (CENC encryption) grouping type... *\/\n+      sgpd_node = qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_sgpd,\n+          &sgpd_data);\n+      while (sgpd_node) {\n+        if (qtdemux_parse_sgpd (qtdemux, stream, &sgpd_data, FOURCC_seig,\n+                &info->fragment_group_properties)) {\n+          \/* CENC encryption grouping found, don't look further. *\/\n+          break;\n+        }\n+        sgpd_node = qtdemux_tree_get_sibling_by_type_full (sgpd_node,\n+            FOURCC_sgpd, &sgpd_data);\n+      }\n+\n+      if (info->fragment_group_properties) {\n+        GstByteReader sbgp_data;\n+        GNode *sbgp_node = qtdemux_tree_get_child_by_type_full (traf_node,\n+            FOURCC_sbgp, &sbgp_data);\n+        while (sbgp_node) {\n+          if (qtdemux_parse_sbgp (qtdemux, stream, &sbgp_data, FOURCC_seig,\n+                  &info->sample_to_group_map, info->default_properties,\n+                  info->track_group_properties,\n+                  info->fragment_group_properties)) {\n+            break;\n+          }\n+          sbgp_node = qtdemux_tree_get_sibling_by_type_full (sbgp_node,\n+              FOURCC_sgpd, &sbgp_data);\n+        }\n+      }\n+    }\n+\n@@ -4327,0 +4669,14 @@\n+    \/* Count the number of trun nodes *\/\n+    if (qtdemux->variant == VARIANT_MSS_FRAGMENTED) {\n+      trun_node =\n+          qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_trun,\n+          &trun_data);\n+      while (trun_node) {\n+        trun_node_total++;\n+        trun_node =\n+            qtdemux_tree_get_sibling_by_type_full (trun_node, FOURCC_trun,\n+            &trun_data);\n+      }\n+      GST_LOG_OBJECT (qtdemux, \"%u trun node(s) available\", trun_node_total);\n+    }\n+\n@@ -4334,1 +4690,1 @@\n-          &running_offset, decode_time, (tfdt_node != NULL));\n+          &running_offset, decode_time, (tfdt_node != NULL), trun_node_total);\n@@ -5094,1 +5450,6 @@\n-    str->to_sample = str->from_sample - 1;\n+    if (str->from_sample == 0) {\n+      GST_LOG_OBJECT (qtdemux, \"already at sample 0\");\n+      str->to_sample = 0;\n+    } else {\n+      str->to_sample = str->from_sample - 1;\n+    }\n@@ -5247,0 +5608,8 @@\n+  \/* Gapless audio requires adjustments to the segment\n+   * to reflect the actual playtime length. In\n+   * particular, this must exclude padding data. *\/\n+  if (qtdemux->gapless_audio_info.type != GAPLESS_AUDIO_INFO_TYPE_NONE) {\n+    stream->segment.stop = stream->segment.start +\n+        qtdemux->gapless_audio_info.valid_duration;\n+  }\n+\n@@ -6154,0 +6523,77 @@\n+  if (qtdemux->gapless_audio_info.type != GAPLESS_AUDIO_INFO_TYPE_NONE) {\n+    guint64 num_start_padding_pcm_frames;\n+    guint64 audio_sample_offset;\n+    guint64 audio_sample_offset_end;\n+    guint64 start_of_trailing_padding;\n+    guint64 start_clip = 0, end_clip = 0;\n+    guint64 total_num_clipped_samples;\n+    GstClockTime timestamp_decrement;\n+\n+    \/* Attach GstAudioClippingMeta to exclude padding data. *\/\n+\n+    num_start_padding_pcm_frames =\n+        qtdemux->gapless_audio_info.num_start_padding_pcm_frames;\n+\n+    audio_sample_offset = stream->sample_index * stream->stts_duration;\n+    audio_sample_offset_end = audio_sample_offset + stream->stts_duration;\n+    start_of_trailing_padding = num_start_padding_pcm_frames +\n+        qtdemux->gapless_audio_info.num_valid_pcm_frames;\n+\n+    if (audio_sample_offset < num_start_padding_pcm_frames) {\n+      guint64 num_padding_audio_samples =\n+          num_start_padding_pcm_frames - audio_sample_offset;\n+      start_clip = MIN (num_padding_audio_samples, stream->stts_duration);\n+    }\n+\n+    timestamp_decrement = qtdemux->gapless_audio_info.start_padding_duration;\n+\n+    if (audio_sample_offset >= start_of_trailing_padding) {\n+      \/* This case happens when the buffer is located fully past\n+       * the beginning of the padding area at the end of the stream.\n+       * Add the end padding to the decrement amount to ensure\n+       * continuous timestamps when transitioning from gapless\n+       * media to gapless media. *\/\n+      end_clip = stream->stts_duration;\n+      timestamp_decrement += qtdemux->gapless_audio_info.end_padding_duration;\n+    } else if (audio_sample_offset_end >= start_of_trailing_padding) {\n+      \/* This case happens when the beginning of the padding area that\n+       * is located at the end of the stream intersects the buffer. *\/\n+      end_clip = audio_sample_offset_end - start_of_trailing_padding;\n+    }\n+\n+    total_num_clipped_samples = start_clip + end_clip;\n+\n+    if (total_num_clipped_samples != 0) {\n+      GST_DEBUG_OBJECT (qtdemux, \"adding audio clipping meta: start \/ \"\n+          \"end clip: %\" G_GUINT64_FORMAT \" \/ %\" G_GUINT64_FORMAT,\n+          start_clip, end_clip);\n+      gst_buffer_add_audio_clipping_meta (buf, GST_FORMAT_DEFAULT,\n+          start_clip, end_clip);\n+\n+      if (total_num_clipped_samples >= stream->stts_duration) {\n+        GST_BUFFER_DURATION (buf) = 0;\n+        GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DECODE_ONLY);\n+        GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DROPPABLE);\n+      } else {\n+        guint64 num_valid_samples =\n+            stream->stts_duration - total_num_clipped_samples;\n+        GST_BUFFER_DURATION (buf) =\n+            QTSTREAMTIME_TO_GSTTIME (stream, num_valid_samples);\n+      }\n+    }\n+\n+    \/* The timestamps need to be shifted to factor in the skipped padding data. *\/\n+\n+    if (GST_BUFFER_PTS_IS_VALID (buf)) {\n+      GstClockTime ts = GST_BUFFER_PTS (buf);\n+      GST_BUFFER_PTS (buf) =\n+          (ts >= timestamp_decrement) ? (ts - timestamp_decrement) : 0;\n+    }\n+\n+    if (GST_BUFFER_DTS_IS_VALID (buf)) {\n+      GstClockTime ts = GST_BUFFER_DTS (buf);\n+      GST_BUFFER_DTS (buf) =\n+          (ts >= timestamp_decrement) ? (ts - timestamp_decrement) : 0;\n+    }\n+  }\n+\n@@ -7306,0 +7752,123 @@\n+static void\n+qtdemux_check_if_is_gapless_audio (GstQTDemux * qtdemux)\n+{\n+  QtDemuxStream *stream;\n+\n+  if (QTDEMUX_N_STREAMS (qtdemux) != 1)\n+    goto incompatible_stream;\n+\n+  stream = QTDEMUX_NTH_STREAM (qtdemux, 0);\n+\n+  if (stream->subtype != FOURCC_soun || stream->n_segments != 1)\n+    goto incompatible_stream;\n+\n+  \/* Gapless audio info from revdns tags (most notably iTunSMPB) is\n+   * detected in the main udta node. If it isn't present, try as\n+   * fallback to recognize the encoder name, and apply known priming\n+   * and padding quantities specific to the encoder. *\/\n+  if (qtdemux->gapless_audio_info.type == GAPLESS_AUDIO_INFO_TYPE_NONE) {\n+    const gchar *orig_encoder_name = NULL;\n+\n+    if (gst_tag_list_peek_string_index (qtdemux->tag_list, GST_TAG_ENCODER, 0,\n+            &orig_encoder_name) && orig_encoder_name != NULL) {\n+      gchar *lowercase_encoder_name = g_ascii_strdown (orig_encoder_name, -1);\n+\n+      if (strstr (lowercase_encoder_name, \"nero\") != NULL)\n+        qtdemux->gapless_audio_info.type = GAPLESS_AUDIO_INFO_TYPE_NERO;\n+\n+      g_free (lowercase_encoder_name);\n+\n+      switch (qtdemux->gapless_audio_info.type) {\n+        case GAPLESS_AUDIO_INFO_TYPE_NERO:{\n+          guint64 total_length;\n+          guint64 valid_length;\n+          guint64 start_padding;\n+\n+          \/* The Nero AAC encoder always uses a lead-in of 1600 PCM frames.\n+           * Also, in Nero AAC's case, stream->duration contains the number\n+           * of PCM frames with start padding but without end padding.\n+           * The decoder delay equals 1 frame length, which is covered by\n+           * factoring stream->stts_duration into the start padding. *\/\n+          start_padding = 1600 + stream->stts_duration;\n+\n+          if (G_UNLIKELY (stream->duration < start_padding)) {\n+            GST_ERROR_OBJECT (qtdemux, \"stream duration is %\" G_GUINT64_FORMAT\n+                \" but start_padding is %\" G_GUINT64_FORMAT, stream->duration,\n+                start_padding);\n+            goto invalid_gapless_audio_info;\n+          }\n+          valid_length = stream->duration - start_padding;\n+\n+          qtdemux->gapless_audio_info.num_start_padding_pcm_frames =\n+              start_padding;\n+          qtdemux->gapless_audio_info.num_valid_pcm_frames = valid_length;\n+\n+          total_length = stream->n_samples * stream->stts_duration;\n+\n+          if (G_LIKELY (total_length >= valid_length)) {\n+            guint64 total_padding = total_length - valid_length;\n+            if (G_UNLIKELY (total_padding < start_padding)) {\n+              GST_ERROR_OBJECT (qtdemux, \"total_padding is %\" G_GUINT64_FORMAT\n+                  \" but start_padding is %\" G_GUINT64_FORMAT, total_padding,\n+                  start_padding);\n+              goto invalid_gapless_audio_info;\n+            }\n+\n+            qtdemux->gapless_audio_info.num_end_padding_pcm_frames =\n+                total_padding - start_padding;\n+          } else {\n+            qtdemux->gapless_audio_info.num_end_padding_pcm_frames = 0;\n+          }\n+\n+          GST_DEBUG_OBJECT (qtdemux, \"media was encoded with Nero AAC encoder; \"\n+              \"using encoder specific lead-in and padding figures\");\n+        }\n+\n+        default:\n+          break;\n+      }\n+    }\n+  }\n+\n+  if (qtdemux->gapless_audio_info.type != GAPLESS_AUDIO_INFO_TYPE_NONE) {\n+    qtdemux->gapless_audio_info.start_padding_duration =\n+        QTSTREAMTIME_TO_GSTTIME (stream,\n+        qtdemux->gapless_audio_info.num_start_padding_pcm_frames);\n+    qtdemux->gapless_audio_info.end_padding_duration =\n+        QTSTREAMTIME_TO_GSTTIME (stream,\n+        qtdemux->gapless_audio_info.num_end_padding_pcm_frames);\n+    qtdemux->gapless_audio_info.valid_duration =\n+        QTSTREAMTIME_TO_GSTTIME (stream,\n+        qtdemux->gapless_audio_info.num_valid_pcm_frames);\n+  }\n+\n+  GST_DEBUG_OBJECT (qtdemux, \"found valid gapless audio info: num start \/ end \"\n+      \"PCM padding frames: %\" G_GUINT64_FORMAT \" \/ %\" G_GUINT64_FORMAT \"; \"\n+      \"start \/ end padding durations: %\" GST_TIME_FORMAT \" \/ %\" GST_TIME_FORMAT\n+      \"; num valid PCM frames: %\" G_GUINT64_FORMAT \"; valid duration: %\"\n+      GST_TIME_FORMAT, qtdemux->gapless_audio_info.num_start_padding_pcm_frames,\n+      qtdemux->gapless_audio_info.num_end_padding_pcm_frames,\n+      GST_TIME_ARGS (qtdemux->gapless_audio_info.start_padding_duration),\n+      GST_TIME_ARGS (qtdemux->gapless_audio_info.end_padding_duration),\n+      qtdemux->gapless_audio_info.num_valid_pcm_frames,\n+      GST_TIME_ARGS (qtdemux->gapless_audio_info.valid_duration));\n+\n+  return;\n+\n+incompatible_stream:\n+  if (G_UNLIKELY (qtdemux->gapless_audio_info.type !=\n+          GAPLESS_AUDIO_INFO_TYPE_NONE)) {\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"media contains gapless audio info, but it is not suitable for \"\n+        \"gapless audio playback (media must be audio-only, single-stream, \"\n+        \"single-segment; ignoring unusable gapless info\");\n+    qtdemux->gapless_audio_info.type = GAPLESS_AUDIO_INFO_TYPE_NONE;\n+  }\n+  return;\n+\n+invalid_gapless_audio_info:\n+  GST_WARNING_OBJECT (qtdemux,\n+      \"media contains invalid\/unusable gapless audio info\");\n+  return;\n+}\n+\n@@ -7971,3 +8540,3 @@\n-          if (G_UNLIKELY (demux->segment.stop != -1\n-                  && demux->segment.stop <= stream_pts && keyframe)\n-              && !(demux->upstream_format_is_time && demux->segment.rate < 0)) {\n+          if (G_UNLIKELY (stream->segment.stop != -1\n+                  && stream->segment.stop <= stream_pts && keyframe)\n+              && !(demux->upstream_format_is_time && stream->segment.rate < 0)) {\n@@ -7979,1 +8548,0 @@\n-            demux->offset += demux->neededbytes;\n@@ -7981,1 +8549,0 @@\n-            \/* check if all streams are eos *\/\n@@ -7983,6 +8550,0 @@\n-            for (i = 0; i < QTDEMUX_N_STREAMS (demux); i++) {\n-              if (!STREAM_IS_EOS (QTDEMUX_NTH_STREAM (demux, i))) {\n-                ret = GST_FLOW_OK;\n-                break;\n-              }\n-            }\n@@ -9109,7 +9670,2 @@\n-      if (CUR_STREAM (stream)->n_channels > 2) {\n-        \/* FIXME: Need to parse the 'chan' atom to get channel layouts\n-         * correctly; this is just the minimum we can do - assume\n-         * we don't actually have any channel positions. *\/\n-        gst_caps_set_simple (CUR_STREAM (stream)->caps,\n-            \"channel-mask\", GST_TYPE_BITMASK, G_GUINT64_CONSTANT (0), NULL);\n-      }\n+      \/* FIXME: Need to parse the 'chan' atom to get channel layouts\n+       * correctly. *\/\n@@ -9690,1 +10246,1 @@\n-          ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stss,\n+          !!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stss,\n@@ -9708,1 +10264,1 @@\n-            ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stps,\n+            !!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stps,\n@@ -9808,1 +10364,1 @@\n-          ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_ctts,\n+          !!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_ctts,\n@@ -11731,1 +12287,1 @@\n-            gboolean full_range = len == 19 ? colr_data[17] >> 7 : FALSE;\n+            gboolean full_range = len == 19 ? colr_data[18] >> 7 : FALSE;\n@@ -13634,0 +14190,13 @@\n+  }\n+\n+  \/* Sample grouping support *\/\n+  if (stream->protected && (stream->protection_scheme_type == FOURCC_cenc\n+          || stream->protection_scheme_type == FOURCC_cbcs)) {\n+    QtDemuxCencSampleSetInfo *info = stream->protection_scheme_info;\n+    GNode *sgpd_node;\n+    GstByteReader sgpd_data;\n+\n+    if (info->track_group_properties) {\n+      g_ptr_array_free (info->fragment_group_properties, TRUE);\n+      info->fragment_group_properties = NULL;\n+    }\n@@ -13635,0 +14204,10 @@\n+    sgpd_node = qtdemux_tree_get_child_by_type_full (stbl, FOURCC_sgpd,\n+        &sgpd_data);\n+    while (sgpd_node) {\n+      if (qtdemux_parse_sgpd (qtdemux, stream, &sgpd_data, FOURCC_seig,\n+              &info->track_group_properties)) {\n+        break;\n+      }\n+      sgpd_node = qtdemux_tree_get_sibling_by_type_full (sgpd_node,\n+          FOURCC_sgpd, &sgpd_data);\n+    }\n@@ -13676,0 +14255,12 @@\n+  \/* https:\/\/dev.w3.org\/html5\/html-sourcing-inband-tracks\/#mpeg4\n+   * FIXME: For CEA 608 and CEA 708 we should use the channel_number and\n+   * service_number respectively.\n+   *\/\n+  if (stream->track_id) {\n+    gchar *track_id_str =\n+        g_strdup_printf (\"%\" G_GUINT32_FORMAT, stream->track_id);\n+    gst_tag_list_add (stream->stream_tags, GST_TAG_MERGE_REPLACE,\n+        GST_TAG_CONTAINER_SPECIFIC_TRACK_ID, track_id_str, NULL);\n+    g_free (track_id_str);\n+  }\n+\n@@ -13891,0 +14482,2 @@\n+  qtdemux_check_if_is_gapless_audio (qtdemux);\n+\n@@ -15411,0 +16004,19 @@\n+    case FOURCC_SHQ0:\n+    case FOURCC_SHQ1:\n+    case FOURCC_SHQ2:\n+    case FOURCC_SHQ3:\n+    case FOURCC_SHQ4:\n+    case FOURCC_SHQ5:\n+    case FOURCC_SHQ6:\n+    case FOURCC_SHQ7:\n+    case FOURCC_SHQ8:\n+    case FOURCC_SHQ9:{\n+      gchar *format =\n+          g_strdup_printf (\"%\" GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));\n+      _codec (\"SpeedHQ\");\n+      caps =\n+          gst_caps_new_simple (\"video\/x-speedhq\", \"variant\", G_TYPE_STRING,\n+          format, NULL);\n+      g_free (format);\n+      break;\n+    }\n@@ -15783,1 +16395,1 @@\n-    stream->max_buffer_size = 4096 * entry->bytes_per_frame;\n+    stream->max_buffer_size = entry->rate * entry->bytes_per_frame;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux.c","additions":662,"deletions":50,"binary":false,"changes":712,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+typedef struct _QtDemuxGaplessAudioInfo QtDemuxGaplessAudioInfo;\n@@ -81,0 +82,30 @@\n+typedef enum {\n+  \/* No valid gapless audio info present. Types other than this one\n+   * are used only if all of these apply:\n+   *\n+   * 1. There is embedded gapless audio information available\n+   * 2. Only one stream exists\n+   * 3. Said stream has only one segment\n+   * 4. Said stream is an audio stream\n+   *\/\n+  GAPLESS_AUDIO_INFO_TYPE_NONE,\n+  \/* Using information from the iTunes iTunSMPB revdns tag. *\/\n+  GAPLESS_AUDIO_INFO_TYPE_ITUNES,\n+  \/* Using known Nero encoder delay information. *\/\n+  GAPLESS_AUDIO_INFO_TYPE_NERO\n+} QtDemuxGaplessAudioInfoType;\n+\n+\/* Gapless audio information, only used for single-stream audio-only media. *\/\n+struct _QtDemuxGaplessAudioInfo {\n+  QtDemuxGaplessAudioInfoType type;\n+\n+  guint64 num_start_padding_pcm_frames;\n+  guint64 num_end_padding_pcm_frames;\n+  guint64 num_valid_pcm_frames;\n+\n+  \/* PCM frame amounts converted to nanoseconds. *\/\n+  GstClockTime start_padding_duration;\n+  GstClockTime end_padding_duration;\n+  GstClockTime valid_duration;\n+};\n+\n@@ -180,0 +211,2 @@\n+  QtDemuxGaplessAudioInfo gapless_audio_info;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"qtdemux_debug.h\"\n@@ -49,0 +50,2 @@\n+#define GST_CAT_DEFAULT qtdemux_debug\n+\n@@ -723,8 +726,8 @@\n-      \"replaygain_track_gain\", GST_TAG_TRACK_GAIN}, {\n-      \"replaygain_track_peak\", GST_TAG_TRACK_PEAK}, {\n-      \"replaygain_album_gain\", GST_TAG_ALBUM_GAIN}, {\n-      \"replaygain_album_peak\", GST_TAG_ALBUM_PEAK}, {\n-      \"MusicBrainz Track Id\", GST_TAG_MUSICBRAINZ_TRACKID}, {\n-      \"MusicBrainz Artist Id\", GST_TAG_MUSICBRAINZ_ARTISTID}, {\n-      \"MusicBrainz Album Id\", GST_TAG_MUSICBRAINZ_ALBUMID}, {\n-      \"MusicBrainz Album Artist Id\", GST_TAG_MUSICBRAINZ_ALBUMARTISTID}\n+          \"replaygain_track_gain\", GST_TAG_TRACK_GAIN}, {\n+          \"replaygain_track_peak\", GST_TAG_TRACK_PEAK}, {\n+          \"replaygain_album_gain\", GST_TAG_ALBUM_GAIN}, {\n+          \"replaygain_album_peak\", GST_TAG_ALBUM_PEAK}, {\n+          \"MusicBrainz Track Id\", GST_TAG_MUSICBRAINZ_TRACKID}, {\n+          \"MusicBrainz Artist Id\", GST_TAG_MUSICBRAINZ_ARTISTID}, {\n+          \"MusicBrainz Album Id\", GST_TAG_MUSICBRAINZ_ALBUMID}, {\n+          \"MusicBrainz Album Artist Id\", GST_TAG_MUSICBRAINZ_ALBUMARTISTID}\n@@ -751,2 +754,100 @@\n-    if (i == G_N_ELEMENTS (tags))\n-      goto unknown_tag;\n+\n+    \/* Some tags might not actually be used for metadata about the media,\n+     * but for other purposes. One such tag is iTunSMPB, which contains\n+     * padding information for gapless playback. Scan these separately. *\/\n+    if (i == G_N_ELEMENTS (tags)) {\n+      if (!g_ascii_strncasecmp (\"iTunSMPB\", namestr, 8)) {\n+        \/* iTunSMPB tag format goes as follows:\n+         *\n+         * \" 00000000 xxxxxxxx yyyyyyyy zzzzzzzzzzzzzzzz 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\"\n+         *\n+         * The data is actually an ASCII string containing these hex fields.\n+         * The description above is _not_ a description of a binary format!\n+         * These need to be parsed with g_ascii_strtoull() and base 16.\n+         *\n+         * (The quotes are not part of it; they just emphasize the\n+         * whitespace at the beginning of the string).\n+         *\n+         * Only the fields marked with x\/y\/z are of interest here.\n+         *\n+         * The x field is the priming, in samples.\n+         * These are the padding samples at the beginning of the stream.\n+         *\n+         * The y field is the remainder, in samples.\n+         * These are the padding samples at the end of the stream.\n+         *\n+         * The z field is the number of valid PCM frames, excluding the\n+         * priming and remainder. (In other words, the number of PCM\n+         * frames that make up the actual audio, without the padding.)\n+         *\n+         * The data starts at offset 16. All access to it must therefore skip\n+         * the first 16 bytes.\n+         *\/\n+\n+        const gsize start_offset = 16;\n+        const gsize priming_offset = start_offset + 10;\n+        const gsize remainder_offset = start_offset + 19;\n+        const gsize num_valid_pcm_frames_offset = start_offset + 28;\n+        const gsize total_length = 44;\n+        const gchar *str;\n+        guint64 priming;\n+        guint64 remainder;\n+        guint64 num_valid_pcm_frames;\n+        \/* Temporary buffer for g_ascii_strtoull() calls.\n+         * Add extra +1 space for nullbyte. *\/\n+        gchar tmp[16 + 1];\n+\n+        \/* Use the iTunSMPB info if no other info has been found yet. *\/\n+        if (demux->gapless_audio_info.type != GAPLESS_AUDIO_INFO_TYPE_NONE) {\n+          GST_DEBUG_OBJECT (demux, \"iTunSMPB information found, \"\n+              \"but other gapless audio info was already read\");\n+          goto finish;\n+        }\n+\n+        if (G_UNLIKELY (datasize < (start_offset + total_length))) {\n+          GST_WARNING_OBJECT (demux,\n+              \"iTunSMPB tag data size too small - not parsing\");\n+          goto finish;\n+        }\n+\n+        str = (gchar *) ((guint8 *) data->data);\n+\n+#define PARSE_ITUNSMPB_FIELD(FIELD_NAME, NUM_DIGITS) \\\n+        G_STMT_START \\\n+        { \\\n+          gint str_idx; \\\n+\\\n+          for (str_idx = 0; str_idx < (NUM_DIGITS); ++str_idx) { \\\n+            gchar ch = str[FIELD_NAME ## _offset + str_idx]; \\\n+            if (!g_ascii_isxdigit (ch)) { \\\n+              GST_WARNING_OBJECT (demux, #FIELD_NAME \" field in iTunSMPB \" \\\n+                  \"tag data has invalid character '%c'\", ch); \\\n+              goto finish; \\\n+            } \\\n+            tmp[str_idx] = ch; \\\n+          } \\\n+          tmp[NUM_DIGITS] = 0; \\\n+\\\n+          FIELD_NAME = g_ascii_strtoull (tmp, NULL, 16); \\\n+        } \\\n+        G_STMT_END\n+\n+        PARSE_ITUNSMPB_FIELD (priming, 8);\n+        PARSE_ITUNSMPB_FIELD (remainder, 8);\n+        PARSE_ITUNSMPB_FIELD (num_valid_pcm_frames, 16);\n+\n+#undef PARSE_ITUNSMPB_FIELD\n+\n+        GST_DEBUG_OBJECT (demux, \"iTunSMPB information: priming %\"\n+            G_GUINT64_FORMAT \" remainder %\" G_GUINT64_FORMAT\n+            \" num valid PCM frames %\" G_GUINT64_FORMAT, priming, remainder,\n+            num_valid_pcm_frames);\n+\n+        demux->gapless_audio_info.type = GAPLESS_AUDIO_INFO_TYPE_ITUNES;\n+        demux->gapless_audio_info.num_start_padding_pcm_frames = priming;\n+        demux->gapless_audio_info.num_end_padding_pcm_frames = remainder;\n+        demux->gapless_audio_info.num_valid_pcm_frames = num_valid_pcm_frames;\n+      } else {\n+        goto unknown_tag;\n+      }\n+    }\n@@ -757,0 +858,1 @@\n+finish:\n@@ -770,1 +872,2 @@\n-        \"file a bug at bugzilla.gnome.org\", meanstr_dbg, namestr_dbg, datatype);\n+        \"file a bug at %s\", meanstr_dbg, namestr_dbg, datatype,\n+        PACKAGE_BUGREPORT);\n@@ -830,57 +933,58 @@\n-  FOURCC__nam, GST_TAG_TITLE, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_titl, GST_TAG_TITLE, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__grp, GST_TAG_GROUPING, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__wrt, GST_TAG_COMPOSER, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__ART, GST_TAG_ARTIST, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_aART, GST_TAG_ALBUM_ARTIST, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_perf, GST_TAG_ARTIST, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_auth, GST_TAG_COMPOSER, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__alb, GST_TAG_ALBUM, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_albm, GST_TAG_ALBUM, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_cprt, GST_TAG_COPYRIGHT, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__cpy, GST_TAG_COPYRIGHT, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__cmt, GST_TAG_COMMENT, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__des, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_desc, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_dscp, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__lyr, GST_TAG_LYRICS, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__day, GST_TAG_DATE, NULL, qtdemux_tag_add_date}, {\n-  FOURCC_yrrc, GST_TAG_DATE, NULL, qtdemux_tag_add_year}, {\n-  FOURCC__too, GST_TAG_ENCODER, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__inf, GST_TAG_COMMENT, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_trkn, GST_TAG_TRACK_NUMBER, GST_TAG_TRACK_COUNT, qtdemux_tag_add_num}, {\n-  FOURCC_disk, GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_ALBUM_VOLUME_COUNT,\n-        qtdemux_tag_add_num}, {\n-  FOURCC_disc, GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_ALBUM_VOLUME_COUNT,\n-        qtdemux_tag_add_num}, {\n-  FOURCC__gen, GST_TAG_GENRE, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_gnre, GST_TAG_GENRE, NULL, qtdemux_tag_add_gnre}, {\n-  FOURCC_tmpo, GST_TAG_BEATS_PER_MINUTE, NULL, qtdemux_tag_add_tmpo}, {\n-  FOURCC_covr, GST_TAG_IMAGE, NULL, qtdemux_tag_add_covr}, {\n-  FOURCC_sonm, GST_TAG_TITLE_SORTNAME, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_soal, GST_TAG_ALBUM_SORTNAME, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_soar, GST_TAG_ARTIST_SORTNAME, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_soaa, GST_TAG_ALBUM_ARTIST_SORTNAME, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_soco, GST_TAG_COMPOSER_SORTNAME, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_sosn, GST_TAG_SHOW_SORTNAME, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_tvsh, GST_TAG_SHOW_NAME, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_tvsn, GST_TAG_SHOW_SEASON_NUMBER, NULL, qtdemux_tag_add_uint32}, {\n-  FOURCC_tves, GST_TAG_SHOW_EPISODE_NUMBER, NULL, qtdemux_tag_add_uint32}, {\n-  FOURCC_kywd, GST_TAG_KEYWORDS, NULL, qtdemux_tag_add_keywords}, {\n-  FOURCC_keyw, GST_TAG_KEYWORDS, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__enc, GST_TAG_ENCODER, NULL, qtdemux_tag_add_str}, {\n-  FOURCC_loci, GST_TAG_GEO_LOCATION_NAME, NULL, qtdemux_tag_add_location}, {\n-  FOURCC_clsf, GST_QT_DEMUX_CLASSIFICATION_TAG, NULL,\n-        qtdemux_tag_add_classification}, {\n-  FOURCC__mak, GST_TAG_DEVICE_MANUFACTURER, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__mod, GST_TAG_DEVICE_MODEL, NULL, qtdemux_tag_add_str}, {\n-  FOURCC__swr, GST_TAG_APPLICATION_NAME, NULL, qtdemux_tag_add_str}, {\n-\n-    \/* This is a special case, some tags are stored in this\n-     * 'reverse dns naming', according to:\n-     * http:\/\/atomicparsley.sourceforge.net\/mpeg-4files.html and\n-     * bug #614471\n-     *\/\n-  FOURCC_____, \"\", NULL, qtdemux_tag_add_revdns}, {\n-    \/* see http:\/\/www.mp4ra.org\/specs.html for ID32 in meta box *\/\n-  FOURCC_ID32, \"\", NULL, qtdemux_tag_add_id32}\n+      FOURCC__nam, GST_TAG_TITLE, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_titl, GST_TAG_TITLE, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__grp, GST_TAG_GROUPING, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__wrt, GST_TAG_COMPOSER, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__ART, GST_TAG_ARTIST, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_aART, GST_TAG_ALBUM_ARTIST, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_perf, GST_TAG_ARTIST, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_auth, GST_TAG_COMPOSER, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__alb, GST_TAG_ALBUM, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_albm, GST_TAG_ALBUM, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_cprt, GST_TAG_COPYRIGHT, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__cpy, GST_TAG_COPYRIGHT, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__cmt, GST_TAG_COMMENT, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__des, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_desc, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_dscp, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__lyr, GST_TAG_LYRICS, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__day, GST_TAG_DATE, NULL, qtdemux_tag_add_date}, {\n+      FOURCC_yrrc, GST_TAG_DATE, NULL, qtdemux_tag_add_year}, {\n+      FOURCC__too, GST_TAG_ENCODER, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__inf, GST_TAG_COMMENT, NULL, qtdemux_tag_add_str}, {\n+        FOURCC_trkn, GST_TAG_TRACK_NUMBER, GST_TAG_TRACK_COUNT,\n+      qtdemux_tag_add_num}, {\n+        FOURCC_disk, GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_ALBUM_VOLUME_COUNT,\n+      qtdemux_tag_add_num}, {\n+        FOURCC_disc, GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_ALBUM_VOLUME_COUNT,\n+      qtdemux_tag_add_num}, {\n+      FOURCC__gen, GST_TAG_GENRE, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_gnre, GST_TAG_GENRE, NULL, qtdemux_tag_add_gnre}, {\n+      FOURCC_tmpo, GST_TAG_BEATS_PER_MINUTE, NULL, qtdemux_tag_add_tmpo}, {\n+      FOURCC_covr, GST_TAG_IMAGE, NULL, qtdemux_tag_add_covr}, {\n+      FOURCC_sonm, GST_TAG_TITLE_SORTNAME, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_soal, GST_TAG_ALBUM_SORTNAME, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_soar, GST_TAG_ARTIST_SORTNAME, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_soaa, GST_TAG_ALBUM_ARTIST_SORTNAME, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_soco, GST_TAG_COMPOSER_SORTNAME, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_sosn, GST_TAG_SHOW_SORTNAME, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_tvsh, GST_TAG_SHOW_NAME, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_tvsn, GST_TAG_SHOW_SEASON_NUMBER, NULL, qtdemux_tag_add_uint32}, {\n+      FOURCC_tves, GST_TAG_SHOW_EPISODE_NUMBER, NULL, qtdemux_tag_add_uint32}, {\n+      FOURCC_kywd, GST_TAG_KEYWORDS, NULL, qtdemux_tag_add_keywords}, {\n+      FOURCC_keyw, GST_TAG_KEYWORDS, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__enc, GST_TAG_ENCODER, NULL, qtdemux_tag_add_str}, {\n+      FOURCC_loci, GST_TAG_GEO_LOCATION_NAME, NULL, qtdemux_tag_add_location}, {\n+        FOURCC_clsf, GST_QT_DEMUX_CLASSIFICATION_TAG, NULL,\n+      qtdemux_tag_add_classification}, {\n+      FOURCC__mak, GST_TAG_DEVICE_MANUFACTURER, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__mod, GST_TAG_DEVICE_MODEL, NULL, qtdemux_tag_add_str}, {\n+      FOURCC__swr, GST_TAG_APPLICATION_NAME, NULL, qtdemux_tag_add_str}, {\n+\n+        \/* This is a special case, some tags are stored in this\n+         * 'reverse dns naming', according to:\n+         * http:\/\/atomicparsley.sourceforge.net\/mpeg-4files.html and\n+         * bug #614471\n+         *\/\n+      FOURCC_____, \"\", NULL, qtdemux_tag_add_revdns}, {\n+        \/* see http:\/\/www.mp4ra.org\/specs.html for ID32 in meta box *\/\n+      FOURCC_ID32, \"\", NULL, qtdemux_tag_add_id32}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux_tags.c","additions":172,"deletions":68,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -236,0 +236,2 @@\n+  {FOURCC_sgpd, \"sample group description\", 0},\n+  {FOURCC_sbgp, \"sample to group\", 0},\n@@ -266,1 +268,1 @@\n-  GST_WARNING (\"unknown QuickTime node type %\" GST_FOURCC_FORMAT,\n+  GST_FIXME (\"unknown QuickTime node type %\" GST_FOURCC_FORMAT,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux_types.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1610,0 +1610,1 @@\n+              gst_buffer_unref (buf);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/wavparse\/gstwavparse.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,4 +47,1 @@\n-  if (!gst_element_register (plugin, \"osxaudiosink\", GST_RANK_PRIMARY,\n-          GST_TYPE_OSX_AUDIO_SINK)) {\n-    return FALSE;\n-  }\n+  gboolean ret = FALSE;\n@@ -53,4 +50,1 @@\n-  if (!gst_element_register (plugin, \"osxaudiosrc\", GST_RANK_PRIMARY,\n-          GST_TYPE_OSX_AUDIO_SRC)) {\n-    return FALSE;\n-  }\n+  ret |= GST_ELEMENT_REGISTER (osxaudiosrc, plugin);\n@@ -59,0 +53,2 @@\n+ret |= GST_ELEMENT_REGISTER (osxaudiosink, plugin);\n+\n@@ -61,3 +57,1 @@\n-  if (!gst_device_provider_register (plugin, \"osxaudiodeviceprovider\",\n-          GST_RANK_PRIMARY, GST_TYPE_OSX_AUDIO_DEVICE_PROVIDER))\n-    return FALSE;\n+  ret |= GST_DEVICE_PROVIDER_REGISTER (osxaudiodeviceprovider, plugin);\n@@ -67,1 +61,1 @@\n-  return TRUE;\n+  return ret;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudio.c","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -177,1 +177,2 @@\n-  AudioStreamBasicDescription format;\n+  AudioStreamBasicDescription format = { 0 };\n+  guint32 frames_per_packet = 0;\n@@ -228,0 +229,2 @@\n+    frames_per_packet = spec->segsize \/ GST_AUDIO_INFO_BPF (&spec->info);\n+\n@@ -242,1 +245,1 @@\n-      is_passthrough);\n+      frames_per_packet, is_passthrough);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudioringbuffer.c","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+GST_ELEMENT_REGISTER_DEFINE (osxaudiosink, \"osxaudiosink\", GST_RANK_PRIMARY,\n+    GST_TYPE_OSX_AUDIO_SINK);\n@@ -565,0 +567,1 @@\n+      CORE_AUDIO_TIMING_LOCK (buf->core_audio);\n@@ -566,0 +569,5 @@\n+      \/* FIXME: Update the timestamp and reported frames in smaller increments\n+       * when the segment size is larger than the total inNumberFrames *\/\n+      gst_core_audio_update_timing (buf->core_audio, inTimeStamp,\n+          inNumberFrames);\n+      CORE_AUDIO_TIMING_UNLOCK (buf->core_audio);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosink.c","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+GST_ELEMENT_REGISTER_DECLARE (osxaudiosink);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosink.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,0 +126,2 @@\n+GST_ELEMENT_REGISTER_DEFINE (osxaudiosrc, \"osxaudiosrc\", GST_RANK_PRIMARY,\n+    GST_TYPE_OSX_AUDIO_SRC);\n@@ -342,0 +344,6 @@\n+  guint64 sample_position;\n+  GstAudioRingBufferSpec *spec = &GST_AUDIO_RING_BUFFER (buf)->spec;\n+  guint bpf = GST_AUDIO_INFO_BPF (&spec->info);\n+\n+  GST_LOG_OBJECT (buf, \"in sample position %f frames %u\",\n+      inTimeStamp->mSampleTime, inNumberFrames);\n@@ -362,0 +370,1 @@\n+  sample_position = inTimeStamp->mSampleTime;\n@@ -380,0 +389,1 @@\n+    sample_position += len \/ bpf;\n@@ -382,0 +392,7 @@\n+      \/* Calculate the timestamp corresponding to the first sample in the segment *\/\n+      guint64 seg_sample_pos = sample_position - (spec->segsize \/ bpf);\n+      GstClockTime ts = gst_util_uint64_scale_int (seg_sample_pos, GST_SECOND,\n+          GST_AUDIO_INFO_RATE (&spec->info));\n+      gst_audio_ring_buffer_set_timestamp (GST_AUDIO_RING_BUFFER (buf),\n+          writeseg, ts);\n+\n@@ -383,0 +400,1 @@\n+      CORE_AUDIO_TIMING_LOCK (buf->core_audio);\n@@ -384,0 +402,5 @@\n+      \/* FIXME: Update the timestamp and reported frames in smaller increments\n+       * when the segment size is larger than the total inNumberFrames *\/\n+      gst_core_audio_update_timing (buf->core_audio, inTimeStamp,\n+          inNumberFrames);\n+      CORE_AUDIO_TIMING_UNLOCK (buf->core_audio);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosrc.c","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+GST_ELEMENT_REGISTER_DECLARE (osxaudiosrc);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosrc.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-GST_DEBUG_CATEGORY_STATIC (osx_audio_debug);\n-#define GST_CAT_DEFAULT osx_audio_debug\n+GST_DEBUG_CATEGORY (osx_coreaudio_debug);\n+#define GST_CAT_DEFAULT osx_coreaudio_debug\n@@ -38,0 +38,8 @@\n+static void\n+gst_core_audio_finalize (GObject * object)\n+{\n+  GstCoreAudio *core_audio = GST_CORE_AUDIO (object);\n+  g_mutex_clear (&core_audio->timing_lock);\n+\n+  G_OBJECT_CLASS (gst_core_audio_parent_class)->finalize (object);\n+}\n@@ -42,0 +50,2 @@\n+  GObjectClass *object_klass = G_OBJECT_CLASS (klass);\n+  object_klass->finalize = gst_core_audio_finalize;\n@@ -57,0 +67,3 @@\n+\n+  mach_timebase_info (&core_audio->timebase);\n+  g_mutex_init (&core_audio->timing_lock);\n@@ -99,0 +112,15 @@\n+static GstClockTime\n+_current_time_ns (GstCoreAudio * core_audio)\n+{\n+  guint64 mach_t = mach_absolute_time ();\n+  return gst_util_uint64_scale (mach_t, core_audio->timebase.numer,\n+      core_audio->timebase.denom);\n+}\n+\n+static GstClockTime\n+_host_time_to_ns (GstCoreAudio * core_audio, uint64_t host_time)\n+{\n+  return gst_util_uint64_scale (host_time, core_audio->timebase.numer,\n+      core_audio->timebase.denom);\n+}\n+\n@@ -205,1 +233,2 @@\n-  return gst_core_audio_get_samples_and_latency_impl (core_audio, rate,\n+  uint64_t now_ns = _current_time_ns (core_audio);\n+  gboolean ret = gst_core_audio_get_samples_and_latency_impl (core_audio, rate,\n@@ -207,0 +236,85 @@\n+\n+  if (!ret)\n+    return FALSE;\n+\n+  CORE_AUDIO_TIMING_LOCK (core_audio);\n+\n+  uint32_t samples_remain = 0;\n+  uint64_t anchor_ns = core_audio->anchor_hosttime_ns;\n+\n+  if (core_audio->is_src) {\n+    int64_t captured_ns =\n+        core_audio->rate_scalar * (int64_t) (now_ns - anchor_ns);\n+\n+    \/* src, the anchor time is the timestamp of the first sample in the last\n+     * packet received, and we increment up from there, unless the device gets stopped. *\/\n+    if (captured_ns > 0) {\n+      if (core_audio->io_proc_active) {\n+        samples_remain = (uint32_t) (captured_ns * rate \/ GST_SECOND);\n+      } else {\n+        samples_remain = core_audio->anchor_pend_samples;\n+      }\n+    } else {\n+      \/* Time went backward. This shouldn't happen for sources, but report something anyway *\/\n+      samples_remain =\n+          (uint32_t) (-captured_ns * rate \/ GST_SECOND) +\n+          core_audio->anchor_pend_samples;\n+    }\n+\n+    GST_DEBUG_OBJECT (core_audio,\n+        \"now_ns %\" G_GUINT64_FORMAT \" anchor %\" G_GUINT64_FORMAT \" elapsed ns %\"\n+        G_GINT64_FORMAT \" rate %f captured_ns %\" G_GINT64_FORMAT\n+        \" anchor_pend_samples %u samples_remain %u\", now_ns, anchor_ns,\n+        now_ns - anchor_ns, rate, captured_ns, core_audio->anchor_pend_samples,\n+        samples_remain);\n+  } else {\n+    \/* Sink, the anchor time is the time the most recent buffer will commence play out,\n+     * and we count down to 0 for unplayed samples beyond that *\/\n+    int64_t unplayed_ns =\n+        core_audio->rate_scalar * (int64_t) (anchor_ns - now_ns);\n+    if (unplayed_ns > 0) {\n+      samples_remain =\n+          (uint32_t) (unplayed_ns * rate \/ GST_SECOND) +\n+          core_audio->anchor_pend_samples;\n+    } else {\n+      uint32_t samples_played = (uint32_t) (-unplayed_ns * rate \/ GST_SECOND);\n+      if (samples_played < core_audio->anchor_pend_samples) {\n+        samples_remain = core_audio->anchor_pend_samples - samples_played;\n+      }\n+    }\n+\n+    GST_DEBUG_OBJECT (core_audio,\n+        \"now_ns %\" G_GUINT64_FORMAT \" anchor %\" G_GUINT64_FORMAT \" elapsed ns %\"\n+        G_GINT64_FORMAT \" rate %f unplayed_ns %\" G_GINT64_FORMAT\n+        \" anchor_pend_samples %u\", now_ns, anchor_ns, now_ns - anchor_ns, rate,\n+        unplayed_ns, core_audio->anchor_pend_samples);\n+  }\n+\n+  CORE_AUDIO_TIMING_UNLOCK (core_audio);\n+\n+  GST_DEBUG_OBJECT (core_audio, \"samples = %u latency %f\", samples_remain,\n+      *latency);\n+\n+  *samples = samples_remain;\n+  return TRUE;\n+}\n+\n+void\n+gst_core_audio_update_timing (GstCoreAudio * core_audio,\n+    const AudioTimeStamp * inTimeStamp, unsigned int inNumberFrames)\n+{\n+  AudioTimeStampFlags target_flags =\n+      kAudioTimeStampSampleHostTimeValid | kAudioTimeStampRateScalarValid;\n+\n+  if ((inTimeStamp->mFlags & target_flags) == target_flags) {\n+    core_audio->anchor_hosttime_ns =\n+        _host_time_to_ns (core_audio, inTimeStamp->mHostTime);\n+    core_audio->anchor_pend_samples = inNumberFrames;\n+    core_audio->rate_scalar = inTimeStamp->mRateScalar;\n+\n+    GST_DEBUG_OBJECT (core_audio,\n+        \"anchor hosttime_ns %\" G_GUINT64_FORMAT\n+        \" scalar_rate %f anchor_pend_samples %u\",\n+        core_audio->anchor_hosttime_ns,\n+        core_audio->rate_scalar, core_audio->anchor_pend_samples);\n+  }\n@@ -211,1 +325,2 @@\n-    AudioStreamBasicDescription format, GstCaps * caps, gboolean is_passthrough)\n+    AudioStreamBasicDescription format, GstCaps * caps,\n+    guint32 frames_per_packet, gboolean is_passthrough)\n@@ -213,2 +328,0 @@\n-  guint32 frame_size;\n-\n@@ -220,1 +333,1 @@\n-          is_passthrough, &frame_size)) {\n+          is_passthrough, &frames_per_packet)) {\n@@ -226,1 +339,6 @@\n-    core_audio->recBufferSize = frame_size * format.mBytesPerFrame;\n+    core_audio->recBufferSize = frames_per_packet * format.mBytesPerFrame;\n+\n+    GST_DEBUG_OBJECT (core_audio,\n+        \"Allocating record buffers %u bytes %u frames\",\n+        core_audio->recBufferSize, frames_per_packet);\n+\n@@ -259,1 +377,1 @@\n-  GST_DEBUG_CATEGORY_INIT (osx_audio_debug, \"osxaudio\", 0,\n+  GST_DEBUG_CATEGORY_INIT (osx_coreaudio_debug, \"osxaudio\", 0,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudio.c","additions":127,"deletions":9,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include <mach\/mach_time.h>\n@@ -80,0 +81,3 @@\n+#define CORE_AUDIO_TIMING_LOCK(core_audio) (g_mutex_lock(&(core_audio->timing_lock)))\n+#define CORE_AUDIO_TIMING_UNLOCK(core_audio) (g_mutex_unlock(&(core_audio->timing_lock)))\n+\n@@ -110,0 +114,6 @@\n+\n+  mach_timebase_info_data_t timebase;\n+  GMutex timing_lock;\n+  uint64_t anchor_hosttime_ns;\n+  uint32_t anchor_pend_samples;\n+  float rate_scalar;\n@@ -130,0 +140,1 @@\n+                                                              guint32 frames_per_packet,\n@@ -145,0 +156,4 @@\n+void gst_core_audio_update_timing                            (GstCoreAudio * core_audio,\n+                                                              const AudioTimeStamp * inTimeStamp,\n+                                                              unsigned int inNumberFrames);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudio.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+GST_DEBUG_CATEGORY_EXTERN (osx_coreaudio_debug);\n+#define GST_CAT_DEFAULT osx_coreaudio_debug\n+\n@@ -388,1 +391,1 @@\n-      return kAudioChannelLabel_LeftSurround;\n+      return kAudioChannelLabel_RearSurroundLeft;\n@@ -390,1 +393,1 @@\n-      return kAudioChannelLabel_RightSurround;\n+      return kAudioChannelLabel_RearSurroundRight;\n@@ -421,0 +424,6 @@\n+    case GST_AUDIO_CHANNEL_POSITION_TOP_CENTER:\n+      return kAudioChannelLabel_TopCenterSurround;\n+    case GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT:\n+      return kAudioChannelLabel_LeftSurround;\n+    case GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT:\n+      return kAudioChannelLabel_RightSurround;\n@@ -430,1 +439,0 @@\n-    case GST_AUDIO_CHANNEL_POSITION_TOP_CENTER:\n@@ -436,2 +444,0 @@\n-    case GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT:\n-    case GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT:\n@@ -458,1 +464,1 @@\n-      return GST_AUDIO_CHANNEL_POSITION_REAR_LEFT;\n+      return GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT;\n@@ -460,1 +466,1 @@\n-      return GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT;\n+      return GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT;\n@@ -489,0 +495,6 @@\n+    case kAudioChannelLabel_RearSurroundLeft:\n+      return GST_AUDIO_CHANNEL_POSITION_REAR_LEFT;\n+    case kAudioChannelLabel_RearSurroundRight:\n+      return GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT;\n+    case kAudioChannelLabel_TopCenterSurround:\n+      return GST_AUDIO_CHANNEL_POSITION_TOP_CENTER;\n@@ -502,3 +514,0 @@\n-    case kAudioChannelLabel_RearSurroundLeft:\n-    case kAudioChannelLabel_RearSurroundRight:\n-    case kAudioChannelLabel_TopCenterSurround:\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudiocommon.c","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+G_BEGIN_DECLS\n+\n@@ -67,0 +69,2 @@\n+\n+G_END_DECLS\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudiocommon.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1165,1 +1165,1 @@\n-    UInt32 propertySize;\n+    UInt32 propertySize = sizeof (*frame_size);\n@@ -1175,2 +1175,5 @@\n-    if (core_audio->is_src) {\n-      propertySize = sizeof (*frame_size);\n+    \/\/ Attempt to configure the requested frame size if smaller than the device's\n+    \/\/ This will apparently modify the size for all audio devices in the current process so should\n+    \/\/ be done conservatively\n+    if (frame_size != 0) {\n+      guint32 cur_frame_size;\n@@ -1178,6 +1181,9 @@\n-          frame_size, &propertySize);\n-\n-      if (status) {\n-        GST_WARNING_OBJECT (core_audio->osxbuf, \"Failed to get frame size: %d\",\n-            (int) status);\n-        goto done;\n+          &cur_frame_size, &propertySize);\n+      if (!status && *frame_size < cur_frame_size) {\n+        status = AudioUnitSetProperty (core_audio->audiounit, kAudioDevicePropertyBufferFrameSize, kAudioUnitScope_Global, 0,   \/* N\/A for global *\/\n+            frame_size, propertySize);\n+        if (status) {\n+          GST_WARNING_OBJECT (core_audio->osxbuf,\n+              \"Failed to set desired frame size of %u: %d\", *frame_size,\n+              (int) status);\n+        }\n@@ -1186,0 +1192,8 @@\n+    status = AudioUnitGetProperty (core_audio->audiounit, kAudioDevicePropertyBufferFrameSize, kAudioUnitScope_Global, 0,       \/* N\/A for global *\/\n+        frame_size, &propertySize);\n+\n+    if (status) {\n+      GST_WARNING_OBJECT (core_audio->osxbuf, \"Failed to get frame size: %d\",\n+          (int) status);\n+      goto done;\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudiohal.c","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -126,0 +126,4 @@\n+#ifdef GST_FULL_STATIC_COMPILATION\n+void gst_init_static_plugins ();\n+#endif\n+\n@@ -194,1 +198,0 @@\n-  ARG_PLUGIN_SPEW,\n@@ -209,1 +212,1 @@\n-#ifdef G_OS_WIN32\n+#if defined(G_OS_WIN32) && !defined(GST_STATIC_COMPILATION)\n@@ -214,7 +217,1 @@\n- *\n- * Also, ideally this should not be defined when GStreamer is built statically.\n- * i.e., it should be conditional on #ifdef DLL_EXPORT. It will be ignored, but\n- * if other libraries make the same mistake of defining it when building\n- * statically, there will be a symbol collision during linking. Fixing this\n- * requires one to build two object files: one for static linking and another\n- * for dynamic linking. *\/\n+ *\/\n@@ -225,1 +222,1 @@\n-  if (fdwReason == DLL_PROCESS_ATTACH)\n+  if (fdwReason == DLL_PROCESS_ATTACH) {\n@@ -227,0 +224,3 @@\n+    priv_gst_clock_init ();\n+  }\n+\n@@ -287,4 +287,0 @@\n-    {\"gst-plugin-spew\", 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,\n-          (gpointer) parse_goption_arg,\n-          N_(\"Enable verbose plugin loading diagnostics\"),\n-        NULL},\n@@ -570,0 +566,2 @@\n+  priv_gst_clock_init ();\n+\n@@ -657,0 +655,3 @@\n+#ifdef GST_FULL_STATIC_COMPILATION\n+  gst_init_static_plugins ();\n+#else\n@@ -670,0 +671,1 @@\n+#endif\n@@ -1039,2 +1041,0 @@\n-    case ARG_PLUGIN_SPEW:\n-      break;\n@@ -1094,1 +1094,0 @@\n-    \"--gst-plugin-spew\", ARG_PLUGIN_SPEW}, {\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gst.c","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include <gst\/gstbytearrayinterface.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gst.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-  GList *deps;    \/* list of GstPluginDep structures *\/\n+  GList *deps;                 \/* list of GstPluginDep structures *\/\n+  GstStructure *status_info;\n@@ -163,1 +164,1 @@\n-gboolean _gst_plugin_loader_client_run (void);\n+gboolean _gst_plugin_loader_client_run (const gchar * pipe_name);\n@@ -542,0 +543,5 @@\n+gint   priv_gst_count_directories (const char *filepath);\n+\n+void priv_gst_clock_init (void);\n+GstClockTime priv_gst_get_monotonic_time (void);\n+GstClockTime priv_gst_get_real_time (void);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gst_private.h","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"glib-compat-private.h\"\n@@ -112,1 +113,2 @@\n-  if (GST_OBJECT_FLAG_IS_SET (allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC))\n+  if (GST_OBJECT_FLAG_IS_SET (allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC) ||\n+      GST_OBJECT_FLAG_IS_SET (allocator, GST_ALLOCATOR_FLAG_NO_COPY))\n@@ -118,1 +120,1 @@\n-    gst_allocator_free (mem->allocator, copy);\n+    gst_allocator_free (copy->allocator, copy);\n@@ -171,1 +173,1 @@\n-  GstAllocationParams *result = g_slice_new (GstAllocationParams);\n+  GstAllocationParams *result = g_new (GstAllocationParams, 1);\n@@ -205,2 +207,2 @@\n-        (GstAllocationParams *) g_slice_copy (sizeof (GstAllocationParams),\n-        params);\n+        (GstAllocationParams *) g_memdup2 (params,\n+        sizeof (GstAllocationParams));\n@@ -220,1 +222,1 @@\n-  g_slice_free (GstAllocationParams, params);\n+  g_free (params);\n@@ -373,1 +375,0 @@\n-  gsize slice_size;\n@@ -396,1 +397,1 @@\n-    GstMemory * parent, gsize slice_size,\n+    GstMemory * parent,\n@@ -403,1 +404,0 @@\n-  mem->slice_size = slice_size;\n@@ -416,1 +416,0 @@\n-  gsize slice_size;\n@@ -418,4 +417,2 @@\n-  slice_size = sizeof (GstMemorySystem);\n-\n-  mem = g_slice_alloc (slice_size);\n-  _sysmem_init (mem, flags, parent, slice_size,\n+  mem = g_new (GstMemorySystem, 1);\n+  _sysmem_init (mem, flags, parent,\n@@ -443,1 +440,1 @@\n-  mem = g_slice_alloc (slice_size);\n+  mem = g_malloc (slice_size);\n@@ -463,1 +460,1 @@\n-  _sysmem_init (mem, flags, NULL, slice_size, data, maxsize,\n+  _sysmem_init (mem, flags, NULL, data, maxsize,\n@@ -554,1 +551,0 @@\n-  gsize slice_size;\n@@ -559,2 +555,0 @@\n-  slice_size = dmem->slice_size;\n-\n@@ -566,1 +560,1 @@\n-  g_slice_free1 (slice_size, mem);\n+  g_free (mem);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstallocator.c","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -91,0 +91,7 @@\n+ *    Only elements designed to work with this allocator should be using it,\n+ *    other elements should ignore it from allocation propositions.\n+ *    This implies %GST_ALLOCATOR_FLAG_NO_COPY.\n+ * @GST_ALLOCATOR_FLAG_NO_COPY: When copying a #GstMemory allocated with this\n+ *    allocator, the copy will instead be allocated using the default allocator.\n+ *    Use this when allocating a new memory is an heavy opperation that should\n+ *    only be done with a #GstBufferPool for example. (Since: 1.24)\n@@ -95,0 +102,10 @@\n+\/**\n+ * GST_ALLOCATOR_FLAG_NO_COPY:\n+ *\n+ * When copying a #GstMemory allocated with this allocator, the copy will\n+ * instead be allocated using the default allocator. Use this when allocating a\n+ * new memory is an heavy opperation that should only be done with a\n+ * #GstBufferPool for example.\n+ *\n+ * Since: 1.24\n+ *\/\n@@ -97,0 +114,1 @@\n+  GST_ALLOCATOR_FLAG_NO_COPY       = (GST_OBJECT_FLAG_LAST << 1),\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstallocator.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n- * ( %GST_EVENT_TYPE_DOWNSTREAM ) or source ( %GST_EVENT_TYPE_UPSTREAM ) elements\n+ * ( %GST_EVENT_TYPE_UPSTREAM ) or source ( %GST_EVENT_TYPE_DOWNSTREAM ) elements\n@@ -2891,4 +2891,7 @@\n-      \/* We might not have reached PAUSED yet due to async errors,\n-       * make sure to always deactivate the pads nonetheless *\/\n-      if (!(gst_bin_src_pads_activate (bin, FALSE)))\n-        goto activate_failure;\n+      \/* Pads can be activated in PULL mode before in NULL state *\/\n+      if (current != GST_STATE_NULL) {\n+        \/* We might not have reached PAUSED yet due to async errors,\n+         * make sure to always deactivate the pads nonetheless *\/\n+        if (!gst_bin_src_pads_activate (bin, FALSE))\n+          goto activate_failure;\n+      }\n@@ -3282,1 +3285,1 @@\n-  g_slice_free (BinContinueData, data);\n+  g_free (data);\n@@ -3452,1 +3455,1 @@\n-    cont = g_slice_new (BinContinueData);\n+    cont = g_new (BinContinueData, 1);\n@@ -3508,0 +3511,7 @@\n+\n+    amessage = gst_message_new_async_done (GST_OBJECT_CAST (bin), running_time);\n+\n+    GST_OBJECT_UNLOCK (bin);\n+    gst_element_post_message (GST_ELEMENT_CAST (bin), amessage);\n+    GST_OBJECT_LOCK (bin);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbin.c","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-#define GST_BUFFER_SLICE_SIZE(b)   (((GstBufferImpl *)(b))->slice_size)\n@@ -160,2 +159,0 @@\n-  gsize slice_size;\n-\n@@ -549,0 +546,1 @@\n+  gboolean sharing_mem = FALSE;\n@@ -652,0 +650,3 @@\n+        \/* Indicates if dest references any of src memories. *\/\n+        sharing_mem |= (newmem == mem);\n+\n@@ -665,0 +666,4 @@\n+\n+      \/* If we were sharing memory and the merge is no-op, we are still sharing. *\/\n+      sharing_mem &= (mem == GST_BUFFER_MEM_PTR (dest, 0));\n+\n@@ -713,0 +718,8 @@\n+  if (sharing_mem && src->pool != NULL) {\n+    \/* The new buffer references some of src's memories. We have to ensure that\n+     * src buffer does not return to its buffer pool as long as its memories are\n+     * used by other buffers. That would cause the buffer to be discarted by the\n+     * pool because its memories are not writable. *\/\n+    gst_buffer_add_parent_buffer_meta (dest, src);\n+  }\n+\n@@ -786,1 +799,0 @@\n-  gsize msize;\n@@ -792,0 +804,9 @@\n+  \/* free our memory *\/\n+  len = GST_BUFFER_MEM_LEN (buffer);\n+  for (i = 0; i < len; i++) {\n+    gst_memory_unlock (GST_BUFFER_MEM_PTR (buffer, i), GST_LOCK_FLAG_EXCLUSIVE);\n+    gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (GST_BUFFER_MEM_PTR\n+            (buffer, i)), GST_MINI_OBJECT_CAST (buffer));\n+    gst_memory_unref (GST_BUFFER_MEM_PTR (buffer, i));\n+  }\n+\n@@ -803,14 +824,1 @@\n-    g_slice_free1 (ITEM_SIZE (info), walk);\n-  }\n-\n-  \/* get the size, when unreffing the memory, we could also unref the buffer\n-   * itself *\/\n-  msize = GST_BUFFER_SLICE_SIZE (buffer);\n-\n-  \/* free our memory *\/\n-  len = GST_BUFFER_MEM_LEN (buffer);\n-  for (i = 0; i < len; i++) {\n-    gst_memory_unlock (GST_BUFFER_MEM_PTR (buffer, i), GST_LOCK_FLAG_EXCLUSIVE);\n-    gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (GST_BUFFER_MEM_PTR\n-            (buffer, i)), GST_MINI_OBJECT_CAST (buffer));\n-    gst_memory_unref (GST_BUFFER_MEM_PTR (buffer, i));\n+    g_free (walk);\n@@ -819,2 +827,0 @@\n-  \/* we set msize to 0 when the buffer is part of the memory block *\/\n-  if (msize) {\n@@ -822,1 +828,1 @@\n-    memset (buffer, 0xff, msize);\n+  memset (buffer, 0xff, sizeof (GstBufferImpl));\n@@ -824,4 +830,1 @@\n-    g_slice_free1 (msize, buffer);\n-  } else {\n-    gst_memory_unref (GST_BUFFER_BUFMEM (buffer));\n-  }\n+  g_free (buffer);\n@@ -831,1 +834,1 @@\n-gst_buffer_init (GstBufferImpl * buffer, gsize size)\n+gst_buffer_init (GstBufferImpl * buffer)\n@@ -838,2 +841,0 @@\n-  GST_BUFFER_SLICE_SIZE (buffer) = size;\n-\n@@ -863,1 +864,1 @@\n-  newbuf = g_slice_new (GstBufferImpl);\n+  newbuf = g_new (GstBufferImpl, 1);\n@@ -866,1 +867,1 @@\n-  gst_buffer_init (newbuf, sizeof (GstBufferImpl));\n+  gst_buffer_init (newbuf);\n@@ -922,1 +923,1 @@\n-  data = g_slice_alloc (asize);\n+  data = g_malloc (asize);\n@@ -2359,1 +2360,1 @@\n-    item = g_slice_alloc0 (size);\n+    item = g_malloc0 (size);\n@@ -2361,1 +2362,1 @@\n-    item = g_slice_alloc (size);\n+    item = g_malloc (size);\n@@ -2389,1 +2390,1 @@\n-    g_slice_free1 (size, item);\n+    g_free (item);\n@@ -2440,1 +2441,1 @@\n-      g_slice_free1 (ITEM_SIZE (info), walk);\n+      g_free (walk);\n@@ -2588,1 +2589,1 @@\n-      g_slice_free1 (ITEM_SIZE (info), walk);\n+      g_free (walk);\n@@ -2906,0 +2907,43 @@\n+static gboolean\n+timestamp_meta_serialize (const GstMeta * meta, GstByteArrayInterface * data,\n+    guint8 * version)\n+{\n+  const GstReferenceTimestampMeta *rtmeta =\n+      (const GstReferenceTimestampMeta *) meta;\n+  gchar *caps_str = gst_caps_to_string (rtmeta->reference);\n+  gsize caps_str_len = strlen (caps_str);\n+\n+  gsize size = 16 + caps_str_len + 1;\n+  guint8 *ptr = gst_byte_array_interface_append (data, size);\n+  if (ptr == NULL) {\n+    g_free (caps_str);\n+    return FALSE;\n+  }\n+\n+  GST_WRITE_UINT64_LE (ptr, rtmeta->timestamp);\n+  GST_WRITE_UINT64_LE (ptr + 8, rtmeta->duration);\n+  memcpy (ptr + 16, caps_str, caps_str_len + 1);\n+  g_free (caps_str);\n+\n+  return TRUE;\n+}\n+\n+static GstMeta *\n+timestamp_meta_deserialize (const GstMetaInfo * info, GstBuffer * buffer,\n+    const guint8 * data, gsize size, guint8 version)\n+{\n+  \/* Sanity check: caps_str must be 0-terminated. *\/\n+  if (version != 0 || size < 2 * sizeof (guint64) + 1 || data[size - 1] != '\\0')\n+    return NULL;\n+\n+  guint64 timestamp = GST_READ_UINT64_LE (data);\n+  guint64 duration = GST_READ_UINT64_LE (data + 8);\n+  const gchar *caps_str = (const gchar *) data + 16;\n+  GstCaps *reference = gst_caps_from_string (caps_str);\n+  GstMeta *meta = (GstMeta *) gst_buffer_add_reference_timestamp_meta (buffer,\n+      reference, timestamp, duration);\n+  gst_caps_unref (reference);\n+\n+  return meta;\n+}\n+\n@@ -2921,2 +2965,3 @@\n-    const GstMetaInfo *meta =\n-        gst_meta_register (gst_reference_timestamp_meta_api_get_type (),\n+    const GstMetaInfo *meta = NULL;\n+    GstMetaInfo *info =\n+        gst_meta_info_new (gst_reference_timestamp_meta_api_get_type (),\n@@ -2924,4 +2969,7 @@\n-        sizeof (GstReferenceTimestampMeta),\n-        (GstMetaInitFunction) _gst_reference_timestamp_meta_init,\n-        (GstMetaFreeFunction) _gst_reference_timestamp_meta_free,\n-        _gst_reference_timestamp_meta_transform);\n+        sizeof (GstReferenceTimestampMeta));\n+    info->init_func = (GstMetaInitFunction) _gst_reference_timestamp_meta_init;\n+    info->free_func = (GstMetaFreeFunction) _gst_reference_timestamp_meta_free;\n+    info->transform_func = _gst_reference_timestamp_meta_transform;\n+    info->serialize_func = timestamp_meta_serialize;\n+    info->deserialize_func = timestamp_meta_deserialize;\n+    meta = gst_meta_info_register (info);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbuffer.c","additions":90,"deletions":42,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -770,0 +770,3 @@\n+ * Since 1.24 it can be serialized using gst_meta_serialize() and\n+ * gst_meta_deserialize().\n+ *\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbuffer.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,2 +64,0 @@\n-  gsize slice_size;\n-\n@@ -107,1 +105,0 @@\n-  gsize slice_size;\n@@ -122,2 +119,0 @@\n-  slice_size = list->slice_size;\n-\n@@ -125,1 +120,1 @@\n-  memset (list, 0xff, slice_size);\n+  memset (list, 0xff, sizeof (GstBufferList));\n@@ -128,1 +123,1 @@\n-  g_slice_free1 (slice_size, list);\n+  g_free (list);\n@@ -132,1 +127,1 @@\n-gst_buffer_list_init (GstBufferList * list, guint n_allocated, gsize slice_size)\n+gst_buffer_list_init (GstBufferList * list, guint n_allocated)\n@@ -141,1 +136,0 @@\n-  list->slice_size = slice_size;\n@@ -169,1 +163,1 @@\n-  list = g_slice_alloc0 (slice_size);\n+  list = g_malloc0 (slice_size);\n@@ -173,1 +167,1 @@\n-  gst_buffer_list_init (list, n_allocated, slice_size);\n+  gst_buffer_list_init (list, n_allocated);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbufferlist.c","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1220,0 +1220,6 @@\n+  } else {\n+    const GstMetaInfo *info = (*meta)->info;\n+\n+    \/* If we can clear it, don't free it *\/\n+    if (info->clear_func)\n+      info->clear_func (buffer, *meta);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbufferpool.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+#define WARN_QUEUE_SIZE 1024\n@@ -368,3 +369,4 @@\n-  \/* If this is a bus without async message delivery\n-   * always drop the message *\/\n-  if (!bus->priv->poll)\n+  \/* If this is a bus without async message delivery always drop the message.\n+   * If the sync handler returned GST_BUS_DROP it is responsible of unreffing\n+   * the message, otherwise do it ourself. *\/\n+  if (!bus->priv->poll && reply != GST_BUS_DROP) {\n@@ -372,0 +374,2 @@\n+    gst_message_unref (message);\n+  }\n@@ -379,1 +383,8 @@\n-    case GST_BUS_PASS:\n+    case GST_BUS_PASS:{\n+      guint length = gst_atomic_queue_length (bus->priv->queue);\n+      if (G_UNLIKELY (length > 0 && length % WARN_QUEUE_SIZE == 0)) {\n+        GST_WARNING_OBJECT (bus, \"queue overflows with %d messages. \"\n+            \"Application is too slow or is not handling messages. \"\n+            \"Please add a message handler, otherwise the queue will grow \"\n+            \"infinitely.\", length);\n+      }\n@@ -387,0 +398,1 @@\n+    }\n@@ -427,0 +439,1 @@\n+      gst_message_unref (message);\n@@ -837,1 +850,0 @@\n-#if GLIB_CHECK_VERSION(2,63,3)\n@@ -853,1 +865,0 @@\n-#endif\n@@ -859,2 +870,0 @@\n-#if !GLIB_CHECK_VERSION(2,63,3)\n-  GstBus *bus = bsource->bus;\n@@ -862,7 +871,5 @@\n-  GST_DEBUG_OBJECT (bus, \"finalize source %p\", source);\n-\n-  GST_OBJECT_LOCK (bus);\n-  if (bus->priv->gsource == source)\n-    bus->priv->gsource = NULL;\n-  GST_OBJECT_UNLOCK (bus);\n-#endif\n+#ifdef GSTREAMER_LITE\n+  \/\/ Use g_source_set_dispose_function() instead, once\n+  \/\/ we no longer need to support older GLib.\n+  gst_bus_source_dispose(source);\n+#endif \/\/ GSTREAMER_LITE\n@@ -897,1 +904,4 @@\n-#if GLIB_CHECK_VERSION(2,63,3)\n+#ifndef GSTREAMER_LITE\n+  \/\/ Remove usage of g_source_set_dispose_function(), so we can run on\n+  \/\/ older GLib.\n+  \/\/ https:\/\/gitlab.freedesktop.org\/gstreamer\/gstreamer\/-\/commit\/654f3370a01dfe96f962fbbadba34b865d123a90\n@@ -899,1 +909,1 @@\n-#endif\n+#endif \/\/ GSTREAMER_LITE\n@@ -1152,1 +1162,1 @@\n-    g_slice_free (GstBusPollData, poll_data);\n+    g_free (poll_data);\n@@ -1162,1 +1172,1 @@\n-    g_slice_free (GstBusPollData, poll_data);\n+    g_free (poll_data);\n@@ -1220,1 +1230,1 @@\n-  poll_data = g_slice_new (GstBusPollData);\n+  poll_data = g_new (GstBusPollData, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbus.c","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/* Copyright (C) 2023 Netflix Inc.\n+ *  Author: Xavier Claessens <xavier.claessens@collabora.com>\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+#pragma once\n+\n+#include <glib.h>\n+#include <gst\/gstconfig.h>\n+\n+#ifdef GSTREAMER_LITE\n+#include <string.h>\n+#endif \/\/ GSTREAMER_LITE\n+\n+G_BEGIN_DECLS\n+\n+\/**\n+ * GstByteArrayInterface:\n+ * @data: A pointer to an array of bytes.\n+ * @len: Number of bytes in @data.\n+ * @resize: Reallocate @data.\n+ *\n+ * Interface for an array of bytes. It is expected to be subclassed to implement\n+ * @resize virtual method using language native array implementation, such as\n+ * GLib's #GByteArray, C++'s `std::vector<uint8_t>` or Rust's `Vec<u8>`.\n+ *\n+ * @resize implementation could allocate more than requested to avoid repeated\n+ * reallocations. It can return %FALSE, or be set to %NULL, in the case the\n+ * array cannot grow.\n+ *\n+ * Since: 1.24\n+ *\/\n+typedef struct _GstByteArrayInterface GstByteArrayInterface;\n+struct _GstByteArrayInterface\n+{\n+  guint8 *data;\n+  gsize len;\n+  gboolean (*resize) (GstByteArrayInterface *self, gsize length);\n+\n+  \/* < private > *\/\n+  gpointer _gst_reserved[GST_PADDING];\n+};\n+\n+\/**\n+ * gst_byte_array_interface_init:\n+ * @self: A #GstByteArrayInterface.\n+ * @length: New size.\n+ *\n+ * Initialize #GstByteArrayInterface structure.\n+ *\n+ * Since: 1.24\n+ *\/\n+static inline void\n+gst_byte_array_interface_init (GstByteArrayInterface *self)\n+{\n+  memset (self, 0, sizeof (GstByteArrayInterface));\n+}\n+\n+\/**\n+ * gst_byte_array_interface_set_size:\n+ * @self: A #GstByteArrayInterface.\n+ * @length: New size.\n+ *\n+ * Reallocate data pointer to fit at least @length bytes. @self->len is updated\n+ * to @length.\n+ *\n+ * Returns: %TRUE on success, %FALSE otherwise.\n+ * Since: 1.24\n+ *\/\n+static inline gboolean\n+gst_byte_array_interface_set_size (GstByteArrayInterface *self, gsize length)\n+{\n+  if (self->resize == NULL || !self->resize (self, length))\n+    return FALSE;\n+  self->len = length;\n+  return TRUE;\n+}\n+\n+\/**\n+ * gst_byte_array_interface_append:\n+ * @self: A #GstByteArrayInterface.\n+ * @size: Number of bytes to append to the array.\n+ *\n+ * Grow the array by @size bytes and return a pointer to the newly added memory.\n+ *\n+ * Returns: Pointer to added memory, or %NULL if reallocation failed.\n+ * Since: 1.24\n+ *\/\n+static inline guint8 *\n+gst_byte_array_interface_append (GstByteArrayInterface *self, gsize size)\n+{\n+  gsize orig = self->len;\n+  if (!gst_byte_array_interface_set_size (self, self->len + size))\n+    return NULL;\n+  return self->data + orig;\n+}\n+\n+\/**\n+ * gst_byte_array_interface_append_data:\n+ * @self: A #GstByteArrayInterface.\n+ * @data: Source data.\n+ * @size: Size of @data.\n+ *\n+ * Append @size bytes from @data, reallocating @self->data pointer if necessary.\n+ *\n+ * Returns: %TRUE on success, %FALSE otherwise.\n+ * Since: 1.24\n+ *\/\n+static inline gboolean\n+gst_byte_array_interface_append_data (GstByteArrayInterface *self, const guint8 *data, gsize size)\n+{\n+  guint8 *ptr = gst_byte_array_interface_append (self, size);\n+  if (ptr == NULL)\n+    return FALSE;\n+  memcpy (ptr, data, size);\n+  return TRUE;\n+}\n+\n+G_END_DECLS\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbytearrayinterface.h","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -225,1 +225,1 @@\n-  g_slice_free1 (sizeof (GstCapsImpl), caps);\n+  g_free (caps);\n@@ -258,1 +258,1 @@\n-  caps = (GstCaps *) g_slice_new (GstCapsImpl);\n+  caps = (GstCaps *) g_new (GstCapsImpl, 1);\n@@ -2653,4 +2653,3 @@\n- * structure and features. In contrast to gst_caps_filter_and_map_in_place(),\n- * the structure and features are removed from the caps if %FALSE is returned\n- * from the function.\n- * The caps must be mutable.\n+ * structure and features. In contrast to gst_caps_map_in_place(), the structure\n+ * and features are removed from the caps if %FALSE is returned from the\n+ * function. The caps must be mutable.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcaps.c","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-  features = g_slice_new (GstCapsFeatures);\n+  features = g_new (GstCapsFeatures, 1);\n@@ -434,1 +434,1 @@\n-  g_slice_free (GstCapsFeatures, features);\n+  g_free (features);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcapsfeatures.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-  entry = (GstClockEntry *) g_slice_new0 (GstClockEntryImpl);\n+  entry = (GstClockEntry *) g_new0 (GstClockEntryImpl, 1);\n@@ -401,1 +401,1 @@\n-  g_slice_free (GstClockEntryImpl, (GstClockEntryImpl *) id);\n+  g_free (id);\n@@ -1781,2 +1781,2 @@\n-  if (clock->priv->synced != ! !synced) {\n-    clock->priv->synced = ! !synced;\n+  if (clock->priv->synced != !!synced) {\n+    clock->priv->synced = !!synced;\n@@ -1785,1 +1785,1 @@\n-    g_signal_emit (clock, gst_clock_signals[SIGNAL_SYNCED], 0, ! !synced);\n+    g_signal_emit (clock, gst_clock_signals[SIGNAL_SYNCED], 0, !!synced);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstclock.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -178,12 +178,16 @@\n- * > on 32-bit systems, a timeval has a range of only 2^32 - 1 seconds,\n- * > which is about 68 years.  Expect trouble if you want to schedule stuff\n- * > in your pipeline for 2038.\n- *\/\n-#define GST_TIME_TO_TIMEVAL(t,tv)                               \\\n-G_STMT_START {                                                  \\\n-  g_assert (\"Value of time \" #t \" is out of timeval's range\" && \\\n-      ((t) \/ GST_SECOND) < G_MAXLONG);                          \\\n-  (tv).tv_sec  = (glong) (((GstClockTime) (t)) \/ GST_SECOND);   \\\n-  (tv).tv_usec = (glong) ((((GstClockTime) (t)) -               \\\n-                  ((GstClockTime) (tv).tv_sec) * GST_SECOND)    \\\n-                 \/ GST_USECOND);                                \\\n+ * > on many 32-bit systems, a timeval has a range of only 2^32 - 1 seconds,\n+ * > which is about 68 years. Expect trouble if you want to schedule stuff\n+ * > in your pipeline for 2038. This macro asserts that this case does not\n+ * > happen.\n+ *\/\n+#define GST_TIME_TO_TIMEVAL(t,tv)                                           \\\n+G_STMT_START {                                                              \\\n+  G_STATIC_ASSERT (sizeof ((tv).tv_sec) == 4 || sizeof ((tv).tv_sec) == 8); \\\n+  if (sizeof ((tv).tv_sec) == 4) {                                          \\\n+    g_assert (\"Value of time \" #t \" is out of timeval's range\" &&           \\\n+        ((t) \/ GST_SECOND) < G_MAXINT32);                                   \\\n+  }                                                                         \\\n+  (tv).tv_sec  = (((GstClockTime) (t)) \/ GST_SECOND);                       \\\n+  (tv).tv_usec = ((((GstClockTime) (t)) -                                   \\\n+                  ((GstClockTime) (tv).tv_sec) * GST_SECOND)                \\\n+                 \/ GST_USECOND);                                            \\\n@@ -206,6 +210,9 @@\n-#define GST_TIME_TO_TIMESPEC(t,ts)                                \\\n-G_STMT_START {                                                    \\\n-  g_assert (\"Value of time \" #t \" is out of timespec's range\" &&  \\\n-      ((t) \/ GST_SECOND) < G_MAXLONG);                            \\\n-  (ts).tv_sec  =  (glong) ((t) \/ GST_SECOND);                     \\\n-  (ts).tv_nsec = (glong) (((t) - (ts).tv_sec * GST_SECOND) \/ GST_NSECOND);        \\\n+#define GST_TIME_TO_TIMESPEC(t,ts)                                          \\\n+G_STMT_START {                                                              \\\n+  G_STATIC_ASSERT (sizeof ((ts).tv_sec) == 4 || sizeof ((ts).tv_sec) == 8); \\\n+  if (sizeof ((ts).tv_sec) == 4) {                                          \\\n+    g_assert (\"Value of time \" #t \" is out of timespec's range\" &&          \\\n+        ((t) \/ GST_SECOND) < G_MAXINT32);                                   \\\n+  }                                                                         \\\n+  (ts).tv_sec  =  ((t) \/ GST_SECOND);                                       \\\n+  (ts).tv_nsec = (((t) - (ts).tv_sec * GST_SECOND) \/ GST_NSECOND);          \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstclock.h","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  g_slice_free1 (sizeof (GstContext), context);\n+  g_free (context);\n@@ -131,1 +131,1 @@\n-  copy = g_slice_new0 (GstContext);\n+  copy = g_new0 (GstContext, 1);\n@@ -174,1 +174,1 @@\n-  context = g_slice_new0 (GstContext);\n+  context = g_new0 (GstContext, 1);\n@@ -319,0 +319,19 @@\n+\/**\n+ * gst_clear_context: (skip)\n+ * @context_ptr: a pointer to a #GstContext reference\n+ *\n+ * Clears a reference to a #GstContext.\n+ *\n+ * @context_ptr must not be `NULL`.\n+ *\n+ * If the reference is `NULL` then this function does nothing. Otherwise, the\n+ * reference count of the context is decreased and the pointer is set to `NULL`.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_clear_context (GstContext ** context_ptr)\n+{\n+  gst_clear_mini_object ((GstMiniObject **) context_ptr);\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcontext.c","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -66,0 +66,6 @@\n+static inline void\n+gst_clear_context (GstContext ** context_ptr)\n+{\n+  gst_clear_mini_object ((GstMiniObject **) context_ptr);\n+}\n+\n@@ -79,0 +85,3 @@\n+GST_API\n+void         gst_clear_context  (GstContext ** context_ptr);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcontext.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-  return ! !binding->disabled;\n+  return !!binding->disabled;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcontrolbinding.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  gst_dt = g_slice_new (GstDateTime);\n+  gst_dt = g_new (GstDateTime, 1);\n@@ -1054,1 +1054,1 @@\n-  g_slice_free (GstDateTime, datetime);\n+  g_free (datetime);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstdatetime.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -925,0 +925,7 @@\n+\n+gchar *\n+gst_debug_bin_to_dot_data (GstBin * bin, GstDebugGraphDetails details)\n+{\n+  return g_strdup (\"\");\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstdebugutils.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2505,0 +2505,1 @@\n+  gint64 end_time;\n@@ -2510,3 +2511,0 @@\n-  ret = GST_STATE_RETURN (element);\n-  GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, \"RETURN is %s\",\n-      gst_element_state_change_return_get_name (ret));\n@@ -2514,3 +2512,4 @@\n-  \/* we got an error, report immediately *\/\n-  if (ret == GST_STATE_CHANGE_FAILURE)\n-    goto done;\n+  if (timeout != GST_CLOCK_TIME_NONE) {\n+    \/* make timeout absolute *\/\n+    end_time = g_get_monotonic_time () + (timeout \/ 1000);\n+  }\n@@ -2518,3 +2517,4 @@\n-  \/* we got no_preroll, report immediately *\/\n-  if (ret == GST_STATE_CHANGE_NO_PREROLL)\n-    goto done;\n+  do {\n+    ret = GST_STATE_RETURN (element);\n+    GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, \"RETURN is %s\",\n+        gst_element_state_change_return_get_name (ret));\n@@ -2522,3 +2522,3 @@\n-  \/* no need to wait async if we are not async *\/\n-  if (ret != GST_STATE_CHANGE_ASYNC)\n-    goto done;\n+    \/* we got an error, report immediately *\/\n+    if (ret == GST_STATE_CHANGE_FAILURE)\n+      goto done;\n@@ -2526,4 +2526,3 @@\n-  old_pending = GST_STATE_PENDING (element);\n-  if (old_pending != GST_STATE_VOID_PENDING) {\n-    gboolean signaled;\n-    guint32 cookie;\n+    \/* we got no_preroll, report immediately *\/\n+    if (ret == GST_STATE_CHANGE_NO_PREROLL)\n+      goto done;\n@@ -2531,2 +2530,3 @@\n-    \/* get cookie to detect state changes during waiting *\/\n-    cookie = element->state_cookie;\n+    \/* no need to wait async if we are not async *\/\n+    if (ret != GST_STATE_CHANGE_ASYNC)\n+      goto done;\n@@ -2534,2 +2534,4 @@\n-    GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,\n-        \"waiting for element to commit state\");\n+    old_pending = GST_STATE_PENDING (element);\n+    if (old_pending != GST_STATE_VOID_PENDING) {\n+      gboolean signaled = TRUE;\n+      guint32 cookie;\n@@ -2537,10 +2539,2 @@\n-    \/* we have a pending state change, wait for it to complete *\/\n-    if (timeout != GST_CLOCK_TIME_NONE) {\n-      gint64 end_time;\n-      \/* make timeout absolute *\/\n-      end_time = g_get_monotonic_time () + (timeout \/ 1000);\n-      signaled = GST_STATE_WAIT_UNTIL (element, end_time);\n-    } else {\n-      GST_STATE_WAIT (element);\n-      signaled = TRUE;\n-    }\n+      \/* get cookie to detect state changes during waiting *\/\n+      cookie = element->state_cookie;\n@@ -2548,7 +2542,2 @@\n-    if (!signaled) {\n-      GST_CAT_INFO_OBJECT (GST_CAT_STATES, element, \"timed out\");\n-      \/* timeout triggered *\/\n-      ret = GST_STATE_CHANGE_ASYNC;\n-    } else {\n-      if (cookie != element->state_cookie)\n-        goto interrupted;\n+      GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,\n+          \"waiting for element to commit state\");\n@@ -2556,4 +2545,4 @@\n-      \/* could be success or failure *\/\n-      if (old_pending == GST_STATE (element)) {\n-        GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, \"got success\");\n-        ret = GST_STATE_CHANGE_SUCCESS;\n+      \/* we have a pending state change, wait for it to complete or for\n+         an interruption *\/\n+      if (timeout != GST_CLOCK_TIME_NONE) {\n+        signaled = GST_STATE_WAIT_UNTIL (element, end_time);\n@@ -2561,2 +2550,26 @@\n-        GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, \"got failure\");\n-        ret = GST_STATE_CHANGE_FAILURE;\n+        GST_STATE_WAIT (element);\n+        signaled = TRUE;\n+      }\n+\n+      if (!signaled) {\n+        GST_CAT_INFO_OBJECT (GST_CAT_STATES, element, \"timed out\");\n+        \/* timeout triggered *\/\n+        ret = GST_STATE_CHANGE_ASYNC;\n+        goto done;\n+      } else {\n+        if (cookie != element->state_cookie)\n+          goto interrupted;\n+\n+        \/* could be success or failure *\/\n+        if (old_pending == GST_STATE (element)) {\n+          GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, \"got success\");\n+          ret = GST_STATE_CHANGE_SUCCESS;\n+        } else {\n+          GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, \"got failure\");\n+          ret = GST_STATE_CHANGE_FAILURE;\n+        }\n+      }\n+      \/* if nothing is pending anymore we can return SUCCESS *\/\n+      if (GST_STATE_PENDING (element) == GST_STATE_VOID_PENDING) {\n+        GST_CAT_LOG_OBJECT (GST_CAT_STATES, element, \"nothing pending\");\n+        ret = GST_STATE_CHANGE_SUCCESS;\n@@ -2565,6 +2578,1 @@\n-    \/* if nothing is pending anymore we can return SUCCESS *\/\n-    if (GST_STATE_PENDING (element) == GST_STATE_VOID_PENDING) {\n-      GST_CAT_LOG_OBJECT (GST_CAT_STATES, element, \"nothing pending\");\n-      ret = GST_STATE_CHANGE_SUCCESS;\n-    }\n-  }\n+  } while (old_pending != GST_STATE (element));\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstelement.c","additions":57,"deletions":49,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    g_slice_free (GstStaticPadTemplate, templ);\n+    g_free (templ);\n@@ -260,1 +260,1 @@\n-    newt = g_slice_new (GstStaticPadTemplate);\n+    newt = g_new (GstStaticPadTemplate, 1);\n@@ -1222,0 +1222,4 @@\n+  if (!res && (type & GST_ELEMENT_FACTORY_TYPE_TIMESTAMPER))\n+    res = ((strstr (klass, \"Timestamper\") != NULL)\n+        && (strstr (klass, \"Codec\") != NULL));\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstelementfactory.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -172,0 +172,8 @@\n+\/**\n+ * GST_ELEMENT_FACTORY_TYPE_TIMESTAMPER:\n+ *\n+ * Timestamp correcting elements\n+ *\n+ * Since: 1.24\n+ *\/\n+#define  GST_ELEMENT_FACTORY_TYPE_TIMESTAMPER    ((GstElementFactoryListType)(G_GUINT64_CONSTANT (1) << 13))\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstelementfactory.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  g_slice_free1 (sizeof (GstEventImpl), event);\n+  g_free (event);\n@@ -275,1 +275,1 @@\n-  copy = g_slice_new0 (GstEventImpl);\n+  copy = g_new0 (GstEventImpl, 1);\n@@ -335,1 +335,1 @@\n-  event = g_slice_new0 (GstEventImpl);\n+  event = g_new0 (GstEventImpl, 1);\n@@ -356,1 +356,1 @@\n-    g_slice_free1 (sizeof (GstEventImpl), event);\n+    g_free (event);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstevent.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-  format = g_slice_new (GstFormatDefinition);\n+  format = g_new (GstFormatDefinition, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstformat.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,3 +109,0 @@\n-#ifdef HAVE_VALGRIND_VALGRIND_H\n-#  include <valgrind\/valgrind.h>\n-#endif\n@@ -1742,1 +1739,1 @@\n-  entry = g_slice_new (LogFuncEntry);\n+  entry = g_new (LogFuncEntry, 1);\n@@ -1809,1 +1806,1 @@\n-    g_slice_free (LogFuncEntry, entry);\n+    g_free (entry);\n@@ -2094,1 +2091,1 @@\n-  entry = g_slice_new (LevelNameEntry);\n+  entry = g_new (LevelNameEntry, 1);\n@@ -2129,1 +2126,1 @@\n-      g_slice_free (LevelNameEntry, entry);\n+      g_free (entry);\n@@ -2149,1 +2146,1 @@\n-  cat = g_slice_new (GstDebugCategory);\n+  cat = g_new (GstDebugCategory, 1);\n@@ -2166,1 +2163,1 @@\n-    g_slice_free (GstDebugCategory, cat);\n+    g_free (cat);\n@@ -2531,1 +2528,1 @@\n-    g_slice_free (LevelNameEntry, level_name_entry);\n+    g_free (level_name_entry);\n@@ -2554,1 +2551,1 @@\n-    g_slice_free (GstDebugCategory, cat);\n+    g_free (cat);\n@@ -2566,1 +2563,1 @@\n-    g_slice_free (LogFuncEntry, log_func_entry);\n+    g_free (log_func_entry);\n@@ -2707,0 +2704,7 @@\n+void\n+gst_debug_log_id_literal (GstDebugCategory * category, GstDebugLevel level,\n+    const gchar * file, const gchar * function, gint line,\n+    const gchar * id, const gchar * message_string)\n+{\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstinfo.c","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"glib-compat-private.h\"\n@@ -86,1 +87,1 @@\n-  copy = g_slice_copy (it->size, it);\n+  copy = g_memdup2 (it, it->size);\n@@ -162,1 +163,1 @@\n-  result = g_slice_alloc0 (size);\n+  result = g_malloc0 (size);\n@@ -425,1 +426,1 @@\n-  g_slice_free1 (it->size, it);\n+  g_free (it);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstiterator.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  g_slice_free1 (sizeof (GstMessageImpl), message);\n+  g_free (message);\n@@ -243,1 +243,1 @@\n-  copy = g_slice_new0 (GstMessageImpl);\n+  copy = g_new0 (GstMessageImpl, 1);\n@@ -302,1 +302,1 @@\n-  message = g_slice_new0 (GstMessageImpl);\n+  message = g_new0 (GstMessageImpl, 1);\n@@ -323,1 +323,1 @@\n-    g_slice_free1 (sizeof (GstMessageImpl), message);\n+    g_free (message);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmessage.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,7 +62,0 @@\n-typedef struct\n-{\n-  GstCustomMeta meta;\n-\n-  GstStructure *structure;\n-} GstCustomMetaImpl;\n-\n@@ -81,1 +74,1 @@\n-  g_slice_free (GstMetaInfoImpl, data);\n+  g_free (data);\n@@ -157,1 +150,1 @@\n-  GstCustomMetaImpl *cmeta = (GstCustomMetaImpl *) meta;\n+  GstCustomMeta *cmeta = (GstCustomMeta *) meta;\n@@ -170,1 +163,1 @@\n-  GstCustomMetaImpl *cmeta = (GstCustomMetaImpl *) meta;\n+  GstCustomMeta *cmeta = (GstCustomMeta *) meta;\n@@ -180,1 +173,1 @@\n-  GstCustomMetaImpl *custom, *cmeta = (GstCustomMetaImpl *) meta;\n+  GstCustomMeta *custom, *cmeta = (GstCustomMeta *) meta;\n@@ -184,1 +177,1 @@\n-    return info->custom_transform_func (transbuf, (GstCustomMeta *) meta,\n+    return info->custom_transform_func (transbuf, cmeta,\n@@ -188,2 +181,1 @@\n-    custom =\n-        (GstCustomMetaImpl *) gst_buffer_add_meta (transbuf, meta->info, NULL);\n+    custom = (GstCustomMeta *) gst_buffer_add_meta (transbuf, meta->info, NULL);\n@@ -202,0 +194,40 @@\n+static gboolean\n+custom_serialize_func (const GstMeta * meta, GstByteArrayInterface * data,\n+    guint8 * version)\n+{\n+  const GstCustomMeta *cmeta = (const GstCustomMeta *) meta;\n+  gchar *str = gst_structure_serialize_full (cmeta->structure,\n+      GST_SERIALIZE_FLAG_STRICT);\n+  if (str == NULL)\n+    return FALSE;\n+\n+  gboolean ret = gst_byte_array_interface_append_data (data, (guint8 *) str,\n+      strlen (str) + 1);\n+  g_free (str);\n+\n+  return ret;\n+}\n+\n+static GstMeta *\n+custom_deserialize_func (const GstMetaInfo * info, GstBuffer * buffer,\n+    const guint8 * data, gsize size, guint8 version)\n+{\n+  if (version != 0 || size < 1 || data[size - 1] != '\\0')\n+    return NULL;\n+\n+  GstStructure *structure =\n+      gst_structure_new_from_string ((const gchar *) data);\n+  if (structure == NULL)\n+    return NULL;\n+\n+  GstMeta *meta = gst_buffer_add_meta (buffer, info, NULL);\n+  GstCustomMeta *cmeta = (GstCustomMeta *) meta;\n+\n+  gst_structure_set_parent_refcount (cmeta->structure, NULL);\n+  gst_structure_take (&cmeta->structure, structure);\n+  gst_structure_set_parent_refcount (cmeta->structure,\n+      &GST_MINI_OBJECT_REFCOUNT (buffer));\n+\n+  return meta;\n+}\n+\n@@ -218,1 +250,1 @@\n-  return ((GstCustomMetaImpl *) meta)->structure;\n+  return meta->structure;\n@@ -236,1 +268,1 @@\n-  return gst_structure_has_name (((GstCustomMetaImpl *) meta)->structure, name);\n+  return gst_structure_has_name (meta->structure, name);\n@@ -272,2 +304,3 @@\n-  GstMetaInfoImpl *info;\n-  GstMetaInfo *ret = NULL;\n+  GstMetaInfo *info;\n+  GstMetaInfoImpl *impl;\n+  const GstMetaInfo *ret = NULL;\n@@ -283,5 +316,2 @@\n-  info = (GstMetaInfoImpl *) gst_meta_register (api, name,\n-      sizeof (GstCustomMetaImpl),\n-      custom_init_func, custom_free_func, custom_transform_func);\n-\n-  if (!info)\n+  info = gst_meta_info_new (api, name, sizeof (GstCustomMeta));\n+  if (info == NULL)\n@@ -290,4 +320,7 @@\n-  info->is_custom = TRUE;\n-  info->custom_transform_func = transform_func;\n-  info->custom_transform_user_data = user_data;\n-  info->custom_transform_destroy_notify = destroy_data;\n+  impl = (GstMetaInfoImpl *) info;\n+\n+  info->init_func = custom_init_func;\n+  info->free_func = custom_free_func;\n+  info->transform_func = custom_transform_func;\n+  info->serialize_func = custom_serialize_func;\n+  info->deserialize_func = custom_deserialize_func;\n@@ -295,1 +328,6 @@\n-  ret = (GstMetaInfo *) info;\n+  impl->is_custom = TRUE;\n+  impl->custom_transform_func = transform_func;\n+  impl->custom_transform_user_data = user_data;\n+  impl->custom_transform_destroy_notify = destroy_data;\n+\n+  ret = gst_meta_info_register (info);\n@@ -301,0 +339,17 @@\n+\/**\n+ * gst_meta_register_custom_simple:\n+ * @name: the name of the #GstMeta implementation\n+ *\n+ * Simplified version of gst_meta_register_custom(), with no tags and no\n+ * transform function.\n+ *\n+ * Returns: (transfer none): a #GstMetaInfo that can be used to access metadata.\n+ * Since: 1.24\n+ *\/\n+const GstMetaInfo *\n+gst_meta_register_custom_simple (const gchar * name)\n+{\n+  const gchar *tags[] = { NULL };\n+  return gst_meta_register_custom (name, tags, NULL, NULL, NULL);\n+}\n+\n@@ -356,0 +411,26 @@\n+static const GstMetaInfo *\n+gst_meta_register_internal (GType api, const gchar * impl, gsize size,\n+    GstMetaInitFunction init_func, GstMetaFreeFunction free_func,\n+    GstMetaTransformFunction transform_func,\n+    GstMetaSerializeFunction serialize_func,\n+    GstMetaDeserializeFunction deserialize_func)\n+{\n+  GstMetaInfo *info;\n+  if (init_func == NULL)\n+    g_critical (\"Registering meta implementation '%s' without init function\",\n+        impl);\n+\n+  info = gst_meta_info_new (api, impl, size);\n+  if (info == NULL)\n+    return NULL;\n+\n+  info->init_func = init_func;\n+  info->free_func = free_func;\n+  info->transform_func = transform_func;\n+  info->serialize_func = serialize_func;\n+  info->deserialize_func = deserialize_func;\n+  ((GstMetaInfoImpl *) info)->is_custom = FALSE;\n+\n+  return gst_meta_info_register (info);\n+}\n+\n@@ -357,1 +438,1 @@\n- * gst_meta_register:\n+ * gst_meta_register: (skip):\n@@ -361,3 +442,3 @@\n- * @init_func: (scope async): a #GstMetaInitFunction\n- * @free_func: (scope async): a #GstMetaFreeFunction\n- * @transform_func: (scope async): a #GstMetaTransformFunction\n+ * @init_func: a #GstMetaInitFunction\n+ * @free_func: a #GstMetaFreeFunction\n+ * @transform_func: a #GstMetaTransformFunction\n@@ -373,1 +454,0 @@\n-\n@@ -379,1 +459,49 @@\n-  GstMetaInfo *info;\n+  return gst_meta_register_internal (api, impl, size, init_func, free_func,\n+      transform_func, NULL, NULL);\n+}\n+\n+\/**\n+ * gst_meta_info_new: (skip):\n+ * @api:  the type of the #GstMeta API\n+ * @impl: the name of the #GstMeta implementation\n+ * @size: the size of the #GstMeta structure\n+ *\n+ * Creates a new structure that needs to be filled before being\n+ * registered.  This structure should filled and then registered with\n+ * gst_meta_info_register().\n+ *\n+ * Example:\n+ * ```c\n+ * const GstMetaInfo *\n+ * gst_my_meta_get_info (void)\n+ * {\n+ *   static const GstMetaInfo *meta_info = NULL;\n+ *\n+ *   if (g_once_init_enter ((GstMetaInfo **) & meta_info)) {\n+ *     GstMetaInfo *info = gst_meta_info_new (\n+ *       gst_my_meta_api_get_type (),\n+ *         \"GstMyMeta\",\n+ *        sizeof (GstMyMeta));\n+ *     const GstMetaInfo *meta = NULL;\n+ *\n+ *     info->init_func = my_meta_init;\n+ *     info->free_func = my_meta_free;\n+ *     info->transform_func = my_meta_transform;\n+ *     info->serialize_func = my_meta_serialize;\n+ *     info->deserialize_func = my_meta_deserialize;\n+ *     meta = gst_meta_info_register (info);\n+ *     g_once_init_leave ((GstMetaInfo **) & meta_info, (GstMetaInfo *) meta);\n+ *   }\n+ *\n+ *   return meta_info;\n+ * }\n+ * ```\n+ *\n+ * Returns: a new #GstMetaInfo that needs to be filled\n+ *\n+ * Since: 1.24\n+ *\/\n+\n+GstMetaInfo *\n+gst_meta_info_new (GType api, const gchar * impl, gsize size)\n+{\n@@ -381,0 +509,1 @@\n+  GstMetaInfo *info;\n@@ -386,4 +515,0 @@\n-  if (init_func == NULL)\n-    g_critical (\"Registering meta implementation '%s' without init function\",\n-        impl);\n-\n@@ -394,2 +519,0 @@\n-  if (type == G_TYPE_INVALID)\n-    return NULL;\n@@ -397,1 +520,1 @@\n-  info = (GstMetaInfo *) g_slice_new (GstMetaInfoImpl);\n+  info = (GstMetaInfo *) g_new0 (GstMetaInfoImpl, 1);\n@@ -401,4 +524,26 @@\n-  info->init_func = init_func;\n-  info->free_func = free_func;\n-  info->transform_func = transform_func;\n-  ((GstMetaInfoImpl *) info)->is_custom = FALSE;\n+\n+  return info;\n+}\n+\n+\/**\n+ * gst_meta_info_register:\n+ * @info: (transfer full): a new #GstMetaInfo created by gst_meta_info_new()\n+ *\n+ * Registers a new meta.\n+ *\n+ * Use the structure returned by gst_meta_info_new(), it consumes it and the\n+ * structure shouldnt be used after. The one returned by the function can be\n+ * kept.\n+ *\n+ * Returns: (transfer none): the registered meta\n+ *\n+ * Since: 1.24\n+ *\/\n+\n+const GstMetaInfo *\n+gst_meta_info_register (GstMetaInfo * info)\n+{\n+  if (info->type == G_TYPE_INVALID) {\n+    g_free (info);\n+    return NULL;\n+  }\n@@ -407,2 +552,2 @@\n-      \"register \\\"%s\\\" implementing \\\"%s\\\" of size %\" G_GSIZE_FORMAT, impl,\n-      g_type_name (api), size);\n+      \"register \\\"%s\\\" implementing \\\"%s\\\" of size %\" G_GSIZE_FORMAT,\n+      g_type_name (info->type), g_type_name (info->api), info->size);\n@@ -411,2 +556,2 @@\n-  g_hash_table_insert (metainfo, (gpointer) g_intern_string (impl),\n-      (gpointer) info);\n+  g_hash_table_insert (metainfo,\n+      (gpointer) g_intern_string (g_type_name (info->type)), (gpointer) info);\n@@ -489,0 +634,177 @@\n+\n+\/**\n+ * gst_meta_serialize:\n+ * @meta: a #GstMeta\n+ * @data: #GstByteArrayInterface to append serialization data\n+ *\n+ * Serialize @meta into a format that can be stored or transmitted and later\n+ * deserialized by gst_meta_deserialize().\n+ *\n+ * This is only supported for meta that implements #GstMetaInfo.serialize_func,\n+ * %FALSE is returned otherwise.\n+ *\n+ * Upon failure, @data->data pointer could have been reallocated, but @data->len\n+ * won't be modified. This is intended to be able to append multiple metas\n+ * into the same #GByteArray.\n+ *\n+ * Since serialization size is often the same for every buffer, caller may want\n+ * to remember the size of previous data to preallocate the next.\n+ *\n+ * Returns: %TRUE on success, %FALSE otherwise.\n+ *\n+ * Since: 1.24\n+ *\/\n+gboolean\n+gst_meta_serialize (const GstMeta * meta, GstByteArrayInterface * data)\n+{\n+  g_return_val_if_fail (meta != NULL, FALSE);\n+  g_return_val_if_fail (data != NULL, FALSE);\n+\n+  if (meta->info->serialize_func != NULL) {\n+    const gchar *name = g_type_name (meta->info->type);\n+    guint32 name_len = strlen (name);\n+    guint32 orig_len = data->len;\n+    guint8 version = 0;\n+\n+    \/* Format: [total size][name_len][name][\\0][version][payload]\n+     * Preallocate space for header but only write it on success because we\n+     * don't have every info yet.\n+     *\/\n+    guint8 header_size = 2 * sizeof (guint32) + name_len + 2;\n+    if (!gst_byte_array_interface_set_size (data, data->len + header_size))\n+      return FALSE;\n+    if (meta->info->serialize_func (meta, data, &version)) {\n+      guint8 *header = data->data + orig_len;\n+      GST_WRITE_UINT32_LE (header + 0, data->len - orig_len);\n+      GST_WRITE_UINT32_LE (header + 4, name_len);\n+      memcpy (header + 8, name, name_len + 1);\n+      header[header_size - 1] = version;\n+      return TRUE;\n+    }\n+    \/\/ Serialization failed, rollback.\n+    gst_byte_array_interface_set_size (data, orig_len);\n+  }\n+\n+  return FALSE;\n+}\n+\n+typedef struct\n+{\n+  GstByteArrayInterface parent;\n+  GByteArray *data;\n+} ByteArrayImpl;\n+\n+static gboolean\n+byte_array_impl_resize (GstByteArrayInterface * parent, gsize length)\n+{\n+  ByteArrayImpl *self = (ByteArrayImpl *) parent;\n+\n+  g_byte_array_set_size (self->data, length);\n+  parent->data = self->data->data;\n+  return TRUE;\n+}\n+\n+\/**\n+ * gst_meta_serialize_simple:\n+ * @meta: a #GstMeta\n+ * @data: #GByteArray to append serialization data\n+ *\n+ * Same as gst_meta_serialize() but with a #GByteArray instead of\n+ * #GstByteArrayInterface.\n+ *\n+ * Returns: %TRUE on success, %FALSE otherwise.\n+ *\n+ * Since: 1.24\n+ *\/\n+gboolean\n+gst_meta_serialize_simple (const GstMeta * meta, GByteArray * data)\n+{\n+  ByteArrayImpl impl;\n+\n+  gst_byte_array_interface_init (&impl.parent);\n+  impl.parent.data = data->data;\n+  impl.parent.len = data->len;\n+  impl.parent.resize = byte_array_impl_resize;\n+  impl.data = data;\n+  return gst_meta_serialize (meta, (GstByteArrayInterface *) & impl);\n+}\n+\n+\/**\n+ * gst_meta_deserialize:\n+ * @buffer: a #GstBuffer\n+ * @data: serialization data obtained from gst_meta_serialize()\n+ * @size: size of @data\n+ * @consumed: (out): total size used by this meta, could be less than @size\n+ *\n+ * Recreate a #GstMeta from serialized data returned by\n+ * gst_meta_serialize() and add it to @buffer.\n+ *\n+ * Note that the meta must have been previously registered by calling one of\n+ * `gst_*_meta_get_info ()` functions.\n+ *\n+ * @consumed is set to the number of bytes that can be skipped from @data to\n+ * find the next meta serialization, if any. In case of parsing error that does\n+ * not allow to determine that size, @consumed is set to 0.\n+ *\n+ * Returns: (transfer none) (nullable): the metadata owned by @buffer, or %NULL.\n+ *\n+ * Since: 1.24\n+ *\/\n+GstMeta *\n+gst_meta_deserialize (GstBuffer * buffer, const guint8 * data, gsize size,\n+    guint32 * consumed)\n+{\n+  g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);\n+  g_return_val_if_fail (data != NULL, NULL);\n+  g_return_val_if_fail (consumed != NULL, NULL);\n+\n+  *consumed = 0;\n+\n+  \/* Format: [total size][name_len][name][\\0][version][payload] *\/\n+  if (size < 2 * sizeof (guint32))\n+    goto bad_header;\n+\n+  guint32 total_size = GST_READ_UINT32_LE (data + 0);\n+  guint32 name_len = GST_READ_UINT32_LE (data + 4);\n+  guint32 header_size = 2 * sizeof (guint32) + name_len + 2;\n+  if (size < total_size || total_size < header_size)\n+    goto bad_header;\n+\n+  guint8 version = data[header_size - 1];\n+  const gchar *name = (const gchar *) (data + 2 * sizeof (guint32));\n+  if (name[name_len] != '\\0')\n+    goto bad_header;\n+\n+  *consumed = total_size;\n+\n+  const GstMetaInfo *info = gst_meta_get_info (name);\n+  if (info == NULL) {\n+    GST_CAT_WARNING (GST_CAT_META,\n+        \"%s does not correspond to a registered meta\", name);\n+    return NULL;\n+  }\n+\n+  if (info->deserialize_func == NULL) {\n+    GST_CAT_WARNING (GST_CAT_META, \"Meta %s does not support deserialization\",\n+        name);\n+    return NULL;\n+  }\n+\n+  const guint8 *payload = data + header_size;\n+  guint32 payload_size = total_size - header_size;\n+  GstMeta *meta =\n+      info->deserialize_func (info, buffer, payload, payload_size, version);\n+  if (meta == NULL) {\n+    GST_CAT_WARNING (GST_CAT_META, \"Failed to deserialize %s payload\", name);\n+    GST_CAT_MEMDUMP (GST_CAT_META, \"Meta serialization payload\", payload,\n+        payload_size);\n+    return NULL;\n+  }\n+\n+  return meta;\n+\n+bad_header:\n+  GST_CAT_WARNING (GST_CAT_META, \"Could not parse meta serialization header\");\n+  GST_CAT_MEMDUMP (GST_CAT_META, \"Meta serialization data\", data, size);\n+  return NULL;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmeta.c","additions":371,"deletions":49,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+#include <gst\/gstbytearrayinterface.h>\n+\n+\n@@ -83,0 +86,1 @@\n+ *\n@@ -118,0 +122,8 @@\n+\/**\n+ * GstCustomMeta.structure:\n+ *\n+ * #GstStructure containing custom metadata.\n+ *\n+ * Since: 1.24\n+ *\/\n+\n@@ -120,0 +132,5 @@\n+ * @meta: parent #GstMeta\n+ * @structure: a #GstStructure containing custom metadata. (Since: 1.24)\n+ *\n+ * Extra custom metadata. The @structure field is the same as returned by\n+ * gst_custom_meta_get_structure().\n@@ -121,1 +138,3 @@\n- * Simple typing wrapper around #GstMeta\n+ * Since 1.24 it can be serialized using gst_meta_serialize() and\n+ * gst_meta_deserialize(), but only if the #GstStructure does not contain any\n+ * fields that cannot be serialized, see %GST_SERIALIZE_FLAG_STRICT.\n@@ -127,0 +146,1 @@\n+  GstStructure *structure;\n@@ -230,0 +250,77 @@\n+\/**\n+ * GstMetaSerializeFunction:\n+ * @meta: a #GstMeta\n+ * @data: #GstByteArrayInterface to append serialization data\n+ * @version: (out): version of the serialization format\n+ *\n+ * Serialize @meta into a format that can be stored or transmitted and later\n+ * deserialized by #GstMetaDeserializeFunction.\n+ *\n+ * By default version is set to 0, it should be bumped if incompatible changes\n+ * are made to the format so %GstMetaDeserializeFunction can deserialize each\n+ * version.\n+ *\n+ * Returns: %TRUE on success, %FALSE otherwise.\n+ *\n+ * Since: 1.24\n+ *\/\n+typedef gboolean (*GstMetaSerializeFunction) (const GstMeta *meta,\n+    GstByteArrayInterface *data, guint8 *version);\n+\n+\/**\n+ * GstMetaDeserializeFunction:\n+ * @info: #GstMetaInfo of the meta\n+ * @buffer: a #GstBuffer\n+ * @data: data obtained from #GstMetaSerializeFunction\n+ * @size: size of data to avoid buffer overflow\n+ *\n+ * Recreate a #GstMeta from serialized data returned by\n+ * #GstMetaSerializeFunction and add it to @buffer.\n+ *\n+ * Returns: (transfer none) (nullable): the metadata owned by @buffer, or %NULL.\n+ *\n+ * Since: 1.24\n+ *\/\n+typedef GstMeta *(*GstMetaDeserializeFunction) (const GstMetaInfo *info,\n+    GstBuffer *buffer, const guint8 *data, gsize size, guint8 version);\n+\n+\/**\n+ * GstMetaClearFunction:\n+ * @buffer: a #GstBuffer\n+ * @meta: a #GstMeta\n+ *\n+ * Clears the content of the meta. This will be called by the GstBufferPool\n+ * when a pooled buffer is returned.\n+ *\n+ * Since: 1.24\n+ *\/\n+typedef void (*GstMetaClearFunction) (GstBuffer *buffer, GstMeta *meta);\n+\n+\/**\n+ * GstMetaInfo.serialize_func:\n+ *\n+ * Function for serializing the metadata, or %NULL if not supported by this\n+ * meta.\n+ *\n+ * Since: 1.24\n+ *\/\n+\n+\/**\n+ * GstMetaInfo.deserialize_func:\n+ *\n+ * Function for deserializing the metadata, or %NULL if not supported by this\n+ * meta.\n+ *\n+ * Since: 1.24\n+ *\/\n+\n+\/**\n+ * GstMetaInfo.clear_func:\n+ *\n+ * Function for clearing the metadata, or %NULL if not supported by this\n+ * meta. This is called by the buffer pool when a buffer is returned for\n+ * pooled metas.\n+ *\n+ * Since: 1.24\n+ *\/\n+\n@@ -238,0 +335,4 @@\n+ * @serialize_func: function for serializing the metadata into a #GstStructure,\n+ *  or %NULL if not supported by this meta. (Since 1.24)\n+ * @deserialize_func: function for deserializing the metadata from a\n+ *  #GstStructure, or %NULL if not supported by this meta. (Since 1.24)\n@@ -250,0 +351,3 @@\n+  GstMetaSerializeFunction   serialize_func;\n+  GstMetaDeserializeFunction deserialize_func;\n+  GstMetaClearFunction       clear_func;\n@@ -269,0 +373,7 @@\n+GST_API\n+GstMetaInfo *        gst_meta_info_new (GType api,\n+                                        const gchar *impl,\n+                                        gsize size);\n+GST_API\n+const GstMetaInfo *  gst_meta_info_register (GstMetaInfo *info);\n+\n@@ -274,0 +385,3 @@\n+GST_API\n+const GstMetaInfo *  gst_meta_register_custom_simple (const gchar *name);\n+\n@@ -296,0 +410,12 @@\n+GST_API\n+gboolean             gst_meta_serialize         (const GstMeta *meta,\n+                                                 GstByteArrayInterface *data);\n+GST_API\n+gboolean             gst_meta_serialize_simple  (const GstMeta *meta,\n+                                                 GByteArray *data);\n+GST_API\n+GstMeta *            gst_meta_deserialize       (GstBuffer *buffer,\n+                                                 const guint8 *data,\n+                                                 gsize size,\n+                                                 guint32 *consumed);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmeta.h","additions":127,"deletions":1,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+  GST_OBJECT_FLAG_SET (object, GST_OBJECT_FLAG_CONSTRUCTED);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstobject.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,13 @@\n+\/**\n+ * GST_OBJECT_FLAG_CONSTRUCTED:\n+ *\n+ * Flag that's set when the object has been constructed. This can be used by\n+ * API such as base class setters to differentiate between the case where\n+ * they're called from a subclass's instance init function (and where the\n+ * object isn't fully constructed yet, and so one shouldn't do anything but\n+ * set values in the instance structure), and the case where the object is\n+ * constructed.\n+ *\n+ * Since: 1.24\n+ *\/\n+\n@@ -53,0 +66,6 @@\n+ * @GST_OBJECT_FLAG_CONSTRUCTED: flag that's set when the object has been\n+ * constructed. This can be used by API such as base class setters to\n+ * differentiate between the case where they're called from a subclass's\n+ * instance init function (and where the object isn't fully constructed yet,\n+ * and so one shouldn't do anything but set values in the instance structure),\n+ * and the case where the object is constructed. (Since: 1.24)\n@@ -60,0 +79,1 @@\n+  GST_OBJECT_FLAG_CONSTRUCTED = (1 << 1),\n@@ -97,0 +117,28 @@\n+\n+\/**\n+ * GST_OBJECT_AUTO_LOCK:\n+ * @obj: a #GstObject to lock\n+ * @var: a variable name to be declared\n+ *\n+ * Declare a #GMutexLocker variable with g_autoptr() and lock the object. The\n+ * mutex will be unlocked automatically when leaving the scope.\n+ *\n+ * ``` c\n+ * {\n+ *   GST_OBJECT_AUTO_LOCK (obj, locker);\n+ *\n+ *   obj->stuff_with_lock();\n+ *   if (cond) {\n+ *     \/\/ No need to unlock\n+ *     return;\n+ *   }\n+ *\n+ *   \/\/ Unlock before end of scope\n+ *   g_clear_pointer (&locker, g_mutex_locker_free);\n+ *   obj->stuff_without_lock();\n+ * }\n+ * ```\n+ * Since: 1.24.0\n+ *\/\n+#define GST_OBJECT_AUTO_LOCK(obj, var) g_autoptr(GMutexLocker) G_GNUC_UNUSED var = g_mutex_locker_new(GST_OBJECT_GET_LOCK(obj))\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstobject.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -662,0 +662,1 @@\n+    guint32 seqnum;\n@@ -667,0 +668,1 @@\n+    seqnum = gst_event_get_seqnum (event);\n@@ -671,0 +673,1 @@\n+    gst_event_set_seqnum (event, seqnum);\n@@ -2381,3 +2384,5 @@\n-\/* FIXME leftover from an attempt at refactoring... *\/\n-\/* call with the two pads unlocked, when this function returns GST_PAD_LINK_OK,\n- * the two pads will be locked in the srcpad, sinkpad order. *\/\n+\/* check that pads does not have any exisiting links\n+ * and that hierarchy is valid for linking.\n+ *\n+ * The LOCK should be held on both pads\n+ *\/\n@@ -2385,1 +2390,2 @@\n-gst_pad_link_prepare (GstPad * srcpad, GstPad * sinkpad, GstPadLinkCheck flags)\n+gst_pad_link_check_relations (GstPad * srcpad, GstPad * sinkpad,\n+    GstPadLinkCheck flags)\n@@ -2387,5 +2393,0 @@\n-  GST_CAT_INFO (GST_CAT_PADS, \"trying to link %s:%s and %s:%s\",\n-      GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));\n-\n-  GST_OBJECT_LOCK (srcpad);\n-\n@@ -2395,2 +2396,0 @@\n-  GST_OBJECT_LOCK (sinkpad);\n-\n@@ -2406,6 +2405,0 @@\n-  \/* check pad caps for non-empty intersection *\/\n-  if (!gst_pad_link_check_compatible_unlocked (srcpad, sinkpad, flags))\n-    goto no_format;\n-\n-  \/* FIXME check pad scheduling for non-empty intersection *\/\n-\n@@ -2421,1 +2414,0 @@\n-    GST_OBJECT_UNLOCK (srcpad);\n@@ -2431,2 +2423,0 @@\n-    GST_OBJECT_UNLOCK (sinkpad);\n-    GST_OBJECT_UNLOCK (srcpad);\n@@ -2438,2 +2428,0 @@\n-    GST_OBJECT_UNLOCK (sinkpad);\n-    GST_OBJECT_UNLOCK (srcpad);\n@@ -2442,2 +2430,23 @@\n-no_format:\n-  {\n+}\n+\n+\/* FIXME leftover from an attempt at refactoring... *\/\n+\/* call with the two pads unlocked, when this function returns GST_PAD_LINK_OK,\n+ * the two pads will be locked in the srcpad, sinkpad order. *\/\n+static GstPadLinkReturn\n+gst_pad_link_prepare (GstPad * srcpad, GstPad * sinkpad, GstPadLinkCheck flags)\n+{\n+  GstPadLinkReturn result;\n+\n+  GST_CAT_INFO (GST_CAT_PADS, \"trying to link %s:%s and %s:%s\",\n+      GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));\n+\n+  GST_OBJECT_LOCK (srcpad);\n+  GST_OBJECT_LOCK (sinkpad);\n+\n+  \/* Check pads state, not already linked and correct hierachy. *\/\n+  result = gst_pad_link_check_relations (srcpad, sinkpad, flags);\n+  if (result != GST_PAD_LINK_OK)\n+    goto unlock_and_return;\n+\n+  \/* check pad caps for non-empty intersection *\/\n+  if (!gst_pad_link_check_compatible_unlocked (srcpad, sinkpad, flags)) {\n@@ -2445,0 +2454,17 @@\n+    result = GST_PAD_LINK_NOFORMAT;\n+    goto unlock_and_return;\n+  }\n+\n+  \/* Need to recheck our pads since gst_pad_link_check_compatible_unlocked might have temporarily unlocked them.\n+     Keeping the first check, because gst_pad_link_check_compatible_unlocked potentially is an expensive operation\n+     which gst_pad_link_check_relations is not. *\/\n+  result = gst_pad_link_check_relations (srcpad, sinkpad, flags);\n+  if (result != GST_PAD_LINK_OK)\n+    goto unlock_and_return;\n+\n+  \/* FIXME check pad scheduling for non-empty intersection *\/\n+\n+  return GST_PAD_LINK_OK;\n+\n+unlock_and_return:\n+  {\n@@ -2447,1 +2473,1 @@\n-    return GST_PAD_LINK_NOFORMAT;\n+    return result;\n@@ -4164,1 +4190,1 @@\n-  gboolean res, serialized;\n+  gboolean res = FALSE, serialized;\n@@ -4208,1 +4234,0 @@\n-  GST_TRACER_PAD_QUERY_POST (pad, query, res);\n@@ -4217,0 +4242,2 @@\n+  GST_TRACER_PAD_QUERY_POST (pad, query, res);\n+\n@@ -4238,0 +4265,1 @@\n+    GST_TRACER_PAD_QUERY_POST (pad, query, res);\n@@ -4246,0 +4274,1 @@\n+    GST_TRACER_PAD_QUERY_POST (pad, query, res);\n@@ -4253,0 +4282,1 @@\n+    GST_TRACER_PAD_QUERY_POST (pad, query, res);\n@@ -4261,0 +4291,1 @@\n+    GST_TRACER_PAD_QUERY_POST (pad, query, res);\n@@ -5569,2 +5600,3 @@\n-  GST_LOG_OBJECT (pad, \"sending event %p (%s) to peerpad %\" GST_PTR_FORMAT,\n-      event, gst_event_type_get_name (event_type), peerpad);\n+  GST_LOG_OBJECT (pad,\n+      \"sending event %\" GST_PTR_FORMAT \" to peerpad %\" GST_PTR_FORMAT,\n+      event, peerpad);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpad.c","additions":61,"deletions":29,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1252,0 +1252,28 @@\n+\n+\/**\n+ * GST_PAD_STREAM_AUTO_LOCK\n+ * @pad: a #GstPad\n+ * @var: a variable name to be declared\n+ *\n+ * Declare a #GRecMutexLocker variable with g_autoptr() and lock the pad. The\n+ * recursive mutex will be unlocked automatically when leaving the scope.\n+ *\n+ * ``` c\n+ * {\n+ *   GST_PAD_STREAM_AUTO_LOCK (pad, locker);\n+ *\n+ *   gst_pad_push_event(pad, event1);\n+ *   if (cond) {\n+ *     \/\/ No need to unlock\n+ *     return;\n+ *   }\n+ *\n+ *   \/\/ Unlock before end of scope\n+ *   g_clear_pointer (&locker, g_rec_mutex_locker_free);\n+ *   gst_pad_push_event(pad, event2);\n+ * }\n+ * ```\n+ * Since: 1.24.0\n+ *\/\n+#define GST_PAD_STREAM_AUTO_LOCK(pad, var) g_autoptr(GRecMutexLocker) G_GNUC_UNUSED var = g_rec_mutex_locker_new(GST_PAD_GET_STREAM_LOCK(pad))\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpad.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  ctx = g_slice_new (GstParseContext);\n+  ctx = g_new (GstParseContext, 1);\n@@ -139,1 +139,1 @@\n-    g_slice_free (GstParseContext, context);\n+    g_free (context);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstparse.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+  GstClockTime min_latency;\n@@ -237,0 +238,1 @@\n+  pipeline->priv->min_latency = GST_CLOCK_TIME_NONE;\n@@ -522,0 +524,1 @@\n+      GST_OBJECT_LOCK (element);\n@@ -523,0 +526,2 @@\n+      pipeline->priv->min_latency = GST_CLOCK_TIME_NONE;\n+      GST_OBJECT_UNLOCK (element);\n@@ -532,0 +537,1 @@\n+    GST_OBJECT_LOCK (element);\n@@ -535,0 +541,1 @@\n+    GST_OBJECT_UNLOCK (element);\n@@ -624,0 +631,1 @@\n+      gboolean is_live;\n@@ -631,0 +639,4 @@\n+      GST_OBJECT_LOCK (pipeline);\n+      is_live = pipeline->priv->is_live;\n+      GST_OBJECT_UNLOCK (pipeline);\n+\n@@ -632,2 +644,1 @@\n-      if (pipeline->priv->is_live\n-          && GST_STATE_TARGET (pipeline) == GST_STATE_PLAYING) {\n+      if (is_live && GST_STATE_TARGET (pipeline) == GST_STATE_PLAYING) {\n@@ -696,0 +707,4 @@\n+    GST_OBJECT_LOCK (pipeline);\n+    pipeline->priv->min_latency = min_latency;\n+    GST_OBJECT_UNLOCK (pipeline);\n+\n@@ -1171,0 +1186,49 @@\n+\n+\/**\n+ * gst_pipeline_is_live:\n+ * @pipeline: a #GstPipeline\n+ *\n+ * Check if @pipeline is live.\n+ *\n+ * Returns: %TRUE if @pipeline is live, %FALSE if not or if it did not reach the PAUSED state yet.\n+ *\n+ * MT safe.\n+ *\n+ * Since: 1.24\n+ *\/\n+gboolean\n+gst_pipeline_is_live (GstPipeline * pipeline)\n+{\n+  gboolean is_live;\n+\n+  GST_OBJECT_LOCK (pipeline);\n+  is_live = pipeline->priv->is_live;\n+  GST_OBJECT_UNLOCK (pipeline);\n+\n+  return is_live;\n+}\n+\n+\/**\n+ * gst_pipeline_get_configured_latency:\n+ * @pipeline: a #GstPipeline\n+ *\n+ * Return the configured latency on @pipeline.\n+ *\n+ * Returns: @pipeline configured latency, or %GST_CLOCK_TIME_NONE if none has been configured\n+ * because @pipeline did not reach the PLAYING state yet.\n+ *\n+ * MT safe.\n+ *\n+ * Since: 1.24\n+ *\/\n+GstClockTime\n+gst_pipeline_get_configured_latency (GstPipeline * pipeline)\n+{\n+  GstClockTime min_latency;\n+\n+  GST_OBJECT_LOCK (pipeline);\n+  min_latency = pipeline->priv->min_latency;\n+  GST_OBJECT_UNLOCK (pipeline);\n+\n+  return min_latency;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpipeline.c","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -133,0 +133,6 @@\n+GST_API\n+gboolean        gst_pipeline_is_live            (GstPipeline *pipeline);\n+\n+GST_API\n+GstClockTime    gst_pipeline_get_configured_latency    (GstPipeline * pipeline);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpipeline.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,0 +169,4 @@\n+  if (plugin->priv->status_info) {\n+    gst_structure_free (plugin->priv->status_info);\n+  }\n+\n@@ -358,1 +362,2 @@\n- *   source-package\n+ *   source-package or\n+ *   *\n@@ -374,0 +379,3 @@\n+  if (strcmp (pattern, \"*\") == 0)\n+    return TRUE;\n+\n@@ -1632,2 +1640,3 @@\n-          GST_INFO_OBJECT (plugin, \"ignoring environment variable content '%s'\"\n-              \": either not an absolute path or not a path at all\", arr[i]);\n+          GST_INFO_OBJECT (plugin, \"ignoring environment variable '%s' with \"\n+              \"content #%u '%s': either not an absolute path or not a path at all\",\n+              components[0], i, arr[i]);\n@@ -1715,1 +1724,1 @@\n-  recurse_dirs = ! !(flags & GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);\n+  recurse_dirs = !!(flags & GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);\n@@ -1777,1 +1786,1 @@\n-  recurse_into_dirs = ! !(flags & GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);\n+  recurse_into_dirs = !!(flags & GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);\n@@ -1894,1 +1903,1 @@\n-  g_slice_free (GstPluginDep, dep);\n+  g_free (dep);\n@@ -1973,1 +1982,1 @@\n-  dep = g_slice_new (GstPluginDep);\n+  dep = g_new (GstPluginDep, 1);\n@@ -2047,0 +2056,145 @@\n+\n+static void\n+gst_plugin_add_status_message (GstPlugin * plugin, const gchar * field_name,\n+    const gchar * message)\n+{\n+  const GValue *val = NULL;\n+  GValue str_val = G_VALUE_INIT;\n+\n+  g_return_if_fail (GST_IS_PLUGIN (plugin));\n+  g_return_if_fail (message != NULL);\n+\n+  g_value_init (&str_val, G_TYPE_STRING);\n+  g_value_set_string (&str_val, message);\n+\n+  if (plugin->priv->status_info == NULL)\n+    plugin->priv->status_info = gst_structure_new_empty (\"plugin-status-info\");\n+  else\n+    val = gst_structure_get_value (plugin->priv->status_info, field_name);\n+\n+  if (val != NULL) {\n+    gst_value_list_append_and_take_value ((GValue *) val, &str_val);\n+  } else {\n+    GValue list_val = G_VALUE_INIT;\n+\n+    gst_value_list_init (&list_val, 1);\n+    gst_value_list_append_and_take_value (&list_val, &str_val);\n+    gst_structure_take_value (plugin->priv->status_info, field_name, &list_val);\n+  }\n+\n+  GST_TRACE_OBJECT (plugin, \"Status info now: %\" GST_PTR_FORMAT,\n+      plugin->priv->status_info);\n+}\n+\n+\/**\n+ * gst_plugin_add_status_error:\n+ * @plugin: a #GstPlugin\n+ * @message: the status error message\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_plugin_add_status_error (GstPlugin * plugin, const gchar * message)\n+{\n+  gst_plugin_add_status_message (plugin, \"error-message\", message);\n+}\n+\n+\/**\n+ * gst_plugin_add_status_warning:\n+ * @plugin: a #GstPlugin\n+ * @message: the status warning message\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_plugin_add_status_warning (GstPlugin * plugin, const gchar * message)\n+{\n+  gst_plugin_add_status_message (plugin, \"warning-message\", message);\n+}\n+\n+\/**\n+ * gst_plugin_add_status_info:\n+ * @plugin: a #GstPlugin\n+ * @message: the status info message\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_plugin_add_status_info (GstPlugin * plugin, const gchar * message)\n+{\n+  gst_plugin_add_status_message (plugin, \"info-message\", message);\n+}\n+\n+static gchar **\n+gst_plugin_get_status_messages (GstPlugin * plugin, const gchar * field_name)\n+{\n+  const GValue *list_val;\n+  guint n_vals, i;\n+  gchar **arr;\n+\n+  g_return_val_if_fail (GST_IS_PLUGIN (plugin), NULL);\n+\n+  if (plugin->priv->status_info == NULL)\n+    return NULL;\n+\n+  list_val = gst_structure_get_value (plugin->priv->status_info, field_name);\n+\n+  if (list_val == NULL)\n+    return NULL;\n+\n+  n_vals = gst_value_list_get_size (list_val);\n+\n+  if (n_vals == 0)\n+    return NULL;\n+\n+  arr = g_new0 (gchar *, n_vals + 1);\n+\n+  for (i = 0; i < n_vals; ++i) {\n+    const GValue *str_val = gst_value_list_get_value (list_val, i);\n+    arr[i] = g_value_dup_string (str_val);\n+  }\n+\n+  return arr;\n+}\n+\n+\/**\n+ * gst_plugin_get_status_errors:\n+ * @plugin: a #GstPlugin\n+ *\n+ * Returns: (transfer full) (nullable): an array of plugin status error messages, or NULL\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar **\n+gst_plugin_get_status_errors (GstPlugin * plugin)\n+{\n+  return gst_plugin_get_status_messages (plugin, \"error-message\");\n+}\n+\n+\/**\n+ * gst_plugin_get_status_warnings:\n+ * @plugin: a #GstPlugin\n+ *\n+ * Returns: (transfer full) (nullable): an array of plugin status warning messages, or NULL\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar **\n+gst_plugin_get_status_warnings (GstPlugin * plugin)\n+{\n+  return gst_plugin_get_status_messages (plugin, \"warning-message\");\n+}\n+\n+\/**\n+ * gst_plugin_get_status_infos:\n+ * @plugin: a #GstPlugin\n+ *\n+ * Returns: (transfer full) (nullable): an array of plugin status info messages, or NULL\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar **\n+gst_plugin_get_status_infos (GstPlugin * plugin)\n+{\n+  return gst_plugin_get_status_messages (plugin, \"info-message\");\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstplugin.c","additions":161,"deletions":7,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -395,0 +395,18 @@\n+GST_API\n+void                    gst_plugin_add_status_error      (GstPlugin   * plugin,\n+                                                          const gchar * message);\n+GST_API\n+void                    gst_plugin_add_status_warning    (GstPlugin   * plugin,\n+                                                          const gchar * message);\n+GST_API\n+void                    gst_plugin_add_status_info       (GstPlugin   * plugin,\n+                                                          const gchar * message);\n+GST_API\n+gchar **                gst_plugin_get_status_errors     (GstPlugin   * plugin);\n+\n+GST_API\n+gchar **                gst_plugin_get_status_warnings   (GstPlugin   * plugin);\n+\n+GST_API\n+gchar **                gst_plugin_get_status_infos      (GstPlugin   * plugin);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstplugin.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -313,2 +313,7 @@\n- * Checks whether the given plugin feature is at least\n- *  the required version\n+ * Checks whether the given plugin feature is at least the required version.\n+ *\n+ * Note: Since version 1.24 this function no longer returns %TRUE if the\n+ * version is a git development version (e.g. 1.23.0.1) and the check is\n+ * for the \"next\" micro version, that is it will no longer return %TRUE for\n+ * e.g. 1.23.0.1 if the check is for 1.23.1. It is still possible to parse\n+ * the nano version from the string and do this check that way if needed.\n@@ -358,4 +363,0 @@\n-      \/* micro is 1 smaller but we have a nano version, this is the upcoming\n-       * release of the requested version and we're ok then *\/\n-      else if (nscan == 4 && nano > 0 && (micro + 1 == min_micro))\n-        ret = TRUE;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpluginfeature.c","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,1191 +0,0 @@\n-\/* GStreamer\n- * Copyright (C) 2008 Jan Schmidt <jan.schmidt@sun.com>\n- *\n- * gstpluginloader.c: GstPluginLoader helper for loading plugin files\n- * out of process.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n- * Boston, MA 02110-1301, USA.\n- *\/\n-\n-#ifdef HAVE_CONFIG_H\n-#  include \"config.h\"\n-#endif\n-\n-#include <gst\/gst_private.h>\n-\n-#ifndef G_OS_WIN32\n-#include <sys\/types.h>\n-#include <sys\/wait.h>\n-#include <sys\/stat.h>\n-#include <fcntl.h>\n-#include <unistd.h>\n-#else\n-#define WIN32_LEAN_AND_MEAN\n-\n-#define fsync(fd) _commit(fd)\n-#include <io.h>\n-\n-#include <windows.h>\n-extern HMODULE _priv_gst_dll_handle;\n-#endif\n-\n-#ifdef HAVE_SYS_UTSNAME_H\n-#include <sys\/utsname.h>\n-#endif\n-\n-#include <errno.h>\n-\n-#include <gst\/gstconfig.h>\n-\n-#include <gst\/gstpoll.h>\n-#include <gst\/gstutils.h>\n-\n-#include <gst\/gstpluginloader.h>\n-#include <gst\/gstregistrychunks.h>\n-#include <gst\/gstregistrybinary.h>\n-\n-\/* IMPORTANT: Bump the version number if the plugin loader packet protocol\n- * changes. Changes in the binary registry format itself are handled by\n- * bumping the GST_MAGIC_BINARY_VERSION_STR\n- *\/\n-static const guint32 loader_protocol_version = 3;\n-\n-#define GST_CAT_DEFAULT GST_CAT_PLUGIN_LOADING\n-\n-static GstPluginLoader *plugin_loader_new (GstRegistry * registry);\n-static gboolean plugin_loader_free (GstPluginLoader * loader);\n-static gboolean plugin_loader_load (GstPluginLoader * loader,\n-    const gchar * filename, off_t file_size, time_t file_mtime);\n-\n-\/* functions used in GstRegistry scanning *\/\n-const GstPluginLoaderFuncs _priv_gst_plugin_loader_funcs = {\n-  plugin_loader_new, plugin_loader_free, plugin_loader_load\n-};\n-\n-typedef struct _PendingPluginEntry\n-{\n-  \/* sequence number *\/\n-  guint32 tag;\n-  gchar *filename;\n-  off_t file_size;\n-  time_t file_mtime;\n-} PendingPluginEntry;\n-\n-struct _GstPluginLoader\n-{\n-  GstRegistry *registry;\n-  GstPoll *fdset;\n-\n-  gboolean child_running;\n-  GPid child_pid;\n-  GstPollFD fd_w;\n-  GstPollFD fd_r;\n-\n-  gboolean is_child;\n-  gboolean got_plugin_details;\n-\n-  \/* Transmit buffer *\/\n-  guint8 *tx_buf;\n-  guint tx_buf_size;\n-  guint tx_buf_write;\n-  guint tx_buf_read;\n-\n-  \/* next sequence number (for PendingPluginEntry) *\/\n-  guint32 next_tag;\n-\n-  guint8 *rx_buf;\n-  guint rx_buf_size;\n-  gboolean rx_done;\n-  gboolean rx_got_sync;\n-\n-  \/* Head and tail of the pending plugins list. List of\n-     PendingPluginEntry structs *\/\n-  GList *pending_plugins;\n-  GList *pending_plugins_tail;\n-};\n-\n-#define PACKET_EXIT 1\n-#define PACKET_LOAD_PLUGIN 2\n-#define PACKET_SYNC 3\n-#define PACKET_PLUGIN_DETAILS 4\n-#define PACKET_VERSION 5\n-\n-#define BUF_INIT_SIZE 512\n-#define BUF_GROW_EXTRA 512\n-#define BUF_MAX_SIZE (32 * 1024 * 1024)\n-\n-#define HEADER_SIZE 12\n-\/* 4 magic hex bytes to mark each packet *\/\n-#define HEADER_MAGIC 0xbefec0ae\n-#define ALIGNMENT   (sizeof (void *))\n-\n-static gboolean gst_plugin_loader_spawn (GstPluginLoader * loader);\n-static void put_packet (GstPluginLoader * loader, guint type, guint32 tag,\n-    const guint8 * payload, guint32 payload_len);\n-static gboolean exchange_packets (GstPluginLoader * l);\n-static gboolean plugin_loader_replay_pending (GstPluginLoader * l);\n-static gboolean plugin_loader_load_and_sync (GstPluginLoader * l,\n-    PendingPluginEntry * entry);\n-static void plugin_loader_create_blacklist_plugin (GstPluginLoader * l,\n-    PendingPluginEntry * entry);\n-static void plugin_loader_cleanup_child (GstPluginLoader * loader);\n-static gboolean plugin_loader_sync_with_child (GstPluginLoader * l);\n-\n-static GstPluginLoader *\n-plugin_loader_new (GstRegistry * registry)\n-{\n-  GstPluginLoader *l = g_slice_new0 (GstPluginLoader);\n-\n-  if (registry)\n-    l->registry = gst_object_ref (registry);\n-  l->fdset = gst_poll_new (FALSE);\n-  gst_poll_fd_init (&l->fd_w);\n-  gst_poll_fd_init (&l->fd_r);\n-\n-  l->tx_buf_size = BUF_INIT_SIZE;\n-  l->tx_buf = g_malloc (BUF_INIT_SIZE);\n-\n-  l->next_tag = 0;\n-\n-  l->rx_buf_size = BUF_INIT_SIZE;\n-  l->rx_buf = g_malloc (BUF_INIT_SIZE);\n-\n-  return l;\n-}\n-\n-static gboolean\n-plugin_loader_free (GstPluginLoader * loader)\n-{\n-  GList *cur;\n-  gboolean got_plugin_details;\n-  gint fsync_ret;\n-\n-  do {\n-    fsync_ret = fsync (loader->fd_w.fd);\n-  } while (fsync_ret < 0 && errno == EINTR);\n-\n-  if (loader->child_running) {\n-    put_packet (loader, PACKET_EXIT, 0, NULL, 0);\n-\n-    \/* Swap packets with the child until it exits cleanly *\/\n-    while (!loader->rx_done) {\n-      if (exchange_packets (loader) || loader->rx_done)\n-        continue;\n-\n-      if (!plugin_loader_replay_pending (loader))\n-        break;\n-      put_packet (loader, PACKET_EXIT, 0, NULL, 0);\n-    }\n-\n-    plugin_loader_cleanup_child (loader);\n-  } else {\n-    close (loader->fd_w.fd);\n-    close (loader->fd_r.fd);\n-  }\n-\n-  gst_poll_free (loader->fdset);\n-\n-  g_free (loader->rx_buf);\n-  g_free (loader->tx_buf);\n-\n-  if (loader->registry)\n-    gst_object_unref (loader->registry);\n-\n-  got_plugin_details = loader->got_plugin_details;\n-\n-  \/* Free any pending plugin entries *\/\n-  cur = loader->pending_plugins;\n-  while (cur) {\n-    PendingPluginEntry *entry = (PendingPluginEntry *) (cur->data);\n-    g_free (entry->filename);\n-    g_slice_free (PendingPluginEntry, entry);\n-\n-    cur = g_list_delete_link (cur, cur);\n-  }\n-\n-  g_slice_free (GstPluginLoader, loader);\n-\n-  return got_plugin_details;\n-}\n-\n-static gboolean\n-plugin_loader_load (GstPluginLoader * loader, const gchar * filename,\n-    off_t file_size, time_t file_mtime)\n-{\n-  gint len;\n-  PendingPluginEntry *entry;\n-\n-  if (!gst_plugin_loader_spawn (loader))\n-    return FALSE;\n-\n-  \/* Send a packet to the child requesting that it load the given file *\/\n-  GST_LOG_OBJECT (loader->registry,\n-      \"Sending file %s to child. tag %u\", filename, loader->next_tag);\n-\n-  entry = g_slice_new (PendingPluginEntry);\n-  entry->tag = loader->next_tag++;\n-  entry->filename = g_strdup (filename);\n-  entry->file_size = file_size;\n-  entry->file_mtime = file_mtime;\n-  loader->pending_plugins_tail =\n-      g_list_append (loader->pending_plugins_tail, entry);\n-\n-  if (loader->pending_plugins == NULL)\n-    loader->pending_plugins = loader->pending_plugins_tail;\n-  else\n-    loader->pending_plugins_tail = g_list_next (loader->pending_plugins_tail);\n-\n-  len = strlen (filename);\n-  put_packet (loader, PACKET_LOAD_PLUGIN, entry->tag,\n-      (guint8 *) filename, len + 1);\n-\n-  if (!exchange_packets (loader)) {\n-    if (!plugin_loader_replay_pending (loader))\n-      return FALSE;\n-  }\n-\n-  return TRUE;\n-}\n-\n-static gboolean\n-plugin_loader_replay_pending (GstPluginLoader * l)\n-{\n-  GList *cur, *next;\n-\n-restart:\n-  if (!gst_plugin_loader_spawn (l))\n-    return FALSE;\n-\n-  \/* Load each plugin one by one synchronously until we find the\n-   * crashing one *\/\n-  while ((cur = l->pending_plugins)) {\n-    PendingPluginEntry *entry = (PendingPluginEntry *) (cur->data);\n-\n-    if (!plugin_loader_load_and_sync (l, entry)) {\n-      \/* Create dummy plugin entry to block re-scanning this file *\/\n-      GST_ERROR (\"Plugin file %s failed to load. Blacklisting\",\n-          entry->filename);\n-      plugin_loader_create_blacklist_plugin (l, entry);\n-      l->got_plugin_details = TRUE;\n-      \/* Now remove this crashy plugin from the head of the list *\/\n-      l->pending_plugins = g_list_delete_link (cur, cur);\n-      g_free (entry->filename);\n-      g_slice_free (PendingPluginEntry, entry);\n-      if (l->pending_plugins == NULL)\n-        l->pending_plugins_tail = NULL;\n-      if (!gst_plugin_loader_spawn (l))\n-        return FALSE;\n-      break;\n-    }\n-  }\n-\n-  \/* We exited after finding the crashing one. If there's any more pending,\n-   * dispatch them post-haste, but don't wait *\/\n-  for (cur = l->pending_plugins; cur != NULL; cur = next) {\n-    PendingPluginEntry *entry = (PendingPluginEntry *) (cur->data);\n-\n-    next = g_list_next (cur);\n-\n-    put_packet (l, PACKET_LOAD_PLUGIN, entry->tag,\n-        (guint8 *) entry->filename, strlen (entry->filename) + 1);\n-\n-    \/* This might invalidate cur, which is why we grabbed 'next' above *\/\n-    if (!exchange_packets (l))\n-      goto restart;\n-  }\n-\n-  return TRUE;\n-}\n-\n-static gboolean\n-plugin_loader_sync_with_child (GstPluginLoader * l)\n-{\n-  put_packet (l, PACKET_SYNC, 0, NULL, 0);\n-\n-  l->rx_got_sync = FALSE;\n-  while (!l->rx_got_sync) {\n-    if (!exchange_packets (l))\n-      return FALSE;\n-  }\n-  return TRUE;\n-}\n-\n-static gboolean\n-plugin_loader_load_and_sync (GstPluginLoader * l, PendingPluginEntry * entry)\n-{\n-  gint len;\n-\n-  GST_DEBUG_OBJECT (l->registry, \"Synchronously loading plugin file %s\",\n-      entry->filename);\n-\n-  len = strlen (entry->filename);\n-  put_packet (l, PACKET_LOAD_PLUGIN, entry->tag,\n-      (guint8 *) entry->filename, len + 1);\n-\n-  return plugin_loader_sync_with_child (l);\n-}\n-\n-static void\n-plugin_loader_create_blacklist_plugin (GstPluginLoader * l,\n-    PendingPluginEntry * entry)\n-{\n-  GstPlugin *plugin = g_object_new (GST_TYPE_PLUGIN, NULL);\n-\n-  plugin->filename = g_strdup (entry->filename);\n-  plugin->file_mtime = entry->file_mtime;\n-  plugin->file_size = entry->file_size;\n-  GST_OBJECT_FLAG_SET (plugin, GST_PLUGIN_FLAG_BLACKLISTED);\n-\n-  plugin->basename = g_path_get_basename (plugin->filename);\n-  plugin->desc.name = g_intern_string (plugin->basename);\n-  plugin->desc.description = \"Plugin for blacklisted file\";\n-  plugin->desc.version = \"0.0.0\";\n-  plugin->desc.license = \"BLACKLIST\";\n-  plugin->desc.source = plugin->desc.license;\n-  plugin->desc.package = plugin->desc.license;\n-  plugin->desc.origin = plugin->desc.license;\n-\n-  GST_DEBUG (\"Adding blacklist plugin '%s'\", plugin->desc.name);\n-  gst_registry_add_plugin (l->registry, plugin);\n-}\n-\n-#ifdef __APPLE__\n-#if defined(__x86_64__)\n-#define USR_BIN_ARCH_SWITCH \"-x86_64\"\n-#elif defined(__i386__)\n-#define USR_BIN_ARCH_SWITCH \"-i386\"\n-#elif defined(__ppc__)\n-#define USR_BIN_ARCH_SWITCH \"-ppc\"\n-#elif defined(__ppc64__)\n-#define USR_BIN_ARCH_SWITCH \"-ppc64\"\n-#endif\n-#endif\n-\n-#define YES_MULTIARCH 1\n-#define NO_MULTIARCH  2\n-\n-#if defined (__APPLE__) && defined (USR_BIN_ARCH_SWITCH)\n-static gboolean\n-gst_plugin_loader_use_usr_bin_arch (void)\n-{\n-  static gsize multiarch = 0;\n-\n-  if (g_once_init_enter (&multiarch)) {\n-    gsize res = NO_MULTIARCH;\n-\n-#ifdef HAVE_SYS_UTSNAME_H\n-    {\n-      struct utsname uname_data;\n-\n-      if (uname (&uname_data) == 0) {\n-        \/* Check for OS X >= 10.5 (darwin kernel 9.0) *\/\n-        GST_LOG (\"%s %s\", uname_data.sysname, uname_data.release);\n-        if (g_ascii_strcasecmp (uname_data.sysname, \"Darwin\") == 0 &&\n-            g_strtod (uname_data.release, NULL) >= 9.0) {\n-          res = YES_MULTIARCH;\n-        }\n-      }\n-    }\n-#endif\n-\n-    GST_INFO (\"multiarch: %s\", (res == YES_MULTIARCH) ? \"yes\" : \"no\");\n-    g_once_init_leave (&multiarch, res);\n-  }\n-  return (multiarch == YES_MULTIARCH);\n-}\n-#endif \/* __APPLE__ && USR_BIN_ARCH_SWITCH *\/\n-\n-static gboolean\n-gst_plugin_loader_try_helper (GstPluginLoader * loader, gchar * location)\n-{\n-  char *argv[6] = { NULL, };\n-  int c = 0;\n-  GError *error = NULL;\n-\n-#if defined (__APPLE__) && defined (USR_BIN_ARCH_SWITCH)\n-  if (gst_plugin_loader_use_usr_bin_arch ()) {\n-    argv[c++] = (char *) \"\/usr\/bin\/arch\";\n-    argv[c++] = (char *) USR_BIN_ARCH_SWITCH;\n-  }\n-#endif\n-  argv[c++] = location;\n-  argv[c++] = (char *) \"-l\";\n-  argv[c++] = _gst_executable_path;\n-  argv[c++] = NULL;\n-\n-  if (c > 4) {\n-    GST_LOG (\"Trying to spawn gst-plugin-scanner helper at %s with arch %s\",\n-        location, argv[1]);\n-  } else {\n-    GST_LOG (\"Trying to spawn gst-plugin-scanner helper at %s\", location);\n-  }\n-\n-  g_spawn_async_with_pipes (NULL, argv, NULL,\n-      G_SPAWN_DO_NOT_REAP_CHILD \/* | G_SPAWN_STDERR_TO_DEV_NULL *\/ ,\n-      NULL, NULL, &loader->child_pid, &loader->fd_w.fd, &loader->fd_r.fd,\n-      NULL, &error);\n-\n-  if (error) {\n-    GST_ERROR (\"Spawning gst-plugin-scanner helper failed: %s\", error->message);\n-    g_clear_error (&error);\n-    return FALSE;\n-  }\n-\n-  gst_poll_add_fd (loader->fdset, &loader->fd_w);\n-  gst_poll_add_fd (loader->fdset, &loader->fd_r);\n-\n-  gst_poll_fd_ctl_read (loader->fdset, &loader->fd_r, TRUE);\n-\n-  loader->tx_buf_write = loader->tx_buf_read = 0;\n-\n-  put_packet (loader, PACKET_VERSION, 0, NULL, 0);\n-  if (!plugin_loader_sync_with_child (loader))\n-    return FALSE;\n-\n-  loader->child_running = TRUE;\n-\n-  return TRUE;\n-}\n-\n-static int\n-count_directories (const char *filepath)\n-{\n-  int i = 0;\n-  char *tmp;\n-  gsize len;\n-\n-  g_return_val_if_fail (!g_path_is_absolute (filepath), 0);\n-\n-  tmp = g_strdup (filepath);\n-  len = strlen (tmp);\n-\n-#if defined(G_OS_WIN32)\n-  \/* ignore UNC share paths entirely *\/\n-  if (len >= 3 && G_IS_DIR_SEPARATOR (tmp[0]) && G_IS_DIR_SEPARATOR (tmp[1])\n-      && !G_IS_DIR_SEPARATOR (tmp[2])) {\n-    GST_WARNING (\"found a UNC share path, ignoring\");\n-    return 0;\n-  }\n-#endif\n-\n-  \/* remove trailing slashes if they exist *\/\n-  while (\n-#if defined(G_OS_WIN32)\n-      \/* don't remove the trailing slash for C:\\.\n-       * UNC paths are at least \\\\s\\s *\/\n-      len > 3\n-#else\n-      \/* don't remove the trailing slash for \/ *\/\n-      len > 1\n-#endif\n-      && G_IS_DIR_SEPARATOR (tmp[len - 1])) {\n-    tmp[len - 1] = '\\0';\n-    len--;\n-  }\n-\n-  while (tmp) {\n-    char *dirname, *basename;\n-    len = strlen (tmp);\n-\n-    if (g_strcmp0 (tmp, \".\") == 0)\n-      break;\n-    if (g_strcmp0 (tmp, \"\/\") == 0)\n-      break;\n-#if defined(G_OS_WIN32)\n-    \/* g_path_get_dirname() may return something of the form 'C:.', where C is\n-     * a drive letter *\/\n-    if (len == 3 && g_ascii_isalpha (tmp[0]) && tmp[1] == ':' && tmp[2] == '.')\n-      break;\n-#endif\n-\n-    basename = g_path_get_basename (tmp);\n-    dirname = g_path_get_dirname (tmp);\n-\n-    if (g_strcmp0 (basename, \"..\") == 0) {\n-      i--;\n-    } else if (g_strcmp0 (basename, \".\") == 0) {\n-      \/* nothing to do *\/\n-    } else {\n-      i++;\n-    }\n-\n-    g_clear_pointer (&basename, g_free);\n-    g_clear_pointer (&tmp, g_free);\n-    tmp = dirname;\n-  }\n-\n-  g_clear_pointer (&tmp, g_free);\n-\n-  if (i < 0) {\n-    g_critical (\"path counting resulted in a negative directory count!\");\n-    return 0;\n-  }\n-\n-  return i;\n-}\n-\n-static gboolean\n-gst_plugin_loader_spawn (GstPluginLoader * loader)\n-{\n-#ifdef GSTREAMER_LITE\n-  return FALSE;\n-#else \/\/ GSTREAMER_LITE\n-  const gchar *env;\n-  char *helper_bin;\n-  gboolean res = FALSE;\n-\n-  if (loader->child_running)\n-    return TRUE;\n-\n-  \/* Find the gst-plugin-scanner *\/\n-  env = g_getenv (\"GST_PLUGIN_SCANNER_1_0\");\n-  if (env == NULL)\n-    env = g_getenv (\"GST_PLUGIN_SCANNER\");\n-\n-  if (env != NULL && *env != '\\0') {\n-    \/* use the env-var if it is set *\/\n-    GST_LOG (\"Trying GST_PLUGIN_SCANNER env var: %s\", env);\n-    helper_bin = g_strdup (env);\n-    res = gst_plugin_loader_try_helper (loader, helper_bin);\n-    g_free (helper_bin);\n-  } else {\n-    char *relocated_libgstreamer;\n-\n-    \/* use the installed version *\/\n-    GST_LOG (\"Trying installed plugin scanner\");\n-\n-#ifdef G_OS_WIN32\n-#define EXESUFFIX \".exe\"\n-#else\n-#define EXESUFFIX\n-#endif\n-\n-#define MAX_PATH_DEPTH 64\n-\n-    relocated_libgstreamer = priv_gst_get_relocated_libgstreamer ();\n-    if (relocated_libgstreamer) {\n-      int plugin_subdir_depth = count_directories (GST_PLUGIN_SUBDIR);\n-\n-      GST_DEBUG (\"found libgstreamer-\" GST_API_VERSION \" library \"\n-          \"at %s\", relocated_libgstreamer);\n-\n-      if (plugin_subdir_depth < MAX_PATH_DEPTH) {\n-        const char *filenamev[MAX_PATH_DEPTH + 5];\n-        int i = 0, j;\n-\n-        filenamev[i++] = relocated_libgstreamer;\n-        for (j = 0; j < plugin_subdir_depth; j++)\n-          filenamev[i++] = \"..\";\n-        filenamev[i++] = GST_PLUGIN_SCANNER_SUBDIR;\n-        filenamev[i++] = \"gstreamer-\" GST_API_VERSION;\n-        filenamev[i++] = \"gst-plugin-scanner\" EXESUFFIX;\n-        filenamev[i++] = NULL;\n-        g_assert (i <= MAX_PATH_DEPTH + 5);\n-\n-        GST_DEBUG (\"constructing path to system plugin scanner using \"\n-            \"plugin dir: \\'%s\\', plugin scanner dir: \\'%s\\'\",\n-            GST_PLUGIN_SUBDIR, GST_PLUGIN_SCANNER_SUBDIR);\n-\n-        helper_bin = g_build_filenamev ((char **) filenamev);\n-      } else {\n-        GST_WARNING (\"GST_PLUGIN_SUBDIR: \\'%s\\' has too many path segments\",\n-            GST_PLUGIN_SUBDIR);\n-        helper_bin = g_strdup (GST_PLUGIN_SCANNER_INSTALLED);\n-      }\n-    } else {\n-      helper_bin = g_strdup (GST_PLUGIN_SCANNER_INSTALLED);\n-    }\n-\n-    GST_DEBUG (\"using system plugin scanner at %s\", helper_bin);\n-\n-    res = gst_plugin_loader_try_helper (loader, helper_bin);\n-    g_free (helper_bin);\n-    g_free (relocated_libgstreamer);\n-  }\n-\n-  if (!res) {\n-    GST_INFO (\"No gst-plugin-scanner available, or not working\");\n-  }\n-\n-  return loader->child_running;\n-#endif \/\/ GSTREAMER_LITE\n-}\n-\n-static void\n-plugin_loader_cleanup_child (GstPluginLoader * l)\n-{\n-  if (!l->child_running || l->is_child)\n-    return;\n-\n-  gst_poll_remove_fd (l->fdset, &l->fd_w);\n-  gst_poll_remove_fd (l->fdset, &l->fd_r);\n-\n-  close (l->fd_w.fd);\n-  close (l->fd_r.fd);\n-\n-#ifndef G_OS_WIN32\n-  GST_LOG (\"waiting for child process to exit\");\n-  waitpid (l->child_pid, NULL, 0);\n-#else\n-  g_warning (\"FIXME: Implement child process shutdown for Win32\");\n-#endif\n-  g_spawn_close_pid (l->child_pid);\n-\n-  l->child_running = FALSE;\n-}\n-\n-gboolean\n-_gst_plugin_loader_client_run (void)\n-{\n-  gboolean res = TRUE;\n-  GstPluginLoader *l;\n-\n-  l = plugin_loader_new (NULL);\n-  if (l == NULL)\n-    return FALSE;\n-\n-  \/* On entry, the inward pipe is STDIN, and outward is STDOUT.\n-   * Dup those somewhere better so that plugins printing things\n-   * won't interfere with anything *\/\n-#ifndef G_OS_WIN32\n-  {\n-    int dup_fd;\n-\n-    dup_fd = dup (0);           \/* STDIN *\/\n-    if (dup_fd == -1) {\n-      GST_ERROR (\"Failed to start. Could not dup STDIN, errno %d\", errno);\n-      res = FALSE;\n-      goto beach;\n-    }\n-    l->fd_r.fd = dup_fd;\n-    close (0);\n-\n-    dup_fd = dup (1);           \/* STDOUT *\/\n-    if (dup_fd == -1) {\n-      GST_ERROR (\"Failed to start. Could not dup STDOUT, errno %d\", errno);\n-      res = FALSE;\n-      goto beach;\n-    }\n-    l->fd_w.fd = dup_fd;\n-    close (1);\n-\n-    \/* Dup stderr down to stdout so things that plugins print are visible,\n-     * but don't care if it fails *\/\n-    dup2 (2, 1);\n-  }\n-#else\n-  \/* FIXME: Use DuplicateHandle and friends on win32 *\/\n-  l->fd_w.fd = 1;               \/* STDOUT *\/\n-  l->fd_r.fd = 0;               \/* STDIN *\/\n-#endif\n-\n-  gst_poll_add_fd (l->fdset, &l->fd_w);\n-  gst_poll_add_fd (l->fdset, &l->fd_r);\n-  gst_poll_fd_ctl_read (l->fdset, &l->fd_r, TRUE);\n-\n-  l->is_child = TRUE;\n-\n-  GST_DEBUG (\"Plugin scanner child running. Waiting for instructions\");\n-\n-  \/* Loop, listening for incoming packets on the fd and writing responses *\/\n-  while (!l->rx_done && exchange_packets (l));\n-\n-#ifndef G_OS_WIN32\n-beach:\n-#endif\n-\n-  plugin_loader_free (l);\n-\n-  return res;\n-}\n-\n-static void\n-put_packet (GstPluginLoader * l, guint type, guint32 tag,\n-    const guint8 * payload, guint32 payload_len)\n-{\n-  guint8 *out;\n-  guint len = payload_len + HEADER_SIZE;\n-\n-  if (l->tx_buf_write + len >= l->tx_buf_size) {\n-    GST_LOG (\"Expanding tx buf from %d to %d for packet of size %d\",\n-        l->tx_buf_size, l->tx_buf_write + len + BUF_GROW_EXTRA, len);\n-    l->tx_buf_size = l->tx_buf_write + len + BUF_GROW_EXTRA;\n-    l->tx_buf = g_realloc (l->tx_buf, l->tx_buf_size);\n-  }\n-\n-  out = l->tx_buf + l->tx_buf_write;\n-\n-  \/* one byte packet type *\/\n-  out[0] = type;\n-  \/* 3 byte packet tag number *\/\n-  GST_WRITE_UINT24_BE (out + 1, tag);\n-  \/* 4 bytes packet length *\/\n-  GST_WRITE_UINT32_BE (out + 4, payload_len);\n-  \/* payload *\/\n-  if (payload && payload_len)\n-    memcpy (out + HEADER_SIZE, payload, payload_len);\n-  \/* Write magic into the header *\/\n-  GST_WRITE_UINT32_BE (out + 8, HEADER_MAGIC);\n-\n-  l->tx_buf_write += len;\n-  gst_poll_fd_ctl_write (l->fdset, &l->fd_w, TRUE);\n-}\n-\n-static void\n-put_chunk (GstPluginLoader * l, GstRegistryChunk * chunk, guint * pos)\n-{\n-  guint padsize = 0;\n-  guint len;\n-  guint8 *out;\n-\n-  \/* Might need to align the chunk *\/\n-  if (chunk->align && ((*pos) % ALIGNMENT) != 0)\n-    padsize = ALIGNMENT - ((*pos) % ALIGNMENT);\n-\n-  len = padsize + chunk->size;\n-\n-  if (G_UNLIKELY (l->tx_buf_write + len >= l->tx_buf_size)) {\n-    guint new_size = MAX (l->tx_buf_write + len,\n-        l->tx_buf_size + l->tx_buf_size \/ 4) + BUF_GROW_EXTRA;\n-    GST_LOG (\"Expanding tx buf from %d to %d for chunk of size %d\",\n-        l->tx_buf_size, new_size, chunk->size);\n-    l->tx_buf_size = new_size;\n-    l->tx_buf = g_realloc (l->tx_buf, l->tx_buf_size);\n-  }\n-\n-  out = l->tx_buf + l->tx_buf_write;\n-  \/* Clear the padding *\/\n-  if (padsize)\n-    memset (out, 0, padsize);\n-  memcpy (out + padsize, chunk->data, chunk->size);\n-\n-  l->tx_buf_write += len;\n-  *pos += len;\n-\n-  gst_poll_fd_ctl_write (l->fdset, &l->fd_w, TRUE);\n-};\n-\n-static gboolean\n-write_one (GstPluginLoader * l)\n-{\n-  guint8 *out;\n-  guint32 to_write, magic;\n-  int res;\n-\n-  if (l->tx_buf_read + HEADER_SIZE > l->tx_buf_write)\n-    return FALSE;\n-\n-  out = l->tx_buf + l->tx_buf_read;\n-\n-  magic = GST_READ_UINT32_BE (out + 8);\n-  if (magic != HEADER_MAGIC) {\n-    GST_ERROR (\"Packet magic number is missing. Memory corruption detected\");\n-    goto fail_and_cleanup;\n-  }\n-\n-  to_write = GST_READ_UINT32_BE (out + 4) + HEADER_SIZE;\n-  \/* Check that the magic is intact, and the size is sensible *\/\n-  if (to_write > l->tx_buf_size) {\n-    GST_ERROR (\"Indicated packet size is too large. Corruption detected\");\n-    goto fail_and_cleanup;\n-  }\n-\n-  l->tx_buf_read += to_write;\n-\n-  GST_LOG (\"Writing packet of size %d bytes to fd %d\", to_write, l->fd_w.fd);\n-\n-  do {\n-    res = write (l->fd_w.fd, out, to_write);\n-    if (G_UNLIKELY (res < 0)) {\n-      if (errno == EAGAIN || errno == EINTR)\n-        continue;\n-      \/* Failed to write -> child died *\/\n-      goto fail_and_cleanup;\n-    } else if (G_UNLIKELY (res == 0)) {\n-      \/* FD closed -> child died *\/\n-      goto fail_and_cleanup;\n-    }\n-    to_write -= res;\n-    out += res;\n-  } while (to_write > 0);\n-\n-  if (l->tx_buf_read == l->tx_buf_write) {\n-    gst_poll_fd_ctl_write (l->fdset, &l->fd_w, FALSE);\n-    l->tx_buf_read = l->tx_buf_write = 0;\n-  }\n-\n-  return TRUE;\n-\n-fail_and_cleanup:\n-  plugin_loader_cleanup_child (l);\n-  return FALSE;\n-}\n-\n-static gboolean\n-do_plugin_load (GstPluginLoader * l, const gchar * filename, guint tag)\n-{\n-  GstPlugin *newplugin;\n-  GList *chunks = NULL;\n-\n-  GST_DEBUG (\"Plugin scanner loading file %s. tag %u\", filename, tag);\n-\n-#if 0                           \/* Test code - crash based on filename *\/\n-  if (strstr (filename, \"coreelements\") == NULL) {\n-    g_printerr (\"Crashing on file %s\\n\", filename);\n-    g_printerr (\"%d\", *(gint *) (NULL));\n-  }\n-#endif\n-\n-  newplugin = gst_plugin_load_file ((gchar *) filename, NULL);\n-  if (newplugin) {\n-    guint hdr_pos;\n-    guint offset;\n-\n-    \/* Now serialise the plugin details and send *\/\n-    if (!_priv_gst_registry_chunks_save_plugin (&chunks,\n-            gst_registry_get (), newplugin))\n-      goto fail;\n-\n-    \/* Store where the header is, write an empty one, then write\n-     * all the payload chunks, then fix up the header size *\/\n-    hdr_pos = l->tx_buf_write;\n-    offset = HEADER_SIZE;\n-    put_packet (l, PACKET_PLUGIN_DETAILS, tag, NULL, 0);\n-\n-    if (chunks) {\n-      GList *walk;\n-      for (walk = chunks; walk; walk = g_list_next (walk)) {\n-        GstRegistryChunk *cur = walk->data;\n-        put_chunk (l, cur, &offset);\n-\n-        _priv_gst_registry_chunk_free (cur);\n-      }\n-\n-      g_list_free (chunks);\n-\n-      \/* Store the size of the written payload *\/\n-      GST_WRITE_UINT32_BE (l->tx_buf + hdr_pos + 4, offset - HEADER_SIZE);\n-    }\n-#if 0                           \/* Test code - corrupt the tx buffer based on filename *\/\n-    if (strstr (filename, \"sink\") != NULL) {\n-      int fd, res;\n-      g_printerr (\"Corrupting tx buf on file %s\\n\", filename);\n-      fd = open (\"\/dev\/urandom\", O_RDONLY);\n-      res = read (fd, l->tx_buf, l->tx_buf_size);\n-      close (fd);\n-    }\n-#endif\n-\n-    gst_object_unref (newplugin);\n-  } else {\n-    put_packet (l, PACKET_PLUGIN_DETAILS, tag, NULL, 0);\n-  }\n-\n-  return TRUE;\n-fail:\n-  put_packet (l, PACKET_PLUGIN_DETAILS, tag, NULL, 0);\n-  if (chunks) {\n-    GList *walk;\n-    for (walk = chunks; walk; walk = g_list_next (walk)) {\n-      GstRegistryChunk *cur = walk->data;\n-\n-      _priv_gst_registry_chunk_free (cur);\n-    }\n-\n-    g_list_free (chunks);\n-  }\n-\n-  return FALSE;\n-}\n-\n-static gboolean\n-check_protocol_version (GstPluginLoader * l, guint8 * payload,\n-    guint payload_len)\n-{\n-  guint32 got_version;\n-  guint8 *binary_reg_ver;\n-\n-  if (payload_len < sizeof (guint32) + GST_MAGIC_BINARY_VERSION_LEN)\n-    return FALSE;\n-\n-  got_version = GST_READ_UINT32_BE (payload);\n-  GST_LOG (\"Got VERSION %u from child. Ours is %u\", got_version,\n-      loader_protocol_version);\n-  if (got_version != loader_protocol_version)\n-    return FALSE;\n-\n-  binary_reg_ver = payload + sizeof (guint32);\n-  if (strcmp ((gchar *) binary_reg_ver, GST_MAGIC_BINARY_VERSION_STR)) {\n-    GST_LOG (\"Binary chunk format of child is different. Ours: %s, child %s\\n\",\n-        GST_MAGIC_BINARY_VERSION_STR, binary_reg_ver);\n-    return FALSE;\n-  }\n-\n-  return TRUE;\n-};\n-\n-static gboolean\n-handle_rx_packet (GstPluginLoader * l,\n-    guint pack_type, guint32 tag, guint8 * payload, guint payload_len)\n-{\n-  gboolean res = TRUE;\n-\n-  switch (pack_type) {\n-    case PACKET_EXIT:\n-      gst_poll_fd_ctl_read (l->fdset, &l->fd_r, FALSE);\n-      if (l->is_child) {\n-        \/* Respond *\/\n-        put_packet (l, PACKET_EXIT, 0, NULL, 0);\n-      }\n-      l->rx_done = TRUE;\n-      return TRUE;\n-    case PACKET_LOAD_PLUGIN:{\n-      if (!l->is_child)\n-        return TRUE;\n-\n-      \/* Payload is the filename to load *\/\n-      res = do_plugin_load (l, (gchar *) payload, tag);\n-\n-      break;\n-    }\n-    case PACKET_PLUGIN_DETAILS:{\n-      gchar *tmp = (gchar *) payload;\n-      PendingPluginEntry *entry = NULL;\n-      GList *cur;\n-\n-      GST_DEBUG_OBJECT (l->registry,\n-          \"Received plugin details from child w\/ tag %u. %d bytes info\",\n-          tag, payload_len);\n-\n-      \/* Assume that tagged details come back in the order\n-       * we requested, and delete anything before (but not\n-       * including) this one *\/\n-      cur = l->pending_plugins;\n-      while (cur) {\n-        PendingPluginEntry *e = (PendingPluginEntry *) (cur->data);\n-\n-        if (e->tag > tag)\n-          break;\n-\n-        if (e->tag == tag) {\n-          entry = e;\n-          break;\n-        } else {\n-          cur = g_list_delete_link (cur, cur);\n-          g_free (e->filename);\n-          g_slice_free (PendingPluginEntry, e);\n-        }\n-      }\n-\n-      l->pending_plugins = cur;\n-      if (cur == NULL)\n-        l->pending_plugins_tail = NULL;\n-\n-      if (payload_len > 0) {\n-        GstPlugin *newplugin = NULL;\n-        if (!_priv_gst_registry_chunks_load_plugin (l->registry, &tmp,\n-                tmp + payload_len, &newplugin)) {\n-          \/* Got garbage from the child, so fail and trigger replay of plugins *\/\n-          GST_ERROR_OBJECT (l->registry,\n-              \"Problems loading plugin details with tag %u from scanner\", tag);\n-          return FALSE;\n-        }\n-\n-        GST_OBJECT_FLAG_UNSET (newplugin, GST_PLUGIN_FLAG_CACHED);\n-        GST_LOG_OBJECT (l->registry,\n-            \"marking plugin %p as registered as %s\", newplugin,\n-            newplugin->filename);\n-        newplugin->registered = TRUE;\n-\n-        \/* We got a set of plugin details - remember it for later *\/\n-        l->got_plugin_details = TRUE;\n-      } else if (entry != NULL) {\n-        \/* Create a blacklist entry for this file to prevent scanning every time *\/\n-        plugin_loader_create_blacklist_plugin (l, entry);\n-        l->got_plugin_details = TRUE;\n-      }\n-\n-      if (entry != NULL) {\n-        g_free (entry->filename);\n-        g_slice_free (PendingPluginEntry, entry);\n-      }\n-\n-      \/* Remove the plugin entry we just loaded *\/\n-      cur = l->pending_plugins;\n-      if (cur != NULL)\n-        cur = g_list_delete_link (cur, cur);\n-      l->pending_plugins = cur;\n-      if (cur == NULL)\n-        l->pending_plugins_tail = NULL;\n-\n-      break;\n-    }\n-    case PACKET_SYNC:\n-      if (l->is_child) {\n-        \/* Respond with our reply - also a sync *\/\n-        put_packet (l, PACKET_SYNC, tag, NULL, 0);\n-        GST_LOG (\"Got SYNC in child - replying\");\n-      } else\n-        l->rx_got_sync = TRUE;\n-      break;\n-    case PACKET_VERSION:\n-      if (l->is_child) {\n-        \/* Respond with our reply - a version packet, with the version *\/\n-        const gint version_len =\n-            sizeof (guint32) + GST_MAGIC_BINARY_VERSION_LEN;\n-        guint8 version_info[sizeof (guint32) + GST_MAGIC_BINARY_VERSION_LEN];\n-        memset (version_info, 0, version_len);\n-        GST_WRITE_UINT32_BE (version_info, loader_protocol_version);\n-        memcpy (version_info + sizeof (guint32), GST_MAGIC_BINARY_VERSION_STR,\n-            strlen (GST_MAGIC_BINARY_VERSION_STR));\n-        put_packet (l, PACKET_VERSION, tag, version_info, version_len);\n-        GST_LOG (\"Got VERSION in child - replying %u\", loader_protocol_version);\n-      } else {\n-        res = check_protocol_version (l, payload, payload_len);\n-      }\n-      break;\n-    default:\n-      return FALSE;             \/* Invalid packet -> something is wrong *\/\n-  }\n-\n-  return res;\n-}\n-\n-static gboolean\n-read_one (GstPluginLoader * l)\n-{\n-  guint64 magic;\n-  guint32 to_read, packet_len, tag;\n-  guint8 *in;\n-  gint res;\n-\n-  to_read = HEADER_SIZE;\n-  in = l->rx_buf;\n-  do {\n-    res = read (l->fd_r.fd, in, to_read);\n-    if (G_UNLIKELY (res < 0)) {\n-      if (errno == EAGAIN || errno == EINTR)\n-        continue;\n-      GST_LOG (\"Failed reading packet header\");\n-      return FALSE;\n-    } else if (G_UNLIKELY (res == 0)) {\n-      GST_LOG (\"Failed reading packet header: Unexpected EOF\");\n-      return FALSE;\n-    }\n-    to_read -= res;\n-    in += res;\n-  } while (to_read > 0);\n-\n-  magic = GST_READ_UINT32_BE (l->rx_buf + 8);\n-  if (magic != HEADER_MAGIC) {\n-    GST_WARNING\n-        (\"Invalid packet (bad magic number) received from plugin scanner subprocess\");\n-    return FALSE;\n-  }\n-\n-  packet_len = GST_READ_UINT32_BE (l->rx_buf + 4);\n-  if (packet_len + HEADER_SIZE > BUF_MAX_SIZE) {\n-    GST_WARNING\n-        (\"Received excessively large packet for plugin scanner subprocess\");\n-    return FALSE;\n-  }\n-  tag = GST_READ_UINT24_BE (l->rx_buf + 1);\n-\n-  if (packet_len > 0) {\n-    if (packet_len + HEADER_SIZE >= l->rx_buf_size) {\n-      GST_LOG (\"Expanding rx buf from %d to %d\",\n-          l->rx_buf_size, packet_len + HEADER_SIZE + BUF_GROW_EXTRA);\n-      l->rx_buf_size = packet_len + HEADER_SIZE + BUF_GROW_EXTRA;\n-      l->rx_buf = g_realloc (l->rx_buf, l->rx_buf_size);\n-    }\n-\n-    in = l->rx_buf + HEADER_SIZE;\n-    to_read = packet_len;\n-    do {\n-      res = read (l->fd_r.fd, in, to_read);\n-      if (G_UNLIKELY (res < 0)) {\n-        if (errno == EAGAIN || errno == EINTR)\n-          continue;\n-        GST_ERROR (\"Packet payload read failed\");\n-        return FALSE;\n-      } else if (G_UNLIKELY (res == 0)) {\n-        GST_ERROR (\"Packet payload read failed: Unexpected EOF\");\n-        return FALSE;\n-      }\n-      to_read -= res;\n-      in += res;\n-    } while (to_read > 0);\n-  } else {\n-    GST_LOG (\"No payload to read for 0 length packet type %d tag %u\",\n-        l->rx_buf[0], tag);\n-  }\n-\n-  return handle_rx_packet (l, l->rx_buf[0], tag,\n-      l->rx_buf + HEADER_SIZE, packet_len);\n-}\n-\n-static gboolean\n-exchange_packets (GstPluginLoader * l)\n-{\n-  gint res;\n-\n-  \/* Wait for activity on our FDs *\/\n-  do {\n-    do {\n-      res = gst_poll_wait (l->fdset, GST_SECOND);\n-    } while (res == -1 && (errno == EINTR || errno == EAGAIN));\n-\n-    if (res < 0)\n-      return FALSE;\n-\n-    GST_LOG (\"Poll res = %d. %d bytes pending for write\", res,\n-        l->tx_buf_write - l->tx_buf_read);\n-\n-    if (!l->rx_done) {\n-      if (gst_poll_fd_has_error (l->fdset, &l->fd_r)) {\n-        GST_LOG (\"read fd %d errored\", l->fd_r.fd);\n-        goto fail_and_cleanup;\n-      }\n-\n-      if (gst_poll_fd_can_read (l->fdset, &l->fd_r)) {\n-        if (!read_one (l))\n-          goto fail_and_cleanup;\n-      } else if (gst_poll_fd_has_closed (l->fdset, &l->fd_r)) {\n-        GST_LOG (\"read fd %d closed\", l->fd_r.fd);\n-        goto fail_and_cleanup;\n-      }\n-    }\n-\n-    if (l->tx_buf_read < l->tx_buf_write) {\n-      if (gst_poll_fd_has_error (l->fdset, &l->fd_w)) {\n-        GST_ERROR (\"write fd %d errored\", l->fd_w.fd);\n-        goto fail_and_cleanup;\n-      }\n-      if (gst_poll_fd_can_write (l->fdset, &l->fd_w)) {\n-        if (!write_one (l))\n-          goto fail_and_cleanup;\n-      } else if (gst_poll_fd_has_closed (l->fdset, &l->fd_w)) {\n-        GST_LOG (\"write fd %d closed\", l->fd_w.fd);\n-        goto fail_and_cleanup;\n-      }\n-    }\n-  } while (l->tx_buf_read < l->tx_buf_write);\n-\n-  return TRUE;\n-fail_and_cleanup:\n-  plugin_loader_cleanup_child (l);\n-  return FALSE;\n-}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpluginloader.c","additions":0,"deletions":1191,"binary":false,"changes":1191,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/* GStreamer\n- * Copyright (C) 2008 Jan Schmidt <jan.schmidt@sun.com>\n- *\n- * gstpluginloader.h: Helper for out-of-process plugin loading. Private header.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n- * Boston, MA 02110-1301, USA.\n- *\/\n-#ifndef __GST_PLUGINLOADER_H__\n-#define __GST_PLUGINLOADER_H__\n-\n-#include <glib.h>\n-#include <gst\/gstregistry.h>\n-\n-G_BEGIN_DECLS\n-\n-typedef struct _GstPluginLoader GstPluginLoader;\n-\n-typedef struct _GstPluginLoaderFuncs {\n-  GstPluginLoader * (*create)   (GstRegistry *registry);\n-  gboolean          (*destroy)  (GstPluginLoader *loader);\n-  gboolean          (*load)     (GstPluginLoader *loader, const gchar *filename,\n-                                 off_t file_size, time_t file_mtime);\n-} GstPluginLoaderFuncs;\n-\n-extern const GstPluginLoaderFuncs _priv_gst_plugin_loader_funcs;\n-\n-G_END_DECLS\n-\n-#endif \/* __GST_PLUGINLOADER_H__ *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpluginloader.h","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -680,1 +680,1 @@\n-  nset = g_slice_new0 (GstPoll);\n+  nset = g_new0 (GstPoll, 1);\n@@ -797,1 +797,1 @@\n-  g_slice_free (GstPoll, set);\n+  g_free (set);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpoll.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,9 @@\n+ * In addition to the #GstProtectionMeta demuxers signal encrypted streams with\n+ * specific caps. The caps #GstStructure name will usually depend on the\n+ * encryption scheme, for instance Common Encryption will be signaled with\n+ * `application\/x-cenc`. To prevent loss of information the media type of the\n+ * decrypted stream will be stored in a `original-media-type` string field.\n+ * Downstream elements can re-use that information, for instance decryptors can\n+ * set their source pad caps according to the `original-media-type` received on\n+ * their sink pad.\n+ *\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstprotection.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  g_slice_free1 (sizeof (GstQueryImpl), query);\n+  g_free (query);\n@@ -678,1 +678,1 @@\n-  query = g_slice_new0 (GstQueryImpl);\n+  query = g_new0 (GstQueryImpl, 1);\n@@ -701,1 +701,1 @@\n-    g_slice_free1 (sizeof (GstQueryImpl), query);\n+    g_free (query);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstquery.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-#endif \/\/ GSTREAMER_LITE\n@@ -116,0 +115,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -1185,0 +1185,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -1186,0 +1187,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -1213,0 +1215,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -1214,0 +1217,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -1220,0 +1224,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -1224,0 +1229,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -1233,6 +1239,1 @@\n-#ifdef G_OS_WIN32\n-  \/* Disable external plugin loader on Windows until it is ported properly. *\/\n-  context->helper_state = REGISTRY_SCAN_HELPER_DISABLED;\n-#endif\n-\n-\n+#ifndef GSTREAMER_LITE\n@@ -1263,0 +1264,3 @@\n+#else \/\/ GSTREAMER_LITE\n+  context->helper_state = REGISTRY_SCAN_HELPER_DISABLED;\n+#endif \/\/ GSTREAMER_LITE\n@@ -1845,0 +1849,2 @@\n+    char *real_fname = NULL;\n+    long path_max = 0;\n@@ -1855,0 +1861,18 @@\n+#ifdef PATH_MAX\n+      path_max = PATH_MAX;\n+#else\n+      path_max = pathconf (info.dli_fname, _PC_PATH_MAX);\n+      if (path_max <= 0)\n+        path_max = 4096;\n+#endif\n+\n+      real_fname = g_malloc (path_max);\n+      if (realpath (info.dli_fname, real_fname)) {\n+        dir = g_path_get_dirname (real_fname);\n+        GST_DEBUG (\"real directory location: %s\", dir);\n+      } else {\n+        GST_ERROR (\"could not canonicalize path %s: %s\", info.dli_fname,\n+            g_strerror (errno));\n+        dir = g_path_get_dirname (info.dli_fname);\n+      }\n+      g_free (real_fname);\n@@ -1856,1 +1880,0 @@\n-      dir = g_path_get_dirname (info.dli_fname);\n@@ -1873,0 +1896,69 @@\n+int\n+priv_gst_count_directories (const char *filepath)\n+{\n+  int i = 0;\n+  char *tmp;\n+  gsize len;\n+\n+  g_return_val_if_fail (!g_path_is_absolute (filepath), 0);\n+\n+  tmp = g_strdup (filepath);\n+  len = strlen (tmp);\n+\n+  \/* ignore UNC share paths entirely *\/\n+  if (len >= 3 && G_IS_DIR_SEPARATOR (tmp[0]) && G_IS_DIR_SEPARATOR (tmp[1])\n+      && !G_IS_DIR_SEPARATOR (tmp[2])) {\n+    GST_WARNING (\"found a UNC share path, ignoring\");\n+    g_clear_pointer (&tmp, g_free);\n+    return 0;\n+  }\n+\n+  \/* remove trailing slashes if they exist *\/\n+  while (\n+      \/* don't remove the trailing slash for C:\\.\n+       * UNC paths are at least \\\\s\\s *\/\n+      len > 3 && G_IS_DIR_SEPARATOR (tmp[len - 1])) {\n+    tmp[len - 1] = '\\0';\n+    len--;\n+  }\n+\n+  while (tmp) {\n+    char *dirname, *basename;\n+    len = strlen (tmp);\n+\n+    if (g_strcmp0 (tmp, \".\") == 0)\n+      break;\n+    if (g_strcmp0 (tmp, \"\/\") == 0)\n+      break;\n+\n+    \/* g_path_get_dirname() may return something of the form 'C:.', where C is\n+     * a drive letter *\/\n+    if (len == 3 && g_ascii_isalpha (tmp[0]) && tmp[1] == ':' && tmp[2] == '.')\n+      break;\n+\n+    basename = g_path_get_basename (tmp);\n+    dirname = g_path_get_dirname (tmp);\n+\n+    if (g_strcmp0 (basename, \"..\") == 0) {\n+      i--;\n+    } else if (g_strcmp0 (basename, \".\") == 0) {\n+      \/* nothing to do *\/\n+    } else {\n+      i++;\n+    }\n+\n+    g_clear_pointer (&basename, g_free);\n+    g_clear_pointer (&tmp, g_free);\n+    tmp = dirname;\n+  }\n+\n+  g_clear_pointer (&tmp, g_free);\n+\n+  if (i < 0) {\n+    g_critical (\"path counting resulted in a negative directory count!\");\n+    return 0;\n+  }\n+\n+  return i;\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstregistry.c","additions":100,"deletions":8,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  BinaryRegistryCache *cache = g_slice_new0 (BinaryRegistryCache);\n+  BinaryRegistryCache *cache = g_new0 (BinaryRegistryCache, 1);\n@@ -162,1 +162,1 @@\n-  g_slice_free (BinaryRegistryCache, cache);\n+  g_free (cache);\n@@ -178,1 +178,1 @@\n-  BinaryRegistryCache *cache = g_slice_new0 (BinaryRegistryCache);\n+  BinaryRegistryCache *cache = g_new0 (BinaryRegistryCache, 1);\n@@ -208,1 +208,1 @@\n-      g_slice_free (BinaryRegistryCache, cache);\n+      g_free (cache);\n@@ -223,1 +223,1 @@\n-    g_slice_free (BinaryRegistryCache, cache);\n+    g_free (cache);\n@@ -315,1 +315,1 @@\n-  g_slice_free (BinaryRegistryCache, cache);\n+  g_free (cache);\n@@ -329,1 +329,1 @@\n-    g_slice_free (BinaryRegistryCache, cache);\n+    g_free (cache);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstregistrybinary.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-#define GST_MAGIC_BINARY_VERSION_STR \"1.3.0\"\n+#define GST_MAGIC_BINARY_VERSION_STR \"1.23.90\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstregistrybinary.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,4 +121,1 @@\n-    if ((chunk->flags & GST_REGISTRY_CHUNK_FLAG_MALLOC))\n-      g_free (chunk->data);\n-    else\n-      g_slice_free1 (chunk->size, chunk->data);\n+    g_free (chunk->data);\n@@ -126,1 +123,1 @@\n-  g_slice_free (GstRegistryChunk, chunk);\n+  g_free (chunk);\n@@ -146,1 +143,1 @@\n-  chunk = g_slice_new (GstRegistryChunk);\n+  chunk = g_new (GstRegistryChunk, 1);\n@@ -167,1 +164,1 @@\n-  chunk = g_slice_new (GstRegistryChunk);\n+  chunk = g_new (GstRegistryChunk, 1);\n@@ -170,1 +167,1 @@\n-  chunk->flags = GST_REGISTRY_CHUNK_FLAG_MALLOC;\n+  chunk->flags = GST_REGISTRY_CHUNK_FLAG_NONE;\n@@ -188,1 +185,1 @@\n-  chunk = g_slice_new (GstRegistryChunk);\n+  chunk = g_new (GstRegistryChunk, 1);\n@@ -211,1 +208,1 @@\n-  pt = g_slice_new (GstRegistryChunkPadTemplate);\n+  pt = g_new (GstRegistryChunkPadTemplate, 1);\n@@ -256,1 +253,1 @@\n-    ef = g_slice_new0 (GstRegistryChunkElementFactory);\n+    ef = g_new0 (GstRegistryChunkElementFactory, 1);\n@@ -316,1 +313,1 @@\n-    tff = g_slice_new0 (GstRegistryChunkTypeFindFactory);\n+    tff = g_new0 (GstRegistryChunkTypeFindFactory, 1);\n@@ -351,1 +348,1 @@\n-    tff = g_slice_new0 (GstRegistryChunkDeviceProviderFactory);\n+    tff = g_new0 (GstRegistryChunkDeviceProviderFactory, 1);\n@@ -366,1 +363,1 @@\n-    pf = g_slice_new0 (GstRegistryChunkPluginFeature);\n+    pf = g_new0 (GstRegistryChunkPluginFeature, 1);\n@@ -372,1 +369,1 @@\n-    tmp = g_slice_new0 (GstRegistryChunkDynamicTypeFactory);\n+    tmp = g_new0 (GstRegistryChunkDynamicTypeFactory, 1);\n@@ -394,2 +391,2 @@\n-  g_slice_free (GstRegistryChunk, chk);\n-  g_slice_free1 (pf_size, pf);\n+  g_free (chk);\n+  g_free (pf);\n@@ -406,1 +403,1 @@\n-  ed = g_slice_new (GstRegistryChunkDep);\n+  ed = g_new (GstRegistryChunkDep, 1);\n@@ -448,1 +445,1 @@\n-  pe = g_slice_new (GstRegistryChunkPluginElement);\n+  pe = g_new (GstRegistryChunkPluginElement, 1);\n@@ -488,0 +485,8 @@\n+  \/* pack status info *\/\n+  if (plugin->priv->status_info) {\n+    gchar *status_str = gst_structure_to_string (plugin->priv->status_info);\n+    gst_registry_chunks_save_string (list, status_str);\n+  } else {\n+    gst_registry_chunks_save_const_string (list, \"\");\n+  }\n+\n@@ -509,2 +514,2 @@\n-  g_slice_free (GstRegistryChunk, chk);\n-  g_slice_free (GstRegistryChunkPluginElement, pe);\n+  g_free (chk);\n+  g_free (pe);\n@@ -534,1 +539,1 @@\n-  template = g_slice_new (GstStaticPadTemplate);\n+  template = g_new (GstStaticPadTemplate, 1);\n@@ -550,1 +555,1 @@\n-    g_slice_free (GstStaticPadTemplate, template);\n+    g_free (template);\n@@ -793,1 +798,1 @@\n-  dep = g_slice_new (GstPluginDep);\n+  dep = g_new (GstPluginDep, 1);\n@@ -838,0 +843,1 @@\n+  const gchar *status_str = NULL;\n@@ -878,0 +884,5 @@\n+  \/* unpack status info *\/\n+  unpack_string_nocopy (*in, status_str, end, fail);\n+  if (status_str != NULL && *status_str != '\\0')\n+    plugin->priv->status_info = gst_structure_from_string (status_str, NULL);\n+\n@@ -935,1 +946,1 @@\n-  hdr = g_slice_new (GstRegistryChunkGlobalHeader);\n+  hdr = g_new (GstRegistryChunkGlobalHeader, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstregistrychunks.c","additions":36,"deletions":25,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * avoid freeing them. If g_free() should be used, the MALLOC flag is set,\n- * otherwise g_slice_free1() will be used!\n+ * avoid freeing them.\n@@ -37,1 +36,0 @@\n-  GST_REGISTRY_CHUNK_FLAG_MALLOC = 2,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstregistrychunks.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  g_slice_free1 (sizeof (GstSample), sample);\n+  g_free (sample);\n@@ -132,1 +132,1 @@\n-  sample = g_slice_new0 (GstSample);\n+  sample = g_new0 (GstSample, 1);\n@@ -466,1 +466,1 @@\n- * @buf: a #GstSample.\n+ * @sample: a #GstSample.\n@@ -471,1 +471,1 @@\n- * Returns: (transfer full): a new copy of @buf.\n+ * Returns: (transfer full): a new copy of @sample.\n@@ -476,1 +476,1 @@\n-gst_sample_copy (const GstSample * buf)\n+gst_sample_copy (const GstSample * sample)\n@@ -479,1 +479,21 @@\n-      GST_SAMPLE_CAST (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (buf)));\n+      GST_SAMPLE_CAST (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST\n+          (sample)));\n+}\n+\n+\/**\n+ * gst_clear_sample: (skip)\n+ * @sample_ptr: a pointer to a #GstSample reference\n+ *\n+ * Clears a reference to a #GstSample\n+ *\n+ * @sample_ptr must not be %NULL.\n+ *\n+ * If the reference is %NULL then this function does nothing. Otherwise, the\n+ * reference count of the sample is decreased and the pointer is set to %NULL.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_clear_sample (GstSample ** sample_ptr)\n+{\n+  gst_clear_mini_object ((GstMiniObject **) sample_ptr);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstsample.c","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-gst_sample_copy (const GstSample * buf)\n+gst_sample_copy (const GstSample * sample)\n@@ -159,1 +159,7 @@\n-  return GST_SAMPLE_CAST (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (buf)));\n+  return GST_SAMPLE_CAST (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (sample)));\n+}\n+\n+static inline void\n+gst_clear_sample (GstSample ** sample_ptr)\n+{\n+  gst_clear_mini_object ((GstMiniObject **) sample_ptr);\n@@ -163,1 +169,4 @@\n-GstSample *   gst_sample_copy(const GstSample * buf);\n+GstSample *   gst_sample_copy (const GstSample * sample);\n+\n+GST_API\n+void          gst_clear_sample (GstSample ** sample_ptr);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstsample.h","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+#include \"glib-compat-private.h\"\n@@ -106,1 +107,1 @@\n-    result = (GstSegment *) g_slice_copy (sizeof (GstSegment), segment);\n+    result = (GstSegment *) g_memdup2 (segment, sizeof (GstSegment));\n@@ -142,1 +143,1 @@\n-  result = g_slice_new0 (GstSegment);\n+  result = g_new0 (GstSegment, 1);\n@@ -157,1 +158,1 @@\n-  g_slice_free (GstSegment, segment);\n+  g_free (segment);\n@@ -777,2 +778,2 @@\n-    g_return_val_if_fail (stop != -1, 0);\n-    g_return_val_if_fail (stop >= offset, 0);\n+    if (stop == -1 || stop < offset)\n+      return 0;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstsegment.c","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-   * GstStream:upstream-id:\n+   * GstStreamCollection:upstream-id:\n@@ -111,1 +111,1 @@\n-   * GstStream::stream-notify:\n+   * GstStreamCollection::stream-notify:\n@@ -192,0 +192,1 @@\n+  GST_OBJECT_LOCK (collection);\n@@ -199,0 +200,9 @@\n+\n+  \/* We hold the object lock, replace directly *\/\n+  g_free (GST_OBJECT_NAME (collection));\n+  if (upstream_id)\n+    GST_OBJECT_NAME (collection) = g_strdup (upstream_id);\n+  else\n+    GST_OBJECT_NAME (collection) = g_strdup (\"unparented\");\n+\n+  GST_OBJECT_UNLOCK (collection);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gststreamcollection.c","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n- * > compatibility reason, gst_structure_serialize() has been added for\n+ * > compatibility reason, gst_structure_serialize_full() has been added for\n@@ -2038,0 +2038,1 @@\n+  gboolean strict = (flags & GST_SERIALIZE_FLAG_STRICT) != 0;\n@@ -2074,1 +2075,2 @@\n-      priv_gst_structure_append_to_gstring (substruct, s, flags);\n+      if (!priv_gst_structure_append_to_gstring (substruct, s, flags))\n+        return FALSE;\n@@ -2086,0 +2088,2 @@\n+      if (strict && G_VALUE_HOLDS_OBJECT (&field->value))\n+        return FALSE;\n@@ -2089,0 +2093,2 @@\n+      if (strict)\n+        return FALSE;\n@@ -2098,0 +2104,2 @@\n+      if (strict)\n+        return FALSE;\n@@ -2173,1 +2181,4 @@\n-  priv_gst_structure_append_to_gstring (structure, s, flags);\n+  if (!priv_gst_structure_append_to_gstring (structure, s, flags)) {\n+    g_string_free (s, TRUE);\n+    return NULL;\n+  }\n@@ -2191,1 +2202,1 @@\n- * gst_structure_serialize() instead for those cases.\n+ * gst_structure_serialize_full() instead for those cases.\n@@ -2216,0 +2227,4 @@\n+ * %GST_SERIALIZE_FLAG_STRICT flags is not allowed because it would make this\n+ * function nullable which is an API break for bindings.\n+ * Use gst_structure_serialize_full() instead.\n+ *\n@@ -2222,0 +2237,1 @@\n+ * Deprecated: Use gst_structure_serialize_full() instead.\n@@ -2226,0 +2242,21 @@\n+{\n+  g_return_val_if_fail ((flags & GST_SERIALIZE_FLAG_STRICT) == 0, NULL);\n+  return structure_serialize (structure, flags);\n+}\n+\n+\/**\n+ * gst_structure_serialize_full:\n+ * @structure: a #GstStructure\n+ * @flags: The flags to use to serialize structure\n+ *\n+ * Alias for gst_structure_serialize() but with nullable annotation because it\n+ * can return %NULL when %GST_SERIALIZE_FLAG_STRICT flag is set.\n+ *\n+ * Returns: (transfer full) (nullable): a pointer to string allocated by g_malloc().\n+ *     g_free() after usage.\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar *\n+gst_structure_serialize_full (const GstStructure * structure,\n+    GstSerializeFlags flags)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gststructure.c","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -39,0 +39,9 @@\n+\/**\n+ * GST_SERIALIZE_FLAG_STRICT:\n+ *\n+ * Serialization fails if a value cannot be serialized instead of using\n+ * placeholder \"NULL\" value (e.g. pointers, objects).\n+ *\n+ * Since: 1.24\n+ *\/\n+\n@@ -44,0 +53,3 @@\n+ * @GST_SERIALIZE_FLAG_STRICT: Serialization fails if a value cannot be\n+ *  serialized instead of using placeholder \"NULL\" value (e.g. pointers,\n+ *  objects). (Since 1.24)\n@@ -51,0 +63,1 @@\n+  GST_SERIALIZE_FLAG_STRICT = (1 << 1),\n@@ -358,1 +371,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_structure_serialize_full)\n@@ -361,0 +374,3 @@\n+GST_API\n+gchar *               gst_structure_serialize_full       (const GstStructure * structure,\n+                                                          GstSerializeFlags flags) G_GNUC_MALLOC;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gststructure.h","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -69,0 +69,123 @@\n+#if defined __APPLE__\n+static struct mach_timebase_info mach_timebase;\n+#endif\n+\n+#if defined G_OS_WIN32\n+static LARGE_INTEGER performance_counter_frequency;\n+#endif\n+\n+\/* Small helper to make the atomics below cheaper.\n+ *\n+ * GLib always uses SEQ_CST atomic ops while here it's more than enough to use\n+ * ACQUIRE\/RELEASE atomic ops. On x86 \/ x86-64 the ACQUIRE load is compiling\n+ * to a simple memory read.\n+ *\/\n+#if defined __APPLE__ || defined G_OS_WIN32\n+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_ATOMICS__)\n+#include <stdatomic.h>\n+\n+typedef atomic_int gst_atomic_int;\n+\n+static inline int\n+gst_atomic_int_get_acquire (gst_atomic_int * x)\n+{\n+  return atomic_load_explicit (x, memory_order_acquire);\n+}\n+\n+static inline void\n+gst_atomic_int_set_release (gst_atomic_int * x, gint val)\n+{\n+  atomic_store_explicit (x, val, memory_order_release);\n+}\n+#elif defined G_OS_WIN32\n+\/* MSVC's C11 atomic might require special cflags\n+ * https:\/\/devblogs.microsoft.com\/cppblog\/c11-atomics-in-visual-studio-2022-version-17-5-preview-2\/\n+ *\n+ * Can remove this code once below GLib MR is merged\n+ * https:\/\/gitlab.gnome.org\/GNOME\/glib\/-\/merge_requests\/3436\n+ *\/\n+\n+typedef LONG gst_atomic_int;\n+\n+static inline int\n+gst_atomic_int_get_acquire (gst_atomic_int * x)\n+{\n+  return InterlockedAndAcquire (x, 1);\n+}\n+\n+static inline void\n+gst_atomic_int_set_release (gst_atomic_int * x, gint val)\n+{\n+  InterlockedOrRelease (x, 1);\n+}\n+#else \/* defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_ATOMICS__) *\/\n+typedef int gst_atomic_int;\n+#define gst_atomic_int_get_acquire(x) g_atomic_int_get(x)\n+#define gst_atomic_int_set_release(x, val) g_atomic_int_set(x, val)\n+#endif \/* defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_ATOMICS__) *\/\n+#endif \/* defined __APPLE__ || defined G_OS_WIN32 *\/\n+\n+\/* priv_gst_clock_init:\n+ *\n+ * Initialize internal state of the clock. This is safe to call multiple\n+ * times.\n+ *\/\n+void\n+priv_gst_clock_init (void)\n+{\n+#if defined __APPLE__\n+  static gst_atomic_int inited = FALSE;\n+\n+  if (!gst_atomic_int_get_acquire (&inited)) {\n+    mach_timebase_info (&mach_timebase);\n+    gst_atomic_int_set_release (&inited, TRUE);\n+  }\n+#endif\n+\n+#if defined G_OS_WIN32\n+  static gst_atomic_int inited = FALSE;\n+\n+  if (!gst_atomic_int_get_acquire (&inited)) {\n+    QueryPerformanceFrequency (&performance_counter_frequency);\n+    gst_atomic_int_set_release (&inited, TRUE);\n+  }\n+#endif\n+}\n+\n+GstClockTime\n+priv_gst_get_monotonic_time (void)\n+{\n+#if defined __APPLE__\n+  guint64 mach_t = mach_absolute_time ();\n+  return gst_util_uint64_scale (mach_t, mach_timebase.numer,\n+      mach_timebase.denom);\n+#elif defined G_OS_WIN32\n+  LARGE_INTEGER now;\n+  QueryPerformanceCounter (&now);\n+\n+  return gst_util_uint64_scale (now.QuadPart, GST_SECOND,\n+      performance_counter_frequency.QuadPart);\n+#elif defined (HAVE_POSIX_TIMERS) && defined(HAVE_MONOTONIC_CLOCK) &&\\\n+    defined (HAVE_CLOCK_GETTIME)\n+  struct timespec now;\n+\n+  clock_gettime (CLOCK_MONOTONIC, &now);\n+  return GST_TIMESPEC_TO_TIME (now);\n+#else\n+  return g_get_monotonic_time () * 1000;\n+#endif\n+}\n+\n+GstClockTime\n+priv_gst_get_real_time (void)\n+{\n+#if defined (HAVE_POSIX_TIMERS) && defined (HAVE_CLOCK_GETTIME)\n+  struct timespec now;\n+\n+  clock_gettime (CLOCK_REALTIME, &now);\n+  return GST_TIMESPEC_TO_TIME (now);\n+#else\n+  return g_get_real_time () * 1000;\n+#endif\n+}\n+\n@@ -136,1 +259,4 @@\n-#if defined(__NR_futex_time64)\n+#if defined(HAVE_FUTEX_TIME64)\n+#if defined(__BIONIC__)\n+  if (__builtin_available (android 30, *)) {\n+#else\n@@ -138,0 +264,1 @@\n+#endif\n@@ -146,1 +273,1 @@\n-#ifdef __NR_futex\n+#if defined(HAVE_FUTEX)\n@@ -156,1 +283,1 @@\n-#if defined(__NR_futex)\n+#if defined(HAVE_FUTEX)\n@@ -194,1 +321,4 @@\n-#ifdef __NR_futex_time64\n+#if defined(HAVE_FUTEX_TIME64)\n+#if defined(__BIONIC__)\n+  if (__builtin_available (android 30, *)) {\n+#else\n@@ -196,0 +326,1 @@\n+#endif\n@@ -215,1 +346,1 @@\n-#ifdef __NR_futex\n+#if defined(HAVE_FUTEX)\n@@ -228,1 +359,1 @@\n-#ifdef __NR_futex\n+#if defined(HAVE_FUTEX)\n@@ -309,1 +440,1 @@\n-    gint64 now = g_get_monotonic_time () * 1000;\n+    gint64 now = priv_gst_get_monotonic_time ();\n@@ -455,7 +586,0 @@\n-\n-#ifdef G_OS_WIN32\n-  LARGE_INTEGER frequency;\n-#endif                          \/* G_OS_WIN32 *\/\n-#ifdef __APPLE__\n-  struct mach_timebase_info mach_timebase;\n-#endif\n@@ -492,4 +616,0 @@\n-#if !defined HAVE_POSIX_TIMERS || !defined HAVE_CLOCK_GETTIME\n-static GstClockTime gst_system_clock_get_mono_time (GstSystemClock * clock);\n-static GstClockTime gst_system_clock_get_real_time ();\n-#endif\n@@ -560,8 +680,0 @@\n-#ifdef G_OS_WIN32\n-  QueryPerformanceFrequency (&priv->frequency);\n-#endif \/* G_OS_WIN32 *\/\n-\n-#ifdef __APPLE__\n-  mach_timebase_info (&priv->mach_timebase);\n-#endif\n-\n@@ -918,1 +1030,0 @@\n-  else\n@@ -936,0 +1047,10 @@\n+\n+  \/* For the monotonic and realtime clock, always directly call the specific\n+   * helper functions above *\/\n+  if (sysclock->priv->clock_type == GST_CLOCK_TYPE_MONOTONIC)\n+    return priv_gst_get_monotonic_time ();\n+  else if (sysclock->priv->clock_type == GST_CLOCK_TYPE_REALTIME)\n+    return priv_gst_get_real_time ();\n+\n+  \/* If POSIX timers are available, use those for any other clock,\n+   * or otherwise return the monotonic time *\/\n@@ -948,6 +1069,2 @@\n-#else\n-  if (sysclock->priv->clock_type == GST_CLOCK_TYPE_REALTIME) {\n-    return gst_system_clock_get_real_time ();\n-  } else {\n-    return gst_system_clock_get_mono_time (sysclock);\n-  }\n+#else \/* !HAVE_POSIX_TIMERS || !HAVE_CLOCK_GETTIME *\/\n+  return priv_gst_get_monotonic_time ();\n@@ -957,39 +1074,0 @@\n-#if !defined HAVE_POSIX_TIMERS || !defined HAVE_CLOCK_GETTIME\n-static GstClockTime\n-gst_system_clock_get_real_time ()\n-{\n-  gint64 rt_micros = g_get_real_time ();\n-  \/\/ g_get_real_time returns microseconds but we need nanos, so we'll multiply by 1000\n-  return ((guint64) rt_micros) * 1000;\n-}\n-\n-static GstClockTime\n-gst_system_clock_get_mono_time (GstSystemClock * sysclock)\n-{\n-#if defined __APPLE__\n-  uint64_t mach_t = mach_absolute_time ();\n-  return gst_util_uint64_scale (mach_t, sysclock->priv->mach_timebase.numer,\n-      sysclock->priv->mach_timebase.denom);\n-#else\n-#if defined G_OS_WIN32\n-  if (sysclock->priv->frequency.QuadPart != 0) {\n-    LARGE_INTEGER now;\n-\n-    \/* we prefer the highly accurate performance counters on windows *\/\n-    QueryPerformanceCounter (&now);\n-\n-    return gst_util_uint64_scale (now.QuadPart,\n-        GST_SECOND, sysclock->priv->frequency.QuadPart);\n-  } else\n-#endif \/* G_OS_WIN32 *\/\n-  {\n-    gint64 monotime;\n-\n-    monotime = g_get_monotonic_time ();\n-\n-    return monotime * 1000;\n-  }\n-#endif \/* __APPLE__ *\/\n-}\n-#endif \/* !HAVE_POSIX_TIMERS || !HAVE_CLOCK_GETTIME *\/\n-\n@@ -1000,1 +1078,2 @@\n-#if defined __APPLE__ || defined G_OS_WIN32\n+\n+#if defined G_OS_WIN32\n@@ -1003,1 +1082,3 @@\n-  } else\n+  } else {\n+    return GST_SECOND \/ performance_counter_frequency.QuadPart;\n+  }\n@@ -1005,0 +1086,1 @@\n+\n@@ -1006,1 +1088,4 @@\n-  {\n+  \/\/ On Apple platforms we want to use mach_absolute_time() unconditionally\n+  \/\/ for the monotonic clock even if clock_gettime() support is available.\n+  \/\/ Only use the latter for other clock types there.\n+  if (sysclock->priv->clock_type == GST_CLOCK_TYPE_MONOTONIC) {\n@@ -1008,2 +1093,1 @@\n-        sysclock->priv->mach_timebase.numer,\n-        sysclock->priv->mach_timebase.denom);\n+        mach_timebase.numer, mach_timebase.denom);\n@@ -1011,1 +1095,3 @@\n-#elif defined G_OS_WIN32\n+#endif\n+\n+#if defined(HAVE_POSIX_TIMERS) && defined(HAVE_CLOCK_GETTIME)\n@@ -1013,7 +1099,0 @@\n-    if (sysclock->priv->frequency.QuadPart != 0) {\n-      return GST_SECOND \/ sysclock->priv->frequency.QuadPart;\n-    } else {\n-      return 1 * GST_USECOND;\n-    }\n-  }\n-#elif defined(HAVE_POSIX_TIMERS) && defined(HAVE_CLOCK_GETTIME)\n@@ -1021,1 +1100,1 @@\n-  struct timespec ts;\n+    struct timespec ts;\n@@ -1023,1 +1102,1 @@\n-  ptype = clock_type_to_posix_id (sysclock->priv->clock_type);\n+    ptype = clock_type_to_posix_id (sysclock->priv->clock_type);\n@@ -1025,2 +1104,2 @@\n-  if (G_UNLIKELY (clock_getres (ptype, &ts)))\n-    return GST_CLOCK_TIME_NONE;\n+    if (G_UNLIKELY (clock_getres (ptype, &ts)))\n+      return GST_CLOCK_TIME_NONE;\n@@ -1028,4 +1107,5 @@\n-  return GST_TIMESPEC_TO_TIME (ts);\n-#else\n-    return 1 * GST_USECOND;\n-#endif \/* __APPLE__ *\/\n+    return GST_TIMESPEC_TO_TIME (ts);\n+  }\n+#endif \/* HAVE_POSIX_TIMERS && HAVE_CLOCK_GETTIME *\/\n+\n+  return 1 * GST_USECOND;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstsystemclock.c","additions":173,"deletions":93,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -413,1 +413,3 @@\n-\n+  gst_tag_register_static (GST_TAG_CONTAINER_SPECIFIC_TRACK_ID,\n+      GST_TAG_FLAG_META, G_TYPE_STRING,\n+      _(\"container-specific-track-id\"), _(\"Container-specific Track ID\"), NULL);\n@@ -551,1 +553,1 @@\n-  info = g_slice_new (GstTagInfo);\n+  info = g_new (GstTagInfo, 1);\n@@ -695,1 +697,1 @@\n-  tag_list = (GstTagList *) g_slice_new (GstTagListImpl);\n+  tag_list = (GstTagList *) g_new (GstTagListImpl, 1);\n@@ -726,1 +728,1 @@\n-  g_slice_free1 (sizeof (GstTagListImpl), list);\n+  g_free (list);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttaglist.c","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1122,0 +1122,12 @@\n+\/**\n+ * GST_TAG_CONTAINER_SPECIFIC_TRACK_ID:\n+ *\n+ * Unique identifier for the audio, video or text track this tag is associated\n+ * with. The mappings for several container formats are defined in the [Sourcing\n+ * In-band Media Resource Tracks from Media Containers into HTML\n+ * specification](https:\/\/dev.w3.org\/html5\/html-sourcing-inband-tracks\/).\n+ *\n+ * Since: 1.24\n+ *\/\n+#define GST_TAG_CONTAINER_SPECIFIC_TRACK_ID \"container-specific-track-id\"\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttaglist.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  g_slice_free (GstTagData, data);\n+  g_free (data);\n@@ -128,1 +128,1 @@\n-      data = g_slice_new (GstTagData);\n+      data = g_new (GstTagData, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttagsetter.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,15 @@\n+static const char *\n+task_state_to_string (GstTaskState state)\n+{\n+  switch (state) {\n+    case GST_TASK_STARTED:\n+      return \"started\";\n+    case GST_TASK_PAUSED:\n+      return \"paused\";\n+    case GST_TASK_STOPPED:\n+      return \"stopped\";\n+    default:\n+      return \"(unknown)\";\n+  }\n+}\n+\n@@ -165,1 +180,1 @@\n-  return ! !SetThreadDescriptionFunc;\n+  return !!SetThreadDescriptionFunc;\n@@ -729,1 +744,2 @@\n-  GST_DEBUG_OBJECT (task, \"Changing task %p to state %d\", task, state);\n+  GST_DEBUG_OBJECT (task, \"Changing task %p to state %s\", task,\n+      task_state_to_string (state));\n@@ -762,2 +778,4 @@\n-    GST_WARNING_OBJECT (task, \"state %d set on task without a lock\", state);\n-    g_warning (\"task without a lock can't be set to state %d\", state);\n+    GST_WARNING_OBJECT (task, \"state %s set on task without a lock\",\n+        task_state_to_string (state));\n+    g_warning (\"task without a lock can't be set to state %s\",\n+        task_state_to_string (state));\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttask.c","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  g_slice_free (TaskData, tdata);\n+  g_free (tdata);\n@@ -105,1 +105,1 @@\n-  tdata = g_slice_new (TaskData);\n+  tdata = g_new (TaskData, 1);\n@@ -113,1 +113,1 @@\n-    g_slice_free (TaskData, tdata);\n+    g_free (tdata);\n@@ -116,1 +116,0 @@\n-\n@@ -352,1 +351,1 @@\n-    g_slice_free (SharedTaskData, tdata);\n+    g_free (tdata);\n@@ -392,1 +391,1 @@\n-  ret = g_slice_new (SharedTaskData);\n+  ret = g_new (SharedTaskData, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttaskpool.c","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  toc = g_slice_new0 (GstToc);\n+  toc = g_new0 (GstToc, 1);\n@@ -272,1 +272,1 @@\n-  entry = g_slice_new0 (GstTocEntry);\n+  entry = g_new0 (GstTocEntry, 1);\n@@ -316,1 +316,1 @@\n-  g_slice_free (GstToc, toc);\n+  g_free (toc);\n@@ -336,1 +336,1 @@\n-  g_slice_free (GstTocEntry, entry);\n+  g_free (entry);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttoc.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  g_slice_free (GstTocData, data);\n+  g_free (data);\n@@ -97,1 +97,1 @@\n-      data = g_slice_new (GstTocData);\n+      data = g_new (GstTocData, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttocsetter.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-      g_slice_free (GstTracerHook, hook);\n+      g_free (hook);\n@@ -186,1 +186,1 @@\n-  GstTracerHook *hook = g_slice_new0 (GstTracerHook);\n+  GstTracerHook *hook = g_new0 (GstTracerHook, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracerutils.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-  return gst_plugin_feature_get_rank (second) -\n+  int diff = gst_plugin_feature_get_rank (second) -\n@@ -569,0 +569,4 @@\n+  if (diff == 0)\n+    diff = g_strcmp0 (gst_plugin_feature_get_name (first),\n+        gst_plugin_feature_get_name (second));\n+  return diff;\n@@ -1007,1 +1011,1 @@\n-  uri = GST_URI_CAST (g_slice_new0 (GstUri));\n+  uri = g_new0 (GstUri, 1);\n@@ -1034,1 +1038,1 @@\n-  g_slice_free1 (sizeof (*uri), uri);\n+  g_free (uri);\n@@ -1997,2 +2001,4 @@\n- * gst_uri_to_string:\n- * @uri: This #GstUri to convert to a string.\n+ * gst_uri_to_string_with_keys:\n+ * @uri: (nullable): This #GstUri to convert to a string.\n+ * @keys: (transfer none) (nullable) (element-type utf8): A GList containing\n+ *   the query argument key strings.\n@@ -2000,1 +2006,2 @@\n- * Convert the URI to a string.\n+ * Convert the URI to a string, with the query arguments in a specific order.\n+ * Only the keys in the @keys list will be added to the resulting string.\n@@ -2008,1 +2015,1 @@\n- * Since: 1.6\n+ * Since: 1.24\n@@ -2011,1 +2018,1 @@\n-gst_uri_to_string (const GstUri * uri)\n+gst_uri_to_string_with_keys (const GstUri * uri, const GList * keys)\n@@ -2055,4 +2062,9 @@\n-    g_string_append (uri_str, \"?\");\n-    escaped = gst_uri_get_query_string (uri);\n-    g_string_append (uri_str, escaped);\n-    g_free (escaped);\n+    if (keys != NULL)\n+      escaped = gst_uri_get_query_string_ordered (uri, keys);\n+    else\n+      escaped = gst_uri_get_query_string (uri);\n+    if (escaped) {\n+      g_string_append (uri_str, \"?\");\n+      g_string_append (uri_str, escaped);\n+      g_free (escaped);\n+    }\n@@ -2070,0 +2082,20 @@\n+\/**\n+ * gst_uri_to_string:\n+ * @uri: This #GstUri to convert to a string.\n+ *\n+ * Convert the URI to a string.\n+ *\n+ * Returns the URI as held in this object as a #gchar* nul-terminated string.\n+ * The caller should g_free() the string once they are finished with it.\n+ * The string is put together as described in RFC 3986.\n+ *\n+ * Returns: (transfer full): The string version of the URI.\n+ *\n+ * Since: 1.6\n+ *\/\n+gchar *\n+gst_uri_to_string (const GstUri * uri)\n+{\n+  return gst_uri_to_string_with_keys (uri, NULL);\n+}\n+\n@@ -2639,0 +2671,61 @@\n+\/**\n+ * gst_uri_get_query_string_ordered:\n+ * @uri: (nullable): The #GstUri to get the query string from.\n+ * @keys: (transfer none) (nullable) (element-type utf8): A GList containing the\n+ *   query argument key strings.\n+ *\n+ * Get a percent encoded URI query string from the @uri, with query parameters\n+ * in the order provided by the @keys list. Only parameter keys in the list will\n+ * be added to the resulting URI string. This method can be used by retrieving\n+ * the keys with gst_uri_get_query_keys() and then sorting the list, for\n+ * example.\n+ *\n+ * Returns: (transfer full) (nullable): A percent encoded query string. Use\n+ * g_free() when no longer needed.\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar *\n+gst_uri_get_query_string_ordered (const GstUri * uri, const GList * keys)\n+{\n+  const gchar *sep = \"\";\n+  gchar *escaped;\n+  GString *ret = NULL;\n+  const GList *key;\n+\n+  if (!uri)\n+    return NULL;\n+  g_return_val_if_fail (GST_IS_URI (uri), NULL);\n+  if (!uri->query)\n+    return NULL;\n+\n+  for (key = keys; key; key = key->next) {\n+    const gchar *query_key = key->data;\n+    const gchar *arg;\n+\n+    \/* Key isn't present, skip *\/\n+    if (!g_hash_table_contains (uri->query, query_key))\n+      continue;\n+\n+    if (ret == NULL)\n+      ret = g_string_new (NULL);\n+\n+    \/* Append the key *\/\n+    g_string_append (ret, sep);\n+    escaped = _gst_uri_escape_http_query_element (query_key);\n+    g_string_append (ret, escaped);\n+    g_free (escaped);\n+\n+    if ((arg = g_hash_table_lookup (uri->query, query_key))) {\n+      \/* Append the argument *\/\n+      escaped = _gst_uri_escape_http_query_element (arg);\n+      g_string_append_printf (ret, \"=%s\", escaped);\n+      g_free (escaped);\n+    }\n+    sep = \"&\";\n+  }\n+\n+  \/* If no keys were seen, return NULL string instead of empty string *\/\n+  return ret ? g_string_free (ret, FALSE) : NULL;\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsturi.c","additions":105,"deletions":12,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -262,0 +262,3 @@\n+GST_API\n+gchar * gst_uri_to_string_with_keys    (const GstUri * uri, const GList *keys);\n+\n@@ -318,0 +321,3 @@\n+\n+GST_API\n+gchar * gst_uri_get_query_string_ordered (const GstUri * uri, const GList *keys);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsturi.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3549,6 +3549,2 @@\n-#if defined (HAVE_POSIX_TIMERS) && defined(HAVE_MONOTONIC_CLOCK) &&\\\n-    defined (HAVE_CLOCK_GETTIME)\n-  struct timespec now;\n-\n-  clock_gettime (CLOCK_MONOTONIC, &now);\n-  return GST_TIMESPEC_TO_TIME (now);\n+#if defined(G_OS_WIN32) && !defined(GST_STATIC_COMPILATION)\n+  \/* priv_gst_clock_init() is called in DllMain *\/\n@@ -3556,1 +3552,1 @@\n-  return g_get_monotonic_time () * 1000;\n+  priv_gst_clock_init ();\n@@ -3558,0 +3554,1 @@\n+  return priv_gst_get_monotonic_time ();\n@@ -3697,0 +3694,67 @@\n+\/**\n+ * gst_util_simplify_fraction:\n+ * @numerator: First value as #gint\n+ * @denominator: Second value as #gint\n+ * @n_terms: non-significative terms (typical value: 8)\n+ * @threshold: threshold (typical value: 333)\n+ *\n+ * Calculates the simpler representation of @numerator and @denominator and\n+ * update both values with the resulting simplified fraction.\n+ *\n+ * Simplify a fraction using a simple continued fraction decomposition.\n+ * The idea here is to convert fractions such as 333333\/10000000 to 1\/30\n+ * using 32 bit arithmetic only. The algorithm is not perfect and relies\n+ * upon two arbitrary parameters to remove non-significative terms from\n+ * the simple continued fraction decomposition. Using 8 and 333 for\n+ * @n_terms and @threshold respectively seems to give nice results.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_util_simplify_fraction (gint * numerator, gint * denominator,\n+    guint n_terms, guint threshold)\n+{\n+  guint *an;\n+  guint x, y, r;\n+  guint i, n;\n+\n+  an = g_malloc_n (n_terms, sizeof (*an));\n+  if (an == NULL)\n+    return;\n+\n+  \/*\n+   * Convert the fraction to a simple continued fraction. See\n+   * https:\/\/en.wikipedia.org\/wiki\/Continued_fraction\n+   * Stop if the current term is bigger than or equal to the given\n+   * threshold.\n+   *\/\n+  x = *numerator;\n+  y = *denominator;\n+\n+  for (n = 0; n < n_terms && y != 0; ++n) {\n+    an[n] = x \/ y;\n+    if (an[n] >= threshold) {\n+      if (n < 2)\n+        n++;\n+      break;\n+    }\n+\n+    r = x - an[n] * y;\n+    x = y;\n+    y = r;\n+  }\n+\n+  \/* Expand the simple continued fraction back to an integer fraction. *\/\n+  x = 0;\n+  y = 1;\n+\n+  for (i = n; i > 0; --i) {\n+    r = y;\n+    y = an[i - 1] * y + x;\n+    x = r;\n+  }\n+\n+  *numerator = y;\n+  *denominator = x;\n+  g_free (an);\n+}\n@@ -3994,1 +4058,1 @@\n-gst_pad_create_stream_id_internal (GstPad * pad, GstElement * parent,\n+gst_element_decorate_stream_id_internal (GstElement * element,\n@@ -4001,12 +4065,0 @@\n-  g_return_val_if_fail (GST_IS_PAD (pad), NULL);\n-  g_return_val_if_fail (GST_PAD_IS_SRC (pad), NULL);\n-  g_return_val_if_fail (GST_IS_ELEMENT (parent), NULL);\n-\n-  g_return_val_if_fail (parent->numsinkpads <= 1, NULL);\n-\n-  \/* If the element has multiple source pads it must\n-   * provide a stream-id for every source pad, otherwise\n-   * all source pads will have the same and are not\n-   * distinguishable *\/\n-  g_return_val_if_fail (parent->numsrcpads <= 1 || stream_id, NULL);\n-\n@@ -4015,1 +4067,1 @@\n-  sinkpad = gst_element_get_static_pad (parent, \"sink\");\n+  sinkpad = gst_element_get_static_pad (element, \"sink\");\n@@ -4039,1 +4091,1 @@\n-    if (gst_element_query (parent, query)) {\n+    if (gst_element_query (element, query)) {\n@@ -4054,1 +4106,1 @@\n-      GST_FIXME_OBJECT (pad, \"Creating random stream-id, consider \"\n+      GST_FIXME_OBJECT (element, \"Creating random stream-id, consider \"\n@@ -4075,0 +4127,133 @@\n+\/**\n+ * gst_element_decorate_stream_id_printf_valist:\n+ * @element: The  #GstElement to create a stream-id for\n+ * @format: (not nullable): The stream-id\n+ * @var_args: parameters for the @format string\n+ *\n+ * Creates a stream-id for @element by combining the upstream information with\n+ * the @format.\n+ *\n+ * This function generates an unique stream-id by getting the upstream\n+ * stream-start event stream ID and appending @format to it. If the element\n+ * has no sinkpad it will generate an upstream stream-id by doing an URI query\n+ * on the element and in the worst case just uses a random number. Source\n+ * elements that don't implement the URI handler interface should ideally\n+ * generate a unique, deterministic stream-id manually instead.\n+ *\n+ * Since stream IDs are sorted alphabetically, any numbers in the stream ID\n+ * should be printed with a fixed number of characters, preceded by 0's, such as\n+ * by using the format \\%03u instead of \\%u.\n+ *\n+ * Returns: (transfer full): A stream-id for @element.\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar *\n+gst_element_decorate_stream_id_printf_valist (GstElement * element,\n+    const gchar * format, va_list var_args)\n+{\n+  gchar *stream_id, *res;\n+\n+  g_return_val_if_fail (format, NULL);\n+\n+  stream_id = g_strdup_vprintf (format, var_args);\n+\n+  res = gst_element_decorate_stream_id_internal (element, stream_id);\n+\n+  g_free (stream_id);\n+\n+  return res;\n+}\n+\n+\/**\n+ * gst_element_decorate_stream_id_printf:\n+ * @element: The  #GstElement to create a stream-id for\n+ * @format: (not nullable): The stream-id\n+ *\n+ * Creates a stream-id for @element by combining the upstream information with\n+ * the @format.\n+ *\n+ * This function generates an unique stream-id by getting the upstream\n+ * stream-start event stream ID and appending the stream-id to it. If the element\n+ * has no sinkpad it will generate an upstream stream-id by doing an URI query\n+ * on the element and in the worst case just uses a random number. Source\n+ * elements that don't implement the URI handler interface should ideally\n+ * generate a unique, deterministic stream-id manually instead.\n+ *\n+ * Since stream IDs are sorted alphabetically, any numbers in the stream ID\n+ * should be printed with a fixed number of characters, preceded by 0's, such as\n+ * by using the format \\%03u instead of \\%u.\n+ *\n+ * Returns: (transfer full): A stream-id for @element.\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar *\n+gst_element_decorate_stream_id_printf (GstElement * element,\n+    const gchar * format, ...)\n+{\n+  gchar *res;\n+  va_list var_args;\n+\n+  g_return_val_if_fail (format, NULL);\n+\n+  va_start (var_args, format);\n+  res =\n+      gst_element_decorate_stream_id_printf_valist (element, format, var_args);\n+  va_end (var_args);\n+\n+  return res;\n+}\n+\n+\n+\/**\n+ * gst_element_decorate_stream_id:\n+ * @element: The  #GstElement to create a stream-id for\n+ * @stream_id: (not nullable): The stream-id\n+ *\n+ * Creates a stream-id for @element by combining the upstream information with\n+ * the @stream_id.\n+ *\n+ * This function generates an unique stream-id by getting the upstream\n+ * stream-start event stream ID and appending @stream_id to it. If the element\n+ * has no sinkpad it will generate an upstream stream-id by doing an URI query\n+ * on the element and in the worst case just uses a random number. Source\n+ * elements that don't implement the URI handler interface should ideally\n+ * generate a unique, deterministic stream-id manually instead.\n+ *\n+ * Since stream IDs are sorted alphabetically, any numbers in the stream ID\n+ * should be printed with a fixed number of characters, preceded by 0's, such as\n+ * by using the format \\%03u instead of \\%u.\n+ *\n+ * Returns: (transfer full): A stream-id for @element.\n+ *\n+ * Since: 1.24\n+ *\/\n+gchar *\n+gst_element_decorate_stream_id (GstElement * element, const gchar * stream_id)\n+{\n+  g_return_val_if_fail (stream_id, NULL);\n+  g_return_val_if_fail (GST_IS_ELEMENT (element), NULL);\n+\n+  return gst_element_decorate_stream_id_internal (element, stream_id);\n+}\n+\n+static gchar *\n+gst_pad_create_stream_id_internal (GstPad * pad, GstElement * parent,\n+    const gchar * stream_id)\n+{\n+  g_return_val_if_fail (GST_IS_PAD (pad), NULL);\n+  g_return_val_if_fail (GST_PAD_IS_SRC (pad), NULL);\n+  g_return_val_if_fail (GST_IS_ELEMENT (parent), NULL);\n+\n+  g_return_val_if_fail (parent->numsinkpads <= 1, NULL);\n+\n+  \/* If the element has multiple source pads it must\n+   * provide a stream-id for every source pad, otherwise\n+   * all source pads will have the same and are not\n+   * distinguishable *\/\n+  g_return_val_if_fail (parent->numsrcpads <= 1 || stream_id, NULL);\n+\n+  return gst_element_decorate_stream_id_internal (parent, stream_id);\n+}\n+\n@@ -4309,0 +4494,36 @@\n+#ifndef GSTREAMER_LITE\n+\/**\n+ * gst_util_ceil_log2:\n+ * @v: a #guint32 value.\n+ *\n+ * Return a max num of log2.\n+ *\n+ * Returns: a computed #guint val.\n+ *\n+ * Since: 1.24\n+ *\/\n+guint\n+gst_util_ceil_log2 (guint32 v)\n+{\n+  \/* Compute Ceil(Log2(v)) *\/\n+  \/* Derived from branchless code for integer log2(v) from:\n+     <http:\/\/graphics.stanford.edu\/~seander\/bithacks.html#IntegerLog> *\/\n+  guint r, shift;\n+\n+  v--;\n+  r = (v > 0xFFFF) << 4;\n+  v >>= r;\n+  shift = (v > 0xFF) << 3;\n+  v >>= shift;\n+  r |= shift;\n+  shift = (v > 0xF) << 2;\n+  v >>= shift;\n+  r |= shift;\n+  shift = (v > 0x3) << 1;\n+  v >>= shift;\n+  r |= shift;\n+  r |= (v >> 1);\n+  return r + 1;\n+}\n+#endif \/\/ GSTREAMER_LITE\n+\n@@ -4594,1 +4815,1 @@\n-      ! !GPOINTER_TO_INT (g_type_get_qdata (type, GST_QUARK (PLUGIN_API)));\n+      !!GPOINTER_TO_INT (g_type_get_qdata (type, GST_QUARK (PLUGIN_API)));\n@@ -4603,0 +4824,38 @@\n+\n+#ifndef GSTREAMER_LITE\n+\/**\n+ * gst_util_filename_compare:\n+ * @a: (type filename): a filename to compare with @b\n+ * @b: (type filename): a filename to compare with @a\n+ *\n+ * Compares the given filenames using natural ordering.\n+ *\n+ * Since: 1.24\n+ *\/\n+gint\n+gst_util_filename_compare (const gchar * a, const gchar * b)\n+{\n+  gchar *a_utf8, *b_utf8;\n+  gchar *a1, *b1;\n+  gint ret;\n+\n+  \/* Filenames in GLib are only guaranteed to be UTF-8 on Windows *\/\n+  a_utf8 = g_filename_to_utf8 (a, -1, NULL, NULL, NULL);\n+  b_utf8 = g_filename_to_utf8 (b, -1, NULL, NULL, NULL);\n+\n+  if (a_utf8 == NULL || b_utf8 == NULL) {\n+    return strcmp (a, b);\n+  }\n+\n+  a1 = g_utf8_collate_key_for_filename (a_utf8, -1);\n+  b1 = g_utf8_collate_key_for_filename (b_utf8, -1);\n+  ret = strcmp (a1, b1);\n+  g_free (a1);\n+  g_free (b1);\n+\n+  g_free (a_utf8);\n+  g_free (b_utf8);\n+\n+  return ret;\n+}\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstutils.c","additions":283,"deletions":24,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -1037,0 +1037,11 @@\n+GST_API\n+gchar *                 gst_element_decorate_stream_id  (GstElement   *element,\n+                                                         const gchar  *stream_id);\n+GST_API\n+gchar *   gst_element_decorate_stream_id_printf_valist  (GstElement * element,\n+                                                         const gchar * format,\n+                                                         va_list var_args) G_GNUC_PRINTF (2, 0) G_GNUC_MALLOC;\n+GST_API\n+gchar *          gst_element_decorate_stream_id_printf  (GstElement * element,\n+                                                         const gchar * format,\n+                                                         ...) G_GNUC_PRINTF (2, 3) G_GNUC_MALLOC;\n@@ -1200,0 +1211,4 @@\n+GST_API\n+void          gst_util_simplify_fraction        (gint *numerator, gint *denominator,\n+                                                 guint n_terms, guint threshold);\n+\n@@ -1228,0 +1243,8 @@\n+#ifndef GSTREAMER_LITE\n+GST_API\n+guint         gst_util_ceil_log2                (guint32 v);\n+\n+GST_API\n+gint          gst_util_filename_compare        (const gchar *a, const gchar *b);\n+#endif \/\/ GSTREAMER_LITE\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstutils.h","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -372,1 +372,2 @@\n-        s_val = gst_structure_serialize (gst_value_get_structure (v), flags);\n+        s_val =\n+            gst_structure_serialize_full (gst_value_get_structure (v), flags);\n@@ -1532,1 +1533,1 @@\n-  gint64 *vals = g_slice_alloc0 (3 * sizeof (gint64));\n+  gint64 *vals = g_malloc0 (3 * sizeof (gint64));\n@@ -1543,1 +1544,1 @@\n-  g_slice_free1 (3 * sizeof (gint64), value->data[0].v_pointer);\n+  g_free (value->data[0].v_pointer);\n@@ -1918,1 +1919,1 @@\n-  value->data[0].v_pointer = vals = g_slice_alloc0 (2 * sizeof (GValue));\n+  value->data[0].v_pointer = vals = g_malloc0 (2 * sizeof (GValue));\n@@ -1932,1 +1933,1 @@\n-    g_slice_free1 (2 * sizeof (GValue), vals);\n+    g_free (vals);\n@@ -4813,0 +4814,98 @@\n+static gboolean\n+gst_value_union_fraction_fraction_range (GValue * dest, const GValue * src1,\n+    const GValue * src2)\n+{\n+  GValue *vals;\n+  int f_n, f_d, fr_start_n, fr_start_d, fr_end_n, fr_end_d;\n+\n+  g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (src1), FALSE);\n+  g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION_RANGE (src2), FALSE);\n+\n+  \/* Fraction *\/\n+  f_n = src1->data[0].v_int;\n+  f_d = src1->data[1].v_int;\n+\n+  vals = src2->data[0].v_pointer;\n+  \/* Fraction range start *\/\n+  fr_start_n = vals[0].data[0].v_int;\n+  fr_start_d = vals[0].data[1].v_int;\n+  \/* Fraction range end *\/\n+  fr_end_n = vals[1].data[0].v_int;\n+  fr_end_d = vals[1].data[1].v_int;\n+\n+  \/* Check if it's already in the range. This is the only case in which we can\n+   * successfully perform a union. *\/\n+  if (gst_util_fraction_compare (f_n, f_d, fr_start_n, fr_start_d) >= 0 &&\n+      gst_util_fraction_compare (f_n, f_d, fr_end_n, fr_end_d) <= 0) {\n+    if (dest)\n+      gst_value_init_and_copy (dest, src2);\n+    return TRUE;\n+  }\n+\n+  return FALSE;\n+}\n+\n+static gboolean\n+gst_value_union_fraction_range_fraction_range (GValue * dest,\n+    const GValue * src1, const GValue * src2)\n+{\n+  GValue *vals1, *vals2;\n+  int fr1_start_n, fr1_start_d, fr1_end_n, fr1_end_d;\n+  int fr2_start_n, fr2_start_d, fr2_end_n, fr2_end_d;\n+  int fr_start_n, fr_start_d, fr_end_n, fr_end_d;\n+\n+  g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION_RANGE (src1), FALSE);\n+  g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION_RANGE (src2), FALSE);\n+\n+  vals1 = src1->data[0].v_pointer;\n+  g_return_val_if_fail (vals1 != NULL, FALSE);\n+\n+  fr1_start_n = vals1[0].data[0].v_int;\n+  fr1_start_d = vals1[0].data[1].v_int;\n+  fr1_end_n = vals1[1].data[0].v_int;\n+  fr1_end_d = vals1[1].data[1].v_int;\n+\n+  vals2 = src2->data[0].v_pointer;\n+  g_return_val_if_fail (vals2 != NULL, FALSE);\n+\n+  fr2_start_n = vals2[0].data[0].v_int;\n+  fr2_start_d = vals2[0].data[1].v_int;\n+  fr2_end_n = vals2[1].data[0].v_int;\n+  fr2_end_d = vals2[1].data[1].v_int;\n+\n+  \/* Ranges are completely disjoint: end of one range is less than the start of\n+   * other range *\/\n+  if (gst_util_fraction_compare (fr2_end_n, fr2_end_d, fr1_start_n,\n+          fr1_start_d) < 0\n+      || gst_util_fraction_compare (fr1_end_n, fr1_end_d, fr2_start_n,\n+          fr2_start_d) < 0)\n+    return FALSE;\n+\n+  \/* Ranges overlap, union is trivial *\/\n+  if (!dest)\n+    return TRUE;\n+\n+  if (gst_util_fraction_compare (fr1_start_n, fr1_start_d, fr2_start_n,\n+          fr2_start_d) < 0) {\n+    fr_start_n = fr1_start_n;\n+    fr_start_d = fr1_start_d;\n+  } else {\n+    fr_start_n = fr2_start_n;\n+    fr_start_d = fr2_start_d;\n+  }\n+\n+  if (gst_util_fraction_compare (fr1_end_n, fr1_end_d, fr2_end_n,\n+          fr2_end_d) > 0) {\n+    fr_end_n = fr1_end_n;\n+    fr_end_d = fr1_end_d;\n+  } else {\n+    fr_end_n = fr2_end_n;\n+    fr_end_d = fr2_end_d;\n+  }\n+\n+  g_value_init (dest, GST_TYPE_FRACTION_RANGE);\n+  gst_value_set_fraction_range_full (dest, fr_start_n, fr_start_d, fr_end_n,\n+      fr_end_d);\n+  return TRUE;\n+}\n+\n@@ -7818,0 +7917,10 @@\n+  if (g_str_has_prefix (cur, \"0x\") || g_str_has_prefix (cur, \"0X\"))\n+    cur += 2;\n+\n+  \/* Flagsets are 32 bits hex numbers, so do not accept any number that has more\n+   * then 8 characters. strtoul() accepts unlimited number of leading zeros and\n+   * 64bit numbers on 64bit platforms.\n+   *\/\n+  if ((next - cur) > 8)\n+    return FALSE;\n+\n@@ -8365,0 +8474,4 @@\n+  gst_value_register_union_func (GST_TYPE_FRACTION, GST_TYPE_FRACTION_RANGE,\n+      gst_value_union_fraction_fraction_range);\n+  gst_value_register_union_func (GST_TYPE_FRACTION_RANGE,\n+      GST_TYPE_FRACTION_RANGE, gst_value_union_fraction_range_fraction_range);\n@@ -8390,8 +8503,0 @@\n-\n-#if 0\n-  \/* Implement these if needed *\/\n-  gst_value_register_union_func (GST_TYPE_FRACTION, GST_TYPE_FRACTION_RANGE,\n-      gst_value_union_fraction_fraction_range);\n-  gst_value_register_union_func (GST_TYPE_FRACTION_RANGE,\n-      GST_TYPE_FRACTION_RANGE, gst_value_union_fraction_range_fraction_range);\n-#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstvalue.c","additions":118,"deletions":13,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n- * @size: the number of bytes to copy\n+ * @size: (in): the number of bytes to copy\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstadapter.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-  copy = g_slice_dup (GstBaseParseFrame, frame);\n+  copy = g_memdup2 (frame, sizeof (GstBaseParseFrame));\n@@ -728,1 +728,1 @@\n-    g_slice_free (GstBaseParseFrame, frame);\n+    g_free (frame);\n@@ -777,1 +777,1 @@\n-  frame = g_slice_new0 (GstBaseParseFrame);\n+  frame = g_new0 (GstBaseParseFrame, 1);\n@@ -2300,0 +2300,4 @@\n+      GST_BUFFER_OFFSET (outbuf) = GST_BUFFER_OFFSET_NONE;\n+      GST_BUFFER_DURATION (outbuf) = GST_CLOCK_TIME_NONE;\n+      GST_BUFFER_OFFSET_END (outbuf) = GST_BUFFER_OFFSET_NONE;\n+      GST_BUFFER_FLAGS (outbuf) = 0;\n@@ -2692,1 +2696,1 @@\n- * Collects parsed data and pushes this downstream.\n+ * Collects parsed data and pushes it downstream.\n@@ -2695,1 +2699,4 @@\n- * If @frame's out_buffer is set, that will be used as subsequent frame data.\n+ * If @frame's out_buffer is set, that will be used as subsequent frame data,\n+ * and @size amount will be flushed from the input data. The output_buffer size\n+ * can differ from the consumed size indicated by @size.\n+ *\n@@ -2742,0 +2749,1 @@\n+    frame->out_buffer = gst_buffer_make_writable (frame->out_buffer);\n@@ -2749,1 +2757,1 @@\n-    GST_MINI_OBJECT_FLAGS (dest) = GST_MINI_OBJECT_FLAGS (src);\n+    GST_BUFFER_FLAGS (dest) = GST_BUFFER_FLAGS (src);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbaseparse.c","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2188,1 +2188,5 @@\n-    goto out_of_segment;\n+    if (basesink->priv->drop_out_of_segment)\n+      goto out_of_segment;\n+\n+    cstart = start;\n+    cstop = stop;\n@@ -3956,0 +3960,5 @@\n+\n+    if (ret == GST_BASE_SINK_FLOW_DROPPED) {\n+      ret = GST_FLOW_OK;\n+      goto dropped;\n+    }\n@@ -3965,0 +3974,3 @@\n+\n+    \/* Not currently supported *\/\n+    g_assert (ret != GST_BASE_SINK_FLOW_DROPPED);\n@@ -5147,1 +5159,2 @@\n-  if (!basesink->have_newsegment)\n+  if (GST_STATE (basesink) <= GST_STATE_READY &&\n+      GST_STATE_PENDING (basesink) <= GST_STATE_READY) {\n@@ -5149,0 +5162,8 @@\n+  }\n+\n+  segment = &basesink->segment;\n+  \/* get the format in the segment *\/\n+  oformat = segment->format;\n+\n+  if (oformat == GST_FORMAT_UNDEFINED)\n+    goto no_segment;\n@@ -5159,5 +5180,0 @@\n-  segment = &basesink->segment;\n-\n-  \/* get the format in the segment *\/\n-  oformat = segment->format;\n-\n@@ -5362,0 +5378,9 @@\n+no_segment:\n+  {\n+    GST_DEBUG_OBJECT (basesink,\n+        \"haven't received a segment yet, can't anwser position, return -1\");\n+    res = FALSE;\n+    *cur = -1;\n+    GST_OBJECT_UNLOCK (basesink);\n+    goto done;\n+  }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbasesink.c","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -61,0 +61,14 @@\n+\/**\n+ * GST_BASE_SINK_FLOW_DROPPED:\n+ *\n+ * A #GstFlowReturn that can be returned from\n+ * #GstBaseSinkClass::render to indicate that the output buffer was not\n+ * rendered.\n+ *\n+ * Note that this is currently not support for #GstBaseSinkClass::render_list\n+ * virtual method.\n+ *\n+ * Since: 1.24\n+ *\/\n+#define GST_BASE_SINK_FLOW_DROPPED     GST_FLOW_CUSTOM_SUCCESS\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbasesink.h","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -192,0 +192,3 @@\n+\/* FIXME 2.0: automatic_eos should probably be disabled by default,\n+ * see https:\/\/gitlab.freedesktop.org\/gstreamer\/gstreamer\/-\/merge_requests\/1330 *\/\n+#define DEFAULT_AUTOMATIC_EOS   TRUE\n@@ -201,1 +204,2 @@\n-  PROP_DO_TIMESTAMP\n+  PROP_DO_TIMESTAMP,\n+  PROP_AUTOMATIC_EOS\n@@ -264,0 +268,3 @@\n+\n+  \/* to delay unlock_stop *\/\n+  gboolean pending_unlock_stop;\n@@ -407,0 +414,12 @@\n+  \/**\n+   * GstBaseSrc:automatic-eos:\n+   *\n+   * See gst_base_src_set_automatic_eos()\n+   *\n+   * Since: 1.24\n+   *\/\n+  g_object_class_install_property (gobject_class, PROP_AUTOMATIC_EOS,\n+      g_param_spec_boolean (\"automatic-eos\", \"Automatic EOS\",\n+          \"Automatically EOS when the segment is done\", DEFAULT_AUTOMATIC_EOS,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n+\n@@ -445,1 +464,1 @@\n-  g_atomic_int_set (&basesrc->priv->automatic_eos, TRUE);\n+  g_atomic_int_set (&basesrc->priv->automatic_eos, DEFAULT_AUTOMATIC_EOS);\n@@ -2207,0 +2226,3 @@\n+    case PROP_AUTOMATIC_EOS:\n+      gst_base_src_set_automatic_eos (src, g_value_get_boolean (value));\n+      break;\n@@ -2236,0 +2258,3 @@\n+    case PROP_AUTOMATIC_EOS:\n+      g_value_set_boolean (value, g_atomic_int_get (&src->priv->automatic_eos));\n+      break;\n@@ -2541,0 +2566,1 @@\n+  gboolean pending_unlock_stop;\n@@ -2591,0 +2617,1 @@\n+retry_create:\n@@ -2592,0 +2619,11 @@\n+\n+  \/* Undo our unlocking initiated from set_playing function. This is done here\n+   * since we require the stream lock to call this virtual function. *\/\n+  GST_OBJECT_LOCK (src);\n+  pending_unlock_stop = src->priv->pending_unlock_stop;\n+  src->priv->pending_unlock_stop = FALSE;\n+  GST_OBJECT_UNLOCK (src);\n+\n+  if (pending_unlock_stop && bclass->unlock_stop)\n+    bclass->unlock_stop (src);\n+\n@@ -2599,0 +2637,6 @@\n+\n+      \/* no need keep old buffer while in pause *\/\n+      if (ret == GST_FLOW_OK && own_res_buf)\n+        gst_clear_buffer (&res_buf);\n+      gst_clear_buffer_list (&src->priv->pending_bufferlist);\n+\n@@ -2601,2 +2645,0 @@\n-        if (ret == GST_FLOW_OK && own_res_buf)\n-          gst_buffer_unref (res_buf);\n@@ -2606,0 +2648,2 @@\n+\n+      goto retry_create;\n@@ -2615,1 +2659,2 @@\n-        gst_buffer_unref (res_buf);\n+        gst_clear_buffer (&res_buf);\n+      gst_clear_buffer_list (&src->priv->pending_bufferlist);\n@@ -3693,1 +3738,1 @@\n-    GST_WARNING_OBJECT (basesrc, \"pad not activated yet\");\n+    GST_INFO_OBJECT (basesrc, \"pad not activated yet\");\n@@ -3848,0 +3893,4 @@\n+  GstBaseSrcClass *bclass;\n+\n+  bclass = GST_BASE_SRC_GET_CLASS (basesrc);\n+\n@@ -3854,0 +3903,7 @@\n+  \/* unlock subclasses locked in ::create, we only do this when we stop playing. *\/\n+  if (!live_play) {\n+    GST_DEBUG_OBJECT (basesrc, \"unlock\");\n+    if (bclass->unlock)\n+      bclass->unlock (basesrc);\n+  }\n+\n@@ -3868,0 +3924,1 @@\n+    basesrc->priv->pending_unlock_stop = TRUE;\n@@ -4145,0 +4202,63 @@\n+\n+\/**\n+ * gst_base_src_push_segment:\n+ * @src: a #GstBaseSrc\n+ * @segment: a pointer to a #GstSegment\n+ *\n+ * Send a new segment downstream. This function must\n+ * only be called by derived sub-classes, and only from the #GstBaseSrcClass::create function,\n+ * as the stream-lock needs to be held.\n+ * This method also requires that an out caps has been configured, so\n+ * gst_base_src_set_caps() needs to have been called before.\n+ *\n+ * The format for the @segment must be identical with the current format\n+ * of the source, as configured with gst_base_src_set_format().\n+ *\n+ * The format of @src must not be %GST_FORMAT_UNDEFINED and the format\n+ * should be configured via gst_base_src_set_format() before calling this method.\n+ *\n+ * This is a variant of gst_base_src_new_segment() sending the segment right away,\n+ * which can be useful to ensure events ordering.\n+ *\n+ * Returns: %TRUE if sending of new segment succeeded.\n+ *\n+ * Since: 1.24\n+*\/\n+gboolean\n+gst_base_src_push_segment (GstBaseSrc * src, const GstSegment * segment)\n+{\n+  GstEvent *seg_event;\n+\n+  g_return_val_if_fail (GST_IS_BASE_SRC (src), FALSE);\n+  g_return_val_if_fail (segment != NULL, FALSE);\n+\n+  GST_OBJECT_LOCK (src);\n+\n+  if (src->segment.format == GST_FORMAT_UNDEFINED) {\n+    \/* subclass must set valid format before calling this method *\/\n+    GST_WARNING_OBJECT (src, \"segment format is not configured yet, ignore\");\n+    GST_OBJECT_UNLOCK (src);\n+    return FALSE;\n+  }\n+\n+  if (src->segment.format != segment->format) {\n+    GST_WARNING_OBJECT (src, \"segment format mismatched, ignore\");\n+    GST_OBJECT_UNLOCK (src);\n+    return FALSE;\n+  }\n+\n+  gst_segment_copy_into (segment, &src->segment);\n+  seg_event = gst_event_new_segment (&src->segment);\n+  src->priv->segment_pending = FALSE;\n+  src->priv->segment_seqnum = gst_util_seqnum_next ();\n+  gst_event_set_seqnum (seg_event, src->priv->segment_seqnum);\n+\n+  GST_OBJECT_UNLOCK (src);\n+\n+  GST_DEBUG_OBJECT (src, \"Sending new segment %\" GST_SEGMENT_FORMAT, segment);\n+  gst_pad_push_event (src->srcpad, seg_event);\n+\n+  src->running = TRUE;\n+\n+  return TRUE;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbasesrc.c","additions":126,"deletions":6,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -350,0 +350,4 @@\n+GST_BASE_API\n+gboolean gst_base_src_push_segment              (GstBaseSrc * src,\n+                                                 const GstSegment * segment);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbasesrc.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  GstBitReader *ret = g_slice_new0 (GstBitReader);\n+  GstBitReader *ret = g_new0 (GstBitReader, 1);\n@@ -86,1 +86,1 @@\n-  g_slice_free (GstBitReader, reader);\n+  g_free (reader);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbitreader.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  GstByteReader *ret = g_slice_new0 (GstByteReader);\n+  GstByteReader *ret = g_new0 (GstByteReader, 1);\n@@ -122,1 +122,1 @@\n-  g_slice_free (GstByteReader, reader);\n+  g_free (reader);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbytereader.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  GstByteWriter *ret = g_slice_new0 (GstByteWriter);\n+  GstByteWriter *ret = g_new0 (GstByteWriter, 1);\n@@ -292,1 +292,1 @@\n-  g_slice_free (GstByteWriter, writer);\n+  g_free (writer);\n@@ -314,1 +314,1 @@\n-  g_slice_free (GstByteWriter, writer);\n+  g_free (writer);\n@@ -339,1 +339,1 @@\n-  g_slice_free (GstByteWriter, writer);\n+  g_free (writer);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbytewriter.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1227,1 +1227,1 @@\n-          ! !waiting)) {\n+          !!waiting)) {\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstcollectpads.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  GstFlowCombiner *combiner = g_slice_new (GstFlowCombiner);\n+  GstFlowCombiner *combiner = g_new (GstFlowCombiner, 1);\n@@ -164,1 +164,1 @@\n-    g_slice_free (GstFlowCombiner, combiner);\n+    g_free (combiner);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstflowcombiner.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-  GstIndexGroup *indexgroup = g_slice_new (GstIndexGroup);\n+  GstIndexGroup *indexgroup = g_new (GstIndexGroup, 1);\n@@ -290,1 +290,1 @@\n-  g_slice_free (GstIndexGroup, group);\n+  g_free (group);\n@@ -531,1 +531,1 @@\n-  GstIndexEntry *new_entry = g_slice_new (GstIndexEntry);\n+  GstIndexEntry *new_entry = g_new (GstIndexEntry, 1);\n@@ -565,1 +565,1 @@\n-  g_slice_free (GstIndexEntry, entry);\n+  g_free (entry);\n@@ -595,1 +595,1 @@\n-  entry = g_slice_new (GstIndexEntry);\n+  entry = g_new (GstIndexEntry, 1);\n@@ -630,1 +630,1 @@\n-  entry = g_slice_new (GstIndexEntry);\n+  entry = g_new (GstIndexEntry, 1);\n@@ -745,1 +745,1 @@\n-      entry = g_slice_new (GstIndexEntry);\n+      entry = g_new (GstIndexEntry, 1);\n@@ -797,1 +797,1 @@\n-  entry = g_slice_new (GstIndexEntry);\n+  entry = g_new (GstIndexEntry, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstindex.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  g_slice_free (GstMemIndexFormatIndex, index);\n+  g_free (index);\n@@ -158,1 +158,1 @@\n-  g_slice_free (GstMemIndexId, id_index);\n+  g_free (id_index);\n@@ -192,1 +192,1 @@\n-    id_index = g_slice_new0 (GstMemIndexId);\n+    id_index = g_new0 (GstMemIndexId, 1);\n@@ -227,1 +227,1 @@\n-    index = g_slice_new0 (GstMemIndexFormatIndex);\n+    index = g_new0 (GstMemIndexFormatIndex, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstmemindex.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+#define gst_queue_array_idx(a, i) \\\n+  ((a)->array + (((a)->head + (i)) % (a)->size) * (a)->elt_size)\n+\n@@ -53,0 +56,6 @@\n+typedef struct\n+{\n+  GCompareDataFunc func;\n+  gpointer user_data;\n+} QueueSortData;\n+\n@@ -72,1 +81,1 @@\n-  array = g_slice_new (GstQueueArray);\n+  array = g_new (GstQueueArray, 1);\n@@ -119,1 +128,1 @@\n-  g_slice_free (GstQueueArray, array);\n+  g_free (array);\n@@ -434,0 +443,206 @@\n+\/* Moves all elements in the queue placed after the given position in the internal array *\/\n+static void\n+gst_queue_array_move_data_after_position (GstQueueArray * array, guint pos)\n+{\n+  guint elt_size = array->elt_size;\n+\n+  \/* If the array does not wrap around OR if it does, but we're inserting past that point *\/\n+  if (array->head < array->tail ||\n+      (array->head >= array->tail && pos < array->head)) {\n+    memmove (array->array + (pos + 1) * elt_size, array->array + pos * elt_size,\n+        (array->tail - pos) * elt_size);\n+    return;\n+  }\n+\n+  \/* Otherwise, array wraps around and we're inserting before the breaking point.\n+   * First, move everything past that point by one place. *\/\n+  memmove (array->array + elt_size, array->array, array->tail * elt_size);\n+\n+  \/* Then move the last element from before the wrap-around point to right after it. *\/\n+  memcpy (array->array, array->array + (array->size - 1) * elt_size, elt_size);\n+\n+  \/* If we're inserting right before the breaking point, no further action is needed.\n+   * Otherwise, move data between insertion point and the breaking point by one place. *\/\n+  if (pos != array->size - 1) {\n+    memmove (array->array + (pos + 1) * elt_size, array->array + pos * elt_size,\n+        (array->size - pos - 1) * elt_size);\n+  }\n+}\n+\n+\/**\n+ * gst_queue_array_push_sorted: (skip)\n+ * @array: a #GstQueueArray object\n+ * @data: object to push\n+ * @func: comparison function\n+ * @user_data: (nullable): data for comparison function\n+ *\n+ * Pushes @data to the queue @array, finding the correct position\n+ * by comparing @data with each array element using @func.\n+ *\n+ * This has a time complexity of O(n), so depending on the size of the queue\n+ * and expected access patterns, a different data structure might be better.\n+ *\n+ * Assumes that the array is already sorted. If it is not, make sure\n+ * to call gst_queue_array_sort() first.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_queue_array_push_sorted (GstQueueArray * array, gpointer data,\n+    GCompareDataFunc func, gpointer user_data)\n+{\n+  guint i;\n+  gpointer *p_element;\n+\n+  g_return_if_fail (array != NULL);\n+  g_return_if_fail (func != NULL);\n+\n+  \/* Check if we need to make room *\/\n+  if (G_UNLIKELY (array->length == array->size))\n+    gst_queue_array_do_expand (array);\n+\n+  \/* Compare against each element, assuming they're already sorted *\/\n+  for (i = 0; i < array->length; i++) {\n+    p_element = (gpointer *) gst_queue_array_idx (array, i);\n+\n+    if (func (*p_element, data, user_data) > 0) {\n+      guint pos = (array->head + i) % array->size;\n+      gst_queue_array_move_data_after_position (array, pos);\n+\n+      *p_element = data;\n+      goto finish;\n+    }\n+  }\n+\n+  \/* No 'bigger' element found - append to tail *\/\n+  *(gpointer *) (array->array + array->elt_size * array->tail) = data;\n+\n+finish:\n+  array->tail++;\n+  array->tail %= array->size;\n+  array->length++;\n+}\n+\n+\/**\n+ * gst_queue_array_push_sorted_struct: (skip)\n+ * @array: a #GstQueueArray object\n+ * @p_struct: address of element or structure to push into the queue\n+ * @func: comparison function\n+ * @user_data: (nullable): data for comparison function\n+ *\n+ * Pushes the element at address @p_struct into the queue @array\n+ * (copying the contents of a structure of the struct_size specified\n+ * when creating the queue into the array), finding the correct position\n+ * by comparing the element at @p_struct with each element in the array using @func.\n+ *\n+ * This has a time complexity of O(n), so depending on the size of the queue\n+ * and expected access patterns, a different data structure might be better.\n+ *\n+ * Assumes that the array is already sorted. If it is not, make sure\n+ * to call gst_queue_array_sort() first.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_queue_array_push_sorted_struct (GstQueueArray * array, gpointer p_struct,\n+    GCompareDataFunc func, gpointer user_data)\n+{\n+  guint i;\n+  gpointer p_element;\n+\n+  g_return_if_fail (array != NULL);\n+  g_return_if_fail (p_struct != NULL);\n+  g_return_if_fail (func != NULL);\n+\n+  \/* Check if we need to make room *\/\n+  if (G_UNLIKELY (array->length == array->size))\n+    gst_queue_array_do_expand (array);\n+\n+  \/* Compare against each element, assuming they're already sorted *\/\n+  for (i = 0; i < array->length; i++) {\n+    p_element = gst_queue_array_idx (array, i);\n+\n+    if (func (p_element, p_struct, user_data) > 0) {\n+      guint pos = (array->head + i) % array->size;\n+      gst_queue_array_move_data_after_position (array, pos);\n+\n+      memcpy (p_element, p_struct, array->elt_size);\n+      goto finish;\n+    }\n+  }\n+\n+  \/* No 'bigger' element found - append to tail *\/\n+  memcpy (array->array + array->elt_size * array->tail, p_struct,\n+      array->elt_size);\n+\n+finish:\n+  array->tail++;\n+  array->tail %= array->size;\n+  array->length++;\n+}\n+\n+static int\n+compare_wrapper (gpointer * a, gpointer * b, QueueSortData * sort_data)\n+{\n+  return sort_data->func (*a, *b, sort_data->user_data);\n+}\n+\n+\/**\n+ * gst_queue_array_sort: (skip)\n+ * @array: a #GstQueueArray object\n+ * @compare_func: comparison function\n+ * @user_data: (nullable): data for comparison function\n+ *\n+ * Sorts the queue @array by comparing elements against each other using\n+ * the provided @compare_func.\n+ *\n+ * Since: 1.24\n+ *\/\n+void\n+gst_queue_array_sort (GstQueueArray * array, GCompareDataFunc compare_func,\n+    gpointer user_data)\n+{\n+  g_return_if_fail (array != NULL);\n+  g_return_if_fail (compare_func != NULL);\n+\n+  if (array->length == 0)\n+    return;\n+\n+  \/* To be able to use g_qsort_with_data, we might need to rearrange:\n+   * [0-----TAIL][HEAD-----SIZE] -> [HEAD-------TAIL] *\/\n+  if (array->head >= array->tail) {\n+    gsize t1 = array->head;\n+    gsize t2 = array->size - array->head;\n+    gsize elt_size = array->elt_size;\n+\n+    \/* Copy [0-------TAIL] part to a temporary buffer *\/\n+    guint8 *tmp = g_malloc0_n (t1, elt_size);\n+    memcpy (tmp, array->array, t1 * elt_size);\n+\n+    \/* Move [HEAD-----SIZE] part to the beginning of the original array *\/\n+    memmove (array->array, array->array + (elt_size * array->head),\n+        t2 * elt_size);\n+\n+    \/* Copy the temporary buffer to the end of the original array *\/\n+    memmove (array->array + (t2 * elt_size), tmp, t1 * elt_size);\n+    g_free (tmp);\n+\n+    array->head = 0;\n+    array->tail = array->length % array->size;\n+  }\n+\n+  if (array->struct_array) {\n+    g_qsort_with_data (array->array +\n+        (array->head % array->size) * array->elt_size, array->length,\n+        array->elt_size, compare_func, user_data);\n+  } else {\n+    \/* For non-struct arrays, we need to wrap the provided compare function\n+     * to dereference our pointers before passing them for comparison.\n+     * This matches the behaviour of gst_queue_array_find(). *\/\n+    QueueSortData sort_data = { compare_func, user_data };\n+    g_qsort_with_data (array->array +\n+        (array->head % array->size) * array->elt_size, array->length,\n+        array->elt_size, (GCompareDataFunc) compare_wrapper, &sort_data);\n+  }\n+}\n+\n@@ -721,1 +936,1 @@\n- * @func: (allow-none): comparison function, or %NULL to find @data by value\n+ * @func: (nullable): comparison function, or %NULL to find @data by value\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstqueuearray.c","additions":218,"deletions":3,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -107,0 +107,17 @@\n+GST_BASE_API\n+void            gst_queue_array_push_sorted (GstQueueArray * array,\n+                                             gpointer data,\n+                                             GCompareDataFunc func,\n+                                             gpointer user_data);\n+\n+GST_BASE_API\n+void            gst_queue_array_push_sorted_struct (GstQueueArray * array,\n+                                                    gpointer p_struct,\n+                                                    GCompareDataFunc func,\n+                                                    gpointer user_data);\n+\n+GST_BASE_API\n+void            gst_queue_array_sort (GstQueueArray *array,\n+                                      GCompareDataFunc compare_func,\n+                                      gpointer user_data);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstqueuearray.h","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-  bmap = g_slice_new0 (GstMappedBuffer);\n+  bmap = g_new0 (GstMappedBuffer, 1);\n@@ -213,1 +213,1 @@\n-    g_slice_free (GstMappedBuffer, bmap);\n+    g_free (bmap);\n@@ -439,1 +439,1 @@\n-    g_slice_free (GstMappedBuffer, bmap);\n+    g_free (bmap);\n@@ -731,1 +731,0 @@\n-  GstTypeFindFactory *factory;\n@@ -734,1 +733,1 @@\n-  GstTypeFindProbability found_probability, last_found_probability;\n+  GstTypeFindProbability last_found_probability;\n@@ -750,1 +749,0 @@\n-  found_probability = GST_TYPE_FIND_NONE;\n@@ -754,1 +752,2 @@\n-    factory = GST_TYPE_FIND_FACTORY (l->data);\n+    GstTypeFindProbability found_probability;\n+    GstTypeFindFactory *factory = GST_TYPE_FIND_FACTORY (l->data);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gsttypefindhelper.c","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -610,7 +610,7 @@\n-  (GstControlSourceGetValue) interpolate_none_get,\n-        (GstControlSourceGetValueArray) interpolate_none_get_value_array}, {\n-  (GstControlSourceGetValue) interpolate_linear_get,\n-        (GstControlSourceGetValueArray) interpolate_linear_get_value_array}, {\n-  (GstControlSourceGetValue) interpolate_cubic_get,\n-        (GstControlSourceGetValueArray) interpolate_cubic_get_value_array}, {\n-    (GstControlSourceGetValue) interpolate_cubic_monotonic_get,\n+        (GstControlSourceGetValue) interpolate_none_get,\n+      (GstControlSourceGetValueArray) interpolate_none_get_value_array}, {\n+        (GstControlSourceGetValue) interpolate_linear_get,\n+      (GstControlSourceGetValueArray) interpolate_linear_get_value_array}, {\n+        (GstControlSourceGetValue) interpolate_cubic_get,\n+      (GstControlSourceGetValueArray) interpolate_cubic_get_value_array}, {\n+        (GstControlSourceGetValue) interpolate_cubic_monotonic_get,\n@@ -618,1 +618,2 @@\n-interpolate_cubic_monotonic_get_value_array}};\n+      interpolate_cubic_monotonic_get_value_array}\n+};\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/controller\/gstinterpolationcontrolsource.c","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -355,10 +355,10 @@\n-  (GstControlSourceGetValue) waveform_sine_get,\n-        (GstControlSourceGetValueArray) waveform_sine_get_value_array}, {\n-  (GstControlSourceGetValue) waveform_square_get,\n-        (GstControlSourceGetValueArray) waveform_square_get_value_array}, {\n-  (GstControlSourceGetValue) waveform_saw_get,\n-        (GstControlSourceGetValueArray) waveform_saw_get_value_array}, {\n-  (GstControlSourceGetValue) waveform_rsaw_get,\n-        (GstControlSourceGetValueArray) waveform_rsaw_get_value_array}, {\n-  (GstControlSourceGetValue) waveform_triangle_get,\n-        (GstControlSourceGetValueArray) waveform_triangle_get_value_array}\n+        (GstControlSourceGetValue) waveform_sine_get,\n+      (GstControlSourceGetValueArray) waveform_sine_get_value_array}, {\n+        (GstControlSourceGetValue) waveform_square_get,\n+      (GstControlSourceGetValueArray) waveform_square_get_value_array}, {\n+        (GstControlSourceGetValue) waveform_saw_get,\n+      (GstControlSourceGetValueArray) waveform_saw_get_value_array}, {\n+        (GstControlSourceGetValue) waveform_rsaw_get,\n+      (GstControlSourceGetValueArray) waveform_rsaw_get_value_array}, {\n+        (GstControlSourceGetValue) waveform_triangle_get,\n+      (GstControlSourceGetValueArray) waveform_triangle_get_value_array}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/controller\/gstlfocontrolsource.c","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  g_slice_free (GstControlPoint, cp);\n+  g_free (cp);\n@@ -95,1 +95,1 @@\n-  return g_slice_dup (GstControlPoint, cp);\n+  return g_memdup2 (cp, sizeof (GstControlPoint));\n@@ -174,1 +174,1 @@\n-  cp = g_slice_new0 (GstControlPoint);\n+  cp = g_new0 (GstControlPoint, 1);\n@@ -346,1 +346,1 @@\n-    cp = g_slice_dup (GstControlPoint, g_sequence_get (iter));\n+    cp = g_memdup2 (g_sequence_get (iter), sizeof (GstControlPoint));\n@@ -357,1 +357,1 @@\n-    g_slice_free (GstControlPoint, cp);\n+    g_free (cp);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/controller\/gsttimedvaluecontrolsource.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+  queue->sink_start_time = GST_CLOCK_STIME_NONE;\n@@ -483,2 +484,2 @@\n-  queue->sink_tainted = TRUE;\n-  queue->src_tainted = TRUE;\n+  queue->sink_tainted = FALSE;\n+  queue->src_tainted = FALSE;\n@@ -538,1 +539,1 @@\n-  gint64 sink_time, src_time;\n+  gint64 sink_time, src_time, sink_start_time;\n@@ -548,0 +549,1 @@\n+  sink_start_time = queue->sink_start_time;\n@@ -558,7 +560,17 @@\n-  GST_LOG_OBJECT (queue, \"sink %\" GST_STIME_FORMAT \", src %\" GST_STIME_FORMAT,\n-      GST_STIME_ARGS (sink_time), GST_STIME_ARGS (src_time));\n-\n-  if (GST_CLOCK_STIME_IS_VALID (src_time)\n-      && GST_CLOCK_STIME_IS_VALID (sink_time) && sink_time >= src_time)\n-    queue->cur_level.time = sink_time - src_time;\n-  else\n+  GST_LOG_OBJECT (queue, \"sink %\" GST_STIME_FORMAT \", src %\" GST_STIME_FORMAT\n+      \", sink-start-time %\" GST_STIME_FORMAT,\n+      GST_STIME_ARGS (sink_time), GST_STIME_ARGS (src_time),\n+      GST_STIME_ARGS (sink_start_time));\n+\n+  if (GST_CLOCK_STIME_IS_VALID (sink_time)) {\n+    if (!GST_CLOCK_STIME_IS_VALID (src_time) &&\n+        GST_CLOCK_STIME_IS_VALID (sink_start_time) &&\n+        sink_time >= sink_start_time) {\n+      \/* If we got input buffers but output thread didn't push any buffer yet *\/\n+      queue->cur_level.time = sink_time - sink_start_time;\n+    } else if (GST_CLOCK_STIME_IS_VALID (src_time) && sink_time >= src_time) {\n+      queue->cur_level.time = sink_time - src_time;\n+    } else {\n+      queue->cur_level.time = 0;\n+    }\n+  } else {\n@@ -566,0 +578,1 @@\n+  }\n@@ -568,2 +581,1 @@\n-\/* take a SEGMENT event and apply the values to segment, updating the time\n- * level of queue. *\/\n+\/* take a SEGMENT event and apply the values to segment *\/\n@@ -572,1 +584,1 @@\n-    gboolean sink)\n+    gboolean is_sink)\n@@ -586,4 +598,0 @@\n-  if (sink)\n-    queue->sink_tainted = TRUE;\n-  else\n-    queue->src_tainted = TRUE;\n@@ -591,1 +599,6 @@\n-  GST_DEBUG_OBJECT (queue, \"configured SEGMENT %\" GST_SEGMENT_FORMAT, segment);\n+  \/* Will be updated on buffer flows *\/\n+  if (is_sink) {\n+    queue->sink_tainted = FALSE;\n+  } else {\n+    queue->src_tainted = FALSE;\n+  }\n@@ -593,2 +606,1 @@\n-  \/* segment can update the time level of the queue *\/\n-  update_time_level (queue);\n+  GST_DEBUG_OBJECT (queue, \"configured SEGMENT %\" GST_SEGMENT_FORMAT, segment);\n@@ -606,1 +618,1 @@\n-  if (GST_CLOCK_TIME_IS_VALID (timestamp)) {\n+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (timestamp));\n@@ -608,3 +620,5 @@\n-    if (GST_CLOCK_TIME_IS_VALID (duration)) {\n-      timestamp += duration;\n-    }\n+  if (is_sink && !GST_CLOCK_STIME_IS_VALID (queue->sink_start_time)) {\n+    queue->sink_start_time = my_segment_to_running_time (segment, timestamp);\n+    GST_DEBUG_OBJECT (queue, \"Start time updated to %\" GST_STIME_FORMAT,\n+        GST_STIME_ARGS (queue->sink_start_time));\n+  }\n@@ -612,1 +626,3 @@\n-    segment->position = timestamp;\n+  if (GST_CLOCK_TIME_IS_VALID (duration)) {\n+    timestamp += duration;\n+  }\n@@ -614,4 +630,1 @@\n-    if (is_sink)\n-      queue->sink_tainted = TRUE;\n-    else\n-      queue->src_tainted = TRUE;\n+  segment->position = timestamp;\n@@ -619,3 +632,7 @@\n-    \/* calc diff with other end *\/\n-    update_time_level (queue);\n-  }\n+  if (is_sink)\n+    queue->sink_tainted = TRUE;\n+  else\n+    queue->src_tainted = TRUE;\n+\n+  \/* calc diff with other end *\/\n+  update_time_level (queue);\n@@ -628,1 +645,1 @@\n-    gboolean sink)\n+    gboolean is_sink)\n@@ -635,2 +652,2 @@\n-  \/* if no timestamp is set, assume it's continuous with the previous\n-   * time *\/\n+  \/* if no timestamp is set, assume it didn't change compared to the previous\n+   * buffer and simply return here *\/\n@@ -638,1 +655,8 @@\n-    timestamp = segment->position;\n+    return;\n+\n+  if (is_sink && !GST_CLOCK_STIME_IS_VALID (queue->sink_start_time) &&\n+      GST_CLOCK_TIME_IS_VALID (timestamp)) {\n+    queue->sink_start_time = my_segment_to_running_time (segment, timestamp);\n+    GST_DEBUG_OBJECT (queue, \"Start time updated to %\" GST_STIME_FORMAT,\n+        GST_STIME_ARGS (queue->sink_start_time));\n+  }\n@@ -645,2 +669,1 @@\n-      segment == &queue->sink_segment ? \"sink\" : \"src\",\n-      GST_TIME_ARGS (timestamp));\n+      is_sink ? \"sink\" : \"src\", GST_TIME_ARGS (timestamp));\n@@ -649,1 +672,1 @@\n-  if (sink)\n+  if (is_sink)\n@@ -654,1 +677,0 @@\n-\n@@ -659,0 +681,6 @@\n+typedef struct\n+{\n+  GstClockTime first_timestamp;\n+  GstClockTime timestamp;\n+} BufListData;\n+\n@@ -662,1 +690,1 @@\n-  GstClockTime *timestamp = user_data;\n+  BufListData *data = user_data;\n@@ -671,2 +699,6 @@\n-  if (GST_CLOCK_TIME_IS_VALID (btime))\n-    *timestamp = btime;\n+  if (GST_CLOCK_TIME_IS_VALID (btime)) {\n+    if (!GST_CLOCK_TIME_IS_VALID (data->first_timestamp))\n+      data->first_timestamp = btime;\n+\n+    data->timestamp = btime;\n+  }\n@@ -674,2 +706,3 @@\n-  if (GST_BUFFER_DURATION_IS_VALID (*buf))\n-    *timestamp += GST_BUFFER_DURATION (*buf);\n+  if (GST_BUFFER_DURATION_IS_VALID (*buf)\n+      && GST_CLOCK_TIME_IS_VALID (data->timestamp))\n+    data->timestamp += GST_BUFFER_DURATION (*buf);\n@@ -677,1 +710,1 @@\n-  GST_TRACE (\"ts now %\" GST_TIME_FORMAT, GST_TIME_ARGS (*timestamp));\n+  GST_TRACE (\"ts now %\" GST_TIME_FORMAT, GST_TIME_ARGS (data->timestamp));\n@@ -685,1 +718,1 @@\n-    GstSegment * segment, gboolean sink)\n+    GstSegment * segment, gboolean is_sink)\n@@ -687,1 +720,3 @@\n-  GstClockTime timestamp;\n+  BufListData data;\n+\n+  data.first_timestamp = GST_CLOCK_TIME_NONE;\n@@ -689,2 +724,3 @@\n-  \/* if no timestamp is set, assume it's continuous with the previous time *\/\n-  timestamp = segment->position;\n+  \/* if no timestamp is set, assume it didn't change compared to the previous\n+   * buffer and simply return here without updating *\/\n+  data.timestamp = GST_CLOCK_TIME_NONE;\n@@ -692,1 +728,12 @@\n-  gst_buffer_list_foreach (buffer_list, buffer_list_apply_time, &timestamp);\n+  gst_buffer_list_foreach (buffer_list, buffer_list_apply_time, &data);\n+\n+  if (!GST_CLOCK_TIME_IS_VALID (data.timestamp))\n+    return;\n+\n+  if (is_sink && !GST_CLOCK_STIME_IS_VALID (queue->sink_start_time) &&\n+      GST_CLOCK_TIME_IS_VALID (data.first_timestamp)) {\n+    queue->sink_start_time = my_segment_to_running_time (segment,\n+        data.first_timestamp);\n+    GST_DEBUG_OBJECT (queue, \"Start time updated to %\" GST_STIME_FORMAT,\n+        GST_STIME_ARGS (queue->sink_start_time));\n+  }\n@@ -695,1 +742,1 @@\n-      GST_TIME_ARGS (timestamp));\n+      GST_TIME_ARGS (data.timestamp));\n@@ -697,1 +744,1 @@\n-  segment->position = timestamp;\n+  segment->position = data.timestamp;\n@@ -699,1 +746,1 @@\n-  if (sink)\n+  if (is_sink)\n@@ -737,1 +784,2 @@\n-  queue->sink_tainted = queue->src_tainted = TRUE;\n+  queue->sink_start_time = GST_CLOCK_STIME_NONE;\n+  queue->sink_tainted = queue->src_tainted = FALSE;\n@@ -1586,1 +1634,5 @@\n-    if (ret == GST_FLOW_FLUSHING) {\n+\n+    \/* flush internal queue except for not-linked and eos\n+     * not-linked: reconfigure event will start srcpad task\n+     * eos: stream-start can clear eos and will start srcpad task again *\/\n+    if (ret != GST_FLOW_NOT_LINKED && ret != GST_FLOW_EOS) {\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/plugins\/elements\/gstqueue.c","additions":108,"deletions":56,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  GstClockTimeDiff sink_start_time;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/plugins\/elements\/gstqueue.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-  flush = ! !(flags & GST_SEEK_FLAG_FLUSH);\n+  flush = !!(flags & GST_SEEK_FLAG_FLUSH);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/plugins\/elements\/gsttypefindelement.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.22.6\"\n+#define PACKAGE_STRING \"GStreamer 1.24.6\"\n@@ -482,1 +482,1 @@\n-#define PACKAGE_VERSION \"1.22.6\"\n+#define PACKAGE_VERSION \"1.24.6\"\n@@ -522,1 +522,1 @@\n-#define VERSION \"1.22.6\"\n+#define VERSION \"1.24.6\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/linux\/common\/config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.22.6\"\n+#define PACKAGE_STRING \"GStreamer 1.24.6\"\n@@ -486,1 +486,1 @@\n-#define PACKAGE_VERSION \"1.22.6\"\n+#define PACKAGE_VERSION \"1.24.6\"\n@@ -526,1 +526,1 @@\n-#define VERSION \"1.22.6\"\n+#define VERSION \"1.24.6\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/osx\/common\/x86_64\/config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.22.6\"\n+#define PACKAGE_STRING \"GStreamer 1.24.6\"\n@@ -487,1 +487,1 @@\n-#define PACKAGE_VERSION \"1.22.6\"\n+#define PACKAGE_VERSION \"1.24.6\"\n@@ -527,1 +527,1 @@\n-#define VERSION \"1.22.6\"\n+#define VERSION \"1.24.6\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/win32\/common\/config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-          gstreamer\/gst\/gstpluginloader.c \\\n@@ -175,0 +174,1 @@\n+          gst-plugins-base\/gst-libs\/gst\/app\/gstapputils.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/linux\/gstreamer-lite\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+            glib\/gdatetime-private.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/mac\/glib-lite\/Makefile","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-            gstreamer\/gst\/gstpluginloader.c \\\n@@ -170,0 +169,1 @@\n+            gst-plugins-base\/gst-libs\/gst\/app\/gstapputils.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/mac\/gstreamer-lite\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+        gdatetime-private.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/glib-lite\/Makefile.glib","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-            gstreamer\/gst\/gstpluginloader.c \\\n@@ -109,0 +108,1 @@\n+            gst-plugins-base\/gst-libs\/gst\/app\/gstapputils.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/gstreamer-lite\/Makefile.gstreamer","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+    <\/ClCompile>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\3rd_party\\glib\\glib\\gdatetime-private.c\">\r\n+      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">WIN32;_WINDOWS;_USRDLL;GLIB_COMPILATION;GSTREAMER_LITE;HAVE_CONFIG_H;G_LOG_DOMAIN=\\\"Glib\\\";G_DISABLE_DEPRECATED;PCRE_STATIC;LINK_SIZE=2;MAX_NAME_SIZE=32;MAX_NAME_COUNT=10000;NEWLINE=-1;POSIX_MALLOC_THRESHOLD=10;MATCH_LIMIT=10000000;MATCH_LIMIT_RECURSION=10000000;HAVE_LONG_LONG;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/glib\/glib.vcxproj","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\3rd_party\\glib\\glib\\gdatetime-private.c\" \/>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/glib\/glib.vcxproj.filters","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -14,12 +14,5 @@\n-    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-bad\\gst\\aiff\\aiff.c\">\r\n-      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">WIN32;_WINDOWS;LIBGSTELEMENTS_EXPORTS;HAVE_CONFIG_H;_WIN32_DCOM;COBJMACROS;GSTREAMER_LITE;GST_REMOVE_DEPRECATED;GST_DISABLE_GST_DEBUG;GST_DISABLE_LOADSAVE;_USE_MATH_DEFINES;_USRDLL;_WINDLL;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n-    <\/ClCompile>\r\n-    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-bad\\gst\\aiff\\aiffparse.c\">\r\n-      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">WIN32;_WINDOWS;LIBGSTELEMENTS_EXPORTS;HAVE_CONFIG_H;_WIN32_DCOM;COBJMACROS;GSTREAMER_LITE;GST_REMOVE_DEPRECATED;GST_DISABLE_GST_DEBUG;GST_DISABLE_LOADSAVE;_USE_MATH_DEFINES;_USRDLL;_WINDLL;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n-    <\/ClCompile>\r\n-    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\app\\gstappbuffer.c\">\r\n-      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">LIBGSTREAMER_EXPORTS;HAVE_CONFIG_H;HAVE_WIN32;LIBDSHOW_EXPORTS;GSTREAMER_LITE;GST_REMOVE_DEPRECATED;GST_REMOVE_DISABLED;GST_DISABLE_GST_DEBUG;GST_DISABLE_LOADSAVE;_USE_MATH_DEFINES;_USRDLL;_WINDLL;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n-    <\/ClCompile>\r\n-    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\app\\gstappsink.c\">\r\n-      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">LIBGSTREAMER_EXPORTS;HAVE_CONFIG_H;HAVE_WIN32;LIBDSHOW_EXPORTS;GSTREAMER_LITE;GST_REMOVE_DEPRECATED;GST_REMOVE_DISABLED;GST_DISABLE_GST_DEBUG;GST_DISABLE_LOADSAVE;_USE_MATH_DEFINES;_USRDLL;_WINDLL;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n-    <\/ClCompile>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-bad\\gst\\aiff\\aiff.c\" \/>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-bad\\gst\\aiff\\aiffparse.c\" \/>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\app\\gstappbuffer.c\" \/>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\app\\gstappsink.c\" \/>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\app\\gstapputils.c\" \/>\r\n@@ -331,3 +324,0 @@\n-    <\/ClCompile>\r\n-    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gstreamer\\gst\\gstpluginloader.c\">\r\n-      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">WIN32;_WINDOWS;LIBGSTREAMER_EXPORTS;HAVE_CONFIG_H;HAVE_WIN32;LIBDSHOW_EXPORTS;GSTREAMER_LITE;GST_REMOVE_DEPRECATED;GST_REMOVE_DISABLED;GST_DISABLE_GST_DEBUG;GST_DISABLE_LOADSAVE;_USE_MATH_DEFINES;_USRDLL;_WINDLL;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/gstreamer\/gstreamer.vcxproj","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -219,3 +219,0 @@\n-    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gstreamer\\gst\\gstpluginloader.c\">\r\n-      <Filter>gstreamer\\gst<\/Filter>\r\n-    <\/ClCompile>\r\n@@ -326,0 +323,3 @@\n+    <\/ClCompile>\r\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\app\\gstapputils.c\">\r\n+      <Filter>gst-plugins-base\\gst-libs\\gst\\app<\/Filter>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/gstreamer\/gstreamer.vcxproj.filters","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}