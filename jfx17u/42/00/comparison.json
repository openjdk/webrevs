{"files":[{"patch":"@@ -0,0 +1,26 @@\n+Updating SQLite in OpenJFX:\n+\n+1. Find the current version of the SQLite used in JavaFX from VERSION.txt\n+\n+2. Check if there are any JavaFX specific changes in SQLite source:\n+    - Compare the SQLite source files from JavaFX workspace with the source files\n+      corresponding to same version on https:\/\/www.sqlite.org\/index.html\n+    - Currently there are no JavaFX specific changes made in SQLite source.\n+      In case you find any changes make sure to retain them with update.\n+\n+3. Get the source code of required release version of SQLite.\n+    - Download the amalgamation code for the release from https:\/\/www.sqlite.org\n+       - For example, the SQLite 3.37.2 amalgamation is named as \"sqlite-amalgamation-3370200.zip\".\n+    - FYI about amalgamation:\n+      - The amalgamation contains everything a library may need to include SQLite.\n+      - Over 100 separate source files are concatenated into a single large C file\n+        named \"sqlite3.c\" and referred as \"the amalgamation\".\n+\n+4. Update the SQLite source files in JavaFX from the downloaded amalgamation source.\n+    - Retain JavaFX changes, if any.\n+\n+5. Update the new version in VERSION.txt.\n+\n+6. Perform build and sanity testing.\n+\n+7. Expand tabs and remove trailing white spaces from source files.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/UPDATING.txt","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-3.32.3\n+3.37.2\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/VERSION.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-** version 3.32.3.  By combining all the individual C code files into this\n+** version 3.37.2.  By combining all the individual C code files into this\n@@ -25,765 +25,0 @@\n-\/************** Begin file ctime.c *******************************************\/\n-\/*\n-** 2010 February 23\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-*************************************************************************\n-**\n-** This file implements routines used to report what compile-time options\n-** SQLite was built with.\n-*\/\n-\n-#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS \/* IMP: R-16824-07538 *\/\n-\n-\/*\n-** Include the configuration header output by 'configure' if we're using the\n-** autoconf-based build\n-*\/\n-#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)\n-#include \"config.h\"\n-#define SQLITECONFIG_H 1\n-#endif\n-\n-\/* These macros are provided to \"stringify\" the value of the define\n-** for those options in which the value is meaningful. *\/\n-#define CTIMEOPT_VAL_(opt) #opt\n-#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)\n-\n-\/* Like CTIMEOPT_VAL, but especially for SQLITE_DEFAULT_LOOKASIDE. This\n-** option requires a separate macro because legal values contain a single\n-** comma. e.g. (-DSQLITE_DEFAULT_LOOKASIDE=\"100,100\") *\/\n-#define CTIMEOPT_VAL2_(opt1,opt2) #opt1 \",\" #opt2\n-#define CTIMEOPT_VAL2(opt) CTIMEOPT_VAL2_(opt)\n-\n-\/*\n-** An array of names of all compile-time options.  This array should\n-** be sorted A-Z.\n-**\n-** This array looks large, but in a typical installation actually uses\n-** only a handful of compile-time options, so most times this array is usually\n-** rather short and uses little memory space.\n-*\/\n-static const char * const sqlite3azCompileOpt[] = {\n-\n-\/*\n-** BEGIN CODE GENERATED BY tool\/mkctime.tcl\n-*\/\n-#if SQLITE_32BIT_ROWID\n-  \"32BIT_ROWID\",\n-#endif\n-#if SQLITE_4_BYTE_ALIGNED_MALLOC\n-  \"4_BYTE_ALIGNED_MALLOC\",\n-#endif\n-#if SQLITE_64BIT_STATS\n-  \"64BIT_STATS\",\n-#endif\n-#if SQLITE_ALLOW_COVERING_INDEX_SCAN\n-  \"ALLOW_COVERING_INDEX_SCAN\",\n-#endif\n-#if SQLITE_ALLOW_URI_AUTHORITY\n-  \"ALLOW_URI_AUTHORITY\",\n-#endif\n-#ifdef SQLITE_BITMASK_TYPE\n-  \"BITMASK_TYPE=\" CTIMEOPT_VAL(SQLITE_BITMASK_TYPE),\n-#endif\n-#if SQLITE_BUG_COMPATIBLE_20160819\n-  \"BUG_COMPATIBLE_20160819\",\n-#endif\n-#if SQLITE_CASE_SENSITIVE_LIKE\n-  \"CASE_SENSITIVE_LIKE\",\n-#endif\n-#if SQLITE_CHECK_PAGES\n-  \"CHECK_PAGES\",\n-#endif\n-#if defined(__clang__) && defined(__clang_major__)\n-  \"COMPILER=clang-\" CTIMEOPT_VAL(__clang_major__) \".\"\n-                    CTIMEOPT_VAL(__clang_minor__) \".\"\n-                    CTIMEOPT_VAL(__clang_patchlevel__),\n-#elif defined(_MSC_VER)\n-  \"COMPILER=msvc-\" CTIMEOPT_VAL(_MSC_VER),\n-#elif defined(__GNUC__) && defined(__VERSION__)\n-  \"COMPILER=gcc-\" __VERSION__,\n-#endif\n-#if SQLITE_COVERAGE_TEST\n-  \"COVERAGE_TEST\",\n-#endif\n-#if SQLITE_DEBUG\n-  \"DEBUG\",\n-#endif\n-#if SQLITE_DEFAULT_AUTOMATIC_INDEX\n-  \"DEFAULT_AUTOMATIC_INDEX\",\n-#endif\n-#if SQLITE_DEFAULT_AUTOVACUUM\n-  \"DEFAULT_AUTOVACUUM\",\n-#endif\n-#ifdef SQLITE_DEFAULT_CACHE_SIZE\n-  \"DEFAULT_CACHE_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_CACHE_SIZE),\n-#endif\n-#if SQLITE_DEFAULT_CKPTFULLFSYNC\n-  \"DEFAULT_CKPTFULLFSYNC\",\n-#endif\n-#ifdef SQLITE_DEFAULT_FILE_FORMAT\n-  \"DEFAULT_FILE_FORMAT=\" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_FORMAT),\n-#endif\n-#ifdef SQLITE_DEFAULT_FILE_PERMISSIONS\n-  \"DEFAULT_FILE_PERMISSIONS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_PERMISSIONS),\n-#endif\n-#if SQLITE_DEFAULT_FOREIGN_KEYS\n-  \"DEFAULT_FOREIGN_KEYS\",\n-#endif\n-#ifdef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT\n-  \"DEFAULT_JOURNAL_SIZE_LIMIT=\" CTIMEOPT_VAL(SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT),\n-#endif\n-#ifdef SQLITE_DEFAULT_LOCKING_MODE\n-  \"DEFAULT_LOCKING_MODE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),\n-#endif\n-#ifdef SQLITE_DEFAULT_LOOKASIDE\n-  \"DEFAULT_LOOKASIDE=\" CTIMEOPT_VAL2(SQLITE_DEFAULT_LOOKASIDE),\n-#endif\n-#if SQLITE_DEFAULT_MEMSTATUS\n-  \"DEFAULT_MEMSTATUS\",\n-#endif\n-#ifdef SQLITE_DEFAULT_MMAP_SIZE\n-  \"DEFAULT_MMAP_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),\n-#endif\n-#ifdef SQLITE_DEFAULT_PAGE_SIZE\n-  \"DEFAULT_PAGE_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_PAGE_SIZE),\n-#endif\n-#ifdef SQLITE_DEFAULT_PCACHE_INITSZ\n-  \"DEFAULT_PCACHE_INITSZ=\" CTIMEOPT_VAL(SQLITE_DEFAULT_PCACHE_INITSZ),\n-#endif\n-#ifdef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS\n-  \"DEFAULT_PROXYDIR_PERMISSIONS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_PROXYDIR_PERMISSIONS),\n-#endif\n-#if SQLITE_DEFAULT_RECURSIVE_TRIGGERS\n-  \"DEFAULT_RECURSIVE_TRIGGERS\",\n-#endif\n-#ifdef SQLITE_DEFAULT_ROWEST\n-  \"DEFAULT_ROWEST=\" CTIMEOPT_VAL(SQLITE_DEFAULT_ROWEST),\n-#endif\n-#ifdef SQLITE_DEFAULT_SECTOR_SIZE\n-  \"DEFAULT_SECTOR_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_SECTOR_SIZE),\n-#endif\n-#ifdef SQLITE_DEFAULT_SYNCHRONOUS\n-  \"DEFAULT_SYNCHRONOUS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_SYNCHRONOUS),\n-#endif\n-#ifdef SQLITE_DEFAULT_WAL_AUTOCHECKPOINT\n-  \"DEFAULT_WAL_AUTOCHECKPOINT=\" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_AUTOCHECKPOINT),\n-#endif\n-#ifdef SQLITE_DEFAULT_WAL_SYNCHRONOUS\n-  \"DEFAULT_WAL_SYNCHRONOUS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_SYNCHRONOUS),\n-#endif\n-#ifdef SQLITE_DEFAULT_WORKER_THREADS\n-  \"DEFAULT_WORKER_THREADS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_WORKER_THREADS),\n-#endif\n-#if SQLITE_DIRECT_OVERFLOW_READ\n-  \"DIRECT_OVERFLOW_READ\",\n-#endif\n-#if SQLITE_DISABLE_DIRSYNC\n-  \"DISABLE_DIRSYNC\",\n-#endif\n-#if SQLITE_DISABLE_FTS3_UNICODE\n-  \"DISABLE_FTS3_UNICODE\",\n-#endif\n-#if SQLITE_DISABLE_FTS4_DEFERRED\n-  \"DISABLE_FTS4_DEFERRED\",\n-#endif\n-#if SQLITE_DISABLE_INTRINSIC\n-  \"DISABLE_INTRINSIC\",\n-#endif\n-#if SQLITE_DISABLE_LFS\n-  \"DISABLE_LFS\",\n-#endif\n-#if SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS\n-  \"DISABLE_PAGECACHE_OVERFLOW_STATS\",\n-#endif\n-#if SQLITE_DISABLE_SKIPAHEAD_DISTINCT\n-  \"DISABLE_SKIPAHEAD_DISTINCT\",\n-#endif\n-#ifdef SQLITE_ENABLE_8_3_NAMES\n-  \"ENABLE_8_3_NAMES=\" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),\n-#endif\n-#if SQLITE_ENABLE_API_ARMOR\n-  \"ENABLE_API_ARMOR\",\n-#endif\n-#if SQLITE_ENABLE_ATOMIC_WRITE\n-  \"ENABLE_ATOMIC_WRITE\",\n-#endif\n-#if SQLITE_ENABLE_BATCH_ATOMIC_WRITE\n-  \"ENABLE_BATCH_ATOMIC_WRITE\",\n-#endif\n-#if SQLITE_ENABLE_BYTECODE_VTAB\n-  \"ENABLE_BYTECODE_VTAB\",\n-#endif\n-#if SQLITE_ENABLE_CEROD\n-  \"ENABLE_CEROD=\" CTIMEOPT_VAL(SQLITE_ENABLE_CEROD),\n-#endif\n-#if SQLITE_ENABLE_COLUMN_METADATA\n-  \"ENABLE_COLUMN_METADATA\",\n-#endif\n-#if SQLITE_ENABLE_COLUMN_USED_MASK\n-  \"ENABLE_COLUMN_USED_MASK\",\n-#endif\n-#if SQLITE_ENABLE_COSTMULT\n-  \"ENABLE_COSTMULT\",\n-#endif\n-#if SQLITE_ENABLE_CURSOR_HINTS\n-  \"ENABLE_CURSOR_HINTS\",\n-#endif\n-#if SQLITE_ENABLE_DBSTAT_VTAB\n-  \"ENABLE_DBSTAT_VTAB\",\n-#endif\n-#if SQLITE_ENABLE_EXPENSIVE_ASSERT\n-  \"ENABLE_EXPENSIVE_ASSERT\",\n-#endif\n-#if SQLITE_ENABLE_FTS1\n-  \"ENABLE_FTS1\",\n-#endif\n-#if SQLITE_ENABLE_FTS2\n-  \"ENABLE_FTS2\",\n-#endif\n-#if SQLITE_ENABLE_FTS3\n-  \"ENABLE_FTS3\",\n-#endif\n-#if SQLITE_ENABLE_FTS3_PARENTHESIS\n-  \"ENABLE_FTS3_PARENTHESIS\",\n-#endif\n-#if SQLITE_ENABLE_FTS3_TOKENIZER\n-  \"ENABLE_FTS3_TOKENIZER\",\n-#endif\n-#if SQLITE_ENABLE_FTS4\n-  \"ENABLE_FTS4\",\n-#endif\n-#if SQLITE_ENABLE_FTS5\n-  \"ENABLE_FTS5\",\n-#endif\n-#if SQLITE_ENABLE_GEOPOLY\n-  \"ENABLE_GEOPOLY\",\n-#endif\n-#if SQLITE_ENABLE_HIDDEN_COLUMNS\n-  \"ENABLE_HIDDEN_COLUMNS\",\n-#endif\n-#if SQLITE_ENABLE_ICU\n-  \"ENABLE_ICU\",\n-#endif\n-#if SQLITE_ENABLE_IOTRACE\n-  \"ENABLE_IOTRACE\",\n-#endif\n-#if SQLITE_ENABLE_JSON1\n-  \"ENABLE_JSON1\",\n-#endif\n-#if SQLITE_ENABLE_LOAD_EXTENSION\n-  \"ENABLE_LOAD_EXTENSION\",\n-#endif\n-#ifdef SQLITE_ENABLE_LOCKING_STYLE\n-  \"ENABLE_LOCKING_STYLE=\" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),\n-#endif\n-#if SQLITE_ENABLE_MEMORY_MANAGEMENT\n-  \"ENABLE_MEMORY_MANAGEMENT\",\n-#endif\n-#if SQLITE_ENABLE_MEMSYS3\n-  \"ENABLE_MEMSYS3\",\n-#endif\n-#if SQLITE_ENABLE_MEMSYS5\n-  \"ENABLE_MEMSYS5\",\n-#endif\n-#if SQLITE_ENABLE_MULTIPLEX\n-  \"ENABLE_MULTIPLEX\",\n-#endif\n-#if SQLITE_ENABLE_NORMALIZE\n-  \"ENABLE_NORMALIZE\",\n-#endif\n-#if SQLITE_ENABLE_NULL_TRIM\n-  \"ENABLE_NULL_TRIM\",\n-#endif\n-#if SQLITE_ENABLE_OVERSIZE_CELL_CHECK\n-  \"ENABLE_OVERSIZE_CELL_CHECK\",\n-#endif\n-#if SQLITE_ENABLE_PREUPDATE_HOOK\n-  \"ENABLE_PREUPDATE_HOOK\",\n-#endif\n-#if SQLITE_ENABLE_QPSG\n-  \"ENABLE_QPSG\",\n-#endif\n-#if SQLITE_ENABLE_RBU\n-  \"ENABLE_RBU\",\n-#endif\n-#if SQLITE_ENABLE_RTREE\n-  \"ENABLE_RTREE\",\n-#endif\n-#if SQLITE_ENABLE_SELECTTRACE\n-  \"ENABLE_SELECTTRACE\",\n-#endif\n-#if SQLITE_ENABLE_SESSION\n-  \"ENABLE_SESSION\",\n-#endif\n-#if SQLITE_ENABLE_SNAPSHOT\n-  \"ENABLE_SNAPSHOT\",\n-#endif\n-#if SQLITE_ENABLE_SORTER_REFERENCES\n-  \"ENABLE_SORTER_REFERENCES\",\n-#endif\n-#if SQLITE_ENABLE_SQLLOG\n-  \"ENABLE_SQLLOG\",\n-#endif\n-#if defined(SQLITE_ENABLE_STAT4)\n-  \"ENABLE_STAT4\",\n-#endif\n-#if SQLITE_ENABLE_STMTVTAB\n-  \"ENABLE_STMTVTAB\",\n-#endif\n-#if SQLITE_ENABLE_STMT_SCANSTATUS\n-  \"ENABLE_STMT_SCANSTATUS\",\n-#endif\n-#if SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n-  \"ENABLE_UNKNOWN_SQL_FUNCTION\",\n-#endif\n-#if SQLITE_ENABLE_UNLOCK_NOTIFY\n-  \"ENABLE_UNLOCK_NOTIFY\",\n-#endif\n-#if SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n-  \"ENABLE_UPDATE_DELETE_LIMIT\",\n-#endif\n-#if SQLITE_ENABLE_URI_00_ERROR\n-  \"ENABLE_URI_00_ERROR\",\n-#endif\n-#if SQLITE_ENABLE_VFSTRACE\n-  \"ENABLE_VFSTRACE\",\n-#endif\n-#if SQLITE_ENABLE_WHERETRACE\n-  \"ENABLE_WHERETRACE\",\n-#endif\n-#if SQLITE_ENABLE_ZIPVFS\n-  \"ENABLE_ZIPVFS\",\n-#endif\n-#if SQLITE_EXPLAIN_ESTIMATED_ROWS\n-  \"EXPLAIN_ESTIMATED_ROWS\",\n-#endif\n-#if SQLITE_EXTRA_IFNULLROW\n-  \"EXTRA_IFNULLROW\",\n-#endif\n-#ifdef SQLITE_EXTRA_INIT\n-  \"EXTRA_INIT=\" CTIMEOPT_VAL(SQLITE_EXTRA_INIT),\n-#endif\n-#ifdef SQLITE_EXTRA_SHUTDOWN\n-  \"EXTRA_SHUTDOWN=\" CTIMEOPT_VAL(SQLITE_EXTRA_SHUTDOWN),\n-#endif\n-#ifdef SQLITE_FTS3_MAX_EXPR_DEPTH\n-  \"FTS3_MAX_EXPR_DEPTH=\" CTIMEOPT_VAL(SQLITE_FTS3_MAX_EXPR_DEPTH),\n-#endif\n-#if SQLITE_FTS5_ENABLE_TEST_MI\n-  \"FTS5_ENABLE_TEST_MI\",\n-#endif\n-#if SQLITE_FTS5_NO_WITHOUT_ROWID\n-  \"FTS5_NO_WITHOUT_ROWID\",\n-#endif\n-#if HAVE_ISNAN || SQLITE_HAVE_ISNAN\n-  \"HAVE_ISNAN\",\n-#endif\n-#if SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n-  \"HOMEGROWN_RECURSIVE_MUTEX\",\n-#endif\n-#if SQLITE_IGNORE_AFP_LOCK_ERRORS\n-  \"IGNORE_AFP_LOCK_ERRORS\",\n-#endif\n-#if SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n-  \"IGNORE_FLOCK_LOCK_ERRORS\",\n-#endif\n-#if SQLITE_INLINE_MEMCPY\n-  \"INLINE_MEMCPY\",\n-#endif\n-#if SQLITE_INT64_TYPE\n-  \"INT64_TYPE\",\n-#endif\n-#ifdef SQLITE_INTEGRITY_CHECK_ERROR_MAX\n-  \"INTEGRITY_CHECK_ERROR_MAX=\" CTIMEOPT_VAL(SQLITE_INTEGRITY_CHECK_ERROR_MAX),\n-#endif\n-#if SQLITE_LIKE_DOESNT_MATCH_BLOBS\n-  \"LIKE_DOESNT_MATCH_BLOBS\",\n-#endif\n-#if SQLITE_LOCK_TRACE\n-  \"LOCK_TRACE\",\n-#endif\n-#if SQLITE_LOG_CACHE_SPILL\n-  \"LOG_CACHE_SPILL\",\n-#endif\n-#ifdef SQLITE_MALLOC_SOFT_LIMIT\n-  \"MALLOC_SOFT_LIMIT=\" CTIMEOPT_VAL(SQLITE_MALLOC_SOFT_LIMIT),\n-#endif\n-#ifdef SQLITE_MAX_ATTACHED\n-  \"MAX_ATTACHED=\" CTIMEOPT_VAL(SQLITE_MAX_ATTACHED),\n-#endif\n-#ifdef SQLITE_MAX_COLUMN\n-  \"MAX_COLUMN=\" CTIMEOPT_VAL(SQLITE_MAX_COLUMN),\n-#endif\n-#ifdef SQLITE_MAX_COMPOUND_SELECT\n-  \"MAX_COMPOUND_SELECT=\" CTIMEOPT_VAL(SQLITE_MAX_COMPOUND_SELECT),\n-#endif\n-#ifdef SQLITE_MAX_DEFAULT_PAGE_SIZE\n-  \"MAX_DEFAULT_PAGE_SIZE=\" CTIMEOPT_VAL(SQLITE_MAX_DEFAULT_PAGE_SIZE),\n-#endif\n-#ifdef SQLITE_MAX_EXPR_DEPTH\n-  \"MAX_EXPR_DEPTH=\" CTIMEOPT_VAL(SQLITE_MAX_EXPR_DEPTH),\n-#endif\n-#ifdef SQLITE_MAX_FUNCTION_ARG\n-  \"MAX_FUNCTION_ARG=\" CTIMEOPT_VAL(SQLITE_MAX_FUNCTION_ARG),\n-#endif\n-#ifdef SQLITE_MAX_LENGTH\n-  \"MAX_LENGTH=\" CTIMEOPT_VAL(SQLITE_MAX_LENGTH),\n-#endif\n-#ifdef SQLITE_MAX_LIKE_PATTERN_LENGTH\n-  \"MAX_LIKE_PATTERN_LENGTH=\" CTIMEOPT_VAL(SQLITE_MAX_LIKE_PATTERN_LENGTH),\n-#endif\n-#ifdef SQLITE_MAX_MEMORY\n-  \"MAX_MEMORY=\" CTIMEOPT_VAL(SQLITE_MAX_MEMORY),\n-#endif\n-#ifdef SQLITE_MAX_MMAP_SIZE\n-  \"MAX_MMAP_SIZE=\" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),\n-#endif\n-#ifdef SQLITE_MAX_MMAP_SIZE_\n-  \"MAX_MMAP_SIZE_=\" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE_),\n-#endif\n-#ifdef SQLITE_MAX_PAGE_COUNT\n-  \"MAX_PAGE_COUNT=\" CTIMEOPT_VAL(SQLITE_MAX_PAGE_COUNT),\n-#endif\n-#ifdef SQLITE_MAX_PAGE_SIZE\n-  \"MAX_PAGE_SIZE=\" CTIMEOPT_VAL(SQLITE_MAX_PAGE_SIZE),\n-#endif\n-#ifdef SQLITE_MAX_SCHEMA_RETRY\n-  \"MAX_SCHEMA_RETRY=\" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),\n-#endif\n-#ifdef SQLITE_MAX_SQL_LENGTH\n-  \"MAX_SQL_LENGTH=\" CTIMEOPT_VAL(SQLITE_MAX_SQL_LENGTH),\n-#endif\n-#ifdef SQLITE_MAX_TRIGGER_DEPTH\n-  \"MAX_TRIGGER_DEPTH=\" CTIMEOPT_VAL(SQLITE_MAX_TRIGGER_DEPTH),\n-#endif\n-#ifdef SQLITE_MAX_VARIABLE_NUMBER\n-  \"MAX_VARIABLE_NUMBER=\" CTIMEOPT_VAL(SQLITE_MAX_VARIABLE_NUMBER),\n-#endif\n-#ifdef SQLITE_MAX_VDBE_OP\n-  \"MAX_VDBE_OP=\" CTIMEOPT_VAL(SQLITE_MAX_VDBE_OP),\n-#endif\n-#ifdef SQLITE_MAX_WORKER_THREADS\n-  \"MAX_WORKER_THREADS=\" CTIMEOPT_VAL(SQLITE_MAX_WORKER_THREADS),\n-#endif\n-#if SQLITE_MEMDEBUG\n-  \"MEMDEBUG\",\n-#endif\n-#if SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n-  \"MIXED_ENDIAN_64BIT_FLOAT\",\n-#endif\n-#if SQLITE_MMAP_READWRITE\n-  \"MMAP_READWRITE\",\n-#endif\n-#if SQLITE_MUTEX_NOOP\n-  \"MUTEX_NOOP\",\n-#endif\n-#if SQLITE_MUTEX_NREF\n-  \"MUTEX_NREF\",\n-#endif\n-#if SQLITE_MUTEX_OMIT\n-  \"MUTEX_OMIT\",\n-#endif\n-#if SQLITE_MUTEX_PTHREADS\n-  \"MUTEX_PTHREADS\",\n-#endif\n-#if SQLITE_MUTEX_W32\n-  \"MUTEX_W32\",\n-#endif\n-#if SQLITE_NEED_ERR_NAME\n-  \"NEED_ERR_NAME\",\n-#endif\n-#if SQLITE_NOINLINE\n-  \"NOINLINE\",\n-#endif\n-#if SQLITE_NO_SYNC\n-  \"NO_SYNC\",\n-#endif\n-#if SQLITE_OMIT_ALTERTABLE\n-  \"OMIT_ALTERTABLE\",\n-#endif\n-#if SQLITE_OMIT_ANALYZE\n-  \"OMIT_ANALYZE\",\n-#endif\n-#if SQLITE_OMIT_ATTACH\n-  \"OMIT_ATTACH\",\n-#endif\n-#if SQLITE_OMIT_AUTHORIZATION\n-  \"OMIT_AUTHORIZATION\",\n-#endif\n-#if SQLITE_OMIT_AUTOINCREMENT\n-  \"OMIT_AUTOINCREMENT\",\n-#endif\n-#if SQLITE_OMIT_AUTOINIT\n-  \"OMIT_AUTOINIT\",\n-#endif\n-#if SQLITE_OMIT_AUTOMATIC_INDEX\n-  \"OMIT_AUTOMATIC_INDEX\",\n-#endif\n-#if SQLITE_OMIT_AUTORESET\n-  \"OMIT_AUTORESET\",\n-#endif\n-#if SQLITE_OMIT_AUTOVACUUM\n-  \"OMIT_AUTOVACUUM\",\n-#endif\n-#if SQLITE_OMIT_BETWEEN_OPTIMIZATION\n-  \"OMIT_BETWEEN_OPTIMIZATION\",\n-#endif\n-#if SQLITE_OMIT_BLOB_LITERAL\n-  \"OMIT_BLOB_LITERAL\",\n-#endif\n-#if SQLITE_OMIT_CAST\n-  \"OMIT_CAST\",\n-#endif\n-#if SQLITE_OMIT_CHECK\n-  \"OMIT_CHECK\",\n-#endif\n-#if SQLITE_OMIT_COMPLETE\n-  \"OMIT_COMPLETE\",\n-#endif\n-#if SQLITE_OMIT_COMPOUND_SELECT\n-  \"OMIT_COMPOUND_SELECT\",\n-#endif\n-#if SQLITE_OMIT_CONFLICT_CLAUSE\n-  \"OMIT_CONFLICT_CLAUSE\",\n-#endif\n-#if SQLITE_OMIT_CTE\n-  \"OMIT_CTE\",\n-#endif\n-#if SQLITE_OMIT_DATETIME_FUNCS\n-  \"OMIT_DATETIME_FUNCS\",\n-#endif\n-#if SQLITE_OMIT_DECLTYPE\n-  \"OMIT_DECLTYPE\",\n-#endif\n-#if SQLITE_OMIT_DEPRECATED\n-  \"OMIT_DEPRECATED\",\n-#endif\n-#if SQLITE_OMIT_DISKIO\n-  \"OMIT_DISKIO\",\n-#endif\n-#if SQLITE_OMIT_EXPLAIN\n-  \"OMIT_EXPLAIN\",\n-#endif\n-#if SQLITE_OMIT_FLAG_PRAGMAS\n-  \"OMIT_FLAG_PRAGMAS\",\n-#endif\n-#if SQLITE_OMIT_FLOATING_POINT\n-  \"OMIT_FLOATING_POINT\",\n-#endif\n-#if SQLITE_OMIT_FOREIGN_KEY\n-  \"OMIT_FOREIGN_KEY\",\n-#endif\n-#if SQLITE_OMIT_GET_TABLE\n-  \"OMIT_GET_TABLE\",\n-#endif\n-#if SQLITE_OMIT_HEX_INTEGER\n-  \"OMIT_HEX_INTEGER\",\n-#endif\n-#if SQLITE_OMIT_INCRBLOB\n-  \"OMIT_INCRBLOB\",\n-#endif\n-#if SQLITE_OMIT_INTEGRITY_CHECK\n-  \"OMIT_INTEGRITY_CHECK\",\n-#endif\n-#if SQLITE_OMIT_LIKE_OPTIMIZATION\n-  \"OMIT_LIKE_OPTIMIZATION\",\n-#endif\n-#if SQLITE_OMIT_LOAD_EXTENSION\n-  \"OMIT_LOAD_EXTENSION\",\n-#endif\n-#if SQLITE_OMIT_LOCALTIME\n-  \"OMIT_LOCALTIME\",\n-#endif\n-#if SQLITE_OMIT_LOOKASIDE\n-  \"OMIT_LOOKASIDE\",\n-#endif\n-#if SQLITE_OMIT_MEMORYDB\n-  \"OMIT_MEMORYDB\",\n-#endif\n-#if SQLITE_OMIT_OR_OPTIMIZATION\n-  \"OMIT_OR_OPTIMIZATION\",\n-#endif\n-#if SQLITE_OMIT_PAGER_PRAGMAS\n-  \"OMIT_PAGER_PRAGMAS\",\n-#endif\n-#if SQLITE_OMIT_PARSER_TRACE\n-  \"OMIT_PARSER_TRACE\",\n-#endif\n-#if SQLITE_OMIT_POPEN\n-  \"OMIT_POPEN\",\n-#endif\n-#if SQLITE_OMIT_PRAGMA\n-  \"OMIT_PRAGMA\",\n-#endif\n-#if SQLITE_OMIT_PROGRESS_CALLBACK\n-  \"OMIT_PROGRESS_CALLBACK\",\n-#endif\n-#if SQLITE_OMIT_QUICKBALANCE\n-  \"OMIT_QUICKBALANCE\",\n-#endif\n-#if SQLITE_OMIT_REINDEX\n-  \"OMIT_REINDEX\",\n-#endif\n-#if SQLITE_OMIT_SCHEMA_PRAGMAS\n-  \"OMIT_SCHEMA_PRAGMAS\",\n-#endif\n-#if SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n-  \"OMIT_SCHEMA_VERSION_PRAGMAS\",\n-#endif\n-#if SQLITE_OMIT_SHARED_CACHE\n-  \"OMIT_SHARED_CACHE\",\n-#endif\n-#if SQLITE_OMIT_SHUTDOWN_DIRECTORIES\n-  \"OMIT_SHUTDOWN_DIRECTORIES\",\n-#endif\n-#if SQLITE_OMIT_SUBQUERY\n-  \"OMIT_SUBQUERY\",\n-#endif\n-#if SQLITE_OMIT_TCL_VARIABLE\n-  \"OMIT_TCL_VARIABLE\",\n-#endif\n-#if SQLITE_OMIT_TEMPDB\n-  \"OMIT_TEMPDB\",\n-#endif\n-#if SQLITE_OMIT_TEST_CONTROL\n-  \"OMIT_TEST_CONTROL\",\n-#endif\n-#if SQLITE_OMIT_TRACE\n-  \"OMIT_TRACE\",\n-#endif\n-#if SQLITE_OMIT_TRIGGER\n-  \"OMIT_TRIGGER\",\n-#endif\n-#if SQLITE_OMIT_TRUNCATE_OPTIMIZATION\n-  \"OMIT_TRUNCATE_OPTIMIZATION\",\n-#endif\n-#if SQLITE_OMIT_UTF16\n-  \"OMIT_UTF16\",\n-#endif\n-#if SQLITE_OMIT_VACUUM\n-  \"OMIT_VACUUM\",\n-#endif\n-#if SQLITE_OMIT_VIEW\n-  \"OMIT_VIEW\",\n-#endif\n-#if SQLITE_OMIT_VIRTUALTABLE\n-  \"OMIT_VIRTUALTABLE\",\n-#endif\n-#if SQLITE_OMIT_WAL\n-  \"OMIT_WAL\",\n-#endif\n-#if SQLITE_OMIT_WSD\n-  \"OMIT_WSD\",\n-#endif\n-#if SQLITE_OMIT_XFER_OPT\n-  \"OMIT_XFER_OPT\",\n-#endif\n-#if SQLITE_PCACHE_SEPARATE_HEADER\n-  \"PCACHE_SEPARATE_HEADER\",\n-#endif\n-#if SQLITE_PERFORMANCE_TRACE\n-  \"PERFORMANCE_TRACE\",\n-#endif\n-#if SQLITE_POWERSAFE_OVERWRITE\n-  \"POWERSAFE_OVERWRITE\",\n-#endif\n-#if SQLITE_PREFER_PROXY_LOCKING\n-  \"PREFER_PROXY_LOCKING\",\n-#endif\n-#if SQLITE_PROXY_DEBUG\n-  \"PROXY_DEBUG\",\n-#endif\n-#if SQLITE_REVERSE_UNORDERED_SELECTS\n-  \"REVERSE_UNORDERED_SELECTS\",\n-#endif\n-#if SQLITE_RTREE_INT_ONLY\n-  \"RTREE_INT_ONLY\",\n-#endif\n-#if SQLITE_SECURE_DELETE\n-  \"SECURE_DELETE\",\n-#endif\n-#if SQLITE_SMALL_STACK\n-  \"SMALL_STACK\",\n-#endif\n-#ifdef SQLITE_SORTER_PMASZ\n-  \"SORTER_PMASZ=\" CTIMEOPT_VAL(SQLITE_SORTER_PMASZ),\n-#endif\n-#if SQLITE_SOUNDEX\n-  \"SOUNDEX\",\n-#endif\n-#ifdef SQLITE_STAT4_SAMPLES\n-  \"STAT4_SAMPLES=\" CTIMEOPT_VAL(SQLITE_STAT4_SAMPLES),\n-#endif\n-#ifdef SQLITE_STMTJRNL_SPILL\n-  \"STMTJRNL_SPILL=\" CTIMEOPT_VAL(SQLITE_STMTJRNL_SPILL),\n-#endif\n-#if SQLITE_SUBSTR_COMPATIBILITY\n-  \"SUBSTR_COMPATIBILITY\",\n-#endif\n-#if SQLITE_SYSTEM_MALLOC\n-  \"SYSTEM_MALLOC\",\n-#endif\n-#if SQLITE_TCL\n-  \"TCL\",\n-#endif\n-#ifdef SQLITE_TEMP_STORE\n-  \"TEMP_STORE=\" CTIMEOPT_VAL(SQLITE_TEMP_STORE),\n-#endif\n-#if SQLITE_TEST\n-  \"TEST\",\n-#endif\n-#if defined(SQLITE_THREADSAFE)\n-  \"THREADSAFE=\" CTIMEOPT_VAL(SQLITE_THREADSAFE),\n-#elif defined(THREADSAFE)\n-  \"THREADSAFE=\" CTIMEOPT_VAL(THREADSAFE),\n-#else\n-  \"THREADSAFE=1\",\n-#endif\n-#if SQLITE_UNLINK_AFTER_CLOSE\n-  \"UNLINK_AFTER_CLOSE\",\n-#endif\n-#if SQLITE_UNTESTABLE\n-  \"UNTESTABLE\",\n-#endif\n-#if SQLITE_USER_AUTHENTICATION\n-  \"USER_AUTHENTICATION\",\n-#endif\n-#if SQLITE_USE_ALLOCA\n-  \"USE_ALLOCA\",\n-#endif\n-#if SQLITE_USE_FCNTL_TRACE\n-  \"USE_FCNTL_TRACE\",\n-#endif\n-#if SQLITE_USE_URI\n-  \"USE_URI\",\n-#endif\n-#if SQLITE_VDBE_COVERAGE\n-  \"VDBE_COVERAGE\",\n-#endif\n-#if SQLITE_WIN32_MALLOC\n-  \"WIN32_MALLOC\",\n-#endif\n-#if SQLITE_ZERO_MALLOC\n-  \"ZERO_MALLOC\",\n-#endif\n-\/*\n-** END CODE GENERATED BY tool\/mkctime.tcl\n-*\/\n-};\n-\n-SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt){\n-  *pnOpt = sizeof(sqlite3azCompileOpt) \/ sizeof(sqlite3azCompileOpt[0]);\n-  return (const char**)sqlite3azCompileOpt;\n-}\n-\n-#endif \/* SQLITE_OMIT_COMPILEOPTION_DIAGS *\/\n-\n-\/************** End of ctime.c ***********************************************\/\n@@ -993,0 +228,12 @@\n+\/*\n+** Some C99 functions in \"math.h\" are only present for MSVC when its version\n+** is associated with Visual Studio 2013 or higher.\n+*\/\n+#ifndef SQLITE_HAVE_C99_MATH_FUNCS\n+# if MSVC_VERSION==0 || MSVC_VERSION>=1800\n+#  define SQLITE_HAVE_C99_MATH_FUNCS (1)\n+# else\n+#  define SQLITE_HAVE_C99_MATH_FUNCS (0)\n+# endif\n+#endif\n+\n@@ -1002,0 +249,9 @@\n+\/*\n+** Macro to disable warnings about missing \"break\" at the end of a \"case\".\n+*\/\n+#if GCC_VERSION>=7000000\n+# define deliberate_fall_through __attribute__((fallthrough));\n+#else\n+# define deliberate_fall_through\n+#endif\n+\n@@ -1034,0 +290,11 @@\n+\/* Optionally #include a user-defined header, whereby compilation options\n+** may be set prior to where they take effect, but after platform setup.\n+** If SQLITE_CUSTOM_INCLUDE=? is defined, its value names the #include\n+** file.\n+*\/\n+#ifdef SQLITE_CUSTOM_INCLUDE\n+# define INC_STRINGIFY_(f) #f\n+# define INC_STRINGIFY(f) INC_STRINGIFY_(f)\n+# include INC_STRINGIFY(SQLITE_CUSTOM_INCLUDE)\n+#endif\n+\n@@ -1085,1 +352,24 @@\n-** Provide the ability to override linkage features of the interface.\n+** Facilitate override of interface linkage and calling conventions.\n+** Be aware that these macros may not be used within this particular\n+** translation of the amalgamation and its associated header file.\n+**\n+** The SQLITE_EXTERN and SQLITE_API macros are used to instruct the\n+** compiler that the target identifier should have external linkage.\n+**\n+** The SQLITE_CDECL macro is used to set the calling convention for\n+** public functions that accept a variable number of arguments.\n+**\n+** The SQLITE_APICALL macro is used to set the calling convention for\n+** public functions that accept a fixed number of arguments.\n+**\n+** The SQLITE_STDCALL macro is no longer used and is now deprecated.\n+**\n+** The SQLITE_CALLBACK macro is used to set the calling convention for\n+** function pointers.\n+**\n+** The SQLITE_SYSAPI macro is used to set the calling convention for\n+** functions provided by the operating system.\n+**\n+** Currently, the SQLITE_CDECL, SQLITE_APICALL, SQLITE_CALLBACK, and\n+** SQLITE_SYSAPI macros are used only when building for environments\n+** that require non-default calling conventions.\n@@ -1165,3 +455,3 @@\n-#define SQLITE_VERSION        \"3.32.3\"\n-#define SQLITE_VERSION_NUMBER 3032003\n-#define SQLITE_SOURCE_ID      \"2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933cc8fd\"\n+#define SQLITE_VERSION        \"3.37.2\"\n+#define SQLITE_VERSION_NUMBER 3037002\n+#define SQLITE_SOURCE_ID      \"2022-01-06 13:25:41 872ba256cbf61d9290b571c0e6d82a20c224ca3ad82971edc46b29818d5d17a0\"\n@@ -1546,0 +836,1 @@\n+#define SQLITE_IOERR_CORRUPTFS         (SQLITE_IOERR | (33<<8))\n@@ -1578,0 +869,1 @@\n+#define SQLITE_CONSTRAINT_DATATYPE     (SQLITE_CONSTRAINT |(12<<8))\n@@ -1591,0 +883,13 @@\n+**\n+** Only those flags marked as \"Ok for sqlite3_open_v2()\" may be\n+** used as the third argument to the [sqlite3_open_v2()] interface.\n+** The other flags have historically been ignored by sqlite3_open_v2(),\n+** though future versions of SQLite might change so that an error is\n+** raised if any of the disallowed bits are passed into sqlite3_open_v2().\n+** Applications should not depend on the historical behavior.\n+**\n+** Note in particular that passing the SQLITE_OPEN_EXCLUSIVE flag into\n+** [sqlite3_open_v2()] does *not* cause the underlying database file\n+** to be opened using O_EXCL.  Passing SQLITE_OPEN_EXCLUSIVE into\n+** [sqlite3_open_v2()] has historically be a no-op and might become an\n+** error in future versions of SQLite.\n@@ -1606,1 +911,1 @@\n-#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  \/* VFS only *\/\n+#define SQLITE_OPEN_SUPER_JOURNAL    0x00004000  \/* VFS only *\/\n@@ -1613,0 +918,1 @@\n+#define SQLITE_OPEN_EXRESCODE        0x02000000  \/* Extended result codes *\/\n@@ -1615,0 +921,3 @@\n+\/* Legacy compatibility: *\/\n+#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  \/* VFS only *\/\n+\n@@ -1912,1 +1221,1 @@\n-** string containing the transactions master-journal file name. VFSes that\n+** string containing the transactions super-journal file name. VFSes that\n@@ -2166,0 +1475,17 @@\n+**\n+** <li>[[SQLITE_FCNTL_EXTERNAL_READER]]\n+** The EXPERIMENTAL [SQLITE_FCNTL_EXTERNAL_READER] opcode is used to detect\n+** whether or not there is a database client in another process with a wal-mode\n+** transaction open on the database or not. It is only available on unix.The\n+** (void*) argument passed with this file-control should be a pointer to a\n+** value of type (int). The integer value is set to 1 if the database is a wal\n+** mode database and there exists at least one client in another process that\n+** currently has an SQL transaction open on the database. It is set to 0 if\n+** the database is not a wal-mode db, or if there is no such connection in any\n+** other process. This opcode cannot be used to detect transactions opened\n+** by clients within the current process, only within other processes.\n+** <\/ul>\n+**\n+** <li>[[SQLITE_FCNTL_CKSM_FILE]]\n+** Used by the cksmvfs VFS module only.\n+** <\/ul>\n@@ -2205,0 +1531,2 @@\n+#define SQLITE_FCNTL_EXTERNAL_READER        40\n+#define SQLITE_FCNTL_CKSM_FILE              41\n@@ -2309,1 +1637,1 @@\n-** <li>  [SQLITE_OPEN_MASTER_JOURNAL]\n+** <li>  [SQLITE_OPEN_SUPER_JOURNAL]\n@@ -2687,1 +2015,1 @@\n-** SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokes\n+** SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes\n@@ -3153,1 +2481,7 @@\n-** which case the trigger setting is not reported back. <\/dd>\n+** which case the trigger setting is not reported back.\n+**\n+** <p>Originally this option disabled all triggers.  ^(However, since\n+** SQLite version 3.35.0, TEMP triggers are still allowed even if\n+** this option is off.  So, in other words, this option now only disables\n+** triggers in the main database schema or in the schemas of ATTACH-ed\n+** databases.)^ <\/dd>\n@@ -3164,1 +2498,7 @@\n-** which case the view setting is not reported back. <\/dd>\n+** which case the view setting is not reported back.\n+**\n+** <p>Originally this option disabled all views.  ^(However, since\n+** SQLite version 3.35.0, TEMP views are still allowed even if\n+** this option is off.  So, in other words, this option now only disables\n+** views in the main database schema or in the schemas of ATTACH-ed\n+** databases.)^ <\/dd>\n@@ -3325,2 +2665,1 @@\n-** assume that database schemas (the contents of the [sqlite_master] tables)\n-** are untainted by malicious content.\n+** assume that database schemas are untainted by malicious content.\n@@ -3472,1 +2811,1 @@\n-** ^This function returns the number of rows modified, inserted or\n+** ^These functions return the number of rows modified, inserted or\n@@ -3475,2 +2814,5 @@\n-** ^Executing any other type of SQL statement does not modify the value\n-** returned by this function.\n+** The two functions are identical except for the type of the return value\n+** and that if the number of rows modified by the most recent INSERT, UPDATE\n+** or DELETE is greater than the maximum value supported by type \"int\", then\n+** the return value of sqlite3_changes() is undefined. ^Executing any other\n+** type of SQL statement does not modify the value returned by these functions.\n@@ -3525,0 +2867,1 @@\n+SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3*);\n@@ -3530,1 +2873,1 @@\n-** ^This function returns the total number of rows inserted, modified or\n+** ^These functions return the total number of rows inserted, modified or\n@@ -3533,2 +2876,6 @@\n-** part of trigger programs. ^Executing any other type of SQL statement\n-** does not affect the value returned by sqlite3_total_changes().\n+** part of trigger programs. The two functions are identical except for the\n+** type of the return value and that if the number of rows modified by the\n+** connection exceeds the maximum value supported by type \"int\", then\n+** the return value of sqlite3_total_changes() is undefined. ^Executing\n+** any other type of SQL statement does not affect the value returned by\n+** sqlite3_total_changes().\n@@ -3562,0 +2909,1 @@\n+SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3*);\n@@ -4391,0 +3739,8 @@\n+** [[OPEN_EXRESCODE]] ^(<dt>[SQLITE_OPEN_EXRESCODE]<\/dt>\n+** <dd>The database connection comes up in \"extended result code mode\".\n+** In other words, the database behaves has if\n+** [sqlite3_extended_result_codes(db,1)] where called on the database\n+** connection as soon as the connection is created. In addition to setting\n+** the extended result code mode, this flag also causes [sqlite3_open_v2()]\n+** to return an extended result code.<\/dd>\n+**\n@@ -4398,1 +3754,9 @@\n-** then the behavior is undefined.\n+** then the behavior is undefined.  Historic versions of SQLite\n+** have silently ignored surplus bits in the flags parameter to\n+** sqlite3_open_v2(), however that behavior might not be carried through\n+** into future versions of SQLite and so applications should not rely\n+** upon it.  Note in particular that the SQLITE_OPEN_EXCLUSIVE flag is a no-op\n+** for sqlite3_open_v2().  The SQLITE_OPEN_EXCLUSIVE does *not* cause\n+** the open to fail if the database already exists.  The SQLITE_OPEN_EXCLUSIVE\n+** flag is intended for use by the [sqlite3_vfs|VFS interface] only, and not\n+** by sqlite3_open_v2().\n@@ -4538,0 +3902,1 @@\n+**          Use \"ro\" instead:  \"file:data.db?mode=ro\".\n@@ -4736,1 +4101,1 @@\n-** corruption or segfaults may occur. The value Y should be\n+** corruption or segfaults may occur. The value Y should not be\n@@ -5165,1 +4530,1 @@\n-** is obtained from [sqlite3_malloc()] and must be free by the application\n+** is obtained from [sqlite3_malloc()] and must be freed by the application\n@@ -5167,0 +4532,3 @@\n+**\n+** ^The sqlite3_normalized_sql() interface is only available if\n+** the [SQLITE_ENABLE_NORMALIZE] compile-time option is defined.\n@@ -5170,0 +4538,1 @@\n+#ifdef SQLITE_ENABLE_NORMALIZE\n@@ -5171,0 +4540,1 @@\n+#endif\n@@ -5205,0 +4575,9 @@\n+**\n+** ^This routine returns false if there is any possibility that the\n+** statement might change the database file.  ^A false return does\n+** not guarantee that the statement will change the database file.\n+** ^For example, an UPDATE statement might have a WHERE clause that\n+** makes it a no-op, but the sqlite3_stmt_readonly() result would still\n+** be false.  ^Similarly, a CREATE TABLE IF NOT EXISTS statement is a\n+** read-only no-op if the table already exists, but\n+** sqlite3_stmt_readonly() still returns false for such a statement.\n@@ -5374,12 +4753,16 @@\n-** ^The fifth argument to the BLOB and string binding interfaces\n-** is a destructor used to dispose of the BLOB or\n-** string after SQLite has finished with it.  ^The destructor is called\n-** to dispose of the BLOB or string even if the call to the bind API fails,\n-** except the destructor is not called if the third parameter is a NULL\n-** pointer or the fourth parameter is negative.\n-** ^If the fifth argument is\n-** the special value [SQLITE_STATIC], then SQLite assumes that the\n-** information is in static, unmanaged space and does not need to be freed.\n-** ^If the fifth argument has the value [SQLITE_TRANSIENT], then\n-** SQLite makes its own private copy of the data immediately, before\n-** the sqlite3_bind_*() routine returns.\n+** ^The fifth argument to the BLOB and string binding interfaces controls\n+** or indicates the lifetime of the object referenced by the third parameter.\n+** These three options exist:\n+** ^ (1) A destructor to dispose of the BLOB or string after SQLite has finished\n+** with it may be passed. ^It is called to dispose of the BLOB or string even\n+** if the call to the bind API fails, except the destructor is not called if\n+** the third parameter is a NULL pointer or the fourth parameter is negative.\n+** ^ (2) The special constant, [SQLITE_STATIC], may be passsed to indicate that\n+** the application remains responsible for disposing of the object. ^In this\n+** case, the object and the provided pointer to it must remain valid until\n+** either the prepared statement is finalized or the same SQL parameter is\n+** bound to something else, whichever occurs sooner.\n+** ^ (3) The constant, [SQLITE_TRANSIENT], may be passed to indicate that the\n+** object is to be copied prior to the return from sqlite3_bind_*(). ^The\n+** object and pointer to it must remain valid until then. ^SQLite will then\n+** manage the lifetime of its private copy.\n@@ -6127,1 +5510,0 @@\n-** <span style=\"background-color:#ffff90;\">\n@@ -6137,1 +5519,0 @@\n-** <\/span>\n@@ -7226,0 +6607,51 @@\n+\/*\n+** CAPI3REF: Determine the transaction state of a database\n+** METHOD: sqlite3\n+**\n+** ^The sqlite3_txn_state(D,S) interface returns the current\n+** [transaction state] of schema S in database connection D.  ^If S is NULL,\n+** then the highest transaction state of any schema on database connection D\n+** is returned.  Transaction states are (in order of lowest to highest):\n+** <ol>\n+** <li value=\"0\"> SQLITE_TXN_NONE\n+** <li value=\"1\"> SQLITE_TXN_READ\n+** <li value=\"2\"> SQLITE_TXN_WRITE\n+** <\/ol>\n+** ^If the S argument to sqlite3_txn_state(D,S) is not the name of\n+** a valid schema, then -1 is returned.\n+*\/\n+SQLITE_API int sqlite3_txn_state(sqlite3*,const char *zSchema);\n+\n+\/*\n+** CAPI3REF: Allowed return values from [sqlite3_txn_state()]\n+** KEYWORDS: {transaction state}\n+**\n+** These constants define the current transaction state of a database file.\n+** ^The [sqlite3_txn_state(D,S)] interface returns one of these\n+** constants in order to describe the transaction state of schema S\n+** in [database connection] D.\n+**\n+** <dl>\n+** [[SQLITE_TXN_NONE]] <dt>SQLITE_TXN_NONE<\/dt>\n+** <dd>The SQLITE_TXN_NONE state means that no transaction is currently\n+** pending.<\/dd>\n+**\n+** [[SQLITE_TXN_READ]] <dt>SQLITE_TXN_READ<\/dt>\n+** <dd>The SQLITE_TXN_READ state means that the database is currently\n+** in a read transaction.  Content has been read from the database file\n+** but nothing in the database file has changed.  The transaction state\n+** will advanced to SQLITE_TXN_WRITE if any changes occur and there are\n+** no other conflicting concurrent write transactions.  The transaction\n+** state will revert to SQLITE_TXN_NONE following a [ROLLBACK] or\n+** [COMMIT].<\/dd>\n+**\n+** [[SQLITE_TXN_WRITE]] <dt>SQLITE_TXN_WRITE<\/dt>\n+** <dd>The SQLITE_TXN_WRITE state means that the database is currently\n+** in a write transaction.  Content has been written to the database file\n+** but has not yet committed.  The transaction state will change to\n+** to SQLITE_TXN_NONE at the next [ROLLBACK] or [COMMIT].<\/dd>\n+*\/\n+#define SQLITE_TXN_NONE  0\n+#define SQLITE_TXN_READ  1\n+#define SQLITE_TXN_WRITE 2\n+\n@@ -7292,0 +6724,66 @@\n+\/*\n+** CAPI3REF: Autovacuum Compaction Amount Callback\n+** METHOD: sqlite3\n+**\n+** ^The sqlite3_autovacuum_pages(D,C,P,X) interface registers a callback\n+** function C that is invoked prior to each autovacuum of the database\n+** file.  ^The callback is passed a copy of the generic data pointer (P),\n+** the schema-name of the attached database that is being autovacuumed,\n+** the the size of the database file in pages, the number of free pages,\n+** and the number of bytes per page, respectively.  The callback should\n+** return the number of free pages that should be removed by the\n+** autovacuum.  ^If the callback returns zero, then no autovacuum happens.\n+** ^If the value returned is greater than or equal to the number of\n+** free pages, then a complete autovacuum happens.\n+**\n+** <p>^If there are multiple ATTACH-ed database files that are being\n+** modified as part of a transaction commit, then the autovacuum pages\n+** callback is invoked separately for each file.\n+**\n+** <p><b>The callback is not reentrant.<\/b> The callback function should\n+** not attempt to invoke any other SQLite interface.  If it does, bad\n+** things may happen, including segmentation faults and corrupt database\n+** files.  The callback function should be a simple function that\n+** does some arithmetic on its input parameters and returns a result.\n+**\n+** ^The X parameter to sqlite3_autovacuum_pages(D,C,P,X) is an optional\n+** destructor for the P parameter.  ^If X is not NULL, then X(P) is\n+** invoked whenever the database connection closes or when the callback\n+** is overwritten by another invocation of sqlite3_autovacuum_pages().\n+**\n+** <p>^There is only one autovacuum pages callback per database connection.\n+** ^Each call to the sqlite3_autovacuum_pages() interface overrides all\n+** previous invocations for that database connection.  ^If the callback\n+** argument (C) to sqlite3_autovacuum_pages(D,C,P,X) is a NULL pointer,\n+** then the autovacuum steps callback is cancelled.  The return value\n+** from sqlite3_autovacuum_pages() is normally SQLITE_OK, but might\n+** be some other error code if something goes wrong.  The current\n+** implementation will only return SQLITE_OK or SQLITE_MISUSE, but other\n+** return codes might be added in future releases.\n+**\n+** <p>If no autovacuum pages callback is specified (the usual case) or\n+** a NULL pointer is provided for the callback,\n+** then the default behavior is to vacuum all free pages.  So, in other\n+** words, the default behavior is the same as if the callback function\n+** were something like this:\n+**\n+** <blockquote><pre>\n+** &nbsp;   unsigned int demonstration_autovac_pages_callback(\n+** &nbsp;     void *pClientData,\n+** &nbsp;     const char *zSchema,\n+** &nbsp;     unsigned int nDbPage,\n+** &nbsp;     unsigned int nFreePage,\n+** &nbsp;     unsigned int nBytePerPage\n+** &nbsp;   ){\n+** &nbsp;     return nFreePage;\n+** &nbsp;   }\n+** <\/pre><\/blockquote>\n+*\/\n+SQLITE_API int sqlite3_autovacuum_pages(\n+  sqlite3 *db,\n+  unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),\n+  void*,\n+  void(*)(void*)\n+);\n+\n+\n@@ -7316,1 +6814,1 @@\n-** modified (i.e. sqlite_master and sqlite_sequence).)^\n+** modified (i.e. sqlite_sequence).)^\n@@ -8418,1 +7916,1 @@\n-** <li>  SQLITE_MUTEX_STATIC_MASTER\n+** <li>  SQLITE_MUTEX_STATIC_MAIN\n@@ -8620,1 +8118,1 @@\n-#define SQLITE_MUTEX_STATIC_MASTER    2\n+#define SQLITE_MUTEX_STATIC_MAIN      2\n@@ -8635,0 +8133,4 @@\n+\/* Legacy compatibility: *\/\n+#define SQLITE_MUTEX_STATIC_MASTER    2\n+\n+\n@@ -8748,1 +8250,4 @@\n-#define SQLITE_TESTCTRL_LAST                    29  \/* Largest TESTCTRL *\/\n+#define SQLITE_TESTCTRL_SEEK_COUNT              30\n+#define SQLITE_TESTCTRL_TRACEFLAGS              31\n+#define SQLITE_TESTCTRL_TUNE                    32\n+#define SQLITE_TESTCTRL_LAST                    32  \/* Largest TESTCTRL *\/\n@@ -9948,2 +9453,3 @@\n-** previously registered write-ahead log callback. ^Note that the\n-** [sqlite3_wal_autocheckpoint()] interface and the\n+** previously registered write-ahead log callback. ^The return value is\n+** a copy of the third parameter from the previous call, if any, or 0.\n+** ^Note that the [sqlite3_wal_autocheckpoint()] interface and the\n@@ -10228,1 +9734,1 @@\n-** method of a [virtual table], then it returns true if and only if the\n+** method of a [virtual table], then it might return true if the\n@@ -10230,2 +9736,3 @@\n-** column value will not change.  Applications might use this to substitute\n-** a return value that is less expensive to compute and that the corresponding\n+** column value will not change.  The virtual table implementation can use\n+** this hint as permission to substitute a return value that is less\n+** expensive to compute and that the corresponding\n@@ -10240,0 +9747,6 @@\n+**\n+** The sqlite3_vtab_nochange() routine is an optimization.  Virtual table\n+** implementations should continue to give a correct answer even if the\n+** sqlite3_vtab_nochange() interface were to always return false.  In the\n+** current implementation, the sqlite3_vtab_nochange() interface does always\n+** returns false for the enhanced [UPDATE FROM] statement.\n@@ -10381,0 +9894,1 @@\n+** METHOD: sqlite3\n@@ -10413,0 +9927,1 @@\n+** METHOD: sqlite3\n@@ -10430,1 +9945,1 @@\n-** system tables like sqlite_master or sqlite_stat1.\n+** system tables like sqlite_sequence or sqlite_stat1.\n@@ -10453,1 +9968,1 @@\n-** INSERT operations on rowid tables.\n+** DELETE operations on rowid tables.\n@@ -10491,0 +10006,9 @@\n+** When the [sqlite3_blob_write()] API is used to update a blob column,\n+** the pre-update hook is invoked with SQLITE_DELETE. This is because the\n+** in this case the new values are not available. In this case, when a\n+** callback made with op==SQLITE_DELETE is actuall a write using the\n+** sqlite3_blob_write() API, the [sqlite3_preupdate_blobwrite()] returns\n+** the index of the column being written. In other cases, where the\n+** pre-update hook is being invoked for some other reason, including a\n+** regular DELETE, sqlite3_preupdate_blobwrite() returns -1.\n+**\n@@ -10511,0 +10035,1 @@\n+SQLITE_API int sqlite3_preupdate_blobwrite(sqlite3 *);\n@@ -10515,0 +10040,1 @@\n+** METHOD: sqlite3\n@@ -10748,2 +10274,2 @@\n-** This interface is only available if SQLite is compiled with the\n-** [SQLITE_ENABLE_DESERIALIZE] option.\n+** This interface is omitted if SQLite is compiled with the\n+** [SQLITE_OMIT_DESERIALIZE] option.\n@@ -10796,0 +10322,4 @@\n+** It is not possible to deserialized into the TEMP database.  If the\n+** S argument to sqlite3_deserialize(D,S,P,N,M,F) is \"temp\" then the\n+** function returns SQLITE_ERROR.\n+**\n@@ -10800,2 +10330,2 @@\n-** This interface is only available if SQLite is compiled with the\n-** [SQLITE_ENABLE_DESERIALIZE] option.\n+** This interface is omitted if SQLite is compiled with the\n+** [SQLITE_OMIT_DESERIALIZE] option.\n@@ -11050,0 +10580,32 @@\n+\/*\n+** CAPIREF: Conigure a Session Object\n+** METHOD: sqlite3_session\n+**\n+** This method is used to configure a session object after it has been\n+** created. At present the only valid value for the second parameter is\n+** [SQLITE_SESSION_OBJCONFIG_SIZE].\n+**\n+** Arguments for sqlite3session_object_config()\n+**\n+** The following values may passed as the the 4th parameter to\n+** sqlite3session_object_config().\n+**\n+** <dt>SQLITE_SESSION_OBJCONFIG_SIZE <dd>\n+**   This option is used to set, clear or query the flag that enables\n+**   the [sqlite3session_changeset_size()] API. Because it imposes some\n+**   computational overhead, this API is disabled by default. Argument\n+**   pArg must point to a value of type (int). If the value is initially\n+**   0, then the sqlite3session_changeset_size() API is disabled. If it\n+**   is greater than 0, then the same API is enabled. Or, if the initial\n+**   value is less than zero, no change is made. In all cases the (int)\n+**   variable is set to 1 if the sqlite3session_changeset_size() API is\n+**   enabled following the current call, or 0 otherwise.\n+**\n+**   It is an error (SQLITE_MISUSE) to attempt to modify this setting after\n+**   the first table has been attached to the session object.\n+*\/\n+SQLITE_API int sqlite3session_object_config(sqlite3_session*, int op, void *pArg);\n+\n+\/*\n+*\/\n+#define SQLITE_SESSION_OBJCONFIG_SIZE 1\n@@ -11294,0 +10856,16 @@\n+\/*\n+** CAPI3REF: Return An Upper-limit For The Size Of The Changeset\n+** METHOD: sqlite3_session\n+**\n+** By default, this function always returns 0. For it to return\n+** a useful result, the sqlite3_session object must have been configured\n+** to enable this API using sqlite3session_object_config() with the\n+** SQLITE_SESSION_OBJCONFIG_SIZE verb.\n+**\n+** When enabled, this function returns an upper limit, in bytes, for the size\n+** of the changeset that might be produced if sqlite3session_changeset() were\n+** called. The final changeset size might be equal to or smaller than the\n+** size in bytes returned by this function.\n+*\/\n+SQLITE_API sqlite3_int64 sqlite3session_changeset_size(sqlite3_session *pSession);\n+\n@@ -11411,0 +10989,8 @@\n+\/*\n+** CAPI3REF: Query for the amount of heap memory used by a session object.\n+**\n+** This API returns the total amount of heap memory in bytes currently\n+** used by the session object passed as the only argument.\n+*\/\n+SQLITE_API sqlite3_int64 sqlite3session_memory_used(sqlite3_session *pSession);\n+\n@@ -11513,7 +11099,14 @@\n-** If argument pzTab is not NULL, then *pzTab is set to point to a\n-** nul-terminated utf-8 encoded string containing the name of the table\n-** affected by the current change. The buffer remains valid until either\n-** sqlite3changeset_next() is called on the iterator or until the\n-** conflict-handler function returns. If pnCol is not NULL, then *pnCol is\n-** set to the number of columns in the table affected by the change. If\n-** pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change\n+** Arguments pOp, pnCol and pzTab may not be NULL. Upon return, three\n+** outputs are set through these pointers:\n+**\n+** *pOp is set to one of [SQLITE_INSERT], [SQLITE_DELETE] or [SQLITE_UPDATE],\n+** depending on the type of change that the iterator currently points to;\n+**\n+** *pnCol is set to the number of columns in the table affected by the change; and\n+**\n+** *pzTab is set to point to a nul-terminated utf-8 encoded string containing\n+** the name of the table affected by the current change. The buffer remains\n+** valid until either sqlite3changeset_next() is called on the iterator\n+** or until the conflict-handler function returns.\n+**\n+** If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change\n@@ -11522,3 +11115,1 @@\n-** changes. Finally, if pOp is not NULL, then *pOp is set to one of\n-** [SQLITE_INSERT], [SQLITE_DELETE] or [SQLITE_UPDATE], depending on the\n-** type of change that the iterator currently points to.\n+** changes.\n@@ -13217,1 +12808,1 @@\n-\/* #include \"config.h\" *\/\n+#include \"config.h\"\n@@ -13285,5 +12876,1 @@\n-** expression.\n-**\n-** A value of 0 used to mean that the limit was not enforced.\n-** But that is no longer true.  The limit is now strictly enforced\n-** at all times.\n+** expression. A value of 0 means that there is no limit.\n@@ -13454,2 +13041,2 @@\n-#ifndef __has_feature\n-# define __has_feature(x) 0       \/* compatibility with non-clang compilers *\/\n+#ifndef __has_extension\n+# define __has_extension(x) 0     \/* compatibility with non-clang compilers *\/\n@@ -13457,1 +13044,2 @@\n-#if GCC_VERSION>=4007000 || __has_feature(c_atomic)\n+#if GCC_VERSION>=4007000 || __has_extension(c_atomic)\n+# define SQLITE_ATOMIC_INTRINSICS 1\n@@ -13461,0 +13049,1 @@\n+# define SQLITE_ATOMIC_INTRINSICS 0\n@@ -13665,1 +13254,0 @@\n-**\n@@ -13667,3 +13255,5 @@\n-#ifdef SQLITE_COVERAGE_TEST\n-SQLITE_PRIVATE   void sqlite3Coverage(int);\n-# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }\n+#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)\n+# ifndef SQLITE_AMALGAMATION\n+    extern unsigned int sqlite3CoverageCounter;\n+# endif\n+# define testcase(X)  if( X ){ sqlite3CoverageCounter += (unsigned)__LINE__; }\n@@ -13699,0 +13289,8 @@\n+\/*\n+** Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage\n+** and mutation testing\n+*\/\n+#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n+# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS  1\n+#endif\n+\n@@ -13714,1 +13312,1 @@\n-#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n+#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)\n@@ -13725,20 +13323,0 @@\n-\/*\n-** The harmless(X) macro indicates that expression X is usually false\n-** but can be true without causing any problems, but we don't know of\n-** any way to cause X to be true.\n-**\n-** In debugging and testing builds, this macro will abort if X is ever\n-** true.  In this way, developers are alerted to a possible test case\n-** that causes X to be true.  If a harmless macro ever fails, that is\n-** an opportunity to change the macro into a testcase() and add a new\n-** test case to the test suite.\n-**\n-** For normal production builds, harmless(X) is a no-op, since it does\n-** not matter whether expression X is true or false.\n-*\/\n-#ifdef SQLITE_DEBUG\n-# define harmless(X)  assert(!(X));\n-#else\n-# define harmless(X)\n-#endif\n-\n@@ -13808,0 +13386,7 @@\n+\/*\n+** SQLITE_OMIT_VIRTUALTABLE implies SQLITE_OMIT_ALTERTABLE\n+*\/\n+#if defined(SQLITE_OMIT_VIRTUALTABLE) && !defined(SQLITE_OMIT_ALTERTABLE)\n+# define SQLITE_OMIT_ALTERTABLE\n+#endif\n+\n@@ -13920,1 +13505,1 @@\n-\/* #define sqliteHashCount(H)  ((H)->count) \/\/ NOT USED *\/\n+#define sqliteHashCount(H)  ((H)->count)\n@@ -13952,2 +13537,2 @@\n-#define TK_WITHOUT                         25\n-#define TK_COMMA                           26\n+#define TK_COMMA                           25\n+#define TK_WITHOUT                         26\n@@ -14024,84 +13609,87 @@\n-#define TK_REINDEX                         97\n-#define TK_RENAME                          98\n-#define TK_CTIME_KW                        99\n-#define TK_ANY                            100\n-#define TK_BITAND                         101\n-#define TK_BITOR                          102\n-#define TK_LSHIFT                         103\n-#define TK_RSHIFT                         104\n-#define TK_PLUS                           105\n-#define TK_MINUS                          106\n-#define TK_STAR                           107\n-#define TK_SLASH                          108\n-#define TK_REM                            109\n-#define TK_CONCAT                         110\n-#define TK_COLLATE                        111\n-#define TK_BITNOT                         112\n-#define TK_ON                             113\n-#define TK_INDEXED                        114\n-#define TK_STRING                         115\n-#define TK_JOIN_KW                        116\n-#define TK_CONSTRAINT                     117\n-#define TK_DEFAULT                        118\n-#define TK_NULL                           119\n-#define TK_PRIMARY                        120\n-#define TK_UNIQUE                         121\n-#define TK_CHECK                          122\n-#define TK_REFERENCES                     123\n-#define TK_AUTOINCR                       124\n-#define TK_INSERT                         125\n-#define TK_DELETE                         126\n-#define TK_UPDATE                         127\n-#define TK_SET                            128\n-#define TK_DEFERRABLE                     129\n-#define TK_FOREIGN                        130\n-#define TK_DROP                           131\n-#define TK_UNION                          132\n-#define TK_ALL                            133\n-#define TK_EXCEPT                         134\n-#define TK_INTERSECT                      135\n-#define TK_SELECT                         136\n-#define TK_VALUES                         137\n-#define TK_DISTINCT                       138\n-#define TK_DOT                            139\n-#define TK_FROM                           140\n-#define TK_JOIN                           141\n-#define TK_USING                          142\n-#define TK_ORDER                          143\n-#define TK_GROUP                          144\n-#define TK_HAVING                         145\n-#define TK_LIMIT                          146\n-#define TK_WHERE                          147\n-#define TK_INTO                           148\n-#define TK_NOTHING                        149\n-#define TK_FLOAT                          150\n-#define TK_BLOB                           151\n-#define TK_INTEGER                        152\n-#define TK_VARIABLE                       153\n-#define TK_CASE                           154\n-#define TK_WHEN                           155\n-#define TK_THEN                           156\n-#define TK_ELSE                           157\n-#define TK_INDEX                          158\n-#define TK_ALTER                          159\n-#define TK_ADD                            160\n-#define TK_WINDOW                         161\n-#define TK_OVER                           162\n-#define TK_FILTER                         163\n-#define TK_COLUMN                         164\n-#define TK_AGG_FUNCTION                   165\n-#define TK_AGG_COLUMN                     166\n-#define TK_TRUEFALSE                      167\n-#define TK_ISNOT                          168\n-#define TK_FUNCTION                       169\n-#define TK_UMINUS                         170\n-#define TK_UPLUS                          171\n-#define TK_TRUTH                          172\n-#define TK_REGISTER                       173\n-#define TK_VECTOR                         174\n-#define TK_SELECT_COLUMN                  175\n-#define TK_IF_NULL_ROW                    176\n-#define TK_ASTERISK                       177\n-#define TK_SPAN                           178\n-#define TK_SPACE                          179\n-#define TK_ILLEGAL                        180\n+#define TK_MATERIALIZED                    97\n+#define TK_REINDEX                         98\n+#define TK_RENAME                          99\n+#define TK_CTIME_KW                       100\n+#define TK_ANY                            101\n+#define TK_BITAND                         102\n+#define TK_BITOR                          103\n+#define TK_LSHIFT                         104\n+#define TK_RSHIFT                         105\n+#define TK_PLUS                           106\n+#define TK_MINUS                          107\n+#define TK_STAR                           108\n+#define TK_SLASH                          109\n+#define TK_REM                            110\n+#define TK_CONCAT                         111\n+#define TK_COLLATE                        112\n+#define TK_BITNOT                         113\n+#define TK_ON                             114\n+#define TK_INDEXED                        115\n+#define TK_STRING                         116\n+#define TK_JOIN_KW                        117\n+#define TK_CONSTRAINT                     118\n+#define TK_DEFAULT                        119\n+#define TK_NULL                           120\n+#define TK_PRIMARY                        121\n+#define TK_UNIQUE                         122\n+#define TK_CHECK                          123\n+#define TK_REFERENCES                     124\n+#define TK_AUTOINCR                       125\n+#define TK_INSERT                         126\n+#define TK_DELETE                         127\n+#define TK_UPDATE                         128\n+#define TK_SET                            129\n+#define TK_DEFERRABLE                     130\n+#define TK_FOREIGN                        131\n+#define TK_DROP                           132\n+#define TK_UNION                          133\n+#define TK_ALL                            134\n+#define TK_EXCEPT                         135\n+#define TK_INTERSECT                      136\n+#define TK_SELECT                         137\n+#define TK_VALUES                         138\n+#define TK_DISTINCT                       139\n+#define TK_DOT                            140\n+#define TK_FROM                           141\n+#define TK_JOIN                           142\n+#define TK_USING                          143\n+#define TK_ORDER                          144\n+#define TK_GROUP                          145\n+#define TK_HAVING                         146\n+#define TK_LIMIT                          147\n+#define TK_WHERE                          148\n+#define TK_RETURNING                      149\n+#define TK_INTO                           150\n+#define TK_NOTHING                        151\n+#define TK_FLOAT                          152\n+#define TK_BLOB                           153\n+#define TK_INTEGER                        154\n+#define TK_VARIABLE                       155\n+#define TK_CASE                           156\n+#define TK_WHEN                           157\n+#define TK_THEN                           158\n+#define TK_ELSE                           159\n+#define TK_INDEX                          160\n+#define TK_ALTER                          161\n+#define TK_ADD                            162\n+#define TK_WINDOW                         163\n+#define TK_OVER                           164\n+#define TK_FILTER                         165\n+#define TK_COLUMN                         166\n+#define TK_AGG_FUNCTION                   167\n+#define TK_AGG_COLUMN                     168\n+#define TK_TRUEFALSE                      169\n+#define TK_ISNOT                          170\n+#define TK_FUNCTION                       171\n+#define TK_UMINUS                         172\n+#define TK_UPLUS                          173\n+#define TK_TRUTH                          174\n+#define TK_REGISTER                       175\n+#define TK_VECTOR                         176\n+#define TK_SELECT_COLUMN                  177\n+#define TK_IF_NULL_ROW                    178\n+#define TK_ASTERISK                       179\n+#define TK_SPAN                           180\n+#define TK_ERROR                          181\n+#define TK_SPACE                          182\n+#define TK_ILLEGAL                        183\n@@ -14213,1 +13801,1 @@\n-** The default value of \"20\" was choosen to minimize the run-time of the\n+** The default value of \"20\" was chosen to minimize the run-time of the\n@@ -14375,0 +13963,1 @@\n+      (defined(__APPLE__) && defined(__POWERPC__)) ||                     \\\n@@ -14450,0 +14039,1 @@\n+#define LARGEST_UINT64 (0xffffffff|(((u64)0xffffffff)<<32))\n@@ -14522,1 +14112,5 @@\n-#if defined(SQLITE_ENABLE_SELECTTRACE)\n+#if !defined(SQLITE_AMALGAMATION)\n+SQLITE_PRIVATE u32 sqlite3SelectTrace;\n+#endif\n+#if defined(SQLITE_DEBUG) \\\n+    && (defined(SQLITE_TEST) || defined(SQLITE_ENABLE_SELECTTRACE))\n@@ -14524,0 +14118,4 @@\n+# define SELECTTRACE(K,P,S,X)  \\\n+  if(sqlite3SelectTrace&(K))   \\\n+    sqlite3DebugPrintf(\"%u\/%d\/%p: \",(S)->selId,(P)->addrExplain,(S)),\\\n+    sqlite3DebugPrintf X\n@@ -14525,0 +14123,1 @@\n+# define SELECTTRACE(K,P,S,X)\n@@ -14528,0 +14127,13 @@\n+\/*\n+** Macros for \"wheretrace\"\n+*\/\n+SQLITE_PRIVATE u32 sqlite3WhereTrace;\n+#if defined(SQLITE_DEBUG) \\\n+    && (defined(SQLITE_TEST) || defined(SQLITE_ENABLE_WHERETRACE))\n+# define WHERETRACE(K,X)  if(sqlite3WhereTrace&(K)) sqlite3DebugPrintf X\n+# define WHERETRACE_ENABLED 1\n+#else\n+# define WHERETRACE(K,X)\n+#endif\n+\n+\n@@ -14545,3 +14157,15 @@\n-** Name of the master database table.  The master database table\n-** is a special table that holds the names and attributes of all\n-** user tables and indices.\n+** Name of table that holds the database schema.\n+**\n+** The PREFERRED names are used whereever possible.  But LEGACY is also\n+** used for backwards compatibility.\n+**\n+**  1.  Queries can use either the PREFERRED or the LEGACY names\n+**  2.  The sqlite3_set_authorizer() callback uses the LEGACY name\n+**  3.  The PRAGMA table_list statement uses the PREFERRED name\n+**\n+** The LEGACY names are stored in the internal symbol hash table\n+** in support of (2).  Names are translated using sqlite3PreferredTableName()\n+** for (3).  The sqlite3FindTable() function takes care of translating\n+** names for (1).\n+**\n+** Note that \"sqlite_temp_schema\" can also be called \"temp.sqlite_schema\".\n@@ -14549,2 +14173,5 @@\n-#define MASTER_NAME       \"sqlite_master\"\n-#define TEMP_MASTER_NAME  \"sqlite_temp_master\"\n+#define LEGACY_SCHEMA_TABLE          \"sqlite_master\"\n+#define LEGACY_TEMP_SCHEMA_TABLE     \"sqlite_temp_master\"\n+#define PREFERRED_SCHEMA_TABLE       \"sqlite_schema\"\n+#define PREFERRED_TEMP_SCHEMA_TABLE  \"sqlite_temp_schema\"\n+\n@@ -14553,1 +14180,1 @@\n-** The root-page of the master database table.\n+** The root-page of the schema table.\n@@ -14555,1 +14182,1 @@\n-#define MASTER_ROOT       1\n+#define SCHEMA_ROOT    1\n@@ -14558,1 +14185,1 @@\n-** The name of the schema table.\n+** The name of the schema table.  The name is different for TEMP.\n@@ -14560,1 +14187,2 @@\n-#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)\n+#define SCHEMA_TABLE(x) \\\n+    ((!OMIT_TEMPDB)&&(x==1)?LEGACY_TEMP_SCHEMA_TABLE:LEGACY_SCHEMA_TABLE)\n@@ -14581,1 +14209,1 @@\n-#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3MallocSize)\n+#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3OomFault)\n@@ -14637,0 +14265,2 @@\n+typedef struct Cte Cte;\n+typedef struct CteUse CteUse;\n@@ -14638,0 +14268,1 @@\n+typedef struct DbFixer DbFixer;\n@@ -14655,0 +14286,1 @@\n+typedef struct ParseCleanup ParseCleanup;\n@@ -14658,0 +14290,1 @@\n+typedef struct Returning Returning;\n@@ -14663,0 +14296,1 @@\n+typedef struct SrcItem SrcItem;\n@@ -14721,0 +14355,247 @@\n+\/************** Include pager.h in the middle of sqliteInt.h *****************\/\n+\/************** Begin file pager.h *******************************************\/\n+\/*\n+** 2001 September 15\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+*************************************************************************\n+** This header file defines the interface that the sqlite page cache\n+** subsystem.  The page cache subsystem reads and writes a file a page\n+** at a time and provides a journal for rollback.\n+*\/\n+\n+#ifndef SQLITE_PAGER_H\n+#define SQLITE_PAGER_H\n+\n+\/*\n+** Default maximum size for persistent journal files. A negative\n+** value means no limit. This value may be overridden using the\n+** sqlite3PagerJournalSizeLimit() API. See also \"PRAGMA journal_size_limit\".\n+*\/\n+#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT\n+  #define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1\n+#endif\n+\n+\/*\n+** The type used to represent a page number.  The first page in a file\n+** is called page 1.  0 is used to represent \"not a page\".\n+*\/\n+typedef u32 Pgno;\n+\n+\/*\n+** Each open file is managed by a separate instance of the \"Pager\" structure.\n+*\/\n+typedef struct Pager Pager;\n+\n+\/*\n+** Handle type for pages.\n+*\/\n+typedef struct PgHdr DbPage;\n+\n+\/*\n+** Page number PAGER_MJ_PGNO is never used in an SQLite database (it is\n+** reserved for working around a windows\/posix incompatibility). It is\n+** used in the journal to signify that the remainder of the journal file\n+** is devoted to storing a super-journal name - there are no more pages to\n+** roll back. See comments for function writeSuperJournal() in pager.c\n+** for details.\n+*\/\n+#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE\/((x)->pageSize))+1))\n+\n+\/*\n+** Allowed values for the flags parameter to sqlite3PagerOpen().\n+**\n+** NOTE: These values must match the corresponding BTREE_ values in btree.h.\n+*\/\n+#define PAGER_OMIT_JOURNAL  0x0001    \/* Do not use a rollback journal *\/\n+#define PAGER_MEMORY        0x0002    \/* In-memory database *\/\n+\n+\/*\n+** Valid values for the second argument to sqlite3PagerLockingMode().\n+*\/\n+#define PAGER_LOCKINGMODE_QUERY      -1\n+#define PAGER_LOCKINGMODE_NORMAL      0\n+#define PAGER_LOCKINGMODE_EXCLUSIVE   1\n+\n+\/*\n+** Numeric constants that encode the journalmode.\n+**\n+** The numeric values encoded here (other than PAGER_JOURNALMODE_QUERY)\n+** are exposed in the API via the \"PRAGMA journal_mode\" command and\n+** therefore cannot be changed without a compatibility break.\n+*\/\n+#define PAGER_JOURNALMODE_QUERY     (-1)  \/* Query the value of journalmode *\/\n+#define PAGER_JOURNALMODE_DELETE      0   \/* Commit by deleting journal file *\/\n+#define PAGER_JOURNALMODE_PERSIST     1   \/* Commit by zeroing journal header *\/\n+#define PAGER_JOURNALMODE_OFF         2   \/* Journal omitted.  *\/\n+#define PAGER_JOURNALMODE_TRUNCATE    3   \/* Commit by truncating journal *\/\n+#define PAGER_JOURNALMODE_MEMORY      4   \/* In-memory journal file *\/\n+#define PAGER_JOURNALMODE_WAL         5   \/* Use write-ahead logging *\/\n+\n+\/*\n+** Flags that make up the mask passed to sqlite3PagerGet().\n+*\/\n+#define PAGER_GET_NOCONTENT     0x01  \/* Do not load data from disk *\/\n+#define PAGER_GET_READONLY      0x02  \/* Read-only page is acceptable *\/\n+\n+\/*\n+** Flags for sqlite3PagerSetFlags()\n+**\n+** Value constraints (enforced via assert()):\n+**    PAGER_FULLFSYNC      == SQLITE_FullFSync\n+**    PAGER_CKPT_FULLFSYNC == SQLITE_CkptFullFSync\n+**    PAGER_CACHE_SPILL    == SQLITE_CacheSpill\n+*\/\n+#define PAGER_SYNCHRONOUS_OFF       0x01  \/* PRAGMA synchronous=OFF *\/\n+#define PAGER_SYNCHRONOUS_NORMAL    0x02  \/* PRAGMA synchronous=NORMAL *\/\n+#define PAGER_SYNCHRONOUS_FULL      0x03  \/* PRAGMA synchronous=FULL *\/\n+#define PAGER_SYNCHRONOUS_EXTRA     0x04  \/* PRAGMA synchronous=EXTRA *\/\n+#define PAGER_SYNCHRONOUS_MASK      0x07  \/* Mask for four values above *\/\n+#define PAGER_FULLFSYNC             0x08  \/* PRAGMA fullfsync=ON *\/\n+#define PAGER_CKPT_FULLFSYNC        0x10  \/* PRAGMA checkpoint_fullfsync=ON *\/\n+#define PAGER_CACHESPILL            0x20  \/* PRAGMA cache_spill=ON *\/\n+#define PAGER_FLAGS_MASK            0x38  \/* All above except SYNCHRONOUS *\/\n+\n+\/*\n+** The remainder of this file contains the declarations of the functions\n+** that make up the Pager sub-system API. See source code comments for\n+** a detailed description of each routine.\n+*\/\n+\n+\/* Open and close a Pager connection. *\/\n+SQLITE_PRIVATE int sqlite3PagerOpen(\n+  sqlite3_vfs*,\n+  Pager **ppPager,\n+  const char*,\n+  int,\n+  int,\n+  int,\n+  void(*)(DbPage*)\n+);\n+SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3*);\n+SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);\n+\n+\/* Functions used to configure a Pager object. *\/\n+SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);\n+SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);\n+SQLITE_PRIVATE Pgno sqlite3PagerMaxPageCount(Pager*, Pgno);\n+SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);\n+SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager*, int);\n+SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);\n+SQLITE_PRIVATE void sqlite3PagerShrink(Pager*);\n+SQLITE_PRIVATE void sqlite3PagerSetFlags(Pager*,unsigned);\n+SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int);\n+SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *, int);\n+SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager*);\n+SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager*);\n+SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64);\n+SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager*);\n+SQLITE_PRIVATE int sqlite3PagerFlush(Pager*);\n+\n+\/* Functions used to obtain and release page references. *\/\n+SQLITE_PRIVATE int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);\n+SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);\n+SQLITE_PRIVATE void sqlite3PagerRef(DbPage*);\n+SQLITE_PRIVATE void sqlite3PagerUnref(DbPage*);\n+SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage*);\n+SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage*);\n+\n+\/* Operations on page references. *\/\n+SQLITE_PRIVATE int sqlite3PagerWrite(DbPage*);\n+SQLITE_PRIVATE void sqlite3PagerDontWrite(DbPage*);\n+SQLITE_PRIVATE int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);\n+SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*);\n+SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *);\n+SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *);\n+\n+\/* Functions used to manage pager transactions and savepoints. *\/\n+SQLITE_PRIVATE void sqlite3PagerPagecount(Pager*, int*);\n+SQLITE_PRIVATE int sqlite3PagerBegin(Pager*, int exFlag, int);\n+SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*,const char *zSuper, int);\n+SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager*);\n+SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zSuper);\n+SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*);\n+SQLITE_PRIVATE int sqlite3PagerRollback(Pager*);\n+SQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int n);\n+SQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);\n+SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager);\n+\n+#ifndef SQLITE_OMIT_WAL\n+SQLITE_PRIVATE   int sqlite3PagerCheckpoint(Pager *pPager, sqlite3*, int, int*, int*);\n+SQLITE_PRIVATE   int sqlite3PagerWalSupported(Pager *pPager);\n+SQLITE_PRIVATE   int sqlite3PagerWalCallback(Pager *pPager);\n+SQLITE_PRIVATE   int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);\n+SQLITE_PRIVATE   int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);\n+# ifdef SQLITE_ENABLE_SNAPSHOT\n+SQLITE_PRIVATE   int sqlite3PagerSnapshotGet(Pager*, sqlite3_snapshot **ppSnapshot);\n+SQLITE_PRIVATE   int sqlite3PagerSnapshotOpen(Pager*, sqlite3_snapshot *pSnapshot);\n+SQLITE_PRIVATE   int sqlite3PagerSnapshotRecover(Pager *pPager);\n+SQLITE_PRIVATE   int sqlite3PagerSnapshotCheck(Pager *pPager, sqlite3_snapshot *pSnapshot);\n+SQLITE_PRIVATE   void sqlite3PagerSnapshotUnlock(Pager *pPager);\n+# endif\n+#endif\n+\n+#if !defined(SQLITE_OMIT_WAL) && defined(SQLITE_ENABLE_SETLK_TIMEOUT)\n+SQLITE_PRIVATE   int sqlite3PagerWalWriteLock(Pager*, int);\n+SQLITE_PRIVATE   void sqlite3PagerWalDb(Pager*, sqlite3*);\n+#else\n+# define sqlite3PagerWalWriteLock(y,z) SQLITE_OK\n+# define sqlite3PagerWalDb(x,y)\n+#endif\n+\n+#ifdef SQLITE_DIRECT_OVERFLOW_READ\n+SQLITE_PRIVATE   int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno);\n+#endif\n+\n+#ifdef SQLITE_ENABLE_ZIPVFS\n+SQLITE_PRIVATE   int sqlite3PagerWalFramesize(Pager *pPager);\n+#endif\n+\n+\/* Functions used to query pager state and configuration. *\/\n+SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager*);\n+SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager*);\n+#ifdef SQLITE_DEBUG\n+SQLITE_PRIVATE   int sqlite3PagerRefcount(Pager*);\n+#endif\n+SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager*);\n+SQLITE_PRIVATE const char *sqlite3PagerFilename(const Pager*, int);\n+SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager*);\n+SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*);\n+SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager*);\n+SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*);\n+SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*);\n+SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*);\n+SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);\n+SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*);\n+SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *);\n+\n+\/* Functions used to truncate the database file. *\/\n+SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno);\n+\n+SQLITE_PRIVATE void sqlite3PagerRekey(DbPage*, Pgno, u16);\n+\n+\/* Functions to support testing and debugging. *\/\n+#if !defined(NDEBUG) || defined(SQLITE_TEST)\n+SQLITE_PRIVATE   Pgno sqlite3PagerPagenumber(DbPage*);\n+SQLITE_PRIVATE   int sqlite3PagerIswriteable(DbPage*);\n+#endif\n+#ifdef SQLITE_TEST\n+SQLITE_PRIVATE   int *sqlite3PagerStats(Pager*);\n+SQLITE_PRIVATE   void sqlite3PagerRefdump(Pager*);\n+  void disable_simulated_io_errors(void);\n+  void enable_simulated_io_errors(void);\n+#else\n+# define disable_simulated_io_errors()\n+# define enable_simulated_io_errors()\n+#endif\n+\n+#endif \/* SQLITE_PAGER_H *\/\n+\n+\/************** End of pager.h ***********************************************\/\n+\/************** Continuing where we left off in sqliteInt.h ******************\/\n@@ -14796,2 +14677,2 @@\n-SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*,int);\n-SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree*);\n+SQLITE_PRIVATE Pgno sqlite3BtreeMaxPageCount(Btree*,Pgno);\n+SQLITE_PRIVATE Pgno sqlite3BtreeLastPage(Btree*);\n@@ -14804,1 +14685,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);\n+SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char*);\n@@ -14809,3 +14690,2 @@\n-SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, int*, int flags);\n-SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree*);\n-SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree*);\n+SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, Pgno*, int flags);\n+SQLITE_PRIVATE int sqlite3BtreeTxnState(Btree*);\n@@ -14813,0 +14693,1 @@\n+\n@@ -14818,0 +14699,3 @@\n+\n+\/* Savepoints are named, nestable SQL transactions mostly implemented *\/\n+\/* in vdbe.c and pager.c See https:\/\/sqlite.org\/lang_savepoint.html *\/\n@@ -14820,0 +14704,5 @@\n+\/* \"Checkpoint\" only refers to WAL. See https:\/\/sqlite.org\/wal.html#ckpt *\/\n+#ifndef SQLITE_OMIT_WAL\n+SQLITE_PRIVATE   int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);\n+#endif\n+\n@@ -14840,1 +14729,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, int*);\n+SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, i64*);\n@@ -14950,1 +14839,1 @@\n-  int iTable,                          \/* Index of root page *\/\n+  Pgno iTable,                         \/* Index of root page *\/\n@@ -14964,1 +14853,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(\n+SQLITE_PRIVATE int sqlite3BtreeTableMoveto(\n@@ -14966,1 +14855,0 @@\n-  UnpackedRecord *pUnKey,\n@@ -14971,0 +14859,5 @@\n+SQLITE_PRIVATE int sqlite3BtreeIndexMoveto(\n+  BtCursor*,\n+  UnpackedRecord *pUnKey,\n+  int *pRes\n+);\n@@ -14979,0 +14872,1 @@\n+#define BTREE_PREFORMAT    0x80  \/* Inserted data is a preformated cell *\/\n@@ -15041,1 +14935,1 @@\n-SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(sqlite3*,Btree*,int*aRoot,int nRoot,int,int*);\n+SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(sqlite3*,Btree*,Pgno*aRoot,int nRoot,int,int*);\n@@ -15056,0 +14950,6 @@\n+#ifdef SQLITE_DEBUG\n+SQLITE_PRIVATE sqlite3_uint64 sqlite3BtreeSeekCount(Btree*);\n+#else\n+# define sqlite3BtreeSeekCount(X) 0\n+#endif\n+\n@@ -15072,0 +14972,2 @@\n+SQLITE_PRIVATE int sqlite3BtreeTransferRow(BtCursor*, BtCursor*, i64);\n+\n@@ -15178,1 +15080,1 @@\n-    int *ai;               \/* Used when p4type is P4_INTARRAY *\/\n+    u32 *ai;               \/* Used when p4type is P4_INTARRAY *\/\n@@ -15312,22 +15214,22 @@\n-#define OP_IfNullRow      21 \/* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 *\/\n-#define OP_SeekLT         22 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekLE         23 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekGE         24 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekGT         25 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IfNotOpen      26 \/* jump, synopsis: if( !csr[P1] ) goto P2     *\/\n-#define OP_IfNoHope       27 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_NoConflict     28 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_NotFound       29 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_Found          30 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekRowid      31 \/* jump, synopsis: intkey=r[P3]               *\/\n-#define OP_NotExists      32 \/* jump, synopsis: intkey=r[P3]               *\/\n-#define OP_Last           33 \/* jump                                       *\/\n-#define OP_IfSmaller      34 \/* jump                                       *\/\n-#define OP_SorterSort     35 \/* jump                                       *\/\n-#define OP_Sort           36 \/* jump                                       *\/\n-#define OP_Rewind         37 \/* jump                                       *\/\n-#define OP_IdxLE          38 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IdxGT          39 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IdxLT          40 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IdxGE          41 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_RowSetRead     42 \/* jump, synopsis: r[P3]=rowset(P1)           *\/\n+#define OP_IsNullOrType   21 \/* jump, synopsis: if typeof(r[P1]) IN (P3,5) goto P2 *\/\n+#define OP_IfNullRow      22 \/* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 *\/\n+#define OP_SeekLT         23 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekLE         24 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekGE         25 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekGT         26 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IfNotOpen      27 \/* jump, synopsis: if( !csr[P1] ) goto P2     *\/\n+#define OP_IfNoHope       28 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_NoConflict     29 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_NotFound       30 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_Found          31 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekRowid      32 \/* jump, synopsis: intkey=r[P3]               *\/\n+#define OP_NotExists      33 \/* jump, synopsis: intkey=r[P3]               *\/\n+#define OP_Last           34 \/* jump                                       *\/\n+#define OP_IfSmaller      35 \/* jump                                       *\/\n+#define OP_SorterSort     36 \/* jump                                       *\/\n+#define OP_Sort           37 \/* jump                                       *\/\n+#define OP_Rewind         38 \/* jump                                       *\/\n+#define OP_IdxLE          39 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IdxGT          40 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IdxLT          41 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IdxGE          42 \/* jump, synopsis: key=r[P3@P4]               *\/\n@@ -15336,5 +15238,5 @@\n-#define OP_RowSetTest     45 \/* jump, synopsis: if r[P3] in rowset(P1) goto P2 *\/\n-#define OP_Program        46 \/* jump                                       *\/\n-#define OP_FkIfZero       47 \/* jump, synopsis: if fkctr[P1]==0 goto P2    *\/\n-#define OP_IfPos          48 \/* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 *\/\n-#define OP_IfNotZero      49 \/* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 *\/\n+#define OP_RowSetRead     45 \/* jump, synopsis: r[P3]=rowset(P1)           *\/\n+#define OP_RowSetTest     46 \/* jump, synopsis: if r[P3] in rowset(P1) goto P2 *\/\n+#define OP_Program        47 \/* jump                                       *\/\n+#define OP_FkIfZero       48 \/* jump, synopsis: if fkctr[P1]==0 goto P2    *\/\n+#define OP_IfPos          49 \/* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 *\/\n@@ -15349,118 +15251,124 @@\n-#define OP_ElseNotEq      58 \/* jump, same as TK_ESCAPE                    *\/\n-#define OP_DecrJumpZero   59 \/* jump, synopsis: if (--r[P1])==0 goto P2    *\/\n-#define OP_IncrVacuum     60 \/* jump                                       *\/\n-#define OP_VNext          61 \/* jump                                       *\/\n-#define OP_Init           62 \/* jump, synopsis: Start at P2                *\/\n-#define OP_PureFunc       63 \/* synopsis: r[P3]=func(r[P2@NP])             *\/\n-#define OP_Function       64 \/* synopsis: r[P3]=func(r[P2@NP])             *\/\n-#define OP_Return         65\n-#define OP_EndCoroutine   66\n-#define OP_HaltIfNull     67 \/* synopsis: if r[P3]=null halt               *\/\n-#define OP_Halt           68\n-#define OP_Integer        69 \/* synopsis: r[P2]=P1                         *\/\n-#define OP_Int64          70 \/* synopsis: r[P2]=P4                         *\/\n-#define OP_String         71 \/* synopsis: r[P2]='P4' (len=P1)              *\/\n-#define OP_Null           72 \/* synopsis: r[P2..P3]=NULL                   *\/\n-#define OP_SoftNull       73 \/* synopsis: r[P1]=NULL                       *\/\n-#define OP_Blob           74 \/* synopsis: r[P2]=P4 (len=P1)                *\/\n-#define OP_Variable       75 \/* synopsis: r[P2]=parameter(P1,P4)           *\/\n-#define OP_Move           76 \/* synopsis: r[P2@P3]=r[P1@P3]                *\/\n-#define OP_Copy           77 \/* synopsis: r[P2@P3+1]=r[P1@P3+1]            *\/\n-#define OP_SCopy          78 \/* synopsis: r[P2]=r[P1]                      *\/\n-#define OP_IntCopy        79 \/* synopsis: r[P2]=r[P1]                      *\/\n-#define OP_ResultRow      80 \/* synopsis: output=r[P1@P2]                  *\/\n-#define OP_CollSeq        81\n-#define OP_AddImm         82 \/* synopsis: r[P1]=r[P1]+P2                   *\/\n-#define OP_RealAffinity   83\n-#define OP_Cast           84 \/* synopsis: affinity(r[P1])                  *\/\n-#define OP_Permutation    85\n-#define OP_Compare        86 \/* synopsis: r[P1@P3] <-> r[P2@P3]            *\/\n-#define OP_IsTrue         87 \/* synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4 *\/\n-#define OP_Offset         88 \/* synopsis: r[P3] = sqlite_offset(P1)        *\/\n-#define OP_Column         89 \/* synopsis: r[P3]=PX                         *\/\n-#define OP_Affinity       90 \/* synopsis: affinity(r[P1@P2])               *\/\n-#define OP_MakeRecord     91 \/* synopsis: r[P3]=mkrec(r[P1@P2])            *\/\n-#define OP_Count          92 \/* synopsis: r[P2]=count()                    *\/\n-#define OP_ReadCookie     93\n-#define OP_SetCookie      94\n-#define OP_ReopenIdx      95 \/* synopsis: root=P2 iDb=P3                   *\/\n-#define OP_OpenRead       96 \/* synopsis: root=P2 iDb=P3                   *\/\n-#define OP_OpenWrite      97 \/* synopsis: root=P2 iDb=P3                   *\/\n-#define OP_OpenDup        98\n-#define OP_OpenAutoindex  99 \/* synopsis: nColumn=P2                       *\/\n-#define OP_OpenEphemeral 100 \/* synopsis: nColumn=P2                       *\/\n-#define OP_BitAnd        101 \/* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] *\/\n-#define OP_BitOr         102 \/* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] *\/\n-#define OP_ShiftLeft     103 \/* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] *\/\n-#define OP_ShiftRight    104 \/* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] *\/\n-#define OP_Add           105 \/* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] *\/\n-#define OP_Subtract      106 \/* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] *\/\n-#define OP_Multiply      107 \/* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] *\/\n-#define OP_Divide        108 \/* same as TK_SLASH, synopsis: r[P3]=r[P2]\/r[P1] *\/\n-#define OP_Remainder     109 \/* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] *\/\n-#define OP_Concat        110 \/* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] *\/\n-#define OP_SorterOpen    111\n-#define OP_BitNot        112 \/* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] *\/\n-#define OP_SequenceTest  113 \/* synopsis: if( cursor[P1].ctr++ ) pc = P2   *\/\n-#define OP_OpenPseudo    114 \/* synopsis: P3 columns in r[P2]              *\/\n-#define OP_String8       115 \/* same as TK_STRING, synopsis: r[P2]='P4'    *\/\n-#define OP_Close         116\n-#define OP_ColumnsUsed   117\n-#define OP_SeekHit       118 \/* synopsis: seekHit=P2                       *\/\n-#define OP_Sequence      119 \/* synopsis: r[P2]=cursor[P1].ctr++           *\/\n-#define OP_NewRowid      120 \/* synopsis: r[P2]=rowid                      *\/\n-#define OP_Insert        121 \/* synopsis: intkey=r[P3] data=r[P2]          *\/\n-#define OP_Delete        122\n-#define OP_ResetCount    123\n-#define OP_SorterCompare 124 \/* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 *\/\n-#define OP_SorterData    125 \/* synopsis: r[P2]=data                       *\/\n-#define OP_RowData       126 \/* synopsis: r[P2]=data                       *\/\n-#define OP_Rowid         127 \/* synopsis: r[P2]=rowid                      *\/\n-#define OP_NullRow       128\n-#define OP_SeekEnd       129\n-#define OP_IdxInsert     130 \/* synopsis: key=r[P2]                        *\/\n-#define OP_SorterInsert  131 \/* synopsis: key=r[P2]                        *\/\n-#define OP_IdxDelete     132 \/* synopsis: key=r[P2@P3]                     *\/\n-#define OP_DeferredSeek  133 \/* synopsis: Move P3 to P1.rowid if needed    *\/\n-#define OP_IdxRowid      134 \/* synopsis: r[P2]=rowid                      *\/\n-#define OP_FinishSeek    135\n-#define OP_Destroy       136\n-#define OP_Clear         137\n-#define OP_ResetSorter   138\n-#define OP_CreateBtree   139 \/* synopsis: r[P2]=root iDb=P1 flags=P3       *\/\n-#define OP_SqlExec       140\n-#define OP_ParseSchema   141\n-#define OP_LoadAnalysis  142\n-#define OP_DropTable     143\n-#define OP_DropIndex     144\n-#define OP_DropTrigger   145\n-#define OP_IntegrityCk   146\n-#define OP_RowSetAdd     147 \/* synopsis: rowset(P1)=r[P2]                 *\/\n-#define OP_Param         148\n-#define OP_FkCounter     149 \/* synopsis: fkctr[P1]+=P2                    *\/\n-#define OP_Real          150 \/* same as TK_FLOAT, synopsis: r[P2]=P4       *\/\n-#define OP_MemMax        151 \/* synopsis: r[P1]=max(r[P1],r[P2])           *\/\n-#define OP_OffsetLimit   152 \/* synopsis: if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) *\/\n-#define OP_AggInverse    153 \/* synopsis: accum=r[P3] inverse(r[P2@P5])    *\/\n-#define OP_AggStep       154 \/* synopsis: accum=r[P3] step(r[P2@P5])       *\/\n-#define OP_AggStep1      155 \/* synopsis: accum=r[P3] step(r[P2@P5])       *\/\n-#define OP_AggValue      156 \/* synopsis: r[P3]=value N=P2                 *\/\n-#define OP_AggFinal      157 \/* synopsis: accum=r[P1] N=P2                 *\/\n-#define OP_Expire        158\n-#define OP_CursorLock    159\n-#define OP_CursorUnlock  160\n-#define OP_TableLock     161 \/* synopsis: iDb=P1 root=P2 write=P3          *\/\n-#define OP_VBegin        162\n-#define OP_VCreate       163\n-#define OP_VDestroy      164\n-#define OP_VOpen         165\n-#define OP_VColumn       166 \/* synopsis: r[P3]=vcolumn(P2)                *\/\n-#define OP_VRename       167\n-#define OP_Pagecount     168\n-#define OP_MaxPgcnt      169\n-#define OP_Trace         170\n-#define OP_CursorHint    171\n-#define OP_ReleaseReg    172 \/* synopsis: release r[P1@P2] mask P3         *\/\n-#define OP_Noop          173\n-#define OP_Explain       174\n-#define OP_Abortable     175\n+#define OP_ElseEq         58 \/* jump, same as TK_ESCAPE                    *\/\n+#define OP_IfNotZero      59 \/* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 *\/\n+#define OP_DecrJumpZero   60 \/* jump, synopsis: if (--r[P1])==0 goto P2    *\/\n+#define OP_IncrVacuum     61 \/* jump                                       *\/\n+#define OP_VNext          62 \/* jump                                       *\/\n+#define OP_Init           63 \/* jump, synopsis: Start at P2                *\/\n+#define OP_PureFunc       64 \/* synopsis: r[P3]=func(r[P2@NP])             *\/\n+#define OP_Function       65 \/* synopsis: r[P3]=func(r[P2@NP])             *\/\n+#define OP_Return         66\n+#define OP_EndCoroutine   67\n+#define OP_HaltIfNull     68 \/* synopsis: if r[P3]=null halt               *\/\n+#define OP_Halt           69\n+#define OP_Integer        70 \/* synopsis: r[P2]=P1                         *\/\n+#define OP_Int64          71 \/* synopsis: r[P2]=P4                         *\/\n+#define OP_String         72 \/* synopsis: r[P2]='P4' (len=P1)              *\/\n+#define OP_Null           73 \/* synopsis: r[P2..P3]=NULL                   *\/\n+#define OP_SoftNull       74 \/* synopsis: r[P1]=NULL                       *\/\n+#define OP_Blob           75 \/* synopsis: r[P2]=P4 (len=P1)                *\/\n+#define OP_Variable       76 \/* synopsis: r[P2]=parameter(P1,P4)           *\/\n+#define OP_Move           77 \/* synopsis: r[P2@P3]=r[P1@P3]                *\/\n+#define OP_Copy           78 \/* synopsis: r[P2@P3+1]=r[P1@P3+1]            *\/\n+#define OP_SCopy          79 \/* synopsis: r[P2]=r[P1]                      *\/\n+#define OP_IntCopy        80 \/* synopsis: r[P2]=r[P1]                      *\/\n+#define OP_ChngCntRow     81 \/* synopsis: output=r[P1]                     *\/\n+#define OP_ResultRow      82 \/* synopsis: output=r[P1@P2]                  *\/\n+#define OP_CollSeq        83\n+#define OP_AddImm         84 \/* synopsis: r[P1]=r[P1]+P2                   *\/\n+#define OP_RealAffinity   85\n+#define OP_Cast           86 \/* synopsis: affinity(r[P1])                  *\/\n+#define OP_Permutation    87\n+#define OP_Compare        88 \/* synopsis: r[P1@P3] <-> r[P2@P3]            *\/\n+#define OP_IsTrue         89 \/* synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4 *\/\n+#define OP_ZeroOrNull     90 \/* synopsis: r[P2] = 0 OR NULL                *\/\n+#define OP_Offset         91 \/* synopsis: r[P3] = sqlite_offset(P1)        *\/\n+#define OP_Column         92 \/* synopsis: r[P3]=PX                         *\/\n+#define OP_TypeCheck      93 \/* synopsis: typecheck(r[P1@P2])              *\/\n+#define OP_Affinity       94 \/* synopsis: affinity(r[P1@P2])               *\/\n+#define OP_MakeRecord     95 \/* synopsis: r[P3]=mkrec(r[P1@P2])            *\/\n+#define OP_Count          96 \/* synopsis: r[P2]=count()                    *\/\n+#define OP_ReadCookie     97\n+#define OP_SetCookie      98\n+#define OP_ReopenIdx      99 \/* synopsis: root=P2 iDb=P3                   *\/\n+#define OP_OpenRead      100 \/* synopsis: root=P2 iDb=P3                   *\/\n+#define OP_OpenWrite     101 \/* synopsis: root=P2 iDb=P3                   *\/\n+#define OP_BitAnd        102 \/* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] *\/\n+#define OP_BitOr         103 \/* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] *\/\n+#define OP_ShiftLeft     104 \/* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] *\/\n+#define OP_ShiftRight    105 \/* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] *\/\n+#define OP_Add           106 \/* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] *\/\n+#define OP_Subtract      107 \/* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] *\/\n+#define OP_Multiply      108 \/* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] *\/\n+#define OP_Divide        109 \/* same as TK_SLASH, synopsis: r[P3]=r[P2]\/r[P1] *\/\n+#define OP_Remainder     110 \/* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] *\/\n+#define OP_Concat        111 \/* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] *\/\n+#define OP_OpenDup       112\n+#define OP_BitNot        113 \/* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] *\/\n+#define OP_OpenAutoindex 114 \/* synopsis: nColumn=P2                       *\/\n+#define OP_OpenEphemeral 115 \/* synopsis: nColumn=P2                       *\/\n+#define OP_String8       116 \/* same as TK_STRING, synopsis: r[P2]='P4'    *\/\n+#define OP_SorterOpen    117\n+#define OP_SequenceTest  118 \/* synopsis: if( cursor[P1].ctr++ ) pc = P2   *\/\n+#define OP_OpenPseudo    119 \/* synopsis: P3 columns in r[P2]              *\/\n+#define OP_Close         120\n+#define OP_ColumnsUsed   121\n+#define OP_SeekScan      122 \/* synopsis: Scan-ahead up to P1 rows         *\/\n+#define OP_SeekHit       123 \/* synopsis: set P2<=seekHit<=P3              *\/\n+#define OP_Sequence      124 \/* synopsis: r[P2]=cursor[P1].ctr++           *\/\n+#define OP_NewRowid      125 \/* synopsis: r[P2]=rowid                      *\/\n+#define OP_Insert        126 \/* synopsis: intkey=r[P3] data=r[P2]          *\/\n+#define OP_RowCell       127\n+#define OP_Delete        128\n+#define OP_ResetCount    129\n+#define OP_SorterCompare 130 \/* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 *\/\n+#define OP_SorterData    131 \/* synopsis: r[P2]=data                       *\/\n+#define OP_RowData       132 \/* synopsis: r[P2]=data                       *\/\n+#define OP_Rowid         133 \/* synopsis: r[P2]=rowid                      *\/\n+#define OP_NullRow       134\n+#define OP_SeekEnd       135\n+#define OP_IdxInsert     136 \/* synopsis: key=r[P2]                        *\/\n+#define OP_SorterInsert  137 \/* synopsis: key=r[P2]                        *\/\n+#define OP_IdxDelete     138 \/* synopsis: key=r[P2@P3]                     *\/\n+#define OP_DeferredSeek  139 \/* synopsis: Move P3 to P1.rowid if needed    *\/\n+#define OP_IdxRowid      140 \/* synopsis: r[P2]=rowid                      *\/\n+#define OP_FinishSeek    141\n+#define OP_Destroy       142\n+#define OP_Clear         143\n+#define OP_ResetSorter   144\n+#define OP_CreateBtree   145 \/* synopsis: r[P2]=root iDb=P1 flags=P3       *\/\n+#define OP_SqlExec       146\n+#define OP_ParseSchema   147\n+#define OP_LoadAnalysis  148\n+#define OP_DropTable     149\n+#define OP_DropIndex     150\n+#define OP_DropTrigger   151\n+#define OP_Real          152 \/* same as TK_FLOAT, synopsis: r[P2]=P4       *\/\n+#define OP_IntegrityCk   153\n+#define OP_RowSetAdd     154 \/* synopsis: rowset(P1)=r[P2]                 *\/\n+#define OP_Param         155\n+#define OP_FkCounter     156 \/* synopsis: fkctr[P1]+=P2                    *\/\n+#define OP_MemMax        157 \/* synopsis: r[P1]=max(r[P1],r[P2])           *\/\n+#define OP_OffsetLimit   158 \/* synopsis: if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) *\/\n+#define OP_AggInverse    159 \/* synopsis: accum=r[P3] inverse(r[P2@P5])    *\/\n+#define OP_AggStep       160 \/* synopsis: accum=r[P3] step(r[P2@P5])       *\/\n+#define OP_AggStep1      161 \/* synopsis: accum=r[P3] step(r[P2@P5])       *\/\n+#define OP_AggValue      162 \/* synopsis: r[P3]=value N=P2                 *\/\n+#define OP_AggFinal      163 \/* synopsis: accum=r[P1] N=P2                 *\/\n+#define OP_Expire        164\n+#define OP_CursorLock    165\n+#define OP_CursorUnlock  166\n+#define OP_TableLock     167 \/* synopsis: iDb=P1 root=P2 write=P3          *\/\n+#define OP_VBegin        168\n+#define OP_VCreate       169\n+#define OP_VDestroy      170\n+#define OP_VOpen         171\n+#define OP_VColumn       172 \/* synopsis: r[P3]=vcolumn(P2)                *\/\n+#define OP_VRename       173\n+#define OP_Pagecount     174\n+#define OP_MaxPgcnt      175\n+#define OP_Trace         176\n+#define OP_CursorHint    177\n+#define OP_ReleaseReg    178 \/* synopsis: release r[P1@P2] mask P3         *\/\n+#define OP_Noop          179\n+#define OP_Explain       180\n+#define OP_Abortable     181\n@@ -15481,18 +15389,18 @@\n-\/*  16 *\/ 0x01, 0x01, 0x03, 0x12, 0x03, 0x01, 0x09, 0x09,\\\n-\/*  24 *\/ 0x09, 0x09, 0x01, 0x09, 0x09, 0x09, 0x09, 0x09,\\\n-\/*  32 *\/ 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\\\n-\/*  40 *\/ 0x01, 0x01, 0x23, 0x26, 0x26, 0x0b, 0x01, 0x01,\\\n-\/*  48 *\/ 0x03, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\\\n-\/*  56 *\/ 0x0b, 0x0b, 0x01, 0x03, 0x01, 0x01, 0x01, 0x00,\\\n-\/*  64 *\/ 0x00, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10, 0x10,\\\n-\/*  72 *\/ 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10,\\\n-\/*  80 *\/ 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00, 0x12,\\\n-\/*  88 *\/ 0x20, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\\\n-\/*  96 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x26, 0x26,\\\n-\/* 104 *\/ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00,\\\n-\/* 112 *\/ 0x12, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,\\\n-\/* 120 *\/ 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\\\n-\/* 128 *\/ 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x10, 0x00,\\\n-\/* 136 *\/ 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,\\\n-\/* 144 *\/ 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x10, 0x04,\\\n-\/* 152 *\/ 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\\\n+\/*  16 *\/ 0x01, 0x01, 0x03, 0x12, 0x03, 0x03, 0x01, 0x09,\\\n+\/*  24 *\/ 0x09, 0x09, 0x09, 0x01, 0x09, 0x09, 0x09, 0x09,\\\n+\/*  32 *\/ 0x09, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\\\n+\/*  40 *\/ 0x01, 0x01, 0x01, 0x26, 0x26, 0x23, 0x0b, 0x01,\\\n+\/*  48 *\/ 0x01, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\\\n+\/*  56 *\/ 0x0b, 0x0b, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01,\\\n+\/*  64 *\/ 0x00, 0x00, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10,\\\n+\/*  72 *\/ 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10,\\\n+\/*  80 *\/ 0x10, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00,\\\n+\/*  88 *\/ 0x00, 0x12, 0x1e, 0x20, 0x00, 0x00, 0x00, 0x00,\\\n+\/*  96 *\/ 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x26, 0x26,\\\n+\/* 104 *\/ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,\\\n+\/* 112 *\/ 0x00, 0x12, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\\\n+\/* 120 *\/ 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\\\n+\/* 128 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,\\\n+\/* 136 *\/ 0x04, 0x04, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00,\\\n+\/* 144 *\/ 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\\\n+\/* 152 *\/ 0x10, 0x00, 0x06, 0x10, 0x00, 0x04, 0x1a, 0x00,\\\n@@ -15500,2 +15408,2 @@\n-\/* 168 *\/ 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\\\n-}\n+\/* 168 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,\\\n+\/* 176 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,}\n@@ -15503,1 +15411,1 @@\n-\/* The sqlite3P2Values() routine is able to run faster if it knows\n+\/* The resolve3P2Values() routine is able to run faster if it knows\n@@ -15509,1 +15417,1 @@\n-#define SQLITE_MX_JUMP_OPCODE  62  \/* Maximum JUMP opcode *\/\n+#define SQLITE_MX_JUMP_OPCODE  63  \/* Maximum JUMP opcode *\/\n@@ -15569,1 +15477,1 @@\n-SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*,int,char*);\n+SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*, int, char*, u16);\n@@ -15743,247 +15651,0 @@\n-\/************** Include pager.h in the middle of sqliteInt.h *****************\/\n-\/************** Begin file pager.h *******************************************\/\n-\/*\n-** 2001 September 15\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-*************************************************************************\n-** This header file defines the interface that the sqlite page cache\n-** subsystem.  The page cache subsystem reads and writes a file a page\n-** at a time and provides a journal for rollback.\n-*\/\n-\n-#ifndef SQLITE_PAGER_H\n-#define SQLITE_PAGER_H\n-\n-\/*\n-** Default maximum size for persistent journal files. A negative\n-** value means no limit. This value may be overridden using the\n-** sqlite3PagerJournalSizeLimit() API. See also \"PRAGMA journal_size_limit\".\n-*\/\n-#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT\n-  #define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1\n-#endif\n-\n-\/*\n-** The type used to represent a page number.  The first page in a file\n-** is called page 1.  0 is used to represent \"not a page\".\n-*\/\n-typedef u32 Pgno;\n-\n-\/*\n-** Each open file is managed by a separate instance of the \"Pager\" structure.\n-*\/\n-typedef struct Pager Pager;\n-\n-\/*\n-** Handle type for pages.\n-*\/\n-typedef struct PgHdr DbPage;\n-\n-\/*\n-** Page number PAGER_MJ_PGNO is never used in an SQLite database (it is\n-** reserved for working around a windows\/posix incompatibility). It is\n-** used in the journal to signify that the remainder of the journal file\n-** is devoted to storing a master journal name - there are no more pages to\n-** roll back. See comments for function writeMasterJournal() in pager.c\n-** for details.\n-*\/\n-#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE\/((x)->pageSize))+1))\n-\n-\/*\n-** Allowed values for the flags parameter to sqlite3PagerOpen().\n-**\n-** NOTE: These values must match the corresponding BTREE_ values in btree.h.\n-*\/\n-#define PAGER_OMIT_JOURNAL  0x0001    \/* Do not use a rollback journal *\/\n-#define PAGER_MEMORY        0x0002    \/* In-memory database *\/\n-\n-\/*\n-** Valid values for the second argument to sqlite3PagerLockingMode().\n-*\/\n-#define PAGER_LOCKINGMODE_QUERY      -1\n-#define PAGER_LOCKINGMODE_NORMAL      0\n-#define PAGER_LOCKINGMODE_EXCLUSIVE   1\n-\n-\/*\n-** Numeric constants that encode the journalmode.\n-**\n-** The numeric values encoded here (other than PAGER_JOURNALMODE_QUERY)\n-** are exposed in the API via the \"PRAGMA journal_mode\" command and\n-** therefore cannot be changed without a compatibility break.\n-*\/\n-#define PAGER_JOURNALMODE_QUERY     (-1)  \/* Query the value of journalmode *\/\n-#define PAGER_JOURNALMODE_DELETE      0   \/* Commit by deleting journal file *\/\n-#define PAGER_JOURNALMODE_PERSIST     1   \/* Commit by zeroing journal header *\/\n-#define PAGER_JOURNALMODE_OFF         2   \/* Journal omitted.  *\/\n-#define PAGER_JOURNALMODE_TRUNCATE    3   \/* Commit by truncating journal *\/\n-#define PAGER_JOURNALMODE_MEMORY      4   \/* In-memory journal file *\/\n-#define PAGER_JOURNALMODE_WAL         5   \/* Use write-ahead logging *\/\n-\n-\/*\n-** Flags that make up the mask passed to sqlite3PagerGet().\n-*\/\n-#define PAGER_GET_NOCONTENT     0x01  \/* Do not load data from disk *\/\n-#define PAGER_GET_READONLY      0x02  \/* Read-only page is acceptable *\/\n-\n-\/*\n-** Flags for sqlite3PagerSetFlags()\n-**\n-** Value constraints (enforced via assert()):\n-**    PAGER_FULLFSYNC      == SQLITE_FullFSync\n-**    PAGER_CKPT_FULLFSYNC == SQLITE_CkptFullFSync\n-**    PAGER_CACHE_SPILL    == SQLITE_CacheSpill\n-*\/\n-#define PAGER_SYNCHRONOUS_OFF       0x01  \/* PRAGMA synchronous=OFF *\/\n-#define PAGER_SYNCHRONOUS_NORMAL    0x02  \/* PRAGMA synchronous=NORMAL *\/\n-#define PAGER_SYNCHRONOUS_FULL      0x03  \/* PRAGMA synchronous=FULL *\/\n-#define PAGER_SYNCHRONOUS_EXTRA     0x04  \/* PRAGMA synchronous=EXTRA *\/\n-#define PAGER_SYNCHRONOUS_MASK      0x07  \/* Mask for four values above *\/\n-#define PAGER_FULLFSYNC             0x08  \/* PRAGMA fullfsync=ON *\/\n-#define PAGER_CKPT_FULLFSYNC        0x10  \/* PRAGMA checkpoint_fullfsync=ON *\/\n-#define PAGER_CACHESPILL            0x20  \/* PRAGMA cache_spill=ON *\/\n-#define PAGER_FLAGS_MASK            0x38  \/* All above except SYNCHRONOUS *\/\n-\n-\/*\n-** The remainder of this file contains the declarations of the functions\n-** that make up the Pager sub-system API. See source code comments for\n-** a detailed description of each routine.\n-*\/\n-\n-\/* Open and close a Pager connection. *\/\n-SQLITE_PRIVATE int sqlite3PagerOpen(\n-  sqlite3_vfs*,\n-  Pager **ppPager,\n-  const char*,\n-  int,\n-  int,\n-  int,\n-  void(*)(DbPage*)\n-);\n-SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3*);\n-SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);\n-\n-\/* Functions used to configure a Pager object. *\/\n-SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);\n-SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);\n-SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int);\n-SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);\n-SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager*, int);\n-SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);\n-SQLITE_PRIVATE void sqlite3PagerShrink(Pager*);\n-SQLITE_PRIVATE void sqlite3PagerSetFlags(Pager*,unsigned);\n-SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int);\n-SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *, int);\n-SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager*);\n-SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager*);\n-SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64);\n-SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager*);\n-SQLITE_PRIVATE int sqlite3PagerFlush(Pager*);\n-\n-\/* Functions used to obtain and release page references. *\/\n-SQLITE_PRIVATE int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);\n-SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);\n-SQLITE_PRIVATE void sqlite3PagerRef(DbPage*);\n-SQLITE_PRIVATE void sqlite3PagerUnref(DbPage*);\n-SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage*);\n-SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage*);\n-\n-\/* Operations on page references. *\/\n-SQLITE_PRIVATE int sqlite3PagerWrite(DbPage*);\n-SQLITE_PRIVATE void sqlite3PagerDontWrite(DbPage*);\n-SQLITE_PRIVATE int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);\n-SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*);\n-SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *);\n-SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *);\n-\n-\/* Functions used to manage pager transactions and savepoints. *\/\n-SQLITE_PRIVATE void sqlite3PagerPagecount(Pager*, int*);\n-SQLITE_PRIVATE int sqlite3PagerBegin(Pager*, int exFlag, int);\n-SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*,const char *zMaster, int);\n-SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager*);\n-SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster);\n-SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*);\n-SQLITE_PRIVATE int sqlite3PagerRollback(Pager*);\n-SQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int n);\n-SQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);\n-SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager);\n-\n-#ifndef SQLITE_OMIT_WAL\n-SQLITE_PRIVATE   int sqlite3PagerCheckpoint(Pager *pPager, sqlite3*, int, int*, int*);\n-SQLITE_PRIVATE   int sqlite3PagerWalSupported(Pager *pPager);\n-SQLITE_PRIVATE   int sqlite3PagerWalCallback(Pager *pPager);\n-SQLITE_PRIVATE   int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);\n-SQLITE_PRIVATE   int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);\n-# ifdef SQLITE_ENABLE_SNAPSHOT\n-SQLITE_PRIVATE   int sqlite3PagerSnapshotGet(Pager*, sqlite3_snapshot **ppSnapshot);\n-SQLITE_PRIVATE   int sqlite3PagerSnapshotOpen(Pager*, sqlite3_snapshot *pSnapshot);\n-SQLITE_PRIVATE   int sqlite3PagerSnapshotRecover(Pager *pPager);\n-SQLITE_PRIVATE   int sqlite3PagerSnapshotCheck(Pager *pPager, sqlite3_snapshot *pSnapshot);\n-SQLITE_PRIVATE   void sqlite3PagerSnapshotUnlock(Pager *pPager);\n-# endif\n-#endif\n-\n-#if !defined(SQLITE_OMIT_WAL) && defined(SQLITE_ENABLE_SETLK_TIMEOUT)\n-SQLITE_PRIVATE   int sqlite3PagerWalWriteLock(Pager*, int);\n-SQLITE_PRIVATE   void sqlite3PagerWalDb(Pager*, sqlite3*);\n-#else\n-# define sqlite3PagerWalWriteLock(y,z) SQLITE_OK\n-# define sqlite3PagerWalDb(x,y)\n-#endif\n-\n-#ifdef SQLITE_DIRECT_OVERFLOW_READ\n-SQLITE_PRIVATE   int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno);\n-#endif\n-\n-#ifdef SQLITE_ENABLE_ZIPVFS\n-SQLITE_PRIVATE   int sqlite3PagerWalFramesize(Pager *pPager);\n-#endif\n-\n-\/* Functions used to query pager state and configuration. *\/\n-SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager*);\n-SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager*);\n-#ifdef SQLITE_DEBUG\n-SQLITE_PRIVATE   int sqlite3PagerRefcount(Pager*);\n-#endif\n-SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager*);\n-SQLITE_PRIVATE const char *sqlite3PagerFilename(const Pager*, int);\n-SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager*);\n-SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*);\n-SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager*);\n-SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*);\n-SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*);\n-SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*);\n-SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);\n-SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*);\n-SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *);\n-\n-\/* Functions used to truncate the database file. *\/\n-SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno);\n-\n-SQLITE_PRIVATE void sqlite3PagerRekey(DbPage*, Pgno, u16);\n-\n-\/* Functions to support testing and debugging. *\/\n-#if !defined(NDEBUG) || defined(SQLITE_TEST)\n-SQLITE_PRIVATE   Pgno sqlite3PagerPagenumber(DbPage*);\n-SQLITE_PRIVATE   int sqlite3PagerIswriteable(DbPage*);\n-#endif\n-#ifdef SQLITE_TEST\n-SQLITE_PRIVATE   int *sqlite3PagerStats(Pager*);\n-SQLITE_PRIVATE   void sqlite3PagerRefdump(Pager*);\n-  void disable_simulated_io_errors(void);\n-  void enable_simulated_io_errors(void);\n-#else\n-# define disable_simulated_io_errors()\n-# define enable_simulated_io_errors()\n-#endif\n-\n-#endif \/* SQLITE_PAGER_H *\/\n-\n-\/************** End of pager.h ***********************************************\/\n-\/************** Continuing where we left off in sqliteInt.h ******************\/\n@@ -16283,0 +15944,6 @@\n+\/* Maximum pathname length.  Note: FILENAME_MAX defined by stdio.h\n+*\/\n+#ifndef SQLITE_MAX_PATHLEN\n+# define SQLITE_MAX_PATHLEN FILENAME_MAX\n+#endif\n+\n@@ -16788,0 +16455,5 @@\n+\/*\n+** Maximum number of sqlite3.aDb[] entries.  This is the number of attached\n+** databases plus 2 for \"main\" and \"temp\".\n+*\/\n+#define SQLITE_MAX_DB (SQLITE_MAX_ATTACHED+2)\n@@ -16808,1 +16480,1 @@\n-  u16 dbOptFlags;               \/* Flags to enable\/disable optimizations *\/\n+  u32 dbOptFlags;               \/* Flags to enable\/disable optimizations *\/\n@@ -16822,0 +16494,1 @@\n+  u8 eOpenState;                \/* Current condition of the connection *\/\n@@ -16823,3 +16496,2 @@\n-  u32 magic;                    \/* Magic number for detect library misuse *\/\n-  int nChange;                  \/* Value returned by sqlite3_changes() *\/\n-  int nTotalChange;             \/* Value returned by sqlite3_total_changes() *\/\n+  i64 nChange;                  \/* Value returned by sqlite3_changes() *\/\n+  i64 nTotalChange;             \/* Value returned by sqlite3_total_changes() *\/\n@@ -16829,1 +16501,1 @@\n-    int newTnum;                \/* Rootpage of table being initialized *\/\n+    Pgno newTnum;               \/* Rootpage of table being initialized *\/\n@@ -16835,1 +16507,1 @@\n-    char **azInit;              \/* \"type\", \"name\", and \"tbl_name\" columns *\/\n+    const char **azInit;        \/* \"type\", \"name\", and \"tbl_name\" columns *\/\n@@ -16844,2 +16516,5 @@\n-  int (*xTrace)(u32,void*,void*,void*);     \/* Trace function *\/\n-  void *pTraceArg;                          \/* Argument to the trace function *\/\n+  union {\n+    void (*xLegacy)(void*,const char*);   \/* mTrace==SQLITE_TRACE_LEGACY *\/\n+    int (*xV2)(u32,void*,void*,void*);    \/* All other mTrace values *\/\n+  } trace;\n+  void *pTraceArg;                        \/* Argument to the trace function *\/\n@@ -16856,0 +16531,3 @@\n+  void *pAutovacPagesArg;           \/* Client argument to autovac_pages *\/\n+  void (*xAutovacDestr)(void*);     \/* Destructor for pAutovacPAgesArg *\/\n+  unsigned int (*xAutovacPages)(void*,const char*,u32,u32,u32);\n@@ -16906,1 +16584,1 @@\n-  \/* The following variables are all protected by the STATIC_MASTER\n+  \/* The following variables are all protected by the STATIC_MAIN\n@@ -16948,1 +16626,1 @@\n-#define SQLITE_WriteSchema    0x00000001  \/* OK to update SQLITE_MASTER *\/\n+#define SQLITE_WriteSchema    0x00000001  \/* OK to update SQLITE_SCHEMA *\/\n@@ -16985,0 +16663,1 @@\n+#define SQLITE_CorruptRdOnly  HI(0x00002) \/* Prohibit writes due to error *\/\n@@ -17012,18 +16691,22 @@\n-#define SQLITE_QueryFlattener 0x0001   \/* Query flattening *\/\n-#define SQLITE_WindowFunc     0x0002   \/* Use xInverse for window functions *\/\n-#define SQLITE_GroupByOrder   0x0004   \/* GROUPBY cover of ORDERBY *\/\n-#define SQLITE_FactorOutConst 0x0008   \/* Constant factoring *\/\n-#define SQLITE_DistinctOpt    0x0010   \/* DISTINCT using indexes *\/\n-#define SQLITE_CoverIdxScan   0x0020   \/* Covering index scans *\/\n-#define SQLITE_OrderByIdxJoin 0x0040   \/* ORDER BY of joins via index *\/\n-#define SQLITE_Transitive     0x0080   \/* Transitive constraints *\/\n-#define SQLITE_OmitNoopJoin   0x0100   \/* Omit unused tables in joins *\/\n-#define SQLITE_CountOfView    0x0200   \/* The count-of-view optimization *\/\n-#define SQLITE_CursorHints    0x0400   \/* Add OP_CursorHint opcodes *\/\n-#define SQLITE_Stat4          0x0800   \/* Use STAT4 data *\/\n-   \/* TH3 expects the Stat4   ^^^^^^ value to be 0x0800.  Don't change it *\/\n-#define SQLITE_PushDown       0x1000   \/* The push-down optimization *\/\n-#define SQLITE_SimplifyJoin   0x2000   \/* Convert LEFT JOIN to JOIN *\/\n-#define SQLITE_SkipScan       0x4000   \/* Skip-scans *\/\n-#define SQLITE_PropagateConst 0x8000   \/* The constant propagation opt *\/\n-#define SQLITE_AllOpts        0xffff   \/* All optimizations *\/\n+#define SQLITE_QueryFlattener 0x00000001 \/* Query flattening *\/\n+#define SQLITE_WindowFunc     0x00000002 \/* Use xInverse for window functions *\/\n+#define SQLITE_GroupByOrder   0x00000004 \/* GROUPBY cover of ORDERBY *\/\n+#define SQLITE_FactorOutConst 0x00000008 \/* Constant factoring *\/\n+#define SQLITE_DistinctOpt    0x00000010 \/* DISTINCT using indexes *\/\n+#define SQLITE_CoverIdxScan   0x00000020 \/* Covering index scans *\/\n+#define SQLITE_OrderByIdxJoin 0x00000040 \/* ORDER BY of joins via index *\/\n+#define SQLITE_Transitive     0x00000080 \/* Transitive constraints *\/\n+#define SQLITE_OmitNoopJoin   0x00000100 \/* Omit unused tables in joins *\/\n+#define SQLITE_CountOfView    0x00000200 \/* The count-of-view optimization *\/\n+#define SQLITE_CursorHints    0x00000400 \/* Add OP_CursorHint opcodes *\/\n+#define SQLITE_Stat4          0x00000800 \/* Use STAT4 data *\/\n+   \/* TH3 expects this value  ^^^^^^^^^^ to be 0x0000800. Don't change it *\/\n+#define SQLITE_PushDown       0x00001000 \/* The push-down optimization *\/\n+#define SQLITE_SimplifyJoin   0x00002000 \/* Convert LEFT JOIN to JOIN *\/\n+#define SQLITE_SkipScan       0x00004000 \/* Skip-scans *\/\n+#define SQLITE_PropagateConst 0x00008000 \/* The constant propagation opt *\/\n+#define SQLITE_MinMaxOpt      0x00010000 \/* The min\/max optimization *\/\n+#define SQLITE_SeekScan       0x00020000 \/* The OP_SeekScan optimization *\/\n+#define SQLITE_OmitOrderBy    0x00040000 \/* Omit pointless ORDER BY *\/\n+   \/* TH3 expects this value  ^^^^^^^^^^ to be 0x40000. Coordinate any change *\/\n+#define SQLITE_AllOpts        0xffffffff \/* All optimizations *\/\n@@ -17043,4 +16726,3 @@\n-\/*\n-** Possible values for the sqlite.magic field.\n-** The numbers are obtained at random and have no special meaning, other\n-** than being distinct from one another.\n+\/* Possible values for the sqlite3.eOpenState field.\n+** The numbers are randomly selected such that a minimum of three bits must\n+** change to convert any number to another or to zero\n@@ -17048,6 +16730,6 @@\n-#define SQLITE_MAGIC_OPEN     0xa029a697  \/* Database is open *\/\n-#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  \/* Database is closed *\/\n-#define SQLITE_MAGIC_SICK     0x4b771290  \/* Error and awaiting close *\/\n-#define SQLITE_MAGIC_BUSY     0xf03b7906  \/* Database currently in use *\/\n-#define SQLITE_MAGIC_ERROR    0xb5357930  \/* An SQLITE_MISUSE error occurred *\/\n-#define SQLITE_MAGIC_ZOMBIE   0x64cffc7f  \/* Close with last statement close *\/\n+#define SQLITE_STATE_OPEN     0x76  \/* Database is open *\/\n+#define SQLITE_STATE_CLOSED   0xce  \/* Database is closed *\/\n+#define SQLITE_STATE_SICK     0xba  \/* Error and awaiting close *\/\n+#define SQLITE_STATE_BUSY     0x6d  \/* Database currently in use *\/\n+#define SQLITE_STATE_ERROR    0xd5  \/* An SQLITE_MISUSE error occurred *\/\n+#define SQLITE_STATE_ZOMBIE   0xa7  \/* Close with last statement close *\/\n@@ -17078,1 +16760,1 @@\n-  } u;\n+  } u; \/* pHash if SQLITE_FUNC_BUILTIN, pDestructor otherwise *\/\n@@ -17108,6 +16790,7 @@\n-**     SQLITE_FUNC_MINMAX    ==  NC_MinMaxAgg      == SF_MinMaxAgg\n-**     SQLITE_FUNC_LENGTH    ==  OPFLAG_LENGTHARG\n-**     SQLITE_FUNC_TYPEOF    ==  OPFLAG_TYPEOFARG\n-**     SQLITE_FUNC_CONSTANT  ==  SQLITE_DETERMINISTIC from the API\n-**     SQLITE_FUNC_DIRECT    ==  SQLITE_DIRECTONLY from the API\n-**     SQLITE_FUNC_UNSAFE    ==  SQLITE_INNOCUOUS\n+**     SQLITE_FUNC_MINMAX      ==  NC_MinMaxAgg      == SF_MinMaxAgg\n+**     SQLITE_FUNC_ANYORDER    ==  NC_OrderAgg       == SF_OrderByReqd\n+**     SQLITE_FUNC_LENGTH      ==  OPFLAG_LENGTHARG\n+**     SQLITE_FUNC_TYPEOF      ==  OPFLAG_TYPEOFARG\n+**     SQLITE_FUNC_CONSTANT    ==  SQLITE_DETERMINISTIC from the API\n+**     SQLITE_FUNC_DIRECT      ==  SQLITE_DIRECTONLY from the API\n+**     SQLITE_FUNC_UNSAFE      ==  SQLITE_INNOCUOUS\n@@ -17138,0 +16821,2 @@\n+#define SQLITE_FUNC_BUILTIN  0x00800000 \/* This is a built-in function *\/\n+#define SQLITE_FUNC_ANYORDER 0x08000000 \/* count\/min\/max aggregate *\/\n@@ -17185,0 +16870,3 @@\n+**   MFUNCTION(zName, nArg, xPtr, xFunc)\n+**     For math-library functions.  xPtr is an arbitrary pointer.\n+**\n@@ -17212,1 +16900,2 @@\n-  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n+  {nArg, SQLITE_FUNC_BUILTIN|\\\n+   SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n@@ -17215,1 +16904,1 @@\n-  {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n+  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n@@ -17218,1 +16907,1 @@\n-  {nArg, SQLITE_UTF8|SQLITE_DIRECTONLY|SQLITE_FUNC_UNSAFE, \\\n+  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_DIRECTONLY|SQLITE_FUNC_UNSAFE, \\\n@@ -17220,0 +16909,3 @@\n+#define MFUNCTION(zName, nArg, xPtr, xFunc) \\\n+  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_FUNC_CONSTANT|SQLITE_UTF8, \\\n+   xPtr, 0, xFunc, 0, 0, 0, #zName, {0} }\n@@ -17221,1 +16913,2 @@\n-  {nArg, SQLITE_UTF8|SQLITE_FUNC_INLINE|SQLITE_FUNC_CONSTANT|(mFlags), \\\n+  {nArg, SQLITE_FUNC_BUILTIN|\\\n+   SQLITE_UTF8|SQLITE_FUNC_INLINE|SQLITE_FUNC_CONSTANT|(mFlags), \\\n@@ -17224,1 +16917,2 @@\n-  {nArg, SQLITE_UTF8|SQLITE_FUNC_INTERNAL|SQLITE_FUNC_TEST| \\\n+  {nArg, SQLITE_FUNC_BUILTIN|\\\n+         SQLITE_UTF8|SQLITE_FUNC_INTERNAL|SQLITE_FUNC_TEST| \\\n@@ -17228,1 +16922,1 @@\n-  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, \\\n+  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, \\\n@@ -17231,1 +16925,2 @@\n-  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n+  {nArg, SQLITE_FUNC_BUILTIN|\\\n+         SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n@@ -17234,1 +16929,2 @@\n-  {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\\\n+  {nArg, SQLITE_FUNC_BUILTIN|\\\n+   SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\\\n@@ -17237,1 +16933,2 @@\n-  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n+  {nArg, SQLITE_FUNC_BUILTIN|\\\n+   SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n@@ -17240,1 +16937,1 @@\n-  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \\\n+  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \\\n@@ -17243,1 +16940,1 @@\n-  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|f, \\\n+  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|f, \\\n@@ -17246,1 +16943,2 @@\n-  {nArg, SQLITE_FUNC_INTERNAL|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n+  {nArg, SQLITE_FUNC_BUILTIN|\\\n+   SQLITE_FUNC_INTERNAL|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n@@ -17302,0 +17000,8 @@\n+**\n+** Notes on zCnName:\n+** The zCnName field stores the name of the column, the datatype of the\n+** column, and the collating sequence for the column, in that order, all in\n+** a single allocation.  Each string is 0x00 terminated.  The datatype\n+** is only included if the COLFLAG_HASTYPE bit of colFlags is set and the\n+** collating sequence name is only included if the COLFLAG_HASCOLL bit is\n+** set.\n@@ -17304,8 +17010,8 @@\n-  char *zName;     \/* Name of this column, \\000, then the type *\/\n-  Expr *pDflt;     \/* Default value or GENERATED ALWAYS AS value *\/\n-  char *zColl;     \/* Collating sequence.  If NULL, use the default *\/\n-  u8 notNull;      \/* An OE_ code for handling a NOT NULL constraint *\/\n-  char affinity;   \/* One of the SQLITE_AFF_... values *\/\n-  u8 szEst;        \/* Estimated size of value in this column. sizeof(INT)==1 *\/\n-  u8 hName;        \/* Column name hash for faster lookup *\/\n-  u16 colFlags;    \/* Boolean properties.  See COLFLAG_ defines below *\/\n+  char *zCnName;        \/* Name of this column *\/\n+  unsigned notNull :4;  \/* An OE_ code for handling a NOT NULL constraint *\/\n+  unsigned eCType :4;   \/* One of the standard types *\/\n+  char affinity;        \/* One of the SQLITE_AFF_... values *\/\n+  u8 szEst;             \/* Est size of value in this column. sizeof(INT)==1 *\/\n+  u8 hName;             \/* Column name hash for faster lookup *\/\n+  u16 iDflt;            \/* 1-based index of DEFAULT.  0 means \"none\" *\/\n+  u16 colFlags;         \/* Boolean properties.  See COLFLAG_ defines below *\/\n@@ -17314,1 +17020,22 @@\n-\/* Allowed values for Column.colFlags:\n+\/* Allowed values for Column.eCType.\n+**\n+** Values must match entries in the global constant arrays\n+** sqlite3StdTypeLen[] and sqlite3StdType[].  Each value is one more\n+** than the offset into these arrays for the corresponding name.\n+** Adjust the SQLITE_N_STDTYPE value if adding or removing entries.\n+*\/\n+#define COLTYPE_CUSTOM      0   \/* Type appended to zName *\/\n+#define COLTYPE_ANY         1\n+#define COLTYPE_BLOB        2\n+#define COLTYPE_INT         3\n+#define COLTYPE_INTEGER     4\n+#define COLTYPE_REAL        5\n+#define COLTYPE_TEXT        6\n+#define SQLITE_N_STDTYPE    6  \/* Number of standard types *\/\n+\n+\/* Allowed values for Column.colFlags.\n+**\n+** Constraints:\n+**         TF_HasVirtual == COLFLAG_VIRTUAL\n+**         TF_HasStored  == COLFLAG_STORED\n+**         TF_HasHidden  == COLFLAG_HIDDEN\n@@ -17325,0 +17052,1 @@\n+#define COLFLAG_HASCOLL   0x0200   \/* Has collating sequence name in zCnName *\/\n@@ -17390,1 +17118,0 @@\n-#define SQLITE_KEEPNULL     0x08  \/* Used by vector == or <> *\/\n@@ -17392,1 +17119,0 @@\n-#define SQLITE_STOREP2      0x20  \/* Store result in reg[P2] rather than jump *\/\n@@ -17456,2 +17182,2 @@\n-** The schema for each SQL table and view is represented in memory\n-** by an instance of the following structure.\n+** The schema for each SQL table, virtual table, and view is represented\n+** in memory by an instance of the following structure.\n@@ -17463,2 +17189,0 @@\n-  Select *pSelect;     \/* NULL for tables.  Points to definition if a view. *\/\n-  FKey *pFKey;         \/* Linked list of all foreign keys in this table *\/\n@@ -17468,1 +17192,1 @@\n-  int tnum;            \/* Root BTree page for this table *\/\n+  Pgno tnum;           \/* Root BTree page for this table *\/\n@@ -17480,9 +17204,18 @@\n-#ifndef SQLITE_OMIT_ALTERTABLE\n-  int addColOffset;    \/* Offset in CREATE TABLE stmt to add a new column *\/\n-#endif\n-#ifndef SQLITE_OMIT_VIRTUALTABLE\n-  int nModuleArg;      \/* Number of arguments to the module *\/\n-  char **azModuleArg;  \/* 0: module 1: schema 2: vtab name 3...: args *\/\n-  VTable *pVTable;     \/* List of VTable objects. *\/\n-#endif\n-  Trigger *pTrigger;   \/* List of triggers stored in pSchema *\/\n+  u8 eTabType;         \/* 0: normal, 1: virtual, 2: view *\/\n+  union {\n+    struct {             \/* Used by ordinary tables: *\/\n+      int addColOffset;    \/* Offset in CREATE TABLE stmt to add a new column *\/\n+      FKey *pFKey;         \/* Linked list of all foreign keys in this table *\/\n+      ExprList *pDfltList; \/* DEFAULT clauses on various columns.\n+                           ** Or the AS clause for generated columns. *\/\n+    } tab;\n+    struct {             \/* Used by views: *\/\n+      Select *pSelect;     \/* View definition *\/\n+    } view;\n+    struct {             \/* Used by virtual tables only: *\/\n+      int nArg;            \/* Number of arguments to the module *\/\n+      char **azArg;        \/* 0: module 1: schema 2: vtab name 3...: args *\/\n+      VTable *p;           \/* List of VTable objects. *\/\n+    } vtab;\n+  } u;\n+  Trigger *pTrigger;   \/* List of triggers on this object *\/\n@@ -17490,1 +17223,0 @@\n-  Table *pNextZombie;  \/* Next on the Parse.pZombieTab list *\/\n@@ -17504,13 +17236,14 @@\n-**         TF_HasVirtual == COLFLAG_Virtual\n-**         TF_HasStored  == COLFLAG_Stored\n-*\/\n-#define TF_Readonly        0x0001    \/* Read-only system table *\/\n-#define TF_Ephemeral       0x0002    \/* An ephemeral table *\/\n-#define TF_HasPrimaryKey   0x0004    \/* Table has a primary key *\/\n-#define TF_Autoincrement   0x0008    \/* Integer primary key is autoincrement *\/\n-#define TF_HasStat1        0x0010    \/* nRowLogEst set from sqlite_stat1 *\/\n-#define TF_HasVirtual      0x0020    \/* Has one or more VIRTUAL columns *\/\n-#define TF_HasStored       0x0040    \/* Has one or more STORED columns *\/\n-#define TF_HasGenerated    0x0060    \/* Combo: HasVirtual + HasStored *\/\n-#define TF_WithoutRowid    0x0080    \/* No rowid.  PRIMARY KEY is the key *\/\n-#define TF_StatsUsed       0x0100    \/* Query planner decisions affected by\n+**         TF_HasVirtual == COLFLAG_VIRTUAL\n+**         TF_HasStored  == COLFLAG_STORED\n+**         TF_HasHidden  == COLFLAG_HIDDEN\n+*\/\n+#define TF_Readonly       0x00000001 \/* Read-only system table *\/\n+#define TF_HasHidden      0x00000002 \/* Has one or more hidden columns *\/\n+#define TF_HasPrimaryKey  0x00000004 \/* Table has a primary key *\/\n+#define TF_Autoincrement  0x00000008 \/* Integer primary key is autoincrement *\/\n+#define TF_HasStat1       0x00000010 \/* nRowLogEst set from sqlite_stat1 *\/\n+#define TF_HasVirtual     0x00000020 \/* Has one or more VIRTUAL columns *\/\n+#define TF_HasStored      0x00000040 \/* Has one or more STORED columns *\/\n+#define TF_HasGenerated   0x00000060 \/* Combo: HasVirtual + HasStored *\/\n+#define TF_WithoutRowid   0x00000080 \/* No rowid.  PRIMARY KEY is the key *\/\n+#define TF_StatsUsed      0x00000100 \/* Query planner decisions affected by\n@@ -17518,4 +17251,18 @@\n-#define TF_NoVisibleRowid  0x0200    \/* No user-visible \"rowid\" column *\/\n-#define TF_OOOHidden       0x0400    \/* Out-of-Order hidden columns *\/\n-#define TF_HasNotNull      0x0800    \/* Contains NOT NULL constraints *\/\n-#define TF_Shadow          0x1000    \/* True for a shadow table *\/\n+#define TF_NoVisibleRowid 0x00000200 \/* No user-visible \"rowid\" column *\/\n+#define TF_OOOHidden      0x00000400 \/* Out-of-Order hidden columns *\/\n+#define TF_HasNotNull     0x00000800 \/* Contains NOT NULL constraints *\/\n+#define TF_Shadow         0x00001000 \/* True for a shadow table *\/\n+#define TF_HasStat4       0x00002000 \/* STAT4 info available for this table *\/\n+#define TF_Ephemeral      0x00004000 \/* An ephemeral table *\/\n+#define TF_Eponymous      0x00008000 \/* An eponymous virtual table *\/\n+#define TF_Strict         0x00010000 \/* STRICT mode *\/\n+\n+\/*\n+** Allowed values for Table.eTabType\n+*\/\n+#define TABTYP_NORM      0     \/* Ordinary table *\/\n+#define TABTYP_VTAB      1     \/* Virtual table *\/\n+#define TABTYP_VIEW      2     \/* A view *\/\n+\n+#define IsView(X)           ((X)->eTabType==TABTYP_VIEW)\n+#define IsOrdinaryTable(X)  ((X)->eTabType==TABTYP_NORM)\n@@ -17529,1 +17276,1 @@\n-#  define IsVirtual(X)      ((X)->nModuleArg)\n+#  define IsVirtual(X)      ((X)->eTabType==TABTYP_VTAB)\n@@ -17531,1 +17278,1 @@\n-              ((X)->op==TK_COLUMN && (X)->y.pTab!=0 && (X)->y.pTab->nModuleArg)\n+    ((X)->op==TK_COLUMN && (X)->y.pTab!=0 && (X)->y.pTab->eTabType==TABTYP_VTAB)\n@@ -17618,0 +17365,2 @@\n+** UPDATE applies to insert operations only and means that the insert\n+** is omitted and the DO UPDATE clause of an upsert is run instead.\n@@ -17619,1 +17368,1 @@\n-** RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys.\n+** RESTRICT, SETNULL, SETDFLT, and CASCADE actions apply only to foreign keys.\n@@ -17622,1 +17371,2 @@\n-** key is set to NULL.  CASCADE means that a DELETE or UPDATE of the\n+** key is set to NULL.  SETDFLT means that the foreign key is set\n+** to its default value.  CASCADE means that a DELETE or UPDATE of the\n@@ -17626,0 +17376,3 @@\n+** The OE_Default value is a place holder that means to use whatever\n+** conflict resolution algorthm is required from context.\n+**\n@@ -17627,1 +17380,1 @@\n-** of action to take.\n+** of conflict resolution action to take.\n@@ -17742,1 +17495,1 @@\n-** generate VDBE code (as opposed to parsing one read from an sqlite_master\n+** generate VDBE code (as opposed to parsing one read from an sqlite_schema\n@@ -17761,1 +17514,1 @@\n-  int tnum;                \/* DB Page containing root of this index *\/\n+  Pgno tnum;               \/* DB Page containing root of this index *\/\n@@ -17866,1 +17619,1 @@\n-    Expr *pExpr;             \/* The original expression *\/\n+    Expr *pCExpr;            \/* The original expression *\/\n@@ -17877,1 +17630,1 @@\n-    Expr *pExpr;             \/* Expression encoding the function *\/\n+    Expr *pFExpr;            \/* Expression encoding the function *\/\n@@ -17881,0 +17634,1 @@\n+    int iDistAddr;           \/* Address of OP_OpenEphemeral *\/\n@@ -17883,4 +17637,1 @@\n-#ifdef SQLITE_DEBUG\n-  int iAggMagic;          \/* Magic number when valid *\/\n-#endif\n-  AggInfo *pNext;         \/* Next in list of them all *\/\n+  u32 selId;              \/* Select to which this AggInfo belongs *\/\n@@ -17889,5 +17640,0 @@\n-\/*\n-** Value for AggInfo.iAggMagic when the structure is valid\n-*\/\n-#define AggInfoMagic  0x2059e99e\n-\n@@ -17921,2 +17667,2 @@\n-** or TK_STRING), then Expr.token contains the text of the SQL literal. If\n-** the expression is a variable (TK_VARIABLE), then Expr.token contains the\n+** or TK_STRING), then Expr.u.zToken contains the text of the SQL literal. If\n+** the expression is a variable (TK_VARIABLE), then Expr.u.zToken contains the\n@@ -17924,1 +17670,1 @@\n-** then Expr.token contains the name of the function.\n+** then Expr.u.zToken contains the name of the function.\n@@ -17964,1 +17710,1 @@\n-** together with Expr.zToken strings.\n+** together with Expr.u.zToken strings.\n@@ -18020,1 +17766,1 @@\n-  i16 iRightJoinTable;   \/* If EP_FromJoin, the right table of the join *\/\n+  int iRightJoinTable;   \/* If EP_FromJoin, the right table of the join *\/\n@@ -18033,2 +17779,1 @@\n-\/*\n-** The following are the meanings of bits in the Expr.flags field.\n+\/* The following are the meanings of bits in the Expr.flags field.\n@@ -18057,1 +17802,1 @@\n-                  \/*  0x020000 \/\/ available for reuse *\/\n+#define EP_IfNullRow  0x020000 \/* The TK_IF_NULL_ROW opcode *\/\n@@ -18062,1 +17807,1 @@\n-#define EP_Alias      0x400000 \/* Is an alias for a result set column *\/\n+                 \/*   0x400000 \/\/ Available *\/\n@@ -18070,1 +17815,1 @@\n-#define EP_FromDDL  0x40000000 \/* Originates from sqlite_master *\/\n+#define EP_FromDDL  0x40000000 \/* Originates from sqlite_schema *\/\n@@ -18073,2 +17818,1 @@\n-\/*\n-** The EP_Propagate mask is a set of properties that automatically propagate\n+\/* The EP_Propagate mask is a set of properties that automatically propagate\n@@ -18079,2 +17823,1 @@\n-\/*\n-** These macros can be used to test, set, or clear bits in the\n+\/* Macros can be used to test, set, or clear bits in the\n@@ -18090,0 +17833,10 @@\n+\/* Macros used to ensure that the correct members of unions are accessed\n+** in Expr.\n+*\/\n+#define ExprUseUToken(E)    (((E)->flags&EP_IntValue)==0)\n+#define ExprUseUValue(E)    (((E)->flags&EP_IntValue)!=0)\n+#define ExprUseXList(E)     (((E)->flags&EP_xIsSelect)==0)\n+#define ExprUseXSelect(E)   (((E)->flags&EP_xIsSelect)!=0)\n+#define ExprUseYTab(E)      (((E)->flags&(EP_WinFunc|EP_Subrtn))==0)\n+#define ExprUseYWin(E)      (((E)->flags&EP_WinFunc)!=0)\n+#define ExprUseYSub(E)      (((E)->flags&EP_Subrtn)!=0)\n@@ -18161,0 +17914,1 @@\n+  int nAlloc;            \/* Number of a[] slots allocated *\/\n@@ -18171,1 +17925,1 @@\n-      struct {\n+      struct {             \/* Used by any ExprList other than Parse.pConsExpr *\/\n@@ -18175,1 +17929,2 @@\n-      int iConstExprReg;      \/* Register in which Expr value is cached *\/\n+      int iConstExprReg;   \/* Register in which Expr value is cached. Used only\n+                           ** by Parse.pConstExpr *\/\n@@ -18210,0 +17965,47 @@\n+\/*\n+** The SrcItem object represents a single term in the FROM clause of a query.\n+** The SrcList object is mostly an array of SrcItems.\n+**\n+** Union member validity:\n+**\n+**    u1.zIndexedBy          fg.isIndexedBy && !fg.isTabFunc\n+**    u1.pFuncArg            fg.isTabFunc   && !fg.isIndexedBy\n+**    u2.pIBIndex            fg.isIndexedBy && !fg.isCte\n+**    u2.pCteUse             fg.isCte       && !fg.isIndexedBy\n+*\/\n+struct SrcItem {\n+  Schema *pSchema;  \/* Schema to which this item is fixed *\/\n+  char *zDatabase;  \/* Name of database holding this table *\/\n+  char *zName;      \/* Name of the table *\/\n+  char *zAlias;     \/* The \"B\" part of a \"A AS B\" phrase.  zName is the \"A\" *\/\n+  Table *pTab;      \/* An SQL table corresponding to zName *\/\n+  Select *pSelect;  \/* A SELECT statement used in place of a table name *\/\n+  int addrFillSub;  \/* Address of subroutine to manifest a subquery *\/\n+  int regReturn;    \/* Register holding return address of addrFillSub *\/\n+  int regResult;    \/* Registers holding results of a co-routine *\/\n+  struct {\n+    u8 jointype;      \/* Type of join between this table and the previous *\/\n+    unsigned notIndexed :1;    \/* True if there is a NOT INDEXED clause *\/\n+    unsigned isIndexedBy :1;   \/* True if there is an INDEXED BY clause *\/\n+    unsigned isTabFunc :1;     \/* True if table-valued-function syntax *\/\n+    unsigned isCorrelated :1;  \/* True if sub-query is correlated *\/\n+    unsigned viaCoroutine :1;  \/* Implemented as a co-routine *\/\n+    unsigned isRecursive :1;   \/* True for recursive reference in WITH *\/\n+    unsigned fromDDL :1;       \/* Comes from sqlite_schema *\/\n+    unsigned isCte :1;         \/* This is a CTE *\/\n+    unsigned notCte :1;        \/* This item may not match a CTE *\/\n+  } fg;\n+  int iCursor;      \/* The VDBE cursor number used to access this table *\/\n+  Expr *pOn;        \/* The ON clause of a join *\/\n+  IdList *pUsing;   \/* The USING clause of a join *\/\n+  Bitmask colUsed;  \/* Bit N (1<<N) set if column N of pTab is used *\/\n+  union {\n+    char *zIndexedBy;    \/* Identifier from \"INDEXED BY <zIndex>\" clause *\/\n+    ExprList *pFuncArg;  \/* Arguments to table-valued-function *\/\n+  } u1;\n+  union {\n+    Index *pIBIndex;  \/* Index structure corresponding to u1.zIndexedBy *\/\n+    CteUse *pCteUse;  \/* CTE Usage info info fg.isCte is true *\/\n+  } u2;\n+};\n+\n@@ -18232,30 +18034,1 @@\n-  struct SrcList_item {\n-    Schema *pSchema;  \/* Schema to which this item is fixed *\/\n-    char *zDatabase;  \/* Name of database holding this table *\/\n-    char *zName;      \/* Name of the table *\/\n-    char *zAlias;     \/* The \"B\" part of a \"A AS B\" phrase.  zName is the \"A\" *\/\n-    Table *pTab;      \/* An SQL table corresponding to zName *\/\n-    Select *pSelect;  \/* A SELECT statement used in place of a table name *\/\n-    int addrFillSub;  \/* Address of subroutine to manifest a subquery *\/\n-    int regReturn;    \/* Register holding return address of addrFillSub *\/\n-    int regResult;    \/* Registers holding results of a co-routine *\/\n-    struct {\n-      u8 jointype;      \/* Type of join between this table and the previous *\/\n-      unsigned notIndexed :1;    \/* True if there is a NOT INDEXED clause *\/\n-      unsigned isIndexedBy :1;   \/* True if there is an INDEXED BY clause *\/\n-      unsigned isTabFunc :1;     \/* True if table-valued-function syntax *\/\n-      unsigned isCorrelated :1;  \/* True if sub-query is correlated *\/\n-      unsigned viaCoroutine :1;  \/* Implemented as a co-routine *\/\n-      unsigned isRecursive :1;   \/* True for recursive reference in WITH *\/\n-      unsigned fromDDL :1;       \/* Comes from sqlite_master *\/\n-    } fg;\n-    int iCursor;      \/* The VDBE cursor number used to access this table *\/\n-    Expr *pOn;        \/* The ON clause of a join *\/\n-    IdList *pUsing;   \/* The USING clause of a join *\/\n-    Bitmask colUsed;  \/* Bit N (1<<N) set if column N of pTab is used *\/\n-    union {\n-      char *zIndexedBy;    \/* Identifier from \"INDEXED BY <zIndex>\" clause *\/\n-      ExprList *pFuncArg;  \/* Arguments to table-valued-function *\/\n-    } u1;\n-    Index *pIBIndex;  \/* Index structure corresponding to u1.zIndexedBy *\/\n-  } a[1];             \/* One entry for each identifier on the list *\/\n+  SrcItem a[1];    \/* One entry for each identifier on the list *\/\n@@ -18295,1 +18068,1 @@\n-#define WHERE_SEEK_TABLE       0x0400 \/* Do not defer seeks on main table *\/\n+#define WHERE_AGG_DISTINCT     0x0400 \/* Query is \"SELECT agg(DISTINCT ...)\" *\/\n@@ -18297,1 +18070,1 @@\n-#define WHERE_SEEK_UNIQ_TABLE  0x1000 \/* Do not defer seeks if unique *\/\n+                        \/*     0x1000    not currently used *\/\n@@ -18337,0 +18110,1 @@\n+    int iBaseReg;        \/* For TK_REGISTER when parsing RETURNING *\/\n@@ -18340,1 +18114,1 @@\n-  int nErr;            \/* Number of errors encountered while resolving names *\/\n+  int nNcErr;          \/* Number of errors encountered while resolving names *\/\n@@ -18349,2 +18123,3 @@\n-**    NC_HasAgg    == SF_HasAgg    == EP_Agg\n-**    NC_MinMaxAgg == SF_MinMaxAgg == SQLITE_FUNC_MINMAX\n+**    NC_HasAgg    == SF_HasAgg       == EP_Agg\n+**    NC_MinMaxAgg == SF_MinMaxAgg    == SQLITE_FUNC_MINMAX\n+**    NC_OrderAgg  == SF_OrderByReqd  == SQLITE_FUNC_ANYORDER\n@@ -18354,18 +18129,21 @@\n-#define NC_AllowAgg  0x00001  \/* Aggregate functions are allowed here *\/\n-#define NC_PartIdx   0x00002  \/* True if resolving a partial index WHERE *\/\n-#define NC_IsCheck   0x00004  \/* True if resolving a CHECK constraint *\/\n-#define NC_GenCol    0x00008  \/* True for a GENERATED ALWAYS AS clause *\/\n-#define NC_HasAgg    0x00010  \/* One or more aggregate functions seen *\/\n-#define NC_IdxExpr   0x00020  \/* True if resolving columns of CREATE INDEX *\/\n-#define NC_SelfRef   0x0002e  \/* Combo: PartIdx, isCheck, GenCol, and IdxExpr *\/\n-#define NC_VarSelect 0x00040  \/* A correlated subquery has been seen *\/\n-#define NC_UEList    0x00080  \/* True if uNC.pEList is used *\/\n-#define NC_UAggInfo  0x00100  \/* True if uNC.pAggInfo is used *\/\n-#define NC_UUpsert   0x00200  \/* True if uNC.pUpsert is used *\/\n-#define NC_MinMaxAgg 0x01000  \/* min\/max aggregates seen.  See note above *\/\n-#define NC_Complex   0x02000  \/* True if a function or subquery seen *\/\n-#define NC_AllowWin  0x04000  \/* Window functions are allowed here *\/\n-#define NC_HasWin    0x08000  \/* One or more window functions seen *\/\n-#define NC_IsDDL     0x10000  \/* Resolving names in a CREATE statement *\/\n-#define NC_InAggFunc 0x20000  \/* True if analyzing arguments to an agg func *\/\n-#define NC_FromDDL   0x40000  \/* SQL text comes from sqlite_master *\/\n+#define NC_AllowAgg  0x000001 \/* Aggregate functions are allowed here *\/\n+#define NC_PartIdx   0x000002 \/* True if resolving a partial index WHERE *\/\n+#define NC_IsCheck   0x000004 \/* True if resolving a CHECK constraint *\/\n+#define NC_GenCol    0x000008 \/* True for a GENERATED ALWAYS AS clause *\/\n+#define NC_HasAgg    0x000010 \/* One or more aggregate functions seen *\/\n+#define NC_IdxExpr   0x000020 \/* True if resolving columns of CREATE INDEX *\/\n+#define NC_SelfRef   0x00002e \/* Combo: PartIdx, isCheck, GenCol, and IdxExpr *\/\n+#define NC_VarSelect 0x000040 \/* A correlated subquery has been seen *\/\n+#define NC_UEList    0x000080 \/* True if uNC.pEList is used *\/\n+#define NC_UAggInfo  0x000100 \/* True if uNC.pAggInfo is used *\/\n+#define NC_UUpsert   0x000200 \/* True if uNC.pUpsert is used *\/\n+#define NC_UBaseReg  0x000400 \/* True if uNC.iBaseReg is used *\/\n+#define NC_MinMaxAgg 0x001000 \/* min\/max aggregates seen.  See note above *\/\n+#define NC_Complex   0x002000 \/* True if a function or subquery seen *\/\n+#define NC_AllowWin  0x004000 \/* Window functions are allowed here *\/\n+#define NC_HasWin    0x008000 \/* One or more window functions seen *\/\n+#define NC_IsDDL     0x010000 \/* Resolving names in a CREATE statement *\/\n+#define NC_InAggFunc 0x020000 \/* True if analyzing arguments to an agg func *\/\n+#define NC_FromDDL   0x040000 \/* SQL text comes from sqlite_schema *\/\n+#define NC_NoSelect  0x080000 \/* Do not descend into sub-selects *\/\n+#define NC_OrderAgg 0x8000000 \/* Has an aggregate other than count\/min\/max *\/\n@@ -18388,1 +18166,1 @@\n-  ExprList *pUpsertTarget;  \/* Optional description of conflicting index *\/\n+  ExprList *pUpsertTarget;  \/* Optional description of conflict target *\/\n@@ -18392,5 +18170,11 @@\n-  \/* The fields above comprise the parse tree for the upsert clause.\n-  ** The fields below are used to transfer information from the INSERT\n-  ** processing down into the UPDATE processing while generating code.\n-  ** Upsert owns the memory allocated above, but not the memory below. *\/\n-  Index *pUpsertIdx;        \/* Constraint that pUpsertTarget identifies *\/\n+  Upsert *pNextUpsert;      \/* Next ON CONFLICT clause in the list *\/\n+  u8 isDoUpdate;            \/* True for DO UPDATE.  False for DO NOTHING *\/\n+  \/* Above this point is the parse tree for the ON CONFLICT clauses.\n+  ** The next group of fields stores intermediate data. *\/\n+  void *pToFree;            \/* Free memory when deleting the Upsert object *\/\n+  \/* All fields above are owned by the Upsert object and must be freed\n+  ** when the Upsert is destroyed.  The fields below are used to transfer\n+  ** information from the INSERT processing down into the UPDATE processing\n+  ** while generating code.  The fields below are owned by the INSERT\n+  ** statement and will be freed by INSERT processing. *\/\n+  Index *pUpsertIdx;        \/* UNIQUE constraint specified by pUpsertTarget *\/\n@@ -18448,3 +18232,4 @@\n-**     SF_HasAgg     == NC_HasAgg\n-**     SF_MinMaxAgg  == NC_MinMaxAgg     == SQLITE_FUNC_MINMAX\n-**     SF_FixedLimit == WHERE_USE_LIMIT\n+**     SF_HasAgg      == NC_HasAgg\n+**     SF_MinMaxAgg   == NC_MinMaxAgg     == SQLITE_FUNC_MINMAX\n+**     SF_OrderByReqd == NC_OrderAgg      == SQLITE_FUNC_ANYORDER\n+**     SF_FixedLimit  == WHERE_USE_LIMIT\n@@ -18475,0 +18260,5 @@\n+#define SF_UFSrcCheck    0x0800000 \/* Check pSrc as required by UPDATE...FROM *\/\n+#define SF_PushDown      0x1000000 \/* SELECT has be modified by push-down opt *\/\n+#define SF_MultiPart     0x2000000 \/* Has multiple incompatible PARTITIONs *\/\n+#define SF_CopyCte       0x4000000 \/* SELECT statement is a copy of a CTE *\/\n+#define SF_OrderByReqd   0x8000000 \/* The ORDER BY clause may not be omitted *\/\n@@ -18493,3 +18283,0 @@\n-** All of the above are free to ignore their ORDER BY clause. Those that\n-** follow must honor the ORDER BY clause.\n-**\n@@ -18539,0 +18326,8 @@\n+**\n+**     SRT_Upfrom      Store results in the temporary table already opened by\n+**                     pDest->iSDParm. If (pDest->iSDParm<0), then the temp\n+**                     table is an intkey table - in this case the first\n+**                     column returned by the SELECT is used as the integer\n+**                     key. If (pDest->iSDParm>0), then the table is an index\n+**                     table. (pDest->iSDParm) is the number of key columns in\n+**                     each index record in this case.\n@@ -18544,2 +18339,7 @@\n-#define SRT_Fifo         5  \/* Store result as data with an automatic rowid *\/\n-#define SRT_DistFifo     6  \/* Like SRT_Fifo, but unique results only *\/\n+#define SRT_DistFifo     5  \/* Like SRT_Fifo, but unique results only *\/\n+#define SRT_DistQueue    6  \/* Like SRT_Queue, but unique results only *\/\n+\n+\/* The DISTINCT clause is ignored for all of the above.  Not that\n+** IgnorableDistinct() implies IgnorableOrderby() *\/\n+#define IgnorableDistinct(X) ((X->eDest)<=SRT_DistQueue)\n+\n@@ -18547,1 +18347,1 @@\n-#define SRT_DistQueue    8  \/* Like SRT_Queue, but unique results only *\/\n+#define SRT_Fifo         8  \/* Store result as data with an automatic rowid *\/\n@@ -18550,1 +18350,1 @@\n-#define IgnorableOrderby(X) ((X->eDest)<=SRT_DistQueue)\n+#define IgnorableOrderby(X) ((X->eDest)<=SRT_Fifo)\n@@ -18558,0 +18358,1 @@\n+#define SRT_Upfrom      15  \/* Store result as data with rowid *\/\n@@ -18564,1 +18365,1 @@\n-  u8 eDest;            \/* How to dispose of the results.  On of SRT_* above. *\/\n+  u8 eDest;            \/* How to dispose of the results.  One of SRT_* above. *\/\n@@ -18566,0 +18367,1 @@\n+  int iSDParm2;        \/* A second parameter for the eDest disposal method *\/\n@@ -18633,0 +18435,11 @@\n+\/*\n+** An instance of the ParseCleanup object specifies an operation that\n+** should be performed after parsing to deallocation resources obtained\n+** during the parse and which are no longer needed.\n+*\/\n+struct ParseCleanup {\n+  ParseCleanup *pNext;               \/* Next cleanup task *\/\n+  void *pPtr;                        \/* Pointer to object to deallocate *\/\n+  void (*xCleanup)(sqlite3*,void*);  \/* Deallocation routine *\/\n+};\n+\n@@ -18664,0 +18477,3 @@\n+#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)\n+  u8 earlyCleanup;     \/* OOM inside sqlite3ParserAddCleanup() *\/\n+#endif\n@@ -18690,3 +18506,6 @@\n-  Parse *pParentParse; \/* Parent parser if this parser is nested *\/\n-  AggInfo *pAggList;   \/* List of all AggInfo objects *\/\n-  int addrCrTab;       \/* Address of OP_CreateBtree opcode on CREATE TABLE *\/\n+  TriggerPrg *pTriggerPrg;  \/* Linked list of coded triggers *\/\n+  ParseCleanup *pCleanup;   \/* List of cleanup operations to run after parse *\/\n+  union {\n+    int addrCrTab;         \/* Address of OP_CreateBtree on CREATE TABLE *\/\n+    Returning *pReturning; \/* The RETURNING clause *\/\n+  } u1;\n@@ -18697,0 +18516,1 @@\n+  u8 bReturning;       \/* Coding a RETURNING trigger *\/\n@@ -18721,1 +18541,0 @@\n-#if !(defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_OMIT_ALTERTABLE))\n@@ -18723,1 +18542,0 @@\n-#endif\n@@ -18744,2 +18562,0 @@\n-  Table *pZombieTab;        \/* List of Table objects to delete after code gen *\/\n-  TriggerPrg *pTriggerPrg;  \/* Linked list of coded triggers *\/\n@@ -18747,1 +18563,0 @@\n-  With *pWithToFree;        \/* Free this WITH object at the end of the parse *\/\n@@ -18753,0 +18568,2 @@\n+\/* Allowed values for Parse.eParseMode\n+*\/\n@@ -18827,0 +18644,1 @@\n+#define OPFLAG_PREFORMAT     0x80    \/* OP_Insert uses preformatted cell *\/\n@@ -18848,0 +18666,1 @@\n+  u8 bReturning;          \/* This trigger implements a RETURNING clause *\/\n@@ -18906,1 +18725,2 @@\n-  u8 op;               \/* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT *\/\n+  u8 op;               \/* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT,\n+                       ** or TK_RETURNING *\/\n@@ -18911,0 +18731,1 @@\n+  SrcList *pFrom;      \/* FROM clause for UPDATE statement (if any) *\/\n@@ -18912,1 +18733,1 @@\n-  ExprList *pExprList; \/* SET clause for UPDATE *\/\n+  ExprList *pExprList; \/* SET clause for UPDATE, or RETURNING clause *\/\n@@ -18921,3 +18742,1 @@\n-** The following structure contains information used by the sqliteFix...\n-** routines as they walk the parse tree to make database references\n-** explicit.\n+** Information about a RETURNING clause\n@@ -18925,8 +18744,8 @@\n-typedef struct DbFixer DbFixer;\n-struct DbFixer {\n-  Parse *pParse;      \/* The parsing context.  Error messages written here *\/\n-  Schema *pSchema;    \/* Fix items to this schema *\/\n-  u8 bTemp;           \/* True for TEMP schema entries *\/\n-  const char *zDb;    \/* Make sure all objects are contained in this database *\/\n-  const char *zType;  \/* Type of the container - used for error messages *\/\n-  const Token *pName; \/* Name of the container - used for error messages *\/\n+struct Returning {\n+  Parse *pParse;        \/* The parse that includes the RETURNING clause *\/\n+  ExprList *pReturnEL;  \/* List of expressions to return *\/\n+  Trigger retTrig;      \/* The transient trigger that implements RETURNING *\/\n+  TriggerStep retTStep; \/* The trigger step *\/\n+  int iRetCur;          \/* Transient table holding RETURNING results *\/\n+  int nRetCol;          \/* Number of in pReturnEL after expansion *\/\n+  int iRetReg;          \/* Register array for holding a row of RETURNING *\/\n@@ -18966,0 +18785,1 @@\n+  Pgno mxPage;        \/* Maximum page number.  0 for no limit. *\/\n@@ -18971,1 +18791,20 @@\n-#define INITFLAG_AlterTable   0x0001  \/* This is a reparse after ALTER TABLE *\/\n+#define INITFLAG_AlterMask     0x0003  \/* Types of ALTER *\/\n+#define INITFLAG_AlterRename   0x0001  \/* Reparse after a RENAME *\/\n+#define INITFLAG_AlterDrop     0x0002  \/* Reparse after a DROP COLUMN *\/\n+#define INITFLAG_AlterAdd      0x0003  \/* Reparse after an ADD COLUMN *\/\n+\n+\/* Tuning parameters are set using SQLITE_TESTCTRL_TUNE and are controlled\n+** on debug-builds of the CLI using \".testctrl tune ID VALUE\".  Tuning\n+** parameters are for temporary use during development, to help find\n+** optimial values for parameters in the query planner.  The should not\n+** be used on trunk check-ins.  They are a temporary mechanism available\n+** for transient development builds only.\n+**\n+** Tuning parameters are numbered starting with 1.\n+*\/\n+#define SQLITE_NTUNE  6             \/* Should be zero for all trunk check-ins *\/\n+#ifdef SQLITE_DEBUG\n+# define Tuning(X)  (sqlite3Config.aTune[(X)-1])\n+#else\n+# define Tuning(X)  0\n+#endif\n@@ -19027,1 +18866,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -19037,0 +18876,4 @@\n+  \/* vvvv--- must be last ---vvv *\/\n+#ifdef SQLITE_DEBUG\n+  sqlite3_int64 aTune[SQLITE_NTUNE]; \/* Tuning parameters *\/\n+#endif\n@@ -19072,1 +18915,0 @@\n-    struct SrcCount *pSrcCount;               \/* Counting column references *\/\n@@ -19074,0 +18916,1 @@\n+    struct RefSrcList *pRefSrcList;           \/* sqlite3ReferencesSrcList() *\/\n@@ -19083,1 +18926,2 @@\n-    struct SrcList_item *pSrcItem;            \/* A single FROM clause item *\/\n+    SrcItem *pSrcItem;                        \/* A single FROM clause item *\/\n+    DbFixer *pFix;\n@@ -19087,0 +18931,15 @@\n+\/*\n+** The following structure contains information used by the sqliteFix...\n+** routines as they walk the parse tree to make database references\n+** explicit.\n+*\/\n+struct DbFixer {\n+  Parse *pParse;      \/* The parsing context.  Error messages written here *\/\n+  Walker w;           \/* Walker object *\/\n+  Schema *pSchema;    \/* Fix items to this schema *\/\n+  u8 bTemp;           \/* True for TEMP schema entries *\/\n+  const char *zDb;    \/* Make sure all objects are contained in this database *\/\n+  const char *zType;  \/* Type of the container - used for error messages *\/\n+  const Token *pName; \/* Name of the container - used for error messages *\/\n+};\n+\n@@ -19098,0 +18957,1 @@\n+SQLITE_PRIVATE void sqlite3WalkWinDefnDummyCallback(Walker*,Select*);\n@@ -19103,0 +18963,6 @@\n+#ifndef SQLITE_OMIT_CTE\n+SQLITE_PRIVATE void sqlite3SelectPopWith(Walker*, Select*);\n+#else\n+# define sqlite3SelectPopWith 0\n+#endif\n+\n@@ -19112,2 +18978,21 @@\n-** An instance of this structure represents a set of one or more CTEs\n-** (common table expressions) created by a single WITH clause.\n+** A single common table expression\n+*\/\n+struct Cte {\n+  char *zName;            \/* Name of this CTE *\/\n+  ExprList *pCols;        \/* List of explicit column names, or NULL *\/\n+  Select *pSelect;        \/* The definition of this CTE *\/\n+  const char *zCteErr;    \/* Error message for circular references *\/\n+  CteUse *pUse;           \/* Usage information for this CTE *\/\n+  u8 eM10d;               \/* The MATERIALIZED flag *\/\n+};\n+\n+\/*\n+** Allowed values for the materialized flag (eM10d):\n+*\/\n+#define M10d_Yes       0  \/* AS MATERIALIZED *\/\n+#define M10d_Any       1  \/* Not specified.  Query planner's choice *\/\n+#define M10d_No        2  \/* AS NOT MATERIALIZED *\/\n+\n+\/*\n+** An instance of the With object represents a WITH clause containing\n+** one or more CTEs (common table expressions).\n@@ -19116,8 +19001,24 @@\n-  int nCte;                       \/* Number of CTEs in the WITH clause *\/\n-  With *pOuter;                   \/* Containing WITH clause, or NULL *\/\n-  struct Cte {                    \/* For each CTE in the WITH clause.... *\/\n-    char *zName;                    \/* Name of this CTE *\/\n-    ExprList *pCols;                \/* List of explicit column names, or NULL *\/\n-    Select *pSelect;                \/* The definition of this CTE *\/\n-    const char *zCteErr;            \/* Error message for circular references *\/\n-  } a[1];\n+  int nCte;               \/* Number of CTEs in the WITH clause *\/\n+  int bView;              \/* Belongs to the outermost Select of a view *\/\n+  With *pOuter;           \/* Containing WITH clause, or NULL *\/\n+  Cte a[1];               \/* For each CTE in the WITH clause.... *\/\n+};\n+\n+\/*\n+** The Cte object is not guaranteed to persist for the entire duration\n+** of code generation.  (The query flattener or other parser tree\n+** edits might delete it.)  The following object records information\n+** about each Common Table Expression that must be preserved for the\n+** duration of the parse.\n+**\n+** The CteUse objects are freed using sqlite3ParserAddCleanup() rather\n+** than sqlite3SelectDelete(), which is what enables them to persist\n+** until the end of code generation.\n+*\/\n+struct CteUse {\n+  int nUse;              \/* Number of users of this CTE *\/\n+  int addrM9e;           \/* Start of subroutine to compute materialization *\/\n+  int regRtn;            \/* Return address register for addrM9e subroutine *\/\n+  int iCur;              \/* Ephemeral table holding the materialization *\/\n+  LogEst nRowEst;        \/* Estimated number of rows in the table *\/\n+  u8 eM10d;              \/* The MATERIALIZED flag *\/\n@@ -19126,0 +19027,1 @@\n+\n@@ -19199,1 +19101,1 @@\n-SQLITE_PRIVATE int sqlite3WindowCompare(Parse*, Window*, Window*, int);\n+SQLITE_PRIVATE int sqlite3WindowCompare(const Parse*, const Window*, const Window*, int);\n@@ -19203,1 +19105,0 @@\n-SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse*, struct SrcList_item*);\n@@ -19332,2 +19233,2 @@\n-SQLITE_PRIVATE int sqlite3MallocSize(void*);\n-SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*);\n+SQLITE_PRIVATE int sqlite3MallocSize(const void*);\n+SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, const void*);\n@@ -19449,0 +19350,1 @@\n+SQLITE_PRIVATE void sqlite3DequoteToken(Token*);\n@@ -19468,2 +19370,2 @@\n-SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*, int);\n-SQLITE_PRIVATE void sqlite3ExprFunctionUsable(Parse*,Expr*,FuncDef*);\n+SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, const Token*, int);\n+SQLITE_PRIVATE void sqlite3ExprFunctionUsable(Parse*,const Expr*,const FuncDef*);\n@@ -19472,0 +19374,1 @@\n+SQLITE_PRIVATE void sqlite3ExprDeferredDelete(Parse*, Expr*);\n@@ -19475,0 +19378,1 @@\n+SQLITE_PRIVATE Select *sqlite3ExprListToValues(Parse*, int, ExprList*);\n@@ -19476,1 +19380,1 @@\n-SQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);\n+SQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,const Token*,int);\n@@ -19492,0 +19396,4 @@\n+SQLITE_PRIVATE void sqlite3ColumnSetExpr(Parse*,Table*,Column*,Expr*);\n+SQLITE_PRIVATE Expr *sqlite3ColumnExpr(Table*,Column*);\n+SQLITE_PRIVATE void sqlite3ColumnSetColl(sqlite3*,Column*,const char*zColl);\n+SQLITE_PRIVATE const char *sqlite3ColumnColl(Column*);\n@@ -19493,0 +19401,1 @@\n+SQLITE_PRIVATE void sqlite3GenerateColumnNames(Parse *pParse, Select *pSelect);\n@@ -19496,1 +19405,1 @@\n-SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int);\n+SQLITE_PRIVATE void sqlite3OpenSchemaTable(Parse *, int);\n@@ -19512,1 +19421,1 @@\n-SQLITE_PRIVATE void sqlite3AddColumn(Parse*,Token*,Token*);\n+SQLITE_PRIVATE void sqlite3AddColumn(Parse*,Token,Token);\n@@ -19515,1 +19424,1 @@\n-SQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*);\n+SQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*, const char*, const char*);\n@@ -19519,1 +19428,2 @@\n-SQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);\n+SQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,u32,Select*);\n+SQLITE_PRIVATE void sqlite3AddReturning(Parse*,ExprList*);\n@@ -19579,0 +19489,1 @@\n+SQLITE_PRIVATE SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2);\n@@ -19584,1 +19495,1 @@\n-SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);\n+SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, SrcItem *);\n@@ -19597,1 +19508,0 @@\n-SQLITE_PRIVATE void sqlite3SelectReset(Parse*, Select*);\n@@ -19613,0 +19523,1 @@\n+SQLITE_PRIVATE void sqlite3WhereMinMaxOptEarlyOut(Vdbe*,WhereInfo*);\n@@ -19627,1 +19538,1 @@\n-SQLITE_PRIVATE void sqlite3ExprCodeGeneratedColumn(Parse*, Column*, int);\n+SQLITE_PRIVATE void sqlite3ExprCodeGeneratedColumn(Parse*, Table*, Column*, int);\n@@ -19646,1 +19557,2 @@\n-SQLITE_PRIVATE Table *sqlite3LocateTableItem(Parse*,u32 flags,struct SrcList_item *);\n+SQLITE_PRIVATE const char *sqlite3PreferredTableName(const char*);\n+SQLITE_PRIVATE Table *sqlite3LocateTableItem(Parse*,u32 flags,SrcItem *);\n@@ -19652,5 +19564,5 @@\n-SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, Token*);\n-SQLITE_PRIVATE int sqlite3ExprCompare(Parse*,Expr*, Expr*, int);\n-SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*, Expr*, int);\n-SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*, int);\n-SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);\n+SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, const Token*);\n+SQLITE_PRIVATE int sqlite3ExprCompare(const Parse*,const Expr*,const Expr*, int);\n+SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*,Expr*,int);\n+SQLITE_PRIVATE int sqlite3ExprListCompare(const ExprList*,const ExprList*, int);\n+SQLITE_PRIVATE int sqlite3ExprImpliesExpr(const Parse*,const Expr*,const Expr*, int);\n@@ -19662,1 +19574,1 @@\n-SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr*, SrcList*);\n+SQLITE_PRIVATE int sqlite3ReferencesSrcList(Parse*, Expr*, SrcList*);\n@@ -19687,1 +19599,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr*, int*);\n+SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr*, int*);\n@@ -19712,5 +19624,5 @@\n-SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*,Expr*,int);\n-SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);\n-SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);\n-SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*,IdList*);\n-SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*,Select*,int);\n+SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*,const Expr*,int);\n+SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*,const ExprList*,int);\n+SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*,const SrcList*,int);\n+SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*,const IdList*);\n+SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*,const Select*,int);\n@@ -19726,0 +19638,1 @@\n+SQLITE_PRIVATE With *sqlite3WithDup(sqlite3 *db, With *p);\n@@ -19749,2 +19662,2 @@\n-SQLITE_PRIVATE   TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,ExprList*, Expr*, u8,\n-                                        const char*,const char*);\n+SQLITE_PRIVATE   TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,SrcList*,ExprList*,\n+                                        Expr*, u8, const char*,const char*);\n@@ -19756,0 +19669,1 @@\n+SQLITE_PRIVATE   SrcList *sqlite3TriggerStepSrc(Parse*, TriggerStep*);\n@@ -19769,0 +19683,1 @@\n+# define sqlite3TriggerStepSrc(A,B) 0\n@@ -19772,0 +19687,1 @@\n+SQLITE_PRIVATE int sqlite3ColumnIndex(Table *pTab, const char *zCol);\n@@ -19794,1 +19710,0 @@\n-SQLITE_PRIVATE int sqlite3FixExprList(DbFixer*, ExprList*);\n@@ -19797,0 +19712,1 @@\n+SQLITE_PRIVATE void sqlite3Int64ToText(i64,char*);\n@@ -19799,0 +19715,1 @@\n+SQLITE_PRIVATE int sqlite3GetUInt32(const char*, u32*);\n@@ -19849,1 +19766,1 @@\n-SQLITE_PRIVATE char sqlite3TableColumnAffinity(Table*,int);\n+SQLITE_PRIVATE char sqlite3TableColumnAffinity(const Table*,int);\n@@ -19855,0 +19772,1 @@\n+SQLITE_PRIVATE void sqlite3ErrorClear(sqlite3*);\n@@ -19864,1 +19782,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -19877,2 +19795,2 @@\n-SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);\n-SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);\n+SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(const Parse *pParse, Expr*, const Token*, int);\n+SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(const Parse*,Expr*,const char*);\n@@ -19884,1 +19802,1 @@\n-SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int);\n+SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, i64);\n@@ -19909,1 +19827,1 @@\n-SQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);\n+SQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, const Expr *, u8, u8, sqlite3_value **);\n@@ -19914,0 +19832,4 @@\n+SQLITE_PRIVATE const unsigned char sqlite3StdTypeLen[];\n+SQLITE_PRIVATE const char sqlite3StdTypeAffinity[];\n+SQLITE_PRIVATE const char sqlite3StdTypeMap[];\n+SQLITE_PRIVATE const char *sqlite3StdType[];\n@@ -19915,0 +19837,3 @@\n+SQLITE_PRIVATE const unsigned char *sqlite3aLTb;\n+SQLITE_PRIVATE const unsigned char *sqlite3aEQb;\n+SQLITE_PRIVATE const unsigned char *sqlite3aGTb;\n@@ -19921,1 +19846,1 @@\n-#endif\n+#endif \/* SQLITE_AMALGAMATION *\/\n@@ -19925,1 +19850,1 @@\n-SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3*, int, int, int);\n+SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3*, int, Pgno, Pgno);\n@@ -19936,0 +19861,1 @@\n+SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse*, SrcItem*);\n@@ -19953,2 +19879,3 @@\n-SQLITE_PRIVATE void *sqlite3RenameTokenMap(Parse*, void*, Token*);\n-SQLITE_PRIVATE void sqlite3RenameTokenRemap(Parse*, void *pTo, void *pFrom);\n+SQLITE_PRIVATE void sqlite3AlterDropColumn(Parse*, SrcList*, const Token*);\n+SQLITE_PRIVATE const void *sqlite3RenameTokenMap(Parse*, const void*, const Token*);\n+SQLITE_PRIVATE void sqlite3RenameTokenRemap(Parse*, const void *pTo, const void *pFrom);\n@@ -19976,0 +19903,1 @@\n+SQLITE_PRIVATE const char *sqlite3SelectOpName(int);\n@@ -19997,0 +19925,2 @@\n+SQLITE_PRIVATE void sqlite3StrAccumSetError(StrAccum*, u8);\n+SQLITE_PRIVATE void sqlite3ResultStrAccum(sqlite3_context*,StrAccum*);\n@@ -20039,1 +19969,1 @@\n-SQLITE_PRIVATE   void sqlite3TableLock(Parse *, int, int, u8, const char *);\n+SQLITE_PRIVATE   void sqlite3TableLock(Parse *, int, Pgno, u8, const char *);\n@@ -20049,1 +19979,1 @@\n-#  define sqlite3VtabClear(Y)\n+#  define sqlite3VtabClear(D,T)\n@@ -20086,0 +20016,1 @@\n+SQLITE_PRIVATE   void sqlite3MarkAllShadowTablesOf(sqlite3*, Table*);\n@@ -20089,0 +20020,1 @@\n+# define sqlite3MarkAllShadowTablesOf(A,B)\n@@ -20106,0 +20038,1 @@\n+SQLITE_PRIVATE void *sqlite3ParserAddCleanup(Parse*,void(*)(sqlite3*,void*),void*);\n@@ -20120,1 +20053,3 @@\n-SQLITE_PRIVATE   With *sqlite3WithAdd(Parse*,With*,Token*,ExprList*,Select*);\n+SQLITE_PRIVATE   Cte *sqlite3CteNew(Parse*,Token*,ExprList*,Select*,u8);\n+SQLITE_PRIVATE   void sqlite3CteDelete(sqlite3*,Cte*);\n+SQLITE_PRIVATE   With *sqlite3WithAdd(Parse*,With*,Cte*);\n@@ -20122,1 +20057,1 @@\n-SQLITE_PRIVATE   void sqlite3WithPush(Parse*, With*, u8);\n+SQLITE_PRIVATE   With *sqlite3WithPush(Parse*, With*, u8);\n@@ -20124,2 +20059,5 @@\n-#define sqlite3WithPush(x,y,z)\n-#define sqlite3WithDelete(x,y)\n+# define sqlite3CteNew(P,T,E,S)   ((void*)0)\n+# define sqlite3CteDelete(D,C)\n+# define sqlite3CteWithAdd(P,W,C) ((void*)0)\n+# define sqlite3WithDelete(x,y)\n+# define sqlite3WithPush(x,y,z) ((void*)0)\n@@ -20128,1 +20066,1 @@\n-SQLITE_PRIVATE   Upsert *sqlite3UpsertNew(sqlite3*,ExprList*,Expr*,ExprList*,Expr*);\n+SQLITE_PRIVATE   Upsert *sqlite3UpsertNew(sqlite3*,ExprList*,Expr*,ExprList*,Expr*,Upsert*);\n@@ -20133,0 +20071,2 @@\n+SQLITE_PRIVATE   Upsert *sqlite3UpsertOfIndex(Upsert*,Index*);\n+SQLITE_PRIVATE   int sqlite3UpsertNextIsIPK(Upsert*);\n@@ -20134,1 +20074,1 @@\n-#define sqlite3UpsertNew(v,w,x,y,z) ((Upsert*)0)\n+#define sqlite3UpsertNew(u,v,w,x,y,z) ((Upsert*)0)\n@@ -20136,1 +20076,3 @@\n-#define sqlite3UpsertDup(x,y)       ((Upsert*)0)\n+#define sqlite3UpsertDup(x,y)         ((Upsert*)0)\n+#define sqlite3UpsertOfIndex(x,y)     ((Upsert*)0)\n+#define sqlite3UpsertNextIsIPK(x)     0\n@@ -20154,0 +20096,1 @@\n+SQLITE_PRIVATE   void sqlite3FkClearTriggerCache(sqlite3*,int);\n@@ -20161,0 +20104,1 @@\n+  #define sqlite3FkClearTriggerCache(a,b)\n@@ -20218,1 +20162,1 @@\n-SQLITE_PRIVATE   int sqlite3SelectExprHeight(Select *);\n+SQLITE_PRIVATE   int sqlite3SelectExprHeight(const Select *);\n@@ -20289,2 +20233,2 @@\n-SQLITE_PRIVATE   int sqlite3MemdebugHasType(void*,u8);\n-SQLITE_PRIVATE   int sqlite3MemdebugNoType(void*,u8);\n+SQLITE_PRIVATE   int sqlite3MemdebugHasType(const void*,u8);\n+SQLITE_PRIVATE   int sqlite3MemdebugNoType(const void*,u8);\n@@ -20315,2 +20259,2 @@\n-SQLITE_PRIVATE int sqlite3ExprVectorSize(Expr *pExpr);\n-SQLITE_PRIVATE int sqlite3ExprIsVector(Expr *pExpr);\n+SQLITE_PRIVATE int sqlite3ExprVectorSize(const Expr *pExpr);\n+SQLITE_PRIVATE int sqlite3ExprIsVector(const Expr *pExpr);\n@@ -20318,1 +20262,1 @@\n-SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(Parse*,Expr*,int);\n+SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(Parse*,Expr*,int,int);\n@@ -20328,0 +20272,984 @@\n+\/************** Begin file os_common.h ***************************************\/\n+\/*\n+** 2004 May 22\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+******************************************************************************\n+**\n+** This file contains macros and a little bit of code that is common to\n+** all of the platform-specific files (os_*.c) and is #included into those\n+** files.\n+**\n+** This file should be #included by the os_*.c files only.  It is not a\n+** general purpose header file.\n+*\/\n+#ifndef _OS_COMMON_H_\n+#define _OS_COMMON_H_\n+\n+\/*\n+** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n+** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n+** switch.  The following code should catch this problem at compile-time.\n+*\/\n+#ifdef MEMORY_DEBUG\n+# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n+#endif\n+\n+\/*\n+** Macros for performance tracing.  Normally turned off.  Only works\n+** on i486 hardware.\n+*\/\n+#ifdef SQLITE_PERFORMANCE_TRACE\n+\n+\/*\n+** hwtime.h contains inline assembler code for implementing\n+** high-performance timing routines.\n+*\/\n+\/************** Include hwtime.h in the middle of os_common.h ****************\/\n+\/************** Begin file hwtime.h ******************************************\/\n+\/*\n+** 2008 May 27\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+******************************************************************************\n+**\n+** This file contains inline asm code for retrieving \"high-performance\"\n+** counters for x86 and x86_64 class CPUs.\n+*\/\n+#ifndef SQLITE_HWTIME_H\n+#define SQLITE_HWTIME_H\n+\n+\/*\n+** The following routine only works on pentium-class (or newer) processors.\n+** It uses the RDTSC opcode to read the cycle count value out of the\n+** processor and returns that value.  This can be used for high-res\n+** profiling.\n+*\/\n+#if !defined(__STRICT_ANSI__) && \\\n+    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n+    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n+\n+  #if defined(__GNUC__)\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+     unsigned int lo, hi;\n+     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n+     return (sqlite_uint64)hi << 32 | lo;\n+  }\n+\n+  #elif defined(_MSC_VER)\n+\n+  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n+     __asm {\n+        rdtsc\n+        ret       ; return value at EDX:EAX\n+     }\n+  }\n+\n+  #endif\n+\n+#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+      unsigned long val;\n+      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n+      return val;\n+  }\n+\n+#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+      unsigned long long retval;\n+      unsigned long junk;\n+      __asm__ __volatile__ (\"\\n\\\n+          1:      mftbu   %1\\n\\\n+                  mftb    %L0\\n\\\n+                  mftbu   %0\\n\\\n+                  cmpw    %0,%1\\n\\\n+                  bne     1b\"\n+                  : \"=r\" (retval), \"=r\" (junk));\n+      return retval;\n+  }\n+\n+#else\n+\n+  \/*\n+  ** asm() is needed for hardware timing support.  Without asm(),\n+  ** disable the sqlite3Hwtime() routine.\n+  **\n+  ** sqlite3Hwtime() is only used for some obscure debugging\n+  ** and analysis configurations, not in any deliverable, so this\n+  ** should not be a great loss.\n+  *\/\n+SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n+\n+#endif\n+\n+#endif \/* !defined(SQLITE_HWTIME_H) *\/\n+\n+\/************** End of hwtime.h **********************************************\/\n+\/************** Continuing where we left off in os_common.h ******************\/\n+\n+static sqlite_uint64 g_start;\n+static sqlite_uint64 g_elapsed;\n+#define TIMER_START       g_start=sqlite3Hwtime()\n+#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n+#define TIMER_ELAPSED     g_elapsed\n+#else\n+#define TIMER_START\n+#define TIMER_END\n+#define TIMER_ELAPSED     ((sqlite_uint64)0)\n+#endif\n+\n+\/*\n+** If we compile with the SQLITE_TEST macro set, then the following block\n+** of code will give us the ability to simulate a disk I\/O error.  This\n+** is used for testing the I\/O recovery logic.\n+*\/\n+#if defined(SQLITE_TEST)\n+SQLITE_API extern int sqlite3_io_error_hit;\n+SQLITE_API extern int sqlite3_io_error_hardhit;\n+SQLITE_API extern int sqlite3_io_error_pending;\n+SQLITE_API extern int sqlite3_io_error_persist;\n+SQLITE_API extern int sqlite3_io_error_benign;\n+SQLITE_API extern int sqlite3_diskfull_pending;\n+SQLITE_API extern int sqlite3_diskfull;\n+#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n+#define SimulateIOError(CODE)  \\\n+  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n+       || sqlite3_io_error_pending-- == 1 )  \\\n+              { local_ioerr(); CODE; }\n+static void local_ioerr(){\n+  IOTRACE((\"IOERR\\n\"));\n+  sqlite3_io_error_hit++;\n+  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n+}\n+#define SimulateDiskfullError(CODE) \\\n+   if( sqlite3_diskfull_pending ){ \\\n+     if( sqlite3_diskfull_pending == 1 ){ \\\n+       local_ioerr(); \\\n+       sqlite3_diskfull = 1; \\\n+       sqlite3_io_error_hit = 1; \\\n+       CODE; \\\n+     }else{ \\\n+       sqlite3_diskfull_pending--; \\\n+     } \\\n+   }\n+#else\n+#define SimulateIOErrorBenign(X)\n+#define SimulateIOError(A)\n+#define SimulateDiskfullError(A)\n+#endif \/* defined(SQLITE_TEST) *\/\n+\n+\/*\n+** When testing, keep a count of the number of open files.\n+*\/\n+#if defined(SQLITE_TEST)\n+SQLITE_API extern int sqlite3_open_file_count;\n+#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n+#else\n+#define OpenCounter(X)\n+#endif \/* defined(SQLITE_TEST) *\/\n+\n+#endif \/* !defined(_OS_COMMON_H_) *\/\n+\n+\/************** End of os_common.h *******************************************\/\n+\/************** Begin file ctime.c *******************************************\/\n+\/*\n+** 2010 February 23\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+*************************************************************************\n+**\n+** This file implements routines used to report what compile-time options\n+** SQLite was built with.\n+*\/\n+#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS \/* IMP: R-16824-07538 *\/\n+\n+\/*\n+** Include the configuration header output by 'configure' if we're using the\n+** autoconf-based build\n+*\/\n+#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)\n+\/* #include \"config.h\" *\/\n+#define SQLITECONFIG_H 1\n+#endif\n+\n+\/* These macros are provided to \"stringify\" the value of the define\n+** for those options in which the value is meaningful. *\/\n+#define CTIMEOPT_VAL_(opt) #opt\n+#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)\n+\n+\/* Like CTIMEOPT_VAL, but especially for SQLITE_DEFAULT_LOOKASIDE. This\n+** option requires a separate macro because legal values contain a single\n+** comma. e.g. (-DSQLITE_DEFAULT_LOOKASIDE=\"100,100\") *\/\n+#define CTIMEOPT_VAL2_(opt1,opt2) #opt1 \",\" #opt2\n+#define CTIMEOPT_VAL2(opt) CTIMEOPT_VAL2_(opt)\n+\/* #include \"sqliteInt.h\" *\/\n+\n+\/*\n+** An array of names of all compile-time options.  This array should\n+** be sorted A-Z.\n+**\n+** This array looks large, but in a typical installation actually uses\n+** only a handful of compile-time options, so most times this array is usually\n+** rather short and uses little memory space.\n+*\/\n+static const char * const sqlite3azCompileOpt[] = {\n+\n+\/*\n+** BEGIN CODE GENERATED BY tool\/mkctime.tcl\n+*\/\n+#ifdef SQLITE_32BIT_ROWID\n+  \"32BIT_ROWID\",\n+#endif\n+#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC\n+  \"4_BYTE_ALIGNED_MALLOC\",\n+#endif\n+#ifdef SQLITE_64BIT_STATS\n+  \"64BIT_STATS\",\n+#endif\n+#ifdef SQLITE_ALLOW_COVERING_INDEX_SCAN\n+# if SQLITE_ALLOW_COVERING_INDEX_SCAN != 1\n+  \"ALLOW_COVERING_INDEX_SCAN=\" CTIMEOPT_VAL(SQLITE_ALLOW_COVERING_INDEX_SCAN),\n+# endif\n+#endif\n+#ifdef SQLITE_ALLOW_URI_AUTHORITY\n+  \"ALLOW_URI_AUTHORITY\",\n+#endif\n+#ifdef SQLITE_ATOMIC_INTRINSICS\n+  \"ATOMIC_INTRINSICS=\" CTIMEOPT_VAL(SQLITE_ATOMIC_INTRINSICS),\n+#endif\n+#ifdef SQLITE_BITMASK_TYPE\n+  \"BITMASK_TYPE=\" CTIMEOPT_VAL(SQLITE_BITMASK_TYPE),\n+#endif\n+#ifdef SQLITE_BUG_COMPATIBLE_20160819\n+  \"BUG_COMPATIBLE_20160819\",\n+#endif\n+#ifdef SQLITE_CASE_SENSITIVE_LIKE\n+  \"CASE_SENSITIVE_LIKE\",\n+#endif\n+#ifdef SQLITE_CHECK_PAGES\n+  \"CHECK_PAGES\",\n+#endif\n+#if defined(__clang__) && defined(__clang_major__)\n+  \"COMPILER=clang-\" CTIMEOPT_VAL(__clang_major__) \".\"\n+                    CTIMEOPT_VAL(__clang_minor__) \".\"\n+                    CTIMEOPT_VAL(__clang_patchlevel__),\n+#elif defined(_MSC_VER)\n+  \"COMPILER=msvc-\" CTIMEOPT_VAL(_MSC_VER),\n+#elif defined(__GNUC__) && defined(__VERSION__)\n+  \"COMPILER=gcc-\" __VERSION__,\n+#endif\n+#ifdef SQLITE_COVERAGE_TEST\n+  \"COVERAGE_TEST\",\n+#endif\n+#ifdef SQLITE_DEBUG\n+  \"DEBUG\",\n+#endif\n+#ifdef SQLITE_DEFAULT_AUTOMATIC_INDEX\n+  \"DEFAULT_AUTOMATIC_INDEX\",\n+#endif\n+#ifdef SQLITE_DEFAULT_AUTOVACUUM\n+  \"DEFAULT_AUTOVACUUM\",\n+#endif\n+#ifdef SQLITE_DEFAULT_CACHE_SIZE\n+  \"DEFAULT_CACHE_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_CACHE_SIZE),\n+#endif\n+#ifdef SQLITE_DEFAULT_CKPTFULLFSYNC\n+  \"DEFAULT_CKPTFULLFSYNC\",\n+#endif\n+#ifdef SQLITE_DEFAULT_FILE_FORMAT\n+  \"DEFAULT_FILE_FORMAT=\" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_FORMAT),\n+#endif\n+#ifdef SQLITE_DEFAULT_FILE_PERMISSIONS\n+  \"DEFAULT_FILE_PERMISSIONS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_PERMISSIONS),\n+#endif\n+#ifdef SQLITE_DEFAULT_FOREIGN_KEYS\n+  \"DEFAULT_FOREIGN_KEYS\",\n+#endif\n+#ifdef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT\n+  \"DEFAULT_JOURNAL_SIZE_LIMIT=\" CTIMEOPT_VAL(SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT),\n+#endif\n+#ifdef SQLITE_DEFAULT_LOCKING_MODE\n+  \"DEFAULT_LOCKING_MODE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),\n+#endif\n+#ifdef SQLITE_DEFAULT_LOOKASIDE\n+  \"DEFAULT_LOOKASIDE=\" CTIMEOPT_VAL2(SQLITE_DEFAULT_LOOKASIDE),\n+#endif\n+#ifdef SQLITE_DEFAULT_MEMSTATUS\n+# if SQLITE_DEFAULT_MEMSTATUS != 1\n+  \"DEFAULT_MEMSTATUS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_MEMSTATUS),\n+# endif\n+#endif\n+#ifdef SQLITE_DEFAULT_MMAP_SIZE\n+  \"DEFAULT_MMAP_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),\n+#endif\n+#ifdef SQLITE_DEFAULT_PAGE_SIZE\n+  \"DEFAULT_PAGE_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_PAGE_SIZE),\n+#endif\n+#ifdef SQLITE_DEFAULT_PCACHE_INITSZ\n+  \"DEFAULT_PCACHE_INITSZ=\" CTIMEOPT_VAL(SQLITE_DEFAULT_PCACHE_INITSZ),\n+#endif\n+#ifdef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS\n+  \"DEFAULT_PROXYDIR_PERMISSIONS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_PROXYDIR_PERMISSIONS),\n+#endif\n+#ifdef SQLITE_DEFAULT_RECURSIVE_TRIGGERS\n+  \"DEFAULT_RECURSIVE_TRIGGERS\",\n+#endif\n+#ifdef SQLITE_DEFAULT_ROWEST\n+  \"DEFAULT_ROWEST=\" CTIMEOPT_VAL(SQLITE_DEFAULT_ROWEST),\n+#endif\n+#ifdef SQLITE_DEFAULT_SECTOR_SIZE\n+  \"DEFAULT_SECTOR_SIZE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_SECTOR_SIZE),\n+#endif\n+#ifdef SQLITE_DEFAULT_SYNCHRONOUS\n+  \"DEFAULT_SYNCHRONOUS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_SYNCHRONOUS),\n+#endif\n+#ifdef SQLITE_DEFAULT_WAL_AUTOCHECKPOINT\n+  \"DEFAULT_WAL_AUTOCHECKPOINT=\" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_AUTOCHECKPOINT),\n+#endif\n+#ifdef SQLITE_DEFAULT_WAL_SYNCHRONOUS\n+  \"DEFAULT_WAL_SYNCHRONOUS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_SYNCHRONOUS),\n+#endif\n+#ifdef SQLITE_DEFAULT_WORKER_THREADS\n+  \"DEFAULT_WORKER_THREADS=\" CTIMEOPT_VAL(SQLITE_DEFAULT_WORKER_THREADS),\n+#endif\n+#ifdef SQLITE_DIRECT_OVERFLOW_READ\n+  \"DIRECT_OVERFLOW_READ\",\n+#endif\n+#ifdef SQLITE_DISABLE_DIRSYNC\n+  \"DISABLE_DIRSYNC\",\n+#endif\n+#ifdef SQLITE_DISABLE_FTS3_UNICODE\n+  \"DISABLE_FTS3_UNICODE\",\n+#endif\n+#ifdef SQLITE_DISABLE_FTS4_DEFERRED\n+  \"DISABLE_FTS4_DEFERRED\",\n+#endif\n+#ifdef SQLITE_DISABLE_INTRINSIC\n+  \"DISABLE_INTRINSIC\",\n+#endif\n+#ifdef SQLITE_DISABLE_LFS\n+  \"DISABLE_LFS\",\n+#endif\n+#ifdef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS\n+  \"DISABLE_PAGECACHE_OVERFLOW_STATS\",\n+#endif\n+#ifdef SQLITE_DISABLE_SKIPAHEAD_DISTINCT\n+  \"DISABLE_SKIPAHEAD_DISTINCT\",\n+#endif\n+#ifdef SQLITE_ENABLE_8_3_NAMES\n+  \"ENABLE_8_3_NAMES=\" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),\n+#endif\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  \"ENABLE_API_ARMOR\",\n+#endif\n+#ifdef SQLITE_ENABLE_ATOMIC_WRITE\n+  \"ENABLE_ATOMIC_WRITE\",\n+#endif\n+#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE\n+  \"ENABLE_BATCH_ATOMIC_WRITE\",\n+#endif\n+#ifdef SQLITE_ENABLE_BYTECODE_VTAB\n+  \"ENABLE_BYTECODE_VTAB\",\n+#endif\n+#ifdef SQLITE_ENABLE_CEROD\n+  \"ENABLE_CEROD=\" CTIMEOPT_VAL(SQLITE_ENABLE_CEROD),\n+#endif\n+#ifdef SQLITE_ENABLE_COLUMN_METADATA\n+  \"ENABLE_COLUMN_METADATA\",\n+#endif\n+#ifdef SQLITE_ENABLE_COLUMN_USED_MASK\n+  \"ENABLE_COLUMN_USED_MASK\",\n+#endif\n+#ifdef SQLITE_ENABLE_COSTMULT\n+  \"ENABLE_COSTMULT\",\n+#endif\n+#ifdef SQLITE_ENABLE_CURSOR_HINTS\n+  \"ENABLE_CURSOR_HINTS\",\n+#endif\n+#ifdef SQLITE_ENABLE_DBPAGE_VTAB\n+  \"ENABLE_DBPAGE_VTAB\",\n+#endif\n+#ifdef SQLITE_ENABLE_DBSTAT_VTAB\n+  \"ENABLE_DBSTAT_VTAB\",\n+#endif\n+#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n+  \"ENABLE_EXPENSIVE_ASSERT\",\n+#endif\n+#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n+  \"ENABLE_EXPLAIN_COMMENTS\",\n+#endif\n+#ifdef SQLITE_ENABLE_FTS3\n+  \"ENABLE_FTS3\",\n+#endif\n+#ifdef SQLITE_ENABLE_FTS3_PARENTHESIS\n+  \"ENABLE_FTS3_PARENTHESIS\",\n+#endif\n+#ifdef SQLITE_ENABLE_FTS3_TOKENIZER\n+  \"ENABLE_FTS3_TOKENIZER\",\n+#endif\n+#ifdef SQLITE_ENABLE_FTS4\n+  \"ENABLE_FTS4\",\n+#endif\n+#ifdef SQLITE_ENABLE_FTS5\n+  \"ENABLE_FTS5\",\n+#endif\n+#ifdef SQLITE_ENABLE_GEOPOLY\n+  \"ENABLE_GEOPOLY\",\n+#endif\n+#ifdef SQLITE_ENABLE_HIDDEN_COLUMNS\n+  \"ENABLE_HIDDEN_COLUMNS\",\n+#endif\n+#ifdef SQLITE_ENABLE_ICU\n+  \"ENABLE_ICU\",\n+#endif\n+#ifdef SQLITE_ENABLE_IOTRACE\n+  \"ENABLE_IOTRACE\",\n+#endif\n+#ifdef SQLITE_ENABLE_JSON1\n+  \"ENABLE_JSON1\",\n+#endif\n+#ifdef SQLITE_ENABLE_LOAD_EXTENSION\n+  \"ENABLE_LOAD_EXTENSION\",\n+#endif\n+#ifdef SQLITE_ENABLE_LOCKING_STYLE\n+  \"ENABLE_LOCKING_STYLE=\" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),\n+#endif\n+#ifdef SQLITE_ENABLE_MATH_FUNCTIONS\n+  \"ENABLE_MATH_FUNCTIONS\",\n+#endif\n+#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n+  \"ENABLE_MEMORY_MANAGEMENT\",\n+#endif\n+#ifdef SQLITE_ENABLE_MEMSYS3\n+  \"ENABLE_MEMSYS3\",\n+#endif\n+#ifdef SQLITE_ENABLE_MEMSYS5\n+  \"ENABLE_MEMSYS5\",\n+#endif\n+#ifdef SQLITE_ENABLE_MULTIPLEX\n+  \"ENABLE_MULTIPLEX\",\n+#endif\n+#ifdef SQLITE_ENABLE_NORMALIZE\n+  \"ENABLE_NORMALIZE\",\n+#endif\n+#ifdef SQLITE_ENABLE_NULL_TRIM\n+  \"ENABLE_NULL_TRIM\",\n+#endif\n+#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n+  \"ENABLE_OFFSET_SQL_FUNC\",\n+#endif\n+#ifdef SQLITE_ENABLE_OVERSIZE_CELL_CHECK\n+  \"ENABLE_OVERSIZE_CELL_CHECK\",\n+#endif\n+#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n+  \"ENABLE_PREUPDATE_HOOK\",\n+#endif\n+#ifdef SQLITE_ENABLE_QPSG\n+  \"ENABLE_QPSG\",\n+#endif\n+#ifdef SQLITE_ENABLE_RBU\n+  \"ENABLE_RBU\",\n+#endif\n+#ifdef SQLITE_ENABLE_RTREE\n+  \"ENABLE_RTREE\",\n+#endif\n+#ifdef SQLITE_ENABLE_SELECTTRACE\n+  \"ENABLE_SELECTTRACE\",\n+#endif\n+#ifdef SQLITE_ENABLE_SESSION\n+  \"ENABLE_SESSION\",\n+#endif\n+#ifdef SQLITE_ENABLE_SNAPSHOT\n+  \"ENABLE_SNAPSHOT\",\n+#endif\n+#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n+  \"ENABLE_SORTER_REFERENCES\",\n+#endif\n+#ifdef SQLITE_ENABLE_SQLLOG\n+  \"ENABLE_SQLLOG\",\n+#endif\n+#ifdef SQLITE_ENABLE_STAT4\n+  \"ENABLE_STAT4\",\n+#endif\n+#ifdef SQLITE_ENABLE_STMTVTAB\n+  \"ENABLE_STMTVTAB\",\n+#endif\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+  \"ENABLE_STMT_SCANSTATUS\",\n+#endif\n+#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n+  \"ENABLE_UNKNOWN_SQL_FUNCTION\",\n+#endif\n+#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n+  \"ENABLE_UNLOCK_NOTIFY\",\n+#endif\n+#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n+  \"ENABLE_UPDATE_DELETE_LIMIT\",\n+#endif\n+#ifdef SQLITE_ENABLE_URI_00_ERROR\n+  \"ENABLE_URI_00_ERROR\",\n+#endif\n+#ifdef SQLITE_ENABLE_VFSTRACE\n+  \"ENABLE_VFSTRACE\",\n+#endif\n+#ifdef SQLITE_ENABLE_WHERETRACE\n+  \"ENABLE_WHERETRACE\",\n+#endif\n+#ifdef SQLITE_ENABLE_ZIPVFS\n+  \"ENABLE_ZIPVFS\",\n+#endif\n+#ifdef SQLITE_EXPLAIN_ESTIMATED_ROWS\n+  \"EXPLAIN_ESTIMATED_ROWS\",\n+#endif\n+#ifdef SQLITE_EXTRA_IFNULLROW\n+  \"EXTRA_IFNULLROW\",\n+#endif\n+#ifdef SQLITE_EXTRA_INIT\n+  \"EXTRA_INIT=\" CTIMEOPT_VAL(SQLITE_EXTRA_INIT),\n+#endif\n+#ifdef SQLITE_EXTRA_SHUTDOWN\n+  \"EXTRA_SHUTDOWN=\" CTIMEOPT_VAL(SQLITE_EXTRA_SHUTDOWN),\n+#endif\n+#ifdef SQLITE_FTS3_MAX_EXPR_DEPTH\n+  \"FTS3_MAX_EXPR_DEPTH=\" CTIMEOPT_VAL(SQLITE_FTS3_MAX_EXPR_DEPTH),\n+#endif\n+#ifdef SQLITE_FTS5_ENABLE_TEST_MI\n+  \"FTS5_ENABLE_TEST_MI\",\n+#endif\n+#ifdef SQLITE_FTS5_NO_WITHOUT_ROWID\n+  \"FTS5_NO_WITHOUT_ROWID\",\n+#endif\n+#if HAVE_ISNAN || SQLITE_HAVE_ISNAN\n+  \"HAVE_ISNAN\",\n+#endif\n+#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n+# if SQLITE_HOMEGROWN_RECURSIVE_MUTEX != 1\n+  \"HOMEGROWN_RECURSIVE_MUTEX=\" CTIMEOPT_VAL(SQLITE_HOMEGROWN_RECURSIVE_MUTEX),\n+# endif\n+#endif\n+#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS\n+  \"IGNORE_AFP_LOCK_ERRORS\",\n+#endif\n+#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n+  \"IGNORE_FLOCK_LOCK_ERRORS\",\n+#endif\n+#ifdef SQLITE_INLINE_MEMCPY\n+  \"INLINE_MEMCPY\",\n+#endif\n+#ifdef SQLITE_INT64_TYPE\n+  \"INT64_TYPE\",\n+#endif\n+#ifdef SQLITE_INTEGRITY_CHECK_ERROR_MAX\n+  \"INTEGRITY_CHECK_ERROR_MAX=\" CTIMEOPT_VAL(SQLITE_INTEGRITY_CHECK_ERROR_MAX),\n+#endif\n+#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS\n+  \"LIKE_DOESNT_MATCH_BLOBS\",\n+#endif\n+#ifdef SQLITE_LOCK_TRACE\n+  \"LOCK_TRACE\",\n+#endif\n+#ifdef SQLITE_LOG_CACHE_SPILL\n+  \"LOG_CACHE_SPILL\",\n+#endif\n+#ifdef SQLITE_MALLOC_SOFT_LIMIT\n+  \"MALLOC_SOFT_LIMIT=\" CTIMEOPT_VAL(SQLITE_MALLOC_SOFT_LIMIT),\n+#endif\n+#ifdef SQLITE_MAX_ATTACHED\n+  \"MAX_ATTACHED=\" CTIMEOPT_VAL(SQLITE_MAX_ATTACHED),\n+#endif\n+#ifdef SQLITE_MAX_COLUMN\n+  \"MAX_COLUMN=\" CTIMEOPT_VAL(SQLITE_MAX_COLUMN),\n+#endif\n+#ifdef SQLITE_MAX_COMPOUND_SELECT\n+  \"MAX_COMPOUND_SELECT=\" CTIMEOPT_VAL(SQLITE_MAX_COMPOUND_SELECT),\n+#endif\n+#ifdef SQLITE_MAX_DEFAULT_PAGE_SIZE\n+  \"MAX_DEFAULT_PAGE_SIZE=\" CTIMEOPT_VAL(SQLITE_MAX_DEFAULT_PAGE_SIZE),\n+#endif\n+#ifdef SQLITE_MAX_EXPR_DEPTH\n+  \"MAX_EXPR_DEPTH=\" CTIMEOPT_VAL(SQLITE_MAX_EXPR_DEPTH),\n+#endif\n+#ifdef SQLITE_MAX_FUNCTION_ARG\n+  \"MAX_FUNCTION_ARG=\" CTIMEOPT_VAL(SQLITE_MAX_FUNCTION_ARG),\n+#endif\n+#ifdef SQLITE_MAX_LENGTH\n+  \"MAX_LENGTH=\" CTIMEOPT_VAL(SQLITE_MAX_LENGTH),\n+#endif\n+#ifdef SQLITE_MAX_LIKE_PATTERN_LENGTH\n+  \"MAX_LIKE_PATTERN_LENGTH=\" CTIMEOPT_VAL(SQLITE_MAX_LIKE_PATTERN_LENGTH),\n+#endif\n+#ifdef SQLITE_MAX_MEMORY\n+  \"MAX_MEMORY=\" CTIMEOPT_VAL(SQLITE_MAX_MEMORY),\n+#endif\n+#ifdef SQLITE_MAX_MMAP_SIZE\n+  \"MAX_MMAP_SIZE=\" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),\n+#endif\n+#ifdef SQLITE_MAX_MMAP_SIZE_\n+  \"MAX_MMAP_SIZE_=\" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE_),\n+#endif\n+#ifdef SQLITE_MAX_PAGE_COUNT\n+  \"MAX_PAGE_COUNT=\" CTIMEOPT_VAL(SQLITE_MAX_PAGE_COUNT),\n+#endif\n+#ifdef SQLITE_MAX_PAGE_SIZE\n+  \"MAX_PAGE_SIZE=\" CTIMEOPT_VAL(SQLITE_MAX_PAGE_SIZE),\n+#endif\n+#ifdef SQLITE_MAX_SCHEMA_RETRY\n+  \"MAX_SCHEMA_RETRY=\" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),\n+#endif\n+#ifdef SQLITE_MAX_SQL_LENGTH\n+  \"MAX_SQL_LENGTH=\" CTIMEOPT_VAL(SQLITE_MAX_SQL_LENGTH),\n+#endif\n+#ifdef SQLITE_MAX_TRIGGER_DEPTH\n+  \"MAX_TRIGGER_DEPTH=\" CTIMEOPT_VAL(SQLITE_MAX_TRIGGER_DEPTH),\n+#endif\n+#ifdef SQLITE_MAX_VARIABLE_NUMBER\n+  \"MAX_VARIABLE_NUMBER=\" CTIMEOPT_VAL(SQLITE_MAX_VARIABLE_NUMBER),\n+#endif\n+#ifdef SQLITE_MAX_VDBE_OP\n+  \"MAX_VDBE_OP=\" CTIMEOPT_VAL(SQLITE_MAX_VDBE_OP),\n+#endif\n+#ifdef SQLITE_MAX_WORKER_THREADS\n+  \"MAX_WORKER_THREADS=\" CTIMEOPT_VAL(SQLITE_MAX_WORKER_THREADS),\n+#endif\n+#ifdef SQLITE_MEMDEBUG\n+  \"MEMDEBUG\",\n+#endif\n+#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n+  \"MIXED_ENDIAN_64BIT_FLOAT\",\n+#endif\n+#ifdef SQLITE_MMAP_READWRITE\n+  \"MMAP_READWRITE\",\n+#endif\n+#ifdef SQLITE_MUTEX_NOOP\n+  \"MUTEX_NOOP\",\n+#endif\n+#ifdef SQLITE_MUTEX_OMIT\n+  \"MUTEX_OMIT\",\n+#endif\n+#ifdef SQLITE_MUTEX_PTHREADS\n+  \"MUTEX_PTHREADS\",\n+#endif\n+#ifdef SQLITE_MUTEX_W32\n+  \"MUTEX_W32\",\n+#endif\n+#ifdef SQLITE_NEED_ERR_NAME\n+  \"NEED_ERR_NAME\",\n+#endif\n+#ifdef SQLITE_NO_SYNC\n+  \"NO_SYNC\",\n+#endif\n+#ifdef SQLITE_OMIT_ALTERTABLE\n+  \"OMIT_ALTERTABLE\",\n+#endif\n+#ifdef SQLITE_OMIT_ANALYZE\n+  \"OMIT_ANALYZE\",\n+#endif\n+#ifdef SQLITE_OMIT_ATTACH\n+  \"OMIT_ATTACH\",\n+#endif\n+#ifdef SQLITE_OMIT_AUTHORIZATION\n+  \"OMIT_AUTHORIZATION\",\n+#endif\n+#ifdef SQLITE_OMIT_AUTOINCREMENT\n+  \"OMIT_AUTOINCREMENT\",\n+#endif\n+#ifdef SQLITE_OMIT_AUTOINIT\n+  \"OMIT_AUTOINIT\",\n+#endif\n+#ifdef SQLITE_OMIT_AUTOMATIC_INDEX\n+  \"OMIT_AUTOMATIC_INDEX\",\n+#endif\n+#ifdef SQLITE_OMIT_AUTORESET\n+  \"OMIT_AUTORESET\",\n+#endif\n+#ifdef SQLITE_OMIT_AUTOVACUUM\n+  \"OMIT_AUTOVACUUM\",\n+#endif\n+#ifdef SQLITE_OMIT_BETWEEN_OPTIMIZATION\n+  \"OMIT_BETWEEN_OPTIMIZATION\",\n+#endif\n+#ifdef SQLITE_OMIT_BLOB_LITERAL\n+  \"OMIT_BLOB_LITERAL\",\n+#endif\n+#ifdef SQLITE_OMIT_CAST\n+  \"OMIT_CAST\",\n+#endif\n+#ifdef SQLITE_OMIT_CHECK\n+  \"OMIT_CHECK\",\n+#endif\n+#ifdef SQLITE_OMIT_COMPLETE\n+  \"OMIT_COMPLETE\",\n+#endif\n+#ifdef SQLITE_OMIT_COMPOUND_SELECT\n+  \"OMIT_COMPOUND_SELECT\",\n+#endif\n+#ifdef SQLITE_OMIT_CONFLICT_CLAUSE\n+  \"OMIT_CONFLICT_CLAUSE\",\n+#endif\n+#ifdef SQLITE_OMIT_CTE\n+  \"OMIT_CTE\",\n+#endif\n+#if defined(SQLITE_OMIT_DATETIME_FUNCS) || defined(SQLITE_OMIT_FLOATING_POINT)\n+  \"OMIT_DATETIME_FUNCS\",\n+#endif\n+#ifdef SQLITE_OMIT_DECLTYPE\n+  \"OMIT_DECLTYPE\",\n+#endif\n+#ifdef SQLITE_OMIT_DEPRECATED\n+  \"OMIT_DEPRECATED\",\n+#endif\n+#ifdef SQLITE_OMIT_DESERIALIZE\n+  \"OMIT_DESERIALIZE\",\n+#endif\n+#ifdef SQLITE_OMIT_DISKIO\n+  \"OMIT_DISKIO\",\n+#endif\n+#ifdef SQLITE_OMIT_EXPLAIN\n+  \"OMIT_EXPLAIN\",\n+#endif\n+#ifdef SQLITE_OMIT_FLAG_PRAGMAS\n+  \"OMIT_FLAG_PRAGMAS\",\n+#endif\n+#ifdef SQLITE_OMIT_FLOATING_POINT\n+  \"OMIT_FLOATING_POINT\",\n+#endif\n+#ifdef SQLITE_OMIT_FOREIGN_KEY\n+  \"OMIT_FOREIGN_KEY\",\n+#endif\n+#ifdef SQLITE_OMIT_GET_TABLE\n+  \"OMIT_GET_TABLE\",\n+#endif\n+#ifdef SQLITE_OMIT_HEX_INTEGER\n+  \"OMIT_HEX_INTEGER\",\n+#endif\n+#ifdef SQLITE_OMIT_INCRBLOB\n+  \"OMIT_INCRBLOB\",\n+#endif\n+#ifdef SQLITE_OMIT_INTEGRITY_CHECK\n+  \"OMIT_INTEGRITY_CHECK\",\n+#endif\n+#ifdef SQLITE_OMIT_INTROSPECTION_PRAGMAS\n+  \"OMIT_INTROSPECTION_PRAGMAS\",\n+#endif\n+#ifdef SQLITE_OMIT_LIKE_OPTIMIZATION\n+  \"OMIT_LIKE_OPTIMIZATION\",\n+#endif\n+#ifdef SQLITE_OMIT_LOAD_EXTENSION\n+  \"OMIT_LOAD_EXTENSION\",\n+#endif\n+#ifdef SQLITE_OMIT_LOCALTIME\n+  \"OMIT_LOCALTIME\",\n+#endif\n+#ifdef SQLITE_OMIT_LOOKASIDE\n+  \"OMIT_LOOKASIDE\",\n+#endif\n+#ifdef SQLITE_OMIT_MEMORYDB\n+  \"OMIT_MEMORYDB\",\n+#endif\n+#ifdef SQLITE_OMIT_OR_OPTIMIZATION\n+  \"OMIT_OR_OPTIMIZATION\",\n+#endif\n+#ifdef SQLITE_OMIT_PAGER_PRAGMAS\n+  \"OMIT_PAGER_PRAGMAS\",\n+#endif\n+#ifdef SQLITE_OMIT_PARSER_TRACE\n+  \"OMIT_PARSER_TRACE\",\n+#endif\n+#ifdef SQLITE_OMIT_POPEN\n+  \"OMIT_POPEN\",\n+#endif\n+#ifdef SQLITE_OMIT_PRAGMA\n+  \"OMIT_PRAGMA\",\n+#endif\n+#ifdef SQLITE_OMIT_PROGRESS_CALLBACK\n+  \"OMIT_PROGRESS_CALLBACK\",\n+#endif\n+#ifdef SQLITE_OMIT_QUICKBALANCE\n+  \"OMIT_QUICKBALANCE\",\n+#endif\n+#ifdef SQLITE_OMIT_REINDEX\n+  \"OMIT_REINDEX\",\n+#endif\n+#ifdef SQLITE_OMIT_SCHEMA_PRAGMAS\n+  \"OMIT_SCHEMA_PRAGMAS\",\n+#endif\n+#ifdef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n+  \"OMIT_SCHEMA_VERSION_PRAGMAS\",\n+#endif\n+#ifdef SQLITE_OMIT_SHARED_CACHE\n+  \"OMIT_SHARED_CACHE\",\n+#endif\n+#ifdef SQLITE_OMIT_SHUTDOWN_DIRECTORIES\n+  \"OMIT_SHUTDOWN_DIRECTORIES\",\n+#endif\n+#ifdef SQLITE_OMIT_SUBQUERY\n+  \"OMIT_SUBQUERY\",\n+#endif\n+#ifdef SQLITE_OMIT_TCL_VARIABLE\n+  \"OMIT_TCL_VARIABLE\",\n+#endif\n+#ifdef SQLITE_OMIT_TEMPDB\n+  \"OMIT_TEMPDB\",\n+#endif\n+#ifdef SQLITE_OMIT_TEST_CONTROL\n+  \"OMIT_TEST_CONTROL\",\n+#endif\n+#ifdef SQLITE_OMIT_TRACE\n+# if SQLITE_OMIT_TRACE != 1\n+  \"OMIT_TRACE=\" CTIMEOPT_VAL(SQLITE_OMIT_TRACE),\n+# endif\n+#endif\n+#ifdef SQLITE_OMIT_TRIGGER\n+  \"OMIT_TRIGGER\",\n+#endif\n+#ifdef SQLITE_OMIT_TRUNCATE_OPTIMIZATION\n+  \"OMIT_TRUNCATE_OPTIMIZATION\",\n+#endif\n+#ifdef SQLITE_OMIT_UTF16\n+  \"OMIT_UTF16\",\n+#endif\n+#ifdef SQLITE_OMIT_VACUUM\n+  \"OMIT_VACUUM\",\n+#endif\n+#ifdef SQLITE_OMIT_VIEW\n+  \"OMIT_VIEW\",\n+#endif\n+#ifdef SQLITE_OMIT_VIRTUALTABLE\n+  \"OMIT_VIRTUALTABLE\",\n+#endif\n+#ifdef SQLITE_OMIT_WAL\n+  \"OMIT_WAL\",\n+#endif\n+#ifdef SQLITE_OMIT_WSD\n+  \"OMIT_WSD\",\n+#endif\n+#ifdef SQLITE_OMIT_XFER_OPT\n+  \"OMIT_XFER_OPT\",\n+#endif\n+#ifdef SQLITE_PCACHE_SEPARATE_HEADER\n+  \"PCACHE_SEPARATE_HEADER\",\n+#endif\n+#ifdef SQLITE_PERFORMANCE_TRACE\n+  \"PERFORMANCE_TRACE\",\n+#endif\n+#ifdef SQLITE_POWERSAFE_OVERWRITE\n+# if SQLITE_POWERSAFE_OVERWRITE != 1\n+  \"POWERSAFE_OVERWRITE=\" CTIMEOPT_VAL(SQLITE_POWERSAFE_OVERWRITE),\n+# endif\n+#endif\n+#ifdef SQLITE_PREFER_PROXY_LOCKING\n+  \"PREFER_PROXY_LOCKING\",\n+#endif\n+#ifdef SQLITE_PROXY_DEBUG\n+  \"PROXY_DEBUG\",\n+#endif\n+#ifdef SQLITE_REVERSE_UNORDERED_SELECTS\n+  \"REVERSE_UNORDERED_SELECTS\",\n+#endif\n+#ifdef SQLITE_RTREE_INT_ONLY\n+  \"RTREE_INT_ONLY\",\n+#endif\n+#ifdef SQLITE_SECURE_DELETE\n+  \"SECURE_DELETE\",\n+#endif\n+#ifdef SQLITE_SMALL_STACK\n+  \"SMALL_STACK\",\n+#endif\n+#ifdef SQLITE_SORTER_PMASZ\n+  \"SORTER_PMASZ=\" CTIMEOPT_VAL(SQLITE_SORTER_PMASZ),\n+#endif\n+#ifdef SQLITE_SOUNDEX\n+  \"SOUNDEX\",\n+#endif\n+#ifdef SQLITE_STAT4_SAMPLES\n+  \"STAT4_SAMPLES=\" CTIMEOPT_VAL(SQLITE_STAT4_SAMPLES),\n+#endif\n+#ifdef SQLITE_STMTJRNL_SPILL\n+  \"STMTJRNL_SPILL=\" CTIMEOPT_VAL(SQLITE_STMTJRNL_SPILL),\n+#endif\n+#ifdef SQLITE_SUBSTR_COMPATIBILITY\n+  \"SUBSTR_COMPATIBILITY\",\n+#endif\n+#if (!defined(SQLITE_WIN32_MALLOC) \\\n+     && !defined(SQLITE_ZERO_MALLOC) \\\n+     && !defined(SQLITE_MEMDEBUG) \\\n+    ) || defined(SQLITE_SYSTEM_MALLOC)\n+  \"SYSTEM_MALLOC\",\n+#endif\n+#ifdef SQLITE_TCL\n+  \"TCL\",\n+#endif\n+#ifdef SQLITE_TEMP_STORE\n+  \"TEMP_STORE=\" CTIMEOPT_VAL(SQLITE_TEMP_STORE),\n+#endif\n+#ifdef SQLITE_TEST\n+  \"TEST\",\n+#endif\n+#if defined(SQLITE_THREADSAFE)\n+  \"THREADSAFE=\" CTIMEOPT_VAL(SQLITE_THREADSAFE),\n+#elif defined(THREADSAFE)\n+  \"THREADSAFE=\" CTIMEOPT_VAL(THREADSAFE),\n+#else\n+  \"THREADSAFE=1\",\n+#endif\n+#ifdef SQLITE_UNLINK_AFTER_CLOSE\n+  \"UNLINK_AFTER_CLOSE\",\n+#endif\n+#ifdef SQLITE_UNTESTABLE\n+  \"UNTESTABLE\",\n+#endif\n+#ifdef SQLITE_USER_AUTHENTICATION\n+  \"USER_AUTHENTICATION\",\n+#endif\n+#ifdef SQLITE_USE_ALLOCA\n+  \"USE_ALLOCA\",\n+#endif\n+#ifdef SQLITE_USE_FCNTL_TRACE\n+  \"USE_FCNTL_TRACE\",\n+#endif\n+#ifdef SQLITE_USE_URI\n+  \"USE_URI\",\n+#endif\n+#ifdef SQLITE_VDBE_COVERAGE\n+  \"VDBE_COVERAGE\",\n+#endif\n+#ifdef SQLITE_WIN32_MALLOC\n+  \"WIN32_MALLOC\",\n+#endif\n+#ifdef SQLITE_ZERO_MALLOC\n+  \"ZERO_MALLOC\",\n+#endif\n+\/*\n+** END CODE GENERATED BY tool\/mkctime.tcl\n+*\/\n+};\n+\n+SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt){\n+  *pnOpt = sizeof(sqlite3azCompileOpt) \/ sizeof(sqlite3azCompileOpt[0]);\n+  return (const char**)sqlite3azCompileOpt;\n+}\n+\n+#endif \/* SQLITE_OMIT_COMPILEOPTION_DIAGS *\/\n+\n+\/************** End of ctime.c ***********************************************\/\n@@ -20368,1 +21296,1 @@\n-    252,253,254,255\n+    252,253,254,255,\n@@ -20388,0 +21316,25 @@\n+\/* All of the upper-to-lower conversion data is above.  The following\n+** 18 integers are completely unrelated.  They are appended to the\n+** sqlite3UpperToLower[] array to avoid UBSAN warnings.  Here's what is\n+** going on:\n+**\n+** The SQL comparison operators (<>, =, >, <=, <, and >=) are implemented\n+** by invoking sqlite3MemCompare(A,B) which compares values A and B and\n+** returns negative, zero, or positive if A is less then, equal to, or\n+** greater than B, respectively.  Then the true false results is found by\n+** consulting sqlite3aLTb[opcode], sqlite3aEQb[opcode], or\n+** sqlite3aGTb[opcode] depending on whether the result of compare(A,B)\n+** is negative, zero, or positive, where opcode is the specific opcode.\n+** The only works because the comparison opcodes are consecutive and in\n+** this order: NE EQ GT LE LT GE.  Various assert()s throughout the code\n+** ensure that is the case.\n+**\n+** These elements must be appended to another array.  Otherwise the\n+** index (here shown as [256-OP_Ne]) would be out-of-bounds and thus\n+** be undefined behavior.  That's goofy, but the C-standards people thought\n+** it was a good idea, so here we are.\n+*\/\n+\/* NE  EQ  GT  LE  LT  GE  *\/\n+   1,  0,  0,  1,  1,  0,  \/* aLTb[]: Use when compare(A,B) less than zero *\/\n+   0,  1,  0,  1,  0,  1,  \/* aEQb[]: Use when compare(A,B) equals zero *\/\n+   1,  0,  1,  0,  0,  1   \/* aGTb[]: Use when compare(A,B) greater than zero*\/\n@@ -20389,0 +21342,3 @@\n+SQLITE_PRIVATE const unsigned char *sqlite3aLTb = &sqlite3UpperToLower[256-OP_Ne];\n+SQLITE_PRIVATE const unsigned char *sqlite3aEQb = &sqlite3UpperToLower[256+6-OP_Ne];\n+SQLITE_PRIVATE const unsigned char *sqlite3aGTb = &sqlite3UpperToLower[256+12-OP_Ne];\n@@ -20582,1 +21538,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -20601,0 +21557,12 @@\n+#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)\n+\/*\n+** Counter used for coverage testing.  Does not come into play for\n+** release builds.\n+**\n+** Access to this global variable is not mutex protected.  This might\n+** result in TSAN warnings.  But as the variable does not exist in\n+** release builds, that should not be a concern.\n+*\/\n+SQLITE_PRIVATE unsigned int sqlite3CoverageCounter;\n+#endif \/* SQLITE_COVERAGE_TEST || SQLITE_DEBUG *\/\n+\n@@ -20631,0 +21599,6 @@\n+\/*\n+** Tracing flags set by SQLITE_TESTCTRL_TRACEFLAGS.\n+*\/\n+SQLITE_PRIVATE u32 sqlite3SelectTrace = 0;\n+SQLITE_PRIVATE u32 sqlite3WhereTrace = 0;\n+\n@@ -20645,0 +21619,42 @@\n+\/*\n+** Standard typenames.  These names must match the COLTYPE_* definitions.\n+** Adjust the SQLITE_N_STDTYPE value if adding or removing entries.\n+**\n+**    sqlite3StdType[]            The actual names of the datatypes.\n+**\n+**    sqlite3StdTypeLen[]         The length (in bytes) of each entry\n+**                                in sqlite3StdType[].\n+**\n+**    sqlite3StdTypeAffinity[]    The affinity associated with each entry\n+**                                in sqlite3StdType[].\n+**\n+**    sqlite3StdTypeMap[]         The type value (as returned from\n+**                                sqlite3_column_type() or sqlite3_value_type())\n+**                                for each entry in sqlite3StdType[].\n+*\/\n+SQLITE_PRIVATE const unsigned char sqlite3StdTypeLen[] = { 3, 4, 3, 7, 4, 4 };\n+SQLITE_PRIVATE const char sqlite3StdTypeAffinity[] = {\n+  SQLITE_AFF_NUMERIC,\n+  SQLITE_AFF_BLOB,\n+  SQLITE_AFF_INTEGER,\n+  SQLITE_AFF_INTEGER,\n+  SQLITE_AFF_REAL,\n+  SQLITE_AFF_TEXT\n+};\n+SQLITE_PRIVATE const char sqlite3StdTypeMap[] = {\n+  0,\n+  SQLITE_BLOB,\n+  SQLITE_INTEGER,\n+  SQLITE_INTEGER,\n+  SQLITE_FLOAT,\n+  SQLITE_TEXT\n+};\n+SQLITE_PRIVATE const char *sqlite3StdType[] = {\n+  \"ANY\",\n+  \"BLOB\",\n+  \"INT\",\n+  \"INTEGER\",\n+  \"REAL\",\n+  \"TEXT\"\n+};\n+\n@@ -20753,1 +21769,2 @@\n-  Bool seekHit:1;         \/* See the OP_SeekHit and OP_IfNoHope opcodes *\/\n+  Bool hasBeenDuped:1;    \/* This cursor was source or target of OP_OpenDup *\/\n+  u16 seekHit;            \/* See the OP_SeekHit and OP_IfNoHope opcodes *\/\n@@ -20756,1 +21773,1 @@\n-  int *aAltMap;           \/* Mapping from table to index column numbers *\/\n+  u32 *aAltMap;           \/* Mapping from table to index column numbers *\/\n@@ -20846,2 +21863,2 @@\n-  int nChange;            \/* Statement changes (Vdbe.nChange)     *\/\n-  int nDbChange;          \/* Value of db->nChange *\/\n+  i64 nChange;            \/* Statement changes (Vdbe.nChange)     *\/\n+  i64 nDbChange;          \/* Value of db->nChange *\/\n@@ -21048,1 +22065,1 @@\n-  u32 magic;              \/* Magic number for sanity checking *\/\n+  u32 iVdbeMagic;         \/* Magic number defining state of the SQL statement *\/\n@@ -21054,1 +22071,1 @@\n-  int nChange;            \/* Number of db changes made since last reset *\/\n+  i64 nChange;            \/* Number of db changes made since last reset *\/\n@@ -21138,0 +22155,1 @@\n+  int iBlobWrite;                 \/* Value returned by preupdate_blobwrite() *\/\n@@ -21152,1 +22170,1 @@\n-SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor**, int*);\n+SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor**, u32*);\n@@ -21181,1 +22199,1 @@\n-SQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));\n+SQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, i64, u8, void(*)(void*));\n@@ -21191,0 +22209,1 @@\n+#ifndef SQLITE_OMIT_INCRBLOB\n@@ -21192,0 +22211,3 @@\n+#else\n+SQLITE_PRIVATE int sqlite3VdbeMemSetZeroBlob(Mem*,int);\n+#endif\n@@ -21198,0 +22220,1 @@\n+SQLITE_PRIVATE int sqlite3IntFloatCompare(i64,double);\n@@ -21226,1 +22249,2 @@\n-SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(Vdbe*,VdbeCursor*,int,const char*,Table*,i64,int);\n+SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(\n+    Vdbe*,VdbeCursor*,int,const char*,Table*,i64,int,int);\n@@ -21628,1 +22652,1 @@\n-      \/* Fall through into the next case *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -22187,1 +23211,1 @@\n-  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n+  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n@@ -22553,0 +23577,1 @@\n+    if( !sqlite3NotPureFunc(context) ) return 1;\n@@ -22680,1 +23705,0 @@\n-  u64 n;\n@@ -22682,1 +23706,0 @@\n-  char *z;\n@@ -22685,1 +23708,3 @@\n-  char zBuf[100];\n+  sqlite3_str sRes;\n+\n+\n@@ -22690,49 +23715,2 @@\n-  for(i=0, n=1; zFmt[i]; i++, n++){\n-    if( zFmt[i]=='%' ){\n-      switch( zFmt[i+1] ){\n-        case 'd':\n-        case 'H':\n-        case 'm':\n-        case 'M':\n-        case 'S':\n-        case 'W':\n-          n++;\n-          \/* fall thru *\/\n-        case 'w':\n-        case '%':\n-          break;\n-        case 'f':\n-          n += 8;\n-          break;\n-        case 'j':\n-          n += 3;\n-          break;\n-        case 'Y':\n-          n += 8;\n-          break;\n-        case 's':\n-        case 'J':\n-          n += 50;\n-          break;\n-        default:\n-          return;  \/* ERROR.  return a NULL *\/\n-      }\n-      i++;\n-    }\n-  }\n-  testcase( n==sizeof(zBuf)-1 );\n-  testcase( n==sizeof(zBuf) );\n-  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH]+1 );\n-  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH] );\n-  if( n<sizeof(zBuf) ){\n-    z = zBuf;\n-  }else if( n>(u64)db->aLimit[SQLITE_LIMIT_LENGTH] ){\n-    sqlite3_result_error_toobig(context);\n-    return;\n-  }else{\n-    z = sqlite3DbMallocRawNN(db, (int)n);\n-    if( z==0 ){\n-      sqlite3_result_error_nomem(context);\n-      return;\n-    }\n-  }\n+  sqlite3StrAccumInit(&sRes, 0, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);\n+\n@@ -22742,55 +23720,34 @@\n-    if( zFmt[i]!='%' ){\n-      z[j++] = zFmt[i];\n-    }else{\n-      i++;\n-      switch( zFmt[i] ){\n-        case 'd':  sqlite3_snprintf(3, &z[j],\"%02d\",x.D); j+=2; break;\n-        case 'f': {\n-          double s = x.s;\n-          if( s>59.999 ) s = 59.999;\n-          sqlite3_snprintf(7, &z[j],\"%06.3f\", s);\n-          j += sqlite3Strlen30(&z[j]);\n-          break;\n-        }\n-        case 'H':  sqlite3_snprintf(3, &z[j],\"%02d\",x.h); j+=2; break;\n-        case 'W': \/* Fall thru *\/\n-        case 'j': {\n-          int nDay;             \/* Number of days since 1st day of year *\/\n-          DateTime y = x;\n-          y.validJD = 0;\n-          y.M = 1;\n-          y.D = 1;\n-          computeJD(&y);\n-          nDay = (int)((x.iJD-y.iJD+43200000)\/86400000);\n-          if( zFmt[i]=='W' ){\n-            int wd;   \/* 0=Monday, 1=Tuesday, ... 6=Sunday *\/\n-            wd = (int)(((x.iJD+43200000)\/86400000)%7);\n-            sqlite3_snprintf(3, &z[j],\"%02d\",(nDay+7-wd)\/7);\n-            j += 2;\n-          }else{\n-            sqlite3_snprintf(4, &z[j],\"%03d\",nDay+1);\n-            j += 3;\n-          }\n-          break;\n-        }\n-        case 'J': {\n-          sqlite3_snprintf(20, &z[j],\"%.16g\",x.iJD\/86400000.0);\n-          j+=sqlite3Strlen30(&z[j]);\n-          break;\n-        }\n-        case 'm':  sqlite3_snprintf(3, &z[j],\"%02d\",x.M); j+=2; break;\n-        case 'M':  sqlite3_snprintf(3, &z[j],\"%02d\",x.m); j+=2; break;\n-        case 's': {\n-          sqlite3_snprintf(30,&z[j],\"%lld\",\n-                           (i64)(x.iJD\/1000 - 21086676*(i64)10000));\n-          j += sqlite3Strlen30(&z[j]);\n-          break;\n-        }\n-        case 'S':  sqlite3_snprintf(3,&z[j],\"%02d\",(int)x.s); j+=2; break;\n-        case 'w': {\n-          z[j++] = (char)(((x.iJD+129600000)\/86400000) % 7) + '0';\n-          break;\n-        }\n-        case 'Y': {\n-          sqlite3_snprintf(5,&z[j],\"%04d\",x.Y); j+=sqlite3Strlen30(&z[j]);\n-          break;\n+    if( zFmt[i]!='%' ) continue;\n+    if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));\n+    i++;\n+    j = i + 1;\n+    switch( zFmt[i] ){\n+      case 'd': {\n+        sqlite3_str_appendf(&sRes, \"%02d\", x.D);\n+        break;\n+      }\n+      case 'f': {\n+        double s = x.s;\n+        if( s>59.999 ) s = 59.999;\n+        sqlite3_str_appendf(&sRes, \"%06.3f\", s);\n+        break;\n+      }\n+      case 'H': {\n+        sqlite3_str_appendf(&sRes, \"%02d\", x.h);\n+        break;\n+      }\n+      case 'W': \/* Fall thru *\/\n+      case 'j': {\n+        int nDay;             \/* Number of days since 1st day of year *\/\n+        DateTime y = x;\n+        y.validJD = 0;\n+        y.M = 1;\n+        y.D = 1;\n+        computeJD(&y);\n+        nDay = (int)((x.iJD-y.iJD+43200000)\/86400000);\n+        if( zFmt[i]=='W' ){\n+          int wd;   \/* 0=Monday, 1=Tuesday, ... 6=Sunday *\/\n+          wd = (int)(((x.iJD+43200000)\/86400000)%7);\n+          sqlite3_str_appendf(&sRes,\"%02d\",(nDay+7-wd)\/7);\n+        }else{\n+          sqlite3_str_appendf(&sRes,\"%03d\",nDay+1);\n@@ -22798,1 +23755,39 @@\n-        default:   z[j++] = '%'; break;\n+        break;\n+      }\n+      case 'J': {\n+        sqlite3_str_appendf(&sRes,\"%.16g\",x.iJD\/86400000.0);\n+        break;\n+      }\n+      case 'm': {\n+        sqlite3_str_appendf(&sRes,\"%02d\",x.M);\n+        break;\n+      }\n+      case 'M': {\n+        sqlite3_str_appendf(&sRes,\"%02d\",x.m);\n+        break;\n+      }\n+      case 's': {\n+        i64 iS = (i64)(x.iJD\/1000 - 21086676*(i64)10000);\n+        sqlite3_str_appendf(&sRes,\"%lld\",iS);\n+        break;\n+      }\n+      case 'S': {\n+        sqlite3_str_appendf(&sRes,\"%02d\",(int)x.s);\n+        break;\n+      }\n+      case 'w': {\n+        sqlite3_str_appendchar(&sRes, 1,\n+                       (char)(((x.iJD+129600000)\/86400000) % 7) + '0');\n+        break;\n+      }\n+      case 'Y': {\n+        sqlite3_str_appendf(&sRes,\"%04d\",x.Y);\n+        break;\n+      }\n+      case '%': {\n+        sqlite3_str_appendchar(&sRes, 1, '%');\n+        break;\n+      }\n+      default: {\n+        sqlite3_str_reset(&sRes);\n+        return;\n@@ -22802,3 +23797,2 @@\n-  z[j] = 0;\n-  sqlite3_result_text(context, z, -1,\n-                      z==zBuf ? SQLITE_TRANSIENT : SQLITE_DYNAMIC);\n+  if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));\n+  sqlite3ResultStrAccum(context, &sRes);\n@@ -22883,1 +23877,1 @@\n-  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n+  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN));\n@@ -22886,1 +23880,1 @@\n-  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n+  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN));\n@@ -23053,0 +24047,2 @@\n+   && op!=SQLITE_FCNTL_CKPT_DONE\n+   && op!=SQLITE_FCNTL_CKPT_START\n@@ -23063,1 +24059,6 @@\n-    ** to the user.  *\/\n+    ** to the user.\n+    **\n+    ** The CKPT_DONE and CKPT_START file-controls are write-only signals\n+    ** to the cksumvfs.  Their return code is meaningless and is ignored\n+    ** by the SQLite core, so there is no point in simulating OOMs for them.\n+    *\/\n@@ -23078,0 +24079,1 @@\n+  if( NEVER(id->pMethods==0) ) return 0;\n@@ -23146,1 +24148,1 @@\n-  return pVfs->xDelete(pVfs, zPath, dirSync);\n+  return pVfs->xDelete!=0 ? pVfs->xDelete(pVfs, zPath, dirSync) : SQLITE_OK;\n@@ -23169,0 +24171,2 @@\n+  assert( zPath!=0 );\n+  assert( strlen(zPath)<=SQLITE_MAX_PATHLEN );  \/* tag-20210611-1 *\/\n@@ -23230,0 +24234,1 @@\n+      *ppFile = 0;\n@@ -23234,0 +24239,1 @@\n+    *ppFile = 0;\n@@ -23236,0 +24242,1 @@\n+  assert( *ppFile!=0 || rc!=SQLITE_OK );\n@@ -23277,1 +24284,1 @@\n-  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n+  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n@@ -23292,1 +24299,1 @@\n-  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) );\n+  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN)) );\n@@ -23323,1 +24330,1 @@\n-  MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )\n+  MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n@@ -23347,1 +24354,1 @@\n-  MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )\n+  MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n@@ -23953,1 +24960,1 @@\n-static struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){\n+static struct MemBlockHdr *sqlite3MemsysGetHeader(const void *pAllocation){\n@@ -24183,1 +25190,1 @@\n-  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){\n+  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){\n@@ -24200,1 +25207,1 @@\n-SQLITE_PRIVATE int sqlite3MemdebugHasType(void *p, u8 eType){\n+SQLITE_PRIVATE int sqlite3MemdebugHasType(const void *p, u8 eType){\n@@ -24202,1 +25209,1 @@\n-  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){\n+  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){\n@@ -24222,1 +25229,1 @@\n-SQLITE_PRIVATE int sqlite3MemdebugNoType(void *p, u8 eType){\n+SQLITE_PRIVATE int sqlite3MemdebugNoType(const void *p, u8 eType){\n@@ -24224,1 +25231,1 @@\n-  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){\n+  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){\n@@ -24453,1 +25460,1 @@\n-  u32 mnMaster;\n+  u32 mnKeyBlk;\n@@ -24456,4 +25463,4 @@\n-  ** iMaster is the index of the master chunk.  Most new allocations\n-  ** occur off of this chunk.  szMaster is the size (in Mem3Blocks)\n-  ** of the current master.  iMaster is 0 if there is not master chunk.\n-  ** The master chunk is not in either the aiHash[] or aiSmall[].\n+  ** iKeyBlk is the index of the key chunk.  Most new allocations\n+  ** occur off of this chunk.  szKeyBlk is the size (in Mem3Blocks)\n+  ** of the current key chunk.  iKeyBlk is 0 if there is no key chunk.\n+  ** The key chunk is not in either the aiHash[] or aiSmall[].\n@@ -24461,2 +25468,2 @@\n-  u32 iMaster;\n-  u32 szMaster;\n+  u32 iKeyBlk;\n+  u32 szKeyBlk;\n@@ -24598,2 +25605,2 @@\n-** Carve a piece off of the end of the mem3.iMaster free chunk.\n-** Return a pointer to the new allocation.  Or, if the master chunk\n+** Carve a piece off of the end of the mem3.iKeyBlk free chunk.\n+** Return a pointer to the new allocation.  Or, if the key chunk\n@@ -24602,1 +25609,1 @@\n-static void *memsys3FromMaster(u32 nBlock){\n+static void *memsys3FromKeyBlk(u32 nBlock){\n@@ -24604,7 +25611,7 @@\n-  assert( mem3.szMaster>=nBlock );\n-  if( nBlock>=mem3.szMaster-1 ){\n-    \/* Use the entire master *\/\n-    void *p = memsys3Checkout(mem3.iMaster, mem3.szMaster);\n-    mem3.iMaster = 0;\n-    mem3.szMaster = 0;\n-    mem3.mnMaster = 0;\n+  assert( mem3.szKeyBlk>=nBlock );\n+  if( nBlock>=mem3.szKeyBlk-1 ){\n+    \/* Use the entire key chunk *\/\n+    void *p = memsys3Checkout(mem3.iKeyBlk, mem3.szKeyBlk);\n+    mem3.iKeyBlk = 0;\n+    mem3.szKeyBlk = 0;\n+    mem3.mnKeyBlk = 0;\n@@ -24613,1 +25620,1 @@\n-    \/* Split the master block.  Return the tail. *\/\n+    \/* Split the key block.  Return the tail. *\/\n@@ -24615,4 +25622,4 @@\n-    newi = mem3.iMaster + mem3.szMaster - nBlock;\n-    assert( newi > mem3.iMaster+1 );\n-    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = nBlock;\n-    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x |= 2;\n+    newi = mem3.iKeyBlk + mem3.szKeyBlk - nBlock;\n+    assert( newi > mem3.iKeyBlk+1 );\n+    mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.prevSize = nBlock;\n+    mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.size4x |= 2;\n@@ -24620,6 +25627,6 @@\n-    mem3.szMaster -= nBlock;\n-    mem3.aPool[newi-1].u.hdr.prevSize = mem3.szMaster;\n-    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;\n-    mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;\n-    if( mem3.szMaster < mem3.mnMaster ){\n-      mem3.mnMaster = mem3.szMaster;\n+    mem3.szKeyBlk -= nBlock;\n+    mem3.aPool[newi-1].u.hdr.prevSize = mem3.szKeyBlk;\n+    x = mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x & 2;\n+    mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x = mem3.szKeyBlk*4 | x;\n+    if( mem3.szKeyBlk < mem3.mnKeyBlk ){\n+      mem3.mnKeyBlk = mem3.szKeyBlk;\n@@ -24639,3 +25646,3 @@\n-** If it sees a chunk that is larger than mem3.iMaster, it replaces\n-** the current mem3.iMaster with the new larger chunk.  In order for\n-** this mem3.iMaster replacement to work, the master chunk must be\n+** If it sees a chunk that is larger than mem3.iKeyBlk, it replaces\n+** the current mem3.iKeyBlk with the new larger chunk.  In order for\n+** this mem3.iKeyBlk replacement to work, the key chunk must be\n@@ -24643,1 +25650,1 @@\n-** affairs, of course.  The calling routine must link the master\n+** affairs, of course.  The calling routine must link the key\n@@ -24645,1 +25652,1 @@\n-** changed) master chunk once this routine has finished.\n+** changed) key chunk once this routine has finished.\n@@ -24672,3 +25679,3 @@\n-    if( size>mem3.szMaster ){\n-      mem3.iMaster = i;\n-      mem3.szMaster = size;\n+    if( size>mem3.szKeyBlk ){\n+      mem3.iKeyBlk = i;\n+      mem3.szKeyBlk = size;\n@@ -24723,1 +25730,1 @@\n-  ** of the master chunk.  This step usually works if step 1 fails.\n+  ** of the key chunk.  This step usually works if step 1 fails.\n@@ -24725,2 +25732,2 @@\n-  if( mem3.szMaster>=nBlock ){\n-    return memsys3FromMaster(nBlock);\n+  if( mem3.szKeyBlk>=nBlock ){\n+    return memsys3FromKeyBlk(nBlock);\n@@ -24732,1 +25739,1 @@\n-  ** chunks.  Recompute the master chunk as the largest free chunk.\n+  ** chunks.  Recompute the key chunk as the largest free chunk.\n@@ -24734,1 +25741,1 @@\n-  ** of the end of the master chunk.  This step happens very\n+  ** of the end of the key chunk.  This step happens very\n@@ -24739,4 +25746,4 @@\n-    if( mem3.iMaster ){\n-      memsys3Link(mem3.iMaster);\n-      mem3.iMaster = 0;\n-      mem3.szMaster = 0;\n+    if( mem3.iKeyBlk ){\n+      memsys3Link(mem3.iKeyBlk);\n+      mem3.iKeyBlk = 0;\n+      mem3.szKeyBlk = 0;\n@@ -24750,4 +25757,4 @@\n-    if( mem3.szMaster ){\n-      memsys3Unlink(mem3.iMaster);\n-      if( mem3.szMaster>=nBlock ){\n-        return memsys3FromMaster(nBlock);\n+    if( mem3.szKeyBlk ){\n+      memsys3Unlink(mem3.iKeyBlk);\n+      if( mem3.szKeyBlk>=nBlock ){\n+        return memsys3FromKeyBlk(nBlock);\n@@ -24783,10 +25790,10 @@\n-  \/* Try to expand the master using the newly freed chunk *\/\n-  if( mem3.iMaster ){\n-    while( (mem3.aPool[mem3.iMaster-1].u.hdr.size4x&2)==0 ){\n-      size = mem3.aPool[mem3.iMaster-1].u.hdr.prevSize;\n-      mem3.iMaster -= size;\n-      mem3.szMaster += size;\n-      memsys3Unlink(mem3.iMaster);\n-      x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;\n-      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;\n-      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;\n+  \/* Try to expand the key using the newly freed chunk *\/\n+  if( mem3.iKeyBlk ){\n+    while( (mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x&2)==0 ){\n+      size = mem3.aPool[mem3.iKeyBlk-1].u.hdr.prevSize;\n+      mem3.iKeyBlk -= size;\n+      mem3.szKeyBlk += size;\n+      memsys3Unlink(mem3.iKeyBlk);\n+      x = mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x & 2;\n+      mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x = mem3.szKeyBlk*4 | x;\n+      mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.prevSize = mem3.szKeyBlk;\n@@ -24794,6 +25801,6 @@\n-    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;\n-    while( (mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x&1)==0 ){\n-      memsys3Unlink(mem3.iMaster+mem3.szMaster);\n-      mem3.szMaster += mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x\/4;\n-      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;\n-      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;\n+    x = mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x & 2;\n+    while( (mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.size4x&1)==0 ){\n+      memsys3Unlink(mem3.iKeyBlk+mem3.szKeyBlk);\n+      mem3.szKeyBlk += mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.size4x\/4;\n+      mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x = mem3.szKeyBlk*4 | x;\n+      mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.prevSize = mem3.szKeyBlk;\n@@ -24895,5 +25902,5 @@\n-  \/* Initialize the master block. *\/\n-  mem3.szMaster = mem3.nPool;\n-  mem3.mnMaster = mem3.szMaster;\n-  mem3.iMaster = 1;\n-  mem3.aPool[0].u.hdr.size4x = (mem3.szMaster<<2) + 2;\n+  \/* Initialize the key block. *\/\n+  mem3.szKeyBlk = mem3.nPool;\n+  mem3.mnKeyBlk = mem3.szKeyBlk;\n+  mem3.iKeyBlk = 1;\n+  mem3.aPool[0].u.hdr.size4x = (mem3.szKeyBlk<<2) + 2;\n@@ -24959,1 +25966,1 @@\n-                  i==mem3.iMaster ? \" **master**\" : \"\");\n+                  i==mem3.iKeyBlk ? \" **key**\" : \"\");\n@@ -24980,3 +25987,3 @@\n-  fprintf(out, \"master=%d\\n\", mem3.iMaster);\n-  fprintf(out, \"nowUsed=%d\\n\", mem3.nPool*8 - mem3.szMaster*8);\n-  fprintf(out, \"mxUsed=%d\\n\", mem3.nPool*8 - mem3.mnMaster*8);\n+  fprintf(out, \"key=%d\\n\", mem3.iKeyBlk);\n+  fprintf(out, \"nowUsed=%d\\n\", mem3.nPool*8 - mem3.szKeyBlk*8);\n+  fprintf(out, \"mxUsed=%d\\n\", mem3.nPool*8 - mem3.mnKeyBlk*8);\n@@ -26298,1 +27305,1 @@\n-** <li>  SQLITE_MUTEX_STATIC_MASTER\n+** <li>  SQLITE_MUTEX_STATIC_MAIN\n@@ -26600,199 +27607,1 @@\n-\/************** Include os_common.h in the middle of mutex_w32.c *************\/\n-\/************** Begin file os_common.h ***************************************\/\n-\/*\n-** 2004 May 22\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains macros and a little bit of code that is common to\n-** all of the platform-specific files (os_*.c) and is #included into those\n-** files.\n-**\n-** This file should be #included by the os_*.c files only.  It is not a\n-** general purpose header file.\n-*\/\n-#ifndef _OS_COMMON_H_\n-#define _OS_COMMON_H_\n-\n-\/*\n-** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n-** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n-** switch.  The following code should catch this problem at compile-time.\n-*\/\n-#ifdef MEMORY_DEBUG\n-# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n-#endif\n-\n-\/*\n-** Macros for performance tracing.  Normally turned off.  Only works\n-** on i486 hardware.\n-*\/\n-#ifdef SQLITE_PERFORMANCE_TRACE\n-\n-\/*\n-** hwtime.h contains inline assembler code for implementing\n-** high-performance timing routines.\n-*\/\n-\/************** Include hwtime.h in the middle of os_common.h ****************\/\n-\/************** Begin file hwtime.h ******************************************\/\n-\/*\n-** 2008 May 27\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains inline asm code for retrieving \"high-performance\"\n-** counters for x86 and x86_64 class CPUs.\n-*\/\n-#ifndef SQLITE_HWTIME_H\n-#define SQLITE_HWTIME_H\n-\n-\/*\n-** The following routine only works on pentium-class (or newer) processors.\n-** It uses the RDTSC opcode to read the cycle count value out of the\n-** processor and returns that value.  This can be used for high-res\n-** profiling.\n-*\/\n-#if !defined(__STRICT_ANSI__) && \\\n-    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n-    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n-\n-  #if defined(__GNUC__)\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-     unsigned int lo, hi;\n-     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n-     return (sqlite_uint64)hi << 32 | lo;\n-  }\n-\n-  #elif defined(_MSC_VER)\n-\n-  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n-     __asm {\n-        rdtsc\n-        ret       ; return value at EDX:EAX\n-     }\n-  }\n-\n-  #endif\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long val;\n-      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n-      return val;\n-  }\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long long retval;\n-      unsigned long junk;\n-      __asm__ __volatile__ (\"\\n\\\n-          1:      mftbu   %1\\n\\\n-                  mftb    %L0\\n\\\n-                  mftbu   %0\\n\\\n-                  cmpw    %0,%1\\n\\\n-                  bne     1b\"\n-                  : \"=r\" (retval), \"=r\" (junk));\n-      return retval;\n-  }\n-\n-#else\n-\n-  \/*\n-  ** asm() is needed for hardware timing support.  Without asm(),\n-  ** disable the sqlite3Hwtime() routine.\n-  **\n-  ** sqlite3Hwtime() is only used for some obscure debugging\n-  ** and analysis configurations, not in any deliverable, so this\n-  ** should not be a great loss.\n-  *\/\n-SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n-\n-#endif\n-\n-#endif \/* !defined(SQLITE_HWTIME_H) *\/\n-\n-\/************** End of hwtime.h **********************************************\/\n-\/************** Continuing where we left off in os_common.h ******************\/\n-\n-static sqlite_uint64 g_start;\n-static sqlite_uint64 g_elapsed;\n-#define TIMER_START       g_start=sqlite3Hwtime()\n-#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n-#define TIMER_ELAPSED     g_elapsed\n-#else\n-#define TIMER_START\n-#define TIMER_END\n-#define TIMER_ELAPSED     ((sqlite_uint64)0)\n-#endif\n-\n-\/*\n-** If we compile with the SQLITE_TEST macro set, then the following block\n-** of code will give us the ability to simulate a disk I\/O error.  This\n-** is used for testing the I\/O recovery logic.\n-*\/\n-#if defined(SQLITE_TEST)\n-SQLITE_API extern int sqlite3_io_error_hit;\n-SQLITE_API extern int sqlite3_io_error_hardhit;\n-SQLITE_API extern int sqlite3_io_error_pending;\n-SQLITE_API extern int sqlite3_io_error_persist;\n-SQLITE_API extern int sqlite3_io_error_benign;\n-SQLITE_API extern int sqlite3_diskfull_pending;\n-SQLITE_API extern int sqlite3_diskfull;\n-#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n-#define SimulateIOError(CODE)  \\\n-  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n-       || sqlite3_io_error_pending-- == 1 )  \\\n-              { local_ioerr(); CODE; }\n-static void local_ioerr(){\n-  IOTRACE((\"IOERR\\n\"));\n-  sqlite3_io_error_hit++;\n-  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n-}\n-#define SimulateDiskfullError(CODE) \\\n-   if( sqlite3_diskfull_pending ){ \\\n-     if( sqlite3_diskfull_pending == 1 ){ \\\n-       local_ioerr(); \\\n-       sqlite3_diskfull = 1; \\\n-       sqlite3_io_error_hit = 1; \\\n-       CODE; \\\n-     }else{ \\\n-       sqlite3_diskfull_pending--; \\\n-     } \\\n-   }\n-#else\n-#define SimulateIOErrorBenign(X)\n-#define SimulateIOError(A)\n-#define SimulateDiskfullError(A)\n-#endif \/* defined(SQLITE_TEST) *\/\n-\n-\/*\n-** When testing, keep a count of the number of open files.\n-*\/\n-#if defined(SQLITE_TEST)\n-SQLITE_API extern int sqlite3_open_file_count;\n-#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n-#else\n-#define OpenCounter(X)\n-#endif \/* defined(SQLITE_TEST) *\/\n-\n-#endif \/* !defined(_OS_COMMON_H_) *\/\n-\n-\/************** End of os_common.h *******************************************\/\n-\/************** Continuing where we left off in mutex_w32.c ******************\/\n+\/* #include \"os_common.h\" *\/\n@@ -27044,1 +27853,1 @@\n-** <li>  SQLITE_MUTEX_STATIC_MASTER\n+** <li>  SQLITE_MUTEX_STATIC_MAIN\n@@ -27436,1 +28245,0 @@\n-  memset(&mem0, 0, sizeof(mem0));\n@@ -27592,1 +28400,1 @@\n-static int isLookaside(sqlite3 *db, void *p){\n+static int isLookaside(sqlite3 *db, const void *p){\n@@ -27603,1 +28411,1 @@\n-SQLITE_PRIVATE int sqlite3MallocSize(void *p){\n+SQLITE_PRIVATE int sqlite3MallocSize(const void *p){\n@@ -27605,1 +28413,1 @@\n-  return sqlite3GlobalConfig.m.xSize(p);\n+  return sqlite3GlobalConfig.m.xSize((void*)p);\n@@ -27607,1 +28415,1 @@\n-static int lookasideMallocSize(sqlite3 *db, void *p){\n+static int lookasideMallocSize(sqlite3 *db, const void *p){\n@@ -27614,1 +28422,1 @@\n-SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){\n+SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, const void *p){\n@@ -27641,1 +28449,1 @@\n-  return sqlite3GlobalConfig.m.xSize(p);\n+  return sqlite3GlobalConfig.m.xSize((void*)p);\n@@ -27749,0 +28557,1 @@\n+    sqlite3_int64 nUsed;\n@@ -27752,1 +28561,1 @@\n-    if( nDiff>0 && sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED) >=\n+    if( nDiff>0 && (nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)) >=\n@@ -27755,0 +28564,4 @@\n+      if( mem0.hardLimit>0 && nUsed >= mem0.hardLimit - nDiff ){\n+        sqlite3_mutex_leave(mem0.mutex);\n+        return 0;\n+      }\n@@ -27994,3 +28807,1 @@\n-  if( z==0 ){\n-    return 0;\n-  }\n+  assert( z!=0 || n==0 );\n@@ -27998,1 +28809,1 @@\n-  zNew = sqlite3DbMallocRawNN(db, n+1);\n+  zNew = z ? sqlite3DbMallocRawNN(db, n+1) : 0;\n@@ -28063,1 +28874,1 @@\n-** Take actions at the end of an API call to indicate an OOM error\n+** Take actions at the end of an API call to deal with error codes.\n@@ -28065,4 +28876,7 @@\n-static SQLITE_NOINLINE int apiOomError(sqlite3 *db){\n-  sqlite3OomClear(db);\n-  sqlite3Error(db, SQLITE_NOMEM);\n-  return SQLITE_NOMEM_BKPT;\n+static SQLITE_NOINLINE int apiHandleError(sqlite3 *db, int rc){\n+  if( db->mallocFailed || rc==SQLITE_IOERR_NOMEM ){\n+    sqlite3OomClear(db);\n+    sqlite3Error(db, SQLITE_NOMEM);\n+    return SQLITE_NOMEM_BKPT;\n+  }\n+  return rc & db->errMask;\n@@ -28090,2 +28904,2 @@\n-  if( db->mallocFailed || rc==SQLITE_IOERR_NOMEM ){\n-    return apiOomError(db);\n+  if( db->mallocFailed || rc ){\n+    return apiHandleError(db, rc);\n@@ -28129,1 +28943,1 @@\n-#define etSRCLIST    12 \/* a pointer to a SrcList *\/\n+#define etSRCITEM    12 \/* a pointer to a SrcItem *\/\n@@ -28195,1 +29009,1 @@\n-  {  'S',  0, 0, etSRCLIST,    0,  0 },\n+  {  'S',  0, 0, etSRCITEM,    0,  0 },\n@@ -28199,0 +29013,6 @@\n+\/* Notes:\n+**\n+**    %S    Takes a pointer to SrcItem.  Shows name or database.name\n+**    %!S   Like %S but prefer the zName over the zAlias\n+*\/\n+\n@@ -28239,1 +29059,1 @@\n-static void setStrAccumError(StrAccum *p, u8 eError){\n+SQLITE_PRIVATE void sqlite3StrAccumSetError(StrAccum *p, u8 eError){\n@@ -28275,1 +29095,1 @@\n-    setStrAccumError(pAccum, SQLITE_TOOBIG);\n+    sqlite3StrAccumSetError(pAccum, SQLITE_TOOBIG);\n@@ -28280,1 +29100,1 @@\n-    setStrAccumError(pAccum, SQLITE_NOMEM);\n+    sqlite3StrAccumSetError(pAccum, SQLITE_NOMEM);\n@@ -28507,1 +29327,1 @@\n-        \/* Fall through into the next case *\/\n+        \/* no break *\/ deliberate_fall_through\n@@ -28511,1 +29331,1 @@\n-        \/* Fall through into the next case *\/\n+        \/* no break *\/ deliberate_fall_through\n@@ -28527,5 +29347,4 @@\n-            if( v==SMALLEST_INT64 ){\n-              longvalue = ((u64)1)<<63;\n-            }else{\n-              longvalue = -v;\n-            }\n+            testcase( v==SMALLEST_INT64 );\n+            testcase( v==(-1) );\n+            longvalue = ~v;\n+            longvalue++;\n@@ -28954,4 +29773,2 @@\n-      case etSRCLIST: {\n-        SrcList *pSrc;\n-        int k;\n-        struct SrcList_item *pItem;\n+      case etSRCITEM: {\n+        SrcItem *pItem;\n@@ -28959,3 +29776,1 @@\n-        pSrc = va_arg(ap, SrcList*);\n-        k = va_arg(ap, int);\n-        pItem = &pSrc->a[k];\n+        pItem = va_arg(ap, SrcItem*);\n@@ -28963,4 +29778,12 @@\n-        assert( k>=0 && k<pSrc->nSrc );\n-        if( pItem->zDatabase ){\n-          sqlite3_str_appendall(pAccum, pItem->zDatabase);\n-          sqlite3_str_append(pAccum, \".\", 1);\n+        if( pItem->zAlias && !flag_altform2 ){\n+          sqlite3_str_appendall(pAccum, pItem->zAlias);\n+        }else if( pItem->zName ){\n+          if( pItem->zDatabase ){\n+            sqlite3_str_appendall(pAccum, pItem->zDatabase);\n+            sqlite3_str_append(pAccum, \".\", 1);\n+          }\n+          sqlite3_str_appendall(pAccum, pItem->zName);\n+        }else if( pItem->zAlias ){\n+          sqlite3_str_appendall(pAccum, pItem->zAlias);\n+        }else if( ALWAYS(pItem->pSelect) ){\n+          sqlite3_str_appendf(pAccum, \"SUBQUERY %u\", pItem->pSelect->selId);\n@@ -28968,1 +29791,0 @@\n-        sqlite3_str_appendall(pAccum, pItem->zName);\n@@ -29017,1 +29839,1 @@\n-    setStrAccumError(p, SQLITE_TOOBIG);\n+    sqlite3StrAccumSetError(p, SQLITE_TOOBIG);\n@@ -29022,1 +29844,1 @@\n-    szNew += N + 1;\n+    szNew += (sqlite3_int64)N + 1;\n@@ -29030,1 +29852,1 @@\n-      setStrAccumError(p, SQLITE_TOOBIG);\n+      sqlite3StrAccumSetError(p, SQLITE_TOOBIG);\n@@ -29048,1 +29870,1 @@\n-      setStrAccumError(p, SQLITE_NOMEM);\n+      sqlite3StrAccumSetError(p, SQLITE_NOMEM);\n@@ -29121,1 +29943,1 @@\n-    setStrAccumError(p, SQLITE_NOMEM);\n+    sqlite3StrAccumSetError(p, SQLITE_NOMEM);\n@@ -29136,0 +29958,16 @@\n+\/*\n+** Use the content of the StrAccum passed as the second argument\n+** as the result of an SQL function.\n+*\/\n+SQLITE_PRIVATE void sqlite3ResultStrAccum(sqlite3_context *pCtx, StrAccum *p){\n+  if( p->accError ){\n+    sqlite3_result_error_code(pCtx, p->accError);\n+    sqlite3_str_reset(p);\n+  }else if( isMalloced(p) ){\n+    sqlite3_result_text(pCtx, p->zText, p->nChar, SQLITE_DYNAMIC);\n+  }else{\n+    sqlite3_result_text(pCtx, \"\", 0, SQLITE_STATIC);\n+    sqlite3_str_reset(p);\n+  }\n+}\n+\n@@ -29525,1 +30363,4 @@\n-      sqlite3_str_appendf(&x, \" AS\");\n+      if( pCte->pUse ){\n+        sqlite3_str_appendf(&x, \" (pUse=0x%p, nUse=%d)\", pCte->pUse,\n+                 pCte->pUse->nUse);\n+      }\n@@ -29541,1 +30382,1 @@\n-    const struct SrcList_item *pItem = &pSrc->a[i];\n+    const SrcItem *pItem = &pSrc->a[i];\n@@ -29545,6 +30386,2 @@\n-    sqlite3_str_appendf(&x, \"{%d:*}\", pItem->iCursor);\n-    if( pItem->zDatabase ){\n-      sqlite3_str_appendf(&x, \" %s.%s\", pItem->zDatabase, pItem->zName);\n-    }else if( pItem->zName ){\n-      sqlite3_str_appendf(&x, \" %s\", pItem->zName);\n-    }\n+    x.printfFlags |= SQLITE_PRINTF_INTERNAL;\n+    sqlite3_str_appendf(&x, \"{%d:*} %!S\", pItem->iCursor, pItem);\n@@ -29555,3 +30392,0 @@\n-    if( pItem->zAlias ){\n-      sqlite3_str_appendf(&x, \" (AS %s)\", pItem->zAlias);\n-    }\n@@ -29560,0 +30394,2 @@\n+    }else if( pItem->fg.jointype & JT_CROSS ){\n+      sqlite3_str_appendf(&x, \" CROSS-JOIN\");\n@@ -29564,0 +30400,3 @@\n+    if( pItem->fg.isCte ){\n+      sqlite3_str_appendf(&x, \" CteUse=0x%p\", pItem->u2.pCteUse);\n+    }\n@@ -29855,0 +30694,1 @@\n+        assert( ExprUseYTab(pExpr) );\n@@ -29874,0 +30714,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29879,0 +30720,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29887,2 +30729,2 @@\n-      sqlite3TreeViewLine(pView,\n-         sqlite3ExprTruthValue(pExpr) ? \"TRUE\" : \"FALSE\");\n+      sqlite3TreeViewLine(pView,\"%s%s\",\n+         sqlite3ExprTruthValue(pExpr) ? \"TRUE\" : \"FALSE\", zFlgs);\n@@ -29893,0 +30735,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29898,0 +30741,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29907,0 +30751,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29913,0 +30758,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29962,0 +30808,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29973,0 +30820,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29988,0 +30836,1 @@\n+        assert( ExprUseXList(pExpr) );\n@@ -29995,0 +30844,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -29996,1 +30846,1 @@\n-        sqlite3TreeViewLine(pView, \"AGG_FUNCTION%d %Q%s iAgg=%d agg=%p\",\n+        sqlite3TreeViewLine(pView, \"AGG_FUNCTION%d %Q%s agg=%d[%d]\/%p\",\n@@ -29998,0 +30848,1 @@\n+                             pExpr->pAggInfo ? pExpr->pAggInfo->selId : 0,\n@@ -30025,0 +30876,1 @@\n+      assert( ExprUseXSelect(pExpr) );\n@@ -30030,1 +30882,2 @@\n-      sqlite3TreeViewLine(pView, \"SELECT-expr flags=0x%x\", pExpr->flags);\n+      assert( ExprUseXSelect(pExpr) );\n+      sqlite3TreeViewLine(pView, \"subquery-expr flags=0x%x\", pExpr->flags);\n@@ -30037,1 +30890,1 @@\n-      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+      if( ExprUseXSelect(pExpr) ){\n@@ -30058,3 +30911,6 @@\n-      Expr *pX = pExpr->pLeft;\n-      Expr *pY = pExpr->x.pList->a[0].pExpr;\n-      Expr *pZ = pExpr->x.pList->a[1].pExpr;\n+      const Expr *pX, *pY, *pZ;\n+      pX = pExpr->pLeft;\n+      assert( ExprUseXList(pExpr) );\n+      assert( pExpr->x.pList->nExpr==2 );\n+      pY = pExpr->x.pList->a[0].pExpr;\n+      pZ = pExpr->x.pList->a[1].pExpr;\n@@ -30082,0 +30938,1 @@\n+      assert( ExprUseXList(pExpr) );\n@@ -30094,0 +30951,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -30106,0 +30964,1 @@\n+      assert( ExprUseXList(pExpr) );\n@@ -30111,1 +30970,4 @@\n-      sqlite3TreeViewLine(pView, \"SELECT-COLUMN %d\", pExpr->iColumn);\n+      sqlite3TreeViewLine(pView, \"SELECT-COLUMN %d of [0..%d]%s\",\n+              pExpr->iColumn, pExpr->iTable-1,\n+              pExpr->pRight==pExpr->pLeft ? \" (SELECT-owner)\" : \"\");\n+      assert( ExprUseXSelect(pExpr->pLeft) );\n@@ -30120,0 +30982,17 @@\n+    case TK_ERROR: {\n+      Expr tmp;\n+      sqlite3TreeViewLine(pView, \"ERROR\");\n+      tmp = *pExpr;\n+      tmp.op = pExpr->op2;\n+      sqlite3TreeViewExpr(pView, &tmp, 0);\n+      break;\n+    }\n+    case TK_ROW: {\n+      if( pExpr->iColumn<=0 ){\n+        sqlite3TreeViewLine(pView, \"First FROM table rowid\");\n+      }else{\n+        sqlite3TreeViewLine(pView, \"First FROM table column %d\",\n+            pExpr->iColumn-1);\n+      }\n+      break;\n+    }\n@@ -30269,0 +31148,1 @@\n+    sqlite3_vfs *pVfs = sqlite3_vfs_find(0);\n@@ -30273,1 +31153,5 @@\n-    sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);\n+    if( NEVER(pVfs==0) ){\n+      memset(k, 0, sizeof(k));\n+    }else{\n+      sqlite3OsRandomness(pVfs, 256, k);\n+    }\n@@ -30949,1 +31833,1 @@\n-  c = pMem->flags;\n+  c = MEM_Str|MEM_Term|(pMem->flags&(MEM_AffMask|MEM_Subtype));\n@@ -30951,1 +31835,1 @@\n-  pMem->flags = MEM_Str|MEM_Term|(c&(MEM_AffMask|MEM_Subtype));\n+  pMem->flags = c;\n@@ -31166,10 +32050,0 @@\n-\/*\n-** Routine needed to support the testcase() macro.\n-*\/\n-#ifdef SQLITE_COVERAGE_TEST\n-SQLITE_PRIVATE void sqlite3Coverage(int x){\n-  static unsigned dummy = 0;\n-  dummy += (unsigned)x;\n-}\n-#endif\n-\n@@ -31205,0 +32079,3 @@\n+**\n+** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.\n+** Otherwise, we have our own implementation that works on most systems.\n@@ -31207,0 +32084,2 @@\n+  int rc;   \/* The value return *\/\n+#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN\n@@ -31209,1 +32088,6 @@\n-  return IsNaN(y);\n+  rc = IsNaN(y);\n+#else\n+  rc = isnan(x);\n+#endif \/* HAVE_ISNAN *\/\n+  testcase( rc );\n+  return rc;\n@@ -31234,2 +32118,8 @@\n-  if( (pCol->colFlags & COLFLAG_HASTYPE)==0 ) return zDflt;\n-  return pCol->zName + strlen(pCol->zName) + 1;\n+  if( pCol->colFlags & COLFLAG_HASTYPE ){\n+    return pCol->zCnName + strlen(pCol->zCnName) + 1;\n+  }else if( pCol->eCType ){\n+    assert( pCol->eCType<=SQLITE_N_STDTYPE );\n+    return (char*)sqlite3StdType[pCol->eCType-1];\n+  }else{\n+    return zDflt;\n+  }\n@@ -31259,0 +32149,10 @@\n+\/*\n+** The equivalent of sqlite3Error(db, SQLITE_OK).  Clear the error state\n+** and error message.\n+*\/\n+SQLITE_PRIVATE void sqlite3ErrorClear(sqlite3 *db){\n+  assert( db!=0 );\n+  db->errCode = SQLITE_OK;\n+  if( db->pErr ) sqlite3ValueSetNull(db->pErr);\n+}\n+\n@@ -31396,0 +32296,1 @@\n+  assert( !ExprHasProperty(p, EP_IntValue) );\n@@ -31401,0 +32302,22 @@\n+\/*\n+** If the input token p is quoted, try to adjust the token to remove\n+** the quotes.  This is not always possible:\n+**\n+**     \"abc\"     ->   abc\n+**     \"ab\"\"cd\"  ->   (not possible because of the interior \"\")\n+**\n+** Remove the quotes if possible.  This is a optimization.  The overall\n+** system should still return the correct answer even if this routine\n+** is always a no-op.\n+*\/\n+SQLITE_PRIVATE void sqlite3DequoteToken(Token *p){\n+  unsigned int i;\n+  if( p->n<2 ) return;\n+  if( !sqlite3Isquote(p->z[0]) ) return;\n+  for(i=1; i<p->n-1; i++){\n+    if( sqlite3Isquote(p->z[i]) ) return;\n+  }\n+  p->n -= 2;\n+  p->z++;\n+}\n+\n@@ -31740,0 +32663,24 @@\n+\/*\n+** Render an signed 64-bit integer as text.  Store the result in zOut[].\n+**\n+** The caller must ensure that zOut[] is at least 21 bytes in size.\n+*\/\n+SQLITE_PRIVATE void sqlite3Int64ToText(i64 v, char *zOut){\n+  int i;\n+  u64 x;\n+  char zTemp[22];\n+  if( v<0 ){\n+    x = (v==SMALLEST_INT64) ? ((u64)1)<<63 : (u64)-v;\n+  }else{\n+    x = v;\n+  }\n+  i = sizeof(zTemp)-2;\n+  zTemp[sizeof(zTemp)-1] = 0;\n+  do{\n+    zTemp[i--] = (x%10) + '0';\n+    x = x\/10;\n+  }while( x );\n+  if( v<0 ) zTemp[i--] = '-';\n+  memcpy(zOut, &zTemp[i+1], sizeof(zTemp)-1-i);\n+}\n+\n@@ -31802,0 +32749,1 @@\n+    length &= ~1;\n@@ -31980,1 +32928,1 @@\n-  if( z ) sqlite3GetInt32(z, &x);\n+  sqlite3GetInt32(z, &x);\n@@ -31984,0 +32932,18 @@\n+\/*\n+** Try to convert z into an unsigned 32-bit integer.  Return true on\n+** success and false if there is an error.\n+**\n+** Only decimal notation is accepted.\n+*\/\n+SQLITE_PRIVATE int sqlite3GetUInt32(const char *z, u32 *pI){\n+  u64 v = 0;\n+  int i;\n+  for(i=0; sqlite3Isdigit(z[i]); i++){\n+    v = v*10 + z[i] - '0';\n+    if( v>4294967296LL ){ *pI = 0; return 0; }\n+  }\n+  if( i==0 || z[i]!=0 ){ *pI = 0; return 0; }\n+  *pI = (u32)v;\n+  return 1;\n+}\n+\n@@ -32286,2 +33252,1 @@\n-    p -= 2;\n-    n = sqlite3GetVarint(p, &v64);\n+    n = sqlite3GetVarint(p-2, &v64);\n@@ -32464,1 +33429,1 @@\n-  u32 magic;\n+  u8 eOpenState;\n@@ -32469,2 +33434,2 @@\n-  magic = db->magic;\n-  if( magic!=SQLITE_MAGIC_OPEN ){\n+  eOpenState = db->eOpenState;\n+  if( eOpenState!=SQLITE_STATE_OPEN ){\n@@ -32481,5 +33446,5 @@\n-  u32 magic;\n-  magic = db->magic;\n-  if( magic!=SQLITE_MAGIC_SICK &&\n-      magic!=SQLITE_MAGIC_OPEN &&\n-      magic!=SQLITE_MAGIC_BUSY ){\n+  u8 eOpenState;\n+  eOpenState = db->eOpenState;\n+  if( eOpenState!=SQLITE_STATE_SICK &&\n+      eOpenState!=SQLITE_STATE_OPEN &&\n+      eOpenState!=SQLITE_STATE_BUSY ){\n@@ -33104,22 +34069,22 @@\n-    \/*  21 *\/ \"IfNullRow\"        OpHelp(\"if P1.nullRow then r[P3]=NULL, goto P2\"),\n-    \/*  22 *\/ \"SeekLT\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  23 *\/ \"SeekLE\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  24 *\/ \"SeekGE\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  25 *\/ \"SeekGT\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  26 *\/ \"IfNotOpen\"        OpHelp(\"if( !csr[P1] ) goto P2\"),\n-    \/*  27 *\/ \"IfNoHope\"         OpHelp(\"key=r[P3@P4]\"),\n-    \/*  28 *\/ \"NoConflict\"       OpHelp(\"key=r[P3@P4]\"),\n-    \/*  29 *\/ \"NotFound\"         OpHelp(\"key=r[P3@P4]\"),\n-    \/*  30 *\/ \"Found\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  31 *\/ \"SeekRowid\"        OpHelp(\"intkey=r[P3]\"),\n-    \/*  32 *\/ \"NotExists\"        OpHelp(\"intkey=r[P3]\"),\n-    \/*  33 *\/ \"Last\"             OpHelp(\"\"),\n-    \/*  34 *\/ \"IfSmaller\"        OpHelp(\"\"),\n-    \/*  35 *\/ \"SorterSort\"       OpHelp(\"\"),\n-    \/*  36 *\/ \"Sort\"             OpHelp(\"\"),\n-    \/*  37 *\/ \"Rewind\"           OpHelp(\"\"),\n-    \/*  38 *\/ \"IdxLE\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  39 *\/ \"IdxGT\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  40 *\/ \"IdxLT\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  41 *\/ \"IdxGE\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  42 *\/ \"RowSetRead\"       OpHelp(\"r[P3]=rowset(P1)\"),\n+    \/*  21 *\/ \"IsNullOrType\"     OpHelp(\"if typeof(r[P1]) IN (P3,5) goto P2\"),\n+    \/*  22 *\/ \"IfNullRow\"        OpHelp(\"if P1.nullRow then r[P3]=NULL, goto P2\"),\n+    \/*  23 *\/ \"SeekLT\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  24 *\/ \"SeekLE\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  25 *\/ \"SeekGE\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  26 *\/ \"SeekGT\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  27 *\/ \"IfNotOpen\"        OpHelp(\"if( !csr[P1] ) goto P2\"),\n+    \/*  28 *\/ \"IfNoHope\"         OpHelp(\"key=r[P3@P4]\"),\n+    \/*  29 *\/ \"NoConflict\"       OpHelp(\"key=r[P3@P4]\"),\n+    \/*  30 *\/ \"NotFound\"         OpHelp(\"key=r[P3@P4]\"),\n+    \/*  31 *\/ \"Found\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  32 *\/ \"SeekRowid\"        OpHelp(\"intkey=r[P3]\"),\n+    \/*  33 *\/ \"NotExists\"        OpHelp(\"intkey=r[P3]\"),\n+    \/*  34 *\/ \"Last\"             OpHelp(\"\"),\n+    \/*  35 *\/ \"IfSmaller\"        OpHelp(\"\"),\n+    \/*  36 *\/ \"SorterSort\"       OpHelp(\"\"),\n+    \/*  37 *\/ \"Sort\"             OpHelp(\"\"),\n+    \/*  38 *\/ \"Rewind\"           OpHelp(\"\"),\n+    \/*  39 *\/ \"IdxLE\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  40 *\/ \"IdxGT\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  41 *\/ \"IdxLT\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  42 *\/ \"IdxGE\"            OpHelp(\"key=r[P3@P4]\"),\n@@ -33128,5 +34093,5 @@\n-    \/*  45 *\/ \"RowSetTest\"       OpHelp(\"if r[P3] in rowset(P1) goto P2\"),\n-    \/*  46 *\/ \"Program\"          OpHelp(\"\"),\n-    \/*  47 *\/ \"FkIfZero\"         OpHelp(\"if fkctr[P1]==0 goto P2\"),\n-    \/*  48 *\/ \"IfPos\"            OpHelp(\"if r[P1]>0 then r[P1]-=P3, goto P2\"),\n-    \/*  49 *\/ \"IfNotZero\"        OpHelp(\"if r[P1]!=0 then r[P1]--, goto P2\"),\n+    \/*  45 *\/ \"RowSetRead\"       OpHelp(\"r[P3]=rowset(P1)\"),\n+    \/*  46 *\/ \"RowSetTest\"       OpHelp(\"if r[P3] in rowset(P1) goto P2\"),\n+    \/*  47 *\/ \"Program\"          OpHelp(\"\"),\n+    \/*  48 *\/ \"FkIfZero\"         OpHelp(\"if fkctr[P1]==0 goto P2\"),\n+    \/*  49 *\/ \"IfPos\"            OpHelp(\"if r[P1]>0 then r[P1]-=P3, goto P2\"),\n@@ -33141,118 +34106,124 @@\n-    \/*  58 *\/ \"ElseNotEq\"        OpHelp(\"\"),\n-    \/*  59 *\/ \"DecrJumpZero\"     OpHelp(\"if (--r[P1])==0 goto P2\"),\n-    \/*  60 *\/ \"IncrVacuum\"       OpHelp(\"\"),\n-    \/*  61 *\/ \"VNext\"            OpHelp(\"\"),\n-    \/*  62 *\/ \"Init\"             OpHelp(\"Start at P2\"),\n-    \/*  63 *\/ \"PureFunc\"         OpHelp(\"r[P3]=func(r[P2@NP])\"),\n-    \/*  64 *\/ \"Function\"         OpHelp(\"r[P3]=func(r[P2@NP])\"),\n-    \/*  65 *\/ \"Return\"           OpHelp(\"\"),\n-    \/*  66 *\/ \"EndCoroutine\"     OpHelp(\"\"),\n-    \/*  67 *\/ \"HaltIfNull\"       OpHelp(\"if r[P3]=null halt\"),\n-    \/*  68 *\/ \"Halt\"             OpHelp(\"\"),\n-    \/*  69 *\/ \"Integer\"          OpHelp(\"r[P2]=P1\"),\n-    \/*  70 *\/ \"Int64\"            OpHelp(\"r[P2]=P4\"),\n-    \/*  71 *\/ \"String\"           OpHelp(\"r[P2]='P4' (len=P1)\"),\n-    \/*  72 *\/ \"Null\"             OpHelp(\"r[P2..P3]=NULL\"),\n-    \/*  73 *\/ \"SoftNull\"         OpHelp(\"r[P1]=NULL\"),\n-    \/*  74 *\/ \"Blob\"             OpHelp(\"r[P2]=P4 (len=P1)\"),\n-    \/*  75 *\/ \"Variable\"         OpHelp(\"r[P2]=parameter(P1,P4)\"),\n-    \/*  76 *\/ \"Move\"             OpHelp(\"r[P2@P3]=r[P1@P3]\"),\n-    \/*  77 *\/ \"Copy\"             OpHelp(\"r[P2@P3+1]=r[P1@P3+1]\"),\n-    \/*  78 *\/ \"SCopy\"            OpHelp(\"r[P2]=r[P1]\"),\n-    \/*  79 *\/ \"IntCopy\"          OpHelp(\"r[P2]=r[P1]\"),\n-    \/*  80 *\/ \"ResultRow\"        OpHelp(\"output=r[P1@P2]\"),\n-    \/*  81 *\/ \"CollSeq\"          OpHelp(\"\"),\n-    \/*  82 *\/ \"AddImm\"           OpHelp(\"r[P1]=r[P1]+P2\"),\n-    \/*  83 *\/ \"RealAffinity\"     OpHelp(\"\"),\n-    \/*  84 *\/ \"Cast\"             OpHelp(\"affinity(r[P1])\"),\n-    \/*  85 *\/ \"Permutation\"      OpHelp(\"\"),\n-    \/*  86 *\/ \"Compare\"          OpHelp(\"r[P1@P3] <-> r[P2@P3]\"),\n-    \/*  87 *\/ \"IsTrue\"           OpHelp(\"r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4\"),\n-    \/*  88 *\/ \"Offset\"           OpHelp(\"r[P3] = sqlite_offset(P1)\"),\n-    \/*  89 *\/ \"Column\"           OpHelp(\"r[P3]=PX\"),\n-    \/*  90 *\/ \"Affinity\"         OpHelp(\"affinity(r[P1@P2])\"),\n-    \/*  91 *\/ \"MakeRecord\"       OpHelp(\"r[P3]=mkrec(r[P1@P2])\"),\n-    \/*  92 *\/ \"Count\"            OpHelp(\"r[P2]=count()\"),\n-    \/*  93 *\/ \"ReadCookie\"       OpHelp(\"\"),\n-    \/*  94 *\/ \"SetCookie\"        OpHelp(\"\"),\n-    \/*  95 *\/ \"ReopenIdx\"        OpHelp(\"root=P2 iDb=P3\"),\n-    \/*  96 *\/ \"OpenRead\"         OpHelp(\"root=P2 iDb=P3\"),\n-    \/*  97 *\/ \"OpenWrite\"        OpHelp(\"root=P2 iDb=P3\"),\n-    \/*  98 *\/ \"OpenDup\"          OpHelp(\"\"),\n-    \/*  99 *\/ \"OpenAutoindex\"    OpHelp(\"nColumn=P2\"),\n-    \/* 100 *\/ \"OpenEphemeral\"    OpHelp(\"nColumn=P2\"),\n-    \/* 101 *\/ \"BitAnd\"           OpHelp(\"r[P3]=r[P1]&r[P2]\"),\n-    \/* 102 *\/ \"BitOr\"            OpHelp(\"r[P3]=r[P1]|r[P2]\"),\n-    \/* 103 *\/ \"ShiftLeft\"        OpHelp(\"r[P3]=r[P2]<<r[P1]\"),\n-    \/* 104 *\/ \"ShiftRight\"       OpHelp(\"r[P3]=r[P2]>>r[P1]\"),\n-    \/* 105 *\/ \"Add\"              OpHelp(\"r[P3]=r[P1]+r[P2]\"),\n-    \/* 106 *\/ \"Subtract\"         OpHelp(\"r[P3]=r[P2]-r[P1]\"),\n-    \/* 107 *\/ \"Multiply\"         OpHelp(\"r[P3]=r[P1]*r[P2]\"),\n-    \/* 108 *\/ \"Divide\"           OpHelp(\"r[P3]=r[P2]\/r[P1]\"),\n-    \/* 109 *\/ \"Remainder\"        OpHelp(\"r[P3]=r[P2]%r[P1]\"),\n-    \/* 110 *\/ \"Concat\"           OpHelp(\"r[P3]=r[P2]+r[P1]\"),\n-    \/* 111 *\/ \"SorterOpen\"       OpHelp(\"\"),\n-    \/* 112 *\/ \"BitNot\"           OpHelp(\"r[P2]= ~r[P1]\"),\n-    \/* 113 *\/ \"SequenceTest\"     OpHelp(\"if( cursor[P1].ctr++ ) pc = P2\"),\n-    \/* 114 *\/ \"OpenPseudo\"       OpHelp(\"P3 columns in r[P2]\"),\n-    \/* 115 *\/ \"String8\"          OpHelp(\"r[P2]='P4'\"),\n-    \/* 116 *\/ \"Close\"            OpHelp(\"\"),\n-    \/* 117 *\/ \"ColumnsUsed\"      OpHelp(\"\"),\n-    \/* 118 *\/ \"SeekHit\"          OpHelp(\"seekHit=P2\"),\n-    \/* 119 *\/ \"Sequence\"         OpHelp(\"r[P2]=cursor[P1].ctr++\"),\n-    \/* 120 *\/ \"NewRowid\"         OpHelp(\"r[P2]=rowid\"),\n-    \/* 121 *\/ \"Insert\"           OpHelp(\"intkey=r[P3] data=r[P2]\"),\n-    \/* 122 *\/ \"Delete\"           OpHelp(\"\"),\n-    \/* 123 *\/ \"ResetCount\"       OpHelp(\"\"),\n-    \/* 124 *\/ \"SorterCompare\"    OpHelp(\"if key(P1)!=trim(r[P3],P4) goto P2\"),\n-    \/* 125 *\/ \"SorterData\"       OpHelp(\"r[P2]=data\"),\n-    \/* 126 *\/ \"RowData\"          OpHelp(\"r[P2]=data\"),\n-    \/* 127 *\/ \"Rowid\"            OpHelp(\"r[P2]=rowid\"),\n-    \/* 128 *\/ \"NullRow\"          OpHelp(\"\"),\n-    \/* 129 *\/ \"SeekEnd\"          OpHelp(\"\"),\n-    \/* 130 *\/ \"IdxInsert\"        OpHelp(\"key=r[P2]\"),\n-    \/* 131 *\/ \"SorterInsert\"     OpHelp(\"key=r[P2]\"),\n-    \/* 132 *\/ \"IdxDelete\"        OpHelp(\"key=r[P2@P3]\"),\n-    \/* 133 *\/ \"DeferredSeek\"     OpHelp(\"Move P3 to P1.rowid if needed\"),\n-    \/* 134 *\/ \"IdxRowid\"         OpHelp(\"r[P2]=rowid\"),\n-    \/* 135 *\/ \"FinishSeek\"       OpHelp(\"\"),\n-    \/* 136 *\/ \"Destroy\"          OpHelp(\"\"),\n-    \/* 137 *\/ \"Clear\"            OpHelp(\"\"),\n-    \/* 138 *\/ \"ResetSorter\"      OpHelp(\"\"),\n-    \/* 139 *\/ \"CreateBtree\"      OpHelp(\"r[P2]=root iDb=P1 flags=P3\"),\n-    \/* 140 *\/ \"SqlExec\"          OpHelp(\"\"),\n-    \/* 141 *\/ \"ParseSchema\"      OpHelp(\"\"),\n-    \/* 142 *\/ \"LoadAnalysis\"     OpHelp(\"\"),\n-    \/* 143 *\/ \"DropTable\"        OpHelp(\"\"),\n-    \/* 144 *\/ \"DropIndex\"        OpHelp(\"\"),\n-    \/* 145 *\/ \"DropTrigger\"      OpHelp(\"\"),\n-    \/* 146 *\/ \"IntegrityCk\"      OpHelp(\"\"),\n-    \/* 147 *\/ \"RowSetAdd\"        OpHelp(\"rowset(P1)=r[P2]\"),\n-    \/* 148 *\/ \"Param\"            OpHelp(\"\"),\n-    \/* 149 *\/ \"FkCounter\"        OpHelp(\"fkctr[P1]+=P2\"),\n-    \/* 150 *\/ \"Real\"             OpHelp(\"r[P2]=P4\"),\n-    \/* 151 *\/ \"MemMax\"           OpHelp(\"r[P1]=max(r[P1],r[P2])\"),\n-    \/* 152 *\/ \"OffsetLimit\"      OpHelp(\"if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)\"),\n-    \/* 153 *\/ \"AggInverse\"       OpHelp(\"accum=r[P3] inverse(r[P2@P5])\"),\n-    \/* 154 *\/ \"AggStep\"          OpHelp(\"accum=r[P3] step(r[P2@P5])\"),\n-    \/* 155 *\/ \"AggStep1\"         OpHelp(\"accum=r[P3] step(r[P2@P5])\"),\n-    \/* 156 *\/ \"AggValue\"         OpHelp(\"r[P3]=value N=P2\"),\n-    \/* 157 *\/ \"AggFinal\"         OpHelp(\"accum=r[P1] N=P2\"),\n-    \/* 158 *\/ \"Expire\"           OpHelp(\"\"),\n-    \/* 159 *\/ \"CursorLock\"       OpHelp(\"\"),\n-    \/* 160 *\/ \"CursorUnlock\"     OpHelp(\"\"),\n-    \/* 161 *\/ \"TableLock\"        OpHelp(\"iDb=P1 root=P2 write=P3\"),\n-    \/* 162 *\/ \"VBegin\"           OpHelp(\"\"),\n-    \/* 163 *\/ \"VCreate\"          OpHelp(\"\"),\n-    \/* 164 *\/ \"VDestroy\"         OpHelp(\"\"),\n-    \/* 165 *\/ \"VOpen\"            OpHelp(\"\"),\n-    \/* 166 *\/ \"VColumn\"          OpHelp(\"r[P3]=vcolumn(P2)\"),\n-    \/* 167 *\/ \"VRename\"          OpHelp(\"\"),\n-    \/* 168 *\/ \"Pagecount\"        OpHelp(\"\"),\n-    \/* 169 *\/ \"MaxPgcnt\"         OpHelp(\"\"),\n-    \/* 170 *\/ \"Trace\"            OpHelp(\"\"),\n-    \/* 171 *\/ \"CursorHint\"       OpHelp(\"\"),\n-    \/* 172 *\/ \"ReleaseReg\"       OpHelp(\"release r[P1@P2] mask P3\"),\n-    \/* 173 *\/ \"Noop\"             OpHelp(\"\"),\n-    \/* 174 *\/ \"Explain\"          OpHelp(\"\"),\n-    \/* 175 *\/ \"Abortable\"        OpHelp(\"\"),\n+    \/*  58 *\/ \"ElseEq\"           OpHelp(\"\"),\n+    \/*  59 *\/ \"IfNotZero\"        OpHelp(\"if r[P1]!=0 then r[P1]--, goto P2\"),\n+    \/*  60 *\/ \"DecrJumpZero\"     OpHelp(\"if (--r[P1])==0 goto P2\"),\n+    \/*  61 *\/ \"IncrVacuum\"       OpHelp(\"\"),\n+    \/*  62 *\/ \"VNext\"            OpHelp(\"\"),\n+    \/*  63 *\/ \"Init\"             OpHelp(\"Start at P2\"),\n+    \/*  64 *\/ \"PureFunc\"         OpHelp(\"r[P3]=func(r[P2@NP])\"),\n+    \/*  65 *\/ \"Function\"         OpHelp(\"r[P3]=func(r[P2@NP])\"),\n+    \/*  66 *\/ \"Return\"           OpHelp(\"\"),\n+    \/*  67 *\/ \"EndCoroutine\"     OpHelp(\"\"),\n+    \/*  68 *\/ \"HaltIfNull\"       OpHelp(\"if r[P3]=null halt\"),\n+    \/*  69 *\/ \"Halt\"             OpHelp(\"\"),\n+    \/*  70 *\/ \"Integer\"          OpHelp(\"r[P2]=P1\"),\n+    \/*  71 *\/ \"Int64\"            OpHelp(\"r[P2]=P4\"),\n+    \/*  72 *\/ \"String\"           OpHelp(\"r[P2]='P4' (len=P1)\"),\n+    \/*  73 *\/ \"Null\"             OpHelp(\"r[P2..P3]=NULL\"),\n+    \/*  74 *\/ \"SoftNull\"         OpHelp(\"r[P1]=NULL\"),\n+    \/*  75 *\/ \"Blob\"             OpHelp(\"r[P2]=P4 (len=P1)\"),\n+    \/*  76 *\/ \"Variable\"         OpHelp(\"r[P2]=parameter(P1,P4)\"),\n+    \/*  77 *\/ \"Move\"             OpHelp(\"r[P2@P3]=r[P1@P3]\"),\n+    \/*  78 *\/ \"Copy\"             OpHelp(\"r[P2@P3+1]=r[P1@P3+1]\"),\n+    \/*  79 *\/ \"SCopy\"            OpHelp(\"r[P2]=r[P1]\"),\n+    \/*  80 *\/ \"IntCopy\"          OpHelp(\"r[P2]=r[P1]\"),\n+    \/*  81 *\/ \"ChngCntRow\"       OpHelp(\"output=r[P1]\"),\n+    \/*  82 *\/ \"ResultRow\"        OpHelp(\"output=r[P1@P2]\"),\n+    \/*  83 *\/ \"CollSeq\"          OpHelp(\"\"),\n+    \/*  84 *\/ \"AddImm\"           OpHelp(\"r[P1]=r[P1]+P2\"),\n+    \/*  85 *\/ \"RealAffinity\"     OpHelp(\"\"),\n+    \/*  86 *\/ \"Cast\"             OpHelp(\"affinity(r[P1])\"),\n+    \/*  87 *\/ \"Permutation\"      OpHelp(\"\"),\n+    \/*  88 *\/ \"Compare\"          OpHelp(\"r[P1@P3] <-> r[P2@P3]\"),\n+    \/*  89 *\/ \"IsTrue\"           OpHelp(\"r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4\"),\n+    \/*  90 *\/ \"ZeroOrNull\"       OpHelp(\"r[P2] = 0 OR NULL\"),\n+    \/*  91 *\/ \"Offset\"           OpHelp(\"r[P3] = sqlite_offset(P1)\"),\n+    \/*  92 *\/ \"Column\"           OpHelp(\"r[P3]=PX\"),\n+    \/*  93 *\/ \"TypeCheck\"        OpHelp(\"typecheck(r[P1@P2])\"),\n+    \/*  94 *\/ \"Affinity\"         OpHelp(\"affinity(r[P1@P2])\"),\n+    \/*  95 *\/ \"MakeRecord\"       OpHelp(\"r[P3]=mkrec(r[P1@P2])\"),\n+    \/*  96 *\/ \"Count\"            OpHelp(\"r[P2]=count()\"),\n+    \/*  97 *\/ \"ReadCookie\"       OpHelp(\"\"),\n+    \/*  98 *\/ \"SetCookie\"        OpHelp(\"\"),\n+    \/*  99 *\/ \"ReopenIdx\"        OpHelp(\"root=P2 iDb=P3\"),\n+    \/* 100 *\/ \"OpenRead\"         OpHelp(\"root=P2 iDb=P3\"),\n+    \/* 101 *\/ \"OpenWrite\"        OpHelp(\"root=P2 iDb=P3\"),\n+    \/* 102 *\/ \"BitAnd\"           OpHelp(\"r[P3]=r[P1]&r[P2]\"),\n+    \/* 103 *\/ \"BitOr\"            OpHelp(\"r[P3]=r[P1]|r[P2]\"),\n+    \/* 104 *\/ \"ShiftLeft\"        OpHelp(\"r[P3]=r[P2]<<r[P1]\"),\n+    \/* 105 *\/ \"ShiftRight\"       OpHelp(\"r[P3]=r[P2]>>r[P1]\"),\n+    \/* 106 *\/ \"Add\"              OpHelp(\"r[P3]=r[P1]+r[P2]\"),\n+    \/* 107 *\/ \"Subtract\"         OpHelp(\"r[P3]=r[P2]-r[P1]\"),\n+    \/* 108 *\/ \"Multiply\"         OpHelp(\"r[P3]=r[P1]*r[P2]\"),\n+    \/* 109 *\/ \"Divide\"           OpHelp(\"r[P3]=r[P2]\/r[P1]\"),\n+    \/* 110 *\/ \"Remainder\"        OpHelp(\"r[P3]=r[P2]%r[P1]\"),\n+    \/* 111 *\/ \"Concat\"           OpHelp(\"r[P3]=r[P2]+r[P1]\"),\n+    \/* 112 *\/ \"OpenDup\"          OpHelp(\"\"),\n+    \/* 113 *\/ \"BitNot\"           OpHelp(\"r[P2]= ~r[P1]\"),\n+    \/* 114 *\/ \"OpenAutoindex\"    OpHelp(\"nColumn=P2\"),\n+    \/* 115 *\/ \"OpenEphemeral\"    OpHelp(\"nColumn=P2\"),\n+    \/* 116 *\/ \"String8\"          OpHelp(\"r[P2]='P4'\"),\n+    \/* 117 *\/ \"SorterOpen\"       OpHelp(\"\"),\n+    \/* 118 *\/ \"SequenceTest\"     OpHelp(\"if( cursor[P1].ctr++ ) pc = P2\"),\n+    \/* 119 *\/ \"OpenPseudo\"       OpHelp(\"P3 columns in r[P2]\"),\n+    \/* 120 *\/ \"Close\"            OpHelp(\"\"),\n+    \/* 121 *\/ \"ColumnsUsed\"      OpHelp(\"\"),\n+    \/* 122 *\/ \"SeekScan\"         OpHelp(\"Scan-ahead up to P1 rows\"),\n+    \/* 123 *\/ \"SeekHit\"          OpHelp(\"set P2<=seekHit<=P3\"),\n+    \/* 124 *\/ \"Sequence\"         OpHelp(\"r[P2]=cursor[P1].ctr++\"),\n+    \/* 125 *\/ \"NewRowid\"         OpHelp(\"r[P2]=rowid\"),\n+    \/* 126 *\/ \"Insert\"           OpHelp(\"intkey=r[P3] data=r[P2]\"),\n+    \/* 127 *\/ \"RowCell\"          OpHelp(\"\"),\n+    \/* 128 *\/ \"Delete\"           OpHelp(\"\"),\n+    \/* 129 *\/ \"ResetCount\"       OpHelp(\"\"),\n+    \/* 130 *\/ \"SorterCompare\"    OpHelp(\"if key(P1)!=trim(r[P3],P4) goto P2\"),\n+    \/* 131 *\/ \"SorterData\"       OpHelp(\"r[P2]=data\"),\n+    \/* 132 *\/ \"RowData\"          OpHelp(\"r[P2]=data\"),\n+    \/* 133 *\/ \"Rowid\"            OpHelp(\"r[P2]=rowid\"),\n+    \/* 134 *\/ \"NullRow\"          OpHelp(\"\"),\n+    \/* 135 *\/ \"SeekEnd\"          OpHelp(\"\"),\n+    \/* 136 *\/ \"IdxInsert\"        OpHelp(\"key=r[P2]\"),\n+    \/* 137 *\/ \"SorterInsert\"     OpHelp(\"key=r[P2]\"),\n+    \/* 138 *\/ \"IdxDelete\"        OpHelp(\"key=r[P2@P3]\"),\n+    \/* 139 *\/ \"DeferredSeek\"     OpHelp(\"Move P3 to P1.rowid if needed\"),\n+    \/* 140 *\/ \"IdxRowid\"         OpHelp(\"r[P2]=rowid\"),\n+    \/* 141 *\/ \"FinishSeek\"       OpHelp(\"\"),\n+    \/* 142 *\/ \"Destroy\"          OpHelp(\"\"),\n+    \/* 143 *\/ \"Clear\"            OpHelp(\"\"),\n+    \/* 144 *\/ \"ResetSorter\"      OpHelp(\"\"),\n+    \/* 145 *\/ \"CreateBtree\"      OpHelp(\"r[P2]=root iDb=P1 flags=P3\"),\n+    \/* 146 *\/ \"SqlExec\"          OpHelp(\"\"),\n+    \/* 147 *\/ \"ParseSchema\"      OpHelp(\"\"),\n+    \/* 148 *\/ \"LoadAnalysis\"     OpHelp(\"\"),\n+    \/* 149 *\/ \"DropTable\"        OpHelp(\"\"),\n+    \/* 150 *\/ \"DropIndex\"        OpHelp(\"\"),\n+    \/* 151 *\/ \"DropTrigger\"      OpHelp(\"\"),\n+    \/* 152 *\/ \"Real\"             OpHelp(\"r[P2]=P4\"),\n+    \/* 153 *\/ \"IntegrityCk\"      OpHelp(\"\"),\n+    \/* 154 *\/ \"RowSetAdd\"        OpHelp(\"rowset(P1)=r[P2]\"),\n+    \/* 155 *\/ \"Param\"            OpHelp(\"\"),\n+    \/* 156 *\/ \"FkCounter\"        OpHelp(\"fkctr[P1]+=P2\"),\n+    \/* 157 *\/ \"MemMax\"           OpHelp(\"r[P1]=max(r[P1],r[P2])\"),\n+    \/* 158 *\/ \"OffsetLimit\"      OpHelp(\"if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)\"),\n+    \/* 159 *\/ \"AggInverse\"       OpHelp(\"accum=r[P3] inverse(r[P2@P5])\"),\n+    \/* 160 *\/ \"AggStep\"          OpHelp(\"accum=r[P3] step(r[P2@P5])\"),\n+    \/* 161 *\/ \"AggStep1\"         OpHelp(\"accum=r[P3] step(r[P2@P5])\"),\n+    \/* 162 *\/ \"AggValue\"         OpHelp(\"r[P3]=value N=P2\"),\n+    \/* 163 *\/ \"AggFinal\"         OpHelp(\"accum=r[P1] N=P2\"),\n+    \/* 164 *\/ \"Expire\"           OpHelp(\"\"),\n+    \/* 165 *\/ \"CursorLock\"       OpHelp(\"\"),\n+    \/* 166 *\/ \"CursorUnlock\"     OpHelp(\"\"),\n+    \/* 167 *\/ \"TableLock\"        OpHelp(\"iDb=P1 root=P2 write=P3\"),\n+    \/* 168 *\/ \"VBegin\"           OpHelp(\"\"),\n+    \/* 169 *\/ \"VCreate\"          OpHelp(\"\"),\n+    \/* 170 *\/ \"VDestroy\"         OpHelp(\"\"),\n+    \/* 171 *\/ \"VOpen\"            OpHelp(\"\"),\n+    \/* 172 *\/ \"VColumn\"          OpHelp(\"r[P3]=vcolumn(P2)\"),\n+    \/* 173 *\/ \"VRename\"          OpHelp(\"\"),\n+    \/* 174 *\/ \"Pagecount\"        OpHelp(\"\"),\n+    \/* 175 *\/ \"MaxPgcnt\"         OpHelp(\"\"),\n+    \/* 176 *\/ \"Trace\"            OpHelp(\"\"),\n+    \/* 177 *\/ \"CursorHint\"       OpHelp(\"\"),\n+    \/* 178 *\/ \"ReleaseReg\"       OpHelp(\"release r[P1@P2] mask P3\"),\n+    \/* 179 *\/ \"Noop\"             OpHelp(\"\"),\n+    \/* 180 *\/ \"Explain\"          OpHelp(\"\"),\n+    \/* 181 *\/ \"Abortable\"        OpHelp(\"\"),\n@@ -33390,1 +34361,2 @@\n-         && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))\n+        && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))\\\n+        && (!defined(TARGET_OS_MACCATALYST) || (TARGET_OS_MACCATALYST==0))\n@@ -33564,199 +34536,1 @@\n-\/************** Include os_common.h in the middle of os_unix.c ***************\/\n-\/************** Begin file os_common.h ***************************************\/\n-\/*\n-** 2004 May 22\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains macros and a little bit of code that is common to\n-** all of the platform-specific files (os_*.c) and is #included into those\n-** files.\n-**\n-** This file should be #included by the os_*.c files only.  It is not a\n-** general purpose header file.\n-*\/\n-#ifndef _OS_COMMON_H_\n-#define _OS_COMMON_H_\n-\n-\/*\n-** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n-** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n-** switch.  The following code should catch this problem at compile-time.\n-*\/\n-#ifdef MEMORY_DEBUG\n-# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n-#endif\n-\n-\/*\n-** Macros for performance tracing.  Normally turned off.  Only works\n-** on i486 hardware.\n-*\/\n-#ifdef SQLITE_PERFORMANCE_TRACE\n-\n-\/*\n-** hwtime.h contains inline assembler code for implementing\n-** high-performance timing routines.\n-*\/\n-\/************** Include hwtime.h in the middle of os_common.h ****************\/\n-\/************** Begin file hwtime.h ******************************************\/\n-\/*\n-** 2008 May 27\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains inline asm code for retrieving \"high-performance\"\n-** counters for x86 and x86_64 class CPUs.\n-*\/\n-#ifndef SQLITE_HWTIME_H\n-#define SQLITE_HWTIME_H\n-\n-\/*\n-** The following routine only works on pentium-class (or newer) processors.\n-** It uses the RDTSC opcode to read the cycle count value out of the\n-** processor and returns that value.  This can be used for high-res\n-** profiling.\n-*\/\n-#if !defined(__STRICT_ANSI__) && \\\n-    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n-    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n-\n-  #if defined(__GNUC__)\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-     unsigned int lo, hi;\n-     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n-     return (sqlite_uint64)hi << 32 | lo;\n-  }\n-\n-  #elif defined(_MSC_VER)\n-\n-  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n-     __asm {\n-        rdtsc\n-        ret       ; return value at EDX:EAX\n-     }\n-  }\n-\n-  #endif\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long val;\n-      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n-      return val;\n-  }\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long long retval;\n-      unsigned long junk;\n-      __asm__ __volatile__ (\"\\n\\\n-          1:      mftbu   %1\\n\\\n-                  mftb    %L0\\n\\\n-                  mftbu   %0\\n\\\n-                  cmpw    %0,%1\\n\\\n-                  bne     1b\"\n-                  : \"=r\" (retval), \"=r\" (junk));\n-      return retval;\n-  }\n-\n-#else\n-\n-  \/*\n-  ** asm() is needed for hardware timing support.  Without asm(),\n-  ** disable the sqlite3Hwtime() routine.\n-  **\n-  ** sqlite3Hwtime() is only used for some obscure debugging\n-  ** and analysis configurations, not in any deliverable, so this\n-  ** should not be a great loss.\n-  *\/\n-SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n-\n-#endif\n-\n-#endif \/* !defined(SQLITE_HWTIME_H) *\/\n-\n-\/************** End of hwtime.h **********************************************\/\n-\/************** Continuing where we left off in os_common.h ******************\/\n-\n-static sqlite_uint64 g_start;\n-static sqlite_uint64 g_elapsed;\n-#define TIMER_START       g_start=sqlite3Hwtime()\n-#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n-#define TIMER_ELAPSED     g_elapsed\n-#else\n-#define TIMER_START\n-#define TIMER_END\n-#define TIMER_ELAPSED     ((sqlite_uint64)0)\n-#endif\n-\n-\/*\n-** If we compile with the SQLITE_TEST macro set, then the following block\n-** of code will give us the ability to simulate a disk I\/O error.  This\n-** is used for testing the I\/O recovery logic.\n-*\/\n-#if defined(SQLITE_TEST)\n-SQLITE_API extern int sqlite3_io_error_hit;\n-SQLITE_API extern int sqlite3_io_error_hardhit;\n-SQLITE_API extern int sqlite3_io_error_pending;\n-SQLITE_API extern int sqlite3_io_error_persist;\n-SQLITE_API extern int sqlite3_io_error_benign;\n-SQLITE_API extern int sqlite3_diskfull_pending;\n-SQLITE_API extern int sqlite3_diskfull;\n-#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n-#define SimulateIOError(CODE)  \\\n-  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n-       || sqlite3_io_error_pending-- == 1 )  \\\n-              { local_ioerr(); CODE; }\n-static void local_ioerr(){\n-  IOTRACE((\"IOERR\\n\"));\n-  sqlite3_io_error_hit++;\n-  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n-}\n-#define SimulateDiskfullError(CODE) \\\n-   if( sqlite3_diskfull_pending ){ \\\n-     if( sqlite3_diskfull_pending == 1 ){ \\\n-       local_ioerr(); \\\n-       sqlite3_diskfull = 1; \\\n-       sqlite3_io_error_hit = 1; \\\n-       CODE; \\\n-     }else{ \\\n-       sqlite3_diskfull_pending--; \\\n-     } \\\n-   }\n-#else\n-#define SimulateIOErrorBenign(X)\n-#define SimulateIOError(A)\n-#define SimulateDiskfullError(A)\n-#endif \/* defined(SQLITE_TEST) *\/\n-\n-\/*\n-** When testing, keep a count of the number of open files.\n-*\/\n-#if defined(SQLITE_TEST)\n-SQLITE_API extern int sqlite3_open_file_count;\n-#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n-#else\n-#define OpenCounter(X)\n-#endif \/* defined(SQLITE_TEST) *\/\n-\n-#endif \/* !defined(_OS_COMMON_H_) *\/\n-\n-\/************** End of os_common.h *******************************************\/\n-\/************** Continuing where we left off in os_unix.c ********************\/\n+\/* #include \"os_common.h\" *\/\n@@ -35010,0 +35784,3 @@\n+\/* Forward declaration*\/\n+static int unixSleep(sqlite3_vfs*,int);\n+\n@@ -35039,1 +35816,1 @@\n-    usleep(1000);\n+    unixSleep(0,1000);\n@@ -35610,0 +36387,1 @@\n+  assert( pFile->pShm==0 );\n@@ -36806,1 +37584,1 @@\n-  \/* If this is a database file (not a journal, master-journal or temp\n+  \/* If this is a database file (not a journal, super-journal or temp\n@@ -36836,1 +37614,18 @@\n-    \/* lastErrno set by seekAndRead *\/\n+    \/* pFile->lastErrno has been set by seekAndRead().\n+    ** Usually we return SQLITE_IOERR_READ here, though for some\n+    ** kinds of errors we return SQLITE_IOERR_CORRUPTFS.  The\n+    ** SQLITE_IOERR_CORRUPTFS will be converted into SQLITE_CORRUPT\n+    ** prior to returning to the application by the sqlite3ApiExit()\n+    ** routine.\n+    *\/\n+    switch( pFile->lastErrno ){\n+      case ERANGE:\n+      case EIO:\n+#ifdef ENXIO\n+      case ENXIO:\n+#endif\n+#ifdef EDEVERR\n+      case EDEVERR:\n+#endif\n+        return SQLITE_IOERR_CORRUPTFS;\n+    }\n@@ -36919,1 +37714,1 @@\n-  \/* If this is a database file (not a journal, master-journal or temp\n+  \/* If this is a database file (not a journal, super-journal or temp\n@@ -37395,0 +38190,3 @@\n+#ifndef SQLITE_OMIT_WAL\n+ static int unixFcntlExternalReader(unixFile*, int*);\n+#endif\n@@ -37511,0 +38309,9 @@\n+\n+    case SQLITE_FCNTL_EXTERNAL_READER: {\n+#ifndef SQLITE_OMIT_WAL\n+      return unixFcntlExternalReader((unixFile*)id, (int*)pArg);\n+#else\n+      *(int*)pArg = 0;\n+      return SQLITE_OK;\n+#endif\n+    }\n@@ -37720,0 +38527,1 @@\n+  int aLock[SQLITE_SHM_NLOCK];  \/* # shared locks on slot, -1==excl lock *\/\n@@ -37755,0 +38563,34 @@\n+\/*\n+** Use F_GETLK to check whether or not there are any readers with open\n+** wal-mode transactions in other processes on database file pFile. If\n+** no error occurs, return SQLITE_OK and set (*piOut) to 1 if there are\n+** such transactions, or 0 otherwise. If an error occurs, return an\n+** SQLite error code. The final value of *piOut is undefined in this\n+** case.\n+*\/\n+static int unixFcntlExternalReader(unixFile *pFile, int *piOut){\n+  int rc = SQLITE_OK;\n+  *piOut = 0;\n+  if( pFile->pShm){\n+    unixShmNode *pShmNode = pFile->pShm->pShmNode;\n+    struct flock f;\n+\n+    memset(&f, 0, sizeof(f));\n+    f.l_type = F_WRLCK;\n+    f.l_whence = SEEK_SET;\n+    f.l_start = UNIX_SHM_BASE + 3;\n+    f.l_len = SQLITE_SHM_NLOCK - 3;\n+\n+    sqlite3_mutex_enter(pShmNode->pShmMutex);\n+    if( osFcntl(pShmNode->hShm, F_GETLK, &f)<0 ){\n+      rc = SQLITE_IOERR_LOCK;\n+    }else{\n+      *piOut = (f.l_type!=F_UNLCK);\n+    }\n+    sqlite3_mutex_leave(pShmNode->pShmMutex);\n+  }\n+\n+  return rc;\n+}\n+\n+\n@@ -38260,0 +39102,32 @@\n+\/*\n+** Check that the pShmNode->aLock[] array comports with the locking bitmasks\n+** held by each client. Return true if it does, or false otherwise. This\n+** is to be used in an assert(). e.g.\n+**\n+**     assert( assertLockingArrayOk(pShmNode) );\n+*\/\n+#ifdef SQLITE_DEBUG\n+static int assertLockingArrayOk(unixShmNode *pShmNode){\n+  unixShm *pX;\n+  int aLock[SQLITE_SHM_NLOCK];\n+  assert( sqlite3_mutex_held(pShmNode->pShmMutex) );\n+\n+  memset(aLock, 0, sizeof(aLock));\n+  for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n+    int i;\n+    for(i=0; i<SQLITE_SHM_NLOCK; i++){\n+      if( pX->exclMask & (1<<i) ){\n+        assert( aLock[i]==0 );\n+        aLock[i] = -1;\n+      }else if( pX->sharedMask & (1<<i) ){\n+        assert( aLock[i]>=0 );\n+        aLock[i]++;\n+      }\n+    }\n+  }\n+\n+  assert( 0==memcmp(pShmNode->aLock, aLock, sizeof(aLock)) );\n+  return (memcmp(pShmNode->aLock, aLock, sizeof(aLock))==0);\n+}\n+#endif\n+\n@@ -38276,1 +39150,0 @@\n-  unixShm *pX;                          \/* For looping over all siblings *\/\n@@ -38280,0 +39153,1 @@\n+  int *aLock = pShmNode->aLock;\n@@ -38302,1 +39176,4 @@\n-  ** held.  *\/\n+  ** held.\n+  **\n+  ** It is not permitted to block on the RECOVER lock.\n+  *\/\n@@ -38315,0 +39192,1 @@\n+  assert( assertLockingArrayOk(pShmNode) );\n@@ -38316,1 +39194,3 @@\n-    u16 allMask = 0; \/* Mask of locks held by siblings *\/\n+    if( (p->exclMask|p->sharedMask) & mask ){\n+      int ii;\n+      int bUnlock = 1;\n@@ -38318,6 +39198,5 @@\n-    \/* See if any siblings hold this same lock *\/\n-    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n-      if( pX==p ) continue;\n-      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );\n-      allMask |= pX->sharedMask;\n-    }\n+      for(ii=ofst; ii<ofst+n; ii++){\n+        if( aLock[ii]>((p->sharedMask & (1<<ii)) ? 1 : 0) ){\n+          bUnlock = 0;\n+        }\n+      }\n@@ -38325,6 +39204,9 @@\n-    \/* Unlock the system-level locks *\/\n-    if( (mask & allMask)==0 ){\n-      rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);\n-    }else{\n-      rc = SQLITE_OK;\n-    }\n+      if( bUnlock ){\n+        rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);\n+        if( rc==SQLITE_OK ){\n+          memset(&aLock[ofst], 0, sizeof(int)*n);\n+        }\n+      }else if( ALWAYS(p->sharedMask & (1<<ofst)) ){\n+        assert( n==1 && aLock[ofst]>1 );\n+        aLock[ofst]--;\n+      }\n@@ -38332,4 +39214,5 @@\n-    \/* Undo the local locks *\/\n-    if( rc==SQLITE_OK ){\n-      p->exclMask &= ~mask;\n-      p->sharedMask &= ~mask;\n+      \/* Undo the local locks *\/\n+      if( rc==SQLITE_OK ){\n+        p->exclMask &= ~mask;\n+        p->sharedMask &= ~mask;\n+      }\n@@ -38338,8 +39221,4 @@\n-    u16 allShared = 0;  \/* Union of locks held by connections other than \"p\" *\/\n-\n-    \/* Find out which shared locks are already held by sibling connections.\n-    ** If any sibling already holds an exclusive lock, go ahead and return\n-    ** SQLITE_BUSY.\n-    *\/\n-    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n-      if( (pX->exclMask & mask)!=0 ){\n+    assert( n==1 );\n+    assert( (p->exclMask & (1<<ofst))==0 );\n+    if( (p->sharedMask & mask)==0 ){\n+      if( aLock[ofst]<0 ){\n@@ -38347,8 +39226,1 @@\n-        break;\n-      }\n-      allShared |= pX->sharedMask;\n-    }\n-\n-    \/* Get shared locks at the system level, if necessary *\/\n-    if( rc==SQLITE_OK ){\n-      if( (allShared & mask)==0 ){\n+      }else if( aLock[ofst]==0 ){\n@@ -38356,2 +39228,0 @@\n-      }else{\n-        rc = SQLITE_OK;\n@@ -38359,1 +39229,0 @@\n-    }\n@@ -38361,3 +39230,5 @@\n-    \/* Get the local shared locks *\/\n-    if( rc==SQLITE_OK ){\n-      p->sharedMask |= mask;\n+      \/* Get the local shared locks *\/\n+      if( rc==SQLITE_OK ){\n+        p->sharedMask |= mask;\n+        aLock[ofst]++;\n+      }\n@@ -38367,4 +39238,5 @@\n-    ** lock.  If any do, return SQLITE_BUSY right away.\n-    *\/\n-    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n-      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){\n+    ** lock.  If any do, return SQLITE_BUSY right away.  *\/\n+    int ii;\n+    for(ii=ofst; ii<ofst+n; ii++){\n+      assert( (p->sharedMask & mask)==0 );\n+      if( ALWAYS((p->exclMask & (1<<ii))==0) && aLock[ii] ){\n@@ -38376,3 +39248,2 @@\n-    \/* Get the exclusive locks at the system level.  Then if successful\n-    ** also mark the local connection as being locked.\n-    *\/\n+    \/* Get the exclusive locks at the system level. Then if successful\n+    ** also update the in-memory values. *\/\n@@ -38384,0 +39255,3 @@\n+        for(ii=ofst; ii<ofst+n; ii++){\n+          aLock[ii] = -1;\n+        }\n@@ -38387,0 +39261,1 @@\n+  assert( assertLockingArrayOk(pShmNode) );\n@@ -39155,1 +40030,1 @@\n-    pNew->pMethod = pLockingStyle;\n+    pId->pMethods = pLockingStyle;\n@@ -39162,0 +40037,20 @@\n+\/*\n+** Directories to consider for temp files.\n+*\/\n+static const char *azTempDirs[] = {\n+  0,\n+  0,\n+  \"\/var\/tmp\",\n+  \"\/usr\/tmp\",\n+  \"\/tmp\",\n+  \".\"\n+};\n+\n+\/*\n+** Initialize first two members of azTempDirs[] array.\n+*\/\n+static void unixTempFileInit(void){\n+  azTempDirs[0] = getenv(\"SQLITE_TMPDIR\");\n+  azTempDirs[1] = getenv(\"TMPDIR\");\n+}\n+\n@@ -39167,8 +40062,0 @@\n-  static const char *azDirs[] = {\n-     0,\n-     0,\n-     \"\/var\/tmp\",\n-     \"\/usr\/tmp\",\n-     \"\/tmp\",\n-     \".\"\n-  };\n@@ -39179,2 +40066,0 @@\n-  if( !azDirs[0] ) azDirs[0] = getenv(\"SQLITE_TMPDIR\");\n-  if( !azDirs[1] ) azDirs[1] = getenv(\"TMPDIR\");\n@@ -39189,2 +40074,2 @@\n-    if( i>=sizeof(azDirs)\/sizeof(azDirs[0]) ) break;\n-    zDir = azDirs[i++];\n+    if( i>=sizeof(azTempDirs)\/sizeof(azTempDirs[0]) ) break;\n+    zDir = azTempDirs[i++];\n@@ -39236,1 +40121,1 @@\n-** file (not a journal or master-journal file) identified by pathname\n+** file (not a journal or super-journal file) identified by pathname\n@@ -39370,1 +40255,1 @@\n-      ** rollback journal specifies a master journal with a goofy name, then\n+      ** rollback journal specifies a super-journal with a goofy name, then\n@@ -39443,1 +40328,1 @@\n-  \/* If creating a master or main-file journal, this function will open\n+  \/* If creating a super- or main-file journal, this function will open\n@@ -39448,1 +40333,1 @@\n-        eType==SQLITE_OPEN_MASTER_JOURNAL\n+        eType==SQLITE_OPEN_SUPER_JOURNAL\n@@ -39471,1 +40356,1 @@\n-  \/* The main DB, main journal, WAL file and master journal are never\n+  \/* The main DB, main journal, WAL file and super-journal are never\n@@ -39475,1 +40360,1 @@\n-  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );\n+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_SUPER_JOURNAL );\n@@ -39481,1 +40366,1 @@\n-       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNAL\n+       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_SUPER_JOURNAL\n@@ -39496,0 +40381,5 @@\n+#ifdef SQLITE_ASSERT_NO_FILES\n+  \/* Applications that never read or write a persistent disk files *\/\n+  assert( zName==0 );\n+#endif\n+\n@@ -39674,1 +40564,1 @@\n-      || eType==SQLITE_OPEN_MASTER_JOURNAL || eType==SQLITE_OPEN_MAIN_JOURNAL\n+      || eType==SQLITE_OPEN_SUPER_JOURNAL || eType==SQLITE_OPEN_MAIN_JOURNAL\n@@ -39763,0 +40653,18 @@\n+** If the last component of the pathname in z[0]..z[j-1] is something\n+** other than \"..\" then back it out and return true.  If the last\n+** component is empty or if it is \"..\" then return false.\n+*\/\n+static int unixBackupDir(const char *z, int *pJ){\n+  int j = *pJ;\n+  int i;\n+  if( j<=0 ) return 0;\n+  for(i=j-1; i>0 && z[i-1]!='\/'; i--){}\n+  if( i==0 ) return 0;\n+  if( z[i]=='.' && i==j-2 && z[i+1]=='.' ) return 0;\n+  *pJ = i-1;\n+  return 1;\n+}\n+\n+\/*\n+** Convert a relative pathname into a full pathname.  Also\n+** simplify the pathname as follows:\n@@ -39764,0 +40672,2 @@\n+**    Remove all instances of \/.\/\n+**    Remove all isntances of \/X\/..\/ for any X\n@@ -39772,0 +40682,1 @@\n+  int i, j;\n@@ -39786,0 +40697,35 @@\n+\n+  \/* Remove duplicate '\/' characters.  Except, two \/\/ at the beginning\n+  ** of a pathname is allowed since this is important on windows. *\/\n+  for(i=j=1; zOut[i]; i++){\n+    zOut[j++] = zOut[i];\n+    while( zOut[i]=='\/' && zOut[i+1]=='\/' ) i++;\n+  }\n+  zOut[j] = 0;\n+\n+  assert( zOut[0]=='\/' );\n+  for(i=j=0; zOut[i]; i++){\n+    if( zOut[i]=='\/' ){\n+      \/* Skip over internal \"\/.\" directory components *\/\n+      if( zOut[i+1]=='.' && zOut[i+2]=='\/' ){\n+        i += 1;\n+        continue;\n+      }\n+\n+      \/* If this is a \"\/..\" directory component then back out the\n+      ** previous term of the directory if it is something other than \"..\".\n+      *\/\n+      if( zOut[i+1]=='.'\n+       && zOut[i+2]=='.'\n+       && zOut[i+3]=='\/'\n+       && unixBackupDir(zOut, &j)\n+      ){\n+        i += 2;\n+        continue;\n+      }\n+    }\n+    if( ALWAYS(j>=0) ) zOut[j] = zOut[i];\n+    j++;\n+  }\n+  if( NEVER(j==0) ) zOut[j++] = '\/';\n+  zOut[j] = 0;\n@@ -40006,1 +40952,2 @@\n-  usleep(microseconds);\n+  if( microseconds>=1000000 ) sleep(microseconds\/1000000);\n+  if( microseconds%1000000 ) usleep(microseconds%1000000);\n@@ -40579,1 +41526,1 @@\n-        usleep(500000); \/* wait 0.5 sec and try the lock again*\/\n+        unixSleep(0,500000); \/* wait 0.5 sec and try the lock again*\/\n@@ -40605,1 +41552,1 @@\n-        usleep(10000000); \/* wait 10 sec and try the lock again *\/\n+        unixSleep(0,10000000); \/* wait 10 sec and try the lock again *\/\n@@ -41381,0 +42328,22 @@\n+\n+#ifndef SQLITE_OMIT_WAL\n+  \/* Validate lock assumptions *\/\n+  assert( SQLITE_SHM_NLOCK==8 );  \/* Number of available locks *\/\n+  assert( UNIX_SHM_BASE==120  );  \/* Start of locking area *\/\n+  \/* Locks:\n+  **    WRITE       UNIX_SHM_BASE      120\n+  **    CKPT        UNIX_SHM_BASE+1    121\n+  **    RECOVER     UNIX_SHM_BASE+2    122\n+  **    READ-0      UNIX_SHM_BASE+3    123\n+  **    READ-1      UNIX_SHM_BASE+4    124\n+  **    READ-2      UNIX_SHM_BASE+5    125\n+  **    READ-3      UNIX_SHM_BASE+6    126\n+  **    READ-4      UNIX_SHM_BASE+7    127\n+  **    DMS         UNIX_SHM_BASE+8    128\n+  *\/\n+  assert( UNIX_SHM_DMS==128   );  \/* Byte offset of the deadman-switch *\/\n+#endif\n+\n+  \/* Initialize temp file dir array. *\/\n+  unixTempFileInit();\n+\n@@ -41420,199 +42389,1 @@\n-\/************** Include os_common.h in the middle of os_win.c ****************\/\n-\/************** Begin file os_common.h ***************************************\/\n-\/*\n-** 2004 May 22\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains macros and a little bit of code that is common to\n-** all of the platform-specific files (os_*.c) and is #included into those\n-** files.\n-**\n-** This file should be #included by the os_*.c files only.  It is not a\n-** general purpose header file.\n-*\/\n-#ifndef _OS_COMMON_H_\n-#define _OS_COMMON_H_\n-\n-\/*\n-** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n-** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n-** switch.  The following code should catch this problem at compile-time.\n-*\/\n-#ifdef MEMORY_DEBUG\n-# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n-#endif\n-\n-\/*\n-** Macros for performance tracing.  Normally turned off.  Only works\n-** on i486 hardware.\n-*\/\n-#ifdef SQLITE_PERFORMANCE_TRACE\n-\n-\/*\n-** hwtime.h contains inline assembler code for implementing\n-** high-performance timing routines.\n-*\/\n-\/************** Include hwtime.h in the middle of os_common.h ****************\/\n-\/************** Begin file hwtime.h ******************************************\/\n-\/*\n-** 2008 May 27\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains inline asm code for retrieving \"high-performance\"\n-** counters for x86 and x86_64 class CPUs.\n-*\/\n-#ifndef SQLITE_HWTIME_H\n-#define SQLITE_HWTIME_H\n-\n-\/*\n-** The following routine only works on pentium-class (or newer) processors.\n-** It uses the RDTSC opcode to read the cycle count value out of the\n-** processor and returns that value.  This can be used for high-res\n-** profiling.\n-*\/\n-#if !defined(__STRICT_ANSI__) && \\\n-    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n-    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n-\n-  #if defined(__GNUC__)\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-     unsigned int lo, hi;\n-     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n-     return (sqlite_uint64)hi << 32 | lo;\n-  }\n-\n-  #elif defined(_MSC_VER)\n-\n-  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n-     __asm {\n-        rdtsc\n-        ret       ; return value at EDX:EAX\n-     }\n-  }\n-\n-  #endif\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long val;\n-      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n-      return val;\n-  }\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long long retval;\n-      unsigned long junk;\n-      __asm__ __volatile__ (\"\\n\\\n-          1:      mftbu   %1\\n\\\n-                  mftb    %L0\\n\\\n-                  mftbu   %0\\n\\\n-                  cmpw    %0,%1\\n\\\n-                  bne     1b\"\n-                  : \"=r\" (retval), \"=r\" (junk));\n-      return retval;\n-  }\n-\n-#else\n-\n-  \/*\n-  ** asm() is needed for hardware timing support.  Without asm(),\n-  ** disable the sqlite3Hwtime() routine.\n-  **\n-  ** sqlite3Hwtime() is only used for some obscure debugging\n-  ** and analysis configurations, not in any deliverable, so this\n-  ** should not be a great loss.\n-  *\/\n-SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n-\n-#endif\n-\n-#endif \/* !defined(SQLITE_HWTIME_H) *\/\n-\n-\/************** End of hwtime.h **********************************************\/\n-\/************** Continuing where we left off in os_common.h ******************\/\n-\n-static sqlite_uint64 g_start;\n-static sqlite_uint64 g_elapsed;\n-#define TIMER_START       g_start=sqlite3Hwtime()\n-#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n-#define TIMER_ELAPSED     g_elapsed\n-#else\n-#define TIMER_START\n-#define TIMER_END\n-#define TIMER_ELAPSED     ((sqlite_uint64)0)\n-#endif\n-\n-\/*\n-** If we compile with the SQLITE_TEST macro set, then the following block\n-** of code will give us the ability to simulate a disk I\/O error.  This\n-** is used for testing the I\/O recovery logic.\n-*\/\n-#if defined(SQLITE_TEST)\n-SQLITE_API extern int sqlite3_io_error_hit;\n-SQLITE_API extern int sqlite3_io_error_hardhit;\n-SQLITE_API extern int sqlite3_io_error_pending;\n-SQLITE_API extern int sqlite3_io_error_persist;\n-SQLITE_API extern int sqlite3_io_error_benign;\n-SQLITE_API extern int sqlite3_diskfull_pending;\n-SQLITE_API extern int sqlite3_diskfull;\n-#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n-#define SimulateIOError(CODE)  \\\n-  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n-       || sqlite3_io_error_pending-- == 1 )  \\\n-              { local_ioerr(); CODE; }\n-static void local_ioerr(){\n-  IOTRACE((\"IOERR\\n\"));\n-  sqlite3_io_error_hit++;\n-  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n-}\n-#define SimulateDiskfullError(CODE) \\\n-   if( sqlite3_diskfull_pending ){ \\\n-     if( sqlite3_diskfull_pending == 1 ){ \\\n-       local_ioerr(); \\\n-       sqlite3_diskfull = 1; \\\n-       sqlite3_io_error_hit = 1; \\\n-       CODE; \\\n-     }else{ \\\n-       sqlite3_diskfull_pending--; \\\n-     } \\\n-   }\n-#else\n-#define SimulateIOErrorBenign(X)\n-#define SimulateIOError(A)\n-#define SimulateDiskfullError(A)\n-#endif \/* defined(SQLITE_TEST) *\/\n-\n-\/*\n-** When testing, keep a count of the number of open files.\n-*\/\n-#if defined(SQLITE_TEST)\n-SQLITE_API extern int sqlite3_open_file_count;\n-#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n-#else\n-#define OpenCounter(X)\n-#endif \/* defined(SQLITE_TEST) *\/\n-\n-#endif \/* !defined(_OS_COMMON_H_) *\/\n-\n-\/************** End of os_common.h *******************************************\/\n-\/************** Continuing where we left off in os_win.c *********************\/\n+\/* #include \"os_common.h\" *\/\n@@ -42890,1 +43661,1 @@\n-  MUTEX_LOGIC( sqlite3_mutex *pMaster; ) \/* The main static mutex *\/\n+  MUTEX_LOGIC( sqlite3_mutex *pMainMtx; ) \/* The main static mutex *\/\n@@ -42892,1 +43663,1 @@\n-  MUTEX_LOGIC( pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )\n+  MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n@@ -42894,1 +43665,1 @@\n-  sqlite3_mutex_enter(pMaster);\n+  sqlite3_mutex_enter(pMainMtx);\n@@ -42900,1 +43671,1 @@\n-    ** the heap.  Also, since both the master and memsys locks are currently\n+    ** the heap.  Also, since both the main and memsys locks are currently\n@@ -42923,1 +43694,1 @@\n-  sqlite3_mutex_leave(pMaster);\n+  sqlite3_mutex_leave(pMainMtx);\n@@ -46623,1 +47394,1 @@\n-        eType==SQLITE_OPEN_MASTER_JOURNAL\n+        eType==SQLITE_OPEN_SUPER_JOURNAL\n@@ -46644,1 +47415,1 @@\n-  \/* The main DB, main journal, WAL file and master journal are never\n+  \/* The main DB, main journal, WAL file and super-journal are never\n@@ -46648,1 +47419,1 @@\n-  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );\n+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_SUPER_JOURNAL );\n@@ -46654,1 +47425,1 @@\n-       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNAL\n+       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_SUPER_JOURNAL\n@@ -46726,1 +47497,5 @@\n-  dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;\n+  if( 0==sqlite3_uri_boolean(zName, \"exclusive\", 0) ){\n+    dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;\n+  }else{\n+    dwShareMode = 0;\n+  }\n@@ -46866,1 +47641,1 @@\n-  pFile->pMethod = pAppData ? pAppData->pMethod : &winIoMethod;\n+  id->pMethods = pAppData ? pAppData->pMethod : &winIoMethod;\n@@ -47770,1 +48545,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -47777,0 +48552,1 @@\n+typedef struct MemStore MemStore;\n@@ -47783,3 +48559,37 @@\n-\/* An open file *\/\n-struct MemFile {\n-  sqlite3_file base;              \/* IO methods *\/\n+\/* Storage for a memdb file.\n+**\n+** An memdb object can be shared or separate.  Shared memdb objects can be\n+** used by more than one database connection.  Mutexes are used by shared\n+** memdb objects to coordinate access.  Separate memdb objects are only\n+** connected to a single database connection and do not require additional\n+** mutexes.\n+**\n+** Shared memdb objects have .zFName!=0 and .pMutex!=0.  They are created\n+** using \"file:\/name?vfs=memdb\".  The first character of the name must be\n+** \"\/\" or else the object will be a separate memdb object.  All shared\n+** memdb objects are stored in memdb_g.apMemStore[] in an arbitrary order.\n+**\n+** Separate memdb objects are created using a name that does not begin\n+** with \"\/\" or using sqlite3_deserialize().\n+**\n+** Access rules for shared MemStore objects:\n+**\n+**   *  .zFName is initialized when the object is created and afterwards\n+**      is unchanged until the object is destroyed.  So it can be accessed\n+**      at any time as long as we know the object is not being destroyed,\n+**      which means while either the SQLITE_MUTEX_STATIC_VFS1 or\n+**      .pMutex is held or the object is not part of memdb_g.apMemStore[].\n+**\n+**   *  Can .pMutex can only be changed while holding the\n+**      SQLITE_MUTEX_STATIC_VFS1 mutex or while the object is not part\n+**      of memdb_g.apMemStore[].\n+**\n+**   *  Other fields can only be changed while holding the .pMutex mutex\n+**      or when the .nRef is less than zero and the object is not part of\n+**      memdb_g.apMemStore[].\n+**\n+**   *  The .aData pointer has the added requirement that it can can only\n+**      be changed (for resizing) when nMmap is zero.\n+**\n+*\/\n+struct MemStore {\n@@ -47790,0 +48600,1 @@\n+  sqlite3_mutex *pMutex;          \/* Used by shared stores only *\/\n@@ -47792,0 +48603,10 @@\n+  int nRdLock;                    \/* Number of readers *\/\n+  int nWrLock;                    \/* Number of writers.  (Always 0 or 1) *\/\n+  int nRef;                       \/* Number of users of this MemStore *\/\n+  char *zFName;                   \/* The filename for shared stores *\/\n+};\n+\n+\/* An open file *\/\n+struct MemFile {\n+  sqlite3_file base;              \/* IO methods *\/\n+  MemStore *pStore;               \/* The storage *\/\n@@ -47795,0 +48616,11 @@\n+\/*\n+** File-scope variables for holding the memdb files that are accessible\n+** to multiple database connections in separate threads.\n+**\n+** Must hold SQLITE_MUTEX_STATIC_VFS1 to access any part of this object.\n+*\/\n+static struct MemFS {\n+  int nMemStore;                  \/* Number of shared MemStore objects *\/\n+  MemStore **apMemStore;          \/* Array of all shared MemStore objects *\/\n+} memdb_g;\n+\n@@ -47848,1 +48680,4 @@\n-  memdbCurrentTimeInt64        \/* xCurrentTimeInt64 *\/\n+  memdbCurrentTimeInt64,       \/* xCurrentTimeInt64 *\/\n+  0,                           \/* xSetSystemCall *\/\n+  0,                           \/* xGetSystemCall *\/\n+  0,                           \/* xNextSystemCall *\/\n@@ -47873,0 +48708,19 @@\n+\/*\n+** Enter\/leave the mutex on a MemStore\n+*\/\n+#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE==0\n+static void memdbEnter(MemStore *p){\n+  UNUSED_PARAMETER(p);\n+}\n+static void memdbLeave(MemStore *p){\n+  UNUSED_PARAMETER(p);\n+}\n+#else\n+static void memdbEnter(MemStore *p){\n+  sqlite3_mutex_enter(p->pMutex);\n+}\n+static void memdbLeave(MemStore *p){\n+  sqlite3_mutex_leave(p->pMutex);\n+}\n+#endif\n+\n@@ -47877,3 +48731,2 @@\n-**\n-** The pData pointer is owned by the application, so there is nothing\n-** to free.\n+** Free the underlying MemStore object when its refcount drops to zero\n+** or less.\n@@ -47882,2 +48735,35 @@\n-  MemFile *p = (MemFile *)pFile;\n-  if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ) sqlite3_free(p->aData);\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n+  if( p->zFName ){\n+    int i;\n+#ifndef SQLITE_MUTEX_OMIT\n+    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);\n+#endif\n+    sqlite3_mutex_enter(pVfsMutex);\n+    for(i=0; ALWAYS(i<memdb_g.nMemStore); i++){\n+      if( memdb_g.apMemStore[i]==p ){\n+        memdbEnter(p);\n+        if( p->nRef==1 ){\n+          memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];\n+          if( memdb_g.nMemStore==0 ){\n+            sqlite3_free(memdb_g.apMemStore);\n+            memdb_g.apMemStore = 0;\n+          }\n+        }\n+        break;\n+      }\n+    }\n+    sqlite3_mutex_leave(pVfsMutex);\n+  }else{\n+    memdbEnter(p);\n+  }\n+  p->nRef--;\n+  if( p->nRef<=0 ){\n+    if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ){\n+      sqlite3_free(p->aData);\n+    }\n+    memdbLeave(p);\n+    sqlite3_mutex_free(p->pMutex);\n+    sqlite3_free(p);\n+  }else{\n+    memdbLeave(p);\n+  }\n@@ -47896,1 +48782,2 @@\n-  MemFile *p = (MemFile *)pFile;\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n+  memdbEnter(p);\n@@ -47900,0 +48787,1 @@\n+    memdbLeave(p);\n@@ -47903,0 +48791,1 @@\n+  memdbLeave(p);\n@@ -47909,1 +48798,1 @@\n-static int memdbEnlarge(MemFile *p, sqlite3_int64 newSz){\n+static int memdbEnlarge(MemStore *p, sqlite3_int64 newSz){\n@@ -47911,1 +48800,1 @@\n-  if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || p->nMmap>0 ){\n+  if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || NEVER(p->nMmap>0) ){\n@@ -47920,1 +48809,1 @@\n-  if( pNew==0 ) return SQLITE_NOMEM;\n+  if( pNew==0 ) return SQLITE_IOERR_NOMEM;\n@@ -47935,2 +48824,8 @@\n-  MemFile *p = (MemFile *)pFile;\n-  if( NEVER(p->mFlags & SQLITE_DESERIALIZE_READONLY) ) return SQLITE_READONLY;\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n+  memdbEnter(p);\n+  if( NEVER(p->mFlags & SQLITE_DESERIALIZE_READONLY) ){\n+    \/* Can't happen: memdbLock() will return SQLITE_READONLY before\n+    ** reaching this point *\/\n+    memdbLeave(p);\n+    return SQLITE_IOERR_WRITE;\n+  }\n@@ -47942,0 +48837,1 @@\n+      memdbLeave(p);\n@@ -47948,0 +48844,1 @@\n+  memdbLeave(p);\n@@ -47959,4 +48856,11 @@\n-  MemFile *p = (MemFile *)pFile;\n-  if( NEVER(size>p->sz) ) return SQLITE_FULL;\n-  p->sz = size;\n-  return SQLITE_OK;\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n+  int rc = SQLITE_OK;\n+  memdbEnter(p);\n+  if( size>p->sz ){\n+    \/* This can only happen with a corrupt wal mode db *\/\n+    rc = SQLITE_CORRUPT;\n+  }else{\n+    p->sz = size;\n+  }\n+  memdbLeave(p);\n+  return rc;\n@@ -47969,0 +48873,2 @@\n+  UNUSED_PARAMETER(pFile);\n+  UNUSED_PARAMETER(flags);\n@@ -47976,1 +48882,2 @@\n-  MemFile *p = (MemFile *)pFile;\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n+  memdbEnter(p);\n@@ -47978,0 +48885,1 @@\n+  memdbLeave(p);\n@@ -47985,5 +48893,32 @@\n-  MemFile *p = (MemFile *)pFile;\n-  if( eLock>SQLITE_LOCK_SHARED\n-   && (p->mFlags & SQLITE_DESERIALIZE_READONLY)!=0\n-  ){\n-    return SQLITE_READONLY;\n+  MemFile *pThis = (MemFile*)pFile;\n+  MemStore *p = pThis->pStore;\n+  int rc = SQLITE_OK;\n+  if( eLock==pThis->eLock ) return SQLITE_OK;\n+  memdbEnter(p);\n+  if( eLock>SQLITE_LOCK_SHARED ){\n+    if( p->mFlags & SQLITE_DESERIALIZE_READONLY ){\n+      rc = SQLITE_READONLY;\n+    }else if( pThis->eLock<=SQLITE_LOCK_SHARED ){\n+      if( p->nWrLock ){\n+        rc = SQLITE_BUSY;\n+      }else{\n+        p->nWrLock = 1;\n+      }\n+    }\n+  }else if( eLock==SQLITE_LOCK_SHARED ){\n+    if( pThis->eLock > SQLITE_LOCK_SHARED ){\n+      assert( p->nWrLock==1 );\n+      p->nWrLock = 0;\n+    }else if( p->nWrLock ){\n+      rc = SQLITE_BUSY;\n+    }else{\n+      p->nRdLock++;\n+    }\n+  }else{\n+    assert( eLock==SQLITE_LOCK_NONE );\n+    if( pThis->eLock>SQLITE_LOCK_SHARED ){\n+      assert( p->nWrLock==1 );\n+      p->nWrLock = 0;\n+    }\n+    assert( p->nRdLock>0 );\n+    p->nRdLock--;\n@@ -47991,2 +48926,3 @@\n-  p->eLock = eLock;\n-  return SQLITE_OK;\n+  if( rc==SQLITE_OK ) pThis->eLock = eLock;\n+  memdbLeave(p);\n+  return rc;\n@@ -47995,1 +48931,1 @@\n-#if 0 \/* Never used because memdbAccess() always returns false *\/\n+#if 0\n@@ -47997,1 +48933,2 @@\n-** Check if another file-handle holds a RESERVED lock on an memdb-file.\n+** This interface is only used for crash recovery, which does not\n+** occur on an in-memory database.\n@@ -48005,0 +48942,1 @@\n+\n@@ -48009,1 +48947,1 @@\n-  MemFile *p = (MemFile *)pFile;\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n@@ -48011,0 +48949,1 @@\n+  memdbEnter(p);\n@@ -48028,0 +48967,1 @@\n+  memdbLeave(p);\n@@ -48044,0 +48984,1 @@\n+  UNUSED_PARAMETER(pFile);\n@@ -48057,2 +48998,3 @@\n-  MemFile *p = (MemFile *)pFile;\n-  if( iOfst+iAmt>p->sz ){\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n+  memdbEnter(p);\n+  if( iOfst+iAmt>p->sz || (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)!=0 ){\n@@ -48064,0 +49006,1 @@\n+  memdbLeave(p);\n@@ -48069,1 +49012,4 @@\n-  MemFile *p = (MemFile *)pFile;\n+  MemStore *p = ((MemFile*)pFile)->pStore;\n+  UNUSED_PARAMETER(iOfst);\n+  UNUSED_PARAMETER(pPage);\n+  memdbEnter(p);\n@@ -48071,0 +49017,1 @@\n+  memdbLeave(p);\n@@ -48080,1 +49027,1 @@\n-  sqlite3_file *pFile,\n+  sqlite3_file *pFd,\n@@ -48084,3 +49031,62 @@\n-  MemFile *p = (MemFile*)pFile;\n-  if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){\n-    return ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), zName, pFile, flags, pOutFlags);\n+  MemFile *pFile = (MemFile*)pFd;\n+  MemStore *p = 0;\n+  int szName;\n+  UNUSED_PARAMETER(pVfs);\n+\n+  memset(pFile, 0, sizeof(*pFile));\n+  szName = sqlite3Strlen30(zName);\n+  if( szName>1 && zName[0]=='\/' ){\n+    int i;\n+#ifndef SQLITE_MUTEX_OMIT\n+    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);\n+#endif\n+    sqlite3_mutex_enter(pVfsMutex);\n+    for(i=0; i<memdb_g.nMemStore; i++){\n+      if( strcmp(memdb_g.apMemStore[i]->zFName,zName)==0 ){\n+        p = memdb_g.apMemStore[i];\n+        break;\n+      }\n+    }\n+    if( p==0 ){\n+      MemStore **apNew;\n+      p = sqlite3Malloc( sizeof(*p) + szName + 3 );\n+      if( p==0 ){\n+        sqlite3_mutex_leave(pVfsMutex);\n+        return SQLITE_NOMEM;\n+      }\n+      apNew = sqlite3Realloc(memdb_g.apMemStore,\n+                             sizeof(apNew[0])*(memdb_g.nMemStore+1) );\n+      if( apNew==0 ){\n+        sqlite3_free(p);\n+        sqlite3_mutex_leave(pVfsMutex);\n+        return SQLITE_NOMEM;\n+      }\n+      apNew[memdb_g.nMemStore++] = p;\n+      memdb_g.apMemStore = apNew;\n+      memset(p, 0, sizeof(*p));\n+      p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE|SQLITE_DESERIALIZE_FREEONCLOSE;\n+      p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n+      p->zFName = (char*)&p[1];\n+      memcpy(p->zFName, zName, szName+1);\n+      p->pMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n+      if( p->pMutex==0 ){\n+        memdb_g.nMemStore--;\n+        sqlite3_free(p);\n+        sqlite3_mutex_leave(pVfsMutex);\n+        return SQLITE_NOMEM;\n+      }\n+      p->nRef = 1;\n+      memdbEnter(p);\n+    }else{\n+      memdbEnter(p);\n+      p->nRef++;\n+    }\n+    sqlite3_mutex_leave(pVfsMutex);\n+  }else{\n+    p = sqlite3Malloc( sizeof(*p) );\n+    if( p==0 ){\n+      return SQLITE_NOMEM;\n+    }\n+    memset(p, 0, sizeof(*p));\n+    p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;\n+    p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n@@ -48088,6 +49094,6 @@\n-  memset(p, 0, sizeof(*p));\n-  p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;\n-  assert( pOutFlags!=0 );  \/* True because flags==SQLITE_OPEN_MAIN_DB *\/\n-  *pOutFlags = flags | SQLITE_OPEN_MEMORY;\n-  p->base.pMethods = &memdb_io_methods;\n-  p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n+  pFile->pStore = p;\n+  if( pOutFlags!=0 ){\n+    *pOutFlags = flags | SQLITE_OPEN_MEMORY;\n+  }\n+  pFd->pMethods = &memdb_io_methods;\n+  memdbLeave(p);\n@@ -48097,1 +49103,1 @@\n-#if 0 \/* Only used to delete rollback journals, master journals, and WAL\n+#if 0 \/* Only used to delete rollback journals, super-journals, and WAL\n@@ -48121,0 +49127,3 @@\n+  UNUSED_PARAMETER(pVfs);\n+  UNUSED_PARAMETER(zPath);\n+  UNUSED_PARAMETER(flags);\n@@ -48136,0 +49145,1 @@\n+  UNUSED_PARAMETER(pVfs);\n@@ -48208,0 +49218,1 @@\n+  MemStore *pStore;\n@@ -48211,0 +49222,4 @@\n+  pStore = p->pStore;\n+  memdbEnter(pStore);\n+  if( pStore->zFName!=0 ) p = 0;\n+  memdbLeave(pStore);\n@@ -48246,1 +49261,3 @@\n-    if( piSize ) *piSize = p->sz;\n+    MemStore *pStore = p->pStore;\n+    assert( pStore->pMutex==0 );\n+    if( piSize ) *piSize = pStore->sz;\n@@ -48248,1 +49265,1 @@\n-      pOut = p->aData;\n+      pOut = pStore->aData;\n@@ -48250,2 +49267,2 @@\n-      pOut = sqlite3_malloc64( p->sz );\n-      if( pOut ) memcpy(pOut, p->aData, p->sz);\n+      pOut = sqlite3_malloc64( pStore->sz );\n+      if( pOut ) memcpy(pOut, pStore->aData, pStore->sz);\n@@ -48321,1 +49338,2 @@\n-  if( iDb<0 ){\n+  testcase( iDb==1 );\n+  if( iDb<2 && iDb!=0 ){\n@@ -48326,2 +49344,6 @@\n-  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n-  sqlite3_free(zSql);\n+  if( zSql==0 ){\n+    rc = SQLITE_NOMEM;\n+  }else{\n+    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n+    sqlite3_free(zSql);\n+  }\n@@ -48341,6 +49363,8 @@\n-    p->aData = pData;\n-    p->sz = szDb;\n-    p->szAlloc = szBuf;\n-    p->szMax = szBuf;\n-    if( p->szMax<sqlite3GlobalConfig.mxMemdbSize ){\n-      p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n+    MemStore *pStore = p->pStore;\n+    pStore->aData = pData;\n+    pData = 0;\n+    pStore->sz = szDb;\n+    pStore->szAlloc = szBuf;\n+    pStore->szMax = szBuf;\n+    if( pStore->szMax<sqlite3GlobalConfig.mxMemdbSize ){\n+      pStore->szMax = sqlite3GlobalConfig.mxMemdbSize;\n@@ -48348,1 +49372,1 @@\n-    p->mFlags = mFlags;\n+    pStore->mFlags = mFlags;\n@@ -48354,0 +49378,3 @@\n+  if( pData && (mFlags & SQLITE_DESERIALIZE_FREEONCLOSE)!=0 ){\n+    sqlite3_free(pData);\n+  }\n@@ -48364,1 +49391,3 @@\n-  int sz = pLower->szOsFile;\n+  unsigned int sz;\n+  if( NEVER(pLower==0) ) return SQLITE_ERROR;\n+  sz = pLower->szOsFile;\n@@ -48374,1 +49403,1 @@\n-#endif \/* SQLITE_ENABLE_DESERIALIZE *\/\n+#endif \/* SQLITE_OMIT_DESERIALIZE *\/\n@@ -48733,1 +49762,1 @@\n-  pc = 0;\n+  pc = i = 0;\n@@ -49037,0 +50066,1 @@\n+    i64 n;\n@@ -49041,1 +50071,3 @@\n-    return (int)((-1024*(i64)p->szCache)\/(p->szPage+p->szExtra));\n+    n = ((-1024*(i64)p->szCache)\/(p->szPage+p->szExtra));\n+    if( n>1000000000 ) n = 1000000000;\n+    return (int)n;\n@@ -50140,0 +51172,1 @@\n+    p->pLruPrev = 0;           \/* Initializing this saves a valgrind error *\/\n@@ -50495,0 +51528,2 @@\n+  u32 n;\n+  assert( nMax>=0 );\n@@ -50498,1 +51533,5 @@\n-    pGroup->nMaxPage += (nMax - pCache->nMax);\n+    n = (u32)nMax;\n+    if( n > 0x7fff0000 - pGroup->nMaxPage + pCache->nMax ){\n+      n = 0x7fff0000 - pGroup->nMaxPage + pCache->nMax;\n+    }\n+    pGroup->nMaxPage += (n - pCache->nMax);\n@@ -50500,1 +51539,1 @@\n-    pCache->nMax = nMax;\n+    pCache->nMax = n;\n@@ -50516,1 +51555,1 @@\n-    int savedMaxPage;\n+    unsigned int savedMaxPage;\n@@ -51693,2 +52732,2 @@\n-** (6) If a master journal file is used, then all writes to the database file\n-**     are synced prior to the master journal being deleted.\n+** (6) If a super-journal file is used, then all writes to the database file\n+**     are synced prior to the super-journal being deleted.\n@@ -52058,0 +53097,1 @@\n+  int bTruncateOnRelease;      \/* If stmt journal may be truncated on RELEASE *\/\n@@ -52111,1 +53151,1 @@\n-** setMaster\n+** setSuper\n@@ -52114,1 +53154,1 @@\n-**   (or may not) specify a master-journal name to be written into the\n+**   (or may not) specify a super-journal name to be written into the\n@@ -52117,1 +53157,1 @@\n-**   Whether or not a journal file contains a master-journal pointer affects\n+**   Whether or not a journal file contains a super-journal pointer affects\n@@ -52120,1 +53160,1 @@\n-**   If a journal file does not contain a master-journal pointer, it is\n+**   If a journal file does not contain a super-journal pointer, it is\n@@ -52122,1 +53162,1 @@\n-**   it does contain a master-journal pointer the journal file is finalized\n+**   it does contain a super-journal pointer the journal file is finalized\n@@ -52126,1 +53166,1 @@\n-**   Journal files that contain master journal pointers cannot be finalized\n+**   Journal files that contain super-journal pointers cannot be finalized\n@@ -52128,1 +53168,1 @@\n-**   master journal pointer could interfere with hot-journal rollback of any\n+**   super-journal pointer could interfere with hot-journal rollback of any\n@@ -52133,1 +53173,1 @@\n-**   journal file from being successfully finalized, the setMaster flag\n+**   journal file from being successfully finalized, the setSuper flag\n@@ -52252,0 +53292,1 @@\n+  u8 memVfs;                  \/* VFS-implemented memory database *\/\n@@ -52265,1 +53306,1 @@\n-  u8 setMaster;               \/* True if a m-j name has been written to jrnl *\/\n+  u8 setSuper;                \/* Super-jrnl name is written into jrnl *\/\n@@ -52301,1 +53342,0 @@\n-  int pageSize;               \/* Number of bytes in a page *\/\n@@ -52303,0 +53343,1 @@\n+  i64 pageSize;               \/* Number of bytes in a page *\/\n@@ -52409,5 +53450,0 @@\n-\/*\n-** The maximum legal page number is (2^31 - 1).\n-*\/\n-#define PAGER_MAX_PGNO 2147483647\n-\n@@ -52543,1 +53579,1 @@\n-      assert( pPager->setMaster==0 );\n+      assert( pPager->setSuper==0 );\n@@ -52698,0 +53734,3 @@\n+      for(i=i+1; i<pPager->nSavepoint; i++){\n+        pPager->aSavepoint[i].bTruncateOnRelease = 0;\n+      }\n@@ -52897,1 +53936,1 @@\n-** This function attempts to read a master journal file name from the\n+** This function attempts to read a super-journal file name from the\n@@ -52899,2 +53938,2 @@\n-** by the caller. See comments above writeMasterJournal() for the format\n-** used to store a master journal file name at the end of a journal file.\n+** by the caller. See comments above writeSuperJournal() for the format\n+** used to store a super-journal file name at the end of a journal file.\n@@ -52902,1 +53941,1 @@\n-** zMaster must point to a buffer of at least nMaster bytes allocated by\n+** zSuper must point to a buffer of at least nSuper bytes allocated by\n@@ -52904,3 +53943,3 @@\n-** enough space to write the master journal name). If the master journal\n-** name in the journal is longer than nMaster bytes (including a\n-** nul-terminator), then this is handled as if no master journal name\n+** enough space to write the super-journal name). If the super-journal\n+** name in the journal is longer than nSuper bytes (including a\n+** nul-terminator), then this is handled as if no super-journal name\n@@ -52909,4 +53948,4 @@\n-** If a master journal file name is present at the end of the journal\n-** file, then it is copied into the buffer pointed to by zMaster. A\n-** nul-terminator byte is appended to the buffer following the master\n-** journal file name.\n+** If a super-journal file name is present at the end of the journal\n+** file, then it is copied into the buffer pointed to by zSuper. A\n+** nul-terminator byte is appended to the buffer following the\n+** super-journal file name.\n@@ -52914,2 +53953,2 @@\n-** If it is determined that no master journal file name is present\n-** zMaster[0] is set to 0 and SQLITE_OK returned.\n+** If it is determined that no super-journal file name is present\n+** zSuper[0] is set to 0 and SQLITE_OK returned.\n@@ -52920,1 +53959,1 @@\n-static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){\n+static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u32 nSuper){\n@@ -52922,1 +53961,1 @@\n-  u32 len;                   \/* Length in bytes of master journal name *\/\n+  u32 len;                   \/* Length in bytes of super-journal name *\/\n@@ -52927,1 +53966,1 @@\n-  zMaster[0] = '\\0';\n+  zSuper[0] = '\\0';\n@@ -52932,1 +53971,1 @@\n-   || len>=nMaster\n+   || len>=nSuper\n@@ -52938,1 +53977,1 @@\n-   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zMaster, len, szJ-16-len))\n+   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zSuper, len, szJ-16-len))\n@@ -52943,1 +53982,1 @@\n-  \/* See if the checksum matches the master journal name *\/\n+  \/* See if the checksum matches the super-journal name *\/\n@@ -52945,1 +53984,1 @@\n-    cksum -= zMaster[u];\n+    cksum -= zSuper[u];\n@@ -52949,1 +53988,1 @@\n-    ** containing the master journal filename is corrupted. This means\n+    ** containing the super-journal filename is corrupted. This means\n@@ -52951,1 +53990,1 @@\n-    ** master-journal filename.\n+    ** super-journal filename.\n@@ -52955,2 +53994,2 @@\n-  zMaster[len] = '\\0';\n-  zMaster[len+1] = '\\0';\n+  zSuper[len] = '\\0';\n+  zSuper[len+1] = '\\0';\n@@ -53284,2 +54323,2 @@\n-** Write the supplied master journal name into the journal file for pager\n-** pPager at the current location. The master journal name must be the last\n+** Write the supplied super-journal name into the journal file for pager\n+** pPager at the current location. The super-journal name must be the last\n@@ -53291,3 +54330,3 @@\n-**   + N bytes: Master journal filename in utf-8.\n-**   + 4 bytes: N (length of master journal name in bytes, no nul-terminator).\n-**   + 4 bytes: Master journal name checksum.\n+**   + N bytes: super-journal filename in utf-8.\n+**   + 4 bytes: N (length of super-journal name in bytes, no nul-terminator).\n+**   + 4 bytes: super-journal name checksum.\n@@ -53296,2 +54335,2 @@\n-** The master journal page checksum is the sum of the bytes in the master\n-** journal name, where each byte is interpreted as a signed 8-bit integer.\n+** The super-journal page checksum is the sum of the bytes in thesuper-journal\n+** name, where each byte is interpreted as a signed 8-bit integer.\n@@ -53299,1 +54338,1 @@\n-** If zMaster is a NULL pointer (occurs for a single database transaction),\n+** If zSuper is a NULL pointer (occurs for a single database transaction),\n@@ -53302,1 +54341,1 @@\n-static int writeMasterJournal(Pager *pPager, const char *zMaster){\n+static int writeSuperJournal(Pager *pPager, const char *zSuper){\n@@ -53304,1 +54343,1 @@\n-  int nMaster;                     \/* Length of string zMaster *\/\n+  int nSuper;                      \/* Length of string zSuper *\/\n@@ -53307,1 +54346,1 @@\n-  u32 cksum = 0;                   \/* Checksum of string zMaster *\/\n+  u32 cksum = 0;                   \/* Checksum of string zSuper *\/\n@@ -53309,1 +54348,1 @@\n-  assert( pPager->setMaster==0 );\n+  assert( pPager->setSuper==0 );\n@@ -53312,1 +54351,1 @@\n-  if( !zMaster\n+  if( !zSuper\n@@ -53318,1 +54357,1 @@\n-  pPager->setMaster = 1;\n+  pPager->setSuper = 1;\n@@ -53321,3 +54360,3 @@\n-  \/* Calculate the length in bytes and the checksum of zMaster *\/\n-  for(nMaster=0; zMaster[nMaster]; nMaster++){\n-    cksum += zMaster[nMaster];\n+  \/* Calculate the length in bytes and the checksum of zSuper *\/\n+  for(nSuper=0; zSuper[nSuper]; nSuper++){\n+    cksum += zSuper[nSuper];\n@@ -53327,1 +54366,1 @@\n-  ** the master journal name. This is in case the previous page written to\n+  ** the super-journal name. This is in case the previous page written to\n@@ -53335,1 +54374,1 @@\n-  \/* Write the master journal data to the end of the journal file. If\n+  \/* Write the super-journal data to the end of the journal file. If\n@@ -53339,3 +54378,3 @@\n-   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff+4)))\n-   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster, nMaster)))\n-   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster+4, cksum)))\n+   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zSuper, nSuper, iHdrOff+4)))\n+   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper, nSuper)))\n+   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper+4, cksum)))\n@@ -53343,1 +54382,1 @@\n-                                 iHdrOff+4+nMaster+8)))\n+                                 iHdrOff+4+nSuper+8)))\n@@ -53347,1 +54386,1 @@\n-  pPager->journalOff += (nMaster+20);\n+  pPager->journalOff += (nSuper+20);\n@@ -53350,1 +54389,1 @@\n-  ** journal-file may extend past the end of the master-journal name\n+  ** journal-file may extend past the end of the super-journal name\n@@ -53353,1 +54392,1 @@\n-  ** will not be able to find the master-journal name to determine\n+  ** will not be able to find the super-journal name to determine\n@@ -53514,1 +54553,1 @@\n-  pPager->setMaster = 0;\n+  pPager->setSuper = 0;\n@@ -53630,1 +54669,1 @@\n-static int pager_end_transaction(Pager *pPager, int hasMaster, int bCommit){\n+static int pager_end_transaction(Pager *pPager, int hasSuper, int bCommit){\n@@ -53682,1 +54721,1 @@\n-      rc = zeroJournalHdr(pPager, hasMaster||pPager->tempFile);\n+      rc = zeroJournalHdr(pPager, hasSuper||pPager->tempFile);\n@@ -53755,1 +54794,1 @@\n-  pPager->setMaster = 0;\n+  pPager->setSuper = 0;\n@@ -54063,3 +55102,3 @@\n-** Parameter zMaster is the name of a master journal file. A single journal\n-** file that referred to the master journal file has just been rolled back.\n-** This routine checks if it is possible to delete the master journal file,\n+** Parameter zSuper is the name of a super-journal file. A single journal\n+** file that referred to the super-journal file has just been rolled back.\n+** This routine checks if it is possible to delete the super-journal file,\n@@ -54068,1 +55107,1 @@\n-** Argument zMaster may point to Pager.pTmpSpace. So that buffer is not\n+** Argument zSuper may point to Pager.pTmpSpace. So that buffer is not\n@@ -54071,1 +55110,1 @@\n-** When a master journal file is created, it is populated with the names\n+** When a super-journal file is created, it is populated with the names\n@@ -54074,1 +55113,1 @@\n-** nul-terminator byte (0x00). i.e. the entire contents of a master journal\n+** nul-terminator byte (0x00). i.e. the entire contents of a super-journal\n@@ -54079,1 +55118,1 @@\n-** A master journal file may only be deleted once all of its child\n+** A super-journal file may only be deleted once all of its child\n@@ -54082,1 +55121,1 @@\n-** This function reads the contents of the master-journal file into\n+** This function reads the contents of the super-journal file into\n@@ -54087,2 +55126,2 @@\n-**   * if the child journal contains a reference to master journal\n-**     file zMaster\n+**   * if the child journal contains a reference to super-journal\n+**     file zSuper\n@@ -54092,1 +55131,1 @@\n-** no such child journal can be found, file zMaster is deleted from\n+** no such child journal can be found, file zSuper is deleted from\n@@ -54101,1 +55140,1 @@\n-** the entire contents of the master journal file. This could be\n+** the entire contents of the super-journal file. This could be\n@@ -54105,1 +55144,1 @@\n-static int pager_delmaster(Pager *pPager, const char *zMaster){\n+static int pager_delsuper(Pager *pPager, const char *zSuper){\n@@ -54108,1 +55147,1 @@\n-  sqlite3_file *pMaster;    \/* Malloc'd master-journal file descriptor *\/\n+  sqlite3_file *pSuper;     \/* Malloc'd super-journal file descriptor *\/\n@@ -54110,2 +55149,2 @@\n-  char *zMasterJournal = 0; \/* Contents of master journal file *\/\n-  i64 nMasterJournal;       \/* Size of master journal file *\/\n+  char *zSuperJournal = 0;  \/* Contents of super-journal file *\/\n+  i64 nSuperJournal;        \/* Size of super-journal file *\/\n@@ -54113,2 +55152,3 @@\n-  char *zMasterPtr;         \/* Space to hold MJ filename from a journal file *\/\n-  int nMasterPtr;           \/* Amount of space allocated to zMasterPtr[] *\/\n+  char *zSuperPtr;          \/* Space to hold super-journal filename *\/\n+  char *zFree = 0;          \/* Free this buffer *\/\n+  int nSuperPtr;            \/* Amount of space allocated to zSuperPtr[] *\/\n@@ -54116,2 +55156,2 @@\n-  \/* Allocate space for both the pJournal and pMaster file descriptors.\n-  ** If successful, open the master journal file for reading.\n+  \/* Allocate space for both the pJournal and pSuper file descriptors.\n+  ** If successful, open the super-journal file for reading.\n@@ -54119,3 +55159,2 @@\n-  pMaster = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);\n-  pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile);\n-  if( !pMaster ){\n+  pSuper = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);\n+  if( !pSuper ){\n@@ -54123,0 +55162,1 @@\n+    pJournal = 0;\n@@ -54124,2 +55164,3 @@\n-    const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MASTER_JOURNAL);\n-    rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0);\n+    const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);\n+    rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);\n+    pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);\n@@ -54127,1 +55168,1 @@\n-  if( rc!=SQLITE_OK ) goto delmaster_out;\n+  if( rc!=SQLITE_OK ) goto delsuper_out;\n@@ -54129,4 +55170,4 @@\n-  \/* Load the entire master journal file into space obtained from\n-  ** sqlite3_malloc() and pointed to by zMasterJournal.   Also obtain\n-  ** sufficient space (in zMasterPtr) to hold the names of master\n-  ** journal files extracted from regular rollback-journals.\n+  \/* Load the entire super-journal file into space obtained from\n+  ** sqlite3_malloc() and pointed to by zSuperJournal.   Also obtain\n+  ** sufficient space (in zSuperPtr) to hold the names of super-journal\n+  ** files extracted from regular rollback-journals.\n@@ -54134,5 +55175,5 @@\n-  rc = sqlite3OsFileSize(pMaster, &nMasterJournal);\n-  if( rc!=SQLITE_OK ) goto delmaster_out;\n-  nMasterPtr = pVfs->mxPathname+1;\n-  zMasterJournal = sqlite3Malloc(nMasterJournal + nMasterPtr + 2);\n-  if( !zMasterJournal ){\n+  rc = sqlite3OsFileSize(pSuper, &nSuperJournal);\n+  if( rc!=SQLITE_OK ) goto delsuper_out;\n+  nSuperPtr = pVfs->mxPathname+1;\n+  zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);\n+  if( !zFree ){\n@@ -54140,10 +55181,12 @@\n-    goto delmaster_out;\n-  }\n-  zMasterPtr = &zMasterJournal[nMasterJournal+2];\n-  rc = sqlite3OsRead(pMaster, zMasterJournal, (int)nMasterJournal, 0);\n-  if( rc!=SQLITE_OK ) goto delmaster_out;\n-  zMasterJournal[nMasterJournal] = 0;\n-  zMasterJournal[nMasterJournal+1] = 0;\n-\n-  zJournal = zMasterJournal;\n-  while( (zJournal-zMasterJournal)<nMasterJournal ){\n+    goto delsuper_out;\n+  }\n+  zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;\n+  zSuperJournal = &zFree[4];\n+  zSuperPtr = &zSuperJournal[nSuperJournal+2];\n+  rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);\n+  if( rc!=SQLITE_OK ) goto delsuper_out;\n+  zSuperJournal[nSuperJournal] = 0;\n+  zSuperJournal[nSuperJournal+1] = 0;\n+\n+  zJournal = zSuperJournal;\n+  while( (zJournal-zSuperJournal)<nSuperJournal ){\n@@ -54153,1 +55196,1 @@\n-      goto delmaster_out;\n+      goto delsuper_out;\n@@ -54156,3 +55199,3 @@\n-      \/* One of the journals pointed to by the master journal exists.\n-      ** Open it and check if it points at the master journal. If\n-      ** so, return without deleting the master journal file.\n+      \/* One of the journals pointed to by the super-journal exists.\n+      ** Open it and check if it points at the super-journal. If\n+      ** so, return without deleting the super-journal file.\n@@ -54160,1 +55203,1 @@\n-      ** MASTER_JOURNAL here so that the VFS will not send the zJournal\n+      ** SUPER_JOURNAL here so that the VFS will not send the zJournal\n@@ -54164,1 +55207,1 @@\n-      int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MASTER_JOURNAL);\n+      int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);\n@@ -54167,1 +55210,1 @@\n-        goto delmaster_out;\n+        goto delsuper_out;\n@@ -54170,1 +55213,1 @@\n-      rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr);\n+      rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);\n@@ -54173,1 +55216,1 @@\n-        goto delmaster_out;\n+        goto delsuper_out;\n@@ -54176,1 +55219,1 @@\n-      c = zMasterPtr[0]!=0 && strcmp(zMasterPtr, zMaster)==0;\n+      c = zSuperPtr[0]!=0 && strcmp(zSuperPtr, zSuper)==0;\n@@ -54178,2 +55221,2 @@\n-        \/* We have a match. Do not delete the master journal file. *\/\n-        goto delmaster_out;\n+        \/* We have a match. Do not delete the super-journal file. *\/\n+        goto delsuper_out;\n@@ -54185,2 +55228,2 @@\n-  sqlite3OsClose(pMaster);\n-  rc = sqlite3OsDelete(pVfs, zMaster, 0);\n+  sqlite3OsClose(pSuper);\n+  rc = sqlite3OsDelete(pVfs, zSuper, 0);\n@@ -54188,4 +55231,4 @@\n-delmaster_out:\n-  sqlite3_free(zMasterJournal);\n-  if( pMaster ){\n-    sqlite3OsClose(pMaster);\n+delsuper_out:\n+  sqlite3_free(zFree);\n+  if( pSuper ){\n+    sqlite3OsClose(pSuper);\n@@ -54193,1 +55236,1 @@\n-    sqlite3_free(pMaster);\n+    sqlite3_free(pSuper);\n@@ -54271,1 +55314,1 @@\n-** master journal pointers within created journal files.\n+** super-journal pointers within created journal files.\n@@ -54370,1 +55413,1 @@\n-  char *zMaster = 0;       \/* Name of master journal file if any *\/\n+  char *zSuper = 0;        \/* Name of super-journal file if any *\/\n@@ -54384,2 +55427,2 @@\n-  \/* Read the master journal name from the journal, if it is present.\n-  ** If a master journal file name is specified, but the file is not\n+  \/* Read the super-journal name from the journal, if it is present.\n+  ** If a super-journal file name is specified, but the file is not\n@@ -54395,4 +55438,4 @@\n-  zMaster = pPager->pTmpSpace;\n-  rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);\n-  if( rc==SQLITE_OK && zMaster[0] ){\n-    rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);\n+  zSuper = pPager->pTmpSpace;\n+  rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);\n+  if( rc==SQLITE_OK && zSuper[0] ){\n+    rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);\n@@ -54400,1 +55443,1 @@\n-  zMaster = 0;\n+  zSuper = 0;\n@@ -54527,2 +55570,6 @@\n-    zMaster = pPager->pTmpSpace;\n-    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);\n+    \/* Leave 4 bytes of space before the super-journal filename in memory.\n+    ** This is because it may end up being passed to sqlite3OsOpen(), in\n+    ** which case it requires 4 0x00 bytes in memory immediately before\n+    ** the filename. *\/\n+    zSuper = &pPager->pTmpSpace[4];\n+    rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);\n@@ -54537,1 +55584,1 @@\n-    rc = pager_end_transaction(pPager, zMaster[0]!='\\0', 0);\n+    rc = pager_end_transaction(pPager, zSuper[0]!='\\0', 0);\n@@ -54540,3 +55587,3 @@\n-  if( rc==SQLITE_OK && zMaster[0] && res ){\n-    \/* If there was a master journal and this routine will return success,\n-    ** see if it is possible to delete the master journal.\n+  if( rc==SQLITE_OK && zSuper[0] && res ){\n+    \/* If there was a super-journal and this routine will return success,\n+    ** see if it is possible to delete the super-journal.\n@@ -54544,1 +55591,3 @@\n-    rc = pager_delmaster(pPager, zMaster);\n+    assert( zSuper==&pPager->pTmpSpace[4] );\n+    memset(&zSuper[-4], 0, 4);\n+    rc = pager_delsuper(pPager, zSuper);\n@@ -54638,0 +55687,1 @@\n+  if( NEVER(pPg==0) ) return;\n@@ -54923,1 +55973,1 @@\n-** the entire master journal file. The case pSavepoint==NULL occurs when\n+** the entire super-journal file. The case pSavepoint==NULL occurs when\n@@ -55386,1 +56436,1 @@\n-SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){\n+SQLITE_PRIVATE Pgno sqlite3PagerMaxPageCount(Pager *pPager, Pgno mxPage){\n@@ -55529,1 +56579,1 @@\n-  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );\n+  assert( pPg->pgno<=pPg->pPager->dbSize || !subjRequiresPage(pPg) );\n@@ -55550,1 +56600,2 @@\n-  assert( pPager->dbSize>=nPage );\n+  assert( pPager->dbSize>=nPage || CORRUPT_DB );\n+  testcase( pPager->dbSize<nPage );\n@@ -56278,1 +57329,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -56471,0 +57522,1 @@\n+  (void)pPtr;  \/* Suppress warning about unused pPtr value *\/\n@@ -56482,2 +57534,2 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n-    memJM = (fout&SQLITE_OPEN_MEMORY)!=0;\n+#ifndef SQLITE_OMIT_DESERIALIZE\n+    pPager->memVfs = memJM = (fout&SQLITE_OPEN_MEMORY)!=0;\n@@ -56663,2 +57715,2 @@\n-** This routine does not check if there is a master journal filename\n-** at the end of the file. If there is, and that master journal file\n+** This routine does not check if there is a super-journal filename\n+** at the end of the file. If there is, and that super-journal file\n@@ -56868,1 +57920,1 @@\n-      if( !isOpen(pPager->jfd) ){\n+      if( !isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){\n@@ -57113,1 +58165,1 @@\n-    assert( pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) );\n+    assert( pgno!=PAGER_MJ_PGNO(pPager) );\n@@ -57121,1 +58173,1 @@\n-    ** (1) The maximum page number is 2^31\n+    ** (*) obsolete.  Was: maximum page number is 2^31\n@@ -57124,1 +58176,1 @@\n-    if( pgno>PAGER_MAX_PGNO || pgno==PAGER_MJ_PGNO(pPager) ){\n+    if( pgno==PAGER_MJ_PGNO(pPager) ){\n@@ -57409,1 +58461,1 @@\n-      pPager->setMaster = 0;\n+      pPager->setSuper = 0;\n@@ -57450,1 +58502,1 @@\n-  if( ALWAYS(pPager->eState==PAGER_READER) ){\n+  if( pPager->eState==PAGER_READER ){\n@@ -57921,1 +58973,1 @@\n-SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster){\n+SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zSuper){\n@@ -57923,1 +58975,1 @@\n-  void *pArg = (void*)zMaster;\n+  void *pArg = (void*)zSuper;\n@@ -57961,4 +59013,4 @@\n-** Sync the database file for the pager pPager. zMaster points to the name\n-** of a master journal file that should be written into the individual\n-** journal file. zMaster may be NULL, which is interpreted as no master\n-** journal (a single database transaction).\n+** Sync the database file for the pager pPager. zSuper points to the name\n+** of a super-journal file that should be written into the individual\n+** journal file. zSuper may be NULL, which is interpreted as no\n+** super-journal (a single database transaction).\n@@ -57976,1 +59028,1 @@\n-** delete the master journal file if specified).\n+** delete the super-journal file if specified).\n@@ -57978,1 +59030,1 @@\n-** Note that if zMaster==NULL, this does not overwrite a previous value\n+** Note that if zSuper==NULL, this does not overwrite a previous value\n@@ -57988,1 +59040,1 @@\n-  const char *zMaster,            \/* If not NULL, the master journal name *\/\n+  const char *zSuper,            \/* If not NULL, the super-journal name *\/\n@@ -58006,2 +59058,2 @@\n-  PAGERTRACE((\"DATABASE SYNC: File=%s zMaster=%s nSize=%d\\n\",\n-      pPager->zFilename, zMaster, pPager->dbSize));\n+  PAGERTRACE((\"DATABASE SYNC: File=%s zSuper=%s nSize=%d\\n\",\n+      pPager->zFilename, zSuper, pPager->dbSize));\n@@ -58046,1 +59098,1 @@\n-      int bBatch = zMaster==0    \/* An SQLITE_IOCAP_BATCH_ATOMIC commit *\/\n+      int bBatch = zSuper==0    \/* An SQLITE_IOCAP_BATCH_ATOMIC commit *\/\n@@ -58084,1 +59136,1 @@\n-        if( !zMaster && isOpen(pPager->jfd)\n+        if( !zSuper && isOpen(pPager->jfd)\n@@ -58105,1 +59157,1 @@\n-      if( zMaster ){\n+      if( zSuper ){\n@@ -58115,3 +59167,3 @@\n-      \/* Write the master journal name into the journal file. If a master\n-      ** journal file name has already been written to the journal file,\n-      ** or if zMaster is NULL (no master journal), then this call is a no-op.\n+      \/* Write the super-journal name into the journal file. If a\n+      ** super-journal file name has already been written to the journal file,\n+      ** or if zSuper is NULL (no super-journal), then this call is a no-op.\n@@ -58119,1 +59171,1 @@\n-      rc = writeMasterJournal(pPager, zMaster);\n+      rc = writeSuperJournal(pPager, zSuper);\n@@ -58187,1 +59239,1 @@\n-        rc = sqlite3PagerSync(pPager, zMaster);\n+        rc = sqlite3PagerSync(pPager, zSuper);\n@@ -58252,1 +59304,1 @@\n-  rc = pager_end_transaction(pPager, pPager->setMaster, 1);\n+  rc = pager_end_transaction(pPager, pPager->setSuper, 1);\n@@ -58297,1 +59349,1 @@\n-    rc2 = pager_end_transaction(pPager, pPager->setMaster, 0);\n+    rc2 = pager_end_transaction(pPager, pPager->setSuper, 0);\n@@ -58350,2 +59402,2 @@\n-  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)\n-                                     + 5*sizeof(void*);\n+  int perPageSize = pPager->pageSize + pPager->nExtra\n+    + (int)(sizeof(PgHdr) + 5*sizeof(void*));\n@@ -58420,1 +59472,1 @@\n-  return pPager->tempFile;\n+  return pPager->tempFile || pPager->memVfs;\n@@ -58466,0 +59518,1 @@\n+    aNew[ii].bTruncateOnRelease = 1;\n@@ -58544,2 +59597,2 @@\n-    \/* If this is a release of the outermost savepoint, truncate\n-    ** the sub-journal to zero bytes in size. *\/\n+    \/* Truncate the sub-journal so that it only includes the parts\n+    ** that are still in use. *\/\n@@ -58547,1 +59600,2 @@\n-      if( nNew==0 && isOpen(pPager->sjfd) ){\n+      PagerSavepoint *pRel = &pPager->aSavepoint[nNew];\n+      if( pRel->bTruncateOnRelease && isOpen(pPager->sjfd) ){\n@@ -58550,1 +59604,2 @@\n-          rc = sqlite3OsTruncate(pPager->sjfd, 0);\n+          i64 sz = (pPager->pageSize+4)*(i64)pRel->iSubRec;\n+          rc = sqlite3OsTruncate(pPager->sjfd, sz);\n@@ -58553,1 +59608,1 @@\n-        pPager->nSubRec = 0;\n+        pPager->nSubRec = pRel->iSubRec;\n@@ -58737,1 +59792,1 @@\n-    if( pPgOld->nRef>1 ){\n+    if( NEVER(pPgOld->nRef>1) ){\n@@ -59483,1 +60538,4 @@\n-** wal-index.\n+** wal-index.  The values are:\n+**\n+**   HASHTABLE_NPAGE      4096\n+**   HASHTABLE_NPAGE_ONE  4062\n@@ -59719,0 +60777,64 @@\n+\/*\n+** This is a schematic view of the complete 136-byte header of the\n+** wal-index file (also known as the -shm file):\n+**\n+**      +-----------------------------+\n+**   0: | iVersion                    | \\\n+**      +-----------------------------+  |\n+**   4: | (unused padding)            |  |\n+**      +-----------------------------+  |\n+**   8: | iChange                     |  |\n+**      +-------+-------+-------------+  |\n+**  12: | bInit |  bBig |   szPage    |  |\n+**      +-------+-------+-------------+  |\n+**  16: | mxFrame                     |  |  First copy of the\n+**      +-----------------------------+  |  WalIndexHdr object\n+**  20: | nPage                       |  |\n+**      +-----------------------------+  |\n+**  24: | aFrameCksum                 |  |\n+**      |                             |  |\n+**      +-----------------------------+  |\n+**  32: | aSalt                       |  |\n+**      |                             |  |\n+**      +-----------------------------+  |\n+**  40: | aCksum                      |  |\n+**      |                             | \/\n+**      +-----------------------------+\n+**  48: | iVersion                    | \\\n+**      +-----------------------------+  |\n+**  52: | (unused padding)            |  |\n+**      +-----------------------------+  |\n+**  56: | iChange                     |  |\n+**      +-------+-------+-------------+  |\n+**  60: | bInit |  bBig |   szPage    |  |\n+**      +-------+-------+-------------+  |  Second copy of the\n+**  64: | mxFrame                     |  |  WalIndexHdr\n+**      +-----------------------------+  |\n+**  68: | nPage                       |  |\n+**      +-----------------------------+  |\n+**  72: | aFrameCksum                 |  |\n+**      |                             |  |\n+**      +-----------------------------+  |\n+**  80: | aSalt                       |  |\n+**      |                             |  |\n+**      +-----------------------------+  |\n+**  88: | aCksum                      |  |\n+**      |                             | \/\n+**      +-----------------------------+\n+**  96: | nBackfill                   |\n+**      +-----------------------------+\n+** 100: | 5 read marks                |\n+**      |                             |\n+**      |                             |\n+**      |                             |\n+**      |                             |\n+**      +-------+-------+------+------+\n+** 120: | Write | Ckpt  | Rcvr | Rd0  | \\\n+**      +-------+-------+------+------+  ) 8 lock bytes\n+**      | Read1 | Read2 | Rd3  | Rd4  | \/\n+**      +-------+-------+------+------+\n+** 128: | nBackfillAttempted          |\n+**      +-----------------------------+\n+** 132: | (unused padding)            |\n+**      +-----------------------------+\n+*\/\n@@ -59830,1 +60952,1 @@\n-  int iPrior;                     \/* Last result returned from the iterator *\/\n+  u32 iPrior;                     \/* Last result returned from the iterator *\/\n@@ -59875,3 +60997,7 @@\n-** If this call is successful, *ppPage is set to point to the wal-index\n-** page and SQLITE_OK is returned. If an error (an OOM or VFS error) occurs,\n-** then an SQLite error code is returned and *ppPage is set to 0.\n+** Three possible result scenarios:\n+**\n+**   (1)  rc==SQLITE_OK    and *ppPage==Requested-Wal-Index-Page\n+**   (2)  rc>=SQLITE_ERROR and *ppPage==NULL\n+**   (3)  rc==SQLITE_OK    and *ppPage==NULL  \/\/ only if iPage==0\n+**\n+** Scenario (3) can only occur when pWal->writeLock is false and iPage==0\n@@ -59910,1 +61036,3 @@\n-    assert( pWal->apWiData[iPage]!=0 || rc!=SQLITE_OK || pWal->writeLock==0 );\n+    assert( pWal->apWiData[iPage]!=0\n+         || rc!=SQLITE_OK\n+         || (pWal->writeLock==0 && iPage==0) );\n@@ -59912,1 +61040,3 @@\n-    if( (rc&0xff)==SQLITE_READONLY ){\n+    if( rc==SQLITE_OK ){\n+      if( iPage>0 && sqlite3FaultSim(600) ) rc = SQLITE_NOMEM;\n+    }else if( (rc&0xff)==SQLITE_READONLY ){\n@@ -60247,2 +61377,2 @@\n-** Finally, set pLoc->aPgno so that pLoc->aPgno[1] is the page number of the\n-** first frame indexed by the hash table, frame (pLoc->iZero+1).\n+** Finally, set pLoc->aPgno so that pLoc->aPgno[0] is the page number of the\n+** first frame indexed by the hash table, frame (pLoc->iZero).\n@@ -60260,1 +61390,1 @@\n-  if( rc==SQLITE_OK ){\n+  if( pLoc->aPgno ){\n@@ -60268,1 +61398,2 @@\n-    pLoc->aPgno = &pLoc->aPgno[-1];\n+  }else if( NEVER(rc==SQLITE_OK) ){\n+    rc = SQLITE_ERROR;\n@@ -60287,0 +61418,1 @@\n+  assert( iHash>=0 );\n@@ -60318,1 +61450,0 @@\n-  int rc;                         \/* Return code form walHashGet() *\/\n@@ -60333,2 +61464,2 @@\n-  rc = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);\n-  if( NEVER(rc) ) return; \/* Defense-in-depth, in case (1) above is wrong *\/\n+  i = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);\n+  if( NEVER(i) ) return; \/* Defense-in-depth, in case (1) above is wrong *\/\n@@ -60350,2 +61481,3 @@\n-  nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit+1]);\n-  memset((void *)&sLoc.aPgno[iLimit+1], 0, nByte);\n+  nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit]);\n+  assert( nByte>=0 );\n+  memset((void *)&sLoc.aPgno[iLimit], 0, nByte);\n@@ -60360,1 +61492,1 @@\n-    for(j=1; j<=iLimit; j++){\n+    for(j=0; j<iLimit; j++){\n@@ -60362,1 +61494,1 @@\n-        if( sLoc.aHash[iKey]==j ) break;\n+        if( sLoc.aHash[iKey]==j+1 ) break;\n@@ -60364,1 +61496,1 @@\n-      assert( sLoc.aHash[iKey]==j );\n+      assert( sLoc.aHash[iKey]==j+1 );\n@@ -60396,3 +61528,3 @@\n-      int nByte = (int)((u8 *)&sLoc.aHash[HASHTABLE_NSLOT]\n-                               - (u8 *)&sLoc.aPgno[1]);\n-      memset((void*)&sLoc.aPgno[1], 0, nByte);\n+      int nByte = (int)((u8*)&sLoc.aHash[HASHTABLE_NSLOT] - (u8*)sLoc.aPgno);\n+      assert( nByte>=0 );\n+      memset((void*)sLoc.aPgno, 0, nByte);\n@@ -60407,1 +61539,1 @@\n-    if( sLoc.aPgno[idx] ){\n+    if( sLoc.aPgno[idx-1] ){\n@@ -60409,1 +61541,1 @@\n-      assert( !sLoc.aPgno[idx] );\n+      assert( !sLoc.aPgno[idx-1] );\n@@ -60417,2 +61549,2 @@\n-    sLoc.aPgno[idx] = iPage;\n-    sLoc.aHash[iKey] = (ht_slot)idx;\n+    sLoc.aPgno[idx-1] = iPage;\n+    AtomicStore(&sLoc.aHash[iKey], (ht_slot)idx);\n@@ -60438,1 +61570,1 @@\n-      for(i=1; i<=idx; i++){\n+      for(i=0; i<idx; i++){\n@@ -60442,1 +61574,1 @@\n-          if( sLoc.aHash[iKey]==i ) break;\n+          if( sLoc.aHash[iKey]==i+1 ) break;\n@@ -60444,1 +61576,1 @@\n-        assert( sLoc.aHash[iKey]==i );\n+        assert( sLoc.aHash[iKey]==i+1 );\n@@ -60450,1 +61582,0 @@\n-\n@@ -60483,6 +61614,0 @@\n-  if( rc==SQLITE_OK ){\n-    rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n-    if( rc!=SQLITE_OK ){\n-      walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);\n-    }\n-  }\n@@ -60504,0 +61629,1 @@\n+    u32 *aPrivate = 0;            \/* Heap copy of *-shm hash being populated *\/\n@@ -60507,2 +61633,0 @@\n-    int iFrame;                   \/* Index of last frame read *\/\n-    i64 iOffset;                  \/* Next offset to read from log file *\/\n@@ -60513,0 +61637,2 @@\n+    u32 iPg;                      \/* Current 32KB wal-index page *\/\n+    u32 iLastFrame;               \/* Last frame in wal, based on nSize alone *\/\n@@ -60559,1 +61685,1 @@\n-    aFrame = (u8 *)sqlite3_malloc64(szFrame);\n+    aFrame = (u8 *)sqlite3_malloc64(szFrame + WALINDEX_PGSZ);\n@@ -60565,0 +61691,1 @@\n+    aPrivate = (u32*)&aData[szPage];\n@@ -60567,23 +61694,65 @@\n-    iFrame = 0;\n-    for(iOffset=WAL_HDRSIZE; (iOffset+szFrame)<=nSize; iOffset+=szFrame){\n-      u32 pgno;                   \/* Database page number for frame *\/\n-      u32 nTruncate;              \/* dbsize field from frame header *\/\n-\n-      \/* Read and decode the next log frame. *\/\n-      iFrame++;\n-      rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n-      if( rc!=SQLITE_OK ) break;\n-      isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n-      if( !isValid ) break;\n-      rc = walIndexAppend(pWal, iFrame, pgno);\n-      if( rc!=SQLITE_OK ) break;\n-\n-      \/* If nTruncate is non-zero, this is a commit record. *\/\n-      if( nTruncate ){\n-        pWal->hdr.mxFrame = iFrame;\n-        pWal->hdr.nPage = nTruncate;\n-        pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n-        testcase( szPage<=32768 );\n-        testcase( szPage>=65536 );\n-        aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n-        aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n+    iLastFrame = (nSize - WAL_HDRSIZE) \/ szFrame;\n+    for(iPg=0; iPg<=(u32)walFramePage(iLastFrame); iPg++){\n+      u32 *aShare;\n+      u32 iFrame;                 \/* Index of last frame read *\/\n+      u32 iLast = MIN(iLastFrame, HASHTABLE_NPAGE_ONE+iPg*HASHTABLE_NPAGE);\n+      u32 iFirst = 1 + (iPg==0?0:HASHTABLE_NPAGE_ONE+(iPg-1)*HASHTABLE_NPAGE);\n+      u32 nHdr, nHdr32;\n+      rc = walIndexPage(pWal, iPg, (volatile u32**)&aShare);\n+      assert( aShare!=0 || rc!=SQLITE_OK );\n+      if( aShare==0 ) break;\n+      pWal->apWiData[iPg] = aPrivate;\n+\n+      for(iFrame=iFirst; iFrame<=iLast; iFrame++){\n+        i64 iOffset = walFrameOffset(iFrame, szPage);\n+        u32 pgno;                 \/* Database page number for frame *\/\n+        u32 nTruncate;            \/* dbsize field from frame header *\/\n+\n+        \/* Read and decode the next log frame. *\/\n+        rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n+        if( rc!=SQLITE_OK ) break;\n+        isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n+        if( !isValid ) break;\n+        rc = walIndexAppend(pWal, iFrame, pgno);\n+        if( NEVER(rc!=SQLITE_OK) ) break;\n+\n+        \/* If nTruncate is non-zero, this is a commit record. *\/\n+        if( nTruncate ){\n+          pWal->hdr.mxFrame = iFrame;\n+          pWal->hdr.nPage = nTruncate;\n+          pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n+          testcase( szPage<=32768 );\n+          testcase( szPage>=65536 );\n+          aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n+          aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n+        }\n+      }\n+      pWal->apWiData[iPg] = aShare;\n+      nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);\n+      nHdr32 = nHdr \/ sizeof(u32);\n+#ifndef SQLITE_SAFER_WALINDEX_RECOVERY\n+      \/* Memcpy() should work fine here, on all reasonable implementations.\n+      ** Technically, memcpy() might change the destination to some\n+      ** intermediate value before setting to the final value, and that might\n+      ** cause a concurrent reader to malfunction.  Memcpy() is allowed to\n+      ** do that, according to the spec, but no memcpy() implementation that\n+      ** we know of actually does that, which is why we say that memcpy()\n+      ** is safe for this.  Memcpy() is certainly a lot faster.\n+      *\/\n+      memcpy(&aShare[nHdr32], &aPrivate[nHdr32], WALINDEX_PGSZ-nHdr);\n+#else\n+      \/* In the event that some platform is found for which memcpy()\n+      ** changes the destination to some intermediate value before\n+      ** setting the final value, this alternative copy routine is\n+      ** provided.\n+      *\/\n+      {\n+        int i;\n+        for(i=nHdr32; i<WALINDEX_PGSZ\/sizeof(u32); i++){\n+          if( aShare[i]!=aPrivate[i] ){\n+            \/* Atomic memory operations are not required here because if\n+            ** the value needs to be changed, that means it is not being\n+            ** accessed concurrently. *\/\n+            aShare[i] = aPrivate[i];\n+          }\n+        }\n@@ -60591,0 +61760,2 @@\n+#endif\n+      if( iFrame<=iLast ) break;\n@@ -60605,2 +61776,2 @@\n-    ** currently holding locks that exclude all other readers, writers and\n-    ** checkpointers.\n+    ** currently holding locks that exclude all other writers and\n+    ** checkpointers. Then set the values of read-mark slots 1 through N.\n@@ -60612,2 +61783,13 @@\n-    for(i=1; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;\n-    if( pWal->hdr.mxFrame ) pInfo->aReadMark[1] = pWal->hdr.mxFrame;\n+    for(i=1; i<WAL_NREADER; i++){\n+      rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n+      if( rc==SQLITE_OK ){\n+        if( i==1 && pWal->hdr.mxFrame ){\n+          pInfo->aReadMark[i] = pWal->hdr.mxFrame;\n+        }else{\n+          pInfo->aReadMark[i] = READMARK_NOT_USED;\n+        }\n+        walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n+      }else if( rc!=SQLITE_BUSY ){\n+        goto recovery_error;\n+      }\n+    }\n@@ -60631,1 +61813,0 @@\n-  walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n@@ -60681,0 +61862,31 @@\n+  \/* Verify the values of various constants.  Any changes to the values\n+  ** of these constants would result in an incompatible on-disk format\n+  ** for the -shm file.  Any change that causes one of these asserts to\n+  ** fail is a backward compatibility problem, even if the change otherwise\n+  ** works.\n+  **\n+  ** This table also serves as a helpful cross-reference when trying to\n+  ** interpret hex dumps of the -shm file.\n+  *\/\n+  assert(    48 ==  sizeof(WalIndexHdr)  );\n+  assert(    40 ==  sizeof(WalCkptInfo)  );\n+  assert(   120 ==  WALINDEX_LOCK_OFFSET );\n+  assert(   136 ==  WALINDEX_HDR_SIZE    );\n+  assert(  4096 ==  HASHTABLE_NPAGE      );\n+  assert(  4062 ==  HASHTABLE_NPAGE_ONE  );\n+  assert(  8192 ==  HASHTABLE_NSLOT      );\n+  assert(   383 ==  HASHTABLE_HASH_1     );\n+  assert( 32768 ==  WALINDEX_PGSZ        );\n+  assert(     8 ==  SQLITE_SHM_NLOCK     );\n+  assert(     5 ==  WAL_NREADER          );\n+  assert(    24 ==  WAL_FRAME_HDRSIZE    );\n+  assert(    32 ==  WAL_HDRSIZE          );\n+  assert(   120 ==  WALINDEX_LOCK_OFFSET + WAL_WRITE_LOCK   );\n+  assert(   121 ==  WALINDEX_LOCK_OFFSET + WAL_CKPT_LOCK    );\n+  assert(   122 ==  WALINDEX_LOCK_OFFSET + WAL_RECOVER_LOCK );\n+  assert(   123 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(0) );\n+  assert(   124 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(1) );\n+  assert(   125 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(2) );\n+  assert(   126 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(3) );\n+  assert(   127 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(4) );\n+\n@@ -60687,2 +61899,0 @@\n-  assert( 120==WALINDEX_LOCK_OFFSET );\n-  assert( 136==WALINDEX_HDR_SIZE );\n@@ -60990,1 +62200,0 @@\n-      sLoc.aPgno++;\n@@ -61279,1 +62488,9 @@\n-          sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT, &nReq);\n+          if( (nSize+65536+(i64)pWal->hdr.mxFrame*szPage)<nReq ){\n+            \/* If the size of the final database is larger than the current\n+            ** database plus the amount of data in the wal file, plus the\n+            ** maximum size of the pending-byte page (65536 bytes), then\n+            ** must be corruption somewhere.  *\/\n+            rc = SQLITE_CORRUPT_BKPT;\n+          }else{\n+            sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT,&nReq);\n+          }\n@@ -61281,1 +62498,0 @@\n-      }\n@@ -61283,0 +62499,1 @@\n+      }\n@@ -62121,1 +63338,2 @@\n-          pgno = sLoc.aPgno[i-sLoc.iZero];\n+          assert( i - sLoc.iZero - 1 >=0 );\n+          pgno = sLoc.aPgno[i-sLoc.iZero-1];\n@@ -62354,1 +63572,1 @@\n-      if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH]==pgno ){\n+      if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH-1]==pgno ){\n@@ -63606,1 +64824,0 @@\n-  u8 bBusy;            \/* Prevent endless loops on corrupt database files *\/\n@@ -63684,1 +64901,1 @@\n-  u32 iDataVersion;  \/* Combines with pBt->pPager->iDataVersion *\/\n+  u32 iBDataVersion; \/* Combines with pBt->pPager->iDataVersion *\/\n@@ -63687,0 +64904,3 @@\n+#ifdef SQLITE_DEBUG\n+  u64 nSeek;         \/* Calls to sqlite3BtreeMovetoUnpacked() *\/\n+#endif\n@@ -63698,0 +64918,3 @@\n+**\n+** These values must match SQLITE_TXN_NONE, SQLITE_TXN_READ, and\n+** SQLITE_TXN_WRITE\n@@ -63703,0 +64926,11 @@\n+#if TRANS_NONE!=SQLITE_TXN_NONE\n+# error wrong numeric code for no-transaction\n+#endif\n+#if TRANS_READ!=SQLITE_TXN_READ\n+# error wrong numeric code for read-transaction\n+#endif\n+#if TRANS_WRITE!=SQLITE_TXN_WRITE\n+# error wrong numeric code for write-transaction\n+#endif\n+\n+\n@@ -63715,1 +64949,1 @@\n-** global SQLITE_MUTEX_STATIC_MASTER mutex.  The pPager field\n+** global SQLITE_MUTEX_STATIC_MAIN mutex.  The pPager field\n@@ -63772,0 +65006,1 @@\n+  int nPreformatSize;   \/* Size of last cell written by TransferRow() *\/\n@@ -64013,1 +65248,1 @@\n-  int mallocFailed; \/* A memory allocation error has occurred *\/\n+  int bOomFault;    \/* A memory allocation error has occurred *\/\n@@ -64015,1 +65250,2 @@\n-  int v1, v2;       \/* Values for up to two %d fields in zPfx *\/\n+  Pgno v1;          \/* Value for first %u substitution in zPfx *\/\n+  int v2;           \/* Value for second %d substitution in zPfx *\/\n@@ -64410,1 +65646,1 @@\n-** Access to this variable is protected by SQLITE_MUTEX_STATIC_MASTER.\n+** Access to this variable is protected by SQLITE_MUTEX_STATIC_MAIN.\n@@ -64453,0 +65689,11 @@\n+#ifdef SQLITE_DEBUG\n+\/*\n+** Return and reset the seek counter for a Btree object.\n+*\/\n+SQLITE_PRIVATE sqlite3_uint64 sqlite3BtreeSeekCount(Btree *pBt){\n+  u64 n =  pBt->nSeek;\n+  pBt->nSeek = 0;\n+  return n;\n+}\n+#endif\n+\n@@ -64698,1 +65945,1 @@\n-  ** by a connection in read-uncommitted mode is on the sqlite_master\n+  ** by a connection in read-uncommitted mode is on the sqlite_schema\n@@ -64877,1 +66124,1 @@\n-  if( pBtree->hasIncrblobCur==0 ) return;\n+  assert( pBtree->hasIncrblobCur );\n@@ -65157,1 +66404,2 @@\n-      goto moveto_done;\n+    }else{\n+      rc = sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes);\n@@ -65159,0 +66407,1 @@\n+    sqlite3DbFree(pCur->pKeyInfo->db, pIdxKey);\n@@ -65161,5 +66410,1 @@\n-  }\n-  rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes);\n-moveto_done:\n-  if( pIdxKey ){\n-    sqlite3DbFree(pCur->pKeyInfo->db, pIdxKey);\n+    rc = sqlite3BtreeTableMoveto(pCur, nKey, bias, pRes);\n@@ -65334,1 +66579,1 @@\n-  \/* The master-journal page number must never be used as a pointer map page *\/\n+  \/* The super-journal page number must never be used as a pointer map page *\/\n@@ -65473,0 +66718,18 @@\n+\/*\n+** Given a record with nPayload bytes of payload stored within btree\n+** page pPage, return the number of bytes of payload stored locally.\n+*\/\n+static int btreePayloadToLocal(MemPage *pPage, i64 nPayload){\n+  int maxLocal;  \/* Maximum amount of payload held locally *\/\n+  maxLocal = pPage->maxLocal;\n+  if( nPayload<=maxLocal ){\n+    return nPayload;\n+  }else{\n+    int minLocal;  \/* Minimum amount of payload held locally *\/\n+    int surplus;   \/* Overflow payload available for local storage *\/\n+    minLocal = pPage->minLocal;\n+    surplus = minLocal + (nPayload - minLocal)%(pPage->pBt->usableSize-4);\n+    return ( surplus <= maxLocal ) ? surplus : minLocal;\n+  }\n+}\n+\n@@ -65560,1 +66823,1 @@\n-  testcase( nPayload==pPage->maxLocal+1 );\n+  testcase( nPayload==(u32)pPage->maxLocal+1 );\n@@ -65597,1 +66860,1 @@\n-  testcase( nPayload==pPage->maxLocal+1 );\n+  testcase( nPayload==(u32)pPage->maxLocal+1 );\n@@ -65660,1 +66923,1 @@\n-  testcase( nSize==pPage->maxLocal+1 );\n+  testcase( nSize==(u32)pPage->maxLocal+1 );\n@@ -65668,1 +66931,1 @@\n-    testcase( nSize==pPage->maxLocal+1 );\n+    testcase( nSize==(u32)pPage->maxLocal+1 );\n@@ -65760,0 +67023,1 @@\n+  int iCellStart;            \/* First cell offset in input *\/\n@@ -65820,0 +67084,1 @@\n+  iCellStart = get2byte(&data[hdr+5]);\n@@ -65829,1 +67094,1 @@\n-    if( pc<iCellFirst || pc>iCellLast ){\n+    if( pc<iCellStart || pc>iCellLast ){\n@@ -65832,1 +67097,1 @@\n-    assert( pc>=iCellFirst && pc<=iCellLast );\n+    assert( pc>=iCellStart && pc<=iCellLast );\n@@ -65835,1 +67100,1 @@\n-    if( cbrk<iCellFirst || pc+size>usableSize ){\n+    if( cbrk<iCellStart || pc+size>usableSize ){\n@@ -65838,1 +67103,1 @@\n-    assert( cbrk+size<=usableSize && cbrk>=iCellFirst );\n+    assert( cbrk+size<=usableSize && cbrk>=iCellStart );\n@@ -65843,1 +67108,0 @@\n-      int x;\n@@ -65846,2 +67110,1 @@\n-      x = get2byte(&data[hdr+5]);\n-      memcpy(&temp[x], &data[x], (cbrk+size) - x);\n+      memcpy(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart);\n@@ -65996,1 +67259,1 @@\n-      if( NEVER(g2<=gap) ){\n+      if( g2<=gap ){\n@@ -66480,1 +67743,0 @@\n-  assert( (pBt->nPage & 0x80000000)==0 || CORRUPT_DB );\n@@ -66483,1 +67745,1 @@\n-SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree *p){\n+SQLITE_PRIVATE Pgno sqlite3BtreeLastPage(Btree *p){\n@@ -66485,1 +67747,1 @@\n-  return btreePagecount(p->pBt) & 0x7fffffff;\n+  return btreePagecount(p->pBt);\n@@ -66763,1 +68025,1 @@\n-      mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n+      mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n@@ -66882,1 +68144,1 @@\n-      MUTEX_LOGIC( mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);)\n+      MUTEX_LOGIC( mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);)\n@@ -66947,1 +68209,1 @@\n-      sqlite3PagerSetCachesize(p->pBt->pPager, SQLITE_DEFAULT_CACHE_SIZE);\n+      sqlite3BtreeSetCacheSize(p, SQLITE_DEFAULT_CACHE_SIZE);\n@@ -66971,1 +68233,1 @@\n-  MUTEX_LOGIC( sqlite3_mutex *pMaster; )\n+  MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )\n@@ -66976,2 +68238,2 @@\n-  MUTEX_LOGIC( pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )\n-  sqlite3_mutex_enter(pMaster);\n+  MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n+  sqlite3_mutex_enter(pMainMtx);\n@@ -66996,1 +68258,1 @@\n-  sqlite3_mutex_leave(pMaster);\n+  sqlite3_mutex_leave(pMainMtx);\n@@ -67050,1 +68312,0 @@\n-  BtCursor *pCur;\n@@ -67055,6 +68316,10 @@\n-  pCur = pBt->pCursor;\n-  while( pCur ){\n-    BtCursor *pTmp = pCur;\n-    pCur = pCur->pNext;\n-    if( pTmp->pBtree==p ){\n-      sqlite3BtreeCloseCursor(pTmp);\n+\n+  \/* Verify that no other cursors have this Btree open *\/\n+#ifdef SQLITE_DEBUG\n+  {\n+    BtCursor *pCur = pBt->pCursor;\n+    while( pCur ){\n+      BtCursor *pTmp = pCur;\n+      pCur = pCur->pNext;\n+      assert( pTmp->pBtree!=p );\n+\n@@ -67063,0 +68328,1 @@\n+#endif\n@@ -67214,0 +68480,1 @@\n+    if( nReserve>32 && pageSize==512 ) pageSize = 1024;\n@@ -67273,2 +68540,2 @@\n-SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){\n-  int n;\n+SQLITE_PRIVATE Pgno sqlite3BtreeMaxPageCount(Btree *p, Pgno mxPage){\n+  Pgno n;\n@@ -67405,1 +68672,0 @@\n-  u32 nPageHeader;     \/* Number of pages in the database according to hdr *\/\n@@ -67417,1 +68683,1 @@\n-  nPage = nPageHeader = get4byte(28+(u8*)pPage1->aData);\n+  nPage = get4byte(28+(u8*)pPage1->aData);\n@@ -67452,1 +68718,1 @@\n-    \/* If the write version is set to 2, this database should be accessed\n+    \/* If the read version is set to 2, this database should be accessed\n@@ -67772,1 +69038,1 @@\n-  rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK);\n+  rc = querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK);\n@@ -68227,1 +69493,1 @@\n-    if( nOrig<nFin ){\n+    if( nOrig<nFin || nFree>=nOrig ){\n@@ -68250,5 +69516,0 @@\n-**\n-** If SQLITE_OK is returned, then *pnTrunc is set to the number of pages\n-** the database file should be truncated to during the commit process.\n-** i.e. the database has been reorganized so that only the first *pnTrunc\n-** pages are in use.\n@@ -68256,1 +69517,1 @@\n-static int autoVacuumCommit(BtShared *pBt){\n+static int autoVacuumCommit(Btree *p){\n@@ -68258,2 +69519,9 @@\n-  Pager *pPager = pBt->pPager;\n-  VVA_ONLY( int nRef = sqlite3PagerRefcount(pPager); )\n+  Pager *pPager;\n+  BtShared *pBt;\n+  sqlite3 *db;\n+  VVA_ONLY( int nRef );\n+\n+  assert( p!=0 );\n+  pBt = p->pBt;\n+  pPager = pBt->pPager;\n+  VVA_ONLY( nRef = sqlite3PagerRefcount(pPager); )\n@@ -68267,0 +69535,1 @@\n+    Pgno nVac;         \/* Number of pages to vacuum *\/\n@@ -68280,1 +69549,23 @@\n-    nFin = finalDbSize(pBt, nOrig, nFree);\n+    db = p->db;\n+    if( db->xAutovacPages ){\n+      int iDb;\n+      for(iDb=0; ALWAYS(iDb<db->nDb); iDb++){\n+        if( db->aDb[iDb].pBt==p ) break;\n+      }\n+      nVac = db->xAutovacPages(\n+        db->pAutovacPagesArg,\n+        db->aDb[iDb].zDbSName,\n+        nOrig,\n+        nFree,\n+        pBt->pageSize\n+      );\n+      if( nVac>nFree ){\n+        nVac = nFree;\n+      }\n+      if( nVac==0 ){\n+        return SQLITE_OK;\n+      }\n+    }else{\n+      nVac = nFree;\n+    }\n+    nFin = finalDbSize(pBt, nOrig, nVac);\n@@ -68286,1 +69577,1 @@\n-      rc = incrVacuumStep(pBt, nFin, iFree, 1);\n+      rc = incrVacuumStep(pBt, nFin, iFree, nVac==nFree);\n@@ -68290,2 +69581,4 @@\n-      put4byte(&pBt->pPage1->aData[32], 0);\n-      put4byte(&pBt->pPage1->aData[36], 0);\n+      if( nVac==nFree ){\n+        put4byte(&pBt->pPage1->aData[32], 0);\n+        put4byte(&pBt->pPage1->aData[36], 0);\n+      }\n@@ -68324,3 +69617,3 @@\n-** Otherwise, sync the database file for the btree pBt. zMaster points to\n-** the name of a master journal file that should be written into the\n-** individual journal file, or is NULL, indicating no master journal file\n+** Otherwise, sync the database file for the btree pBt. zSuperJrnl points to\n+** the name of a super-journal file that should be written into the\n+** individual journal file, or is NULL, indicating no super-journal file\n@@ -68329,1 +69622,1 @@\n-** When this is called, the master journal should already have been\n+** When this is called, the super-journal should already have been\n@@ -68335,1 +69628,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){\n+SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zSuperJrnl){\n@@ -68342,1 +69635,1 @@\n-      rc = autoVacuumCommit(pBt);\n+      rc = autoVacuumCommit(p);\n@@ -68352,1 +69645,1 @@\n-    rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);\n+    rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zSuperJrnl, 0);\n@@ -68415,1 +69708,1 @@\n-** (by deleting a master journal file) and the caller will ignore this\n+** (by deleting a super-journal file) and the caller will ignore this\n@@ -68443,1 +69736,1 @@\n-    p->iDataVersion--;  \/* Compensate for pPager->iDataVersion++; *\/\n+    p->iBDataVersion--;  \/* Compensate for pPager->iDataVersion++; *\/\n@@ -68529,1 +69822,1 @@\n-  testcase( pBt->nPage!=nPage );\n+  testcase( pBt->nPage!=(u32)nPage );\n@@ -68713,1 +70006,1 @@\n-  int iTable,                            \/* Root page of table to open *\/\n+  Pgno iTable,                           \/* Root page of table to open *\/\n@@ -68756,1 +70049,1 @@\n-  pCur->pgnoRoot = (Pgno)iTable;\n+  pCur->pgnoRoot = iTable;\n@@ -68766,1 +70059,1 @@\n-    if( pX->pgnoRoot==(Pgno)iTable ){\n+    if( pX->pgnoRoot==iTable ){\n@@ -68778,1 +70071,1 @@\n-  int iTable,                            \/* Root page of table to open *\/\n+  Pgno iTable,                           \/* Root page of table to open *\/\n@@ -68791,1 +70084,1 @@\n-  int iTable,                                 \/* Root page of table to open *\/\n+  Pgno iTable,                                \/* Root page of table to open *\/\n@@ -68853,1 +70146,8 @@\n-    sqlite3BtreeLeave(pBtree);\n+    if( (pBt->openFlags & BTREE_SINGLE) && pBt->pCursor==0 ){\n+      \/* Since the BtShared is not sharable, there is no need to\n+      ** worry about the missing sqlite3BtreeLeave() call here.  *\/\n+      assert( pBtree->sharable==0 );\n+      sqlite3BtreeClose(pBtree);\n+    }else{\n+      sqlite3BtreeLeave(pBtree);\n+    }\n@@ -69140,1 +70440,3 @@\n-  assert( pCur->ix<pPage->nCell );\n+  if( pCur->ix>=pPage->nCell ){\n+    return SQLITE_CORRUPT_PAGE(pPage);\n+  }\n@@ -69216,0 +70518,1 @@\n+      if( nextPage > pBt->nPage ) return SQLITE_CORRUPT_BKPT;\n@@ -69326,1 +70629,0 @@\n-  assert( pCur->ix<pCur->pPage->nCell );\n@@ -69388,1 +70690,1 @@\n-  assert( pCur->ix<pCur->pPage->nCell );\n+  assert( pCur->ix<pCur->pPage->nCell || CORRUPT_DB );\n@@ -69694,1 +70996,3 @@\n-    assert( pCur->ix==pCur->pPage->nCell-1 );\n+    assert( pCur->ix==pCur->pPage->nCell-1 || CORRUPT_DB );\n+    testcase( pCur->ix!=pCur->pPage->nCell-1 );\n+    \/* ^-- dbsqlfuzz b92b72e4de80b5140c30ab71372ca719b8feb618 *\/\n@@ -69719,6 +71023,2 @@\n-\/* Move the cursor so that it points to an entry near the key\n-** specified by pIdxKey or intKey.   Return a success code.\n-**\n-** For INTKEY tables, the intKey parameter is used.  pIdxKey\n-** must be NULL.  For index tables, pIdxKey is used and intKey\n-** is ignored.\n+\/* Move the cursor so that it points to an entry in a table (a.k.a INTKEY)\n+** table near the key intKey.   Return a success code.\n@@ -69737,1 +71037,1 @@\n-**                  is smaller than intKey\/pIdxKey or if the table is empty\n+**                  is smaller than intKey or if the table is empty\n@@ -69741,1 +71041,1 @@\n-**                  exactly matches intKey\/pIdxKey.\n+**                  exactly matches intKey.\n@@ -69744,4 +71044,1 @@\n-**                  is larger than intKey\/pIdxKey.\n-**\n-** For index tables, the pIdxKey->eqSeen field is set to 1 if there\n-** exists an entry in the table that exactly matches pIdxKey.\n+**                  is larger than intKey.\n@@ -69749,1 +71046,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(\n+SQLITE_PRIVATE int sqlite3BtreeTableMoveto(\n@@ -69751,1 +71048,0 @@\n-  UnpackedRecord *pIdxKey, \/* Unpacked index key *\/\n@@ -69757,1 +71053,0 @@\n-  RecordCompare xRecordCompare;\n@@ -69762,2 +71057,2 @@\n-  assert( (pIdxKey==0)==(pCur->pKeyInfo==0) );\n-  assert( pCur->eState!=CURSOR_VALID || (pIdxKey==0)==(pCur->curIntKey!=0) );\n+  assert( pCur->pKeyInfo==0 );\n+  assert( pCur->eState!=CURSOR_VALID || pCur->curIntKey!=0 );\n@@ -69767,3 +71062,1 @@\n-  if( pIdxKey==0\n-   && pCur->eState==CURSOR_VALID && (pCur->curFlags & BTCF_ValidNKey)!=0\n-  ){\n+  if( pCur->eState==CURSOR_VALID && (pCur->curFlags & BTCF_ValidNKey)!=0 ){\n@@ -69791,3 +71084,1 @@\n-        }else if( rc==SQLITE_DONE ){\n-          rc = SQLITE_OK;\n-        }else{\n+        }else if( rc!=SQLITE_DONE ){\n@@ -69800,10 +71091,3 @@\n-  if( pIdxKey ){\n-    xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);\n-    pIdxKey->errCode = 0;\n-    assert( pIdxKey->default_rc==1\n-         || pIdxKey->default_rc==0\n-         || pIdxKey->default_rc==-1\n-    );\n-  }else{\n-    xRecordCompare = 0; \/* All keys are integers *\/\n-  }\n+#ifdef SQLITE_DEBUG\n+  pCur->pBtree->nSeek++;   \/* Performance measurement during testing *\/\n+#endif\n@@ -69825,1 +71109,2 @@\n-  assert( pCur->curIntKey || pIdxKey );\n+  assert( pCur->curIntKey );\n+\n@@ -69839,1 +71124,1 @@\n-    assert( pPage->intKey==(pIdxKey==0) );\n+    assert( pPage->intKey );\n@@ -69845,9 +71130,7 @@\n-    if( xRecordCompare==0 ){\n-      for(;;){\n-        i64 nCellKey;\n-        pCell = findCellPastPtr(pPage, idx);\n-        if( pPage->intKeyLeaf ){\n-          while( 0x80 <= *(pCell++) ){\n-            if( pCell>=pPage->aDataEnd ){\n-              return SQLITE_CORRUPT_PAGE(pPage);\n-            }\n+    for(;;){\n+      i64 nCellKey;\n+      pCell = findCellPastPtr(pPage, idx);\n+      if( pPage->intKeyLeaf ){\n+        while( 0x80 <= *(pCell++) ){\n+          if( pCell>=pPage->aDataEnd ){\n+            return SQLITE_CORRUPT_PAGE(pPage);\n@@ -69856,7 +71139,14 @@\n-        getVarint(pCell, (u64*)&nCellKey);\n-        if( nCellKey<intKey ){\n-          lwr = idx+1;\n-          if( lwr>upr ){ c = -1; break; }\n-        }else if( nCellKey>intKey ){\n-          upr = idx-1;\n-          if( lwr>upr ){ c = +1; break; }\n+      }\n+      getVarint(pCell, (u64*)&nCellKey);\n+      if( nCellKey<intKey ){\n+        lwr = idx+1;\n+        if( lwr>upr ){ c = -1; break; }\n+      }else if( nCellKey>intKey ){\n+        upr = idx-1;\n+        if( lwr>upr ){ c = +1; break; }\n+      }else{\n+        assert( nCellKey==intKey );\n+        pCur->ix = (u16)idx;\n+        if( !pPage->leaf ){\n+          lwr = idx;\n+          goto moveto_table_next_layer;\n@@ -69864,12 +71154,5 @@\n-          assert( nCellKey==intKey );\n-          pCur->ix = (u16)idx;\n-          if( !pPage->leaf ){\n-            lwr = idx;\n-            goto moveto_next_layer;\n-          }else{\n-            pCur->curFlags |= BTCF_ValidNKey;\n-            pCur->info.nKey = nCellKey;\n-            pCur->info.nSize = 0;\n-            *pRes = 0;\n-            return SQLITE_OK;\n-          }\n+          pCur->curFlags |= BTCF_ValidNKey;\n+          pCur->info.nKey = nCellKey;\n+          pCur->info.nSize = 0;\n+          *pRes = 0;\n+          return SQLITE_OK;\n@@ -69877,2 +71160,0 @@\n-        assert( lwr+upr>=0 );\n-        idx = (lwr+upr)>>1;  \/* idx = (lwr+upr)\/2; *\/\n@@ -69880,0 +71161,15 @@\n+      assert( lwr+upr>=0 );\n+      idx = (lwr+upr)>>1;  \/* idx = (lwr+upr)\/2; *\/\n+    }\n+    assert( lwr==upr+1 || !pPage->leaf );\n+    assert( pPage->isInit );\n+    if( pPage->leaf ){\n+      assert( pCur->ix<pCur->pPage->nCell );\n+      pCur->ix = (u16)idx;\n+      *pRes = c;\n+      rc = SQLITE_OK;\n+      goto moveto_table_finish;\n+    }\n+moveto_table_next_layer:\n+    if( lwr>=pPage->nCell ){\n+      chldPg = get4byte(&pPage->aData[pPage->hdrOffset+8]);\n@@ -69881,64 +71177,148 @@\n-      for(;;){\n-        int nCell;  \/* Size of the pCell cell in bytes *\/\n-        pCell = findCellPastPtr(pPage, idx);\n-\n-        \/* The maximum supported page-size is 65536 bytes. This means that\n-        ** the maximum number of record bytes stored on an index B-Tree\n-        ** page is less than 16384 bytes and may be stored as a 2-byte\n-        ** varint. This information is used to attempt to avoid parsing\n-        ** the entire cell by checking for the cases where the record is\n-        ** stored entirely within the b-tree page by inspecting the first\n-        ** 2 bytes of the cell.\n-        *\/\n-        nCell = pCell[0];\n-        if( nCell<=pPage->max1bytePayload ){\n-          \/* This branch runs if the record-size field of the cell is a\n-          ** single byte varint and the record fits entirely on the main\n-          ** b-tree page.  *\/\n-          testcase( pCell+nCell+1==pPage->aDataEnd );\n-          c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);\n-        }else if( !(pCell[1] & 0x80)\n-          && (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal\n-        ){\n-          \/* The record-size field is a 2 byte varint and the record\n-          ** fits entirely on the main b-tree page.  *\/\n-          testcase( pCell+nCell+2==pPage->aDataEnd );\n-          c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);\n-        }else{\n-          \/* The record flows over onto one or more overflow pages. In\n-          ** this case the whole cell needs to be parsed, a buffer allocated\n-          ** and accessPayload() used to retrieve the record into the\n-          ** buffer before VdbeRecordCompare() can be called.\n-          **\n-          ** If the record is corrupt, the xRecordCompare routine may read\n-          ** up to two varints past the end of the buffer. An extra 18\n-          ** bytes of padding is allocated at the end of the buffer in\n-          ** case this happens.  *\/\n-          void *pCellKey;\n-          u8 * const pCellBody = pCell - pPage->childPtrSize;\n-          const int nOverrun = 18;  \/* Size of the overrun padding *\/\n-          pPage->xParseCell(pPage, pCellBody, &pCur->info);\n-          nCell = (int)pCur->info.nKey;\n-          testcase( nCell<0 );   \/* True if key size is 2^32 or more *\/\n-          testcase( nCell==0 );  \/* Invalid key size:  0x80 0x80 0x00 *\/\n-          testcase( nCell==1 );  \/* Invalid key size:  0x80 0x80 0x01 *\/\n-          testcase( nCell==2 );  \/* Minimum legal index key size *\/\n-          if( nCell<2 || nCell\/pCur->pBt->usableSize>pCur->pBt->nPage ){\n-            rc = SQLITE_CORRUPT_PAGE(pPage);\n-            goto moveto_finish;\n-          }\n-          pCellKey = sqlite3Malloc( nCell+nOverrun );\n-          if( pCellKey==0 ){\n-            rc = SQLITE_NOMEM_BKPT;\n-            goto moveto_finish;\n-          }\n-          pCur->ix = (u16)idx;\n-          rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);\n-          memset(((u8*)pCellKey)+nCell,0,nOverrun); \/* Fix uninit warnings *\/\n-          pCur->curFlags &= ~BTCF_ValidOvfl;\n-          if( rc ){\n-            sqlite3_free(pCellKey);\n-            goto moveto_finish;\n-          }\n-          c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);\n-          sqlite3_free(pCellKey);\n+      chldPg = get4byte(findCell(pPage, lwr));\n+    }\n+    pCur->ix = (u16)lwr;\n+    rc = moveToChild(pCur, chldPg);\n+    if( rc ) break;\n+  }\n+moveto_table_finish:\n+  pCur->info.nSize = 0;\n+  assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );\n+  return rc;\n+}\n+\n+\/* Move the cursor so that it points to an entry in an index table\n+** near the key pIdxKey.   Return a success code.\n+**\n+** If an exact match is not found, then the cursor is always\n+** left pointing at a leaf page which would hold the entry if it\n+** were present.  The cursor might point to an entry that comes\n+** before or after the key.\n+**\n+** An integer is written into *pRes which is the result of\n+** comparing the key with the entry to which the cursor is\n+** pointing.  The meaning of the integer written into\n+** *pRes is as follows:\n+**\n+**     *pRes<0      The cursor is left pointing at an entry that\n+**                  is smaller than pIdxKey or if the table is empty\n+**                  and the cursor is therefore left point to nothing.\n+**\n+**     *pRes==0     The cursor is left pointing at an entry that\n+**                  exactly matches pIdxKey.\n+**\n+**     *pRes>0      The cursor is left pointing at an entry that\n+**                  is larger than pIdxKey.\n+**\n+** The pIdxKey->eqSeen field is set to 1 if there\n+** exists an entry in the table that exactly matches pIdxKey.\n+*\/\n+SQLITE_PRIVATE int sqlite3BtreeIndexMoveto(\n+  BtCursor *pCur,          \/* The cursor to be moved *\/\n+  UnpackedRecord *pIdxKey, \/* Unpacked index key *\/\n+  int *pRes                \/* Write search results here *\/\n+){\n+  int rc;\n+  RecordCompare xRecordCompare;\n+\n+  assert( cursorOwnsBtShared(pCur) );\n+  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );\n+  assert( pRes );\n+  assert( pCur->pKeyInfo!=0 );\n+\n+#ifdef SQLITE_DEBUG\n+  pCur->pBtree->nSeek++;   \/* Performance measurement during testing *\/\n+#endif\n+\n+  xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);\n+  pIdxKey->errCode = 0;\n+  assert( pIdxKey->default_rc==1\n+       || pIdxKey->default_rc==0\n+       || pIdxKey->default_rc==-1\n+  );\n+\n+  rc = moveToRoot(pCur);\n+  if( rc ){\n+    if( rc==SQLITE_EMPTY ){\n+      assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );\n+      *pRes = -1;\n+      return SQLITE_OK;\n+    }\n+    return rc;\n+  }\n+  assert( pCur->pPage );\n+  assert( pCur->pPage->isInit );\n+  assert( pCur->eState==CURSOR_VALID );\n+  assert( pCur->pPage->nCell > 0 );\n+  assert( pCur->iPage==0 || pCur->apPage[0]->intKey==pCur->curIntKey );\n+  assert( pCur->curIntKey || pIdxKey );\n+  for(;;){\n+    int lwr, upr, idx, c;\n+    Pgno chldPg;\n+    MemPage *pPage = pCur->pPage;\n+    u8 *pCell;                          \/* Pointer to current cell in pPage *\/\n+\n+    \/* pPage->nCell must be greater than zero. If this is the root-page\n+    ** the cursor would have been INVALID above and this for(;;) loop\n+    ** not run. If this is not the root-page, then the moveToChild() routine\n+    ** would have already detected db corruption. Similarly, pPage must\n+    ** be the right kind (index or table) of b-tree page. Otherwise\n+    ** a moveToChild() or moveToRoot() call would have detected corruption.  *\/\n+    assert( pPage->nCell>0 );\n+    assert( pPage->intKey==(pIdxKey==0) );\n+    lwr = 0;\n+    upr = pPage->nCell-1;\n+    idx = upr>>1; \/* idx = (lwr+upr)\/2; *\/\n+    pCur->ix = (u16)idx;\n+    for(;;){\n+      int nCell;  \/* Size of the pCell cell in bytes *\/\n+      pCell = findCellPastPtr(pPage, idx);\n+\n+      \/* The maximum supported page-size is 65536 bytes. This means that\n+      ** the maximum number of record bytes stored on an index B-Tree\n+      ** page is less than 16384 bytes and may be stored as a 2-byte\n+      ** varint. This information is used to attempt to avoid parsing\n+      ** the entire cell by checking for the cases where the record is\n+      ** stored entirely within the b-tree page by inspecting the first\n+      ** 2 bytes of the cell.\n+      *\/\n+      nCell = pCell[0];\n+      if( nCell<=pPage->max1bytePayload ){\n+        \/* This branch runs if the record-size field of the cell is a\n+        ** single byte varint and the record fits entirely on the main\n+        ** b-tree page.  *\/\n+        testcase( pCell+nCell+1==pPage->aDataEnd );\n+        c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);\n+      }else if( !(pCell[1] & 0x80)\n+        && (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal\n+      ){\n+        \/* The record-size field is a 2 byte varint and the record\n+        ** fits entirely on the main b-tree page.  *\/\n+        testcase( pCell+nCell+2==pPage->aDataEnd );\n+        c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);\n+      }else{\n+        \/* The record flows over onto one or more overflow pages. In\n+        ** this case the whole cell needs to be parsed, a buffer allocated\n+        ** and accessPayload() used to retrieve the record into the\n+        ** buffer before VdbeRecordCompare() can be called.\n+        **\n+        ** If the record is corrupt, the xRecordCompare routine may read\n+        ** up to two varints past the end of the buffer. An extra 18\n+        ** bytes of padding is allocated at the end of the buffer in\n+        ** case this happens.  *\/\n+        void *pCellKey;\n+        u8 * const pCellBody = pCell - pPage->childPtrSize;\n+        const int nOverrun = 18;  \/* Size of the overrun padding *\/\n+        pPage->xParseCell(pPage, pCellBody, &pCur->info);\n+        nCell = (int)pCur->info.nKey;\n+        testcase( nCell<0 );   \/* True if key size is 2^32 or more *\/\n+        testcase( nCell==0 );  \/* Invalid key size:  0x80 0x80 0x00 *\/\n+        testcase( nCell==1 );  \/* Invalid key size:  0x80 0x80 0x01 *\/\n+        testcase( nCell==2 );  \/* Minimum legal index key size *\/\n+        if( nCell<2 || nCell\/pCur->pBt->usableSize>pCur->pBt->nPage ){\n+          rc = SQLITE_CORRUPT_PAGE(pPage);\n+          goto moveto_index_finish;\n+        }\n+        pCellKey = sqlite3Malloc( nCell+nOverrun );\n+        if( pCellKey==0 ){\n+          rc = SQLITE_NOMEM_BKPT;\n+          goto moveto_index_finish;\n@@ -69946,15 +71326,7 @@\n-        assert(\n-            (pIdxKey->errCode!=SQLITE_CORRUPT || c==0)\n-         && (pIdxKey->errCode!=SQLITE_NOMEM || pCur->pBtree->db->mallocFailed)\n-        );\n-        if( c<0 ){\n-          lwr = idx+1;\n-        }else if( c>0 ){\n-          upr = idx-1;\n-        }else{\n-          assert( c==0 );\n-          *pRes = 0;\n-          rc = SQLITE_OK;\n-          pCur->ix = (u16)idx;\n-          if( pIdxKey->errCode ) rc = SQLITE_CORRUPT_BKPT;\n-          goto moveto_finish;\n+        pCur->ix = (u16)idx;\n+        rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);\n+        memset(((u8*)pCellKey)+nCell,0,nOverrun); \/* Fix uninit warnings *\/\n+        pCur->curFlags &= ~BTCF_ValidOvfl;\n+        if( rc ){\n+          sqlite3_free(pCellKey);\n+          goto moveto_index_finish;\n@@ -69962,3 +71334,18 @@\n-        if( lwr>upr ) break;\n-        assert( lwr+upr>=0 );\n-        idx = (lwr+upr)>>1;  \/* idx = (lwr+upr)\/2 *\/\n+        c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);\n+        sqlite3_free(pCellKey);\n+      }\n+      assert(\n+          (pIdxKey->errCode!=SQLITE_CORRUPT || c==0)\n+       && (pIdxKey->errCode!=SQLITE_NOMEM || pCur->pBtree->db->mallocFailed)\n+      );\n+      if( c<0 ){\n+        lwr = idx+1;\n+      }else if( c>0 ){\n+        upr = idx-1;\n+      }else{\n+        assert( c==0 );\n+        *pRes = 0;\n+        rc = SQLITE_OK;\n+        pCur->ix = (u16)idx;\n+        if( pIdxKey->errCode ) rc = SQLITE_CORRUPT_BKPT;\n+        goto moveto_index_finish;\n@@ -69966,0 +71353,3 @@\n+      if( lwr>upr ) break;\n+      assert( lwr+upr>=0 );\n+      idx = (lwr+upr)>>1;  \/* idx = (lwr+upr)\/2 *\/\n@@ -69974,1 +71364,1 @@\n-      goto moveto_finish;\n+      goto moveto_index_finish;\n@@ -69976,1 +71366,0 @@\n-moveto_next_layer:\n@@ -69986,1 +71375,1 @@\n-moveto_finish:\n+moveto_index_finish:\n@@ -70076,1 +71465,1 @@\n-  if( !pPage->isInit ){\n+  if( !pPage->isInit || sqlite3FaultSim(412) ){\n@@ -70087,10 +71476,0 @@\n-  \/* If the database file is corrupt, it is possible for the value of idx\n-  ** to be invalid here. This can only occur if a second cursor modifies\n-  ** the page while cursor pCur is holding a reference to it. Which can\n-  ** only happen if the database is corrupt in such a way as to link the\n-  ** page into more than one b-tree structure.\n-  **\n-  ** Update 2019-12-23: appears to long longer be possible after the\n-  ** addition of anotherValidCursor() condition on balance_deeper().  *\/\n-  harmless( idx>pPage->nCell );\n-\n@@ -70457,1 +71836,1 @@\n-        if( iPage>mxPage ){\n+        if( iPage>mxPage || iPage<2 ){\n@@ -70584,1 +71963,1 @@\n-  if( iPage<2 || iPage>pBt->nPage ){\n+  if( NEVER(iPage<2) || iPage>pBt->nPage ){\n@@ -70631,0 +72010,4 @@\n+    if( iTrunk>btreePagecount(pBt) ){\n+      rc = SQLITE_CORRUPT_BKPT;\n+      goto freepage_out;\n+    }\n@@ -70709,2 +72092,1 @@\n-** Free any overflow pages associated with the given Cell.  Store\n-** size information about the cell in pInfo.\n+** Free the overflow pages associated with the given Cell.\n@@ -70712,1 +72094,1 @@\n-static int clearCell(\n+static SQLITE_NOINLINE int clearCellOverflow(\n@@ -70724,4 +72106,1 @@\n-  pPage->xParseCell(pPage, pCell, pInfo);\n-  if( pInfo->nLocal==pInfo->nPayload ){\n-    return SQLITE_OK;  \/* No overflow pages. Return without doing anything *\/\n-  }\n+  assert( pInfo->nLocal!=pInfo->nPayload );\n@@ -70783,0 +72162,15 @@\n+\/* Call xParseCell to compute the size of a cell.  If the cell contains\n+** overflow, then invoke cellClearOverflow to clear out that overflow.\n+** STore the result code (SQLITE_OK or some error code) in rc.\n+**\n+** Implemented as macro to force inlining for performance.\n+*\/\n+#define BTREE_CLEAR_CELL(rc, pPage, pCell, sInfo)   \\\n+  pPage->xParseCell(pPage, pCell, &sInfo);          \\\n+  if( sInfo.nLocal!=sInfo.nPayload ){               \\\n+    rc = clearCellOverflow(pPage, pCell, &sInfo);   \\\n+  }else{                                            \\\n+    rc = SQLITE_OK;                                 \\\n+  }\n+\n+\n@@ -70993,1 +72387,2 @@\n-  assert( idx>=0 && idx<pPage->nCell );\n+  assert( idx>=0 );\n+  assert( idx<pPage->nCell );\n@@ -71000,0 +72395,1 @@\n+  assert( pPage->pBt->usableSize > (int)(ptr-data) );\n@@ -71002,1 +72398,1 @@\n-  testcase( pc==get2byte(&data[hdr+5]) );\n+  testcase( pc==(u32)get2byte(&data[hdr+5]) );\n@@ -71294,1 +72690,1 @@\n-  if( NEVER(j>(u32)usableSize) ){ j = 0; }\n+  if( j>(u32)usableSize ){ j = 0; }\n@@ -71305,1 +72701,1 @@\n-    if( SQLITE_WITHIN(pCell,aData,pEnd) ){\n+    if( SQLITE_WITHIN(pCell,aData+j,pEnd) ){\n@@ -71318,1 +72714,1 @@\n-    memcpy(pData, pCell, sz);\n+    memmove(pData, pCell, sz);\n@@ -71320,1 +72716,0 @@\n-    testcase( sz!=pPg->xCellSize(pPg,pCell) )\n@@ -71459,1 +72854,3 @@\n-        if( pFree+sz>pEnd ) return 0;\n+        if( pFree+sz>pEnd ){\n+          return 0;\n+        }\n@@ -71524,0 +72921,1 @@\n+  if( pData>pPg->aDataEnd ) goto editpage_fail;\n@@ -71885,1 +73283,1 @@\n-  CellArray b;                  \/* Parsed information on cells being balanced *\/\n+  CellArray b;                 \/* Parsed information on cells being balanced *\/\n@@ -71888,2 +73286,1 @@\n-  b.nCell = 0;\n-  b.apCell = 0;\n+  memset(&b, 0, sizeof(b));\n@@ -71940,1 +73337,3 @@\n-    rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);\n+    if( rc==SQLITE_OK ){\n+      rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);\n+    }\n@@ -71952,0 +73351,1 @@\n+    nMaxCells += apOld[i]->nCell + ArraySize(pParent->apOvfl);\n@@ -71979,0 +73379,2 @@\n+        \/* If the following if() condition is not true, the db is corrupted.\n+        ** The call to dropCell() below will detect this.  *\/\n@@ -71980,5 +73382,1 @@\n-        if( (iOff+szNew[i])>(int)pBt->usableSize ){\n-          rc = SQLITE_CORRUPT_BKPT;\n-          memset(apOld, 0, (i+1)*sizeof(MemPage*));\n-          goto balance_cleanup;\n-        }else{\n+        if( (iOff+szNew[i])<=(int)pBt->usableSize ){\n@@ -71995,1 +73393,0 @@\n-  nMaxCells = nOld*(MX_CELL(pBt) + ArraySize(pParent->apOvfl));\n@@ -72112,1 +73509,1 @@\n-        assert( pOld->hdrOffset==0 );\n+        assert( pOld->hdrOffset==0 || CORRUPT_DB );\n@@ -72278,0 +73675,5 @@\n+      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv))\n+       && rc==SQLITE_OK\n+      ){\n+        rc = SQLITE_CORRUPT_BKPT;\n+      }\n@@ -72314,1 +73716,1 @@\n-      if( aPgno[j]==aPgno[i] ){\n+      if( NEVER(aPgno[j]==aPgno[i]) ){\n@@ -72432,0 +73834,1 @@\n+    u8 *pSrcEnd;\n@@ -72475,0 +73878,6 @@\n+    for(k=0; b.ixNx[k]<=i && ALWAYS(k<NB*2); k++){}\n+    pSrcEnd = b.apEnd[k];\n+    if( SQLITE_WITHIN(pSrcEnd, pCell, pCell+sz) ){\n+      rc = SQLITE_CORRUPT_BKPT;\n+      goto balance_cleanup;\n+    }\n@@ -72688,1 +74097,1 @@\n-** This can if a database is corrupt with two or more SQL tables\n+** This can occur if a database is corrupt with two or more SQL tables\n@@ -72917,1 +74326,1 @@\n-    if( sqlite3PagerPageRefcount(pPage->pDbPage)!=1 ){\n+    if( sqlite3PagerPageRefcount(pPage->pDbPage)!=1 || pPage->isInit ){\n@@ -72982,1 +74391,2 @@\n-  assert( (flags & (BTREE_SAVEPOSITION|BTREE_APPEND))==flags );\n+  assert( (flags & (BTREE_SAVEPOSITION|BTREE_APPEND|BTREE_PREFORMAT))==flags );\n+  assert( (flags & BTREE_PREFORMAT)==0 || seekResult || pCur->pKeyInfo==0 );\n@@ -73000,1 +74410,1 @@\n-  assert( (pX->pKey==0)==(pCur->pKeyInfo==0) );\n+  assert( (flags & BTREE_PREFORMAT) || (pX->pKey==0)==(pCur->pKeyInfo==0) );\n@@ -73016,0 +74426,8 @@\n+    if( loc && pCur->iPage<0 ){\n+      \/* This can only happen if the schema is corrupt such that there is more\n+      ** than one table or index with the same root page as used by the cursor.\n+      ** Which can only happen if the SQLITE_NoSchemaError flag was set when\n+      ** the schema was loaded. This cannot be asserted though, as a user might\n+      ** set the flag, load the schema, and then unset the flag.  *\/\n+      return SQLITE_CORRUPT_BKPT;\n+    }\n@@ -73022,1 +74440,3 @@\n-    invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);\n+    if( p->hasIncrblobCur ){\n+      invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);\n+    }\n@@ -73055,1 +74475,2 @@\n-      rc = sqlite3BtreeMovetoUnpacked(pCur, 0, pX->nKey, flags!=0, &loc);\n+      rc = sqlite3BtreeTableMoveto(pCur, pX->nKey,\n+               (flags & BTREE_APPEND)!=0, &loc);\n@@ -73078,3 +74499,0 @@\n-        r.errCode = 0;\n-        r.r1 = 0;\n-        r.r2 = 0;\n@@ -73082,1 +74500,1 @@\n-        rc = sqlite3BtreeMovetoUnpacked(pCur, &r, 0, flags!=0, &loc);\n+        rc = sqlite3BtreeIndexMoveto(pCur, &r, &loc);\n@@ -73084,1 +74502,2 @@\n-        rc = btreeMoveto(pCur, pX->pKey, pX->nKey, flags!=0, &loc);\n+        rc = btreeMoveto(pCur, pX->pKey, pX->nKey,\n+                    (flags & BTREE_APPEND)!=0, &loc);\n@@ -73103,1 +74522,0 @@\n-\n@@ -73110,1 +74528,1 @@\n-  assert( pPage->intKey || pX->nKey>=0 );\n+  assert( pPage->intKey || pX->nKey>=0 || (flags & BTREE_PREFORMAT) );\n@@ -73113,1 +74531,5 @@\n-    rc = btreeComputeFreeSpace(pPage);\n+    if( NEVER(pCur->eState>CURSOR_INVALID) ){\n+      rc = SQLITE_CORRUPT_BKPT;\n+    }else{\n+      rc = btreeComputeFreeSpace(pPage);\n+    }\n@@ -73123,1 +74545,15 @@\n-  rc = fillInCell(pPage, newCell, pX, &szNew);\n+  if( flags & BTREE_PREFORMAT ){\n+    rc = SQLITE_OK;\n+    szNew = pBt->nPreformatSize;\n+    if( szNew<4 ) szNew = 4;\n+    if( ISAUTOVACUUM && szNew>pPage->maxLocal ){\n+      CellInfo info;\n+      pPage->xParseCell(pPage, newCell, &info);\n+      if( info.nPayload!=info.nLocal ){\n+        Pgno ovfl = get4byte(&newCell[szNew-4]);\n+        ptrmapPut(pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, &rc);\n+      }\n+    }\n+  }else{\n+    rc = fillInCell(pPage, newCell, pX, &szNew);\n+  }\n@@ -73130,1 +74566,4 @@\n-    assert( idx<pPage->nCell );\n+    assert( idx>=0 );\n+    if( idx>=pPage->nCell ){\n+      return SQLITE_CORRUPT_BKPT;\n+    }\n@@ -73139,1 +74578,1 @@\n-    rc = clearCell(pPage, oldCell, &info);\n+    BTREE_CLEAR_CELL(rc, pPage, oldCell, info);\n@@ -73230,0 +74669,108 @@\n+\/*\n+** This function is used as part of copying the current row from cursor\n+** pSrc into cursor pDest. If the cursors are open on intkey tables, then\n+** parameter iKey is used as the rowid value when the record is copied\n+** into pDest. Otherwise, the record is copied verbatim.\n+**\n+** This function does not actually write the new value to cursor pDest.\n+** Instead, it creates and populates any required overflow pages and\n+** writes the data for the new cell into the BtShared.pTmpSpace buffer\n+** for the destination database. The size of the cell, in bytes, is left\n+** in BtShared.nPreformatSize. The caller completes the insertion by\n+** calling sqlite3BtreeInsert() with the BTREE_PREFORMAT flag specified.\n+**\n+** SQLITE_OK is returned if successful, or an SQLite error code otherwise.\n+*\/\n+SQLITE_PRIVATE int sqlite3BtreeTransferRow(BtCursor *pDest, BtCursor *pSrc, i64 iKey){\n+  int rc = SQLITE_OK;\n+  BtShared *pBt = pDest->pBt;\n+  u8 *aOut = pBt->pTmpSpace;    \/* Pointer to next output buffer *\/\n+  const u8 *aIn;                \/* Pointer to next input buffer *\/\n+  u32 nIn;                      \/* Size of input buffer aIn[] *\/\n+  u32 nRem;                     \/* Bytes of data still to copy *\/\n+\n+  getCellInfo(pSrc);\n+  aOut += putVarint32(aOut, pSrc->info.nPayload);\n+  if( pDest->pKeyInfo==0 ) aOut += putVarint(aOut, iKey);\n+  nIn = pSrc->info.nLocal;\n+  aIn = pSrc->info.pPayload;\n+  if( aIn+nIn>pSrc->pPage->aDataEnd ){\n+    return SQLITE_CORRUPT_BKPT;\n+  }\n+  nRem = pSrc->info.nPayload;\n+  if( nIn==nRem && nIn<pDest->pPage->maxLocal ){\n+    memcpy(aOut, aIn, nIn);\n+    pBt->nPreformatSize = nIn + (aOut - pBt->pTmpSpace);\n+  }else{\n+    Pager *pSrcPager = pSrc->pBt->pPager;\n+    u8 *pPgnoOut = 0;\n+    Pgno ovflIn = 0;\n+    DbPage *pPageIn = 0;\n+    MemPage *pPageOut = 0;\n+    u32 nOut;                     \/* Size of output buffer aOut[] *\/\n+\n+    nOut = btreePayloadToLocal(pDest->pPage, pSrc->info.nPayload);\n+    pBt->nPreformatSize = nOut + (aOut - pBt->pTmpSpace);\n+    if( nOut<pSrc->info.nPayload ){\n+      pPgnoOut = &aOut[nOut];\n+      pBt->nPreformatSize += 4;\n+    }\n+\n+    if( nRem>nIn ){\n+      if( aIn+nIn+4>pSrc->pPage->aDataEnd ){\n+        return SQLITE_CORRUPT_BKPT;\n+      }\n+      ovflIn = get4byte(&pSrc->info.pPayload[nIn]);\n+    }\n+\n+    do {\n+      nRem -= nOut;\n+      do{\n+        assert( nOut>0 );\n+        if( nIn>0 ){\n+          int nCopy = MIN(nOut, nIn);\n+          memcpy(aOut, aIn, nCopy);\n+          nOut -= nCopy;\n+          nIn -= nCopy;\n+          aOut += nCopy;\n+          aIn += nCopy;\n+        }\n+        if( nOut>0 ){\n+          sqlite3PagerUnref(pPageIn);\n+          pPageIn = 0;\n+          rc = sqlite3PagerGet(pSrcPager, ovflIn, &pPageIn, PAGER_GET_READONLY);\n+          if( rc==SQLITE_OK ){\n+            aIn = (const u8*)sqlite3PagerGetData(pPageIn);\n+            ovflIn = get4byte(aIn);\n+            aIn += 4;\n+            nIn = pSrc->pBt->usableSize - 4;\n+          }\n+        }\n+      }while( rc==SQLITE_OK && nOut>0 );\n+\n+      if( rc==SQLITE_OK && nRem>0 && ALWAYS(pPgnoOut) ){\n+        Pgno pgnoNew;\n+        MemPage *pNew = 0;\n+        rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);\n+        put4byte(pPgnoOut, pgnoNew);\n+        if( ISAUTOVACUUM && pPageOut ){\n+          ptrmapPut(pBt, pgnoNew, PTRMAP_OVERFLOW2, pPageOut->pgno, &rc);\n+        }\n+        releasePage(pPageOut);\n+        pPageOut = pNew;\n+        if( pPageOut ){\n+          pPgnoOut = pPageOut->aData;\n+          put4byte(pPgnoOut, 0);\n+          aOut = &pPgnoOut[4];\n+          nOut = MIN(pBt->usableSize - 4, nRem);\n+        }\n+      }\n+    }while( nRem>0 && rc==SQLITE_OK );\n+\n+    releasePage(pPageOut);\n+    sqlite3PagerUnref(pPageIn);\n+  }\n+\n+  return rc;\n+}\n+\n@@ -73268,1 +74815,2 @@\n-    if( rc ) return rc;\n+    assert( rc!=SQLITE_OK || CORRUPT_DB || pCur->eState==CURSOR_VALID );\n+    if( rc || pCur->eState!=CURSOR_VALID ) return rc;\n@@ -73270,1 +74818,1 @@\n-  assert( pCur->eState==CURSOR_VALID );\n+  assert( CORRUPT_DB || pCur->eState==CURSOR_VALID );\n@@ -73276,1 +74824,6 @@\n-  if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ) return SQLITE_CORRUPT;\n+  if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ){\n+    return SQLITE_CORRUPT_BKPT;\n+  }\n+  if( pPage->nCell<=iCellIdx ){\n+    return SQLITE_CORRUPT_BKPT;\n+  }\n@@ -73323,1 +74876,1 @@\n-  if( pCur->pKeyInfo==0 ){\n+  if( pCur->pKeyInfo==0 && p->hasIncrblobCur ){\n@@ -73332,1 +74885,1 @@\n-  rc = clearCell(pPage, pCell, &info);\n+  BTREE_CLEAR_CELL(rc, pPage, pCell, info);\n@@ -73431,1 +74984,1 @@\n-static int btreeCreateTable(Btree *p, int *piTable, int createTabFlags){\n+static int btreeCreateTable(Btree *p, Pgno *piTable, int createTabFlags){\n@@ -73464,0 +75017,3 @@\n+    if( pgnoRoot>btreePagecount(pBt) ){\n+      return SQLITE_CORRUPT_BKPT;\n+    }\n@@ -73473,2 +75029,1 @@\n-    assert( pgnoRoot>=3 || CORRUPT_DB );\n-    testcase( pgnoRoot<3 );\n+    assert( pgnoRoot>=3 );\n@@ -73571,1 +75126,1 @@\n-  *piTable = (int)pgnoRoot;\n+  *piTable = pgnoRoot;\n@@ -73574,1 +75129,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){\n+SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree *p, Pgno *piTable, int flags){\n@@ -73590,1 +75145,1 @@\n-  int *pnChange            \/* Add number of Cells freed to this counter *\/\n+  i64 *pnChange            \/* Add number of Cells freed to this counter *\/\n@@ -73605,1 +75160,3 @@\n-  if( pPage->bBusy ){\n+  if( (pBt->openFlags & BTREE_SINGLE)==0\n+   && sqlite3PagerPageRefcount(pPage->pDbPage)!=1\n+  ){\n@@ -73609,1 +75166,0 @@\n-  pPage->bBusy = 1;\n@@ -73617,1 +75173,1 @@\n-    rc = clearCell(pPage, pCell, &info);\n+    BTREE_CLEAR_CELL(rc, pPage, pCell, info);\n@@ -73623,2 +75179,3 @@\n-  }else if( pnChange ){\n-    assert( pPage->intKey || CORRUPT_DB );\n+    if( pPage->intKey ) pnChange = 0;\n+  }\n+  if( pnChange ){\n@@ -73635,1 +75192,0 @@\n-  pPage->bBusy = 0;\n@@ -73649,3 +75205,2 @@\n-** If pnChange is not NULL, then table iTable must be an intkey table. The\n-** integer value pointed to by pnChange is incremented by the number of\n-** entries in the table.\n+** If pnChange is not NULL, then the integer value pointed to by pnChange\n+** is incremented by the number of entries in the table.\n@@ -73653,1 +75208,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange){\n+SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree *p, int iTable, i64 *pnChange){\n@@ -73665,1 +75220,3 @@\n-    invalidateIncrblobCursors(p, (Pgno)iTable, 0, 1);\n+    if( p->hasIncrblobCur ){\n+      invalidateIncrblobCursors(p, (Pgno)iTable, 0, 1);\n+    }\n@@ -73713,2 +75270,0 @@\n-  rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);\n-  if( rc ) return rc;\n@@ -73716,1 +75271,3 @@\n-  if( rc ){\n+  if( rc ) return rc;\n+  rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);\n+  if( NEVER(rc) ){\n@@ -73820,1 +75377,1 @@\n-  assert( SQLITE_OK==querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK) );\n+  assert( SQLITE_OK==querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK) );\n@@ -73825,1 +75382,1 @@\n-    *pMeta = sqlite3PagerDataVersion(pBt->pPager) + p->iDataVersion;\n+    *pMeta = sqlite3PagerDataVersion(pBt->pPager) + p->iBDataVersion;\n@@ -73973,1 +75530,1 @@\n-    pCheck->mallocFailed = 1;\n+    pCheck->bOomFault = 1;\n@@ -74038,1 +75595,1 @@\n-    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;\n+    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->bOomFault = 1;\n@@ -74058,1 +75615,1 @@\n-  int iPage,            \/* Page number for first page in the list *\/\n+  Pgno iPage,           \/* Page number for first page in the list *\/\n@@ -74190,1 +75747,1 @@\n-  int iPage,            \/* Page number of the page to check *\/\n+  Pgno iPage,           \/* Page number of the page to check *\/\n@@ -74226,1 +75783,1 @@\n-  pCheck->zPfx = \"Page %d: \";\n+  pCheck->zPfx = \"Page %u: \";\n@@ -74228,1 +75785,1 @@\n-  if( (rc = btreeGetPage(pBt, (Pgno)iPage, &pPage, 0))!=0 ){\n+  if( (rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0 ){\n@@ -74253,1 +75810,1 @@\n-  pCheck->zPfx = \"On tree page %d cell %d: \";\n+  pCheck->zPfx = \"On tree page %u cell %d: \";\n@@ -74273,1 +75830,1 @@\n-      pCheck->zPfx = \"On page %d at right child: \";\n+      pCheck->zPfx = \"On page %u at right child: \";\n@@ -74414,1 +75971,1 @@\n-          \"Multiple uses for byte %u of page %d\", x>>16, iPage);\n+          \"Multiple uses for byte %u of page %u\", x>>16, iPage);\n@@ -74429,1 +75986,1 @@\n-          \"Fragmentation of %d bytes reported as %d on page %d\",\n+          \"Fragmentation of %d bytes reported as %d on page %u\",\n@@ -74457,0 +76014,9 @@\n+**\n+** If the first entry in aRoot[] is 0, that indicates that the list of\n+** root pages is incomplete.  This is a \"partial integrity-check\".  This\n+** happens when performing an integrity check on a single table.  The\n+** zero is skipped, of course.  But in addition, the freelist checks\n+** and the checks to make sure every page is referenced are also skipped,\n+** since obviously it is not possible to know which pages are covered by\n+** the unverified btrees.  Except, if aRoot[1] is 1, then the freelist\n+** checks are still performed.\n@@ -74461,1 +76027,1 @@\n-  int *aRoot,   \/* An array of root pages numbers for individual trees *\/\n+  Pgno *aRoot,  \/* An array of root pages numbers for individual trees *\/\n@@ -74471,0 +76037,2 @@\n+  int bPartial = 0;            \/* True if not checking all btrees *\/\n+  int bCkFreelist = 1;         \/* True to scan the freelist *\/\n@@ -74472,0 +76040,8 @@\n+  assert( nRoot>0 );\n+\n+  \/* aRoot[0]==0 means this is a partial check *\/\n+  if( aRoot[0]==0 ){\n+    assert( nRoot>1 );\n+    bPartial = 1;\n+    if( aRoot[1]!=1 ) bCkFreelist = 0;\n+  }\n@@ -74483,1 +76059,1 @@\n-  sCheck.mallocFailed = 0;\n+  sCheck.bOomFault = 0;\n@@ -74497,1 +76073,1 @@\n-    sCheck.mallocFailed = 1;\n+    sCheck.bOomFault = 1;\n@@ -74502,1 +76078,1 @@\n-    sCheck.mallocFailed = 1;\n+    sCheck.bOomFault = 1;\n@@ -74511,4 +76087,6 @@\n-  sCheck.zPfx = \"Main freelist: \";\n-  checkList(&sCheck, 1, get4byte(&pBt->pPage1->aData[32]),\n-            get4byte(&pBt->pPage1->aData[36]));\n-  sCheck.zPfx = 0;\n+  if( bCkFreelist ){\n+    sCheck.zPfx = \"Main freelist: \";\n+    checkList(&sCheck, 1, get4byte(&pBt->pPage1->aData[32]),\n+              get4byte(&pBt->pPage1->aData[36]));\n+    sCheck.zPfx = 0;\n+  }\n@@ -74519,6 +76097,13 @@\n-  if( pBt->autoVacuum ){\n-    int mx = 0;\n-    int mxInHdr;\n-    for(i=0; (int)i<nRoot; i++) if( mx<aRoot[i] ) mx = aRoot[i];\n-    mxInHdr = get4byte(&pBt->pPage1->aData[52]);\n-    if( mx!=mxInHdr ){\n+  if( !bPartial ){\n+    if( pBt->autoVacuum ){\n+      Pgno mx = 0;\n+      Pgno mxInHdr;\n+      for(i=0; (int)i<nRoot; i++) if( mx<aRoot[i] ) mx = aRoot[i];\n+      mxInHdr = get4byte(&pBt->pPage1->aData[52]);\n+      if( mx!=mxInHdr ){\n+        checkAppendMsg(&sCheck,\n+          \"max rootpage (%d) disagrees with header (%d)\",\n+          mx, mxInHdr\n+        );\n+      }\n+    }else if( get4byte(&pBt->pPage1->aData[64])!=0 ){\n@@ -74526,2 +76111,1 @@\n-        \"max rootpage (%d) disagrees with header (%d)\",\n-        mx, mxInHdr\n+        \"incremental_vacuum enabled with a max rootpage of zero\"\n@@ -74530,4 +76114,0 @@\n-  }else if( get4byte(&pBt->pPage1->aData[64])!=0 ){\n-    checkAppendMsg(&sCheck,\n-      \"incremental_vacuum enabled with a max rootpage of zero\"\n-    );\n@@ -74542,1 +76122,1 @@\n-    if( pBt->autoVacuum && aRoot[i]>1 ){\n+    if( pBt->autoVacuum && aRoot[i]>1 && !bPartial ){\n@@ -74552,1 +76132,2 @@\n-  for(i=1; i<=sCheck.nPage && sCheck.mxErr; i++){\n+  if( !bPartial ){\n+    for(i=1; i<=sCheck.nPage && sCheck.mxErr; i++){\n@@ -74554,3 +76135,3 @@\n-    if( getPageReferenced(&sCheck, i)==0 ){\n-      checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n-    }\n+      if( getPageReferenced(&sCheck, i)==0 ){\n+        checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n+      }\n@@ -74558,11 +76139,11 @@\n-    \/* If the database supports auto-vacuum, make sure no tables contain\n-    ** references to pointer-map pages.\n-    *\/\n-    if( getPageReferenced(&sCheck, i)==0 &&\n-       (PTRMAP_PAGENO(pBt, i)!=i || !pBt->autoVacuum) ){\n-      checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n-    }\n-    if( getPageReferenced(&sCheck, i)!=0 &&\n-       (PTRMAP_PAGENO(pBt, i)==i && pBt->autoVacuum) ){\n-      checkAppendMsg(&sCheck, \"Pointer map page %d is referenced\", i);\n-    }\n+      \/* If the database supports auto-vacuum, make sure no tables contain\n+      ** references to pointer-map pages.\n+      *\/\n+      if( getPageReferenced(&sCheck, i)==0 &&\n+         (PTRMAP_PAGENO(pBt, i)!=i || !pBt->autoVacuum) ){\n+        checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n+      }\n+      if( getPageReferenced(&sCheck, i)!=0 &&\n+         (PTRMAP_PAGENO(pBt, i)==i && pBt->autoVacuum) ){\n+        checkAppendMsg(&sCheck, \"Pointer map page %d is referenced\", i);\n+      }\n@@ -74570,0 +76151,1 @@\n+    }\n@@ -74577,1 +76159,1 @@\n-  if( sCheck.mallocFailed ){\n+  if( sCheck.bOomFault ){\n@@ -74616,1 +76198,2 @@\n-** Return non-zero if a transaction is active.\n+** Return one of SQLITE_TXN_NONE, SQLITE_TXN_READ, or SQLITE_TXN_WRITE\n+** to describe the current transaction state of Btree p.\n@@ -74618,1 +76201,1 @@\n-SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree *p){\n+SQLITE_PRIVATE int sqlite3BtreeTxnState(Btree *p){\n@@ -74620,1 +76203,1 @@\n-  return (p && (p->inTrans==TRANS_WRITE));\n+  return p ? p->inTrans : 0;\n@@ -74649,1 +76232,1 @@\n-** Return non-zero if a read (or write) transaction is active.\n+** Return true if there is currently a backup running on Btree p.\n@@ -74651,6 +76234,0 @@\n-SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree *p){\n-  assert( p );\n-  assert( sqlite3_mutex_held(p->db->mutex) );\n-  return p->inTrans!=TRANS_NONE;\n-}\n-\n@@ -74697,1 +76274,1 @@\n-** sqlite_master table. Otherwise SQLITE_OK.\n+** sqlite_schema table. Otherwise SQLITE_OK.\n@@ -74703,1 +76280,1 @@\n-  rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK);\n+  rc = querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK);\n@@ -75002,1 +76579,1 @@\n-  if( sqlite3BtreeIsInReadTrans(p) ){\n+  if( sqlite3BtreeTxnState(p)!=SQLITE_TXN_NONE ){\n@@ -75233,1 +76810,1 @@\n-    if( rc==SQLITE_OK && 0==sqlite3BtreeIsInReadTrans(p->pSrc) ){\n+    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){\n@@ -75605,1 +77182,1 @@\n-  assert( sqlite3BtreeIsInTrans(pTo) );\n+  assert( sqlite3BtreeTxnState(pTo)==SQLITE_TXN_WRITE );\n@@ -75641,1 +77218,1 @@\n-  assert( sqlite3BtreeIsInTrans(pTo)==0 );\n+  assert( sqlite3BtreeTxnState(pTo)!=SQLITE_TXN_WRITE );\n@@ -75728,1 +77305,3 @@\n-       || p->szMalloc==sqlite3DbMallocSize(p->db,p->zMalloc) );\n+       || (p->flags==MEM_Undefined\n+           && p->szMalloc<=sqlite3DbMallocSize(p->db,p->zMalloc))\n+       || p->szMalloc==sqlite3DbMallocSize(p->db,p->zMalloc));\n@@ -75757,1 +77336,1 @@\n-  sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);\n+  assert( sz>22 );\n@@ -75759,3 +77338,10 @@\n-    sqlite3_str_appendf(&acc, \"%lld\", p->u.i);\n-  }else if( p->flags & MEM_IntReal ){\n-    sqlite3_str_appendf(&acc, \"%!.15g\", (double)p->u.i);\n+#if GCC_VERSION>=7000000\n+    \/* Work-around for GCC bug\n+    ** https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=96270 *\/\n+    i64 x;\n+    assert( (p->flags&MEM_Int)*2==sizeof(x) );\n+    memcpy(&x, (char*)&p->u, (p->flags&MEM_Int)*2);\n+    sqlite3Int64ToText(x, zBuf);\n+#else\n+    sqlite3Int64ToText(p->u.i, zBuf);\n+#endif\n@@ -75763,1 +77349,5 @@\n-    sqlite3_str_appendf(&acc, \"%!.15g\", p->u.r);\n+    sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);\n+    sqlite3_str_appendf(&acc, \"%!.15g\",\n+         (p->flags & MEM_IntReal)!=0 ? (double)p->u.i : p->u.r);\n+    assert( acc.zText==zBuf && acc.mxAlloc<=0 );\n+    zBuf[acc.nChar] = 0; \/* Fast version of sqlite3StrAccumFinish(&acc) *\/\n@@ -75765,2 +77355,0 @@\n-  assert( acc.zText==zBuf && acc.mxAlloc<=0 );\n-  zBuf[acc.nChar] = 0; \/* Fast version of sqlite3StrAccumFinish(&acc) *\/\n@@ -75842,0 +77430,1 @@\n+  assert( pMem!=0 );\n@@ -75883,1 +77472,3 @@\n-       || pMem->szMalloc==sqlite3DbMallocSize(pMem->db, pMem->zMalloc) );\n+       || (pMem->flags==MEM_Undefined\n+           && pMem->szMalloc<=sqlite3DbMallocSize(pMem->db,pMem->zMalloc))\n+       || pMem->szMalloc==sqlite3DbMallocSize(pMem->db,pMem->zMalloc));\n@@ -75972,0 +77563,1 @@\n+  assert( pMem!=0 );\n@@ -75996,0 +77588,1 @@\n+  assert( pMem!=0 );\n@@ -76011,0 +77604,2 @@\n+  assert( pMem->z!=0 );\n+  assert( sqlite3DbMallocSize(pMem->db,pMem->z) >= nByte );\n@@ -76023,0 +77618,1 @@\n+  assert( pMem!=0 );\n@@ -76050,0 +77646,1 @@\n+  assert( pMem!=0 );\n@@ -76085,0 +77682,1 @@\n+  assert( pMem!=0 );\n@@ -76235,0 +77833,1 @@\n+  assert( pMem!=0 );\n@@ -76263,0 +77862,1 @@\n+  assert( pMem!=0 );\n@@ -76295,0 +77895,1 @@\n+  assert( pMem!=0 );\n@@ -76322,0 +77923,1 @@\n+  assert( pMem!=0 );\n@@ -76336,0 +77938,1 @@\n+  assert( pMem!=0 );\n@@ -76369,0 +77972,1 @@\n+  assert( pMem!=0 );\n@@ -76478,0 +78082,1 @@\n+#ifndef SQLITE_OMIT_INCRBLOB\n@@ -76487,0 +78092,15 @@\n+#else\n+SQLITE_PRIVATE int sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){\n+  int nByte = n>0?n:1;\n+  if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){\n+    return SQLITE_NOMEM_BKPT;\n+  }\n+  assert( pMem->z!=0 );\n+  assert( sqlite3DbMallocSize(pMem->db, pMem->z)>=nByte );\n+  memset(pMem->z, 0, nByte);\n+  pMem->n = n>0?n:0;\n+  pMem->flags = MEM_Blob;\n+  pMem->enc = SQLITE_UTF8;\n+  return SQLITE_OK;\n+}\n+#endif\n@@ -76712,1 +78332,1 @@\n-  int n,              \/* Bytes in string, or negative *\/\n+  i64 n,              \/* Bytes in string, or negative *\/\n@@ -76716,1 +78336,1 @@\n-  int nByte = n;      \/* New value for pMem->n *\/\n+  i64 nByte = n;      \/* New value for pMem->n *\/\n@@ -76720,0 +78340,1 @@\n+  assert( pMem!=0 );\n@@ -76738,1 +78359,1 @@\n-      nByte = 0x7fffffff & (int)strlen(z);\n+      nByte = strlen(z);\n@@ -76750,1 +78371,1 @@\n-    u32 nAlloc = nByte;\n+    i64 nAlloc = nByte;\n@@ -76776,1 +78397,1 @@\n-  pMem->n = nByte;\n+  pMem->n = (int)(nByte & 0x7fffffff);\n@@ -76796,1 +78417,1 @@\n-    return SQLITE_TOOBIG;\n+    return sqlite3ErrorToParser(pMem->db, SQLITE_TOOBIG);\n@@ -77028,1 +78649,1 @@\n-  Expr *p,                        \/* The expression to evaluate *\/\n+  const Expr *p,                  \/* The expression to evaluate *\/\n@@ -77045,0 +78666,1 @@\n+  assert( ExprUseXList(p) );\n@@ -77047,0 +78669,1 @@\n+  assert( !ExprHasProperty(p, EP_IntValue) );\n@@ -77122,1 +78745,1 @@\n-  Expr *pExpr,                    \/* The expression to evaluate *\/\n+  const Expr *pExpr,              \/* The expression to evaluate *\/\n@@ -77150,1 +78773,3 @@\n-    u8 aff = sqlite3AffinityType(pExpr->u.zToken,0);\n+    u8 aff;\n+    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+    aff = sqlite3AffinityType(pExpr->u.zToken,0);\n@@ -77223,0 +78848,1 @@\n+    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -77240,0 +78866,1 @@\n+    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -77277,1 +78904,1 @@\n-  Expr *pExpr,              \/* The expression to evaluate *\/\n+  const Expr *pExpr,        \/* The expression to evaluate *\/\n@@ -77587,1 +79214,1 @@\n-  p->magic = VDBE_MAGIC_INIT;\n+  p->iVdbeMagic = VDBE_MAGIC_INIT;\n@@ -77788,1 +79415,1 @@\n-  assert( p->magic==VDBE_MAGIC_INIT );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );\n@@ -77793,0 +79420,1 @@\n+  assert( p->aOp!=0 );\n@@ -77795,0 +79423,1 @@\n+  assert( pOp!=0 );\n@@ -78023,1 +79652,1 @@\n-SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere){\n+SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere, u16 p5){\n@@ -78026,0 +79655,1 @@\n+  sqlite3VdbeChangeP5(p, p5);\n@@ -78027,0 +79657,1 @@\n+  sqlite3MayAbort(p->pParse);\n@@ -78116,1 +79747,1 @@\n-  assert( v->magic==VDBE_MAGIC_INIT );\n+  assert( v->iVdbeMagic==VDBE_MAGIC_INIT );\n@@ -78255,1 +79886,1 @@\n-     || (opcode==OP_ParseSchema && pOp->p4.z==0)\n+     || opcode==OP_ParseSchema\n@@ -78360,1 +79991,1 @@\n-          \/* fall thru *\/\n+          \/* no break *\/ deliberate_fall_through\n@@ -78407,0 +80038,1 @@\n+          \/* no break *\/ deliberate_fall_through\n@@ -78440,1 +80072,1 @@\n-  assert( p->magic==VDBE_MAGIC_INIT );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );\n@@ -78525,1 +80157,1 @@\n-  assert( p->magic==VDBE_MAGIC_INIT );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );\n@@ -78849,1 +80481,1 @@\n-  assert( p->magic==VDBE_MAGIC_INIT );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );\n@@ -78978,1 +80610,1 @@\n-  assert( p->magic==VDBE_MAGIC_INIT );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );\n@@ -79034,1 +80666,1 @@\n-    zSynopsis = zOpName += nOpName + 1;\n+    zSynopsis = zOpName + nOpName + 1;\n@@ -79036,5 +80668,1 @@\n-      if( pOp->p5 & SQLITE_STOREP2 ){\n-        sqlite3_snprintf(sizeof(zAlt), zAlt, \"r[P2] = (%s)\", zSynopsis+3);\n-      }else{\n-        sqlite3_snprintf(sizeof(zAlt), zAlt, \"if %s goto P2\", zSynopsis+3);\n-      }\n+      sqlite3_snprintf(sizeof(zAlt), zAlt, \"if %s goto P2\", zSynopsis+3);\n@@ -79072,1 +80700,1 @@\n-            }else{\n+            }else if( x.accError==0 ){\n@@ -79111,0 +80739,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -79213,1 +80842,1 @@\n-      assert( pColl->enc>=0 && pColl->enc<4 );\n+      assert( pColl->enc<4 );\n@@ -79264,3 +80893,3 @@\n-      int i;\n-      int *ai = pOp->p4.ai;\n-      int n = ai[0];   \/* The first element of an INTARRAY is always the\n+      u32 i;\n+      u32 *ai = pOp->p4.ai;\n+      u32 n = ai[0];   \/* The first element of an INTARRAY is always the\n@@ -79269,1 +80898,1 @@\n-        sqlite3_str_appendf(&x, \"%c%d\", (i==1 ? '[' : ','), ai[i]);\n+        sqlite3_str_appendf(&x, \"%c%u\", (i==1 ? '[' : ','), ai[i]);\n@@ -79457,1 +81086,0 @@\n-      testcase( p->xDel==sqlite3VdbeFrameMemDel );\n@@ -79459,0 +81087,1 @@\n+        testcase( (p->flags & MEM_Dyn)!=0 && p->xDel==sqlite3VdbeFrameMemDel );\n@@ -79663,1 +81292,1 @@\n-  assert( p->magic==VDBE_MAGIC_RUN );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_RUN );\n@@ -79843,1 +81472,1 @@\n-  assert( p->magic==VDBE_MAGIC_INIT || p->magic==VDBE_MAGIC_RESET );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_INIT || p->iVdbeMagic==VDBE_MAGIC_RESET );\n@@ -79850,1 +81479,1 @@\n-  p->magic = VDBE_MAGIC_RUN;\n+  p->iVdbeMagic = VDBE_MAGIC_RUN;\n@@ -79906,1 +81535,1 @@\n-  assert( p->magic==VDBE_MAGIC_INIT );\n+  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );\n@@ -79908,0 +81537,2 @@\n+  p->pVList = pParse->pVList;\n+  pParse->pVList =  0;\n@@ -79992,2 +81623,0 @@\n-  p->pVList = pParse->pVList;\n-  pParse->pVList =  0;\n@@ -80021,0 +81650,1 @@\n+  assert( pCx->pBtx==0 || pCx->isEphemeral );\n@@ -80027,8 +81657,2 @@\n-      if( pCx->isEphemeral ){\n-        if( pCx->pBtx ) sqlite3BtreeClose(pCx->pBtx);\n-        \/* The pCx->pCursor will be close automatically, if it exists, by\n-        ** the call above. *\/\n-      }else{\n-        assert( pCx->uc.pCursor!=0 );\n-        sqlite3BtreeCloseCursor(pCx->uc.pCursor);\n-      }\n+      assert( pCx->uc.pCursor!=0 );\n+      sqlite3BtreeCloseCursor(pCx->uc.pCursor);\n@@ -80181,1 +81805,1 @@\n-** takes care of the master journal trickery.\n+** takes care of the super-journal trickery.\n@@ -80187,1 +81811,1 @@\n-                   ** master-journal *\/\n+                   ** super-journal *\/\n@@ -80200,1 +81824,1 @@\n-  ** be done before determining whether a master journal file is\n+  ** be done before determining whether a super-journal file is\n@@ -80209,1 +81833,1 @@\n-  ** one database file has an open write transaction, a master journal\n+  ** one database file has an open write transaction, a super-journal\n@@ -80214,2 +81838,2 @@\n-    if( sqlite3BtreeIsInTrans(pBt) ){\n-      \/* Whether or not a database might need a master journal depends upon\n+    if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){\n+      \/* Whether or not a database might need a super-journal depends upon\n@@ -80217,1 +81841,1 @@\n-      ** journal modes use a master journal and which do not *\/\n+      ** journal modes use a super-journal and which do not *\/\n@@ -80255,1 +81879,1 @@\n-  ** master-journal.\n+  ** super-journal.\n@@ -80289,1 +81913,1 @@\n-  ** This requires a master journal file to ensure the transaction is\n+  ** This requires a super-journal file to ensure the transaction is\n@@ -80295,1 +81919,1 @@\n-    char *zMaster = 0;   \/* File-name for the master journal *\/\n+    char *zSuper = 0;   \/* File-name for the super-journal *\/\n@@ -80297,1 +81921,1 @@\n-    sqlite3_file *pMaster = 0;\n+    sqlite3_file *pSuperJrnl = 0;\n@@ -80303,1 +81927,1 @@\n-    \/* Select a master journal file name *\/\n+    \/* Select a super-journal file name *\/\n@@ -80305,3 +81929,3 @@\n-    zMaster = sqlite3MPrintf(db, \"%.4c%s%.16c\", 0,zMainFile,0);\n-    if( zMaster==0 ) return SQLITE_NOMEM_BKPT;\n-    zMaster += 4;\n+    zSuper = sqlite3MPrintf(db, \"%.4c%s%.16c\", 0,zMainFile,0);\n+    if( zSuper==0 ) return SQLITE_NOMEM_BKPT;\n+    zSuper += 4;\n@@ -80312,2 +81936,2 @@\n-          sqlite3_log(SQLITE_FULL, \"MJ delete: %s\", zMaster);\n-          sqlite3OsDelete(pVfs, zMaster, 0);\n+          sqlite3_log(SQLITE_FULL, \"MJ delete: %s\", zSuper);\n+          sqlite3OsDelete(pVfs, zSuper, 0);\n@@ -80316,1 +81940,1 @@\n-          sqlite3_log(SQLITE_FULL, \"MJ collide: %s\", zMaster);\n+          sqlite3_log(SQLITE_FULL, \"MJ collide: %s\", zSuper);\n@@ -80321,1 +81945,1 @@\n-      sqlite3_snprintf(13, &zMaster[nMainFile], \"-mj%06X9%02X\",\n+      sqlite3_snprintf(13, &zSuper[nMainFile], \"-mj%06X9%02X\",\n@@ -80323,1 +81947,1 @@\n-      \/* The antipenultimate character of the master journal name must\n+      \/* The antipenultimate character of the super-journal name must\n@@ -80325,3 +81949,3 @@\n-      assert( zMaster[sqlite3Strlen30(zMaster)-3]=='9' );\n-      sqlite3FileSuffix3(zMainFile, zMaster);\n-      rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);\n+      assert( zSuper[sqlite3Strlen30(zSuper)-3]=='9' );\n+      sqlite3FileSuffix3(zMainFile, zSuper);\n+      rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);\n@@ -80330,2 +81954,2 @@\n-      \/* Open the master journal. *\/\n-      rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster,\n+      \/* Open the super-journal. *\/\n+      rc = sqlite3OsOpenMalloc(pVfs, zSuper, &pSuperJrnl,\n@@ -80333,1 +81957,1 @@\n-          SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_MASTER_JOURNAL, 0\n+          SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_SUPER_JOURNAL, 0\n@@ -80337,1 +81961,1 @@\n-      sqlite3DbFree(db, zMaster-4);\n+      sqlite3DbFree(db, zSuper-4);\n@@ -80342,3 +81966,3 @@\n-    ** master journal file. If an error occurs at this point close\n-    ** and delete the master journal file. All the individual journal files\n-    ** still have 'null' as the master journal pointer, so they will roll\n+    ** super-journal file. If an error occurs at this point close\n+    ** and delete the super-journal file. All the individual journal files\n+    ** still have 'null' as the super-journal pointer, so they will roll\n@@ -80349,1 +81973,1 @@\n-      if( sqlite3BtreeIsInTrans(pBt) ){\n+      if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){\n@@ -80355,1 +81979,1 @@\n-        rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile)+1, offset);\n+        rc = sqlite3OsWrite(pSuperJrnl, zFile, sqlite3Strlen30(zFile)+1,offset);\n@@ -80358,3 +81982,3 @@\n-          sqlite3OsCloseFree(pMaster);\n-          sqlite3OsDelete(pVfs, zMaster, 0);\n-          sqlite3DbFree(db, zMaster-4);\n+          sqlite3OsCloseFree(pSuperJrnl);\n+          sqlite3OsDelete(pVfs, zSuper, 0);\n+          sqlite3DbFree(db, zSuper-4);\n@@ -80366,1 +81990,1 @@\n-    \/* Sync the master journal file. If the IOCAP_SEQUENTIAL device\n+    \/* Sync the super-journal file. If the IOCAP_SEQUENTIAL device\n@@ -80369,2 +81993,2 @@\n-    if( 0==(sqlite3OsDeviceCharacteristics(pMaster)&SQLITE_IOCAP_SEQUENTIAL)\n-     && SQLITE_OK!=(rc = sqlite3OsSync(pMaster, SQLITE_SYNC_NORMAL))\n+    if( 0==(sqlite3OsDeviceCharacteristics(pSuperJrnl)&SQLITE_IOCAP_SEQUENTIAL)\n+     && SQLITE_OK!=(rc = sqlite3OsSync(pSuperJrnl, SQLITE_SYNC_NORMAL))\n@@ -80372,3 +81996,3 @@\n-      sqlite3OsCloseFree(pMaster);\n-      sqlite3OsDelete(pVfs, zMaster, 0);\n-      sqlite3DbFree(db, zMaster-4);\n+      sqlite3OsCloseFree(pSuperJrnl);\n+      sqlite3OsDelete(pVfs, zSuper, 0);\n+      sqlite3DbFree(db, zSuper-4);\n@@ -80379,2 +82003,2 @@\n-    ** sets the master journal pointer in each individual journal. If\n-    ** an error occurs here, do not delete the master journal file.\n+    ** sets the super-journal pointer in each individual journal. If\n+    ** an error occurs here, do not delete the super-journal file.\n@@ -80384,2 +82008,2 @@\n-    ** master journal file will be orphaned. But we cannot delete it,\n-    ** in case the master journal file name was written into the journal\n+    ** super-journal file will be orphaned. But we cannot delete it,\n+    ** in case the super-journal file name was written into the journal\n@@ -80391,1 +82015,1 @@\n-        rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster);\n+        rc = sqlite3BtreeCommitPhaseOne(pBt, zSuper);\n@@ -80394,1 +82018,1 @@\n-    sqlite3OsCloseFree(pMaster);\n+    sqlite3OsCloseFree(pSuperJrnl);\n@@ -80397,1 +82021,1 @@\n-      sqlite3DbFree(db, zMaster-4);\n+      sqlite3DbFree(db, zSuper-4);\n@@ -80401,1 +82025,1 @@\n-    \/* Delete the master journal file. This commits the transaction. After\n+    \/* Delete the super-journal file. This commits the transaction. After\n@@ -80405,3 +82029,3 @@\n-    rc = sqlite3OsDelete(pVfs, zMaster, 1);\n-    sqlite3DbFree(db, zMaster-4);\n-    zMaster = 0;\n+    rc = sqlite3OsDelete(pVfs, zSuper, 1);\n+    sqlite3DbFree(db, zSuper-4);\n+    zSuper = 0;\n@@ -80563,3 +82187,3 @@\n-** This routine is the only way to move the state of a VM from\n-** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to\n-** call this on a VM that is in the SQLITE_MAGIC_HALT state.\n+** This routine is the only way to move the sqlite3eOpenState of a VM from\n+** SQLITE_STATE_RUN to SQLITE_STATE_HALT.  It is harmless to\n+** call this on a VM that is in the SQLITE_STATE_HALT state.\n@@ -80591,1 +82215,1 @@\n-  if( p->magic!=VDBE_MAGIC_RUN ){\n+  if( p->iVdbeMagic!=VDBE_MAGIC_RUN ){\n@@ -80611,3 +82235,9 @@\n-    mrc = p->rc & 0xff;\n-    isSpecialError = mrc==SQLITE_NOMEM || mrc==SQLITE_IOERR\n-                     || mrc==SQLITE_INTERRUPT || mrc==SQLITE_FULL;\n+    if( p->rc ){\n+      mrc = p->rc & 0xff;\n+      isSpecialError = mrc==SQLITE_NOMEM\n+                    || mrc==SQLITE_IOERR\n+                    || mrc==SQLITE_INTERRUPT\n+                    || mrc==SQLITE_FULL;\n+    }else{\n+      mrc = isSpecialError = 0;\n+    }\n@@ -80665,0 +82295,3 @@\n+        }else if( db->flags & SQLITE_CorruptRdOnly ){\n+          rc = SQLITE_CORRUPT;\n+          db->flags &= ~SQLITE_CorruptRdOnly;\n@@ -80749,1 +82382,1 @@\n-  p->magic = VDBE_MAGIC_HALT;\n+  p->iVdbeMagic = VDBE_MAGIC_HALT;\n@@ -80854,1 +82487,5 @@\n-    sqlite3VdbeTransferError(p);\n+    if( db->pErr || p->zErrMsg ){\n+      sqlite3VdbeTransferError(p);\n+    }else{\n+      db->errCode = p->rc;\n+    }\n@@ -80874,2 +82511,4 @@\n-  sqlite3DbFree(db, p->zErrMsg);\n-  p->zErrMsg = 0;\n+  if( p->zErrMsg ){\n+    sqlite3DbFree(db, p->zErrMsg);\n+    p->zErrMsg = 0;\n+  }\n@@ -80916,1 +82555,1 @@\n-  p->magic = VDBE_MAGIC_RESET;\n+  p->iVdbeMagic = VDBE_MAGIC_RESET;\n@@ -80926,1 +82565,1 @@\n-  if( p->magic==VDBE_MAGIC_RUN || p->magic==VDBE_MAGIC_HALT ){\n+  if( p->iVdbeMagic==VDBE_MAGIC_RUN || p->iVdbeMagic==VDBE_MAGIC_HALT ){\n@@ -80987,1 +82626,1 @@\n-  if( p->magic!=VDBE_MAGIC_INIT ){\n+  if( p->iVdbeMagic!=VDBE_MAGIC_INIT ){\n@@ -81035,1 +82674,1 @@\n-  p->magic = VDBE_MAGIC_DEAD;\n+  p->iVdbeMagic = VDBE_MAGIC_DEAD;\n@@ -81053,1 +82692,1 @@\n-  rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);\n+  rc = sqlite3BtreeTableMoveto(p->uc.pCursor, p->movetoTarget, 0, &res);\n@@ -81107,1 +82746,1 @@\n-SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor **pp, int *piCol){\n+SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor **pp, u32 *piCol){\n@@ -81111,1 +82750,2 @@\n-    int iMap;\n+    u32 iMap;\n+    assert( !p->isEphemeral );\n@@ -81836,1 +83476,1 @@\n-static int sqlite3IntFloatCompare(i64 i, double r){\n+SQLITE_PRIVATE int sqlite3IntFloatCompare(i64 i, double r){\n@@ -81839,0 +83479,3 @@\n+    testcase( x<r );\n+    testcase( x>r );\n+    testcase( x==r );\n@@ -81840,2 +83483,2 @@\n-    if( x>r ) return +1;\n-    return 0;\n+    if( x>r ) return +1;  \/*NO_TEST*\/ \/* work around bugs in gcov *\/\n+    return 0;             \/*NO_TEST*\/ \/* work around bugs in gcov *\/\n@@ -82470,1 +84113,1 @@\n-  testcase( szHdr==m.n );\n+  testcase( szHdr==(u32)m.n );\n@@ -82557,1 +84200,1 @@\n-SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){\n+SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *db, i64 nChange){\n@@ -82737,1 +84380,2 @@\n-  int iReg                        \/* Register for new.* record *\/\n+  int iReg,                       \/* Register for new.* record *\/\n+  int iBlobWrite\n@@ -82758,0 +84402,2 @@\n+  assert( pCsr!=0 );\n+  assert( pCsr->eCurType==CURTYPE_BTREE );\n@@ -82773,0 +84419,1 @@\n+  preupdate.iBlobWrite = iBlobWrite;\n@@ -82867,1 +84514,1 @@\n-    db->xTrace(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);\n+    db->trace.xV2(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);\n@@ -83156,2 +84803,2 @@\n-** result as a string or blob but if the string or blob is too large, it\n-** then sets the error code to SQLITE_TOOBIG\n+** result as a string or blob.  Appropriate errors are set if the string\/blob\n+** is too big or if an OOM occurs.\n@@ -83169,2 +84816,10 @@\n-  if( sqlite3VdbeMemSetStr(pCtx->pOut, z, n, enc, xDel)==SQLITE_TOOBIG ){\n-    sqlite3_result_error_toobig(pCtx);\n+  int rc = sqlite3VdbeMemSetStr(pCtx->pOut, z, n, enc, xDel);\n+  if( rc ){\n+    if( rc==SQLITE_TOOBIG ){\n+      sqlite3_result_error_toobig(pCtx);\n+    }else{\n+      \/* The only errors possible from sqlite3VdbeMemSetStr are\n+      ** SQLITE_TOOBIG and SQLITE_NOMEM *\/\n+      assert( rc==SQLITE_NOMEM );\n+      sqlite3_result_error_nomem(pCtx);\n+    }\n@@ -83186,1 +84841,1 @@\n-  if( pCtx ) sqlite3_result_error_toobig(pCtx);\n+  sqlite3_result_error_toobig(pCtx);\n@@ -83327,0 +84982,1 @@\n+#ifndef SQLITE_OMIT_INCRBLOB\n@@ -83329,0 +84985,3 @@\n+#else\n+  return sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);\n+#endif\n@@ -83411,1 +85070,1 @@\n-  if( p->magic!=VDBE_MAGIC_RUN ){\n+  if( p->iVdbeMagic!=VDBE_MAGIC_RUN ){\n@@ -83449,0 +85108,7 @@\n+    if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){\n+      \/* If this statement was prepared using saved SQL and an\n+      ** error has occurred, then return the error code in p->rc to the\n+      ** caller. Set the error code in the database handle to the same value.\n+      *\/\n+      rc = sqlite3VdbeTransferError(p);\n+    }\n@@ -83504,0 +85170,6 @@\n+    }else if( rc!=SQLITE_DONE && (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){\n+      \/* If this statement was prepared using saved SQL and an\n+      ** error has occurred, then return the error code in p->rc to the\n+      ** caller. Set the error code in the database handle to the same value.\n+      *\/\n+      rc = sqlite3VdbeTransferError(p);\n@@ -83510,0 +85182,1 @@\n+    if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ) rc = p->rc;\n@@ -83512,8 +85185,4 @@\n-  \/* At this point local variable rc holds the value that should be\n-  ** returned if this statement was compiled using the legacy\n-  ** sqlite3_prepare() interface. According to the docs, this can only\n-  ** be one of the values in the first assert() below. Variable p->rc\n-  ** contains the value that would be returned if sqlite3_finalize()\n-  ** were called on statement p.\n-  *\/\n-  assert( rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR\n+  \/* There are only a limited number of result codes allowed from the\n+  ** statements prepared using the legacy sqlite3_prepare() interface *\/\n+  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0\n+       || rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR\n@@ -83522,11 +85191,0 @@\n-  assert( (p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE) || p->rc==p->rcApp );\n-  if( rc!=SQLITE_ROW\n-   && rc!=SQLITE_DONE\n-   && (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0\n-  ){\n-    \/* If this statement was prepared using saved SQL and an\n-    ** error has occurred, then return the error code in p->rc to the\n-    ** caller. Set the error code in the database handle to the same value.\n-    *\/\n-    rc = sqlite3VdbeTransferError(p);\n-  }\n@@ -84128,1 +85786,1 @@\n-  if( p->magic!=VDBE_MAGIC_RUN || p->pc>=0 ){\n+  if( p->iVdbeMagic!=VDBE_MAGIC_RUN || p->pc>=0 ){\n@@ -84169,1 +85827,1 @@\n-  int nData,             \/* Number of bytes of data to be bound *\/\n+  i64 nData,             \/* Number of bytes of data to be bound *\/\n@@ -84221,5 +85879,1 @@\n-  if( nData>0x7fffffff ){\n-    return invokeValueDestructor(zData, xDel, 0);\n-  }else{\n-    return bindText(pStmt, i, zData, (int)nData, xDel, 0);\n-  }\n+  return bindText(pStmt, i, zData, nData, xDel, 0);\n@@ -84295,6 +85949,2 @@\n-  if( nData>0x7fffffff ){\n-    return invokeValueDestructor(zData, xDel, 0);\n-  }else{\n-    if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n-    return bindText(pStmt, i, zData, (int)nData, xDel, enc);\n-  }\n+  if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n+  return bindText(pStmt, i, zData, nData, xDel, enc);\n@@ -84349,0 +85999,1 @@\n+#ifndef SQLITE_OMIT_INCRBLOB\n@@ -84350,0 +86001,3 @@\n+#else\n+    rc = sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);\n+#endif\n@@ -84482,1 +86136,1 @@\n-  return v!=0 && v->magic==VDBE_MAGIC_RUN && v->pc>=0;\n+  return v!=0 && v->iVdbeMagic==VDBE_MAGIC_RUN && v->pc>=0;\n@@ -84637,0 +86291,1 @@\n+    assert( p->pCsr->eCurType==CURTYPE_BTREE );\n@@ -84700,0 +86355,11 @@\n+#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n+\/*\n+** This function is designed to be called from within a pre-update callback\n+** only.\n+*\/\n+SQLITE_API int sqlite3_preupdate_blobwrite(sqlite3 *db){\n+  PreUpdate *p = db->pPreUpdate;\n+  return (p ? p->iBlobWrite : -1);\n+}\n+#endif\n+\n@@ -84933,1 +86599,0 @@\n-  char zBase[100];         \/* Initial working space *\/\n@@ -84936,2 +86601,1 @@\n-  sqlite3StrAccumInit(&out, 0, zBase, sizeof(zBase),\n-                      db->aLimit[SQLITE_LIMIT_LENGTH]);\n+  sqlite3StrAccumInit(&out, 0, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);\n@@ -84974,1 +86638,1 @@\n-      nextIndex = idx + 1;\n+      nextIndex = MAX(idx + 1, nextIndex);\n@@ -85318,5 +86982,0 @@\n-    \/* Before calling sqlite3VdbeFreeCursor(), ensure the isEphemeral flag\n-    ** is clear. Otherwise, if this is an ephemeral cursor created by\n-    ** OP_OpenDup, the cursor will not be closed and will still be part\n-    ** of a BtShared.pCursor list.  *\/\n-    if( p->apCsr[iCur]->pBtx==0 ) p->apCsr[iCur]->isEphemeral = 0;\n@@ -85326,11 +86985,16 @@\n-  if( SQLITE_OK==sqlite3VdbeMemClearAndResize(pMem, nByte) ){\n-    p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;\n-    memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));\n-    pCx->eCurType = eCurType;\n-    pCx->iDb = iDb;\n-    pCx->nField = nField;\n-    pCx->aOffset = &pCx->aType[nField];\n-    if( eCurType==CURTYPE_BTREE ){\n-      pCx->uc.pCursor = (BtCursor*)\n-          &pMem->z[ROUND8(sizeof(VdbeCursor))+2*sizeof(u32)*nField];\n-      sqlite3BtreeCursorZero(pCx->uc.pCursor);\n+\n+  \/* There used to be a call to sqlite3VdbeMemClearAndResize() to make sure\n+  ** the pMem used to hold space for the cursor has enough storage available\n+  ** in pMem->zMalloc.  But for the special case of the aMem[] entries used\n+  ** to hold cursors, it is faster to in-line the logic. *\/\n+  assert( pMem->flags==MEM_Undefined );\n+  assert( (pMem->flags & MEM_Dyn)==0 );\n+  assert( pMem->szMalloc==0 || pMem->z==pMem->zMalloc );\n+  if( pMem->szMalloc<nByte ){\n+    if( pMem->szMalloc>0 ){\n+      sqlite3DbFreeNN(pMem->db, pMem->zMalloc);\n+    }\n+    pMem->z = pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, nByte);\n+    if( pMem->zMalloc==0 ){\n+      pMem->szMalloc = 0;\n+      return 0;\n@@ -85338,0 +87002,13 @@\n+    pMem->szMalloc = nByte;\n+  }\n+\n+  p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->zMalloc;\n+  memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));\n+  pCx->eCurType = eCurType;\n+  pCx->iDb = iDb;\n+  pCx->nField = nField;\n+  pCx->aOffset = &pCx->aType[nField];\n+  if( eCurType==CURTYPE_BTREE ){\n+    pCx->uc.pCursor = (BtCursor*)\n+        &pMem->z[ROUND8(sizeof(VdbeCursor))+2*sizeof(u32)*nField];\n+    sqlite3BtreeCursorZero(pCx->uc.pCursor);\n@@ -85484,1 +87161,4 @@\n-  ExpandBlob(pMem);\n+  if( ExpandBlob(pMem) ){\n+    pMem->u.i = 0;\n+    return MEM_Int;\n+  }\n@@ -85622,0 +87302,5 @@\n+\/**\/ void sqlite3PrintMem(Mem *pMem){\n+  memTracePrint(pMem);\n+  printf(\"\\n\");\n+  fflush(stdout);\n+}\n@@ -85649,90 +87334,1 @@\n-\/************** Include hwtime.h in the middle of vdbe.c *********************\/\n-\/************** Begin file hwtime.h ******************************************\/\n-\/*\n-** 2008 May 27\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains inline asm code for retrieving \"high-performance\"\n-** counters for x86 and x86_64 class CPUs.\n-*\/\n-#ifndef SQLITE_HWTIME_H\n-#define SQLITE_HWTIME_H\n-\n-\/*\n-** The following routine only works on pentium-class (or newer) processors.\n-** It uses the RDTSC opcode to read the cycle count value out of the\n-** processor and returns that value.  This can be used for high-res\n-** profiling.\n-*\/\n-#if !defined(__STRICT_ANSI__) && \\\n-    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n-    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n-\n-  #if defined(__GNUC__)\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-     unsigned int lo, hi;\n-     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n-     return (sqlite_uint64)hi << 32 | lo;\n-  }\n-\n-  #elif defined(_MSC_VER)\n-\n-  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n-     __asm {\n-        rdtsc\n-        ret       ; return value at EDX:EAX\n-     }\n-  }\n-\n-  #endif\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long val;\n-      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n-      return val;\n-  }\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long long retval;\n-      unsigned long junk;\n-      __asm__ __volatile__ (\"\\n\\\n-          1:      mftbu   %1\\n\\\n-                  mftb    %L0\\n\\\n-                  mftbu   %0\\n\\\n-                  cmpw    %0,%1\\n\\\n-                  bne     1b\"\n-                  : \"=r\" (retval), \"=r\" (junk));\n-      return retval;\n-  }\n-\n-#else\n-\n-  \/*\n-  ** asm() is needed for hardware timing support.  Without asm(),\n-  ** disable the sqlite3Hwtime() routine.\n-  **\n-  ** sqlite3Hwtime() is only used for some obscure debugging\n-  ** and analysis configurations, not in any deliverable, so this\n-  ** should not be a great loss.\n-  *\/\n-SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n-\n-#endif\n-\n-#endif \/* !defined(SQLITE_HWTIME_H) *\/\n-\n-\/************** End of hwtime.h **********************************************\/\n-\/************** Continuing where we left off in vdbe.c ***********************\/\n+\/* #include \"hwtime.h\" *\/\n@@ -85785,0 +87381,13 @@\n+\/*\n+** Return the symbolic name for the data type of a pMem\n+*\/\n+static const char *vdbeMemTypeName(Mem *pMem){\n+  static const char *azTypes[] = {\n+      \/* SQLITE_INTEGER *\/ \"INT\",\n+      \/* SQLITE_FLOAT   *\/ \"REAL\",\n+      \/* SQLITE_TEXT    *\/ \"TEXT\",\n+      \/* SQLITE_BLOB    *\/ \"BLOB\",\n+      \/* SQLITE_NULL    *\/ \"NULL\"\n+  };\n+  return azTypes[sqlite3_value_type(pMem)-1];\n+}\n@@ -85806,1 +87415,1 @@\n-  unsigned nVmStep = 0;      \/* Number of virtual machine steps *\/\n+  u64 nVmStep = 0;           \/* Number of virtual machine steps *\/\n@@ -85808,1 +87417,1 @@\n-  unsigned nProgressLimit;   \/* Invoke xProgress() when nVmStep reaches this *\/\n+  u64 nProgressLimit;        \/* Invoke xProgress() when nVmStep reaches this *\/\n@@ -85820,1 +87429,1 @@\n-  assert( p->magic==VDBE_MAGIC_RUN );  \/* sqlite3_step() verifies this *\/\n+  assert( p->iVdbeMagic==VDBE_MAGIC_RUN );  \/* sqlite3_step() verifies this *\/\n@@ -85828,1 +87437,1 @@\n-    nProgressLimit = 0xffffffff;\n+    nProgressLimit = LARGEST_UINT64;\n@@ -86040,1 +87649,1 @@\n-      nProgressLimit = 0xffffffff;\n+      nProgressLimit = LARGEST_UINT64;\n@@ -86168,0 +87777,1 @@\n+  \/* no break *\/ deliberate_fall_through\n@@ -86338,0 +87948,1 @@\n+  \/* no break *\/ deliberate_fall_through\n@@ -86578,0 +88189,20 @@\n+\/* Opcode: ChngCntRow P1 P2 * * *\n+** Synopsis: output=r[P1]\n+**\n+** Output value in register P1 as the chance count for a DML statement,\n+** due to the \"PRAGMA count_changes=ON\" setting.  Or, if there was a\n+** foreign key error in the statement, trigger the error now.\n+**\n+** This opcode is a variant of OP_ResultRow that checks the foreign key\n+** immediate constraint count and throws an error if the count is\n+** non-zero.  The P2 opcode must be 1.\n+*\/\n+case OP_ChngCntRow: {\n+  assert( pOp->p2==1 );\n+  if( (rc = sqlite3VdbeCheckFk(p,0))!=SQLITE_OK ){\n+    goto abort_due_to_error;\n+  }\n+  \/* Fall through to the next case, OP_ResultRow *\/\n+  \/* no break *\/ deliberate_fall_through\n+}\n+\n@@ -86591,1 +88222,1 @@\n-  assert( pOp->p1>0 );\n+  assert( pOp->p1>0 || CORRUPT_DB );\n@@ -86594,28 +88225,0 @@\n-  \/* If this statement has violated immediate foreign key constraints, do\n-  ** not return the number of rows modified. And do not RELEASE the statement\n-  ** transaction. It needs to be rolled back.  *\/\n-  if( SQLITE_OK!=(rc = sqlite3VdbeCheckFk(p, 0)) ){\n-    assert( db->flags&SQLITE_CountRows );\n-    assert( p->usesStmtJournal );\n-    goto abort_due_to_error;\n-  }\n-\n-  \/* If the SQLITE_CountRows flag is set in sqlite3.flags mask, then\n-  ** DML statements invoke this opcode to return the number of rows\n-  ** modified to the user. This is the only way that a VM that\n-  ** opens a statement transaction may invoke this opcode.\n-  **\n-  ** In case this is such a statement, close any statement transaction\n-  ** opened by this VM before returning control to the user. This is to\n-  ** ensure that statement-transactions are always nested, not overlapping.\n-  ** If the open statement-transaction is not closed here, then the user\n-  ** may step another VM that opens its own statement transaction. This\n-  ** may lead to overlapping statement transactions.\n-  **\n-  ** The statement transaction is never a top-level transaction.  Hence\n-  ** the RELEASE call below can never fail.\n-  *\/\n-  assert( p->iStatement==0 || db->flags&SQLITE_CountRows );\n-  rc = sqlite3VdbeCloseStatement(p, SAVEPOINT_RELEASE);\n-  assert( rc==SQLITE_OK );\n-\n@@ -86649,1 +88252,1 @@\n-    db->xTrace(SQLITE_TRACE_ROW, db->pTraceArg, p, 0);\n+    db->trace.xV2(SQLITE_TRACE_ROW, db->pTraceArg, p, 0);\n@@ -87061,2 +88664,1 @@\n-** jump to address P2.  Or if the SQLITE_STOREP2 flag is set in P5, then\n-** store the result of comparison in register P2.\n+** jump to address P2.\n@@ -87088,3 +88690,2 @@\n-** If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the\n-** content of r[P2] is only changed if the new value is NULL or 0 (false).\n-** In other words, a prior r[P2] value will not be overwritten by 1 (true).\n+** This opcode saves the result of comparison for use by the new\n+** OP_Jump opcode.\n@@ -87098,4 +88699,0 @@\n-**\n-** If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the\n-** content of r[P2] is only changed if the new value is NULL or 1 (true).\n-** In other words, a prior r[P2] value will not be overwritten by 0 (false).\n@@ -87107,2 +88704,1 @@\n-** jump to address P2.  Or if the SQLITE_STOREP2 flag is set in P5 store\n-** the result of comparison (0 or 1 or NULL) into register P2.\n+** jump to address P2.\n@@ -87131,0 +88727,3 @@\n+**\n+** This opcode saves the result of comparison for use by the new\n+** OP_Jump opcode.\n@@ -87168,0 +88767,25 @@\n+  if( (flags1 & flags3 & MEM_Int)!=0 ){\n+    assert( (pOp->p5 & SQLITE_AFF_MASK)!=SQLITE_AFF_TEXT || CORRUPT_DB );\n+    \/* Common case of comparison of two integers *\/\n+    if( pIn3->u.i > pIn1->u.i ){\n+      iCompare = +1;\n+      if( sqlite3aGTb[pOp->opcode] ){\n+        VdbeBranchTaken(1, (pOp->p5 & SQLITE_NULLEQ)?2:3);\n+        goto jump_to_p2;\n+      }\n+    }else if( pIn3->u.i < pIn1->u.i ){\n+      iCompare = -1;\n+      if( sqlite3aLTb[pOp->opcode] ){\n+        VdbeBranchTaken(1, (pOp->p5 & SQLITE_NULLEQ)?2:3);\n+        goto jump_to_p2;\n+      }\n+    }else{\n+      iCompare = 0;\n+      if( sqlite3aEQb[pOp->opcode] ){\n+        VdbeBranchTaken(1, (pOp->p5 & SQLITE_NULLEQ)?2:3);\n+        goto jump_to_p2;\n+      }\n+    }\n+    VdbeBranchTaken(0, (pOp->p5 & SQLITE_NULLEQ)?2:3);\n+    break;\n+  }\n@@ -87190,11 +88814,4 @@\n-      if( pOp->p5 & SQLITE_STOREP2 ){\n-        pOut = &aMem[pOp->p2];\n-        iCompare = 1;    \/* Operands are not equal *\/\n-        memAboutToChange(p, pOut);\n-        MemSetTypeFlag(pOut, MEM_Null);\n-        REGISTER_TRACE(pOp->p2, pOut);\n-      }else{\n-        VdbeBranchTaken(2,3);\n-        if( pOp->p5 & SQLITE_JUMPIFNULL ){\n-          goto jump_to_p2;\n-        }\n+      iCompare = 1;    \/* Operands are not equal *\/\n+      VdbeBranchTaken(2,3);\n+      if( pOp->p5 & SQLITE_JUMPIFNULL ){\n+        goto jump_to_p2;\n@@ -87205,1 +88822,2 @@\n-    \/* Neither operand is NULL.  Do a comparison. *\/\n+    \/* Neither operand is NULL and we couldn't do the special high-speed\n+    ** integer comparison case.  So do a general-case comparison. *\/\n@@ -87218,8 +88836,0 @@\n-      \/* Handle the common case of integer comparison here, as an\n-      ** optimization, to avoid a call to sqlite3MemCompare() *\/\n-      if( (pIn1->flags & pIn3->flags & MEM_Int)!=0 ){\n-        if( pIn3->u.i > pIn1->u.i ){ res = +1; goto compare_op; }\n-        if( pIn3->u.i < pIn1->u.i ){ res = -1; goto compare_op; }\n-        res = 0;\n-        goto compare_op;\n-      }\n@@ -87248,1 +88858,1 @@\n-compare_op:\n+\n@@ -87257,3 +88867,2 @@\n-  if( res<0 ){                        \/* ne, eq, gt, le, lt, ge *\/\n-    static const unsigned char aLTb[] = { 1,  0,  0,  1,  1,  0 };\n-    res2 = aLTb[pOp->opcode - OP_Ne];\n+  if( res<0 ){\n+    res2 = sqlite3aLTb[pOp->opcode];\n@@ -87261,2 +88870,1 @@\n-    static const unsigned char aEQb[] = { 0,  1,  0,  1,  0,  1 };\n-    res2 = aEQb[pOp->opcode - OP_Ne];\n+    res2 = sqlite3aEQb[pOp->opcode];\n@@ -87264,2 +88872,1 @@\n-    static const unsigned char aGTb[] = { 1,  0,  1,  0,  0,  1 };\n-    res2 = aGTb[pOp->opcode - OP_Ne];\n+    res2 = sqlite3aGTb[pOp->opcode];\n@@ -87267,0 +88874,1 @@\n+  iCompare = res;\n@@ -87274,28 +88882,3 @@\n-  if( pOp->p5 & SQLITE_STOREP2 ){\n-    pOut = &aMem[pOp->p2];\n-    iCompare = res;\n-    if( (pOp->p5 & SQLITE_KEEPNULL)!=0 ){\n-      \/* The KEEPNULL flag prevents OP_Eq from overwriting a NULL with 1\n-      ** and prevents OP_Ne from overwriting NULL with 0.  This flag\n-      ** is only used in contexts where either:\n-      **   (1) op==OP_Eq && (r[P2]==NULL || r[P2]==0)\n-      **   (2) op==OP_Ne && (r[P2]==NULL || r[P2]==1)\n-      ** Therefore it is not necessary to check the content of r[P2] for\n-      ** NULL. *\/\n-      assert( pOp->opcode==OP_Ne || pOp->opcode==OP_Eq );\n-      assert( res2==0 || res2==1 );\n-      testcase( res2==0 && pOp->opcode==OP_Eq );\n-      testcase( res2==1 && pOp->opcode==OP_Eq );\n-      testcase( res2==0 && pOp->opcode==OP_Ne );\n-      testcase( res2==1 && pOp->opcode==OP_Ne );\n-      if( (pOp->opcode==OP_Eq)==res2 ) break;\n-    }\n-    memAboutToChange(p, pOut);\n-    MemSetTypeFlag(pOut, MEM_Int);\n-    pOut->u.i = res2;\n-    REGISTER_TRACE(pOp->p2, pOut);\n-  }else{\n-    VdbeBranchTaken(res2!=0, (pOp->p5 & SQLITE_NULLEQ)?2:3);\n-    if( res2 ){\n-      goto jump_to_p2;\n-    }\n+  VdbeBranchTaken(res2!=0, (pOp->p5 & SQLITE_NULLEQ)?2:3);\n+  if( res2 ){\n+    goto jump_to_p2;\n@@ -87306,1 +88889,1 @@\n-\/* Opcode: ElseNotEq * P2 * * *\n+\/* Opcode: ElseEq * P2 * * *\n@@ -87311,2 +88894,1 @@\n-** OP_Lt or OP_Gt.  Furthermore, the prior OP_Lt or OP_Gt must have the\n-** SQLITE_STOREP2 bit set in the P5 field.\n+** OP_Lt or OP_Gt.\n@@ -87315,3 +88897,3 @@\n-** prior OP_Lt or OP_Gt would have been NULL or false (0), then then\n-** jump to P2.  If the result of an OP_Eq comparison on the two previous\n-** operands would have been true (1), then fall through.\n+** prior OP_Lt or OP_Gt would have been true, then jump to P2.\n+** If the result of an OP_Eq comparison on the two previous\n+** operands would have been false or NULL, then fall through.\n@@ -87319,1 +88901,1 @@\n-case OP_ElseNotEq: {       \/* same as TK_ESCAPE, jump *\/\n+case OP_ElseEq: {       \/* same as TK_ESCAPE, jump *\/\n@@ -87323,2 +88905,1 @@\n-  ** OP_Gt with the SQLITE_STOREP2 flag set, with zero or more intervening\n-  ** OP_ReleaseReg opcodes *\/\n+  ** OP_Gt with zero or more intervening OP_ReleaseReg opcodes *\/\n@@ -87329,1 +88910,0 @@\n-    assert( aOp[iAddr].p5 & SQLITE_STOREP2 );\n@@ -87333,2 +88913,2 @@\n-  VdbeBranchTaken(iCompare!=0, 2);\n-  if( iCompare!=0 ) goto jump_to_p2;\n+  VdbeBranchTaken(iCompare==0, 2);\n+  if( iCompare==0 ) goto jump_to_p2;\n@@ -87385,1 +88965,1 @@\n-  int idx;\n+  u32 idx;\n@@ -87388,1 +88968,1 @@\n-  int *aPermute;     \/* The permutation *\/\n+  u32 *aPermute;     \/* The permutation *\/\n@@ -87408,1 +88988,1 @@\n-    for(k=0; k<n; k++) if( aPermute[k]>mx ) mx = aPermute[k];\n+    for(k=0; k<n; k++) if( aPermute[k]>(u32)mx ) mx = aPermute[k];\n@@ -87417,1 +88997,1 @@\n-    idx = aPermute ? aPermute[i] : i;\n+    idx = aPermute ? aPermute[i] : (u32)i;\n@@ -87645,0 +89225,34 @@\n+\/* Opcode: IsNullOrType P1 P2 P3 * *\n+** Synopsis: if typeof(r[P1]) IN (P3,5) goto P2\n+**\n+** Jump to P2 if the value in register P1 is NULL or has a datatype P3.\n+** P3 is an integer which should be one of SQLITE_INTEGER, SQLITE_FLOAT,\n+** SQLITE_BLOB, SQLITE_NULL, or SQLITE_TEXT.\n+*\/\n+case OP_IsNullOrType: {      \/* jump, in1 *\/\n+  int doTheJump;\n+  pIn1 = &aMem[pOp->p1];\n+  doTheJump = (pIn1->flags & MEM_Null)!=0 || sqlite3_value_type(pIn1)==pOp->p3;\n+  VdbeBranchTaken( doTheJump, 2);\n+  if( doTheJump ) goto jump_to_p2;\n+  break;\n+}\n+\n+\/* Opcode: ZeroOrNull P1 P2 P3 * *\n+** Synopsis: r[P2] = 0 OR NULL\n+**\n+** If all both registers P1 and P3 are NOT NULL, then store a zero in\n+** register P2.  If either registers P1 or P3 are NULL then put\n+** a NULL in register P2.\n+*\/\n+case OP_ZeroOrNull: {            \/* in1, in2, out2, in3 *\/\n+  if( (aMem[pOp->p1].flags & MEM_Null)!=0\n+   || (aMem[pOp->p3].flags & MEM_Null)!=0\n+  ){\n+    sqlite3VdbeMemSetNull(aMem + pOp->p2);\n+  }else{\n+    sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);\n+  }\n+  break;\n+}\n+\n@@ -87728,1 +89342,1 @@\n-  int p2;            \/* column number to retrieve *\/\n+  u32 p2;            \/* column number to retrieve *\/\n@@ -87746,1 +89360,1 @@\n-  p2 = pOp->p2;\n+  p2 = (u32)pOp->p2;\n@@ -87758,1 +89372,1 @@\n-  assert( p2<pC->nField );\n+  assert( p2<(u32)pC->nField );\n@@ -87873,1 +89487,1 @@\n-      }while( i<=p2 && zHdr<zEndHdr );\n+      }while( (u32)i<=p2 && zHdr<zEndHdr );\n@@ -87995,0 +89609,102 @@\n+\/* Opcode: TypeCheck P1 P2 P3 P4 *\n+** Synopsis: typecheck(r[P1@P2])\n+**\n+** Apply affinities to the range of P2 registers beginning with P1.\n+** Take the affinities from the Table object in P4.  If any value\n+** cannot be coerced into the correct type, then raise an error.\n+**\n+** This opcode is similar to OP_Affinity except that this opcode\n+** forces the register type to the Table column type.  This is used\n+** to implement \"strict affinity\".\n+**\n+** GENERATED ALWAYS AS ... STATIC columns are only checked if P3\n+** is zero.  When P3 is non-zero, no type checking occurs for\n+** static generated columns.  Virtual columns are computed at query time\n+** and so they are never checked.\n+**\n+** Preconditions:\n+**\n+** <ul>\n+** <li> P2 should be the number of non-virtual columns in the\n+**      table of P4.\n+** <li> Table P4 should be a STRICT table.\n+** <\/ul>\n+**\n+** If any precondition is false, an assertion fault occurs.\n+*\/\n+case OP_TypeCheck: {\n+  Table *pTab;\n+  Column *aCol;\n+  int i;\n+\n+  assert( pOp->p4type==P4_TABLE );\n+  pTab = pOp->p4.pTab;\n+  assert( pTab->tabFlags & TF_Strict );\n+  assert( pTab->nNVCol==pOp->p2 );\n+  aCol = pTab->aCol;\n+  pIn1 = &aMem[pOp->p1];\n+  for(i=0; i<pTab->nCol; i++){\n+    if( aCol[i].colFlags & COLFLAG_GENERATED ){\n+      if( aCol[i].colFlags & COLFLAG_VIRTUAL ) continue;\n+      if( pOp->p3 ){ pIn1++; continue; }\n+    }\n+    assert( pIn1 < &aMem[pOp->p1+pOp->p2] );\n+    applyAffinity(pIn1, aCol[i].affinity, encoding);\n+    if( (pIn1->flags & MEM_Null)==0 ){\n+      switch( aCol[i].eCType ){\n+        case COLTYPE_BLOB: {\n+          if( (pIn1->flags & MEM_Blob)==0 ) goto vdbe_type_error;\n+          break;\n+        }\n+        case COLTYPE_INTEGER:\n+        case COLTYPE_INT: {\n+          if( (pIn1->flags & MEM_Int)==0 ) goto vdbe_type_error;\n+          break;\n+        }\n+        case COLTYPE_TEXT: {\n+          if( (pIn1->flags & MEM_Str)==0 ) goto vdbe_type_error;\n+          break;\n+        }\n+        case COLTYPE_REAL: {\n+          if( pIn1->flags & MEM_Int ){\n+            \/* When applying REAL affinity, if the result is still an MEM_Int\n+            ** that will fit in 6 bytes, then change the type to MEM_IntReal\n+            ** so that we keep the high-resolution integer value but know that\n+            ** the type really wants to be REAL. *\/\n+            testcase( pIn1->u.i==140737488355328LL );\n+            testcase( pIn1->u.i==140737488355327LL );\n+            testcase( pIn1->u.i==-140737488355328LL );\n+            testcase( pIn1->u.i==-140737488355329LL );\n+            if( pIn1->u.i<=140737488355327LL && pIn1->u.i>=-140737488355328LL){\n+              pIn1->flags |= MEM_IntReal;\n+              pIn1->flags &= ~MEM_Int;\n+            }else{\n+              pIn1->u.r = (double)pIn1->u.i;\n+              pIn1->flags |= MEM_Real;\n+              pIn1->flags &= ~MEM_Int;\n+            }\n+          }else if( (pIn1->flags & MEM_Real)==0 ){\n+            goto vdbe_type_error;\n+          }\n+          break;\n+        }\n+        default: {\n+          \/* COLTYPE_ANY.  Accept anything. *\/\n+          break;\n+        }\n+      }\n+    }\n+    REGISTER_TRACE((int)(pIn1-aMem), pIn1);\n+    pIn1++;\n+  }\n+  assert( pIn1 == &aMem[pOp->p1+pOp->p2] );\n+  break;\n+\n+vdbe_type_error:\n+  sqlite3VdbeError(p, \"cannot store %s value in %s column %s.%s\",\n+     vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType-1],\n+     pTab->zName, aCol[i].zCnName);\n+  rc = SQLITE_CONSTRAINT_DATATYPE;\n+  goto abort_due_to_error;\n+}\n+\n@@ -88057,0 +89773,11 @@\n+**\n+** The meaning of P5 depends on whether or not the SQLITE_ENABLE_NULL_TRIM\n+** compile-time option is enabled:\n+**\n+**   * If SQLITE_ENABLE_NULL_TRIM is enabled, then the P5 is the index\n+**     of the right-most table that can be null-trimmed.\n+**\n+**   * If SQLITE_ENABLE_NULL_TRIM is omitted, then P5 has the value\n+**     OPFLAG_NOCHNG_MAGIC if the OP_MakeRecord opcode is allowed to\n+**     accept no-change records with serial_type 10.  This value is\n+**     only used inside an assert() and does not affect the end result.\n@@ -88175,0 +89902,1 @@\n+#ifndef SQLITE_ENABLE_NULL_TRIM\n@@ -88176,0 +89904,1 @@\n+#endif\n@@ -88607,1 +90336,2 @@\n-** If P2 is zero, then a read-transaction is started.\n+** If P2 is zero, then a read-transaction is started.  If P2 is 2 or more\n+** then an exclusive transaction is started.\n@@ -88641,0 +90371,1 @@\n+  assert( pOp->p2>=0 && pOp->p2<=2 );\n@@ -88643,2 +90374,10 @@\n-  if( pOp->p2 && (db->flags & SQLITE_QueryOnly)!=0 ){\n-    rc = SQLITE_READONLY;\n+  assert( rc==SQLITE_OK );\n+  if( pOp->p2 && (db->flags & (SQLITE_QueryOnly|SQLITE_CorruptRdOnly))!=0 ){\n+    if( db->flags & SQLITE_QueryOnly ){\n+      \/* Writes prohibited by the \"PRAGMA query_only=TRUE\" statement *\/\n+      rc = SQLITE_READONLY;\n+    }else{\n+      \/* Writes prohibited due to a prior SQLITE_CORRUPT in the current\n+      ** transaction *\/\n+      rc = SQLITE_CORRUPT;\n+    }\n@@ -88666,1 +90405,1 @@\n-      assert( sqlite3BtreeIsInTrans(pBt) );\n+      assert( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE );\n@@ -88686,1 +90425,2 @@\n-  if( pOp->p5\n+  if( rc==SQLITE_OK\n+   && pOp->p5\n@@ -88751,1 +90491,1 @@\n-\/* Opcode: SetCookie P1 P2 P3 * *\n+\/* Opcode: SetCookie P1 P2 P3 * P5\n@@ -88760,0 +90500,5 @@\n+**\n+** If P2 is the SCHEMA_VERSION cookie (cookie number 1) then the internal\n+** schema version is set to P3-P5.  The \"PRAGMA schema_version=N\" statement\n+** has P5 set to 1, so that the internal schema version will be different\n+** from the database schema version, resulting in a schema reset.\n@@ -88776,1 +90521,1 @@\n-    pDb->pSchema->schema_cookie = pOp->p3;\n+    pDb->pSchema->schema_cookie = pOp->p3 - pOp->p5;\n@@ -88778,0 +90523,1 @@\n+    sqlite3FkClearTriggerCache(db, pOp->p1);\n@@ -88879,1 +90625,1 @@\n-  int p2;\n+  u32 p2;\n@@ -88891,0 +90637,2 @@\n+    assert( pCur->eCurType==CURTYPE_BTREE );\n+    sqlite3BtreeClearCursor(pCur->uc.pCursor);\n@@ -88910,1 +90658,1 @@\n-  p2 = pOp->p2;\n+  p2 = (u32)pOp->p2;\n@@ -88929,1 +90677,1 @@\n-    assert( p2<=(p->nMem+1 - p->nCursor) );\n+    assert( p2<=(u32)(p->nMem+1 - p->nCursor) );\n@@ -88994,1 +90742,1 @@\n-  assert( pOrig->pBtx!=0 );  \/* Only ephemeral cursors can be duplicated *\/\n+  assert( pOrig->isEphemeral );  \/* Only ephemeral cursors can be duplicated *\/\n@@ -89004,1 +90752,4 @@\n-  rc = sqlite3BtreeCursor(pOrig->pBtx, pCx->pgnoRoot, BTREE_WRCSR,\n+  pCx->pBtx = pOrig->pBtx;\n+  pCx->hasBeenDuped = 1;\n+  pOrig->hasBeenDuped = 1;\n+  rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,\n@@ -89014,1 +90765,1 @@\n-\/* Opcode: OpenEphemeral P1 P2 * P4 P5\n+\/* Opcode: OpenEphemeral P1 P2 P3 P4 P5\n@@ -89034,0 +90785,4 @@\n+**\n+** If P3 is positive, then reg[P3] is modified slightly so that it\n+** can be used as zero-length data for OP_Insert.  This is an optimization\n+** that avoids an extra OP_Blob opcode to initialize that register.\n@@ -89056,0 +90811,9 @@\n+  if( pOp->p3>0 ){\n+    \/* Make register reg[P3] into a value that can be used as the data\n+    ** form sqlite3BtreeInsert() where the length of the data is zero. *\/\n+    assert( pOp->p2==0 ); \/* Only used when number of columns is zero *\/\n+    assert( pOp->opcode==OP_OpenEphemeral );\n+    assert( aMem[pOp->p3].flags & MEM_Null );\n+    aMem[pOp->p3].n = 0;\n+    aMem[pOp->p3].z = \"\";\n+  }\n@@ -89057,3 +90821,4 @@\n-  if( pCx && pCx->pBtx ){\n-    \/* If the ephermeral table is already open, erase all existing content\n-    ** so that the table is empty again, rather than creating a new table. *\/\n+  if( pCx && !pCx->hasBeenDuped &&  ALWAYS(pOp->p2<=pCx->nField) ){\n+    \/* If the ephermeral table is already open and has no duplicates from\n+    ** OP_OpenDup, then erase all existing content so that the table is\n+    ** empty again, rather than creating a new table. *\/\n@@ -89073,17 +90838,23 @@\n-    }\n-    if( rc==SQLITE_OK ){\n-      \/* If a transient index is required, create it by calling\n-      ** sqlite3BtreeCreateTable() with the BTREE_BLOBKEY flag before\n-      ** opening it. If a transient table is required, just use the\n-      ** automatically created table with root-page 1 (an BLOB_INTKEY table).\n-      *\/\n-      if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){\n-        assert( pOp->p4type==P4_KEYINFO );\n-        rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,\n-                                     BTREE_BLOBKEY | pOp->p5);\n-        if( rc==SQLITE_OK ){\n-          assert( pCx->pgnoRoot==MASTER_ROOT+1 );\n-          assert( pKeyInfo->db==db );\n-          assert( pKeyInfo->enc==ENC(db) );\n-          rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,\n-                                  pKeyInfo, pCx->uc.pCursor);\n+      if( rc==SQLITE_OK ){\n+        \/* If a transient index is required, create it by calling\n+        ** sqlite3BtreeCreateTable() with the BTREE_BLOBKEY flag before\n+        ** opening it. If a transient table is required, just use the\n+        ** automatically created table with root-page 1 (an BLOB_INTKEY table).\n+        *\/\n+        if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){\n+          assert( pOp->p4type==P4_KEYINFO );\n+          rc = sqlite3BtreeCreateTable(pCx->pBtx, &pCx->pgnoRoot,\n+              BTREE_BLOBKEY | pOp->p5);\n+          if( rc==SQLITE_OK ){\n+            assert( pCx->pgnoRoot==SCHEMA_ROOT+1 );\n+            assert( pKeyInfo->db==db );\n+            assert( pKeyInfo->enc==ENC(db) );\n+            rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,\n+                pKeyInfo, pCx->uc.pCursor);\n+          }\n+          pCx->isTable = 0;\n+        }else{\n+          pCx->pgnoRoot = SCHEMA_ROOT;\n+          rc = sqlite3BtreeCursor(pCx->pBtx, SCHEMA_ROOT, BTREE_WRCSR,\n+              0, pCx->uc.pCursor);\n+          pCx->isTable = 1;\n@@ -89091,6 +90862,4 @@\n-        pCx->isTable = 0;\n-      }else{\n-        pCx->pgnoRoot = MASTER_ROOT;\n-        rc = sqlite3BtreeCursor(pCx->pBtx, MASTER_ROOT, BTREE_WRCSR,\n-                                0, pCx->uc.pCursor);\n-        pCx->isTable = 1;\n+      }\n+      pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);\n+      if( rc ){\n+        sqlite3BtreeClose(pCx->pBtx);\n@@ -89099,1 +90868,0 @@\n-    pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);\n@@ -89358,0 +91126,1 @@\n+      int c;\n@@ -89367,1 +91136,2 @@\n-      }else\n+      }\n+      c = sqlite3IntFloatCompare(iKey, pIn3->u.r);\n@@ -89376,1 +91146,1 @@\n-      if( pIn3->u.r<(double)iKey ){\n+      if( c>0 ){\n@@ -89385,1 +91155,1 @@\n-      else if( pIn3->u.r>(double)iKey ){\n+      else if( c<0 ){\n@@ -89392,1 +91162,1 @@\n-    rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)iKey, 0, &res);\n+    rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);\n@@ -89439,1 +91209,1 @@\n-    rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, &r, 0, 0, &res);\n+    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);\n@@ -89498,2 +91268,144 @@\n-\/* Opcode: SeekHit P1 P2 * * *\n-** Synopsis: seekHit=P2\n+\n+\/* Opcode: SeekScan  P1 P2 * * *\n+** Synopsis: Scan-ahead up to P1 rows\n+**\n+** This opcode is a prefix opcode to OP_SeekGE.  In other words, this\n+** opcode must be immediately followed by OP_SeekGE. This constraint is\n+** checked by assert() statements.\n+**\n+** This opcode uses the P1 through P4 operands of the subsequent\n+** OP_SeekGE.  In the text that follows, the operands of the subsequent\n+** OP_SeekGE opcode are denoted as SeekOP.P1 through SeekOP.P4.   Only\n+** the P1 and P2 operands of this opcode are also used, and  are called\n+** This.P1 and This.P2.\n+**\n+** This opcode helps to optimize IN operators on a multi-column index\n+** where the IN operator is on the later terms of the index by avoiding\n+** unnecessary seeks on the btree, substituting steps to the next row\n+** of the b-tree instead.  A correct answer is obtained if this opcode\n+** is omitted or is a no-op.\n+**\n+** The SeekGE.P3 and SeekGE.P4 operands identify an unpacked key which\n+** is the desired entry that we want the cursor SeekGE.P1 to be pointing\n+** to.  Call this SeekGE.P4\/P5 row the \"target\".\n+**\n+** If the SeekGE.P1 cursor is not currently pointing to a valid row,\n+** then this opcode is a no-op and control passes through into the OP_SeekGE.\n+**\n+** If the SeekGE.P1 cursor is pointing to a valid row, then that row\n+** might be the target row, or it might be near and slightly before the\n+** target row.  This opcode attempts to position the cursor on the target\n+** row by, perhaps by invoking sqlite3BtreeStep() on the cursor\n+** between 0 and This.P1 times.\n+**\n+** There are three possible outcomes from this opcode:<ol>\n+**\n+** <li> If after This.P1 steps, the cursor is still pointing to a place that\n+**      is earlier in the btree than the target row, then fall through\n+**      into the subsquence OP_SeekGE opcode.\n+**\n+** <li> If the cursor is successfully moved to the target row by 0 or more\n+**      sqlite3BtreeNext() calls, then jump to This.P2, which will land just\n+**      past the OP_IdxGT or OP_IdxGE opcode that follows the OP_SeekGE.\n+**\n+** <li> If the cursor ends up past the target row (indicating the the target\n+**      row does not exist in the btree) then jump to SeekOP.P2.\n+** <\/ol>\n+*\/\n+case OP_SeekScan: {\n+  VdbeCursor *pC;\n+  int res;\n+  int nStep;\n+  UnpackedRecord r;\n+\n+  assert( pOp[1].opcode==OP_SeekGE );\n+\n+  \/* pOp->p2 points to the first instruction past the OP_IdxGT that\n+  ** follows the OP_SeekGE.  *\/\n+  assert( pOp->p2>=(int)(pOp-aOp)+2 );\n+  assert( aOp[pOp->p2-1].opcode==OP_IdxGT || aOp[pOp->p2-1].opcode==OP_IdxGE );\n+  testcase( aOp[pOp->p2-1].opcode==OP_IdxGE );\n+  assert( pOp[1].p1==aOp[pOp->p2-1].p1 );\n+  assert( pOp[1].p2==aOp[pOp->p2-1].p2 );\n+  assert( pOp[1].p3==aOp[pOp->p2-1].p3 );\n+\n+  assert( pOp->p1>0 );\n+  pC = p->apCsr[pOp[1].p1];\n+  assert( pC!=0 );\n+  assert( pC->eCurType==CURTYPE_BTREE );\n+  assert( !pC->isTable );\n+  if( !sqlite3BtreeCursorIsValidNN(pC->uc.pCursor) ){\n+#ifdef SQLITE_DEBUG\n+     if( db->flags&SQLITE_VdbeTrace ){\n+       printf(\"... cursor not valid - fall through\\n\");\n+     }\n+#endif\n+    break;\n+  }\n+  nStep = pOp->p1;\n+  assert( nStep>=1 );\n+  r.pKeyInfo = pC->pKeyInfo;\n+  r.nField = (u16)pOp[1].p4.i;\n+  r.default_rc = 0;\n+  r.aMem = &aMem[pOp[1].p3];\n+#ifdef SQLITE_DEBUG\n+  {\n+    int i;\n+    for(i=0; i<r.nField; i++){\n+      assert( memIsValid(&r.aMem[i]) );\n+      REGISTER_TRACE(pOp[1].p3+i, &aMem[pOp[1].p3+i]);\n+    }\n+  }\n+#endif\n+  res = 0;  \/* Not needed.  Only used to silence a warning. *\/\n+  while(1){\n+    rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);\n+    if( rc ) goto abort_due_to_error;\n+    if( res>0 ){\n+      seekscan_search_fail:\n+#ifdef SQLITE_DEBUG\n+      if( db->flags&SQLITE_VdbeTrace ){\n+        printf(\"... %d steps and then skip\\n\", pOp->p1 - nStep);\n+      }\n+#endif\n+      VdbeBranchTaken(1,3);\n+      pOp++;\n+      goto jump_to_p2;\n+    }\n+    if( res==0 ){\n+#ifdef SQLITE_DEBUG\n+      if( db->flags&SQLITE_VdbeTrace ){\n+        printf(\"... %d steps and then success\\n\", pOp->p1 - nStep);\n+      }\n+#endif\n+      VdbeBranchTaken(2,3);\n+      goto jump_to_p2;\n+      break;\n+    }\n+    if( nStep<=0 ){\n+#ifdef SQLITE_DEBUG\n+      if( db->flags&SQLITE_VdbeTrace ){\n+        printf(\"... fall through after %d steps\\n\", pOp->p1);\n+      }\n+#endif\n+      VdbeBranchTaken(0,3);\n+      break;\n+    }\n+    nStep--;\n+    rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n+    if( rc ){\n+      if( rc==SQLITE_DONE ){\n+        rc = SQLITE_OK;\n+        goto seekscan_search_fail;\n+      }else{\n+        goto abort_due_to_error;\n+      }\n+    }\n+  }\n+\n+  break;\n+}\n+\n+\n+\/* Opcode: SeekHit P1 P2 P3 * *\n+** Synopsis: set P2<=seekHit<=P3\n@@ -89501,2 +91413,2 @@\n-** Set the seekHit flag on cursor P1 to the value in P2.\n-* The seekHit flag is used by the IfNoHope opcode.\n+** Increase or decrease the seekHit value for cursor P1, if necessary,\n+** so that it is no less than P2 and no greater than P3.\n@@ -89504,2 +91416,7 @@\n-** P1 must be a valid b-tree cursor.  P2 must be a boolean value,\n-** either 0 or 1.\n+** The seekHit integer represents the maximum of terms in an index for which\n+** there is known to be at least one match.  If the seekHit value is smaller\n+** than the total number of equality terms in an index lookup, then the\n+** OP_IfNoHope opcode might run to see if the IN loop can be abandoned\n+** early, thus saving work.  This is part of the IN-early-out optimization.\n+**\n+** P1 must be a valid b-tree cursor.\n@@ -89512,2 +91429,16 @@\n-  assert( pOp->p2==0 || pOp->p2==1 );\n-  pC->seekHit = pOp->p2 & 1;\n+  assert( pOp->p3>=pOp->p2 );\n+  if( pC->seekHit<pOp->p2 ){\n+#ifdef SQLITE_DEBUG\n+    if( db->flags&SQLITE_VdbeTrace ){\n+      printf(\"seekHit changes from %d to %d\\n\", pC->seekHit, pOp->p2);\n+    }\n+#endif\n+    pC->seekHit = pOp->p2;\n+  }else if( pC->seekHit>pOp->p3 ){\n+#ifdef SQLITE_DEBUG\n+    if( db->flags&SQLITE_VdbeTrace ){\n+      printf(\"seekHit changes from %d to %d\\n\", pC->seekHit, pOp->p3);\n+    }\n+#endif\n+    pC->seekHit = pOp->p3;\n+  }\n@@ -89571,1 +91502,3 @@\n-** record.\n+** record.  Cursor P1 is an index btree.  P2 is a jump destination.\n+** In other words, the operands to this opcode are the same as the\n+** operands to OP_NotFound and OP_IdxGT.\n@@ -89573,5 +91506,3 @@\n-** Cursor P1 is on an index btree.  If the seekHit flag is set on P1, then\n-** this opcode is a no-op.  But if the seekHit flag of P1 is clear, then\n-** check to see if there is any entry in P1 that matches the\n-** prefix identified by P3 and P4.  If no entry matches the prefix,\n-** jump to P2.  Otherwise fall through.\n+** This opcode is an optimization attempt only.  If this opcode always\n+** falls through, the correct answer is still obtained, but extra works\n+** is performed.\n@@ -89579,2 +91510,6 @@\n-** This opcode behaves like OP_NotFound if the seekHit\n-** flag is clear and it behaves like OP_Noop if the seekHit flag is set.\n+** A value of N in the seekHit flag of cursor P1 means that there exists\n+** a key P3:N that will match some record in the index.  We want to know\n+** if it is possible for a record P3:P4 to match some record in the\n+** index.  If it is not possible, we can skips some work.  So if seekHit\n+** is less than P4, attempt to find out if a match is possible by running\n+** OP_NotFound.\n@@ -89622,1 +91557,6 @@\n-  if( pC->seekHit ) break;\n+#ifdef SQLITE_DEBUG\n+  if( db->flags&SQLITE_VdbeTrace ){\n+    printf(\"seekHit is %d\\n\", pC->seekHit);\n+  }\n+#endif\n+  if( pC->seekHit>=pOp->p4.i ) break;\n@@ -89624,0 +91564,1 @@\n+  \/* no break *\/ deliberate_fall_through\n@@ -89687,1 +91628,1 @@\n-  rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, pIdxKey, 0, 0, &res);\n+  rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &res);\n@@ -89703,0 +91644,1 @@\n+    if( pOp->opcode==OP_IfNoHope ) pC->seekHit = pOp->p4.i;\n@@ -89778,0 +91720,1 @@\n+  \/* no break *\/ deliberate_fall_through\n@@ -89794,1 +91737,1 @@\n-  rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);\n+  rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);\n@@ -89852,0 +91795,1 @@\n+#ifndef SQLITE_OMIT_AUTOINCREMENT\n@@ -89854,0 +91798,1 @@\n+#endif\n@@ -89949,1 +91894,1 @@\n-      }while(  ((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)v,\n+      }while(  ((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v,\n@@ -90039,1 +91984,1 @@\n-    zDb = 0;  \/* Not needed.  Silence a compiler warning. *\/\n+    zDb = 0;\n@@ -90046,1 +91991,1 @@\n-      sqlite3VdbePreUpdateHook(p, pC, SQLITE_INSERT, zDb, pTab, x.nKey,pOp->p2);\n+      sqlite3VdbePreUpdateHook(p,pC,SQLITE_INSERT,zDb,pTab,x.nKey,pOp->p2,-1);\n@@ -90058,1 +92003,1 @@\n-  assert( pData->flags & (MEM_Blob|MEM_Str) );\n+  assert( (pData->flags & (MEM_Blob|MEM_Str))!=0 || pData->n==0 );\n@@ -90069,1 +92014,2 @@\n-      (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)), seekResult\n+      (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION|OPFLAG_PREFORMAT)),\n+      seekResult\n@@ -90086,0 +92032,27 @@\n+\/* Opcode: RowCell P1 P2 P3 * *\n+**\n+** P1 and P2 are both open cursors. Both must be opened on the same type\n+** of table - intkey or index. This opcode is used as part of copying\n+** the current row from P2 into P1. If the cursors are opened on intkey\n+** tables, register P3 contains the rowid to use with the new record in\n+** P1. If they are opened on index tables, P3 is not used.\n+**\n+** This opcode must be followed by either an Insert or InsertIdx opcode\n+** with the OPFLAG_PREFORMAT flag set to complete the insert operation.\n+*\/\n+case OP_RowCell: {\n+  VdbeCursor *pDest;              \/* Cursor to write to *\/\n+  VdbeCursor *pSrc;               \/* Cursor to read from *\/\n+  i64 iKey;                       \/* Rowid value to insert with *\/\n+  assert( pOp[1].opcode==OP_Insert || pOp[1].opcode==OP_IdxInsert );\n+  assert( pOp[1].opcode==OP_Insert    || pOp->p3==0 );\n+  assert( pOp[1].opcode==OP_IdxInsert || pOp->p3>0 );\n+  assert( pOp[1].p5 & OPFLAG_PREFORMAT );\n+  pDest = p->apCsr[pOp->p1];\n+  pSrc = p->apCsr[pOp->p2];\n+  iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;\n+  rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);\n+  if( rc!=SQLITE_OK ) goto abort_due_to_error;\n+  break;\n+};\n+\n@@ -90164,2 +92137,2 @@\n-    zDb = 0;   \/* Not needed.  Silence a compiler warning. *\/\n-    pTab = 0;  \/* Not needed.  Silence a compiler warning. *\/\n+    zDb = 0;\n+    pTab = 0;\n@@ -90170,1 +92143,2 @@\n-  if( db->xPreUpdateCallback && pOp->p4.pTab ){\n+  assert( db->xPreUpdateCallback==0 || pTab==pOp->p4.pTab );\n+  if( db->xPreUpdateCallback && pTab ){\n@@ -90178,1 +92152,1 @@\n-        pOp->p3\n+        pOp->p3, -1\n@@ -90211,1 +92185,1 @@\n-    if( db->xUpdateCallback && HasRowid(pTab) ){\n+    if( db->xUpdateCallback && ALWAYS(pTab!=0) && HasRowid(pTab) ){\n@@ -90346,4 +92320,0 @@\n-#if 0  \/* Not required due to the previous to assert() statements *\/\n-  rc = sqlite3VdbeCursorMoveto(pC);\n-  if( rc!=SQLITE_OK ) goto abort_due_to_error;\n-#endif\n@@ -90553,0 +92523,1 @@\n+  \/* no break *\/ deliberate_fall_through\n@@ -90744,1 +92715,1 @@\n-  assert( pIn2->flags & MEM_Blob );\n+  assert( (pIn2->flags & MEM_Blob) || (pOp->p5 & OPFLAG_PREFORMAT) );\n@@ -90755,1 +92726,1 @@\n-       (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)),\n+       (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION|OPFLAG_PREFORMAT)),\n@@ -90801,1 +92772,2 @@\n-** entry is found.  For those cases, P5 is zero.\n+** entry is found.  For those cases, P5 is zero.  Also, do not raise\n+** this (self-correcting and non-critical) error if in writable_schema mode.\n@@ -90822,1 +92794,1 @@\n-  rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);\n+  rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);\n@@ -90827,2 +92799,2 @@\n-  }else if( pOp->p5 ){\n-    rc = SQLITE_CORRUPT_INDEX;\n+  }else if( pOp->p5 && !sqlite3WritableSchema(db) ){\n+    rc = sqlite3ReportError(SQLITE_CORRUPT_INDEX, __LINE__, \"index corruption\");\n@@ -90907,0 +92879,2 @@\n+      assert( !pC->isEphemeral );\n+      assert( !pTabCur->isEphemeral );\n@@ -90937,1 +92911,1 @@\n-\/* Opcode: IdxGE P1 P2 P3 P4 P5\n+\/* Opcode: IdxGE P1 P2 P3 P4 *\n@@ -90948,1 +92922,1 @@\n-\/* Opcode: IdxGT P1 P2 P3 P4 P5\n+\/* Opcode: IdxGT P1 P2 P3 P4 *\n@@ -90959,1 +92933,1 @@\n-\/* Opcode: IdxLT P1 P2 P3 P4 P5\n+\/* Opcode: IdxLT P1 P2 P3 P4 *\n@@ -90970,1 +92944,1 @@\n-\/* Opcode: IdxLE P1 P2 P3 P4 P5\n+\/* Opcode: IdxLE P1 P2 P3 P4 *\n@@ -90996,1 +92970,0 @@\n-  assert( pOp->p5==0 || pOp->p5==1 );\n@@ -91017,2 +92990,25 @@\n-  res = 0;  \/* Not needed.  Only used to silence a warning. *\/\n-  rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);\n+\n+  \/* Inlined version of sqlite3VdbeIdxKeyCompare() *\/\n+  {\n+    i64 nCellKey = 0;\n+    BtCursor *pCur;\n+    Mem m;\n+\n+    assert( pC->eCurType==CURTYPE_BTREE );\n+    pCur = pC->uc.pCursor;\n+    assert( sqlite3BtreeCursorIsValid(pCur) );\n+    nCellKey = sqlite3BtreePayloadSize(pCur);\n+    \/* nCellKey will always be between 0 and 0xffffffff because of the way\n+    ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented *\/\n+    if( nCellKey<=0 || nCellKey>0x7fffffff ){\n+      rc = SQLITE_CORRUPT_BKPT;\n+      goto abort_due_to_error;\n+    }\n+    sqlite3VdbeMemInit(&m, db, 0);\n+    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n+    if( rc ) goto abort_due_to_error;\n+    res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);\n+    sqlite3VdbeMemRelease(&m);\n+  }\n+  \/* End of inlined sqlite3VdbeIdxKeyCompare() *\/\n+\n@@ -91028,1 +93024,1 @@\n-  if( rc ) goto abort_due_to_error;\n+  assert( rc==SQLITE_OK );\n@@ -91103,5 +93099,4 @@\n-** If the P3 value is non-zero, then the table referred to must be an\n-** intkey table (an SQL table, not an index). In this case the row change\n-** count is incremented by the number of rows in the table being cleared.\n-** If P3 is greater than zero, then the value stored in register P3 is\n-** also incremented by the number of rows in the table being cleared.\n+** If the P3 value is non-zero, then the row change count is incremented\n+** by the number of rows in the table being cleared. If P3 is greater\n+** than zero, then the value stored in register P3 is also incremented\n+** by the number of rows in the table being cleared.\n@@ -91112,1 +93107,1 @@\n-  int nChange;\n+  i64 nChange;\n@@ -91118,3 +93113,1 @@\n-  rc = sqlite3BtreeClearTable(\n-      db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)\n-  );\n+  rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);\n@@ -91168,1 +93161,1 @@\n-  int pgno;\n+  Pgno pgno;\n@@ -91201,1 +93194,1 @@\n-** Read and parse all entries from the SQLITE_MASTER table of database P1\n+** Read and parse all entries from the schema table of database P1\n@@ -91210,1 +93203,1 @@\n-  const char *zMaster;\n+  const char *zSchema;\n@@ -91226,1 +93219,3 @@\n-  assert( DbHasProperty(db, iDb, DB_SchemaLoaded) );\n+  assert( DbHasProperty(db, iDb, DB_SchemaLoaded)\n+           || db->mallocFailed\n+           || (CORRUPT_DB && (db->flags & SQLITE_NoSchemaError)!=0) );\n@@ -91232,1 +93227,1 @@\n-    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, INITFLAG_AlterTable);\n+    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);\n@@ -91238,1 +93233,1 @@\n-    zMaster = MASTER_NAME;\n+    zSchema = LEGACY_SCHEMA_TABLE;\n@@ -91243,0 +93238,1 @@\n+    initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);\n@@ -91245,1 +93241,1 @@\n-       db->aDb[iDb].zDbSName, zMaster, pOp->p4.z);\n+       db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);\n@@ -91259,1 +93255,1 @@\n-        ** the sqlite_master table is corrupt. *\/\n+        ** the sqlite_schema table is corrupt. *\/\n@@ -91356,1 +93352,1 @@\n-  int *aRoot;     \/* Array of rootpage numbers for tables to be checked *\/\n+  Pgno *aRoot;    \/* Array of rootpage numbers for tables to be checked *\/\n@@ -91365,1 +93361,1 @@\n-  assert( aRoot[0]==nRoot );\n+  assert( aRoot[0]==(Pgno)nRoot );\n@@ -91905,0 +93901,1 @@\n+  \/* no break *\/ deliberate_fall_through\n@@ -92106,0 +94103,1 @@\n+  assert( sqlite3BtreeHoldsMutex(pBt) );\n@@ -92152,1 +94150,1 @@\n-      assert( sqlite3BtreeIsInTrans(pBt)==0 );\n+      assert( sqlite3BtreeTxnState(pBt)!=SQLITE_TXN_WRITE );\n@@ -92455,0 +94453,1 @@\n+  assert( pCur!=0 );\n@@ -92466,1 +94465,0 @@\n-  res = 0;\n@@ -92504,0 +94502,1 @@\n+  assert( pCur!=0 );\n@@ -92556,1 +94555,0 @@\n-  res = 0;\n@@ -92558,0 +94556,1 @@\n+  assert( pCur!=0 );\n@@ -92653,1 +94652,1 @@\n-  sqlite_int64 rowid;\n+  sqlite_int64 rowid = 0;\n@@ -92894,1 +94893,0 @@\n-      void (*x)(void*,const char*) = (void(*)(void*,const char*))db->xTrace;\n@@ -92896,1 +94894,1 @@\n-      x(db->pTraceArg, z);\n+      db->trace.xLegacy(db->pTraceArg, z);\n@@ -92902,1 +94900,1 @@\n-      (void)db->xTrace(SQLITE_TRACE_STMT, db->pTraceArg, p, z);\n+      (void)db->trace.xV2(SQLITE_TRACE_STMT, db->pTraceArg, p, z);\n@@ -92905,1 +94903,1 @@\n-      (void)db->xTrace(SQLITE_TRACE_STMT, db->pTraceArg, p, zTrace);\n+      (void)db->trace.xV2(SQLITE_TRACE_STMT, db->pTraceArg, p, zTrace);\n@@ -93093,1 +95091,5 @@\n-  if( db->mallocFailed ) rc = SQLITE_NOMEM_BKPT;\n+  if( db->mallocFailed ){\n+    rc = SQLITE_NOMEM_BKPT;\n+  }else if( rc==SQLITE_IOERR_CORRUPTFS ){\n+    rc = SQLITE_CORRUPT_BKPT;\n+  }\n@@ -93095,0 +95097,12 @@\n+#ifdef SQLITE_DEBUG\n+  if( db->flags & SQLITE_VdbeTrace ){\n+    const char *zTrace = p->zSql;\n+    if( zTrace==0 ){\n+      if( aOp[0].opcode==OP_Trace ){\n+        zTrace = aOp[0].p4.z;\n+      }\n+      if( zTrace==0 ) zTrace = \"???\";\n+    }\n+    printf(\"ABORT-due-to-error (rc=%d): %s\\n\", rc, zTrace);\n+  }\n+#endif\n@@ -93105,0 +95119,3 @@\n+  if( rc==SQLITE_CORRUPT && db->autoCommit==0 ){\n+    db->flags |= SQLITE_CorruptRdOnly;\n+  }\n@@ -93118,1 +95135,1 @@\n-      nProgressLimit = 0xffffffff;\n+      nProgressLimit = LARGEST_UINT64;\n@@ -93152,3 +95169,1 @@\n-  rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;\n-  p->rc = rc;\n-  sqlite3VdbeError(p, \"%s\", sqlite3ErrStr(rc));\n+  rc = SQLITE_INTERRUPT;\n@@ -93238,1 +95253,4 @@\n-    u32 type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;\n+    u32 type;\n+    assert( pC!=0 );\n+    assert( pC->eCurType==CURTYPE_BTREE );\n+    type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;\n@@ -93330,1 +95348,1 @@\n-    if( pTab && pTab->pSelect ){\n+    if( pTab && IsView(pTab) ){\n@@ -93350,1 +95368,1 @@\n-      if( sqlite3StrICmp(pTab->aCol[iCol].zName, zColumn)==0 ){\n+      if( sqlite3StrICmp(pTab->aCol[iCol].zCnName, zColumn)==0 ){\n@@ -93375,1 +95393,2 @@\n-        for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n+        assert( IsOrdinaryTable(pTab) );\n+        for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n@@ -93582,0 +95601,2 @@\n+      assert( v->apCsr[0]!=0 );\n+      assert( v->apCsr[0]->eCurType==CURTYPE_BTREE );\n@@ -93583,1 +95604,1 @@\n-          v, v->apCsr[0], SQLITE_DELETE, p->zDb, p->pTab, iKey, -1\n+          v, v->apCsr[0], SQLITE_DELETE, p->zDb, p->pTab, iKey, -1, p->iCol\n@@ -93654,0 +95675,1 @@\n+    ((Vdbe*)p->pStmt)->rc = SQLITE_OK;\n@@ -94644,0 +96666,1 @@\n+    Btree *pBt = db->aDb[0].pBt;\n@@ -94650,1 +96673,3 @@\n-    pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(db->aDb[0].pBt);\n+    sqlite3BtreeEnter(pBt);\n+    pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(pBt);\n+    sqlite3BtreeLeave(pBt);\n@@ -94744,2 +96769,3 @@\n-  i64 t;\n-  sqlite3OsCurrentTimeInt64(sqlite3_vfs_find(0), &t);\n+  i64 t = 0;\n+  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);\n+  if( ALWAYS(pVfs) ) sqlite3OsCurrentTimeInt64(pVfs, &t);\n@@ -94959,1 +96985,1 @@\n-    sqlite3OsUnfetch(pFd, 0, p);\n+    if( p ) sqlite3OsUnfetch(pFd, 0, p);\n@@ -95677,0 +97703,1 @@\n+  assert( *ppOut!=0 || rc!=SQLITE_OK );\n@@ -96643,1 +98670,1 @@\n-        int iRoot = pOp->p2;\n+        Pgno iRoot = (Pgno)pOp->p2;\n@@ -96934,1 +98961,0 @@\n-  int nSize;                      \/* Bytes of data currently in memory *\/\n@@ -96995,1 +99021,1 @@\n-static void memjrnlFreeChunks(MemJournal *p){\n+static void memjrnlFreeChunks(FileChunk *pFirst){\n@@ -96998,1 +99024,1 @@\n-  for(pIter=p->pFirst; pIter; pIter=pNext){\n+  for(pIter=pFirst; pIter; pIter=pNext){\n@@ -97002,1 +99028,0 @@\n-  p->pFirst = 0;\n@@ -97029,1 +99054,1 @@\n-      memjrnlFreeChunks(&copy);\n+      memjrnlFreeChunks(copy.pFirst);\n@@ -97112,1 +99137,0 @@\n-      p->nSize = iAmt + iOfst;\n@@ -97120,5 +99144,1 @@\n-** Truncate the file.\n-**\n-** If the journal file is already on disk, truncate it there. Or, if it\n-** is still in main memory but is being truncated to zero bytes in size,\n-** ignore\n+** Truncate the in-memory file.\n@@ -97128,5 +99148,19 @@\n-  if( ALWAYS(size==0) ){\n-    memjrnlFreeChunks(p);\n-    p->nSize = 0;\n-    p->endpoint.pChunk = 0;\n-    p->endpoint.iOffset = 0;\n+  assert( p->endpoint.pChunk==0 || p->endpoint.pChunk->pNext==0 );\n+  if( size<p->endpoint.iOffset ){\n+    FileChunk *pIter = 0;\n+    if( size==0 ){\n+      memjrnlFreeChunks(p->pFirst);\n+      p->pFirst = 0;\n+    }else{\n+      i64 iOff = p->nChunkSize;\n+      for(pIter=p->pFirst; ALWAYS(pIter) && iOff<size; pIter=pIter->pNext){\n+        iOff += p->nChunkSize;\n+      }\n+      if( ALWAYS(pIter) ){\n+        memjrnlFreeChunks(pIter->pNext);\n+        pIter->pNext = 0;\n+      }\n+    }\n+\n+    p->endpoint.pChunk = pIter;\n+    p->endpoint.iOffset = size;\n@@ -97144,1 +99178,1 @@\n-  memjrnlFreeChunks(p);\n+  memjrnlFreeChunks(p->pFirst);\n@@ -97230,1 +99264,1 @@\n-  p->pMethod = (const sqlite3_io_methods*)&MemJournalMethods;\n+  pJfd->pMethods = (const sqlite3_io_methods*)&MemJournalMethods;\n@@ -97256,1 +99290,1 @@\n-  if( p->pMethod==&MemJournalMethods && (\n+  if( pJfd->pMethods==&MemJournalMethods && (\n@@ -97318,1 +99352,1 @@\n-static int walkWindowList(Walker *pWalker, Window *pList){\n+static int walkWindowList(Walker *pWalker, Window *pList, int bOneOnly){\n@@ -97328,5 +99362,0 @@\n-\n-    \/* The next two are purely for calls to sqlite3RenameExprUnmap()\n-    ** within sqlite3WindowOffsetExpr().  Because of constraints imposed\n-    ** by sqlite3WindowOffsetExpr(), they can never fail.  The results do\n-    ** not matter anyhow. *\/\n@@ -97334,1 +99363,1 @@\n-    if( NEVER(rc) ) return WRC_Abort;\n+    if( rc ) return WRC_Abort;\n@@ -97336,1 +99365,2 @@\n-    if( NEVER(rc) ) return WRC_Abort;\n+    if( rc ) return WRC_Abort;\n+    if( bOneOnly ) break;\n@@ -97375,1 +99405,1 @@\n-      }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+      }else if( ExprUseXSelect(pExpr) ){\n@@ -97384,1 +99414,1 @@\n-          if( walkWindowList(pWalker, pExpr->y.pWin) ) return WRC_Abort;\n+          if( walkWindowList(pWalker, pExpr->y.pWin, 1) ) return WRC_Abort;\n@@ -97412,0 +99442,10 @@\n+\/*\n+** This is a no-op callback for Walker->xSelectCallback2.  If this\n+** callback is set, then the Select->pWinDefn list is traversed.\n+*\/\n+SQLITE_PRIVATE void sqlite3WalkWinDefnDummyCallback(Walker *pWalker, Select *p){\n+  UNUSED_PARAMETER(pWalker);\n+  UNUSED_PARAMETER(p);\n+  \/* No-op *\/\n+}\n+\n@@ -97425,4 +99465,9 @@\n-#if !defined(SQLITE_OMIT_WINDOWFUNC) && !defined(SQLITE_OMIT_ALTERTABLE)\n-  {\n-    Parse *pParse = pWalker->pParse;\n-    if( pParse && IN_RENAME_OBJECT ){\n+#if !defined(SQLITE_OMIT_WINDOWFUNC)\n+  if( p->pWinDefn ){\n+    Parse *pParse;\n+    if( pWalker->xSelectCallback2==sqlite3WalkWinDefnDummyCallback\n+     || ((pParse = pWalker->pParse)!=0 && IN_RENAME_OBJECT)\n+#ifndef SQLITE_OMIT_CTE\n+     || pWalker->xSelectCallback2==sqlite3SelectPopWith\n+#endif\n+    ){\n@@ -97431,1 +99476,1 @@\n-      int rc = walkWindowList(pWalker, p->pWinDefn);\n+      int rc = walkWindowList(pWalker, p->pWinDefn, 0);\n@@ -97449,1 +99494,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -97452,1 +99497,1 @@\n-  if( pSrc ){\n+  if( ALWAYS(pSrc) ){\n@@ -97561,0 +99606,5 @@\n+\/*\n+** Magic table number to mean the EXCLUDED table in an UPSERT statement.\n+*\/\n+#define EXCLUDED_TABLE_NUMBER  2\n+\n@@ -97610,1 +99660,0 @@\n-  const char *zType,     \/* \"GROUP\" or \"ORDER\" or \"\" *\/\n@@ -97622,2 +99671,5 @@\n-  if( pDup!=0 ){\n-    if( zType[0]!='G' ) incrAggFunctionDepth(pDup, nSubquery);\n+  if( db->mallocFailed ){\n+    sqlite3ExprDelete(db, pDup);\n+    pDup = 0;\n+  }else{\n+    incrAggFunctionDepth(pDup, nSubquery);\n@@ -97625,0 +99677,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -97644,1 +99697,1 @@\n-      if( pExpr->y.pWin!=0 ){\n+      if( ALWAYS(pExpr->y.pWin!=0) ){\n@@ -97646,2 +99699,0 @@\n-      }else{\n-        assert( db->mallocFailed );\n@@ -97652,1 +99703,0 @@\n-  ExprSetProperty(pExpr, EP_Alias);\n@@ -97731,0 +99781,1 @@\n+  assert( ExprUseYTab(pExpr) );\n@@ -97787,2 +99838,2 @@\n-  struct SrcList_item *pItem;       \/* Use for looping over pSrcList items *\/\n-  struct SrcList_item *pMatch = 0;  \/* The matching pSrcList item *\/\n+  SrcItem *pItem;                   \/* Use for looping over pSrcList items *\/\n+  SrcItem *pMatch = 0;              \/* The matching pSrcList item *\/\n@@ -97844,1 +99895,1 @@\n-        assert( pTab->nCol>0 );\n+        assert( pTab->nCol>0 || pParse->nErr );\n@@ -97868,0 +99919,1 @@\n+          assert( ExprUseYTab(pExpr) );\n@@ -97872,3 +99924,0 @@\n-        if( 0==(cntTab++) ){\n-          pMatch = pItem;\n-        }\n@@ -97877,1 +99926,3 @@\n-          if( pCol->hName==hCol && sqlite3StrICmp(pCol->zName, zCol)==0 ){\n+          if( pCol->hName==hCol\n+           && sqlite3StrICmp(pCol->zCnName, zCol)==0\n+          ){\n@@ -97893,0 +99944,4 @@\n+        if( 0==cnt && VisibleRowid(pTab) ){\n+          cntTab++;\n+          pMatch = pItem;\n+        }\n@@ -97896,0 +99951,1 @@\n+        assert( ExprUseYTab(pExpr) );\n@@ -97909,1 +99965,2 @@\n-    ** maybe it is an excluded.* from an upsert.\n+    ** maybe it is an excluded.* from an upsert.  Or maybe it is\n+    ** a reference in the RETURNING clause to a table being modified.\n@@ -97911,1 +99968,1 @@\n-    if( zDb==0 && zTab!=0 && cntTab==0 ){\n+    if( cnt==0 && zDb==0 ){\n@@ -97917,1 +99974,8 @@\n-        if( op!=TK_DELETE && sqlite3StrICmp(\"new\",zTab) == 0 ){\n+        if( pParse->bReturning ){\n+          if( (pNC->ncFlags & NC_UBaseReg)!=0\n+           && (zTab==0 || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0)\n+          ){\n+            pExpr->iTable = op!=TK_DELETE;\n+            pTab = pParse->pTriggerTab;\n+          }\n+        }else if( op!=TK_DELETE && zTab && sqlite3StrICmp(\"new\",zTab) == 0 ){\n@@ -97920,1 +99984,1 @@\n-        }else if( op!=TK_INSERT && sqlite3StrICmp(\"old\",zTab)==0 ){\n+        }else if( op!=TK_INSERT && zTab && sqlite3StrICmp(\"old\",zTab)==0 ){\n@@ -97927,1 +99991,1 @@\n-      if( (pNC->ncFlags & NC_UUpsert)!=0 ){\n+      if( (pNC->ncFlags & NC_UUpsert)!=0 && zTab!=0 ){\n@@ -97931,1 +99995,1 @@\n-          pExpr->iTable = 2;\n+          pExpr->iTable = EXCLUDED_TABLE_NUMBER;\n@@ -97942,1 +100006,3 @@\n-          if( pCol->hName==hCol && sqlite3StrICmp(pCol->zName, zCol)==0 ){\n+          if( pCol->hName==hCol\n+           && sqlite3StrICmp(pCol->zCnName, zCol)==0\n+          ){\n@@ -97955,0 +100021,1 @@\n+          pMatch = 0;\n@@ -97956,1 +100023,1 @@\n-          if( pExpr->iTable==2 ){\n+          if( pExpr->iTable==EXCLUDED_TABLE_NUMBER ){\n@@ -97958,0 +100025,1 @@\n+            assert( ExprUseYTab(pExpr) );\n@@ -97963,1 +100031,2 @@\n-              pExpr->iTable = pNC->uNC.pUpsert->regData + iCol;\n+              pExpr->iTable = pNC->uNC.pUpsert->regData +\n+                 sqlite3TableColumnToStorage(pTab, iCol);\n@@ -97965,1 +100034,0 @@\n-              ExprSetProperty(pExpr, EP_Alias);\n@@ -97970,12 +100038,1 @@\n-#ifndef SQLITE_OMIT_TRIGGER\n-            if( iCol<0 ){\n-              pExpr->affExpr = SQLITE_AFF_INTEGER;\n-            }else if( pExpr->iTable==0 ){\n-              testcase( iCol==31 );\n-              testcase( iCol==32 );\n-              pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n-            }else{\n-              testcase( iCol==31 );\n-              testcase( iCol==32 );\n-              pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n-            }\n+            assert( ExprUseYTab(pExpr) );\n@@ -97983,2 +100040,19 @@\n-            pExpr->iColumn = (i16)iCol;\n-            eNewExprOp = TK_TRIGGER;\n+            if( pParse->bReturning ){\n+              eNewExprOp = TK_REGISTER;\n+              pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol+1)*pExpr->iTable +\n+                 sqlite3TableColumnToStorage(pTab, iCol) + 1;\n+            }else{\n+              pExpr->iColumn = (i16)iCol;\n+              eNewExprOp = TK_TRIGGER;\n+#ifndef SQLITE_OMIT_TRIGGER\n+              if( iCol<0 ){\n+                pExpr->affExpr = SQLITE_AFF_INTEGER;\n+              }else if( pExpr->iTable==0 ){\n+                testcase( iCol==31 );\n+                testcase( iCol==32 );\n+                pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n+              }else{\n+                testcase( iCol==31 );\n+                testcase( iCol==32 );\n+                pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n+              }\n@@ -97986,0 +100060,1 @@\n+            }\n@@ -98000,1 +100075,1 @@\n-     && VisibleRowid(pMatch->pTab)\n+     && ALWAYS(VisibleRowid(pMatch->pTab))\n@@ -98025,2 +100100,2 @@\n-    if( (pNC->ncFlags & NC_UEList)!=0\n-     && cnt==0\n+    if( cnt==0\n+     && (pNC->ncFlags & NC_UEList)!=0\n@@ -98038,2 +100113,2 @@\n-          assert( pExpr->x.pList==0 );\n-          assert( pExpr->x.pSelect==0 );\n+          assert( ExprUseXList(pExpr)==0 || pExpr->x.pList==0 );\n+          assert( ExprUseXSelect(pExpr)==0 || pExpr->x.pSelect==0 );\n@@ -98055,1 +100130,1 @@\n-          resolveAlias(pParse, pEList, j, pExpr, \"\", nSubquery);\n+          resolveAlias(pParse, pEList, j, pExpr, nSubquery);\n@@ -98111,1 +100186,1 @@\n-      pExpr->y.pTab = 0;\n+      memset(&pExpr->y, 0, sizeof(pExpr->y));\n@@ -98134,1 +100209,1 @@\n-    pTopNC->nErr++;\n+    pTopNC->nNcErr++;\n@@ -98157,4 +100232,6 @@\n-  sqlite3ExprDelete(db, pExpr->pLeft);\n-  pExpr->pLeft = 0;\n-  sqlite3ExprDelete(db, pExpr->pRight);\n-  pExpr->pRight = 0;\n+  if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){\n+    sqlite3ExprDelete(db, pExpr->pLeft);\n+    pExpr->pLeft = 0;\n+    sqlite3ExprDelete(db, pExpr->pRight);\n+    pExpr->pRight = 0;\n+  }\n@@ -98166,1 +100243,4 @@\n-    if( !ExprHasProperty(pExpr, EP_Alias) ){\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+    if( pParse->db->xAuth\n+     && (pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER)\n+    ){\n@@ -98169,0 +100249,1 @@\n+#endif\n@@ -98190,2 +100271,4 @@\n-    struct SrcList_item *pItem = &pSrc->a[iSrc];\n-    Table *pTab = p->y.pTab = pItem->pTab;\n+    SrcItem *pItem = &pSrc->a[iSrc];\n+    Table *pTab;\n+    assert( ExprUseYTab(p) );\n+    pTab = p->y.pTab = pItem->pTab;\n@@ -98258,0 +100341,1 @@\n+  assert( !ExprHasProperty(p, EP_IntValue) );\n@@ -98295,1 +100379,0 @@\n-#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)\n@@ -98298,1 +100381,2 @@\n-    ** clause processing on UPDATE and DELETE statements.\n+    ** clause processing on UPDATE and DELETE statements, and by\n+    ** UPDATE ... FROM statement processing.\n@@ -98302,2 +100386,2 @@\n-      struct SrcList_item *pItem;\n-      assert( pSrcList && pSrcList->nSrc==1 );\n+      SrcItem *pItem;\n+      assert( pSrcList && pSrcList->nSrc>=1 );\n@@ -98305,1 +100389,0 @@\n-      assert( HasRowid(pItem->pTab) && pItem->pTab->pSelect==0 );\n@@ -98307,0 +100390,1 @@\n+      assert( ExprUseYTab(pExpr) );\n@@ -98309,1 +100393,1 @@\n-      pExpr->iColumn = -1;\n+      pExpr->iColumn--;\n@@ -98313,2 +100397,43 @@\n-#endif \/* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)\n-          && !defined(SQLITE_OMIT_SUBQUERY) *\/\n+\n+    \/* An optimization:  Attempt to convert\n+    **\n+    **      \"expr IS NOT NULL\"  -->  \"TRUE\"\n+    **      \"expr IS NULL\"      -->  \"FALSE\"\n+    **\n+    ** if we can prove that \"expr\" is never NULL.  Call this the\n+    ** \"NOT NULL strength reduction optimization\".\n+    **\n+    ** If this optimization occurs, also restore the NameContext ref-counts\n+    ** to the state they where in before the \"column\" LHS expression was\n+    ** resolved.  This prevents \"column\" from being counted as having been\n+    ** referenced, which might prevent a SELECT from being erroneously\n+    ** marked as correlated.\n+    *\/\n+    case TK_NOTNULL:\n+    case TK_ISNULL: {\n+      int anRef[8];\n+      NameContext *p;\n+      int i;\n+      for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){\n+        anRef[i] = p->nRef;\n+      }\n+      sqlite3WalkExpr(pWalker, pExpr->pLeft);\n+      if( 0==sqlite3ExprCanBeNull(pExpr->pLeft) && !IN_RENAME_OBJECT ){\n+        testcase( ExprHasProperty(pExpr, EP_FromJoin) );\n+        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+        if( pExpr->op==TK_NOTNULL ){\n+          pExpr->u.zToken = \"true\";\n+          ExprSetProperty(pExpr, EP_IsTrue);\n+        }else{\n+          pExpr->u.zToken = \"false\";\n+          ExprSetProperty(pExpr, EP_IsFalse);\n+        }\n+        pExpr->op = TK_TRUEFALSE;\n+        for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){\n+          p->nRef = anRef[i];\n+        }\n+        sqlite3ExprDelete(pParse->db, pExpr->pLeft);\n+        pExpr->pLeft = 0;\n+      }\n+      return WRC_Prune;\n+    }\n@@ -98334,0 +100459,1 @@\n+        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -98346,0 +100472,1 @@\n+          assert( !ExprHasProperty(pRight, EP_IntValue) );\n@@ -98350,0 +100477,1 @@\n+        assert( ExprUseUToken(pLeft) && ExprUseUToken(pRight) );\n@@ -98352,0 +100480,1 @@\n+        assert( ExprUseYTab(pExpr) );\n@@ -98376,1 +100505,1 @@\n-      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n+      assert( !ExprHasProperty(pExpr, EP_xIsSelect|EP_IntValue) );\n@@ -98397,1 +100526,1 @@\n-              pNC->nErr++;\n+              pNC->nNcErr++;\n@@ -98419,1 +100548,1 @@\n-              pNC->nErr++;\n+              pNC->nNcErr++;\n@@ -98475,1 +100604,1 @@\n-          pNC->nErr++;\n+          pNC->nNcErr++;\n@@ -98488,1 +100617,1 @@\n-          pNC->nErr++;\n+          pNC->nNcErr++;\n@@ -98494,1 +100623,1 @@\n-          pNC->nErr++;\n+          pNC->nNcErr++;\n@@ -98504,1 +100633,1 @@\n-          pNC->nErr++;\n+          pNC->nNcErr++;\n@@ -98508,1 +100637,1 @@\n-          pNC->nErr++;\n+          pNC->nNcErr++;\n@@ -98516,1 +100645,1 @@\n-          pNC->nErr++;\n+          pNC->nNcErr++;\n@@ -98540,1 +100669,1 @@\n-          assert( pWin==pExpr->y.pWin );\n+          assert( pWin==0 || (ExprUseYWin(pExpr) && pWin==pExpr->y.pWin) );\n@@ -98543,0 +100672,1 @@\n+            if( pParse->db->mallocFailed ) break;\n@@ -98552,1 +100682,1 @@\n-          NameContext *pNC2 = pNC;\n+          NameContext *pNC2;          \/* For looping up thru outer contexts *\/\n@@ -98560,1 +100690,4 @@\n-          while( pNC2 && !sqlite3FunctionUsesThisSrc(pExpr, pNC2->pSrcList) ){\n+          pNC2 = pNC;\n+          while( pNC2\n+              && sqlite3ReferencesSrcList(pParse, pExpr, pNC2->pSrcList)==0\n+          ){\n@@ -98567,0 +100700,1 @@\n+            assert( SQLITE_FUNC_ANYORDER==NC_OrderAgg );\n@@ -98568,2 +100702,4 @@\n-            pNC2->ncFlags |= NC_HasAgg | (pDef->funcFlags & SQLITE_FUNC_MINMAX);\n-\n+            testcase( (pDef->funcFlags & SQLITE_FUNC_ANYORDER)!=0 );\n+            pNC2->ncFlags |= NC_HasAgg\n+              | ((pDef->funcFlags^SQLITE_FUNC_ANYORDER)\n+                  & (SQLITE_FUNC_MINMAX|SQLITE_FUNC_ANYORDER));\n@@ -98585,1 +100721,1 @@\n-      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+      if( ExprUseXSelect(pExpr) ){\n@@ -98591,3 +100727,5 @@\n-        sqlite3ResolveNotValid(pParse, pNC, \"subqueries\",\n-                 NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol, pExpr);\n-        sqlite3WalkSelect(pWalker, pExpr->x.pSelect);\n+        if( pNC->ncFlags & NC_SelfRef ){\n+          notValidImpl(pParse, pNC, \"subqueries\", pExpr);\n+        }else{\n+          sqlite3WalkSelect(pWalker, pExpr->x.pSelect);\n+        }\n@@ -98617,1 +100755,1 @@\n-      if( pRight && pRight->op==TK_ID ){\n+      if( ALWAYS(pRight) && (pRight->op==TK_ID || pRight->op==TK_TRUEFALSE) ){\n@@ -98626,1 +100764,1 @@\n-      \/* Fall thru *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -98640,0 +100778,1 @@\n+        assert( ExprUseXList(pExpr) );\n@@ -98688,1 +100827,3 @@\n-    char *zCol = pE->u.zToken;\n+    const char *zCol;\n+    assert( !ExprHasProperty(pE, EP_IntValue) );\n+    zCol = pE->u.zToken;\n@@ -98739,2 +100880,2 @@\n-  nc.ncFlags = NC_AllowAgg|NC_UEList;\n-  nc.nErr = 0;\n+  nc.ncFlags = NC_AllowAgg|NC_UEList|NC_NoSelect;\n+  nc.nNcErr = 0;\n@@ -98743,1 +100884,1 @@\n-  if( IN_RENAME_OBJECT==0 ) db->suppressErr = 1;\n+  db->suppressErr = 1;\n@@ -98826,0 +100967,1 @@\n+      if( NEVER(pE==0) ) continue;\n@@ -98841,11 +100983,5 @@\n-          ** Or, if this is running as part of an ALTER TABLE operation,\n-          ** resolve the symbols in the actual expression, not a duplicate.\n-          ** And, if one of the comparisons is successful, leave the expression\n-          ** as is instead of transforming it to an integer as in the usual\n-          ** case. This allows the code in alter.c to modify column\n-          ** refererences within the ORDER BY expression as required.  *\/\n-          if( IN_RENAME_OBJECT ){\n-            pDup = pE;\n-          }else{\n-            pDup = sqlite3ExprDup(db, pE, 0);\n-          }\n+          ** If this is running as part of an ALTER TABLE operation and\n+          ** the symbols resolve successfully, also resolve the symbols in the\n+          ** actual expression. This allows the code in alter.c to modify\n+          ** column references within the ORDER BY expression as required.  *\/\n+          pDup = sqlite3ExprDup(db, pE, 0);\n@@ -98855,0 +100991,3 @@\n+            if( IN_RENAME_OBJECT && iCol>0 ){\n+              resolveOrderByTermToExprList(pParse, pSelect, pE);\n+            }\n@@ -98856,3 +100995,1 @@\n-          if( !IN_RENAME_OBJECT ){\n-            sqlite3ExprDelete(db, pDup);\n-          }\n+          sqlite3ExprDelete(db, pDup);\n@@ -98863,1 +101000,1 @@\n-        ** taking care to preserve the COLLATE clause if it exists *\/\n+        ** taking care to preserve the COLLATE clause if it exists. *\/\n@@ -98932,2 +101069,1 @@\n-      resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr,\n-                   zType,0);\n+      resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr,0);\n@@ -98999,1 +101135,1 @@\n-  if( pOrderBy==0 ) return 0;\n+  assert( pOrderBy!=0 );\n@@ -99005,0 +101141,1 @@\n+    if( NEVER(pE2==0) ) continue;\n@@ -99088,0 +101225,1 @@\n+    assert( db->suppressErr==0 ); \/* SF_Resolved not set if errors suppressed *\/\n@@ -99090,0 +101228,1 @@\n+\n@@ -99114,1 +101253,1 @@\n-    \/* Recursively resolve names in all subqueries\n+    \/* Recursively resolve names in all subqueries in the FROM clause\n@@ -99117,1 +101256,1 @@\n-      struct SrcList_item *pItem = &p->pSrc->a[i];\n+      SrcItem *pItem = &p->pSrc->a[i];\n@@ -99119,2 +101258,1 @@\n-        NameContext *pNC;         \/* Used to iterate name contexts *\/\n-        int nRef = 0;             \/* Refcount for pOuterNC and outer contexts *\/\n+        int nRef = pOuterNC ? pOuterNC->nRef : 0;\n@@ -99123,7 +101261,0 @@\n-        \/* Count the total number of references to pOuterNC and all of its\n-        ** parent contexts. After resolving references to expressions in\n-        ** pItem->pSelect, check if this value has changed. If so, then\n-        ** SELECT statement pItem->pSelect must be correlated. Set the\n-        ** pItem->fg.isCorrelated flag if this is the case. *\/\n-        for(pNC=pOuterNC; pNC; pNC=pNC->pNext) nRef += pNC->nRef;\n-\n@@ -99135,3 +101266,10 @@\n-        for(pNC=pOuterNC; pNC; pNC=pNC->pNext) nRef -= pNC->nRef;\n-        assert( pItem->fg.isCorrelated==0 && nRef<=0 );\n-        pItem->fg.isCorrelated = (nRef!=0);\n+        \/* If the number of references to the outer context changed when\n+        ** expressions in the sub-select were resolved, the sub-select\n+        ** is correlated. It is not required to check the refcount on any\n+        ** but the innermost outer context object, as lookupName() increments\n+        ** the refcount on all contexts between the current one and the\n+        ** context containing the column when it resolves a name. *\/\n+        if( pOuterNC ){\n+          assert( pItem->fg.isCorrelated==0 && pOuterNC->nRef>=nRef );\n+          pItem->fg.isCorrelated = (pOuterNC->nRef>nRef);\n+        }\n@@ -99159,1 +101297,2 @@\n-      p->selFlags |= SF_Aggregate | (sNC.ncFlags&NC_MinMaxAgg);\n+      assert( NC_OrderAgg==SF_OrderByReqd );\n+      p->selFlags |= SF_Aggregate | (sNC.ncFlags&(NC_MinMaxAgg|NC_OrderAgg));\n@@ -99164,7 +101303,0 @@\n-    \/* If a HAVING clause is present, then there must be a GROUP BY clause.\n-    *\/\n-    if( p->pHaving && !pGroupBy ){\n-      sqlite3ErrorMsg(pParse, \"a GROUP BY clause is required before HAVING\");\n-      return WRC_Abort;\n-    }\n-\n@@ -99179,1 +101311,1 @@\n-    assert( (sNC.ncFlags & (NC_UAggInfo|NC_UUpsert))==0 );\n+    assert( (sNC.ncFlags & (NC_UAggInfo|NC_UUpsert|NC_UBaseReg))==0 );\n@@ -99182,1 +101314,7 @@\n-    if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) return WRC_Abort;\n+    if( p->pHaving ){\n+      if( !pGroupBy ){\n+        sqlite3ErrorMsg(pParse, \"a GROUP BY clause is required before HAVING\");\n+        return WRC_Abort;\n+      }\n+      if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) return WRC_Abort;\n+    }\n@@ -99187,1 +101325,1 @@\n-      struct SrcList_item *pItem = &p->pSrc->a[i];\n+      SrcItem *pItem = &p->pSrc->a[i];\n@@ -99195,0 +101333,13 @@\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+    if( IN_RENAME_OBJECT ){\n+      Window *pWin;\n+      for(pWin=p->pWinDefn; pWin; pWin=pWin->pNextWin){\n+        if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)\n+         || sqlite3ResolveExprListNames(&sNC, pWin->pPartition)\n+        ){\n+          return WRC_Abort;\n+        }\n+      }\n+    }\n+#endif\n+\n@@ -99222,1 +101373,2 @@\n-    if( isCompound<=nCompound  \/* Defer right-most ORDER BY of a compound *\/\n+    if( p->pOrderBy!=0\n+     && isCompound<=nCompound  \/* Defer right-most ORDER BY of a compound *\/\n@@ -99250,13 +101402,0 @@\n-#ifndef SQLITE_OMIT_WINDOWFUNC\n-    if( IN_RENAME_OBJECT ){\n-      Window *pWin;\n-      for(pWin=p->pWinDefn; pWin; pWin=pWin->pNextWin){\n-        if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)\n-         || sqlite3ResolveExprListNames(&sNC, pWin->pPartition)\n-        ){\n-          return WRC_Abort;\n-        }\n-      }\n-    }\n-#endif\n-\n@@ -99342,2 +101481,2 @@\n-  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);\n-  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);\n+  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);\n+  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);\n@@ -99346,1 +101485,1 @@\n-  w.xSelectCallback = resolveSelectStep;\n+  w.xSelectCallback = (pNC->ncFlags & NC_NoSelect) ? 0 : resolveSelectStep;\n@@ -99365,1 +101504,1 @@\n-  return pNC->nErr>0 || w.pParse->nErr>0;\n+  return pNC->nNcErr>0 || w.pParse->nErr>0;\n@@ -99386,2 +101525,2 @@\n-  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);\n-  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);\n+  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);\n+  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);\n@@ -99405,1 +101544,1 @@\n-    if( pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin) ){\n+    if( pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg) ){\n@@ -99407,2 +101546,3 @@\n-      savedHasAgg |= pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);\n-      pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);\n+      savedHasAgg |= pNC->ncFlags &\n+                          (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);\n+      pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);\n@@ -99410,1 +101550,1 @@\n-    if( pNC->nErr>0 || w.pParse->nErr>0 ) return WRC_Abort;\n+    if( w.pParse->nErr>0 ) return WRC_Abort;\n@@ -99522,3 +101662,3 @@\n-SQLITE_PRIVATE char sqlite3TableColumnAffinity(Table *pTab, int iCol){\n-  assert( iCol<pTab->nCol );\n-  return iCol>=0 ? pTab->aCol[iCol].affinity : SQLITE_AFF_INTEGER;\n+SQLITE_PRIVATE char sqlite3TableColumnAffinity(const Table *pTab, int iCol){\n+  if( iCol<0 || NEVER(iCol>=pTab->nCol) ) return SQLITE_AFF_INTEGER;\n+  return pTab->aCol[iCol].affinity;\n@@ -99545,2 +101685,4 @@\n-  while( ExprHasProperty(pExpr, EP_Skip) ){\n-    assert( pExpr->op==TK_COLLATE || pExpr->op==TK_IF_NULL_ROW );\n+  while( ExprHasProperty(pExpr, EP_Skip|EP_IfNullRow) ){\n+    assert( pExpr->op==TK_COLLATE\n+         || pExpr->op==TK_IF_NULL_ROW\n+         || (pExpr->op==TK_REGISTER && pExpr->op2==TK_IF_NULL_ROW) );\n@@ -99551,7 +101693,5 @@\n-  if( op==TK_SELECT ){\n-    assert( pExpr->flags&EP_xIsSelect );\n-    if( ALWAYS(pExpr->x.pSelect)\n-     && pExpr->x.pSelect->pEList\n-     && ALWAYS(pExpr->x.pSelect->pEList->a[0].pExpr)\n-    ){\n-      return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);\n+  if( op==TK_REGISTER ) op = pExpr->op2;\n+  if( op==TK_COLUMN || op==TK_AGG_COLUMN ){\n+    assert( ExprUseYTab(pExpr) );\n+    if( pExpr->y.pTab ){\n+      return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n@@ -99560,1 +101700,7 @@\n-  if( op==TK_REGISTER ) op = pExpr->op2;\n+  if( op==TK_SELECT ){\n+    assert( ExprUseXSelect(pExpr) );\n+    assert( pExpr->x.pSelect!=0 );\n+    assert( pExpr->x.pSelect->pEList!=0 );\n+    assert( pExpr->x.pSelect->pEList->a[0].pExpr!=0 );\n+    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);\n+  }\n@@ -99567,3 +101713,0 @@\n-  if( (op==TK_AGG_COLUMN || op==TK_COLUMN) && pExpr->y.pTab ){\n-    return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n-  }\n@@ -99571,1 +101714,3 @@\n-    assert( pExpr->pLeft->flags&EP_xIsSelect );\n+    assert( pExpr->pLeft!=0 && ExprUseXSelect(pExpr->pLeft) );\n+    assert( pExpr->iColumn < pExpr->iTable );\n+    assert( pExpr->iTable==pExpr->pLeft->x.pSelect->pEList->nExpr );\n@@ -99577,0 +101722,1 @@\n+    assert( ExprUseXList(pExpr) );\n@@ -99591,1 +101737,1 @@\n-  Parse *pParse,           \/* Parsing context *\/\n+  const Parse *pParse,     \/* Parsing context *\/\n@@ -99606,1 +101752,5 @@\n-SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC){\n+SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(\n+  const Parse *pParse,  \/* Parsing context *\/\n+  Expr *pExpr,          \/* Add the \"COLLATE\" clause to this expression *\/\n+  const char *zC        \/* The collating sequence name *\/\n+){\n@@ -99618,1 +101768,1 @@\n-    assert( pExpr->op==TK_COLLATE || pExpr->op==TK_IF_NULL_ROW );\n+    assert( pExpr->op==TK_COLLATE );\n@@ -99632,1 +101782,1 @@\n-      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n+      assert( ExprUseXList(pExpr) );\n@@ -99637,1 +101787,1 @@\n-      assert( pExpr->op==TK_COLLATE || pExpr->op==TK_IF_NULL_ROW );\n+      assert( pExpr->op==TK_COLLATE );\n@@ -99665,9 +101815,11 @@\n-    if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER)\n-     && p->y.pTab!=0\n-    ){\n-      \/* op==TK_REGISTER && p->y.pTab!=0 happens when pExpr was originally\n-      ** a TK_COLUMN but was previously evaluated and cached in a register *\/\n-      int j = p->iColumn;\n-      if( j>=0 ){\n-        const char *zColl = p->y.pTab->aCol[j].zColl;\n-        pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n+    if( op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER ){\n+      assert( ExprUseYTab(p) );\n+      if( p->y.pTab!=0 ){\n+        \/* op==TK_REGISTER && p->y.pTab!=0 happens when pExpr was originally\n+        ** a TK_COLUMN but was previously evaluated and cached in a register *\/\n+        int j = p->iColumn;\n+        if( j>=0 ){\n+          const char *zColl = sqlite3ColumnColl(&p->y.pTab->aCol[j]);\n+          pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n+        }\n+        break;\n@@ -99675,1 +101827,0 @@\n-      break;\n@@ -99682,0 +101833,1 @@\n+      assert( ExprUseXList(p) );\n@@ -99686,0 +101838,1 @@\n+      assert( !ExprHasProperty(p, EP_IntValue) );\n@@ -99695,0 +101848,1 @@\n+        assert( ExprUseXList(p) );\n@@ -99696,4 +101850,1 @@\n-        if( p->x.pList!=0\n-         && !db->mallocFailed\n-         && ALWAYS(!ExprHasProperty(p, EP_xIsSelect))\n-        ){\n+        if( p->x.pList!=0 && !db->mallocFailed ){\n@@ -99701,1 +101852,1 @@\n-          for(i=0; i<p->x.pList->nExpr; i++){\n+          for(i=0; ALWAYS(i<p->x.pList->nExpr); i++){\n@@ -99782,1 +101933,1 @@\n-  }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+  }else if( ExprUseXSelect(pExpr) ){\n@@ -99908,1 +102059,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsVector(Expr *pExpr){\n+SQLITE_PRIVATE int sqlite3ExprIsVector(const Expr *pExpr){\n@@ -99918,1 +102069,1 @@\n-SQLITE_PRIVATE int sqlite3ExprVectorSize(Expr *pExpr){\n+SQLITE_PRIVATE int sqlite3ExprVectorSize(const Expr *pExpr){\n@@ -99922,0 +102073,1 @@\n+    assert( ExprUseXList(pExpr) );\n@@ -99924,0 +102076,1 @@\n+    assert( ExprUseXSelect(pExpr) );\n@@ -99946,1 +102099,1 @@\n-  assert( i<sqlite3ExprVectorSize(pVector) );\n+  assert( i<sqlite3ExprVectorSize(pVector) || pVector->op==TK_ERROR );\n@@ -99950,0 +102103,1 @@\n+      assert( ExprUseXSelect(pVector) );\n@@ -99952,0 +102106,1 @@\n+      assert( ExprUseXList(pVector) );\n@@ -99982,1 +102137,2 @@\n-  int iField           \/* Which column of the vector to return *\/\n+  int iField,          \/* Which column of the vector to return *\/\n+  int nField           \/* Total number of columns in the vector *\/\n@@ -99986,1 +102142,1 @@\n-    assert( pVector->flags & EP_xIsSelect );\n+    assert( ExprUseXSelect(pVector) );\n@@ -100005,0 +102161,1 @@\n+      pRet->iTable = nField;\n@@ -100008,1 +102165,0 @@\n-    assert( pRet==0 || pRet->iTable==0 );\n@@ -100010,1 +102166,11 @@\n-    if( pVector->op==TK_VECTOR ) pVector = pVector->x.pList->a[iField].pExpr;\n+    if( pVector->op==TK_VECTOR ){\n+      Expr **ppVector;\n+      assert( ExprUseXList(pVector) );\n+      ppVector = &pVector->x.pList->a[iField].pExpr;\n+      pVector = *ppVector;\n+      if( IN_RENAME_OBJECT ){\n+        \/* This must be a vector UPDATE inside a trigger *\/\n+        *ppVector = 0;\n+        return pVector;\n+      }\n+    }\n@@ -100012,1 +102178,0 @@\n-    sqlite3RenameTokenRemap(pParse, pRet, pVector);\n@@ -100062,1 +102227,1 @@\n-  assert( op==TK_VECTOR || op==TK_REGISTER || op==TK_SELECT );\n+  assert( op==TK_VECTOR || op==TK_REGISTER || op==TK_SELECT || op==TK_ERROR );\n@@ -100068,0 +102233,1 @@\n+    assert( ExprUseXSelect(pVector) );\n@@ -100071,2 +102237,6 @@\n-  *ppExpr = pVector->x.pList->a[iField].pExpr;\n-  return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);\n+  if( op==TK_VECTOR ){\n+    assert( ExprUseXList(pVector) );\n+    *ppExpr = pVector->x.pList->a[iField].pExpr;\n+    return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);\n+  }\n+  return 0;\n@@ -100101,0 +102271,1 @@\n+  int addrCmp = 0;\n@@ -100120,3 +102291,3 @@\n-  p5 |= SQLITE_STOREP2;\n-  if( opx==TK_LE ) opx = TK_LT;\n-  if( opx==TK_GE ) opx = TK_GT;\n+  if( op==TK_LE ) opx = TK_LT;\n+  if( op==TK_GE ) opx = TK_GT;\n+  if( op==TK_NE ) opx = TK_EQ;\n@@ -100127,0 +102298,1 @@\n+  sqlite3VdbeAddOp2(v, OP_Integer, 1, dest);\n@@ -100129,1 +102301,1 @@\n-    Expr *pL, *pR;\n+    Expr *pL = 0, *pR = 0;\n@@ -100132,0 +102304,1 @@\n+    if( addrCmp ) sqlite3VdbeJumpHere(v, addrCmp);\n@@ -100134,1 +102307,2 @@\n-    codeCompare(pParse, pL, pR, opx, r1, r2, dest, p5, isCommuted);\n+    addrCmp = sqlite3VdbeCurrentAddr(v);\n+    codeCompare(pParse, pL, pR, opx, r1, r2, addrDone, p5, isCommuted);\n@@ -100143,0 +102317,10 @@\n+    if( (opx==TK_LT || opx==TK_GT) && i<nLeft-1 ){\n+      addrCmp = sqlite3VdbeAddOp0(v, OP_ElseEq);\n+      testcase(opx==TK_LT); VdbeCoverageIf(v,opx==TK_LT);\n+      testcase(opx==TK_GT); VdbeCoverageIf(v,opx==TK_GT);\n+    }\n+    if( p5==SQLITE_NULLEQ ){\n+      sqlite3VdbeAddOp2(v, OP_Integer, 0, dest);\n+    }else{\n+      sqlite3VdbeAddOp3(v, OP_ZeroOrNull, r1, dest, r2);\n+    }\n@@ -100147,5 +102331,1 @@\n-      sqlite3VdbeAddOp2(v, OP_IfNot, dest, addrDone); VdbeCoverage(v);\n-      p5 |= SQLITE_KEEPNULL;\n-    }else if( opx==TK_NE ){\n-      sqlite3VdbeAddOp2(v, OP_If, dest, addrDone); VdbeCoverage(v);\n-      p5 |= SQLITE_KEEPNULL;\n+      sqlite3VdbeAddOp2(v, OP_NotNull, dest, addrDone); VdbeCoverage(v);\n@@ -100154,5 +102334,1 @@\n-      sqlite3VdbeAddOp2(v, OP_ElseNotEq, 0, addrDone);\n-      VdbeCoverageIf(v, op==TK_LT);\n-      VdbeCoverageIf(v, op==TK_GT);\n-      VdbeCoverageIf(v, op==TK_LE);\n-      VdbeCoverageIf(v, op==TK_GE);\n+      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);\n@@ -100162,0 +102338,1 @@\n+  sqlite3VdbeJumpHere(v, addrCmp);\n@@ -100163,0 +102340,3 @@\n+  if( op==TK_NE ){\n+    sqlite3VdbeAddOp2(v, OP_Not, dest, dest);\n+  }\n@@ -100192,1 +102372,1 @@\n-static void heightOfExpr(Expr *p, int *pnHeight){\n+static void heightOfExpr(const Expr *p, int *pnHeight){\n@@ -100199,1 +102379,1 @@\n-static void heightOfExprList(ExprList *p, int *pnHeight){\n+static void heightOfExprList(const ExprList *p, int *pnHeight){\n@@ -100207,2 +102387,2 @@\n-static void heightOfSelect(Select *pSelect, int *pnHeight){\n-  Select *p;\n+static void heightOfSelect(const Select *pSelect, int *pnHeight){\n+  const Select *p;\n@@ -100233,1 +102413,1 @@\n-  if( ExprHasProperty(p, EP_xIsSelect) ){\n+  if( ExprUseXSelect(p) ){\n@@ -100260,1 +102440,1 @@\n-SQLITE_PRIVATE int sqlite3SelectExprHeight(Select *p){\n+SQLITE_PRIVATE int sqlite3SelectExprHeight(const Select *p){\n@@ -100271,1 +102451,2 @@\n-  if( p && p->x.pList && !ExprHasProperty(p, EP_xIsSelect) ){\n+  if( pParse->nErr ) return;\n+  if( p && ExprUseXList(p) && p->x.pList ){\n@@ -100429,0 +102610,57 @@\n+\/*\n+** Expression list pEList is a list of vector values. This function\n+** converts the contents of pEList to a VALUES(...) Select statement\n+** returning 1 row for each element of the list. For example, the\n+** expression list:\n+**\n+**   ( (1,2), (3,4) (5,6) )\n+**\n+** is translated to the equivalent of:\n+**\n+**   VALUES(1,2), (3,4), (5,6)\n+**\n+** Each of the vector values in pEList must contain exactly nElem terms.\n+** If a list element that is not a vector or does not contain nElem terms,\n+** an error message is left in pParse.\n+**\n+** This is used as part of processing IN(...) expressions with a list\n+** of vectors on the RHS. e.g. \"... IN ((1,2), (3,4), (5,6))\".\n+*\/\n+SQLITE_PRIVATE Select *sqlite3ExprListToValues(Parse *pParse, int nElem, ExprList *pEList){\n+  int ii;\n+  Select *pRet = 0;\n+  assert( nElem>1 );\n+  for(ii=0; ii<pEList->nExpr; ii++){\n+    Select *pSel;\n+    Expr *pExpr = pEList->a[ii].pExpr;\n+    int nExprElem;\n+    if( pExpr->op==TK_VECTOR ){\n+      assert( ExprUseXList(pExpr) );\n+      nExprElem = pExpr->x.pList->nExpr;\n+    }else{\n+      nExprElem = 1;\n+    }\n+    if( nExprElem!=nElem ){\n+      sqlite3ErrorMsg(pParse, \"IN(...) element has %d term%s - expected %d\",\n+          nExprElem, nExprElem>1?\"s\":\"\", nElem\n+      );\n+      break;\n+    }\n+    assert( ExprUseXList(pExpr) );\n+    pSel = sqlite3SelectNew(pParse, pExpr->x.pList, 0, 0, 0, 0, 0, SF_Values,0);\n+    pExpr->x.pList = 0;\n+    if( pSel ){\n+      if( pRet ){\n+        pSel->op = TK_ALL;\n+        pSel->pPrior = pRet;\n+      }\n+      pRet = pSel;\n+    }\n+  }\n+\n+  if( pRet && pRet->pPrior ){\n+    pRet->selFlags |= SF_MultiValue;\n+  }\n+  sqlite3ExprListDelete(pParse->db, pEList);\n+  return pRet;\n+}\n@@ -100447,2 +102685,2 @@\n-    sqlite3ExprDelete(db, pLeft);\n-    sqlite3ExprDelete(db, pRight);\n+    sqlite3ExprDeferredDelete(pParse, pLeft);\n+    sqlite3ExprDeferredDelete(pParse, pRight);\n@@ -100462,1 +102700,1 @@\n-  Token *pToken,        \/* Name of the function *\/\n+  const Token *pToken,  \/* Name of the function *\/\n@@ -100473,1 +102711,4 @@\n-  if( pList && pList->nExpr > pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG] ){\n+  if( pList\n+   && pList->nExpr > pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG]\n+   && !pParse->nested\n+  ){\n@@ -100478,1 +102719,1 @@\n-  assert( !ExprHasProperty(pNew, EP_xIsSelect) );\n+  assert( ExprUseXList(pNew) );\n@@ -100497,2 +102738,2 @@\n-  Expr *pExpr,           \/* The function invocation *\/\n-  FuncDef *pDef          \/* The function being invoked *\/\n+  const Expr *pExpr,     \/* The function invocation *\/\n+  const FuncDef *pDef    \/* The function being invoked *\/\n@@ -100604,6 +102845,4 @@\n-  \/* Sanity check: Assert that the IntValue is non-negative if it exists *\/\n-  assert( !ExprHasProperty(p, EP_IntValue) || p->u.iValue>=0 );\n-\n-  assert( !ExprHasProperty(p, EP_WinFunc) || p->y.pWin!=0 || db->mallocFailed );\n-  assert( p->op!=TK_FUNCTION || ExprHasProperty(p, EP_TokenOnly|EP_Reduced)\n-          || p->y.pWin==0 || ExprHasProperty(p, EP_WinFunc) );\n+  assert( !ExprUseUValue(p) || p->u.iValue>=0 );\n+  assert( !ExprUseYWin(p) || !ExprUseYSub(p) );\n+  assert( !ExprUseYWin(p) || p->y.pWin!=0 || db->mallocFailed );\n+  assert( p->op!=TK_FUNCTION || !ExprUseYSub(p) );\n@@ -100614,1 +102853,2 @@\n-    assert( p->x.pSelect==0 );\n+    assert( !ExprUseXSelect(p) || p->x.pSelect==0 );\n+    assert( !ExprUseXList(p) || p->x.pList==0 );\n@@ -100619,1 +102859,1 @@\n-    assert( p->x.pList==0 || p->pRight==0 );\n+    assert( (ExprUseXList(p) && p->x.pList==0) || p->pRight==0 );\n@@ -100624,1 +102864,1 @@\n-    }else if( ExprHasProperty(p, EP_xIsSelect) ){\n+    }else if( ExprUseXSelect(p) ){\n@@ -100636,1 +102876,4 @@\n-  if( ExprHasProperty(p, EP_MemToken) ) sqlite3DbFree(db, p->u.zToken);\n+  if( ExprHasProperty(p, EP_MemToken) ){\n+    assert( !ExprHasProperty(p, EP_IntValue) );\n+    sqlite3DbFree(db, p->u.zToken);\n+  }\n@@ -100645,0 +102888,16 @@\n+\n+\/*\n+** Arrange to cause pExpr to be deleted when the pParse is deleted.\n+** This is similar to sqlite3ExprDelete() except that the delete is\n+** deferred untilthe pParse is deleted.\n+**\n+** The pExpr might be deleted immediately on an OOM error.\n+**\n+** The deferred delete is (currently) implemented by adding the\n+** pExpr to the pParse->pConstExpr list with a register number of 0.\n+*\/\n+SQLITE_PRIVATE void sqlite3ExprDeferredDelete(Parse *pParse, Expr *pExpr){\n+  pParse->pConstExpr =\n+      sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);\n+}\n+\n@@ -100662,1 +102921,1 @@\n-static int exprStructSize(Expr *p){\n+static int exprStructSize(const Expr *p){\n@@ -100702,1 +102961,1 @@\n-static int dupedExprStructSize(Expr *p, int flags){\n+static int dupedExprStructSize(const Expr *p, int flags){\n@@ -100733,1 +102992,1 @@\n-static int dupedExprNodeSize(Expr *p, int flags){\n+static int dupedExprNodeSize(const Expr *p, int flags){\n@@ -100754,1 +103013,1 @@\n-static int dupedExprSize(Expr *p, int flags){\n+static int dupedExprSize(const Expr *p, int flags){\n@@ -100773,1 +103032,1 @@\n-static Expr *exprDup(sqlite3 *db, Expr *p, int dupFlags, u8 **pzBuffer){\n+static Expr *exprDup(sqlite3 *db, const Expr *p, int dupFlags, u8 **pzBuffer){\n@@ -100787,0 +103046,1 @@\n+    assert( zAlloc!=0 );\n@@ -100835,1 +103095,1 @@\n-      if( ExprHasProperty(p, EP_xIsSelect) ){\n+      if( ExprUseXSelect(p) ){\n@@ -100864,2 +103124,2 @@\n-          assert( p->iColumn==0 || p->pRight==0 );\n-          assert( p->pRight==0  || p->pRight==p->pLeft );\n+          assert( p->pRight==0  || p->pRight==p->pLeft\n+                                || ExprHasProperty(p->pLeft, EP_Subquery) );\n@@ -100882,1 +103142,1 @@\n-static With *withDup(sqlite3 *db, With *p){\n+SQLITE_PRIVATE With *sqlite3WithDup(sqlite3 *db, With *p){\n@@ -100900,1 +103160,1 @@\n-# define withDup(x,y) 0\n+# define sqlite3WithDup(x,y) 0\n@@ -100953,1 +103213,1 @@\n-SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){\n+SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3 *db, const Expr *p, int flags){\n@@ -100957,1 +103217,1 @@\n-SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){\n+SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, const ExprList *p, int flags){\n@@ -100959,1 +103219,2 @@\n-  struct ExprList_item *pItem, *pOldItem;\n+  struct ExprList_item *pItem;\n+  const struct ExprList_item *pOldItem;\n@@ -100961,1 +103222,2 @@\n-  Expr *pPriorSelectCol = 0;\n+  Expr *pPriorSelectColOld = 0;\n+  Expr *pPriorSelectColNew = 0;\n@@ -100967,0 +103229,1 @@\n+  pNew->nAlloc = p->nAlloc;\n@@ -100977,4 +103240,4 @@\n-      assert( pNewExpr->iColumn==0 || i>0 );\n-      if( pNewExpr->iColumn==0 ){\n-        assert( pOldExpr->pLeft==pOldExpr->pRight );\n-        pPriorSelectCol = pNewExpr->pLeft = pNewExpr->pRight;\n+      if( pNewExpr->pRight ){\n+        pPriorSelectColOld = pOldExpr->pRight;\n+        pPriorSelectColNew = pNewExpr->pRight;\n+        pNewExpr->pLeft = pNewExpr->pRight;\n@@ -100982,5 +103245,6 @@\n-        assert( i>0 );\n-        assert( pItem[-1].pExpr!=0 );\n-        assert( pNewExpr->iColumn==pItem[-1].pExpr->iColumn+1 );\n-        assert( pPriorSelectCol==pItem[-1].pExpr->pLeft );\n-        pNewExpr->pLeft = pPriorSelectCol;\n+        if( pOldExpr->pLeft!=pPriorSelectColOld ){\n+          pPriorSelectColOld = pOldExpr->pLeft;\n+          pPriorSelectColNew = sqlite3ExprDup(db, pPriorSelectColOld, flags);\n+          pNewExpr->pRight = pPriorSelectColNew;\n+        }\n+        pNewExpr->pLeft = pPriorSelectColNew;\n@@ -101008,1 +103272,1 @@\n-SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){\n+SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, const SrcList *p, int flags){\n@@ -101019,2 +103283,2 @@\n-    struct SrcList_item *pNewItem = &pNew->a[i];\n-    struct SrcList_item *pOldItem = &p->a[i];\n+    SrcItem *pNewItem = &pNew->a[i];\n+    const SrcItem *pOldItem = &p->a[i];\n@@ -101033,1 +103297,4 @@\n-    pNewItem->pIBIndex = pOldItem->pIBIndex;\n+    pNewItem->u2 = pOldItem->u2;\n+    if( pNewItem->fg.isCte ){\n+      pNewItem->u2.pCteUse->nUse++;\n+    }\n@@ -101049,1 +103316,1 @@\n-SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){\n+SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, const IdList *p){\n@@ -101073,1 +103340,1 @@\n-SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *pDup, int flags){\n+SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, const Select *pDup, int flags){\n@@ -101077,1 +103344,1 @@\n-  Select *p;\n+  const Select *p;\n@@ -101099,1 +103366,1 @@\n-    pNew->pWith = withDup(db, p->pWith);\n+    pNew->pWith = sqlite3WithDup(db, p->pWith);\n@@ -101106,0 +103373,8 @@\n+    if( db->mallocFailed ){\n+      \/* Any prior OOM might have left the Select object incomplete.\n+      ** Delete the whole thing rather than allow an incomplete Select\n+      ** to be used by the code generator. *\/\n+      pNew->pNext = 0;\n+      sqlite3SelectDelete(db, pNew);\n+      break;\n+    }\n@@ -101114,1 +103389,1 @@\n-SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){\n+SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, const Select *p, int flags){\n@@ -101136,0 +103411,42 @@\n+static const struct ExprList_item zeroItem = {0};\n+SQLITE_PRIVATE SQLITE_NOINLINE ExprList *sqlite3ExprListAppendNew(\n+  sqlite3 *db,            \/* Database handle.  Used for memory allocation *\/\n+  Expr *pExpr             \/* Expression to be appended. Might be NULL *\/\n+){\n+  struct ExprList_item *pItem;\n+  ExprList *pList;\n+\n+  pList = sqlite3DbMallocRawNN(db, sizeof(ExprList)+sizeof(pList->a[0])*4 );\n+  if( pList==0 ){\n+    sqlite3ExprDelete(db, pExpr);\n+    return 0;\n+  }\n+  pList->nAlloc = 4;\n+  pList->nExpr = 1;\n+  pItem = &pList->a[0];\n+  *pItem = zeroItem;\n+  pItem->pExpr = pExpr;\n+  return pList;\n+}\n+SQLITE_PRIVATE SQLITE_NOINLINE ExprList *sqlite3ExprListAppendGrow(\n+  sqlite3 *db,            \/* Database handle.  Used for memory allocation *\/\n+  ExprList *pList,        \/* List to which to append. Might be NULL *\/\n+  Expr *pExpr             \/* Expression to be appended. Might be NULL *\/\n+){\n+  struct ExprList_item *pItem;\n+  ExprList *pNew;\n+  pList->nAlloc *= 2;\n+  pNew = sqlite3DbRealloc(db, pList,\n+       sizeof(*pList)+(pList->nAlloc-1)*sizeof(pList->a[0]));\n+  if( pNew==0 ){\n+    sqlite3ExprListDelete(db, pList);\n+    sqlite3ExprDelete(db, pExpr);\n+    return 0;\n+  }else{\n+    pList = pNew;\n+  }\n+  pItem = &pList->a[pList->nExpr++];\n+  *pItem = zeroItem;\n+  pItem->pExpr = pExpr;\n+  return pList;\n+}\n@@ -101142,2 +103459,0 @@\n-  sqlite3 *db = pParse->db;\n-  assert( db!=0 );\n@@ -101145,13 +103460,4 @@\n-    pList = sqlite3DbMallocRawNN(db, sizeof(ExprList) );\n-    if( pList==0 ){\n-      goto no_mem;\n-    }\n-    pList->nExpr = 0;\n-  }else if( (pList->nExpr & (pList->nExpr-1))==0 ){\n-    ExprList *pNew;\n-    pNew = sqlite3DbRealloc(db, pList,\n-         sizeof(*pList)+(2*(sqlite3_int64)pList->nExpr-1)*sizeof(pList->a[0]));\n-    if( pNew==0 ){\n-      goto no_mem;\n-    }\n-    pList = pNew;\n+    return sqlite3ExprListAppendNew(pParse->db,pExpr);\n+  }\n+  if( pList->nAlloc<pList->nExpr+1 ){\n+    return sqlite3ExprListAppendGrow(pParse->db,pList,pExpr);\n@@ -101160,3 +103466,1 @@\n-  assert( offsetof(struct ExprList_item,zEName)==sizeof(pItem->pExpr) );\n-  assert( offsetof(struct ExprList_item,pExpr)==0 );\n-  memset(&pItem->zEName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zEName));\n+  *pItem = zeroItem;\n@@ -101165,6 +103469,0 @@\n-\n-no_mem:\n-  \/* Avoid leaking memory if malloc has failed. *\/\n-  sqlite3ExprDelete(db, pExpr);\n-  sqlite3ExprListDelete(db, pList);\n-  return 0;\n@@ -101211,1 +103509,1 @@\n-    Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i);\n+    Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns->nId);\n@@ -101213,1 +103511,0 @@\n-    assert( pSubExpr==0 || pSubExpr->iTable==0 );\n@@ -101215,1 +103512,0 @@\n-    pSubExpr->iTable = pColumns->nId;\n@@ -101289,1 +103585,1 @@\n-  Token *pName,           \/* Name to be added *\/\n+  const Token *pName,     \/* Name to be added *\/\n@@ -101307,1 +103603,1 @@\n-        sqlite3RenameTokenMap(pParse, (void*)pItem->zEName, pName);\n+        sqlite3RenameTokenMap(pParse, (const void*)pItem->zEName, pName);\n@@ -101426,1 +103722,1 @@\n-  if( !ExprHasProperty(pExpr, EP_Quoted)\n+  if( !ExprHasProperty(pExpr, EP_Quoted|EP_IntValue)\n@@ -101443,0 +103739,1 @@\n+  assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -101494,1 +103791,1 @@\n-** when parsing an existing schema out of the sqlite_master table and 4\n+** when parsing an existing schema out of the sqlite_schema table and 4\n@@ -101497,1 +103794,1 @@\n-** to NULL for existing schemas.  This allows sqlite_master tables that\n+** to NULL for existing schemas.  This allows sqlite_schema tables that\n@@ -101532,1 +103829,1 @@\n-      \/* Fall thru *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -101546,1 +103843,1 @@\n-      \/* Fall through *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -101559,1 +103856,1 @@\n-        ** of the sqlite_master table *\/\n+        ** of the sqlite_schema table *\/\n@@ -101567,1 +103864,1 @@\n-      \/* Fall through *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -101647,1 +103944,1 @@\n-  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+  if( ExprUseXSelect(pExpr) ){\n@@ -101692,1 +103989,1 @@\n-** isInit is true when parsing from sqlite_master.  isInit is false when\n+** isInit is true when parsing from sqlite_schema.  isInit is false when\n@@ -101697,1 +103994,1 @@\n-** allowed it, so we need to support it when reading sqlite_master for\n+** allowed it, so we need to support it when reading sqlite_schema for\n@@ -101735,1 +104032,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr *p, int *pValue){\n+SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr *p, int *pValue){\n@@ -101754,1 +104051,1 @@\n-      int v;\n+      int v = 0;\n@@ -101756,1 +104053,1 @@\n-        assert( v!=(-2147483647-1) );\n+        assert( ((unsigned int)v)!=0x80000000 );\n@@ -101783,0 +104080,1 @@\n+  assert( p!=0 );\n@@ -101785,0 +104083,1 @@\n+    assert( p!=0 );\n@@ -101795,0 +104094,1 @@\n+      assert( ExprUseYTab(p) );\n@@ -101798,1 +104098,1 @@\n-              && ALWAYS(p->y.pTab->aCol!=0) \/* Defense against OOM problems *\/\n+              && p->y.pTab->aCol!=0 \/* Possible due to prior error *\/\n@@ -101866,1 +104166,1 @@\n-static Select *isCandidateForInOpt(Expr *pX){\n+static Select *isCandidateForInOpt(const Expr *pX){\n@@ -101872,1 +104172,1 @@\n-  if( !ExprHasProperty(pX, EP_xIsSelect) ) return 0;  \/* Not a subquery *\/\n+  if( !ExprUseXSelect(pX) ) return 0;                 \/* Not a subquery *\/\n@@ -101890,1 +104190,1 @@\n-  assert( pTab->pSelect==0 );            \/* FROM clause is not a view *\/\n+  assert( !IsView(pTab)  );              \/* FROM clause is not a view *\/\n@@ -102043,1 +104343,1 @@\n-  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){\n+  if( prRhsHasNull && ExprUseXSelect(pX) ){\n@@ -102060,1 +104360,1 @@\n-    i16 iDb;                               \/* Database idx for pTab *\/\n+    int iDb;                               \/* Database idx for pTab *\/\n@@ -102071,0 +104371,1 @@\n+    assert( iDb>=0 && iDb<SQLITE_MAX_DB );\n@@ -102143,1 +104444,2 @@\n-            assert( pReq!=0 || pRhs->iColumn==XN_ROWID || pParse->nErr );\n+            assert( pReq!=0 || pRhs->iColumn==XN_ROWID\n+                   || pParse->nErr || db->mallocFailed );\n@@ -102198,1 +104500,1 @@\n-   && !ExprHasProperty(pX, EP_xIsSelect)\n+   && ExprUseXList(pX)\n@@ -102243,1 +104545,1 @@\n-static char *exprINAffinity(Parse *pParse, Expr *pExpr){\n+static char *exprINAffinity(Parse *pParse, const Expr *pExpr){\n@@ -102246,1 +104548,1 @@\n-  Select *pSelect = (pExpr->flags & EP_xIsSelect) ? pExpr->x.pSelect : 0;\n+  Select *pSelect = ExprUseXSelect(pExpr) ? pExpr->x.pSelect : 0;\n@@ -102296,1 +104598,1 @@\n-  if( pExpr->flags & EP_xIsSelect ){\n+  if( ExprUseXSelect(pExpr) ){\n@@ -102360,1 +104662,1 @@\n-      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+      if( ExprUseXSelect(pExpr) ){\n@@ -102364,0 +104666,1 @@\n+      assert( ExprUseYSub(pExpr) );\n@@ -102372,0 +104675,1 @@\n+    assert( !ExprUseYWin(pExpr) );\n@@ -102392,1 +104696,1 @@\n-  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+  if( ExprUseXSelect(pExpr) ){\n@@ -102400,1 +104704,1 @@\n-  if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+  if( ExprUseXSelect(pExpr) ){\n@@ -102415,0 +104719,1 @@\n+      Select *pCopy;\n@@ -102417,0 +104722,1 @@\n+      int rc;\n@@ -102422,2 +104728,5 @@\n-      if( sqlite3Select(pParse, pSelect, &dest) ){\n-        sqlite3DbFree(pParse->db, dest.zAffSdst);\n+      pCopy = sqlite3SelectDup(pParse->db, pSelect, 0);\n+      rc = pParse->db->mallocFailed ? 1 :sqlite3Select(pParse, pCopy, &dest);\n+      sqlite3SelectDelete(pParse->db, pCopy);\n+      sqlite3DbFree(pParse->db, dest.zAffSdst);\n+      if( rc ){\n@@ -102427,1 +104736,0 @@\n-      sqlite3DbFree(pParse->db, dest.zAffSdst);\n@@ -102494,0 +104802,1 @@\n+    assert( ExprUseYSub(pExpr) );\n@@ -102526,0 +104835,1 @@\n+  if( pParse->nErr ) return 0;\n@@ -102529,1 +104839,1 @@\n-  assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n+  assert( ExprUseXSelect(pExpr) );\n@@ -102532,0 +104842,20 @@\n+  \/* If this routine has already been coded, then invoke it as a\n+  ** subroutine. *\/\n+  if( ExprHasProperty(pExpr, EP_Subrtn) ){\n+    ExplainQueryPlan((pParse, 0, \"REUSE SUBQUERY %d\", pSel->selId));\n+    assert( ExprUseYSub(pExpr) );\n+    sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,\n+                      pExpr->y.sub.iAddr);\n+    return pExpr->iTable;\n+  }\n+\n+  \/* Begin coding the subroutine *\/\n+  assert( !ExprUseYWin(pExpr) );\n+  assert( !ExprHasProperty(pExpr, EP_Reduced|EP_TokenOnly) );\n+  ExprSetProperty(pExpr, EP_Subrtn);\n+  pExpr->y.sub.regReturn = ++pParse->nMem;\n+  pExpr->y.sub.iAddr =\n+    sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;\n+  VdbeComment((v, \"return address\"));\n+\n+\n@@ -102543,16 +104873,0 @@\n-    \/* If this routine has already been coded, then invoke it as a\n-    ** subroutine. *\/\n-    if( ExprHasProperty(pExpr, EP_Subrtn) ){\n-      ExplainQueryPlan((pParse, 0, \"REUSE SUBQUERY %d\", pSel->selId));\n-      sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,\n-                        pExpr->y.sub.iAddr);\n-      return pExpr->iTable;\n-    }\n-\n-    \/* Begin coding the subroutine *\/\n-    ExprSetProperty(pExpr, EP_Subrtn);\n-    pExpr->y.sub.regReturn = ++pParse->nMem;\n-    pExpr->y.sub.iAddr =\n-      sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;\n-    VdbeComment((v, \"return address\"));\n-\n@@ -102607,0 +104921,4 @@\n+    if( pParse->nErr ){\n+      pExpr->op2 = pExpr->op;\n+      pExpr->op = TK_ERROR;\n+    }\n@@ -102613,5 +104931,0 @@\n-\n-    \/* Subroutine return *\/\n-    sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);\n-    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);\n-    sqlite3ClearTempRegCache(pParse);\n@@ -102620,0 +104933,5 @@\n+  \/* Subroutine return *\/\n+  assert( ExprUseYSub(pExpr) );\n+  sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);\n+  sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);\n+  sqlite3ClearTempRegCache(pParse);\n@@ -102633,1 +104951,1 @@\n-  if( (pIn->flags & EP_xIsSelect) ){\n+  if( ExprUseXSelect(pIn) && !pParse->db->mallocFailed ){\n@@ -102767,2 +105085,2 @@\n-    ExprList *pList = pExpr->x.pList;\n-    CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n+    ExprList *pList;\n+    CollSeq *pColl;\n@@ -102773,1 +105091,3 @@\n-    assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n+    assert( ExprUseXList(pExpr) );\n+    pList = pExpr->x.pList;\n+    pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n@@ -102824,0 +105144,1 @@\n+    if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;\n@@ -103009,3 +105330,4 @@\n-  Parse *pParse,\n-  Column *pCol,\n-  int regOut\n+  Parse *pParse,     \/* Parsing context *\/\n+  Table *pTab,       \/* Table containing the generated column *\/\n+  Column *pCol,      \/* The generated column *\/\n+  int regOut         \/* Put the result in this register *\/\n@@ -103022,1 +105344,1 @@\n-  sqlite3ExprCodeCopy(pParse, pCol->pDflt, regOut);\n+  sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab,pCol), regOut);\n@@ -103058,1 +105380,2 @@\n-        sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zName);\n+        sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",\n+                        pCol->zCnName);\n@@ -103063,1 +105386,1 @@\n-        sqlite3ExprCodeGeneratedColumn(pParse, pCol, regOut);\n+        sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, regOut);\n@@ -103122,0 +105445,1 @@\n+  if( NEVER(p==0) ) return;\n@@ -103155,0 +105479,1 @@\n+      assert( ExprUseXList(p) );\n@@ -103229,0 +105554,1 @@\n+#if !defined(SQLITE_UNTESTABLE)\n@@ -103262,1 +105588,0 @@\n-#ifdef SQLITE_DEBUG\n@@ -103276,1 +105601,1 @@\n-#endif\n+#endif \/* !defined(SQLITE_UNTESTABLE) *\/\n@@ -103304,4 +105629,1 @@\n-  if( v==0 ){\n-    assert( pParse->db->mallocFailed );\n-    return 0;\n-  }\n+  assert( v!=0 );\n@@ -103333,1 +105655,2 @@\n-          VdbeComment((v,\"%s.%s\",pTab->zName,pTab->aCol[pCol->iColumn].zName));\n+          VdbeComment((v,\"%s.%s\",\n+              pTab->zName, pTab->aCol[pCol->iColumn].zCnName));\n@@ -103341,0 +105664,1 @@\n+      \/* no break *\/ deliberate_fall_through\n@@ -103354,0 +105678,1 @@\n+        assert( ExprUseYTab(pExpr) );\n@@ -103377,1 +105702,1 @@\n-          Table *pTab = pExpr->y.pTab;\n+          Table *pTab;\n@@ -103380,0 +105705,2 @@\n+          assert( ExprUseYTab(pExpr) );\n+          pTab = pExpr->y.pTab;\n@@ -103393,1 +105720,1 @@\n-                              pCol->zName);\n+                              pCol->zCnName);\n@@ -103398,1 +105725,1 @@\n-              sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);\n+              sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);\n@@ -103417,0 +105744,1 @@\n+      assert( ExprUseYTab(pExpr) );\n@@ -103450,1 +105778,1 @@\n-      assert( op==TK_NULL );\n+      assert( op==TK_NULL || op==TK_ERROR || pParse->db->mallocFailed );\n@@ -103494,0 +105822,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -103516,2 +105845,3 @@\n-        codeCompare(pParse, pLeft, pExpr->pRight, op,\n-            r1, r2, inReg, SQLITE_STOREP2 | p5,\n+        sqlite3VdbeAddOp2(v, OP_Integer, 1, inReg);\n+        codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2,\n+            sqlite3VdbeCurrentAddr(v)+2, p5,\n@@ -103525,0 +105855,5 @@\n+        if( p5==SQLITE_NULLEQ ){\n+          sqlite3VdbeAddOp2(v, OP_Integer, 0, inReg);\n+        }else{\n+          sqlite3VdbeAddOp3(v, OP_ZeroOrNull, r1, inReg, r2);\n+        }\n@@ -103655,1 +105990,0 @@\n-      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n@@ -103657,0 +105991,1 @@\n+      assert( ExprUseXList(pExpr) );\n@@ -103745,1 +106080,1 @@\n-      if( pDef->funcFlags & SQLITE_FUNC_OFFSET ){\n+      if( (pDef->funcFlags & SQLITE_FUNC_OFFSET)!=0 && ALWAYS(pFarg!=0) ){\n@@ -103773,1 +106108,6 @@\n-      if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){\n+      if( pParse->db->mallocFailed ){\n+        return 0;\n+      }else if( op==TK_SELECT\n+             && ALWAYS( ExprUseXSelect(pExpr) )\n+             && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1\n+      ){\n@@ -103785,4 +106125,3 @@\n-      assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );\n-      if( pExpr->iTable!=0\n-       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))\n-      ){\n+      assert( pExpr->pLeft->op==TK_SELECT || pExpr->pLeft->op==TK_ERROR );\n+      n = sqlite3ExprVectorSize(pExpr->pLeft);\n+      if( pExpr->iTable!=n ){\n@@ -103856,3 +106195,8 @@\n-      Table *pTab = pExpr->y.pTab;\n-      int iCol = pExpr->iColumn;\n-      int p1 = pExpr->iTable * (pTab->nCol+1) + 1\n+      Table *pTab;\n+      int iCol;\n+      int p1;\n+\n+      assert( ExprUseYTab(pExpr) );\n+      pTab = pExpr->y.pTab;\n+      iCol = pExpr->iColumn;\n+      p1 = pExpr->iTable * (pTab->nCol+1) + 1\n@@ -103869,1 +106213,1 @@\n-        (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zName)\n+        (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zCnName)\n@@ -103946,1 +106290,1 @@\n-      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );\n+      assert( ExprUseXList(pExpr) && pExpr->x.pList!=0 );\n@@ -104109,0 +106453,1 @@\n+   && ALWAYS(pExpr!=0)\n@@ -104137,1 +106482,0 @@\n-  inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);\n@@ -104139,1 +106483,3 @@\n-  if( inReg!=target && pParse->pVdbe ){\n+  if( pParse->pVdbe==0 ) return;\n+  inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);\n+  if( inReg!=target ){\n@@ -104141,1 +106487,1 @@\n-    if( ExprHasProperty(pExpr,EP_Subquery) ){\n+    if( ALWAYS(pExpr) && ExprHasProperty(pExpr,EP_Subquery) ){\n@@ -104289,1 +106635,1 @@\n-  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n+  assert( ExprUseXList(pExpr) );\n@@ -104403,1 +106749,1 @@\n-      \/* Fall thru *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -104579,1 +106925,1 @@\n-      \/* Fall thru *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -104679,1 +107025,5 @@\n-static int exprCompareVariable(Parse *pParse, Expr *pVar, Expr *pExpr){\n+static int exprCompareVariable(\n+  const Parse *pParse,\n+  const Expr *pVar,\n+  const Expr *pExpr\n+){\n@@ -104731,1 +107081,6 @@\n-SQLITE_PRIVATE int sqlite3ExprCompare(Parse *pParse, Expr *pA, Expr *pB, int iTab){\n+SQLITE_PRIVATE int sqlite3ExprCompare(\n+  const Parse *pParse,\n+  const Expr *pA,\n+  const Expr *pB,\n+  int iTab\n+){\n@@ -104755,1 +107110,3 @@\n-  if( pA->op!=TK_COLUMN && pA->op!=TK_AGG_COLUMN && pA->u.zToken ){\n+  assert( !ExprHasProperty(pA, EP_IntValue) );\n+  assert( !ExprHasProperty(pB, EP_IntValue) );\n+  if( pA->u.zToken ){\n@@ -104773,1 +107130,6 @@\n-    }else if( ALWAYS(pB->u.zToken!=0) && strcmp(pA->u.zToken,pB->u.zToken)!=0 ){\n+    }else\n+    if( pB->u.zToken!=0\n+     && pA->op!=TK_COLUMN\n+     && pA->op!=TK_AGG_COLUMN\n+     && strcmp(pA->u.zToken,pB->u.zToken)!=0\n+    ){\n@@ -104815,1 +107177,1 @@\n-SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){\n+SQLITE_PRIVATE int sqlite3ExprListCompare(const ExprList *pA, const ExprList *pB, int iTab){\n@@ -104834,1 +107196,1 @@\n-SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){\n+SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr *pA,Expr *pB, int iTab){\n@@ -104848,3 +107210,3 @@\n-  Parse *pParse,      \/* Parsing context *\/\n-  Expr *p,            \/* The expression to be checked *\/\n-  Expr *pNN,          \/* The expression that is NOT NULL *\/\n+  const Parse *pParse,\/* Parsing context *\/\n+  const Expr *p,      \/* The expression to be checked *\/\n+  const Expr *pNN,    \/* The expression that is NOT NULL *\/\n@@ -104862,2 +107224,1 @@\n-      assert( ExprHasProperty(p,EP_xIsSelect)\n-           || (p->x.pList!=0 && p->x.pList->nExpr>0) );\n+      assert( ExprUseXSelect(p) || (p->x.pList!=0 && p->x.pList->nExpr>0) );\n@@ -104867,1 +107228,3 @@\n-      ExprList *pList = p->x.pList;\n+      ExprList *pList;\n+      assert( ExprUseXList(p) );\n+      pList = p->x.pList;\n@@ -104891,1 +107254,1 @@\n-      \/* Fall thru *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -104897,1 +107260,1 @@\n-      \/* Fall thru into the next case *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -104943,1 +107306,6 @@\n-SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse *pParse, Expr *pE1, Expr *pE2, int iTab){\n+SQLITE_PRIVATE int sqlite3ExprImpliesExpr(\n+  const Parse *pParse,\n+  const Expr *pE1,\n+  const Expr *pE2,\n+  int iTab\n+){\n@@ -105039,4 +107407,8 @@\n-      if( (pLeft->op==TK_COLUMN && ALWAYS(pLeft->y.pTab!=0)\n-                               && IsVirtual(pLeft->y.pTab))\n-       || (pRight->op==TK_COLUMN && ALWAYS(pRight->y.pTab!=0)\n-                               && IsVirtual(pRight->y.pTab))\n+      assert( pLeft->op!=TK_COLUMN || ExprUseYTab(pLeft) );\n+      assert( pRight->op!=TK_COLUMN || ExprUseYTab(pRight) );\n+      if( (pLeft->op==TK_COLUMN\n+           && pLeft->y.pTab!=0\n+           && IsVirtual(pLeft->y.pTab))\n+       || (pRight->op==TK_COLUMN\n+           && pRight->y.pTab!=0\n+           && IsVirtual(pRight->y.pTab))\n@@ -105046,0 +107418,1 @@\n+      \/* no break *\/ deliberate_fall_through\n@@ -105150,11 +107523,8 @@\n-\/*\n-** An instance of the following structure is used by the tree walker\n-** to count references to table columns in the arguments of an\n-** aggregate function, in order to implement the\n-** sqlite3FunctionThisSrc() routine.\n-*\/\n-struct SrcCount {\n-  SrcList *pSrc;   \/* One particular FROM clause in a nested query *\/\n-  int iSrcInner;   \/* Smallest cursor number in this context *\/\n-  int nThis;       \/* Number of references to columns in pSrcList *\/\n-  int nOther;      \/* Number of references to columns in other FROM clauses *\/\n+\/* Structure used to pass information throught the Walker in order to\n+** implement sqlite3ReferencesSrcList().\n+*\/\n+struct RefSrcList {\n+  sqlite3 *db;         \/* Database connection used for sqlite3DbRealloc() *\/\n+  SrcList *pRef;       \/* Looking for references to these tables *\/\n+  i64 nExclude;        \/* Number of tables to exclude from the search *\/\n+  int *aiExclude;      \/* Cursor IDs for tables to exclude from the search *\/\n@@ -105164,4 +107534,6 @@\n-** xSelect callback for sqlite3FunctionUsesThisSrc(). If this is the first\n-** SELECT with a FROM clause encountered during this iteration, set\n-** SrcCount.iSrcInner to the cursor number of the leftmost object in\n-** the FROM cause.\n+** Walker SELECT callbacks for sqlite3ReferencesSrcList().\n+**\n+** When entering a new subquery on the pExpr argument, add all FROM clause\n+** entries for that subquery to the exclude list.\n+**\n+** When leaving the subquery, remove those entries from the exclude list.\n@@ -105169,4 +107541,17 @@\n-static int selectSrcCount(Walker *pWalker, Select *pSel){\n-  struct SrcCount *p = pWalker->u.pSrcCount;\n-  if( p->iSrcInner==0x7FFFFFFF && ALWAYS(pSel->pSrc) && pSel->pSrc->nSrc ){\n-    pWalker->u.pSrcCount->iSrcInner = pSel->pSrc->a[0].iCursor;\n+static int selectRefEnter(Walker *pWalker, Select *pSelect){\n+  struct RefSrcList *p = pWalker->u.pRefSrcList;\n+  SrcList *pSrc = pSelect->pSrc;\n+  i64 i, j;\n+  int *piNew;\n+  if( pSrc->nSrc==0 ) return WRC_Continue;\n+  j = p->nExclude;\n+  p->nExclude += pSrc->nSrc;\n+  piNew = sqlite3DbRealloc(p->db, p->aiExclude, p->nExclude*sizeof(int));\n+  if( piNew==0 ){\n+    p->nExclude = 0;\n+    return WRC_Abort;\n+  }else{\n+    p->aiExclude = piNew;\n+  }\n+  for(i=0; i<pSrc->nSrc; i++, j++){\n+     p->aiExclude[j] = pSrc->a[i].iCursor;\n@@ -105176,0 +107561,8 @@\n+static void selectRefLeave(Walker *pWalker, Select *pSelect){\n+  struct RefSrcList *p = pWalker->u.pRefSrcList;\n+  SrcList *pSrc = pSelect->pSrc;\n+  if( p->nExclude ){\n+    assert( p->nExclude>=pSrc->nSrc );\n+    p->nExclude -= pSrc->nSrc;\n+  }\n+}\n@@ -105177,2 +107570,7 @@\n-\/*\n-** Count the number of references to columns.\n+\/* This is the Walker EXPR callback for sqlite3ReferencesSrcList().\n+**\n+** Set the 0x01 bit of pWalker->eCode if there is a reference to any\n+** of the tables shown in RefSrcList.pRef.\n+**\n+** Set the 0x02 bit of pWalker->eCode if there is a reference to a\n+** table is in neither RefSrcList.pRef nor RefSrcList.aiExclude.\n@@ -105180,8 +107578,4 @@\n-static int exprSrcCount(Walker *pWalker, Expr *pExpr){\n-  \/* There was once a NEVER() on the second term on the grounds that\n-  ** sqlite3FunctionUsesThisSrc() was always called before\n-  ** sqlite3ExprAnalyzeAggregates() and so the TK_COLUMNs have not yet\n-  ** been converted into TK_AGG_COLUMN. But this is no longer true due\n-  ** to window functions - sqlite3WindowRewrite() may now indirectly call\n-  ** FunctionUsesThisSrc() when creating a new sub-select. *\/\n-  if( pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN ){\n+static int exprRefToSrcList(Walker *pWalker, Expr *pExpr){\n+  if( pExpr->op==TK_COLUMN\n+   || pExpr->op==TK_AGG_COLUMN\n+  ){\n@@ -105189,2 +107583,2 @@\n-    struct SrcCount *p = pWalker->u.pSrcCount;\n-    SrcList *pSrc = p->pSrc;\n+    struct RefSrcList *p = pWalker->u.pRefSrcList;\n+    SrcList *pSrc = p->pRef;\n@@ -105193,1 +107587,4 @@\n-      if( pExpr->iTable==pSrc->a[i].iCursor ) break;\n+      if( pExpr->iTable==pSrc->a[i].iCursor ){\n+        pWalker->eCode |= 1;\n+        return WRC_Continue;\n+      }\n@@ -105195,7 +107592,3 @@\n-    if( i<nSrc ){\n-      p->nThis++;\n-    }else if( pExpr->iTable<p->iSrcInner ){\n-      \/* In a well-formed parse tree (no name resolution errors),\n-      ** TK_COLUMN nodes with smaller Expr.iTable values are in an\n-      ** outer context.  Those are the only ones to count as \"other\" *\/\n-      p->nOther++;\n+    for(i=0; i<p->nExclude && p->aiExclude[i]!=pExpr->iTable; i++){}\n+    if( i>=p->nExclude ){\n+      pWalker->eCode |= 2;\n@@ -105208,4 +107601,13 @@\n-** Determine if any of the arguments to the pExpr Function reference\n-** pSrcList.  Return true if they do.  Also return true if the function\n-** has no arguments or has only constant arguments.  Return false if pExpr\n-** references columns but not columns of tables found in pSrcList.\n+** Check to see if pExpr references any tables in pSrcList.\n+** Possible return values:\n+**\n+**    1         pExpr does references a table in pSrcList.\n+**\n+**    0         pExpr references some table that is not defined in either\n+**              pSrcList or in subqueries of pExpr itself.\n+**\n+**   -1         pExpr only references no tables at all, or it only\n+**              references tables defined in subqueries of pExpr itself.\n+**\n+** As currently used, pExpr is always an aggregate function call.  That\n+** fact is exploited for efficiency.\n@@ -105213,1 +107615,1 @@\n-SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){\n+SQLITE_PRIVATE int sqlite3ReferencesSrcList(Parse *pParse, Expr *pExpr, SrcList *pSrcList){\n@@ -105215,2 +107617,1 @@\n-  struct SrcCount cnt;\n-  assert( pExpr->op==TK_AGG_FUNCTION );\n+  struct RefSrcList x;\n@@ -105218,7 +107619,9 @@\n-  w.xExprCallback = exprSrcCount;\n-  w.xSelectCallback = selectSrcCount;\n-  w.u.pSrcCount = &cnt;\n-  cnt.pSrc = pSrcList;\n-  cnt.iSrcInner = (pSrcList&&pSrcList->nSrc)?pSrcList->a[0].iCursor:0x7FFFFFFF;\n-  cnt.nThis = 0;\n-  cnt.nOther = 0;\n+  memset(&x, 0, sizeof(x));\n+  w.xExprCallback = exprRefToSrcList;\n+  w.xSelectCallback = selectRefEnter;\n+  w.xSelectCallback2 = selectRefLeave;\n+  w.u.pRefSrcList = &x;\n+  x.db = pParse->db;\n+  x.pRef = pSrcList;\n+  assert( pExpr->op==TK_AGG_FUNCTION );\n+  assert( ExprUseXList(pExpr) );\n@@ -105231,1 +107634,8 @@\n-  return cnt.nThis>0 || cnt.nOther==0;\n+  sqlite3DbFree(pParse->db, x.aiExclude);\n+  if( w.eCode & 0x01 ){\n+    return 1;\n+  }else if( w.eCode ){\n+    return 0;\n+  }else{\n+    return -1;\n+  }\n@@ -105258,1 +107668,1 @@\n-      if( pAggInfo->aCol[iAgg].pExpr==pExpr ){\n+      if( pAggInfo->aCol[iAgg].pCExpr==pExpr ){\n@@ -105261,3 +107671,2 @@\n-          pAggInfo->aCol[iAgg].pExpr = pExpr;\n-          pParse->pConstExpr =\n-             sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);\n+          pAggInfo->aCol[iAgg].pCExpr = pExpr;\n+          sqlite3ExprDeferredDelete(pParse, pExpr);\n@@ -105268,1 +107677,1 @@\n-      if( pAggInfo->aFunc[iAgg].pExpr==pExpr ){\n+      if( pAggInfo->aFunc[iAgg].pFExpr==pExpr ){\n@@ -105271,3 +107680,2 @@\n-          pAggInfo->aFunc[iAgg].pExpr = pExpr;\n-          pParse->pConstExpr =\n-             sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);\n+          pAggInfo->aFunc[iAgg].pFExpr = pExpr;\n+          sqlite3ExprDeferredDelete(pParse, pExpr);\n@@ -105345,1 +107753,1 @@\n-        struct SrcList_item *pItem = pSrcList->a;\n+        SrcItem *pItem = pSrcList->a;\n@@ -105368,0 +107776,1 @@\n+              assert( ExprUseYTab(pExpr) );\n@@ -105373,1 +107782,1 @@\n-              pCol->pExpr = pExpr;\n+              pCol->pCExpr = pExpr;\n@@ -105416,1 +107825,2 @@\n-          if( sqlite3ExprCompare(0, pItem->pExpr, pExpr, -1)==0 ){\n+          if( pItem->pFExpr==pExpr ) break;\n+          if( sqlite3ExprCompare(0, pItem->pFExpr, pExpr, -1)==0 ){\n@@ -105428,1 +107838,1 @@\n-            pItem->pExpr = pExpr;\n+            pItem->pFExpr = pExpr;\n@@ -105430,1 +107840,1 @@\n-            assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+            assert( ExprUseUToken(pExpr) );\n@@ -105616,0 +108026,1 @@\n+   || (pTab->tabFlags & TF_Eponymous)!=0\n@@ -105634,1 +108045,8 @@\n-static void renameTestSchema(Parse *pParse, const char *zDb, int bTemp){\n+static void renameTestSchema(\n+  Parse *pParse,                  \/* Parse context *\/\n+  const char *zDb,                \/* Name of db to verify schema of *\/\n+  int bTemp,                      \/* True if this is the temp db *\/\n+  const char *zWhen,              \/* \"when\" part of error message *\/\n+  int bNoDQS                      \/* Do not allow DQS in the schema *\/\n+){\n+  pParse->colNamesSet = 1;\n@@ -105637,1 +108055,1 @@\n-      \"FROM \\\"%w\\\".%s \"\n+      \"FROM \\\"%w\\\".\" LEGACY_SCHEMA_TABLE \" \"\n@@ -105640,3 +108058,3 @@\n-      \" AND sqlite_rename_test(%Q, sql, type, name, %d)=NULL \",\n-      zDb, MASTER_NAME,\n-      zDb, bTemp\n+      \" AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL \",\n+      zDb,\n+      zDb, bTemp, zWhen, bNoDQS\n@@ -105648,1 +108066,1 @@\n-        \"FROM temp.%s \"\n+        \"FROM temp.\" LEGACY_SCHEMA_TABLE \" \"\n@@ -105651,2 +108069,26 @@\n-        \" AND sqlite_rename_test(%Q, sql, type, name, 1)=NULL \",\n-        MASTER_NAME, zDb\n+        \" AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL \",\n+        zDb, zWhen, bNoDQS\n+    );\n+  }\n+}\n+\n+\/*\n+** Generate VM code to replace any double-quoted strings (but not double-quoted\n+** identifiers) within the \"sql\" column of the sqlite_schema table in\n+** database zDb with their single-quoted equivalents. If argument bTemp is\n+** not true, similarly update all SQL statements in the sqlite_schema table\n+** of the temp db.\n+*\/\n+static void renameFixQuotes(Parse *pParse, const char *zDb, int bTemp){\n+  sqlite3NestedParse(pParse,\n+      \"UPDATE \\\"%w\\\".\" LEGACY_SCHEMA_TABLE\n+      \" SET sql = sqlite_rename_quotefix(%Q, sql)\"\n+      \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n+      \" AND sql NOT LIKE 'create virtual%%'\" , zDb, zDb\n+  );\n+  if( bTemp==0 ){\n+    sqlite3NestedParse(pParse,\n+      \"UPDATE temp.\" LEGACY_SCHEMA_TABLE\n+      \" SET sql = sqlite_rename_quotefix('temp', sql)\"\n+      \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n+      \" AND sql NOT LIKE 'create virtual%%'\"\n@@ -105661,1 +108103,1 @@\n-static void renameReloadSchema(Parse *pParse, int iDb){\n+static void renameReloadSchema(Parse *pParse, int iDb, u16 p5){\n@@ -105665,2 +108107,2 @@\n-    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0);\n-    if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0);\n+    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0, p5);\n+    if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0, p5);\n@@ -105688,1 +108130,0 @@\n-  u32 savedDbFlags;         \/* Saved value of db->mDbFlags *\/\n@@ -105690,1 +108131,0 @@\n-  savedDbFlags = db->mDbFlags;\n@@ -105699,1 +108139,0 @@\n-  db->mDbFlags |= DBFLAG_PreferBuiltin;\n@@ -105728,1 +108167,1 @@\n-  if( pTab->pSelect ){\n+  if( IsView(pTab) ){\n@@ -105770,1 +108209,1 @@\n-      \"UPDATE \\\"%w\\\".%s SET \"\n+      \"UPDATE \\\"%w\\\".\" LEGACY_SCHEMA_TABLE \" SET \"\n@@ -105774,1 +108213,1 @@\n-      , zDb, MASTER_NAME, zDb, zTabName, zName, (iDb==1), zTabName\n+      , zDb, zDb, zTabName, zName, (iDb==1), zTabName\n@@ -105777,1 +108216,1 @@\n-  \/* Update the tbl_name and name columns of the sqlite_master table\n+  \/* Update the tbl_name and name columns of the sqlite_schema table\n@@ -105780,1 +108219,1 @@\n-      \"UPDATE %Q.%s SET \"\n+      \"UPDATE %Q.\" LEGACY_SCHEMA_TABLE \" SET \"\n@@ -105790,1 +108229,1 @@\n-      zDb, MASTER_NAME,\n+      zDb,\n@@ -105811,1 +108250,1 @@\n-        \"UPDATE sqlite_temp_master SET \"\n+        \"UPDATE sqlite_temp_schema SET \"\n@@ -105815,1 +108254,1 @@\n-              \"          sqlite_rename_test(%Q, sql, type, name, 1) \"\n+              \"  sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) \"\n@@ -105834,2 +108273,2 @@\n-  renameReloadSchema(pParse, iDb);\n-  renameTestSchema(pParse, zDb, iDb==1);\n+  renameReloadSchema(pParse, iDb, INITFLAG_AlterRename);\n+  renameTestSchema(pParse, zDb, iDb==1, \"after rename\", 0);\n@@ -105840,1 +108279,0 @@\n-  db->mDbFlags = savedDbFlags;\n@@ -105890,1 +108328,1 @@\n-  pDflt = pCol->pDflt;\n+  pDflt = sqlite3ColumnExpr(pNew, pCol);\n@@ -105924,1 +108362,2 @@\n-    if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){\n+    assert( IsOrdinaryTable(pNew) );\n+    if( (db->flags&SQLITE_ForeignKeys) && pNew->u.tab.pFKey && pDflt ){\n@@ -105961,1 +108400,0 @@\n-    u32 savedDbFlags = db->mDbFlags;\n@@ -105965,1 +108403,4 @@\n-    db->mDbFlags |= DBFLAG_PreferBuiltin;\n+    \/* substr() operations on characters, but addColOffset is in bytes. So we\n+    ** have to use printf() to translate between these units: *\/\n+    assert( IsOrdinaryTable(pTab) );\n+    assert( IsOrdinaryTable(pNew) );\n@@ -105967,2 +108408,3 @@\n-        \"UPDATE \\\"%w\\\".%s SET \"\n-          \"sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) \"\n+        \"UPDATE \\\"%w\\\".\" LEGACY_SCHEMA_TABLE \" SET \"\n+          \"sql = printf('%%.%ds, ',sql) || %Q\"\n+          \" || substr(sql,1+length(printf('%%.%ds',sql))) \"\n@@ -105970,1 +108412,1 @@\n-      zDb, MASTER_NAME, pNew->addColOffset, zCol, pNew->addColOffset+1,\n+      zDb, pNew->u.tab.addColOffset, zCol, pNew->u.tab.addColOffset,\n@@ -105974,1 +108416,0 @@\n-    db->mDbFlags = savedDbFlags;\n@@ -105977,4 +108418,0 @@\n-  \/* Make sure the schema version is at least 3.  But do not upgrade\n-  ** from less than 3 to 4, as that will corrupt any preexisting DESC\n-  ** index.\n-  *\/\n@@ -105983,0 +108420,4 @@\n+    \/* Make sure the schema version is at least 3.  But do not upgrade\n+    ** from less than 3 to 4, as that will corrupt any preexisting DESC\n+    ** index.\n+    *\/\n@@ -105991,1 +108432,0 @@\n-  }\n@@ -105993,2 +108433,18 @@\n-  \/* Reload the table definition *\/\n-  renameReloadSchema(pParse, iDb);\n+    \/* Reload the table definition *\/\n+    renameReloadSchema(pParse, iDb, INITFLAG_AlterAdd);\n+\n+    \/* Verify that constraints are still satisfied *\/\n+    if( pNew->pCheck!=0\n+     || (pCol->notNull && (pCol->colFlags & COLFLAG_GENERATED)!=0)\n+    ){\n+      sqlite3NestedParse(pParse,\n+        \"SELECT CASE WHEN quick_check GLOB 'CHECK*'\"\n+        \" THEN raise(ABORT,'CHECK constraint failed')\"\n+        \" ELSE raise(ABORT,'NOT NULL constraint failed')\"\n+        \" END\"\n+        \"  FROM pragma_quick_check(\\\"%w\\\",\\\"%w\\\")\"\n+        \" WHERE quick_check GLOB 'CHECK*' OR quick_check GLOB 'NULL*'\",\n+        zTab, zDb\n+      );\n+    }\n+  }\n@@ -106035,1 +108491,1 @@\n-  if( pTab->pSelect ){\n+  if( IsView(pTab) ){\n@@ -106044,1 +108500,2 @@\n-  assert( pTab->addColOffset>0 );\n+  assert( IsOrdinaryTable(pTab) );\n+  assert( pTab->u.tab.addColOffset>0 );\n@@ -106071,4 +108528,2 @@\n-    pCol->zName = sqlite3DbStrDup(db, pCol->zName);\n-    pCol->hName = sqlite3StrIHash(pCol->zName);\n-    pCol->zColl = 0;\n-    pCol->pDflt = 0;\n+    pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);\n+    pCol->hName = sqlite3StrIHash(pCol->zCnName);\n@@ -106076,0 +108531,2 @@\n+  assert( IsOrdinaryTable(pNew) );\n+  pNew->u.tab.pDfltList = sqlite3ExprListDup(db, pTab->u.tab.pDfltList, 0);\n@@ -106077,1 +108534,1 @@\n-  pNew->addColOffset = pTab->addColOffset;\n+  pNew->u.tab.addColOffset = pTab->u.tab.addColOffset;\n@@ -106094,1 +108551,1 @@\n-static int isRealTable(Parse *pParse, Table *pTab){\n+static int isRealTable(Parse *pParse, Table *pTab, int bDrop){\n@@ -106097,1 +108554,1 @@\n-  if( pTab->pSelect ){\n+  if( IsView(pTab) ){\n@@ -106107,2 +108564,3 @@\n-    sqlite3ErrorMsg(\n-        pParse, \"cannot rename columns of %s \\\"%s\\\"\", zType, pTab->zName\n+    sqlite3ErrorMsg(pParse, \"cannot %s %s \\\"%s\\\"\",\n+        (bDrop ? \"drop column from\" : \"rename columns of\"),\n+        zType, pTab->zName\n@@ -106115,1 +108573,1 @@\n-# define isRealTable(x,y) (0)\n+# define isRealTable(x,y,z) (0)\n@@ -106144,1 +108602,1 @@\n-  if( SQLITE_OK!=isRealTable(pParse, pTab) ) goto exit_rename_column;\n+  if( SQLITE_OK!=isRealTable(pParse, pTab, 0) ) goto exit_rename_column;\n@@ -106163,1 +108621,1 @@\n-    if( 0==sqlite3StrICmp(pTab->aCol[iCol].zName, zOld) ) break;\n+    if( 0==sqlite3StrICmp(pTab->aCol[iCol].zCnName, zOld) ) break;\n@@ -106170,0 +108628,4 @@\n+  \/* Ensure the schema contains no double-quoted strings *\/\n+  renameTestSchema(pParse, zDb, iSchema==1, \"\", 0);\n+  renameFixQuotes(pParse, zDb, iSchema==1);\n+\n@@ -106172,1 +108634,1 @@\n-  ** CREATE statement text for the sqlite_master table.\n+  ** CREATE statement text for the sqlite_schema table.\n@@ -106180,1 +108642,1 @@\n-      \"UPDATE \\\"%w\\\".%s SET \"\n+      \"UPDATE \\\"%w\\\".\" LEGACY_SCHEMA_TABLE \" SET \"\n@@ -106183,3 +108645,2 @@\n-      \" AND (type != 'index' OR tbl_name = %Q)\"\n-      \" AND sql NOT LIKE 'create virtual%%'\",\n-      zDb, MASTER_NAME,\n+      \" AND (type != 'index' OR tbl_name = %Q)\",\n+      zDb,\n@@ -106191,1 +108652,1 @@\n-      \"UPDATE temp.%s SET \"\n+      \"UPDATE temp.\" LEGACY_SCHEMA_TABLE \" SET \"\n@@ -106194,1 +108655,0 @@\n-      MASTER_NAME,\n@@ -106199,2 +108659,2 @@\n-  renameReloadSchema(pParse, iSchema);\n-  renameTestSchema(pParse, zDb, iSchema==1);\n+  renameReloadSchema(pParse, iSchema, INITFLAG_AlterRename);\n+  renameTestSchema(pParse, zDb, iSchema==1, \"after rename\", 1);\n@@ -106227,1 +108687,1 @@\n-  void *p;               \/* Parse tree element created by token t *\/\n+  const void *p;         \/* Parse tree element created by token t *\/\n@@ -106269,1 +108729,1 @@\n-static void renameTokenCheckAll(Parse *pParse, void *pPtr){\n+static void renameTokenCheckAll(Parse *pParse, const void *pPtr){\n@@ -106271,1 +108731,1 @@\n-    RenameToken *p;\n+    const RenameToken *p;\n@@ -106297,1 +108757,5 @@\n-SQLITE_PRIVATE void *sqlite3RenameTokenMap(Parse *pParse, void *pPtr, Token *pToken){\n+SQLITE_PRIVATE const void *sqlite3RenameTokenMap(\n+  Parse *pParse,\n+  const void *pPtr,\n+  const Token *pToken\n+){\n@@ -106319,1 +108783,1 @@\n-SQLITE_PRIVATE void sqlite3RenameTokenRemap(Parse *pParse, void *pTo, void *pFrom){\n+SQLITE_PRIVATE void sqlite3RenameTokenRemap(Parse *pParse, const void *pTo, const void *pFrom){\n@@ -106335,1 +108799,4 @@\n-  sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);\n+  sqlite3RenameTokenRemap(pParse, 0, (const void*)pExpr);\n+  if( ExprUseYTab(pExpr) ){\n+    sqlite3RenameTokenRemap(pParse, 0, (const void*)&pExpr->y.pTab);\n+  }\n@@ -106346,0 +108813,1 @@\n+    Parse *pParse = pWalker->pParse;\n@@ -106347,0 +108815,11 @@\n+    With *pCopy = 0;\n+    assert( pWith->nCte>0 );\n+    if( (pWith->a[0].pSelect->selFlags & SF_Expanded)==0 ){\n+      \/* Push a copy of the With object onto the with-stack. We use a copy\n+      ** here as the original will be expanded and resolved (flags SF_Expanded\n+      ** and SF_Resolved) below. And the parser code that uses the with-stack\n+      ** fails if the Select objects on it have already been expanded and\n+      ** resolved.  *\/\n+      pCopy = sqlite3WithDup(pParse->db, pWith);\n+      pCopy = sqlite3WithPush(pParse, pCopy, 1);\n+    }\n@@ -106351,2 +108830,3 @@\n-      sNC.pParse = pWalker->pParse;\n-      sqlite3SelectPrep(sNC.pParse, p, &sNC);\n+      sNC.pParse = pParse;\n+      if( pCopy ) sqlite3SelectPrep(sNC.pParse, p, &sNC);\n+      if( sNC.pParse->db->mallocFailed ) return;\n@@ -106354,1 +108834,4 @@\n-      sqlite3RenameExprlistUnmap(pWalker->pParse, pWith->a[i].pCols);\n+      sqlite3RenameExprlistUnmap(pParse, pWith->a[i].pCols);\n+    }\n+    if( pCopy && pParse->pWith==pCopy ){\n+      pParse->pWith = pCopy->pOuter;\n@@ -106364,1 +108847,1 @@\n-  IdList *pIdList\n+  const IdList *pIdList\n@@ -106369,1 +108852,1 @@\n-      sqlite3RenameTokenRemap(pParse, 0, (void*)pIdList->a[ii].zName);\n+      sqlite3RenameTokenRemap(pParse, 0, (const void*)pIdList->a[ii].zName);\n@@ -106381,1 +108864,5 @@\n-  if( NEVER(p->selFlags & SF_View) ) return WRC_Prune;\n+  testcase( p->selFlags & SF_View );\n+  testcase( p->selFlags & SF_CopyCte );\n+  if( p->selFlags & (SF_View|SF_CopyCte) ){\n+    return WRC_Prune;\n+  }\n@@ -106394,1 +108881,1 @@\n-      if( sqlite3WalkExpr(pWalker, pSrc->a[i].pOn) ) return WRC_Abort;\n+      sqlite3WalkExpr(pWalker, pSrc->a[i].pOn);\n@@ -106452,3 +108939,6 @@\n-** object associated with parse tree element pPtr. If found, remove it\n-** from the Parse object and add it to the list maintained by the\n-** RenameCtx object passed as the second argument.\n+** object associated with parse tree element pPtr. If found, return a pointer\n+** to it. Otherwise, return NULL.\n+**\n+** If the second argument passed to this function is not NULL and a matching\n+** RenameToken object is found, remove it from the Parse object and add it to\n+** the list maintained by the RenameCtx object.\n@@ -106456,1 +108946,5 @@\n-static void renameTokenFind(Parse *pParse, struct RenameCtx *pCtx, void *pPtr){\n+static RenameToken *renameTokenFind(\n+  Parse *pParse,\n+  struct RenameCtx *pCtx,\n+  const void *pPtr\n+){\n@@ -106458,1 +108952,3 @@\n-  assert( pPtr!=0 );\n+  if( NEVER(pPtr==0) ){\n+    return 0;\n+  }\n@@ -106462,5 +108958,7 @@\n-      *pp = pToken->pNext;\n-      pToken->pNext = pCtx->pList;\n-      pCtx->pList = pToken;\n-      pCtx->nList++;\n-      break;\n+      if( pCtx ){\n+        *pp = pToken->pNext;\n+        pToken->pNext = pCtx->pList;\n+        pCtx->pList = pToken;\n+        pCtx->nList++;\n+      }\n+      return pToken;\n@@ -106469,0 +108967,1 @@\n+  return 0;\n@@ -106477,1 +108976,5 @@\n-  if( p->selFlags & SF_View ) return WRC_Prune;\n+  if( p->selFlags & (SF_View|SF_CopyCte) ){\n+    testcase( p->selFlags & SF_View );\n+    testcase( p->selFlags & SF_CopyCte );\n+    return WRC_Prune;\n+  }\n@@ -106500,0 +109003,1 @@\n+   && ALWAYS(ExprUseYTab(pExpr))\n@@ -106539,1 +109043,1 @@\n-  int bPost,\n+  const char *zWhen,\n@@ -106548,2 +109052,2 @@\n-  zErr = sqlite3_mprintf(\"error in %s %s%s: %s\",\n-      zT, zN, (bPost ? \" after rename\" : \"\"),\n+  zErr = sqlite3_mprintf(\"error in %s %s%s%s: %s\",\n+      zT, zN, (zWhen[0] ? \" \" : \"\"), zWhen,\n@@ -106565,1 +109069,1 @@\n-  ExprList *pEList,\n+  const ExprList *pEList,\n@@ -106571,1 +109075,1 @@\n-      char *zName = pEList->a[i].zEName;\n+      const char *zName = pEList->a[i].zEName;\n@@ -106576,1 +109080,1 @@\n-        renameTokenFind(pParse, pCtx, (void*)zName);\n+        renameTokenFind(pParse, pCtx, (const void*)zName);\n@@ -106590,1 +109094,1 @@\n-  IdList *pIdList,\n+  const IdList *pIdList,\n@@ -106596,1 +109100,1 @@\n-      char *zName = pIdList->a[i].zName;\n+      const char *zName = pIdList->a[i].zName;\n@@ -106598,1 +109102,1 @@\n-        renameTokenFind(pParse, pCtx, (void*)zName);\n+        renameTokenFind(pParse, pCtx, (const void*)zName);\n@@ -106628,1 +109132,1 @@\n-  rc = sqlite3RunParser(p, zSql, &zErr);\n+  rc = zSql ? sqlite3RunParser(p, zSql, &zErr) : SQLITE_NOMEM;\n@@ -106671,2 +109175,2 @@\n-  int nNew = sqlite3Strlen30(zNew);\n-  int nSql = sqlite3Strlen30(zSql);\n+  i64 nNew = sqlite3Strlen30(zNew);\n+  i64 nSql = sqlite3Strlen30(zSql);\n@@ -106675,1 +109179,1 @@\n-  char *zQuot;\n+  char *zQuot = 0;\n@@ -106677,10 +109181,19 @@\n-  int nQuot;\n-\n-  \/* Set zQuot to point to a buffer containing a quoted copy of the\n-  ** identifier zNew. If the corresponding identifier in the original\n-  ** ALTER TABLE statement was quoted (bQuote==1), then set zNew to\n-  ** point to zQuot so that all substitutions are made using the\n-  ** quoted version of the new column name.  *\/\n-  zQuot = sqlite3MPrintf(db, \"\\\"%w\\\"\", zNew);\n-  if( zQuot==0 ){\n-    return SQLITE_NOMEM;\n+  i64 nQuot = 0;\n+  char *zBuf1 = 0;\n+  char *zBuf2 = 0;\n+\n+  if( zNew ){\n+    \/* Set zQuot to point to a buffer containing a quoted copy of the\n+    ** identifier zNew. If the corresponding identifier in the original\n+    ** ALTER TABLE statement was quoted (bQuote==1), then set zNew to\n+    ** point to zQuot so that all substitutions are made using the\n+    ** quoted version of the new column name.  *\/\n+    zQuot = sqlite3MPrintf(db, \"\\\"%w\\\" \", zNew);\n+    if( zQuot==0 ){\n+      return SQLITE_NOMEM;\n+    }else{\n+      nQuot = sqlite3Strlen30(zQuot)-1;\n+    }\n+\n+    assert( nQuot>=nNew );\n+    zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);\n@@ -106688,5 +109201,5 @@\n-    nQuot = sqlite3Strlen30(zQuot);\n-  }\n-  if( bQuote ){\n-    zNew = zQuot;\n-    nNew = nQuot;\n+    zOut = (char*)sqlite3DbMallocZero(db, (nSql*2+1) * 3);\n+    if( zOut ){\n+      zBuf1 = &zOut[nSql*2+1];\n+      zBuf2 = &zOut[nSql*4+2];\n+    }\n@@ -106697,4 +109210,2 @@\n-  ** with the new column name. All that remains is to construct and\n-  ** return the edited SQL string. *\/\n-  assert( nQuot>=nNew );\n-  zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);\n+  ** with the new column name, or with single-quoted versions of themselves.\n+  ** All that remains is to construct and return the edited SQL string. *\/\n@@ -106706,2 +109217,0 @@\n-      RenameToken *pBest = renameColumnTokenNext(pRename);\n-\n@@ -106710,3 +109219,11 @@\n-      if( sqlite3IsIdChar(*pBest->t.z) ){\n-        nReplace = nNew;\n-        zReplace = zNew;\n+      RenameToken *pBest = renameColumnTokenNext(pRename);\n+\n+      if( zNew ){\n+        if( bQuote==0 && sqlite3IsIdChar(*pBest->t.z) ){\n+          nReplace = nNew;\n+          zReplace = zNew;\n+        }else{\n+          nReplace = nQuot;\n+          zReplace = zQuot;\n+          if( pBest->t.z[pBest->t.n]=='\"' ) nReplace++;\n+        }\n@@ -106714,2 +109231,14 @@\n-        nReplace = nQuot;\n-        zReplace = zQuot;\n+        \/* Dequote the double-quoted token. Then requote it again, this time\n+        ** using single quotes. If the character immediately following the\n+        ** original token within the input SQL was a single quote ('), then\n+        ** add another space after the new, single-quoted version of the\n+        ** token. This is so that (SELECT \"string\"'alias') maps to\n+        ** (SELECT 'string' 'alias'), and not (SELECT 'string''alias').  *\/\n+        memcpy(zBuf1, pBest->t.z, pBest->t.n);\n+        zBuf1[pBest->t.n] = 0;\n+        sqlite3Dequote(zBuf1);\n+        sqlite3_snprintf(nSql*2, zBuf2, \"%Q%s\", zBuf1,\n+            pBest->t.z[pBest->t.n]=='\\'' ? \" \" : \"\"\n+        );\n+        zReplace = zBuf2;\n+        nReplace = sqlite3Strlen30(zReplace);\n@@ -106746,1 +109275,1 @@\n-static int renameResolveTrigger(Parse *pParse, const char *zDb){\n+static int renameResolveTrigger(Parse *pParse){\n@@ -106777,11 +109306,27 @@\n-      Table *pTarget = sqlite3LocateTable(pParse, 0, pStep->zTarget, zDb);\n-      if( pTarget==0 ){\n-        rc = SQLITE_ERROR;\n-      }else if( SQLITE_OK==(rc = sqlite3ViewGetColumnNames(pParse, pTarget)) ){\n-        SrcList sSrc;\n-        memset(&sSrc, 0, sizeof(sSrc));\n-        sSrc.nSrc = 1;\n-        sSrc.a[0].zName = pStep->zTarget;\n-        sSrc.a[0].pTab = pTarget;\n-        sNC.pSrcList = &sSrc;\n-        if( pStep->pWhere ){\n+      SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);\n+      if( pSrc ){\n+        int i;\n+        for(i=0; i<pSrc->nSrc && rc==SQLITE_OK; i++){\n+          SrcItem *p = &pSrc->a[i];\n+          p->iCursor = pParse->nTab++;\n+          if( p->pSelect ){\n+            sqlite3SelectPrep(pParse, p->pSelect, 0);\n+            sqlite3ExpandSubquery(pParse, p);\n+            assert( i>0 );\n+            assert( pStep->pFrom->a[i-1].pSelect );\n+            sqlite3SelectPrep(pParse, pStep->pFrom->a[i-1].pSelect, 0);\n+          }else{\n+            p->pTab = sqlite3LocateTableItem(pParse, 0, p);\n+            if( p->pTab==0 ){\n+              rc = SQLITE_ERROR;\n+            }else{\n+              p->pTab->nTabRef++;\n+              rc = sqlite3ViewGetColumnNames(pParse, p->pTab);\n+            }\n+          }\n+        }\n+        if( rc==SQLITE_OK && db->mallocFailed ){\n+          rc = SQLITE_NOMEM;\n+        }\n+        sNC.pSrcList = pSrc;\n+        if( rc==SQLITE_OK && pStep->pWhere ){\n@@ -106794,1 +109339,1 @@\n-        if( pStep->pUpsert ){\n+        if( pStep->pUpsert && rc==SQLITE_OK ){\n@@ -106796,2 +109341,1 @@\n-          assert( rc==SQLITE_OK );\n-          pUpsert->pUpsertSrc = &sSrc;\n+          pUpsert->pUpsertSrc = pSrc;\n@@ -106814,0 +109358,3 @@\n+        sqlite3SrcListDelete(db, pSrc);\n+      }else{\n+        rc = SQLITE_NOMEM;\n@@ -106842,0 +109389,6 @@\n+    if( pStep->pFrom ){\n+      int i;\n+      for(i=0; i<pStep->pFrom->nSrc; i++){\n+        sqlite3WalkSelect(pWalker, pStep->pFrom->a[i].pSelect);\n+      }\n+    }\n@@ -106925,1 +109478,1 @@\n-  zOld = pTab->aCol[iCol].zName;\n+  zOld = pTab->aCol[iCol].zCnName;\n@@ -106944,2 +109497,2 @@\n-    Select *pSelect = sParse.pNewTable->pSelect;\n-    if( pSelect ){\n+    if( IsView(sParse.pNewTable) ){\n+      Select *pSelect = sParse.pNewTable->u.view.pSelect;\n@@ -106954,1 +109507,1 @@\n-    }else{\n+    }else if( IsOrdinaryTable(sParse.pNewTable) ){\n@@ -106958,1 +109511,0 @@\n-      assert( sParse.pNewTable->pSelect==0 );\n@@ -106961,3 +109513,5 @@\n-        renameTokenFind(\n-            &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zName\n-        );\n+        if( iCol<sParse.pNewTable->nCol ){\n+          renameTokenFind(\n+              &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zCnName\n+          );\n+        }\n@@ -106974,1 +109528,0 @@\n-      }\n@@ -106976,3 +109529,5 @@\n-      for(i=0; i<sParse.pNewTable->nCol; i++){\n-        sqlite3WalkExpr(&sWalker, sParse.pNewTable->aCol[i].pDflt);\n-      }\n+        for(i=0; i<sParse.pNewTable->nCol; i++){\n+          Expr *pExpr = sqlite3ColumnExpr(sParse.pNewTable,\n+                                                  &sParse.pNewTable->aCol[i]);\n+          sqlite3WalkExpr(&sWalker, pExpr);\n+        }\n@@ -106980,0 +109535,1 @@\n+      }\n@@ -106981,1 +109537,2 @@\n-      for(pFKey=sParse.pNewTable->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n+      assert( IsOrdinaryTable(sParse.pNewTable) );\n+      for(pFKey=sParse.pNewTable->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n@@ -107000,1 +109557,1 @@\n-    rc = renameResolveTrigger(&sParse, (bTemp ? 0 : zDb));\n+    rc = renameResolveTrigger(&sParse);\n@@ -107033,1 +109590,1 @@\n-      renameColumnParseError(context, 0, argv[1], argv[2], &sParse);\n+      renameColumnParseError(context, \"\", argv[1], argv[2], &sParse);\n@@ -107052,1 +109609,4 @@\n-  if( pExpr->op==TK_COLUMN && p->pTab==pExpr->y.pTab ){\n+  if( pExpr->op==TK_COLUMN\n+   && ALWAYS(ExprUseYTab(pExpr))\n+   && p->pTab==pExpr->y.pTab\n+  ){\n@@ -107065,2 +109625,6 @@\n-  if( pSelect->selFlags & SF_View ) return WRC_Prune;\n-  if( pSrc==0 ){\n+  if( pSelect->selFlags & (SF_View|SF_CopyCte) ){\n+    testcase( pSelect->selFlags & SF_View );\n+    testcase( pSelect->selFlags & SF_CopyCte );\n+    return WRC_Prune;\n+  }\n+  if( NEVER(pSrc==0) ){\n@@ -107071,1 +109635,1 @@\n-    struct SrcList_item *pItem = &pSrc->a[i];\n+    SrcItem *pItem = &pSrc->a[i];\n@@ -107143,1 +109707,1 @@\n-        if( pTab->pSelect ){\n+        if( IsView(pTab) ){\n@@ -107145,1 +109709,1 @@\n-            Select *pSelect = pTab->pSelect;\n+            Select *pSelect = pTab->u.view.pSelect;\n@@ -107152,1 +109716,1 @@\n-            sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);\n+            sqlite3SelectPrep(&sParse, pTab->u.view.pSelect, &sNC);\n@@ -107156,1 +109720,1 @@\n-              sqlite3WalkSelect(&sWalker, pTab->pSelect);\n+              sqlite3WalkSelect(&sWalker, pTab->u.view.pSelect);\n@@ -107162,1 +109726,3 @@\n-          if( isLegacy==0 || (db->flags & SQLITE_ForeignKeys) ){\n+          if( (isLegacy==0 || (db->flags & SQLITE_ForeignKeys))\n+           && !IsVirtual(pTab)\n+          ){\n@@ -107164,1 +109730,2 @@\n-            for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n+            assert( IsOrdinaryTable(pTab) );\n+            for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n@@ -107203,1 +109770,1 @@\n-          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);\n+          rc = renameResolveTrigger(&sParse);\n@@ -107222,1 +109789,1 @@\n-        renameColumnParseError(context, 0, argv[1], argv[2], &sParse);\n+        renameColumnParseError(context, \"\", argv[1], argv[2], &sParse);\n@@ -107239,0 +109806,115 @@\n+static int renameQuotefixExprCb(Walker *pWalker, Expr *pExpr){\n+  if( pExpr->op==TK_STRING && (pExpr->flags & EP_DblQuoted) ){\n+    renameTokenFind(pWalker->pParse, pWalker->u.pRename, (const void*)pExpr);\n+  }\n+  return WRC_Continue;\n+}\n+\n+\/*\n+** The implementation of an SQL scalar function that rewrites DDL statements\n+** so that any string literals that use double-quotes are modified so that\n+** they use single quotes.\n+**\n+** Two arguments must be passed:\n+**\n+**   0: Database name (\"main\", \"temp\" etc.).\n+**   1: SQL statement to edit.\n+**\n+** The returned value is the modified SQL statement. For example, given\n+** the database schema:\n+**\n+**   CREATE TABLE t1(a, b, c);\n+**\n+**   SELECT sqlite_rename_quotefix('main',\n+**       'CREATE VIEW v1 AS SELECT \"a\", \"string\" FROM t1'\n+**   );\n+**\n+** returns the string:\n+**\n+**   CREATE VIEW v1 AS SELECT \"a\", 'string' FROM t1\n+*\/\n+static void renameQuotefixFunc(\n+  sqlite3_context *context,\n+  int NotUsed,\n+  sqlite3_value **argv\n+){\n+  sqlite3 *db = sqlite3_context_db_handle(context);\n+  char const *zDb = (const char*)sqlite3_value_text(argv[0]);\n+  char const *zInput = (const char*)sqlite3_value_text(argv[1]);\n+\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+  sqlite3_xauth xAuth = db->xAuth;\n+  db->xAuth = 0;\n+#endif\n+\n+  sqlite3BtreeEnterAll(db);\n+\n+  UNUSED_PARAMETER(NotUsed);\n+  if( zDb && zInput ){\n+    int rc;\n+    Parse sParse;\n+    rc = renameParseSql(&sParse, zDb, db, zInput, 0);\n+\n+    if( rc==SQLITE_OK ){\n+      RenameCtx sCtx;\n+      Walker sWalker;\n+\n+      \/* Walker to find tokens that need to be replaced. *\/\n+      memset(&sCtx, 0, sizeof(RenameCtx));\n+      memset(&sWalker, 0, sizeof(Walker));\n+      sWalker.pParse = &sParse;\n+      sWalker.xExprCallback = renameQuotefixExprCb;\n+      sWalker.xSelectCallback = renameColumnSelectCb;\n+      sWalker.u.pRename = &sCtx;\n+\n+      if( sParse.pNewTable ){\n+        if( IsView(sParse.pNewTable) ){\n+          Select *pSelect = sParse.pNewTable->u.view.pSelect;\n+          pSelect->selFlags &= ~SF_View;\n+          sParse.rc = SQLITE_OK;\n+          sqlite3SelectPrep(&sParse, pSelect, 0);\n+          rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);\n+          if( rc==SQLITE_OK ){\n+            sqlite3WalkSelect(&sWalker, pSelect);\n+          }\n+        }else{\n+          int i;\n+          sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n+#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n+          for(i=0; i<sParse.pNewTable->nCol; i++){\n+            sqlite3WalkExpr(&sWalker,\n+               sqlite3ColumnExpr(sParse.pNewTable,\n+                                         &sParse.pNewTable->aCol[i]));\n+          }\n+#endif \/* SQLITE_OMIT_GENERATED_COLUMNS *\/\n+        }\n+      }else if( sParse.pNewIndex ){\n+        sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n+        sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n+      }else{\n+#ifndef SQLITE_OMIT_TRIGGER\n+        rc = renameResolveTrigger(&sParse);\n+        if( rc==SQLITE_OK ){\n+          renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n+        }\n+#endif \/* SQLITE_OMIT_TRIGGER *\/\n+      }\n+\n+      if( rc==SQLITE_OK ){\n+        rc = renameEditSql(context, &sCtx, zInput, 0, 0);\n+      }\n+      renameTokenFree(db, sCtx.pList);\n+    }\n+    if( rc!=SQLITE_OK ){\n+      sqlite3_result_error_code(context, rc);\n+    }\n+    renameParseCleanup(&sParse);\n+  }\n+\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+  db->xAuth = xAuth;\n+#endif\n+\n+  sqlite3BtreeLeaveAll(db);\n+}\n+\n@@ -107251,0 +109933,2 @@\n+**   5: \"when\" part of error message.\n+**   6: True to disable the DQS quirk when parsing SQL.\n@@ -107268,0 +109952,2 @@\n+  char const *zWhen = (const char*)sqlite3_value_text(argv[5]);\n+  int bNoDQS = sqlite3_value_int(argv[6]);\n@@ -107275,0 +109961,1 @@\n+\n@@ -107278,0 +109965,2 @@\n+    int flags = db->flags;\n+    if( bNoDQS ) db->flags &= ~(SQLITE_DqsDML|SQLITE_DqsDDL);\n@@ -107279,0 +109968,1 @@\n+    db->flags |= (flags & (SQLITE_DqsDML|SQLITE_DqsDDL));\n@@ -107280,1 +109970,1 @@\n-      if( isLegacy==0 && sParse.pNewTable && sParse.pNewTable->pSelect ){\n+      if( isLegacy==0 && sParse.pNewTable && IsView(sParse.pNewTable) ){\n@@ -107284,1 +109974,1 @@\n-        sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, &sNC);\n+        sqlite3SelectPrep(&sParse, sParse.pNewTable->u.view.pSelect, &sNC);\n@@ -107290,1 +109980,1 @@\n-          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);\n+          rc = renameResolveTrigger(&sParse);\n@@ -107300,2 +109990,2 @@\n-    if( rc!=SQLITE_OK ){\n-      renameColumnParseError(context, 1, argv[2], argv[3], &sParse);\n+    if( rc!=SQLITE_OK && zWhen ){\n+      renameColumnParseError(context, zWhen, argv[2], argv[3],&sParse);\n@@ -107311,0 +110001,210 @@\n+\/*\n+** The implementation of internal UDF sqlite_drop_column().\n+**\n+** Arguments:\n+**\n+**  argv[0]: An integer - the index of the schema containing the table\n+**  argv[1]: CREATE TABLE statement to modify.\n+**  argv[2]: An integer - the index of the column to remove.\n+**\n+** The value returned is a string containing the CREATE TABLE statement\n+** with column argv[2] removed.\n+*\/\n+static void dropColumnFunc(\n+  sqlite3_context *context,\n+  int NotUsed,\n+  sqlite3_value **argv\n+){\n+  sqlite3 *db = sqlite3_context_db_handle(context);\n+  int iSchema = sqlite3_value_int(argv[0]);\n+  const char *zSql = (const char*)sqlite3_value_text(argv[1]);\n+  int iCol = sqlite3_value_int(argv[2]);\n+  const char *zDb = db->aDb[iSchema].zDbSName;\n+  int rc;\n+  Parse sParse;\n+  RenameToken *pCol;\n+  Table *pTab;\n+  const char *zEnd;\n+  char *zNew = 0;\n+\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+  sqlite3_xauth xAuth = db->xAuth;\n+  db->xAuth = 0;\n+#endif\n+\n+  UNUSED_PARAMETER(NotUsed);\n+  rc = renameParseSql(&sParse, zDb, db, zSql, iSchema==1);\n+  if( rc!=SQLITE_OK ) goto drop_column_done;\n+  pTab = sParse.pNewTable;\n+  if( pTab==0 || pTab->nCol==1 || iCol>=pTab->nCol ){\n+    \/* This can happen if the sqlite_schema table is corrupt *\/\n+    rc = SQLITE_CORRUPT_BKPT;\n+    goto drop_column_done;\n+  }\n+\n+  pCol = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol].zCnName);\n+  if( iCol<pTab->nCol-1 ){\n+    RenameToken *pEnd;\n+    pEnd = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol+1].zCnName);\n+    zEnd = (const char*)pEnd->t.z;\n+  }else{\n+    assert( IsOrdinaryTable(pTab) );\n+    zEnd = (const char*)&zSql[pTab->u.tab.addColOffset];\n+    while( ALWAYS(pCol->t.z[0]!=0) && pCol->t.z[0]!=',' ) pCol->t.z--;\n+  }\n+\n+  zNew = sqlite3MPrintf(db, \"%.*s%s\", pCol->t.z-zSql, zSql, zEnd);\n+  sqlite3_result_text(context, zNew, -1, SQLITE_TRANSIENT);\n+  sqlite3_free(zNew);\n+\n+drop_column_done:\n+  renameParseCleanup(&sParse);\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+  db->xAuth = xAuth;\n+#endif\n+  if( rc!=SQLITE_OK ){\n+    sqlite3_result_error_code(context, rc);\n+  }\n+}\n+\n+\/*\n+** This function is called by the parser upon parsing an\n+**\n+**     ALTER TABLE pSrc DROP COLUMN pName\n+**\n+** statement. Argument pSrc contains the possibly qualified name of the\n+** table being edited, and token pName the name of the column to drop.\n+*\/\n+SQLITE_PRIVATE void sqlite3AlterDropColumn(Parse *pParse, SrcList *pSrc, const Token *pName){\n+  sqlite3 *db = pParse->db;       \/* Database handle *\/\n+  Table *pTab;                    \/* Table to modify *\/\n+  int iDb;                        \/* Index of db containing pTab in aDb[] *\/\n+  const char *zDb;                \/* Database containing pTab (\"main\" etc.) *\/\n+  char *zCol = 0;                 \/* Name of column to drop *\/\n+  int iCol;                       \/* Index of column zCol in pTab->aCol[] *\/\n+\n+  \/* Look up the table being altered. *\/\n+  assert( pParse->pNewTable==0 );\n+  assert( sqlite3BtreeHoldsAllMutexes(db) );\n+  if( NEVER(db->mallocFailed) ) goto exit_drop_column;\n+  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n+  if( !pTab ) goto exit_drop_column;\n+\n+  \/* Make sure this is not an attempt to ALTER a view, virtual table or\n+  ** system table. *\/\n+  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ) goto exit_drop_column;\n+  if( SQLITE_OK!=isRealTable(pParse, pTab, 1) ) goto exit_drop_column;\n+\n+  \/* Find the index of the column being dropped. *\/\n+  zCol = sqlite3NameFromToken(db, pName);\n+  if( zCol==0 ){\n+    assert( db->mallocFailed );\n+    goto exit_drop_column;\n+  }\n+  iCol = sqlite3ColumnIndex(pTab, zCol);\n+  if( iCol<0 ){\n+    sqlite3ErrorMsg(pParse, \"no such column: \\\"%s\\\"\", zCol);\n+    goto exit_drop_column;\n+  }\n+\n+  \/* Do not allow the user to drop a PRIMARY KEY column or a column\n+  ** constrained by a UNIQUE constraint.  *\/\n+  if( pTab->aCol[iCol].colFlags & (COLFLAG_PRIMKEY|COLFLAG_UNIQUE) ){\n+    sqlite3ErrorMsg(pParse, \"cannot drop %s column: \\\"%s\\\"\",\n+        (pTab->aCol[iCol].colFlags&COLFLAG_PRIMKEY) ? \"PRIMARY KEY\" : \"UNIQUE\",\n+        zCol\n+    );\n+    goto exit_drop_column;\n+  }\n+\n+  \/* Do not allow the number of columns to go to zero *\/\n+  if( pTab->nCol<=1 ){\n+    sqlite3ErrorMsg(pParse, \"cannot drop column \\\"%s\\\": no other columns exist\",zCol);\n+    goto exit_drop_column;\n+  }\n+\n+  \/* Edit the sqlite_schema table *\/\n+  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n+  assert( iDb>=0 );\n+  zDb = db->aDb[iDb].zDbSName;\n+  renameTestSchema(pParse, zDb, iDb==1, \"\", 0);\n+  renameFixQuotes(pParse, zDb, iDb==1);\n+  sqlite3NestedParse(pParse,\n+      \"UPDATE \\\"%w\\\".\" LEGACY_SCHEMA_TABLE \" SET \"\n+      \"sql = sqlite_drop_column(%d, sql, %d) \"\n+      \"WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)\"\n+      , zDb, iDb, iCol, pTab->zName\n+  );\n+\n+  \/* Drop and reload the database schema. *\/\n+  renameReloadSchema(pParse, iDb, INITFLAG_AlterDrop);\n+  renameTestSchema(pParse, zDb, iDb==1, \"after drop column\", 1);\n+\n+  \/* Edit rows of table on disk *\/\n+  if( pParse->nErr==0 && (pTab->aCol[iCol].colFlags & COLFLAG_VIRTUAL)==0 ){\n+    int i;\n+    int addr;\n+    int reg;\n+    int regRec;\n+    Index *pPk = 0;\n+    int nField = 0;               \/* Number of non-virtual columns after drop *\/\n+    int iCur;\n+    Vdbe *v = sqlite3GetVdbe(pParse);\n+    iCur = pParse->nTab++;\n+    sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenWrite);\n+    addr = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);\n+    reg = ++pParse->nMem;\n+    if( HasRowid(pTab) ){\n+      sqlite3VdbeAddOp2(v, OP_Rowid, iCur, reg);\n+      pParse->nMem += pTab->nCol;\n+    }else{\n+      pPk = sqlite3PrimaryKeyIndex(pTab);\n+      pParse->nMem += pPk->nColumn;\n+      for(i=0; i<pPk->nKeyCol; i++){\n+        sqlite3VdbeAddOp3(v, OP_Column, iCur, i, reg+i+1);\n+      }\n+      nField = pPk->nKeyCol;\n+    }\n+    regRec = ++pParse->nMem;\n+    for(i=0; i<pTab->nCol; i++){\n+      if( i!=iCol && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){\n+        int regOut;\n+        if( pPk ){\n+          int iPos = sqlite3TableColumnToIndex(pPk, i);\n+          int iColPos = sqlite3TableColumnToIndex(pPk, iCol);\n+          if( iPos<pPk->nKeyCol ) continue;\n+          regOut = reg+1+iPos-(iPos>iColPos);\n+        }else{\n+          regOut = reg+1+nField;\n+        }\n+        if( i==pTab->iPKey ){\n+          sqlite3VdbeAddOp2(v, OP_Null, 0, regOut);\n+        }else{\n+          sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut);\n+        }\n+        nField++;\n+      }\n+    }\n+    if( nField==0 ){\n+      \/* dbsqlfuzz 5f09e7bcc78b4954d06bf9f2400d7715f48d1fef *\/\n+      pParse->nMem++;\n+      sqlite3VdbeAddOp2(v, OP_Null, 0, reg+1);\n+      nField = 1;\n+    }\n+    sqlite3VdbeAddOp3(v, OP_MakeRecord, reg+1, nField, regRec);\n+    if( pPk ){\n+      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iCur, regRec, reg+1, pPk->nKeyCol);\n+    }else{\n+      sqlite3VdbeAddOp3(v, OP_Insert, iCur, regRec, reg);\n+    }\n+    sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);\n+\n+    sqlite3VdbeAddOp2(v, OP_Next, iCur, addr+1); VdbeCoverage(v);\n+    sqlite3VdbeJumpHere(v, addr);\n+  }\n+\n+exit_drop_column:\n+  sqlite3DbFree(db, zCol);\n+  sqlite3SrcListDelete(db, pSrc);\n+}\n+\n@@ -107316,3 +110216,5 @@\n-    INTERNAL_FUNCTION(sqlite_rename_column, 9, renameColumnFunc),\n-    INTERNAL_FUNCTION(sqlite_rename_table,  7, renameTableFunc),\n-    INTERNAL_FUNCTION(sqlite_rename_test,   5, renameTableTest),\n+    INTERNAL_FUNCTION(sqlite_rename_column,  9, renameColumnFunc),\n+    INTERNAL_FUNCTION(sqlite_rename_table,   7, renameTableFunc),\n+    INTERNAL_FUNCTION(sqlite_rename_test,    7, renameTableTest),\n+    INTERNAL_FUNCTION(sqlite_drop_column,    3, dropColumnFunc),\n+    INTERNAL_FUNCTION(sqlite_rename_quotefix,2, renameQuotefixFunc),\n@@ -107514,1 +110416,1 @@\n-  int aRoot[ArraySize(aTable)];\n+  u32 aRoot[ArraySize(aTable)];\n@@ -107543,1 +110445,1 @@\n-        aRoot[i] = pParse->regRoot;\n+        aRoot[i] = (u32)pParse->regRoot;\n@@ -107563,1 +110465,1 @@\n-        sqlite3VdbeAddOp2(v, OP_Clear, aRoot[i], iDb);\n+        sqlite3VdbeAddOp2(v, OP_Clear, (int)aRoot[i], iDb);\n@@ -107571,1 +110473,1 @@\n-    sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, aRoot[i], iDb, 3);\n+    sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, (int)aRoot[i], iDb, 3);\n@@ -107761,1 +110663,0 @@\n-  db = sqlite3_context_db_handle(context);\n@@ -108180,2 +111081,2 @@\n-    char *z;\n-    int i;\n+    sqlite3_str sStat;   \/* Text of the constructed \"stat\" line *\/\n+    int i;               \/* Loop counter *\/\n@@ -108183,7 +111084,2 @@\n-    char *zRet = sqlite3MallocZero( (p->nKeyCol+1)*25 );\n-    if( zRet==0 ){\n-      sqlite3_result_error_nomem(context);\n-      return;\n-    }\n-\n-    sqlite3_snprintf(24, zRet, \"%llu\",\n+    sqlite3StrAccumInit(&sStat, 0, 0, 0, (p->nKeyCol+1)*100);\n+    sqlite3_str_appendf(&sStat, \"%llu\",\n@@ -108191,1 +111087,0 @@\n-    z = zRet + sqlite3Strlen30(zRet);\n@@ -108195,2 +111090,1 @@\n-      sqlite3_snprintf(24, z, \" %llu\", iVal);\n-      z += sqlite3Strlen30(z);\n+      sqlite3_str_appendf(&sStat, \" %llu\", iVal);\n@@ -108199,3 +111093,1 @@\n-    assert( z[0]=='\\0' && z>zRet );\n-\n-    sqlite3_result_text(context, zRet, -1, sqlite3_free);\n+    sqlite3ResultStrAccum(context, &sStat);\n@@ -108220,0 +111112,2 @@\n+    sqlite3_str sStat;\n+    int i;\n@@ -108231,16 +111125,3 @@\n-\n-    {\n-      char *zRet = sqlite3MallocZero(p->nCol * 25);\n-      if( zRet==0 ){\n-        sqlite3_result_error_nomem(context);\n-      }else{\n-        int i;\n-        char *z = zRet;\n-        for(i=0; i<p->nCol; i++){\n-          sqlite3_snprintf(24, z, \"%llu \", (u64)aCnt[i]);\n-          z += sqlite3Strlen30(z);\n-        }\n-        assert( z[0]=='\\0' && z>zRet );\n-        z[-1] = '\\0';\n-        sqlite3_result_text(context, zRet, -1, sqlite3_free);\n-      }\n+    sqlite3StrAccumInit(&sStat, 0, 0, 0, p->nCol*100);\n+    for(i=0; i<p->nCol; i++){\n+      sqlite3_str_appendf(&sStat, \"%llu \", (u64)aCnt[i]);\n@@ -108248,0 +111129,2 @@\n+    if( sStat.nChar ) sStat.nChar--;\n+    sqlite3ResultStrAccum(context, &sStat);\n@@ -108279,0 +111162,24 @@\n+#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n+\/* Add a comment to the most recent VDBE opcode that is the name\n+** of the k-th column of the pIdx index.\n+*\/\n+static void analyzeVdbeCommentIndexWithColumnName(\n+  Vdbe *v,         \/* Prepared statement under construction *\/\n+  Index *pIdx,     \/* Index whose column is being loaded *\/\n+  int k            \/* Which column index *\/\n+){\n+  int i;           \/* Index of column in the table *\/\n+  assert( k>=0 && k<pIdx->nColumn );\n+  i = pIdx->aiColumn[k];\n+  if( NEVER(i==XN_ROWID) ){\n+    VdbeComment((v,\"%s.rowid\",pIdx->zName));\n+  }else if( i==XN_EXPR ){\n+    VdbeComment((v,\"%s.expr(%d)\",pIdx->zName, k));\n+  }else{\n+    VdbeComment((v,\"%s.%s\", pIdx->zName, pIdx->pTable->aCol[i].zCnName));\n+  }\n+}\n+#else\n+# define analyzeVdbeCommentIndexWithColumnName(a,b,c)\n+#endif \/* SQLITE_DEBUG *\/\n+\n@@ -108319,1 +111226,1 @@\n-  if( pTab->tnum==0 ){\n+  if( !IsOrdinaryTable(pTab) ){\n@@ -108495,1 +111402,1 @@\n-        VdbeComment((v, \"%s.column(%d)\", pIdx->zName, i));\n+        analyzeVdbeCommentIndexWithColumnName(v,pIdx,i);\n@@ -108516,1 +111423,1 @@\n-        VdbeComment((v, \"%s.column(%d)\", pIdx->zName, i));\n+        analyzeVdbeCommentIndexWithColumnName(v,pIdx,i);\n@@ -108542,1 +111449,1 @@\n-          VdbeComment((v, \"%s.column(%d)\", pIdx->zName, i));\n+          analyzeVdbeCommentIndexWithColumnName(v,pIdx,k);\n@@ -109076,0 +111983,1 @@\n+    pIdx->pTable->tabFlags |= TF_HasStat4;\n@@ -109143,0 +112051,1 @@\n+  const Table *pStat4;\n@@ -109145,1 +112054,3 @@\n-  if( sqlite3FindTable(db, \"sqlite_stat4\", zDb) ){\n+  if( (pStat4 = sqlite3FindTable(db, \"sqlite_stat4\", zDb))!=0\n+   && IsOrdinaryTable(pStat4)\n+  ){\n@@ -109182,0 +112093,1 @@\n+  const Table *pStat1;\n@@ -109204,1 +112116,3 @@\n-  if( sqlite3FindTable(db, \"sqlite_stat1\", sInfo.zDatabase)!=0 ){\n+  if( (pStat1 = sqlite3FindTable(db, \"sqlite_stat1\", sInfo.zDatabase))\n+   && IsOrdinaryTable(pStat1)\n+  ){\n@@ -109344,1 +112258,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -109542,1 +112456,3 @@\n-  if( sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt) ){\n+  if( sqlite3BtreeTxnState(pDb->pBt)!=SQLITE_TXN_NONE\n+   || sqlite3BtreeIsInBackup(pDb->pBt)\n+  ){\n@@ -109593,3 +112509,3 @@\n-      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||\n-      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) ||\n-      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))\n+      SQLITE_OK!=resolveAttachExpr(&sName, pFilename) ||\n+      SQLITE_OK!=resolveAttachExpr(&sName, pDbname) ||\n+      SQLITE_OK!=resolveAttachExpr(&sName, pKey)\n@@ -109604,0 +112520,1 @@\n+      assert( !ExprHasProperty(pAuthArg, EP_IntValue) );\n@@ -109680,0 +112597,59 @@\n+\/*\n+** Expression callback used by sqlite3FixAAAA() routines.\n+*\/\n+static int fixExprCb(Walker *p, Expr *pExpr){\n+  DbFixer *pFix = p->u.pFix;\n+  if( !pFix->bTemp ) ExprSetProperty(pExpr, EP_FromDDL);\n+  if( pExpr->op==TK_VARIABLE ){\n+    if( pFix->pParse->db->init.busy ){\n+      pExpr->op = TK_NULL;\n+    }else{\n+      sqlite3ErrorMsg(pFix->pParse, \"%s cannot use variables\", pFix->zType);\n+      return WRC_Abort;\n+    }\n+  }\n+  return WRC_Continue;\n+}\n+\n+\/*\n+** Select callback used by sqlite3FixAAAA() routines.\n+*\/\n+static int fixSelectCb(Walker *p, Select *pSelect){\n+  DbFixer *pFix = p->u.pFix;\n+  int i;\n+  SrcItem *pItem;\n+  sqlite3 *db = pFix->pParse->db;\n+  int iDb = sqlite3FindDbName(db, pFix->zDb);\n+  SrcList *pList = pSelect->pSrc;\n+\n+  if( NEVER(pList==0) ) return WRC_Continue;\n+  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n+    if( pFix->bTemp==0 ){\n+      if( pItem->zDatabase ){\n+        if( iDb!=sqlite3FindDbName(db, pItem->zDatabase) ){\n+          sqlite3ErrorMsg(pFix->pParse,\n+              \"%s %T cannot reference objects in database %s\",\n+              pFix->zType, pFix->pName, pItem->zDatabase);\n+          return WRC_Abort;\n+        }\n+        sqlite3DbFree(db, pItem->zDatabase);\n+        pItem->zDatabase = 0;\n+        pItem->fg.notCte = 1;\n+      }\n+      pItem->pSchema = pFix->pSchema;\n+      pItem->fg.fromDDL = 1;\n+    }\n+#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)\n+    if( sqlite3WalkExpr(&pFix->w, pList->a[i].pOn) ) return WRC_Abort;\n+#endif\n+  }\n+  if( pSelect->pWith ){\n+    for(i=0; i<pSelect->pWith->nCte; i++){\n+      if( sqlite3WalkSelect(p, pSelect->pWith->a[i].pSelect) ){\n+        return WRC_Abort;\n+      }\n+    }\n+  }\n+  return WRC_Continue;\n+}\n+\n@@ -109691,3 +112667,1 @@\n-  sqlite3 *db;\n-\n-  db = pParse->db;\n+  sqlite3 *db = pParse->db;\n@@ -109701,0 +112675,7 @@\n+  pFix->w.pParse = pParse;\n+  pFix->w.xExprCallback = fixExprCb;\n+  pFix->w.xSelectCallback = fixSelectCb;\n+  pFix->w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback;\n+  pFix->w.walkerDepth = 0;\n+  pFix->w.eCode = 0;\n+  pFix->w.u.pFix = pFix;\n@@ -109721,27 +112702,6 @@\n-  int i;\n-  struct SrcList_item *pItem;\n-  sqlite3 *db = pFix->pParse->db;\n-  int iDb = sqlite3FindDbName(db, pFix->zDb);\n-\n-  if( NEVER(pList==0) ) return 0;\n-\n-  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n-    if( pFix->bTemp==0 ){\n-      if( pItem->zDatabase && iDb!=sqlite3FindDbName(db, pItem->zDatabase) ){\n-        sqlite3ErrorMsg(pFix->pParse,\n-            \"%s %T cannot reference objects in database %s\",\n-            pFix->zType, pFix->pName, pItem->zDatabase);\n-        return 1;\n-      }\n-      sqlite3DbFree(db, pItem->zDatabase);\n-      pItem->zDatabase = 0;\n-      pItem->pSchema = pFix->pSchema;\n-      pItem->fg.fromDDL = 1;\n-    }\n-#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)\n-    if( sqlite3FixSelect(pFix, pItem->pSelect) ) return 1;\n-    if( sqlite3FixExpr(pFix, pItem->pOn) ) return 1;\n-#endif\n-    if( pItem->fg.isTabFunc && sqlite3FixExprList(pFix, pItem->u1.pFuncArg) ){\n-      return 1;\n-    }\n+  int res = 0;\n+  if( pList ){\n+    Select s;\n+    memset(&s, 0, sizeof(s));\n+    s.pSrc = pList;\n+    res = sqlite3WalkSelect(&pFix->w, &s);\n@@ -109749,1 +112709,1 @@\n-  return 0;\n+  return res;\n@@ -109756,33 +112716,1 @@\n-  while( pSelect ){\n-    if( sqlite3FixExprList(pFix, pSelect->pEList) ){\n-      return 1;\n-    }\n-    if( sqlite3FixSrcList(pFix, pSelect->pSrc) ){\n-      return 1;\n-    }\n-    if( sqlite3FixExpr(pFix, pSelect->pWhere) ){\n-      return 1;\n-    }\n-    if( sqlite3FixExprList(pFix, pSelect->pGroupBy) ){\n-      return 1;\n-    }\n-    if( sqlite3FixExpr(pFix, pSelect->pHaving) ){\n-      return 1;\n-    }\n-    if( sqlite3FixExprList(pFix, pSelect->pOrderBy) ){\n-      return 1;\n-    }\n-    if( sqlite3FixExpr(pFix, pSelect->pLimit) ){\n-      return 1;\n-    }\n-    if( pSelect->pWith ){\n-      int i;\n-      for(i=0; i<pSelect->pWith->nCte; i++){\n-        if( sqlite3FixSelect(pFix, pSelect->pWith->a[i].pSelect) ){\n-          return 1;\n-        }\n-      }\n-    }\n-    pSelect = pSelect->pPrior;\n-  }\n-  return 0;\n+  return sqlite3WalkSelect(&pFix->w, pSelect);\n@@ -109794,36 +112722,1 @@\n-  while( pExpr ){\n-    if( !pFix->bTemp ) ExprSetProperty(pExpr, EP_FromDDL);\n-    if( pExpr->op==TK_VARIABLE ){\n-      if( pFix->pParse->db->init.busy ){\n-        pExpr->op = TK_NULL;\n-      }else{\n-        sqlite3ErrorMsg(pFix->pParse, \"%s cannot use variables\", pFix->zType);\n-        return 1;\n-      }\n-    }\n-    if( ExprHasProperty(pExpr, EP_TokenOnly|EP_Leaf) ) break;\n-    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n-      if( sqlite3FixSelect(pFix, pExpr->x.pSelect) ) return 1;\n-    }else{\n-      if( sqlite3FixExprList(pFix, pExpr->x.pList) ) return 1;\n-    }\n-    if( sqlite3FixExpr(pFix, pExpr->pRight) ){\n-      return 1;\n-    }\n-    pExpr = pExpr->pLeft;\n-  }\n-  return 0;\n-}\n-SQLITE_PRIVATE int sqlite3FixExprList(\n-  DbFixer *pFix,     \/* Context of the fixation *\/\n-  ExprList *pList    \/* The expression to be fixed to one database *\/\n-){\n-  int i;\n-  struct ExprList_item *pItem;\n-  if( pList==0 ) return 0;\n-  for(i=0, pItem=pList->a; i<pList->nExpr; i++, pItem++){\n-    if( sqlite3FixExpr(pFix, pItem->pExpr) ){\n-      return 1;\n-    }\n-  }\n-  return 0;\n+  return sqlite3WalkExpr(&pFix->w, pExpr);\n@@ -109839,7 +112732,5 @@\n-    if( sqlite3FixSelect(pFix, pStep->pSelect) ){\n-      return 1;\n-    }\n-    if( sqlite3FixExpr(pFix, pStep->pWhere) ){\n-      return 1;\n-    }\n-    if( sqlite3FixExprList(pFix, pStep->pExprList) ){\n+    if( sqlite3WalkSelect(&pFix->w, pStep->pSelect)\n+     || sqlite3WalkExpr(&pFix->w, pStep->pWhere)\n+     || sqlite3WalkExprList(&pFix->w, pStep->pExprList)\n+     || sqlite3FixSrcList(pFix, pStep->pFrom)\n+    ){\n@@ -109849,8 +112740,10 @@\n-    if( pStep->pUpsert ){\n-      Upsert *pUp = pStep->pUpsert;\n-      if( sqlite3FixExprList(pFix, pUp->pUpsertTarget)\n-       || sqlite3FixExpr(pFix, pUp->pUpsertTargetWhere)\n-       || sqlite3FixExprList(pFix, pUp->pUpsertSet)\n-       || sqlite3FixExpr(pFix, pUp->pUpsertWhere)\n-      ){\n-        return 1;\n+    {\n+      Upsert *pUp;\n+      for(pUp=pStep->pUpsert; pUp; pUp=pUp->pNextUpsert){\n+        if( sqlite3WalkExprList(&pFix->w, pUp->pUpsertTarget)\n+         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertTargetWhere)\n+         || sqlite3WalkExprList(&pFix->w, pUp->pUpsertSet)\n+         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertWhere)\n+        ){\n+          return 1;\n+        }\n@@ -109862,0 +112755,1 @@\n+\n@@ -110013,1 +112907,0 @@\n-  sqlite3 *db = pParse->db;\n@@ -110021,2 +112914,2 @@\n-  assert( !IN_RENAME_OBJECT || db->xAuth==0 );\n-  if( db->xAuth==0 ) return;\n+  assert( !IN_RENAME_OBJECT );\n+  assert( pParse->db->xAuth!=0 );\n@@ -110034,1 +112927,1 @@\n-    for(iSrc=0; ALWAYS(iSrc<pTabList->nSrc); iSrc++){\n+    for(iSrc=0; iSrc<pTabList->nSrc; iSrc++){\n@@ -110042,1 +112935,1 @@\n-  if( NEVER(pTab==0) ) return;\n+  if( pTab==0 ) return;\n@@ -110046,1 +112939,1 @@\n-    zCol = pTab->aCol[iCol].zName;\n+    zCol = pTab->aCol[iCol].zCnName;\n@@ -110049,1 +112942,1 @@\n-    zCol = pTab->aCol[pTab->iPKey].zName;\n+    zCol = pTab->aCol[pTab->iPKey].zCnName;\n@@ -110053,1 +112946,1 @@\n-  assert( iDb>=0 && iDb<db->nDb );\n+  assert( iDb>=0 && iDb<pParse->db->nDb );\n@@ -110079,5 +112972,1 @@\n-  if( db->init.busy || IN_SPECIAL_PARSE ){\n-    return SQLITE_OK;\n-  }\n-\n-  if( db->xAuth==0 ){\n+  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){\n@@ -110177,1 +113066,1 @@\n-  int iTab;              \/* The root page of the table to be locked *\/\n+  Pgno iTab;             \/* The root page of the table to be locked *\/\n@@ -110192,1 +113081,1 @@\n-SQLITE_PRIVATE void sqlite3TableLock(\n+static SQLITE_NOINLINE void lockTable(\n@@ -110195,1 +113084,1 @@\n-  int iTab,          \/* Root page number of the table to be locked *\/\n+  Pgno iTab,         \/* Root page number of the table to be locked *\/\n@@ -110199,1 +113088,1 @@\n-  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n+  Parse *pToplevel;\n@@ -110205,2 +113094,1 @@\n-  if( iDb==1 ) return;\n-  if( !sqlite3BtreeSharable(pParse->db->aDb[iDb].pBt) ) return;\n+  pToplevel = sqlite3ParseToplevel(pParse);\n@@ -110229,0 +113117,11 @@\n+SQLITE_PRIVATE void sqlite3TableLock(\n+  Parse *pParse,     \/* Parsing context *\/\n+  int iDb,           \/* Index of the database containing the table to lock *\/\n+  Pgno iTab,         \/* Root page number of the table to be locked *\/\n+  u8 isWriteLock,    \/* True for a write lock *\/\n+  const char *zName  \/* Name of the table to be locked *\/\n+){\n+  if( iDb==1 ) return;\n+  if( !sqlite3BtreeSharable(pParse->db->aDb[iDb].pBt) ) return;\n+  lockTable(pParse, iDb, iTab, isWriteLock, zName);\n+}\n@@ -110236,4 +113135,2 @@\n-  Vdbe *pVdbe;\n-\n-  pVdbe = sqlite3GetVdbe(pParse);\n-  assert( pVdbe!=0 ); \/* sqlite3GetVdbe cannot fail: VDBE already allocated *\/\n+  Vdbe *pVdbe = pParse->pVdbe;\n+  assert( pVdbe!=0 );\n@@ -110290,1 +113187,9 @@\n-  v = sqlite3GetVdbe(pParse);\n+  v = pParse->pVdbe;\n+  if( v==0 ){\n+    if( db->init.busy ){\n+      pParse->rc = SQLITE_DONE;\n+      return;\n+    }\n+    v = sqlite3GetVdbe(pParse);\n+    if( v==0 ) pParse->rc = SQLITE_ERROR;\n+  }\n@@ -110294,0 +113199,22 @@\n+    if( pParse->bReturning ){\n+      Returning *pReturning = pParse->u1.pReturning;\n+      int addrRewind;\n+      int i;\n+      int reg;\n+\n+      if( pReturning->nRetCol==0 ){\n+        assert( CORRUPT_DB );\n+      }else{\n+        addrRewind =\n+           sqlite3VdbeAddOp1(v, OP_Rewind, pReturning->iRetCur);\n+        VdbeCoverage(v);\n+        reg = pReturning->iRetReg;\n+        for(i=0; i<pReturning->nRetCol; i++){\n+          sqlite3VdbeAddOp3(v, OP_Column, pReturning->iRetCur, i, reg+i);\n+        }\n+        sqlite3VdbeAddOp2(v, OP_ResultRow, reg, i);\n+        sqlite3VdbeAddOp2(v, OP_Next, pReturning->iRetCur, addrRewind+1);\n+        VdbeCoverage(v);\n+        sqlite3VdbeJumpHere(v, addrRewind);\n+      }\n+    }\n@@ -110371,0 +113298,9 @@\n+      if( pParse->bReturning ){\n+        Returning *pRet = pParse->u1.pReturning;\n+        if( pRet->nRetCol==0 ){\n+          assert( CORRUPT_DB );\n+        }else{\n+          sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pRet->iRetCur, pRet->nRetCol);\n+        }\n+      }\n+\n@@ -110376,1 +113312,0 @@\n-\n@@ -110393,4 +113328,5 @@\n-** currently under construction.  When the parser is run recursively\n-** this way, the final OP_Halt is not appended and other initialization\n-** and finalization steps are omitted because those are handling by the\n-** outermost parser.\n+** currently under construction.  Notes:\n+**\n+**   *  The final OP_Halt is not appended and other initialization\n+**      and finalization steps are omitted because those are handling by the\n+**      outermost parser.\n@@ -110398,3 +113334,3 @@\n-** Not everything is nestable.  This facility is designed to permit\n-** INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use\n-** care if you decide to try to use this routine for some other purposes.\n+**   *  Built-in SQL functions always take precedence over application-defined\n+**      SQL functions.  In other words, it is not possible to override a\n+**      built-in function.\n@@ -110407,0 +113343,1 @@\n+  u32 savedDbFlags = db->mDbFlags;\n@@ -110425,0 +113362,1 @@\n+  db->mDbFlags |= DBFLAG_PreferBuiltin;\n@@ -110426,0 +113364,1 @@\n+  db->mDbFlags = savedDbFlags;\n@@ -110481,3 +113420,15 @@\n-    if( p==0 && i==1 && sqlite3StrICmp(zName, MASTER_NAME)==0 ){\n-      \/* All temp.sqlite_master to be an alias for sqlite_temp_master *\/\n-      p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash, TEMP_MASTER_NAME);\n+    if( p==0 && sqlite3StrNICmp(zName, \"sqlite_\", 7)==0 ){\n+      if( i==1 ){\n+        if( sqlite3StrICmp(zName+7, &PREFERRED_TEMP_SCHEMA_TABLE[7])==0\n+         || sqlite3StrICmp(zName+7, &PREFERRED_SCHEMA_TABLE[7])==0\n+         || sqlite3StrICmp(zName+7, &LEGACY_SCHEMA_TABLE[7])==0\n+        ){\n+          p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash,\n+                              LEGACY_TEMP_SCHEMA_TABLE);\n+        }\n+      }else{\n+        if( sqlite3StrICmp(zName+7, &PREFERRED_SCHEMA_TABLE[7])==0 ){\n+          p = sqlite3HashFind(&db->aDb[i].pSchema->tblHash,\n+                              LEGACY_SCHEMA_TABLE);\n+        }\n+      }\n@@ -110498,0 +113449,8 @@\n+    if( p==0 && sqlite3StrNICmp(zName, \"sqlite_\", 7)==0 ){\n+      if( sqlite3StrICmp(zName+7, &PREFERRED_SCHEMA_TABLE[7])==0 ){\n+        p = sqlite3HashFind(&db->aDb[0].pSchema->tblHash, LEGACY_SCHEMA_TABLE);\n+      }else if( sqlite3StrICmp(zName+7, &PREFERRED_TEMP_SCHEMA_TABLE[7])==0 ){\n+        p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash,\n+                            LEGACY_TEMP_SCHEMA_TABLE);\n+      }\n+    }\n@@ -110535,1 +113494,1 @@\n-    if( pParse->disableVtab==0 ){\n+    if( pParse->disableVtab==0 && db->init.busy==0 ){\n@@ -110541,0 +113500,1 @@\n+        testcase( pMod->pEpoTab==0 );\n@@ -110558,0 +113518,2 @@\n+  }else{\n+    assert( HasRowid(p) || p->iPKey<0 );\n@@ -110575,1 +113537,1 @@\n-  struct SrcList_item *p\n+  SrcItem *p\n@@ -110588,0 +113550,16 @@\n+\/*\n+** Return the preferred table name for system tables.  Translate legacy\n+** names into the new preferred names, as appropriate.\n+*\/\n+SQLITE_PRIVATE const char *sqlite3PreferredTableName(const char *zName){\n+  if( sqlite3StrNICmp(zName, \"sqlite_\", 7)==0 ){\n+    if( sqlite3StrICmp(zName+7, &LEGACY_SCHEMA_TABLE[7])==0 ){\n+      return PREFERRED_SCHEMA_TABLE;\n+    }\n+    if( sqlite3StrICmp(zName+7, &LEGACY_TEMP_SCHEMA_TABLE[7])==0 ){\n+      return PREFERRED_TEMP_SCHEMA_TABLE;\n+    }\n+  }\n+  return zName;\n+}\n+\n@@ -110752,0 +113730,78 @@\n+\/*\n+** Set the expression associated with a column.  This is usually\n+** the DEFAULT value, but might also be the expression that computes\n+** the value for a generated column.\n+*\/\n+SQLITE_PRIVATE void sqlite3ColumnSetExpr(\n+  Parse *pParse,    \/* Parsing context *\/\n+  Table *pTab,      \/* The table containing the column *\/\n+  Column *pCol,     \/* The column to receive the new DEFAULT expression *\/\n+  Expr *pExpr       \/* The new default expression *\/\n+){\n+  ExprList *pList;\n+  assert( IsOrdinaryTable(pTab) );\n+  pList = pTab->u.tab.pDfltList;\n+  if( pCol->iDflt==0\n+   || NEVER(pList==0)\n+   || NEVER(pList->nExpr<pCol->iDflt)\n+  ){\n+    pCol->iDflt = pList==0 ? 1 : pList->nExpr+1;\n+    pTab->u.tab.pDfltList = sqlite3ExprListAppend(pParse, pList, pExpr);\n+  }else{\n+    sqlite3ExprDelete(pParse->db, pList->a[pCol->iDflt-1].pExpr);\n+    pList->a[pCol->iDflt-1].pExpr = pExpr;\n+  }\n+}\n+\n+\/*\n+** Return the expression associated with a column.  The expression might be\n+** the DEFAULT clause or the AS clause of a generated column.\n+** Return NULL if the column has no associated expression.\n+*\/\n+SQLITE_PRIVATE Expr *sqlite3ColumnExpr(Table *pTab, Column *pCol){\n+  if( pCol->iDflt==0 ) return 0;\n+  if( NEVER(!IsOrdinaryTable(pTab)) ) return 0;\n+  if( NEVER(pTab->u.tab.pDfltList==0) ) return 0;\n+  if( NEVER(pTab->u.tab.pDfltList->nExpr<pCol->iDflt) ) return 0;\n+  return pTab->u.tab.pDfltList->a[pCol->iDflt-1].pExpr;\n+}\n+\n+\/*\n+** Set the collating sequence name for a column.\n+*\/\n+SQLITE_PRIVATE void sqlite3ColumnSetColl(\n+  sqlite3 *db,\n+  Column *pCol,\n+  const char *zColl\n+){\n+  i64 nColl;\n+  i64 n;\n+  char *zNew;\n+  assert( zColl!=0 );\n+  n = sqlite3Strlen30(pCol->zCnName) + 1;\n+  if( pCol->colFlags & COLFLAG_HASTYPE ){\n+    n += sqlite3Strlen30(pCol->zCnName+n) + 1;\n+  }\n+  nColl = sqlite3Strlen30(zColl) + 1;\n+  zNew = sqlite3DbRealloc(db, pCol->zCnName, nColl+n);\n+  if( zNew ){\n+    pCol->zCnName = zNew;\n+    memcpy(pCol->zCnName + n, zColl, nColl);\n+    pCol->colFlags |= COLFLAG_HASCOLL;\n+  }\n+}\n+\n+\/*\n+** Return the collating squence name for a column\n+*\/\n+SQLITE_PRIVATE const char *sqlite3ColumnColl(Column *pCol){\n+  const char *z;\n+  if( (pCol->colFlags & COLFLAG_HASCOLL)==0 ) return 0;\n+  z = pCol->zCnName;\n+  while( *z ){ z++; }\n+  if( pCol->colFlags & COLFLAG_HASTYPE ){\n+    do{ z++; }while( *z );\n+  }\n+  return z+1;\n+}\n+\n@@ -110762,4 +113818,2 @@\n-      assert( pCol->zName==0 || pCol->hName==sqlite3StrIHash(pCol->zName) );\n-      sqlite3DbFree(db, pCol->zName);\n-      sqlite3ExprDelete(db, pCol->pDflt);\n-      sqlite3DbFree(db, pCol->zColl);\n+      assert( pCol->zCnName==0 || pCol->hName==sqlite3StrIHash(pCol->zCnName) );\n+      sqlite3DbFree(db, pCol->zCnName);\n@@ -110768,0 +113822,10 @@\n+    if( IsOrdinaryTable(pTable) ){\n+      sqlite3ExprListDelete(db, pTable->u.tab.pDfltList);\n+    }\n+    if( db==0 || db->pnBytesFreed==0 ){\n+      pTable->aCol = 0;\n+      pTable->nCol = 0;\n+      if( IsOrdinaryTable(pTable) ){\n+        pTable->u.tab.pDfltList = 0;\n+      }\n+    }\n@@ -110819,2 +113883,12 @@\n-  \/* Delete any foreign keys attached to this table. *\/\n-  sqlite3FkDelete(db, pTable);\n+  if( IsOrdinaryTable(pTable) ){\n+    sqlite3FkDelete(db, pTable);\n+  }\n+#ifndef SQLITE_OMIT_VIRTUAL_TABLE\n+  else if( IsVirtual(pTable) ){\n+    sqlite3VtabClear(db, pTable);\n+  }\n+#endif\n+  else{\n+    assert( IsView(pTable) );\n+    sqlite3SelectDelete(db, pTable->u.view.pSelect);\n+  }\n@@ -110827,1 +113901,0 @@\n-  sqlite3SelectDelete(db, pTable->pSelect);\n@@ -110829,3 +113902,0 @@\n-#ifndef SQLITE_OMIT_VIRTUALTABLE\n-  sqlite3VtabClear(db, pTable);\n-#endif\n@@ -110877,1 +113947,1 @@\n-SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, Token *pName){\n+SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, const Token *pName){\n@@ -110880,1 +113950,1 @@\n-    zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);\n+    zName = sqlite3DbStrNDup(db, (const char*)pName->z, pName->n);\n@@ -110889,1 +113959,1 @@\n-** Open the sqlite_master table stored in database number iDb for\n+** Open the sqlite_schema table stored in database number iDb for\n@@ -110892,1 +113962,1 @@\n-SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *p, int iDb){\n+SQLITE_PRIVATE void sqlite3OpenSchemaTable(Parse *p, int iDb){\n@@ -110894,2 +113964,2 @@\n-  sqlite3TableLock(p, iDb, MASTER_ROOT, 1, MASTER_NAME);\n-  sqlite3VdbeAddOp4Int(v, OP_OpenWrite, 0, MASTER_ROOT, iDb, 5);\n+  sqlite3TableLock(p, iDb, SCHEMA_ROOT, 1, LEGACY_SCHEMA_TABLE);\n+  sqlite3VdbeAddOp4Int(v, OP_OpenWrite, 0, SCHEMA_ROOT, iDb, 5);\n@@ -110974,1 +114044,1 @@\n-    assert( db->init.iDb==0 || db->init.busy || IN_RENAME_OBJECT\n+    assert( db->init.iDb==0 || db->init.busy || IN_SPECIAL_PARSE\n@@ -111003,1 +114073,1 @@\n-** When parsing the sqlite_master table, this routine also checks to\n+** When parsing the sqlite_schema table, this routine also checks to\n@@ -111014,1 +114084,4 @@\n-  if( sqlite3WritableSchema(db) || db->init.imposterTable ){\n+  if( sqlite3WritableSchema(db)\n+   || db->init.imposterTable\n+   || !sqlite3Config.bExtraSchemaChecks\n+  ){\n@@ -111023,4 +114096,2 @@\n-      if( sqlite3Config.bExtraSchemaChecks ){\n-        sqlite3ErrorMsg(pParse, \"\"); \/* corruptSchema() will supply the error *\/\n-        return SQLITE_ERROR;\n-      }\n+      sqlite3ErrorMsg(pParse, \"\"); \/* corruptSchema() will supply the error *\/\n+      return SQLITE_ERROR;\n@@ -111142,0 +114213,17 @@\n+\/*\n+** Insert a single OP_JournalMode query opcode in order to force the\n+** prepared statement to return false for sqlite3_stmt_readonly().  This\n+** is used by CREATE TABLE IF NOT EXISTS and similar if the table already\n+** exists, so that the prepared statement for CREATE TABLE IF NOT EXISTS\n+** will return false for sqlite3_stmt_readonly() even if that statement\n+** is a read-only no-op.\n+*\/\n+static void sqlite3ForceNotReadOnly(Parse *pParse){\n+  int iReg = ++pParse->nMem;\n+  Vdbe *v = sqlite3GetVdbe(pParse);\n+  if( v ){\n+    sqlite3VdbeAddOp3(v, OP_JournalMode, 0, iReg, PAGER_JOURNALMODE_QUERY);\n+    sqlite3VdbeUsesBtree(v, 0);\n+  }\n+}\n+\n@@ -111175,1 +114263,1 @@\n-    \/* Special case:  Parsing the sqlite_master or sqlite_temp_master schema *\/\n+    \/* Special case:  Parsing the sqlite_schema or sqlite_temp_schema schema *\/\n@@ -111241,0 +114329,1 @@\n+        sqlite3ForceNotReadOnly(pParse);\n@@ -111269,11 +114358,0 @@\n-  \/* If this is the magic sqlite_sequence table used by autoincrement,\n-  ** then record a pointer to this table in the main database structure\n-  ** so that INSERT can find the table easily.\n-  *\/\n-#ifndef SQLITE_OMIT_AUTOINCREMENT\n-  if( !pParse->nested && strcmp(zName, \"sqlite_sequence\")==0 ){\n-    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n-    pTable->pSchema->pSeqTab = pTable;\n-  }\n-#endif\n-\n@@ -111281,1 +114359,1 @@\n-  ** the SQLITE_MASTER table.  Note in particular that we must go ahead\n+  ** the schema table.  Note in particular that we must go ahead\n@@ -111317,1 +114395,1 @@\n-    \/* This just creates a place-holder record in the sqlite_master table.\n+    \/* This just creates a place-holder record in the sqlite_schema table.\n@@ -111332,1 +114410,2 @@\n-      pParse->addrCrTab =\n+      assert( !pParse->bReturning );\n+      pParse->u1.addrCrTab =\n@@ -111335,1 +114414,1 @@\n-    sqlite3OpenMasterTable(pParse, iDb);\n+    sqlite3OpenSchemaTable(pParse, iDb);\n@@ -111348,0 +114427,1 @@\n+  pParse->checkSchema = 1;\n@@ -111357,1 +114437,1 @@\n-  if( sqlite3_strnicmp(pCol->zName, \"__hidden__\", 10)==0 ){\n+  if( sqlite3_strnicmp(pCol->zCnName, \"__hidden__\", 10)==0 ){\n@@ -111359,0 +114439,1 @@\n+    if( pTab ) pTab->tabFlags |= TF_HasHidden;\n@@ -111365,0 +114446,73 @@\n+\/*\n+** Name of the special TEMP trigger used to implement RETURNING.  The\n+** name begins with \"sqlite_\" so that it is guaranteed not to collide\n+** with any application-generated triggers.\n+*\/\n+#define RETURNING_TRIGGER_NAME  \"sqlite_returning\"\n+\n+\/*\n+** Clean up the data structures associated with the RETURNING clause.\n+*\/\n+static void sqlite3DeleteReturning(sqlite3 *db, Returning *pRet){\n+  Hash *pHash;\n+  pHash = &(db->aDb[1].pSchema->trigHash);\n+  sqlite3HashInsert(pHash, RETURNING_TRIGGER_NAME, 0);\n+  sqlite3ExprListDelete(db, pRet->pReturnEL);\n+  sqlite3DbFree(db, pRet);\n+}\n+\n+\/*\n+** Add the RETURNING clause to the parse currently underway.\n+**\n+** This routine creates a special TEMP trigger that will fire for each row\n+** of the DML statement.  That TEMP trigger contains a single SELECT\n+** statement with a result set that is the argument of the RETURNING clause.\n+** The trigger has the Trigger.bReturning flag and an opcode of\n+** TK_RETURNING instead of TK_SELECT, so that the trigger code generator\n+** knows to handle it specially.  The TEMP trigger is automatically\n+** removed at the end of the parse.\n+**\n+** When this routine is called, we do not yet know if the RETURNING clause\n+** is attached to a DELETE, INSERT, or UPDATE, so construct it as a\n+** RETURNING trigger instead.  It will then be converted into the appropriate\n+** type on the first call to sqlite3TriggersExist().\n+*\/\n+SQLITE_PRIVATE void sqlite3AddReturning(Parse *pParse, ExprList *pList){\n+  Returning *pRet;\n+  Hash *pHash;\n+  sqlite3 *db = pParse->db;\n+  if( pParse->pNewTrigger ){\n+    sqlite3ErrorMsg(pParse, \"cannot use RETURNING in a trigger\");\n+  }else{\n+    assert( pParse->bReturning==0 );\n+  }\n+  pParse->bReturning = 1;\n+  pRet = sqlite3DbMallocZero(db, sizeof(*pRet));\n+  if( pRet==0 ){\n+    sqlite3ExprListDelete(db, pList);\n+    return;\n+  }\n+  pParse->u1.pReturning = pRet;\n+  pRet->pParse = pParse;\n+  pRet->pReturnEL = pList;\n+  sqlite3ParserAddCleanup(pParse,\n+     (void(*)(sqlite3*,void*))sqlite3DeleteReturning, pRet);\n+  testcase( pParse->earlyCleanup );\n+  if( db->mallocFailed ) return;\n+  pRet->retTrig.zName = RETURNING_TRIGGER_NAME;\n+  pRet->retTrig.op = TK_RETURNING;\n+  pRet->retTrig.tr_tm = TRIGGER_AFTER;\n+  pRet->retTrig.bReturning = 1;\n+  pRet->retTrig.pSchema = db->aDb[1].pSchema;\n+  pRet->retTrig.pTabSchema = db->aDb[1].pSchema;\n+  pRet->retTrig.step_list = &pRet->retTStep;\n+  pRet->retTStep.op = TK_RETURNING;\n+  pRet->retTStep.pTrig = &pRet->retTrig;\n+  pRet->retTStep.pExprList = pList;\n+  pHash = &(db->aDb[1].pSchema->trigHash);\n+  assert( sqlite3HashFind(pHash, RETURNING_TRIGGER_NAME)==0 || pParse->nErr );\n+  if( sqlite3HashInsert(pHash, RETURNING_TRIGGER_NAME, &pRet->retTrig)\n+          ==&pRet->retTrig ){\n+    sqlite3OomFault(db);\n+  }\n+}\n@@ -111374,1 +114528,1 @@\n-SQLITE_PRIVATE void sqlite3AddColumn(Parse *pParse, Token *pName, Token *pType){\n+SQLITE_PRIVATE void sqlite3AddColumn(Parse *pParse, Token sName, Token sType){\n@@ -111381,0 +114535,6 @@\n+  u8 hName;\n+  Column *aNew;\n+  u8 eType = COLTYPE_CUSTOM;\n+  u8 szEst = 1;\n+  char affinity = SQLITE_AFF_BLOB;\n+\n@@ -111386,1 +114546,38 @@\n-  z = sqlite3DbMallocRaw(db, pName->n + pType->n + 2);\n+  if( !IN_RENAME_OBJECT ) sqlite3DequoteToken(&sName);\n+\n+  \/* Because keywords GENERATE ALWAYS can be converted into indentifiers\n+  ** by the parser, we can sometimes end up with a typename that ends\n+  ** with \"generated always\".  Check for this case and omit the surplus\n+  ** text. *\/\n+  if( sType.n>=16\n+   && sqlite3_strnicmp(sType.z+(sType.n-6),\"always\",6)==0\n+  ){\n+    sType.n -= 6;\n+    while( ALWAYS(sType.n>0) && sqlite3Isspace(sType.z[sType.n-1]) ) sType.n--;\n+    if( sType.n>=9\n+     && sqlite3_strnicmp(sType.z+(sType.n-9),\"generated\",9)==0\n+    ){\n+      sType.n -= 9;\n+      while( sType.n>0 && sqlite3Isspace(sType.z[sType.n-1]) ) sType.n--;\n+    }\n+  }\n+\n+  \/* Check for standard typenames.  For standard typenames we will\n+  ** set the Column.eType field rather than storing the typename after\n+  ** the column name, in order to save space. *\/\n+  if( sType.n>=3 ){\n+    sqlite3DequoteToken(&sType);\n+    for(i=0; i<SQLITE_N_STDTYPE; i++){\n+       if( sType.n==sqlite3StdTypeLen[i]\n+        && sqlite3_strnicmp(sType.z, sqlite3StdType[i], sType.n)==0\n+       ){\n+         sType.n = 0;\n+         eType = i+1;\n+         affinity = sqlite3StdTypeAffinity[i];\n+         if( affinity<=SQLITE_AFF_TEXT ) szEst = 5;\n+         break;\n+       }\n+    }\n+  }\n+\n+  z = sqlite3DbMallocRaw(db, (i64)sName.n + 1 + (i64)sType.n + (sType.n>0) );\n@@ -111388,3 +114585,3 @@\n-  if( IN_RENAME_OBJECT ) sqlite3RenameTokenMap(pParse, (void*)z, pName);\n-  memcpy(z, pName->z, pName->n);\n-  z[pName->n] = 0;\n+  if( IN_RENAME_OBJECT ) sqlite3RenameTokenMap(pParse, (void*)z, &sName);\n+  memcpy(z, sName.z, sName.n);\n+  z[sName.n] = 0;\n@@ -111392,0 +114589,1 @@\n+  hName = sqlite3StrIHash(z);\n@@ -111393,1 +114591,1 @@\n-    if( sqlite3_stricmp(z, p->aCol[i].zName)==0 ){\n+    if( p->aCol[i].hName==hName && sqlite3StrICmp(z, p->aCol[i].zCnName)==0 ){\n@@ -111399,8 +114597,4 @@\n-  if( (p->nCol & 0x7)==0 ){\n-    Column *aNew;\n-    aNew = sqlite3DbRealloc(db,p->aCol,(p->nCol+8)*sizeof(p->aCol[0]));\n-    if( aNew==0 ){\n-      sqlite3DbFree(db, z);\n-      return;\n-    }\n-    p->aCol = aNew;\n+  aNew = sqlite3DbRealloc(db,p->aCol,((i64)p->nCol+1)*sizeof(p->aCol[0]));\n+  if( aNew==0 ){\n+    sqlite3DbFree(db, z);\n+    return;\n@@ -111408,0 +114602,1 @@\n+  p->aCol = aNew;\n@@ -111410,2 +114605,2 @@\n-  pCol->zName = z;\n-  pCol->hName = sqlite3StrIHash(z);\n+  pCol->zCnName = z;\n+  pCol->hName = hName;\n@@ -111414,1 +114609,1 @@\n-  if( pType->n==0 ){\n+  if( sType.n==0 ){\n@@ -111417,2 +114612,3 @@\n-    pCol->affinity = SQLITE_AFF_BLOB;\n-    pCol->szEst = 1;\n+    pCol->affinity = affinity;\n+    pCol->eCType = eType;\n+    pCol->szEst = szEst;\n@@ -111420,2 +114616,4 @@\n-    if( 4>=sqlite3GlobalConfig.szSorterRef ){\n-      pCol->colFlags |= COLFLAG_SORTERREF;\n+    if( affinity==SQLITE_AFF_BLOB ){\n+      if( 4>=sqlite3GlobalConfig.szSorterRef ){\n+        pCol->colFlags |= COLFLAG_SORTERREF;\n+      }\n@@ -111426,2 +114624,2 @@\n-    memcpy(zType, pType->z, pType->n);\n-    zType[pType->n] = 0;\n+    memcpy(zType, sType.z, sType.n);\n+    zType[sType.n] = 0;\n@@ -111582,1 +114780,1 @@\n-          pCol->zName);\n+          pCol->zCnName);\n@@ -111593,2 +114791,1 @@\n-      Expr x;\n-      sqlite3ExprDelete(db, pCol->pDflt);\n+      Expr x, *pDfltExpr;\n@@ -111600,1 +114797,1 @@\n-      pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n+      pDfltExpr = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n@@ -111602,0 +114799,1 @@\n+      sqlite3ColumnSetExpr(pParse, p, pCol, pDfltExpr);\n@@ -111697,1 +114895,3 @@\n-        const char *zCName = pCExpr->u.zToken;\n+        const char *zCName;\n+        assert( !ExprHasProperty(pCExpr, EP_IntValue) );\n+        zCName = pCExpr->u.zToken;\n@@ -111699,1 +114899,1 @@\n-          if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zName)==0 ){\n+          if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zCnName)==0 ){\n@@ -111710,1 +114910,1 @@\n-   && sqlite3StrICmp(sqlite3ColumnType(pCol,\"\"), \"INTEGER\")==0\n+   && pCol->eCType==COLTYPE_INTEGER\n@@ -111743,2 +114943,4 @@\n-  Parse *pParse,    \/* Parsing context *\/\n-  Expr *pCheckExpr  \/* The check expression *\/\n+  Parse *pParse,      \/* Parsing context *\/\n+  Expr *pCheckExpr,   \/* The check expression *\/\n+  const char *zStart, \/* Opening \"(\" *\/\n+  const char *zEnd    \/* Closing \")\" *\/\n@@ -111755,0 +114957,7 @@\n+    }else{\n+      Token t;\n+      for(zStart++; sqlite3Isspace(zStart[0]); zStart++){}\n+      while( sqlite3Isspace(zEnd[-1]) ){ zEnd--; }\n+      t.z = zStart;\n+      t.n = (int)(zEnd - t.z);\n+      sqlite3ExprListSetName(pParse, pTab->pCheck, &t, 1);\n@@ -111773,1 +114982,1 @@\n-  if( (p = pParse->pNewTable)==0 ) return;\n+  if( (p = pParse->pNewTable)==0 || IN_RENAME_OBJECT ) return;\n@@ -111781,2 +114990,1 @@\n-    sqlite3DbFree(db, p->aCol[i].zColl);\n-    p->aCol[i].zColl = zColl;\n+    sqlite3ColumnSetColl(db, &p->aCol[i], zColl);\n@@ -111791,1 +114999,1 @@\n-        pIdx->azColl[0] = p->aCol[i].zColl;\n+        pIdx->azColl[0] = sqlite3ColumnColl(&p->aCol[i]);\n@@ -111794,2 +115002,0 @@\n-  }else{\n-    sqlite3DbFree(db, zColl);\n@@ -111797,0 +115003,1 @@\n+  sqlite3DbFree(db, zColl);\n@@ -111816,1 +115023,1 @@\n-  if( pCol->pDflt ) goto generated_error;\n+  if( pCol->iDflt>0 ) goto generated_error;\n@@ -111834,1 +115041,1 @@\n-  pCol->pDflt = pExpr;\n+  sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);\n@@ -111840,1 +115047,1 @@\n-                  pCol->zName);\n+                  pCol->zCnName);\n@@ -111942,1 +115149,1 @@\n-    n += identLength(pCol->zName) + 5;\n+    n += identLength(pCol->zCnName) + 5;\n@@ -111978,1 +115185,1 @@\n-    identPut(zStmt, &k, pCol->zName);\n+    identPut(zStmt, &k, pCol->zCnName);\n@@ -112008,1 +115215,1 @@\n-  nByte = (sizeof(char*) + sizeof(i16) + 1)*N;\n+  nByte = (sizeof(char*) + sizeof(LogEst) + sizeof(i16) + 1)*N;\n@@ -112014,0 +115221,3 @@\n+  memcpy(zExtra, pIdx->aiRowLogEst, sizeof(LogEst)*(pIdx->nKeyCol+1));\n+  pIdx->aiRowLogEst = (LogEst*)zExtra;\n+  zExtra += sizeof(LogEst)*N;\n@@ -112059,1 +115269,0 @@\n-    assert( aiCol[0]>=0 );\n@@ -112145,1 +115354,1 @@\n-**     (3)  Bypass the creation of the sqlite_master table entry\n+**     (3)  Bypass the creation of the sqlite_schema table entry\n@@ -112147,1 +115356,1 @@\n-**          identified by the sqlite_master table entry of the table itself.\n+**          identified by the sqlite_schema table entry of the table itself.\n@@ -112172,1 +115381,3 @@\n-      if( (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY)!=0 ){\n+      if( (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY)!=0\n+       && (pTab->aCol[i].notNull==OE_None)\n+      ){\n@@ -112182,1 +115393,2 @@\n-  if( pParse->addrCrTab ){\n+  assert( !pParse->bReturning );\n+  if( pParse->u1.addrCrTab ){\n@@ -112184,1 +115396,1 @@\n-    sqlite3VdbeChangeP3(v, pParse->addrCrTab, BTREE_BLOBKEY);\n+    sqlite3VdbeChangeP3(v, pParse->u1.addrCrTab, BTREE_BLOBKEY);\n@@ -112193,1 +115405,1 @@\n-    sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zName);\n+    sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zCnName);\n@@ -112196,1 +115408,4 @@\n-    if( pList==0 ) return;\n+    if( pList==0 ){\n+      pTab->tabFlags &= ~TF_WithoutRowid;\n+      return;\n+    }\n@@ -112205,1 +115420,4 @@\n-    if( db->mallocFailed || pParse->nErr ) return;\n+    if( db->mallocFailed || pParse->nErr ){\n+      pTab->tabFlags &= ~TF_WithoutRowid;\n+      return;\n+    }\n@@ -112234,1 +115452,1 @@\n-  \/* Bypass the creation of the PRIMARY KEY btree and the sqlite_master\n+  \/* Bypass the creation of the PRIMARY KEY btree and the sqlite_schema\n@@ -112240,1 +115458,1 @@\n-    sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);\n+    sqlite3VdbeChangeOpcode(v, (int)pPk->tnum, OP_Goto);\n@@ -112317,1 +115535,1 @@\n-  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->azModuleArg[0]);\n+  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->u.vtab.azArg[0]);\n@@ -112325,0 +115543,35 @@\n+#ifndef SQLITE_OMIT_VIRTUALTABLE\n+\/*\n+** Table pTab is a virtual table.  If it the virtual table implementation\n+** exists and has an xShadowName method, then loop over all other ordinary\n+** tables within the same schema looking for shadow tables of pTab, and mark\n+** any shadow tables seen using the TF_Shadow flag.\n+*\/\n+SQLITE_PRIVATE void sqlite3MarkAllShadowTablesOf(sqlite3 *db, Table *pTab){\n+  int nName;                    \/* Length of pTab->zName *\/\n+  Module *pMod;                 \/* Module for the virtual table *\/\n+  HashElem *k;                  \/* For looping through the symbol table *\/\n+\n+  assert( IsVirtual(pTab) );\n+  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->u.vtab.azArg[0]);\n+  if( pMod==0 ) return;\n+  if( NEVER(pMod->pModule==0) ) return;\n+  if( pMod->pModule->iVersion<3 ) return;\n+  if( pMod->pModule->xShadowName==0 ) return;\n+  assert( pTab->zName!=0 );\n+  nName = sqlite3Strlen30(pTab->zName);\n+  for(k=sqliteHashFirst(&pTab->pSchema->tblHash); k; k=sqliteHashNext(k)){\n+    Table *pOther = sqliteHashData(k);\n+    assert( pOther->zName!=0 );\n+    if( !IsOrdinaryTable(pOther) ) continue;\n+    if( pOther->tabFlags & TF_Shadow ) continue;\n+    if( sqlite3StrNICmp(pOther->zName, pTab->zName, nName)==0\n+     && pOther->zName[nName]=='_'\n+     && pMod->pModule->xShadowName(pOther->zName+nName+1)\n+    ){\n+      pOther->tabFlags |= TF_Shadow;\n+    }\n+  }\n+}\n+#endif \/* ifndef SQLITE_OMIT_VIRTUALTABLE *\/\n+\n@@ -112382,1 +115635,1 @@\n-** An entry for the table is made in the master table on disk, unless\n+** An entry for the table is made in the schema table on disk, unless\n@@ -112384,2 +115637,2 @@\n-** it means we are reading the sqlite_master table because we just\n-** connected to the database or because the sqlite_master table has\n+** it means we are reading the sqlite_schema table because we just\n+** connected to the database or because the sqlite_schema table has\n@@ -112387,1 +115640,1 @@\n-** the sqlite_master table.  We do not want to create it again.\n+** the sqlite_schema table.  We do not want to create it again.\n@@ -112398,1 +115651,1 @@\n-  u8 tabOpts,             \/* Extra table options. Usually 0. *\/\n+  u32 tabOpts,            \/* Extra table options. Usually 0. *\/\n@@ -112409,1 +115662,0 @@\n-  assert( !db->mallocFailed );\n@@ -112418,1 +115670,1 @@\n-  ** \"sqlite_master\" or \"sqlite_temp_master\" table on the disk.\n+  ** \"sqlite_schema\" or \"sqlite_temp_schema\" table on the disk.\n@@ -112423,1 +115675,1 @@\n-  ** If the root page number is 1, that means this is the sqlite_master\n+  ** If the root page number is 1, that means this is the sqlite_schema\n@@ -112427,1 +115679,1 @@\n-    if( pSelect ){\n+    if( pSelect || (!IsOrdinaryTable(p) && db->init.newTnum) ){\n@@ -112435,0 +115687,38 @@\n+  \/* Special processing for tables that include the STRICT keyword:\n+  **\n+  **   *  Do not allow custom column datatypes.  Every column must have\n+  **      a datatype that is one of INT, INTEGER, REAL, TEXT, or BLOB.\n+  **\n+  **   *  If a PRIMARY KEY is defined, other than the INTEGER PRIMARY KEY,\n+  **      then all columns of the PRIMARY KEY must have a NOT NULL\n+  **      constraint.\n+  *\/\n+  if( tabOpts & TF_Strict ){\n+    int ii;\n+    p->tabFlags |= TF_Strict;\n+    for(ii=0; ii<p->nCol; ii++){\n+      Column *pCol = &p->aCol[ii];\n+      if( pCol->eCType==COLTYPE_CUSTOM ){\n+        if( pCol->colFlags & COLFLAG_HASTYPE ){\n+          sqlite3ErrorMsg(pParse,\n+            \"unknown datatype for %s.%s: \\\"%s\\\"\",\n+            p->zName, pCol->zCnName, sqlite3ColumnType(pCol, \"\")\n+          );\n+        }else{\n+          sqlite3ErrorMsg(pParse, \"missing datatype for %s.%s\",\n+                          p->zName, pCol->zCnName);\n+        }\n+        return;\n+      }else if( pCol->eCType==COLTYPE_ANY ){\n+        pCol->affinity = SQLITE_AFF_BLOB;\n+      }\n+      if( (pCol->colFlags & COLFLAG_PRIMKEY)!=0\n+       && p->iPKey!=ii\n+       && pCol->notNull == OE_None\n+      ){\n+        pCol->notNull = OE_Abort;\n+        p->tabFlags |= TF_HasNotNull;\n+      }\n+    }\n+  }\n+\n@@ -112479,1 +115769,1 @@\n-        Expr *pX = p->aCol[ii].pDflt;\n+        Expr *pX = sqlite3ColumnExpr(p, &p->aCol[ii]);\n@@ -112489,2 +115779,2 @@\n-          sqlite3ExprDelete(db, pX);\n-          p->aCol[ii].pDflt = sqlite3ExprAlloc(db, TK_NULL, 0, 0);\n+          sqlite3ColumnSetExpr(pParse, p, &p->aCol[ii],\n+               sqlite3ExprAlloc(db, TK_NULL, 0, 0));\n@@ -112510,1 +115800,1 @@\n-  ** in the SQLITE_MASTER table of the database.\n+  ** in the schema table of the database.\n@@ -112530,1 +115820,1 @@\n-    if( p->pSelect==0 ){\n+    if( IsOrdinaryTable(p) ){\n@@ -112612,1 +115902,1 @@\n-    ** SQLITE_MASTER table.  We just need to update that slot with all\n+    ** schema table.  We just need to update that slot with all\n@@ -112616,4 +115906,4 @@\n-      \"UPDATE %Q.%s \"\n-         \"SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q \"\n-       \"WHERE rowid=#%d\",\n-      db->aDb[iDb].zDbSName, MASTER_NAME,\n+      \"UPDATE %Q.\" LEGACY_SCHEMA_TABLE\n+      \" SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q\"\n+      \" WHERE rowid=#%d\",\n+      db->aDb[iDb].zDbSName,\n@@ -112634,1 +115924,1 @@\n-    if( (p->tabFlags & TF_Autoincrement)!=0 ){\n+    if( (p->tabFlags & TF_Autoincrement)!=0 && !IN_SPECIAL_PARSE ){\n@@ -112648,1 +115938,1 @@\n-           sqlite3MPrintf(db, \"tbl_name='%q' AND type!='trigger'\", p->zName));\n+           sqlite3MPrintf(db, \"tbl_name='%q' AND type!='trigger'\", p->zName),0);\n@@ -112657,0 +115947,1 @@\n+    assert( HasRowid(p) || p->iPKey<0 );\n@@ -112666,10 +115957,8 @@\n-#ifndef SQLITE_OMIT_ALTERTABLE\n-    if( !p->pSelect ){\n-      const char *zName = (const char *)pParse->sNameToken.z;\n-      int nName;\n-      assert( !pSelect && pCons && pEnd );\n-      if( pCons->z==0 ){\n-        pCons = pEnd;\n-      }\n-      nName = (int)((const char *)pCons->z - zName);\n-      p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);\n+    \/* If this is the magic sqlite_sequence table used by autoincrement,\n+    ** then record a pointer to this table in the main database structure\n+    ** so that INSERT can find the table easily.  *\/\n+    assert( !pParse->nested );\n+#ifndef SQLITE_OMIT_AUTOINCREMENT\n+    if( strcmp(p->zName, \"sqlite_sequence\")==0 ){\n+      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n+      p->pSchema->pSeqTab = p;\n@@ -112679,0 +115968,10 @@\n+\n+#ifndef SQLITE_OMIT_ALTERTABLE\n+  if( !pSelect && IsOrdinaryTable(p) ){\n+    assert( pCons && pEnd );\n+    if( pCons->z==0 ){\n+      pCons = pEnd;\n+    }\n+    p->u.tab.addColOffset = 13 + (int)(pCons->z - pParse->sNameToken.z);\n+  }\n+#endif\n@@ -112711,0 +116010,10 @@\n+\n+  \/* Legacy versions of SQLite allowed the use of the magic \"rowid\" column\n+  ** on a view, even though views do not have rowids.  The following flag\n+  ** setting fixes this problem.  But the fix can be disabled by compiling\n+  ** with -DSQLITE_ALLOW_ROWID_IN_VIEW in case there are legacy apps that\n+  ** depend upon the old buggy behavior. *\/\n+#ifndef SQLITE_ALLOW_ROWID_IN_VIEW\n+  p->tabFlags |= TF_NoVisibleRowid;\n+#endif\n+\n@@ -112723,1 +116032,1 @@\n-    p->pSelect = pSelect;\n+    p->u.view.pSelect = pSelect;\n@@ -112726,1 +116035,1 @@\n-    p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n+    p->u.view.pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n@@ -112729,0 +116038,1 @@\n+  p->eTabType = TABTYP_VIEW;\n@@ -112747,1 +116057,1 @@\n-  \/* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table *\/\n+  \/* Use sqlite3EndTable() to add the view to the schema table *\/\n@@ -112782,5 +116092,5 @@\n-  db->nSchemaLock++;\n-  rc = sqlite3VtabCallConnect(pParse, pTable);\n-  db->nSchemaLock--;\n-  if( rc ){\n-    return 1;\n+  if( IsVirtual(pTable) ){\n+    db->nSchemaLock++;\n+    rc = sqlite3VtabCallConnect(pParse, pTable);\n+    db->nSchemaLock--;\n+    return rc;\n@@ -112788,1 +116098,0 @@\n-  if( IsVirtual(pTable) ) return 0;\n@@ -112825,2 +116134,2 @@\n-  assert( pTable->pSelect );\n-  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);\n+  assert( IsView(pTable) );\n+  pSel = sqlite3SelectDup(db, pTable->u.view.pSelect, 0);\n@@ -112828,1 +116137,0 @@\n-#ifndef SQLITE_OMIT_ALTERTABLE\n@@ -112831,1 +116139,0 @@\n-#endif\n@@ -112871,0 +116178,1 @@\n+      pTable->tabFlags |= (pSelTab->tabFlags & COLFLAG_NOINSERT);\n@@ -112879,1 +116187,0 @@\n-#ifndef SQLITE_OMIT_ALTERTABLE\n@@ -112881,1 +116188,0 @@\n-#endif\n@@ -112888,2 +116194,0 @@\n-    pTable->aCol = 0;\n-    pTable->nCol = 0;\n@@ -112906,1 +116210,1 @@\n-    if( pTab->pSelect ){\n+    if( IsView(pTab) ){\n@@ -112908,2 +116212,0 @@\n-      pTab->aCol = 0;\n-      pTab->nCol = 0;\n@@ -112936,1 +116238,1 @@\n-SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo){\n+SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3 *db, int iDb, Pgno iFrom, Pgno iTo){\n@@ -112962,1 +116264,1 @@\n-** Also write code to modify the sqlite_master table and internal schema\n+** Also write code to modify the sqlite_schema table and internal schema\n@@ -112975,1 +116277,1 @@\n-  ** location iTable. The following code modifies the sqlite_master table to\n+  ** location iTable. The following code modifies the sqlite_schema table to\n@@ -112983,2 +116285,3 @@\n-     \"UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d\",\n-     pParse->db->aDb[iDb].zDbSName, MASTER_NAME, iTable, r1, r1);\n+     \"UPDATE %Q.\" LEGACY_SCHEMA_TABLE\n+     \" SET rootpage=%d WHERE #%d AND rootpage=#%d\",\n+     pParse->db->aDb[iDb].zDbSName, iTable, r1, r1);\n@@ -112991,1 +116294,1 @@\n-** Code to update the sqlite_master tables and internal schema definitions\n+** Code to update the sqlite_schema tables and internal schema definitions\n@@ -113012,2 +116315,2 @@\n-  int iTab = pTab->tnum;\n-  int iDestroyed = 0;\n+  Pgno iTab = pTab->tnum;\n+  Pgno iDestroyed = 0;\n@@ -113017,1 +116320,1 @@\n-    int iLargest = 0;\n+    Pgno iLargest = 0;\n@@ -113023,1 +116326,1 @@\n-      int iIdx = pIdx->tnum;\n+      Pgno iIdx = pIdx->tnum;\n@@ -113084,2 +116387,2 @@\n-  ** is generated to remove entries from sqlite_master and\/or\n-  ** sqlite_temp_master if required.\n+  ** is generated to remove entries from sqlite_schema and\/or\n+  ** sqlite_temp_schema if required.\n@@ -113109,2 +116412,2 @@\n-  \/* Drop all SQLITE_MASTER table and index entries that refer to the\n-  ** table. The program name loops through the master table and deletes\n+  \/* Drop all entries in the schema table that refer to the\n+  ** table. The program name loops through the schema table and deletes\n@@ -113117,2 +116420,3 @@\n-      \"DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'\",\n-      pDb->zDbSName, MASTER_NAME, pTab->zName);\n+      \"DELETE FROM %Q.\" LEGACY_SCHEMA_TABLE\n+      \" WHERE tbl_name=%Q and type!='trigger'\",\n+      pDb->zDbSName, pTab->zName);\n@@ -113144,0 +116448,1 @@\n+   && !sqlite3VtabInSync(db)\n@@ -113163,0 +116468,3 @@\n+  if( pTab->tabFlags & TF_Eponymous ){\n+    return 1;\n+  }\n@@ -113188,1 +116496,4 @@\n-    if( noErr ) sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n+    if( noErr ){\n+      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n+      sqlite3ForceNotReadOnly(pParse);\n+    }\n@@ -113244,1 +116555,1 @@\n-  if( isView && pTab->pSelect==0 ){\n+  if( isView && !IsView(pTab) ){\n@@ -113248,1 +116559,1 @@\n-  if( !isView && pTab->pSelect ){\n+  if( !isView && IsView(pTab) ){\n@@ -113254,1 +116565,1 @@\n-  \/* Generate code to remove the table from the master table\n+  \/* Generate code to remove the table from the schema table\n@@ -113299,1 +116610,1 @@\n-  int nByte;\n+  i64 nByte;\n@@ -113312,1 +116623,1 @@\n-         p->aCol[iCol].zName, pTo);\n+         p->aCol[iCol].zCnName, pTo);\n@@ -113335,1 +116646,2 @@\n-  pFKey->pNextFrom = p->pFKey;\n+  assert( IsOrdinaryTable(p) );\n+  pFKey->pNextFrom = p->u.tab.pFKey;\n@@ -113352,1 +116664,1 @@\n-        if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zEName)==0 ){\n+        if( sqlite3StrICmp(p->aCol[j].zCnName, pFromCol->a[i].zEName)==0 ){\n@@ -113400,1 +116712,2 @@\n-  p->pFKey = pFKey;\n+  assert( IsOrdinaryTable(p) );\n+  p->u.tab.pFKey = pFKey;\n@@ -113421,1 +116734,3 @@\n-  if( (pTab = pParse->pNewTable)==0 || (pFKey = pTab->pFKey)==0 ) return;\n+  if( (pTab = pParse->pNewTable)==0 ) return;\n+  if( NEVER(!IsOrdinaryTable(pTab)) ) return;\n+  if( (pFKey = pTab->u.tab.pFKey)==0 ) return;\n@@ -113445,1 +116760,1 @@\n-  int tnum;                      \/* Root page of index *\/\n+  Pgno tnum;                     \/* Root page of index *\/\n@@ -113466,1 +116781,1 @@\n-    tnum = memRootPage;\n+    tnum = (Pgno)memRootPage;\n@@ -113491,1 +116806,1 @@\n-  sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb,\n+  sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, (int)tnum, iDb,\n@@ -113708,4 +117023,1 @@\n-#ifdef SQLITE_ALLOW_SQLITE_MASTER_INDEX\n-       && sqlite3StrICmp(&pTab->zName[7],\"master\")!=0\n-#endif\n- ){\n+  ){\n@@ -113716,1 +117028,1 @@\n-  if( pTab->pSelect ){\n+  if( IsView(pTab) ){\n@@ -113733,1 +117045,1 @@\n-  ** sqlite_master table (because some other process changed the schema) and\n+  ** sqlite_schema table (because some other process changed the schema) and\n@@ -113761,0 +117073,1 @@\n+          sqlite3ForceNotReadOnly(pParse);\n@@ -113806,1 +117119,1 @@\n-    sqlite3TokenInit(&prevCol, pCol->zName);\n+    sqlite3TokenInit(&prevCol, pCol->zCnName);\n@@ -113824,0 +117137,1 @@\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -113919,0 +117233,1 @@\n+      assert( !ExprHasProperty(pListItem->pExpr, EP_IntValue) );\n@@ -113927,1 +117242,1 @@\n-      zColl = pTab->aCol[j].zColl;\n+      zColl = sqlite3ColumnColl(&pTab->aCol[j]);\n@@ -114077,2 +117392,2 @@\n-    ** the index in the sqlite_master table and populate the index with\n-    ** content.  But, do not do this if we are simply reading the sqlite_master\n+    ** the index in the sqlite_schema table and populate the index with\n+    ** content.  But, do not do this if we are simply reading the sqlite_schema\n@@ -114103,1 +117418,1 @@\n-      pIndex->tnum = sqlite3VdbeAddOp0(v, OP_Noop);\n+      pIndex->tnum = (Pgno)sqlite3VdbeAddOp0(v, OP_Noop);\n@@ -114122,1 +117437,1 @@\n-      \/* Add an entry in sqlite_master for this index\n+      \/* Add an entry in sqlite_schema for this index\n@@ -114125,2 +117440,2 @@\n-          \"INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);\",\n-          db->aDb[iDb].zDbSName, MASTER_NAME,\n+          \"INSERT INTO %Q.\" LEGACY_SCHEMA_TABLE \" VALUES('index',%Q,%Q,#%d,%Q);\",\n+          db->aDb[iDb].zDbSName,\n@@ -114141,1 +117456,1 @@\n-            sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName));\n+            sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName), 0);\n@@ -114145,1 +117460,1 @@\n-      sqlite3VdbeJumpHere(v, pIndex->tnum);\n+      sqlite3VdbeJumpHere(v, (int)pIndex->tnum);\n@@ -114162,2 +117477,6 @@\n-  if( pTab ){  \/* Ensure all REPLACE indexes are at the end of the list *\/\n-    Index **ppFrom = &pTab->pIndex;\n+  if( pTab ){\n+    \/* Ensure all REPLACE indexes on pTab are at the end of the pIndex list.\n+    ** The list was already ordered when this routine was entered, so at this\n+    ** point at most a single index (the newly added index) will be out of\n+    ** order.  So we have to reorder at most one index. *\/\n+    Index **ppFrom;\n@@ -114176,0 +117495,10 @@\n+#ifdef SQLITE_DEBUG\n+    \/* Verify that all REPLACE indexes really are now at the end\n+    ** of the index list.  In other words, no other index type ever\n+    ** comes after a REPLACE index on the list. *\/\n+    for(pThis = pTab->pIndex; pThis; pThis=pThis->pNext){\n+      assert( pThis->onError!=OE_Replace\n+           || pThis->pNext==0\n+           || pThis->pNext->onError==OE_Replace );\n+    }\n+#endif\n@@ -114202,2 +117531,2 @@\n-  \/*                10,  9,  8,  7,  6 *\/\n-  LogEst aVal[] = { 33, 32, 30, 28, 26 };\n+               \/*                10,  9,  8,  7,  6 *\/\n+  static const LogEst aVal[] = { 33, 32, 30, 28, 26 };\n@@ -114205,0 +117534,1 @@\n+  LogEst x;\n@@ -114213,4 +117543,15 @@\n-  ** for a partial index.   But do not let the estimate drop below 10. *\/\n-  a[0] = pIdx->pTable->nRowLogEst;\n-  if( pIdx->pPartIdxWhere!=0 ) a[0] -= 10;  assert( 10==sqlite3LogEst(2) );\n-  if( a[0]<33 ) a[0] = 33;                  assert( 33==sqlite3LogEst(10) );\n+  ** for a partial index.\n+  **\n+  ** 2020-05-27:  If some of the stat data is coming from the sqlite_stat1\n+  ** table but other parts we are having to guess at, then do not let the\n+  ** estimated number of rows in the table be less than 1000 (LogEst 99).\n+  ** Failure to do this can cause the indexes for which we do not have\n+  ** stat1 data to be ignored by the query planner.\n+  *\/\n+  x = pIdx->pTable->nRowLogEst;\n+  assert( 99==sqlite3LogEst(1000) );\n+  if( x<99 ){\n+    pIdx->pTable->nRowLogEst = x = 99;\n+  }\n+  if( pIdx->pPartIdxWhere!=0 ){ x -= 10;  assert( 10==sqlite3LogEst(2) ); }\n+  a[0] = x;\n@@ -114250,1 +117591,1 @@\n-      sqlite3ErrorMsg(pParse, \"no such index: %S\", pName, 0);\n+      sqlite3ErrorMsg(pParse, \"no such index: %S\", pName->a);\n@@ -114253,0 +117594,1 @@\n+      sqlite3ForceNotReadOnly(pParse);\n@@ -114272,1 +117614,1 @@\n-    if( !OMIT_TEMPDB && iDb ) code = SQLITE_DROP_TEMP_INDEX;\n+    if( !OMIT_TEMPDB && iDb==1 ) code = SQLITE_DROP_TEMP_INDEX;\n@@ -114279,1 +117621,1 @@\n-  \/* Generate code to remove the index and from the master table *\/\n+  \/* Generate code to remove the index and from the schema table *\/\n@@ -114284,2 +117626,2 @@\n-       \"DELETE FROM %Q.%s WHERE name=%Q AND type='index'\",\n-       db->aDb[iDb].zDbSName, MASTER_NAME, pIndex->zName\n+       \"DELETE FROM %Q.\" LEGACY_SCHEMA_TABLE \" WHERE name=%Q AND type='index'\",\n+       db->aDb[iDb].zDbSName, pIndex->zName\n@@ -114522,1 +117864,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -114563,3 +117905,3 @@\n-  struct SrcList_item *pItem;\n-  assert(pList || pParse->db->mallocFailed );\n-  if( pList ){\n+  SrcItem *pItem;\n+  assert( pList || pParse->db->mallocFailed );\n+  if( ALWAYS(pList) ){\n@@ -114567,1 +117909,1 @@\n-      if( pItem->iCursor>=0 ) break;\n+      if( pItem->iCursor>=0 ) continue;\n@@ -114581,1 +117923,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -114584,1 +117926,1 @@\n-    sqlite3DbFree(db, pItem->zDatabase);\n+    if( pItem->zDatabase ) sqlite3DbFreeNN(db, pItem->zDatabase);\n@@ -114586,1 +117928,1 @@\n-    sqlite3DbFree(db, pItem->zAlias);\n+    if( pItem->zAlias ) sqlite3DbFreeNN(db, pItem->zAlias);\n@@ -114590,3 +117932,3 @@\n-    sqlite3SelectDelete(db, pItem->pSelect);\n-    sqlite3ExprDelete(db, pItem->pOn);\n-    sqlite3IdListDelete(db, pItem->pUsing);\n+    if( pItem->pSelect ) sqlite3SelectDelete(db, pItem->pSelect);\n+    if( pItem->pOn ) sqlite3ExprDelete(db, pItem->pOn);\n+    if( pItem->pUsing ) sqlite3IdListDelete(db, pItem->pUsing);\n@@ -114623,1 +117965,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -114667,1 +118009,1 @@\n-    struct SrcList_item *pItem;\n+    SrcItem *pItem;\n@@ -114680,0 +118022,1 @@\n+      assert( pItem->fg.isCte==0 );  \/* No collision on union u2 *\/\n@@ -114684,0 +118027,20 @@\n+\/*\n+** Append the contents of SrcList p2 to SrcList p1 and return the resulting\n+** SrcList. Or, if an error occurs, return NULL. In all cases, p1 and p2\n+** are deleted by this function.\n+*\/\n+SQLITE_PRIVATE SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2){\n+  assert( p1 && p1->nSrc==1 );\n+  if( p2 ){\n+    SrcList *pNew = sqlite3SrcListEnlarge(pParse, p1, p2->nSrc, 1);\n+    if( pNew==0 ){\n+      sqlite3SrcListDelete(pParse->db, p2);\n+    }else{\n+      p1 = pNew;\n+      memcpy(&p1->a[1], p2->a, p2->nSrc*sizeof(SrcItem));\n+      sqlite3DbFree(pParse->db, p2);\n+    }\n+  }\n+  return p1;\n+}\n+\n@@ -114690,1 +118053,1 @@\n-    struct SrcList_item *pItem = &p->a[p->nSrc-1];\n+    SrcItem *pItem = &p->a[p->nSrc-1];\n@@ -114744,1 +118107,10 @@\n-      sqlite3VdbeAddOp2(v, OP_Transaction, i, (type==TK_EXCLUSIVE)+1);\n+      int eTxnType;\n+      Btree *pBt = db->aDb[i].pBt;\n+      if( pBt && sqlite3BtreeIsReadonly(pBt) ){\n+        eTxnType = 0;  \/* Read txn *\/\n+      }else if( type==TK_EXCLUSIVE ){\n+        eTxnType = 2;  \/* Exclusive txn *\/\n+      }else{\n+        eTxnType = 1;  \/* Write txn *\/\n+      }\n+      sqlite3VdbeAddOp2(v, OP_Transaction, i, eTxnType);\n@@ -114833,7 +118205,5 @@\n-SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse *pParse, int iDb){\n-  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n-\n-  assert( iDb>=0 && iDb<pParse->db->nDb );\n-  assert( pParse->db->aDb[iDb].pBt!=0 || iDb==1 );\n-  assert( iDb<SQLITE_MAX_ATTACHED+2 );\n-  assert( sqlite3SchemaMutexHeld(pParse->db, iDb, 0) );\n+static void sqlite3CodeVerifySchemaAtToplevel(Parse *pToplevel, int iDb){\n+  assert( iDb>=0 && iDb<pToplevel->db->nDb );\n+  assert( pToplevel->db->aDb[iDb].pBt!=0 || iDb==1 );\n+  assert( iDb<SQLITE_MAX_DB );\n+  assert( sqlite3SchemaMutexHeld(pToplevel->db, iDb, 0) );\n@@ -114847,0 +118217,4 @@\n+SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse *pParse, int iDb){\n+  sqlite3CodeVerifySchemaAtToplevel(sqlite3ParseToplevel(pParse), iDb);\n+}\n+\n@@ -114878,1 +118252,1 @@\n-  sqlite3CodeVerifySchema(pParse, iDb);\n+  sqlite3CodeVerifySchemaAtToplevel(pToplevel, iDb);\n@@ -114929,1 +118303,3 @@\n-  Vdbe *v = sqlite3GetVdbe(pParse);\n+  Vdbe *v;\n+  assert( pParse->pVdbe!=0 );\n+  v = sqlite3GetVdbe(pParse);\n@@ -114959,1 +118335,1 @@\n-      zCol = pTab->aCol[pIdx->aiColumn[j]].zName;\n+      zCol = pTab->aCol[pIdx->aiColumn[j]].zCnName;\n@@ -114986,1 +118362,1 @@\n-                          pTab->aCol[pTab->iPKey].zName);\n+                          pTab->aCol[pTab->iPKey].zCnName);\n@@ -115174,0 +118550,48 @@\n+\/*\n+** Create a new CTE object\n+*\/\n+SQLITE_PRIVATE Cte *sqlite3CteNew(\n+  Parse *pParse,          \/* Parsing context *\/\n+  Token *pName,           \/* Name of the common-table *\/\n+  ExprList *pArglist,     \/* Optional column name list for the table *\/\n+  Select *pQuery,         \/* Query used to initialize the table *\/\n+  u8 eM10d                \/* The MATERIALIZED flag *\/\n+){\n+  Cte *pNew;\n+  sqlite3 *db = pParse->db;\n+\n+  pNew = sqlite3DbMallocZero(db, sizeof(*pNew));\n+  assert( pNew!=0 || db->mallocFailed );\n+\n+  if( db->mallocFailed ){\n+    sqlite3ExprListDelete(db, pArglist);\n+    sqlite3SelectDelete(db, pQuery);\n+  }else{\n+    pNew->pSelect = pQuery;\n+    pNew->pCols = pArglist;\n+    pNew->zName = sqlite3NameFromToken(pParse->db, pName);\n+    pNew->eM10d = eM10d;\n+  }\n+  return pNew;\n+}\n+\n+\/*\n+** Clear information from a Cte object, but do not deallocate storage\n+** for the object itself.\n+*\/\n+static void cteClear(sqlite3 *db, Cte *pCte){\n+  assert( pCte!=0 );\n+  sqlite3ExprListDelete(db, pCte->pCols);\n+  sqlite3SelectDelete(db, pCte->pSelect);\n+  sqlite3DbFree(db, pCte->zName);\n+}\n+\n+\/*\n+** Free the contents of the CTE object passed as the second argument.\n+*\/\n+SQLITE_PRIVATE void sqlite3CteDelete(sqlite3 *db, Cte *pCte){\n+  assert( pCte!=0 );\n+  cteClear(db, pCte);\n+  sqlite3DbFree(db, pCte);\n+}\n+\n@@ -115176,1 +118600,3 @@\n-** WITH clause.\n+** WITH clause.  The CTE described by teh third argument is added to\n+** the WITH clause of the second argument.  If the second argument is\n+** NULL, then a new WITH argument is created.\n@@ -115181,3 +118607,1 @@\n-  Token *pName,           \/* Name of the common-table *\/\n-  ExprList *pArglist,     \/* Optional column name list for the table *\/\n-  Select *pQuery          \/* Query used to initialize the table *\/\n+  Cte *pCte               \/* CTE to add to the WITH clause *\/\n@@ -115189,0 +118613,4 @@\n+  if( pCte==0 ){\n+    return pWith;\n+  }\n+\n@@ -115191,1 +118619,1 @@\n-  zName = sqlite3NameFromToken(pParse->db, pName);\n+  zName = pCte->zName;\n@@ -115210,3 +118638,1 @@\n-    sqlite3ExprListDelete(db, pArglist);\n-    sqlite3SelectDelete(db, pQuery);\n-    sqlite3DbFree(db, zName);\n+    sqlite3CteDelete(db, pCte);\n@@ -115215,5 +118641,2 @@\n-    pNew->a[pNew->nCte].pSelect = pQuery;\n-    pNew->a[pNew->nCte].pCols = pArglist;\n-    pNew->a[pNew->nCte].zName = zName;\n-    pNew->a[pNew->nCte].zCteErr = 0;\n-    pNew->nCte++;\n+    pNew->a[pNew->nCte++] = *pCte;\n+    sqlite3DbFree(db, pCte);\n@@ -115232,4 +118655,1 @@\n-      struct Cte *pCte = &pWith->a[i];\n-      sqlite3ExprListDelete(db, pCte->pCols);\n-      sqlite3SelectDelete(db, pCte->pSelect);\n-      sqlite3DbFree(db, pCte->zName);\n+      cteClear(db, &pWith->a[i]);\n@@ -115583,0 +119003,1 @@\n+    assert( p->funcFlags & SQLITE_FUNC_BUILTIN );\n@@ -115604,0 +119025,1 @@\n+    assert( aDef[i].funcFlags & SQLITE_FUNC_BUILTIN );\n@@ -115814,1 +119236,1 @@\n-  struct SrcList_item *pItem = pSrc->a;\n+  SrcItem *pItem = pSrc->a;\n@@ -115816,1 +119238,1 @@\n-  assert( pItem && pSrc->nSrc==1 );\n+  assert( pItem && pSrc->nSrc>=1 );\n@@ -115822,3 +119244,3 @@\n-  }\n-  if( sqlite3IndexedByLookup(pParse, pItem) ){\n-    pTab = 0;\n+    if( pItem->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pItem) ){\n+      pTab = 0;\n+    }\n@@ -115836,1 +119258,1 @@\n-**   2) It is a system table (i.e. sqlite_master), this call is not\n+**   2) It is a system table (i.e. sqlite_schema), this call is not\n@@ -115869,1 +119291,1 @@\n-  if( !viewOk && pTab->pSelect ){\n+  if( !viewOk && IsView(pTab) ){\n@@ -115973,1 +119395,1 @@\n-      const char *zName = pTab->aCol[pPk->aiColumn[0]].zName;\n+      const char *zName = pTab->aCol[pPk->aiColumn[0]].zCnName;\n@@ -115979,1 +119401,1 @@\n-        Expr *p = sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zName);\n+        Expr *p = sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zCnName);\n@@ -115992,1 +119414,1 @@\n-  pSelectSrc = sqlite3SrcListDup(pParse->db, pSrc, 0);\n+  pSelectSrc = sqlite3SrcListDup(db, pSrc, 0);\n@@ -115994,1 +119416,8 @@\n-  pSrc->a[0].pIBIndex = 0;\n+  if( pSrc->a[0].fg.isIndexedBy ){\n+    assert( pSrc->a[0].fg.isCte==0 );\n+    pSrc->a[0].u2.pIBIndex = 0;\n+    pSrc->a[0].fg.isIndexedBy = 0;\n+    sqlite3DbFree(db, pSrc->a[0].u1.zIndexedBy);\n+  }else if( pSrc->a[0].fg.isCte ){\n+    pSrc->a[0].u2.pCteUse->nUse++;\n+  }\n@@ -116080,1 +119509,1 @@\n-  isView = pTab->pSelect!=0;\n+  isView = IsView(pTab);\n@@ -116172,0 +119601,1 @@\n+   && !pParse->bReturning\n@@ -116206,0 +119636,3 @@\n+      if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){\n+        sqlite3VdbeChangeP3(v, -1, memCnt ? memCnt : -1);\n+      }\n@@ -116210,1 +119643,1 @@\n-    u16 wcf = WHERE_ONEPASS_DESIRED|WHERE_DUPLICATES_OK|WHERE_SEEK_TABLE;\n+    u16 wcf = WHERE_ONEPASS_DESIRED|WHERE_DUPLICATES_OK;\n@@ -116246,0 +119679,3 @@\n+    if( sqlite3WhereUsesDeferredSeek(pWInfo) ){\n+      sqlite3VdbeAddOp1(v, OP_FinishSeek, iTabCur);\n+    }\n@@ -116280,0 +119716,1 @@\n+      addrBypass = sqlite3VdbeMakeLabel(pParse);\n@@ -116293,7 +119730,0 @@\n-    }\n-\n-    \/* If this DELETE cannot use the ONEPASS strategy, this is the\n-    ** end of the WHERE loop *\/\n-    if( eOnePass!=ONEPASS_OFF ){\n-      addrBypass = sqlite3VdbeMakeLabel(pParse);\n-    }else{\n@@ -116329,1 +119759,1 @@\n-        assert( pPk!=0 || pTab->pSelect!=0 );\n+        assert( pPk!=0 || IsView(pTab) );\n@@ -116396,1 +119826,1 @@\n-    sqlite3VdbeAddOp2(v, OP_ResultRow, memCnt, 1);\n+    sqlite3VdbeAddOp2(v, OP_ChngCntRow, memCnt, 1);\n@@ -116563,1 +119993,1 @@\n-  if( pTab->pSelect==0 ){\n+  if( !IsView(pTab) ){\n@@ -116720,7 +120150,9 @@\n-    \/* If the column affinity is REAL but the number is an integer, then it\n-    ** might be stored in the table as an integer (using a compact\n-    ** representation) then converted to REAL by an OP_RealAffinity opcode.\n-    ** But we are getting ready to store this value back into an index, where\n-    ** it should be converted by to INTEGER again.  So omit the OP_RealAffinity\n-    ** opcode if it is present *\/\n-    sqlite3VdbeDeletePriorOpcode(v, OP_RealAffinity);\n+    if( pIdx->aiColumn[j]>=0 ){\n+      \/* If the column affinity is REAL but the number is an integer, then it\n+      ** might be stored in the table as an integer (using a compact\n+      ** representation) then converted to REAL by an OP_RealAffinity opcode.\n+      ** But we are getting ready to store this value back into an index, where\n+      ** it should be converted by to INTEGER again.  So omit the\n+      ** OP_RealAffinity opcode if it is present *\/\n+      sqlite3VdbeDeletePriorOpcode(v, OP_RealAffinity);\n+    }\n@@ -116730,4 +120162,0 @@\n-    if( pIdx->pTable->pSelect ){\n-      const char *zAff = sqlite3IndexAffinityStr(pParse->db, pIdx);\n-      sqlite3VdbeChangeP4(v, -1, zAff, P4_TRANSIENT);\n-    }\n@@ -117325,3 +120753,3 @@\n-** IMP: R-62073-11209 The changes() SQL function is a wrapper\n-** around the sqlite3_changes() C\/C++ function and hence follows the same\n-** rules for counting changes.\n+** IMP: R-32760-32347 The changes() SQL function is a wrapper\n+** around the sqlite3_changes64() C\/C++ function and hence follows the\n+** same rules for counting changes.\n@@ -117336,1 +120764,1 @@\n-  sqlite3_result_int(context, sqlite3_changes(db));\n+  sqlite3_result_int64(context, sqlite3_changes64(db));\n@@ -117341,1 +120769,1 @@\n-** the same as the sqlite3_total_changes() API function.\n+** the same as the sqlite3_total_changes64() API function.\n@@ -117350,3 +120778,3 @@\n-  \/* IMP: R-52756-41993 This function is a wrapper around the\n-  ** sqlite3_total_changes() C\/C++ interface. *\/\n-  sqlite3_result_int(context, sqlite3_total_changes(db));\n+  \/* IMP: R-11217-42568 This function is a wrapper around the\n+  ** sqlite3_total_changes64() C\/C++ interface. *\/\n+  sqlite3_result_int64(context, sqlite3_total_changes64(db));\n@@ -117448,1 +120876,2 @@\n-      while( (c=Utf8Read(zPattern)) == matchAll || c == matchOne ){\n+      while( (c=Utf8Read(zPattern)) == matchAll\n+             || (c == matchOne && matchOne!=0) ){\n@@ -118069,1 +121498,1 @@\n-  int nIn;                          \/* Number of bytes in input *\/\n+  unsigned int nIn;                 \/* Number of bytes in input *\/\n@@ -118072,1 +121501,1 @@\n-  unsigned char *aLen = 0;          \/* Length of each character in zCharSet *\/\n+  unsigned int *aLen = 0;           \/* Length of each character in zCharSet *\/\n@@ -118081,1 +121510,1 @@\n-  nIn = sqlite3_value_bytes(argv[0]);\n+  nIn = (unsigned)sqlite3_value_bytes(argv[0]);\n@@ -118084,1 +121513,1 @@\n-    static const unsigned char lenOne[] = { 1 };\n+    static const unsigned lenOne[] = { 1 };\n@@ -118087,1 +121516,1 @@\n-    aLen = (u8*)lenOne;\n+    aLen = (unsigned*)lenOne;\n@@ -118098,1 +121527,2 @@\n-      azChar = contextMalloc(context, ((i64)nChar)*(sizeof(char*)+1));\n+      azChar = contextMalloc(context,\n+                     ((i64)nChar)*(sizeof(char*)+sizeof(unsigned)));\n@@ -118102,1 +121532,1 @@\n-      aLen = (unsigned char*)&azChar[nChar];\n+      aLen = (unsigned*)&azChar[nChar];\n@@ -118106,1 +121536,1 @@\n-        aLen[nChar] = (u8)(z - azChar[nChar]);\n+        aLen[nChar] = (unsigned)(z - azChar[nChar]);\n@@ -118114,1 +121544,1 @@\n-        int len = 0;\n+        unsigned int len = 0;\n@@ -118126,1 +121556,1 @@\n-        int len = 0;\n+        unsigned int len = 0;\n@@ -118467,0 +121897,6 @@\n+**\n+** The SEPARATOR goes before the EXPR string.  This is tragic.  The\n+** groupConcatInverse() implementation would have been easier if the\n+** SEPARATOR were appended after EXPR.  And the order is undocumented,\n+** so we could change it, in theory.  But the old behavior has been\n+** around for so long that we dare not, for fear of breaking something.\n@@ -118468,0 +121904,14 @@\n+typedef struct {\n+  StrAccum str;          \/* The accumulated concatenation *\/\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+  int nAccum;            \/* Number of strings presently concatenated *\/\n+  int nFirstSepLength;   \/* Used to detect separator length change *\/\n+  \/* If pnSepLengths!=0, refs an array of inter-string separator lengths,\n+  ** stored as actually incorporated into presently accumulated result.\n+  ** (Hence, its slots in use number nAccum-1 between method calls.)\n+  ** If pnSepLengths==0, nFirstSepLength is the length used throughout.\n+  *\/\n+  int *pnSepLengths;\n+#endif\n+} GroupConcatCtx;\n+\n@@ -118474,1 +121924,1 @@\n-  StrAccum *pAccum;\n+  GroupConcatCtx *pGCC;\n@@ -118479,3 +121929,2 @@\n-  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));\n-\n-  if( pAccum ){\n+  pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));\n+  if( pGCC ){\n@@ -118483,9 +121932,41 @@\n-    int firstTerm = pAccum->mxAlloc==0;\n-    pAccum->mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];\n-    if( !firstTerm ){\n-      if( argc==2 ){\n-        zSep = (char*)sqlite3_value_text(argv[1]);\n-        nSep = sqlite3_value_bytes(argv[1]);\n-      }else{\n-        zSep = \",\";\n-        nSep = 1;\n+    int firstTerm = pGCC->str.mxAlloc==0;\n+    pGCC->str.mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];\n+    if( argc==1 ){\n+      if( !firstTerm ){\n+        sqlite3_str_appendchar(&pGCC->str, 1, ',');\n+      }\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+      else{\n+        pGCC->nFirstSepLength = 1;\n+      }\n+#endif\n+    }else if( !firstTerm ){\n+      zSep = (char*)sqlite3_value_text(argv[1]);\n+      nSep = sqlite3_value_bytes(argv[1]);\n+      if( zSep ){\n+        sqlite3_str_append(&pGCC->str, zSep, nSep);\n+      }\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+      else{\n+        nSep = 0;\n+      }\n+      if( nSep != pGCC->nFirstSepLength || pGCC->pnSepLengths != 0 ){\n+        int *pnsl = pGCC->pnSepLengths;\n+        if( pnsl == 0 ){\n+          \/* First separator length variation seen, start tracking them. *\/\n+          pnsl = (int*)sqlite3_malloc64((pGCC->nAccum+1) * sizeof(int));\n+          if( pnsl!=0 ){\n+            int i = 0, nA = pGCC->nAccum-1;\n+            while( i<nA ) pnsl[i++] = pGCC->nFirstSepLength;\n+          }\n+        }else{\n+          pnsl = (int*)sqlite3_realloc64(pnsl, pGCC->nAccum * sizeof(int));\n+        }\n+        if( pnsl!=0 ){\n+          if( ALWAYS(pGCC->nAccum>0) ){\n+            pnsl[pGCC->nAccum-1] = nSep;\n+          }\n+          pGCC->pnSepLengths = pnsl;\n+        }else{\n+          sqlite3StrAccumSetError(&pGCC->str, SQLITE_NOMEM);\n+        }\n@@ -118493,1 +121974,5 @@\n-      if( zSep ) sqlite3_str_append(pAccum, zSep, nSep);\n+#endif\n+    }\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+    else{\n+      pGCC->nFirstSepLength = sqlite3_value_bytes(argv[1]);\n@@ -118495,0 +121980,2 @@\n+    pGCC->nAccum += 1;\n+#endif\n@@ -118497,1 +121984,1 @@\n-    if( zVal ) sqlite3_str_append(pAccum, zVal, nVal);\n+    if( zVal ) sqlite3_str_append(&pGCC->str, zVal, nVal);\n@@ -118500,0 +121987,1 @@\n+\n@@ -118506,2 +121994,1 @@\n-  int n;\n-  StrAccum *pAccum;\n+  GroupConcatCtx *pGCC;\n@@ -118509,0 +121996,1 @@\n+  (void)argc;  \/* Suppress unused parameter warning *\/\n@@ -118510,2 +121998,2 @@\n-  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));\n-  \/* pAccum is always non-NULL since groupConcatStep() will have always\n+  pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));\n+  \/* pGCC is always non-NULL since groupConcatStep() will have always\n@@ -118513,4 +122001,14 @@\n-  if( ALWAYS(pAccum) ){\n-    n = sqlite3_value_bytes(argv[0]);\n-    if( argc==2 ){\n-      n += sqlite3_value_bytes(argv[1]);\n+  if( ALWAYS(pGCC) ){\n+    int nVS;\n+    \/* Must call sqlite3_value_text() to convert the argument into text prior\n+    ** to invoking sqlite3_value_bytes(), in case the text encoding is UTF16 *\/\n+    (void)sqlite3_value_text(argv[0]);\n+    nVS = sqlite3_value_bytes(argv[0]);\n+    pGCC->nAccum -= 1;\n+    if( pGCC->pnSepLengths!=0 ){\n+      assert(pGCC->nAccum >= 0);\n+      if( pGCC->nAccum>0 ){\n+        nVS += *pGCC->pnSepLengths;\n+        memmove(pGCC->pnSepLengths, pGCC->pnSepLengths+1,\n+               (pGCC->nAccum-1)*sizeof(int));\n+      }\n@@ -118518,1 +122016,2 @@\n-      n++;\n+      \/* If removing single accumulated string, harmlessly over-do. *\/\n+      nVS += pGCC->nFirstSepLength;\n@@ -118520,2 +122019,2 @@\n-    if( n>=(int)pAccum->nChar ){\n-      pAccum->nChar = 0;\n+    if( nVS>=(int)pGCC->str.nChar ){\n+      pGCC->str.nChar = 0;\n@@ -118523,2 +122022,7 @@\n-      pAccum->nChar -= n;\n-      memmove(pAccum->zText, &pAccum->zText[n], pAccum->nChar);\n+      pGCC->str.nChar -= nVS;\n+      memmove(pGCC->str.zText, &pGCC->str.zText[nVS], pGCC->str.nChar);\n+    }\n+    if( pGCC->str.nChar==0 ){\n+      pGCC->str.mxAlloc = 0;\n+      sqlite3_free(pGCC->pnSepLengths);\n+      pGCC->pnSepLengths = 0;\n@@ -118526,1 +122030,0 @@\n-    if( pAccum->nChar==0 ) pAccum->mxAlloc = 0;\n@@ -118533,11 +122036,7 @@\n-  StrAccum *pAccum;\n-  pAccum = sqlite3_aggregate_context(context, 0);\n-  if( pAccum ){\n-    if( pAccum->accError==SQLITE_TOOBIG ){\n-      sqlite3_result_error_toobig(context);\n-    }else if( pAccum->accError==SQLITE_NOMEM ){\n-      sqlite3_result_error_nomem(context);\n-    }else{\n-      sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), -1,\n-                          sqlite3_free);\n-    }\n+  GroupConcatCtx *pGCC\n+    = (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);\n+  if( pGCC ){\n+    sqlite3ResultStrAccum(context, &pGCC->str);\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+    sqlite3_free(pGCC->pnSepLengths);\n+#endif\n@@ -118548,3 +122047,4 @@\n-  sqlite3_str *pAccum;\n-  pAccum = (sqlite3_str*)sqlite3_aggregate_context(context, 0);\n-  if( pAccum ){\n+  GroupConcatCtx *pGCC\n+    = (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);\n+  if( pGCC ){\n+    StrAccum *pAccum = &pGCC->str;\n@@ -118557,1 +122057,1 @@\n-      sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT);\n+      sqlite3_result_text(context, zText, pAccum->nChar, SQLITE_TRANSIENT);\n@@ -118619,1 +122119,4 @@\n-  if( pExpr->op!=TK_FUNCTION || !pExpr->x.pList ){\n+  assert( pExpr!=0 );\n+  assert( pExpr->op==TK_FUNCTION );\n+  assert( ExprUseXList(pExpr) );\n+  if( !pExpr->x.pList ){\n@@ -118622,1 +122125,0 @@\n-  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n@@ -118624,0 +122126,1 @@\n+  assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -118647,0 +122150,1 @@\n+    assert( !ExprHasProperty(pEscape, EP_IntValue) );\n@@ -118658,0 +122162,195 @@\n+\/* Mathematical Constants *\/\n+#ifndef M_PI\n+# define M_PI   3.141592653589793238462643383279502884\n+#endif\n+#ifndef M_LN10\n+# define M_LN10 2.302585092994045684017991454684364208\n+#endif\n+#ifndef M_LN2\n+# define M_LN2  0.693147180559945309417232121458176568\n+#endif\n+\n+\n+\/* Extra math functions that require linking with -lm\n+*\/\n+#ifdef SQLITE_ENABLE_MATH_FUNCTIONS\n+\/*\n+** Implementation SQL functions:\n+**\n+**   ceil(X)\n+**   ceiling(X)\n+**   floor(X)\n+**\n+** The sqlite3_user_data() pointer is a pointer to the libm implementation\n+** of the underlying C function.\n+*\/\n+static void ceilingFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  assert( argc==1 );\n+  switch( sqlite3_value_numeric_type(argv[0]) ){\n+    case SQLITE_INTEGER: {\n+       sqlite3_result_int64(context, sqlite3_value_int64(argv[0]));\n+       break;\n+    }\n+    case SQLITE_FLOAT: {\n+       double (*x)(double) = (double(*)(double))sqlite3_user_data(context);\n+       sqlite3_result_double(context, x(sqlite3_value_double(argv[0])));\n+       break;\n+    }\n+    default: {\n+       break;\n+    }\n+  }\n+}\n+\n+\/*\n+** On some systems, ceil() and floor() are intrinsic function.  You are\n+** unable to take a pointer to these functions.  Hence, we here wrap them\n+** in our own actual functions.\n+*\/\n+static double xCeil(double x){ return ceil(x); }\n+static double xFloor(double x){ return floor(x); }\n+\n+\/*\n+** Implementation of SQL functions:\n+**\n+**   ln(X)       - natural logarithm\n+**   log(X)      - log X base 10\n+**   log10(X)    - log X base 10\n+**   log(B,X)    - log X base B\n+*\/\n+static void logFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  double x, b, ans;\n+  assert( argc==1 || argc==2 );\n+  switch( sqlite3_value_numeric_type(argv[0]) ){\n+    case SQLITE_INTEGER:\n+    case SQLITE_FLOAT:\n+      x = sqlite3_value_double(argv[0]);\n+      if( x<=0.0 ) return;\n+      break;\n+    default:\n+      return;\n+  }\n+  if( argc==2 ){\n+    switch( sqlite3_value_numeric_type(argv[0]) ){\n+      case SQLITE_INTEGER:\n+      case SQLITE_FLOAT:\n+        b = log(x);\n+        if( b<=0.0 ) return;\n+        x = sqlite3_value_double(argv[1]);\n+        if( x<=0.0 ) return;\n+        break;\n+     default:\n+        return;\n+    }\n+    ans = log(x)\/b;\n+  }else{\n+    ans = log(x);\n+    switch( SQLITE_PTR_TO_INT(sqlite3_user_data(context)) ){\n+      case 1:\n+        \/* Convert from natural logarithm to log base 10 *\/\n+        ans *= 1.0\/M_LN10;\n+        break;\n+      case 2:\n+        \/* Convert from natural logarithm to log base 2 *\/\n+        ans *= 1.0\/M_LN2;\n+        break;\n+      default:\n+        break;\n+    }\n+  }\n+  sqlite3_result_double(context, ans);\n+}\n+\n+\/*\n+** Functions to converts degrees to radians and radians to degrees.\n+*\/\n+static double degToRad(double x){ return x*(M_PI\/180.0); }\n+static double radToDeg(double x){ return x*(180.0\/M_PI); }\n+\n+\/*\n+** Implementation of 1-argument SQL math functions:\n+**\n+**   exp(X)  - Compute e to the X-th power\n+*\/\n+static void math1Func(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  int type0;\n+  double v0, ans;\n+  double (*x)(double);\n+  assert( argc==1 );\n+  type0 = sqlite3_value_numeric_type(argv[0]);\n+  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;\n+  v0 = sqlite3_value_double(argv[0]);\n+  x = (double(*)(double))sqlite3_user_data(context);\n+  ans = x(v0);\n+  sqlite3_result_double(context, ans);\n+}\n+\n+\/*\n+** Implementation of 2-argument SQL math functions:\n+**\n+**   power(X,Y)  - Compute X to the Y-th power\n+*\/\n+static void math2Func(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  int type0, type1;\n+  double v0, v1, ans;\n+  double (*x)(double,double);\n+  assert( argc==2 );\n+  type0 = sqlite3_value_numeric_type(argv[0]);\n+  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;\n+  type1 = sqlite3_value_numeric_type(argv[1]);\n+  if( type1!=SQLITE_INTEGER && type1!=SQLITE_FLOAT ) return;\n+  v0 = sqlite3_value_double(argv[0]);\n+  v1 = sqlite3_value_double(argv[1]);\n+  x = (double(*)(double,double))sqlite3_user_data(context);\n+  ans = x(v0, v1);\n+  sqlite3_result_double(context, ans);\n+}\n+\n+\/*\n+** Implementation of 0-argument pi() function.\n+*\/\n+static void piFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  assert( argc==0 );\n+  sqlite3_result_double(context, M_PI);\n+}\n+\n+#endif \/* SQLITE_ENABLE_MATH_FUNCTIONS *\/\n+\n+\/*\n+** Implementation of sign(X) function.\n+*\/\n+static void signFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  int type0;\n+  double x;\n+  UNUSED_PARAMETER(argc);\n+  assert( argc==1 );\n+  type0 = sqlite3_value_numeric_type(argv[0]);\n+  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;\n+  x = sqlite3_value_double(argv[0]);\n+  sqlite3_result_int(context, x<0.0 ? -1 : x>0.0 ? +1 : 0);\n+}\n+\n@@ -118678,0 +122377,1 @@\n+#if !defined(SQLITE_UNTESTABLE)\n@@ -118681,3 +122381,2 @@\n-#ifdef SQLITE_DEBUG\n-    TEST_FUNC(affinity,          1, INLINEFUNC_affinity, 0),\n-#endif\n+    TEST_FUNC(affinity,            1, INLINEFUNC_affinity,            0),\n+#endif \/* !defined(SQLITE_UNTESTABLE) *\/\n@@ -118715,1 +122414,1 @@\n-                                          SQLITE_FUNC_MINMAX ),\n+                                 SQLITE_FUNC_MINMAX|SQLITE_FUNC_ANYORDER ),\n@@ -118719,1 +122418,1 @@\n-                                          SQLITE_FUNC_MINMAX ),\n+                                 SQLITE_FUNC_MINMAX|SQLITE_FUNC_ANYORDER ),\n@@ -118749,0 +122448,2 @@\n+    FUNCTION(substring,          2, 0, 0, substrFunc       ),\n+    FUNCTION(substring,          3, 0, 0, substrFunc       ),\n@@ -118753,1 +122454,2 @@\n-        countFinalize, countFinalize, countInverse, SQLITE_FUNC_COUNT  ),\n+        countFinalize, countFinalize, countInverse,\n+        SQLITE_FUNC_COUNT|SQLITE_FUNC_ANYORDER  ),\n@@ -118755,1 +122457,1 @@\n-        countFinalize, countFinalize, countInverse, 0  ),\n+        countFinalize, countFinalize, countInverse, SQLITE_FUNC_ANYORDER ),\n@@ -118774,0 +122476,37 @@\n+#ifdef SQLITE_ENABLE_MATH_FUNCTIONS\n+    MFUNCTION(ceil,              1, xCeil,     ceilingFunc ),\n+    MFUNCTION(ceiling,           1, xCeil,     ceilingFunc ),\n+    MFUNCTION(floor,             1, xFloor,    ceilingFunc ),\n+#if SQLITE_HAVE_C99_MATH_FUNCS\n+    MFUNCTION(trunc,             1, trunc,     ceilingFunc ),\n+#endif\n+    FUNCTION(ln,                 1, 0, 0,      logFunc     ),\n+    FUNCTION(log,                1, 1, 0,      logFunc     ),\n+    FUNCTION(log10,              1, 1, 0,      logFunc     ),\n+    FUNCTION(log2,               1, 2, 0,      logFunc     ),\n+    FUNCTION(log,                2, 0, 0,      logFunc     ),\n+    MFUNCTION(exp,               1, exp,       math1Func   ),\n+    MFUNCTION(pow,               2, pow,       math2Func   ),\n+    MFUNCTION(power,             2, pow,       math2Func   ),\n+    MFUNCTION(mod,               2, fmod,      math2Func   ),\n+    MFUNCTION(acos,              1, acos,      math1Func   ),\n+    MFUNCTION(asin,              1, asin,      math1Func   ),\n+    MFUNCTION(atan,              1, atan,      math1Func   ),\n+    MFUNCTION(atan2,             2, atan2,     math2Func   ),\n+    MFUNCTION(cos,               1, cos,       math1Func   ),\n+    MFUNCTION(sin,               1, sin,       math1Func   ),\n+    MFUNCTION(tan,               1, tan,       math1Func   ),\n+    MFUNCTION(cosh,              1, cosh,      math1Func   ),\n+    MFUNCTION(sinh,              1, sinh,      math1Func   ),\n+    MFUNCTION(tanh,              1, tanh,      math1Func   ),\n+#if SQLITE_HAVE_C99_MATH_FUNCS\n+    MFUNCTION(acosh,             1, acosh,     math1Func   ),\n+    MFUNCTION(asinh,             1, asinh,     math1Func   ),\n+    MFUNCTION(atanh,             1, atanh,     math1Func   ),\n+#endif\n+    MFUNCTION(sqrt,              1, sqrt,      math1Func   ),\n+    MFUNCTION(radians,           1, degToRad,  math1Func   ),\n+    MFUNCTION(degrees,           1, radToDeg,  math1Func   ),\n+    FUNCTION(pi,                 0, 0, 0,      piFunc      ),\n+#endif \/* SQLITE_ENABLE_MATH_FUNCTIONS *\/\n+    FUNCTION(sign,               1, 0, 0,      signFunc    ),\n@@ -118793,0 +122532,1 @@\n+        assert( p->funcFlags & SQLITE_FUNC_BUILTIN );\n@@ -119020,1 +122760,3 @@\n-      if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zName, zKey) ) return 0;\n+      if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zCnName, zKey) ){\n+        return 0;\n+      }\n@@ -119062,1 +122804,1 @@\n-          zDfltColl = pParent->aCol[iCol].zColl;\n+          zDfltColl = sqlite3ColumnColl(&pParent->aCol[iCol]);\n@@ -119066,1 +122808,1 @@\n-          zIdxCol = pParent->aCol[iCol].zName;\n+          zIdxCol = pParent->aCol[iCol].zCnName;\n@@ -119290,1 +123032,1 @@\n-      zColl = pCol->zColl;\n+      zColl = sqlite3ColumnColl(pCol);\n@@ -119313,0 +123055,1 @@\n+    assert( ExprUseYTab(pExpr) );\n@@ -119399,1 +123142,1 @@\n-    zCol = pFKey->pFrom->aCol[iCol].zName;\n+    zCol = pFKey->pFrom->aCol[iCol].zCnName;\n@@ -119434,1 +123177,1 @@\n-        pRight = sqlite3Expr(db, TK_ID, pTab->aCol[iCol].zName);\n+        pRight = sqlite3Expr(db, TK_ID, pTab->aCol[iCol].zCnName);\n@@ -119504,0 +123247,19 @@\n+\/*\n+** Clear the apTrigger[] cache of CASCADE triggers for all foreign keys\n+** in a particular database.  This needs to happen when the schema\n+** changes.\n+*\/\n+SQLITE_PRIVATE void sqlite3FkClearTriggerCache(sqlite3 *db, int iDb){\n+  HashElem *k;\n+  Hash *pHash = &db->aDb[iDb].pSchema->tblHash;\n+  for(k=sqliteHashFirst(pHash); k; k=sqliteHashNext(k)){\n+    Table *pTab = sqliteHashData(k);\n+    FKey *pFKey;\n+    if( !IsOrdinaryTable(pTab) ) continue;\n+    for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n+      fkTriggerDelete(db, pFKey->apTrigger[0]); pFKey->apTrigger[0] = 0;\n+      fkTriggerDelete(db, pFKey->apTrigger[1]); pFKey->apTrigger[1] = 0;\n+    }\n+  }\n+}\n+\n@@ -119523,1 +123285,1 @@\n-  if( (db->flags&SQLITE_ForeignKeys) && !IsVirtual(pTab) ){\n+  if( (db->flags&SQLITE_ForeignKeys) && IsOrdinaryTable(pTab) ){\n@@ -119528,1 +123290,1 @@\n-    assert( pTab->pSelect==0 );   \/* Not a view *\/\n+    assert( IsOrdinaryTable(pTab) );\n@@ -119536,1 +123298,1 @@\n-      for(p=pTab->pFKey; p; p=p->pNextFrom){\n+      for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){\n@@ -119625,1 +123387,1 @@\n-          if( 0==sqlite3StrICmp(pCol->zName, zKey) ) return 1;\n+          if( 0==sqlite3StrICmp(pCol->zCnName, zKey) ) return 1;\n@@ -119692,0 +123454,1 @@\n+  if( !IsOrdinaryTable(pTab) ) return;\n@@ -119698,1 +123461,1 @@\n-  for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n+  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n@@ -119765,1 +123528,1 @@\n-        char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zName;\n+        char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zCnName;\n@@ -119829,1 +123592,1 @@\n-      struct SrcList_item *pItem = pSrc->a;\n+      SrcItem *pItem = pSrc->a;\n@@ -119880,1 +123643,1 @@\n-  if( pParse->db->flags&SQLITE_ForeignKeys ){\n+  if( pParse->db->flags&SQLITE_ForeignKeys && IsOrdinaryTable(pTab) ){\n@@ -119883,1 +123646,1 @@\n-    for(p=pTab->pFKey; p; p=p->pNextFrom){\n+    for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){\n@@ -119917,1 +123680,3 @@\n-**   * There are any FKs for which pTab is the child and the parent table, or\n+**   * There are any FKs for which pTab is the child and the parent table\n+**     and any FK processing at all is required (even of a different FK), or\n+**\n@@ -119929,2 +123694,3 @@\n-  int eRet = 0;\n-  if( pParse->db->flags&SQLITE_ForeignKeys ){\n+  int eRet = 1;                   \/* Value to return if bHaveFK is true *\/\n+  int bHaveFK = 0;                \/* If FK processing is required *\/\n+  if( pParse->db->flags&SQLITE_ForeignKeys && IsOrdinaryTable(pTab) ){\n@@ -119935,1 +123701,1 @@\n-      eRet = (sqlite3FkReferences(pTab) || pTab->pFKey);\n+      bHaveFK = (sqlite3FkReferences(pTab) || pTab->u.tab.pFKey);\n@@ -119942,2 +123708,1 @@\n-      for(p=pTab->pFKey; p; p=p->pNextFrom){\n-        if( 0==sqlite3_stricmp(pTab->zName, p->zTo) ) return 2;\n+      for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){\n@@ -119945,1 +123710,2 @@\n-          eRet = 1;\n+          if( 0==sqlite3_stricmp(pTab->zName, p->zTo) ) eRet = 2;\n+          bHaveFK = 1;\n@@ -119953,1 +123719,1 @@\n-          eRet = 1;\n+          bHaveFK = 1;\n@@ -119958,1 +123724,1 @@\n-  return eRet;\n+  return bHaveFK ? eRet : 0;\n@@ -120035,2 +123801,2 @@\n-                   pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName);\n-      sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zName);\n+                   pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zCnName);\n+      sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zCnName);\n@@ -120081,1 +123847,1 @@\n-            pDflt = pCol->pDflt;\n+            pDflt = sqlite3ColumnExpr(pFKey->pFrom, pCol);\n@@ -120164,0 +123930,1 @@\n+        \/* no break *\/ deliberate_fall_through\n@@ -120217,3 +123984,3 @@\n-  assert( db==0 || IsVirtual(pTab)\n-         || sqlite3SchemaMutexHeld(db, 0, pTab->pSchema) );\n-  for(pFKey=pTab->pFKey; pFKey; pFKey=pNext){\n+  assert( IsOrdinaryTable(pTab) );\n+  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pNext){\n+    assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pTab->pSchema) );\n@@ -120288,1 +124055,2 @@\n-  v = sqlite3GetVdbe(pParse);\n+  assert( pParse->pVdbe!=0 );\n+  v = pParse->pVdbe;\n@@ -120298,1 +124066,1 @@\n-    assert( pPk->tnum==pTab->tnum );\n+    assert( pPk->tnum==pTab->tnum || CORRUPT_DB );\n@@ -120365,0 +124133,6 @@\n+** Make changes to the evolving bytecode to do affinity transformations\n+** of values that are about to be gathered into a row for table pTab.\n+**\n+** For ordinary (legacy, non-strict) tables:\n+** -----------------------------------------\n+**\n@@ -120368,3 +124142,5 @@\n-** If the affinity exists (if it is no entirely SQLITE_AFF_BLOB values) and\n-** if iReg>0 then code an OP_Affinity opcode that will set the affinities\n-** for register iReg and following.  Or if affinities exists and iReg==0,\n+** If the affinity string is empty (because it was all SQLITE_AFF_BLOB entries\n+** which were then optimized out) then this routine becomes a no-op.\n+**\n+** Otherwise if iReg>0 then code an OP_Affinity opcode that will set the\n+** affinities for register iReg and following.  Or if iReg==0,\n@@ -120376,7 +124152,19 @@\n-**  Character      Column affinity\n-**  ------------------------------\n-**  'A'            BLOB\n-**  'B'            TEXT\n-**  'C'            NUMERIC\n-**  'D'            INTEGER\n-**  'E'            REAL\n+**    Character      Column affinity\n+**    ---------      ---------------\n+**    'A'            BLOB\n+**    'B'            TEXT\n+**    'C'            NUMERIC\n+**    'D'            INTEGER\n+**    'E'            REAL\n+**\n+** For STRICT tables:\n+** ------------------\n+**\n+** Generate an appropropriate OP_TypeCheck opcode that will verify the\n+** datatypes against the column definitions in pTab.  If iReg==0, that\n+** means an OP_MakeRecord opcode has already been generated and should be\n+** the last opcode generated.  The new OP_TypeCheck needs to be inserted\n+** before the OP_MakeRecord.  The new OP_TypeCheck should use the same\n+** register set as the OP_MakeRecord.  If iReg>0 then register iReg is\n+** the first of a series of registers that will form the new record.\n+** Apply the type checking to that array of registers.\n@@ -120386,1 +124174,21 @@\n-  char *zColAff = pTab->zColAff;\n+  char *zColAff;\n+  if( pTab->tabFlags & TF_Strict ){\n+    if( iReg==0 ){\n+      \/* Move the previous opcode (which should be OP_MakeRecord) forward\n+      ** by one slot and insert a new OP_TypeCheck where the current\n+      ** OP_MakeRecord is found *\/\n+      VdbeOp *pPrev;\n+      sqlite3VdbeAppendP4(v, pTab, P4_TABLE);\n+      pPrev = sqlite3VdbeGetOp(v, -1);\n+      assert( pPrev!=0 );\n+      assert( pPrev->opcode==OP_MakeRecord || sqlite3VdbeDb(v)->mallocFailed );\n+      pPrev->opcode = OP_TypeCheck;\n+      sqlite3VdbeAddOp3(v, OP_MakeRecord, pPrev->p1, pPrev->p2, pPrev->p3);\n+    }else{\n+      \/* Insert an isolated OP_Typecheck *\/\n+      sqlite3VdbeAddOp2(v, OP_TypeCheck, iReg, pTab->nNVCol);\n+      sqlite3VdbeAppendP4(v, pTab, P4_TABLE);\n+    }\n+    return;\n+  }\n+  zColAff = pTab->zColAff;\n@@ -120412,0 +124220,2 @@\n+      assert( sqlite3VdbeGetOp(v, -1)->opcode==OP_MakeRecord\n+              || sqlite3VdbeDb(v)->mallocFailed );\n@@ -120436,1 +124246,1 @@\n-      int tnum = pOp->p2;\n+      Pgno tnum = pOp->p2;\n@@ -120495,16 +124305,18 @@\n-  if( (pTab->tabFlags & TF_HasStored)!=0\n-   && (pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1))->opcode==OP_Affinity\n-  ){\n-    \/* Change the OP_Affinity argument to '@' (NONE) for all stored\n-    ** columns.  '@' is the no-op affinity and those columns have not\n-    ** yet been computed. *\/\n-    int ii, jj;\n-    char *zP4 = pOp->p4.z;\n-    assert( zP4!=0 );\n-    assert( pOp->p4type==P4_DYNAMIC );\n-    for(ii=jj=0; zP4[jj]; ii++){\n-      if( pTab->aCol[ii].colFlags & COLFLAG_VIRTUAL ){\n-        continue;\n-      }\n-      if( pTab->aCol[ii].colFlags & COLFLAG_STORED ){\n-        zP4[jj] = SQLITE_AFF_NONE;\n+  if( (pTab->tabFlags & TF_HasStored)!=0 ){\n+    pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);\n+    if( pOp->opcode==OP_Affinity ){\n+      \/* Change the OP_Affinity argument to '@' (NONE) for all stored\n+      ** columns.  '@' is the no-op affinity and those columns have not\n+      ** yet been computed. *\/\n+      int ii, jj;\n+      char *zP4 = pOp->p4.z;\n+      assert( zP4!=0 );\n+      assert( pOp->p4type==P4_DYNAMIC );\n+      for(ii=jj=0; zP4[jj]; ii++){\n+        if( pTab->aCol[ii].colFlags & COLFLAG_VIRTUAL ){\n+          continue;\n+        }\n+        if( pTab->aCol[ii].colFlags & COLFLAG_STORED ){\n+          zP4[jj] = SQLITE_AFF_NONE;\n+        }\n+        jj++;\n@@ -120512,1 +124324,5 @@\n-      jj++;\n+    }else if( pOp->opcode==OP_TypeCheck ){\n+      \/* If an OP_TypeCheck was generated because the table is STRICT,\n+      ** then set the P3 operand to indicate that generated columns should\n+      ** not be checked *\/\n+      pOp->p3 = 1;\n@@ -120548,1 +124364,1 @@\n-        sqlite3WalkExpr(&w, pCol->pDflt);\n+        sqlite3WalkExpr(&w, sqlite3ColumnExpr(pTab, pCol));\n@@ -120557,1 +124373,1 @@\n-        sqlite3ExprCodeGeneratedColumn(pParse, pCol, x);\n+        sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, x);\n@@ -120563,1 +124379,1 @@\n-    sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pRedo->zName);\n+    sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pRedo->zCnName);\n@@ -120613,1 +124429,1 @@\n-     || IsVirtual(pSeqTab)\n+     || NEVER(IsVirtual(pSeqTab))\n@@ -120625,1 +124441,3 @@\n-      if( pInfo==0 ) return 0;\n+      sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);\n+      testcase( pParse->earlyCleanup );\n+      if( pParse->db->mallocFailed ) return 0;\n@@ -120956,1 +124774,1 @@\n-  isView = pTab->pSelect!=0;\n+  isView = IsView(pTab);\n@@ -121047,1 +124865,1 @@\n-        if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zName)==0 ){\n+        if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zCnName)==0 ){\n@@ -121057,1 +124875,1 @@\n-               pTab->aCol[j].zName);\n+               pTab->aCol[j].zCnName);\n@@ -121070,1 +124888,1 @@\n-              pTabList, 0, pColumn->a[i].zName);\n+              pTabList->a, pColumn->a[i].zName);\n@@ -121183,1 +125001,0 @@\n-  }\n@@ -121185,11 +125002,17 @@\n-  \/* Make sure the number of columns in the source data matches the number\n-  ** of columns to be inserted into the table.\n-  *\/\n-  for(i=0; i<pTab->nCol; i++){\n-    if( pTab->aCol[i].colFlags & COLFLAG_NOINSERT ) nHidden++;\n-  }\n-  if( pColumn==0 && nColumn && nColumn!=(pTab->nCol-nHidden) ){\n-    sqlite3ErrorMsg(pParse,\n-       \"table %S has %d columns but %d values were supplied\",\n-       pTabList, 0, pTab->nCol-nHidden, nColumn);\n-    goto insert_cleanup;\n+    \/* Make sure the number of columns in the source data matches the number\n+    ** of columns to be inserted into the table.\n+    *\/\n+    assert( TF_HasHidden==COLFLAG_HIDDEN );\n+    assert( TF_HasGenerated==COLFLAG_GENERATED );\n+    assert( COLFLAG_NOINSERT==(COLFLAG_GENERATED|COLFLAG_HIDDEN) );\n+    if( (pTab->tabFlags & (TF_HasGenerated|TF_HasHidden))!=0 ){\n+      for(i=0; i<pTab->nCol; i++){\n+        if( pTab->aCol[i].colFlags & COLFLAG_NOINSERT ) nHidden++;\n+      }\n+    }\n+    if( nColumn!=(pTab->nCol-nHidden) ){\n+      sqlite3ErrorMsg(pParse,\n+         \"table %S has %d columns but %d values were supplied\",\n+         pTabList->a, pTab->nCol-nHidden, nColumn);\n+     goto insert_cleanup;\n+    }\n@@ -121207,0 +125030,1 @@\n+   && !pParse->bReturning\n@@ -121230,0 +125054,1 @@\n+    Upsert *pNx;\n@@ -121235,1 +125060,1 @@\n-    if( pTab->pSelect ){\n+    if( IsView(pTab) ){\n@@ -121243,7 +125068,13 @@\n-    pUpsert->pUpsertSrc = pTabList;\n-    pUpsert->regData = regData;\n-    pUpsert->iDataCur = iDataCur;\n-    pUpsert->iIdxCur = iIdxCur;\n-    if( pUpsert->pUpsertTarget ){\n-      sqlite3UpsertAnalyzeTarget(pParse, pTabList, pUpsert);\n-    }\n+    pNx = pUpsert;\n+    do{\n+      pNx->pUpsertSrc = pTabList;\n+      pNx->regData = regData;\n+      pNx->iDataCur = iDataCur;\n+      pNx->iIdxCur = iIdxCur;\n+      if( pNx->pUpsertTarget ){\n+        if( sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx) ){\n+          goto insert_cleanup;\n+        }\n+      }\n+      pNx = pNx->pNextUpsert;\n+    }while( pNx!=0 );\n@@ -121328,1 +125159,3 @@\n-        sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);\n+        sqlite3ExprCodeFactorable(pParse,\n+            sqlite3ColumnExpr(pTab, &pTab->aCol[i]),\n+            iRegStore);\n@@ -121337,1 +125170,3 @@\n-        sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);\n+        sqlite3ExprCodeFactorable(pParse,\n+            sqlite3ColumnExpr(pTab, &pTab->aCol[i]),\n+            iRegStore);\n@@ -121343,1 +125178,3 @@\n-      sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);\n+      sqlite3ExprCodeFactorable(pParse,\n+          sqlite3ColumnExpr(pTab, &pTab->aCol[i]),\n+          iRegStore);\n@@ -121390,5 +125227,0 @@\n-    \/* Cannot have triggers on a virtual table. If it were possible,\n-    ** this block would have to account for hidden column.\n-    *\/\n-    assert( !IsVirtual(pTab) );\n-\n@@ -121493,1 +125325,1 @@\n-      int isReplace;    \/* Set to true if constraints may cause a replace *\/\n+      int isReplace = 0;\/* Set to true if constraints may cause a replace *\/\n@@ -121513,0 +125345,7 @@\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+  }else if( pParse->bReturning ){\n+    \/* If there is a RETURNING clause, populate the rowid register with\n+    ** constant value -1, in case one or more of the returned expressions\n+    ** refer to the \"rowid\" of the view.  *\/\n+    sqlite3VdbeAddOp2(v, OP_Integer, -1, regRowid);\n+#endif\n@@ -121549,0 +125388,1 @@\n+#ifndef SQLITE_OMIT_XFER_OPT\n@@ -121550,0 +125390,1 @@\n+#endif \/* SQLITE_OMIT_XFER_OPT *\/\n@@ -121564,1 +125405,1 @@\n-    sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1);\n+    sqlite3VdbeAddOp2(v, OP_ChngCntRow, regRowCount, 1);\n@@ -121654,0 +125495,64 @@\n+\/*\n+** The sqlite3GenerateConstraintChecks() routine usually wants to visit\n+** the indexes of a table in the order provided in the Table->pIndex list.\n+** However, sometimes (rarely - when there is an upsert) it wants to visit\n+** the indexes in a different order.  The following data structures accomplish\n+** this.\n+**\n+** The IndexIterator object is used to walk through all of the indexes\n+** of a table in either Index.pNext order, or in some other order established\n+** by an array of IndexListTerm objects.\n+*\/\n+typedef struct IndexListTerm IndexListTerm;\n+typedef struct IndexIterator IndexIterator;\n+struct IndexIterator {\n+  int eType;    \/* 0 for Index.pNext list.  1 for an array of IndexListTerm *\/\n+  int i;        \/* Index of the current item from the list *\/\n+  union {\n+    struct {    \/* Use this object for eType==0: A Index.pNext list *\/\n+      Index *pIdx;   \/* The current Index *\/\n+    } lx;\n+    struct {    \/* Use this object for eType==1; Array of IndexListTerm *\/\n+      int nIdx;               \/* Size of the array *\/\n+      IndexListTerm *aIdx;    \/* Array of IndexListTerms *\/\n+    } ax;\n+  } u;\n+};\n+\n+\/* When IndexIterator.eType==1, then each index is an array of instances\n+** of the following object\n+*\/\n+struct IndexListTerm {\n+  Index *p;  \/* The index *\/\n+  int ix;    \/* Which entry in the original Table.pIndex list is this index*\/\n+};\n+\n+\/* Return the first index on the list *\/\n+static Index *indexIteratorFirst(IndexIterator *pIter, int *pIx){\n+  assert( pIter->i==0 );\n+  if( pIter->eType ){\n+    *pIx = pIter->u.ax.aIdx[0].ix;\n+    return pIter->u.ax.aIdx[0].p;\n+  }else{\n+    *pIx = 0;\n+    return pIter->u.lx.pIdx;\n+  }\n+}\n+\n+\/* Return the next index from the list.  Return NULL when out of indexes *\/\n+static Index *indexIteratorNext(IndexIterator *pIter, int *pIx){\n+  if( pIter->eType ){\n+    int i = ++pIter->i;\n+    if( i>=pIter->u.ax.nIdx ){\n+      *pIx = i;\n+      return 0;\n+    }\n+    *pIx = pIter->u.ax.aIdx[i].ix;\n+    return pIter->u.ax.aIdx[i].p;\n+  }else{\n+    ++(*pIx);\n+    pIter->u.lx.pIdx = pIter->u.lx.pIdx->pNext;\n+    return pIter->u.lx.pIdx;\n+  }\n+}\n+\n@@ -121762,1 +125667,1 @@\n-  Index *pPk = 0;      \/* The PRIMARY KEY index *\/\n+  Index *pPk = 0;      \/* The PRIMARY KEY index for WITHOUT ROWID tables *\/\n@@ -121770,2 +125675,2 @@\n-  Index *pUpIdx = 0;   \/* Index to which to apply the upsert *\/\n-  u8 isUpdate;         \/* True if this is an UPDATE operation *\/\n+  Upsert *pUpsertClause = 0;  \/* The specific ON CONFLICT clause for pIdx *\/\n+  u8 isUpdate;           \/* True if this is an UPDATE operation *\/\n@@ -121773,2 +125678,2 @@\n-  int upsertBypass = 0;  \/* Address of Goto to bypass upsert subroutine *\/\n-  int upsertJump = 0;    \/* Address of Goto that jumps into upsert subroutine *\/\n+  int upsertIpkReturn = 0; \/* Address of Goto at end of IPK uniqueness check *\/\n+  int upsertIpkDelay = 0;  \/* Address of Goto to bypass initial IPK check *\/\n@@ -121784,0 +125689,1 @@\n+  IndexIterator sIdxIter;  \/* Index iterator *\/\n@@ -121787,1 +125693,1 @@\n-  v = sqlite3GetVdbe(pParse);\n+  v = pParse->pVdbe;\n@@ -121789,1 +125695,1 @@\n-  assert( pTab->pSelect==0 );  \/* This table is not a VIEW *\/\n+  assert( !IsView(pTab) );  \/* This table is not a VIEW *\/\n@@ -121840,1 +125746,1 @@\n-           || pCol->pDflt==0  \/* REPLACE is ABORT if no DEFAULT value *\/\n+           || pCol->iDflt==0  \/* REPLACE is ABORT if no DEFAULT value *\/\n@@ -121862,1 +125768,2 @@\n-            sqlite3ExprCodeCopy(pParse, pCol->pDflt, iReg);\n+            sqlite3ExprCodeCopy(pParse,\n+               sqlite3ColumnExpr(pTab, pCol), iReg);\n@@ -121868,1 +125775,1 @@\n-            \/* Fall through *\/\n+            \/* no break *\/ deliberate_fall_through\n@@ -121872,1 +125779,1 @@\n-                                        pCol->zName);\n+                                        pCol->zCnName);\n@@ -121941,1 +125848,1 @@\n-        if( zName==0 ) zName = pTab->zName;\n+        assert( zName!=0 || pParse->db->mallocFailed );\n@@ -121981,1 +125888,4 @@\n-\n+  sIdxIter.eType = 0;\n+  sIdxIter.i = 0;\n+  sIdxIter.u.ax.aIdx = 0;  \/* Silence harmless compiler warning *\/\n+  sIdxIter.u.lx.pIdx = pTab->pIndex;\n@@ -121984,10 +125894,51 @@\n-      \/* An ON CONFLICT DO NOTHING clause, without a constraint-target.\n-      ** Make all unique constraint resolution be OE_Ignore *\/\n-      assert( pUpsert->pUpsertSet==0 );\n-      overrideError = OE_Ignore;\n-      pUpsert = 0;\n-    }else if( (pUpIdx = pUpsert->pUpsertIdx)!=0 ){\n-      \/* If the constraint-target uniqueness check must be run first.\n-      ** Jump to that uniqueness check now *\/\n-      upsertJump = sqlite3VdbeAddOp0(v, OP_Goto);\n-      VdbeComment((v, \"UPSERT constraint goes first\"));\n+      \/* There is just on ON CONFLICT clause and it has no constraint-target *\/\n+      assert( pUpsert->pNextUpsert==0 );\n+      if( pUpsert->isDoUpdate==0 ){\n+        \/* A single ON CONFLICT DO NOTHING clause, without a constraint-target.\n+        ** Make all unique constraint resolution be OE_Ignore *\/\n+        overrideError = OE_Ignore;\n+        pUpsert = 0;\n+      }else{\n+        \/* A single ON CONFLICT DO UPDATE.  Make all resolutions OE_Update *\/\n+        overrideError = OE_Update;\n+      }\n+    }else if( pTab->pIndex!=0 ){\n+      \/* Otherwise, we'll need to run the IndexListTerm array version of the\n+      ** iterator to ensure that all of the ON CONFLICT conditions are\n+      ** checked first and in order. *\/\n+      int nIdx, jj;\n+      u64 nByte;\n+      Upsert *pTerm;\n+      u8 *bUsed;\n+      for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){\n+         assert( aRegIdx[nIdx]>0 );\n+      }\n+      sIdxIter.eType = 1;\n+      sIdxIter.u.ax.nIdx = nIdx;\n+      nByte = (sizeof(IndexListTerm)+1)*nIdx + nIdx;\n+      sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, nByte);\n+      if( sIdxIter.u.ax.aIdx==0 ) return; \/* OOM *\/\n+      bUsed = (u8*)&sIdxIter.u.ax.aIdx[nIdx];\n+      pUpsert->pToFree = sIdxIter.u.ax.aIdx;\n+      for(i=0, pTerm=pUpsert; pTerm; pTerm=pTerm->pNextUpsert){\n+        if( pTerm->pUpsertTarget==0 ) break;\n+        if( pTerm->pUpsertIdx==0 ) continue;  \/* Skip ON CONFLICT for the IPK *\/\n+        jj = 0;\n+        pIdx = pTab->pIndex;\n+        while( ALWAYS(pIdx!=0) && pIdx!=pTerm->pUpsertIdx ){\n+           pIdx = pIdx->pNext;\n+           jj++;\n+        }\n+        if( bUsed[jj] ) continue; \/* Duplicate ON CONFLICT clause ignored *\/\n+        bUsed[jj] = 1;\n+        sIdxIter.u.ax.aIdx[i].p = pIdx;\n+        sIdxIter.u.ax.aIdx[i].ix = jj;\n+        i++;\n+      }\n+      for(jj=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, jj++){\n+        if( bUsed[jj] ) continue;\n+        sIdxIter.u.ax.aIdx[i].p = pIdx;\n+        sIdxIter.u.ax.aIdx[i].ix = jj;\n+        i++;\n+      }\n+      assert( i==nIdx );\n@@ -122056,5 +126007,14 @@\n-    if( pUpsert && pUpsert->pUpsertIdx==0 ){\n-      if( pUpsert->pUpsertSet==0 ){\n-        onError = OE_Ignore;  \/* DO NOTHING is the same as INSERT OR IGNORE *\/\n-      }else{\n-        onError = OE_Update;  \/* DO UPDATE *\/\n+    if( pUpsert ){\n+      pUpsertClause = sqlite3UpsertOfIndex(pUpsert,0);\n+      if( pUpsertClause!=0 ){\n+        if( pUpsertClause->isDoUpdate==0 ){\n+          onError = OE_Ignore;  \/* DO NOTHING is the same as INSERT OR IGNORE *\/\n+        }else{\n+          onError = OE_Update;  \/* DO UPDATE *\/\n+        }\n+      }\n+      if( pUpsertClause!=pUpsert ){\n+        \/* The first ON CONFLICT clause has a conflict target other than\n+        ** the IPK.  We have to jump ahead to that first ON CONFLICT clause\n+        ** and then come back here and deal with the IPK afterwards *\/\n+        upsertIpkDelay = sqlite3VdbeAddOp0(v, OP_Goto);\n@@ -122070,1 +126030,1 @@\n-     && onError!=overrideError   \/* Rules for other contraints are different *\/\n+     && onError!=overrideError   \/* Rules for other constraints are different *\/\n@@ -122072,0 +126032,1 @@\n+     && !upsertIpkDelay          \/* IPK check already deferred by UPSERT *\/\n@@ -122096,1 +126057,1 @@\n-        \/* Fall thru into the next case *\/\n+        \/* no break *\/ deliberate_fall_through\n@@ -122157,1 +126118,1 @@\n-        \/* Fall through *\/\n+        \/* no break *\/ deliberate_fall_through\n@@ -122167,1 +126128,3 @@\n-    if( ipkTop ){\n+    if( pUpsert && pUpsertClause!=pUpsert ){\n+      upsertIpkReturn = sqlite3VdbeAddOp0(v, OP_Goto);\n+    }else if( ipkTop ){\n@@ -122180,1 +126143,4 @@\n-  for(ix=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, ix++){\n+  for(pIdx = indexIteratorFirst(&sIdxIter, &ix);\n+      pIdx;\n+      pIdx = indexIteratorNext(&sIdxIter, &ix)\n+  ){\n@@ -122188,7 +126154,5 @@\n-    if( pUpIdx==pIdx ){\n-      addrUniqueOk = upsertJump+1;\n-      upsertBypass = sqlite3VdbeGoto(v, 0);\n-      VdbeComment((v, \"Skip upsert subroutine\"));\n-      sqlite3VdbeJumpHere(v, upsertJump);\n-    }else{\n-      addrUniqueOk = sqlite3VdbeMakeLabel(pParse);\n+    if( pUpsert ){\n+      pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);\n+      if( upsertIpkDelay && pUpsertClause==pUpsert ){\n+        sqlite3VdbeJumpHere(v, upsertIpkDelay);\n+      }\n@@ -122196,1 +126160,2 @@\n-    if( bAffinityDone==0 && (pUpIdx==0 || pUpIdx==pIdx) ){\n+    addrUniqueOk = sqlite3VdbeMakeLabel(pParse);\n+    if( bAffinityDone==0 ){\n@@ -122233,1 +126198,1 @@\n-        VdbeComment((v, \"%s\", pTab->aCol[iField].zName));\n+        VdbeComment((v, \"%s\", pTab->aCol[iField].zCnName));\n@@ -122267,2 +126232,2 @@\n-    if( pUpIdx==pIdx ){\n-      if( pUpsert->pUpsertSet==0 ){\n+    if( pUpsertClause ){\n+      if( pUpsertClause->isDoUpdate==0 ){\n@@ -122285,0 +126250,1 @@\n+    assert( IsOrdinaryTable(pTab) );\n@@ -122292,1 +126258,1 @@\n-         (0==pTab->pFKey && 0==sqlite3FkReferences(pTab)))\n+         (0==pTab->u.tab.pFKey && 0==sqlite3FkReferences(pTab)))\n@@ -122306,1 +126272,1 @@\n-    regR = (pIdx==pPk) ? regIdx : sqlite3GetTempRange(pParse, nPkField);\n+    regR = pIdx==pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);\n@@ -122327,1 +126293,1 @@\n-                         pTab->aCol[pPk->aiColumn[i]].zName));\n+                         pTab->aCol[pPk->aiColumn[i]].zCnName));\n@@ -122378,1 +126344,1 @@\n-        \/* Fall through *\/\n+        \/* no break *\/ deliberate_fall_through\n@@ -122391,1 +126357,2 @@\n-        assert( nConflictCk>0 );\n+        assert( nConflictCk>0 || db->mallocFailed );\n+        testcase( nConflictCk<=0 );\n@@ -122458,6 +126425,1 @@\n-    if( pUpIdx==pIdx ){\n-      sqlite3VdbeGoto(v, upsertJump+1);\n-      sqlite3VdbeJumpHere(v, upsertBypass);\n-    }else{\n-      sqlite3VdbeResolveLabel(v, addrUniqueOk);\n-    }\n+    sqlite3VdbeResolveLabel(v, addrUniqueOk);\n@@ -122465,0 +126427,8 @@\n+    if( pUpsertClause\n+     && upsertIpkReturn\n+     && sqlite3UpsertNextIsIPK(pUpsertClause)\n+    ){\n+      sqlite3VdbeGoto(v, upsertIpkDelay+1);\n+      sqlite3VdbeJumpHere(v, upsertIpkReturn);\n+      upsertIpkReturn = 0;\n+    }\n@@ -122471,0 +126441,1 @@\n+    assert( ipkBottom>0 );\n@@ -122523,1 +126494,1 @@\n-    if( pTab->aCol[i].pDflt!=0 ) break;\n+    if( pTab->aCol[i].iDflt!=0 ) break;\n@@ -122530,0 +126501,26 @@\n+\/*\n+** Table pTab is a WITHOUT ROWID table that is being written to. The cursor\n+** number is iCur, and register regData contains the new record for the\n+** PK index. This function adds code to invoke the pre-update hook,\n+** if one is registered.\n+*\/\n+#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n+static void codeWithoutRowidPreupdate(\n+  Parse *pParse,                  \/* Parse context *\/\n+  Table *pTab,                    \/* Table being updated *\/\n+  int iCur,                       \/* Cursor number for table *\/\n+  int regData                     \/* Data containing new record *\/\n+){\n+  Vdbe *v = pParse->pVdbe;\n+  int r = sqlite3GetTempReg(pParse);\n+  assert( !HasRowid(pTab) );\n+  assert( 0==(pParse->db->mDbFlags & DBFLAG_Vacuum) || CORRUPT_DB );\n+  sqlite3VdbeAddOp2(v, OP_Integer, 0, r);\n+  sqlite3VdbeAddOp4(v, OP_Insert, iCur, regData, r, (char*)pTab, P4_TABLE);\n+  sqlite3VdbeChangeP5(v, OPFLAG_ISNOOP);\n+  sqlite3ReleaseTempReg(pParse, r);\n+}\n+#else\n+# define codeWithoutRowidPreupdate(a,b,c,d)\n+#endif\n+\n@@ -122560,1 +126557,1 @@\n-  v = sqlite3GetVdbe(pParse);\n+  v = pParse->pVdbe;\n@@ -122562,1 +126559,1 @@\n-  assert( pTab->pSelect==0 );  \/* This table is not a VIEW *\/\n+  assert( !IsView(pTab) );  \/* This table is not a VIEW *\/\n@@ -122575,1 +126572,0 @@\n-      assert( pParse->nested==0 );\n@@ -122578,1 +126574,0 @@\n-#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n@@ -122580,7 +126575,1 @@\n-        int r = sqlite3GetTempReg(pParse);\n-        sqlite3VdbeAddOp2(v, OP_Integer, 0, r);\n-        sqlite3VdbeAddOp4(v, OP_Insert,\n-            iIdxCur+i, aRegIdx[i], r, (char*)pTab, P4_TABLE\n-        );\n-        sqlite3VdbeChangeP5(v, OPFLAG_ISNOOP);\n-        sqlite3ReleaseTempReg(pParse, r);\n+        codeWithoutRowidPreupdate(pParse, pTab, iIdxCur+i, aRegIdx[i]);\n@@ -122588,1 +126577,0 @@\n-#endif\n@@ -122656,2 +126644,3 @@\n-    ** variables *piDataCur and *piIdxCur uninitialized so that valgrind\n-    ** can detect if they are used by mistake in the caller. *\/\n+    ** variables *piDataCur and *piIdxCur set to illegal cursor numbers\n+    ** for improved error detection. *\/\n+    *piDataCur = *piIdxCur = -999;\n@@ -122661,1 +126650,1 @@\n-  v = sqlite3GetVdbe(pParse);\n+  v = pParse->pVdbe;\n@@ -122786,1 +126775,1 @@\n-  struct SrcList_item *pItem;      \/* An element of pSelect->pSrc *\/\n+  SrcItem *pItem;                  \/* An element of pSelect->pSrc *\/\n@@ -122866,1 +126855,1 @@\n-    testcase( pSrc!=pDest ); \/* Possible due to bad sqlite_master.rootpage *\/\n+    testcase( pSrc!=pDest ); \/* Possible due to bad sqlite_schema.rootpage *\/\n@@ -122872,7 +126861,2 @@\n-#ifndef SQLITE_OMIT_VIRTUALTABLE\n-  if( IsVirtual(pSrc) ){\n-    return 0;   \/* tab2 must not be a virtual table *\/\n-  }\n-#endif\n-  if( pSrc->pSelect ){\n-    return 0;   \/* tab2 may not be a view *\/\n+  if( !IsOrdinaryTable(pSrc) ){\n+    return 0;   \/* tab2 may not be a view or virtual table *\/\n@@ -122886,0 +126870,3 @@\n+  if( (pDest->tabFlags & TF_Strict)!=0 && (pSrc->tabFlags & TF_Strict)==0 ){\n+    return 0;   \/* Cannot feed from a non-strict into a strict table *\/\n+  }\n@@ -122922,1 +126909,3 @@\n-      if( sqlite3ExprCompare(0, pSrcCol->pDflt, pDestCol->pDflt, -1)!=0 ){\n+      if( sqlite3ExprCompare(0,\n+             sqlite3ColumnExpr(pSrc, pSrcCol),\n+             sqlite3ColumnExpr(pDest, pDestCol), -1)!=0 ){\n@@ -122932,1 +126921,2 @@\n-    if( sqlite3_stricmp(pDestCol->zColl, pSrcCol->zColl)!=0 ){\n+    if( sqlite3_stricmp(sqlite3ColumnColl(pDestCol),\n+                        sqlite3ColumnColl(pSrcCol))!=0 ){\n@@ -122940,5 +126930,9 @@\n-      assert( pDestCol->pDflt==0 || pDestCol->pDflt->op==TK_SPAN );\n-      assert( pSrcCol->pDflt==0 || pSrcCol->pDflt->op==TK_SPAN );\n-      if( (pDestCol->pDflt==0)!=(pSrcCol->pDflt==0)\n-       || (pDestCol->pDflt && strcmp(pDestCol->pDflt->u.zToken,\n-                                       pSrcCol->pDflt->u.zToken)!=0)\n+      Expr *pDestExpr = sqlite3ColumnExpr(pDest, pDestCol);\n+      Expr *pSrcExpr = sqlite3ColumnExpr(pSrc, pSrcCol);\n+      assert( pDestExpr==0 || pDestExpr->op==TK_SPAN );\n+      assert( pDestExpr==0 || !ExprHasProperty(pDestExpr, EP_IntValue) );\n+      assert( pSrcExpr==0 || pSrcExpr->op==TK_SPAN );\n+      assert( pSrcExpr==0 || !ExprHasProperty(pSrcExpr, EP_IntValue) );\n+      if( (pDestExpr==0)!=(pSrcExpr==0)\n+       || (pDestExpr!=0 && strcmp(pDestExpr->u.zToken,\n+                                       pSrcExpr->u.zToken)!=0)\n@@ -122981,1 +126975,2 @@\n-  if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->pFKey!=0 ){\n+  assert( IsOrdinaryTable(pDest) );\n+  if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->u.tab.pFKey!=0 ){\n@@ -123003,0 +126998,1 @@\n+  sqlite3VdbeAddOp2(v, OP_Null, 0, regData);\n@@ -123038,5 +127034,7 @@\n-      sqlite3VdbeVerifyAbortable(v, onError);\n-      addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid);\n-      VdbeCoverage(v);\n-      sqlite3RowidConstraint(pParse, onError, pDest);\n-      sqlite3VdbeJumpHere(v, addr2);\n+      if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){\n+        sqlite3VdbeVerifyAbortable(v, onError);\n+        addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid);\n+        VdbeCoverage(v);\n+        sqlite3RowidConstraint(pParse, onError, pDest);\n+        sqlite3VdbeJumpHere(v, addr2);\n+      }\n@@ -123050,0 +127048,1 @@\n+\n@@ -123052,1 +127051,1 @@\n-      insFlags = OPFLAG_APPEND|OPFLAG_USESEEKRESULT;\n+      insFlags = OPFLAG_APPEND|OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;\n@@ -123054,1 +127053,14 @@\n-      insFlags = OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND;\n+      insFlags = OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND|OPFLAG_PREFORMAT;\n+    }\n+#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n+    if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){\n+      sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);\n+      insFlags &= ~OPFLAG_PREFORMAT;\n+    }else\n+#endif\n+    {\n+      sqlite3VdbeAddOp3(v, OP_RowCell, iDest, iSrc, regRowid);\n+    }\n+    sqlite3VdbeAddOp3(v, OP_Insert, iDest, regData, regRowid);\n+    if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){\n+      sqlite3VdbeChangeP4(v, -1, (char*)pDest, P4_TABLE);\n@@ -123056,3 +127068,0 @@\n-    sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);\n-    sqlite3VdbeAddOp4(v, OP_Insert, iDest, regData, regRowid,\n-                      (char*)pDest, P4_TABLE);\n@@ -123060,0 +127069,1 @@\n+\n@@ -123101,1 +127111,1 @@\n-        idxInsFlags = OPFLAG_USESEEKRESULT;\n+        idxInsFlags = OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;\n@@ -123103,0 +127113,1 @@\n+        sqlite3VdbeAddOp2(v, OP_RowCell, iDest, iSrc);\n@@ -123107,1 +127118,9 @@\n-    sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);\n+    if( idxInsFlags!=(OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT) ){\n+      sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);\n+      if( (db->mDbFlags & DBFLAG_Vacuum)==0\n+       && !HasRowid(pDest)\n+       && IsPrimaryKeyIndex(pDestIdx)\n+      ){\n+        codeWithoutRowidPreupdate(pParse, pDest, iDest, regData);\n+      }\n+    }\n@@ -123633,0 +127652,9 @@\n+  \/* Version 3.34.0 and later *\/\n+  int (*txn_state)(sqlite3*,const char*);\n+  \/* Version 3.36.1 and later *\/\n+  sqlite3_int64 (*changes64)(sqlite3*);\n+  sqlite3_int64 (*total_changes64)(sqlite3*);\n+  \/* Version 3.37.0 and later *\/\n+  int (*autovacuum_pages)(sqlite3*,\n+     unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),\n+     void*, void(*)(void*));\n@@ -123937,0 +127965,7 @@\n+\/* Version 3.34.0 and later *\/\n+#define sqlite3_txn_state              sqlite3_api->txn_state\n+\/* Version 3.36.1 and later *\/\n+#define sqlite3_changes64              sqlite3_api->changes64\n+#define sqlite3_total_changes64        sqlite3_api->total_changes64\n+\/* Version 3.37.0 and later *\/\n+#define sqlite3_autovacuum_pages       sqlite3_api->autovacuum_pages\n@@ -124419,0 +128454,7 @@\n+  \/* Version 3.34.0 and later *\/\n+  sqlite3_txn_state,\n+  \/* Version 3.36.1 and later *\/\n+  sqlite3_changes64,\n+  sqlite3_total_changes64,\n+  \/* Version 3.37.0 and later *\/\n+  sqlite3_autovacuum_pages,\n@@ -124454,1 +128496,1 @@\n-  u64 nMsg = 300 + sqlite3Strlen30(zFile);\n+  u64 nMsg = strlen(zFile);\n@@ -124488,0 +128530,6 @@\n+  \/* tag-20210611-1.  Some dlopen() implementations will segfault if given\n+  ** an oversize filename.  Most filesystems have a pathname limit of 4K,\n+  ** so limit the extension filename length to about twice that.\n+  ** https:\/\/sqlite.org\/forum\/forumpost\/08a0d6d9bf *\/\n+  if( nMsg>SQLITE_MAX_PATHLEN ) goto extension_not_found;\n+\n@@ -124497,11 +128545,1 @@\n-  if( handle==0 ){\n-    if( pzErrMsg ){\n-      *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n-      if( zErrmsg ){\n-        sqlite3_snprintf(nMsg, zErrmsg,\n-            \"unable to open shared library [%s]\", zFile);\n-        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);\n-      }\n-    }\n-    return SQLITE_ERROR;\n-  }\n+  if( handle==0 ) goto extension_not_found;\n@@ -124544,1 +128582,1 @@\n-      nMsg += sqlite3Strlen30(zEntry);\n+      nMsg += strlen(zEntry) + 300;\n@@ -124547,1 +128585,2 @@\n-        sqlite3_snprintf(nMsg, zErrmsg,\n+        assert( nMsg<0x7fffffff );  \/* zErrmsg would be NULL if not so *\/\n+        sqlite3_snprintf((int)nMsg, zErrmsg,\n@@ -124581,0 +128620,13 @@\n+\n+extension_not_found:\n+  if( pzErrMsg ){\n+    nMsg += 300;\n+    *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n+    if( zErrmsg ){\n+      assert( nMsg<0x7fffffff );  \/* zErrmsg would be NULL if not so *\/\n+      sqlite3_snprintf((int)nMsg, zErrmsg,\n+          \"unable to open shared library [%.*s]\", SQLITE_MAX_PATHLEN, zFile);\n+      sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);\n+    }\n+  }\n+  return SQLITE_ERROR;\n@@ -124630,1 +128682,1 @@\n-** This list is shared across threads.  The SQLITE_MUTEX_STATIC_MASTER\n+** This list is shared across threads.  The SQLITE_MUTEX_STATIC_MAIN\n@@ -124672,1 +128724,1 @@\n-    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n+    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n@@ -124710,1 +128762,1 @@\n-  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n+  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n@@ -124737,1 +128789,1 @@\n-    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n+    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n@@ -124767,1 +128819,1 @@\n-    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n+    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n@@ -124871,7 +128923,8 @@\n-#define PragTyp_TEMP_STORE                    38\n-#define PragTyp_TEMP_STORE_DIRECTORY          39\n-#define PragTyp_THREADS                       40\n-#define PragTyp_WAL_AUTOCHECKPOINT            41\n-#define PragTyp_WAL_CHECKPOINT                42\n-#define PragTyp_LOCK_STATUS                   43\n-#define PragTyp_STATS                         44\n+#define PragTyp_TABLE_LIST                    38\n+#define PragTyp_TEMP_STORE                    39\n+#define PragTyp_TEMP_STORE_DIRECTORY          40\n+#define PragTyp_THREADS                       41\n+#define PragTyp_WAL_AUTOCHECKPOINT            42\n+#define PragTyp_WAL_CHECKPOINT                43\n+#define PragTyp_LOCK_STATUS                   44\n+#define PragTyp_STATS                         45\n@@ -124910,37 +128963,43 @@\n-  \/*  15 *\/ \"seqno\",       \/* Used by: index_xinfo *\/\n-  \/*  16 *\/ \"cid\",\n-  \/*  17 *\/ \"name\",\n-  \/*  18 *\/ \"desc\",\n-  \/*  19 *\/ \"coll\",\n-  \/*  20 *\/ \"key\",\n-  \/*  21 *\/ \"name\",        \/* Used by: function_list *\/\n-  \/*  22 *\/ \"builtin\",\n-  \/*  23 *\/ \"type\",\n-  \/*  24 *\/ \"enc\",\n-  \/*  25 *\/ \"narg\",\n-  \/*  26 *\/ \"flags\",\n-  \/*  27 *\/ \"tbl\",         \/* Used by: stats *\/\n-  \/*  28 *\/ \"idx\",\n-  \/*  29 *\/ \"wdth\",\n-  \/*  30 *\/ \"hght\",\n-  \/*  31 *\/ \"flgs\",\n-  \/*  32 *\/ \"seq\",         \/* Used by: index_list *\/\n-  \/*  33 *\/ \"name\",\n-  \/*  34 *\/ \"unique\",\n-  \/*  35 *\/ \"origin\",\n-  \/*  36 *\/ \"partial\",\n-  \/*  37 *\/ \"table\",       \/* Used by: foreign_key_check *\/\n-  \/*  38 *\/ \"rowid\",\n-  \/*  39 *\/ \"parent\",\n-  \/*  40 *\/ \"fkid\",\n-                           \/* index_info reuses 15 *\/\n-  \/*  41 *\/ \"seq\",         \/* Used by: database_list *\/\n-  \/*  42 *\/ \"name\",\n-  \/*  43 *\/ \"file\",\n-  \/*  44 *\/ \"busy\",        \/* Used by: wal_checkpoint *\/\n-  \/*  45 *\/ \"log\",\n-  \/*  46 *\/ \"checkpointed\",\n-                           \/* collation_list reuses 32 *\/\n-  \/*  47 *\/ \"database\",    \/* Used by: lock_status *\/\n-  \/*  48 *\/ \"status\",\n-  \/*  49 *\/ \"cache_size\",  \/* Used by: default_cache_size *\/\n+  \/*  15 *\/ \"schema\",      \/* Used by: table_list *\/\n+  \/*  16 *\/ \"name\",\n+  \/*  17 *\/ \"type\",\n+  \/*  18 *\/ \"ncol\",\n+  \/*  19 *\/ \"wr\",\n+  \/*  20 *\/ \"strict\",\n+  \/*  21 *\/ \"seqno\",       \/* Used by: index_xinfo *\/\n+  \/*  22 *\/ \"cid\",\n+  \/*  23 *\/ \"name\",\n+  \/*  24 *\/ \"desc\",\n+  \/*  25 *\/ \"coll\",\n+  \/*  26 *\/ \"key\",\n+  \/*  27 *\/ \"name\",        \/* Used by: function_list *\/\n+  \/*  28 *\/ \"builtin\",\n+  \/*  29 *\/ \"type\",\n+  \/*  30 *\/ \"enc\",\n+  \/*  31 *\/ \"narg\",\n+  \/*  32 *\/ \"flags\",\n+  \/*  33 *\/ \"tbl\",         \/* Used by: stats *\/\n+  \/*  34 *\/ \"idx\",\n+  \/*  35 *\/ \"wdth\",\n+  \/*  36 *\/ \"hght\",\n+  \/*  37 *\/ \"flgs\",\n+  \/*  38 *\/ \"seq\",         \/* Used by: index_list *\/\n+  \/*  39 *\/ \"name\",\n+  \/*  40 *\/ \"unique\",\n+  \/*  41 *\/ \"origin\",\n+  \/*  42 *\/ \"partial\",\n+  \/*  43 *\/ \"table\",       \/* Used by: foreign_key_check *\/\n+  \/*  44 *\/ \"rowid\",\n+  \/*  45 *\/ \"parent\",\n+  \/*  46 *\/ \"fkid\",\n+                           \/* index_info reuses 21 *\/\n+  \/*  47 *\/ \"seq\",         \/* Used by: database_list *\/\n+  \/*  48 *\/ \"name\",\n+  \/*  49 *\/ \"file\",\n+  \/*  50 *\/ \"busy\",        \/* Used by: wal_checkpoint *\/\n+  \/*  51 *\/ \"log\",\n+  \/*  52 *\/ \"checkpointed\",\n+                           \/* collation_list reuses 38 *\/\n+  \/*  53 *\/ \"database\",    \/* Used by: lock_status *\/\n+  \/*  54 *\/ \"status\",\n+  \/*  55 *\/ \"cache_size\",  \/* Used by: default_cache_size *\/\n@@ -124948,1 +129007,1 @@\n-  \/*  50 *\/ \"timeout\",     \/* Used by: busy_timeout *\/\n+  \/*  56 *\/ \"timeout\",     \/* Used by: busy_timeout *\/\n@@ -124999,1 +129058,1 @@\n-  \/* ColNames:  *\/ 50, 1,\n+  \/* ColNames:  *\/ 56, 1,\n@@ -125038,1 +129097,1 @@\n-  \/* ColNames:  *\/ 32, 2,\n+  \/* ColNames:  *\/ 38, 2,\n@@ -125073,1 +129132,1 @@\n-  \/* ColNames:  *\/ 41, 3,\n+  \/* ColNames:  *\/ 47, 3,\n@@ -125080,1 +129139,1 @@\n-  \/* ColNames:  *\/ 49, 1,\n+  \/* ColNames:  *\/ 55, 1,\n@@ -125109,2 +129168,2 @@\n-  \/* ePragFlg:  *\/ PragFlg_NeedSchema|PragFlg_Result0,\n-  \/* ColNames:  *\/ 37, 4,\n+  \/* ePragFlg:  *\/ PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1|PragFlg_SchemaOpt,\n+  \/* ColNames:  *\/ 43, 4,\n@@ -125153,1 +129212,1 @@\n-  \/* ColNames:  *\/ 21, 6,\n+  \/* ColNames:  *\/ 27, 6,\n@@ -125182,1 +129241,1 @@\n-  \/* ColNames:  *\/ 15, 3,\n+  \/* ColNames:  *\/ 21, 3,\n@@ -125187,1 +129246,1 @@\n-  \/* ColNames:  *\/ 32, 5,\n+  \/* ColNames:  *\/ 38, 5,\n@@ -125192,1 +129251,1 @@\n-  \/* ColNames:  *\/ 15, 6,\n+  \/* ColNames:  *\/ 21, 6,\n@@ -125198,1 +129257,1 @@\n-  \/* ePragFlg:  *\/ PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1,\n+  \/* ePragFlg:  *\/ PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1|PragFlg_SchemaOpt,\n@@ -125232,1 +129291,1 @@\n-  \/* ColNames:  *\/ 47, 2,\n+  \/* ColNames:  *\/ 53, 2,\n@@ -125306,1 +129365,1 @@\n-  \/* ePragFlg:  *\/ PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1,\n+  \/* ePragFlg:  *\/ PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1|PragFlg_SchemaOpt,\n@@ -125371,1 +129430,1 @@\n-  \/* ColNames:  *\/ 27, 5,\n+  \/* ColNames:  *\/ 33, 5,\n@@ -125387,0 +129446,5 @@\n+ {\/* zName:     *\/ \"table_list\",\n+  \/* ePragTyp:  *\/ PragTyp_TABLE_LIST,\n+  \/* ePragFlg:  *\/ PragFlg_NeedSchema|PragFlg_Result1,\n+  \/* ColNames:  *\/ 15, 6,\n+  \/* iArg:      *\/ 0 },\n@@ -125462,1 +129526,1 @@\n-  \/* ColNames:  *\/ 44, 3,\n+  \/* ColNames:  *\/ 50, 3,\n@@ -125473,1 +129537,1 @@\n-\/* Number of pragmas: 67 on by default, 77 total. *\/\n+\/* Number of pragmas: 68 on by default, 78 total. *\/\n@@ -125579,1 +129643,3 @@\n-    if( !db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt) ){\n+    if( !db->autoCommit\n+     || sqlite3BtreeTxnState(db->aDb[1].pBt)!=SQLITE_TXN_NONE\n+    ){\n@@ -125913,1 +129979,5 @@\n-  if( pPragma==0 ) goto pragma_out;\n+  if( pPragma==0 ){\n+    \/* IMP: R-43042-22504 No error messages are generated if an\n+    ** unknown pragma is issued. *\/\n+    goto pragma_out;\n+  }\n@@ -126059,0 +130129,1 @@\n+    i64 x = 0;\n@@ -126064,2 +130135,7 @@\n-      sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg,\n-                        sqlite3AbsInt32(sqlite3Atoi(zRight)));\n+      if( zRight && sqlite3DecOrHexToI64(zRight,&x)==0 ){\n+        if( x<0 ) x = 0;\n+        else if( x>0xfffffffe ) x = 0xfffffffe;\n+      }else{\n+        x = 0;\n+      }\n+      sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg, (int)x);\n@@ -126557,0 +130633,8 @@\n+        if( (mask & SQLITE_WriteSchema)!=0\n+         && sqlite3_stricmp(zRight, \"reset\")==0\n+        ){\n+          \/* IMP: R-60817-01178 If the argument is \"RESET\" then schema\n+          ** writing is disabled (as with \"PRAGMA writable_schema=OFF\") and,\n+          ** in addition, the schema is reloaded. *\/\n+          sqlite3ResetAllSchemasOfConnection(db);\n+        }\n@@ -126586,0 +130670,1 @@\n+    sqlite3CodeVerifyNamedSchema(pParse, zDb);\n@@ -126588,1 +130673,0 @@\n-      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n@@ -126594,1 +130678,0 @@\n-      sqlite3CodeVerifySchema(pParse, iTabDb);\n@@ -126598,0 +130681,1 @@\n+        const Expr *pColExpr;\n@@ -126618,1 +130702,4 @@\n-        assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN || isHidden>=2 );\n+        pColExpr = sqlite3ColumnExpr(pTab,pCol);\n+        assert( pColExpr==0 || pColExpr->op==TK_SPAN || isHidden>=2 );\n+        assert( pColExpr==0 || !ExprHasProperty(pColExpr, EP_IntValue)\n+                  || isHidden>=2 );\n@@ -126621,1 +130708,1 @@\n-               pCol->zName,\n+               pCol->zCnName,\n@@ -126624,1 +130711,1 @@\n-               pCol->pDflt && isHidden<2 ? pCol->pDflt->u.zToken : 0,\n+               (isHidden>=2 || pColExpr==0) ? 0 : pColExpr->u.zToken,\n@@ -126632,0 +130719,75 @@\n+  \/*\n+  **   PRAGMA table_list\n+  **\n+  ** Return a single row for each table, virtual table, or view in the\n+  ** entire schema.\n+  **\n+  ** schema:     Name of attached database hold this table\n+  ** name:       Name of the table itself\n+  ** type:       \"table\", \"view\", \"virtual\", \"shadow\"\n+  ** ncol:       Number of columns\n+  ** wr:         True for a WITHOUT ROWID table\n+  ** strict:     True for a STRICT table\n+  *\/\n+  case PragTyp_TABLE_LIST: {\n+    int ii;\n+    pParse->nMem = 6;\n+    sqlite3CodeVerifyNamedSchema(pParse, zDb);\n+    for(ii=0; ii<db->nDb; ii++){\n+      HashElem *k;\n+      Hash *pHash;\n+      int initNCol;\n+      if( zDb && sqlite3_stricmp(zDb, db->aDb[ii].zDbSName)!=0 ) continue;\n+\n+      \/* Ensure that the Table.nCol field is initialized for all views\n+      ** and virtual tables.  Each time we initialize a Table.nCol value\n+      ** for a table, that can potentially disrupt the hash table, so restart\n+      ** the initialization scan.\n+      *\/\n+      pHash = &db->aDb[ii].pSchema->tblHash;\n+      initNCol = sqliteHashCount(pHash);\n+      while( initNCol-- ){\n+        for(k=sqliteHashFirst(pHash); 1; k=sqliteHashNext(k) ){\n+          Table *pTab;\n+          if( k==0 ){ initNCol = 0; break; }\n+          pTab = sqliteHashData(k);\n+          if( pTab->nCol==0 ){\n+            char *zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\"\", pTab->zName);\n+            if( zSql ){\n+              sqlite3_stmt *pDummy = 0;\n+              (void)sqlite3_prepare(db, zSql, -1, &pDummy, 0);\n+              (void)sqlite3_finalize(pDummy);\n+              sqlite3DbFree(db, zSql);\n+            }\n+            pHash = &db->aDb[ii].pSchema->tblHash;\n+            break;\n+          }\n+        }\n+      }\n+\n+      for(k=sqliteHashFirst(pHash); k; k=sqliteHashNext(k) ){\n+        Table *pTab = sqliteHashData(k);\n+        const char *zType;\n+        if( zRight && sqlite3_stricmp(zRight, pTab->zName)!=0 ) continue;\n+        if( IsView(pTab) ){\n+          zType = \"view\";\n+        }else if( IsVirtual(pTab) ){\n+          zType = \"virtual\";\n+        }else if( pTab->tabFlags & TF_Shadow ){\n+          zType = \"shadow\";\n+        }else{\n+          zType = \"table\";\n+        }\n+        sqlite3VdbeMultiLoad(v, 1, \"sssiii\",\n+           db->aDb[ii].zDbSName,\n+           sqlite3PreferredTableName(pTab->zName),\n+           zType,\n+           pTab->nCol,\n+           (pTab->tabFlags & TF_WithoutRowid)!=0,\n+           (pTab->tabFlags & TF_Strict)!=0\n+        );\n+      }\n+    }\n+  }\n+  break;\n+\n@@ -126641,1 +130803,1 @@\n-           pTab->zName,\n+           sqlite3PreferredTableName(pTab->zName),\n@@ -126691,1 +130853,1 @@\n-                             cnum<0 ? 0 : pTab->aCol[cnum].zName);\n+                             cnum<0 ? 0 : pTab->aCol[cnum].zCnName);\n@@ -126760,0 +130922,1 @@\n+        assert( p->funcFlags & SQLITE_FUNC_BUILTIN );\n@@ -126765,0 +130928,1 @@\n+      assert( (p->funcFlags & SQLITE_FUNC_BUILTIN)==0 );\n@@ -126798,2 +130962,2 @@\n-    if( pTab ){\n-      pFK = pTab->pFKey;\n+    if( pTab && IsOrdinaryTable(pTab) ){\n+      pFK = pTab->u.tab.pFKey;\n@@ -126812,1 +130976,1 @@\n-                   pTab->aCol[pFK->aCol[j].iFrom].zName,\n+                   pTab->aCol[pFK->aCol[j].iFrom].zCnName,\n@@ -126851,1 +131015,0 @@\n-      int iTabDb;\n@@ -126859,4 +131022,5 @@\n-      if( pTab==0 || pTab->pFKey==0 ) continue;\n-      iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n-      sqlite3CodeVerifySchema(pParse, iTabDb);\n-      sqlite3TableLock(pParse, iTabDb, pTab->tnum, 0, pTab->zName);\n+      if( pTab==0 || !IsOrdinaryTable(pTab) || pTab->u.tab.pFKey==0 ) continue;\n+      iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n+      zDb = db->aDb[iDb].zDbSName;\n+      sqlite3CodeVerifySchema(pParse, iDb);\n+      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n@@ -126864,1 +131028,1 @@\n-      sqlite3OpenTable(pParse, 0, iTabDb, pTab, OP_OpenRead);\n+      sqlite3OpenTable(pParse, 0, iDb, pTab, OP_OpenRead);\n@@ -126866,1 +131030,2 @@\n-      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n+      assert( IsOrdinaryTable(pTab) );\n+      for(i=1, pFK=pTab->u.tab.pFKey; pFK; i++, pFK=pFK->pNextFrom){\n@@ -126870,1 +131035,1 @@\n-        sqlite3TableLock(pParse, iTabDb, pParent->tnum, 0, pParent->zName);\n+        sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);\n@@ -126874,1 +131039,1 @@\n-            sqlite3OpenTable(pParse, i, iTabDb, pParent, OP_OpenRead);\n+            sqlite3OpenTable(pParse, i, iDb, pParent, OP_OpenRead);\n@@ -126876,1 +131041,1 @@\n-            sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iTabDb);\n+            sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iDb);\n@@ -126888,1 +131053,2 @@\n-      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n+      assert( IsOrdinaryTable(pTab) );\n+      for(i=1, pFK=pTab->u.tab.pFKey; pFK; i++, pFK=pFK->pNextFrom){\n@@ -126894,1 +131060,1 @@\n-          assert( x==0 );\n+          assert( x==0 || db->mallocFailed );\n@@ -126902,0 +131068,1 @@\n+        if( regRow+pFK->nCol>pParse->nMem ) pParse->nMem = regRow+pFK->nCol;\n@@ -126919,1 +131086,1 @@\n-          assert( pFK->nCol==1 );\n+          assert( pFK->nCol==1 || db->mallocFailed );\n@@ -126969,0 +131136,12 @@\n+  **\n+  ** The maximum nubmer of errors is 100 by default.  A different default\n+  ** can be specified using a numeric parameter N.\n+  **\n+  ** Or, the parameter N can be the name of a table.  In that case, only\n+  ** the one table named is verified.  The freelist is only verified if\n+  ** the named table is \"sqlite_schema\" (or one of its aliases).\n+  **\n+  ** All schemas are checked by default.  To check just a single\n+  ** schema, use the form:\n+  **\n+  **      PRAGMA schema.integrity_check;\n@@ -126972,0 +131151,1 @@\n+    Table *pObjTab = 0;     \/* Check only this one table, if not NULL *\/\n@@ -126994,3 +131174,7 @@\n-      sqlite3GetInt32(zRight, &mxErr);\n-      if( mxErr<=0 ){\n-        mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n+      if( sqlite3GetInt32(zRight, &mxErr) ){\n+        if( mxErr<=0 ){\n+          mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n+        }\n+      }else{\n+        pObjTab = sqlite3LocateTable(pParse, 0, zRight,\n+                      iDb>=0 ? db->aDb[iDb].zDbSName : 0);\n@@ -127025,0 +131209,1 @@\n+        if( pObjTab && pObjTab!=pTab ) continue;\n@@ -127029,0 +131214,2 @@\n+      if( cnt==0 ) continue;\n+      if( pObjTab ) cnt++;\n@@ -127031,1 +131218,3 @@\n-      for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n+      cnt = 0;\n+      if( pObjTab ) aRoot[++cnt] = 0;\n+      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n@@ -127034,0 +131223,1 @@\n+        if( pObjTab && pObjTab!=pTab ) continue;\n@@ -127065,0 +131255,1 @@\n+        int bStrict;\n@@ -127066,1 +131257,2 @@\n-        if( pTab->tnum<1 ) continue;  \/* Skip VIEWs or VIRTUAL TABLEs *\/\n+        if( !IsOrdinaryTable(pTab) ) continue;\n+        if( pObjTab && pObjTab!=pTab ) continue;\n@@ -127085,0 +131277,1 @@\n+          VdbeComment((v, \"(right-most column)\"));\n@@ -127086,1 +131279,3 @@\n-        \/* Verify that all NOT NULL columns really are NOT NULL *\/\n+        \/* Verify that all NOT NULL columns really are NOT NULL.  At the\n+        ** same time verify the type of the content of STRICT tables *\/\n+        bStrict = (pTab->tabFlags & TF_Strict)!=0;\n@@ -127089,1 +131284,2 @@\n-          int jmp2;\n+          Column *pCol = pTab->aCol + j;\n+          int doError, jmp2;\n@@ -127091,1 +131287,2 @@\n-          if( pTab->aCol[j].notNull==0 ) continue;\n+          if( pCol->notNull==0 && !bStrict ) continue;\n+          doError = bStrict ? sqlite3VdbeMakeLabel(pParse) : 0;\n@@ -127096,6 +131293,26 @@\n-          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n-          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n-                              pTab->aCol[j].zName);\n-          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n-          integrityCheckResultRow(v);\n-          sqlite3VdbeJumpHere(v, jmp2);\n+          if( pCol->notNull ){\n+            jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n+            zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n+                                pCol->zCnName);\n+            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n+            if( bStrict && pCol->eCType!=COLTYPE_ANY ){\n+              sqlite3VdbeGoto(v, doError);\n+            }else{\n+              integrityCheckResultRow(v);\n+            }\n+            sqlite3VdbeJumpHere(v, jmp2);\n+          }\n+          if( (pTab->tabFlags & TF_Strict)!=0\n+           && pCol->eCType!=COLTYPE_ANY\n+          ){\n+            jmp2 = sqlite3VdbeAddOp3(v, OP_IsNullOrType, 3, 0,\n+                                     sqlite3StdTypeMap[pCol->eCType-1]);\n+            VdbeCoverage(v);\n+            zErr = sqlite3MPrintf(db, \"non-%s value in %s.%s\",\n+                                  sqlite3StdType[pCol->eCType-1],\n+                                  pTab->zName, pTab->aCol[j].zCnName);\n+            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n+            sqlite3VdbeResolveLabel(v, doError);\n+            integrityCheckResultRow(v);\n+            sqlite3VdbeJumpHere(v, jmp2);\n+          }\n@@ -127338,0 +131555,1 @@\n+      aOp[1].p5 = 1;\n@@ -127385,1 +131603,1 @@\n-    int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);\n+    int iBt = (pId2->z?iDb:SQLITE_MAX_DB);\n@@ -127634,1 +131852,1 @@\n-     && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK\n+     && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK \/* IMP: R-40975-20399 *\/\n@@ -127639,1 +131857,1 @@\n-    returnSingleInt(v, db->nAnalysisLimit);\n+    returnSingleInt(v, db->nAnalysisLimit); \/* IMP: R-57594-65522 *\/\n@@ -128033,1 +132251,1 @@\n-  const char *zObj,    \/* Object being parsed at the point of error *\/\n+  char **azObj,        \/* Type and name of object being parsed *\/\n@@ -128041,2 +132259,11 @@\n-  }else if( pData->mInitFlags & INITFLAG_AlterTable ){\n-    *pData->pzErrMsg = sqlite3DbStrDup(db, zExtra);\n+  }else if( pData->mInitFlags & (INITFLAG_AlterMask) ){\n+    static const char *azAlterType[] = {\n+       \"rename\",\n+       \"drop column\",\n+       \"add column\"\n+    };\n+    *pData->pzErrMsg = sqlite3MPrintf(db,\n+        \"error in %s %s after %s: %s\", azObj[0], azObj[1],\n+        azAlterType[(pData->mInitFlags&INITFLAG_AlterMask)-1],\n+        zExtra\n+    );\n@@ -128048,1 +132275,1 @@\n-    if( zObj==0 ) zObj = \"?\";\n+    const char *zObj = azObj[1] ? azObj[1] : \"?\";\n@@ -128104,0 +132331,1 @@\n+  if( argv==0 ) return 0;   \/* Might happen if EMPTY_RESULT_CALLBACKS are on *\/\n@@ -128106,1 +132334,1 @@\n-    corruptSchema(pData, argv[1], 0);\n+    corruptSchema(pData, argv, 0);\n@@ -128111,1 +132339,0 @@\n-  if( argv==0 ) return 0;   \/* Might happen if EMPTY_RESULT_CALLBACKS are on *\/\n@@ -128113,2 +132340,4 @@\n-    corruptSchema(pData, argv[1], 0);\n-  }else if( sqlite3_strnicmp(argv[4],\"create \",7)==0 ){\n+    corruptSchema(pData, argv, 0);\n+  }else if( argv[4]\n+         && 'c'==sqlite3UpperToLower[(unsigned char)argv[4][0]]\n+         && 'r'==sqlite3UpperToLower[(unsigned char)argv[4][1]] ){\n@@ -128119,0 +132348,5 @@\n+    **\n+    ** No other valid SQL statement, other than the variable CREATE statements,\n+    ** can begin with the letters \"C\" and \"R\".  Thus, it is not possible run\n+    ** any other kind of statement while parsing the schema, even a corrupt\n+    ** schema.\n@@ -128127,1 +132361,7 @@\n-    db->init.newTnum = sqlite3Atoi(argv[3]);\n+    if( sqlite3GetUInt32(argv[3], &db->init.newTnum)==0\n+     || (db->init.newTnum>pData->mxPage && pData->mxPage>0)\n+    ){\n+      if( sqlite3Config.bExtraSchemaChecks ){\n+        corruptSchema(pData, argv, \"invalid rootpage\");\n+      }\n+    }\n@@ -128129,1 +132369,1 @@\n-    db->init.azInit = argv;\n+    db->init.azInit = (const char**)argv;\n@@ -128144,1 +132384,1 @@\n-          corruptSchema(pData, argv[1], sqlite3_errmsg(db));\n+          corruptSchema(pData, argv, sqlite3_errmsg(db));\n@@ -128148,0 +132388,1 @@\n+    db->init.azInit = sqlite3StdType; \/* Any array of string ptrs will do *\/\n@@ -128150,1 +132391,1 @@\n-    corruptSchema(pData, argv[1], 0);\n+    corruptSchema(pData, argv, 0);\n@@ -128160,2 +132401,4 @@\n-    if( pIndex==0\n-     || sqlite3GetInt32(argv[3],&pIndex->tnum)==0\n+    if( pIndex==0 ){\n+      corruptSchema(pData, argv, \"orphan index\");\n+    }else\n+    if( sqlite3GetUInt32(argv[3],&pIndex->tnum)==0\n@@ -128163,0 +132406,1 @@\n+     || pIndex->tnum>pData->mxPage\n@@ -128165,1 +132409,3 @@\n-      corruptSchema(pData, argv[1], pIndex?\"invalid rootpage\":\"orphan index\");\n+      if( sqlite3Config.bExtraSchemaChecks ){\n+        corruptSchema(pData, argv, \"invalid rootpage\");\n+      }\n@@ -128189,1 +132435,1 @@\n-  const char *zMasterName;\n+  const char *zSchemaTabName;\n@@ -128201,2 +132447,2 @@\n-  \/* Construct the in-memory representation schema tables (sqlite_master or\n-  ** sqlite_temp_master) by invoking the parser directly.  The appropriate\n+  \/* Construct the in-memory representation schema tables (sqlite_schema or\n+  ** sqlite_temp_schema) by invoking the parser directly.  The appropriate\n@@ -128207,1 +132453,1 @@\n-  azArg[1] = zMasterName = SCHEMA_TABLE(iDb);\n+  azArg[1] = zSchemaTabName = SCHEMA_TABLE(iDb);\n@@ -128219,0 +132465,1 @@\n+  initData.mxPage = 0;\n@@ -128240,1 +132487,1 @@\n-  if( !sqlite3BtreeIsInReadTrans(pDb->pBt) ){\n+  if( sqlite3BtreeTxnState(pDb->pBt)==SQLITE_TXN_NONE ){\n@@ -128341,0 +132588,1 @@\n+  initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);\n@@ -128345,1 +132593,1 @@\n-        db->aDb[iDb].zDbSName, zMasterName);\n+        db->aDb[iDb].zDbSName, zSchemaTabName);\n@@ -128365,0 +132613,1 @@\n+  assert( pDb == &(db->aDb[iDb]) );\n@@ -128368,1 +132617,2 @@\n-  }\n+    pDb = &db->aDb[iDb];\n+  }else\n@@ -128370,7 +132620,9 @@\n-    \/* Black magic: If the SQLITE_NoSchemaError flag is set, then consider\n-    ** the schema loaded, even if errors occurred. In this situation the\n-    ** current sqlite3_prepare() operation will fail, but the following one\n-    ** will attempt to compile the supplied statement against whatever subset\n-    ** of the schema was loaded before the error occurred. The primary\n-    ** purpose of this is to allow access to the sqlite_master table\n-    ** even when its contents have been corrupted.\n+    \/* Hack: If the SQLITE_NoSchemaError flag is set, then consider\n+    ** the schema loaded, even if errors (other than OOM) occurred. In\n+    ** this situation the current sqlite3_prepare() operation will fail,\n+    ** but the following one will attempt to compile the supplied statement\n+    ** against whatever subset of the schema was loaded before the error\n+    ** occurred.\n+    **\n+    ** The primary purpose of this is to allow access to the sqlite_schema\n+    ** table even when its contents have been corrupted.\n@@ -128482,1 +132734,1 @@\n-    if( !sqlite3BtreeIsInReadTrans(pBt) ){\n+    if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_NONE ){\n@@ -128486,0 +132738,1 @@\n+        pParse->rc = SQLITE_NOMEM;\n@@ -128516,1 +132769,1 @@\n-  int i = -1000000;\n+  int i = -32768;\n@@ -128518,1 +132771,1 @@\n-  \/* If pSchema is NULL, then return -1000000. This happens when code in\n+  \/* If pSchema is NULL, then return -32768. This happens when code in\n@@ -128523,2 +132776,2 @@\n-  ** We return -1000000 instead of the more usual -1 simply because using\n-  ** -1000000 as the incorrect index into db->aDb[] is much\n+  ** We return -32768 instead of the more usual -1 simply because using\n+  ** -32768 as the incorrect index into db->aDb[] is much\n@@ -128526,1 +132779,2 @@\n-  ** statements too, but it never hurts to play the odds).\n+  ** statements too, but it never hurts to play the odds) and\n+  ** -32768 will still fit into a 16-bit signed integer.\n@@ -128541,9 +132795,0 @@\n-\/*\n-** Deallocate a single AggInfo object\n-*\/\n-static void agginfoFree(sqlite3 *db, AggInfo *p){\n-  sqlite3DbFree(db, p->aCol);\n-  sqlite3DbFree(db, p->aFunc);\n-  sqlite3DbFree(db, p);\n-}\n-\n@@ -128555,5 +132800,5 @@\n-  AggInfo *pThis = pParse->pAggList;\n-  while( pThis ){\n-    AggInfo *pNext = pThis->pNext;\n-    agginfoFree(db, pThis);\n-    pThis = pNext;\n+  while( pParse->pCleanup ){\n+    ParseCleanup *pCleanup = pParse->pCleanup;\n+    pParse->pCleanup = pCleanup->pNext;\n+    pCleanup->xCleanup(db, pCleanup->pPtr);\n+    sqlite3DbFreeNN(db, pCleanup);\n@@ -128562,1 +132807,3 @@\n-  sqlite3ExprListDelete(db, pParse->pConstExpr);\n+  if( pParse->pConstExpr ){\n+    sqlite3ExprListDelete(db, pParse->pConstExpr);\n+  }\n@@ -128571,0 +132818,49 @@\n+\/*\n+** Add a new cleanup operation to a Parser.  The cleanup should happen when\n+** the parser object is destroyed.  But, beware: the cleanup might happen\n+** immediately.\n+**\n+** Use this mechanism for uncommon cleanups.  There is a higher setup\n+** cost for this mechansim (an extra malloc), so it should not be used\n+** for common cleanups that happen on most calls.  But for less\n+** common cleanups, we save a single NULL-pointer comparison in\n+** sqlite3ParserReset(), which reduces the total CPU cycle count.\n+**\n+** If a memory allocation error occurs, then the cleanup happens immediately.\n+** When either SQLITE_DEBUG or SQLITE_COVERAGE_TEST are defined, the\n+** pParse->earlyCleanup flag is set in that case.  Calling code show verify\n+** that test cases exist for which this happens, to guard against possible\n+** use-after-free errors following an OOM.  The preferred way to do this is\n+** to immediately follow the call to this routine with:\n+**\n+**       testcase( pParse->earlyCleanup );\n+**\n+** This routine returns a copy of its pPtr input (the third parameter)\n+** except if an early cleanup occurs, in which case it returns NULL.  So\n+** another way to check for early cleanup is to check the return value.\n+** Or, stop using the pPtr parameter with this call and use only its\n+** return value thereafter.  Something like this:\n+**\n+**       pObj = sqlite3ParserAddCleanup(pParse, destructor, pObj);\n+*\/\n+SQLITE_PRIVATE void *sqlite3ParserAddCleanup(\n+  Parse *pParse,                      \/* Destroy when this Parser finishes *\/\n+  void (*xCleanup)(sqlite3*,void*),   \/* The cleanup routine *\/\n+  void *pPtr                          \/* Pointer to object to be cleaned up *\/\n+){\n+  ParseCleanup *pCleanup = sqlite3DbMallocRaw(pParse->db, sizeof(*pCleanup));\n+  if( pCleanup ){\n+    pCleanup->pNext = pParse->pCleanup;\n+    pParse->pCleanup = pCleanup;\n+    pCleanup->pPtr = pPtr;\n+    pCleanup->xCleanup = xCleanup;\n+  }else{\n+    xCleanup(pParse->db, pPtr);\n+    pPtr = 0;\n+#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)\n+    pParse->earlyCleanup = 1;\n+#endif\n+  }\n+  return pPtr;\n+}\n+\n@@ -128669,6 +132965,0 @@\n-  if( sParse.rc==SQLITE_DONE ){\n-    sParse.rc = SQLITE_OK;\n-  }\n-  if( sParse.checkSchema ){\n-    schemaIsValid(&sParse);\n-  }\n@@ -128684,0 +132974,1 @@\n+    sParse.checkSchema = 0;\n@@ -128685,4 +132976,15 @@\n-  rc = sParse.rc;\n-  if( rc!=SQLITE_OK ){\n-    if( sParse.pVdbe ) sqlite3VdbeFinalize(sParse.pVdbe);\n-    assert(!(*ppStmt));\n+  if( sParse.rc!=SQLITE_OK && sParse.rc!=SQLITE_DONE ){\n+    if( sParse.checkSchema && db->init.busy==0 ){\n+      schemaIsValid(&sParse);\n+    }\n+    if( sParse.pVdbe ){\n+      sqlite3VdbeFinalize(sParse.pVdbe);\n+    }\n+    assert( 0==(*ppStmt) );\n+    rc = sParse.rc;\n+    if( zErrMsg ){\n+      sqlite3ErrorWithMsg(db, rc, \"%s\", zErrMsg);\n+      sqlite3DbFree(db, zErrMsg);\n+    }else{\n+      sqlite3Error(db, rc);\n+    }\n@@ -128690,0 +132992,1 @@\n+    assert( zErrMsg==0 );\n@@ -128691,0 +132994,2 @@\n+    rc = SQLITE_OK;\n+    sqlite3ErrorClear(db);\n@@ -128693,6 +132998,0 @@\n-  if( zErrMsg ){\n-    sqlite3ErrorWithMsg(db, rc, \"%s\", zErrMsg);\n-    sqlite3DbFree(db, zErrMsg);\n-  }else{\n-    sqlite3Error(db, rc);\n-  }\n@@ -128739,0 +133038,1 @@\n+    if( rc==SQLITE_OK || db->mallocFailed ) break;\n@@ -128744,0 +133044,1 @@\n+  db->busyHandler.nBusy = 0;\n@@ -128754,1 +133055,1 @@\n-** locked the sqlite3_master table, return SQLITE_LOCKED. If any other error\n+** locked the sqlite3_schema table, return SQLITE_LOCKED. If any other error\n@@ -128972,14 +133273,0 @@\n-\/*\n-** Trace output macros\n-*\/\n-#if SELECTTRACE_ENABLED\n-\/***\/ int sqlite3SelectTrace = 0;\n-# define SELECTTRACE(K,P,S,X)  \\\n-  if(sqlite3SelectTrace&(K))   \\\n-    sqlite3DebugPrintf(\"%u\/%d\/%p: \",(S)->selId,(P)->addrExplain,(S)),\\\n-    sqlite3DebugPrintf X\n-#else\n-# define SELECTTRACE(K,P,S,X)\n-#endif\n-\n-\n@@ -129057,0 +133344,1 @@\n+    if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);\n@@ -129061,0 +133349,4 @@\n+    while( p->pWin ){\n+      assert( p->pWin->ppThis==&p->pWin );\n+      sqlite3WindowUnlinkFromSelect(p->pWin);\n+    }\n@@ -129062,1 +133354,0 @@\n-    if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);\n@@ -129075,0 +133366,1 @@\n+  pDest->iSDParm2 = 0;\n@@ -129096,1 +133388,1 @@\n-  Select *pNew;\n+  Select *pNew, *pAllocated;\n@@ -129098,1 +133390,1 @@\n-  pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );\n+  pAllocated = pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );\n@@ -129132,1 +133424,1 @@\n-    pNew = 0;\n+    pAllocated = 0;\n@@ -129136,2 +133428,1 @@\n-  assert( pNew!=&standin );\n-  return pNew;\n+  return pAllocated;\n@@ -129148,15 +133439,0 @@\n-\/*\n-** Delete all the substructure for p, but keep p allocated.  Redefine\n-** p to be a single SELECT where every column of the result set has a\n-** value of NULL.\n-*\/\n-SQLITE_PRIVATE void sqlite3SelectReset(Parse *pParse, Select *p){\n-  if( ALWAYS(p) ){\n-    clearSelect(pParse->db, p, 0);\n-    memset(&p->iLimit, 0, sizeof(Select) - offsetof(Select,iLimit));\n-    p->pEList = sqlite3ExprListAppend(pParse, 0,\n-                     sqlite3ExprAlloc(pParse->db,TK_NULL,0,0));\n-    p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(SrcList));\n-  }\n-}\n-\n@@ -129249,1 +133525,1 @@\n-static int columnIndex(Table *pTab, const char *zCol){\n+SQLITE_PRIVATE int sqlite3ColumnIndex(Table *pTab, const char *zCol){\n@@ -129251,2 +133527,4 @@\n-  for(i=0; i<pTab->nCol; i++){\n-    if( sqlite3StrICmp(pTab->aCol[i].zName, zCol)==0 ) return i;\n+  u8 h = sqlite3StrIHash(zCol);\n+  Column *pCol;\n+  for(pCol=pTab->aCol, i=0; i<pTab->nCol; pCol++, i++){\n+    if( pCol->hName==h && sqlite3StrICmp(pCol->zCnName, zCol)==0 ) return i;\n@@ -129279,1 +133557,1 @@\n-    iCol = columnIndex(pSrc->a[i].pTab, zCol);\n+    iCol = sqlite3ColumnIndex(pSrc->a[i].pTab, zCol);\n@@ -129328,0 +133606,3 @@\n+  assert( pE2!=0 || pEq==0 );  \/* Due to db->mallocFailed test\n+                               ** in sqlite3DbMallocRawNN() called from\n+                               ** sqlite3PExpr(). *\/\n@@ -129332,1 +133613,1 @@\n-    pEq->iRightJoinTable = (i16)pE2->iTable;\n+    pEq->iRightJoinTable = pE2->iTable;\n@@ -129368,5 +133649,8 @@\n-    p->iRightJoinTable = (i16)iTable;\n-    if( p->op==TK_FUNCTION && p->x.pList ){\n-      int i;\n-      for(i=0; i<p->x.pList->nExpr; i++){\n-        sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n+    p->iRightJoinTable = iTable;\n+    if( p->op==TK_FUNCTION ){\n+      assert( ExprUseXList(p) );\n+      if( p->x.pList ){\n+        int i;\n+        for(i=0; i<p->x.pList->nExpr; i++){\n+          sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n+        }\n@@ -129392,4 +133676,10 @@\n-    if( p->op==TK_FUNCTION && p->x.pList ){\n-      int i;\n-      for(i=0; i<p->x.pList->nExpr; i++){\n-        unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n+    if( p->op==TK_COLUMN && p->iTable==iTable ){\n+      ExprClearProperty(p, EP_CanBeNull);\n+    }\n+    if( p->op==TK_FUNCTION ){\n+      assert( ExprUseXList(p) );\n+      if( p->x.pList ){\n+        int i;\n+        for(i=0; i<p->x.pList->nExpr; i++){\n+          unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n+        }\n@@ -129420,2 +133710,2 @@\n-  struct SrcList_item *pLeft;     \/* Left table being joined *\/\n-  struct SrcList_item *pRight;    \/* Right table being joined *\/\n+  SrcItem *pLeft;                 \/* Left table being joined *\/\n+  SrcItem *pRight;                \/* Right table being joined *\/\n@@ -129448,1 +133738,1 @@\n-        zName = pRightTab->aCol[j].zName;\n+        zName = pRightTab->aCol[j].zCnName;\n@@ -129489,1 +133779,1 @@\n-        iRightCol = columnIndex(pRightTab, zName);\n+        iRightCol = sqlite3ColumnIndex(pRightTab, zName);\n@@ -129719,4 +134009,5 @@\n-** Add code that will check to make sure the N registers starting at iMem\n-** form a distinct entry.  iTab is a sorting index that holds previously\n-** seen combinations of the N values.  A new entry is made in iTab\n-** if the current N values are new.\n+** Add code that will check to make sure the array of registers starting at\n+** iMem form a distinct entry. This is used by both \"SELECT DISTINCT ...\" and\n+** distinct aggregates (\"SELECT count(DISTINCT <expr>) ...\"). Three strategies\n+** are available. Which is used depends on the value of parameter eTnctType,\n+** as follows:\n@@ -129724,4 +134015,37 @@\n-** A jump to addrRepeat is made and the N+1 values are popped from the\n-** stack if the top N elements are not distinct.\n-*\/\n-static void codeDistinct(\n+**   WHERE_DISTINCT_UNORDERED\/WHERE_DISTINCT_NOOP:\n+**     Build an ephemeral table that contains all entries seen before and\n+**     skip entries which have been seen before.\n+**\n+**     Parameter iTab is the cursor number of an ephemeral table that must\n+**     be opened before the VM code generated by this routine is executed.\n+**     The ephemeral cursor table is queried for a record identical to the\n+**     record formed by the current array of registers. If one is found,\n+**     jump to VM address addrRepeat. Otherwise, insert a new record into\n+**     the ephemeral cursor and proceed.\n+**\n+**     The returned value in this case is a copy of parameter iTab.\n+**\n+**   WHERE_DISTINCT_ORDERED:\n+**     In this case rows are being delivered sorted order. The ephermal\n+**     table is not required. Instead, the current set of values\n+**     is compared against previous row. If they match, the new row\n+**     is not distinct and control jumps to VM address addrRepeat. Otherwise,\n+**     the VM program proceeds with processing the new row.\n+**\n+**     The returned value in this case is the register number of the first\n+**     in an array of registers used to store the previous result row so that\n+**     it can be compared to the next. The caller must ensure that this\n+**     register is initialized to NULL.  (The fixDistinctOpenEph() routine\n+**     will take care of this initialization.)\n+**\n+**   WHERE_DISTINCT_UNIQUE:\n+**     In this case it has already been determined that the rows are distinct.\n+**     No special action is required. The return value is zero.\n+**\n+** Parameter pEList is the list of expressions used to generated the\n+** contents of each row. It is used by this routine to determine (a)\n+** how many elements there are in the array of registers and (b) the\n+** collation sequences that should be used for the comparisons if\n+** eTnctType is WHERE_DISTINCT_ORDERED.\n+*\/\n+static int codeDistinct(\n@@ -129729,0 +134053,1 @@\n+  int eTnctType,     \/* WHERE_DISTINCT_* value *\/\n@@ -129731,2 +134056,2 @@\n-  int N,             \/* Number of elements *\/\n-  int iMem           \/* First element *\/\n+  ExprList *pEList,  \/* Expression for each element *\/\n+  int regElem        \/* First element *\/\n@@ -129734,2 +134059,3 @@\n-  Vdbe *v;\n-  int r1;\n+  int iRet = 0;\n+  int nResultCol = pEList->nExpr;\n+  Vdbe *v = pParse->pVdbe;\n@@ -129737,7 +134063,97 @@\n-  v = pParse->pVdbe;\n-  r1 = sqlite3GetTempReg(pParse);\n-  sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, iMem, N); VdbeCoverage(v);\n-  sqlite3VdbeAddOp3(v, OP_MakeRecord, iMem, N, r1);\n-  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r1, iMem, N);\n-  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n-  sqlite3ReleaseTempReg(pParse, r1);\n+  switch( eTnctType ){\n+    case WHERE_DISTINCT_ORDERED: {\n+      int i;\n+      int iJump;              \/* Jump destination *\/\n+      int regPrev;            \/* Previous row content *\/\n+\n+      \/* Allocate space for the previous row *\/\n+      iRet = regPrev = pParse->nMem+1;\n+      pParse->nMem += nResultCol;\n+\n+      iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;\n+      for(i=0; i<nResultCol; i++){\n+        CollSeq *pColl = sqlite3ExprCollSeq(pParse, pEList->a[i].pExpr);\n+        if( i<nResultCol-1 ){\n+          sqlite3VdbeAddOp3(v, OP_Ne, regElem+i, iJump, regPrev+i);\n+          VdbeCoverage(v);\n+        }else{\n+          sqlite3VdbeAddOp3(v, OP_Eq, regElem+i, addrRepeat, regPrev+i);\n+          VdbeCoverage(v);\n+         }\n+        sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);\n+        sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n+      }\n+      assert( sqlite3VdbeCurrentAddr(v)==iJump || pParse->db->mallocFailed );\n+      sqlite3VdbeAddOp3(v, OP_Copy, regElem, regPrev, nResultCol-1);\n+      break;\n+    }\n+\n+    case WHERE_DISTINCT_UNIQUE: {\n+      \/* nothing to do *\/\n+      break;\n+    }\n+\n+    default: {\n+      int r1 = sqlite3GetTempReg(pParse);\n+      sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, regElem, nResultCol);\n+      VdbeCoverage(v);\n+      sqlite3VdbeAddOp3(v, OP_MakeRecord, regElem, nResultCol, r1);\n+      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r1, regElem, nResultCol);\n+      sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n+      sqlite3ReleaseTempReg(pParse, r1);\n+      iRet = iTab;\n+      break;\n+    }\n+  }\n+\n+  return iRet;\n+}\n+\n+\/*\n+** This routine runs after codeDistinct().  It makes necessary\n+** adjustments to the OP_OpenEphemeral opcode that the codeDistinct()\n+** routine made use of.  This processing must be done separately since\n+** sometimes codeDistinct is called before the OP_OpenEphemeral is actually\n+** laid down.\n+**\n+** WHERE_DISTINCT_NOOP:\n+** WHERE_DISTINCT_UNORDERED:\n+**\n+**     No adjustments necessary.  This function is a no-op.\n+**\n+** WHERE_DISTINCT_UNIQUE:\n+**\n+**     The ephemeral table is not needed.  So change the\n+**     OP_OpenEphemeral opcode into an OP_Noop.\n+**\n+** WHERE_DISTINCT_ORDERED:\n+**\n+**     The ephemeral table is not needed.  But we do need register\n+**     iVal to be initialized to NULL.  So change the OP_OpenEphemeral\n+**     into an OP_Null on the iVal register.\n+*\/\n+static void fixDistinctOpenEph(\n+  Parse *pParse,     \/* Parsing and code generating context *\/\n+  int eTnctType,     \/* WHERE_DISTINCT_* value *\/\n+  int iVal,          \/* Value returned by codeDistinct() *\/\n+  int iOpenEphAddr   \/* Address of OP_OpenEphemeral instruction for iTab *\/\n+){\n+  if( pParse->nErr==0\n+   && (eTnctType==WHERE_DISTINCT_UNIQUE || eTnctType==WHERE_DISTINCT_ORDERED)\n+  ){\n+    Vdbe *v = pParse->pVdbe;\n+    sqlite3VdbeChangeToNoop(v, iOpenEphAddr);\n+    if( sqlite3VdbeGetOp(v, iOpenEphAddr+1)->opcode==OP_Explain ){\n+      sqlite3VdbeChangeToNoop(v, iOpenEphAddr+1);\n+    }\n+    if( eTnctType==WHERE_DISTINCT_ORDERED ){\n+      \/* Change the OP_OpenEphemeral to an OP_Null that sets the MEM_Cleared\n+      ** bit on the first register of the previous value.  This will cause the\n+      ** OP_Ne added in codeDistinct() to always fail on the first iteration of\n+      ** the loop even if the first row is all NULLs.  *\/\n+      VdbeOp *pOp = sqlite3VdbeGetOp(v, iOpenEphAddr);\n+      pOp->opcode = OP_Null;\n+      pOp->p1 = 1;\n+      pOp->p2 = iVal;\n+    }\n+  }\n@@ -129784,3 +134200,7 @@\n-      Table *pTab = pExpr->y.pTab;\n-      if( pExpr->op==TK_COLUMN && pExpr->iColumn>=0 && pTab && !IsVirtual(pTab)\n-       && (pTab->aCol[pExpr->iColumn].colFlags & COLFLAG_SORTERREF)\n+      Table *pTab;\n+      if( pExpr->op==TK_COLUMN\n+       && pExpr->iColumn>=0\n+       && ALWAYS( ExprUseYTab(pExpr) )\n+       && (pTab = pExpr->y.pTab)!=0\n+       && IsOrdinaryTable(pTab)\n+       && (pTab->aCol[pExpr->iColumn].colFlags & COLFLAG_SORTERREF)!=0\n@@ -129807,0 +134227,1 @@\n+                assert( ExprUseYTab(pNew) );\n@@ -129963,1 +134384,2 @@\n-           || eDest==SRT_Coroutine || eDest==SRT_Output );\n+           || eDest==SRT_Coroutine || eDest==SRT_Output\n+           || eDest==SRT_Upfrom );\n@@ -129990,53 +134412,5 @@\n-    switch( pDistinct->eTnctType ){\n-      case WHERE_DISTINCT_ORDERED: {\n-        VdbeOp *pOp;            \/* No longer required OpenEphemeral instr. *\/\n-        int iJump;              \/* Jump destination *\/\n-        int regPrev;            \/* Previous row content *\/\n-\n-        \/* Allocate space for the previous row *\/\n-        regPrev = pParse->nMem+1;\n-        pParse->nMem += nResultCol;\n-\n-        \/* Change the OP_OpenEphemeral coded earlier to an OP_Null\n-        ** sets the MEM_Cleared bit on the first register of the\n-        ** previous value.  This will cause the OP_Ne below to always\n-        ** fail on the first iteration of the loop even if the first\n-        ** row is all NULLs.\n-        *\/\n-        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);\n-        pOp = sqlite3VdbeGetOp(v, pDistinct->addrTnct);\n-        pOp->opcode = OP_Null;\n-        pOp->p1 = 1;\n-        pOp->p2 = regPrev;\n-        pOp = 0;  \/* Ensure pOp is not used after sqlite3VdbeAddOp() *\/\n-\n-        iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;\n-        for(i=0; i<nResultCol; i++){\n-          CollSeq *pColl = sqlite3ExprCollSeq(pParse, p->pEList->a[i].pExpr);\n-          if( i<nResultCol-1 ){\n-            sqlite3VdbeAddOp3(v, OP_Ne, regResult+i, iJump, regPrev+i);\n-            VdbeCoverage(v);\n-          }else{\n-            sqlite3VdbeAddOp3(v, OP_Eq, regResult+i, iContinue, regPrev+i);\n-            VdbeCoverage(v);\n-           }\n-          sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);\n-          sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n-        }\n-        assert( sqlite3VdbeCurrentAddr(v)==iJump || pParse->db->mallocFailed );\n-        sqlite3VdbeAddOp3(v, OP_Copy, regResult, regPrev, nResultCol-1);\n-        break;\n-      }\n-\n-      case WHERE_DISTINCT_UNIQUE: {\n-        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);\n-        break;\n-      }\n-\n-      default: {\n-        assert( pDistinct->eTnctType==WHERE_DISTINCT_UNORDERED );\n-        codeDistinct(pParse, pDistinct->tabTnct, iContinue, nResultCol,\n-                     regResult);\n-        break;\n-      }\n-    }\n+    int eType = pDistinct->eTnctType;\n+    int iTab = pDistinct->tabTnct;\n+    assert( nResultCol==p->pEList->nExpr );\n+    iTab = codeDistinct(pParse, eType, iTab, iContinue, p->pEList, regResult);\n+    fixDistinctOpenEph(pParse, eType, iTab, pDistinct->addrTnct);\n@@ -130112,0 +134486,24 @@\n+    case SRT_Upfrom: {\n+      if( pSort ){\n+        pushOntoSorter(\n+            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n+      }else{\n+        int i2 = pDest->iSDParm2;\n+        int r1 = sqlite3GetTempReg(pParse);\n+\n+        \/* If the UPDATE FROM join is an aggregate that matches no rows, it\n+        ** might still be trying to return one row, because that is what\n+        ** aggregates do.  Don't record that empty row in the output table. *\/\n+        sqlite3VdbeAddOp2(v, OP_IsNull, regResult, iBreak); VdbeCoverage(v);\n+\n+        sqlite3VdbeAddOp3(v, OP_MakeRecord,\n+                          regResult+(i2<0), nResultCol-(i2<0), r1);\n+        if( i2<0 ){\n+          sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);\n+        }else{\n+          sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);\n+        }\n+      }\n+      break;\n+    }\n+\n@@ -130136,0 +134534,1 @@\n+\n@@ -130342,1 +134741,1 @@\n-static const char *selectOpName(int id){\n+SQLITE_PRIVATE const char *sqlite3SelectOpName(int id){\n@@ -130543,0 +134942,11 @@\n+    case SRT_Upfrom: {\n+      int i2 = pDest->iSDParm2;\n+      int r1 = sqlite3GetTempReg(pParse);\n+      sqlite3VdbeAddOp3(v, OP_MakeRecord,regRow+(i2<0),nColumn-(i2<0),r1);\n+      if( i2<0 ){\n+        sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regRow);\n+      }else{\n+        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regRow, i2);\n+      }\n+      break;\n+    }\n@@ -130666,1 +135076,1 @@\n-      assert( pTab && pExpr->y.pTab==pTab );\n+      assert( pTab && ExprUseYTab(pExpr) && pExpr->y.pTab==pTab );\n@@ -130672,1 +135082,7 @@\n-        if( iCol>=0 && iCol<pS->pEList->nExpr ){\n+        if( iCol<pS->pEList->nExpr\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+         && iCol>=0\n+#else\n+         && ALWAYS(iCol>=0)\n+#endif\n+        ){\n@@ -130694,1 +135110,1 @@\n-          zOrigCol = pTab->aCol[iCol].zName;\n+          zOrigCol = pTab->aCol[iCol].zCnName;\n@@ -130720,3 +135136,5 @@\n-      Select *pS = pExpr->x.pSelect;\n-      Expr *p = pS->pEList->a[0].pExpr;\n-      assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n+      Select *pS;\n+      Expr *p;\n+      assert( ExprUseXSelect(pExpr) );\n+      pS = pExpr->x.pSelect;\n+      p = pS->pEList->a[0].pExpr;\n@@ -130814,1 +135232,1 @@\n-static void generateColumnNames(\n+SQLITE_PRIVATE void sqlite3GenerateColumnNames(\n@@ -130851,1 +135269,2 @@\n-    assert( p->op!=TK_COLUMN || p->y.pTab!=0 ); \/* Covering idx not yet coded *\/\n+    assert( p->op!=TK_COLUMN\n+        || (ExprUseYTab(p) && p->y.pTab!=0) ); \/* Covering idx not yet coded *\/\n@@ -130866,1 +135285,1 @@\n-        zCol = pTab->aCol[iCol].zName;\n+        zCol = pTab->aCol[iCol].zCnName;\n@@ -130904,1 +135323,1 @@\n-** See Also: generateColumnNames()\n+** See Also: sqlite3GenerateColumnNames()\n@@ -130920,0 +135339,1 @@\n+  Table *pTab;\n@@ -130926,1 +135346,1 @@\n-    if( nCol>32767 ) nCol = 32767;\n+    if( NEVER(nCol>32767) ) nCol = 32767;\n@@ -130942,1 +135362,1 @@\n-      while( pColExpr->op==TK_DOT ){\n+      while( ALWAYS(pColExpr!=0) && pColExpr->op==TK_DOT ){\n@@ -130946,1 +135366,4 @@\n-      if( pColExpr->op==TK_COLUMN ){\n+      if( pColExpr->op==TK_COLUMN\n+       && ALWAYS( ExprUseYTab(pColExpr) )\n+       && (pTab = pColExpr->y.pTab)!=0\n+      ){\n@@ -130949,2 +135372,0 @@\n-        Table *pTab = pColExpr->y.pTab;\n-        assert( pTab!=0 );\n@@ -130952,1 +135373,1 @@\n-        zName = iCol>=0 ? pTab->aCol[iCol].zName : \"rowid\";\n+        zName = iCol>=0 ? pTab->aCol[iCol].zCnName : \"rowid\";\n@@ -130980,1 +135401,1 @@\n-    pCol->zName = zName;\n+    pCol->zCnName = zName;\n@@ -130990,1 +135411,1 @@\n-      sqlite3DbFree(db, aCol[j].zName);\n+      sqlite3DbFree(db, aCol[j].zCnName);\n@@ -131034,1 +135455,2 @@\n-    int n, m;\n+    i64 n, m;\n+    pTab->tabFlags |= (pCol->colFlags & COLFLAG_NOINSERT);\n@@ -131041,4 +135463,4 @@\n-      n = sqlite3Strlen30(pCol->zName);\n-      pCol->zName = sqlite3DbReallocOrFree(db, pCol->zName, n+m+2);\n-      if( pCol->zName ){\n-        memcpy(&pCol->zName[n+1], zType, m+1);\n+      n = sqlite3Strlen30(pCol->zCnName);\n+      pCol->zCnName = sqlite3DbReallocOrFree(db, pCol->zCnName, n+m+2);\n+      if( pCol->zCnName ){\n+        memcpy(&pCol->zCnName[n+1], zType, m+1);\n@@ -131046,0 +135468,3 @@\n+      }else{\n+        testcase( pCol->colFlags & COLFLAG_HASTYPE );\n+        pCol->colFlags &= ~(COLFLAG_HASTYPE|COLFLAG_HASCOLL);\n@@ -131050,2 +135475,3 @@\n-    if( pColl && pCol->zColl==0 ){\n-      pCol->zColl = sqlite3DbStrDup(db, pColl->zName);\n+    if( pColl ){\n+      assert( pTab->pIndex==0 );\n+      sqlite3ColumnSetColl(db, pCol, pColl->zName);\n@@ -131215,1 +135641,1 @@\n-  int nOrderBy = p->pOrderBy->nExpr;\n+  int nOrderBy = ALWAYS(pOrderBy!=0) ? pOrderBy->nExpr : 0;\n@@ -131287,1 +135713,2 @@\n-  Select *pSetup = p->pPrior;   \/* The setup query *\/\n+  Select *pSetup;               \/* The setup query *\/\n+  Select *pFirstRec;            \/* Left-most recursive term *\/\n@@ -131363,0 +135790,16 @@\n+  \/* Figure out how many elements of the compound SELECT are part of the\n+  ** recursive query.  Make sure no recursive elements use aggregate\n+  ** functions.  Mark the recursive elements as UNION ALL even if they\n+  ** are really UNION because the distinctness will be enforced by the\n+  ** iDistinct table.  pFirstRec is left pointing to the left-most\n+  ** recursive term of the CTE.\n+  *\/\n+  for(pFirstRec=p; ALWAYS(pFirstRec!=0); pFirstRec=pFirstRec->pPrior){\n+    if( pFirstRec->selFlags & SF_Aggregate ){\n+      sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n+      goto end_of_recursive_query;\n+    }\n+    pFirstRec->op = TK_ALL;\n+    if( (pFirstRec->pPrior->selFlags & SF_Recursive)==0 ) break;\n+  }\n+\n@@ -131364,0 +135807,1 @@\n+  pSetup = pFirstRec->pPrior;\n@@ -131396,9 +135840,5 @@\n-  if( p->selFlags & SF_Aggregate ){\n-    sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n-  }else{\n-    p->pPrior = 0;\n-    ExplainQueryPlan((pParse, 1, \"RECURSIVE STEP\"));\n-    sqlite3Select(pParse, p, &destQueue);\n-    assert( p->pPrior==0 );\n-    p->pPrior = pSetup;\n-  }\n+  pFirstRec->pPrior = 0;\n+  ExplainQueryPlan((pParse, 1, \"RECURSIVE STEP\"));\n+  sqlite3Select(pParse, p, &destQueue);\n+  assert( pFirstRec->pPrior==0 );\n+  pFirstRec->pPrior = pSetup;\n@@ -131473,0 +135913,10 @@\n+\/*\n+** Return true if the SELECT statement which is known to be the recursive\n+** part of a recursive CTE still has its anchor terms attached.  If the\n+** anchor terms have already been removed, then return false.\n+*\/\n+static int hasAnchor(Select *p){\n+  while( p && (p->selFlags & SF_Recursive)!=0 ){ p = p->pPrior; }\n+  return p!=0;\n+}\n+\n@@ -131525,6 +135975,2 @@\n-  if( pPrior->pOrderBy || pPrior->pLimit ){\n-    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n-      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n-    rc = 1;\n-    goto multi_select_end;\n-  }\n+  assert( pPrior->pOrderBy==0 );\n+  assert( pPrior->pLimit==0 );\n@@ -131558,1 +136004,1 @@\n-  if( p->selFlags & SF_Recursive ){\n+  if( (p->selFlags & SF_Recursive)!=0 && hasAnchor(p) ){\n@@ -131581,1 +136027,1 @@\n-        int nLimit;\n+        int nLimit = 0;  \/* Initialize to suppress harmless compiler warning *\/\n@@ -131586,0 +136032,1 @@\n+        SELECTTRACE(1, pParse, p, (\"multiSelect UNION ALL left...\\n\"));\n@@ -131587,1 +136034,1 @@\n-        p->pLimit = 0;\n+        pPrior->pLimit = 0;\n@@ -131603,0 +136050,1 @@\n+        SELECTTRACE(1, pParse, p, (\"multiSelect UNION ALL right...\\n\"));\n@@ -131608,2 +136056,2 @@\n-        if( pPrior->pLimit\n-         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n+        if( p->pLimit\n+         && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit)\n@@ -131650,0 +136098,1 @@\n+\n@@ -131654,0 +136103,1 @@\n+        SELECTTRACE(1, pParse, p, (\"multiSelect EXCEPT\/UNION left...\\n\"));\n@@ -131672,1 +136122,2 @@\n-                          selectOpName(p->op)));\n+                          sqlite3SelectOpName(p->op)));\n+        SELECTTRACE(1, pParse, p, (\"multiSelect EXCEPT\/UNION right...\\n\"));\n@@ -131733,0 +136184,1 @@\n+        SELECTTRACE(1, pParse, p, (\"multiSelect INTERSECT left...\\n\"));\n@@ -131748,1 +136200,2 @@\n-                          selectOpName(p->op)));\n+                          sqlite3SelectOpName(p->op)));\n+        SELECTTRACE(1, pParse, p, (\"multiSelect INTERSECT right...\\n\"));\n@@ -131809,0 +136262,1 @@\n+    assert( p->pEList!=0 );\n@@ -131843,1 +136297,5 @@\n-  sqlite3SelectDelete(db, pDelete);\n+  if( pDelete ){\n+    sqlite3ParserAddCleanup(pParse,\n+        (void(*)(sqlite3*,void*))sqlite3SelectDelete,\n+        pDelete);\n+  }\n@@ -131857,1 +136315,2 @@\n-      \" do not have the same number of result columns\", selectOpName(p->op));\n+      \" do not have the same number of result columns\",\n+      sqlite3SelectOpName(p->op));\n@@ -131954,4 +136413,2 @@\n-      if( pParse->nErr==0 ){\n-        testcase( pIn->nSdst>1 );\n-        sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);\n-      }\n+      testcase( pIn->nSdst>1 );\n+      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);\n@@ -132129,1 +136586,1 @@\n-  int *aPermute;        \/* Mapping from ORDER BY terms to result set columns *\/\n+  u32 *aPermute;        \/* Mapping from ORDER BY terms to result set columns *\/\n@@ -132157,0 +136614,1 @@\n+        assert( pItem!=0 );\n@@ -132178,1 +136636,1 @@\n-  aPermute = sqlite3DbMallocRawNN(db, sizeof(int)*(nOrderBy + 1));\n+  aPermute = sqlite3DbMallocRawNN(db, sizeof(u32)*(nOrderBy + 1));\n@@ -132183,0 +136641,1 @@\n+      assert( pItem!=0 );\n@@ -132249,1 +136708,1 @@\n-  ExplainQueryPlan((pParse, 1, \"MERGE (%s)\", selectOpName(p->op)));\n+  ExplainQueryPlan((pParse, 1, \"MERGE (%s)\", sqlite3SelectOpName(p->op)));\n@@ -132383,0 +136842,3 @@\n+  sqlite3ExprListDelete(db, pPrior->pOrderBy);\n+  pPrior->pOrderBy = 0;\n+\n@@ -132437,0 +136899,1 @@\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n@@ -132439,1 +136902,3 @@\n-    }else{\n+    }else\n+#endif\n+    {\n@@ -132454,1 +136919,1 @@\n-          ifNullRow.flags = EP_Skip;\n+          ifNullRow.flags = EP_IfNullRow;\n@@ -132459,1 +136924,5 @@\n-        if( pNew && pSubst->isLeftJoin ){\n+        if( db->mallocFailed ){\n+          sqlite3ExprDelete(db, pNew);\n+          return pExpr;\n+        }\n+        if( pSubst->isLeftJoin ){\n@@ -132462,3 +136931,2 @@\n-        if( pNew && ExprHasProperty(pExpr,EP_FromJoin) ){\n-          pNew->iRightJoinTable = pExpr->iRightJoinTable;\n-          ExprSetProperty(pNew, EP_FromJoin);\n+        if( ExprHasProperty(pExpr,EP_FromJoin) ){\n+          sqlite3SetJoinExpr(pNew, pExpr->iRightJoinTable);\n@@ -132471,8 +136939,5 @@\n-        if( pExpr ){\n-          if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){\n-            CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);\n-            pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,\n-                (pColl ? pColl->zName : \"BINARY\")\n-            );\n-          }\n-          ExprClearProperty(pExpr, EP_Collate);\n+        if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){\n+          CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);\n+          pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,\n+              (pColl ? pColl->zName : \"BINARY\")\n+          );\n@@ -132480,0 +136945,1 @@\n+        ExprClearProperty(pExpr, EP_Collate);\n@@ -132488,1 +136954,1 @@\n-    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+    if( ExprUseXSelect(pExpr) ){\n@@ -132520,1 +136986,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -132550,1 +137016,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -132560,1 +137026,1 @@\n-  struct SrcList_item *pSrcItem    \/* Which FROM clause item to recompute *\/\n+  SrcItem *pSrcItem                \/* Which FROM clause item to recompute *\/\n@@ -132573,0 +137039,97 @@\n+#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n+\/*\n+** Assign new cursor numbers to each of the items in pSrc. For each\n+** new cursor number assigned, set an entry in the aCsrMap[] array\n+** to map the old cursor number to the new:\n+**\n+**     aCsrMap[iOld+1] = iNew;\n+**\n+** The array is guaranteed by the caller to be large enough for all\n+** existing cursor numbers in pSrc.  aCsrMap[0] is the array size.\n+**\n+** If pSrc contains any sub-selects, call this routine recursively\n+** on the FROM clause of each such sub-select, with iExcept set to -1.\n+*\/\n+static void srclistRenumberCursors(\n+  Parse *pParse,                  \/* Parse context *\/\n+  int *aCsrMap,                   \/* Array to store cursor mappings in *\/\n+  SrcList *pSrc,                  \/* FROM clause to renumber *\/\n+  int iExcept                     \/* FROM clause item to skip *\/\n+){\n+  int i;\n+  SrcItem *pItem;\n+  for(i=0, pItem=pSrc->a; i<pSrc->nSrc; i++, pItem++){\n+    if( i!=iExcept ){\n+      Select *p;\n+      assert( pItem->iCursor < aCsrMap[0] );\n+      if( !pItem->fg.isRecursive || aCsrMap[pItem->iCursor+1]==0 ){\n+        aCsrMap[pItem->iCursor+1] = pParse->nTab++;\n+      }\n+      pItem->iCursor = aCsrMap[pItem->iCursor+1];\n+      for(p=pItem->pSelect; p; p=p->pPrior){\n+        srclistRenumberCursors(pParse, aCsrMap, p->pSrc, -1);\n+      }\n+    }\n+  }\n+}\n+\n+\/*\n+** *piCursor is a cursor number.  Change it if it needs to be mapped.\n+*\/\n+static void renumberCursorDoMapping(Walker *pWalker, int *piCursor){\n+  int *aCsrMap = pWalker->u.aiCol;\n+  int iCsr = *piCursor;\n+  if( iCsr < aCsrMap[0] && aCsrMap[iCsr+1]>0 ){\n+    *piCursor = aCsrMap[iCsr+1];\n+  }\n+}\n+\n+\/*\n+** Expression walker callback used by renumberCursors() to update\n+** Expr objects to match newly assigned cursor numbers.\n+*\/\n+static int renumberCursorsCb(Walker *pWalker, Expr *pExpr){\n+  int op = pExpr->op;\n+  if( op==TK_COLUMN || op==TK_IF_NULL_ROW ){\n+    renumberCursorDoMapping(pWalker, &pExpr->iTable);\n+  }\n+  if( ExprHasProperty(pExpr, EP_FromJoin) ){\n+    renumberCursorDoMapping(pWalker, &pExpr->iRightJoinTable);\n+  }\n+  return WRC_Continue;\n+}\n+\n+\/*\n+** Assign a new cursor number to each cursor in the FROM clause (Select.pSrc)\n+** of the SELECT statement passed as the second argument, and to each\n+** cursor in the FROM clause of any FROM clause sub-selects, recursively.\n+** Except, do not assign a new cursor number to the iExcept'th element in\n+** the FROM clause of (*p). Update all expressions and other references\n+** to refer to the new cursor numbers.\n+**\n+** Argument aCsrMap is an array that may be used for temporary working\n+** space. Two guarantees are made by the caller:\n+**\n+**   * the array is larger than the largest cursor number used within the\n+**     select statement passed as an argument, and\n+**\n+**   * the array entries for all cursor numbers that do *not* appear in\n+**     FROM clauses of the select statement as described above are\n+**     initialized to zero.\n+*\/\n+static void renumberCursors(\n+  Parse *pParse,                  \/* Parse context *\/\n+  Select *p,                      \/* Select to renumber cursors within *\/\n+  int iExcept,                    \/* FROM clause item to skip *\/\n+  int *aCsrMap                    \/* Working space *\/\n+){\n+  Walker w;\n+  srclistRenumberCursors(pParse, aCsrMap, p->pSrc, iExcept);\n+  memset(&w, 0, sizeof(w));\n+  w.u.aiCol = aCsrMap;\n+  w.xExprCallback = renumberCursorsCb;\n+  w.xSelectCallback = sqlite3SelectWalkNoop;\n+  sqlite3WalkSelect(&w, p);\n+}\n+#endif \/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) *\/\n+\n@@ -132667,3 +137230,3 @@\n-**              (17d2) DISTINCT, or\n-**              (17d3) a join.\n-**        (17e) the subquery may not contain window functions\n+**              (17d2) DISTINCT\n+**        (17e) the subquery may not contain window functions, and\n+**        (17f) the subquery must not be the RHS of a LEFT JOIN.\n@@ -132685,2 +137248,2 @@\n-**        ORDER BY clause of the parent must be simple references to\n-**        columns of the sub-query.\n+**        ORDER BY clause of the parent must be copies of a term returned\n+**        by the parent query.\n@@ -132702,3 +137265,2 @@\n-**  (**)  Subsumed into restriction (17d3).  Was: If the outer query is\n-**        a recursive CTE, then the sub-query may not be a compound query.\n-**        This restriction is because transforming the\n+**  (23)  If the outer query is a recursive CTE, then the sub-query may not be\n+**        a compound query.  This restriction is because transforming the\n@@ -132746,1 +137308,1 @@\n-  struct SrcList_item *pSubitem;   \/* The subquery *\/\n+  SrcItem *pSubitem;               \/* The subquery *\/\n@@ -132749,0 +137311,1 @@\n+  int *aCsrMap = 0;\n@@ -132844,2 +137407,2 @@\n-    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){\n-      return 0; \/* (17d1), (17d2), or (17d3) *\/\n+    if( isAgg || (p->selFlags & SF_Distinct)!=0 || isLeftJoin>0 ){\n+      return 0; \/* (17d1), (17d2), or (17f) *\/\n@@ -132851,0 +137414,1 @@\n+      assert( (pSub->selFlags & SF_Recursive)==0 );\n@@ -132871,1 +137435,0 @@\n-  }\n@@ -132873,7 +137436,9 @@\n-  \/* Ex-restriction (23):\n-  ** The only way that the recursive part of a CTE can contain a compound\n-  ** subquery is for the subquery to be one term of a join.  But if the\n-  ** subquery is a join, then the flattening has already been stopped by\n-  ** restriction (17d3)\n-  *\/\n-  assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );\n+    \/* Restriction (23) *\/\n+    if( (p->selFlags & SF_Recursive) ) return 0;\n+\n+    if( pSrc->nSrc>1 ){\n+      if( pParse->nSelect>500 ) return 0;\n+      aCsrMap = sqlite3DbMallocZero(db, ((i64)pParse->nTab+1)*sizeof(int));\n+      if( aCsrMap ) aCsrMap[0] = pParse->nTab;\n+    }\n+  }\n@@ -132891,0 +137456,11 @@\n+  \/* Delete the transient structures associated with thesubquery *\/\n+  pSub1 = pSubitem->pSelect;\n+  sqlite3DbFree(db, pSubitem->zDatabase);\n+  sqlite3DbFree(db, pSubitem->zName);\n+  sqlite3DbFree(db, pSubitem->zAlias);\n+  pSubitem->zDatabase = 0;\n+  pSubitem->zName = 0;\n+  pSubitem->zAlias = 0;\n+  pSubitem->pSelect = 0;\n+  assert( pSubitem->pOn==0 );\n+\n@@ -132929,0 +137505,2 @@\n+    Table *pItemTab = pSubitem->pTab;\n+    pSubitem->pTab = 0;\n@@ -132930,1 +137508,0 @@\n-    p->pSrc = 0;\n@@ -132936,1 +137513,0 @@\n-    p->pSrc = pSrc;\n@@ -132938,0 +137514,1 @@\n+    pSubitem->pTab = pItemTab;\n@@ -132941,0 +137518,4 @@\n+      pNew->selId = ++pParse->nSelect;\n+      if( aCsrMap && ALWAYS(db->mallocFailed==0) ){\n+        renumberCursors(pParse, pNew, iFrom, aCsrMap);\n+      }\n@@ -132948,1 +137529,6 @@\n-    if( db->mallocFailed ) return 1;\n+    assert( pSubitem->pSelect==0 );\n+  }\n+  sqlite3DbFree(db, aCsrMap);\n+  if( db->mallocFailed ){\n+    pSubitem->pSelect = pSub1;\n+    return 1;\n@@ -132950,16 +137536,0 @@\n-\n-  \/* Begin flattening the iFrom-th entry of the FROM clause\n-  ** in the outer query.\n-  *\/\n-  pSub = pSub1 = pSubitem->pSelect;\n-\n-  \/* Delete the transient table structure associated with the\n-  ** subquery\n-  *\/\n-  sqlite3DbFree(db, pSubitem->zDatabase);\n-  sqlite3DbFree(db, pSubitem->zName);\n-  sqlite3DbFree(db, pSubitem->zAlias);\n-  pSubitem->zDatabase = 0;\n-  pSubitem->zName = 0;\n-  pSubitem->zAlias = 0;\n-  pSubitem->pSelect = 0;\n@@ -132978,2 +137548,4 @@\n-      pTabToDel->pNextZombie = pToplevel->pZombieTab;\n-      pToplevel->pZombieTab = pTabToDel;\n+      sqlite3ParserAddCleanup(pToplevel,\n+         (void(*)(sqlite3*,void*))sqlite3DeleteTable,\n+         pTabToDel);\n+      testcase( pToplevel->earlyCleanup );\n@@ -132999,0 +137571,1 @@\n+  pSub = pSub1;\n@@ -133007,8 +137580,2 @@\n-    if( pSrc ){\n-      assert( pParent==p );  \/* First time through the loop *\/\n-      jointype = pSubitem->fg.jointype;\n-    }else{\n-      assert( pParent!=p );  \/* 2nd and subsequent times through the loop *\/\n-      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n-      if( pSrc==0 ) break;\n-      pParent->pSrc = pSrc;\n+    if( pParent==p ){\n+      jointype = pSubitem->fg.jointype;     \/* First time through the loop *\/\n@@ -133151,0 +137718,1 @@\n+  u8 *pOomFault;   \/* Pointer to pParse->db->mallocFailed *\/\n@@ -133153,0 +137721,1 @@\n+  int bHasAffBlob; \/* At least one column in apExpr[] as affinity BLOB *\/\n@@ -133191,0 +137760,3 @@\n+  if( sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){\n+    pConst->bHasAffBlob = 1;\n+  }\n@@ -133211,1 +137783,1 @@\n-  if( pExpr==0 ) return;\n+  if( NEVER(pExpr==0) ) return;\n@@ -133232,4 +137804,7 @@\n-** This is a Walker expression callback.  pExpr is a candidate expression\n-** to be replaced by a value.  If pExpr is equivalent to one of the\n-** columns named in pWalker->u.pConst, then overwrite it with its\n-** corresponding value.\n+** This is a helper function for Walker callback propagateConstantExprRewrite().\n+**\n+** Argument pExpr is a candidate expression to be replaced by a value. If\n+** pExpr is equivalent to one of the columns named in pWalker->u.pConst,\n+** then overwrite it with the corresponding value. Except, do not do so\n+** if argument bIgnoreAffBlob is non-zero and the affinity of pExpr\n+** is SQLITE_AFF_BLOB.\n@@ -133237,1 +137812,5 @@\n-static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n+static int propagateConstantExprRewriteOne(\n+  WhereConst *pConst,\n+  Expr *pExpr,\n+  int bIgnoreAffBlob\n+){\n@@ -133239,1 +137818,1 @@\n-  WhereConst *pConst;\n+  if( pConst->pOomFault[0] ) return WRC_Prune;\n@@ -133246,1 +137825,0 @@\n-  pConst = pWalker->u.pConst;\n@@ -133252,0 +137830,3 @@\n+    if( bIgnoreAffBlob && sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){\n+      break;\n+    }\n@@ -133258,0 +137839,1 @@\n+    if( pConst->pParse->db->mallocFailed ) return WRC_Prune;\n@@ -133263,0 +137845,36 @@\n+\/*\n+** This is a Walker expression callback. pExpr is a node from the WHERE\n+** clause of a SELECT statement. This function examines pExpr to see if\n+** any substitutions based on the contents of pWalker->u.pConst should\n+** be made to pExpr or its immediate children.\n+**\n+** A substitution is made if:\n+**\n+**   + pExpr is a column with an affinity other than BLOB that matches\n+**     one of the columns in pWalker->u.pConst, or\n+**\n+**   + pExpr is a binary comparison operator (=, <=, >=, <, >) that\n+**     uses an affinity other than TEXT and one of its immediate\n+**     children is a column that matches one of the columns in\n+**     pWalker->u.pConst.\n+*\/\n+static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n+  WhereConst *pConst = pWalker->u.pConst;\n+  assert( TK_GT==TK_EQ+1 );\n+  assert( TK_LE==TK_EQ+2 );\n+  assert( TK_LT==TK_EQ+3 );\n+  assert( TK_GE==TK_EQ+4 );\n+  if( pConst->bHasAffBlob ){\n+    if( (pExpr->op>=TK_EQ && pExpr->op<=TK_GE)\n+     || pExpr->op==TK_IS\n+    ){\n+      propagateConstantExprRewriteOne(pConst, pExpr->pLeft, 0);\n+      if( pConst->pOomFault[0] ) return WRC_Prune;\n+      if( sqlite3ExprAffinity(pExpr->pLeft)!=SQLITE_AFF_TEXT ){\n+        propagateConstantExprRewriteOne(pConst, pExpr->pRight, 0);\n+      }\n+    }\n+  }\n+  return propagateConstantExprRewriteOne(pConst, pExpr, pConst->bHasAffBlob);\n+}\n+\n@@ -133298,0 +137916,15 @@\n+**\n+** 2021-05-25 forum post 6a06202608: Another troublesome case is...\n+**\n+**    CREATE TABLE t1(x);\n+**    INSERT INTO t1 VALUES(10.0);\n+**    SELECT 1 FROM t1 WHERE x=10 AND x LIKE 10;\n+**\n+** The query should return no rows, because the t1.x value is '10.0' not '10'\n+** and '10.0' is not LIKE '10'.  But if we are not careful, the first WHERE\n+** term \"x=10\" will cause the second WHERE term to become \"10 LIKE 10\",\n+** resulting in a false positive.  To avoid this, constant propagation for\n+** columns with BLOB affinity is only allowed if the constant is used with\n+** operators ==, <=, <, >=, >, or IS in a way that will cause the correct\n+** type conversions to occur.  See logic associated with the bHasAffBlob flag\n+** for details.\n@@ -133307,0 +137940,1 @@\n+  x.pOomFault = &pParse->db->mallocFailed;\n@@ -133311,0 +137945,1 @@\n+    x.bHasAffBlob = 0;\n@@ -133328,0 +137963,29 @@\n+#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n+# if !defined(SQLITE_OMIT_WINDOWFUNC)\n+\/*\n+** This function is called to determine whether or not it is safe to\n+** push WHERE clause expression pExpr down to FROM clause sub-query\n+** pSubq, which contains at least one window function. Return 1\n+** if it is safe and the expression should be pushed down, or 0\n+** otherwise.\n+**\n+** It is only safe to push the expression down if it consists only\n+** of constants and copies of expressions that appear in the PARTITION\n+** BY clause of all window function used by the sub-query. It is safe\n+** to filter out entire partitions, but not rows within partitions, as\n+** this may change the results of the window functions.\n+**\n+** At the time this function is called it is guaranteed that\n+**\n+**   * the sub-query uses only one distinct window frame, and\n+**   * that the window frame has a PARTITION BY clase.\n+*\/\n+static int pushDownWindowCheck(Parse *pParse, Select *pSubq, Expr *pExpr){\n+  assert( pSubq->pWin->pPartition );\n+  assert( (pSubq->selFlags & SF_MultiPart)==0 );\n+  assert( pSubq->pPrior==0 );\n+  return sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq->pWin->pPartition);\n+}\n+# endif \/* SQLITE_OMIT_WINDOWFUNC *\/\n+#endif \/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) *\/\n+\n@@ -133375,3 +138039,18 @@\n-**   (6) The inner query features one or more window-functions (since\n-**       changes to the WHERE clause of the inner query could change the\n-**       window over which window functions are calculated).\n+**   (6) Window functions make things tricky as changes to the WHERE clause\n+**       of the inner query could change the window over which window\n+**       functions are calculated. Therefore, do not attempt the optimization\n+**       if:\n+**\n+**     (6a) The inner query uses multiple incompatible window partitions.\n+**\n+**     (6b) The inner query is a compound and uses window-functions.\n+**\n+**     (6c) The WHERE clause does not consist entirely of constants and\n+**          copies of expressions found in the PARTITION BY clause of\n+**          all window-functions used by the sub-query. It is safe to\n+**          filter out entire partitions, as this does not change the\n+**          window over which any window-function is calculated.\n+**\n+**   (7) The inner query is a Common Table Expression (CTE) that should\n+**       be materialized.  (This restriction is implemented in the calling\n+**       routine.)\n@@ -133391,1 +138070,0 @@\n-  Select *pSel;\n@@ -133393,1 +138071,1 @@\n-  if( pSubq->selFlags & SF_Recursive ) return 0;  \/* restriction (2) *\/\n+  if( pSubq->selFlags & (SF_Recursive|SF_MultiPart) ) return 0;\n@@ -133396,2 +138074,7 @@\n-  for(pSel=pSubq; pSel; pSel=pSel->pPrior){\n-    if( pSel->pWin ) return 0;    \/* restriction (6) *\/\n+  if( pSubq->pPrior ){\n+    Select *pSel;\n+    for(pSel=pSubq; pSel; pSel=pSel->pPrior){\n+      if( pSel->pWin ) return 0;    \/* restriction (6b) *\/\n+    }\n+  }else{\n+    if( pSubq->pWin && pSubq->pWin->pPartition==0 ) return 0;\n@@ -133433,0 +138116,1 @@\n+    pSubq->selFlags |= SF_PushDown;\n@@ -133443,0 +138127,8 @@\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+      if( pSubq->pWin && 0==pushDownWindowCheck(pParse, pSubq, pNew) ){\n+        \/* Restriction 6c has prevented push-down in this case *\/\n+        sqlite3ExprDelete(pParse->db, pNew);\n+        nChng--;\n+        break;\n+      }\n+#endif\n@@ -133473,1 +138165,1 @@\n-  ExprList *pEList = pFunc->x.pList;    \/* Arguments to agg function *\/\n+  ExprList *pEList;                     \/* Arguments to agg function *\/\n@@ -133481,1 +138173,7 @@\n-  if( pEList==0 || pEList->nExpr!=1 || ExprHasProperty(pFunc, EP_WinFunc) ){\n+  assert( ExprUseXList(pFunc) );\n+  pEList = pFunc->x.pList;\n+  if( pEList==0\n+   || pEList->nExpr!=1\n+   || ExprHasProperty(pFunc, EP_WinFunc)\n+   || OptimizationDisabled(db, SQLITE_MinMaxOpt)\n+  ){\n@@ -133484,0 +138182,1 @@\n+  assert( !ExprHasProperty(pFunc, EP_IntValue) );\n@@ -133511,1 +138210,7 @@\n-** <tbl> is returned. Otherwise, 0 is returned.\n+** <tbl> is returned. Otherwise, NULL is returned.\n+**\n+** This routine checks to see if it is safe to use the count optimization.\n+** A correct answer is still obtained (though perhaps more slowly) if\n+** this routine returns NULL when it could have returned a table pointer.\n+** But returning the pointer when NULL should have been returned can\n+** result in incorrect answers and\/or crashes.  So, when in doubt, return NULL.\n@@ -133519,2 +138224,5 @@\n-  if( p->pWhere || p->pEList->nExpr!=1\n-   || p->pSrc->nSrc!=1 || p->pSrc->a[0].pSelect\n+  if( p->pWhere\n+   || p->pEList->nExpr!=1\n+   || p->pSrc->nSrc!=1\n+   || p->pSrc->a[0].pSelect\n+   || pAggInfo->nFunc!=1\n@@ -133525,0 +138233,3 @@\n+  assert( pTab!=0 );\n+  assert( !IsView(pTab) );\n+  if( !IsOrdinaryTable(pTab) ) return 0;\n@@ -133526,3 +138237,1 @@\n-  assert( pTab && !pTab->pSelect && pExpr );\n-\n-  if( IsVirtual(pTab) ) return 0;\n+  assert( pExpr!=0 );\n@@ -133530,1 +138239,1 @@\n-  if( NEVER(pAggInfo->nFunc==0) ) return 0;\n+  if( pExpr->pAggInfo!=pAggInfo ) return 0;\n@@ -133532,0 +138241,3 @@\n+  assert( pAggInfo->aFunc[0].pFExpr==pExpr );\n+  testcase( ExprHasProperty(pExpr, EP_Distinct) );\n+  testcase( ExprHasProperty(pExpr, EP_WinFunc) );\n@@ -133544,15 +138256,15 @@\n-SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){\n-  if( pFrom->pTab && pFrom->fg.isIndexedBy ){\n-    Table *pTab = pFrom->pTab;\n-    char *zIndexedBy = pFrom->u1.zIndexedBy;\n-    Index *pIdx;\n-    for(pIdx=pTab->pIndex;\n-        pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy);\n-        pIdx=pIdx->pNext\n-    );\n-    if( !pIdx ){\n-      sqlite3ErrorMsg(pParse, \"no such index: %s\", zIndexedBy, 0);\n-      pParse->checkSchema = 1;\n-      return SQLITE_ERROR;\n-    }\n-    pFrom->pIBIndex = pIdx;\n+SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, SrcItem *pFrom){\n+  Table *pTab = pFrom->pTab;\n+  char *zIndexedBy = pFrom->u1.zIndexedBy;\n+  Index *pIdx;\n+  assert( pTab!=0 );\n+  assert( pFrom->fg.isIndexedBy!=0 );\n+\n+  for(pIdx=pTab->pIndex;\n+      pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy);\n+      pIdx=pIdx->pNext\n+  );\n+  if( !pIdx ){\n+    sqlite3ErrorMsg(pParse, \"no such index: %s\", zIndexedBy, 0);\n+    pParse->checkSchema = 1;\n+    return SQLITE_ERROR;\n@@ -133560,0 +138272,2 @@\n+  assert( pFrom->fg.isCte==0 );\n+  pFrom->u2.pIBIndex = pIdx;\n@@ -133562,0 +138276,1 @@\n+\n@@ -133648,1 +138363,1 @@\n-static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){\n+static int cannotBeFunction(Parse *pParse, SrcItem *pFrom){\n@@ -133669,1 +138384,1 @@\n-  struct SrcList_item *pItem,     \/* FROM clause element to resolve *\/\n+  SrcItem *pItem,                 \/* FROM clause element to resolve *\/\n@@ -133672,10 +138387,10 @@\n-  const char *zName;\n-  if( pItem->zDatabase==0 && (zName = pItem->zName)!=0 ){\n-    With *p;\n-    for(p=pWith; p; p=p->pOuter){\n-      int i;\n-      for(i=0; i<p->nCte; i++){\n-        if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){\n-          *ppContext = p;\n-          return &p->a[i];\n-        }\n+  const char *zName = pItem->zName;\n+  With *p;\n+  assert( pItem->zDatabase==0 );\n+  assert( zName!=0 );\n+  for(p=pWith; p; p=p->pOuter){\n+    int i;\n+    for(i=0; i<p->nCte; i++){\n+      if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){\n+        *ppContext = p;\n+        return &p->a[i];\n@@ -133684,0 +138399,1 @@\n+    if( p->bView ) break;\n@@ -133693,2 +138409,2 @@\n-** WITH clause will never be popped from the stack. In this case it\n-** should be freed along with the Parse object. In other cases, when\n+** WITH clause will never be popped from the stack but should instead\n+** be freed along with the Parse object. In other cases, when\n@@ -133697,0 +138413,7 @@\n+**\n+** This routine returns a copy of pWith.  Or, if bFree is true and\n+** the pWith object is destroyed immediately due to an OOM condition,\n+** then this routine return NULL.\n+**\n+** If bFree is true, do not continue to use the pWith pointer after\n+** calling this routine,  Instead, use only the return value.\n@@ -133698,2 +138421,1 @@\n-SQLITE_PRIVATE void sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){\n-  assert( bFree==0 || (pParse->pWith==0 && pParse->pWithToFree==0) );\n+SQLITE_PRIVATE With *sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){\n@@ -133701,4 +138423,11 @@\n-    assert( pParse->pWith!=pWith );\n-    pWith->pOuter = pParse->pWith;\n-    pParse->pWith = pWith;\n-    if( bFree ) pParse->pWithToFree = pWith;\n+    if( bFree ){\n+      pWith = (With*)sqlite3ParserAddCleanup(pParse,\n+                      (void(*)(sqlite3*,void*))sqlite3WithDelete,\n+                      pWith);\n+      if( pWith==0 ) return 0;\n+    }\n+    if( pParse->nErr==0 ){\n+      assert( pParse->pWith!=pWith );\n+      pWith->pOuter = pParse->pWith;\n+      pParse->pWith = pWith;\n+    }\n@@ -133706,0 +138435,1 @@\n+  return pWith;\n@@ -133710,3 +138440,4 @@\n-** a WITH clause on the stack currently maintained by the parser. And,\n-** if currently processing a CTE expression, if it is a recursive\n-** reference to the current CTE.\n+** a WITH clause on the stack currently maintained by the parser (on the\n+** pParse->pWith linked list).  And if currently processing a CTE\n+** CTE expression, through routine checks to see if the reference is\n+** a recursive reference to the CTE.\n@@ -133714,4 +138445,2 @@\n-** If pFrom falls into either of the two categories above, pFrom->pTab\n-** and other fields are populated accordingly. The caller should check\n-** (pFrom->pTab!=0) to determine whether or not a successful match\n-** was found.\n+** If pFrom matches a CTE according to either of these two above, pFrom->pTab\n+** and other fields are populated accordingly.\n@@ -133719,3 +138448,3 @@\n-** Whether or not a match is found, SQLITE_OK is returned if no error\n-** occurs. If an error does occur, an error message is stored in the\n-** parser and some error code other than SQLITE_OK returned.\n+** Return 0 if no match is found.\n+** Return 1 if a match is found.\n+** Return 2 if an error condition is detected.\n@@ -133723,3 +138452,4 @@\n-static int withExpand(\n-  Walker *pWalker,\n-  struct SrcList_item *pFrom\n+static int resolveFromTermToCte(\n+  Parse *pParse,                  \/* The parsing context *\/\n+  Walker *pWalker,                \/* Current tree walker *\/\n+  SrcItem *pFrom                  \/* The FROM clause term to check *\/\n@@ -133727,4 +138457,2 @@\n-  Parse *pParse = pWalker->pParse;\n-  sqlite3 *db = pParse->db;\n-  struct Cte *pCte;               \/* Matched CTE (or NULL if no match) *\/\n-  With *pWith;                    \/* WITH clause that pCte belongs to *\/\n+  Cte *pCte;               \/* Matched CTE (or NULL if no match) *\/\n+  With *pWith;             \/* The matching WITH *\/\n@@ -133733,0 +138461,4 @@\n+  if( pParse->pWith==0 ){\n+    \/* There are no WITH clauses in the stack.  No match is possible *\/\n+    return 0;\n+  }\n@@ -133734,1 +138466,16 @@\n-    return SQLITE_ERROR;\n+    \/* Prior errors might have left pParse->pWith in a goofy state, so\n+    ** go no further. *\/\n+    return 0;\n+  }\n+  if( pFrom->zDatabase!=0 ){\n+    \/* The FROM term contains a schema qualifier (ex: main.t1) and so\n+    ** it cannot possibly be a CTE reference. *\/\n+    return 0;\n+  }\n+  if( pFrom->fg.notCte ){\n+    \/* The FROM term is specifically excluded from matching a CTE.\n+    **   (1)  It is part of a trigger that used to have zDatabase but had\n+    **        zDatabase removed by sqlite3FixTriggerStep().\n+    **   (2)  This is the first term in the FROM clause of an UPDATE.\n+    *\/\n+    return 0;\n@@ -133736,1 +138483,0 @@\n-\n@@ -133739,0 +138485,1 @@\n+    sqlite3 *db = pParse->db;\n@@ -133743,0 +138490,1 @@\n+    Select *pRecTerm;             \/* Left-most recursive term *\/\n@@ -133745,0 +138493,2 @@\n+    int iRecTab = -1;             \/* Cursor for recursive table *\/\n+    CteUse *pCteUse;\n@@ -133752,1 +138502,1 @@\n-      return SQLITE_ERROR;\n+      return 2;\n@@ -133754,1 +138504,1 @@\n-    if( cannotBeFunction(pParse, pFrom) ) return SQLITE_ERROR;\n+    if( cannotBeFunction(pParse, pFrom) ) return 2;\n@@ -133757,2 +138507,14 @@\n-    pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));\n-    if( pTab==0 ) return WRC_Abort;\n+    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n+    if( pTab==0 ) return 2;\n+    pCteUse = pCte->pUse;\n+    if( pCteUse==0 ){\n+      pCte->pUse = pCteUse = sqlite3DbMallocZero(db, sizeof(pCteUse[0]));\n+      if( pCteUse==0\n+       || sqlite3ParserAddCleanup(pParse,sqlite3DbFree,pCteUse)==0\n+      ){\n+        sqlite3DbFree(db, pTab);\n+        return 2;\n+      }\n+      pCteUse->eM10d = pCte->eM10d;\n+    }\n+    pFrom->pTab = pTab;\n@@ -133765,1 +138527,2 @@\n-    if( db->mallocFailed ) return SQLITE_NOMEM_BKPT;\n+    if( db->mallocFailed ) return 2;\n+    pFrom->pSelect->selFlags |= SF_CopyCte;\n@@ -133767,0 +138530,10 @@\n+    if( pFrom->fg.isIndexedBy ){\n+      sqlite3ErrorMsg(pParse, \"no such index: \\\"%s\\\"\", pFrom->u1.zIndexedBy);\n+      return 2;\n+    }\n+    pFrom->fg.isCte = 1;\n+    pFrom->u2.pCteUse = pCteUse;\n+    pCteUse->nUse++;\n+    if( pCteUse->nUse>=2 && pCteUse->eM10d==M10d_Any ){\n+      pCteUse->eM10d = M10d_Yes;\n+    }\n@@ -133769,1 +138542,1 @@\n-    pSel = pFrom->pSelect;\n+    pRecTerm = pSel = pFrom->pSelect;\n@@ -133771,1 +138544,1 @@\n-    if( bMayRecursive ){\n+    while( bMayRecursive && pRecTerm->op==pSel->op ){\n@@ -133773,1 +138546,2 @@\n-      SrcList *pSrc = pFrom->pSelect->pSrc;\n+      SrcList *pSrc = pRecTerm->pSrc;\n+      assert( pRecTerm->pPrior!=0 );\n@@ -133775,1 +138549,1 @@\n-        struct SrcList_item *pItem = &pSrc->a[i];\n+        SrcItem *pItem = &pSrc->a[i];\n@@ -133779,1 +138553,1 @@\n-          ){\n+        ){\n@@ -133781,1 +138555,0 @@\n-          pItem->fg.isRecursive = 1;\n@@ -133783,1 +138556,10 @@\n-          pSel->selFlags |= SF_Recursive;\n+          pItem->fg.isRecursive = 1;\n+          if( pRecTerm->selFlags & SF_Recursive ){\n+            sqlite3ErrorMsg(pParse,\n+               \"multiple references to recursive table: %s\", pCte->zName\n+            );\n+            return 2;\n+          }\n+          pRecTerm->selFlags |= SF_Recursive;\n+          if( iRecTab<0 ) iRecTab = pParse->nTab++;\n+          pItem->iCursor = iRecTab;\n@@ -133786,0 +138568,2 @@\n+      if( (pRecTerm->selFlags & SF_Recursive)==0 ) break;\n+      pRecTerm = pRecTerm->pPrior;\n@@ -133788,10 +138572,0 @@\n-    \/* Only one recursive reference is permitted. *\/\n-    if( pTab->nTabRef>2 ){\n-      sqlite3ErrorMsg(\n-          pParse, \"multiple references to recursive table: %s\", pCte->zName\n-      );\n-      return SQLITE_ERROR;\n-    }\n-    assert( pTab->nTabRef==1 ||\n-            ((pSel->selFlags&SF_Recursive) && pTab->nTabRef==2 ));\n-\n@@ -133801,6 +138575,14 @@\n-    if( bMayRecursive ){\n-      Select *pPrior = pSel->pPrior;\n-      assert( pPrior->pWith==0 );\n-      pPrior->pWith = pSel->pWith;\n-      sqlite3WalkSelect(pWalker, pPrior);\n-      pPrior->pWith = 0;\n+    if( pSel->selFlags & SF_Recursive ){\n+      int rc;\n+      assert( pRecTerm!=0 );\n+      assert( (pRecTerm->selFlags & SF_Recursive)==0 );\n+      assert( pRecTerm->pNext!=0 );\n+      assert( (pRecTerm->pNext->selFlags & SF_Recursive)!=0 );\n+      assert( pRecTerm->pWith==0 );\n+      pRecTerm->pWith = pSel->pWith;\n+      rc = sqlite3WalkSelect(pWalker, pRecTerm);\n+      pRecTerm->pWith = 0;\n+      if( rc ){\n+        pParse->pWith = pSavedWith;\n+        return 2;\n+      }\n@@ -133808,1 +138590,4 @@\n-      sqlite3WalkSelect(pWalker, pSel);\n+      if( sqlite3WalkSelect(pWalker, pSel) ){\n+        pParse->pWith = pSavedWith;\n+        return 2;\n+      }\n@@ -133820,1 +138605,1 @@\n-        return SQLITE_ERROR;\n+        return 2;\n@@ -133836,0 +138621,1 @@\n+    return 1;  \/* Success *\/\n@@ -133837,2 +138623,1 @@\n-\n-  return SQLITE_OK;\n+  return 0;  \/* No match *\/\n@@ -133851,1 +138636,1 @@\n-static void selectPopWith(Walker *pWalker, Select *p){\n+SQLITE_PRIVATE void sqlite3SelectPopWith(Walker *pWalker, Select *p){\n@@ -133861,2 +138646,0 @@\n-#else\n-#define selectPopWith 0\n@@ -133872,1 +138655,1 @@\n-SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse *pParse, struct SrcList_item *pFrom){\n+SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse *pParse, SrcItem *pFrom){\n@@ -133889,1 +138672,7 @@\n-  pTab->tabFlags |= TF_Ephemeral;\n+#ifndef SQLITE_ALLOW_ROWID_IN_VIEW\n+  \/* The usual case - do not allow ROWID on a subquery *\/\n+  pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;\n+#else\n+  pTab->tabFlags |= TF_Ephemeral;  \/* Legacy compatibility mode *\/\n+#endif\n+\n@@ -133920,1 +138709,1 @@\n-  int i, j, k;\n+  int i, j, k, rc;\n@@ -133923,1 +138712,1 @@\n-  struct SrcList_item *pFrom;\n+  SrcItem *pFrom;\n@@ -133943,0 +138732,9 @@\n+  if( pParse->pWith && (p->selFlags & SF_View) ){\n+    if( p->pWith==0 ){\n+      p->pWith = (With*)sqlite3DbMallocZero(db, sizeof(With));\n+      if( p->pWith==0 ){\n+        return WRC_Abort;\n+      }\n+    }\n+    p->pWith->bView = 1;\n+  }\n@@ -133957,6 +138755,2 @@\n-    if( pFrom->fg.isRecursive ) continue;\n-    assert( pFrom->pTab==0 );\n-#ifndef SQLITE_OMIT_CTE\n-    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n-    if( pFrom->pTab ) {} else\n-#endif\n+    if( pFrom->pTab ) continue;\n+    assert( pFrom->fg.isRecursive==0 );\n@@ -133971,0 +138765,6 @@\n+#endif\n+#ifndef SQLITE_OMIT_CTE\n+    }else if( (rc = resolveFromTermToCte(pParse, pWalker, pFrom))!=0 ){\n+      if( rc>1 ) return WRC_Abort;\n+      pTab = pFrom->pTab;\n+      assert( pTab!=0 );\n@@ -133988,1 +138788,1 @@\n-      if( IsVirtual(pTab) || pTab->pSelect ){\n+      if( !IsOrdinaryTable(pTab) ){\n@@ -133993,3 +138793,8 @@\n-        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n-          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n-            pTab->zName);\n+        if( IsView(pTab) ){\n+          if( (db->flags & SQLITE_EnableView)==0\n+           && pTab->pSchema!=db->aDb[1].pSchema\n+          ){\n+            sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n+              pTab->zName);\n+          }\n+          pFrom->pSelect = sqlite3SelectDup(db, pTab->u.view.pSelect, 0);\n@@ -133998,1 +138803,1 @@\n-        if( IsVirtual(pTab)\n+        else if( ALWAYS(IsVirtual(pTab))\n@@ -134000,2 +138805,2 @@\n-         && ALWAYS(pTab->pVTable!=0)\n-         && pTab->pVTable->eVtabRisk > ((db->flags & SQLITE_TrustedSchema)!=0)\n+         && ALWAYS(pTab->u.vtab.p!=0)\n+         && pTab->u.vtab.p->eVtabRisk > ((db->flags & SQLITE_TrustedSchema)!=0)\n@@ -134006,0 +138811,1 @@\n+        assert( SQLITE_VTABRISK_Normal==1 && SQLITE_VTABRISK_High==2 );\n@@ -134007,1 +138813,0 @@\n-        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n@@ -134019,1 +138824,1 @@\n-    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n+    if( pFrom->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pFrom) ){\n@@ -134107,1 +138912,1 @@\n-            char *zName = pTab->aCol[j].zName;\n+            char *zName = pTab->aCol[j].zCnName;\n@@ -134238,1 +139043,1 @@\n-  w.xSelectCallback2 = selectPopWith;\n+  w.xSelectCallback2 = sqlite3SelectPopWith;\n@@ -134262,1 +139067,1 @@\n-  struct SrcList_item *pFrom;\n+  SrcItem *pFrom;\n@@ -134346,1 +139151,1 @@\n-  if( pParse->nErr ) return;\n+  if( pParse->nErr || pParse->db->mallocFailed ) return;\n@@ -134363,2 +139168,2 @@\n-      Expr *pE = pFunc->pExpr;\n-      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n+      Expr *pE = pFunc->pFExpr;\n+      assert( ExprUseXList(pE) );\n@@ -134371,2 +139176,4 @@\n-        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n-                          (char*)pKeyInfo, P4_KEYINFO);\n+        pFunc->iDistAddr = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n+            pFunc->iDistinct, 0, 0, (char*)pKeyInfo, P4_KEYINFO);\n+        ExplainQueryPlan((pParse, 0, \"USE TEMP B-TREE FOR %s(DISTINCT)\",\n+                          pFunc->pFunc->zName));\n@@ -134387,2 +139194,3 @@\n-    ExprList *pList = pF->pExpr->x.pList;\n-    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n+    ExprList *pList;\n+    assert( ExprUseXList(pF->pFExpr) );\n+    pList = pF->pFExpr->x.pList;\n@@ -134404,1 +139212,6 @@\n-static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo){\n+static void updateAccumulator(\n+  Parse *pParse,\n+  int regAcc,\n+  AggInfo *pAggInfo,\n+  int eDistinctType\n+){\n@@ -134417,5 +139230,6 @@\n-    ExprList *pList = pF->pExpr->x.pList;\n-    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n-    assert( !IsWindowFunc(pF->pExpr) );\n-    if( ExprHasProperty(pF->pExpr, EP_WinFunc) ){\n-      Expr *pFilter = pF->pExpr->y.pWin->pFilter;\n+    ExprList *pList;\n+    assert( ExprUseXList(pF->pFExpr) );\n+    assert( !IsWindowFunc(pF->pFExpr) );\n+    pList = pF->pFExpr->x.pList;\n+    if( ExprHasProperty(pF->pFExpr, EP_WinFunc) ){\n+      Expr *pFilter = pF->pFExpr->y.pWin->pFilter;\n@@ -134424,0 +139238,1 @@\n+       && regAcc\n@@ -134425,0 +139240,3 @@\n+        \/* If regAcc==0, there there exists some min() or max() function\n+        ** without a FILTER clause that will ensure the magnet registers\n+        ** are populated. *\/\n@@ -134426,1 +139244,1 @@\n-        \/* If this is the first row of the group (regAcc==0), clear the\n+        \/* If this is the first row of the group (regAcc contains 0), clear the\n@@ -134430,3 +139248,3 @@\n-        ** the first row (regAcc==1), set the magnet register so that the\n-        ** accumulators are not populated unless the min()\/max() is invoked and\n-        ** indicates that they should be.  *\/\n+        ** the first row (regAcc contains 1), set the magnet register so that\n+        ** the accumulators are not populated unless the min()\/max() is invoked\n+        ** and indicates that they should be.  *\/\n@@ -134446,1 +139264,1 @@\n-    if( pF->iDistinct>=0 ){\n+    if( pF->iDistinct>=0 && pList ){\n@@ -134450,3 +139268,2 @@\n-      testcase( nArg==0 );  \/* Error condition *\/\n-      testcase( nArg>1 );   \/* Also an error *\/\n-      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);\n+      pF->iDistinct = codeDistinct(pParse, eDistinctType,\n+          pF->iDistinct, addrNext, pList, regAgg);\n@@ -134483,1 +139300,1 @@\n-    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);\n+    sqlite3ExprCode(pParse, pC->pCExpr, pC->iMem);\n@@ -134504,1 +139321,1 @@\n-    sqlite3VdbeExplain(pParse, 0, \"SCAN TABLE %s%s%s\",\n+    sqlite3VdbeExplain(pParse, 0, \"SCAN %s%s%s\",\n@@ -134529,1 +139346,11 @@\n-    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy) ){\n+    \/* This routine is called before the HAVING clause of the current\n+    ** SELECT is analyzed for aggregates. So if pExpr->pAggInfo is set\n+    ** here, it indicates that the expression is a correlated reference to a\n+    ** column from an outer aggregate query, or an aggregate function that\n+    ** belongs to an outer query. Do not move the expression to the WHERE\n+    ** clause in this obscure case, as doing so may corrupt the outer Select\n+    ** statements AggInfo structure.  *\/\n+    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy)\n+     && ExprAlwaysFalse(pExpr)==0\n+     && pExpr->pAggInfo==0\n+    ){\n@@ -134580,1 +139407,1 @@\n-static struct SrcList_item *isSelfJoinView(\n+static SrcItem *isSelfJoinView(\n@@ -134582,1 +139409,1 @@\n-  struct SrcList_item *pThis   \/* Search for prior reference to this subquery *\/\n+  SrcItem *pThis               \/* Search for prior reference to this subquery *\/\n@@ -134584,1 +139411,3 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n+  assert( pThis->pSelect!=0 );\n+  if( pThis->pSelect->selFlags & SF_PushDown ) return 0;\n@@ -134600,3 +139429,1 @@\n-    if( sqlite3ExprCompare(0, pThis->pSelect->pWhere, pS1->pWhere, -1)\n-     || sqlite3ExprCompare(0, pThis->pSelect->pHaving, pS1->pHaving, -1)\n-    ){\n+    if( pItem->pSelect->selFlags & SF_PushDown ){\n@@ -134612,0 +139439,9 @@\n+\/*\n+** Deallocate a single AggInfo object\n+*\/\n+static void agginfoFree(sqlite3 *db, AggInfo *p){\n+  sqlite3DbFree(db, p->aCol);\n+  sqlite3DbFree(db, p->aFunc);\n+  sqlite3DbFreeNN(db, p);\n+}\n+\n@@ -134643,0 +139479,1 @@\n+  assert( ExprUseUToken(pExpr) );\n@@ -134644,0 +139481,1 @@\n+  assert( ExprUseXList(pExpr) );\n@@ -134752,9 +139590,18 @@\n-  if( IgnorableOrderby(pDest) ){\n-    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union ||\n-           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n-           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n-           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n-    \/* If ORDER BY makes no difference in the output then neither does\n-    ** DISTINCT so it can be removed too. *\/\n-    sqlite3ExprListDelete(db, p->pOrderBy);\n-    p->pOrderBy = 0;\n+  if( IgnorableDistinct(pDest) ){\n+    assert(pDest->eDest==SRT_Exists     || pDest->eDest==SRT_Union ||\n+           pDest->eDest==SRT_Except     || pDest->eDest==SRT_Discard ||\n+           pDest->eDest==SRT_DistQueue  || pDest->eDest==SRT_DistFifo );\n+    \/* All of these destinations are also able to ignore the ORDER BY clause *\/\n+    if( p->pOrderBy ){\n+#if SELECTTRACE_ENABLED\n+      SELECTTRACE(1,pParse,p, (\"dropping superfluous ORDER BY:\\n\"));\n+      if( sqlite3SelectTrace & 0x100 ){\n+        sqlite3TreeViewExprList(0, p->pOrderBy, 0, \"ORDERBY\");\n+      }\n+#endif\n+      sqlite3ParserAddCleanup(pParse,\n+        (void(*)(sqlite3*,void*))sqlite3ExprListDelete,\n+        p->pOrderBy);\n+      testcase( pParse->earlyCleanup );\n+      p->pOrderBy = 0;\n+    }\n@@ -134776,0 +139623,29 @@\n+  \/* If the SF_UFSrcCheck flag is set, then this function is being called\n+  ** as part of populating the temp table for an UPDATE...FROM statement.\n+  ** In this case, it is an error if the target object (pSrc->a[0]) name\n+  ** or alias is duplicated within FROM clause (pSrc->a[1..n]).\n+  **\n+  ** Postgres disallows this case too. The reason is that some other\n+  ** systems handle this case differently, and not all the same way,\n+  ** which is just confusing. To avoid this, we follow PG's lead and\n+  ** disallow it altogether.  *\/\n+  if( p->selFlags & SF_UFSrcCheck ){\n+    SrcItem *p0 = &p->pSrc->a[0];\n+    for(i=1; i<p->pSrc->nSrc; i++){\n+      SrcItem *p1 = &p->pSrc->a[i];\n+      if( p0->pTab==p1->pTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){\n+        sqlite3ErrorMsg(pParse,\n+            \"target object\/alias may not appear in FROM clause: %s\",\n+            p0->zAlias ? p0->zAlias : p0->pTab->zName\n+        );\n+        goto select_end;\n+      }\n+    }\n+\n+    \/* Clear the SF_UFSrcCheck flag. The check has already been performed,\n+    ** and leaving this flag set can cause errors if a compound sub-query\n+    ** in p->pSrc is flattened into this query and this function called\n+    ** again as part of compound SELECT processing.  *\/\n+    p->selFlags &= ~SF_UFSrcCheck;\n+  }\n+\n@@ -134777,1 +139653,1 @@\n-    generateColumnNames(pParse, p);\n+    sqlite3GenerateColumnNames(pParse, p);\n@@ -134781,2 +139657,1 @@\n-  rc = sqlite3WindowRewrite(pParse, p);\n-  if( rc ){\n+  if( sqlite3WindowRewrite(pParse, p) ){\n@@ -134798,1 +139673,1 @@\n-  \/* Try to various optimizations (flattening subqueries, and strength\n+  \/* Try to do various optimizations (flattening subqueries, and strength\n@@ -134803,1 +139678,1 @@\n-    struct SrcList_item *pItem = &pTabList->a[i];\n+    SrcItem *pItem = &pTabList->a[i];\n@@ -134807,0 +139682,5 @@\n+    \/* The expander should have already created transient Table objects\n+    ** even for FROM clause elements such as subqueries that do not correspond\n+    ** to a real table *\/\n+    assert( pTab!=0 );\n+\n@@ -134841,0 +139721,33 @@\n+    \/* If a FROM-clause subquery has an ORDER BY clause that is not\n+    ** really doing anything, then delete it now so that it does not\n+    ** interfere with query flattening.  See the discussion at\n+    ** https:\/\/sqlite.org\/forum\/forumpost\/2d76f2bcf65d256a\n+    **\n+    ** Beware of these cases where the ORDER BY clause may not be safely\n+    ** omitted:\n+    **\n+    **    (1)   There is also a LIMIT clause\n+    **    (2)   The subquery was added to help with window-function\n+    **          processing\n+    **    (3)   The subquery is in the FROM clause of an UPDATE\n+    **    (4)   The outer query uses an aggregate function other than\n+    **          the built-in count(), min(), or max().\n+    **    (5)   The ORDER BY isn't going to accomplish anything because\n+    **          one of:\n+    **            (a)  The outer query has a different ORDER BY clause\n+    **            (b)  The subquery is part of a join\n+    **          See forum post 062d576715d277c8\n+    *\/\n+    if( pSub->pOrderBy!=0\n+     && (p->pOrderBy!=0 || pTabList->nSrc>1)      \/* Condition (5) *\/\n+     && pSub->pLimit==0                           \/* Condition (1) *\/\n+     && (pSub->selFlags & SF_OrderByReqd)==0      \/* Condition (2) *\/\n+     && (p->selFlags & SF_OrderByReqd)==0         \/* Condition (3) and (4) *\/\n+     && OptimizationEnabled(db, SQLITE_OmitOrderBy)\n+    ){\n+      SELECTTRACE(0x100,pParse,p,\n+                (\"omit superfluous ORDER BY on %r FROM-clause subquery\\n\",i+1));\n+      sqlite3ExprListDelete(db, pSub->pOrderBy);\n+      pSub->pOrderBy = 0;\n+    }\n+\n@@ -134903,1 +139816,2 @@\n-  if( pTabList->nSrc>1\n+  if( p->pWhere!=0\n+   && p->pWhere->op==TK_AND\n@@ -134932,1 +139846,2 @@\n-    struct SrcList_item *pItem = &pTabList->a[i];\n+    SrcItem *pItem = &pTabList->a[i];\n+    SrcItem *pPrior;\n@@ -134965,13 +139880,2 @@\n-    \/* The code for a subquery should only be generated once, though it is\n-    ** technically harmless for it to be generated multiple times. The\n-    ** following assert() will detect if something changes to cause\n-    ** the same subquery to be coded multiple times, as a signal to the\n-    ** developers to try to optimize the situation.\n-    **\n-    ** Update 2019-07-24:\n-    ** See ticket https:\/\/sqlite.org\/src\/tktview\/c52b09c7f38903b1311cec40.\n-    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n-    ** coded twice.  So this assert() now becomes a testcase().  It should\n-    ** be very rare, though.\n-    *\/\n-    testcase( pItem->addrFillSub!=0 );\n+    \/* The code for a subquery should only be generated once. *\/\n+    assert( pItem->addrFillSub==0 );\n@@ -134992,0 +139896,2 @@\n+     && (pItem->fg.isCte==0\n+         || (pItem->u2.pCteUse->eM10d!=M10d_Yes && pItem->u2.pCteUse->nUse<2))\n@@ -135002,0 +139908,1 @@\n+      assert( pItem->pSelect && (pItem->pSelect->selFlags & SF_PushDown)!=0 );\n@@ -135011,3 +139918,4 @@\n-    ** The subquery is implemented as a co-routine if the subquery is\n-    ** guaranteed to be the outer loop (so that it does not need to be\n-    ** computed more than once)\n+    ** The subquery is implemented as a co-routine if:\n+    **    (1)  the subquery is guaranteed to be the outer loop (so that\n+    **         it does not need to be computed more than once), and\n+    **    (2)  the subquery is not a CTE that should be materialized\n@@ -135015,1 +139923,1 @@\n-    ** TODO: Are there other reasons beside (1) to use a co-routine\n+    ** TODO: Are there other reasons beside (1) and (2) to use a co-routine\n@@ -135021,0 +139929,1 @@\n+     && (pItem->fg.isCte==0 || pItem->u2.pCteUse->eM10d!=M10d_Yes)  \/* (2) *\/\n@@ -135029,1 +139938,1 @@\n-      VdbeComment((v, \"%s\", pItem->pTab->zName));\n+      VdbeComment((v, \"%!S\", pItem));\n@@ -135032,1 +139941,1 @@\n-      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n+      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %!S\", pItem));\n@@ -135040,6 +139949,24 @@\n-    }else{\n-      \/* Generate a subroutine that will fill an ephemeral table with\n-      ** the content of this subquery.  pItem->addrFillSub will point\n-      ** to the address of the generated subroutine.  pItem->regReturn\n-      ** is a register allocated to hold the subroutine return address\n-      *\/\n+    }else if( pItem->fg.isCte && pItem->u2.pCteUse->addrM9e>0 ){\n+      \/* This is a CTE for which materialization code has already been\n+      ** generated.  Invoke the subroutine to compute the materialization,\n+      ** the make the pItem->iCursor be a copy of the ephemerial table that\n+      ** holds the result of the materialization. *\/\n+      CteUse *pCteUse = pItem->u2.pCteUse;\n+      sqlite3VdbeAddOp2(v, OP_Gosub, pCteUse->regRtn, pCteUse->addrM9e);\n+      if( pItem->iCursor!=pCteUse->iCur ){\n+        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pCteUse->iCur);\n+        VdbeComment((v, \"%!S\", pItem));\n+      }\n+      pSub->nSelectRow = pCteUse->nRowEst;\n+    }else if( (pPrior = isSelfJoinView(pTabList, pItem))!=0 ){\n+      \/* This view has already been materialized by a prior entry in\n+      ** this same FROM clause.  Reuse it. *\/\n+      if( pPrior->addrFillSub ){\n+        sqlite3VdbeAddOp2(v, OP_Gosub, pPrior->regReturn, pPrior->addrFillSub);\n+      }\n+      sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n+      pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n+    }else{\n+      \/* Materialize the view.  If the view is not correlated, generate a\n+      ** subroutine to do the materialization so that subsequent uses of\n+      ** the same view can reuse the materialization. *\/\n@@ -135049,1 +139976,0 @@\n-      struct SrcList_item *pPrior;\n@@ -135051,1 +139977,0 @@\n-      testcase( pItem->addrFillSub==0 ); \/* Ticket c52b09c7f38903b1311 *\/\n@@ -135060,1 +139985,1 @@\n-        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n+        VdbeComment((v, \"materialize %!S\", pItem));\n@@ -135062,11 +139987,1 @@\n-        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n-      }\n-      pPrior = isSelfJoinView(pTabList, pItem);\n-      if( pPrior ){\n-        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n-        assert( pPrior->pSelect!=0 );\n-        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n-      }else{\n-        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n-        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n-        sqlite3Select(pParse, pSub, &dest);\n+        VdbeNoopComment((v, \"materialize %!S\", pItem));\n@@ -135074,0 +139989,3 @@\n+      sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n+      ExplainQueryPlan((pParse, 1, \"MATERIALIZE %!S\", pItem));\n+      sqlite3Select(pParse, pSub, &dest);\n@@ -135077,1 +139995,1 @@\n-      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n+      VdbeComment((v, \"end %!S\", pItem));\n@@ -135080,0 +139998,7 @@\n+      if( pItem->fg.isCte && pItem->fg.isCorrelated==0 ){\n+        CteUse *pCteUse = pItem->u2.pCteUse;\n+        pCteUse->addrM9e = pItem->addrFillSub;\n+        pCteUse->regRtn = pItem->regReturn;\n+        pCteUse->iCur = pItem->iCursor;\n+        pCteUse->nRowEst = pSub->nSelectRow;\n+      }\n@@ -135198,1 +140123,1 @@\n-    Window *pWin = p->pWin;      \/* Master window object (or NULL) *\/\n+    Window *pWin = p->pWin;      \/* Main window object (or NULL) *\/\n@@ -135224,0 +140149,1 @@\n+    SELECTTRACE(1,pParse,p,(\"WhereBegin returns\\n\"));\n@@ -135262,0 +140188,1 @@\n+      SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n@@ -135332,1 +140259,6 @@\n-    if( pAggInfo==0 ){\n+    if( pAggInfo ){\n+      sqlite3ParserAddCleanup(pParse,\n+          (void(*)(sqlite3*,void*))agginfoFree, pAggInfo);\n+      testcase( pParse->earlyCleanup );\n+    }\n+    if( db->mallocFailed ){\n@@ -135335,2 +140267,1 @@\n-    pAggInfo->pNext = pParse->pAggList;\n-    pParse->pAggList = pAggInfo;\n+    pAggInfo->selId = p->selId;\n@@ -135359,1 +140290,1 @@\n-      minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pExpr, &pMinMaxOrderBy);\n+      minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);\n@@ -135364,2 +140295,2 @@\n-      Expr *pExpr = pAggInfo->aFunc[i].pExpr;\n-      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n+      Expr *pExpr = pAggInfo->aFunc[i].pFExpr;\n+      assert( ExprUseXList(pExpr) );\n@@ -135383,0 +140314,4 @@\n+      if( minMaxFlag ){\n+        sqlite3DebugPrintf(\"MIN\/MAX Optimization (0x%02x) adds:\\n\", minMaxFlag);\n+        sqlite3TreeViewExprList(0, pMinMaxOrderBy, 0, \"ORDERBY\");\n+      }\n@@ -135386,1 +140321,1 @@\n-        sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pExpr, 0);\n+        sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pCExpr, 0);\n@@ -135391,1 +140326,1 @@\n-        sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pExpr, 0);\n+        sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pFExpr, 0);\n@@ -135410,0 +140345,16 @@\n+      ExprList *pDistinct = 0;\n+      u16 distFlag = 0;\n+      int eDist = WHERE_DISTINCT_NOOP;\n+\n+      if( pAggInfo->nFunc==1\n+       && pAggInfo->aFunc[0].iDistinct>=0\n+       && ALWAYS(pAggInfo->aFunc[0].pFExpr!=0)\n+       && ALWAYS(ExprUseXList(pAggInfo->aFunc[0].pFExpr))\n+       && pAggInfo->aFunc[0].pFExpr->x.pList!=0\n+      ){\n+        Expr *pExpr = pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr;\n+        pExpr = sqlite3ExprDup(db, pExpr, 0);\n+        pDistinct = sqlite3ExprListDup(db, pGroupBy, 0);\n+        pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);\n+        distFlag = pDistinct ? (WHERE_WANT_DISTINCT|WHERE_AGG_DISTINCT) : 0;\n+      }\n@@ -135446,2 +140397,2 @@\n-      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n-          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n+      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct,\n+          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0) | distFlag, 0\n@@ -135449,1 +140400,6 @@\n-      if( pWInfo==0 ) goto select_end;\n+      if( pWInfo==0 ){\n+        sqlite3ExprListDelete(db, pDistinct);\n+        goto select_end;\n+      }\n+      eDist = sqlite3WhereIsDistinct(pWInfo);\n+      SELECTTRACE(1,pParse,p,(\"WhereBegin returns\\n\"));\n@@ -135498,0 +140454,1 @@\n+        SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n@@ -135565,1 +140522,1 @@\n-      updateAccumulator(pParse, iUseFlag, pAggInfo);\n+      updateAccumulator(pParse, iUseFlag, pAggInfo, eDist);\n@@ -135572,1 +140529,1 @@\n-        sqlite3VdbeAddOp2(v, OP_SorterNext, pAggInfo->sortingIdx, addrTopOfLoop);\n+        sqlite3VdbeAddOp2(v, OP_SorterNext, pAggInfo->sortingIdx,addrTopOfLoop);\n@@ -135575,0 +140532,1 @@\n+        SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n@@ -135578,0 +140536,1 @@\n+      sqlite3ExprListDelete(db, pDistinct);\n@@ -135621,0 +140580,4 @@\n+      if( eDist!=WHERE_DISTINCT_NOOP ){\n+        struct AggInfo_func *pF = &pAggInfo->aFunc[0];\n+        fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n+      }\n@@ -135643,1 +140606,1 @@\n-        int iRoot = pTab->tnum;              \/* Root page of scanned b-tree *\/\n+        Pgno iRoot = pTab->tnum;             \/* Root page of scanned b-tree *\/\n@@ -135675,1 +140638,1 @@\n-        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n+        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, (int)iRoot, iDb, 1);\n@@ -135684,0 +140647,3 @@\n+        ExprList *pDistinct = 0;\n+        u16 distFlag = 0;\n+        int eDist;\n@@ -135696,1 +140662,1 @@\n-            if( ExprHasProperty(pAggInfo->aFunc[i].pExpr, EP_WinFunc) ){\n+            if( ExprHasProperty(pAggInfo->aFunc[i].pFExpr, EP_WinFunc) ){\n@@ -135707,0 +140673,4 @@\n+        }else if( pAggInfo->nFunc==1 && pAggInfo->aFunc[0].iDistinct>=0 ){\n+          assert( ExprUseXList(pAggInfo->aFunc[0].pFExpr) );\n+          pDistinct = pAggInfo->aFunc[0].pFExpr->x.pList;\n+          distFlag = pDistinct ? (WHERE_WANT_DISTINCT|WHERE_AGG_DISTINCT) : 0;\n@@ -135726,1 +140696,1 @@\n-                                   0, minMaxFlag, 0);\n+                                   pDistinct, minMaxFlag|distFlag, 0);\n@@ -135730,1 +140700,8 @@\n-        updateAccumulator(pParse, regAcc, pAggInfo);\n+        SELECTTRACE(1,pParse,p,(\"WhereBegin returns\\n\"));\n+        eDist = sqlite3WhereIsDistinct(pWInfo);\n+        updateAccumulator(pParse, regAcc, pAggInfo, eDist);\n+        if( eDist!=WHERE_DISTINCT_NOOP ){\n+          struct AggInfo_func *pF = &pAggInfo->aFunc[0];\n+          fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n+        }\n+\n@@ -135732,4 +140709,2 @@\n-        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n-          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n-          VdbeComment((v, \"%s() by index\",\n-                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n+        if( minMaxFlag ){\n+          sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);\n@@ -135737,0 +140712,1 @@\n+        SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n@@ -135776,0 +140752,2 @@\n+  assert( db->mallocFailed==0 || db->mallocFailed==1 );\n+  pParse->nErr += db->mallocFailed;\n@@ -135780,3 +140758,2 @@\n-      Expr *pExpr = pAggInfo->aCol[i].pExpr;\n-      assert( pExpr!=0 || db->mallocFailed );\n-      if( pExpr==0 ) continue;\n+      Expr *pExpr = pAggInfo->aCol[i].pCExpr;\n+      assert( pExpr!=0 );\n@@ -135787,3 +140764,2 @@\n-      Expr *pExpr = pAggInfo->aFunc[i].pExpr;\n-      assert( pExpr!=0 || db->mallocFailed );\n-      if( pExpr==0 ) continue;\n+      Expr *pExpr = pAggInfo->aFunc[i].pFExpr;\n+      assert( pExpr!=0 );\n@@ -136037,0 +141013,1 @@\n+    sqlite3SrcListDelete(db, pTmp->pFrom);\n@@ -136058,2 +141035,3 @@\n-  Schema * const pTmpSchema = pParse->db->aDb[1].pSchema;\n-  Trigger *pList = 0;                  \/* List of triggers to return *\/\n+  Schema *pTmpSchema;       \/* Schema of the pTab table *\/\n+  Trigger *pList;           \/* List of triggers to return *\/\n+  HashElem *p;              \/* Loop variable for TEMP triggers *\/\n@@ -136064,12 +141042,23 @@\n-\n-  if( pTmpSchema!=pTab->pSchema ){\n-    HashElem *p;\n-    assert( sqlite3SchemaMutexHeld(pParse->db, 0, pTmpSchema) );\n-    for(p=sqliteHashFirst(&pTmpSchema->trigHash); p; p=sqliteHashNext(p)){\n-      Trigger *pTrig = (Trigger *)sqliteHashData(p);\n-      if( pTrig->pTabSchema==pTab->pSchema\n-       && 0==sqlite3StrICmp(pTrig->table, pTab->zName)\n-      ){\n-        pTrig->pNext = (pList ? pList : pTab->pTrigger);\n-        pList = pTrig;\n-      }\n+  pTmpSchema = pParse->db->aDb[1].pSchema;\n+  p = sqliteHashFirst(&pTmpSchema->trigHash);\n+  pList = pTab->pTrigger;\n+  while( p ){\n+    Trigger *pTrig = (Trigger *)sqliteHashData(p);\n+    if( pTrig->pTabSchema==pTab->pSchema\n+     && pTrig->table\n+     && 0==sqlite3StrICmp(pTrig->table, pTab->zName)\n+     && pTrig->pTabSchema!=pTmpSchema\n+    ){\n+      pTrig->pNext = pList;\n+      pList = pTrig;\n+    }else if( pTrig->op==TK_RETURNING\n+#ifndef SQLITE_OMIT_VIRTUALTABLE\n+              && pParse->db->pVtabCtx==0\n+#endif\n+    ){\n+      assert( pParse->bReturning );\n+      assert( &(pParse->u1.pReturning->retTrig) == pTrig );\n+      pTrig->table = pTab->zName;\n+      pTrig->pTabSchema = pTab->pSchema;\n+      pTrig->pNext = pList;\n+      pList = pTrig;\n@@ -136077,0 +141066,1 @@\n+    p = sqliteHashNext(p);\n@@ -136078,2 +141068,12 @@\n-\n-  return (pList ? pList : pTab->pTrigger);\n+#if 0\n+  if( pList ){\n+    Trigger *pX;\n+    printf(\"Triggers for %s:\", pTab->zName);\n+    for(pX=pList; pX; pX=pX->pNext){\n+      printf(\" %s\", pX->zName);\n+    }\n+    printf(\"\\n\");\n+    fflush(stdout);\n+  }\n+#endif\n+  return pList;\n@@ -136139,1 +141139,1 @@\n-  ** name on pTableName if we are reparsing out of SQLITE_MASTER.\n+  ** name on pTableName if we are reparsing out of the schema table\n@@ -136167,12 +141167,1 @@\n-    if( db->init.iDb==1 ){\n-      \/* Ticket #3810.\n-      ** Normally, whenever a table is dropped, all associated triggers are\n-      ** dropped too.  But if a TEMP trigger is created on a non-TEMP table\n-      ** and the table is dropped by a different database connection, the\n-      ** trigger is not visible to the database connection that does the\n-      ** drop so the trigger cannot be dropped.  This results in an\n-      ** \"orphaned trigger\" - a trigger whose associated table is missing.\n-      *\/\n-      db->init.orphanTrigger = 1;\n-    }\n-    goto trigger_cleanup;\n+    goto trigger_orphan_error;\n@@ -136182,1 +141171,1 @@\n-    goto trigger_cleanup;\n+    goto trigger_orphan_error;\n@@ -136217,1 +141206,1 @@\n-  if( pTab->pSelect && tr_tm!=TK_INSTEAD ){\n+  if( IsView(pTab) && tr_tm!=TK_INSTEAD ){\n@@ -136219,2 +141208,2 @@\n-        (tr_tm == TK_BEFORE)?\"BEFORE\":\"AFTER\", pTableName, 0);\n-    goto trigger_cleanup;\n+        (tr_tm == TK_BEFORE)?\"BEFORE\":\"AFTER\", pTableName->a);\n+    goto trigger_orphan_error;\n@@ -136222,1 +141211,1 @@\n-  if( !pTab->pSelect && tr_tm==TK_INSTEAD ){\n+  if( !IsView(pTab) && tr_tm==TK_INSTEAD ){\n@@ -136224,2 +141213,2 @@\n-        \" trigger on table: %S\", pTableName, 0);\n-    goto trigger_cleanup;\n+        \" trigger on table: %S\", pTableName->a);\n+    goto trigger_orphan_error;\n@@ -136285,0 +141274,17 @@\n+  return;\n+\n+trigger_orphan_error:\n+  if( db->init.iDb==1 ){\n+    \/* Ticket #3810.\n+    ** Normally, whenever a table is dropped, all associated triggers are\n+    ** dropped too.  But if a TEMP trigger is created on a non-TEMP table\n+    ** and the table is dropped by a different database connection, the\n+    ** trigger is not visible to the database connection that does the\n+    ** drop so the trigger cannot be dropped.  This results in an\n+    ** \"orphaned trigger\" - a trigger whose associated table is missing.\n+    **\n+    ** 2020-11-05 see also https:\/\/sqlite.org\/forum\/forumpost\/157dc791df\n+    *\/\n+    db->init.orphanTrigger = 1;\n+  }\n+  goto trigger_cleanup;\n@@ -136329,1 +141335,1 @@\n-  ** build the sqlite_master entry\n+  ** build the sqlite_schema entry\n@@ -136335,1 +141341,1 @@\n-    \/* Make an entry in the sqlite_master table *\/\n+    \/* Make an entry in the sqlite_schema table *\/\n@@ -136342,2 +141348,3 @@\n-       \"INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')\",\n-       db->aDb[iDb].zDbSName, MASTER_NAME, zName,\n+       \"INSERT INTO %Q.\" LEGACY_SCHEMA_TABLE\n+       \" VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')\",\n+       db->aDb[iDb].zDbSName, zName,\n@@ -136348,1 +141355,1 @@\n-        sqlite3MPrintf(db, \"type='trigger' AND name='%q'\", zName));\n+        sqlite3MPrintf(db, \"type='trigger' AND name='%q'\", zName), 0);\n@@ -136496,0 +141503,1 @@\n+  SrcList *pFrom,\n@@ -136510,0 +141518,1 @@\n+      pTriggerStep->pFrom = pFrom;\n@@ -136512,0 +141521,1 @@\n+      pFrom = 0;\n@@ -136515,0 +141525,1 @@\n+      pTriggerStep->pFrom = sqlite3SrcListDup(db, pFrom, EXPRDUP_REDUCE);\n@@ -136520,0 +141531,1 @@\n+  sqlite3SrcListDelete(db, pFrom);\n@@ -136556,1 +141568,1 @@\n-  if( pTrigger==0 ) return;\n+  if( pTrigger==0 || pTrigger->bReturning ) return;\n@@ -136598,1 +141610,1 @@\n-      sqlite3ErrorMsg(pParse, \"no such trigger: %S\", pName, 0);\n+      sqlite3ErrorMsg(pParse, \"no such trigger: %S\", pName->a);\n@@ -136650,2 +141662,2 @@\n-       \"DELETE FROM %Q.%s WHERE name=%Q AND type='trigger'\",\n-       db->aDb[iDb].zDbSName, MASTER_NAME, pTrigger->zName\n+       \"DELETE FROM %Q.\" LEGACY_SCHEMA_TABLE \" WHERE name=%Q AND type='trigger'\",\n+       db->aDb[iDb].zDbSName, pTrigger->zName\n@@ -136721,7 +141733,18 @@\n-  if( (pParse->db->flags & SQLITE_EnableTrigger)!=0 ){\n-    pList = sqlite3TriggerList(pParse, pTab);\n-  }\n-  assert( pList==0 || IsVirtual(pTab)==0 );\n-  for(p=pList; p; p=p->pNext){\n-    if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){\n-      mask |= p->tr_tm;\n+  pList = sqlite3TriggerList(pParse, pTab);\n+  assert( pList==0 || IsVirtual(pTab)==0\n+           || (pList->bReturning && pList->pNext==0) );\n+  if( pList!=0 ){\n+    p = pList;\n+    if( (pParse->db->flags & SQLITE_EnableTrigger)==0\n+     && pTab->pTrigger!=0\n+    ){\n+      \/* The SQLITE_DBCONFIG_ENABLE_TRIGGER setting is off.  That means that\n+      ** only TEMP triggers are allowed.  Truncate the pList so that it\n+      ** includes only TEMP triggers *\/\n+      if( pList==pTab->pTrigger ){\n+        pList = 0;\n+        goto exit_triggers_exist;\n+      }\n+      while( ALWAYS(p->pNext) && p->pNext!=pTab->pTrigger ) p = p->pNext;\n+      p->pNext = 0;\n+      p = pList;\n@@ -136729,0 +141752,26 @@\n+    do{\n+      if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){\n+        mask |= p->tr_tm;\n+      }else if( p->op==TK_RETURNING ){\n+        \/* The first time a RETURNING trigger is seen, the \"op\" value tells\n+        ** us what time of trigger it should be. *\/\n+        assert( sqlite3IsToplevel(pParse) );\n+        p->op = op;\n+        if( IsVirtual(pTab) ){\n+          if( op!=TK_INSERT ){\n+            sqlite3ErrorMsg(pParse,\n+              \"%s RETURNING is not available on virtual tables\",\n+              op==TK_DELETE ? \"DELETE\" : \"UPDATE\");\n+          }\n+          p->tr_tm = TRIGGER_BEFORE;\n+        }else{\n+          p->tr_tm = TRIGGER_AFTER;\n+        }\n+        mask |= p->tr_tm;\n+      }else if( p->bReturning && p->op==TK_INSERT && op==TK_UPDATE\n+                && sqlite3IsToplevel(pParse) ){\n+        \/* Also fire a RETURNING trigger for an UPSERT *\/\n+        mask |= p->tr_tm;\n+      }\n+      p = p->pNext;\n+    }while( p );\n@@ -136730,0 +141779,1 @@\n+exit_triggers_exist:\n@@ -136746,1 +141796,1 @@\n-static SrcList *targetSrcList(\n+SQLITE_PRIVATE SrcList *sqlite3TriggerStepSrc(\n@@ -136751,3 +141801,2 @@\n-  int iDb;             \/* Index of the database to use *\/\n-  SrcList *pSrc;       \/* SrcList to be returned *\/\n-\n+  SrcList *pSrc;                  \/* SrcList to be returned *\/\n+  char *zName = sqlite3DbStrDup(db, pStep->zTarget);\n@@ -136755,0 +141804,2 @@\n+  assert( pSrc==0 || pSrc->nSrc==1 );\n+  assert( zName || pSrc==0 );\n@@ -136756,8 +141807,4 @@\n-    assert( pSrc->nSrc>0 );\n-    pSrc->a[pSrc->nSrc-1].zName = sqlite3DbStrDup(db, pStep->zTarget);\n-    iDb = sqlite3SchemaToIndex(db, pStep->pTrig->pSchema);\n-    if( iDb==0 || iDb>=2 ){\n-      const char *zDb;\n-      assert( iDb<db->nDb );\n-      zDb = db->aDb[iDb].zDbSName;\n-      pSrc->a[pSrc->nSrc-1].zDatabase =  sqlite3DbStrDup(db, zDb);\n+    Schema *pSchema = pStep->pTrig->pSchema;\n+    pSrc->a[0].zName = zName;\n+    if( pSchema!=db->aDb[1].pSchema ){\n+      pSrc->a[0].pSchema = pSchema;\n@@ -136765,0 +141812,6 @@\n+    if( pStep->pFrom ){\n+      SrcList *pDup = sqlite3SrcListDup(db, pStep->pFrom, 0);\n+      pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);\n+    }\n+  }else{\n+    sqlite3DbFree(db, zName);\n@@ -136769,0 +141822,135 @@\n+\/*\n+** Return true if the pExpr term from the RETURNING clause argument\n+** list is of the form \"*\".  Raise an error if the terms if of the\n+** form \"table.*\".\n+*\/\n+static int isAsteriskTerm(\n+  Parse *pParse,      \/* Parsing context *\/\n+  Expr *pTerm         \/* A term in the RETURNING clause *\/\n+){\n+  assert( pTerm!=0 );\n+  if( pTerm->op==TK_ASTERISK ) return 1;\n+  if( pTerm->op!=TK_DOT ) return 0;\n+  assert( pTerm->pRight!=0 );\n+  assert( pTerm->pLeft!=0 );\n+  if( pTerm->pRight->op!=TK_ASTERISK ) return 0;\n+  sqlite3ErrorMsg(pParse, \"RETURNING may not use \\\"TABLE.*\\\" wildcards\");\n+  return 1;\n+}\n+\n+\/* The input list pList is the list of result set terms from a RETURNING\n+** clause.  The table that we are returning from is pTab.\n+**\n+** This routine makes a copy of the pList, and at the same time expands\n+** any \"*\" wildcards to be the complete set of columns from pTab.\n+*\/\n+static ExprList *sqlite3ExpandReturning(\n+  Parse *pParse,        \/* Parsing context *\/\n+  ExprList *pList,      \/* The arguments to RETURNING *\/\n+  Table *pTab           \/* The table being updated *\/\n+){\n+  ExprList *pNew = 0;\n+  sqlite3 *db = pParse->db;\n+  int i;\n+\n+  for(i=0; i<pList->nExpr; i++){\n+    Expr *pOldExpr = pList->a[i].pExpr;\n+    if( NEVER(pOldExpr==0) ) continue;\n+    if( isAsteriskTerm(pParse, pOldExpr) ){\n+      int jj;\n+      for(jj=0; jj<pTab->nCol; jj++){\n+        Expr *pNewExpr;\n+        if( IsHiddenColumn(pTab->aCol+jj) ) continue;\n+        pNewExpr = sqlite3Expr(db, TK_ID, pTab->aCol[jj].zCnName);\n+        pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);\n+        if( !db->mallocFailed ){\n+          struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];\n+          pItem->zEName = sqlite3DbStrDup(db, pTab->aCol[jj].zCnName);\n+          pItem->eEName = ENAME_NAME;\n+        }\n+      }\n+    }else{\n+      Expr *pNewExpr = sqlite3ExprDup(db, pOldExpr, 0);\n+      pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);\n+      if( !db->mallocFailed && ALWAYS(pList->a[i].zEName!=0) ){\n+        struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];\n+        pItem->zEName = sqlite3DbStrDup(db, pList->a[i].zEName);\n+        pItem->eEName = pList->a[i].eEName;\n+      }\n+    }\n+  }\n+  return pNew;\n+}\n+\n+\/*\n+** Generate code for the RETURNING trigger.  Unlike other triggers\n+** that invoke a subprogram in the bytecode, the code for RETURNING\n+** is generated in-line.\n+*\/\n+static void codeReturningTrigger(\n+  Parse *pParse,       \/* Parse context *\/\n+  Trigger *pTrigger,   \/* The trigger step that defines the RETURNING *\/\n+  Table *pTab,         \/* The table to code triggers from *\/\n+  int regIn            \/* The first in an array of registers *\/\n+){\n+  Vdbe *v = pParse->pVdbe;\n+  sqlite3 *db = pParse->db;\n+  ExprList *pNew;\n+  Returning *pReturning;\n+  Select sSelect;\n+  SrcList sFrom;\n+\n+  assert( v!=0 );\n+  assert( pParse->bReturning );\n+  pReturning = pParse->u1.pReturning;\n+  assert( pTrigger == &(pReturning->retTrig) );\n+  memset(&sSelect, 0, sizeof(sSelect));\n+  memset(&sFrom, 0, sizeof(sFrom));\n+  sSelect.pEList = sqlite3ExprListDup(db, pReturning->pReturnEL, 0);\n+  sSelect.pSrc = &sFrom;\n+  sFrom.nSrc = 1;\n+  sFrom.a[0].pTab = pTab;\n+  sFrom.a[0].iCursor = -1;\n+  sqlite3SelectPrep(pParse, &sSelect, 0);\n+  if( db->mallocFailed==0 && pParse->nErr==0 ){\n+    sqlite3GenerateColumnNames(pParse, &sSelect);\n+  }\n+  sqlite3ExprListDelete(db, sSelect.pEList);\n+  pNew = sqlite3ExpandReturning(pParse, pReturning->pReturnEL, pTab);\n+  if( !db->mallocFailed ){\n+    NameContext sNC;\n+    memset(&sNC, 0, sizeof(sNC));\n+    if( pReturning->nRetCol==0 ){\n+      pReturning->nRetCol = pNew->nExpr;\n+      pReturning->iRetCur = pParse->nTab++;\n+    }\n+    sNC.pParse = pParse;\n+    sNC.uNC.iBaseReg = regIn;\n+    sNC.ncFlags = NC_UBaseReg;\n+    pParse->eTriggerOp = pTrigger->op;\n+    pParse->pTriggerTab = pTab;\n+    if( sqlite3ResolveExprListNames(&sNC, pNew)==SQLITE_OK\n+     && !db->mallocFailed\n+    ){\n+      int i;\n+      int nCol = pNew->nExpr;\n+      int reg = pParse->nMem+1;\n+      pParse->nMem += nCol+2;\n+      pReturning->iRetReg = reg;\n+      for(i=0; i<nCol; i++){\n+        Expr *pCol = pNew->a[i].pExpr;\n+        assert( pCol!=0 ); \/* Due to !db->mallocFailed ~9 lines above *\/\n+        sqlite3ExprCodeFactorable(pParse, pCol, reg+i);\n+      }\n+      sqlite3VdbeAddOp3(v, OP_MakeRecord, reg, i, reg+i);\n+      sqlite3VdbeAddOp2(v, OP_NewRowid, pReturning->iRetCur, reg+i+1);\n+      sqlite3VdbeAddOp3(v, OP_Insert, pReturning->iRetCur, reg+i, reg+i+1);\n+    }\n+  }\n+  sqlite3ExprListDelete(db, pNew);\n+  pParse->eTriggerOp = 0;\n+  pParse->pTriggerTab = 0;\n+}\n+\n+\n+\n@@ -136813,1 +142001,1 @@\n-          targetSrcList(pParse, pStep),\n+          sqlite3TriggerStepSrc(pParse, pStep),\n@@ -136818,0 +142006,1 @@\n+        sqlite3VdbeAddOp0(v, OP_ResetCount);\n@@ -136822,1 +142011,1 @@\n-          targetSrcList(pParse, pStep),\n+          sqlite3TriggerStepSrc(pParse, pStep),\n@@ -136828,0 +142017,1 @@\n+        sqlite3VdbeAddOp0(v, OP_ResetCount);\n@@ -136832,1 +142022,1 @@\n-          targetSrcList(pParse, pStep),\n+          sqlite3TriggerStepSrc(pParse, pStep),\n@@ -136835,0 +142025,1 @@\n+        sqlite3VdbeAddOp0(v, OP_ResetCount);\n@@ -136846,3 +142037,0 @@\n-    if( pStep->op!=TK_SELECT ){\n-      sqlite3VdbeAddOp0(v, OP_ResetCount);\n-    }\n@@ -136964,2 +142152,2 @@\n-      if( SQLITE_OK==sqlite3ResolveExprNames(&sNC, pWhen)\n-       && db->mallocFailed==0\n+      if( db->mallocFailed==0\n+       && SQLITE_OK==sqlite3ResolveExprNames(&sNC, pWhen)\n@@ -136995,1 +142183,0 @@\n-  assert( !pSubParse->pAinc       && !pSubParse->pZombieTab );\n@@ -137097,1 +142284,1 @@\n-**   reg+N+2        OLD.* value of left-most column of pTab\n+**   reg+N+2        NEW.* value of left-most column of pTab\n@@ -137142,2 +142329,6 @@\n-    \/* Determine whether we should code this trigger *\/\n-    if( p->op==op\n+    \/* Determine whether we should code this trigger.  One of two choices:\n+    **   1. The trigger is an exact match to the current DML statement\n+    **   2. This is a RETURNING trigger for INSERT but we are currently\n+    **      doing the UPDATE part of an UPSERT.\n+    *\/\n+    if( (p->op==op || (p->bReturning && p->op==TK_INSERT && op==TK_UPDATE))\n@@ -137147,1 +142338,5 @@\n-      sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);\n+      if( !p->bReturning ){\n+        sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);\n+      }else if( sqlite3IsToplevel(pParse) ){\n+        codeReturningTrigger(pParse, p, pTab, reg);\n+      }\n@@ -137192,1 +142387,2 @@\n-    if( p->op==op && (tr_tm&p->tr_tm)\n+    if( p->op==op\n+     && (tr_tm&p->tr_tm)\n@@ -137195,4 +142391,8 @@\n-      TriggerPrg *pPrg;\n-      pPrg = getRowTrigger(pParse, p, pTab, orconf);\n-      if( pPrg ){\n-        mask |= pPrg->aColmask[isNew];\n+      if( p->bReturning ){\n+        mask = 0xffffffff;\n+      }else{\n+        TriggerPrg *pPrg;\n+        pPrg = getRowTrigger(pParse, p, pTab, orconf);\n+        if( pPrg ){\n+          mask |= pPrg->aColmask[isNew];\n+        }\n@@ -137258,1 +142458,1 @@\n-** into the sqlite_master table.)\n+** into the sqlite_schema table.)\n@@ -137272,1 +142472,1 @@\n-  if( !pTab->pSelect ){\n+  if( !IsView(pTab) ){\n@@ -137276,1 +142476,1 @@\n-    VdbeComment((v, \"%s.%s\", pTab->zName, pCol->zName));\n+    VdbeComment((v, \"%s.%s\", pTab->zName, pCol->zCnName));\n@@ -137278,1 +142478,2 @@\n-    sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc,\n+    sqlite3ValueFromExpr(sqlite3VdbeDb(v),\n+                         sqlite3ColumnExpr(pTab,pCol), enc,\n@@ -137342,0 +142543,138 @@\n+\/*\n+** Allocate and return a pointer to an expression of type TK_ROW with\n+** Expr.iColumn set to value (iCol+1). The resolver will modify the\n+** expression to be a TK_COLUMN reading column iCol of the first\n+** table in the source-list (pSrc->a[0]).\n+*\/\n+static Expr *exprRowColumn(Parse *pParse, int iCol){\n+  Expr *pRet = sqlite3PExpr(pParse, TK_ROW, 0, 0);\n+  if( pRet ) pRet->iColumn = iCol+1;\n+  return pRet;\n+}\n+\n+\/*\n+** Assuming both the pLimit and pOrderBy parameters are NULL, this function\n+** generates VM code to run the query:\n+**\n+**   SELECT <other-columns>, pChanges FROM pTabList WHERE pWhere\n+**\n+** and write the results to the ephemeral table already opened as cursor\n+** iEph. None of pChanges, pTabList or pWhere are modified or consumed by\n+** this function, they must be deleted by the caller.\n+**\n+** Or, if pLimit and pOrderBy are not NULL, and pTab is not a view:\n+**\n+**   SELECT <other-columns>, pChanges FROM pTabList\n+**   WHERE pWhere\n+**   GROUP BY <other-columns>\n+**   ORDER BY pOrderBy LIMIT pLimit\n+**\n+** If pTab is a view, the GROUP BY clause is omitted.\n+**\n+** Exactly how results are written to table iEph, and exactly what\n+** the <other-columns> in the query above are is determined by the type\n+** of table pTabList->a[0].pTab.\n+**\n+** If the table is a WITHOUT ROWID table, then argument pPk must be its\n+** PRIMARY KEY. In this case <other-columns> are the primary key columns\n+** of the table, in order. The results of the query are written to ephemeral\n+** table iEph as index keys, using OP_IdxInsert.\n+**\n+** If the table is actually a view, then <other-columns> are all columns of\n+** the view. The results are written to the ephemeral table iEph as records\n+** with automatically assigned integer keys.\n+**\n+** If the table is a virtual or ordinary intkey table, then <other-columns>\n+** is its rowid. For a virtual table, the results are written to iEph as\n+** records with automatically assigned integer keys For intkey tables, the\n+** rowid value in <other-columns> is used as the integer key, and the\n+** remaining fields make up the table record.\n+*\/\n+static void updateFromSelect(\n+  Parse *pParse,                  \/* Parse context *\/\n+  int iEph,                       \/* Cursor for open eph. table *\/\n+  Index *pPk,                     \/* PK if table 0 is WITHOUT ROWID *\/\n+  ExprList *pChanges,             \/* List of expressions to return *\/\n+  SrcList *pTabList,              \/* List of tables to select from *\/\n+  Expr *pWhere,                   \/* WHERE clause for query *\/\n+  ExprList *pOrderBy,             \/* ORDER BY clause *\/\n+  Expr *pLimit                    \/* LIMIT clause *\/\n+){\n+  int i;\n+  SelectDest dest;\n+  Select *pSelect = 0;\n+  ExprList *pList = 0;\n+  ExprList *pGrp = 0;\n+  Expr *pLimit2 = 0;\n+  ExprList *pOrderBy2 = 0;\n+  sqlite3 *db = pParse->db;\n+  Table *pTab = pTabList->a[0].pTab;\n+  SrcList *pSrc;\n+  Expr *pWhere2;\n+  int eDest;\n+\n+#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n+  if( pOrderBy && pLimit==0 ) {\n+    sqlite3ErrorMsg(pParse, \"ORDER BY without LIMIT on UPDATE\");\n+    return;\n+  }\n+  pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);\n+  pLimit2 = sqlite3ExprDup(db, pLimit, 0);\n+#else\n+  UNUSED_PARAMETER(pOrderBy);\n+  UNUSED_PARAMETER(pLimit);\n+#endif\n+\n+  pSrc = sqlite3SrcListDup(db, pTabList, 0);\n+  pWhere2 = sqlite3ExprDup(db, pWhere, 0);\n+\n+  assert( pTabList->nSrc>1 );\n+  if( pSrc ){\n+    pSrc->a[0].fg.notCte = 1;\n+    pSrc->a[0].iCursor = -1;\n+    pSrc->a[0].pTab->nTabRef--;\n+    pSrc->a[0].pTab = 0;\n+  }\n+  if( pPk ){\n+    for(i=0; i<pPk->nKeyCol; i++){\n+      Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);\n+#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n+      if( pLimit ){\n+        pGrp = sqlite3ExprListAppend(pParse, pGrp, sqlite3ExprDup(db, pNew, 0));\n+      }\n+#endif\n+      pList = sqlite3ExprListAppend(pParse, pList, pNew);\n+    }\n+    eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;\n+  }else if( IsView(pTab) ){\n+    for(i=0; i<pTab->nCol; i++){\n+      pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));\n+    }\n+    eDest = SRT_Table;\n+  }else{\n+    eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;\n+    pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));\n+#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n+    if( pLimit ){\n+      pGrp = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));\n+    }\n+#endif\n+  }\n+  assert( pChanges!=0 || pParse->db->mallocFailed );\n+  if( pChanges ){\n+    for(i=0; i<pChanges->nExpr; i++){\n+      pList = sqlite3ExprListAppend(pParse, pList,\n+          sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)\n+      );\n+    }\n+  }\n+  pSelect = sqlite3SelectNew(pParse, pList,\n+      pSrc, pWhere2, pGrp, 0, pOrderBy2, SF_UFSrcCheck|SF_IncludeHidden, pLimit2\n+  );\n+  if( pSelect ) pSelect->selFlags |= SF_OrderByReqd;\n+  sqlite3SelectDestInit(&dest, eDest, iEph);\n+  dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);\n+  sqlite3Select(pParse, pSelect, &dest);\n+  sqlite3SelectDelete(db, pSelect);\n+}\n+\n@@ -137345,3 +142684,5 @@\n-**   UPDATE OR IGNORE table_wxyz SET a=b, c=d WHERE e<5 AND f NOT NULL;\n-**          \\_______\/ \\________\/     \\______\/       \\________________\/\n-*            onError   pTabList      pChanges             pWhere\n+**   UPDATE OR IGNORE tbl SET a=b, c=d FROM tbl2... WHERE e<5 AND f NOT NULL;\n+**          \\_______\/ \\_\/     \\______\/      \\_____\/       \\________________\/\n+**           onError   |      pChanges         |                pWhere\n+**                     \\_______________________\/\n+**                               pTabList\n@@ -137362,1 +142703,1 @@\n-  WhereInfo *pWInfo;     \/* Information about the WHERE clause *\/\n+  WhereInfo *pWInfo = 0; \/* Information about the WHERE clause *\/\n@@ -137381,0 +142722,1 @@\n+  int iRowidExpr = -1;   \/* Index of \"rowid=\" (or IPK) assignment in pChanges *\/\n@@ -137404,0 +142746,1 @@\n+  int nChangeFrom = 0;   \/* If there is a FROM, pChanges->nExpr, else 0 *\/\n@@ -137419,1 +142762,0 @@\n-  assert( pTabList->nSrc==1 );\n@@ -137432,1 +142774,1 @@\n-  isView = pTab->pSelect!=0;\n+  isView = IsView(pTab);\n@@ -137444,0 +142786,7 @@\n+  \/* If there was a FROM clause, set nChangeFrom to the number of expressions\n+  ** in the change-list. Otherwise, set it to 0. There cannot be a FROM\n+  ** clause if this function is being called to generate code for part of\n+  ** an UPSERT statement.  *\/\n+  nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;\n+  assert( nChangeFrom==0 || pUpsert==0 );\n+\n@@ -137445,1 +142794,1 @@\n-  if( !isView ){\n+  if( !isView && nChangeFrom==0 ){\n@@ -137514,1 +142863,4 @@\n-    if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){\n+    u8 hCol = sqlite3StrIHash(pChanges->a[i].zEName);\n+    \/* If this is an UPDATE with a FROM clause, do not resolve expressions\n+    ** here. The call to sqlite3Select() below will do that. *\/\n+    if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){\n@@ -137518,1 +142870,3 @@\n-      if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zEName)==0 ){\n+      if( pTab->aCol[j].hName==hCol\n+       && sqlite3StrICmp(pTab->aCol[j].zCnName, pChanges->a[i].zEName)==0\n+      ){\n@@ -137522,0 +142876,1 @@\n+          iRowidExpr = i;\n@@ -137531,1 +142886,1 @@\n-             pTab->aCol[j].zName);\n+             pTab->aCol[j].zCnName);\n@@ -137544,0 +142899,1 @@\n+        iRowidExpr = i;\n@@ -137554,1 +142910,1 @@\n-                            j<0 ? \"ROWID\" : pTab->aCol[j].zName,\n+                            j<0 ? \"ROWID\" : pTab->aCol[j].zCnName,\n@@ -137586,2 +142942,4 @@\n-        if( sqlite3ExprReferencesUpdatedColumn(pTab->aCol[i].pDflt,\n-                                               aXRef, chngRowid) ){\n+        if( sqlite3ExprReferencesUpdatedColumn(\n+                sqlite3ColumnExpr(pTab, &pTab->aCol[i]),\n+                 aXRef, chngRowid)\n+        ){\n@@ -137673,1 +143031,1 @@\n-  if( isView ){\n+  if( nChangeFrom==0 && isView ){\n@@ -137685,1 +143043,1 @@\n-  if( sqlite3ResolveExprNames(&sNC, pWhere) ){\n+  if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){\n@@ -137706,0 +143064,1 @@\n+   && !pParse->bReturning\n@@ -137712,1 +143071,1 @@\n-  if( HasRowid(pTab) ){\n+  if( nChangeFrom==0 && HasRowid(pTab) ){\n@@ -137714,0 +143073,2 @@\n+    iEph = pParse->nTab++;\n+    addrOpen = sqlite3VdbeAddOp3(v, OP_OpenEphemeral, iEph, 0, regRowSet);\n@@ -137715,2 +143076,2 @@\n-    assert( pPk!=0 );\n-    nPk = pPk->nKeyCol;\n+    assert( pPk!=0 || HasRowid(pTab) );\n+    nPk = pPk ? pPk->nKeyCol : 0;\n@@ -137719,0 +143080,1 @@\n+    pParse->nMem += nChangeFrom;\n@@ -137721,0 +143083,1 @@\n+      int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);\n@@ -137722,3 +143085,17 @@\n-        sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);\n-      addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nPk);\n-      sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n+      if( pPk ) sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);\n+      addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);\n+      if( pPk ){\n+        KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);\n+        if( pKeyInfo ){\n+          pKeyInfo->nAllField = nEphCol;\n+          sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);\n+        }\n+      }\n+      if( nChangeFrom ){\n+        updateFromSelect(\n+            pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit\n+        );\n+#ifndef SQLITE_OMIT_SUBQUERY\n+        if( isView ) iDataCur = iEph;\n+#endif\n+      }\n@@ -137728,10 +143105,5 @@\n-  if( pUpsert ){\n-    \/* If this is an UPSERT, then all cursors have already been opened by\n-    ** the outer INSERT and the data cursor should be pointing at the row\n-    ** that is to be updated.  So bypass the code that searches for the\n-    ** row(s) to be updated.\n-    *\/\n-    pWInfo = 0;\n-    eOnePass = ONEPASS_SINGLE;\n-    sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);\n-    bFinishSeek = 0;\n+  if( nChangeFrom ){\n+    sqlite3MultiWrite(pParse);\n+    eOnePass = ONEPASS_OFF;\n+    nKey = nPk;\n+    regKey = iPk;\n@@ -137739,32 +143111,45 @@\n-    \/* Begin the database scan.\n-    **\n-    ** Do not consider a single-pass strategy for a multi-row update if\n-    ** there are any triggers or foreign keys to process, or rows may\n-    ** be deleted as a result of REPLACE conflict handling. Any of these\n-    ** things might disturb a cursor being used to scan through the table\n-    ** or index, causing a single-pass approach to malfunction.  *\/\n-    flags = WHERE_ONEPASS_DESIRED|WHERE_SEEK_UNIQ_TABLE;\n-    if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){\n-      flags |= WHERE_ONEPASS_MULTIROW;\n-    }\n-    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags, iIdxCur);\n-    if( pWInfo==0 ) goto update_cleanup;\n-\n-    \/* A one-pass strategy that might update more than one row may not\n-    ** be used if any column of the index used for the scan is being\n-    ** updated. Otherwise, if there is an index on \"b\", statements like\n-    ** the following could create an infinite loop:\n-    **\n-    **   UPDATE t1 SET b=b+1 WHERE b>?\n-    **\n-    ** Fall back to ONEPASS_OFF if where.c has selected a ONEPASS_MULTI\n-    ** strategy that uses an index for which one or more columns are being\n-    ** updated.  *\/\n-    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n-    bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);\n-    if( eOnePass!=ONEPASS_SINGLE ){\n-      sqlite3MultiWrite(pParse);\n-      if( eOnePass==ONEPASS_MULTI ){\n-        int iCur = aiCurOnePass[1];\n-        if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){\n-          eOnePass = ONEPASS_OFF;\n+    if( pUpsert ){\n+      \/* If this is an UPSERT, then all cursors have already been opened by\n+      ** the outer INSERT and the data cursor should be pointing at the row\n+      ** that is to be updated.  So bypass the code that searches for the\n+      ** row(s) to be updated.\n+      *\/\n+      pWInfo = 0;\n+      eOnePass = ONEPASS_SINGLE;\n+      sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);\n+      bFinishSeek = 0;\n+    }else{\n+      \/* Begin the database scan.\n+      **\n+      ** Do not consider a single-pass strategy for a multi-row update if\n+      ** there are any triggers or foreign keys to process, or rows may\n+      ** be deleted as a result of REPLACE conflict handling. Any of these\n+      ** things might disturb a cursor being used to scan through the table\n+      ** or index, causing a single-pass approach to malfunction.  *\/\n+      flags = WHERE_ONEPASS_DESIRED;\n+      if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){\n+        flags |= WHERE_ONEPASS_MULTIROW;\n+      }\n+      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags,iIdxCur);\n+      if( pWInfo==0 ) goto update_cleanup;\n+\n+      \/* A one-pass strategy that might update more than one row may not\n+      ** be used if any column of the index used for the scan is being\n+      ** updated. Otherwise, if there is an index on \"b\", statements like\n+      ** the following could create an infinite loop:\n+      **\n+      **   UPDATE t1 SET b=b+1 WHERE b>?\n+      **\n+      ** Fall back to ONEPASS_OFF if where.c has selected a ONEPASS_MULTI\n+      ** strategy that uses an index for which one or more columns are being\n+      ** updated.  *\/\n+      eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n+      bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);\n+      if( eOnePass!=ONEPASS_SINGLE ){\n+        sqlite3MultiWrite(pParse);\n+        if( eOnePass==ONEPASS_MULTI ){\n+          int iCur = aiCurOnePass[1];\n+          if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){\n+            eOnePass = ONEPASS_OFF;\n+          }\n+          assert( iCur!=iDataCur || !HasRowid(pTab) );\n@@ -137772,1 +143157,0 @@\n-        assert( iCur!=iDataCur || !HasRowid(pTab) );\n@@ -137775,1 +143159,0 @@\n-  }\n@@ -137777,25 +143160,11 @@\n-  if( HasRowid(pTab) ){\n-    \/* Read the rowid of the current row of the WHERE scan. In ONEPASS_OFF\n-    ** mode, write the rowid into the FIFO. In either of the one-pass modes,\n-    ** leave it in register regOldRowid.  *\/\n-    sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);\n-    if( eOnePass==ONEPASS_OFF ){\n-      \/* We need to use regRowSet, so reallocate aRegIdx[nAllIdx] *\/\n-      aRegIdx[nAllIdx] = ++pParse->nMem;\n-      sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);\n-    }\n-  }else{\n-    \/* Read the PK of the current row into an array of registers. In\n-    ** ONEPASS_OFF mode, serialize the array into a record and store it in\n-    ** the ephemeral table. Or, in ONEPASS_SINGLE or MULTI mode, change\n-    ** the OP_OpenEphemeral instruction to a Noop (the ephemeral table\n-    ** is not required) and leave the PK fields in the array of registers.  *\/\n-    for(i=0; i<nPk; i++){\n-      assert( pPk->aiColumn[i]>=0 );\n-      sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,\n-                                      pPk->aiColumn[i], iPk+i);\n-    }\n-    if( eOnePass ){\n-      if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);\n-      nKey = nPk;\n-      regKey = iPk;\n+    if( HasRowid(pTab) ){\n+      \/* Read the rowid of the current row of the WHERE scan. In ONEPASS_OFF\n+      ** mode, write the rowid into the FIFO. In either of the one-pass modes,\n+      ** leave it in register regOldRowid.  *\/\n+      sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);\n+      if( eOnePass==ONEPASS_OFF ){\n+        aRegIdx[nAllIdx] = ++pParse->nMem;\n+        sqlite3VdbeAddOp3(v, OP_Insert, iEph, regRowSet, regOldRowid);\n+      }else{\n+        if( ALWAYS(addrOpen) ) sqlite3VdbeChangeToNoop(v, addrOpen);\n+      }\n@@ -137803,3 +143172,19 @@\n-      sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,\n-                        sqlite3IndexAffinityStr(db, pPk), nPk);\n-      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);\n+      \/* Read the PK of the current row into an array of registers. In\n+      ** ONEPASS_OFF mode, serialize the array into a record and store it in\n+      ** the ephemeral table. Or, in ONEPASS_SINGLE or MULTI mode, change\n+      ** the OP_OpenEphemeral instruction to a Noop (the ephemeral table\n+      ** is not required) and leave the PK fields in the array of registers.  *\/\n+      for(i=0; i<nPk; i++){\n+        assert( pPk->aiColumn[i]>=0 );\n+        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,\n+                                        pPk->aiColumn[i], iPk+i);\n+      }\n+      if( eOnePass ){\n+        if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);\n+        nKey = nPk;\n+        regKey = iPk;\n+      }else{\n+        sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,\n+                          sqlite3IndexAffinityStr(db, pPk), nPk);\n+        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);\n+      }\n@@ -137810,1 +143195,1 @@\n-    if( eOnePass!=ONEPASS_MULTI ){\n+    if( nChangeFrom==0 && eOnePass!=ONEPASS_MULTI ){\n@@ -137835,1 +143220,6 @@\n-      if( !isView && aiCurOnePass[0]!=iDataCur && aiCurOnePass[1]!=iDataCur ){\n+      if( aiCurOnePass[0]!=iDataCur\n+       && aiCurOnePass[1]!=iDataCur\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+       && !isView\n+#endif\n+      ){\n@@ -137846,1 +143236,1 @@\n-    }else if( pPk ){\n+    }else if( pPk || nChangeFrom ){\n@@ -137849,3 +143239,22 @@\n-      addrTop = sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);\n-      sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey, 0);\n-      VdbeCoverage(v);\n+      addrTop = sqlite3VdbeCurrentAddr(v);\n+      if( nChangeFrom ){\n+        if( !isView ){\n+          if( pPk ){\n+            for(i=0; i<nPk; i++){\n+              sqlite3VdbeAddOp3(v, OP_Column, iEph, i, iPk+i);\n+            }\n+            sqlite3VdbeAddOp4Int(\n+                v, OP_NotFound, iDataCur, labelContinue, iPk, nPk\n+            ); VdbeCoverage(v);\n+          }else{\n+            sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);\n+            sqlite3VdbeAddOp3(\n+                v, OP_NotExists, iDataCur, labelContinue, regOldRowid\n+            ); VdbeCoverage(v);\n+          }\n+        }\n+      }else{\n+        sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);\n+        sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey,0);\n+        VdbeCoverage(v);\n+      }\n@@ -137853,2 +143262,3 @@\n-      labelContinue = sqlite3VdbeAddOp3(v, OP_RowSetRead, regRowSet,labelBreak,\n-                               regOldRowid);\n+      sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);\n+      labelContinue = sqlite3VdbeMakeLabel(pParse);\n+      addrTop = sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);\n@@ -137867,1 +143277,6 @@\n-    sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);\n+    assert( iRowidExpr>=0 );\n+    if( nChangeFrom==0 ){\n+      sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);\n+    }else{\n+      sqlite3VdbeAddOp3(v, OP_Column, iEph, iRowidExpr, regNewRowid);\n+    }\n@@ -137920,1 +143335,7 @@\n-        sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);\n+        if( nChangeFrom ){\n+          int nOff = (isView ? pTab->nCol : nPk);\n+          assert( eOnePass==ONEPASS_OFF );\n+          sqlite3VdbeAddOp3(v, OP_Column, iEph, nOff+j, k);\n+        }else{\n+          sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);\n+        }\n@@ -137952,13 +143373,14 @@\n-    \/* The row-trigger may have deleted the row being updated. In this\n-    ** case, jump to the next row. No updates or AFTER triggers are\n-    ** required. This behavior - what happens when the row being updated\n-    ** is deleted or renamed by a BEFORE trigger - is left undefined in the\n-    ** documentation.\n-    *\/\n-    if( pPk ){\n-      sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue,regKey,nKey);\n-      VdbeCoverage(v);\n-    }else{\n-      sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);\n-      VdbeCoverage(v);\n-    }\n+    if( !isView ){\n+      \/* The row-trigger may have deleted the row being updated. In this\n+      ** case, jump to the next row. No updates or AFTER triggers are\n+      ** required. This behavior - what happens when the row being updated\n+      ** is deleted or renamed by a BEFORE trigger - is left undefined in the\n+      ** documentation.\n+      *\/\n+      if( pPk ){\n+        sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);\n+        VdbeCoverage(v);\n+      }else{\n+        sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);\n+        VdbeCoverage(v);\n+      }\n@@ -137966,14 +143388,15 @@\n-    \/* After-BEFORE-trigger-reload-loop:\n-    ** If it did not delete it, the BEFORE trigger may still have modified\n-    ** some of the columns of the row being updated. Load the values for\n-    ** all columns not modified by the update statement into their registers\n-    ** in case this has happened. Only unmodified columns are reloaded.\n-    ** The values computed for modified columns use the values before the\n-    ** BEFORE trigger runs.  See test case trigger1-18.0 (added 2018-04-26)\n-    ** for an example.\n-    *\/\n-    for(i=0, k=regNew; i<pTab->nCol; i++, k++){\n-      if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){\n-        if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;\n-      }else if( aXRef[i]<0 && i!=pTab->iPKey ){\n-        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n+      \/* After-BEFORE-trigger-reload-loop:\n+      ** If it did not delete it, the BEFORE trigger may still have modified\n+      ** some of the columns of the row being updated. Load the values for\n+      ** all columns not modified by the update statement into their registers\n+      ** in case this has happened. Only unmodified columns are reloaded.\n+      ** The values computed for modified columns use the values before the\n+      ** BEFORE trigger runs.  See test case trigger1-18.0 (added 2018-04-26)\n+      ** for an example.\n+      *\/\n+      for(i=0, k=regNew; i<pTab->nCol; i++, k++){\n+        if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){\n+          if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;\n+        }else if( aXRef[i]<0 && i!=pTab->iPKey ){\n+          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n+        }\n@@ -137981,1 +143404,0 @@\n-    }\n@@ -137983,5 +143405,5 @@\n-    if( pTab->tabFlags & TF_HasGenerated ){\n-      testcase( pTab->tabFlags & TF_HasVirtual );\n-      testcase( pTab->tabFlags & TF_HasStored );\n-      sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n-    }\n+      if( pTab->tabFlags & TF_HasGenerated ){\n+        testcase( pTab->tabFlags & TF_HasVirtual );\n+        testcase( pTab->tabFlags & TF_HasStored );\n+        sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n+      }\n@@ -137989,0 +143411,1 @@\n+    }\n@@ -138091,1 +143514,1 @@\n-  }else if( pPk ){\n+  }else{\n@@ -138094,2 +143517,0 @@\n-  }else{\n-    sqlite3VdbeGoto(v, labelContinue);\n@@ -138112,1 +143533,1 @@\n-    sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1);\n+    sqlite3VdbeAddOp2(v, OP_ChngCntRow, regRowCount, 1);\n@@ -138176,1 +143597,1 @@\n-  WhereInfo *pWInfo;\n+  WhereInfo *pWInfo = 0;\n@@ -138194,2 +143615,23 @@\n-  regRec = ++pParse->nMem;\n-  regRowid = ++pParse->nMem;\n+  if( pSrc->nSrc>1 ){\n+    Index *pPk = 0;\n+    Expr *pRow;\n+    ExprList *pList;\n+    if( HasRowid(pTab) ){\n+      if( pRowid ){\n+        pRow = sqlite3ExprDup(db, pRowid, 0);\n+      }else{\n+        pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);\n+      }\n+    }else{\n+      i16 iPk;      \/* PRIMARY KEY column *\/\n+      pPk = sqlite3PrimaryKeyIndex(pTab);\n+      assert( pPk!=0 );\n+      assert( pPk->nKeyCol==1 );\n+      iPk = pPk->aiColumn[0];\n+      if( aXRef[iPk]>=0 ){\n+        pRow = sqlite3ExprDup(db, pChanges->a[aXRef[iPk]].pExpr, 0);\n+      }else{\n+        pRow = exprRowColumn(pParse, iPk);\n+      }\n+    }\n+    pList = sqlite3ExprListAppend(pParse, 0, pRow);\n@@ -138197,3 +143639,9 @@\n-  \/* Start scanning the virtual table *\/\n-  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0,0,WHERE_ONEPASS_DESIRED,0);\n-  if( pWInfo==0 ) return;\n+    for(i=0; i<pTab->nCol; i++){\n+      if( aXRef[i]>=0 ){\n+        pList = sqlite3ExprListAppend(pParse, pList,\n+          sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)\n+        );\n+      }else{\n+        pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));\n+      }\n+    }\n@@ -138201,8 +143649,20 @@\n-  \/* Populate the argument registers. *\/\n-  for(i=0; i<pTab->nCol; i++){\n-    assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );\n-    if( aXRef[i]>=0 ){\n-      sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);\n-    }else{\n-      sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);\n-      sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG);\/* Enable sqlite3_vtab_nochange() *\/\n+    updateFromSelect(pParse, ephemTab, pPk, pList, pSrc, pWhere, 0, 0);\n+    sqlite3ExprListDelete(db, pList);\n+    eOnePass = ONEPASS_OFF;\n+  }else{\n+    regRec = ++pParse->nMem;\n+    regRowid = ++pParse->nMem;\n+\n+    \/* Start scanning the virtual table *\/\n+    pWInfo = sqlite3WhereBegin(pParse, pSrc,pWhere,0,0,WHERE_ONEPASS_DESIRED,0);\n+    if( pWInfo==0 ) return;\n+\n+    \/* Populate the argument registers. *\/\n+    for(i=0; i<pTab->nCol; i++){\n+      assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );\n+      if( aXRef[i]>=0 ){\n+        sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);\n+      }else{\n+        sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);\n+        sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG);\/* For sqlite3_vtab_nochange() *\/\n+      }\n@@ -138210,5 +143670,7 @@\n-  }\n-  if( HasRowid(pTab) ){\n-    sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);\n-    if( pRowid ){\n-      sqlite3ExprCode(pParse, pRowid, regArg+1);\n+    if( HasRowid(pTab) ){\n+      sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);\n+      if( pRowid ){\n+        sqlite3ExprCode(pParse, pRowid, regArg+1);\n+      }else{\n+        sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);\n+      }\n@@ -138216,1 +143678,8 @@\n-      sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);\n+      Index *pPk;   \/* PRIMARY KEY index *\/\n+      i16 iPk;      \/* PRIMARY KEY column *\/\n+      pPk = sqlite3PrimaryKeyIndex(pTab);\n+      assert( pPk!=0 );\n+      assert( pPk->nKeyCol==1 );\n+      iPk = pPk->aiColumn[0];\n+      sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);\n+      sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);\n@@ -138218,10 +143687,0 @@\n-  }else{\n-    Index *pPk;   \/* PRIMARY KEY index *\/\n-    i16 iPk;      \/* PRIMARY KEY column *\/\n-    pPk = sqlite3PrimaryKeyIndex(pTab);\n-    assert( pPk!=0 );\n-    assert( pPk->nKeyCol==1 );\n-    iPk = pPk->aiColumn[0];\n-    sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);\n-    sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);\n-  }\n@@ -138229,1 +143688,1 @@\n-  eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);\n+    eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);\n@@ -138231,2 +143690,2 @@\n-  \/* There is no ONEPASS_MULTI on virtual tables *\/\n-  assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );\n+    \/* There is no ONEPASS_MULTI on virtual tables *\/\n+    assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );\n@@ -138234,14 +143693,14 @@\n-  if( eOnePass ){\n-    \/* If using the onepass strategy, no-op out the OP_OpenEphemeral coded\n-    ** above. *\/\n-    sqlite3VdbeChangeToNoop(v, addr);\n-    sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n-  }else{\n-    \/* Create a record from the argument register contents and insert it into\n-    ** the ephemeral table. *\/\n-    sqlite3MultiWrite(pParse);\n-    sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);\n-#ifdef SQLITE_DEBUG\n-    \/* Signal an assert() within OP_MakeRecord that it is allowed to\n-    ** accept no-change records with serial_type 10 *\/\n-    sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);\n+    if( eOnePass ){\n+      \/* If using the onepass strategy, no-op out the OP_OpenEphemeral coded\n+      ** above. *\/\n+      sqlite3VdbeChangeToNoop(v, addr);\n+      sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n+    }else{\n+      \/* Create a record from the argument register contents and insert it into\n+      ** the ephemeral table. *\/\n+      sqlite3MultiWrite(pParse);\n+      sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);\n+#if defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_NULL_TRIM)\n+      \/* Signal an assert() within OP_MakeRecord that it is allowed to\n+      ** accept no-change records with serial_type 10 *\/\n+      sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);\n@@ -138249,2 +143708,3 @@\n-    sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);\n-    sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);\n+      sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);\n+      sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);\n+    }\n@@ -138256,1 +143716,3 @@\n-    sqlite3WhereEnd(pWInfo);\n+    if( pSrc->nSrc==1 ){\n+      sqlite3WhereEnd(pWInfo);\n+    }\n@@ -138306,2 +143768,3 @@\n-SQLITE_PRIVATE void sqlite3UpsertDelete(sqlite3 *db, Upsert *p){\n-  if( p ){\n+static void SQLITE_NOINLINE upsertDelete(sqlite3 *db, Upsert *p){\n+  do{\n+    Upsert *pNext = p->pNextUpsert;\n@@ -138312,0 +143775,1 @@\n+    sqlite3DbFree(db, p->pToFree);\n@@ -138313,1 +143777,5 @@\n-  }\n+    p = pNext;\n+  }while( p );\n+}\n+SQLITE_PRIVATE void sqlite3UpsertDelete(sqlite3 *db, Upsert *p){\n+  if( p ) upsertDelete(db, p);\n@@ -138316,0 +143784,1 @@\n+\n@@ -138325,1 +143794,2 @@\n-           sqlite3ExprDup(db, p->pUpsertWhere, 0)\n+           sqlite3ExprDup(db, p->pUpsertWhere, 0),\n+           sqlite3UpsertDup(db, p->pNextUpsert)\n@@ -138337,1 +143807,2 @@\n-  Expr *pWhere           \/* WHERE clause for the ON CONFLICT UPDATE *\/\n+  Expr *pWhere,          \/* WHERE clause for the ON CONFLICT UPDATE *\/\n+  Upsert *pNext          \/* Next ON CONFLICT clause in the list *\/\n@@ -138340,1 +143811,1 @@\n-  pNew = sqlite3DbMallocRaw(db, sizeof(Upsert));\n+  pNew = sqlite3DbMallocZero(db, sizeof(Upsert));\n@@ -138346,0 +143817,1 @@\n+    sqlite3UpsertDelete(db, pNext);\n@@ -138352,1 +143824,2 @@\n-    pNew->pUpsertIdx = 0;\n+    pNew->isDoUpdate = pSet!=0;\n+    pNew->pNextUpsert = pNext;\n@@ -138377,0 +143850,1 @@\n+  int nClause = 0;        \/* Counter of ON CONFLICT clauses *\/\n@@ -138390,4 +143864,6 @@\n-  rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);\n-  if( rc ) return rc;\n-  rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);\n-  if( rc ) return rc;\n+  for(; pUpsert && pUpsert->pUpsertTarget;\n+        pUpsert=pUpsert->pNextUpsert, nClause++){\n+    rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);\n+    if( rc ) return rc;\n+    rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);\n+    if( rc ) return rc;\n@@ -138395,13 +143871,13 @@\n-  \/* Check to see if the conflict target matches the rowid. *\/\n-  pTab = pTabList->a[0].pTab;\n-  pTarget = pUpsert->pUpsertTarget;\n-  iCursor = pTabList->a[0].iCursor;\n-  if( HasRowid(pTab)\n-   && pTarget->nExpr==1\n-   && (pTerm = pTarget->a[0].pExpr)->op==TK_COLUMN\n-   && pTerm->iColumn==XN_ROWID\n-  ){\n-    \/* The conflict-target is the rowid of the primary table *\/\n-    assert( pUpsert->pUpsertIdx==0 );\n-    return SQLITE_OK;\n-  }\n+    \/* Check to see if the conflict target matches the rowid. *\/\n+    pTab = pTabList->a[0].pTab;\n+    pTarget = pUpsert->pUpsertTarget;\n+    iCursor = pTabList->a[0].iCursor;\n+    if( HasRowid(pTab)\n+     && pTarget->nExpr==1\n+     && (pTerm = pTarget->a[0].pExpr)->op==TK_COLUMN\n+     && pTerm->iColumn==XN_ROWID\n+    ){\n+      \/* The conflict-target is the rowid of the primary table *\/\n+      assert( pUpsert->pUpsertIdx==0 );\n+      continue;\n+    }\n@@ -138409,11 +143885,11 @@\n-  \/* Initialize sCol[0..1] to be an expression parse tree for a\n-  ** single column of an index.  The sCol[0] node will be the TK_COLLATE\n-  ** operator and sCol[1] will be the TK_COLUMN operator.  Code below\n-  ** will populate the specific collation and column number values\n-  ** prior to comparing against the conflict-target expression.\n-  *\/\n-  memset(sCol, 0, sizeof(sCol));\n-  sCol[0].op = TK_COLLATE;\n-  sCol[0].pLeft = &sCol[1];\n-  sCol[1].op = TK_COLUMN;\n-  sCol[1].iTable = pTabList->a[0].iCursor;\n+    \/* Initialize sCol[0..1] to be an expression parse tree for a\n+    ** single column of an index.  The sCol[0] node will be the TK_COLLATE\n+    ** operator and sCol[1] will be the TK_COLUMN operator.  Code below\n+    ** will populate the specific collation and column number values\n+    ** prior to comparing against the conflict-target expression.\n+    *\/\n+    memset(sCol, 0, sizeof(sCol));\n+    sCol[0].op = TK_COLLATE;\n+    sCol[0].pLeft = &sCol[1];\n+    sCol[1].op = TK_COLUMN;\n+    sCol[1].iTable = pTabList->a[0].iCursor;\n@@ -138421,10 +143897,11 @@\n-  \/* Check for matches against other indexes *\/\n-  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n-    int ii, jj, nn;\n-    if( !IsUniqueIndex(pIdx) ) continue;\n-    if( pTarget->nExpr!=pIdx->nKeyCol ) continue;\n-    if( pIdx->pPartIdxWhere ){\n-      if( pUpsert->pUpsertTargetWhere==0 ) continue;\n-      if( sqlite3ExprCompare(pParse, pUpsert->pUpsertTargetWhere,\n-                             pIdx->pPartIdxWhere, iCursor)!=0 ){\n-        continue;\n+    \/* Check for matches against other indexes *\/\n+    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n+      int ii, jj, nn;\n+      if( !IsUniqueIndex(pIdx) ) continue;\n+      if( pTarget->nExpr!=pIdx->nKeyCol ) continue;\n+      if( pIdx->pPartIdxWhere ){\n+        if( pUpsert->pUpsertTargetWhere==0 ) continue;\n+        if( sqlite3ExprCompare(pParse, pUpsert->pUpsertTargetWhere,\n+                               pIdx->pPartIdxWhere, iCursor)!=0 ){\n+          continue;\n+        }\n@@ -138432,11 +143909,15 @@\n-    }\n-    nn = pIdx->nKeyCol;\n-    for(ii=0; ii<nn; ii++){\n-      Expr *pExpr;\n-      sCol[0].u.zToken = (char*)pIdx->azColl[ii];\n-      if( pIdx->aiColumn[ii]==XN_EXPR ){\n-        assert( pIdx->aColExpr!=0 );\n-        assert( pIdx->aColExpr->nExpr>ii );\n-        pExpr = pIdx->aColExpr->a[ii].pExpr;\n-        if( pExpr->op!=TK_COLLATE ){\n-          sCol[0].pLeft = pExpr;\n+      nn = pIdx->nKeyCol;\n+      for(ii=0; ii<nn; ii++){\n+        Expr *pExpr;\n+        sCol[0].u.zToken = (char*)pIdx->azColl[ii];\n+        if( pIdx->aiColumn[ii]==XN_EXPR ){\n+          assert( pIdx->aColExpr!=0 );\n+          assert( pIdx->aColExpr->nExpr>ii );\n+          pExpr = pIdx->aColExpr->a[ii].pExpr;\n+          if( pExpr->op!=TK_COLLATE ){\n+            sCol[0].pLeft = pExpr;\n+            pExpr = &sCol[0];\n+          }\n+        }else{\n+          sCol[0].pLeft = &sCol[1];\n+          sCol[1].iColumn = pIdx->aiColumn[ii];\n@@ -138445,8 +143926,8 @@\n-      }else{\n-        sCol[0].pLeft = &sCol[1];\n-        sCol[1].iColumn = pIdx->aiColumn[ii];\n-        pExpr = &sCol[0];\n-      }\n-      for(jj=0; jj<nn; jj++){\n-        if( sqlite3ExprCompare(pParse, pTarget->a[jj].pExpr, pExpr,iCursor)<2 ){\n-          break;  \/* Column ii of the index matches column jj of target *\/\n+        for(jj=0; jj<nn; jj++){\n+          if( sqlite3ExprCompare(pParse,pTarget->a[jj].pExpr,pExpr,iCursor)<2 ){\n+            break;  \/* Column ii of the index matches column jj of target *\/\n+          }\n+        }\n+        if( jj>=nn ){\n+          \/* The target contains no match for column jj of the index *\/\n+          break;\n@@ -138455,3 +143936,4 @@\n-      if( jj>=nn ){\n-        \/* The target contains no match for column jj of the index *\/\n-        break;\n+      if( ii<nn ){\n+        \/* Column ii of the index did not match any term of the conflict target.\n+        ** Continue the search with the next index. *\/\n+        continue;\n@@ -138459,0 +143941,2 @@\n+      pUpsert->pUpsertIdx = pIdx;\n+      break;\n@@ -138460,4 +143944,10 @@\n-    if( ii<nn ){\n-      \/* Column ii of the index did not match any term of the conflict target.\n-      ** Continue the search with the next index. *\/\n-      continue;\n+    if( pUpsert->pUpsertIdx==0 ){\n+      char zWhich[16];\n+      if( nClause==0 && pUpsert->pNextUpsert==0 ){\n+        zWhich[0] = 0;\n+      }else{\n+        sqlite3_snprintf(sizeof(zWhich),zWhich,\"%r \", nClause+1);\n+      }\n+      sqlite3ErrorMsg(pParse, \"%sON CONFLICT clause does not match any \"\n+                              \"PRIMARY KEY or UNIQUE constraint\", zWhich);\n+      return SQLITE_ERROR;\n@@ -138465,2 +143955,0 @@\n-    pUpsert->pUpsertIdx = pIdx;\n-    return SQLITE_OK;\n@@ -138468,3 +143956,33 @@\n-  sqlite3ErrorMsg(pParse, \"ON CONFLICT clause does not match any \"\n-                          \"PRIMARY KEY or UNIQUE constraint\");\n-  return SQLITE_ERROR;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Return true if pUpsert is the last ON CONFLICT clause with a\n+** conflict target, or if pUpsert is followed by another ON CONFLICT\n+** clause that targets the INTEGER PRIMARY KEY.\n+*\/\n+SQLITE_PRIVATE int sqlite3UpsertNextIsIPK(Upsert *pUpsert){\n+  Upsert *pNext;\n+  if( NEVER(pUpsert==0) ) return 0;\n+  pNext = pUpsert->pNextUpsert;\n+  if( pNext==0 ) return 1;\n+  if( pNext->pUpsertTarget==0 ) return 1;\n+  if( pNext->pUpsertIdx==0 ) return 1;\n+  return 0;\n+}\n+\n+\/*\n+** Given the list of ON CONFLICT clauses described by pUpsert, and\n+** a particular index pIdx, return a pointer to the particular ON CONFLICT\n+** clause that applies to the index.  Or, if the index is not subject to\n+** any ON CONFLICT clause, return NULL.\n+*\/\n+SQLITE_PRIVATE Upsert *sqlite3UpsertOfIndex(Upsert *pUpsert, Index *pIdx){\n+  while(\n+      pUpsert\n+   && pUpsert->pUpsertTarget!=0\n+   && pUpsert->pUpsertIdx!=pIdx\n+  ){\n+     pUpsert = pUpsert->pNextUpsert;\n+  }\n+  return pUpsert;\n@@ -138494,0 +144012,1 @@\n+  Upsert *pTop = pUpsert;\n@@ -138497,1 +144016,0 @@\n-  VdbeNoopComment((v, \"Begin DO UPDATE of UPSERT\"));\n@@ -138499,0 +144017,2 @@\n+  pUpsert = sqlite3UpsertOfIndex(pTop, pIdx);\n+  VdbeNoopComment((v, \"Begin DO UPDATE of UPSERT\"));\n@@ -138517,1 +144037,1 @@\n-                    pTab->aCol[pPk->aiColumn[i]].zName));\n+                    pTab->aCol[pPk->aiColumn[i]].zCnName));\n@@ -138528,3 +144048,3 @@\n-  \/* pUpsert does not own pUpsertSrc - the outer INSERT statement does.  So\n-  ** we have to make a copy before passing it down into sqlite3Update() *\/\n-  pSrc = sqlite3SrcListDup(db, pUpsert->pUpsertSrc, 0);\n+  \/* pUpsert does not own pTop->pUpsertSrc - the outer INSERT statement does.\n+  ** So we have to make a copy before passing it down into sqlite3Update() *\/\n+  pSrc = sqlite3SrcListDup(db, pTop->pUpsertSrc, 0);\n@@ -138534,1 +144054,1 @@\n-      sqlite3VdbeAddOp1(v, OP_RealAffinity, pUpsert->regData+i);\n+      sqlite3VdbeAddOp1(v, OP_RealAffinity, pTop->regData+i);\n@@ -138537,4 +144057,2 @@\n-  sqlite3Update(pParse, pSrc, pUpsert->pUpsertSet,\n-      pUpsert->pUpsertWhere, OE_Abort, 0, 0, pUpsert);\n-  pUpsert->pUpsertSet = 0;    \/* Will have been deleted by sqlite3Update() *\/\n-  pUpsert->pUpsertWhere = 0;  \/* Will have been deleted by sqlite3Update() *\/\n+  sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db,pUpsert->pUpsertSet,0),\n+      sqlite3ExprDup(db,pUpsert->pUpsertWhere,0), OE_Abort, 0, 0, pUpsert);\n@@ -138591,1 +144109,1 @@\n-    ** corrupt the sqlite_master.sql field with other kinds of statements\n+    ** corrupt the sqlite_schema.sql field with other kinds of statements\n@@ -138701,2 +144219,2 @@\n-  int saved_nChange;      \/* Saved value of db->nChange *\/\n-  int saved_nTotalChange; \/* Saved value of db->nTotalChange *\/\n+  i64 saved_nChange;      \/* Saved value of db->nChange *\/\n+  i64 saved_nTotalChange; \/* Saved value of db->nTotalChange *\/\n@@ -138800,1 +144318,3 @@\n-                                               ==PAGER_JOURNALMODE_WAL ){\n+                                               ==PAGER_JOURNALMODE_WAL\n+   && pOut==0\n+  ){\n@@ -138822,1 +144342,1 @@\n-      \"SELECT sql FROM \\\"%w\\\".sqlite_master\"\n+      \"SELECT sql FROM \\\"%w\\\".sqlite_schema\"\n@@ -138829,1 +144349,1 @@\n-      \"SELECT sql FROM \\\"%w\\\".sqlite_master\"\n+      \"SELECT sql FROM \\\"%w\\\".sqlite_schema\"\n@@ -138843,1 +144363,1 @@\n-      \"FROM vacuum_db.sqlite_master \"\n+      \"FROM vacuum_db.sqlite_schema \"\n@@ -138854,1 +144374,1 @@\n-  ** from the SQLITE_MASTER table.\n+  ** from the schema table.\n@@ -138857,2 +144377,2 @@\n-      \"INSERT INTO vacuum_db.sqlite_master\"\n-      \" SELECT*FROM \\\"%w\\\".sqlite_master\"\n+      \"INSERT INTO vacuum_db.sqlite_schema\"\n+      \" SELECT*FROM \\\"%w\\\".sqlite_schema\"\n@@ -138889,2 +144409,2 @@\n-    assert( 1==sqlite3BtreeIsInTrans(pTemp) );\n-    assert( pOut!=0 || 1==sqlite3BtreeIsInTrans(pMain) );\n+    assert( SQLITE_TXN_WRITE==sqlite3BtreeTxnState(pTemp) );\n+    assert( pOut!=0 || SQLITE_TXN_WRITE==sqlite3BtreeTxnState(pMain) );\n@@ -139149,1 +144669,1 @@\n-  for(pVtab=pTab->pVTable; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);\n+  for(pVtab=pTab->u.vtab.p; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);\n@@ -139162,1 +144682,2 @@\n-  assert( db->magic==SQLITE_MAGIC_OPEN || db->magic==SQLITE_MAGIC_ZOMBIE );\n+  assert( db->eOpenState==SQLITE_STATE_OPEN\n+       || db->eOpenState==SQLITE_STATE_ZOMBIE );\n@@ -139177,1 +144698,1 @@\n-** p->pVTable list to the sqlite3.pDisconnect lists of their associated\n+** p->u.vtab.p list to the sqlite3.pDisconnect lists of their associated\n@@ -139180,1 +144701,1 @@\n-** connection db is left in the p->pVTable list.\n+** connection db is left in the p->u.vtab.p list.\n@@ -139184,2 +144705,5 @@\n-  VTable *pVTable = p->pVTable;\n-  p->pVTable = 0;\n+  VTable *pVTable;\n+\n+  assert( IsVirtual(p) );\n+  pVTable = p->u.vtab.p;\n+  p->u.vtab.p = 0;\n@@ -139191,1 +144715,1 @@\n-  ** database connection that may have an entry in the p->pVTable list.\n+  ** database connection that may have an entry in the p->u.vtab.p list.\n@@ -139201,1 +144725,1 @@\n-      p->pVTable = pRet;\n+      p->u.vtab.p = pRet;\n@@ -139229,1 +144753,1 @@\n-  for(ppVTab=&p->pVTable; *ppVTab; ppVTab=&(*ppVTab)->pNext){\n+  for(ppVTab=&p->u.vtab.p; *ppVTab; ppVTab=&(*ppVTab)->pNext){\n@@ -139292,0 +144816,1 @@\n+  assert( IsVirtual(p) );\n@@ -139293,1 +144818,1 @@\n-  if( p->azModuleArg ){\n+  if( p->u.vtab.azArg ){\n@@ -139295,2 +144820,2 @@\n-    for(i=0; i<p->nModuleArg; i++){\n-      if( i!=1 ) sqlite3DbFree(db, p->azModuleArg[i]);\n+    for(i=0; i<p->u.vtab.nArg; i++){\n+      if( i!=1 ) sqlite3DbFree(db, p->u.vtab.azArg[i]);\n@@ -139298,1 +144823,1 @@\n-    sqlite3DbFree(db, p->azModuleArg);\n+    sqlite3DbFree(db, p->u.vtab.azArg);\n@@ -139303,1 +144828,1 @@\n-** Add a new module argument to pTable->azModuleArg[].\n+** Add a new module argument to pTable->u.vtab.azArg[].\n@@ -139309,1 +144834,1 @@\n-  sqlite3_int64 nBytes = sizeof(char *)*(2+pTable->nModuleArg);\n+  sqlite3_int64 nBytes;\n@@ -139312,1 +144837,4 @@\n-  if( pTable->nModuleArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){\n+\n+  assert( IsVirtual(pTable) );\n+  nBytes = sizeof(char *)*(2+pTable->u.vtab.nArg);\n+  if( pTable->u.vtab.nArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){\n@@ -139315,1 +144843,1 @@\n-  azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);\n+  azModuleArg = sqlite3DbRealloc(db, pTable->u.vtab.azArg, nBytes);\n@@ -139319,1 +144847,1 @@\n-    int i = pTable->nModuleArg++;\n+    int i = pTable->u.vtab.nArg++;\n@@ -139322,1 +144850,1 @@\n-    pTable->azModuleArg = azModuleArg;\n+    pTable->u.vtab.azArg = azModuleArg;\n@@ -139345,0 +144873,1 @@\n+  pTable->eTabType = TABTYP_VTAB;\n@@ -139348,1 +144877,1 @@\n-  assert( pTable->nModuleArg==0 );\n+  assert( pTable->u.vtab.nArg==0 );\n@@ -139362,1 +144891,1 @@\n-  ** sqlite_master table, has already been made by sqlite3StartTable().\n+  ** sqlite_schema table, has already been made by sqlite3StartTable().\n@@ -139365,1 +144894,1 @@\n-  if( pTable->azModuleArg ){\n+  if( pTable->u.vtab.azArg ){\n@@ -139369,1 +144898,1 @@\n-            pTable->azModuleArg[0], pParse->db->aDb[iDb].zDbSName);\n+            pTable->u.vtab.azArg[0], pParse->db->aDb[iDb].zDbSName);\n@@ -139397,0 +144926,1 @@\n+  assert( IsVirtual(pTab) );\n@@ -139399,1 +144929,1 @@\n-  if( pTab->nModuleArg<1 ) return;\n+  if( pTab->u.vtab.nArg<1 ) return;\n@@ -139403,1 +144933,1 @@\n-  ** created now instead of just being read out of sqlite_master) then\n+  ** created now instead of just being read out of sqlite_schema) then\n@@ -139405,1 +144935,1 @@\n-  ** in the sqlite_master table.\n+  ** in the sqlite_schema table.\n@@ -139423,1 +144953,1 @@\n-    ** SQLITE_MASTER table.  We just need to update that slot with all\n+    ** schema table.  We just need to update that slot with all\n@@ -139427,1 +144957,1 @@\n-    ** entry in the sqlite_master table tht was created for this vtab\n+    ** entry in the sqlite_schema table tht was created for this vtab\n@@ -139432,1 +144962,1 @@\n-      \"UPDATE %Q.%s \"\n+      \"UPDATE %Q.\" LEGACY_SCHEMA_TABLE \" \"\n@@ -139435,1 +144965,1 @@\n-      db->aDb[iDb].zDbSName, MASTER_NAME,\n+      db->aDb[iDb].zDbSName,\n@@ -139446,1 +144976,1 @@\n-    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);\n+    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere, 0);\n@@ -139452,8 +144982,3 @@\n-  }\n-\n-  \/* If we are rereading the sqlite_master table create the in-memory\n-  ** record of the table. The xConnect() method is not called until\n-  ** the first time the virtual table is used in an SQL statement. This\n-  ** allows a schema that contains virtual tables to be loaded before\n-  ** the required virtual table implementations are registered.  *\/\n-  else {\n+  }else{\n+    \/* If we are rereading the sqlite_schema table create the in-memory\n+    ** record of the table. *\/\n@@ -139463,1 +144988,2 @@\n-    assert( sqlite3SchemaMutexHeld(db, 0, pSchema) );\n+    assert( zName!=0 );\n+    sqlite3MarkAllShadowTablesOf(db, pTab);\n@@ -139514,2 +145040,2 @@\n-  const char *const*azArg = (const char *const*)pTab->azModuleArg;\n-  int nArg = pTab->nModuleArg;\n+  const char *const*azArg;\n+  int nArg = pTab->u.vtab.nArg;\n@@ -139521,0 +145047,3 @@\n+  assert( IsVirtual(pTab) );\n+  azArg = (const char *const*)pTab->u.vtab.azArg;\n+\n@@ -139547,1 +145076,1 @@\n-  pTab->azModuleArg[1] = db->aDb[iDb].zDbSName;\n+  pTab->u.vtab.azArg[1] = db->aDb[iDb].zDbSName;\n@@ -139586,1 +145115,1 @@\n-      ** into the linked list headed by pTab->pVTable. Then loop through the\n+      ** into the linked list headed by pTab->u.vtab.p. Then loop through the\n@@ -139590,2 +145119,2 @@\n-      pVTable->pNext = pTab->pVTable;\n-      pTab->pVTable = pVTable;\n+      pVTable->pNext = pTab->u.vtab.p;\n+      pTab->u.vtab.p = pVTable;\n@@ -139617,0 +145146,1 @@\n+          pTab->tabFlags |= TF_HasHidden;\n@@ -139643,1 +145173,2 @@\n-  if( !IsVirtual(pTab) || sqlite3GetVTable(db, pTab) ){\n+  assert( IsVirtual(pTab) );\n+  if( sqlite3GetVTable(db, pTab) ){\n@@ -139648,1 +145179,1 @@\n-  zMod = pTab->azModuleArg[0];\n+  zMod = pTab->u.vtab.azArg[0];\n@@ -139652,1 +145183,1 @@\n-    const char *zModule = pTab->azModuleArg[0];\n+    const char *zModule = pTab->u.vtab.azArg[0];\n@@ -139715,1 +145246,1 @@\n-  assert( pTab && IsVirtual(pTab) && !pTab->pVTable );\n+  assert( pTab && IsVirtual(pTab) && !pTab->u.vtab.p );\n@@ -139718,1 +145249,1 @@\n-  zMod = pTab->azModuleArg[0];\n+  zMod = pTab->u.vtab.azArg[0];\n@@ -139755,0 +145286,1 @@\n+  int initBusy;\n@@ -139774,0 +145306,6 @@\n+  \/* We should never be able to reach this point while loading the\n+  ** schema.  Nevertheless, defend against that (turn off db->init.busy)\n+  ** in case a bug arises. *\/\n+  assert( db->init.busy==0 );\n+  initBusy = db->init.busy;\n+  db->init.busy = 0;\n@@ -139778,2 +145316,1 @@\n-   && !sParse.pNewTable->pSelect\n-   && !IsVirtual(sParse.pNewTable)\n+   && IsOrdinaryTable(sParse.pNewTable)\n@@ -139785,1 +145322,2 @@\n-      pTab->nCol = pNew->nCol;\n+      sqlite3ExprListDelete(db, pNew->u.tab.pDfltList);\n+      pTab->nNVCol = pTab->nCol = pNew->nCol;\n@@ -139820,0 +145358,1 @@\n+  db->init.busy = initBusy;\n@@ -139839,1 +145378,4 @@\n-  if( pTab!=0 && ALWAYS(pTab->pVTable!=0) ){\n+  if( ALWAYS(pTab!=0)\n+   && ALWAYS(IsVirtual(pTab))\n+   && ALWAYS(pTab->u.vtab.p!=0)\n+  ){\n@@ -139842,1 +145384,1 @@\n-    for(p=pTab->pVTable; p; p=p->pNext){\n+    for(p=pTab->u.vtab.p; p; p=p->pNext){\n@@ -139856,1 +145398,1 @@\n-      assert( pTab->pVTable==p && p->pNext==0 );\n+      assert( pTab->u.vtab.p==p && p->pNext==0 );\n@@ -139858,1 +145400,1 @@\n-      pTab->pVTable = 0;\n+      pTab->u.vtab.p = 0;\n@@ -140072,0 +145614,1 @@\n+  assert( ExprUseYTab(pExpr) );\n@@ -140146,2 +145689,3 @@\n-** exist. Return non-zero if the eponymous virtual table instance exists\n-** when this routine returns, and return zero if it does not exist.\n+** exist. Return non-zero if either the eponymous virtual table instance\n+** exists when this routine returns or if an attempt to create it failed\n+** and an error message was left in pParse.\n@@ -140174,0 +145718,1 @@\n+  pTab->eTabType = TABTYP_VTAB;\n@@ -140175,1 +145720,1 @@\n-  assert( pTab->nModuleArg==0 );\n+  assert( pTab->u.vtab.nArg==0 );\n@@ -140177,0 +145722,1 @@\n+  pTab->tabFlags |= TF_Eponymous;\n@@ -140185,1 +145731,0 @@\n-    return 0;\n@@ -140317,13 +145862,0 @@\n-\/*\n-** Trace output macros\n-*\/\n-#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)\n-\/***\/ extern int sqlite3WhereTrace;\n-#endif\n-#if defined(SQLITE_DEBUG) \\\n-    && (defined(SQLITE_TEST) || defined(SQLITE_ENABLE_WHERETRACE))\n-# define WHERETRACE(K,X)  if(sqlite3WhereTrace&(K)) sqlite3DebugPrintf X\n-# define WHERETRACE_ENABLED 1\n-#else\n-# define WHERETRACE(K,X)\n-#endif\n@@ -140391,1 +145923,1 @@\n-    Index *pCovidx;       \/* Possible covering index for WHERE_MULTI_OR *\/\n+    Index *pCoveringIdx;  \/* Possible covering index for WHERE_MULTI_OR *\/\n@@ -140561,1 +146093,0 @@\n-  int iField;             \/* Field in (?,?,?) IN (SELECT...) vector *\/\n@@ -140563,1 +146094,4 @@\n-    int leftColumn;         \/* Column number of X in \"X <op> <expr>\" *\/\n+    struct {\n+      int leftColumn;         \/* Column number of X in \"X <op> <expr>\" *\/\n+      int iField;             \/* Field in (?,?,?) IN (SELECT...) vector *\/\n+    } x;                    \/* Opcode other than OP_OR or OP_AND *\/\n@@ -140581,5 +146115,1 @@\n-#ifdef SQLITE_ENABLE_STAT4\n-#  define TERM_VNULL    0x0080 \/* Manufactured x>NULL or x<=NULL term *\/\n-#else\n-#  define TERM_VNULL    0x0000 \/* Disabled if not using stat4 *\/\n-#endif\n+#define TERM_VNULL      0x0080 \/* Manufactured x>NULL or x<=NULL term *\/\n@@ -140608,2 +146138,2 @@\n-  unsigned char nEquiv;      \/* Number of entries in aEquiv[] *\/\n-  unsigned char iEquiv;      \/* Next unused slot in aEquiv[] *\/\n+  unsigned char nEquiv;      \/* Number of entries in aiCur[] and aiColumn[] *\/\n+  unsigned char iEquiv;      \/* Next unused slot in aiCur[] and aiColumn[] *\/\n@@ -140788,0 +146318,1 @@\n+  int iEndWhere;            \/* End of the WHERE clause itself *\/\n@@ -140854,1 +146385,1 @@\n-SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(Parse*, struct SrcList_item*, WhereClause*);\n+SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(Parse*, SrcItem*, WhereClause*);\n@@ -140916,0 +146447,2 @@\n+#define WHERE_IN_SEEKSCAN  0x00100000  \/* Seek-scan optimization for IN *\/\n+#define WHERE_TRANSCONS    0x00200000  \/* Uses a transitive constraint *\/\n@@ -140931,1 +146464,1 @@\n-  return pIdx->pTable->aCol[i].zName;\n+  return pIdx->pTable->aCol[i].zCnName;\n@@ -141031,1 +146564,1 @@\n-    struct SrcList_item *pItem = &pTabList->a[pLevel->iFrom];\n+    SrcItem *pItem = &pTabList->a[pLevel->iFrom];\n@@ -141050,10 +146583,2 @@\n-    sqlite3_str_appendall(&str, isSearch ? \"SEARCH\" : \"SCAN\");\n-    if( pItem->pSelect ){\n-      sqlite3_str_appendf(&str, \" SUBQUERY %u\", pItem->pSelect->selId);\n-    }else{\n-      sqlite3_str_appendf(&str, \" TABLE %s\", pItem->zName);\n-    }\n-\n-    if( pItem->zAlias ){\n-      sqlite3_str_appendf(&str, \" AS %s\", pItem->zAlias);\n-    }\n+    str.printfFlags = SQLITE_PRINTF_INTERNAL;\n+    sqlite3_str_appendf(&str, \"%s %S\", isSearch ? \"SEARCH\" : \"SCAN\", pItem);\n@@ -141207,0 +146732,6 @@\n+#ifdef WHERETRACE_ENABLED\n+    if( sqlite3WhereTrace & 0x20000 ){\n+      sqlite3DebugPrintf(\"DISABLE-\");\n+      sqlite3WhereTermPrint(pTerm, (int)(pTerm - (pTerm->pWC->a)));\n+    }\n+#endif\n@@ -141320,2 +146851,2 @@\n-    ExprList *pOrigRhs = pNew->x.pSelect->pEList;  \/* Original unmodified RHS *\/\n-    ExprList *pOrigLhs = pNew->pLeft->x.pList;     \/* Original unmodified LHS *\/\n+    ExprList *pOrigRhs;         \/* Original unmodified RHS *\/\n+    ExprList *pOrigLhs;         \/* Original unmodified LHS *\/\n@@ -141327,0 +146858,5 @@\n+    assert( ExprUseXSelect(pNew) );\n+    pOrigRhs = pNew->x.pSelect->pEList;\n+    assert( pNew->pLeft!=0 );\n+    assert( ExprUseXList(pNew->pLeft) );\n+    pOrigLhs = pNew->pLeft->x.pList;\n@@ -141329,1 +146865,3 @@\n-        int iField = pLoop->aLTerm[i]->iField - 1;\n+        int iField;\n+        assert( (pLoop->aLTerm[i]->eOperator & (WO_OR|WO_AND))==0 );\n+        iField = pLoop->aLTerm[i]->u.x.iField - 1;\n@@ -141444,1 +146982,1 @@\n-    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){\n+    if( !ExprUseXSelect(pX) || pX->x.pSelect->pEList->nExpr==1 ){\n@@ -141466,1 +147004,0 @@\n-    assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );\n@@ -141468,0 +147005,1 @@\n+    assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );\n@@ -141472,0 +147010,3 @@\n+    if( iEq>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0 ){\n+      pLoop->wsFlags |= WHERE_IN_EARLYOUT;\n+    }\n@@ -141498,1 +147039,0 @@\n-              pLoop->wsFlags |= WHERE_IN_EARLYOUT;\n@@ -141508,0 +147048,8 @@\n+      testcase( iEq>0\n+                && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0\n+                && (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 );\n+      if( iEq>0\n+       && (pLoop->wsFlags & (WHERE_IN_SEEKSCAN|WHERE_VIRTUALTABLE))==0\n+      ){\n+        sqlite3VdbeAddOp3(v, OP_SeekHit, pLevel->iIdxCur, 0, iEq);\n+      }\n@@ -141514,1 +147062,16 @@\n-  disableTerm(pLevel, pTerm);\n+\n+  \/* As an optimization, try to disable the WHERE clause term that is\n+  ** driving the index as it will always be true.  The correct answer is\n+  ** obtained regardless, but we might get the answer with fewer CPU cycles\n+  ** by omitting the term.\n+  **\n+  ** But do not disable the term unless we are certain that the term is\n+  ** not a transitive constraint.  For an example of where that does not\n+  ** work, see https:\/\/sqlite.org\/forum\/forumpost\/eb8613976a (2021-05-04)\n+  *\/\n+  if( (pLevel->pWLoop->wsFlags & WHERE_TRANSCONS)==0\n+   || (pTerm->eOperator & WO_EQUIV)==0\n+  ){\n+    disableTerm(pLevel, pTerm);\n+  }\n+\n@@ -141600,0 +147163,1 @@\n+    sqlite3VdbeAddOp3(v, OP_Null, 0, regBase, regBase+nSkip-1);\n@@ -141634,1 +147198,1 @@\n-        sqlite3VdbeAddOp2(v, OP_SCopy, r1, regBase+j);\n+        sqlite3VdbeAddOp2(v, OP_Copy, r1, regBase+j);\n@@ -141651,1 +147215,1 @@\n-      if( zAff ){\n+      if( pParse->db->mallocFailed==0 && pParse->nErr==0 ){\n@@ -141814,1 +147378,1 @@\n-  struct SrcList_item *pTabItem,  \/* FROM clause item *\/\n+  SrcItem *pTabItem,  \/* FROM clause item *\/\n@@ -141954,1 +147518,1 @@\n-    int *ai = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*(pTab->nCol+1));\n+    u32 *ai = (u32*)sqlite3DbMallocZero(pParse->db, sizeof(u32)*(pTab->nCol+1));\n@@ -141983,1 +147547,1 @@\n-    if( (p->flags & EP_xIsSelect) ){\n+    if( ExprUseXSelect(p) ){\n@@ -141993,1 +147557,3 @@\n-      ExprList *pList = p->x.pList;\n+      const ExprList *pList;\n+      assert( ExprUseXList(p) );\n+      pList = p->x.pList;\n@@ -142000,1 +147566,1 @@\n-    assert( nReg==1 );\n+    assert( nReg==1 || pParse->nErr );\n@@ -142046,1 +147612,0 @@\n-    pExpr->y.pTab = 0;\n@@ -142049,1 +147614,2 @@\n-    ExprClearProperty(pExpr, EP_Skip|EP_Unlikely);\n+    ExprClearProperty(pExpr, EP_Skip|EP_Unlikely|EP_WinFunc|EP_Subrtn);\n+    pExpr->y.pTab = 0;\n@@ -142064,1 +147630,1 @@\n-      assert( pExpr->y.pTab!=0 );\n+      assert( ExprUseYTab(pExpr) && pExpr->y.pTab!=0 );\n@@ -142112,1 +147678,1 @@\n-      assert( aColExpr->a[iIdxCol].pExpr!=0 );\n+      assert( aColExpr!=0 && aColExpr->a[iIdxCol].pExpr!=0 );\n@@ -142119,2 +147685,3 @@\n-       && (pTab->aCol[iRef].zColl==0\n-           || sqlite3StrICmp(pTab->aCol[iRef].zColl, sqlite3StrBINARY)==0)\n+       && ((pTab->aCol[iRef].colFlags & COLFLAG_HASCOLL)==0\n+           || sqlite3StrICmp(sqlite3ColumnColl(&pTab->aCol[iRef]),\n+                                               sqlite3StrBINARY)==0)\n@@ -142189,1 +147756,1 @@\n-  struct SrcList_item *pTabItem;  \/* FROM clause term being coded *\/\n+  SrcItem *pTabItem;              \/* FROM clause term being coded *\/\n@@ -142294,0 +147861,3 @@\n+    \/* An OOM inside of AddOp4(OP_VFilter) instruction above might have freed\n+    ** the u.vtab.idxStr.  NULL it out to prevent a use-after-free *\/\n+    if( db->mallocFailed ) pLoop->u.vtab.idxStr = 0;\n@@ -142297,1 +147867,6 @@\n-    iIn = pLevel->u.in.nIn;\n+    assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );\n+    if( pLoop->wsFlags & WHERE_IN_ABLE ){\n+      iIn = pLevel->u.in.nIn;\n+    }else{\n+      iIn = 0;\n+    }\n@@ -142374,3 +147949,0 @@\n-    if( (pTerm->prereqAll & pLevel->notReady)==0 ){\n-      pTerm->wtFlags |= TERM_CODED;\n-    }\n@@ -142552,0 +148124,1 @@\n+    int addrSeekScan = 0;        \/* Opcode of the OP_SeekScan, if any *\/\n@@ -142623,3 +148196,1 @@\n-    if( (nEq<pIdx->nKeyCol && bRev==(pIdx->aSortOrder[nEq]==SQLITE_SO_ASC))\n-     || (bRev && pIdx->nKeyCol==nEq)\n-    ){\n+    if( (nEq<pIdx->nColumn && bRev==(pIdx->aSortOrder[nEq]==SQLITE_SO_ASC)) ){\n@@ -142631,0 +148202,6 @@\n+    if( iLevel>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)!=0 ){\n+      \/* In case OP_SeekScan is used, ensure that the index cursor does not\n+      ** point to a valid row for the first iteration of this loop. *\/\n+      sqlite3VdbeAddOp1(v, OP_NullRow, iIdxCur);\n+    }\n+\n@@ -142690,3 +148267,0 @@\n-      if( pLoop->wsFlags & WHERE_IN_EARLYOUT ){\n-        sqlite3VdbeAddOp1(v, OP_SeekHit, iIdxCur);\n-      }\n@@ -142700,0 +148274,14 @@\n+      if( (pLoop->wsFlags & WHERE_IN_SEEKSCAN)!=0 && op==OP_SeekGE ){\n+        assert( regBignull==0 );\n+        \/* TUNING:  The OP_SeekScan opcode seeks to reduce the number\n+        ** of expensive seek operations by replacing a single seek with\n+        ** 1 or more step operations.  The question is, how many steps\n+        ** should we try before giving up and going with a seek.  The cost\n+        ** of a seek is proportional to the logarithm of the of the number\n+        ** of entries in the tree, so basing the number of steps to try\n+        ** on the estimated number of rows in the btree seems like a good\n+        ** guess. *\/\n+        addrSeekScan = sqlite3VdbeAddOp1(v, OP_SeekScan,\n+                                         (pIdx->aiRowLogEst[0]+9)\/10);\n+        VdbeCoverage(v);\n+      }\n@@ -142731,0 +148319,1 @@\n+    assert( pLevel->p2==0 );\n@@ -142733,0 +148322,10 @@\n+      if( addrSeekScan ){\n+        \/* For a seek-scan that has a range on the lowest term of the index,\n+        ** we have to make the top of the loop be code that sets the end\n+        ** condition of the range.  Otherwise, the OP_SeekScan might jump\n+        ** over that initialization, leaving the range-end value set to the\n+        ** range-start value, resulting in a wrong answer.\n+        ** See ticket 5981a8c041a3c2f3 (2021-11-02).\n+        *\/\n+        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n+      }\n@@ -142766,1 +148365,1 @@\n-    pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n+    if( pLevel->p2==0 ) pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n@@ -142782,0 +148381,1 @@\n+      if( addrSeekScan ) sqlite3VdbeJumpHere(v, addrSeekScan);\n@@ -142801,2 +148401,2 @@\n-    if( pLoop->wsFlags & WHERE_IN_EARLYOUT ){\n-      sqlite3VdbeAddOp2(v, OP_SeekHit, iIdxCur, 1);\n+    if( (pLoop->wsFlags & WHERE_IN_EARLYOUT)!=0 ){\n+      sqlite3VdbeAddOp3(v, OP_SeekHit, iIdxCur, nEq, nEq);\n@@ -142811,11 +148411,1 @@\n-      if( (pWInfo->wctrlFlags & WHERE_SEEK_TABLE)\n-       || ( (pWInfo->wctrlFlags & WHERE_SEEK_UNIQ_TABLE)!=0\n-           && (pWInfo->eOnePass==ONEPASS_SINGLE || pLoop->nLTerm==0) )\n-      ){\n-        iRowidReg = ++pParse->nMem;\n-        sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, iRowidReg);\n-        sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, iRowidReg);\n-        VdbeCoverage(v);\n-      }else{\n-        codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);\n-      }\n+      codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);\n@@ -142948,1 +148538,0 @@\n-    u16 wctrlFlags;                    \/* Flags for sub-WHERE clause *\/\n@@ -142966,1 +148555,1 @@\n-      struct SrcList_item *origSrc;     \/* Original list of tables *\/\n+      SrcItem *origSrc;              \/* Original list of tables *\/\n@@ -143039,1 +148628,1 @@\n-        ** prevents sqlite3PExpr() from implementing AND short-circuit\n+        ** prevents sqlite3PExpr() from applying the AND short-circuit\n@@ -143049,1 +148638,0 @@\n-    wctrlFlags =  WHERE_OR_SUBCLAUSE | (pWInfo->wctrlFlags & WHERE_SEEK_TABLE);\n@@ -143056,0 +148644,1 @@\n+        Expr *pDelete;                  \/* Local copy of OR clause term *\/\n@@ -143060,0 +148649,5 @@\n+        pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, 0);\n+        if( db->mallocFailed ){\n+          sqlite3ExprDelete(db, pDelete);\n+          continue;\n+        }\n@@ -143068,1 +148662,1 @@\n-                                      wctrlFlags, iCovCur);\n+                                      WHERE_OR_SUBCLAUSE, iCovCur);\n@@ -143166,0 +148760,3 @@\n+          if( sqlite3WhereUsesDeferredSeek(pSubWInfo) ){\n+            pWInfo->bDeferredSeek = 1;\n+          }\n@@ -143171,0 +148768,1 @@\n+        sqlite3ExprDelete(db, pDelete);\n@@ -143174,1 +148772,4 @@\n-    pLevel->u.pCovidx = pCov;\n+    assert( pLevel->pWLoop==pLoop );\n+    assert( (pLoop->wsFlags & WHERE_MULTI_OR)!=0 );\n+    assert( (pLoop->wsFlags & WHERE_IN_ABLE)==0 );\n+    pLevel->u.pCoveringIdx = pCov;\n@@ -143318,1 +148919,2 @@\n-    pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.leftColumn, notReady,\n+    assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+    pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.x.leftColumn, notReady,\n@@ -143323,1 +148925,1 @@\n-     && (pAlt->pExpr->flags & EP_xIsSelect)\n+     && ExprUseXSelect(pAlt->pExpr)\n@@ -143335,0 +148937,1 @@\n+    pAlt->wtFlags |= TERM_CODED;\n@@ -143571,0 +149174,1 @@\n+  assert( ExprUseXList(pExpr) );\n@@ -143586,1 +149190,2 @@\n-    z = (u8*)pRight->u.zToken;\n+    assert( !ExprHasProperty(pRight, EP_IntValue) );\n+     z = (u8*)pRight->u.zToken;\n@@ -143615,1 +149220,3 @@\n-        char *zNew = pPrefix->u.zToken;\n+        char *zNew;\n+        assert( !ExprHasProperty(pPrefix, EP_IntValue) );\n+        zNew = pPrefix->u.zToken;\n@@ -143639,1 +149246,3 @@\n-         || IsVirtual(pLeft->y.pTab)  \/* Value might be numeric *\/\n+         || (ALWAYS( ExprUseYTab(pLeft) )\n+             && pLeft->y.pTab\n+             && IsVirtual(pLeft->y.pTab))  \/* Might be numeric *\/\n@@ -143667,0 +149276,1 @@\n+        assert( !ExprHasProperty(pRight, EP_IntValue) );\n@@ -143740,0 +149350,1 @@\n+    assert( ExprUseXList(pExpr) );\n@@ -143753,0 +149364,1 @@\n+    assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );\n@@ -143756,0 +149368,1 @@\n+        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n@@ -143776,0 +149389,1 @@\n+    assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );\n@@ -143785,1 +149399,2 @@\n-      pMod = (sqlite3_module *)pVtab->pModule;\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+       pMod = (sqlite3_module *)pVtab->pModule;\n@@ -143800,0 +149415,1 @@\n+    assert( pLeft->op!=TK_COLUMN || ExprUseYTab(pLeft) );\n@@ -143804,0 +149420,1 @@\n+    assert( pRight==0 || pRight->op!=TK_COLUMN || ExprUseYTab(pRight) );\n@@ -143887,0 +149504,1 @@\n+  if( (pOne->wtFlags | pTwo->wtFlags) & TERM_VNULL ) return;\n@@ -144055,0 +149673,1 @@\n+        pOrTerm->leftCursor = -1;\n@@ -144097,0 +149716,2 @@\n+  pTerm->eOperator = WO_OR;\n+  pTerm->leftCursor = -1;\n@@ -144098,1 +149719,0 @@\n-    pTerm->eOperator = WO_OR;\n@@ -144100,2 +149720,0 @@\n-  }else{\n-    pTerm->eOperator = WO_OR;\n@@ -144174,1 +149792,2 @@\n-        iColumn = pOrTerm->u.leftColumn;\n+        assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n+        iColumn = pOrTerm->u.x.leftColumn;\n@@ -144194,0 +149813,1 @@\n+        assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n@@ -144196,1 +149816,1 @@\n-        }else if( pOrTerm->u.leftColumn!=iColumn || (iColumn==XN_EXPR\n+        }else if( pOrTerm->u.x.leftColumn!=iColumn || (iColumn==XN_EXPR\n@@ -144230,0 +149850,1 @@\n+        assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n@@ -144231,1 +149852,1 @@\n-        assert( pOrTerm->u.leftColumn==iColumn );\n+        assert( pOrTerm->u.x.leftColumn==iColumn );\n@@ -144242,1 +149863,1 @@\n-        assert( !ExprHasProperty(pNew, EP_xIsSelect) );\n+        assert( ExprUseXList(pNew) );\n@@ -144247,1 +149868,1 @@\n-        \/* pTerm = &pWC->a[idxTerm]; \/\/ would be needed if pTerm where used again *\/\n+        \/* pTerm = &pWC->a[idxTerm]; \/\/ would be needed if pTerm where reused *\/\n@@ -144370,0 +149991,1 @@\n+    assert( ExprUseXList(pExpr) );\n@@ -144371,0 +149993,1 @@\n+\n@@ -144383,0 +150006,1 @@\n+\n@@ -144434,1 +150058,1 @@\n-    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+    if( ExprUseXSelect(pExpr) ){\n@@ -144467,1 +150091,1 @@\n-    if( pTerm->iField>0 ){\n+    if( pTerm->u.x.iField>0 ){\n@@ -144470,1 +150094,2 @@\n-      pLeft = pLeft->x.pList->a[pTerm->iField-1].pExpr;\n+      assert( ExprUseXList(pLeft) );\n+      pLeft = pLeft->x.pList->a[pTerm->u.x.iField-1].pExpr;\n@@ -144475,1 +150100,2 @@\n-      pTerm->u.leftColumn = aiCurCol[1];\n+      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+      pTerm->u.x.leftColumn = aiCurCol[1];\n@@ -144481,0 +150107,1 @@\n+     && !ExprHasProperty(pRight, EP_FixedCol)\n@@ -144485,1 +150112,1 @@\n-      assert( pTerm->iField==0 );\n+      assert( pTerm->u.x.iField==0 );\n@@ -144511,1 +150138,2 @@\n-      pNew->u.leftColumn = aiCurCol[1];\n+      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+      pNew->u.x.leftColumn = aiCurCol[1];\n@@ -144516,0 +150144,11 @@\n+    }else\n+    if( op==TK_ISNULL\n+     && !ExprHasProperty(pExpr,EP_FromJoin)\n+     && 0==sqlite3ExprCanBeNull(pLeft)\n+    ){\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+      pExpr->op = TK_TRUEFALSE;\n+      pExpr->u.zToken = \"false\";\n+      ExprSetProperty(pExpr, EP_IsFalse);\n+      pTerm->prereqAll = 0;\n+      pTerm->eOperator = 0;\n@@ -144536,1 +150175,1 @@\n-    ExprList *pList = pExpr->x.pList;\n+    ExprList *pList;\n@@ -144539,0 +150178,2 @@\n+    assert( ExprUseXList(pExpr) );\n+    pList = pExpr->x.pList;\n@@ -144567,0 +150208,36 @@\n+  \/* The form \"x IS NOT NULL\" can sometimes be evaluated more efficiently\n+  ** as \"x>NULL\" if x is not an INTEGER PRIMARY KEY.  So construct a\n+  ** virtual term of that form.\n+  **\n+  ** The virtual term must be tagged with TERM_VNULL.\n+  *\/\n+  else if( pExpr->op==TK_NOTNULL ){\n+    if( pExpr->pLeft->op==TK_COLUMN\n+     && pExpr->pLeft->iColumn>=0\n+     && !ExprHasProperty(pExpr, EP_FromJoin)\n+    ){\n+      Expr *pNewExpr;\n+      Expr *pLeft = pExpr->pLeft;\n+      int idxNew;\n+      WhereTerm *pNewTerm;\n+\n+      pNewExpr = sqlite3PExpr(pParse, TK_GT,\n+                              sqlite3ExprDup(db, pLeft, 0),\n+                              sqlite3ExprAlloc(db, TK_NULL, 0, 0));\n+\n+      idxNew = whereClauseInsert(pWC, pNewExpr,\n+                                TERM_VIRTUAL|TERM_DYNAMIC|TERM_VNULL);\n+      if( idxNew ){\n+        pNewTerm = &pWC->a[idxNew];\n+        pNewTerm->prereqRight = 0;\n+        pNewTerm->leftCursor = pLeft->iTable;\n+        pNewTerm->u.x.leftColumn = pLeft->iColumn;\n+        pNewTerm->eOperator = WO_GT;\n+        markTermAsChild(pWC, idxNew, idxTerm);\n+        pTerm = &pWC->a[idxTerm];\n+        pTerm->wtFlags |= TERM_COPIED;\n+        pNewTerm->prereqAll = pTerm->prereqAll;\n+      }\n+    }\n+  }\n+\n@@ -144582,1 +150259,2 @@\n-  if( pWC->op==TK_AND\n+  else if( pExpr->op==TK_FUNCTION\n+   && pWC->op==TK_AND\n@@ -144594,0 +150272,1 @@\n+    assert( ExprUseXList(pExpr) );\n@@ -144596,0 +150275,3 @@\n+    assert( pStr1==0 || !ExprHasProperty(pStr1, EP_IntValue) );\n+    assert( pStr2==0 || !ExprHasProperty(pStr2, EP_IntValue) );\n+\n@@ -144652,46 +150334,0 @@\n-#ifndef SQLITE_OMIT_VIRTUALTABLE\n-  \/* Add a WO_AUX auxiliary term to the constraint set if the\n-  ** current expression is of the form \"column OP expr\" where OP\n-  ** is an operator that gets passed into virtual tables but which is\n-  ** not normally optimized for ordinary tables.  In other words, OP\n-  ** is one of MATCH, LIKE, GLOB, REGEXP, !=, IS, IS NOT, or NOT NULL.\n-  ** This information is used by the xBestIndex methods of\n-  ** virtual tables.  The native query optimizer does not attempt\n-  ** to do anything with MATCH functions.\n-  *\/\n-  if( pWC->op==TK_AND ){\n-    Expr *pRight = 0, *pLeft = 0;\n-    int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);\n-    while( res-- > 0 ){\n-      int idxNew;\n-      WhereTerm *pNewTerm;\n-      Bitmask prereqColumn, prereqExpr;\n-\n-      prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);\n-      prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);\n-      if( (prereqExpr & prereqColumn)==0 ){\n-        Expr *pNewExpr;\n-        pNewExpr = sqlite3PExpr(pParse, TK_MATCH,\n-            0, sqlite3ExprDup(db, pRight, 0));\n-        if( ExprHasProperty(pExpr, EP_FromJoin) && pNewExpr ){\n-          ExprSetProperty(pNewExpr, EP_FromJoin);\n-          pNewExpr->iRightJoinTable = pExpr->iRightJoinTable;\n-        }\n-        idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n-        testcase( idxNew==0 );\n-        pNewTerm = &pWC->a[idxNew];\n-        pNewTerm->prereqRight = prereqExpr;\n-        pNewTerm->leftCursor = pLeft->iTable;\n-        pNewTerm->u.leftColumn = pLeft->iColumn;\n-        pNewTerm->eOperator = WO_AUX;\n-        pNewTerm->eMatchOp = eOp2;\n-        markTermAsChild(pWC, idxNew, idxTerm);\n-        pTerm = &pWC->a[idxTerm];\n-        pTerm->wtFlags |= TERM_COPIED;\n-        pNewTerm->prereqAll = pTerm->prereqAll;\n-      }\n-      SWAP(Expr*, pLeft, pRight);\n-    }\n-  }\n-#endif \/* SQLITE_OMIT_VIRTUALTABLE *\/\n-\n@@ -144705,6 +150341,6 @@\n-  if( pWC->op==TK_AND\n-  && (pExpr->op==TK_EQ || pExpr->op==TK_IS)\n-  && (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1\n-  && sqlite3ExprVectorSize(pExpr->pRight)==nLeft\n-  && ( (pExpr->pLeft->flags & EP_xIsSelect)==0\n-    || (pExpr->pRight->flags & EP_xIsSelect)==0)\n+  if( (pExpr->op==TK_EQ || pExpr->op==TK_IS)\n+   && (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1\n+   && sqlite3ExprVectorSize(pExpr->pRight)==nLeft\n+   && ( (pExpr->pLeft->flags & EP_xIsSelect)==0\n+     || (pExpr->pRight->flags & EP_xIsSelect)==0)\n+   && pWC->op==TK_AND\n@@ -144716,2 +150352,2 @@\n-      Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i);\n-      Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i);\n+      Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i, nLeft);\n+      Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i, nLeft);\n@@ -144732,1 +150368,1 @@\n-  ** expression). The WhereTerm.iField variable identifies the index within\n+  ** expression). The WhereTerm.u.x.iField variable identifies the index within\n@@ -144738,1 +150374,2 @@\n-  if( pWC->op==TK_AND && pExpr->op==TK_IN && pTerm->iField==0\n+  else if( pExpr->op==TK_IN\n+   && pTerm->u.x.iField==0\n@@ -144740,0 +150377,1 @@\n+   && ALWAYS( ExprUseXSelect(pExpr) )\n@@ -144744,0 +150382,1 @@\n+   && pWC->op==TK_AND\n@@ -144749,1 +150388,1 @@\n-      pWC->a[idxNew].iField = i+1;\n+      pWC->a[idxNew].u.x.iField = i+1;\n@@ -144755,7 +150394,9 @@\n-#ifdef SQLITE_ENABLE_STAT4\n-  \/* When sqlite_stat4 histogram data is available an operator of the\n-  ** form \"x IS NOT NULL\" can sometimes be evaluated more efficiently\n-  ** as \"x>NULL\" if x is not an INTEGER PRIMARY KEY.  So construct a\n-  ** virtual term of that form.\n-  **\n-  ** Note that the virtual term must be tagged with TERM_VNULL.\n+#ifndef SQLITE_OMIT_VIRTUALTABLE\n+  \/* Add a WO_AUX auxiliary term to the constraint set if the\n+  ** current expression is of the form \"column OP expr\" where OP\n+  ** is an operator that gets passed into virtual tables but which is\n+  ** not normally optimized for ordinary tables.  In other words, OP\n+  ** is one of MATCH, LIKE, GLOB, REGEXP, !=, IS, IS NOT, or NOT NULL.\n+  ** This information is used by the xBestIndex methods of\n+  ** virtual tables.  The native query optimizer does not attempt\n+  ** to do anything with MATCH functions.\n@@ -144763,27 +150404,32 @@\n-  if( pExpr->op==TK_NOTNULL\n-   && pExpr->pLeft->op==TK_COLUMN\n-   && pExpr->pLeft->iColumn>=0\n-   && !ExprHasProperty(pExpr, EP_FromJoin)\n-   && OptimizationEnabled(db, SQLITE_Stat4)\n-  ){\n-    Expr *pNewExpr;\n-    Expr *pLeft = pExpr->pLeft;\n-    int idxNew;\n-    WhereTerm *pNewTerm;\n-\n-    pNewExpr = sqlite3PExpr(pParse, TK_GT,\n-                            sqlite3ExprDup(db, pLeft, 0),\n-                            sqlite3ExprAlloc(db, TK_NULL, 0, 0));\n-\n-    idxNew = whereClauseInsert(pWC, pNewExpr,\n-                              TERM_VIRTUAL|TERM_DYNAMIC|TERM_VNULL);\n-    if( idxNew ){\n-      pNewTerm = &pWC->a[idxNew];\n-      pNewTerm->prereqRight = 0;\n-      pNewTerm->leftCursor = pLeft->iTable;\n-      pNewTerm->u.leftColumn = pLeft->iColumn;\n-      pNewTerm->eOperator = WO_GT;\n-      markTermAsChild(pWC, idxNew, idxTerm);\n-      pTerm = &pWC->a[idxTerm];\n-      pTerm->wtFlags |= TERM_COPIED;\n-      pNewTerm->prereqAll = pTerm->prereqAll;\n+  else if( pWC->op==TK_AND ){\n+    Expr *pRight = 0, *pLeft = 0;\n+    int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);\n+    while( res-- > 0 ){\n+      int idxNew;\n+      WhereTerm *pNewTerm;\n+      Bitmask prereqColumn, prereqExpr;\n+\n+      prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);\n+      prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);\n+      if( (prereqExpr & prereqColumn)==0 ){\n+        Expr *pNewExpr;\n+        pNewExpr = sqlite3PExpr(pParse, TK_MATCH,\n+            0, sqlite3ExprDup(db, pRight, 0));\n+        if( ExprHasProperty(pExpr, EP_FromJoin) && pNewExpr ){\n+          ExprSetProperty(pNewExpr, EP_FromJoin);\n+          pNewExpr->iRightJoinTable = pExpr->iRightJoinTable;\n+        }\n+        idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n+        testcase( idxNew==0 );\n+        pNewTerm = &pWC->a[idxNew];\n+        pNewTerm->prereqRight = prereqExpr;\n+        pNewTerm->leftCursor = pLeft->iTable;\n+        pNewTerm->u.x.leftColumn = pLeft->iColumn;\n+        pNewTerm->eOperator = WO_AUX;\n+        pNewTerm->eMatchOp = eOp2;\n+        markTermAsChild(pWC, idxNew, idxTerm);\n+        pTerm = &pWC->a[idxTerm];\n+        pTerm->wtFlags |= TERM_COPIED;\n+        pNewTerm->prereqAll = pTerm->prereqAll;\n+      }\n+      SWAP(Expr*, pLeft, pRight);\n@@ -144792,1 +150438,1 @@\n-#endif \/* SQLITE_ENABLE_STAT4 *\/\n+#endif \/* SQLITE_OMIT_VIRTUALTABLE *\/\n@@ -144827,0 +150473,1 @@\n+  assert( pE2!=0 || pExpr==0 );\n@@ -144894,1 +150541,1 @@\n-  }else if( ExprHasProperty(p, EP_xIsSelect) ){\n+  }else if( ExprUseXSelect(p) ){\n@@ -144901,1 +150548,2 @@\n-  if( (p->op==TK_FUNCTION || p->op==TK_AGG_FUNCTION) && p->y.pWin ){\n+  if( (p->op==TK_FUNCTION || p->op==TK_AGG_FUNCTION) && ExprUseYWin(p) ){\n+    assert( p->y.pWin!=0 );\n@@ -144951,1 +150599,1 @@\n-  struct SrcList_item *pItem,       \/* The FROM clause term to process *\/\n+  SrcItem *pItem,                   \/* The FROM clause term to process *\/\n@@ -144976,0 +150624,1 @@\n+    assert( ExprUseYTab(pColRef) );\n@@ -145028,6 +150677,0 @@\n-\/* Test variable that can be set to enable WHERE tracing *\/\n-#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)\n-\/***\/ int sqlite3WhereTrace = 0;\n-#endif\n-\n-\n@@ -145050,2 +150693,6 @@\n-** Return TRUE if the WHERE clause returns rows in ORDER BY order.\n-** Return FALSE if the output needs to be sorted.\n+** Return the number of ORDER BY terms that are satisfied by the\n+** WHERE clause.  A return of 0 means that the output must be\n+** completely sorted.  A return equal to the number of ORDER BY\n+** terms means that no sorting is needed at all.  A return that\n+** is positive but less than the number of ORDER BY terms means that\n+** block sorting is required.\n@@ -145092,0 +150739,26 @@\n+\/*\n+** While generating code for the min\/max optimization, after handling\n+** the aggregate-step call to min() or max(), check to see if any\n+** additional looping is required.  If the output order is such that\n+** we are certain that the correct answer has already been found, then\n+** code an OP_Goto to by pass subsequent processing.\n+**\n+** Any extra OP_Goto that is coded here is an optimization.  The\n+** correct answer should be obtained regardless.  This OP_Goto just\n+** makes the answer appear faster.\n+*\/\n+SQLITE_PRIVATE void sqlite3WhereMinMaxOptEarlyOut(Vdbe *v, WhereInfo *pWInfo){\n+  WhereLevel *pInner;\n+  int i;\n+  if( !pWInfo->bOrderedInnerLoop ) return;\n+  if( pWInfo->nOBSat==0 ) return;\n+  for(i=pWInfo->nLevel-1; i>=0; i--){\n+    pInner = &pWInfo->a[i];\n+    if( (pInner->pWLoop->wsFlags & WHERE_COLUMN_IN)!=0 ){\n+      sqlite3VdbeGoto(v, pInner->addrNxt);\n+      return;\n+    }\n+  }\n+  sqlite3VdbeGoto(v, pWInfo->iBreak);\n+}\n+\n@@ -145222,0 +150895,12 @@\n+\/*\n+** If the right-hand branch of the expression is a TK_COLUMN, then return\n+** a pointer to the right-hand branch.  Otherwise, return NULL.\n+*\/\n+static Expr *whereRightSubexprIsColumn(Expr *p){\n+  p = sqlite3ExprSkipCollateAndLikely(p->pRight);\n+  if( ALWAYS(p!=0) && p->op==TK_COLUMN && !ExprHasProperty(p, EP_FixedCol) ){\n+    return p;\n+  }\n+  return 0;\n+}\n+\n@@ -145241,0 +150926,1 @@\n+    assert( iCur>=0 );\n@@ -145243,0 +150929,1 @@\n+        assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 || pTerm->leftCursor<0 );\n@@ -145244,1 +150931,1 @@\n-         && pTerm->u.leftColumn==iColumn\n+         && pTerm->u.x.leftColumn==iColumn\n@@ -145252,2 +150939,1 @@\n-           && (pX = sqlite3ExprSkipCollateAndLikely(pTerm->pExpr->pRight))->op\n-               ==TK_COLUMN\n+           && (pX = whereRightSubexprIsColumn(pTerm->pExpr))!=0\n@@ -145285,1 +150971,2 @@\n-             && (pX = pTerm->pExpr->pRight)->op==TK_COLUMN\n+             && (pX = pTerm->pExpr->pRight, ALWAYS(pX!=0))\n+             && pX->op==TK_COLUMN\n@@ -145294,0 +150981,12 @@\n+#ifdef WHERETRACE_ENABLED\n+            if( sqlite3WhereTrace & 0x20000 ){\n+              int ii;\n+              sqlite3DebugPrintf(\"SCAN-TERM %p: nEquiv=%d\",\n+                 pTerm, pScan->nEquiv);\n+              for(ii=0; ii<pScan->nEquiv; ii++){\n+                sqlite3DebugPrintf(\" {%d:%d}\",\n+                   pScan->aiCur[ii], pScan->aiColumn[ii]);\n+              }\n+              sqlite3DebugPrintf(\"\\n\");\n+            }\n+#endif\n@@ -145449,1 +151148,2 @@\n-    if( p->op==TK_COLUMN\n+    if( ALWAYS(p!=0)\n+     && (p->op==TK_COLUMN || p->op==TK_AGG_COLUMN)\n@@ -145513,1 +151213,3 @@\n-    if( p->op==TK_COLUMN && p->iTable==iBase && p->iColumn<0 ) return 1;\n+    if( NEVER(p==0) ) continue;\n+    if( p->op!=TK_COLUMN && p->op!=TK_AGG_COLUMN ) continue;\n+    if( p->iTable==iBase && p->iColumn<0 ) return 1;\n@@ -145531,0 +151233,1 @@\n+    if( pIdx->pPartIdxWhere ) continue;\n@@ -145585,4 +151288,4 @@\n-      if( iAutoidxCur ){\n-        pOp->opcode = OP_Sequence;\n-        pOp->p1 = iAutoidxCur;\n-      }else{\n+      pOp->opcode = OP_Sequence;\n+      pOp->p1 = iAutoidxCur;\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+      if( iAutoidxCur==0 ){\n@@ -145590,1 +151293,0 @@\n-        pOp->p1 = 0;\n@@ -145593,0 +151295,1 @@\n+#endif\n@@ -145650,1 +151353,1 @@\n-  struct SrcList_item *pSrc,     \/* Table we are trying to access *\/\n+  SrcItem *pSrc,                 \/* Table we are trying to access *\/\n@@ -145666,2 +151369,3 @@\n-  if( pTerm->u.leftColumn<0 ) return 0;\n-  aff = pSrc->pTab->aCol[pTerm->u.leftColumn].affinity;\n+  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+  if( pTerm->u.x.leftColumn<0 ) return 0;\n+  aff = pSrc->pTab->aCol[pTerm->u.x.leftColumn].affinity;\n@@ -145684,1 +151388,1 @@\n-  struct SrcList_item *pSrc,  \/* The FROM clause term to get the next index *\/\n+  SrcItem *pSrc,              \/* The FROM clause term to get the next index *\/\n@@ -145708,1 +151412,1 @@\n-  struct SrcList_item *pTabItem;  \/* FROM clause term being indexed *\/\n+  SrcItem *pTabItem;          \/* FROM clause term being indexed *\/\n@@ -145738,2 +151442,5 @@\n-      int iCol = pTerm->u.leftColumn;\n-      Bitmask cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);\n+      int iCol;\n+      Bitmask cMask;\n+      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+      iCol = pTerm->u.x.leftColumn;\n+      cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);\n@@ -145745,1 +151452,1 @@\n-            pTable->aCol[iCol].zName);\n+            pTable->aCol[iCol].zCnName);\n@@ -145757,1 +151464,1 @@\n-  assert( nKeyCol>0 );\n+  assert( nKeyCol>0 || pParse->db->mallocFailed );\n@@ -145791,2 +151498,5 @@\n-      int iCol = pTerm->u.leftColumn;\n-      Bitmask cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);\n+      int iCol;\n+      Bitmask cMask;\n+      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+      iCol = pTerm->u.x.leftColumn;\n+      cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);\n@@ -145798,1 +151508,1 @@\n-        pIdx->aiColumn[n] = pTerm->u.leftColumn;\n+        pIdx->aiColumn[n] = pTerm->u.x.leftColumn;\n@@ -145892,1 +151602,1 @@\n-  struct SrcList_item *pSrc,      \/* The FROM clause term that is the vtab *\/\n+  SrcItem *pSrc,                  \/* The FROM clause term that is the vtab *\/\n@@ -145919,1 +151629,2 @@\n-    assert( pTerm->u.leftColumn>=(-1) );\n+    assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+    assert( pTerm->u.x.leftColumn>=(-1) );\n@@ -145979,2 +151690,3 @@\n-    assert( pTerm->u.leftColumn>=(-1) );\n-    pIdxCons[j].iColumn = pTerm->u.leftColumn;\n+    assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+    assert( pTerm->u.x.leftColumn>=(-1) );\n+    pIdxCons[j].iColumn = pTerm->u.x.leftColumn;\n@@ -146742,0 +152454,1 @@\n+      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n@@ -146743,1 +152456,1 @@\n-                       pTerm->leftCursor, pTerm->u.leftColumn);\n+                       pTerm->leftCursor, pTerm->u.x.leftColumn);\n@@ -146745,1 +152458,1 @@\n-      sqlite3_snprintf(sizeof(zLeft),zLeft,\"indexable=0x%lld\",\n+      sqlite3_snprintf(sizeof(zLeft),zLeft,\"indexable=0x%llx\",\n@@ -146759,2 +152472,2 @@\n-    if( pTerm->iField ){\n-      sqlite3DebugPrintf(\" iField=%d\", pTerm->iField);\n+    if( (pTerm->eOperator & (WO_OR|WO_AND))==0 && pTerm->u.x.iField ){\n+      sqlite3DebugPrintf(\" iField=%d\", pTerm->u.x.iField);\n@@ -146790,1 +152503,1 @@\n-  struct SrcList_item *pItem = pWInfo->pTabList->a + p->iTab;\n+  SrcItem *pItem = pWInfo->pTabList->a + p->iTab;\n@@ -146894,1 +152607,1 @@\n-    memset(&pTo->u, 0, sizeof(pTo->u));\n+    memset(pTo, 0, WHERE_LOOP_XFER_SZ);\n@@ -146923,1 +152636,2 @@\n-    if( pLevel->pWLoop && (pLevel->pWLoop->wsFlags & WHERE_IN_ABLE) ){\n+    if( pLevel->pWLoop && (pLevel->pWLoop->wsFlags & WHERE_IN_ABLE)!=0 ){\n+      assert( (pLevel->pWLoop->wsFlags & WHERE_MULTI_OR)==0 );\n@@ -146937,0 +152651,11 @@\n+\/* Undo all Expr node modifications\n+*\/\n+static void whereUndoExprMods(WhereInfo *pWInfo){\n+  while( pWInfo->pExprMods ){\n+    WhereExprMod *p = pWInfo->pExprMods;\n+    pWInfo->pExprMods = p->pNext;\n+    memcpy(p->pExpr, &p->orig, sizeof(p->orig));\n+    sqlite3DbFree(pWInfo->pParse->db, p);\n+  }\n+}\n+\n@@ -146940,1 +152665,2 @@\n-**   (1)  X has the same or lower cost that Y\n+**   (1)  X has the same or lower cost, or returns the same or fewer rows,\n+**        than Y.\n@@ -146963,0 +152689,1 @@\n+  if( pX->rRun>pY->rRun && pX->nOut>pY->nOut ) return 0;\n@@ -146964,4 +152691,0 @@\n-  if( pX->rRun >= pY->rRun ){\n-    if( pX->rRun > pY->rRun ) return 0;    \/* X costs more than Y *\/\n-    if( pX->nOut > pY->nOut ) return 0;    \/* X costs more than Y *\/\n-  }\n@@ -146983,2 +152706,2 @@\n-** Try to adjust the cost of WhereLoop pTemplate upwards or downwards so\n-** that:\n+** Try to adjust the cost and number of output rows of WhereLoop pTemplate\n+** upwards or downwards so that:\n@@ -147005,3 +152728,5 @@\n-                       pTemplate->rRun, pTemplate->nOut, p->rRun, p->nOut-1));\n-      pTemplate->rRun = p->rRun;\n-      pTemplate->nOut = p->nOut - 1;\n+                       pTemplate->rRun, pTemplate->nOut,\n+                       MIN(p->rRun, pTemplate->rRun),\n+                       MIN(p->nOut - 1, pTemplate->nOut)));\n+      pTemplate->rRun = MIN(p->rRun, pTemplate->rRun);\n+      pTemplate->nOut = MIN(p->nOut - 1, pTemplate->nOut);\n@@ -147012,3 +152737,5 @@\n-                       pTemplate->rRun, pTemplate->nOut, p->rRun, p->nOut+1));\n-      pTemplate->rRun = p->rRun;\n-      pTemplate->nOut = p->nOut + 1;\n+                       pTemplate->rRun, pTemplate->nOut,\n+                       MAX(p->rRun, pTemplate->rRun),\n+                       MAX(p->nOut + 1, pTemplate->nOut)));\n+      pTemplate->rRun = MAX(p->rRun, pTemplate->rRun);\n+      pTemplate->nOut = MAX(p->nOut + 1, pTemplate->nOut);\n@@ -147345,3 +153072,6 @@\n-    Expr *pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;\n-    Expr *pRhs = pTerm->pExpr->pRight;\n-    if( pRhs->flags & EP_xIsSelect ){\n+    Expr *pLhs, *pRhs;\n+\n+    assert( ExprUseXList(pTerm->pExpr->pLeft) );\n+    pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;\n+    pRhs = pTerm->pExpr->pRight;\n+    if( ExprUseXSelect(pRhs) ){\n@@ -147401,1 +153131,1 @@\n-  struct SrcList_item *pSrc,      \/* FROM clause term being analyzed *\/\n+  SrcItem *pSrc,                  \/* FROM clause term being analyzed *\/\n@@ -147427,1 +153157,1 @@\n-  WHERETRACE(0x800, (\"BEGIN %s.addBtreeIdx(%s), nEq=%d, nSkip=%d\\n\",\n+  WHERETRACE(0x800, (\"BEGIN %s.addBtreeIdx(%s), nEq=%d, nSkip=%d, rRun=%d\\n\",\n@@ -147429,1 +153159,1 @@\n-                     pNew->u.btree.nEq, pNew->nSkip));\n+                     pNew->u.btree.nEq, pNew->nSkip, pNew->rRun));\n@@ -147442,0 +153172,2 @@\n+  assert( pNew->u.btree.nEq<pProbe->nKeyCol\n+       || pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY );\n@@ -147506,1 +153238,1 @@\n-      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n+      if( ExprUseXSelect(pExpr) ){\n@@ -147523,2 +153255,2 @@\n-      if( pProbe->hasStat1 ){\n-        LogEst M, logK, safetyMargin;\n+      if( pProbe->hasStat1 && rLogSize>=10 ){\n+        LogEst M, logK, x;\n@@ -147542,1 +153274,2 @@\n-        ** the index.\n+        ** the index.  Do not bother with this optimization on very small\n+        ** tables (less than 2 rows) as it is pointless in that case.\n@@ -147546,2 +153279,3 @@\n-        safetyMargin = 10;  \/* TUNING: extra weight for indexed IN *\/\n-        if( M + logK + safetyMargin < nIn + rLogSize ){\n+        \/* TUNING      v-----  10 to bias toward indexed IN *\/\n+        x = M + logK + 10 - (nIn + rLogSize);\n+        if( x>=0 ){\n@@ -147549,3 +153283,9 @@\n-            (\"Scan preferred over IN operator on column %d of \\\"%s\\\" (%d<%d)\\n\",\n-             saved_nEq, pProbe->zName, M+logK+10, nIn+rLogSize));\n-          continue;\n+            (\"IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d) \"\n+             \"prefers indexed lookup\\n\",\n+             saved_nEq, M, logK, nIn, rLogSize, x));\n+        }else if( nInMul<2 && OptimizationEnabled(db, SQLITE_SeekScan) ){\n+          WHERETRACE(0x40,\n+            (\"IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d\"\n+             \" nInMul=%d) prefers skip-scan\\n\",\n+             saved_nEq, M, logK, nIn, rLogSize, x, nInMul));\n+          pNew->wsFlags |= WHERE_IN_SEEKSCAN;\n@@ -147554,2 +153294,4 @@\n-            (\"IN operator preferred on column %d of \\\"%s\\\" (%d>=%d)\\n\",\n-             saved_nEq, pProbe->zName, M+logK+10, nIn+rLogSize));\n+            (\"IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d\"\n+             \" nInMul=%d) prefers normal scan\\n\",\n+             saved_nEq, M, logK, nIn, rLogSize, x, nInMul));\n+          continue;\n@@ -147574,0 +153316,1 @@\n+      if( scan.iEquiv>1 ) pNew->wsFlags |= WHERE_TRANSCONS;\n@@ -147586,1 +153329,1 @@\n-        \/* Range contraints that come from the LIKE optimization are\n+        \/* Range constraints that come from the LIKE optimization are\n@@ -147635,2 +153378,2 @@\n-         && pNew->u.btree.nEq<=pProbe->nSampleCol\n-         && ((eOp & WO_IN)==0 || !ExprHasProperty(pTerm->pExpr, EP_xIsSelect))\n+         && ALWAYS(pNew->u.btree.nEq<=pProbe->nSampleCol)\n+         && ((eOp & WO_IN)==0 || ExprUseXList(pTerm->pExpr))\n@@ -147717,0 +153460,2 @@\n+     && (pNew->u.btree.nEq<pProbe->nKeyCol ||\n+           pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY)\n@@ -147797,0 +153542,1 @@\n+    if( NEVER(pExpr==0) ) continue;\n@@ -147837,0 +153583,1 @@\n+     && (pTerm->wtFlags & TERM_VNULL)==0\n@@ -147890,1 +153637,1 @@\n-  struct SrcList_item *pSrc;  \/* The FROM clause btree term to add *\/\n+  SrcItem *pSrc;              \/* The FROM clause btree term to add *\/\n@@ -147896,1 +153643,0 @@\n-  LogEst rLogSize;            \/* Logarithm of the number of rows in the table *\/\n@@ -147908,1 +153654,2 @@\n-  if( pSrc->pIBIndex ){\n+  if( pSrc->fg.isIndexedBy ){\n+    assert( pSrc->fg.isCte==0 );\n@@ -147910,1 +153657,1 @@\n-    pProbe = pSrc->pIBIndex;\n+    pProbe = pSrc->u2.pIBIndex;\n@@ -147939,1 +153686,0 @@\n-  rLogSize = estLog(rSize);\n@@ -147946,1 +153692,1 @@\n-   && pSrc->pIBIndex==0      \/* Has no INDEXED BY clause *\/\n+   && !pSrc->fg.isIndexedBy  \/* Has no INDEXED BY clause *\/\n@@ -147953,0 +153699,1 @@\n+    LogEst rLogSize;         \/* Logarithm of the number of rows in the table *\/\n@@ -147955,0 +153702,1 @@\n+    rLogSize = estLog(rSize);\n@@ -147972,1 +153720,1 @@\n-        if( pTab->pSelect==0 && (pTab->tabFlags & TF_Ephemeral)==0 ){\n+        if( !IsView(pTab) && (pTab->tabFlags & TF_Ephemeral)==0 ){\n@@ -147996,1 +153744,1 @@\n-      pProbe=(pSrc->pIBIndex ? 0 : pProbe->pNext), iSortIdx++\n+      pProbe=(pSrc->fg.isIndexedBy ? 0 : pProbe->pNext), iSortIdx++\n@@ -148019,0 +153767,1 @@\n+\n@@ -148027,1 +153776,15 @@\n-      \/* TUNING: Cost of full table scan is (N*3.0). *\/\n+      \/* TUNING: Cost of full table scan is 3.0*N.  The 3.0 factor is an\n+      ** extra cost designed to discourage the use of full table scans,\n+      ** since index lookups have better worst-case performance if our\n+      ** stat guesses are wrong.  Reduce the 3.0 penalty slightly\n+      ** (to 2.75) if we have valid STAT4 information for the table.\n+      ** At 2.75, a full table scan is preferred over using an index on\n+      ** a column with just two distinct values where each value has about\n+      ** an equal number of appearances.  Without STAT4 data, we still want\n+      ** to use an index in that case, since the constraint might be for\n+      ** the scarcer of the two values, and in that case an index lookup is\n+      ** better.\n+      *\/\n+#ifdef SQLITE_ENABLE_STAT4\n+      pNew->rRun = rSize + 16 - 2*((pTab->tabFlags & TF_HasStat4)!=0);\n+#else\n@@ -148029,0 +153792,1 @@\n+#endif\n@@ -148048,0 +153812,1 @@\n+       || pSrc->fg.isIndexedBy\n@@ -148154,1 +153919,1 @@\n-  struct SrcList_item *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];\n+  SrcItem *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];\n@@ -148346,1 +154111,1 @@\n-  struct SrcList_item *pSrc;   \/* The FROM clause term to search *\/\n+  SrcItem *pSrc;               \/* The FROM clause term to search *\/\n@@ -148474,1 +154239,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -148530,1 +154295,3 @@\n-        assert( rc==SQLITE_OK || rc==SQLITE_DONE || sCur.n==0 );\n+        assert( rc==SQLITE_OK || rc==SQLITE_DONE || sCur.n==0\n+                || rc==SQLITE_NOMEM );\n+        testcase( rc==SQLITE_NOMEM && sCur.n>0 );\n@@ -148590,2 +154357,2 @@\n-  struct SrcList_item *pItem;\n-  struct SrcList_item *pEnd = &pTabList->a[pWInfo->nLevel];\n+  SrcItem *pItem;\n+  SrcItem *pEnd = &pTabList->a[pWInfo->nLevel];\n@@ -148595,1 +154362,0 @@\n-  u8 priorJointype = 0;\n@@ -148606,1 +154372,1 @@\n-    if( ((pItem->fg.jointype|priorJointype) & (JT_LEFT|JT_CROSS))!=0 ){\n+    if( (pItem->fg.jointype & (JT_LEFT|JT_CROSS))!=0 ){\n@@ -148610,0 +154376,2 @@\n+    }else{\n+      mPrereq = 0;\n@@ -148611,1 +154379,0 @@\n-    priorJointype = pItem->fg.jointype;\n@@ -148614,1 +154381,1 @@\n-      struct SrcList_item *p;\n+      SrcItem *p;\n@@ -148729,1 +154496,3 @@\n-  if( wctrlFlags & WHERE_ORDERBY_LIMIT ) eqOpMask |= WO_IN;\n+  if( wctrlFlags & (WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MAX|WHERE_ORDERBY_MIN) ){\n+    eqOpMask |= WO_IN;\n+  }\n@@ -148756,1 +154525,2 @@\n-      if( pOBExpr->op!=TK_COLUMN ) continue;\n+      if( NEVER(pOBExpr==0) ) continue;\n+      if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) continue;\n@@ -148765,1 +154535,2 @@\n-        assert( wctrlFlags & WHERE_ORDERBY_LIMIT );\n+        assert( wctrlFlags &\n+               (WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX) );\n@@ -148795,0 +154566,4 @@\n+        \/* All relevant terms of the index must also be non-NULL in order\n+        ** for isOrderDistinct to be true.  So the isOrderDistint value\n+        ** computed here might be a false positive.  Corrections will be\n+        ** made at tag-20210426-1 below *\/\n@@ -148862,1 +154637,1 @@\n-        ** WhereLoop is not well-ordered\n+        ** WhereLoop is not well-ordered.  tag-20210426-1\n@@ -148864,6 +154639,10 @@\n-        if( isOrderDistinct\n-         && iColumn>=0\n-         && j>=pLoop->u.btree.nEq\n-         && pIndex->pTable->aCol[iColumn].notNull==0\n-        ){\n-          isOrderDistinct = 0;\n+        if( isOrderDistinct ){\n+          if( iColumn>=0\n+           && j>=pLoop->u.btree.nEq\n+           && pIndex->pTable->aCol[iColumn].notNull==0\n+          ){\n+            isOrderDistinct = 0;\n+          }\n+          if( iColumn==XN_EXPR ){\n+            isOrderDistinct = 0;\n+          }\n@@ -148881,0 +154660,1 @@\n+          if( NEVER(pOBExpr==0) ) continue;\n@@ -148883,1 +154663,1 @@\n-            if( pOBExpr->op!=TK_COLUMN ) continue;\n+            if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) continue;\n@@ -148962,1 +154742,1 @@\n-      Bitmask m = MASKBIT(i) - 1;\n+      Bitmask m = ALWAYS(i<BMS) ? MASKBIT(i) - 1 : 0;\n@@ -149035,1 +154815,2 @@\n-  ** below.  *\/\n+  ** below.\n+  *\/\n@@ -149042,1 +154823,4 @@\n-  ** Use the LIMIT for M if it is smaller *\/\n+  ** Use the LIMIT for M if it is smaller.  Or if this sort is for\n+  ** a DISTINCT operator, M will be the number of distinct output\n+  ** rows, so fudge it downwards a bit.\n+  *\/\n@@ -149045,0 +154829,4 @@\n+  }else if( (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT) ){\n+    \/* TUNING: In the sort for a DISTINCT operator, assume that the DISTINCT\n+    ** reduces the number of output rows by a factor of 2 *\/\n+    if( nRow>10 ){ nRow -= 10;  assert( 10==sqlite3LogEst(2) ); }\n@@ -149413,0 +155201,5 @@\n+      }else if( nLoop\n+            && pWInfo->nOBSat==1\n+            && (pWInfo->wctrlFlags & (WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX))!=0\n+            ){\n+        pWInfo->bOrderedInnerLoop = 1;\n@@ -149451,1 +155244,1 @@\n-  struct SrcList_item *pItem;\n+  SrcItem *pItem;\n@@ -149459,0 +155252,1 @@\n+  WhereScan scan;\n@@ -149472,1 +155266,2 @@\n-  pTerm = sqlite3WhereFindTerm(pWC, iCur, -1, 0, WO_EQ|WO_IS, 0);\n+  pTerm = whereScanInit(&scan, pWC, iCur, -1, WO_EQ|WO_IS, 0);\n+  while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);\n@@ -149491,1 +155286,2 @@\n-        pTerm = sqlite3WhereFindTerm(pWC, iCur, j, 0, opMask, pIdx);\n+        pTerm = whereScanInit(&scan, pWC, iCur, j, opMask, pIdx);\n+        while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);\n@@ -149520,0 +155316,1 @@\n+    if( scan.iEquiv>1 ) pLoop->wsFlags |= WHERE_TRANSCONS;\n@@ -149522,0 +155319,5 @@\n+#endif\n+#ifdef WHERETRACE_ENABLED\n+    if( sqlite3WhereTrace ){\n+      sqlite3DebugPrintf(\"whereShortCut() used to compute solution\\n\");\n+    }\n@@ -149910,1 +155712,1 @@\n-  if( pParse->nErr || NEVER(db->mallocFailed) ){\n+  if( pParse->nErr || db->mallocFailed ){\n@@ -149971,1 +155773,2 @@\n-   && pResultSet!=0               \/* guarantees condition (1) above *\/\n+   && pResultSet!=0                         \/* these two combine to guarantee *\/\n+   && 0==(wctrlFlags & WHERE_AGG_DISTINCT)  \/* condition (1) above *\/\n@@ -149981,1 +155784,1 @@\n-      struct SrcList_item *pItem;\n+      SrcItem *pItem;\n@@ -150071,1 +155874,1 @@\n-    struct SrcList_item *pTabItem;\n+    SrcItem *pTabItem;\n@@ -150077,1 +155880,1 @@\n-    if( (pTab->tabFlags & TF_Ephemeral)!=0 || pTab->pSelect ){\n+    if( (pTab->tabFlags & TF_Ephemeral)!=0 || IsView(pTab) ){\n@@ -150166,0 +155969,1 @@\n+         && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0\n@@ -150201,0 +156005,1 @@\n+    if( pParse->nErr ) goto whereBeginError;\n@@ -150223,0 +156028,1 @@\n+  pWInfo->iEndWhere = sqlite3VdbeCurrentAddr(v);\n@@ -150228,0 +156034,2 @@\n+    testcase( pWInfo->pExprMods!=0 );\n+    whereUndoExprMods(pWInfo);\n@@ -150266,0 +156074,1 @@\n+  int iEnd = sqlite3VdbeCurrentAddr(v);\n@@ -150318,1 +156127,1 @@\n-    if( pLoop->wsFlags & WHERE_IN_ABLE && pLevel->u.in.nIn>0 ){\n+    if( (pLoop->wsFlags & WHERE_IN_ABLE)!=0 && pLevel->u.in.nIn>0 ){\n@@ -150323,0 +156132,2 @@\n+        assert( sqlite3VdbeGetOp(v, pIn->addrInTop+1)->opcode==OP_IsNull\n+                 || pParse->db->mallocFailed );\n@@ -150326,1 +156137,3 @@\n-            assert( pLoop->wsFlags & WHERE_IN_EARLYOUT );\n+            int bEarlyOut =\n+                (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0\n+                 && (pLoop->wsFlags & WHERE_IN_EARLYOUT)!=0;\n@@ -150337,3 +156150,1 @@\n-                  sqlite3VdbeCurrentAddr(v) + 2 +\n-                     ((pLoop->wsFlags & WHERE_VIRTUALTABLE)==0)\n-              );\n+                  sqlite3VdbeCurrentAddr(v) + 2 + bEarlyOut);\n@@ -150342,1 +156153,1 @@\n-            if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0 ){\n+            if( bEarlyOut ){\n@@ -150347,0 +156158,5 @@\n+              \/* Retarget the OP_IsNull against the left operand of IN so\n+              ** it jumps past the OP_IfNoHope.  This is because the\n+              ** OP_IsNull also bypasses the OP_Affinity opcode that is\n+              ** required by OP_IfNoHope. *\/\n+              sqlite3VdbeJumpHere(v, pIn->addrInTop+1);\n@@ -150380,1 +156196,1 @@\n-       || ((ws & WHERE_MULTI_OR) && pLevel->u.pCovidx)\n+       || ((ws & WHERE_MULTI_OR) && pLevel->u.pCoveringIdx)\n@@ -150382,0 +156198,6 @@\n+        if( ws & WHERE_MULTI_OR ){\n+          Index *pIx = pLevel->u.pCoveringIdx;\n+          int iDb = sqlite3SchemaToIndex(db, pIx->pSchema);\n+          sqlite3VdbeAddOp3(v, OP_ReopenIdx, pLevel->iIdxCur, pIx->tnum, iDb);\n+          sqlite3VdbeSetP4KeyInfo(pParse, pIx);\n+        }\n@@ -150403,1 +156225,1 @@\n-    VdbeOp *pOp;\n+    VdbeOp *pOp, *pLastOp;\n@@ -150405,1 +156227,1 @@\n-    struct SrcList_item *pTabItem = &pTabList->a[pLevel->iFrom];\n+    SrcItem *pTabItem = &pTabList->a[pLevel->iFrom];\n@@ -150428,1 +156250,1 @@\n-     && pTab->pSelect==0\n+     && !IsView(pTab)\n@@ -150458,1 +156280,1 @@\n-      pIdx = pLevel->u.pCovidx;\n+      pIdx = pLevel->u.pCoveringIdx;\n@@ -150461,1 +156283,0 @@\n-     && (pWInfo->eOnePass==ONEPASS_OFF || !HasRowid(pIdx->pTable))\n@@ -150464,2 +156285,6 @@\n-      last = sqlite3VdbeCurrentAddr(v);\n-      k = pLevel->addrBody;\n+      if( pWInfo->eOnePass==ONEPASS_OFF || !HasRowid(pIdx->pTable) ){\n+        last = iEnd;\n+      }else{\n+        last = pWInfo->iEndWhere;\n+      }\n+      k = pLevel->addrBody + 1;\n@@ -150470,0 +156295,5 @@\n+      \/* Proof that the \"+1\" on the k value above is safe *\/\n+      pOp = sqlite3VdbeGetOp(v, k - 1);\n+      assert( pOp->opcode!=OP_Column || pOp->p1!=pLevel->iTabCur );\n+      assert( pOp->opcode!=OP_Rowid  || pOp->p1!=pLevel->iTabCur );\n+      assert( pOp->opcode!=OP_IfNullRow || pOp->p1!=pLevel->iTabCur );\n@@ -150472,3 +156302,6 @@\n-      for(; k<last; k++, pOp++){\n-        if( pOp->p1!=pLevel->iTabCur ) continue;\n-        if( pOp->opcode==OP_Column\n+      pLastOp = pOp + (last - k);\n+      assert( pOp<=pLastOp );\n+      do{\n+        if( pOp->p1!=pLevel->iTabCur ){\n+          \/* no-op *\/\n+        }else if( pOp->opcode==OP_Column\n@@ -150505,1 +156338,4 @@\n-      }\n+#ifdef SQLITE_DEBUG\n+        k++;\n+#endif\n+      }while( (++pOp)<pLastOp );\n@@ -150512,8 +156348,0 @@\n-  \/* Undo all Expr node modifications *\/\n-  while( pWInfo->pExprMods ){\n-    WhereExprMod *p = pWInfo->pExprMods;\n-    pWInfo->pExprMods = p->pNext;\n-    memcpy(p->pExpr, &p->orig, sizeof(p->orig));\n-    sqlite3DbFree(db, p);\n-  }\n-\n@@ -150522,0 +156350,1 @@\n+  if( pWInfo->pExprMods ) whereUndoExprMods(pWInfo);\n@@ -151112,1 +156941,1 @@\n-  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n+  nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  \\\n@@ -151120,1 +156949,1 @@\n-  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n+  nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  \\\n@@ -151129,1 +156958,1 @@\n-  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \\\n+  nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  \\\n@@ -151314,1 +157143,1 @@\n-      \/* Fall through.  *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -151319,0 +157148,1 @@\n+      if( pParse->db->mallocFailed ) return WRC_Abort;\n@@ -151334,0 +157164,1 @@\n+        int f = pExpr->flags & EP_Collate;\n@@ -151344,0 +157175,1 @@\n+        pExpr->flags = f;\n@@ -151426,1 +157258,2 @@\n-      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);\n+      sqlite3 *db = pParse->db;\n+      Expr *pDup = sqlite3ExprDup(db, pAppend->a[i].pExpr, 0);\n@@ -151428,1 +157261,5 @@\n-      if( bIntToNull && pDup ){\n+      if( db->mallocFailed ){\n+        sqlite3ExprDelete(db, pDup);\n+        break;\n+      }\n+      if( bIntToNull ){\n@@ -151431,3 +157268,1 @@\n-        for(pSub=pDup; ExprHasProperty(pSub, EP_Skip); pSub=pSub->pLeft){\n-          assert( pSub );\n-        }\n+        pSub = sqlite3ExprSkipCollateAndLikely(pDup);\n@@ -151464,0 +157299,9 @@\n+static int disallowAggregatesInOrderByCb(Walker *pWalker, Expr *pExpr){\n+  if( pExpr->op==TK_AGG_FUNCTION && pExpr->pAggInfo==0 ){\n+    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+     sqlite3ErrorMsg(pWalker->pParse,\n+         \"misuse of aggregate: %s()\", pExpr->u.zToken);\n+  }\n+  return WRC_Continue;\n+}\n+\n@@ -151473,1 +157317,1 @@\n-  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n+  if( p->pWin && p->pPrior==0 && ALWAYS((p->selFlags & SF_WinRewrite)==0) ){\n@@ -151484,1 +157328,1 @@\n-    Window *pMWin = p->pWin;      \/* Master window object *\/\n+    Window *pMWin = p->pWin;      \/* Main window object *\/\n@@ -151497,0 +157341,5 @@\n+    if( (p->selFlags & SF_Aggregate)==0 ){\n+      w.xExprCallback = disallowAggregatesInOrderByCb;\n+      w.xSelectCallback = 0;\n+      sqlite3WalkExprList(&w, p->pOrderBy);\n+    }\n@@ -151541,1 +157390,3 @@\n-      ExprList *pArgs = pWin->pOwner->x.pList;\n+      ExprList *pArgs;\n+      assert( ExprUseXList(pWin->pOwner) );\n+      pArgs = pWin->pOwner->x.pList;\n@@ -151574,0 +157425,3 @@\n+    SELECTTRACE(1,pParse,pSub,\n+       (\"New window-function subquery in FROM clause of (%u\/%p)\\n\",\n+       p->selId, p));\n@@ -151575,0 +157429,3 @@\n+    assert( pSub!=0 || p->pSrc==0 ); \/* Due to db->mallocFailed test inside\n+                                     ** of sqlite3DbMallocRawNN() called from\n+                                     ** sqlite3SrcListAppend() *\/\n@@ -151579,1 +157436,1 @@\n-      pSub->selFlags |= SF_Expanded;\n+      pSub->selFlags |= SF_Expanded|SF_OrderByReqd;\n@@ -151602,1 +157459,5 @@\n-    sqlite3DbFree(db, pTab);\n+\n+    \/* Defer deleting the temporary table pTab because if an error occurred,\n+    ** there could still be references to that table embedded in the\n+    ** result-set or ORDER BY clause of the SELECT statement p.  *\/\n+    sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pTab);\n@@ -151610,1 +157471,0 @@\n-    sqlite3SelectReset(pParse, p);\n@@ -151831,6 +157691,12 @@\n-  if( pSel!=0\n-   && (0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0))\n-  ){\n-    pWin->pNextWin = pSel->pWin;\n-    if( pSel->pWin ){\n-      pSel->pWin->ppThis = &pWin->pNextWin;\n+  if( pSel ){\n+    if( 0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0) ){\n+      pWin->pNextWin = pSel->pWin;\n+      if( pSel->pWin ){\n+        pSel->pWin->ppThis = &pWin->pNextWin;\n+      }\n+      pSel->pWin = pWin;\n+      pWin->ppThis = &pSel->pWin;\n+    }else{\n+      if( sqlite3ExprListCompare(pWin->pPartition, pSel->pWin->pPartition,-1) ){\n+        pSel->selFlags |= SF_MultiPart;\n+      }\n@@ -151838,2 +157704,0 @@\n-    pSel->pWin = pWin;\n-    pWin->ppThis = &pSel->pWin;\n@@ -151848,1 +157712,6 @@\n-SQLITE_PRIVATE int sqlite3WindowCompare(Parse *pParse, Window *p1, Window *p2, int bFilter){\n+SQLITE_PRIVATE int sqlite3WindowCompare(\n+  const Parse *pParse,\n+  const Window *p1,\n+  const Window *p2,\n+  int bFilter\n+){\n@@ -151920,2 +157789,5 @@\n-      ExprList *pList = pWin->pOwner->x.pList;\n-      KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);\n+      ExprList *pList;\n+      KeyInfo *pKeyInfo;\n+      assert( ExprUseXList(pWin->pOwner) );\n+      pList = pWin->pOwner->x.pList;\n+      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);\n@@ -151992,0 +157864,1 @@\n+  sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC);\n@@ -152008,1 +157881,3 @@\n-  ExprList *pList = pWin->pOwner->x.pList;\n+  const ExprList *pList;\n+  assert( ExprUseXList(pWin->pOwner) );\n+  pList = pWin->pOwner->x.pList;\n@@ -152086,0 +157961,1 @@\n+  int regRowid;\n@@ -152192,0 +158068,1 @@\n+        assert( ExprUseXList(pWin->pOwner) );\n@@ -152202,2 +158079,2 @@\n-        int iStart = sqlite3VdbeCurrentAddr(v);\n-        VdbeOp *pOp, *pEnd;\n+        int iOp = sqlite3VdbeCurrentAddr(v);\n+        int iEnd;\n@@ -152205,0 +158082,1 @@\n+        assert( ExprUseXList(pWin->pOwner) );\n@@ -152209,2 +158087,2 @@\n-        pEnd = sqlite3VdbeGetOp(v, -1);\n-        for(pOp=sqlite3VdbeGetOp(v, iStart); pOp<=pEnd; pOp++){\n+        for(iEnd=sqlite3VdbeCurrentAddr(v); iOp<iEnd; iOp++){\n+          VdbeOp *pOp = sqlite3VdbeGetOp(v, iOp);\n@@ -152219,0 +158097,1 @@\n+        assert( ExprUseXList(pWin->pOwner) );\n@@ -152404,0 +158283,1 @@\n+      assert( ExprUseXList(pWin->pOwner) );\n@@ -152569,1 +158449,1 @@\n-** a numeric type (real or integer), then the result of the addition addition\n+** a numeric type (real or integer), then the result of the addition\n@@ -152588,0 +158468,6 @@\n+  int addrDone = sqlite3VdbeMakeLabel(pParse);   \/* Address past OP_Ge *\/\n+  CollSeq *pColl;\n+\n+  \/* Read the peer-value from each cursor into a register *\/\n+  windowReadPeerValues(p, csr1, reg1);\n+  windowReadPeerValues(p, csr2, reg2);\n@@ -152600,4 +158486,0 @@\n-  \/* Read the peer-value from each cursor into a register *\/\n-  windowReadPeerValues(p, csr1, reg1);\n-  windowReadPeerValues(p, csr2, reg2);\n-\n@@ -152609,19 +158491,0 @@\n-  \/* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).\n-  ** This block adds (or subtracts for DESC) the numeric value in regVal\n-  ** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),\n-  ** then leave reg1 as it is. In pseudo-code, this is implemented as:\n-  **\n-  **   if( reg1>='' ) goto addrGe;\n-  **   reg1 = reg1 +\/- regVal\n-  **   addrGe:\n-  **\n-  ** Since all strings and blobs are greater-than-or-equal-to an empty string,\n-  ** the add\/subtract is skipped for these, as required. If reg1 is a NULL,\n-  ** then the arithmetic is performed, but since adding or subtracting from\n-  ** NULL is always NULL anyway, this case is handled as required too.  *\/\n-  sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, \"\", P4_STATIC);\n-  addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);\n-  VdbeCoverage(v);\n-  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);\n-  sqlite3VdbeJumpHere(v, addrGe);\n-\n@@ -152664,1 +158527,1 @@\n-    sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+3);\n+    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);\n@@ -152670,1 +158533,1 @@\n-      sqlite3VdbeChangeP2(v, -1, sqlite3VdbeCurrentAddr(v)+1);\n+      sqlite3VdbeChangeP2(v, -1, addrDone);\n@@ -152674,0 +158537,22 @@\n+  \/* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).\n+  ** This block adds (or subtracts for DESC) the numeric value in regVal\n+  ** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),\n+  ** then leave reg1 as it is. In pseudo-code, this is implemented as:\n+  **\n+  **   if( reg1>='' ) goto addrGe;\n+  **   reg1 = reg1 +\/- regVal\n+  **   addrGe:\n+  **\n+  ** Since all strings and blobs are greater-than-or-equal-to an empty string,\n+  ** the add\/subtract is skipped for these, as required. If reg1 is a NULL,\n+  ** then the arithmetic is performed, but since adding or subtracting from\n+  ** NULL is always NULL anyway, this case is handled as required too.  *\/\n+  sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, \"\", P4_STATIC);\n+  addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);\n+  VdbeCoverage(v);\n+  if( (op==OP_Ge && arith==OP_Add) || (op==OP_Le && arith==OP_Subtract) ){\n+    sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);\n+  }\n+  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);\n+  sqlite3VdbeJumpHere(v, addrGe);\n+\n@@ -152678,0 +158563,2 @@\n+  pColl = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[0].pExpr);\n+  sqlite3VdbeAppendP4(v, (void*)pColl, P4_COLLSEQ);\n@@ -152679,0 +158566,1 @@\n+  sqlite3VdbeResolveLabel(v, addrDone);\n@@ -152754,1 +158642,3 @@\n-  ** temporary table. It otherwise might, if (a>b).  *\/\n+  ** temporary table. It otherwise might, if (a>b). Also ensure that,\n+  ** if the input cursor is still finding new rows, that the end\n+  ** cursor does not go past it to EOF. *\/\n@@ -152756,1 +158646,1 @@\n-   && pMWin->eFrmType==TK_RANGE && op==WINDOW_AGGINVERSE\n+   && pMWin->eFrmType==TK_RANGE\n@@ -152760,4 +158650,10 @@\n-    sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);\n-    sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);\n-    sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);\n-    VdbeCoverage(v);\n+    if( op==WINDOW_AGGINVERSE ){\n+      sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);\n+      sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);\n+      sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);\n+      VdbeCoverage(v);\n+    }else if( p->regRowid ){\n+      sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid1);\n+      sqlite3VdbeAddOp3(v, OP_Ge, p->regRowid, lblDone, regRowid1);\n+      VdbeCoverageNeverNull(v);\n+    }\n@@ -153260,1 +159156,0 @@\n-  int regRowid;                   \/* Rowid for regRecord in eph table *\/\n@@ -153332,1 +159227,1 @@\n-  regRowid = ++pParse->nMem;\n+  s.regRowid = ++pParse->nMem;\n@@ -153388,3 +159283,3 @@\n-  sqlite3VdbeAddOp2(v, OP_NewRowid, csrWrite, regRowid);\n-  sqlite3VdbeAddOp3(v, OP_Insert, csrWrite, regRecord, regRowid);\n-  addrNe = sqlite3VdbeAddOp3(v, OP_Ne, pMWin->regOne, 0, regRowid);\n+  sqlite3VdbeAddOp2(v, OP_NewRowid, csrWrite, s.regRowid);\n+  sqlite3VdbeAddOp3(v, OP_Insert, csrWrite, regRecord, s.regRowid);\n+  addrNe = sqlite3VdbeAddOp3(v, OP_Ne, pMWin->regOne, 0, s.regRowid);\n@@ -153508,0 +159403,1 @@\n+  s.regRowid = 0;\n@@ -153570,0 +159466,2 @@\n+\/* This file is automatically generated by Lemon from input grammar\n+** source file \"parse.y\". *\/\n@@ -153571,1 +159469,1 @@\n-** 2000-05-29\n+** 2001-09-15\n@@ -153581,1 +159479,1 @@\n-** Driver template for the LEMON parser generator.\n+** This file contains SQLite's SQL parser.\n@@ -153583,10 +159481,6 @@\n-** The \"lemon\" program processes an LALR(1) input grammar file, then uses\n-** this template to construct a parser.  The \"lemon\" program inserts text\n-** at each \"%%\" line.  Also, any \"P-a-r-s-e\" identifer prefix (without the\n-** interstitial \"-\" characters) contained in this template is changed into\n-** the value of the %name directive from the grammar.  Otherwise, the content\n-** of this template is copied straight through into the generate parser\n-** source file.\n-**\n-** The following is the concatenation of all %include directives from the\n-** input grammar file:\n+** The canonical source code to this file (\"parse.y\") is a Lemon grammar\n+** file that specifies the input grammar and actions to take while parsing.\n+** That input file is processed by Lemon to generate a C-language\n+** implementation of a parser for the given grammer.  You might be reading\n+** this comment as part of the translated C-code.  Edits should be made\n+** to the original parse.y sources.\n@@ -153594,3 +159488,0 @@\n-\/* #include <stdio.h> *\/\n-\/* #include <assert.h> *\/\n-\/************ Begin %include sections from the grammar ************************\/\n@@ -153659,0 +159550,21 @@\n+#if !defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) \\\n+ && defined(SQLITE_UDL_CAPABLE_PARSER)\n+\/*\n+** Issue an error message if an ORDER BY or LIMIT clause occurs on an\n+** UPDATE or DELETE statement.\n+*\/\n+static void updateDeleteLimitError(\n+  Parse *pParse,\n+  ExprList *pOrderBy,\n+  Expr *pLimit\n+){\n+  if( pOrderBy ){\n+    sqlite3ErrorMsg(pParse, \"syntax error near \\\"ORDER BY\\\"\");\n+  }else{\n+    sqlite3ErrorMsg(pParse, \"syntax error near \\\"LIMIT\\\"\");\n+  }\n+  sqlite3ExprListDelete(pParse->db, pOrderBy);\n+  sqlite3ExprDelete(pParse->db, pLimit);\n+}\n+#endif \/* SQLITE_ENABLE_UPDATE_DELETE_LIMIT *\/\n+\n@@ -153668,3 +159580,3 @@\n-      Select *pNext = 0, *pLoop;\n-      int mxSelect, cnt = 0;\n-      for(pLoop=p; pLoop; pNext=pLoop, pLoop=pLoop->pPrior, cnt++){\n+      Select *pNext = 0, *pLoop = p;\n+      int mxSelect, cnt = 1;\n+      while(1){\n@@ -153673,0 +159585,10 @@\n+        pNext = pLoop;\n+        pLoop = pLoop->pPrior;\n+        if( pLoop==0 ) break;\n+        cnt++;\n+        if( pLoop->pOrderBy || pLoop->pLimit ){\n+          sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n+             pLoop->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\",\n+             sqlite3SelectOpName(pNext->op));\n+          break;\n+        }\n@@ -153683,0 +159605,13 @@\n+  \/* Attach a With object describing the WITH clause to a Select\n+  ** object describing the query for which the WITH clause is a prefix.\n+  *\/\n+  static Select *attachWithToSelect(Parse *pParse, Select *pSelect, With *pWith){\n+    if( pSelect ){\n+      pSelect->pWith = pWith;\n+      parserDoubleLinkSelect(pParse, pSelect);\n+    }else{\n+      sqlite3WithDelete(pParse->db, pWith);\n+    }\n+    return pSelect;\n+  }\n+\n@@ -153698,1 +159633,0 @@\n-      p->x.pList = 0;\n@@ -153700,1 +159634,2 @@\n-      p->y.pTab = 0;\n+      memset(&p->x, 0, sizeof(p->x));\n+      memset(&p->y, 0, sizeof(p->y));\n@@ -153759,5 +159694,188 @@\n-\/* These constants specify the various numeric values for terminal symbols\n-** in a format understandable to \"makeheaders\".  This section is blank unless\n-** \"lemon\" is run with the \"-m\" command-line option.\n-***************** Begin makeheaders token definitions *************************\/\n-\/**************** End makeheaders token definitions ***************************\/\n+\/* These constants specify the various numeric values for terminal symbols.\n+***************** Begin token definitions *************************************\/\n+#ifndef TK_SEMI\n+#define TK_SEMI                            1\n+#define TK_EXPLAIN                         2\n+#define TK_QUERY                           3\n+#define TK_PLAN                            4\n+#define TK_BEGIN                           5\n+#define TK_TRANSACTION                     6\n+#define TK_DEFERRED                        7\n+#define TK_IMMEDIATE                       8\n+#define TK_EXCLUSIVE                       9\n+#define TK_COMMIT                         10\n+#define TK_END                            11\n+#define TK_ROLLBACK                       12\n+#define TK_SAVEPOINT                      13\n+#define TK_RELEASE                        14\n+#define TK_TO                             15\n+#define TK_TABLE                          16\n+#define TK_CREATE                         17\n+#define TK_IF                             18\n+#define TK_NOT                            19\n+#define TK_EXISTS                         20\n+#define TK_TEMP                           21\n+#define TK_LP                             22\n+#define TK_RP                             23\n+#define TK_AS                             24\n+#define TK_COMMA                          25\n+#define TK_WITHOUT                        26\n+#define TK_ABORT                          27\n+#define TK_ACTION                         28\n+#define TK_AFTER                          29\n+#define TK_ANALYZE                        30\n+#define TK_ASC                            31\n+#define TK_ATTACH                         32\n+#define TK_BEFORE                         33\n+#define TK_BY                             34\n+#define TK_CASCADE                        35\n+#define TK_CAST                           36\n+#define TK_CONFLICT                       37\n+#define TK_DATABASE                       38\n+#define TK_DESC                           39\n+#define TK_DETACH                         40\n+#define TK_EACH                           41\n+#define TK_FAIL                           42\n+#define TK_OR                             43\n+#define TK_AND                            44\n+#define TK_IS                             45\n+#define TK_MATCH                          46\n+#define TK_LIKE_KW                        47\n+#define TK_BETWEEN                        48\n+#define TK_IN                             49\n+#define TK_ISNULL                         50\n+#define TK_NOTNULL                        51\n+#define TK_NE                             52\n+#define TK_EQ                             53\n+#define TK_GT                             54\n+#define TK_LE                             55\n+#define TK_LT                             56\n+#define TK_GE                             57\n+#define TK_ESCAPE                         58\n+#define TK_ID                             59\n+#define TK_COLUMNKW                       60\n+#define TK_DO                             61\n+#define TK_FOR                            62\n+#define TK_IGNORE                         63\n+#define TK_INITIALLY                      64\n+#define TK_INSTEAD                        65\n+#define TK_NO                             66\n+#define TK_KEY                            67\n+#define TK_OF                             68\n+#define TK_OFFSET                         69\n+#define TK_PRAGMA                         70\n+#define TK_RAISE                          71\n+#define TK_RECURSIVE                      72\n+#define TK_REPLACE                        73\n+#define TK_RESTRICT                       74\n+#define TK_ROW                            75\n+#define TK_ROWS                           76\n+#define TK_TRIGGER                        77\n+#define TK_VACUUM                         78\n+#define TK_VIEW                           79\n+#define TK_VIRTUAL                        80\n+#define TK_WITH                           81\n+#define TK_NULLS                          82\n+#define TK_FIRST                          83\n+#define TK_LAST                           84\n+#define TK_CURRENT                        85\n+#define TK_FOLLOWING                      86\n+#define TK_PARTITION                      87\n+#define TK_PRECEDING                      88\n+#define TK_RANGE                          89\n+#define TK_UNBOUNDED                      90\n+#define TK_EXCLUDE                        91\n+#define TK_GROUPS                         92\n+#define TK_OTHERS                         93\n+#define TK_TIES                           94\n+#define TK_GENERATED                      95\n+#define TK_ALWAYS                         96\n+#define TK_MATERIALIZED                   97\n+#define TK_REINDEX                        98\n+#define TK_RENAME                         99\n+#define TK_CTIME_KW                       100\n+#define TK_ANY                            101\n+#define TK_BITAND                         102\n+#define TK_BITOR                          103\n+#define TK_LSHIFT                         104\n+#define TK_RSHIFT                         105\n+#define TK_PLUS                           106\n+#define TK_MINUS                          107\n+#define TK_STAR                           108\n+#define TK_SLASH                          109\n+#define TK_REM                            110\n+#define TK_CONCAT                         111\n+#define TK_COLLATE                        112\n+#define TK_BITNOT                         113\n+#define TK_ON                             114\n+#define TK_INDEXED                        115\n+#define TK_STRING                         116\n+#define TK_JOIN_KW                        117\n+#define TK_CONSTRAINT                     118\n+#define TK_DEFAULT                        119\n+#define TK_NULL                           120\n+#define TK_PRIMARY                        121\n+#define TK_UNIQUE                         122\n+#define TK_CHECK                          123\n+#define TK_REFERENCES                     124\n+#define TK_AUTOINCR                       125\n+#define TK_INSERT                         126\n+#define TK_DELETE                         127\n+#define TK_UPDATE                         128\n+#define TK_SET                            129\n+#define TK_DEFERRABLE                     130\n+#define TK_FOREIGN                        131\n+#define TK_DROP                           132\n+#define TK_UNION                          133\n+#define TK_ALL                            134\n+#define TK_EXCEPT                         135\n+#define TK_INTERSECT                      136\n+#define TK_SELECT                         137\n+#define TK_VALUES                         138\n+#define TK_DISTINCT                       139\n+#define TK_DOT                            140\n+#define TK_FROM                           141\n+#define TK_JOIN                           142\n+#define TK_USING                          143\n+#define TK_ORDER                          144\n+#define TK_GROUP                          145\n+#define TK_HAVING                         146\n+#define TK_LIMIT                          147\n+#define TK_WHERE                          148\n+#define TK_RETURNING                      149\n+#define TK_INTO                           150\n+#define TK_NOTHING                        151\n+#define TK_FLOAT                          152\n+#define TK_BLOB                           153\n+#define TK_INTEGER                        154\n+#define TK_VARIABLE                       155\n+#define TK_CASE                           156\n+#define TK_WHEN                           157\n+#define TK_THEN                           158\n+#define TK_ELSE                           159\n+#define TK_INDEX                          160\n+#define TK_ALTER                          161\n+#define TK_ADD                            162\n+#define TK_WINDOW                         163\n+#define TK_OVER                           164\n+#define TK_FILTER                         165\n+#define TK_COLUMN                         166\n+#define TK_AGG_FUNCTION                   167\n+#define TK_AGG_COLUMN                     168\n+#define TK_TRUEFALSE                      169\n+#define TK_ISNOT                          170\n+#define TK_FUNCTION                       171\n+#define TK_UMINUS                         172\n+#define TK_UPLUS                          173\n+#define TK_TRUTH                          174\n+#define TK_REGISTER                       175\n+#define TK_VECTOR                         176\n+#define TK_SELECT_COLUMN                  177\n+#define TK_IF_NULL_ROW                    178\n+#define TK_ASTERISK                       179\n+#define TK_SPAN                           180\n+#define TK_ERROR                          181\n+#define TK_SPACE                          182\n+#define TK_ILLEGAL                        183\n+#endif\n+\/**************** End token definitions ***************************************\/\n@@ -153821,1 +159939,1 @@\n-#define YYNOCODE 310\n+#define YYNOCODE 318\n@@ -153823,1 +159941,1 @@\n-#define YYWILDCARD 100\n+#define YYWILDCARD 101\n@@ -153828,15 +159946,17 @@\n-  SrcList* yy47;\n-  u8 yy58;\n-  struct FrameBound yy77;\n-  With* yy131;\n-  int yy192;\n-  Expr* yy202;\n-  struct {int value; int mask;} yy207;\n-  struct TrigEvent yy230;\n-  ExprList* yy242;\n-  Window* yy303;\n-  Upsert* yy318;\n-  const char* yy436;\n-  TriggerStep* yy447;\n-  Select* yy539;\n-  IdList* yy600;\n+  With* yy43;\n+  u32 yy51;\n+  int yy64;\n+  struct FrameBound yy81;\n+  struct {int value; int mask;} yy83;\n+  TriggerStep* yy95;\n+  Upsert* yy138;\n+  IdList* yy240;\n+  Cte* yy255;\n+  Select* yy303;\n+  Window* yy375;\n+  u8 yy534;\n+  ExprList* yy562;\n+  struct TrigEvent yy570;\n+  const char* yy600;\n+  SrcList* yy607;\n+  Expr* yy626;\n@@ -153858,12 +159978,12 @@\n-#define YYNSTATE             551\n-#define YYNRULE              385\n-#define YYNRULE_WITH_ACTION  325\n-#define YYNTOKEN             181\n-#define YY_MAX_SHIFT         550\n-#define YY_MIN_SHIFTREDUCE   801\n-#define YY_MAX_SHIFTREDUCE   1185\n-#define YY_ERROR_ACTION      1186\n-#define YY_ACCEPT_ACTION     1187\n-#define YY_NO_ACTION         1188\n-#define YY_MIN_REDUCE        1189\n-#define YY_MAX_REDUCE        1573\n+#define YYNSTATE             572\n+#define YYNRULE              401\n+#define YYNRULE_WITH_ACTION  339\n+#define YYNTOKEN             184\n+#define YY_MAX_SHIFT         571\n+#define YY_MIN_SHIFTREDUCE   829\n+#define YY_MAX_SHIFTREDUCE   1229\n+#define YY_ERROR_ACTION      1230\n+#define YY_ACCEPT_ACTION     1231\n+#define YY_NO_ACTION         1232\n+#define YY_MIN_REDUCE        1233\n+#define YY_MAX_REDUCE        1633\n@@ -153936,1 +160056,1 @@\n-#define YY_ACTTAB_COUNT (1958)\n+#define YY_ACTTAB_COUNT (2037)\n@@ -153938,196 +160058,204 @@\n- \/*     0 *\/   544, 1220,  544,  449, 1258,  544, 1237,  544,  114,  111,\n- \/*    10 *\/   211,  544, 1535,  544, 1258,  521,  114,  111,  211,  390,\n- \/*    20 *\/  1230,  342,   42,   42,   42,   42, 1223,   42,   42,   71,\n- \/*    30 *\/    71,  935, 1222,   71,   71,   71,   71, 1460, 1491,  936,\n- \/*    40 *\/   818,  451,    6,  121,  122,  112, 1163, 1163, 1004, 1007,\n- \/*    50 *\/   997,  997,  119,  119,  120,  120,  120,  120, 1541,  390,\n- \/*    60 *\/  1356, 1515,  550,    2, 1191,  194,  526,  434,  143,  291,\n- \/*    70 *\/   526,  136,  526,  369,  261,  502,  272,  383, 1271,  525,\n- \/*    80 *\/   501,  491,  164,  121,  122,  112, 1163, 1163, 1004, 1007,\n- \/*    90 *\/   997,  997,  119,  119,  120,  120,  120,  120, 1356,  440,\n- \/*   100 *\/  1512,  118,  118,  118,  118,  117,  117,  116,  116,  116,\n- \/*   110 *\/   115,  422,  266,  266,  266,  266, 1496,  356, 1498,  433,\n- \/*   120 *\/   355, 1496,  515,  522, 1483,  541, 1112,  541, 1112,  390,\n- \/*   130 *\/   403,  241,  208,  114,  111,  211,   98,  290,  535,  221,\n- \/*   140 *\/  1027,  118,  118,  118,  118,  117,  117,  116,  116,  116,\n- \/*   150 *\/   115,  422, 1140,  121,  122,  112, 1163, 1163, 1004, 1007,\n- \/*   160 *\/   997,  997,  119,  119,  120,  120,  120,  120,  404,  426,\n- \/*   170 *\/   117,  117,  116,  116,  116,  115,  422, 1416,  466,  123,\n- \/*   180 *\/   118,  118,  118,  118,  117,  117,  116,  116,  116,  115,\n- \/*   190 *\/   422,  116,  116,  116,  115,  422,  538,  538,  538,  390,\n- \/*   200 *\/   503,  120,  120,  120,  120,  113, 1049, 1140, 1141, 1142,\n- \/*   210 *\/  1049,  118,  118,  118,  118,  117,  117,  116,  116,  116,\n- \/*   220 *\/   115,  422, 1459,  121,  122,  112, 1163, 1163, 1004, 1007,\n- \/*   230 *\/   997,  997,  119,  119,  120,  120,  120,  120,  390,  442,\n- \/*   240 *\/   314,   83,  461,   81,  357,  380, 1140,   80,  118,  118,\n- \/*   250 *\/   118,  118,  117,  117,  116,  116,  116,  115,  422,  179,\n- \/*   260 *\/   432,  422,  121,  122,  112, 1163, 1163, 1004, 1007,  997,\n- \/*   270 *\/   997,  119,  119,  120,  120,  120,  120,  432,  431,  266,\n- \/*   280 *\/   266,  118,  118,  118,  118,  117,  117,  116,  116,  116,\n- \/*   290 *\/   115,  422,  541, 1107,  901,  504, 1140,  114,  111,  211,\n- \/*   300 *\/  1429, 1140, 1141, 1142,  206,  489, 1107,  390,  447, 1107,\n- \/*   310 *\/   543,  328,  120,  120,  120,  120,  298, 1429, 1431,   17,\n- \/*   320 *\/   118,  118,  118,  118,  117,  117,  116,  116,  116,  115,\n- \/*   330 *\/   422,  121,  122,  112, 1163, 1163, 1004, 1007,  997,  997,\n- \/*   340 *\/   119,  119,  120,  120,  120,  120,  390, 1356,  432, 1140,\n- \/*   350 *\/   480, 1140, 1141, 1142,  994,  994, 1005, 1008,  443,  118,\n- \/*   360 *\/   118,  118,  118,  117,  117,  116,  116,  116,  115,  422,\n- \/*   370 *\/   121,  122,  112, 1163, 1163, 1004, 1007,  997,  997,  119,\n- \/*   380 *\/   119,  120,  120,  120,  120, 1052, 1052,  463, 1429,  118,\n- \/*   390 *\/   118,  118,  118,  117,  117,  116,  116,  116,  115,  422,\n- \/*   400 *\/  1140,  449,  544, 1424, 1140, 1141, 1142,  233,  964, 1140,\n- \/*   410 *\/   479,  476,  475,  171,  358,  390,  164,  405,  412,  840,\n- \/*   420 *\/   474,  164,  185,  332,   71,   71, 1241,  998,  118,  118,\n- \/*   430 *\/   118,  118,  117,  117,  116,  116,  116,  115,  422,  121,\n- \/*   440 *\/   122,  112, 1163, 1163, 1004, 1007,  997,  997,  119,  119,\n- \/*   450 *\/   120,  120,  120,  120,  390, 1140, 1141, 1142,  833,   12,\n- \/*   460 *\/   313,  507,  163,  354, 1140, 1141, 1142,  114,  111,  211,\n- \/*   470 *\/   506,  290,  535,  544,  276,  180,  290,  535,  121,  122,\n- \/*   480 *\/   112, 1163, 1163, 1004, 1007,  997,  997,  119,  119,  120,\n- \/*   490 *\/   120,  120,  120,  343,  482,   71,   71,  118,  118,  118,\n- \/*   500 *\/   118,  117,  117,  116,  116,  116,  115,  422, 1140,  209,\n- \/*   510 *\/   409,  521, 1140, 1107, 1569,  376,  252,  269,  340,  485,\n- \/*   520 *\/   335,  484,  238,  390,  511,  362, 1107, 1125,  331, 1107,\n- \/*   530 *\/   191,  407,  286,   32,  455,  441,  118,  118,  118,  118,\n- \/*   540 *\/   117,  117,  116,  116,  116,  115,  422,  121,  122,  112,\n- \/*   550 *\/  1163, 1163, 1004, 1007,  997,  997,  119,  119,  120,  120,\n- \/*   560 *\/   120,  120,  390, 1140, 1141, 1142,  985, 1140, 1141, 1142,\n- \/*   570 *\/  1140,  233,  490, 1490,  479,  476,  475,    6,  163,  544,\n- \/*   580 *\/   510,  544,  115,  422,  474,    5,  121,  122,  112, 1163,\n- \/*   590 *\/  1163, 1004, 1007,  997,  997,  119,  119,  120,  120,  120,\n- \/*   600 *\/   120,   13,   13,   13,   13,  118,  118,  118,  118,  117,\n- \/*   610 *\/   117,  116,  116,  116,  115,  422,  401,  500,  406,  544,\n- \/*   620 *\/  1484,  542, 1140,  890,  890, 1140, 1141, 1142, 1471, 1140,\n- \/*   630 *\/   275,  390,  806,  807,  808,  969,  420,  420,  420,   16,\n- \/*   640 *\/    16,   55,   55, 1240,  118,  118,  118,  118,  117,  117,\n- \/*   650 *\/   116,  116,  116,  115,  422,  121,  122,  112, 1163, 1163,\n- \/*   660 *\/  1004, 1007,  997,  997,  119,  119,  120,  120,  120,  120,\n- \/*   670 *\/   390, 1187,    1,    1,  550,    2, 1191, 1140, 1141, 1142,\n- \/*   680 *\/   194,  291,  896,  136, 1140, 1141, 1142,  895,  519, 1490,\n- \/*   690 *\/  1271,    3,  378,    6,  121,  122,  112, 1163, 1163, 1004,\n- \/*   700 *\/  1007,  997,  997,  119,  119,  120,  120,  120,  120,  856,\n- \/*   710 *\/   544,  922,  544,  118,  118,  118,  118,  117,  117,  116,\n- \/*   720 *\/   116,  116,  115,  422,  266,  266, 1090, 1567, 1140,  549,\n- \/*   730 *\/  1567, 1191,   13,   13,   13,   13,  291,  541,  136,  390,\n- \/*   740 *\/   483,  419,  418,  964,  342, 1271,  466,  408,  857,  279,\n- \/*   750 *\/   140,  221,  118,  118,  118,  118,  117,  117,  116,  116,\n- \/*   760 *\/   116,  115,  422,  121,  122,  112, 1163, 1163, 1004, 1007,\n- \/*   770 *\/   997,  997,  119,  119,  120,  120,  120,  120,  544,  266,\n- \/*   780 *\/   266,  426,  390, 1140, 1141, 1142, 1170,  828, 1170,  466,\n- \/*   790 *\/   429,  145,  541, 1144,  399,  313,  437,  301,  836, 1488,\n- \/*   800 *\/    71,   71,  410,    6, 1088,  471,  221,  100,  112, 1163,\n- \/*   810 *\/  1163, 1004, 1007,  997,  997,  119,  119,  120,  120,  120,\n- \/*   820 *\/   120,  118,  118,  118,  118,  117,  117,  116,  116,  116,\n- \/*   830 *\/   115,  422,  237, 1423,  544,  449,  426,  287,  984,  544,\n- \/*   840 *\/   236,  235,  234,  828,   97,  527,  427, 1263, 1263, 1144,\n- \/*   850 *\/   492,  306,  428,  836,  975,  544,   71,   71,  974, 1239,\n- \/*   860 *\/   544,   51,   51,  300,  118,  118,  118,  118,  117,  117,\n- \/*   870 *\/   116,  116,  116,  115,  422,  194,  103,   70,   70,  266,\n- \/*   880 *\/   266,  544,   71,   71,  266,  266,   30,  389,  342,  974,\n- \/*   890 *\/   974,  976,  541,  526, 1107,  326,  390,  541,  493,  395,\n- \/*   900 *\/  1468,  195,  528,   13,   13, 1356,  240, 1107,  277,  280,\n- \/*   910 *\/  1107,  280,  303,  455,  305,  331,  390,   31,  188,  417,\n- \/*   920 *\/   121,  122,  112, 1163, 1163, 1004, 1007,  997,  997,  119,\n- \/*   930 *\/   119,  120,  120,  120,  120,  142,  390,  363,  455,  984,\n- \/*   940 *\/   121,  122,  112, 1163, 1163, 1004, 1007,  997,  997,  119,\n- \/*   950 *\/   119,  120,  120,  120,  120,  975,  321, 1140,  324,  974,\n- \/*   960 *\/   121,  110,  112, 1163, 1163, 1004, 1007,  997,  997,  119,\n- \/*   970 *\/   119,  120,  120,  120,  120,  462,  375, 1183,  118,  118,\n- \/*   980 *\/   118,  118,  117,  117,  116,  116,  116,  115,  422, 1140,\n- \/*   990 *\/   974,  974,  976,  304,    9,  364,  244,  360,  118,  118,\n- \/*  1000 *\/   118,  118,  117,  117,  116,  116,  116,  115,  422,  312,\n- \/*  1010 *\/   544,  342, 1140, 1141, 1142,  299,  290,  535,  118,  118,\n- \/*  1020 *\/   118,  118,  117,  117,  116,  116,  116,  115,  422, 1261,\n- \/*  1030 *\/  1261, 1161,   13,   13,  278,  419,  418,  466,  390,  921,\n- \/*  1040 *\/   260,  260,  289, 1167, 1140, 1141, 1142,  189, 1169,  266,\n- \/*  1050 *\/   266,  466,  388,  541, 1184,  544, 1168,  263,  144,  487,\n- \/*  1060 *\/   920,  544,  541,  122,  112, 1163, 1163, 1004, 1007,  997,\n- \/*  1070 *\/   997,  119,  119,  120,  120,  120,  120,   71,   71, 1140,\n- \/*  1080 *\/  1170, 1270, 1170,   13,   13,  896, 1068, 1161,  544,  466,\n- \/*  1090 *\/   895,  107,  536, 1489,    4, 1266, 1107,    6,  523, 1047,\n- \/*  1100 *\/    12, 1069, 1090, 1568,  311,  453, 1568,  518,  539, 1107,\n- \/*  1110 *\/    56,   56, 1107, 1487,  421, 1356, 1070,    6,  343,  285,\n- \/*  1120 *\/   118,  118,  118,  118,  117,  117,  116,  116,  116,  115,\n- \/*  1130 *\/   422,  423, 1269,  319, 1140, 1141, 1142,  876,  266,  266,\n- \/*  1140 *\/  1275,  107,  536,  533,    4, 1486,  293,  877, 1209,    6,\n- \/*  1150 *\/   210,  541,  541,  164, 1540,  494,  414,  865,  539,  267,\n- \/*  1160 *\/   267, 1212,  396,  509,  497,  204,  266,  266,  394,  529,\n- \/*  1170 *\/     8,  984,  541,  517,  544,  920,  456,  105,  105,  541,\n- \/*  1180 *\/  1088,  423,  266,  266,  106,  415,  423,  546,  545,  266,\n- \/*  1190 *\/   266,  974,  516,  533, 1371,  541,   15,   15,  266,  266,\n- \/*  1200 *\/   454, 1118,  541,  266,  266, 1068, 1370,  513,  290,  535,\n- \/*  1210 *\/   544,  541,  512,   97,  442,  314,  541,  544,  920,  125,\n- \/*  1220 *\/  1069,  984,  974,  974,  976,  977,   27,  105,  105,  399,\n- \/*  1230 *\/   341, 1509,   44,   44,  106, 1070,  423,  546,  545,   57,\n- \/*  1240 *\/    57,  974,  341, 1509,  107,  536,  544,    4,  460,  399,\n- \/*  1250 *\/   214, 1118,  457,  294,  375, 1089,  532,  297,  544,  537,\n- \/*  1260 *\/   396,  539,  290,  535,  104,  244,  102,  524,   58,   58,\n- \/*  1270 *\/   544,  109,  974,  974,  976,  977,   27, 1514, 1129,  425,\n- \/*  1280 *\/    59,   59,  270,  237,  423,  138,   95,  373,  373,  372,\n- \/*  1290 *\/   255,  370,   60,   60,  815, 1178,  533,  544,  273,  544,\n- \/*  1300 *\/  1161,  843,  387,  386,  544, 1307,  544,  215,  210,  296,\n- \/*  1310 *\/   513,  847,  544,  265,  208,  514, 1306,  295,  274,   61,\n- \/*  1320 *\/    61,   62,   62,  436,  984, 1160,   45,   45,   46,   46,\n- \/*  1330 *\/   105,  105, 1184,  920,   47,   47, 1474,  106,  544,  423,\n- \/*  1340 *\/   546,  545,  218,  544,  974,  935, 1085,  217,  544,  377,\n- \/*  1350 *\/   395,  107,  536,  936,    4,  156, 1161,  843,  158,  544,\n- \/*  1360 *\/    49,   49,  141,  544,   38,   50,   50,  544,  539,  307,\n- \/*  1370 *\/    63,   63,  544, 1448,  216,  974,  974,  976,  977,   27,\n- \/*  1380 *\/   444,   64,   64,  544, 1447,   65,   65,  544,  524,   14,\n- \/*  1390 *\/    14,  423,  458,  544,   66,   66,  310,  544,  316,   97,\n- \/*  1400 *\/  1034,  544,  961,  533,  268,  127,  127,  544,  391,   67,\n- \/*  1410 *\/    67,  544,  978,  290,  535,   52,   52,  513,  544,   68,\n- \/*  1420 *\/    68, 1294,  512,   69,   69,  397,  165,  855,  854,   53,\n- \/*  1430 *\/    53,  984,  966,  151,  151,  243,  430,  105,  105,  199,\n- \/*  1440 *\/   152,  152,  448, 1303,  106,  243,  423,  546,  545, 1129,\n- \/*  1450 *\/   425,  974,  320,  270,  862,  863, 1034,  220,  373,  373,\n- \/*  1460 *\/   372,  255,  370,  450,  323,  815,  243,  544,  978,  544,\n- \/*  1470 *\/   107,  536,  544,    4,  544,  938,  939,  325,  215, 1046,\n- \/*  1480 *\/   296, 1046,  974,  974,  976,  977,   27,  539,  295,   76,\n- \/*  1490 *\/    76,   54,   54,  327,   72,   72,  128,  128, 1503, 1254,\n- \/*  1500 *\/   107,  536,  544,    4, 1045,  544, 1045,  531, 1238,  544,\n- \/*  1510 *\/   423,  544,  315,  334,  544,   97,  544,  539,  217,  544,\n- \/*  1520 *\/   472, 1528,  533,  239,   73,   73,  156,  129,  129,  158,\n- \/*  1530 *\/   467,  130,  130,  126,  126,  344,  150,  150,  149,  149,\n- \/*  1540 *\/   423,  134,  134,  329, 1030,  216,   97,  239,  929,  345,\n- \/*  1550 *\/   984,  243,  533, 1315,  339,  544,  105,  105,  900, 1355,\n- \/*  1560 *\/   544, 1290,  258,  106,  338,  423,  546,  545,  544, 1301,\n- \/*  1570 *\/   974,  893,   99,  536,  109,    4,  544,  133,  133,  391,\n- \/*  1580 *\/   984,  197,  131,  131,  290,  535,  105,  105,  530,  539,\n- \/*  1590 *\/   132,  132, 1361,  106, 1219,  423,  546,  545,   75,   75,\n- \/*  1600 *\/   974,  974,  974,  976,  977,   27,  544,  430,  826, 1211,\n- \/*  1610 *\/   894,  139,  423,  109,  544, 1200, 1199, 1201, 1522,  544,\n- \/*  1620 *\/   201,  544,   11,  374,  533, 1287,  347,  349,   77,   77,\n- \/*  1630 *\/  1340,  974,  974,  976,  977,   27,   74,   74,  351,  213,\n- \/*  1640 *\/   435,   43,   43,   48,   48,  302,  477,  309, 1348,  382,\n- \/*  1650 *\/   353,  452,  984,  337, 1237, 1420, 1419,  205,  105,  105,\n- \/*  1660 *\/   192,  367,  193,  534, 1525,  106, 1178,  423,  546,  545,\n- \/*  1670 *\/   247,  167,  974,  270, 1467,  200, 1465, 1175,  373,  373,\n- \/*  1680 *\/   372,  255,  370,  398,   79,  815,   83,   82, 1425,  446,\n- \/*  1690 *\/   161,  177,  169,   95, 1337,  438,  172,  173,  215,  174,\n- \/*  1700 *\/   296,  175,   35,  974,  974,  976,  977,   27,  295, 1345,\n- \/*  1710 *\/   439,  470,  223,   36,  379,  445, 1414,  381,  459, 1351,\n- \/*  1720 *\/   181,  227,   88,  465,  259,  229, 1436,  318,  186,  468,\n- \/*  1730 *\/   322,  230,  384, 1202,  231,  486, 1257, 1256,  217,  411,\n- \/*  1740 *\/  1255, 1248,   90,  847,  206,  413,  156,  505, 1539,  158,\n- \/*  1750 *\/  1226, 1538,  283, 1508, 1227,  336,  385,  284, 1225,  496,\n- \/*  1760 *\/  1537, 1298,   94,  346,  348,  216, 1247,  499, 1299,  245,\n- \/*  1770 *\/   246, 1297,  416,  350, 1494,  124, 1493,   10,  524,  361,\n- \/*  1780 *\/  1400,  101,   96,  288,  508,  253, 1135, 1208,   34, 1296,\n- \/*  1790 *\/   547,  254,  256,  257,  392,  548, 1197, 1192,  359,  391,\n- \/*  1800 *\/  1280, 1279,  196,  365,  290,  535,  366,  352, 1452, 1322,\n- \/*  1810 *\/  1321, 1453,  153,  137,  281,  154,  802,  424,  155, 1451,\n- \/*  1820 *\/  1450,  198,  292,  202,  203,   78,  212,  430,  271,  135,\n- \/*  1830 *\/  1044, 1042,  958,  168,  219,  157,  170,  879,  308,  222,\n- \/*  1840 *\/  1058,  176,  159,  962,  400,   84,  402,  178,   85,   86,\n- \/*  1850 *\/    87,  166,  160,  393, 1061,  224,  225, 1057,  146,   18,\n- \/*  1860 *\/   226,  317, 1050, 1172,  243,  464,  182,  228,   37,  183,\n- \/*  1870 *\/   817,  469,  338,  232,  330,  481,  184,   89,  845,   19,\n- \/*  1880 *\/    20,   92,  473,  478,  333,   91,  162,  858,  147,  488,\n- \/*  1890 *\/   282, 1123,  148, 1010,  928, 1093,   39,   93,   40,  495,\n- \/*  1900 *\/  1094,  187,  498,  207,  262,  264,  923,  242, 1109,  109,\n- \/*  1910 *\/  1113, 1111, 1097,   33,   21, 1117,  520, 1025,   22,   23,\n- \/*  1920 *\/    24, 1116,   25,  190,   97, 1011, 1009,   26, 1013, 1067,\n- \/*  1930 *\/   248,    7, 1066,  249, 1014,   28,   41,  889,  979,  827,\n- \/*  1940 *\/   108,   29,  250,  540,  251, 1530,  371,  368, 1131, 1130,\n- \/*  1950 *\/  1188, 1188, 1188, 1188, 1188, 1188, 1188, 1529,\n+ \/*     0 *\/   564,  115,  112,  220,  169,  199,  115,  112,  220,  564,\n+ \/*    10 *\/   375, 1266,  564,  376,  564,  270, 1309, 1309,  406,  407,\n+ \/*    20 *\/  1084,  199, 1513,   41,   41,  515,  489,  521,  558,  558,\n+ \/*    30 *\/   558,  965,   41,   41,  395,   41,   41,   51,   51,  966,\n+ \/*    40 *\/   296, 1269,  296,  122,  123,  113, 1207, 1207, 1041, 1044,\n+ \/*    50 *\/  1034, 1034,  120,  120,  121,  121,  121,  121,  564,  407,\n+ \/*    60 *\/   275,  275,  275,  275, 1268,  115,  112,  220,  115,  112,\n+ \/*    70 *\/   220, 1512,  846,  561,  516,  561,  115,  112,  220,  250,\n+ \/*    80 *\/   217,   71,   71,  122,  123,  113, 1207, 1207, 1041, 1044,\n+ \/*    90 *\/  1034, 1034,  120,  120,  121,  121,  121,  121,  440,  440,\n+ \/*   100 *\/   440, 1149,  119,  119,  119,  119,  118,  118,  117,  117,\n+ \/*   110 *\/   117,  116,  442, 1183, 1149,  116,  442, 1149,  546,  513,\n+ \/*   120 *\/  1548, 1554,  374,  442,    6, 1183, 1154,  522, 1154,  407,\n+ \/*   130 *\/  1556,  461,  373, 1554,  535,   99,  463,  332,  121,  121,\n+ \/*   140 *\/   121,  121,  119,  119,  119,  119,  118,  118,  117,  117,\n+ \/*   150 *\/   117,  116,  442,  122,  123,  113, 1207, 1207, 1041, 1044,\n+ \/*   160 *\/  1034, 1034,  120,  120,  121,  121,  121,  121, 1257, 1183,\n+ \/*   170 *\/  1184, 1185,  243, 1064,  564,  502,  499,  498,  567,  124,\n+ \/*   180 *\/   567, 1183, 1184, 1185,  474,  497,  119,  119,  119,  119,\n+ \/*   190 *\/   118,  118,  117,  117,  117,  116,  442,   70,   70,  407,\n+ \/*   200 *\/   121,  121,  121,  121,  114,  117,  117,  117,  116,  442,\n+ \/*   210 *\/  1409, 1469,  119,  119,  119,  119,  118,  118,  117,  117,\n+ \/*   220 *\/   117,  116,  442,  122,  123,  113, 1207, 1207, 1041, 1044,\n+ \/*   230 *\/  1034, 1034,  120,  120,  121,  121,  121,  121,  407, 1031,\n+ \/*   240 *\/  1031, 1042, 1045,   81,  382,  541,  378,   80,  119,  119,\n+ \/*   250 *\/   119,  119,  118,  118,  117,  117,  117,  116,  442,  381,\n+ \/*   260 *\/   463,  332,  122,  123,  113, 1207, 1207, 1041, 1044, 1034,\n+ \/*   270 *\/  1034,  120,  120,  121,  121,  121,  121,  262,  215,  512,\n+ \/*   280 *\/  1424,  422,  119,  119,  119,  119,  118,  118,  117,  117,\n+ \/*   290 *\/   117,  116,  442, 1231,    1,    1,  571,    2, 1235, 1573,\n+ \/*   300 *\/   571,    2, 1235,  307, 1149,  141, 1600,  307,  407,  141,\n+ \/*   310 *\/  1183,  361, 1317, 1035,  866,  531, 1317, 1149,  359, 1567,\n+ \/*   320 *\/  1149,  119,  119,  119,  119,  118,  118,  117,  117,  117,\n+ \/*   330 *\/   116,  442,  122,  123,  113, 1207, 1207, 1041, 1044, 1034,\n+ \/*   340 *\/  1034,  120,  120,  121,  121,  121,  121,  275,  275, 1001,\n+ \/*   350 *\/   426,  275,  275, 1128, 1627, 1021, 1627,  137,  542, 1541,\n+ \/*   360 *\/   561,  272,  950,  950,  561, 1423, 1183, 1184, 1185, 1594,\n+ \/*   370 *\/   866, 1012,  530,  315,  231, 1011,  468, 1276,  231,  119,\n+ \/*   380 *\/   119,  119,  119,  118,  118,  117,  117,  117,  116,  442,\n+ \/*   390 *\/  1570,  119,  119,  119,  119,  118,  118,  117,  117,  117,\n+ \/*   400 *\/   116,  442,  330,  359, 1567,  564,  446, 1011, 1011, 1013,\n+ \/*   410 *\/   446,  207,  564,  306,  555,  407,  363, 1021,  363,  346,\n+ \/*   420 *\/   184,  118,  118,  117,  117,  117,  116,  442,   71,   71,\n+ \/*   430 *\/   439,  438, 1126, 1012,  472,   71,   71, 1011,  205,  122,\n+ \/*   440 *\/   123,  113, 1207, 1207, 1041, 1044, 1034, 1034,  120,  120,\n+ \/*   450 *\/   121,  121,  121,  121,  219,  219,  472, 1183,  407,  570,\n+ \/*   460 *\/  1183, 1235,  503, 1477,  149,  546,  307,  489,  141, 1011,\n+ \/*   470 *\/  1011, 1013,  546,  140,  545, 1317, 1214,  191, 1214,  950,\n+ \/*   480 *\/   950,  514,  122,  123,  113, 1207, 1207, 1041, 1044, 1034,\n+ \/*   490 *\/  1034,  120,  120,  121,  121,  121,  121,  563,  119,  119,\n+ \/*   500 *\/   119,  119,  118,  118,  117,  117,  117,  116,  442,  283,\n+ \/*   510 *\/   275,  275,  415, 1183, 1184, 1185, 1183, 1184, 1185,  372,\n+ \/*   520 *\/  1183,  243,  344,  561,  502,  499,  498, 1539,  407, 1540,\n+ \/*   530 *\/  1183,  288,  870,  143,  497, 1549,  185,  231,    9,    6,\n+ \/*   540 *\/   253,  119,  119,  119,  119,  118,  118,  117,  117,  117,\n+ \/*   550 *\/   116,  442,  122,  123,  113, 1207, 1207, 1041, 1044, 1034,\n+ \/*   560 *\/  1034,  120,  120,  121,  121,  121,  121,  407,  137,  446,\n+ \/*   570 *\/   447,  863,  169, 1183,  397, 1204, 1183, 1184, 1185,  931,\n+ \/*   580 *\/   526, 1001,   98,  339,  564,  342, 1183, 1184, 1185,  306,\n+ \/*   590 *\/   555,  122,  123,  113, 1207, 1207, 1041, 1044, 1034, 1034,\n+ \/*   600 *\/   120,  120,  121,  121,  121,  121,  452,   71,   71,  275,\n+ \/*   610 *\/   275,  119,  119,  119,  119,  118,  118,  117,  117,  117,\n+ \/*   620 *\/   116,  442,  561,  417,  306,  555, 1183, 1307, 1307, 1183,\n+ \/*   630 *\/  1184, 1185, 1204, 1149,  330,  458,  318,  407,  363,  470,\n+ \/*   640 *\/   431, 1167,   32,  541,  527,  350, 1149, 1629,  393, 1149,\n+ \/*   650 *\/   119,  119,  119,  119,  118,  118,  117,  117,  117,  116,\n+ \/*   660 *\/   442,  122,  123,  113, 1207, 1207, 1041, 1044, 1034, 1034,\n+ \/*   670 *\/   120,  120,  121,  121,  121,  121,  407,  199,  472, 1183,\n+ \/*   680 *\/  1022,  472, 1183, 1184, 1185,  386,  151,  539, 1548,  277,\n+ \/*   690 *\/   400,  137,    6,  317,    5,  564,  562,    3,  920,  920,\n+ \/*   700 *\/   122,  123,  113, 1207, 1207, 1041, 1044, 1034, 1034,  120,\n+ \/*   710 *\/   120,  121,  121,  121,  121,  411,  505,   83,   71,   71,\n+ \/*   720 *\/   119,  119,  119,  119,  118,  118,  117,  117,  117,  116,\n+ \/*   730 *\/   442, 1183,  218,  428, 1183, 1183, 1184, 1185,  363,  261,\n+ \/*   740 *\/   278,  358,  508,  353,  507,  248,  407,  306,  555, 1539,\n+ \/*   750 *\/  1006,  349,  363,  291,  489,  302,  293, 1542,  281,  119,\n+ \/*   760 *\/   119,  119,  119,  118,  118,  117,  117,  117,  116,  442,\n+ \/*   770 *\/   122,  123,  113, 1207, 1207, 1041, 1044, 1034, 1034,  120,\n+ \/*   780 *\/   120,  121,  121,  121,  121,  407,  148, 1183, 1184, 1185,\n+ \/*   790 *\/  1183, 1184, 1185,  275,  275, 1304, 1257, 1283,  483, 1476,\n+ \/*   800 *\/   150,  489,  480,  564, 1187, 1304,  561, 1587, 1255,  122,\n+ \/*   810 *\/   123,  113, 1207, 1207, 1041, 1044, 1034, 1034,  120,  120,\n+ \/*   820 *\/   121,  121,  121,  121,  564,  886,   13,   13,  520,  119,\n+ \/*   830 *\/   119,  119,  119,  118,  118,  117,  117,  117,  116,  442,\n+ \/*   840 *\/  1183,  420,  417,  564,  269,  269, 1316,   13,   13, 1539,\n+ \/*   850 *\/  1546,   16,   16,  322,    6,  407,  506,  561, 1089, 1089,\n+ \/*   860 *\/   486, 1187,  425, 1539,  887,  292,   71,   71,  119,  119,\n+ \/*   870 *\/   119,  119,  118,  118,  117,  117,  117,  116,  442,  122,\n+ \/*   880 *\/   123,  113, 1207, 1207, 1041, 1044, 1034, 1034,  120,  120,\n+ \/*   890 *\/   121,  121,  121,  121,  564,   12, 1183, 1184, 1185,  407,\n+ \/*   900 *\/   275,  275,  451,  303,  834,  835,  836,  417,  489,  276,\n+ \/*   910 *\/   276, 1547,  284,  561,  319,    6,  321,   71,   71,  429,\n+ \/*   920 *\/   451,  450,  561,  952,  101,  113, 1207, 1207, 1041, 1044,\n+ \/*   930 *\/  1034, 1034,  120,  120,  121,  121,  121,  121,  119,  119,\n+ \/*   940 *\/   119,  119,  118,  118,  117,  117,  117,  116,  442, 1105,\n+ \/*   950 *\/  1183,  489,  564, 1312,  437,  455,  478,  564,  246,  245,\n+ \/*   960 *\/   244, 1409, 1545,  547, 1106,  405,    6, 1544,  196, 1258,\n+ \/*   970 *\/   413,    6,  105,  462,  103,   71,   71,  286,  564, 1107,\n+ \/*   980 *\/    13,   13,  119,  119,  119,  119,  118,  118,  117,  117,\n+ \/*   990 *\/   117,  116,  442,  451,  104,  427,  337,  320,  275,  275,\n+ \/*  1000 *\/   906,   13,   13,  564, 1482, 1105, 1183, 1184, 1185,  126,\n+ \/*  1010 *\/   907,  561,  546,  564,  407,  478,  295, 1321,  253,  200,\n+ \/*  1020 *\/  1106,  548, 1482, 1484,  280, 1409,   55,   55, 1287,  561,\n+ \/*  1030 *\/   478,  380,  423,  951,  407, 1107,   71,   71,  122,  123,\n+ \/*  1040 *\/   113, 1207, 1207, 1041, 1044, 1034, 1034,  120,  120,  121,\n+ \/*  1050 *\/   121,  121,  121, 1204,  407,  287,  552,  309,  122,  123,\n+ \/*  1060 *\/   113, 1207, 1207, 1041, 1044, 1034, 1034,  120,  120,  121,\n+ \/*  1070 *\/   121,  121,  121,  441, 1128, 1628,  146, 1628,  122,  111,\n+ \/*  1080 *\/   113, 1207, 1207, 1041, 1044, 1034, 1034,  120,  120,  121,\n+ \/*  1090 *\/   121,  121,  121,  404,  403, 1482,  424,  119,  119,  119,\n+ \/*  1100 *\/   119,  118,  118,  117,  117,  117,  116,  442, 1183,  564,\n+ \/*  1110 *\/  1204,  544, 1086,  858,  329,  361, 1086,  119,  119,  119,\n+ \/*  1120 *\/   119,  118,  118,  117,  117,  117,  116,  442,  564,  294,\n+ \/*  1130 *\/   144,  523,   56,   56,  224,  564,  510,  119,  119,  119,\n+ \/*  1140 *\/   119,  118,  118,  117,  117,  117,  116,  442,  484, 1409,\n+ \/*  1150 *\/   537,   15,   15, 1126,  434,  439,  438,  407,   13,   13,\n+ \/*  1160 *\/  1523,   12,  926, 1211, 1183, 1184, 1185,  925, 1213,  536,\n+ \/*  1170 *\/   858,  557,  413,  193, 1525,  494, 1212,  448, 1160, 1222,\n+ \/*  1180 *\/  1183,  564,  123,  113, 1207, 1207, 1041, 1044, 1034, 1034,\n+ \/*  1190 *\/   120,  120,  121,  121,  121,  121, 1521, 1149,  564,  965,\n+ \/*  1200 *\/   564, 1214,  247, 1214,   13,   13, 1409,  966,  538,  564,\n+ \/*  1210 *\/  1149,  108,  556, 1149,    4,  310,  392, 1227,   17,  194,\n+ \/*  1220 *\/   485,   43,   43,   57,   57,  306,  555,  524,  559, 1160,\n+ \/*  1230 *\/   464,  564,   44,   44,  392, 1127, 1183, 1184, 1185,  479,\n+ \/*  1240 *\/   119,  119,  119,  119,  118,  118,  117,  117,  117,  116,\n+ \/*  1250 *\/   442,  443,  564,  327,   13,   13,  564,  418, 1315,  414,\n+ \/*  1260 *\/   171,  564,  311,  553,  213,  529, 1253,  564,  517,  543,\n+ \/*  1270 *\/   412,  108,  556,  137,    4,   58,   58,  435,  314,   59,\n+ \/*  1280 *\/    59,  274,  217,  549,   60,   60,  349,  476,  559, 1353,\n+ \/*  1290 *\/    61,   61, 1021,  275,  275, 1228,  213,  564,  106,  106,\n+ \/*  1300 *\/     8,  275,  275,  275,  275,  107,  561,  443,  566,  565,\n+ \/*  1310 *\/   564,  443, 1011, 1228,  561,  564,  561,  564,  275,  275,\n+ \/*  1320 *\/    62,   62, 1352,  553,  247,  456,  564,   98,  110,  306,\n+ \/*  1330 *\/   555,  561,  564,   45,   45,  405, 1203,  533,   46,   46,\n+ \/*  1340 *\/    47,   47,  532,  465, 1011, 1011, 1013, 1014,   27,   49,\n+ \/*  1350 *\/    49,  564, 1021,  405,  469,   50,   50,  564,  106,  106,\n+ \/*  1360 *\/   305,  564,   84,  204,  405,  107,  564,  443,  566,  565,\n+ \/*  1370 *\/   405,  564, 1011,  564,   63,   63,  564, 1599,  564,  895,\n+ \/*  1380 *\/    64,   64,  457,  477,   65,   65,  147,   96,   38,   14,\n+ \/*  1390 *\/    14, 1528,  412,  564,   66,   66,  128,  128,  926,   67,\n+ \/*  1400 *\/    67,   52,   52,  925, 1011, 1011, 1013, 1014,   27, 1572,\n+ \/*  1410 *\/  1171,  445,  208, 1123,  279,  394,   68,   68,  228,  390,\n+ \/*  1420 *\/   390,  389,  264,  387, 1171,  445,  843,  877,  279,  108,\n+ \/*  1430 *\/   556,  453,    4,  390,  390,  389,  264,  387,  564,  225,\n+ \/*  1440 *\/   843,  313,  328, 1003,   98,  252,  559,  544,  471,  312,\n+ \/*  1450 *\/   252,  564,  208,  225,  564,  313,  473,   30,  252,  279,\n+ \/*  1460 *\/   466,   69,   69,  312,  390,  390,  389,  264,  387,  443,\n+ \/*  1470 *\/   333,  843,   98,  564,   53,   53,  323,  157,  157,  227,\n+ \/*  1480 *\/   495,  553,  249,  289,  225,  564,  313,  162,   31, 1501,\n+ \/*  1490 *\/   135,  564, 1500,  227,  312,  533,  158,  158,  885,  884,\n+ \/*  1500 *\/   534,  162,  873,  301,  135,  564,  481,  226,   76,   76,\n+ \/*  1510 *\/  1021,  347, 1071,   98,   54,   54,  106,  106, 1067,  564,\n+ \/*  1520 *\/   249,  226,  519,  107,  227,  443,  566,  565,   72,   72,\n+ \/*  1530 *\/  1011,  334,  162,  564,  230,  135,  108,  556,  959,    4,\n+ \/*  1540 *\/   252,  408,  129,  129,  564, 1349,  306,  555,  564,  923,\n+ \/*  1550 *\/   564,  110,  226,  559,  564,  408,   73,   73,  564,  873,\n+ \/*  1560 *\/   306,  555, 1011, 1011, 1013, 1014,   27,  130,  130, 1071,\n+ \/*  1570 *\/   449,  131,  131,  127,  127,  357,  443,  156,  156,  892,\n+ \/*  1580 *\/   893,  155,  155,  338,  449,  356,  408,  564,  553,  968,\n+ \/*  1590 *\/   969,  306,  555, 1015,  341,  564,  108,  556,  564,    4,\n+ \/*  1600 *\/  1132, 1286,  533,  564,  856,  343,  145,  532,  345, 1300,\n+ \/*  1610 *\/   136,  136, 1083,  559, 1083,  449,  564, 1021,  134,  134,\n+ \/*  1620 *\/  1284,  132,  132,  106,  106, 1285,  133,  133,  564,  352,\n+ \/*  1630 *\/   107,  564,  443,  566,  565, 1340,  443, 1011,  362,   75,\n+ \/*  1640 *\/    75, 1082,  564, 1082,  564,  924, 1561,  110,  553,  551,\n+ \/*  1650 *\/  1015,   77,   77, 1361,   74,   74, 1408, 1336, 1347,  550,\n+ \/*  1660 *\/  1414, 1265, 1256, 1244, 1243,   42,   42,   48,   48, 1011,\n+ \/*  1670 *\/  1011, 1013, 1014,   27, 1245, 1580,  490, 1021,  267,  202,\n+ \/*  1680 *\/  1333,  365,   11,  106,  106,  930,  367,  210,  369,  391,\n+ \/*  1690 *\/   107, 1395,  443,  566,  565,  223, 1390, 1011,  500,  454,\n+ \/*  1700 *\/   282, 1400,  285,  108,  556,  214,    4,  325, 1383, 1283,\n+ \/*  1710 *\/   475,  355, 1473, 1583, 1472, 1399,  371, 1222,  326,  398,\n+ \/*  1720 *\/   559,  290,  331,  197,  100,  556,  209,    4,  198, 1011,\n+ \/*  1730 *\/  1011, 1013, 1014,   27,  385,  256, 1520, 1518,  554, 1219,\n+ \/*  1740 *\/   416,  559,   83,  443,  173,  206,  182,  221,  459,  167,\n+ \/*  1750 *\/   177,  460,  175,  493,  233,  553,   79,  178, 1396,  179,\n+ \/*  1760 *\/    35,  180,   96, 1402,  443,  396,   36,  467, 1478, 1401,\n+ \/*  1770 *\/   482,  237, 1404,  399,   82,  186,  553, 1467,   89,  488,\n+ \/*  1780 *\/   190,  268,  239,  491, 1021,  340,  240,  401, 1246, 1489,\n+ \/*  1790 *\/   106,  106,  336,  509, 1294,  241, 1303,  107,  430,  443,\n+ \/*  1800 *\/   566,  565, 1302,   91, 1011, 1021, 1598, 1301, 1273,  215,\n+ \/*  1810 *\/  1597,  106,  106,  402,  877,  432,  354, 1272,  107, 1271,\n+ \/*  1820 *\/   443,  566,  565, 1596, 1566, 1011, 1293,  433,  518,  299,\n+ \/*  1830 *\/   300,  360,   95,  525, 1344,  364, 1011, 1011, 1013, 1014,\n+ \/*  1840 *\/    27,  254,  255, 1552,  436, 1551,  125,  544,   10,  379,\n+ \/*  1850 *\/  1326, 1453,  102,   97, 1345,  528,  304, 1011, 1011, 1013,\n+ \/*  1860 *\/  1014,   27,  366,  377, 1343, 1342,  368,  370, 1325,  384,\n+ \/*  1870 *\/   201,  383,   34, 1368, 1367,  568, 1177,  266,  263,  265,\n+ \/*  1880 *\/  1505,  159,  569, 1241, 1236, 1506,  160,  142, 1504, 1503,\n+ \/*  1890 *\/   297,  211,  830,  161,  212,   78,  444,  203,  308,  222,\n+ \/*  1900 *\/  1081,  139, 1079,  316,  174,  163, 1203,  229,  176,  909,\n+ \/*  1910 *\/   324,  232, 1095,  181,  409,  410,  172,  164,  165,  419,\n+ \/*  1920 *\/   183,   85,   86,  421,  166,   87,   88, 1098, 1094,  234,\n+ \/*  1930 *\/   235,  152,   18,  236,  335, 1087, 1216,  252,  187,  487,\n+ \/*  1940 *\/   238,  188,   37,  845,  492,  356,  242,  496,  351,  501,\n+ \/*  1950 *\/   189,   90,   19,  504,  348,   20,  875,   92,  298,  168,\n+ \/*  1960 *\/   888,  153,   93,  511,   94, 1165,  154, 1047, 1134,   39,\n+ \/*  1970 *\/   216, 1133,  271,  273,  958,  192,  953,  110, 1151, 1155,\n+ \/*  1980 *\/   251,    7,   21, 1159, 1139,   22, 1153,   33,   23,   24,\n+ \/*  1990 *\/    25,  540, 1158,  195,   98, 1062,   26, 1048, 1046, 1050,\n+ \/*  2000 *\/  1104, 1051, 1103,  257,  258,   28,   40, 1173, 1016,  857,\n+ \/*  2010 *\/   109,   29,  560,  388,  138, 1172,  259,  170,  260, 1232,\n+ \/*  2020 *\/  1232,  919, 1232, 1232, 1232, 1232, 1232, 1232, 1232, 1232,\n+ \/*  2030 *\/  1232, 1232, 1589, 1232, 1232, 1232, 1588,\n@@ -154136,44 +160264,44 @@\n- \/*     0 *\/   189,  211,  189,  189,  218,  189,  220,  189,  267,  268,\n- \/*    10 *\/   269,  189,  210,  189,  228,  189,  267,  268,  269,   19,\n- \/*    20 *\/   218,  189,  211,  212,  211,  212,  211,  211,  212,  211,\n- \/*    30 *\/   212,   31,  211,  211,  212,  211,  212,  288,  300,   39,\n- \/*    40 *\/    21,  189,  304,   43,   44,   45,   46,   47,   48,   49,\n- \/*    50 *\/    50,   51,   52,   53,   54,   55,   56,   57,  225,   19,\n- \/*    60 *\/   189,  183,  184,  185,  186,  189,  248,  263,  236,  191,\n- \/*    70 *\/   248,  193,  248,  197,  208,  257,  262,  201,  200,  257,\n- \/*    80 *\/   200,  257,   81,   43,   44,   45,   46,   47,   48,   49,\n- \/*    90 *\/    50,   51,   52,   53,   54,   55,   56,   57,  189,   80,\n- \/*   100 *\/   189,  101,  102,  103,  104,  105,  106,  107,  108,  109,\n- \/*   110 *\/   110,  111,  234,  235,  234,  235,  305,  306,  305,  118,\n- \/*   120 *\/   307,  305,  306,  297,  298,  247,   86,  247,   88,   19,\n- \/*   130 *\/   259,  251,  252,  267,  268,  269,   26,  136,  137,  261,\n- \/*   140 *\/   121,  101,  102,  103,  104,  105,  106,  107,  108,  109,\n- \/*   150 *\/   110,  111,   59,   43,   44,   45,   46,   47,   48,   49,\n- \/*   160 *\/    50,   51,   52,   53,   54,   55,   56,   57,  259,  291,\n- \/*   170 *\/   105,  106,  107,  108,  109,  110,  111,  158,  189,   69,\n- \/*   180 *\/   101,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n- \/*   190 *\/   111,  107,  108,  109,  110,  111,  205,  206,  207,   19,\n- \/*   200 *\/    19,   54,   55,   56,   57,   58,   29,  114,  115,  116,\n- \/*   210 *\/    33,  101,  102,  103,  104,  105,  106,  107,  108,  109,\n- \/*   220 *\/   110,  111,  233,   43,   44,   45,   46,   47,   48,   49,\n- \/*   230 *\/    50,   51,   52,   53,   54,   55,   56,   57,   19,  126,\n- \/*   240 *\/   127,  148,   65,   24,  214,  200,   59,   67,  101,  102,\n- \/*   250 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,   22,\n- \/*   260 *\/   189,  111,   43,   44,   45,   46,   47,   48,   49,   50,\n- \/*   270 *\/    51,   52,   53,   54,   55,   56,   57,  206,  207,  234,\n- \/*   280 *\/   235,  101,  102,  103,  104,  105,  106,  107,  108,  109,\n- \/*   290 *\/   110,  111,  247,   76,  107,  114,   59,  267,  268,  269,\n- \/*   300 *\/   189,  114,  115,  116,  162,  163,   89,   19,  263,   92,\n- \/*   310 *\/   189,   23,   54,   55,   56,   57,  189,  206,  207,   22,\n- \/*   320 *\/   101,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n- \/*   330 *\/   111,   43,   44,   45,   46,   47,   48,   49,   50,   51,\n- \/*   340 *\/    52,   53,   54,   55,   56,   57,   19,  189,  277,   59,\n- \/*   350 *\/    23,  114,  115,  116,   46,   47,   48,   49,   61,  101,\n- \/*   360 *\/   102,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n- \/*   370 *\/    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,\n- \/*   380 *\/    53,   54,   55,   56,   57,  125,  126,  127,  277,  101,\n- \/*   390 *\/   102,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n- \/*   400 *\/    59,  189,  189,  276,  114,  115,  116,  117,   73,   59,\n- \/*   410 *\/   120,  121,  122,   72,  214,   19,   81,  259,   19,   23,\n- \/*   420 *\/   130,   81,   72,   24,  211,  212,  221,  119,  101,  102,\n- \/*   430 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,   43,\n+ \/*     0 *\/   192,  273,  274,  275,  192,  192,  273,  274,  275,  192,\n+ \/*    10 *\/   218,  215,  192,  218,  192,  212,  234,  235,  205,   19,\n+ \/*    20 *\/    11,  192,  294,  215,  216,  203,  192,  203,  209,  210,\n+ \/*    30 *\/   211,   31,  215,  216,  205,  215,  216,  215,  216,   39,\n+ \/*    40 *\/   227,  215,  229,   43,   44,   45,   46,   47,   48,   49,\n+ \/*    50 *\/    50,   51,   52,   53,   54,   55,   56,   57,  192,   19,\n+ \/*    60 *\/   238,  239,  238,  239,  215,  273,  274,  275,  273,  274,\n+ \/*    70 *\/   275,  237,   21,  251,  252,  251,  273,  274,  275,  255,\n+ \/*    80 *\/   256,  215,  216,   43,   44,   45,   46,   47,   48,   49,\n+ \/*    90 *\/    50,   51,   52,   53,   54,   55,   56,   57,  209,  210,\n+ \/*   100 *\/   211,   76,  102,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   110 *\/   110,  111,  112,   59,   89,  111,  112,   92,  252,  307,\n+ \/*   120 *\/   308,  313,  314,  112,  312,   59,   86,  261,   88,   19,\n+ \/*   130 *\/   313,   80,  315,  313,  314,   25,  127,  128,   54,   55,\n+ \/*   140 *\/    56,   57,  102,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   150 *\/   110,  111,  112,   43,   44,   45,   46,   47,   48,   49,\n+ \/*   160 *\/    50,   51,   52,   53,   54,   55,   56,   57,  192,  115,\n+ \/*   170 *\/   116,  117,  118,  122,  192,  121,  122,  123,  202,   69,\n+ \/*   180 *\/   204,  115,  116,  117,  192,  131,  102,  103,  104,  105,\n+ \/*   190 *\/   106,  107,  108,  109,  110,  111,  112,  215,  216,   19,\n+ \/*   200 *\/    54,   55,   56,   57,   58,  108,  109,  110,  111,  112,\n+ \/*   210 *\/   192,  160,  102,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   220 *\/   110,  111,  112,   43,   44,   45,   46,   47,   48,   49,\n+ \/*   230 *\/    50,   51,   52,   53,   54,   55,   56,   57,   19,   46,\n+ \/*   240 *\/    47,   48,   49,   24,  248,  192,  250,   67,  102,  103,\n+ \/*   250 *\/   104,  105,  106,  107,  108,  109,  110,  111,  112,  277,\n+ \/*   260 *\/   127,  128,   43,   44,   45,   46,   47,   48,   49,   50,\n+ \/*   270 *\/    51,   52,   53,   54,   55,   56,   57,   26,  164,  165,\n+ \/*   280 *\/   272,  263,  102,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   290 *\/   110,  111,  112,  184,  185,  186,  187,  188,  189,  186,\n+ \/*   300 *\/   187,  188,  189,  194,   76,  196,  229,  194,   19,  196,\n+ \/*   310 *\/    59,  192,  203,  120,   59,   87,  203,   89,  310,  311,\n+ \/*   320 *\/    92,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n+ \/*   330 *\/   111,  112,   43,   44,   45,   46,   47,   48,   49,   50,\n+ \/*   340 *\/    51,   52,   53,   54,   55,   56,   57,  238,  239,   73,\n+ \/*   350 *\/   231,  238,  239,   22,   23,  100,   25,   81,  305,  306,\n+ \/*   360 *\/   251,   23,   25,   25,  251,  272,  115,  116,  117,  214,\n+ \/*   370 *\/   115,  116,  144,  192,  265,  120,  114,  222,  265,  102,\n+ \/*   380 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n+ \/*   390 *\/   192,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n+ \/*   400 *\/   111,  112,  126,  310,  311,  192,  297,  152,  153,  154,\n+ \/*   410 *\/   297,  149,  192,  137,  138,   19,  192,  100,  192,   23,\n+ \/*   420 *\/    22,  106,  107,  108,  109,  110,  111,  112,  215,  216,\n+ \/*   430 *\/   106,  107,  101,  116,  192,  215,  216,  120,  149,   43,\n@@ -154181,169 +160309,178 @@\n- \/*   450 *\/    54,   55,   56,   57,   19,  114,  115,  116,   23,  208,\n- \/*   460 *\/   125,  248,  189,  189,  114,  115,  116,  267,  268,  269,\n- \/*   470 *\/   189,  136,  137,  189,  262,   22,  136,  137,   43,   44,\n- \/*   480 *\/    45,   46,   47,   48,   49,   50,   51,   52,   53,   54,\n- \/*   490 *\/    55,   56,   57,  189,   95,  211,  212,  101,  102,  103,\n- \/*   500 *\/   104,  105,  106,  107,  108,  109,  110,  111,   59,  189,\n- \/*   510 *\/   111,  189,   59,   76,  294,  295,  117,  118,  119,  120,\n- \/*   520 *\/   121,  122,  123,   19,   87,  189,   89,   23,  129,   92,\n- \/*   530 *\/   279,  227,  248,   22,  189,  284,  101,  102,  103,  104,\n- \/*   540 *\/   105,  106,  107,  108,  109,  110,  111,   43,   44,   45,\n- \/*   550 *\/    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,\n- \/*   560 *\/    56,   57,   19,  114,  115,  116,   23,  114,  115,  116,\n- \/*   570 *\/    59,  117,  299,  300,  120,  121,  122,  304,  189,  189,\n- \/*   580 *\/   143,  189,  110,  111,  130,   22,   43,   44,   45,   46,\n- \/*   590 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*   600 *\/    57,  211,  212,  211,  212,  101,  102,  103,  104,  105,\n- \/*   610 *\/   106,  107,  108,  109,  110,  111,  226,  189,  226,  189,\n- \/*   620 *\/   298,  132,   59,  134,  135,  114,  115,  116,  189,   59,\n- \/*   630 *\/   285,   19,    7,    8,    9,   23,  205,  206,  207,  211,\n- \/*   640 *\/   212,  211,  212,  221,  101,  102,  103,  104,  105,  106,\n- \/*   650 *\/   107,  108,  109,  110,  111,   43,   44,   45,   46,   47,\n- \/*   660 *\/    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,\n- \/*   670 *\/    19,  181,  182,  183,  184,  185,  186,  114,  115,  116,\n- \/*   680 *\/   189,  191,  133,  193,  114,  115,  116,  138,  299,  300,\n- \/*   690 *\/   200,   22,  201,  304,   43,   44,   45,   46,   47,   48,\n- \/*   700 *\/    49,   50,   51,   52,   53,   54,   55,   56,   57,   35,\n- \/*   710 *\/   189,  141,  189,  101,  102,  103,  104,  105,  106,  107,\n- \/*   720 *\/   108,  109,  110,  111,  234,  235,   22,   23,   59,  184,\n- \/*   730 *\/    26,  186,  211,  212,  211,  212,  191,  247,  193,   19,\n- \/*   740 *\/    66,  105,  106,   73,  189,  200,  189,  226,   74,  226,\n- \/*   750 *\/    22,  261,  101,  102,  103,  104,  105,  106,  107,  108,\n- \/*   760 *\/   109,  110,  111,   43,   44,   45,   46,   47,   48,   49,\n- \/*   770 *\/    50,   51,   52,   53,   54,   55,   56,   57,  189,  234,\n- \/*   780 *\/   235,  291,   19,  114,  115,  116,  150,   59,  152,  189,\n- \/*   790 *\/   233,  236,  247,   59,  189,  125,  126,  127,   59,  300,\n- \/*   800 *\/   211,  212,  128,  304,  100,   19,  261,  156,   45,   46,\n- \/*   810 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*   820 *\/    57,  101,  102,  103,  104,  105,  106,  107,  108,  109,\n- \/*   830 *\/   110,  111,   46,  233,  189,  189,  291,  248,   99,  189,\n- \/*   840 *\/   125,  126,  127,  115,   26,  200,  289,  230,  231,  115,\n- \/*   850 *\/   200,   16,  189,  114,  115,  189,  211,  212,  119,  221,\n- \/*   860 *\/   189,  211,  212,  258,  101,  102,  103,  104,  105,  106,\n- \/*   870 *\/   107,  108,  109,  110,  111,  189,  156,  211,  212,  234,\n- \/*   880 *\/   235,  189,  211,  212,  234,  235,   22,  201,  189,  150,\n- \/*   890 *\/   151,  152,  247,  248,   76,   16,   19,  247,  248,  113,\n- \/*   900 *\/   189,   24,  257,  211,  212,  189,   26,   89,  262,  223,\n- \/*   910 *\/    92,  225,   77,  189,   79,  129,   19,   53,  226,  248,\n- \/*   920 *\/    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,\n- \/*   930 *\/    53,   54,   55,   56,   57,  236,   19,  271,  189,   99,\n- \/*   940 *\/    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,\n- \/*   950 *\/    53,   54,   55,   56,   57,  115,   77,   59,   79,  119,\n- \/*   960 *\/    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,\n- \/*   970 *\/    53,   54,   55,   56,   57,  259,   22,   23,  101,  102,\n- \/*   980 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,   59,\n- \/*   990 *\/   150,  151,  152,  158,   22,  244,   24,  246,  101,  102,\n- \/*  1000 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  285,\n- \/*  1010 *\/   189,  189,  114,  115,  116,  200,  136,  137,  101,  102,\n- \/*  1020 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  230,\n- \/*  1030 *\/   231,   59,  211,  212,  285,  105,  106,  189,   19,  141,\n- \/*  1040 *\/   234,  235,  239,  113,  114,  115,  116,  226,  118,  234,\n- \/*  1050 *\/   235,  189,  249,  247,  100,  189,  126,   23,  236,  107,\n- \/*  1060 *\/    26,  189,  247,   44,   45,   46,   47,   48,   49,   50,\n- \/*  1070 *\/    51,   52,   53,   54,   55,   56,   57,  211,  212,   59,\n- \/*  1080 *\/   150,  233,  152,  211,  212,  133,   12,  115,  189,  189,\n- \/*  1090 *\/   138,   19,   20,  300,   22,  233,   76,  304,  226,   11,\n- \/*  1100 *\/   208,   27,   22,   23,  200,   19,   26,   87,   36,   89,\n- \/*  1110 *\/   211,  212,   92,  300,  248,  189,   42,  304,  189,  250,\n- \/*  1120 *\/   101,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n- \/*  1130 *\/   111,   59,  200,  233,  114,  115,  116,   63,  234,  235,\n- \/*  1140 *\/   235,   19,   20,   71,   22,  300,  189,   73,  200,  304,\n- \/*  1150 *\/   116,  247,  247,   81,   23,  200,  227,   26,   36,  234,\n- \/*  1160 *\/   235,  203,  204,  143,  200,   26,  234,  235,  194,  200,\n- \/*  1170 *\/    48,   99,  247,   66,  189,  141,  284,  105,  106,  247,\n- \/*  1180 *\/   100,   59,  234,  235,  112,  259,  114,  115,  116,  234,\n- \/*  1190 *\/   235,  119,   85,   71,  266,  247,  211,  212,  234,  235,\n- \/*  1200 *\/   114,   94,  247,  234,  235,   12,  266,   85,  136,  137,\n- \/*  1210 *\/   189,  247,   90,   26,  126,  127,  247,  189,   26,   22,\n- \/*  1220 *\/    27,   99,  150,  151,  152,  153,  154,  105,  106,  189,\n- \/*  1230 *\/   302,  303,  211,  212,  112,   42,  114,  115,  116,  211,\n- \/*  1240 *\/   212,  119,  302,  303,   19,   20,  189,   22,  274,  189,\n- \/*  1250 *\/    15,  144,  278,  189,   22,   23,   63,  189,  189,  203,\n- \/*  1260 *\/   204,   36,  136,  137,  155,   24,  157,  143,  211,  212,\n- \/*  1270 *\/   189,   26,  150,  151,  152,  153,  154,    0,    1,    2,\n- \/*  1280 *\/   211,  212,    5,   46,   59,  161,  147,   10,   11,   12,\n- \/*  1290 *\/    13,   14,  211,  212,   17,   60,   71,  189,  258,  189,\n- \/*  1300 *\/    59,   59,  105,  106,  189,  189,  189,   30,  116,   32,\n- \/*  1310 *\/    85,  124,  189,  251,  252,   90,  189,   40,  258,  211,\n- \/*  1320 *\/   212,  211,  212,  189,   99,   26,  211,  212,  211,  212,\n- \/*  1330 *\/   105,  106,  100,  141,  211,  212,  189,  112,  189,  114,\n- \/*  1340 *\/   115,  116,   24,  189,  119,   31,   23,   70,  189,   26,\n- \/*  1350 *\/   113,   19,   20,   39,   22,   78,  115,  115,   81,  189,\n- \/*  1360 *\/   211,  212,   22,  189,   24,  211,  212,  189,   36,  189,\n- \/*  1370 *\/   211,  212,  189,  189,   97,  150,  151,  152,  153,  154,\n- \/*  1380 *\/   127,  211,  212,  189,  189,  211,  212,  189,  143,  211,\n- \/*  1390 *\/   212,   59,  189,  189,  211,  212,   23,  189,  189,   26,\n- \/*  1400 *\/    59,  189,  149,   71,   22,  211,  212,  189,  131,  211,\n- \/*  1410 *\/   212,  189,   59,  136,  137,  211,  212,   85,  189,  211,\n- \/*  1420 *\/   212,  253,   90,  211,  212,  292,  293,  118,  119,  211,\n- \/*  1430 *\/   212,   99,   23,  211,  212,   26,  159,  105,  106,  140,\n- \/*  1440 *\/   211,  212,   23,  189,  112,   26,  114,  115,  116,    1,\n- \/*  1450 *\/     2,  119,  189,    5,    7,    8,  115,  139,   10,   11,\n- \/*  1460 *\/    12,   13,   14,   23,  189,   17,   26,  189,  115,  189,\n- \/*  1470 *\/    19,   20,  189,   22,  189,   83,   84,  189,   30,  150,\n- \/*  1480 *\/    32,  152,  150,  151,  152,  153,  154,   36,   40,  211,\n- \/*  1490 *\/   212,  211,  212,  189,  211,  212,  211,  212,  309,  189,\n- \/*  1500 *\/    19,   20,  189,   22,  150,  189,  152,  231,  189,  189,\n- \/*  1510 *\/    59,  189,   23,  189,  189,   26,  189,   36,   70,  189,\n- \/*  1520 *\/    23,  139,   71,   26,  211,  212,   78,  211,  212,   81,\n- \/*  1530 *\/   281,  211,  212,  211,  212,  189,  211,  212,  211,  212,\n- \/*  1540 *\/    59,  211,  212,   23,   23,   97,   26,   26,   23,  189,\n- \/*  1550 *\/    99,   26,   71,  189,  119,  189,  105,  106,  107,  189,\n- \/*  1560 *\/   189,  189,  280,  112,  129,  114,  115,  116,  189,  189,\n- \/*  1570 *\/   119,   23,   19,   20,   26,   22,  189,  211,  212,  131,\n- \/*  1580 *\/    99,  237,  211,  212,  136,  137,  105,  106,  189,   36,\n- \/*  1590 *\/   211,  212,  189,  112,  189,  114,  115,  116,  211,  212,\n- \/*  1600 *\/   119,  150,  151,  152,  153,  154,  189,  159,   23,  189,\n- \/*  1610 *\/    23,   26,   59,   26,  189,  189,  189,  189,  189,  189,\n- \/*  1620 *\/   209,  189,  238,  187,   71,  250,  250,  250,  211,  212,\n- \/*  1630 *\/   241,  150,  151,  152,  153,  154,  211,  212,  250,  290,\n- \/*  1640 *\/   254,  211,  212,  211,  212,  254,  215,  286,  241,  241,\n- \/*  1650 *\/   254,  286,   99,  214,  220,  214,  214,  224,  105,  106,\n- \/*  1660 *\/   244,  240,  244,  273,  192,  112,   60,  114,  115,  116,\n- \/*  1670 *\/   139,  290,  119,    5,  196,  238,  196,   38,   10,   11,\n- \/*  1680 *\/    12,   13,   14,  196,  287,   17,  148,  287,  276,  113,\n- \/*  1690 *\/    43,   22,  229,  147,  241,   18,  232,  232,   30,  232,\n- \/*  1700 *\/    32,  232,  264,  150,  151,  152,  153,  154,   40,  265,\n- \/*  1710 *\/   196,   18,  195,  264,  241,  241,  241,  265,  196,  229,\n- \/*  1720 *\/   229,  195,  155,   62,  196,  195,  283,  282,   22,  216,\n- \/*  1730 *\/   196,  195,  216,  196,  195,  113,  213,  213,   70,   64,\n- \/*  1740 *\/   213,  222,   22,  124,  162,  111,   78,  142,  219,   81,\n- \/*  1750 *\/   215,  219,  275,  303,  213,  213,  216,  275,  213,  216,\n- \/*  1760 *\/   213,  256,  113,  255,  255,   97,  222,  216,  256,  196,\n- \/*  1770 *\/    91,  256,   82,  255,  308,  146,  308,   22,  143,  196,\n- \/*  1780 *\/   270,  155,  145,  272,  144,   25,   13,  199,   26,  256,\n- \/*  1790 *\/   198,  190,  190,    6,  296,  188,  188,  188,  244,  131,\n- \/*  1800 *\/   245,  245,  243,  242,  136,  137,  241,  255,  208,  260,\n- \/*  1810 *\/   260,  208,  202,  217,  217,  202,    4,    3,  202,  208,\n- \/*  1820 *\/   208,   22,  160,  209,  209,  208,   15,  159,   98,   16,\n- \/*  1830 *\/    23,   23,  137,  148,   24,  128,  140,   20,   16,  142,\n- \/*  1840 *\/     1,  140,  128,  149,   61,   53,   37,  148,   53,   53,\n- \/*  1850 *\/    53,  293,  128,  296,  114,   34,  139,    1,    5,   22,\n- \/*  1860 *\/   113,  158,   68,   75,   26,   41,   68,  139,   24,  113,\n- \/*  1870 *\/    20,   19,  129,  123,   23,   96,   22,   22,   59,   22,\n- \/*  1880 *\/    22,  147,   67,   67,   24,   22,   37,   28,   23,   22,\n- \/*  1890 *\/    67,   23,   23,   23,  114,   23,   22,   26,   22,   24,\n- \/*  1900 *\/    23,   22,   24,  139,   23,   23,  141,   34,   88,   26,\n- \/*  1910 *\/    75,   86,   23,   22,   34,   75,   24,   23,   34,   34,\n- \/*  1920 *\/    34,   93,   34,   26,   26,   23,   23,   34,   23,   23,\n- \/*  1930 *\/    26,   44,   23,   22,   11,   22,   22,  133,   23,   23,\n- \/*  1940 *\/    22,   22,  139,   26,  139,  139,   15,   23,    1,    1,\n- \/*  1950 *\/   310,  310,  310,  310,  310,  310,  310,  139,  310,  310,\n- \/*  1960 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  1970 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  1980 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  1990 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2000 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2010 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2020 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2030 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2040 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2050 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2060 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2070 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2080 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2090 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2100 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2110 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2120 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,  310,\n- \/*  2130 *\/   310,  310,  310,  310,  310,  310,  310,  310,  310,\n+ \/*   450 *\/    54,   55,   56,   57,  117,  117,  192,   59,   19,  187,\n+ \/*   460 *\/    59,  189,   23,  282,  240,  252,  194,  192,  196,  152,\n+ \/*   470 *\/   153,  154,  252,   72,  261,  203,  152,   25,  154,  142,\n+ \/*   480 *\/   142,  261,   43,   44,   45,   46,   47,   48,   49,   50,\n+ \/*   490 *\/    51,   52,   53,   54,   55,   56,   57,  192,  102,  103,\n+ \/*   500 *\/   104,  105,  106,  107,  108,  109,  110,  111,  112,  267,\n+ \/*   510 *\/   238,  239,  237,  115,  116,  117,  115,  116,  117,  192,\n+ \/*   520 *\/    59,  118,   16,  251,  121,  122,  123,  303,   19,  303,\n+ \/*   530 *\/    59,  267,   23,   72,  131,  308,   22,  265,   22,  312,\n+ \/*   540 *\/    24,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n+ \/*   550 *\/   111,  112,   43,   44,   45,   46,   47,   48,   49,   50,\n+ \/*   560 *\/    51,   52,   53,   54,   55,   56,   57,   19,   81,  297,\n+ \/*   570 *\/   295,   23,  192,   59,  203,   59,  115,  116,  117,  108,\n+ \/*   580 *\/   192,   73,   25,   77,  192,   79,  115,  116,  117,  137,\n+ \/*   590 *\/   138,   43,   44,   45,   46,   47,   48,   49,   50,   51,\n+ \/*   600 *\/    52,   53,   54,   55,   56,   57,  119,  215,  216,  238,\n+ \/*   610 *\/   239,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n+ \/*   620 *\/   111,  112,  251,  192,  137,  138,   59,  234,  235,  115,\n+ \/*   630 *\/   116,  117,  116,   76,  126,  127,  128,   19,  192,  268,\n+ \/*   640 *\/    19,   23,   22,  192,  252,   24,   89,  300,  301,   92,\n+ \/*   650 *\/   102,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n+ \/*   660 *\/   112,   43,   44,   45,   46,   47,   48,   49,   50,   51,\n+ \/*   670 *\/    52,   53,   54,   55,   56,   57,   19,  192,  192,   59,\n+ \/*   680 *\/    23,  192,  115,  116,  117,  200,  240,  307,  308,   22,\n+ \/*   690 *\/   205,   81,  312,  262,   22,  192,  133,   22,  135,  136,\n+ \/*   700 *\/    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,\n+ \/*   710 *\/    53,   54,   55,   56,   57,  197,   95,  150,  215,  216,\n+ \/*   720 *\/   102,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n+ \/*   730 *\/   112,   59,  192,  112,   59,  115,  116,  117,  192,  118,\n+ \/*   740 *\/   119,  120,  121,  122,  123,  124,   19,  137,  138,  303,\n+ \/*   750 *\/    23,  130,  192,  267,  192,  252,  267,  306,  203,  102,\n+ \/*   760 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n+ \/*   770 *\/    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,\n+ \/*   780 *\/    53,   54,   55,   56,   57,   19,  240,  115,  116,  117,\n+ \/*   790 *\/   115,  116,  117,  238,  239,  222,  192,  224,  280,  237,\n+ \/*   800 *\/   240,  192,  284,  192,   59,  232,  251,  140,  204,   43,\n+ \/*   810 *\/    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,\n+ \/*   820 *\/    54,   55,   56,   57,  192,   35,  215,  216,  192,  102,\n+ \/*   830 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n+ \/*   840 *\/    59,  230,  192,  192,  238,  239,  237,  215,  216,  303,\n+ \/*   850 *\/   308,  215,  216,   16,  312,   19,   66,  251,  126,  127,\n+ \/*   860 *\/   128,  116,  230,  303,   74,  203,  215,  216,  102,  103,\n+ \/*   870 *\/   104,  105,  106,  107,  108,  109,  110,  111,  112,   43,\n+ \/*   880 *\/    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,\n+ \/*   890 *\/    54,   55,   56,   57,  192,  212,  115,  116,  117,   19,\n+ \/*   900 *\/   238,  239,  192,  252,    7,    8,    9,  192,  192,  238,\n+ \/*   910 *\/   239,  308,  262,  251,   77,  312,   79,  215,  216,  129,\n+ \/*   920 *\/   210,  211,  251,  142,  158,   45,   46,   47,   48,   49,\n+ \/*   930 *\/    50,   51,   52,   53,   54,   55,   56,   57,  102,  103,\n+ \/*   940 *\/   104,  105,  106,  107,  108,  109,  110,  111,  112,   12,\n+ \/*   950 *\/    59,  192,  192,  237,  252,  243,  192,  192,  126,  127,\n+ \/*   960 *\/   128,  192,  308,  203,   27,  253,  312,  308,  285,  207,\n+ \/*   970 *\/   208,  312,  157,  290,  159,  215,  216,  262,  192,   42,\n+ \/*   980 *\/   215,  216,  102,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   990 *\/   110,  111,  112,  283,  158,  230,  237,  160,  238,  239,\n+ \/*  1000 *\/    63,  215,  216,  192,  192,   12,  115,  116,  117,   22,\n+ \/*  1010 *\/    73,  251,  252,  192,   19,  192,  230,  239,   24,   24,\n+ \/*  1020 *\/    27,  261,  210,  211,   99,  192,  215,  216,  225,  251,\n+ \/*  1030 *\/   192,  192,  263,  142,   19,   42,  215,  216,   43,   44,\n+ \/*  1040 *\/    45,   46,   47,   48,   49,   50,   51,   52,   53,   54,\n+ \/*  1050 *\/    55,   56,   57,   59,   19,  291,   63,  132,   43,   44,\n+ \/*  1060 *\/    45,   46,   47,   48,   49,   50,   51,   52,   53,   54,\n+ \/*  1070 *\/    55,   56,   57,  252,   22,   23,   22,   25,   43,   44,\n+ \/*  1080 *\/    45,   46,   47,   48,   49,   50,   51,   52,   53,   54,\n+ \/*  1090 *\/    55,   56,   57,  106,  107,  283,  263,  102,  103,  104,\n+ \/*  1100 *\/   105,  106,  107,  108,  109,  110,  111,  112,   59,  192,\n+ \/*  1110 *\/   116,  144,   29,   59,  291,  192,   33,  102,  103,  104,\n+ \/*  1120 *\/   105,  106,  107,  108,  109,  110,  111,  112,  192,  291,\n+ \/*  1130 *\/   163,   19,  215,  216,   15,  192,  108,  102,  103,  104,\n+ \/*  1140 *\/   105,  106,  107,  108,  109,  110,  111,  112,   65,  192,\n+ \/*  1150 *\/    66,  215,  216,  101,  231,  106,  107,   19,  215,  216,\n+ \/*  1160 *\/   192,  212,  134,  114,  115,  116,  117,  139,  119,   85,\n+ \/*  1170 *\/   116,  207,  208,  230,  192,   19,  127,  192,   94,   60,\n+ \/*  1180 *\/    59,  192,   44,   45,   46,   47,   48,   49,   50,   51,\n+ \/*  1190 *\/    52,   53,   54,   55,   56,   57,  192,   76,  192,   31,\n+ \/*  1200 *\/   192,  152,   46,  154,  215,  216,  192,   39,   87,  192,\n+ \/*  1210 *\/    89,   19,   20,   92,   22,  192,   22,   23,   22,  230,\n+ \/*  1220 *\/   263,  215,  216,  215,  216,  137,  138,  115,   36,  145,\n+ \/*  1230 *\/   128,  192,  215,  216,   22,   23,  115,  116,  117,  290,\n+ \/*  1240 *\/   102,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n+ \/*  1250 *\/   112,   59,  192,  151,  215,  216,  192,   61,  203,  298,\n+ \/*  1260 *\/   299,  192,  192,   71,   25,  144,  203,  192,  203,  230,\n+ \/*  1270 *\/   114,   19,   20,   81,   22,  215,  216,  263,  192,  215,\n+ \/*  1280 *\/   216,  255,  256,  203,  215,  216,  130,   19,   36,  192,\n+ \/*  1290 *\/   215,  216,  100,  238,  239,  101,   25,  192,  106,  107,\n+ \/*  1300 *\/    48,  238,  239,  238,  239,  113,  251,  115,  116,  117,\n+ \/*  1310 *\/   192,   59,  120,  101,  251,  192,  251,  192,  238,  239,\n+ \/*  1320 *\/   215,  216,  192,   71,   46,  243,  192,   25,   25,  137,\n+ \/*  1330 *\/   138,  251,  192,  215,  216,  253,   25,   85,  215,  216,\n+ \/*  1340 *\/   215,  216,   90,  243,  152,  153,  154,  155,  156,  215,\n+ \/*  1350 *\/   216,  192,  100,  253,  243,  215,  216,  192,  106,  107,\n+ \/*  1360 *\/   243,  192,  148,  149,  253,  113,  192,  115,  116,  117,\n+ \/*  1370 *\/   253,  192,  120,  192,  215,  216,  192,   23,  192,   25,\n+ \/*  1380 *\/   215,  216,  192,  115,  215,  216,   22,  148,   24,  215,\n+ \/*  1390 *\/   216,  192,  114,  192,  215,  216,  215,  216,  134,  215,\n+ \/*  1400 *\/   216,  215,  216,  139,  152,  153,  154,  155,  156,    0,\n+ \/*  1410 *\/     1,    2,  141,   23,    5,   25,  215,  216,   24,   10,\n+ \/*  1420 *\/    11,   12,   13,   14,    1,    2,   17,  125,    5,   19,\n+ \/*  1430 *\/    20,  268,   22,   10,   11,   12,   13,   14,  192,   30,\n+ \/*  1440 *\/    17,   32,   23,   23,   25,   25,   36,  144,   23,   40,\n+ \/*  1450 *\/    25,  192,  141,   30,  192,   32,   23,   22,   25,    5,\n+ \/*  1460 *\/   128,  215,  216,   40,   10,   11,   12,   13,   14,   59,\n+ \/*  1470 *\/    23,   17,   25,  192,  215,  216,  192,  215,  216,   70,\n+ \/*  1480 *\/    23,   71,   25,  151,   30,  192,   32,   78,   53,  192,\n+ \/*  1490 *\/    81,  192,  192,   70,   40,   85,  215,  216,  119,  120,\n+ \/*  1500 *\/    90,   78,   59,  254,   81,  192,  192,   98,  215,  216,\n+ \/*  1510 *\/   100,   23,   59,   25,  215,  216,  106,  107,   23,  192,\n+ \/*  1520 *\/    25,   98,   19,  113,   70,  115,  116,  117,  215,  216,\n+ \/*  1530 *\/   120,  192,   78,  192,  140,   81,   19,   20,   23,   22,\n+ \/*  1540 *\/    25,  132,  215,  216,  192,  192,  137,  138,  192,   23,\n+ \/*  1550 *\/   192,   25,   98,   36,  192,  132,  215,  216,  192,  116,\n+ \/*  1560 *\/   137,  138,  152,  153,  154,  155,  156,  215,  216,  116,\n+ \/*  1570 *\/   161,  215,  216,  215,  216,  120,   59,  215,  216,    7,\n+ \/*  1580 *\/     8,  215,  216,  192,  161,  130,  132,  192,   71,   83,\n+ \/*  1590 *\/    84,  137,  138,   59,  192,  192,   19,   20,  192,   22,\n+ \/*  1600 *\/    97,  225,   85,  192,   23,  192,   25,   90,  192,  192,\n+ \/*  1610 *\/   215,  216,  152,   36,  154,  161,  192,  100,  215,  216,\n+ \/*  1620 *\/   192,  215,  216,  106,  107,  225,  215,  216,  192,  192,\n+ \/*  1630 *\/   113,  192,  115,  116,  117,  257,   59,  120,  192,  215,\n+ \/*  1640 *\/   216,  152,  192,  154,  192,   23,  317,   25,   71,  235,\n+ \/*  1650 *\/   116,  215,  216,  192,  215,  216,  192,  192,  192,  192,\n+ \/*  1660 *\/   192,  192,  192,  192,  192,  215,  216,  215,  216,  152,\n+ \/*  1670 *\/   153,  154,  155,  156,  192,  192,  287,  100,  286,  241,\n+ \/*  1680 *\/   254,  254,  242,  106,  107,  108,  254,  213,  254,  190,\n+ \/*  1690 *\/   113,  270,  115,  116,  117,  296,  266,  120,  219,  258,\n+ \/*  1700 *\/   244,  270,  258,   19,   20,  228,   22,  292,  266,  224,\n+ \/*  1710 *\/   292,  218,  218,  195,  218,  270,  258,   60,  245,  270,\n+ \/*  1720 *\/    36,  245,  244,  248,   19,   20,  242,   22,  248,  152,\n+ \/*  1730 *\/   153,  154,  155,  156,  244,  140,  199,  199,  279,   38,\n+ \/*  1740 *\/   199,   36,  150,   59,  296,  149,   22,  296,   18,   43,\n+ \/*  1750 *\/   236,  199,  233,   18,  198,   71,  293,  236,  271,  236,\n+ \/*  1760 *\/   269,  236,  148,  271,   59,  245,  269,  245,  282,  271,\n+ \/*  1770 *\/   199,  198,  233,  245,  293,  233,   71,  245,  157,   62,\n+ \/*  1780 *\/    22,  199,  198,  220,  100,  199,  198,  220,  199,  289,\n+ \/*  1790 *\/   106,  107,  288,  114,  226,  198,  217,  113,   64,  115,\n+ \/*  1800 *\/   116,  117,  217,   22,  120,  100,  223,  217,  217,  164,\n+ \/*  1810 *\/   223,  106,  107,  220,  125,   24,  217,  219,  113,  217,\n+ \/*  1820 *\/   115,  116,  117,  217,  311,  120,  226,  112,  304,  281,\n+ \/*  1830 *\/   281,  220,  114,  143,  260,  259,  152,  153,  154,  155,\n+ \/*  1840 *\/   156,  199,   91,  316,   82,  316,  147,  144,   22,  199,\n+ \/*  1850 *\/   249,  276,  157,  146,  260,  145,  278,  152,  153,  154,\n+ \/*  1860 *\/   155,  156,  259,  248,  260,  260,  259,  259,  249,  245,\n+ \/*  1870 *\/   247,  246,   25,  264,  264,  201,   13,    6,  193,  193,\n+ \/*  1880 *\/   212,  206,  191,  191,  191,  212,  206,  221,  212,  212,\n+ \/*  1890 *\/   221,  213,    4,  206,  213,  212,    3,   22,  162,   15,\n+ \/*  1900 *\/    23,   16,   23,  138,  150,  129,   25,   24,  141,   20,\n+ \/*  1910 *\/    16,  143,    1,  141,  302,  302,  299,  129,  129,   61,\n+ \/*  1920 *\/   150,   53,   53,   37,  129,   53,   53,  115,    1,   34,\n+ \/*  1930 *\/   140,    5,   22,  114,  160,   68,   75,   25,   68,   41,\n+ \/*  1940 *\/   140,  114,   24,   20,   19,  130,  124,   67,   24,   67,\n+ \/*  1950 *\/    22,   22,   22,   96,   23,   22,   59,   22,   67,   37,\n+ \/*  1960 *\/    28,   23,  148,   22,   25,   23,   23,   23,   23,   22,\n+ \/*  1970 *\/   140,   97,   23,   23,  115,   22,  142,   25,   88,   75,\n+ \/*  1980 *\/    34,   44,   34,   75,   23,   34,   86,   22,   34,   34,\n+ \/*  1990 *\/    34,   24,   93,   25,   25,   23,   34,   23,   23,   23,\n+ \/*  2000 *\/    23,   11,   23,   25,   22,   22,   22,    1,   23,   23,\n+ \/*  2010 *\/    22,   22,   25,   15,   23,    1,  140,   25,  140,  318,\n+ \/*  2020 *\/   318,  134,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2030 *\/   318,  318,  140,  318,  318,  318,  140,  318,  318,  318,\n+ \/*  2040 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2050 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2060 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2070 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2080 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2090 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2100 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2110 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2120 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2130 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2140 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2150 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2160 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2170 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2180 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2190 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2200 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2210 *\/   318,  318,  318,  318,  318,  318,  318,  318,  318,  318,\n+ \/*  2220 *\/   318,\n@@ -154351,1 +160488,1 @@\n-#define YY_SHIFT_COUNT    (550)\n+#define YY_SHIFT_COUNT    (571)\n@@ -154353,1 +160490,1 @@\n-#define YY_SHIFT_MAX      (1948)\n+#define YY_SHIFT_MAX      (2014)\n@@ -154355,56 +160492,58 @@\n- \/*     0 *\/  1448, 1277, 1668, 1072, 1072,  340, 1122, 1225, 1332, 1481,\n- \/*    10 *\/  1481, 1481,  335,    0,    0,  180,  897, 1481, 1481, 1481,\n- \/*    20 *\/  1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481,\n- \/*    30 *\/   930,  930, 1020, 1020,  290,    1,  340,  340,  340,  340,\n- \/*    40 *\/   340,  340,   40,  110,  219,  288,  327,  396,  435,  504,\n- \/*    50 *\/   543,  612,  651,  720,  877,  897,  897,  897,  897,  897,\n- \/*    60 *\/   897,  897,  897,  897,  897,  897,  897,  897,  897,  897,\n- \/*    70 *\/   897,  897,  897,  917,  897, 1019,  763,  763, 1451, 1481,\n- \/*    80 *\/  1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481,\n- \/*    90 *\/  1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481,\n- \/*   100 *\/  1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481,\n- \/*   110 *\/  1481, 1481, 1553, 1481, 1481, 1481, 1481, 1481, 1481, 1481,\n- \/*   120 *\/  1481, 1481, 1481, 1481, 1481, 1481,  147,  258,  258,  258,\n- \/*   130 *\/   258,  258,   79,   65,   84,  449,   19,  786,  449,  636,\n- \/*   140 *\/   636,  449,  880,  880,  880,  880,  113,  142,  142,  472,\n- \/*   150 *\/   150, 1958, 1958,  399,  399,  399,   93,  237,  341,  237,\n- \/*   160 *\/   237, 1074, 1074,  437,  350,  704, 1080,  449,  449,  449,\n- \/*   170 *\/   449,  449,  449,  449,  449,  449,  449,  449,  449,  449,\n- \/*   180 *\/   449,  449,  449,  449,  449,  449,  449,  449,  818,  818,\n- \/*   190 *\/   449, 1088,  217,  217,  734,  734, 1124, 1126, 1958, 1958,\n- \/*   200 *\/  1958,  739,  840,  840,  453,  454,  511,  187,  563,  570,\n- \/*   210 *\/   898,  669,  449,  449,  449,  449,  449,  449,  449,  449,\n- \/*   220 *\/   449,  670,  449,  449,  449,  449,  449,  449,  449,  449,\n- \/*   230 *\/   449,  449,  449,  449,  674,  674,  674,  449,  449,  449,\n- \/*   240 *\/   449, 1034,  449,  449,  449,  972, 1107,  449,  449, 1193,\n- \/*   250 *\/   449,  449,  449,  449,  449,  449,  449,  449,  260,  177,\n- \/*   260 *\/   489, 1241, 1241, 1241, 1241, 1192,  489,  489,  952, 1197,\n- \/*   270 *\/   625, 1235, 1139,  181,  181, 1086, 1139, 1139, 1086, 1187,\n- \/*   280 *\/  1131, 1237, 1314, 1314, 1314,  181, 1245, 1245, 1109, 1299,\n- \/*   290 *\/   549, 1340, 1606, 1531, 1531, 1639, 1639, 1531, 1538, 1576,\n- \/*   300 *\/  1669, 1647, 1546, 1677, 1677, 1677, 1677, 1531, 1693, 1546,\n- \/*   310 *\/  1546, 1576, 1669, 1647, 1647, 1546, 1531, 1693, 1567, 1661,\n- \/*   320 *\/  1531, 1693, 1706, 1531, 1693, 1531, 1693, 1706, 1622, 1622,\n- \/*   330 *\/  1622, 1675, 1720, 1720, 1706, 1622, 1619, 1622, 1675, 1622,\n- \/*   340 *\/  1622, 1582, 1706, 1634, 1634, 1706, 1605, 1649, 1605, 1649,\n- \/*   350 *\/  1605, 1649, 1605, 1649, 1531, 1679, 1679, 1690, 1690, 1629,\n- \/*   360 *\/  1635, 1755, 1531, 1626, 1629, 1637, 1640, 1546, 1760, 1762,\n- \/*   370 *\/  1773, 1773, 1787, 1787, 1787, 1958, 1958, 1958, 1958, 1958,\n- \/*   380 *\/  1958, 1958, 1958, 1958, 1958, 1958, 1958, 1958, 1958, 1958,\n- \/*   390 *\/   308,  835,  954, 1232,  879,  715,  728, 1323,  864, 1318,\n- \/*   400 *\/  1253, 1373,  297, 1409, 1419, 1440, 1489, 1497, 1520, 1242,\n- \/*   410 *\/  1309, 1447, 1435, 1341, 1521, 1525, 1392, 1548, 1329, 1354,\n- \/*   420 *\/  1585, 1587, 1353, 1382, 1812, 1814, 1799, 1662, 1811, 1730,\n- \/*   430 *\/  1813, 1807, 1808, 1695, 1685, 1707, 1810, 1696, 1817, 1697,\n- \/*   440 *\/  1822, 1839, 1701, 1694, 1714, 1783, 1809, 1699, 1792, 1795,\n- \/*   450 *\/  1796, 1797, 1724, 1740, 1821, 1717, 1856, 1853, 1837, 1747,\n- \/*   460 *\/  1703, 1794, 1838, 1798, 1788, 1824, 1728, 1756, 1844, 1850,\n- \/*   470 *\/  1852, 1743, 1750, 1854, 1815, 1855, 1857, 1851, 1858, 1816,\n- \/*   480 *\/  1819, 1860, 1779, 1859, 1863, 1823, 1849, 1865, 1734, 1867,\n- \/*   490 *\/  1868, 1869, 1870, 1871, 1872, 1874, 1875, 1877, 1876, 1878,\n- \/*   500 *\/  1764, 1881, 1882, 1780, 1873, 1879, 1765, 1883, 1880, 1884,\n- \/*   510 *\/  1885, 1886, 1820, 1835, 1825, 1887, 1840, 1828, 1888, 1889,\n- \/*   520 *\/  1891, 1892, 1897, 1898, 1893, 1894, 1883, 1902, 1903, 1905,\n- \/*   530 *\/  1906, 1904, 1909, 1911, 1923, 1913, 1914, 1915, 1916, 1918,\n- \/*   540 *\/  1919, 1917, 1804, 1803, 1805, 1806, 1818, 1924, 1931, 1947,\n- \/*   550 *\/  1948,\n+ \/*     0 *\/  1423, 1409, 1454, 1192, 1192,  610, 1252, 1410, 1517, 1684,\n+ \/*    10 *\/  1684, 1684,  276,    0,    0,  180, 1015, 1684, 1684, 1684,\n+ \/*    20 *\/  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,\n+ \/*    30 *\/  1049, 1049, 1121, 1121,   54,  487,  610,  610,  610,  610,\n+ \/*    40 *\/   610,   40,  110,  219,  289,  396,  439,  509,  548,  618,\n+ \/*    50 *\/   657,  727,  766,  836,  995, 1015, 1015, 1015, 1015, 1015,\n+ \/*    60 *\/  1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015,\n+ \/*    70 *\/  1015, 1015, 1015, 1035, 1015, 1138,  880,  880, 1577, 1684,\n+ \/*    80 *\/  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,\n+ \/*    90 *\/  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,\n+ \/*   100 *\/  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,\n+ \/*   110 *\/  1684, 1684, 1684, 1705, 1684, 1684, 1684, 1684, 1684, 1684,\n+ \/*   120 *\/  1684, 1684, 1684, 1684, 1684, 1684, 1684,  146,   84,   84,\n+ \/*   130 *\/    84,   84,   84,  277,  315,  401,   97,  461,  251,   66,\n+ \/*   140 *\/    66,   51, 1156,   66,   66,  324,  324,   66,  452,  452,\n+ \/*   150 *\/   452,  452,  133,  114,  114,    4,   11, 2037, 2037,  621,\n+ \/*   160 *\/   621,  621,  567,  398,  398,  398,  398,  937,  937,  228,\n+ \/*   170 *\/   251,  331, 1052,   66,   66,   66,   66,   66,   66,   66,\n+ \/*   180 *\/    66,   66,   66,   66,   66,   66,   66,   66,   66,   66,\n+ \/*   190 *\/    66,   66,   66,  557,  557,   66,    9,   25,   25,  745,\n+ \/*   200 *\/   745,  967, 1088, 2037, 2037, 2037, 2037, 2037, 2037, 2037,\n+ \/*   210 *\/   255,  317,  317,  514,  403,  620,  471,  672,  781,  891,\n+ \/*   220 *\/   675,   66,   66,   66,   66,   66,   66,   66,   66,   66,\n+ \/*   230 *\/    66,  508,   66,   66,   66,   66,   66,   66,   66,   66,\n+ \/*   240 *\/    66,   66,   66,   66,  790,  790,  790,   66,   66,   66,\n+ \/*   250 *\/   338,   66,   66,   66,  516, 1084,   66,   66,  993,   66,\n+ \/*   260 *\/    66,   66,   66,   66,   66,   66,   66,  732, 1083,  563,\n+ \/*   270 *\/   994,  994,  994,  994,  337,  563,  563, 1028,  987,  897,\n+ \/*   280 *\/  1119,  262, 1214, 1271, 1112, 1214, 1112, 1268, 1239,  262,\n+ \/*   290 *\/   262, 1239,  262, 1271, 1268, 1302, 1354, 1278, 1168, 1168,\n+ \/*   300 *\/  1168, 1112, 1303, 1303,  815, 1311, 1264, 1364, 1657, 1657,\n+ \/*   310 *\/  1595, 1595, 1701, 1701, 1595, 1592, 1596, 1724, 1706, 1730,\n+ \/*   320 *\/  1730, 1730, 1730, 1595, 1735, 1614, 1596, 1596, 1614, 1724,\n+ \/*   330 *\/  1706, 1614, 1706, 1614, 1595, 1735, 1621, 1717, 1595, 1735,\n+ \/*   340 *\/  1758, 1595, 1735, 1595, 1735, 1758, 1679, 1679, 1679, 1734,\n+ \/*   350 *\/  1781, 1781, 1758, 1679, 1689, 1679, 1734, 1679, 1679, 1645,\n+ \/*   360 *\/  1791, 1715, 1715, 1758, 1690, 1718, 1690, 1718, 1690, 1718,\n+ \/*   370 *\/  1690, 1718, 1595, 1751, 1751, 1762, 1762, 1699, 1703, 1826,\n+ \/*   380 *\/  1595, 1695, 1699, 1707, 1710, 1614, 1847, 1863, 1863, 1871,\n+ \/*   390 *\/  1871, 1871, 2037, 2037, 2037, 2037, 2037, 2037, 2037, 2037,\n+ \/*   400 *\/  2037, 2037, 2037, 2037, 2037, 2037, 2037,  193,  837, 1194,\n+ \/*   410 *\/  1212,  506,  832, 1054, 1390,  925, 1435, 1394, 1102, 1332,\n+ \/*   420 *\/  1419, 1196, 1420, 1425, 1433, 1447, 1457, 1488, 1443, 1379,\n+ \/*   430 *\/  1572, 1455, 1503, 1453, 1495, 1515, 1506, 1526, 1460, 1489,\n+ \/*   440 *\/  1581, 1622, 1534,  667, 1888, 1893, 1875, 1736, 1884, 1885,\n+ \/*   450 *\/  1877, 1879, 1765, 1754, 1776, 1881, 1881, 1883, 1767, 1889,\n+ \/*   460 *\/  1768, 1894, 1911, 1772, 1788, 1881, 1789, 1858, 1886, 1881,\n+ \/*   470 *\/  1770, 1868, 1869, 1872, 1873, 1795, 1812, 1895, 1790, 1927,\n+ \/*   480 *\/  1926, 1910, 1819, 1774, 1867, 1912, 1870, 1861, 1898, 1800,\n+ \/*   490 *\/  1827, 1918, 1923, 1925, 1815, 1822, 1928, 1880, 1929, 1930,\n+ \/*   500 *\/  1931, 1933, 1882, 1897, 1924, 1857, 1932, 1935, 1891, 1922,\n+ \/*   510 *\/  1938, 1814, 1941, 1942, 1943, 1944, 1939, 1945, 1947, 1874,\n+ \/*   520 *\/  1830, 1949, 1950, 1859, 1946, 1953, 1834, 1952, 1948, 1951,\n+ \/*   530 *\/  1954, 1955, 1890, 1904, 1900, 1937, 1908, 1899, 1956, 1961,\n+ \/*   540 *\/  1965, 1967, 1968, 1969, 1962, 1972, 1952, 1974, 1975, 1976,\n+ \/*   550 *\/  1977, 1978, 1979, 1982, 1990, 1983, 1984, 1985, 1986, 1988,\n+ \/*   560 *\/  1989, 1987, 1887, 1876, 1878, 1892, 1896, 1992, 1991, 1998,\n+ \/*   570 *\/  2006, 2014,\n@@ -154412,3 +160551,3 @@\n-#define YY_REDUCE_COUNT (389)\n-#define YY_REDUCE_MIN   (-262)\n-#define YY_REDUCE_MAX   (1617)\n+#define YY_REDUCE_COUNT (406)\n+#define YY_REDUCE_MIN   (-272)\n+#define YY_REDUCE_MAX   (1693)\n@@ -154416,39 +160555,41 @@\n- \/*     0 *\/   490, -122,  545,  645,  650, -120, -189, -187, -184, -182,\n- \/*    10 *\/  -178, -176,   45,   30,  200, -251, -134,  390,  392,  521,\n- \/*    20 *\/   523,  213,  692,  821,  284,  589,  872,  666,  671,  866,\n- \/*    30 *\/    71,  111,  273,  389,  686,  815,  904,  932,  948,  955,\n- \/*    40 *\/   964,  969, -259, -259, -259, -259, -259, -259, -259, -259,\n- \/*    50 *\/  -259, -259, -259, -259, -259, -259, -259, -259, -259, -259,\n- \/*    60 *\/  -259, -259, -259, -259, -259, -259, -259, -259, -259, -259,\n- \/*    70 *\/  -259, -259, -259, -259, -259, -259, -259, -259,  428,  430,\n- \/*    80 *\/   899,  985, 1021, 1028, 1057, 1069, 1081, 1108, 1110, 1115,\n- \/*    90 *\/  1117, 1123, 1149, 1154, 1159, 1170, 1174, 1178, 1183, 1194,\n- \/*   100 *\/  1198, 1204, 1208, 1212, 1218, 1222, 1229, 1278, 1280, 1283,\n- \/*   110 *\/  1285, 1313, 1316, 1320, 1322, 1325, 1327, 1330, 1366, 1371,\n- \/*   120 *\/  1379, 1387, 1417, 1425, 1430, 1432, -259, -259, -259, -259,\n- \/*   130 *\/  -259, -259, -259, -259, -259,  557,  974, -214, -174,   -9,\n- \/*   140 *\/   431, -124,  806,  925,  806,  925,  251,  928,  940, -259,\n- \/*   150 *\/  -259, -259, -259, -198, -198, -198,  127, -186, -168,  212,\n- \/*   160 *\/   646,  617,  799, -262,  555,  220,  220,  491,  605, 1040,\n- \/*   170 *\/  1060,  699,  -11,  600,  848,  862,  345, -129,  724,  -91,\n- \/*   180 *\/   158,  749,  716,  900,  304,  822,  929,  926,  499,  793,\n- \/*   190 *\/   322,  892,  813,  845,  958, 1056,  751,  905, 1133, 1062,\n- \/*   200 *\/   803, -210, -185, -179, -148, -167,  -89,  121,  274,  281,\n- \/*   210 *\/   320,  336,  439,  663,  711,  957, 1064, 1068, 1116, 1127,\n- \/*   220 *\/  1134, -196, 1147, 1180, 1184, 1195, 1203, 1209, 1254, 1263,\n- \/*   230 *\/  1275, 1288, 1304, 1310,  205,  422,  638, 1319, 1324, 1346,\n- \/*   240 *\/  1360, 1168, 1364, 1370, 1372,  869, 1189, 1380, 1399, 1276,\n- \/*   250 *\/  1403,  121, 1405, 1420, 1426, 1427, 1428, 1429, 1249, 1282,\n- \/*   260 *\/  1344, 1375, 1376, 1377, 1388, 1168, 1344, 1344, 1384, 1411,\n- \/*   270 *\/  1436, 1349, 1389, 1386, 1391, 1361, 1407, 1408, 1365, 1431,\n- \/*   280 *\/  1433, 1434, 1439, 1441, 1442, 1396, 1416, 1418, 1390, 1421,\n- \/*   290 *\/  1437, 1472, 1381, 1478, 1480, 1397, 1400, 1487, 1412, 1444,\n- \/*   300 *\/  1438, 1463, 1453, 1464, 1465, 1467, 1469, 1514, 1517, 1473,\n- \/*   310 *\/  1474, 1452, 1449, 1490, 1491, 1475, 1522, 1526, 1443, 1445,\n- \/*   320 *\/  1528, 1530, 1513, 1534, 1536, 1537, 1539, 1516, 1523, 1524,\n- \/*   330 *\/  1527, 1519, 1529, 1532, 1540, 1541, 1535, 1542, 1544, 1545,\n- \/*   340 *\/  1547, 1450, 1543, 1477, 1482, 1551, 1505, 1508, 1512, 1509,\n- \/*   350 *\/  1515, 1518, 1533, 1552, 1573, 1466, 1468, 1549, 1550, 1555,\n- \/*   360 *\/  1554, 1510, 1583, 1511, 1556, 1559, 1561, 1565, 1588, 1592,\n- \/*   370 *\/  1601, 1602, 1607, 1608, 1609, 1498, 1557, 1558, 1610, 1600,\n- \/*   380 *\/  1603, 1611, 1612, 1613, 1596, 1597, 1614, 1615, 1617, 1616,\n+ \/*     0 *\/   109,  113,  272,  760, -178, -176, -192, -183, -180, -134,\n+ \/*    10 *\/   213,  220,  371, -208, -205, -272, -197,  611,  632,  765,\n+ \/*    20 *\/   786,  392,  943,  989,  503,  651, 1039,  -18,  702,  821,\n+ \/*    30 *\/   710,  812, -188,  380, -187,  555,  662, 1055, 1063, 1065,\n+ \/*    40 *\/  1080, -267, -267, -267, -267, -267, -267, -267, -267, -267,\n+ \/*    50 *\/  -267, -267, -267, -267, -267, -267, -267, -267, -267, -267,\n+ \/*    60 *\/  -267, -267, -267, -267, -267, -267, -267, -267, -267, -267,\n+ \/*    70 *\/  -267, -267, -267, -267, -267, -267, -267, -267,  636,  811,\n+ \/*    80 *\/   917,  936, 1006, 1008, 1017, 1060, 1064, 1069, 1075, 1105,\n+ \/*    90 *\/  1118, 1123, 1125, 1134, 1140, 1159, 1165, 1169, 1174, 1179,\n+ \/*   100 *\/  1181, 1184, 1186, 1201, 1246, 1259, 1262, 1281, 1293, 1299,\n+ \/*   110 *\/  1313, 1327, 1341, 1352, 1356, 1358, 1362, 1366, 1395, 1403,\n+ \/*   120 *\/  1406, 1411, 1424, 1436, 1439, 1450, 1452, -267, -267, -267,\n+ \/*   130 *\/  -267, -267, -267, -267, -267,  224, -267,  446,  -24,  275,\n+ \/*   140 *\/   546,  518,  573,  560,   53, -181, -111,  485,  606,  671,\n+ \/*   150 *\/   606,  671,  683,    8,   93, -267, -267, -267, -267,  155,\n+ \/*   160 *\/   155,  155,  181,  242,  264,  486,  489, -218,  393,  227,\n+ \/*   170 *\/   604,  347,  347, -171,  431,  650,  715, -166,  562,  609,\n+ \/*   180 *\/   716,  764,   18,  823,  769,  833,  838,  957,  759,  119,\n+ \/*   190 *\/   923,  226, 1014,  542,  603,  451,  949,  654,  659,  762,\n+ \/*   200 *\/   964,   -4,  778,  961,  712, 1082, 1100, 1111, 1026, 1117,\n+ \/*   210 *\/  -204, -174, -151,   -8,   77,  198,  305,  327,  388,  540,\n+ \/*   220 *\/   839,  968,  982,  985, 1004, 1023, 1070, 1086, 1097, 1130,\n+ \/*   230 *\/  1190, 1163, 1199, 1284, 1297, 1300, 1314, 1339, 1353, 1391,\n+ \/*   240 *\/  1402, 1413, 1416, 1417,  803, 1376, 1400, 1428, 1437, 1446,\n+ \/*   250 *\/  1378, 1461, 1464, 1465, 1249, 1329, 1466, 1467, 1414, 1468,\n+ \/*   260 *\/   305, 1469, 1470, 1471, 1472, 1482, 1483, 1389, 1392, 1438,\n+ \/*   270 *\/  1426, 1427, 1432, 1434, 1378, 1438, 1438, 1440, 1474, 1499,\n+ \/*   280 *\/  1399, 1421, 1430, 1456, 1441, 1442, 1444, 1415, 1473, 1431,\n+ \/*   290 *\/  1445, 1476, 1449, 1478, 1418, 1479, 1477, 1485, 1493, 1494,\n+ \/*   300 *\/  1496, 1458, 1475, 1480, 1459, 1490, 1484, 1518, 1448, 1451,\n+ \/*   310 *\/  1537, 1538, 1463, 1481, 1541, 1486, 1487, 1491, 1519, 1514,\n+ \/*   320 *\/  1521, 1523, 1525, 1552, 1556, 1520, 1492, 1498, 1522, 1497,\n+ \/*   330 *\/  1539, 1528, 1542, 1532, 1571, 1573, 1500, 1504, 1582, 1584,\n+ \/*   340 *\/  1563, 1586, 1588, 1589, 1597, 1567, 1579, 1585, 1590, 1568,\n+ \/*   350 *\/  1583, 1587, 1593, 1591, 1598, 1599, 1600, 1602, 1606, 1513,\n+ \/*   360 *\/  1524, 1548, 1549, 1611, 1574, 1576, 1594, 1603, 1604, 1607,\n+ \/*   370 *\/  1605, 1608, 1642, 1527, 1529, 1609, 1610, 1601, 1615, 1575,\n+ \/*   380 *\/  1650, 1578, 1619, 1623, 1625, 1624, 1674, 1685, 1686, 1691,\n+ \/*   390 *\/  1692, 1693, 1612, 1613, 1617, 1675, 1668, 1673, 1676, 1677,\n+ \/*   400 *\/  1680, 1666, 1669, 1678, 1681, 1683, 1687,\n@@ -154457,56 +160598,58 @@\n- \/*     0 *\/  1573, 1573, 1573, 1409, 1186, 1295, 1186, 1186, 1186, 1409,\n- \/*    10 *\/  1409, 1409, 1186, 1325, 1325, 1462, 1217, 1186, 1186, 1186,\n- \/*    20 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1408, 1186, 1186,\n- \/*    30 *\/  1186, 1186, 1492, 1492, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*    40 *\/  1186, 1186, 1186, 1334, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*    50 *\/  1410, 1411, 1186, 1186, 1186, 1461, 1463, 1426, 1344, 1343,\n- \/*    60 *\/  1342, 1341, 1444, 1312, 1339, 1332, 1336, 1404, 1405, 1403,\n- \/*    70 *\/  1407, 1411, 1410, 1186, 1335, 1375, 1389, 1374, 1186, 1186,\n- \/*    80 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*    90 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   100 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   110 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   120 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1383, 1388, 1394, 1387,\n- \/*   130 *\/  1384, 1377, 1376, 1378, 1379, 1186, 1207, 1259, 1186, 1186,\n- \/*   140 *\/  1186, 1186, 1480, 1479, 1186, 1186, 1217, 1369, 1368, 1380,\n- \/*   150 *\/  1381, 1391, 1390, 1469, 1527, 1526, 1427, 1186, 1186, 1186,\n- \/*   160 *\/  1186, 1186, 1186, 1492, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   170 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   180 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1492, 1492,\n- \/*   190 *\/  1186, 1217, 1492, 1492, 1213, 1213, 1319, 1186, 1475, 1295,\n- \/*   200 *\/  1286, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   210 *\/  1186, 1186, 1186, 1186, 1186, 1466, 1464, 1186, 1186, 1186,\n- \/*   220 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   230 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   240 *\/  1186, 1186, 1186, 1186, 1186, 1291, 1186, 1186, 1186, 1186,\n- \/*   250 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1521, 1186, 1439,\n- \/*   260 *\/  1273, 1291, 1291, 1291, 1291, 1293, 1274, 1272, 1285, 1218,\n- \/*   270 *\/  1193, 1565, 1338, 1314, 1314, 1562, 1338, 1338, 1562, 1234,\n- \/*   280 *\/  1543, 1229, 1325, 1325, 1325, 1314, 1319, 1319, 1406, 1292,\n- \/*   290 *\/  1285, 1186, 1565, 1300, 1300, 1564, 1564, 1300, 1427, 1347,\n- \/*   300 *\/  1353, 1262, 1338, 1268, 1268, 1268, 1268, 1300, 1204, 1338,\n- \/*   310 *\/  1338, 1347, 1353, 1262, 1262, 1338, 1300, 1204, 1443, 1559,\n- \/*   320 *\/  1300, 1204, 1417, 1300, 1204, 1300, 1204, 1417, 1260, 1260,\n- \/*   330 *\/  1260, 1249, 1186, 1186, 1417, 1260, 1234, 1260, 1249, 1260,\n- \/*   340 *\/  1260, 1510, 1417, 1421, 1421, 1417, 1318, 1313, 1318, 1313,\n- \/*   350 *\/  1318, 1313, 1318, 1313, 1300, 1502, 1502, 1328, 1328, 1333,\n- \/*   360 *\/  1319, 1412, 1300, 1186, 1333, 1331, 1329, 1338, 1210, 1252,\n- \/*   370 *\/  1524, 1524, 1520, 1520, 1520, 1570, 1570, 1475, 1536, 1217,\n- \/*   380 *\/  1217, 1217, 1217, 1536, 1236, 1236, 1218, 1218, 1217, 1536,\n- \/*   390 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1531, 1186, 1428, 1304,\n- \/*   400 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   410 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   420 *\/  1186, 1186, 1186, 1358, 1186, 1189, 1472, 1186, 1186, 1470,\n- \/*   430 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1305, 1186, 1186, 1186,\n- \/*   440 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   450 *\/  1186, 1186, 1186, 1186, 1186, 1561, 1186, 1186, 1186, 1186,\n- \/*   460 *\/  1186, 1186, 1442, 1441, 1186, 1186, 1302, 1186, 1186, 1186,\n- \/*   470 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   480 *\/  1232, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   490 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   500 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1330, 1186, 1186,\n- \/*   510 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   520 *\/  1186, 1186, 1507, 1320, 1186, 1186, 1552, 1186, 1186, 1186,\n- \/*   530 *\/  1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186, 1186,\n- \/*   540 *\/  1186, 1547, 1276, 1360, 1186, 1359, 1363, 1186, 1198, 1186,\n- \/*   550 *\/  1186,\n+ \/*     0 *\/  1633, 1633, 1633, 1462, 1230, 1341, 1230, 1230, 1230, 1462,\n+ \/*    10 *\/  1462, 1462, 1230, 1371, 1371, 1515, 1263, 1230, 1230, 1230,\n+ \/*    20 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1461, 1230, 1230,\n+ \/*    30 *\/  1230, 1230, 1550, 1550, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*    40 *\/  1230, 1230, 1380, 1230, 1387, 1230, 1230, 1230, 1230, 1230,\n+ \/*    50 *\/  1463, 1464, 1230, 1230, 1230, 1514, 1516, 1479, 1394, 1393,\n+ \/*    60 *\/  1392, 1391, 1497, 1358, 1385, 1378, 1382, 1457, 1458, 1456,\n+ \/*    70 *\/  1460, 1464, 1463, 1230, 1381, 1428, 1442, 1427, 1230, 1230,\n+ \/*    80 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*    90 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   100 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   110 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   120 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1436, 1441, 1447,\n+ \/*   130 *\/  1440, 1437, 1430, 1429, 1431, 1230, 1432, 1230, 1254, 1230,\n+ \/*   140 *\/  1230, 1251, 1305, 1230, 1230, 1230, 1230, 1230, 1534, 1533,\n+ \/*   150 *\/  1230, 1230, 1263, 1422, 1421, 1433, 1434, 1444, 1443, 1522,\n+ \/*   160 *\/  1586, 1585, 1480, 1230, 1230, 1230, 1230, 1230, 1230, 1550,\n+ \/*   170 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   180 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   190 *\/  1230, 1230, 1230, 1550, 1550, 1230, 1263, 1550, 1550, 1259,\n+ \/*   200 *\/  1259, 1365, 1230, 1529, 1332, 1332, 1332, 1332, 1341, 1332,\n+ \/*   210 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   220 *\/  1230, 1230, 1230, 1230, 1230, 1519, 1517, 1230, 1230, 1230,\n+ \/*   230 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   240 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   250 *\/  1230, 1230, 1230, 1230, 1337, 1230, 1230, 1230, 1230, 1230,\n+ \/*   260 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1579, 1230, 1492, 1319,\n+ \/*   270 *\/  1337, 1337, 1337, 1337, 1339, 1320, 1318, 1331, 1264, 1237,\n+ \/*   280 *\/  1625, 1397, 1386, 1338, 1360, 1386, 1360, 1622, 1384, 1397,\n+ \/*   290 *\/  1397, 1384, 1397, 1338, 1622, 1280, 1602, 1275, 1371, 1371,\n+ \/*   300 *\/  1371, 1360, 1365, 1365, 1459, 1338, 1331, 1230, 1625, 1625,\n+ \/*   310 *\/  1346, 1346, 1624, 1624, 1346, 1480, 1609, 1406, 1308, 1314,\n+ \/*   320 *\/  1314, 1314, 1314, 1346, 1248, 1384, 1609, 1609, 1384, 1406,\n+ \/*   330 *\/  1308, 1384, 1308, 1384, 1346, 1248, 1496, 1619, 1346, 1248,\n+ \/*   340 *\/  1470, 1346, 1248, 1346, 1248, 1470, 1306, 1306, 1306, 1295,\n+ \/*   350 *\/  1230, 1230, 1470, 1306, 1280, 1306, 1295, 1306, 1306, 1568,\n+ \/*   360 *\/  1230, 1474, 1474, 1470, 1364, 1359, 1364, 1359, 1364, 1359,\n+ \/*   370 *\/  1364, 1359, 1346, 1560, 1560, 1374, 1374, 1379, 1365, 1465,\n+ \/*   380 *\/  1346, 1230, 1379, 1377, 1375, 1384, 1298, 1582, 1582, 1578,\n+ \/*   390 *\/  1578, 1578, 1630, 1630, 1529, 1595, 1263, 1263, 1263, 1263,\n+ \/*   400 *\/  1595, 1282, 1282, 1264, 1264, 1263, 1595, 1230, 1230, 1230,\n+ \/*   410 *\/  1230, 1230, 1230, 1590, 1230, 1524, 1481, 1350, 1230, 1230,\n+ \/*   420 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   430 *\/  1230, 1230, 1535, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   440 *\/  1230, 1230, 1230, 1411, 1230, 1233, 1526, 1230, 1230, 1230,\n+ \/*   450 *\/  1230, 1230, 1230, 1230, 1230, 1388, 1389, 1351, 1230, 1230,\n+ \/*   460 *\/  1230, 1230, 1230, 1230, 1230, 1403, 1230, 1230, 1230, 1398,\n+ \/*   470 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1621, 1230,\n+ \/*   480 *\/  1230, 1230, 1230, 1230, 1230, 1495, 1494, 1230, 1230, 1348,\n+ \/*   490 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   500 *\/  1230, 1230, 1230, 1278, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   510 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   520 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1376, 1230, 1230,\n+ \/*   530 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   540 *\/  1230, 1230, 1565, 1366, 1230, 1230, 1612, 1230, 1230, 1230,\n+ \/*   550 *\/  1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230,\n+ \/*   560 *\/  1230, 1606, 1322, 1413, 1230, 1412, 1416, 1252, 1230, 1242,\n+ \/*   570 *\/  1230, 1230,\n@@ -154557,1 +160700,0 @@\n-   59,  \/*    WITHOUT => ID *\/\n@@ -154559,0 +160701,1 @@\n+   59,  \/*    WITHOUT => ID *\/\n@@ -154629,0 +160772,1 @@\n+   59,  \/* MATERIALIZED => ID *\/\n@@ -154680,0 +160824,1 @@\n+    0,  \/*  RETURNING => nothing *\/\n@@ -154711,0 +160856,1 @@\n+    0,  \/*      ERROR => nothing *\/\n@@ -154764,0 +160910,1 @@\n+\/* #include <assert.h> *\/\n@@ -154825,2 +160972,2 @@\n-  \/*   25 *\/ \"WITHOUT\",\n-  \/*   26 *\/ \"COMMA\",\n+  \/*   25 *\/ \"COMMA\",\n+  \/*   26 *\/ \"WITHOUT\",\n@@ -154897,213 +161044,221 @@\n-  \/*   97 *\/ \"REINDEX\",\n-  \/*   98 *\/ \"RENAME\",\n-  \/*   99 *\/ \"CTIME_KW\",\n-  \/*  100 *\/ \"ANY\",\n-  \/*  101 *\/ \"BITAND\",\n-  \/*  102 *\/ \"BITOR\",\n-  \/*  103 *\/ \"LSHIFT\",\n-  \/*  104 *\/ \"RSHIFT\",\n-  \/*  105 *\/ \"PLUS\",\n-  \/*  106 *\/ \"MINUS\",\n-  \/*  107 *\/ \"STAR\",\n-  \/*  108 *\/ \"SLASH\",\n-  \/*  109 *\/ \"REM\",\n-  \/*  110 *\/ \"CONCAT\",\n-  \/*  111 *\/ \"COLLATE\",\n-  \/*  112 *\/ \"BITNOT\",\n-  \/*  113 *\/ \"ON\",\n-  \/*  114 *\/ \"INDEXED\",\n-  \/*  115 *\/ \"STRING\",\n-  \/*  116 *\/ \"JOIN_KW\",\n-  \/*  117 *\/ \"CONSTRAINT\",\n-  \/*  118 *\/ \"DEFAULT\",\n-  \/*  119 *\/ \"NULL\",\n-  \/*  120 *\/ \"PRIMARY\",\n-  \/*  121 *\/ \"UNIQUE\",\n-  \/*  122 *\/ \"CHECK\",\n-  \/*  123 *\/ \"REFERENCES\",\n-  \/*  124 *\/ \"AUTOINCR\",\n-  \/*  125 *\/ \"INSERT\",\n-  \/*  126 *\/ \"DELETE\",\n-  \/*  127 *\/ \"UPDATE\",\n-  \/*  128 *\/ \"SET\",\n-  \/*  129 *\/ \"DEFERRABLE\",\n-  \/*  130 *\/ \"FOREIGN\",\n-  \/*  131 *\/ \"DROP\",\n-  \/*  132 *\/ \"UNION\",\n-  \/*  133 *\/ \"ALL\",\n-  \/*  134 *\/ \"EXCEPT\",\n-  \/*  135 *\/ \"INTERSECT\",\n-  \/*  136 *\/ \"SELECT\",\n-  \/*  137 *\/ \"VALUES\",\n-  \/*  138 *\/ \"DISTINCT\",\n-  \/*  139 *\/ \"DOT\",\n-  \/*  140 *\/ \"FROM\",\n-  \/*  141 *\/ \"JOIN\",\n-  \/*  142 *\/ \"USING\",\n-  \/*  143 *\/ \"ORDER\",\n-  \/*  144 *\/ \"GROUP\",\n-  \/*  145 *\/ \"HAVING\",\n-  \/*  146 *\/ \"LIMIT\",\n-  \/*  147 *\/ \"WHERE\",\n-  \/*  148 *\/ \"INTO\",\n-  \/*  149 *\/ \"NOTHING\",\n-  \/*  150 *\/ \"FLOAT\",\n-  \/*  151 *\/ \"BLOB\",\n-  \/*  152 *\/ \"INTEGER\",\n-  \/*  153 *\/ \"VARIABLE\",\n-  \/*  154 *\/ \"CASE\",\n-  \/*  155 *\/ \"WHEN\",\n-  \/*  156 *\/ \"THEN\",\n-  \/*  157 *\/ \"ELSE\",\n-  \/*  158 *\/ \"INDEX\",\n-  \/*  159 *\/ \"ALTER\",\n-  \/*  160 *\/ \"ADD\",\n-  \/*  161 *\/ \"WINDOW\",\n-  \/*  162 *\/ \"OVER\",\n-  \/*  163 *\/ \"FILTER\",\n-  \/*  164 *\/ \"COLUMN\",\n-  \/*  165 *\/ \"AGG_FUNCTION\",\n-  \/*  166 *\/ \"AGG_COLUMN\",\n-  \/*  167 *\/ \"TRUEFALSE\",\n-  \/*  168 *\/ \"ISNOT\",\n-  \/*  169 *\/ \"FUNCTION\",\n-  \/*  170 *\/ \"UMINUS\",\n-  \/*  171 *\/ \"UPLUS\",\n-  \/*  172 *\/ \"TRUTH\",\n-  \/*  173 *\/ \"REGISTER\",\n-  \/*  174 *\/ \"VECTOR\",\n-  \/*  175 *\/ \"SELECT_COLUMN\",\n-  \/*  176 *\/ \"IF_NULL_ROW\",\n-  \/*  177 *\/ \"ASTERISK\",\n-  \/*  178 *\/ \"SPAN\",\n-  \/*  179 *\/ \"SPACE\",\n-  \/*  180 *\/ \"ILLEGAL\",\n-  \/*  181 *\/ \"input\",\n-  \/*  182 *\/ \"cmdlist\",\n-  \/*  183 *\/ \"ecmd\",\n-  \/*  184 *\/ \"cmdx\",\n-  \/*  185 *\/ \"explain\",\n-  \/*  186 *\/ \"cmd\",\n-  \/*  187 *\/ \"transtype\",\n-  \/*  188 *\/ \"trans_opt\",\n-  \/*  189 *\/ \"nm\",\n-  \/*  190 *\/ \"savepoint_opt\",\n-  \/*  191 *\/ \"create_table\",\n-  \/*  192 *\/ \"create_table_args\",\n-  \/*  193 *\/ \"createkw\",\n-  \/*  194 *\/ \"temp\",\n-  \/*  195 *\/ \"ifnotexists\",\n-  \/*  196 *\/ \"dbnm\",\n-  \/*  197 *\/ \"columnlist\",\n-  \/*  198 *\/ \"conslist_opt\",\n-  \/*  199 *\/ \"table_options\",\n-  \/*  200 *\/ \"select\",\n-  \/*  201 *\/ \"columnname\",\n-  \/*  202 *\/ \"carglist\",\n-  \/*  203 *\/ \"typetoken\",\n-  \/*  204 *\/ \"typename\",\n-  \/*  205 *\/ \"signed\",\n-  \/*  206 *\/ \"plus_num\",\n-  \/*  207 *\/ \"minus_num\",\n-  \/*  208 *\/ \"scanpt\",\n-  \/*  209 *\/ \"scantok\",\n-  \/*  210 *\/ \"ccons\",\n-  \/*  211 *\/ \"term\",\n-  \/*  212 *\/ \"expr\",\n-  \/*  213 *\/ \"onconf\",\n-  \/*  214 *\/ \"sortorder\",\n-  \/*  215 *\/ \"autoinc\",\n-  \/*  216 *\/ \"eidlist_opt\",\n-  \/*  217 *\/ \"refargs\",\n-  \/*  218 *\/ \"defer_subclause\",\n-  \/*  219 *\/ \"generated\",\n-  \/*  220 *\/ \"refarg\",\n-  \/*  221 *\/ \"refact\",\n-  \/*  222 *\/ \"init_deferred_pred_opt\",\n-  \/*  223 *\/ \"conslist\",\n-  \/*  224 *\/ \"tconscomma\",\n-  \/*  225 *\/ \"tcons\",\n-  \/*  226 *\/ \"sortlist\",\n-  \/*  227 *\/ \"eidlist\",\n-  \/*  228 *\/ \"defer_subclause_opt\",\n-  \/*  229 *\/ \"orconf\",\n-  \/*  230 *\/ \"resolvetype\",\n-  \/*  231 *\/ \"raisetype\",\n-  \/*  232 *\/ \"ifexists\",\n-  \/*  233 *\/ \"fullname\",\n-  \/*  234 *\/ \"selectnowith\",\n-  \/*  235 *\/ \"oneselect\",\n-  \/*  236 *\/ \"wqlist\",\n-  \/*  237 *\/ \"multiselect_op\",\n-  \/*  238 *\/ \"distinct\",\n-  \/*  239 *\/ \"selcollist\",\n-  \/*  240 *\/ \"from\",\n-  \/*  241 *\/ \"where_opt\",\n-  \/*  242 *\/ \"groupby_opt\",\n-  \/*  243 *\/ \"having_opt\",\n-  \/*  244 *\/ \"orderby_opt\",\n-  \/*  245 *\/ \"limit_opt\",\n-  \/*  246 *\/ \"window_clause\",\n-  \/*  247 *\/ \"values\",\n-  \/*  248 *\/ \"nexprlist\",\n-  \/*  249 *\/ \"sclp\",\n-  \/*  250 *\/ \"as\",\n-  \/*  251 *\/ \"seltablist\",\n-  \/*  252 *\/ \"stl_prefix\",\n-  \/*  253 *\/ \"joinop\",\n-  \/*  254 *\/ \"indexed_opt\",\n-  \/*  255 *\/ \"on_opt\",\n-  \/*  256 *\/ \"using_opt\",\n-  \/*  257 *\/ \"exprlist\",\n-  \/*  258 *\/ \"xfullname\",\n-  \/*  259 *\/ \"idlist\",\n-  \/*  260 *\/ \"nulls\",\n-  \/*  261 *\/ \"with\",\n-  \/*  262 *\/ \"setlist\",\n-  \/*  263 *\/ \"insert_cmd\",\n-  \/*  264 *\/ \"idlist_opt\",\n-  \/*  265 *\/ \"upsert\",\n-  \/*  266 *\/ \"filter_over\",\n-  \/*  267 *\/ \"likeop\",\n-  \/*  268 *\/ \"between_op\",\n-  \/*  269 *\/ \"in_op\",\n-  \/*  270 *\/ \"paren_exprlist\",\n-  \/*  271 *\/ \"case_operand\",\n-  \/*  272 *\/ \"case_exprlist\",\n-  \/*  273 *\/ \"case_else\",\n-  \/*  274 *\/ \"uniqueflag\",\n-  \/*  275 *\/ \"collate\",\n-  \/*  276 *\/ \"vinto\",\n-  \/*  277 *\/ \"nmnum\",\n-  \/*  278 *\/ \"trigger_decl\",\n-  \/*  279 *\/ \"trigger_cmd_list\",\n-  \/*  280 *\/ \"trigger_time\",\n-  \/*  281 *\/ \"trigger_event\",\n-  \/*  282 *\/ \"foreach_clause\",\n-  \/*  283 *\/ \"when_clause\",\n-  \/*  284 *\/ \"trigger_cmd\",\n-  \/*  285 *\/ \"trnm\",\n-  \/*  286 *\/ \"tridxby\",\n-  \/*  287 *\/ \"database_kw_opt\",\n-  \/*  288 *\/ \"key_opt\",\n-  \/*  289 *\/ \"add_column_fullname\",\n-  \/*  290 *\/ \"kwcolumn_opt\",\n-  \/*  291 *\/ \"create_vtab\",\n-  \/*  292 *\/ \"vtabarglist\",\n-  \/*  293 *\/ \"vtabarg\",\n-  \/*  294 *\/ \"vtabargtoken\",\n-  \/*  295 *\/ \"lp\",\n-  \/*  296 *\/ \"anylist\",\n-  \/*  297 *\/ \"windowdefn_list\",\n-  \/*  298 *\/ \"windowdefn\",\n-  \/*  299 *\/ \"window\",\n-  \/*  300 *\/ \"frame_opt\",\n-  \/*  301 *\/ \"part_opt\",\n-  \/*  302 *\/ \"filter_clause\",\n-  \/*  303 *\/ \"over_clause\",\n-  \/*  304 *\/ \"range_or_rows\",\n-  \/*  305 *\/ \"frame_bound\",\n-  \/*  306 *\/ \"frame_bound_s\",\n-  \/*  307 *\/ \"frame_bound_e\",\n-  \/*  308 *\/ \"frame_exclude_opt\",\n-  \/*  309 *\/ \"frame_exclude\",\n+  \/*   97 *\/ \"MATERIALIZED\",\n+  \/*   98 *\/ \"REINDEX\",\n+  \/*   99 *\/ \"RENAME\",\n+  \/*  100 *\/ \"CTIME_KW\",\n+  \/*  101 *\/ \"ANY\",\n+  \/*  102 *\/ \"BITAND\",\n+  \/*  103 *\/ \"BITOR\",\n+  \/*  104 *\/ \"LSHIFT\",\n+  \/*  105 *\/ \"RSHIFT\",\n+  \/*  106 *\/ \"PLUS\",\n+  \/*  107 *\/ \"MINUS\",\n+  \/*  108 *\/ \"STAR\",\n+  \/*  109 *\/ \"SLASH\",\n+  \/*  110 *\/ \"REM\",\n+  \/*  111 *\/ \"CONCAT\",\n+  \/*  112 *\/ \"COLLATE\",\n+  \/*  113 *\/ \"BITNOT\",\n+  \/*  114 *\/ \"ON\",\n+  \/*  115 *\/ \"INDEXED\",\n+  \/*  116 *\/ \"STRING\",\n+  \/*  117 *\/ \"JOIN_KW\",\n+  \/*  118 *\/ \"CONSTRAINT\",\n+  \/*  119 *\/ \"DEFAULT\",\n+  \/*  120 *\/ \"NULL\",\n+  \/*  121 *\/ \"PRIMARY\",\n+  \/*  122 *\/ \"UNIQUE\",\n+  \/*  123 *\/ \"CHECK\",\n+  \/*  124 *\/ \"REFERENCES\",\n+  \/*  125 *\/ \"AUTOINCR\",\n+  \/*  126 *\/ \"INSERT\",\n+  \/*  127 *\/ \"DELETE\",\n+  \/*  128 *\/ \"UPDATE\",\n+  \/*  129 *\/ \"SET\",\n+  \/*  130 *\/ \"DEFERRABLE\",\n+  \/*  131 *\/ \"FOREIGN\",\n+  \/*  132 *\/ \"DROP\",\n+  \/*  133 *\/ \"UNION\",\n+  \/*  134 *\/ \"ALL\",\n+  \/*  135 *\/ \"EXCEPT\",\n+  \/*  136 *\/ \"INTERSECT\",\n+  \/*  137 *\/ \"SELECT\",\n+  \/*  138 *\/ \"VALUES\",\n+  \/*  139 *\/ \"DISTINCT\",\n+  \/*  140 *\/ \"DOT\",\n+  \/*  141 *\/ \"FROM\",\n+  \/*  142 *\/ \"JOIN\",\n+  \/*  143 *\/ \"USING\",\n+  \/*  144 *\/ \"ORDER\",\n+  \/*  145 *\/ \"GROUP\",\n+  \/*  146 *\/ \"HAVING\",\n+  \/*  147 *\/ \"LIMIT\",\n+  \/*  148 *\/ \"WHERE\",\n+  \/*  149 *\/ \"RETURNING\",\n+  \/*  150 *\/ \"INTO\",\n+  \/*  151 *\/ \"NOTHING\",\n+  \/*  152 *\/ \"FLOAT\",\n+  \/*  153 *\/ \"BLOB\",\n+  \/*  154 *\/ \"INTEGER\",\n+  \/*  155 *\/ \"VARIABLE\",\n+  \/*  156 *\/ \"CASE\",\n+  \/*  157 *\/ \"WHEN\",\n+  \/*  158 *\/ \"THEN\",\n+  \/*  159 *\/ \"ELSE\",\n+  \/*  160 *\/ \"INDEX\",\n+  \/*  161 *\/ \"ALTER\",\n+  \/*  162 *\/ \"ADD\",\n+  \/*  163 *\/ \"WINDOW\",\n+  \/*  164 *\/ \"OVER\",\n+  \/*  165 *\/ \"FILTER\",\n+  \/*  166 *\/ \"COLUMN\",\n+  \/*  167 *\/ \"AGG_FUNCTION\",\n+  \/*  168 *\/ \"AGG_COLUMN\",\n+  \/*  169 *\/ \"TRUEFALSE\",\n+  \/*  170 *\/ \"ISNOT\",\n+  \/*  171 *\/ \"FUNCTION\",\n+  \/*  172 *\/ \"UMINUS\",\n+  \/*  173 *\/ \"UPLUS\",\n+  \/*  174 *\/ \"TRUTH\",\n+  \/*  175 *\/ \"REGISTER\",\n+  \/*  176 *\/ \"VECTOR\",\n+  \/*  177 *\/ \"SELECT_COLUMN\",\n+  \/*  178 *\/ \"IF_NULL_ROW\",\n+  \/*  179 *\/ \"ASTERISK\",\n+  \/*  180 *\/ \"SPAN\",\n+  \/*  181 *\/ \"ERROR\",\n+  \/*  182 *\/ \"SPACE\",\n+  \/*  183 *\/ \"ILLEGAL\",\n+  \/*  184 *\/ \"input\",\n+  \/*  185 *\/ \"cmdlist\",\n+  \/*  186 *\/ \"ecmd\",\n+  \/*  187 *\/ \"cmdx\",\n+  \/*  188 *\/ \"explain\",\n+  \/*  189 *\/ \"cmd\",\n+  \/*  190 *\/ \"transtype\",\n+  \/*  191 *\/ \"trans_opt\",\n+  \/*  192 *\/ \"nm\",\n+  \/*  193 *\/ \"savepoint_opt\",\n+  \/*  194 *\/ \"create_table\",\n+  \/*  195 *\/ \"create_table_args\",\n+  \/*  196 *\/ \"createkw\",\n+  \/*  197 *\/ \"temp\",\n+  \/*  198 *\/ \"ifnotexists\",\n+  \/*  199 *\/ \"dbnm\",\n+  \/*  200 *\/ \"columnlist\",\n+  \/*  201 *\/ \"conslist_opt\",\n+  \/*  202 *\/ \"table_option_set\",\n+  \/*  203 *\/ \"select\",\n+  \/*  204 *\/ \"table_option\",\n+  \/*  205 *\/ \"columnname\",\n+  \/*  206 *\/ \"carglist\",\n+  \/*  207 *\/ \"typetoken\",\n+  \/*  208 *\/ \"typename\",\n+  \/*  209 *\/ \"signed\",\n+  \/*  210 *\/ \"plus_num\",\n+  \/*  211 *\/ \"minus_num\",\n+  \/*  212 *\/ \"scanpt\",\n+  \/*  213 *\/ \"scantok\",\n+  \/*  214 *\/ \"ccons\",\n+  \/*  215 *\/ \"term\",\n+  \/*  216 *\/ \"expr\",\n+  \/*  217 *\/ \"onconf\",\n+  \/*  218 *\/ \"sortorder\",\n+  \/*  219 *\/ \"autoinc\",\n+  \/*  220 *\/ \"eidlist_opt\",\n+  \/*  221 *\/ \"refargs\",\n+  \/*  222 *\/ \"defer_subclause\",\n+  \/*  223 *\/ \"generated\",\n+  \/*  224 *\/ \"refarg\",\n+  \/*  225 *\/ \"refact\",\n+  \/*  226 *\/ \"init_deferred_pred_opt\",\n+  \/*  227 *\/ \"conslist\",\n+  \/*  228 *\/ \"tconscomma\",\n+  \/*  229 *\/ \"tcons\",\n+  \/*  230 *\/ \"sortlist\",\n+  \/*  231 *\/ \"eidlist\",\n+  \/*  232 *\/ \"defer_subclause_opt\",\n+  \/*  233 *\/ \"orconf\",\n+  \/*  234 *\/ \"resolvetype\",\n+  \/*  235 *\/ \"raisetype\",\n+  \/*  236 *\/ \"ifexists\",\n+  \/*  237 *\/ \"fullname\",\n+  \/*  238 *\/ \"selectnowith\",\n+  \/*  239 *\/ \"oneselect\",\n+  \/*  240 *\/ \"wqlist\",\n+  \/*  241 *\/ \"multiselect_op\",\n+  \/*  242 *\/ \"distinct\",\n+  \/*  243 *\/ \"selcollist\",\n+  \/*  244 *\/ \"from\",\n+  \/*  245 *\/ \"where_opt\",\n+  \/*  246 *\/ \"groupby_opt\",\n+  \/*  247 *\/ \"having_opt\",\n+  \/*  248 *\/ \"orderby_opt\",\n+  \/*  249 *\/ \"limit_opt\",\n+  \/*  250 *\/ \"window_clause\",\n+  \/*  251 *\/ \"values\",\n+  \/*  252 *\/ \"nexprlist\",\n+  \/*  253 *\/ \"sclp\",\n+  \/*  254 *\/ \"as\",\n+  \/*  255 *\/ \"seltablist\",\n+  \/*  256 *\/ \"stl_prefix\",\n+  \/*  257 *\/ \"joinop\",\n+  \/*  258 *\/ \"indexed_opt\",\n+  \/*  259 *\/ \"on_opt\",\n+  \/*  260 *\/ \"using_opt\",\n+  \/*  261 *\/ \"exprlist\",\n+  \/*  262 *\/ \"xfullname\",\n+  \/*  263 *\/ \"idlist\",\n+  \/*  264 *\/ \"nulls\",\n+  \/*  265 *\/ \"with\",\n+  \/*  266 *\/ \"where_opt_ret\",\n+  \/*  267 *\/ \"setlist\",\n+  \/*  268 *\/ \"insert_cmd\",\n+  \/*  269 *\/ \"idlist_opt\",\n+  \/*  270 *\/ \"upsert\",\n+  \/*  271 *\/ \"returning\",\n+  \/*  272 *\/ \"filter_over\",\n+  \/*  273 *\/ \"likeop\",\n+  \/*  274 *\/ \"between_op\",\n+  \/*  275 *\/ \"in_op\",\n+  \/*  276 *\/ \"paren_exprlist\",\n+  \/*  277 *\/ \"case_operand\",\n+  \/*  278 *\/ \"case_exprlist\",\n+  \/*  279 *\/ \"case_else\",\n+  \/*  280 *\/ \"uniqueflag\",\n+  \/*  281 *\/ \"collate\",\n+  \/*  282 *\/ \"vinto\",\n+  \/*  283 *\/ \"nmnum\",\n+  \/*  284 *\/ \"trigger_decl\",\n+  \/*  285 *\/ \"trigger_cmd_list\",\n+  \/*  286 *\/ \"trigger_time\",\n+  \/*  287 *\/ \"trigger_event\",\n+  \/*  288 *\/ \"foreach_clause\",\n+  \/*  289 *\/ \"when_clause\",\n+  \/*  290 *\/ \"trigger_cmd\",\n+  \/*  291 *\/ \"trnm\",\n+  \/*  292 *\/ \"tridxby\",\n+  \/*  293 *\/ \"database_kw_opt\",\n+  \/*  294 *\/ \"key_opt\",\n+  \/*  295 *\/ \"add_column_fullname\",\n+  \/*  296 *\/ \"kwcolumn_opt\",\n+  \/*  297 *\/ \"create_vtab\",\n+  \/*  298 *\/ \"vtabarglist\",\n+  \/*  299 *\/ \"vtabarg\",\n+  \/*  300 *\/ \"vtabargtoken\",\n+  \/*  301 *\/ \"lp\",\n+  \/*  302 *\/ \"anylist\",\n+  \/*  303 *\/ \"wqitem\",\n+  \/*  304 *\/ \"wqas\",\n+  \/*  305 *\/ \"windowdefn_list\",\n+  \/*  306 *\/ \"windowdefn\",\n+  \/*  307 *\/ \"window\",\n+  \/*  308 *\/ \"frame_opt\",\n+  \/*  309 *\/ \"part_opt\",\n+  \/*  310 *\/ \"filter_clause\",\n+  \/*  311 *\/ \"over_clause\",\n+  \/*  312 *\/ \"range_or_rows\",\n+  \/*  313 *\/ \"frame_bound\",\n+  \/*  314 *\/ \"frame_bound_s\",\n+  \/*  315 *\/ \"frame_bound_e\",\n+  \/*  316 *\/ \"frame_exclude_opt\",\n+  \/*  317 *\/ \"frame_exclude\",\n@@ -155136,1 +161291,1 @@\n- \/*  19 *\/ \"create_table_args ::= LP columnlist conslist_opt RP table_options\",\n+ \/*  19 *\/ \"create_table_args ::= LP columnlist conslist_opt RP table_option_set\",\n@@ -155138,364 +161293,380 @@\n- \/*  21 *\/ \"table_options ::=\",\n- \/*  22 *\/ \"table_options ::= WITHOUT nm\",\n- \/*  23 *\/ \"columnname ::= nm typetoken\",\n- \/*  24 *\/ \"typetoken ::=\",\n- \/*  25 *\/ \"typetoken ::= typename LP signed RP\",\n- \/*  26 *\/ \"typetoken ::= typename LP signed COMMA signed RP\",\n- \/*  27 *\/ \"typename ::= typename ID|STRING\",\n- \/*  28 *\/ \"scanpt ::=\",\n- \/*  29 *\/ \"scantok ::=\",\n- \/*  30 *\/ \"ccons ::= CONSTRAINT nm\",\n- \/*  31 *\/ \"ccons ::= DEFAULT scantok term\",\n- \/*  32 *\/ \"ccons ::= DEFAULT LP expr RP\",\n- \/*  33 *\/ \"ccons ::= DEFAULT PLUS scantok term\",\n- \/*  34 *\/ \"ccons ::= DEFAULT MINUS scantok term\",\n- \/*  35 *\/ \"ccons ::= DEFAULT scantok ID|INDEXED\",\n- \/*  36 *\/ \"ccons ::= NOT NULL onconf\",\n- \/*  37 *\/ \"ccons ::= PRIMARY KEY sortorder onconf autoinc\",\n- \/*  38 *\/ \"ccons ::= UNIQUE onconf\",\n- \/*  39 *\/ \"ccons ::= CHECK LP expr RP\",\n- \/*  40 *\/ \"ccons ::= REFERENCES nm eidlist_opt refargs\",\n- \/*  41 *\/ \"ccons ::= defer_subclause\",\n- \/*  42 *\/ \"ccons ::= COLLATE ID|STRING\",\n- \/*  43 *\/ \"generated ::= LP expr RP\",\n- \/*  44 *\/ \"generated ::= LP expr RP ID\",\n- \/*  45 *\/ \"autoinc ::=\",\n- \/*  46 *\/ \"autoinc ::= AUTOINCR\",\n- \/*  47 *\/ \"refargs ::=\",\n- \/*  48 *\/ \"refargs ::= refargs refarg\",\n- \/*  49 *\/ \"refarg ::= MATCH nm\",\n- \/*  50 *\/ \"refarg ::= ON INSERT refact\",\n- \/*  51 *\/ \"refarg ::= ON DELETE refact\",\n- \/*  52 *\/ \"refarg ::= ON UPDATE refact\",\n- \/*  53 *\/ \"refact ::= SET NULL\",\n- \/*  54 *\/ \"refact ::= SET DEFAULT\",\n- \/*  55 *\/ \"refact ::= CASCADE\",\n- \/*  56 *\/ \"refact ::= RESTRICT\",\n- \/*  57 *\/ \"refact ::= NO ACTION\",\n- \/*  58 *\/ \"defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt\",\n- \/*  59 *\/ \"defer_subclause ::= DEFERRABLE init_deferred_pred_opt\",\n- \/*  60 *\/ \"init_deferred_pred_opt ::=\",\n- \/*  61 *\/ \"init_deferred_pred_opt ::= INITIALLY DEFERRED\",\n- \/*  62 *\/ \"init_deferred_pred_opt ::= INITIALLY IMMEDIATE\",\n- \/*  63 *\/ \"conslist_opt ::=\",\n- \/*  64 *\/ \"tconscomma ::= COMMA\",\n- \/*  65 *\/ \"tcons ::= CONSTRAINT nm\",\n- \/*  66 *\/ \"tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf\",\n- \/*  67 *\/ \"tcons ::= UNIQUE LP sortlist RP onconf\",\n- \/*  68 *\/ \"tcons ::= CHECK LP expr RP onconf\",\n- \/*  69 *\/ \"tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt\",\n- \/*  70 *\/ \"defer_subclause_opt ::=\",\n- \/*  71 *\/ \"onconf ::=\",\n- \/*  72 *\/ \"onconf ::= ON CONFLICT resolvetype\",\n- \/*  73 *\/ \"orconf ::=\",\n- \/*  74 *\/ \"orconf ::= OR resolvetype\",\n- \/*  75 *\/ \"resolvetype ::= IGNORE\",\n- \/*  76 *\/ \"resolvetype ::= REPLACE\",\n- \/*  77 *\/ \"cmd ::= DROP TABLE ifexists fullname\",\n- \/*  78 *\/ \"ifexists ::= IF EXISTS\",\n- \/*  79 *\/ \"ifexists ::=\",\n- \/*  80 *\/ \"cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select\",\n- \/*  81 *\/ \"cmd ::= DROP VIEW ifexists fullname\",\n- \/*  82 *\/ \"cmd ::= select\",\n- \/*  83 *\/ \"select ::= WITH wqlist selectnowith\",\n- \/*  84 *\/ \"select ::= WITH RECURSIVE wqlist selectnowith\",\n- \/*  85 *\/ \"select ::= selectnowith\",\n- \/*  86 *\/ \"selectnowith ::= selectnowith multiselect_op oneselect\",\n- \/*  87 *\/ \"multiselect_op ::= UNION\",\n- \/*  88 *\/ \"multiselect_op ::= UNION ALL\",\n- \/*  89 *\/ \"multiselect_op ::= EXCEPT|INTERSECT\",\n- \/*  90 *\/ \"oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt\",\n- \/*  91 *\/ \"oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt\",\n- \/*  92 *\/ \"values ::= VALUES LP nexprlist RP\",\n- \/*  93 *\/ \"values ::= values COMMA LP nexprlist RP\",\n- \/*  94 *\/ \"distinct ::= DISTINCT\",\n- \/*  95 *\/ \"distinct ::= ALL\",\n- \/*  96 *\/ \"distinct ::=\",\n- \/*  97 *\/ \"sclp ::=\",\n- \/*  98 *\/ \"selcollist ::= sclp scanpt expr scanpt as\",\n- \/*  99 *\/ \"selcollist ::= sclp scanpt STAR\",\n- \/* 100 *\/ \"selcollist ::= sclp scanpt nm DOT STAR\",\n- \/* 101 *\/ \"as ::= AS nm\",\n- \/* 102 *\/ \"as ::=\",\n- \/* 103 *\/ \"from ::=\",\n- \/* 104 *\/ \"from ::= FROM seltablist\",\n- \/* 105 *\/ \"stl_prefix ::= seltablist joinop\",\n- \/* 106 *\/ \"stl_prefix ::=\",\n- \/* 107 *\/ \"seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt\",\n- \/* 108 *\/ \"seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt\",\n- \/* 109 *\/ \"seltablist ::= stl_prefix LP select RP as on_opt using_opt\",\n- \/* 110 *\/ \"seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt\",\n- \/* 111 *\/ \"dbnm ::=\",\n- \/* 112 *\/ \"dbnm ::= DOT nm\",\n- \/* 113 *\/ \"fullname ::= nm\",\n- \/* 114 *\/ \"fullname ::= nm DOT nm\",\n- \/* 115 *\/ \"xfullname ::= nm\",\n- \/* 116 *\/ \"xfullname ::= nm DOT nm\",\n- \/* 117 *\/ \"xfullname ::= nm DOT nm AS nm\",\n- \/* 118 *\/ \"xfullname ::= nm AS nm\",\n- \/* 119 *\/ \"joinop ::= COMMA|JOIN\",\n- \/* 120 *\/ \"joinop ::= JOIN_KW JOIN\",\n- \/* 121 *\/ \"joinop ::= JOIN_KW nm JOIN\",\n- \/* 122 *\/ \"joinop ::= JOIN_KW nm nm JOIN\",\n- \/* 123 *\/ \"on_opt ::= ON expr\",\n- \/* 124 *\/ \"on_opt ::=\",\n- \/* 125 *\/ \"indexed_opt ::=\",\n- \/* 126 *\/ \"indexed_opt ::= INDEXED BY nm\",\n- \/* 127 *\/ \"indexed_opt ::= NOT INDEXED\",\n- \/* 128 *\/ \"using_opt ::= USING LP idlist RP\",\n- \/* 129 *\/ \"using_opt ::=\",\n- \/* 130 *\/ \"orderby_opt ::=\",\n- \/* 131 *\/ \"orderby_opt ::= ORDER BY sortlist\",\n- \/* 132 *\/ \"sortlist ::= sortlist COMMA expr sortorder nulls\",\n- \/* 133 *\/ \"sortlist ::= expr sortorder nulls\",\n- \/* 134 *\/ \"sortorder ::= ASC\",\n- \/* 135 *\/ \"sortorder ::= DESC\",\n- \/* 136 *\/ \"sortorder ::=\",\n- \/* 137 *\/ \"nulls ::= NULLS FIRST\",\n- \/* 138 *\/ \"nulls ::= NULLS LAST\",\n- \/* 139 *\/ \"nulls ::=\",\n- \/* 140 *\/ \"groupby_opt ::=\",\n- \/* 141 *\/ \"groupby_opt ::= GROUP BY nexprlist\",\n- \/* 142 *\/ \"having_opt ::=\",\n- \/* 143 *\/ \"having_opt ::= HAVING expr\",\n- \/* 144 *\/ \"limit_opt ::=\",\n- \/* 145 *\/ \"limit_opt ::= LIMIT expr\",\n- \/* 146 *\/ \"limit_opt ::= LIMIT expr OFFSET expr\",\n- \/* 147 *\/ \"limit_opt ::= LIMIT expr COMMA expr\",\n- \/* 148 *\/ \"cmd ::= with DELETE FROM xfullname indexed_opt where_opt\",\n- \/* 149 *\/ \"where_opt ::=\",\n- \/* 150 *\/ \"where_opt ::= WHERE expr\",\n- \/* 151 *\/ \"cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt\",\n- \/* 152 *\/ \"setlist ::= setlist COMMA nm EQ expr\",\n- \/* 153 *\/ \"setlist ::= setlist COMMA LP idlist RP EQ expr\",\n- \/* 154 *\/ \"setlist ::= nm EQ expr\",\n- \/* 155 *\/ \"setlist ::= LP idlist RP EQ expr\",\n- \/* 156 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert\",\n- \/* 157 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES\",\n- \/* 158 *\/ \"upsert ::=\",\n- \/* 159 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt\",\n- \/* 160 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING\",\n- \/* 161 *\/ \"upsert ::= ON CONFLICT DO NOTHING\",\n- \/* 162 *\/ \"insert_cmd ::= INSERT orconf\",\n- \/* 163 *\/ \"insert_cmd ::= REPLACE\",\n- \/* 164 *\/ \"idlist_opt ::=\",\n- \/* 165 *\/ \"idlist_opt ::= LP idlist RP\",\n- \/* 166 *\/ \"idlist ::= idlist COMMA nm\",\n- \/* 167 *\/ \"idlist ::= nm\",\n- \/* 168 *\/ \"expr ::= LP expr RP\",\n- \/* 169 *\/ \"expr ::= ID|INDEXED\",\n- \/* 170 *\/ \"expr ::= JOIN_KW\",\n- \/* 171 *\/ \"expr ::= nm DOT nm\",\n- \/* 172 *\/ \"expr ::= nm DOT nm DOT nm\",\n- \/* 173 *\/ \"term ::= NULL|FLOAT|BLOB\",\n- \/* 174 *\/ \"term ::= STRING\",\n- \/* 175 *\/ \"term ::= INTEGER\",\n- \/* 176 *\/ \"expr ::= VARIABLE\",\n- \/* 177 *\/ \"expr ::= expr COLLATE ID|STRING\",\n- \/* 178 *\/ \"expr ::= CAST LP expr AS typetoken RP\",\n- \/* 179 *\/ \"expr ::= ID|INDEXED LP distinct exprlist RP\",\n- \/* 180 *\/ \"expr ::= ID|INDEXED LP STAR RP\",\n- \/* 181 *\/ \"expr ::= ID|INDEXED LP distinct exprlist RP filter_over\",\n- \/* 182 *\/ \"expr ::= ID|INDEXED LP STAR RP filter_over\",\n- \/* 183 *\/ \"term ::= CTIME_KW\",\n- \/* 184 *\/ \"expr ::= LP nexprlist COMMA expr RP\",\n- \/* 185 *\/ \"expr ::= expr AND expr\",\n- \/* 186 *\/ \"expr ::= expr OR expr\",\n- \/* 187 *\/ \"expr ::= expr LT|GT|GE|LE expr\",\n- \/* 188 *\/ \"expr ::= expr EQ|NE expr\",\n- \/* 189 *\/ \"expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr\",\n- \/* 190 *\/ \"expr ::= expr PLUS|MINUS expr\",\n- \/* 191 *\/ \"expr ::= expr STAR|SLASH|REM expr\",\n- \/* 192 *\/ \"expr ::= expr CONCAT expr\",\n- \/* 193 *\/ \"likeop ::= NOT LIKE_KW|MATCH\",\n- \/* 194 *\/ \"expr ::= expr likeop expr\",\n- \/* 195 *\/ \"expr ::= expr likeop expr ESCAPE expr\",\n- \/* 196 *\/ \"expr ::= expr ISNULL|NOTNULL\",\n- \/* 197 *\/ \"expr ::= expr NOT NULL\",\n- \/* 198 *\/ \"expr ::= expr IS expr\",\n- \/* 199 *\/ \"expr ::= expr IS NOT expr\",\n- \/* 200 *\/ \"expr ::= NOT expr\",\n- \/* 201 *\/ \"expr ::= BITNOT expr\",\n- \/* 202 *\/ \"expr ::= PLUS|MINUS expr\",\n- \/* 203 *\/ \"between_op ::= BETWEEN\",\n- \/* 204 *\/ \"between_op ::= NOT BETWEEN\",\n- \/* 205 *\/ \"expr ::= expr between_op expr AND expr\",\n- \/* 206 *\/ \"in_op ::= IN\",\n- \/* 207 *\/ \"in_op ::= NOT IN\",\n- \/* 208 *\/ \"expr ::= expr in_op LP exprlist RP\",\n- \/* 209 *\/ \"expr ::= LP select RP\",\n- \/* 210 *\/ \"expr ::= expr in_op LP select RP\",\n- \/* 211 *\/ \"expr ::= expr in_op nm dbnm paren_exprlist\",\n- \/* 212 *\/ \"expr ::= EXISTS LP select RP\",\n- \/* 213 *\/ \"expr ::= CASE case_operand case_exprlist case_else END\",\n- \/* 214 *\/ \"case_exprlist ::= case_exprlist WHEN expr THEN expr\",\n- \/* 215 *\/ \"case_exprlist ::= WHEN expr THEN expr\",\n- \/* 216 *\/ \"case_else ::= ELSE expr\",\n- \/* 217 *\/ \"case_else ::=\",\n- \/* 218 *\/ \"case_operand ::= expr\",\n- \/* 219 *\/ \"case_operand ::=\",\n- \/* 220 *\/ \"exprlist ::=\",\n- \/* 221 *\/ \"nexprlist ::= nexprlist COMMA expr\",\n- \/* 222 *\/ \"nexprlist ::= expr\",\n- \/* 223 *\/ \"paren_exprlist ::=\",\n- \/* 224 *\/ \"paren_exprlist ::= LP exprlist RP\",\n- \/* 225 *\/ \"cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt\",\n- \/* 226 *\/ \"uniqueflag ::= UNIQUE\",\n- \/* 227 *\/ \"uniqueflag ::=\",\n- \/* 228 *\/ \"eidlist_opt ::=\",\n- \/* 229 *\/ \"eidlist_opt ::= LP eidlist RP\",\n- \/* 230 *\/ \"eidlist ::= eidlist COMMA nm collate sortorder\",\n- \/* 231 *\/ \"eidlist ::= nm collate sortorder\",\n- \/* 232 *\/ \"collate ::=\",\n- \/* 233 *\/ \"collate ::= COLLATE ID|STRING\",\n- \/* 234 *\/ \"cmd ::= DROP INDEX ifexists fullname\",\n- \/* 235 *\/ \"cmd ::= VACUUM vinto\",\n- \/* 236 *\/ \"cmd ::= VACUUM nm vinto\",\n- \/* 237 *\/ \"vinto ::= INTO expr\",\n- \/* 238 *\/ \"vinto ::=\",\n- \/* 239 *\/ \"cmd ::= PRAGMA nm dbnm\",\n- \/* 240 *\/ \"cmd ::= PRAGMA nm dbnm EQ nmnum\",\n- \/* 241 *\/ \"cmd ::= PRAGMA nm dbnm LP nmnum RP\",\n- \/* 242 *\/ \"cmd ::= PRAGMA nm dbnm EQ minus_num\",\n- \/* 243 *\/ \"cmd ::= PRAGMA nm dbnm LP minus_num RP\",\n- \/* 244 *\/ \"plus_num ::= PLUS INTEGER|FLOAT\",\n- \/* 245 *\/ \"minus_num ::= MINUS INTEGER|FLOAT\",\n- \/* 246 *\/ \"cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END\",\n- \/* 247 *\/ \"trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause\",\n- \/* 248 *\/ \"trigger_time ::= BEFORE|AFTER\",\n- \/* 249 *\/ \"trigger_time ::= INSTEAD OF\",\n- \/* 250 *\/ \"trigger_time ::=\",\n- \/* 251 *\/ \"trigger_event ::= DELETE|INSERT\",\n- \/* 252 *\/ \"trigger_event ::= UPDATE\",\n- \/* 253 *\/ \"trigger_event ::= UPDATE OF idlist\",\n- \/* 254 *\/ \"when_clause ::=\",\n- \/* 255 *\/ \"when_clause ::= WHEN expr\",\n- \/* 256 *\/ \"trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI\",\n- \/* 257 *\/ \"trigger_cmd_list ::= trigger_cmd SEMI\",\n- \/* 258 *\/ \"trnm ::= nm DOT nm\",\n- \/* 259 *\/ \"tridxby ::= INDEXED BY nm\",\n- \/* 260 *\/ \"tridxby ::= NOT INDEXED\",\n- \/* 261 *\/ \"trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt\",\n- \/* 262 *\/ \"trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt\",\n- \/* 263 *\/ \"trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt\",\n- \/* 264 *\/ \"trigger_cmd ::= scanpt select scanpt\",\n- \/* 265 *\/ \"expr ::= RAISE LP IGNORE RP\",\n- \/* 266 *\/ \"expr ::= RAISE LP raisetype COMMA nm RP\",\n- \/* 267 *\/ \"raisetype ::= ROLLBACK\",\n- \/* 268 *\/ \"raisetype ::= ABORT\",\n- \/* 269 *\/ \"raisetype ::= FAIL\",\n- \/* 270 *\/ \"cmd ::= DROP TRIGGER ifexists fullname\",\n- \/* 271 *\/ \"cmd ::= ATTACH database_kw_opt expr AS expr key_opt\",\n- \/* 272 *\/ \"cmd ::= DETACH database_kw_opt expr\",\n- \/* 273 *\/ \"key_opt ::=\",\n- \/* 274 *\/ \"key_opt ::= KEY expr\",\n- \/* 275 *\/ \"cmd ::= REINDEX\",\n- \/* 276 *\/ \"cmd ::= REINDEX nm dbnm\",\n- \/* 277 *\/ \"cmd ::= ANALYZE\",\n- \/* 278 *\/ \"cmd ::= ANALYZE nm dbnm\",\n- \/* 279 *\/ \"cmd ::= ALTER TABLE fullname RENAME TO nm\",\n- \/* 280 *\/ \"cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist\",\n- \/* 281 *\/ \"add_column_fullname ::= fullname\",\n- \/* 282 *\/ \"cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm\",\n- \/* 283 *\/ \"cmd ::= create_vtab\",\n- \/* 284 *\/ \"cmd ::= create_vtab LP vtabarglist RP\",\n- \/* 285 *\/ \"create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm\",\n- \/* 286 *\/ \"vtabarg ::=\",\n- \/* 287 *\/ \"vtabargtoken ::= ANY\",\n- \/* 288 *\/ \"vtabargtoken ::= lp anylist RP\",\n- \/* 289 *\/ \"lp ::= LP\",\n- \/* 290 *\/ \"with ::= WITH wqlist\",\n- \/* 291 *\/ \"with ::= WITH RECURSIVE wqlist\",\n- \/* 292 *\/ \"wqlist ::= nm eidlist_opt AS LP select RP\",\n- \/* 293 *\/ \"wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP\",\n- \/* 294 *\/ \"windowdefn_list ::= windowdefn\",\n- \/* 295 *\/ \"windowdefn_list ::= windowdefn_list COMMA windowdefn\",\n- \/* 296 *\/ \"windowdefn ::= nm AS LP window RP\",\n- \/* 297 *\/ \"window ::= PARTITION BY nexprlist orderby_opt frame_opt\",\n- \/* 298 *\/ \"window ::= nm PARTITION BY nexprlist orderby_opt frame_opt\",\n- \/* 299 *\/ \"window ::= ORDER BY sortlist frame_opt\",\n- \/* 300 *\/ \"window ::= nm ORDER BY sortlist frame_opt\",\n- \/* 301 *\/ \"window ::= frame_opt\",\n- \/* 302 *\/ \"window ::= nm frame_opt\",\n- \/* 303 *\/ \"frame_opt ::=\",\n- \/* 304 *\/ \"frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt\",\n- \/* 305 *\/ \"frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt\",\n- \/* 306 *\/ \"range_or_rows ::= RANGE|ROWS|GROUPS\",\n- \/* 307 *\/ \"frame_bound_s ::= frame_bound\",\n- \/* 308 *\/ \"frame_bound_s ::= UNBOUNDED PRECEDING\",\n- \/* 309 *\/ \"frame_bound_e ::= frame_bound\",\n- \/* 310 *\/ \"frame_bound_e ::= UNBOUNDED FOLLOWING\",\n- \/* 311 *\/ \"frame_bound ::= expr PRECEDING|FOLLOWING\",\n- \/* 312 *\/ \"frame_bound ::= CURRENT ROW\",\n- \/* 313 *\/ \"frame_exclude_opt ::=\",\n- \/* 314 *\/ \"frame_exclude_opt ::= EXCLUDE frame_exclude\",\n- \/* 315 *\/ \"frame_exclude ::= NO OTHERS\",\n- \/* 316 *\/ \"frame_exclude ::= CURRENT ROW\",\n- \/* 317 *\/ \"frame_exclude ::= GROUP|TIES\",\n- \/* 318 *\/ \"window_clause ::= WINDOW windowdefn_list\",\n- \/* 319 *\/ \"filter_over ::= filter_clause over_clause\",\n- \/* 320 *\/ \"filter_over ::= over_clause\",\n- \/* 321 *\/ \"filter_over ::= filter_clause\",\n- \/* 322 *\/ \"over_clause ::= OVER LP window RP\",\n- \/* 323 *\/ \"over_clause ::= OVER nm\",\n- \/* 324 *\/ \"filter_clause ::= FILTER LP WHERE expr RP\",\n- \/* 325 *\/ \"input ::= cmdlist\",\n- \/* 326 *\/ \"cmdlist ::= cmdlist ecmd\",\n- \/* 327 *\/ \"cmdlist ::= ecmd\",\n- \/* 328 *\/ \"ecmd ::= SEMI\",\n- \/* 329 *\/ \"ecmd ::= cmdx SEMI\",\n- \/* 330 *\/ \"ecmd ::= explain cmdx SEMI\",\n- \/* 331 *\/ \"trans_opt ::=\",\n- \/* 332 *\/ \"trans_opt ::= TRANSACTION\",\n- \/* 333 *\/ \"trans_opt ::= TRANSACTION nm\",\n- \/* 334 *\/ \"savepoint_opt ::= SAVEPOINT\",\n- \/* 335 *\/ \"savepoint_opt ::=\",\n- \/* 336 *\/ \"cmd ::= create_table create_table_args\",\n- \/* 337 *\/ \"columnlist ::= columnlist COMMA columnname carglist\",\n- \/* 338 *\/ \"columnlist ::= columnname carglist\",\n- \/* 339 *\/ \"nm ::= ID|INDEXED\",\n- \/* 340 *\/ \"nm ::= STRING\",\n- \/* 341 *\/ \"nm ::= JOIN_KW\",\n- \/* 342 *\/ \"typetoken ::= typename\",\n- \/* 343 *\/ \"typename ::= ID|STRING\",\n- \/* 344 *\/ \"signed ::= plus_num\",\n- \/* 345 *\/ \"signed ::= minus_num\",\n- \/* 346 *\/ \"carglist ::= carglist ccons\",\n- \/* 347 *\/ \"carglist ::=\",\n- \/* 348 *\/ \"ccons ::= NULL onconf\",\n- \/* 349 *\/ \"ccons ::= GENERATED ALWAYS AS generated\",\n- \/* 350 *\/ \"ccons ::= AS generated\",\n- \/* 351 *\/ \"conslist_opt ::= COMMA conslist\",\n- \/* 352 *\/ \"conslist ::= conslist tconscomma tcons\",\n- \/* 353 *\/ \"conslist ::= tcons\",\n- \/* 354 *\/ \"tconscomma ::=\",\n- \/* 355 *\/ \"defer_subclause_opt ::= defer_subclause\",\n- \/* 356 *\/ \"resolvetype ::= raisetype\",\n- \/* 357 *\/ \"selectnowith ::= oneselect\",\n- \/* 358 *\/ \"oneselect ::= values\",\n- \/* 359 *\/ \"sclp ::= selcollist COMMA\",\n- \/* 360 *\/ \"as ::= ID|STRING\",\n- \/* 361 *\/ \"expr ::= term\",\n- \/* 362 *\/ \"likeop ::= LIKE_KW|MATCH\",\n- \/* 363 *\/ \"exprlist ::= nexprlist\",\n- \/* 364 *\/ \"nmnum ::= plus_num\",\n- \/* 365 *\/ \"nmnum ::= nm\",\n- \/* 366 *\/ \"nmnum ::= ON\",\n- \/* 367 *\/ \"nmnum ::= DELETE\",\n- \/* 368 *\/ \"nmnum ::= DEFAULT\",\n- \/* 369 *\/ \"plus_num ::= INTEGER|FLOAT\",\n- \/* 370 *\/ \"foreach_clause ::=\",\n- \/* 371 *\/ \"foreach_clause ::= FOR EACH ROW\",\n- \/* 372 *\/ \"trnm ::= nm\",\n- \/* 373 *\/ \"tridxby ::=\",\n- \/* 374 *\/ \"database_kw_opt ::= DATABASE\",\n- \/* 375 *\/ \"database_kw_opt ::=\",\n- \/* 376 *\/ \"kwcolumn_opt ::=\",\n- \/* 377 *\/ \"kwcolumn_opt ::= COLUMNKW\",\n- \/* 378 *\/ \"vtabarglist ::= vtabarg\",\n- \/* 379 *\/ \"vtabarglist ::= vtabarglist COMMA vtabarg\",\n- \/* 380 *\/ \"vtabarg ::= vtabarg vtabargtoken\",\n- \/* 381 *\/ \"anylist ::=\",\n- \/* 382 *\/ \"anylist ::= anylist LP anylist RP\",\n- \/* 383 *\/ \"anylist ::= anylist ANY\",\n- \/* 384 *\/ \"with ::=\",\n+ \/*  21 *\/ \"table_option_set ::=\",\n+ \/*  22 *\/ \"table_option_set ::= table_option_set COMMA table_option\",\n+ \/*  23 *\/ \"table_option ::= WITHOUT nm\",\n+ \/*  24 *\/ \"table_option ::= nm\",\n+ \/*  25 *\/ \"columnname ::= nm typetoken\",\n+ \/*  26 *\/ \"typetoken ::=\",\n+ \/*  27 *\/ \"typetoken ::= typename LP signed RP\",\n+ \/*  28 *\/ \"typetoken ::= typename LP signed COMMA signed RP\",\n+ \/*  29 *\/ \"typename ::= typename ID|STRING\",\n+ \/*  30 *\/ \"scanpt ::=\",\n+ \/*  31 *\/ \"scantok ::=\",\n+ \/*  32 *\/ \"ccons ::= CONSTRAINT nm\",\n+ \/*  33 *\/ \"ccons ::= DEFAULT scantok term\",\n+ \/*  34 *\/ \"ccons ::= DEFAULT LP expr RP\",\n+ \/*  35 *\/ \"ccons ::= DEFAULT PLUS scantok term\",\n+ \/*  36 *\/ \"ccons ::= DEFAULT MINUS scantok term\",\n+ \/*  37 *\/ \"ccons ::= DEFAULT scantok ID|INDEXED\",\n+ \/*  38 *\/ \"ccons ::= NOT NULL onconf\",\n+ \/*  39 *\/ \"ccons ::= PRIMARY KEY sortorder onconf autoinc\",\n+ \/*  40 *\/ \"ccons ::= UNIQUE onconf\",\n+ \/*  41 *\/ \"ccons ::= CHECK LP expr RP\",\n+ \/*  42 *\/ \"ccons ::= REFERENCES nm eidlist_opt refargs\",\n+ \/*  43 *\/ \"ccons ::= defer_subclause\",\n+ \/*  44 *\/ \"ccons ::= COLLATE ID|STRING\",\n+ \/*  45 *\/ \"generated ::= LP expr RP\",\n+ \/*  46 *\/ \"generated ::= LP expr RP ID\",\n+ \/*  47 *\/ \"autoinc ::=\",\n+ \/*  48 *\/ \"autoinc ::= AUTOINCR\",\n+ \/*  49 *\/ \"refargs ::=\",\n+ \/*  50 *\/ \"refargs ::= refargs refarg\",\n+ \/*  51 *\/ \"refarg ::= MATCH nm\",\n+ \/*  52 *\/ \"refarg ::= ON INSERT refact\",\n+ \/*  53 *\/ \"refarg ::= ON DELETE refact\",\n+ \/*  54 *\/ \"refarg ::= ON UPDATE refact\",\n+ \/*  55 *\/ \"refact ::= SET NULL\",\n+ \/*  56 *\/ \"refact ::= SET DEFAULT\",\n+ \/*  57 *\/ \"refact ::= CASCADE\",\n+ \/*  58 *\/ \"refact ::= RESTRICT\",\n+ \/*  59 *\/ \"refact ::= NO ACTION\",\n+ \/*  60 *\/ \"defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt\",\n+ \/*  61 *\/ \"defer_subclause ::= DEFERRABLE init_deferred_pred_opt\",\n+ \/*  62 *\/ \"init_deferred_pred_opt ::=\",\n+ \/*  63 *\/ \"init_deferred_pred_opt ::= INITIALLY DEFERRED\",\n+ \/*  64 *\/ \"init_deferred_pred_opt ::= INITIALLY IMMEDIATE\",\n+ \/*  65 *\/ \"conslist_opt ::=\",\n+ \/*  66 *\/ \"tconscomma ::= COMMA\",\n+ \/*  67 *\/ \"tcons ::= CONSTRAINT nm\",\n+ \/*  68 *\/ \"tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf\",\n+ \/*  69 *\/ \"tcons ::= UNIQUE LP sortlist RP onconf\",\n+ \/*  70 *\/ \"tcons ::= CHECK LP expr RP onconf\",\n+ \/*  71 *\/ \"tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt\",\n+ \/*  72 *\/ \"defer_subclause_opt ::=\",\n+ \/*  73 *\/ \"onconf ::=\",\n+ \/*  74 *\/ \"onconf ::= ON CONFLICT resolvetype\",\n+ \/*  75 *\/ \"orconf ::=\",\n+ \/*  76 *\/ \"orconf ::= OR resolvetype\",\n+ \/*  77 *\/ \"resolvetype ::= IGNORE\",\n+ \/*  78 *\/ \"resolvetype ::= REPLACE\",\n+ \/*  79 *\/ \"cmd ::= DROP TABLE ifexists fullname\",\n+ \/*  80 *\/ \"ifexists ::= IF EXISTS\",\n+ \/*  81 *\/ \"ifexists ::=\",\n+ \/*  82 *\/ \"cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select\",\n+ \/*  83 *\/ \"cmd ::= DROP VIEW ifexists fullname\",\n+ \/*  84 *\/ \"cmd ::= select\",\n+ \/*  85 *\/ \"select ::= WITH wqlist selectnowith\",\n+ \/*  86 *\/ \"select ::= WITH RECURSIVE wqlist selectnowith\",\n+ \/*  87 *\/ \"select ::= selectnowith\",\n+ \/*  88 *\/ \"selectnowith ::= selectnowith multiselect_op oneselect\",\n+ \/*  89 *\/ \"multiselect_op ::= UNION\",\n+ \/*  90 *\/ \"multiselect_op ::= UNION ALL\",\n+ \/*  91 *\/ \"multiselect_op ::= EXCEPT|INTERSECT\",\n+ \/*  92 *\/ \"oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt\",\n+ \/*  93 *\/ \"oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt\",\n+ \/*  94 *\/ \"values ::= VALUES LP nexprlist RP\",\n+ \/*  95 *\/ \"values ::= values COMMA LP nexprlist RP\",\n+ \/*  96 *\/ \"distinct ::= DISTINCT\",\n+ \/*  97 *\/ \"distinct ::= ALL\",\n+ \/*  98 *\/ \"distinct ::=\",\n+ \/*  99 *\/ \"sclp ::=\",\n+ \/* 100 *\/ \"selcollist ::= sclp scanpt expr scanpt as\",\n+ \/* 101 *\/ \"selcollist ::= sclp scanpt STAR\",\n+ \/* 102 *\/ \"selcollist ::= sclp scanpt nm DOT STAR\",\n+ \/* 103 *\/ \"as ::= AS nm\",\n+ \/* 104 *\/ \"as ::=\",\n+ \/* 105 *\/ \"from ::=\",\n+ \/* 106 *\/ \"from ::= FROM seltablist\",\n+ \/* 107 *\/ \"stl_prefix ::= seltablist joinop\",\n+ \/* 108 *\/ \"stl_prefix ::=\",\n+ \/* 109 *\/ \"seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt\",\n+ \/* 110 *\/ \"seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt\",\n+ \/* 111 *\/ \"seltablist ::= stl_prefix LP select RP as on_opt using_opt\",\n+ \/* 112 *\/ \"seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt\",\n+ \/* 113 *\/ \"dbnm ::=\",\n+ \/* 114 *\/ \"dbnm ::= DOT nm\",\n+ \/* 115 *\/ \"fullname ::= nm\",\n+ \/* 116 *\/ \"fullname ::= nm DOT nm\",\n+ \/* 117 *\/ \"xfullname ::= nm\",\n+ \/* 118 *\/ \"xfullname ::= nm DOT nm\",\n+ \/* 119 *\/ \"xfullname ::= nm DOT nm AS nm\",\n+ \/* 120 *\/ \"xfullname ::= nm AS nm\",\n+ \/* 121 *\/ \"joinop ::= COMMA|JOIN\",\n+ \/* 122 *\/ \"joinop ::= JOIN_KW JOIN\",\n+ \/* 123 *\/ \"joinop ::= JOIN_KW nm JOIN\",\n+ \/* 124 *\/ \"joinop ::= JOIN_KW nm nm JOIN\",\n+ \/* 125 *\/ \"on_opt ::= ON expr\",\n+ \/* 126 *\/ \"on_opt ::=\",\n+ \/* 127 *\/ \"indexed_opt ::=\",\n+ \/* 128 *\/ \"indexed_opt ::= INDEXED BY nm\",\n+ \/* 129 *\/ \"indexed_opt ::= NOT INDEXED\",\n+ \/* 130 *\/ \"using_opt ::= USING LP idlist RP\",\n+ \/* 131 *\/ \"using_opt ::=\",\n+ \/* 132 *\/ \"orderby_opt ::=\",\n+ \/* 133 *\/ \"orderby_opt ::= ORDER BY sortlist\",\n+ \/* 134 *\/ \"sortlist ::= sortlist COMMA expr sortorder nulls\",\n+ \/* 135 *\/ \"sortlist ::= expr sortorder nulls\",\n+ \/* 136 *\/ \"sortorder ::= ASC\",\n+ \/* 137 *\/ \"sortorder ::= DESC\",\n+ \/* 138 *\/ \"sortorder ::=\",\n+ \/* 139 *\/ \"nulls ::= NULLS FIRST\",\n+ \/* 140 *\/ \"nulls ::= NULLS LAST\",\n+ \/* 141 *\/ \"nulls ::=\",\n+ \/* 142 *\/ \"groupby_opt ::=\",\n+ \/* 143 *\/ \"groupby_opt ::= GROUP BY nexprlist\",\n+ \/* 144 *\/ \"having_opt ::=\",\n+ \/* 145 *\/ \"having_opt ::= HAVING expr\",\n+ \/* 146 *\/ \"limit_opt ::=\",\n+ \/* 147 *\/ \"limit_opt ::= LIMIT expr\",\n+ \/* 148 *\/ \"limit_opt ::= LIMIT expr OFFSET expr\",\n+ \/* 149 *\/ \"limit_opt ::= LIMIT expr COMMA expr\",\n+ \/* 150 *\/ \"cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret\",\n+ \/* 151 *\/ \"where_opt ::=\",\n+ \/* 152 *\/ \"where_opt ::= WHERE expr\",\n+ \/* 153 *\/ \"where_opt_ret ::=\",\n+ \/* 154 *\/ \"where_opt_ret ::= WHERE expr\",\n+ \/* 155 *\/ \"where_opt_ret ::= RETURNING selcollist\",\n+ \/* 156 *\/ \"where_opt_ret ::= WHERE expr RETURNING selcollist\",\n+ \/* 157 *\/ \"cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret\",\n+ \/* 158 *\/ \"setlist ::= setlist COMMA nm EQ expr\",\n+ \/* 159 *\/ \"setlist ::= setlist COMMA LP idlist RP EQ expr\",\n+ \/* 160 *\/ \"setlist ::= nm EQ expr\",\n+ \/* 161 *\/ \"setlist ::= LP idlist RP EQ expr\",\n+ \/* 162 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert\",\n+ \/* 163 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning\",\n+ \/* 164 *\/ \"upsert ::=\",\n+ \/* 165 *\/ \"upsert ::= RETURNING selcollist\",\n+ \/* 166 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert\",\n+ \/* 167 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert\",\n+ \/* 168 *\/ \"upsert ::= ON CONFLICT DO NOTHING returning\",\n+ \/* 169 *\/ \"upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning\",\n+ \/* 170 *\/ \"returning ::= RETURNING selcollist\",\n+ \/* 171 *\/ \"insert_cmd ::= INSERT orconf\",\n+ \/* 172 *\/ \"insert_cmd ::= REPLACE\",\n+ \/* 173 *\/ \"idlist_opt ::=\",\n+ \/* 174 *\/ \"idlist_opt ::= LP idlist RP\",\n+ \/* 175 *\/ \"idlist ::= idlist COMMA nm\",\n+ \/* 176 *\/ \"idlist ::= nm\",\n+ \/* 177 *\/ \"expr ::= LP expr RP\",\n+ \/* 178 *\/ \"expr ::= ID|INDEXED\",\n+ \/* 179 *\/ \"expr ::= JOIN_KW\",\n+ \/* 180 *\/ \"expr ::= nm DOT nm\",\n+ \/* 181 *\/ \"expr ::= nm DOT nm DOT nm\",\n+ \/* 182 *\/ \"term ::= NULL|FLOAT|BLOB\",\n+ \/* 183 *\/ \"term ::= STRING\",\n+ \/* 184 *\/ \"term ::= INTEGER\",\n+ \/* 185 *\/ \"expr ::= VARIABLE\",\n+ \/* 186 *\/ \"expr ::= expr COLLATE ID|STRING\",\n+ \/* 187 *\/ \"expr ::= CAST LP expr AS typetoken RP\",\n+ \/* 188 *\/ \"expr ::= ID|INDEXED LP distinct exprlist RP\",\n+ \/* 189 *\/ \"expr ::= ID|INDEXED LP STAR RP\",\n+ \/* 190 *\/ \"expr ::= ID|INDEXED LP distinct exprlist RP filter_over\",\n+ \/* 191 *\/ \"expr ::= ID|INDEXED LP STAR RP filter_over\",\n+ \/* 192 *\/ \"term ::= CTIME_KW\",\n+ \/* 193 *\/ \"expr ::= LP nexprlist COMMA expr RP\",\n+ \/* 194 *\/ \"expr ::= expr AND expr\",\n+ \/* 195 *\/ \"expr ::= expr OR expr\",\n+ \/* 196 *\/ \"expr ::= expr LT|GT|GE|LE expr\",\n+ \/* 197 *\/ \"expr ::= expr EQ|NE expr\",\n+ \/* 198 *\/ \"expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr\",\n+ \/* 199 *\/ \"expr ::= expr PLUS|MINUS expr\",\n+ \/* 200 *\/ \"expr ::= expr STAR|SLASH|REM expr\",\n+ \/* 201 *\/ \"expr ::= expr CONCAT expr\",\n+ \/* 202 *\/ \"likeop ::= NOT LIKE_KW|MATCH\",\n+ \/* 203 *\/ \"expr ::= expr likeop expr\",\n+ \/* 204 *\/ \"expr ::= expr likeop expr ESCAPE expr\",\n+ \/* 205 *\/ \"expr ::= expr ISNULL|NOTNULL\",\n+ \/* 206 *\/ \"expr ::= expr NOT NULL\",\n+ \/* 207 *\/ \"expr ::= expr IS expr\",\n+ \/* 208 *\/ \"expr ::= expr IS NOT expr\",\n+ \/* 209 *\/ \"expr ::= NOT expr\",\n+ \/* 210 *\/ \"expr ::= BITNOT expr\",\n+ \/* 211 *\/ \"expr ::= PLUS|MINUS expr\",\n+ \/* 212 *\/ \"between_op ::= BETWEEN\",\n+ \/* 213 *\/ \"between_op ::= NOT BETWEEN\",\n+ \/* 214 *\/ \"expr ::= expr between_op expr AND expr\",\n+ \/* 215 *\/ \"in_op ::= IN\",\n+ \/* 216 *\/ \"in_op ::= NOT IN\",\n+ \/* 217 *\/ \"expr ::= expr in_op LP exprlist RP\",\n+ \/* 218 *\/ \"expr ::= LP select RP\",\n+ \/* 219 *\/ \"expr ::= expr in_op LP select RP\",\n+ \/* 220 *\/ \"expr ::= expr in_op nm dbnm paren_exprlist\",\n+ \/* 221 *\/ \"expr ::= EXISTS LP select RP\",\n+ \/* 222 *\/ \"expr ::= CASE case_operand case_exprlist case_else END\",\n+ \/* 223 *\/ \"case_exprlist ::= case_exprlist WHEN expr THEN expr\",\n+ \/* 224 *\/ \"case_exprlist ::= WHEN expr THEN expr\",\n+ \/* 225 *\/ \"case_else ::= ELSE expr\",\n+ \/* 226 *\/ \"case_else ::=\",\n+ \/* 227 *\/ \"case_operand ::= expr\",\n+ \/* 228 *\/ \"case_operand ::=\",\n+ \/* 229 *\/ \"exprlist ::=\",\n+ \/* 230 *\/ \"nexprlist ::= nexprlist COMMA expr\",\n+ \/* 231 *\/ \"nexprlist ::= expr\",\n+ \/* 232 *\/ \"paren_exprlist ::=\",\n+ \/* 233 *\/ \"paren_exprlist ::= LP exprlist RP\",\n+ \/* 234 *\/ \"cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt\",\n+ \/* 235 *\/ \"uniqueflag ::= UNIQUE\",\n+ \/* 236 *\/ \"uniqueflag ::=\",\n+ \/* 237 *\/ \"eidlist_opt ::=\",\n+ \/* 238 *\/ \"eidlist_opt ::= LP eidlist RP\",\n+ \/* 239 *\/ \"eidlist ::= eidlist COMMA nm collate sortorder\",\n+ \/* 240 *\/ \"eidlist ::= nm collate sortorder\",\n+ \/* 241 *\/ \"collate ::=\",\n+ \/* 242 *\/ \"collate ::= COLLATE ID|STRING\",\n+ \/* 243 *\/ \"cmd ::= DROP INDEX ifexists fullname\",\n+ \/* 244 *\/ \"cmd ::= VACUUM vinto\",\n+ \/* 245 *\/ \"cmd ::= VACUUM nm vinto\",\n+ \/* 246 *\/ \"vinto ::= INTO expr\",\n+ \/* 247 *\/ \"vinto ::=\",\n+ \/* 248 *\/ \"cmd ::= PRAGMA nm dbnm\",\n+ \/* 249 *\/ \"cmd ::= PRAGMA nm dbnm EQ nmnum\",\n+ \/* 250 *\/ \"cmd ::= PRAGMA nm dbnm LP nmnum RP\",\n+ \/* 251 *\/ \"cmd ::= PRAGMA nm dbnm EQ minus_num\",\n+ \/* 252 *\/ \"cmd ::= PRAGMA nm dbnm LP minus_num RP\",\n+ \/* 253 *\/ \"plus_num ::= PLUS INTEGER|FLOAT\",\n+ \/* 254 *\/ \"minus_num ::= MINUS INTEGER|FLOAT\",\n+ \/* 255 *\/ \"cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END\",\n+ \/* 256 *\/ \"trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause\",\n+ \/* 257 *\/ \"trigger_time ::= BEFORE|AFTER\",\n+ \/* 258 *\/ \"trigger_time ::= INSTEAD OF\",\n+ \/* 259 *\/ \"trigger_time ::=\",\n+ \/* 260 *\/ \"trigger_event ::= DELETE|INSERT\",\n+ \/* 261 *\/ \"trigger_event ::= UPDATE\",\n+ \/* 262 *\/ \"trigger_event ::= UPDATE OF idlist\",\n+ \/* 263 *\/ \"when_clause ::=\",\n+ \/* 264 *\/ \"when_clause ::= WHEN expr\",\n+ \/* 265 *\/ \"trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI\",\n+ \/* 266 *\/ \"trigger_cmd_list ::= trigger_cmd SEMI\",\n+ \/* 267 *\/ \"trnm ::= nm DOT nm\",\n+ \/* 268 *\/ \"tridxby ::= INDEXED BY nm\",\n+ \/* 269 *\/ \"tridxby ::= NOT INDEXED\",\n+ \/* 270 *\/ \"trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt\",\n+ \/* 271 *\/ \"trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt\",\n+ \/* 272 *\/ \"trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt\",\n+ \/* 273 *\/ \"trigger_cmd ::= scanpt select scanpt\",\n+ \/* 274 *\/ \"expr ::= RAISE LP IGNORE RP\",\n+ \/* 275 *\/ \"expr ::= RAISE LP raisetype COMMA nm RP\",\n+ \/* 276 *\/ \"raisetype ::= ROLLBACK\",\n+ \/* 277 *\/ \"raisetype ::= ABORT\",\n+ \/* 278 *\/ \"raisetype ::= FAIL\",\n+ \/* 279 *\/ \"cmd ::= DROP TRIGGER ifexists fullname\",\n+ \/* 280 *\/ \"cmd ::= ATTACH database_kw_opt expr AS expr key_opt\",\n+ \/* 281 *\/ \"cmd ::= DETACH database_kw_opt expr\",\n+ \/* 282 *\/ \"key_opt ::=\",\n+ \/* 283 *\/ \"key_opt ::= KEY expr\",\n+ \/* 284 *\/ \"cmd ::= REINDEX\",\n+ \/* 285 *\/ \"cmd ::= REINDEX nm dbnm\",\n+ \/* 286 *\/ \"cmd ::= ANALYZE\",\n+ \/* 287 *\/ \"cmd ::= ANALYZE nm dbnm\",\n+ \/* 288 *\/ \"cmd ::= ALTER TABLE fullname RENAME TO nm\",\n+ \/* 289 *\/ \"cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist\",\n+ \/* 290 *\/ \"cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm\",\n+ \/* 291 *\/ \"add_column_fullname ::= fullname\",\n+ \/* 292 *\/ \"cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm\",\n+ \/* 293 *\/ \"cmd ::= create_vtab\",\n+ \/* 294 *\/ \"cmd ::= create_vtab LP vtabarglist RP\",\n+ \/* 295 *\/ \"create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm\",\n+ \/* 296 *\/ \"vtabarg ::=\",\n+ \/* 297 *\/ \"vtabargtoken ::= ANY\",\n+ \/* 298 *\/ \"vtabargtoken ::= lp anylist RP\",\n+ \/* 299 *\/ \"lp ::= LP\",\n+ \/* 300 *\/ \"with ::= WITH wqlist\",\n+ \/* 301 *\/ \"with ::= WITH RECURSIVE wqlist\",\n+ \/* 302 *\/ \"wqas ::= AS\",\n+ \/* 303 *\/ \"wqas ::= AS MATERIALIZED\",\n+ \/* 304 *\/ \"wqas ::= AS NOT MATERIALIZED\",\n+ \/* 305 *\/ \"wqitem ::= nm eidlist_opt wqas LP select RP\",\n+ \/* 306 *\/ \"wqlist ::= wqitem\",\n+ \/* 307 *\/ \"wqlist ::= wqlist COMMA wqitem\",\n+ \/* 308 *\/ \"windowdefn_list ::= windowdefn\",\n+ \/* 309 *\/ \"windowdefn_list ::= windowdefn_list COMMA windowdefn\",\n+ \/* 310 *\/ \"windowdefn ::= nm AS LP window RP\",\n+ \/* 311 *\/ \"window ::= PARTITION BY nexprlist orderby_opt frame_opt\",\n+ \/* 312 *\/ \"window ::= nm PARTITION BY nexprlist orderby_opt frame_opt\",\n+ \/* 313 *\/ \"window ::= ORDER BY sortlist frame_opt\",\n+ \/* 314 *\/ \"window ::= nm ORDER BY sortlist frame_opt\",\n+ \/* 315 *\/ \"window ::= frame_opt\",\n+ \/* 316 *\/ \"window ::= nm frame_opt\",\n+ \/* 317 *\/ \"frame_opt ::=\",\n+ \/* 318 *\/ \"frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt\",\n+ \/* 319 *\/ \"frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt\",\n+ \/* 320 *\/ \"range_or_rows ::= RANGE|ROWS|GROUPS\",\n+ \/* 321 *\/ \"frame_bound_s ::= frame_bound\",\n+ \/* 322 *\/ \"frame_bound_s ::= UNBOUNDED PRECEDING\",\n+ \/* 323 *\/ \"frame_bound_e ::= frame_bound\",\n+ \/* 324 *\/ \"frame_bound_e ::= UNBOUNDED FOLLOWING\",\n+ \/* 325 *\/ \"frame_bound ::= expr PRECEDING|FOLLOWING\",\n+ \/* 326 *\/ \"frame_bound ::= CURRENT ROW\",\n+ \/* 327 *\/ \"frame_exclude_opt ::=\",\n+ \/* 328 *\/ \"frame_exclude_opt ::= EXCLUDE frame_exclude\",\n+ \/* 329 *\/ \"frame_exclude ::= NO OTHERS\",\n+ \/* 330 *\/ \"frame_exclude ::= CURRENT ROW\",\n+ \/* 331 *\/ \"frame_exclude ::= GROUP|TIES\",\n+ \/* 332 *\/ \"window_clause ::= WINDOW windowdefn_list\",\n+ \/* 333 *\/ \"filter_over ::= filter_clause over_clause\",\n+ \/* 334 *\/ \"filter_over ::= over_clause\",\n+ \/* 335 *\/ \"filter_over ::= filter_clause\",\n+ \/* 336 *\/ \"over_clause ::= OVER LP window RP\",\n+ \/* 337 *\/ \"over_clause ::= OVER nm\",\n+ \/* 338 *\/ \"filter_clause ::= FILTER LP WHERE expr RP\",\n+ \/* 339 *\/ \"input ::= cmdlist\",\n+ \/* 340 *\/ \"cmdlist ::= cmdlist ecmd\",\n+ \/* 341 *\/ \"cmdlist ::= ecmd\",\n+ \/* 342 *\/ \"ecmd ::= SEMI\",\n+ \/* 343 *\/ \"ecmd ::= cmdx SEMI\",\n+ \/* 344 *\/ \"ecmd ::= explain cmdx SEMI\",\n+ \/* 345 *\/ \"trans_opt ::=\",\n+ \/* 346 *\/ \"trans_opt ::= TRANSACTION\",\n+ \/* 347 *\/ \"trans_opt ::= TRANSACTION nm\",\n+ \/* 348 *\/ \"savepoint_opt ::= SAVEPOINT\",\n+ \/* 349 *\/ \"savepoint_opt ::=\",\n+ \/* 350 *\/ \"cmd ::= create_table create_table_args\",\n+ \/* 351 *\/ \"table_option_set ::= table_option\",\n+ \/* 352 *\/ \"columnlist ::= columnlist COMMA columnname carglist\",\n+ \/* 353 *\/ \"columnlist ::= columnname carglist\",\n+ \/* 354 *\/ \"nm ::= ID|INDEXED\",\n+ \/* 355 *\/ \"nm ::= STRING\",\n+ \/* 356 *\/ \"nm ::= JOIN_KW\",\n+ \/* 357 *\/ \"typetoken ::= typename\",\n+ \/* 358 *\/ \"typename ::= ID|STRING\",\n+ \/* 359 *\/ \"signed ::= plus_num\",\n+ \/* 360 *\/ \"signed ::= minus_num\",\n+ \/* 361 *\/ \"carglist ::= carglist ccons\",\n+ \/* 362 *\/ \"carglist ::=\",\n+ \/* 363 *\/ \"ccons ::= NULL onconf\",\n+ \/* 364 *\/ \"ccons ::= GENERATED ALWAYS AS generated\",\n+ \/* 365 *\/ \"ccons ::= AS generated\",\n+ \/* 366 *\/ \"conslist_opt ::= COMMA conslist\",\n+ \/* 367 *\/ \"conslist ::= conslist tconscomma tcons\",\n+ \/* 368 *\/ \"conslist ::= tcons\",\n+ \/* 369 *\/ \"tconscomma ::=\",\n+ \/* 370 *\/ \"defer_subclause_opt ::= defer_subclause\",\n+ \/* 371 *\/ \"resolvetype ::= raisetype\",\n+ \/* 372 *\/ \"selectnowith ::= oneselect\",\n+ \/* 373 *\/ \"oneselect ::= values\",\n+ \/* 374 *\/ \"sclp ::= selcollist COMMA\",\n+ \/* 375 *\/ \"as ::= ID|STRING\",\n+ \/* 376 *\/ \"returning ::=\",\n+ \/* 377 *\/ \"expr ::= term\",\n+ \/* 378 *\/ \"likeop ::= LIKE_KW|MATCH\",\n+ \/* 379 *\/ \"exprlist ::= nexprlist\",\n+ \/* 380 *\/ \"nmnum ::= plus_num\",\n+ \/* 381 *\/ \"nmnum ::= nm\",\n+ \/* 382 *\/ \"nmnum ::= ON\",\n+ \/* 383 *\/ \"nmnum ::= DELETE\",\n+ \/* 384 *\/ \"nmnum ::= DEFAULT\",\n+ \/* 385 *\/ \"plus_num ::= INTEGER|FLOAT\",\n+ \/* 386 *\/ \"foreach_clause ::=\",\n+ \/* 387 *\/ \"foreach_clause ::= FOR EACH ROW\",\n+ \/* 388 *\/ \"trnm ::= nm\",\n+ \/* 389 *\/ \"tridxby ::=\",\n+ \/* 390 *\/ \"database_kw_opt ::= DATABASE\",\n+ \/* 391 *\/ \"database_kw_opt ::=\",\n+ \/* 392 *\/ \"kwcolumn_opt ::=\",\n+ \/* 393 *\/ \"kwcolumn_opt ::= COLUMNKW\",\n+ \/* 394 *\/ \"vtabarglist ::= vtabarg\",\n+ \/* 395 *\/ \"vtabarglist ::= vtabarglist COMMA vtabarg\",\n+ \/* 396 *\/ \"vtabarg ::= vtabarg vtabargtoken\",\n+ \/* 397 *\/ \"anylist ::=\",\n+ \/* 398 *\/ \"anylist ::= anylist LP anylist RP\",\n+ \/* 399 *\/ \"anylist ::= anylist ANY\",\n+ \/* 400 *\/ \"with ::=\",\n@@ -155627,4 +161798,4 @@\n-    case 200: \/* select *\/\n-    case 234: \/* selectnowith *\/\n-    case 235: \/* oneselect *\/\n-    case 247: \/* values *\/\n+    case 203: \/* select *\/\n+    case 238: \/* selectnowith *\/\n+    case 239: \/* oneselect *\/\n+    case 251: \/* values *\/\n@@ -155632,14 +161803,15 @@\n-sqlite3SelectDelete(pParse->db, (yypminor->yy539));\n-}\n-      break;\n-    case 211: \/* term *\/\n-    case 212: \/* expr *\/\n-    case 241: \/* where_opt *\/\n-    case 243: \/* having_opt *\/\n-    case 255: \/* on_opt *\/\n-    case 271: \/* case_operand *\/\n-    case 273: \/* case_else *\/\n-    case 276: \/* vinto *\/\n-    case 283: \/* when_clause *\/\n-    case 288: \/* key_opt *\/\n-    case 302: \/* filter_clause *\/\n+sqlite3SelectDelete(pParse->db, (yypminor->yy303));\n+}\n+      break;\n+    case 215: \/* term *\/\n+    case 216: \/* expr *\/\n+    case 245: \/* where_opt *\/\n+    case 247: \/* having_opt *\/\n+    case 259: \/* on_opt *\/\n+    case 266: \/* where_opt_ret *\/\n+    case 277: \/* case_operand *\/\n+    case 279: \/* case_else *\/\n+    case 282: \/* vinto *\/\n+    case 289: \/* when_clause *\/\n+    case 294: \/* key_opt *\/\n+    case 310: \/* filter_clause *\/\n@@ -155647,16 +161819,16 @@\n-sqlite3ExprDelete(pParse->db, (yypminor->yy202));\n-}\n-      break;\n-    case 216: \/* eidlist_opt *\/\n-    case 226: \/* sortlist *\/\n-    case 227: \/* eidlist *\/\n-    case 239: \/* selcollist *\/\n-    case 242: \/* groupby_opt *\/\n-    case 244: \/* orderby_opt *\/\n-    case 248: \/* nexprlist *\/\n-    case 249: \/* sclp *\/\n-    case 257: \/* exprlist *\/\n-    case 262: \/* setlist *\/\n-    case 270: \/* paren_exprlist *\/\n-    case 272: \/* case_exprlist *\/\n-    case 301: \/* part_opt *\/\n+sqlite3ExprDelete(pParse->db, (yypminor->yy626));\n+}\n+      break;\n+    case 220: \/* eidlist_opt *\/\n+    case 230: \/* sortlist *\/\n+    case 231: \/* eidlist *\/\n+    case 243: \/* selcollist *\/\n+    case 246: \/* groupby_opt *\/\n+    case 248: \/* orderby_opt *\/\n+    case 252: \/* nexprlist *\/\n+    case 253: \/* sclp *\/\n+    case 261: \/* exprlist *\/\n+    case 267: \/* setlist *\/\n+    case 276: \/* paren_exprlist *\/\n+    case 278: \/* case_exprlist *\/\n+    case 309: \/* part_opt *\/\n@@ -155664,1 +161836,1 @@\n-sqlite3ExprListDelete(pParse->db, (yypminor->yy242));\n+sqlite3ExprListDelete(pParse->db, (yypminor->yy562));\n@@ -155667,5 +161839,5 @@\n-    case 233: \/* fullname *\/\n-    case 240: \/* from *\/\n-    case 251: \/* seltablist *\/\n-    case 252: \/* stl_prefix *\/\n-    case 258: \/* xfullname *\/\n+    case 237: \/* fullname *\/\n+    case 244: \/* from *\/\n+    case 255: \/* seltablist *\/\n+    case 256: \/* stl_prefix *\/\n+    case 262: \/* xfullname *\/\n@@ -155673,1 +161845,1 @@\n-sqlite3SrcListDelete(pParse->db, (yypminor->yy47));\n+sqlite3SrcListDelete(pParse->db, (yypminor->yy607));\n@@ -155676,1 +161848,1 @@\n-    case 236: \/* wqlist *\/\n+    case 240: \/* wqlist *\/\n@@ -155678,1 +161850,1 @@\n-sqlite3WithDelete(pParse->db, (yypminor->yy131));\n+sqlite3WithDelete(pParse->db, (yypminor->yy43));\n@@ -155681,2 +161853,2 @@\n-    case 246: \/* window_clause *\/\n-    case 297: \/* windowdefn_list *\/\n+    case 250: \/* window_clause *\/\n+    case 305: \/* windowdefn_list *\/\n@@ -155684,1 +161856,1 @@\n-sqlite3WindowListDelete(pParse->db, (yypminor->yy303));\n+sqlite3WindowListDelete(pParse->db, (yypminor->yy375));\n@@ -155687,3 +161859,3 @@\n-    case 256: \/* using_opt *\/\n-    case 259: \/* idlist *\/\n-    case 264: \/* idlist_opt *\/\n+    case 260: \/* using_opt *\/\n+    case 263: \/* idlist *\/\n+    case 269: \/* idlist_opt *\/\n@@ -155691,1 +161863,1 @@\n-sqlite3IdListDelete(pParse->db, (yypminor->yy600));\n+sqlite3IdListDelete(pParse->db, (yypminor->yy240));\n@@ -155694,5 +161866,5 @@\n-    case 266: \/* filter_over *\/\n-    case 298: \/* windowdefn *\/\n-    case 299: \/* window *\/\n-    case 300: \/* frame_opt *\/\n-    case 303: \/* over_clause *\/\n+    case 272: \/* filter_over *\/\n+    case 306: \/* windowdefn *\/\n+    case 307: \/* window *\/\n+    case 308: \/* frame_opt *\/\n+    case 311: \/* over_clause *\/\n@@ -155700,1 +161872,1 @@\n-sqlite3WindowDelete(pParse->db, (yypminor->yy303));\n+sqlite3WindowDelete(pParse->db, (yypminor->yy375));\n@@ -155703,2 +161875,2 @@\n-    case 279: \/* trigger_cmd_list *\/\n-    case 284: \/* trigger_cmd *\/\n+    case 285: \/* trigger_cmd_list *\/\n+    case 290: \/* trigger_cmd *\/\n@@ -155706,1 +161878,1 @@\n-sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy447));\n+sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy95));\n@@ -155709,1 +161881,1 @@\n-    case 281: \/* trigger_event *\/\n+    case 287: \/* trigger_event *\/\n@@ -155711,1 +161883,1 @@\n-sqlite3IdListDelete(pParse->db, (yypminor->yy230).b);\n+sqlite3IdListDelete(pParse->db, (yypminor->yy570).b);\n@@ -155714,3 +161886,3 @@\n-    case 305: \/* frame_bound *\/\n-    case 306: \/* frame_bound_s *\/\n-    case 307: \/* frame_bound_e *\/\n+    case 313: \/* frame_bound *\/\n+    case 314: \/* frame_bound_s *\/\n+    case 315: \/* frame_bound_e *\/\n@@ -155718,1 +161890,1 @@\n-sqlite3ExprDelete(pParse->db, (yypminor->yy77).pExpr);\n+sqlite3ExprDelete(pParse->db, (yypminor->yy81).pExpr);\n@@ -155885,1 +162057,1 @@\n-      assert( i>=0 && i<sizeof(yy_action)\/sizeof(yy_action[0]) );\n+      assert( i>=0 && i<(int)(sizeof(yy_action)\/sizeof(yy_action[0])) );\n@@ -156009,385 +162181,401 @@\n-   185,  \/* (0) explain ::= EXPLAIN *\/\n-   185,  \/* (1) explain ::= EXPLAIN QUERY PLAN *\/\n-   184,  \/* (2) cmdx ::= cmd *\/\n-   186,  \/* (3) cmd ::= BEGIN transtype trans_opt *\/\n-   187,  \/* (4) transtype ::= *\/\n-   187,  \/* (5) transtype ::= DEFERRED *\/\n-   187,  \/* (6) transtype ::= IMMEDIATE *\/\n-   187,  \/* (7) transtype ::= EXCLUSIVE *\/\n-   186,  \/* (8) cmd ::= COMMIT|END trans_opt *\/\n-   186,  \/* (9) cmd ::= ROLLBACK trans_opt *\/\n-   186,  \/* (10) cmd ::= SAVEPOINT nm *\/\n-   186,  \/* (11) cmd ::= RELEASE savepoint_opt nm *\/\n-   186,  \/* (12) cmd ::= ROLLBACK trans_opt TO savepoint_opt nm *\/\n-   191,  \/* (13) create_table ::= createkw temp TABLE ifnotexists nm dbnm *\/\n-   193,  \/* (14) createkw ::= CREATE *\/\n-   195,  \/* (15) ifnotexists ::= *\/\n-   195,  \/* (16) ifnotexists ::= IF NOT EXISTS *\/\n-   194,  \/* (17) temp ::= TEMP *\/\n-   194,  \/* (18) temp ::= *\/\n-   192,  \/* (19) create_table_args ::= LP columnlist conslist_opt RP table_options *\/\n-   192,  \/* (20) create_table_args ::= AS select *\/\n-   199,  \/* (21) table_options ::= *\/\n-   199,  \/* (22) table_options ::= WITHOUT nm *\/\n-   201,  \/* (23) columnname ::= nm typetoken *\/\n-   203,  \/* (24) typetoken ::= *\/\n-   203,  \/* (25) typetoken ::= typename LP signed RP *\/\n-   203,  \/* (26) typetoken ::= typename LP signed COMMA signed RP *\/\n-   204,  \/* (27) typename ::= typename ID|STRING *\/\n-   208,  \/* (28) scanpt ::= *\/\n-   209,  \/* (29) scantok ::= *\/\n-   210,  \/* (30) ccons ::= CONSTRAINT nm *\/\n-   210,  \/* (31) ccons ::= DEFAULT scantok term *\/\n-   210,  \/* (32) ccons ::= DEFAULT LP expr RP *\/\n-   210,  \/* (33) ccons ::= DEFAULT PLUS scantok term *\/\n-   210,  \/* (34) ccons ::= DEFAULT MINUS scantok term *\/\n-   210,  \/* (35) ccons ::= DEFAULT scantok ID|INDEXED *\/\n-   210,  \/* (36) ccons ::= NOT NULL onconf *\/\n-   210,  \/* (37) ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n-   210,  \/* (38) ccons ::= UNIQUE onconf *\/\n-   210,  \/* (39) ccons ::= CHECK LP expr RP *\/\n-   210,  \/* (40) ccons ::= REFERENCES nm eidlist_opt refargs *\/\n-   210,  \/* (41) ccons ::= defer_subclause *\/\n-   210,  \/* (42) ccons ::= COLLATE ID|STRING *\/\n-   219,  \/* (43) generated ::= LP expr RP *\/\n-   219,  \/* (44) generated ::= LP expr RP ID *\/\n-   215,  \/* (45) autoinc ::= *\/\n-   215,  \/* (46) autoinc ::= AUTOINCR *\/\n-   217,  \/* (47) refargs ::= *\/\n-   217,  \/* (48) refargs ::= refargs refarg *\/\n-   220,  \/* (49) refarg ::= MATCH nm *\/\n-   220,  \/* (50) refarg ::= ON INSERT refact *\/\n-   220,  \/* (51) refarg ::= ON DELETE refact *\/\n-   220,  \/* (52) refarg ::= ON UPDATE refact *\/\n-   221,  \/* (53) refact ::= SET NULL *\/\n-   221,  \/* (54) refact ::= SET DEFAULT *\/\n-   221,  \/* (55) refact ::= CASCADE *\/\n-   221,  \/* (56) refact ::= RESTRICT *\/\n-   221,  \/* (57) refact ::= NO ACTION *\/\n-   218,  \/* (58) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n-   218,  \/* (59) defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n-   222,  \/* (60) init_deferred_pred_opt ::= *\/\n-   222,  \/* (61) init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n-   222,  \/* (62) init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n-   198,  \/* (63) conslist_opt ::= *\/\n-   224,  \/* (64) tconscomma ::= COMMA *\/\n-   225,  \/* (65) tcons ::= CONSTRAINT nm *\/\n-   225,  \/* (66) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n-   225,  \/* (67) tcons ::= UNIQUE LP sortlist RP onconf *\/\n-   225,  \/* (68) tcons ::= CHECK LP expr RP onconf *\/\n-   225,  \/* (69) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n-   228,  \/* (70) defer_subclause_opt ::= *\/\n-   213,  \/* (71) onconf ::= *\/\n-   213,  \/* (72) onconf ::= ON CONFLICT resolvetype *\/\n-   229,  \/* (73) orconf ::= *\/\n-   229,  \/* (74) orconf ::= OR resolvetype *\/\n-   230,  \/* (75) resolvetype ::= IGNORE *\/\n-   230,  \/* (76) resolvetype ::= REPLACE *\/\n-   186,  \/* (77) cmd ::= DROP TABLE ifexists fullname *\/\n-   232,  \/* (78) ifexists ::= IF EXISTS *\/\n-   232,  \/* (79) ifexists ::= *\/\n-   186,  \/* (80) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n-   186,  \/* (81) cmd ::= DROP VIEW ifexists fullname *\/\n-   186,  \/* (82) cmd ::= select *\/\n-   200,  \/* (83) select ::= WITH wqlist selectnowith *\/\n-   200,  \/* (84) select ::= WITH RECURSIVE wqlist selectnowith *\/\n-   200,  \/* (85) select ::= selectnowith *\/\n-   234,  \/* (86) selectnowith ::= selectnowith multiselect_op oneselect *\/\n-   237,  \/* (87) multiselect_op ::= UNION *\/\n-   237,  \/* (88) multiselect_op ::= UNION ALL *\/\n-   237,  \/* (89) multiselect_op ::= EXCEPT|INTERSECT *\/\n-   235,  \/* (90) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n-   235,  \/* (91) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n-   247,  \/* (92) values ::= VALUES LP nexprlist RP *\/\n-   247,  \/* (93) values ::= values COMMA LP nexprlist RP *\/\n-   238,  \/* (94) distinct ::= DISTINCT *\/\n-   238,  \/* (95) distinct ::= ALL *\/\n-   238,  \/* (96) distinct ::= *\/\n-   249,  \/* (97) sclp ::= *\/\n-   239,  \/* (98) selcollist ::= sclp scanpt expr scanpt as *\/\n-   239,  \/* (99) selcollist ::= sclp scanpt STAR *\/\n-   239,  \/* (100) selcollist ::= sclp scanpt nm DOT STAR *\/\n-   250,  \/* (101) as ::= AS nm *\/\n-   250,  \/* (102) as ::= *\/\n-   240,  \/* (103) from ::= *\/\n-   240,  \/* (104) from ::= FROM seltablist *\/\n-   252,  \/* (105) stl_prefix ::= seltablist joinop *\/\n-   252,  \/* (106) stl_prefix ::= *\/\n-   251,  \/* (107) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt *\/\n-   251,  \/* (108) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt *\/\n-   251,  \/* (109) seltablist ::= stl_prefix LP select RP as on_opt using_opt *\/\n-   251,  \/* (110) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt *\/\n-   196,  \/* (111) dbnm ::= *\/\n-   196,  \/* (112) dbnm ::= DOT nm *\/\n-   233,  \/* (113) fullname ::= nm *\/\n-   233,  \/* (114) fullname ::= nm DOT nm *\/\n-   258,  \/* (115) xfullname ::= nm *\/\n-   258,  \/* (116) xfullname ::= nm DOT nm *\/\n-   258,  \/* (117) xfullname ::= nm DOT nm AS nm *\/\n-   258,  \/* (118) xfullname ::= nm AS nm *\/\n-   253,  \/* (119) joinop ::= COMMA|JOIN *\/\n-   253,  \/* (120) joinop ::= JOIN_KW JOIN *\/\n-   253,  \/* (121) joinop ::= JOIN_KW nm JOIN *\/\n-   253,  \/* (122) joinop ::= JOIN_KW nm nm JOIN *\/\n-   255,  \/* (123) on_opt ::= ON expr *\/\n-   255,  \/* (124) on_opt ::= *\/\n-   254,  \/* (125) indexed_opt ::= *\/\n-   254,  \/* (126) indexed_opt ::= INDEXED BY nm *\/\n-   254,  \/* (127) indexed_opt ::= NOT INDEXED *\/\n-   256,  \/* (128) using_opt ::= USING LP idlist RP *\/\n-   256,  \/* (129) using_opt ::= *\/\n-   244,  \/* (130) orderby_opt ::= *\/\n-   244,  \/* (131) orderby_opt ::= ORDER BY sortlist *\/\n-   226,  \/* (132) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n-   226,  \/* (133) sortlist ::= expr sortorder nulls *\/\n-   214,  \/* (134) sortorder ::= ASC *\/\n-   214,  \/* (135) sortorder ::= DESC *\/\n-   214,  \/* (136) sortorder ::= *\/\n-   260,  \/* (137) nulls ::= NULLS FIRST *\/\n-   260,  \/* (138) nulls ::= NULLS LAST *\/\n-   260,  \/* (139) nulls ::= *\/\n-   242,  \/* (140) groupby_opt ::= *\/\n-   242,  \/* (141) groupby_opt ::= GROUP BY nexprlist *\/\n-   243,  \/* (142) having_opt ::= *\/\n-   243,  \/* (143) having_opt ::= HAVING expr *\/\n-   245,  \/* (144) limit_opt ::= *\/\n-   245,  \/* (145) limit_opt ::= LIMIT expr *\/\n-   245,  \/* (146) limit_opt ::= LIMIT expr OFFSET expr *\/\n-   245,  \/* (147) limit_opt ::= LIMIT expr COMMA expr *\/\n-   186,  \/* (148) cmd ::= with DELETE FROM xfullname indexed_opt where_opt *\/\n-   241,  \/* (149) where_opt ::= *\/\n-   241,  \/* (150) where_opt ::= WHERE expr *\/\n-   186,  \/* (151) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt *\/\n-   262,  \/* (152) setlist ::= setlist COMMA nm EQ expr *\/\n-   262,  \/* (153) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n-   262,  \/* (154) setlist ::= nm EQ expr *\/\n-   262,  \/* (155) setlist ::= LP idlist RP EQ expr *\/\n-   186,  \/* (156) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n-   186,  \/* (157) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES *\/\n-   265,  \/* (158) upsert ::= *\/\n-   265,  \/* (159) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt *\/\n-   265,  \/* (160) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING *\/\n-   265,  \/* (161) upsert ::= ON CONFLICT DO NOTHING *\/\n-   263,  \/* (162) insert_cmd ::= INSERT orconf *\/\n-   263,  \/* (163) insert_cmd ::= REPLACE *\/\n-   264,  \/* (164) idlist_opt ::= *\/\n-   264,  \/* (165) idlist_opt ::= LP idlist RP *\/\n-   259,  \/* (166) idlist ::= idlist COMMA nm *\/\n-   259,  \/* (167) idlist ::= nm *\/\n-   212,  \/* (168) expr ::= LP expr RP *\/\n-   212,  \/* (169) expr ::= ID|INDEXED *\/\n-   212,  \/* (170) expr ::= JOIN_KW *\/\n-   212,  \/* (171) expr ::= nm DOT nm *\/\n-   212,  \/* (172) expr ::= nm DOT nm DOT nm *\/\n-   211,  \/* (173) term ::= NULL|FLOAT|BLOB *\/\n-   211,  \/* (174) term ::= STRING *\/\n-   211,  \/* (175) term ::= INTEGER *\/\n-   212,  \/* (176) expr ::= VARIABLE *\/\n-   212,  \/* (177) expr ::= expr COLLATE ID|STRING *\/\n-   212,  \/* (178) expr ::= CAST LP expr AS typetoken RP *\/\n-   212,  \/* (179) expr ::= ID|INDEXED LP distinct exprlist RP *\/\n-   212,  \/* (180) expr ::= ID|INDEXED LP STAR RP *\/\n-   212,  \/* (181) expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n-   212,  \/* (182) expr ::= ID|INDEXED LP STAR RP filter_over *\/\n-   211,  \/* (183) term ::= CTIME_KW *\/\n-   212,  \/* (184) expr ::= LP nexprlist COMMA expr RP *\/\n-   212,  \/* (185) expr ::= expr AND expr *\/\n-   212,  \/* (186) expr ::= expr OR expr *\/\n-   212,  \/* (187) expr ::= expr LT|GT|GE|LE expr *\/\n-   212,  \/* (188) expr ::= expr EQ|NE expr *\/\n-   212,  \/* (189) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n-   212,  \/* (190) expr ::= expr PLUS|MINUS expr *\/\n-   212,  \/* (191) expr ::= expr STAR|SLASH|REM expr *\/\n-   212,  \/* (192) expr ::= expr CONCAT expr *\/\n-   267,  \/* (193) likeop ::= NOT LIKE_KW|MATCH *\/\n-   212,  \/* (194) expr ::= expr likeop expr *\/\n-   212,  \/* (195) expr ::= expr likeop expr ESCAPE expr *\/\n-   212,  \/* (196) expr ::= expr ISNULL|NOTNULL *\/\n-   212,  \/* (197) expr ::= expr NOT NULL *\/\n-   212,  \/* (198) expr ::= expr IS expr *\/\n-   212,  \/* (199) expr ::= expr IS NOT expr *\/\n-   212,  \/* (200) expr ::= NOT expr *\/\n-   212,  \/* (201) expr ::= BITNOT expr *\/\n-   212,  \/* (202) expr ::= PLUS|MINUS expr *\/\n-   268,  \/* (203) between_op ::= BETWEEN *\/\n-   268,  \/* (204) between_op ::= NOT BETWEEN *\/\n-   212,  \/* (205) expr ::= expr between_op expr AND expr *\/\n-   269,  \/* (206) in_op ::= IN *\/\n-   269,  \/* (207) in_op ::= NOT IN *\/\n-   212,  \/* (208) expr ::= expr in_op LP exprlist RP *\/\n-   212,  \/* (209) expr ::= LP select RP *\/\n-   212,  \/* (210) expr ::= expr in_op LP select RP *\/\n-   212,  \/* (211) expr ::= expr in_op nm dbnm paren_exprlist *\/\n-   212,  \/* (212) expr ::= EXISTS LP select RP *\/\n-   212,  \/* (213) expr ::= CASE case_operand case_exprlist case_else END *\/\n-   272,  \/* (214) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n-   272,  \/* (215) case_exprlist ::= WHEN expr THEN expr *\/\n-   273,  \/* (216) case_else ::= ELSE expr *\/\n-   273,  \/* (217) case_else ::= *\/\n-   271,  \/* (218) case_operand ::= expr *\/\n-   271,  \/* (219) case_operand ::= *\/\n-   257,  \/* (220) exprlist ::= *\/\n-   248,  \/* (221) nexprlist ::= nexprlist COMMA expr *\/\n-   248,  \/* (222) nexprlist ::= expr *\/\n-   270,  \/* (223) paren_exprlist ::= *\/\n-   270,  \/* (224) paren_exprlist ::= LP exprlist RP *\/\n-   186,  \/* (225) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n-   274,  \/* (226) uniqueflag ::= UNIQUE *\/\n-   274,  \/* (227) uniqueflag ::= *\/\n-   216,  \/* (228) eidlist_opt ::= *\/\n-   216,  \/* (229) eidlist_opt ::= LP eidlist RP *\/\n-   227,  \/* (230) eidlist ::= eidlist COMMA nm collate sortorder *\/\n-   227,  \/* (231) eidlist ::= nm collate sortorder *\/\n-   275,  \/* (232) collate ::= *\/\n-   275,  \/* (233) collate ::= COLLATE ID|STRING *\/\n-   186,  \/* (234) cmd ::= DROP INDEX ifexists fullname *\/\n-   186,  \/* (235) cmd ::= VACUUM vinto *\/\n-   186,  \/* (236) cmd ::= VACUUM nm vinto *\/\n-   276,  \/* (237) vinto ::= INTO expr *\/\n-   276,  \/* (238) vinto ::= *\/\n-   186,  \/* (239) cmd ::= PRAGMA nm dbnm *\/\n-   186,  \/* (240) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n-   186,  \/* (241) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n-   186,  \/* (242) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n-   186,  \/* (243) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n-   206,  \/* (244) plus_num ::= PLUS INTEGER|FLOAT *\/\n-   207,  \/* (245) minus_num ::= MINUS INTEGER|FLOAT *\/\n-   186,  \/* (246) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n-   278,  \/* (247) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n-   280,  \/* (248) trigger_time ::= BEFORE|AFTER *\/\n-   280,  \/* (249) trigger_time ::= INSTEAD OF *\/\n-   280,  \/* (250) trigger_time ::= *\/\n-   281,  \/* (251) trigger_event ::= DELETE|INSERT *\/\n-   281,  \/* (252) trigger_event ::= UPDATE *\/\n-   281,  \/* (253) trigger_event ::= UPDATE OF idlist *\/\n-   283,  \/* (254) when_clause ::= *\/\n-   283,  \/* (255) when_clause ::= WHEN expr *\/\n-   279,  \/* (256) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n-   279,  \/* (257) trigger_cmd_list ::= trigger_cmd SEMI *\/\n-   285,  \/* (258) trnm ::= nm DOT nm *\/\n-   286,  \/* (259) tridxby ::= INDEXED BY nm *\/\n-   286,  \/* (260) tridxby ::= NOT INDEXED *\/\n-   284,  \/* (261) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt *\/\n-   284,  \/* (262) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n-   284,  \/* (263) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n-   284,  \/* (264) trigger_cmd ::= scanpt select scanpt *\/\n-   212,  \/* (265) expr ::= RAISE LP IGNORE RP *\/\n-   212,  \/* (266) expr ::= RAISE LP raisetype COMMA nm RP *\/\n-   231,  \/* (267) raisetype ::= ROLLBACK *\/\n-   231,  \/* (268) raisetype ::= ABORT *\/\n-   231,  \/* (269) raisetype ::= FAIL *\/\n-   186,  \/* (270) cmd ::= DROP TRIGGER ifexists fullname *\/\n-   186,  \/* (271) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n-   186,  \/* (272) cmd ::= DETACH database_kw_opt expr *\/\n-   288,  \/* (273) key_opt ::= *\/\n-   288,  \/* (274) key_opt ::= KEY expr *\/\n-   186,  \/* (275) cmd ::= REINDEX *\/\n-   186,  \/* (276) cmd ::= REINDEX nm dbnm *\/\n-   186,  \/* (277) cmd ::= ANALYZE *\/\n-   186,  \/* (278) cmd ::= ANALYZE nm dbnm *\/\n-   186,  \/* (279) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n-   186,  \/* (280) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n-   289,  \/* (281) add_column_fullname ::= fullname *\/\n-   186,  \/* (282) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n-   186,  \/* (283) cmd ::= create_vtab *\/\n-   186,  \/* (284) cmd ::= create_vtab LP vtabarglist RP *\/\n-   291,  \/* (285) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n-   293,  \/* (286) vtabarg ::= *\/\n-   294,  \/* (287) vtabargtoken ::= ANY *\/\n-   294,  \/* (288) vtabargtoken ::= lp anylist RP *\/\n-   295,  \/* (289) lp ::= LP *\/\n-   261,  \/* (290) with ::= WITH wqlist *\/\n-   261,  \/* (291) with ::= WITH RECURSIVE wqlist *\/\n-   236,  \/* (292) wqlist ::= nm eidlist_opt AS LP select RP *\/\n-   236,  \/* (293) wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP *\/\n-   297,  \/* (294) windowdefn_list ::= windowdefn *\/\n-   297,  \/* (295) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n-   298,  \/* (296) windowdefn ::= nm AS LP window RP *\/\n-   299,  \/* (297) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   299,  \/* (298) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   299,  \/* (299) window ::= ORDER BY sortlist frame_opt *\/\n-   299,  \/* (300) window ::= nm ORDER BY sortlist frame_opt *\/\n-   299,  \/* (301) window ::= frame_opt *\/\n-   299,  \/* (302) window ::= nm frame_opt *\/\n-   300,  \/* (303) frame_opt ::= *\/\n-   300,  \/* (304) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n-   300,  \/* (305) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n-   304,  \/* (306) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n-   306,  \/* (307) frame_bound_s ::= frame_bound *\/\n-   306,  \/* (308) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-   307,  \/* (309) frame_bound_e ::= frame_bound *\/\n-   307,  \/* (310) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n-   305,  \/* (311) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-   305,  \/* (312) frame_bound ::= CURRENT ROW *\/\n-   308,  \/* (313) frame_exclude_opt ::= *\/\n-   308,  \/* (314) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-   309,  \/* (315) frame_exclude ::= NO OTHERS *\/\n-   309,  \/* (316) frame_exclude ::= CURRENT ROW *\/\n-   309,  \/* (317) frame_exclude ::= GROUP|TIES *\/\n-   246,  \/* (318) window_clause ::= WINDOW windowdefn_list *\/\n-   266,  \/* (319) filter_over ::= filter_clause over_clause *\/\n-   266,  \/* (320) filter_over ::= over_clause *\/\n-   266,  \/* (321) filter_over ::= filter_clause *\/\n-   303,  \/* (322) over_clause ::= OVER LP window RP *\/\n-   303,  \/* (323) over_clause ::= OVER nm *\/\n-   302,  \/* (324) filter_clause ::= FILTER LP WHERE expr RP *\/\n-   181,  \/* (325) input ::= cmdlist *\/\n-   182,  \/* (326) cmdlist ::= cmdlist ecmd *\/\n-   182,  \/* (327) cmdlist ::= ecmd *\/\n-   183,  \/* (328) ecmd ::= SEMI *\/\n-   183,  \/* (329) ecmd ::= cmdx SEMI *\/\n-   183,  \/* (330) ecmd ::= explain cmdx SEMI *\/\n-   188,  \/* (331) trans_opt ::= *\/\n-   188,  \/* (332) trans_opt ::= TRANSACTION *\/\n-   188,  \/* (333) trans_opt ::= TRANSACTION nm *\/\n-   190,  \/* (334) savepoint_opt ::= SAVEPOINT *\/\n-   190,  \/* (335) savepoint_opt ::= *\/\n-   186,  \/* (336) cmd ::= create_table create_table_args *\/\n-   197,  \/* (337) columnlist ::= columnlist COMMA columnname carglist *\/\n-   197,  \/* (338) columnlist ::= columnname carglist *\/\n-   189,  \/* (339) nm ::= ID|INDEXED *\/\n-   189,  \/* (340) nm ::= STRING *\/\n-   189,  \/* (341) nm ::= JOIN_KW *\/\n-   203,  \/* (342) typetoken ::= typename *\/\n-   204,  \/* (343) typename ::= ID|STRING *\/\n-   205,  \/* (344) signed ::= plus_num *\/\n-   205,  \/* (345) signed ::= minus_num *\/\n-   202,  \/* (346) carglist ::= carglist ccons *\/\n-   202,  \/* (347) carglist ::= *\/\n-   210,  \/* (348) ccons ::= NULL onconf *\/\n-   210,  \/* (349) ccons ::= GENERATED ALWAYS AS generated *\/\n-   210,  \/* (350) ccons ::= AS generated *\/\n-   198,  \/* (351) conslist_opt ::= COMMA conslist *\/\n-   223,  \/* (352) conslist ::= conslist tconscomma tcons *\/\n-   223,  \/* (353) conslist ::= tcons *\/\n-   224,  \/* (354) tconscomma ::= *\/\n-   228,  \/* (355) defer_subclause_opt ::= defer_subclause *\/\n-   230,  \/* (356) resolvetype ::= raisetype *\/\n-   234,  \/* (357) selectnowith ::= oneselect *\/\n-   235,  \/* (358) oneselect ::= values *\/\n-   249,  \/* (359) sclp ::= selcollist COMMA *\/\n-   250,  \/* (360) as ::= ID|STRING *\/\n-   212,  \/* (361) expr ::= term *\/\n-   267,  \/* (362) likeop ::= LIKE_KW|MATCH *\/\n-   257,  \/* (363) exprlist ::= nexprlist *\/\n-   277,  \/* (364) nmnum ::= plus_num *\/\n-   277,  \/* (365) nmnum ::= nm *\/\n-   277,  \/* (366) nmnum ::= ON *\/\n-   277,  \/* (367) nmnum ::= DELETE *\/\n-   277,  \/* (368) nmnum ::= DEFAULT *\/\n-   206,  \/* (369) plus_num ::= INTEGER|FLOAT *\/\n-   282,  \/* (370) foreach_clause ::= *\/\n-   282,  \/* (371) foreach_clause ::= FOR EACH ROW *\/\n-   285,  \/* (372) trnm ::= nm *\/\n-   286,  \/* (373) tridxby ::= *\/\n-   287,  \/* (374) database_kw_opt ::= DATABASE *\/\n-   287,  \/* (375) database_kw_opt ::= *\/\n-   290,  \/* (376) kwcolumn_opt ::= *\/\n-   290,  \/* (377) kwcolumn_opt ::= COLUMNKW *\/\n-   292,  \/* (378) vtabarglist ::= vtabarg *\/\n-   292,  \/* (379) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n-   293,  \/* (380) vtabarg ::= vtabarg vtabargtoken *\/\n-   296,  \/* (381) anylist ::= *\/\n-   296,  \/* (382) anylist ::= anylist LP anylist RP *\/\n-   296,  \/* (383) anylist ::= anylist ANY *\/\n-   261,  \/* (384) with ::= *\/\n+   188,  \/* (0) explain ::= EXPLAIN *\/\n+   188,  \/* (1) explain ::= EXPLAIN QUERY PLAN *\/\n+   187,  \/* (2) cmdx ::= cmd *\/\n+   189,  \/* (3) cmd ::= BEGIN transtype trans_opt *\/\n+   190,  \/* (4) transtype ::= *\/\n+   190,  \/* (5) transtype ::= DEFERRED *\/\n+   190,  \/* (6) transtype ::= IMMEDIATE *\/\n+   190,  \/* (7) transtype ::= EXCLUSIVE *\/\n+   189,  \/* (8) cmd ::= COMMIT|END trans_opt *\/\n+   189,  \/* (9) cmd ::= ROLLBACK trans_opt *\/\n+   189,  \/* (10) cmd ::= SAVEPOINT nm *\/\n+   189,  \/* (11) cmd ::= RELEASE savepoint_opt nm *\/\n+   189,  \/* (12) cmd ::= ROLLBACK trans_opt TO savepoint_opt nm *\/\n+   194,  \/* (13) create_table ::= createkw temp TABLE ifnotexists nm dbnm *\/\n+   196,  \/* (14) createkw ::= CREATE *\/\n+   198,  \/* (15) ifnotexists ::= *\/\n+   198,  \/* (16) ifnotexists ::= IF NOT EXISTS *\/\n+   197,  \/* (17) temp ::= TEMP *\/\n+   197,  \/* (18) temp ::= *\/\n+   195,  \/* (19) create_table_args ::= LP columnlist conslist_opt RP table_option_set *\/\n+   195,  \/* (20) create_table_args ::= AS select *\/\n+   202,  \/* (21) table_option_set ::= *\/\n+   202,  \/* (22) table_option_set ::= table_option_set COMMA table_option *\/\n+   204,  \/* (23) table_option ::= WITHOUT nm *\/\n+   204,  \/* (24) table_option ::= nm *\/\n+   205,  \/* (25) columnname ::= nm typetoken *\/\n+   207,  \/* (26) typetoken ::= *\/\n+   207,  \/* (27) typetoken ::= typename LP signed RP *\/\n+   207,  \/* (28) typetoken ::= typename LP signed COMMA signed RP *\/\n+   208,  \/* (29) typename ::= typename ID|STRING *\/\n+   212,  \/* (30) scanpt ::= *\/\n+   213,  \/* (31) scantok ::= *\/\n+   214,  \/* (32) ccons ::= CONSTRAINT nm *\/\n+   214,  \/* (33) ccons ::= DEFAULT scantok term *\/\n+   214,  \/* (34) ccons ::= DEFAULT LP expr RP *\/\n+   214,  \/* (35) ccons ::= DEFAULT PLUS scantok term *\/\n+   214,  \/* (36) ccons ::= DEFAULT MINUS scantok term *\/\n+   214,  \/* (37) ccons ::= DEFAULT scantok ID|INDEXED *\/\n+   214,  \/* (38) ccons ::= NOT NULL onconf *\/\n+   214,  \/* (39) ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n+   214,  \/* (40) ccons ::= UNIQUE onconf *\/\n+   214,  \/* (41) ccons ::= CHECK LP expr RP *\/\n+   214,  \/* (42) ccons ::= REFERENCES nm eidlist_opt refargs *\/\n+   214,  \/* (43) ccons ::= defer_subclause *\/\n+   214,  \/* (44) ccons ::= COLLATE ID|STRING *\/\n+   223,  \/* (45) generated ::= LP expr RP *\/\n+   223,  \/* (46) generated ::= LP expr RP ID *\/\n+   219,  \/* (47) autoinc ::= *\/\n+   219,  \/* (48) autoinc ::= AUTOINCR *\/\n+   221,  \/* (49) refargs ::= *\/\n+   221,  \/* (50) refargs ::= refargs refarg *\/\n+   224,  \/* (51) refarg ::= MATCH nm *\/\n+   224,  \/* (52) refarg ::= ON INSERT refact *\/\n+   224,  \/* (53) refarg ::= ON DELETE refact *\/\n+   224,  \/* (54) refarg ::= ON UPDATE refact *\/\n+   225,  \/* (55) refact ::= SET NULL *\/\n+   225,  \/* (56) refact ::= SET DEFAULT *\/\n+   225,  \/* (57) refact ::= CASCADE *\/\n+   225,  \/* (58) refact ::= RESTRICT *\/\n+   225,  \/* (59) refact ::= NO ACTION *\/\n+   222,  \/* (60) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n+   222,  \/* (61) defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n+   226,  \/* (62) init_deferred_pred_opt ::= *\/\n+   226,  \/* (63) init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n+   226,  \/* (64) init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n+   201,  \/* (65) conslist_opt ::= *\/\n+   228,  \/* (66) tconscomma ::= COMMA *\/\n+   229,  \/* (67) tcons ::= CONSTRAINT nm *\/\n+   229,  \/* (68) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n+   229,  \/* (69) tcons ::= UNIQUE LP sortlist RP onconf *\/\n+   229,  \/* (70) tcons ::= CHECK LP expr RP onconf *\/\n+   229,  \/* (71) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n+   232,  \/* (72) defer_subclause_opt ::= *\/\n+   217,  \/* (73) onconf ::= *\/\n+   217,  \/* (74) onconf ::= ON CONFLICT resolvetype *\/\n+   233,  \/* (75) orconf ::= *\/\n+   233,  \/* (76) orconf ::= OR resolvetype *\/\n+   234,  \/* (77) resolvetype ::= IGNORE *\/\n+   234,  \/* (78) resolvetype ::= REPLACE *\/\n+   189,  \/* (79) cmd ::= DROP TABLE ifexists fullname *\/\n+   236,  \/* (80) ifexists ::= IF EXISTS *\/\n+   236,  \/* (81) ifexists ::= *\/\n+   189,  \/* (82) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n+   189,  \/* (83) cmd ::= DROP VIEW ifexists fullname *\/\n+   189,  \/* (84) cmd ::= select *\/\n+   203,  \/* (85) select ::= WITH wqlist selectnowith *\/\n+   203,  \/* (86) select ::= WITH RECURSIVE wqlist selectnowith *\/\n+   203,  \/* (87) select ::= selectnowith *\/\n+   238,  \/* (88) selectnowith ::= selectnowith multiselect_op oneselect *\/\n+   241,  \/* (89) multiselect_op ::= UNION *\/\n+   241,  \/* (90) multiselect_op ::= UNION ALL *\/\n+   241,  \/* (91) multiselect_op ::= EXCEPT|INTERSECT *\/\n+   239,  \/* (92) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n+   239,  \/* (93) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n+   251,  \/* (94) values ::= VALUES LP nexprlist RP *\/\n+   251,  \/* (95) values ::= values COMMA LP nexprlist RP *\/\n+   242,  \/* (96) distinct ::= DISTINCT *\/\n+   242,  \/* (97) distinct ::= ALL *\/\n+   242,  \/* (98) distinct ::= *\/\n+   253,  \/* (99) sclp ::= *\/\n+   243,  \/* (100) selcollist ::= sclp scanpt expr scanpt as *\/\n+   243,  \/* (101) selcollist ::= sclp scanpt STAR *\/\n+   243,  \/* (102) selcollist ::= sclp scanpt nm DOT STAR *\/\n+   254,  \/* (103) as ::= AS nm *\/\n+   254,  \/* (104) as ::= *\/\n+   244,  \/* (105) from ::= *\/\n+   244,  \/* (106) from ::= FROM seltablist *\/\n+   256,  \/* (107) stl_prefix ::= seltablist joinop *\/\n+   256,  \/* (108) stl_prefix ::= *\/\n+   255,  \/* (109) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt *\/\n+   255,  \/* (110) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt *\/\n+   255,  \/* (111) seltablist ::= stl_prefix LP select RP as on_opt using_opt *\/\n+   255,  \/* (112) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt *\/\n+   199,  \/* (113) dbnm ::= *\/\n+   199,  \/* (114) dbnm ::= DOT nm *\/\n+   237,  \/* (115) fullname ::= nm *\/\n+   237,  \/* (116) fullname ::= nm DOT nm *\/\n+   262,  \/* (117) xfullname ::= nm *\/\n+   262,  \/* (118) xfullname ::= nm DOT nm *\/\n+   262,  \/* (119) xfullname ::= nm DOT nm AS nm *\/\n+   262,  \/* (120) xfullname ::= nm AS nm *\/\n+   257,  \/* (121) joinop ::= COMMA|JOIN *\/\n+   257,  \/* (122) joinop ::= JOIN_KW JOIN *\/\n+   257,  \/* (123) joinop ::= JOIN_KW nm JOIN *\/\n+   257,  \/* (124) joinop ::= JOIN_KW nm nm JOIN *\/\n+   259,  \/* (125) on_opt ::= ON expr *\/\n+   259,  \/* (126) on_opt ::= *\/\n+   258,  \/* (127) indexed_opt ::= *\/\n+   258,  \/* (128) indexed_opt ::= INDEXED BY nm *\/\n+   258,  \/* (129) indexed_opt ::= NOT INDEXED *\/\n+   260,  \/* (130) using_opt ::= USING LP idlist RP *\/\n+   260,  \/* (131) using_opt ::= *\/\n+   248,  \/* (132) orderby_opt ::= *\/\n+   248,  \/* (133) orderby_opt ::= ORDER BY sortlist *\/\n+   230,  \/* (134) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n+   230,  \/* (135) sortlist ::= expr sortorder nulls *\/\n+   218,  \/* (136) sortorder ::= ASC *\/\n+   218,  \/* (137) sortorder ::= DESC *\/\n+   218,  \/* (138) sortorder ::= *\/\n+   264,  \/* (139) nulls ::= NULLS FIRST *\/\n+   264,  \/* (140) nulls ::= NULLS LAST *\/\n+   264,  \/* (141) nulls ::= *\/\n+   246,  \/* (142) groupby_opt ::= *\/\n+   246,  \/* (143) groupby_opt ::= GROUP BY nexprlist *\/\n+   247,  \/* (144) having_opt ::= *\/\n+   247,  \/* (145) having_opt ::= HAVING expr *\/\n+   249,  \/* (146) limit_opt ::= *\/\n+   249,  \/* (147) limit_opt ::= LIMIT expr *\/\n+   249,  \/* (148) limit_opt ::= LIMIT expr OFFSET expr *\/\n+   249,  \/* (149) limit_opt ::= LIMIT expr COMMA expr *\/\n+   189,  \/* (150) cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n+   245,  \/* (151) where_opt ::= *\/\n+   245,  \/* (152) where_opt ::= WHERE expr *\/\n+   266,  \/* (153) where_opt_ret ::= *\/\n+   266,  \/* (154) where_opt_ret ::= WHERE expr *\/\n+   266,  \/* (155) where_opt_ret ::= RETURNING selcollist *\/\n+   266,  \/* (156) where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n+   189,  \/* (157) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n+   267,  \/* (158) setlist ::= setlist COMMA nm EQ expr *\/\n+   267,  \/* (159) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n+   267,  \/* (160) setlist ::= nm EQ expr *\/\n+   267,  \/* (161) setlist ::= LP idlist RP EQ expr *\/\n+   189,  \/* (162) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n+   189,  \/* (163) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n+   270,  \/* (164) upsert ::= *\/\n+   270,  \/* (165) upsert ::= RETURNING selcollist *\/\n+   270,  \/* (166) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n+   270,  \/* (167) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n+   270,  \/* (168) upsert ::= ON CONFLICT DO NOTHING returning *\/\n+   270,  \/* (169) upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n+   271,  \/* (170) returning ::= RETURNING selcollist *\/\n+   268,  \/* (171) insert_cmd ::= INSERT orconf *\/\n+   268,  \/* (172) insert_cmd ::= REPLACE *\/\n+   269,  \/* (173) idlist_opt ::= *\/\n+   269,  \/* (174) idlist_opt ::= LP idlist RP *\/\n+   263,  \/* (175) idlist ::= idlist COMMA nm *\/\n+   263,  \/* (176) idlist ::= nm *\/\n+   216,  \/* (177) expr ::= LP expr RP *\/\n+   216,  \/* (178) expr ::= ID|INDEXED *\/\n+   216,  \/* (179) expr ::= JOIN_KW *\/\n+   216,  \/* (180) expr ::= nm DOT nm *\/\n+   216,  \/* (181) expr ::= nm DOT nm DOT nm *\/\n+   215,  \/* (182) term ::= NULL|FLOAT|BLOB *\/\n+   215,  \/* (183) term ::= STRING *\/\n+   215,  \/* (184) term ::= INTEGER *\/\n+   216,  \/* (185) expr ::= VARIABLE *\/\n+   216,  \/* (186) expr ::= expr COLLATE ID|STRING *\/\n+   216,  \/* (187) expr ::= CAST LP expr AS typetoken RP *\/\n+   216,  \/* (188) expr ::= ID|INDEXED LP distinct exprlist RP *\/\n+   216,  \/* (189) expr ::= ID|INDEXED LP STAR RP *\/\n+   216,  \/* (190) expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n+   216,  \/* (191) expr ::= ID|INDEXED LP STAR RP filter_over *\/\n+   215,  \/* (192) term ::= CTIME_KW *\/\n+   216,  \/* (193) expr ::= LP nexprlist COMMA expr RP *\/\n+   216,  \/* (194) expr ::= expr AND expr *\/\n+   216,  \/* (195) expr ::= expr OR expr *\/\n+   216,  \/* (196) expr ::= expr LT|GT|GE|LE expr *\/\n+   216,  \/* (197) expr ::= expr EQ|NE expr *\/\n+   216,  \/* (198) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n+   216,  \/* (199) expr ::= expr PLUS|MINUS expr *\/\n+   216,  \/* (200) expr ::= expr STAR|SLASH|REM expr *\/\n+   216,  \/* (201) expr ::= expr CONCAT expr *\/\n+   273,  \/* (202) likeop ::= NOT LIKE_KW|MATCH *\/\n+   216,  \/* (203) expr ::= expr likeop expr *\/\n+   216,  \/* (204) expr ::= expr likeop expr ESCAPE expr *\/\n+   216,  \/* (205) expr ::= expr ISNULL|NOTNULL *\/\n+   216,  \/* (206) expr ::= expr NOT NULL *\/\n+   216,  \/* (207) expr ::= expr IS expr *\/\n+   216,  \/* (208) expr ::= expr IS NOT expr *\/\n+   216,  \/* (209) expr ::= NOT expr *\/\n+   216,  \/* (210) expr ::= BITNOT expr *\/\n+   216,  \/* (211) expr ::= PLUS|MINUS expr *\/\n+   274,  \/* (212) between_op ::= BETWEEN *\/\n+   274,  \/* (213) between_op ::= NOT BETWEEN *\/\n+   216,  \/* (214) expr ::= expr between_op expr AND expr *\/\n+   275,  \/* (215) in_op ::= IN *\/\n+   275,  \/* (216) in_op ::= NOT IN *\/\n+   216,  \/* (217) expr ::= expr in_op LP exprlist RP *\/\n+   216,  \/* (218) expr ::= LP select RP *\/\n+   216,  \/* (219) expr ::= expr in_op LP select RP *\/\n+   216,  \/* (220) expr ::= expr in_op nm dbnm paren_exprlist *\/\n+   216,  \/* (221) expr ::= EXISTS LP select RP *\/\n+   216,  \/* (222) expr ::= CASE case_operand case_exprlist case_else END *\/\n+   278,  \/* (223) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+   278,  \/* (224) case_exprlist ::= WHEN expr THEN expr *\/\n+   279,  \/* (225) case_else ::= ELSE expr *\/\n+   279,  \/* (226) case_else ::= *\/\n+   277,  \/* (227) case_operand ::= expr *\/\n+   277,  \/* (228) case_operand ::= *\/\n+   261,  \/* (229) exprlist ::= *\/\n+   252,  \/* (230) nexprlist ::= nexprlist COMMA expr *\/\n+   252,  \/* (231) nexprlist ::= expr *\/\n+   276,  \/* (232) paren_exprlist ::= *\/\n+   276,  \/* (233) paren_exprlist ::= LP exprlist RP *\/\n+   189,  \/* (234) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n+   280,  \/* (235) uniqueflag ::= UNIQUE *\/\n+   280,  \/* (236) uniqueflag ::= *\/\n+   220,  \/* (237) eidlist_opt ::= *\/\n+   220,  \/* (238) eidlist_opt ::= LP eidlist RP *\/\n+   231,  \/* (239) eidlist ::= eidlist COMMA nm collate sortorder *\/\n+   231,  \/* (240) eidlist ::= nm collate sortorder *\/\n+   281,  \/* (241) collate ::= *\/\n+   281,  \/* (242) collate ::= COLLATE ID|STRING *\/\n+   189,  \/* (243) cmd ::= DROP INDEX ifexists fullname *\/\n+   189,  \/* (244) cmd ::= VACUUM vinto *\/\n+   189,  \/* (245) cmd ::= VACUUM nm vinto *\/\n+   282,  \/* (246) vinto ::= INTO expr *\/\n+   282,  \/* (247) vinto ::= *\/\n+   189,  \/* (248) cmd ::= PRAGMA nm dbnm *\/\n+   189,  \/* (249) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n+   189,  \/* (250) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n+   189,  \/* (251) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n+   189,  \/* (252) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n+   210,  \/* (253) plus_num ::= PLUS INTEGER|FLOAT *\/\n+   211,  \/* (254) minus_num ::= MINUS INTEGER|FLOAT *\/\n+   189,  \/* (255) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n+   284,  \/* (256) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n+   286,  \/* (257) trigger_time ::= BEFORE|AFTER *\/\n+   286,  \/* (258) trigger_time ::= INSTEAD OF *\/\n+   286,  \/* (259) trigger_time ::= *\/\n+   287,  \/* (260) trigger_event ::= DELETE|INSERT *\/\n+   287,  \/* (261) trigger_event ::= UPDATE *\/\n+   287,  \/* (262) trigger_event ::= UPDATE OF idlist *\/\n+   289,  \/* (263) when_clause ::= *\/\n+   289,  \/* (264) when_clause ::= WHEN expr *\/\n+   285,  \/* (265) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n+   285,  \/* (266) trigger_cmd_list ::= trigger_cmd SEMI *\/\n+   291,  \/* (267) trnm ::= nm DOT nm *\/\n+   292,  \/* (268) tridxby ::= INDEXED BY nm *\/\n+   292,  \/* (269) tridxby ::= NOT INDEXED *\/\n+   290,  \/* (270) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n+   290,  \/* (271) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n+   290,  \/* (272) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n+   290,  \/* (273) trigger_cmd ::= scanpt select scanpt *\/\n+   216,  \/* (274) expr ::= RAISE LP IGNORE RP *\/\n+   216,  \/* (275) expr ::= RAISE LP raisetype COMMA nm RP *\/\n+   235,  \/* (276) raisetype ::= ROLLBACK *\/\n+   235,  \/* (277) raisetype ::= ABORT *\/\n+   235,  \/* (278) raisetype ::= FAIL *\/\n+   189,  \/* (279) cmd ::= DROP TRIGGER ifexists fullname *\/\n+   189,  \/* (280) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n+   189,  \/* (281) cmd ::= DETACH database_kw_opt expr *\/\n+   294,  \/* (282) key_opt ::= *\/\n+   294,  \/* (283) key_opt ::= KEY expr *\/\n+   189,  \/* (284) cmd ::= REINDEX *\/\n+   189,  \/* (285) cmd ::= REINDEX nm dbnm *\/\n+   189,  \/* (286) cmd ::= ANALYZE *\/\n+   189,  \/* (287) cmd ::= ANALYZE nm dbnm *\/\n+   189,  \/* (288) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n+   189,  \/* (289) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n+   189,  \/* (290) cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n+   295,  \/* (291) add_column_fullname ::= fullname *\/\n+   189,  \/* (292) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n+   189,  \/* (293) cmd ::= create_vtab *\/\n+   189,  \/* (294) cmd ::= create_vtab LP vtabarglist RP *\/\n+   297,  \/* (295) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n+   299,  \/* (296) vtabarg ::= *\/\n+   300,  \/* (297) vtabargtoken ::= ANY *\/\n+   300,  \/* (298) vtabargtoken ::= lp anylist RP *\/\n+   301,  \/* (299) lp ::= LP *\/\n+   265,  \/* (300) with ::= WITH wqlist *\/\n+   265,  \/* (301) with ::= WITH RECURSIVE wqlist *\/\n+   304,  \/* (302) wqas ::= AS *\/\n+   304,  \/* (303) wqas ::= AS MATERIALIZED *\/\n+   304,  \/* (304) wqas ::= AS NOT MATERIALIZED *\/\n+   303,  \/* (305) wqitem ::= nm eidlist_opt wqas LP select RP *\/\n+   240,  \/* (306) wqlist ::= wqitem *\/\n+   240,  \/* (307) wqlist ::= wqlist COMMA wqitem *\/\n+   305,  \/* (308) windowdefn_list ::= windowdefn *\/\n+   305,  \/* (309) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+   306,  \/* (310) windowdefn ::= nm AS LP window RP *\/\n+   307,  \/* (311) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   307,  \/* (312) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   307,  \/* (313) window ::= ORDER BY sortlist frame_opt *\/\n+   307,  \/* (314) window ::= nm ORDER BY sortlist frame_opt *\/\n+   307,  \/* (315) window ::= frame_opt *\/\n+   307,  \/* (316) window ::= nm frame_opt *\/\n+   308,  \/* (317) frame_opt ::= *\/\n+   308,  \/* (318) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+   308,  \/* (319) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+   312,  \/* (320) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n+   314,  \/* (321) frame_bound_s ::= frame_bound *\/\n+   314,  \/* (322) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+   315,  \/* (323) frame_bound_e ::= frame_bound *\/\n+   315,  \/* (324) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n+   313,  \/* (325) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+   313,  \/* (326) frame_bound ::= CURRENT ROW *\/\n+   316,  \/* (327) frame_exclude_opt ::= *\/\n+   316,  \/* (328) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+   317,  \/* (329) frame_exclude ::= NO OTHERS *\/\n+   317,  \/* (330) frame_exclude ::= CURRENT ROW *\/\n+   317,  \/* (331) frame_exclude ::= GROUP|TIES *\/\n+   250,  \/* (332) window_clause ::= WINDOW windowdefn_list *\/\n+   272,  \/* (333) filter_over ::= filter_clause over_clause *\/\n+   272,  \/* (334) filter_over ::= over_clause *\/\n+   272,  \/* (335) filter_over ::= filter_clause *\/\n+   311,  \/* (336) over_clause ::= OVER LP window RP *\/\n+   311,  \/* (337) over_clause ::= OVER nm *\/\n+   310,  \/* (338) filter_clause ::= FILTER LP WHERE expr RP *\/\n+   184,  \/* (339) input ::= cmdlist *\/\n+   185,  \/* (340) cmdlist ::= cmdlist ecmd *\/\n+   185,  \/* (341) cmdlist ::= ecmd *\/\n+   186,  \/* (342) ecmd ::= SEMI *\/\n+   186,  \/* (343) ecmd ::= cmdx SEMI *\/\n+   186,  \/* (344) ecmd ::= explain cmdx SEMI *\/\n+   191,  \/* (345) trans_opt ::= *\/\n+   191,  \/* (346) trans_opt ::= TRANSACTION *\/\n+   191,  \/* (347) trans_opt ::= TRANSACTION nm *\/\n+   193,  \/* (348) savepoint_opt ::= SAVEPOINT *\/\n+   193,  \/* (349) savepoint_opt ::= *\/\n+   189,  \/* (350) cmd ::= create_table create_table_args *\/\n+   202,  \/* (351) table_option_set ::= table_option *\/\n+   200,  \/* (352) columnlist ::= columnlist COMMA columnname carglist *\/\n+   200,  \/* (353) columnlist ::= columnname carglist *\/\n+   192,  \/* (354) nm ::= ID|INDEXED *\/\n+   192,  \/* (355) nm ::= STRING *\/\n+   192,  \/* (356) nm ::= JOIN_KW *\/\n+   207,  \/* (357) typetoken ::= typename *\/\n+   208,  \/* (358) typename ::= ID|STRING *\/\n+   209,  \/* (359) signed ::= plus_num *\/\n+   209,  \/* (360) signed ::= minus_num *\/\n+   206,  \/* (361) carglist ::= carglist ccons *\/\n+   206,  \/* (362) carglist ::= *\/\n+   214,  \/* (363) ccons ::= NULL onconf *\/\n+   214,  \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/\n+   214,  \/* (365) ccons ::= AS generated *\/\n+   201,  \/* (366) conslist_opt ::= COMMA conslist *\/\n+   227,  \/* (367) conslist ::= conslist tconscomma tcons *\/\n+   227,  \/* (368) conslist ::= tcons *\/\n+   228,  \/* (369) tconscomma ::= *\/\n+   232,  \/* (370) defer_subclause_opt ::= defer_subclause *\/\n+   234,  \/* (371) resolvetype ::= raisetype *\/\n+   238,  \/* (372) selectnowith ::= oneselect *\/\n+   239,  \/* (373) oneselect ::= values *\/\n+   253,  \/* (374) sclp ::= selcollist COMMA *\/\n+   254,  \/* (375) as ::= ID|STRING *\/\n+   271,  \/* (376) returning ::= *\/\n+   216,  \/* (377) expr ::= term *\/\n+   273,  \/* (378) likeop ::= LIKE_KW|MATCH *\/\n+   261,  \/* (379) exprlist ::= nexprlist *\/\n+   283,  \/* (380) nmnum ::= plus_num *\/\n+   283,  \/* (381) nmnum ::= nm *\/\n+   283,  \/* (382) nmnum ::= ON *\/\n+   283,  \/* (383) nmnum ::= DELETE *\/\n+   283,  \/* (384) nmnum ::= DEFAULT *\/\n+   210,  \/* (385) plus_num ::= INTEGER|FLOAT *\/\n+   288,  \/* (386) foreach_clause ::= *\/\n+   288,  \/* (387) foreach_clause ::= FOR EACH ROW *\/\n+   291,  \/* (388) trnm ::= nm *\/\n+   292,  \/* (389) tridxby ::= *\/\n+   293,  \/* (390) database_kw_opt ::= DATABASE *\/\n+   293,  \/* (391) database_kw_opt ::= *\/\n+   296,  \/* (392) kwcolumn_opt ::= *\/\n+   296,  \/* (393) kwcolumn_opt ::= COLUMNKW *\/\n+   298,  \/* (394) vtabarglist ::= vtabarg *\/\n+   298,  \/* (395) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n+   299,  \/* (396) vtabarg ::= vtabarg vtabargtoken *\/\n+   302,  \/* (397) anylist ::= *\/\n+   302,  \/* (398) anylist ::= anylist LP anylist RP *\/\n+   302,  \/* (399) anylist ::= anylist ANY *\/\n+   265,  \/* (400) with ::= *\/\n@@ -156418,1 +162606,1 @@\n-   -5,  \/* (19) create_table_args ::= LP columnlist conslist_opt RP table_options *\/\n+   -5,  \/* (19) create_table_args ::= LP columnlist conslist_opt RP table_option_set *\/\n@@ -156420,364 +162608,380 @@\n-    0,  \/* (21) table_options ::= *\/\n-   -2,  \/* (22) table_options ::= WITHOUT nm *\/\n-   -2,  \/* (23) columnname ::= nm typetoken *\/\n-    0,  \/* (24) typetoken ::= *\/\n-   -4,  \/* (25) typetoken ::= typename LP signed RP *\/\n-   -6,  \/* (26) typetoken ::= typename LP signed COMMA signed RP *\/\n-   -2,  \/* (27) typename ::= typename ID|STRING *\/\n-    0,  \/* (28) scanpt ::= *\/\n-    0,  \/* (29) scantok ::= *\/\n-   -2,  \/* (30) ccons ::= CONSTRAINT nm *\/\n-   -3,  \/* (31) ccons ::= DEFAULT scantok term *\/\n-   -4,  \/* (32) ccons ::= DEFAULT LP expr RP *\/\n-   -4,  \/* (33) ccons ::= DEFAULT PLUS scantok term *\/\n-   -4,  \/* (34) ccons ::= DEFAULT MINUS scantok term *\/\n-   -3,  \/* (35) ccons ::= DEFAULT scantok ID|INDEXED *\/\n-   -3,  \/* (36) ccons ::= NOT NULL onconf *\/\n-   -5,  \/* (37) ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n-   -2,  \/* (38) ccons ::= UNIQUE onconf *\/\n-   -4,  \/* (39) ccons ::= CHECK LP expr RP *\/\n-   -4,  \/* (40) ccons ::= REFERENCES nm eidlist_opt refargs *\/\n-   -1,  \/* (41) ccons ::= defer_subclause *\/\n-   -2,  \/* (42) ccons ::= COLLATE ID|STRING *\/\n-   -3,  \/* (43) generated ::= LP expr RP *\/\n-   -4,  \/* (44) generated ::= LP expr RP ID *\/\n-    0,  \/* (45) autoinc ::= *\/\n-   -1,  \/* (46) autoinc ::= AUTOINCR *\/\n-    0,  \/* (47) refargs ::= *\/\n-   -2,  \/* (48) refargs ::= refargs refarg *\/\n-   -2,  \/* (49) refarg ::= MATCH nm *\/\n-   -3,  \/* (50) refarg ::= ON INSERT refact *\/\n-   -3,  \/* (51) refarg ::= ON DELETE refact *\/\n-   -3,  \/* (52) refarg ::= ON UPDATE refact *\/\n-   -2,  \/* (53) refact ::= SET NULL *\/\n-   -2,  \/* (54) refact ::= SET DEFAULT *\/\n-   -1,  \/* (55) refact ::= CASCADE *\/\n-   -1,  \/* (56) refact ::= RESTRICT *\/\n-   -2,  \/* (57) refact ::= NO ACTION *\/\n-   -3,  \/* (58) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n-   -2,  \/* (59) defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n-    0,  \/* (60) init_deferred_pred_opt ::= *\/\n-   -2,  \/* (61) init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n-   -2,  \/* (62) init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n-    0,  \/* (63) conslist_opt ::= *\/\n-   -1,  \/* (64) tconscomma ::= COMMA *\/\n-   -2,  \/* (65) tcons ::= CONSTRAINT nm *\/\n-   -7,  \/* (66) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n-   -5,  \/* (67) tcons ::= UNIQUE LP sortlist RP onconf *\/\n-   -5,  \/* (68) tcons ::= CHECK LP expr RP onconf *\/\n-  -10,  \/* (69) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n-    0,  \/* (70) defer_subclause_opt ::= *\/\n-    0,  \/* (71) onconf ::= *\/\n-   -3,  \/* (72) onconf ::= ON CONFLICT resolvetype *\/\n-    0,  \/* (73) orconf ::= *\/\n-   -2,  \/* (74) orconf ::= OR resolvetype *\/\n-   -1,  \/* (75) resolvetype ::= IGNORE *\/\n-   -1,  \/* (76) resolvetype ::= REPLACE *\/\n-   -4,  \/* (77) cmd ::= DROP TABLE ifexists fullname *\/\n-   -2,  \/* (78) ifexists ::= IF EXISTS *\/\n-    0,  \/* (79) ifexists ::= *\/\n-   -9,  \/* (80) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n-   -4,  \/* (81) cmd ::= DROP VIEW ifexists fullname *\/\n-   -1,  \/* (82) cmd ::= select *\/\n-   -3,  \/* (83) select ::= WITH wqlist selectnowith *\/\n-   -4,  \/* (84) select ::= WITH RECURSIVE wqlist selectnowith *\/\n-   -1,  \/* (85) select ::= selectnowith *\/\n-   -3,  \/* (86) selectnowith ::= selectnowith multiselect_op oneselect *\/\n-   -1,  \/* (87) multiselect_op ::= UNION *\/\n-   -2,  \/* (88) multiselect_op ::= UNION ALL *\/\n-   -1,  \/* (89) multiselect_op ::= EXCEPT|INTERSECT *\/\n-   -9,  \/* (90) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n-  -10,  \/* (91) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n-   -4,  \/* (92) values ::= VALUES LP nexprlist RP *\/\n-   -5,  \/* (93) values ::= values COMMA LP nexprlist RP *\/\n-   -1,  \/* (94) distinct ::= DISTINCT *\/\n-   -1,  \/* (95) distinct ::= ALL *\/\n-    0,  \/* (96) distinct ::= *\/\n-    0,  \/* (97) sclp ::= *\/\n-   -5,  \/* (98) selcollist ::= sclp scanpt expr scanpt as *\/\n-   -3,  \/* (99) selcollist ::= sclp scanpt STAR *\/\n-   -5,  \/* (100) selcollist ::= sclp scanpt nm DOT STAR *\/\n-   -2,  \/* (101) as ::= AS nm *\/\n-    0,  \/* (102) as ::= *\/\n-    0,  \/* (103) from ::= *\/\n-   -2,  \/* (104) from ::= FROM seltablist *\/\n-   -2,  \/* (105) stl_prefix ::= seltablist joinop *\/\n-    0,  \/* (106) stl_prefix ::= *\/\n-   -7,  \/* (107) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt *\/\n-   -9,  \/* (108) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt *\/\n-   -7,  \/* (109) seltablist ::= stl_prefix LP select RP as on_opt using_opt *\/\n-   -7,  \/* (110) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt *\/\n-    0,  \/* (111) dbnm ::= *\/\n-   -2,  \/* (112) dbnm ::= DOT nm *\/\n-   -1,  \/* (113) fullname ::= nm *\/\n-   -3,  \/* (114) fullname ::= nm DOT nm *\/\n-   -1,  \/* (115) xfullname ::= nm *\/\n-   -3,  \/* (116) xfullname ::= nm DOT nm *\/\n-   -5,  \/* (117) xfullname ::= nm DOT nm AS nm *\/\n-   -3,  \/* (118) xfullname ::= nm AS nm *\/\n-   -1,  \/* (119) joinop ::= COMMA|JOIN *\/\n-   -2,  \/* (120) joinop ::= JOIN_KW JOIN *\/\n-   -3,  \/* (121) joinop ::= JOIN_KW nm JOIN *\/\n-   -4,  \/* (122) joinop ::= JOIN_KW nm nm JOIN *\/\n-   -2,  \/* (123) on_opt ::= ON expr *\/\n-    0,  \/* (124) on_opt ::= *\/\n-    0,  \/* (125) indexed_opt ::= *\/\n-   -3,  \/* (126) indexed_opt ::= INDEXED BY nm *\/\n-   -2,  \/* (127) indexed_opt ::= NOT INDEXED *\/\n-   -4,  \/* (128) using_opt ::= USING LP idlist RP *\/\n-    0,  \/* (129) using_opt ::= *\/\n-    0,  \/* (130) orderby_opt ::= *\/\n-   -3,  \/* (131) orderby_opt ::= ORDER BY sortlist *\/\n-   -5,  \/* (132) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n-   -3,  \/* (133) sortlist ::= expr sortorder nulls *\/\n-   -1,  \/* (134) sortorder ::= ASC *\/\n-   -1,  \/* (135) sortorder ::= DESC *\/\n-    0,  \/* (136) sortorder ::= *\/\n-   -2,  \/* (137) nulls ::= NULLS FIRST *\/\n-   -2,  \/* (138) nulls ::= NULLS LAST *\/\n-    0,  \/* (139) nulls ::= *\/\n-    0,  \/* (140) groupby_opt ::= *\/\n-   -3,  \/* (141) groupby_opt ::= GROUP BY nexprlist *\/\n-    0,  \/* (142) having_opt ::= *\/\n-   -2,  \/* (143) having_opt ::= HAVING expr *\/\n-    0,  \/* (144) limit_opt ::= *\/\n-   -2,  \/* (145) limit_opt ::= LIMIT expr *\/\n-   -4,  \/* (146) limit_opt ::= LIMIT expr OFFSET expr *\/\n-   -4,  \/* (147) limit_opt ::= LIMIT expr COMMA expr *\/\n-   -6,  \/* (148) cmd ::= with DELETE FROM xfullname indexed_opt where_opt *\/\n-    0,  \/* (149) where_opt ::= *\/\n-   -2,  \/* (150) where_opt ::= WHERE expr *\/\n-   -8,  \/* (151) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt *\/\n-   -5,  \/* (152) setlist ::= setlist COMMA nm EQ expr *\/\n-   -7,  \/* (153) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n-   -3,  \/* (154) setlist ::= nm EQ expr *\/\n-   -5,  \/* (155) setlist ::= LP idlist RP EQ expr *\/\n-   -7,  \/* (156) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n-   -7,  \/* (157) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES *\/\n-    0,  \/* (158) upsert ::= *\/\n-  -11,  \/* (159) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt *\/\n-   -8,  \/* (160) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING *\/\n-   -4,  \/* (161) upsert ::= ON CONFLICT DO NOTHING *\/\n-   -2,  \/* (162) insert_cmd ::= INSERT orconf *\/\n-   -1,  \/* (163) insert_cmd ::= REPLACE *\/\n-    0,  \/* (164) idlist_opt ::= *\/\n-   -3,  \/* (165) idlist_opt ::= LP idlist RP *\/\n-   -3,  \/* (166) idlist ::= idlist COMMA nm *\/\n-   -1,  \/* (167) idlist ::= nm *\/\n-   -3,  \/* (168) expr ::= LP expr RP *\/\n-   -1,  \/* (169) expr ::= ID|INDEXED *\/\n-   -1,  \/* (170) expr ::= JOIN_KW *\/\n-   -3,  \/* (171) expr ::= nm DOT nm *\/\n-   -5,  \/* (172) expr ::= nm DOT nm DOT nm *\/\n-   -1,  \/* (173) term ::= NULL|FLOAT|BLOB *\/\n-   -1,  \/* (174) term ::= STRING *\/\n-   -1,  \/* (175) term ::= INTEGER *\/\n-   -1,  \/* (176) expr ::= VARIABLE *\/\n-   -3,  \/* (177) expr ::= expr COLLATE ID|STRING *\/\n-   -6,  \/* (178) expr ::= CAST LP expr AS typetoken RP *\/\n-   -5,  \/* (179) expr ::= ID|INDEXED LP distinct exprlist RP *\/\n-   -4,  \/* (180) expr ::= ID|INDEXED LP STAR RP *\/\n-   -6,  \/* (181) expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n-   -5,  \/* (182) expr ::= ID|INDEXED LP STAR RP filter_over *\/\n-   -1,  \/* (183) term ::= CTIME_KW *\/\n-   -5,  \/* (184) expr ::= LP nexprlist COMMA expr RP *\/\n-   -3,  \/* (185) expr ::= expr AND expr *\/\n-   -3,  \/* (186) expr ::= expr OR expr *\/\n-   -3,  \/* (187) expr ::= expr LT|GT|GE|LE expr *\/\n-   -3,  \/* (188) expr ::= expr EQ|NE expr *\/\n-   -3,  \/* (189) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n-   -3,  \/* (190) expr ::= expr PLUS|MINUS expr *\/\n-   -3,  \/* (191) expr ::= expr STAR|SLASH|REM expr *\/\n-   -3,  \/* (192) expr ::= expr CONCAT expr *\/\n-   -2,  \/* (193) likeop ::= NOT LIKE_KW|MATCH *\/\n-   -3,  \/* (194) expr ::= expr likeop expr *\/\n-   -5,  \/* (195) expr ::= expr likeop expr ESCAPE expr *\/\n-   -2,  \/* (196) expr ::= expr ISNULL|NOTNULL *\/\n-   -3,  \/* (197) expr ::= expr NOT NULL *\/\n-   -3,  \/* (198) expr ::= expr IS expr *\/\n-   -4,  \/* (199) expr ::= expr IS NOT expr *\/\n-   -2,  \/* (200) expr ::= NOT expr *\/\n-   -2,  \/* (201) expr ::= BITNOT expr *\/\n-   -2,  \/* (202) expr ::= PLUS|MINUS expr *\/\n-   -1,  \/* (203) between_op ::= BETWEEN *\/\n-   -2,  \/* (204) between_op ::= NOT BETWEEN *\/\n-   -5,  \/* (205) expr ::= expr between_op expr AND expr *\/\n-   -1,  \/* (206) in_op ::= IN *\/\n-   -2,  \/* (207) in_op ::= NOT IN *\/\n-   -5,  \/* (208) expr ::= expr in_op LP exprlist RP *\/\n-   -3,  \/* (209) expr ::= LP select RP *\/\n-   -5,  \/* (210) expr ::= expr in_op LP select RP *\/\n-   -5,  \/* (211) expr ::= expr in_op nm dbnm paren_exprlist *\/\n-   -4,  \/* (212) expr ::= EXISTS LP select RP *\/\n-   -5,  \/* (213) expr ::= CASE case_operand case_exprlist case_else END *\/\n-   -5,  \/* (214) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n-   -4,  \/* (215) case_exprlist ::= WHEN expr THEN expr *\/\n-   -2,  \/* (216) case_else ::= ELSE expr *\/\n-    0,  \/* (217) case_else ::= *\/\n-   -1,  \/* (218) case_operand ::= expr *\/\n-    0,  \/* (219) case_operand ::= *\/\n-    0,  \/* (220) exprlist ::= *\/\n-   -3,  \/* (221) nexprlist ::= nexprlist COMMA expr *\/\n-   -1,  \/* (222) nexprlist ::= expr *\/\n-    0,  \/* (223) paren_exprlist ::= *\/\n-   -3,  \/* (224) paren_exprlist ::= LP exprlist RP *\/\n-  -12,  \/* (225) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n-   -1,  \/* (226) uniqueflag ::= UNIQUE *\/\n-    0,  \/* (227) uniqueflag ::= *\/\n-    0,  \/* (228) eidlist_opt ::= *\/\n-   -3,  \/* (229) eidlist_opt ::= LP eidlist RP *\/\n-   -5,  \/* (230) eidlist ::= eidlist COMMA nm collate sortorder *\/\n-   -3,  \/* (231) eidlist ::= nm collate sortorder *\/\n-    0,  \/* (232) collate ::= *\/\n-   -2,  \/* (233) collate ::= COLLATE ID|STRING *\/\n-   -4,  \/* (234) cmd ::= DROP INDEX ifexists fullname *\/\n-   -2,  \/* (235) cmd ::= VACUUM vinto *\/\n-   -3,  \/* (236) cmd ::= VACUUM nm vinto *\/\n-   -2,  \/* (237) vinto ::= INTO expr *\/\n-    0,  \/* (238) vinto ::= *\/\n-   -3,  \/* (239) cmd ::= PRAGMA nm dbnm *\/\n-   -5,  \/* (240) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n-   -6,  \/* (241) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n-   -5,  \/* (242) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n-   -6,  \/* (243) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n-   -2,  \/* (244) plus_num ::= PLUS INTEGER|FLOAT *\/\n-   -2,  \/* (245) minus_num ::= MINUS INTEGER|FLOAT *\/\n-   -5,  \/* (246) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n-  -11,  \/* (247) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n-   -1,  \/* (248) trigger_time ::= BEFORE|AFTER *\/\n-   -2,  \/* (249) trigger_time ::= INSTEAD OF *\/\n-    0,  \/* (250) trigger_time ::= *\/\n-   -1,  \/* (251) trigger_event ::= DELETE|INSERT *\/\n-   -1,  \/* (252) trigger_event ::= UPDATE *\/\n-   -3,  \/* (253) trigger_event ::= UPDATE OF idlist *\/\n-    0,  \/* (254) when_clause ::= *\/\n-   -2,  \/* (255) when_clause ::= WHEN expr *\/\n-   -3,  \/* (256) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n-   -2,  \/* (257) trigger_cmd_list ::= trigger_cmd SEMI *\/\n-   -3,  \/* (258) trnm ::= nm DOT nm *\/\n-   -3,  \/* (259) tridxby ::= INDEXED BY nm *\/\n-   -2,  \/* (260) tridxby ::= NOT INDEXED *\/\n-   -8,  \/* (261) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt *\/\n-   -8,  \/* (262) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n-   -6,  \/* (263) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n-   -3,  \/* (264) trigger_cmd ::= scanpt select scanpt *\/\n-   -4,  \/* (265) expr ::= RAISE LP IGNORE RP *\/\n-   -6,  \/* (266) expr ::= RAISE LP raisetype COMMA nm RP *\/\n-   -1,  \/* (267) raisetype ::= ROLLBACK *\/\n-   -1,  \/* (268) raisetype ::= ABORT *\/\n-   -1,  \/* (269) raisetype ::= FAIL *\/\n-   -4,  \/* (270) cmd ::= DROP TRIGGER ifexists fullname *\/\n-   -6,  \/* (271) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n-   -3,  \/* (272) cmd ::= DETACH database_kw_opt expr *\/\n-    0,  \/* (273) key_opt ::= *\/\n-   -2,  \/* (274) key_opt ::= KEY expr *\/\n-   -1,  \/* (275) cmd ::= REINDEX *\/\n-   -3,  \/* (276) cmd ::= REINDEX nm dbnm *\/\n-   -1,  \/* (277) cmd ::= ANALYZE *\/\n-   -3,  \/* (278) cmd ::= ANALYZE nm dbnm *\/\n-   -6,  \/* (279) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n-   -7,  \/* (280) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n-   -1,  \/* (281) add_column_fullname ::= fullname *\/\n-   -8,  \/* (282) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n-   -1,  \/* (283) cmd ::= create_vtab *\/\n-   -4,  \/* (284) cmd ::= create_vtab LP vtabarglist RP *\/\n-   -8,  \/* (285) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n-    0,  \/* (286) vtabarg ::= *\/\n-   -1,  \/* (287) vtabargtoken ::= ANY *\/\n-   -3,  \/* (288) vtabargtoken ::= lp anylist RP *\/\n-   -1,  \/* (289) lp ::= LP *\/\n-   -2,  \/* (290) with ::= WITH wqlist *\/\n-   -3,  \/* (291) with ::= WITH RECURSIVE wqlist *\/\n-   -6,  \/* (292) wqlist ::= nm eidlist_opt AS LP select RP *\/\n-   -8,  \/* (293) wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP *\/\n-   -1,  \/* (294) windowdefn_list ::= windowdefn *\/\n-   -3,  \/* (295) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n-   -5,  \/* (296) windowdefn ::= nm AS LP window RP *\/\n-   -5,  \/* (297) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   -6,  \/* (298) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   -4,  \/* (299) window ::= ORDER BY sortlist frame_opt *\/\n-   -5,  \/* (300) window ::= nm ORDER BY sortlist frame_opt *\/\n-   -1,  \/* (301) window ::= frame_opt *\/\n-   -2,  \/* (302) window ::= nm frame_opt *\/\n-    0,  \/* (303) frame_opt ::= *\/\n-   -3,  \/* (304) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n-   -6,  \/* (305) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n-   -1,  \/* (306) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n-   -1,  \/* (307) frame_bound_s ::= frame_bound *\/\n-   -2,  \/* (308) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-   -1,  \/* (309) frame_bound_e ::= frame_bound *\/\n-   -2,  \/* (310) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n-   -2,  \/* (311) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-   -2,  \/* (312) frame_bound ::= CURRENT ROW *\/\n-    0,  \/* (313) frame_exclude_opt ::= *\/\n-   -2,  \/* (314) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-   -2,  \/* (315) frame_exclude ::= NO OTHERS *\/\n-   -2,  \/* (316) frame_exclude ::= CURRENT ROW *\/\n-   -1,  \/* (317) frame_exclude ::= GROUP|TIES *\/\n-   -2,  \/* (318) window_clause ::= WINDOW windowdefn_list *\/\n-   -2,  \/* (319) filter_over ::= filter_clause over_clause *\/\n-   -1,  \/* (320) filter_over ::= over_clause *\/\n-   -1,  \/* (321) filter_over ::= filter_clause *\/\n-   -4,  \/* (322) over_clause ::= OVER LP window RP *\/\n-   -2,  \/* (323) over_clause ::= OVER nm *\/\n-   -5,  \/* (324) filter_clause ::= FILTER LP WHERE expr RP *\/\n-   -1,  \/* (325) input ::= cmdlist *\/\n-   -2,  \/* (326) cmdlist ::= cmdlist ecmd *\/\n-   -1,  \/* (327) cmdlist ::= ecmd *\/\n-   -1,  \/* (328) ecmd ::= SEMI *\/\n-   -2,  \/* (329) ecmd ::= cmdx SEMI *\/\n-   -3,  \/* (330) ecmd ::= explain cmdx SEMI *\/\n-    0,  \/* (331) trans_opt ::= *\/\n-   -1,  \/* (332) trans_opt ::= TRANSACTION *\/\n-   -2,  \/* (333) trans_opt ::= TRANSACTION nm *\/\n-   -1,  \/* (334) savepoint_opt ::= SAVEPOINT *\/\n-    0,  \/* (335) savepoint_opt ::= *\/\n-   -2,  \/* (336) cmd ::= create_table create_table_args *\/\n-   -4,  \/* (337) columnlist ::= columnlist COMMA columnname carglist *\/\n-   -2,  \/* (338) columnlist ::= columnname carglist *\/\n-   -1,  \/* (339) nm ::= ID|INDEXED *\/\n-   -1,  \/* (340) nm ::= STRING *\/\n-   -1,  \/* (341) nm ::= JOIN_KW *\/\n-   -1,  \/* (342) typetoken ::= typename *\/\n-   -1,  \/* (343) typename ::= ID|STRING *\/\n-   -1,  \/* (344) signed ::= plus_num *\/\n-   -1,  \/* (345) signed ::= minus_num *\/\n-   -2,  \/* (346) carglist ::= carglist ccons *\/\n-    0,  \/* (347) carglist ::= *\/\n-   -2,  \/* (348) ccons ::= NULL onconf *\/\n-   -4,  \/* (349) ccons ::= GENERATED ALWAYS AS generated *\/\n-   -2,  \/* (350) ccons ::= AS generated *\/\n-   -2,  \/* (351) conslist_opt ::= COMMA conslist *\/\n-   -3,  \/* (352) conslist ::= conslist tconscomma tcons *\/\n-   -1,  \/* (353) conslist ::= tcons *\/\n-    0,  \/* (354) tconscomma ::= *\/\n-   -1,  \/* (355) defer_subclause_opt ::= defer_subclause *\/\n-   -1,  \/* (356) resolvetype ::= raisetype *\/\n-   -1,  \/* (357) selectnowith ::= oneselect *\/\n-   -1,  \/* (358) oneselect ::= values *\/\n-   -2,  \/* (359) sclp ::= selcollist COMMA *\/\n-   -1,  \/* (360) as ::= ID|STRING *\/\n-   -1,  \/* (361) expr ::= term *\/\n-   -1,  \/* (362) likeop ::= LIKE_KW|MATCH *\/\n-   -1,  \/* (363) exprlist ::= nexprlist *\/\n-   -1,  \/* (364) nmnum ::= plus_num *\/\n-   -1,  \/* (365) nmnum ::= nm *\/\n-   -1,  \/* (366) nmnum ::= ON *\/\n-   -1,  \/* (367) nmnum ::= DELETE *\/\n-   -1,  \/* (368) nmnum ::= DEFAULT *\/\n-   -1,  \/* (369) plus_num ::= INTEGER|FLOAT *\/\n-    0,  \/* (370) foreach_clause ::= *\/\n-   -3,  \/* (371) foreach_clause ::= FOR EACH ROW *\/\n-   -1,  \/* (372) trnm ::= nm *\/\n-    0,  \/* (373) tridxby ::= *\/\n-   -1,  \/* (374) database_kw_opt ::= DATABASE *\/\n-    0,  \/* (375) database_kw_opt ::= *\/\n-    0,  \/* (376) kwcolumn_opt ::= *\/\n-   -1,  \/* (377) kwcolumn_opt ::= COLUMNKW *\/\n-   -1,  \/* (378) vtabarglist ::= vtabarg *\/\n-   -3,  \/* (379) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n-   -2,  \/* (380) vtabarg ::= vtabarg vtabargtoken *\/\n-    0,  \/* (381) anylist ::= *\/\n-   -4,  \/* (382) anylist ::= anylist LP anylist RP *\/\n-   -2,  \/* (383) anylist ::= anylist ANY *\/\n-    0,  \/* (384) with ::= *\/\n+    0,  \/* (21) table_option_set ::= *\/\n+   -3,  \/* (22) table_option_set ::= table_option_set COMMA table_option *\/\n+   -2,  \/* (23) table_option ::= WITHOUT nm *\/\n+   -1,  \/* (24) table_option ::= nm *\/\n+   -2,  \/* (25) columnname ::= nm typetoken *\/\n+    0,  \/* (26) typetoken ::= *\/\n+   -4,  \/* (27) typetoken ::= typename LP signed RP *\/\n+   -6,  \/* (28) typetoken ::= typename LP signed COMMA signed RP *\/\n+   -2,  \/* (29) typename ::= typename ID|STRING *\/\n+    0,  \/* (30) scanpt ::= *\/\n+    0,  \/* (31) scantok ::= *\/\n+   -2,  \/* (32) ccons ::= CONSTRAINT nm *\/\n+   -3,  \/* (33) ccons ::= DEFAULT scantok term *\/\n+   -4,  \/* (34) ccons ::= DEFAULT LP expr RP *\/\n+   -4,  \/* (35) ccons ::= DEFAULT PLUS scantok term *\/\n+   -4,  \/* (36) ccons ::= DEFAULT MINUS scantok term *\/\n+   -3,  \/* (37) ccons ::= DEFAULT scantok ID|INDEXED *\/\n+   -3,  \/* (38) ccons ::= NOT NULL onconf *\/\n+   -5,  \/* (39) ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n+   -2,  \/* (40) ccons ::= UNIQUE onconf *\/\n+   -4,  \/* (41) ccons ::= CHECK LP expr RP *\/\n+   -4,  \/* (42) ccons ::= REFERENCES nm eidlist_opt refargs *\/\n+   -1,  \/* (43) ccons ::= defer_subclause *\/\n+   -2,  \/* (44) ccons ::= COLLATE ID|STRING *\/\n+   -3,  \/* (45) generated ::= LP expr RP *\/\n+   -4,  \/* (46) generated ::= LP expr RP ID *\/\n+    0,  \/* (47) autoinc ::= *\/\n+   -1,  \/* (48) autoinc ::= AUTOINCR *\/\n+    0,  \/* (49) refargs ::= *\/\n+   -2,  \/* (50) refargs ::= refargs refarg *\/\n+   -2,  \/* (51) refarg ::= MATCH nm *\/\n+   -3,  \/* (52) refarg ::= ON INSERT refact *\/\n+   -3,  \/* (53) refarg ::= ON DELETE refact *\/\n+   -3,  \/* (54) refarg ::= ON UPDATE refact *\/\n+   -2,  \/* (55) refact ::= SET NULL *\/\n+   -2,  \/* (56) refact ::= SET DEFAULT *\/\n+   -1,  \/* (57) refact ::= CASCADE *\/\n+   -1,  \/* (58) refact ::= RESTRICT *\/\n+   -2,  \/* (59) refact ::= NO ACTION *\/\n+   -3,  \/* (60) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n+   -2,  \/* (61) defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n+    0,  \/* (62) init_deferred_pred_opt ::= *\/\n+   -2,  \/* (63) init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n+   -2,  \/* (64) init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n+    0,  \/* (65) conslist_opt ::= *\/\n+   -1,  \/* (66) tconscomma ::= COMMA *\/\n+   -2,  \/* (67) tcons ::= CONSTRAINT nm *\/\n+   -7,  \/* (68) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n+   -5,  \/* (69) tcons ::= UNIQUE LP sortlist RP onconf *\/\n+   -5,  \/* (70) tcons ::= CHECK LP expr RP onconf *\/\n+  -10,  \/* (71) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n+    0,  \/* (72) defer_subclause_opt ::= *\/\n+    0,  \/* (73) onconf ::= *\/\n+   -3,  \/* (74) onconf ::= ON CONFLICT resolvetype *\/\n+    0,  \/* (75) orconf ::= *\/\n+   -2,  \/* (76) orconf ::= OR resolvetype *\/\n+   -1,  \/* (77) resolvetype ::= IGNORE *\/\n+   -1,  \/* (78) resolvetype ::= REPLACE *\/\n+   -4,  \/* (79) cmd ::= DROP TABLE ifexists fullname *\/\n+   -2,  \/* (80) ifexists ::= IF EXISTS *\/\n+    0,  \/* (81) ifexists ::= *\/\n+   -9,  \/* (82) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n+   -4,  \/* (83) cmd ::= DROP VIEW ifexists fullname *\/\n+   -1,  \/* (84) cmd ::= select *\/\n+   -3,  \/* (85) select ::= WITH wqlist selectnowith *\/\n+   -4,  \/* (86) select ::= WITH RECURSIVE wqlist selectnowith *\/\n+   -1,  \/* (87) select ::= selectnowith *\/\n+   -3,  \/* (88) selectnowith ::= selectnowith multiselect_op oneselect *\/\n+   -1,  \/* (89) multiselect_op ::= UNION *\/\n+   -2,  \/* (90) multiselect_op ::= UNION ALL *\/\n+   -1,  \/* (91) multiselect_op ::= EXCEPT|INTERSECT *\/\n+   -9,  \/* (92) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n+  -10,  \/* (93) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n+   -4,  \/* (94) values ::= VALUES LP nexprlist RP *\/\n+   -5,  \/* (95) values ::= values COMMA LP nexprlist RP *\/\n+   -1,  \/* (96) distinct ::= DISTINCT *\/\n+   -1,  \/* (97) distinct ::= ALL *\/\n+    0,  \/* (98) distinct ::= *\/\n+    0,  \/* (99) sclp ::= *\/\n+   -5,  \/* (100) selcollist ::= sclp scanpt expr scanpt as *\/\n+   -3,  \/* (101) selcollist ::= sclp scanpt STAR *\/\n+   -5,  \/* (102) selcollist ::= sclp scanpt nm DOT STAR *\/\n+   -2,  \/* (103) as ::= AS nm *\/\n+    0,  \/* (104) as ::= *\/\n+    0,  \/* (105) from ::= *\/\n+   -2,  \/* (106) from ::= FROM seltablist *\/\n+   -2,  \/* (107) stl_prefix ::= seltablist joinop *\/\n+    0,  \/* (108) stl_prefix ::= *\/\n+   -7,  \/* (109) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt *\/\n+   -9,  \/* (110) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt *\/\n+   -7,  \/* (111) seltablist ::= stl_prefix LP select RP as on_opt using_opt *\/\n+   -7,  \/* (112) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt *\/\n+    0,  \/* (113) dbnm ::= *\/\n+   -2,  \/* (114) dbnm ::= DOT nm *\/\n+   -1,  \/* (115) fullname ::= nm *\/\n+   -3,  \/* (116) fullname ::= nm DOT nm *\/\n+   -1,  \/* (117) xfullname ::= nm *\/\n+   -3,  \/* (118) xfullname ::= nm DOT nm *\/\n+   -5,  \/* (119) xfullname ::= nm DOT nm AS nm *\/\n+   -3,  \/* (120) xfullname ::= nm AS nm *\/\n+   -1,  \/* (121) joinop ::= COMMA|JOIN *\/\n+   -2,  \/* (122) joinop ::= JOIN_KW JOIN *\/\n+   -3,  \/* (123) joinop ::= JOIN_KW nm JOIN *\/\n+   -4,  \/* (124) joinop ::= JOIN_KW nm nm JOIN *\/\n+   -2,  \/* (125) on_opt ::= ON expr *\/\n+    0,  \/* (126) on_opt ::= *\/\n+    0,  \/* (127) indexed_opt ::= *\/\n+   -3,  \/* (128) indexed_opt ::= INDEXED BY nm *\/\n+   -2,  \/* (129) indexed_opt ::= NOT INDEXED *\/\n+   -4,  \/* (130) using_opt ::= USING LP idlist RP *\/\n+    0,  \/* (131) using_opt ::= *\/\n+    0,  \/* (132) orderby_opt ::= *\/\n+   -3,  \/* (133) orderby_opt ::= ORDER BY sortlist *\/\n+   -5,  \/* (134) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n+   -3,  \/* (135) sortlist ::= expr sortorder nulls *\/\n+   -1,  \/* (136) sortorder ::= ASC *\/\n+   -1,  \/* (137) sortorder ::= DESC *\/\n+    0,  \/* (138) sortorder ::= *\/\n+   -2,  \/* (139) nulls ::= NULLS FIRST *\/\n+   -2,  \/* (140) nulls ::= NULLS LAST *\/\n+    0,  \/* (141) nulls ::= *\/\n+    0,  \/* (142) groupby_opt ::= *\/\n+   -3,  \/* (143) groupby_opt ::= GROUP BY nexprlist *\/\n+    0,  \/* (144) having_opt ::= *\/\n+   -2,  \/* (145) having_opt ::= HAVING expr *\/\n+    0,  \/* (146) limit_opt ::= *\/\n+   -2,  \/* (147) limit_opt ::= LIMIT expr *\/\n+   -4,  \/* (148) limit_opt ::= LIMIT expr OFFSET expr *\/\n+   -4,  \/* (149) limit_opt ::= LIMIT expr COMMA expr *\/\n+   -6,  \/* (150) cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n+    0,  \/* (151) where_opt ::= *\/\n+   -2,  \/* (152) where_opt ::= WHERE expr *\/\n+    0,  \/* (153) where_opt_ret ::= *\/\n+   -2,  \/* (154) where_opt_ret ::= WHERE expr *\/\n+   -2,  \/* (155) where_opt_ret ::= RETURNING selcollist *\/\n+   -4,  \/* (156) where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n+   -9,  \/* (157) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n+   -5,  \/* (158) setlist ::= setlist COMMA nm EQ expr *\/\n+   -7,  \/* (159) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n+   -3,  \/* (160) setlist ::= nm EQ expr *\/\n+   -5,  \/* (161) setlist ::= LP idlist RP EQ expr *\/\n+   -7,  \/* (162) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n+   -8,  \/* (163) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n+    0,  \/* (164) upsert ::= *\/\n+   -2,  \/* (165) upsert ::= RETURNING selcollist *\/\n+  -12,  \/* (166) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n+   -9,  \/* (167) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n+   -5,  \/* (168) upsert ::= ON CONFLICT DO NOTHING returning *\/\n+   -8,  \/* (169) upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n+   -2,  \/* (170) returning ::= RETURNING selcollist *\/\n+   -2,  \/* (171) insert_cmd ::= INSERT orconf *\/\n+   -1,  \/* (172) insert_cmd ::= REPLACE *\/\n+    0,  \/* (173) idlist_opt ::= *\/\n+   -3,  \/* (174) idlist_opt ::= LP idlist RP *\/\n+   -3,  \/* (175) idlist ::= idlist COMMA nm *\/\n+   -1,  \/* (176) idlist ::= nm *\/\n+   -3,  \/* (177) expr ::= LP expr RP *\/\n+   -1,  \/* (178) expr ::= ID|INDEXED *\/\n+   -1,  \/* (179) expr ::= JOIN_KW *\/\n+   -3,  \/* (180) expr ::= nm DOT nm *\/\n+   -5,  \/* (181) expr ::= nm DOT nm DOT nm *\/\n+   -1,  \/* (182) term ::= NULL|FLOAT|BLOB *\/\n+   -1,  \/* (183) term ::= STRING *\/\n+   -1,  \/* (184) term ::= INTEGER *\/\n+   -1,  \/* (185) expr ::= VARIABLE *\/\n+   -3,  \/* (186) expr ::= expr COLLATE ID|STRING *\/\n+   -6,  \/* (187) expr ::= CAST LP expr AS typetoken RP *\/\n+   -5,  \/* (188) expr ::= ID|INDEXED LP distinct exprlist RP *\/\n+   -4,  \/* (189) expr ::= ID|INDEXED LP STAR RP *\/\n+   -6,  \/* (190) expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n+   -5,  \/* (191) expr ::= ID|INDEXED LP STAR RP filter_over *\/\n+   -1,  \/* (192) term ::= CTIME_KW *\/\n+   -5,  \/* (193) expr ::= LP nexprlist COMMA expr RP *\/\n+   -3,  \/* (194) expr ::= expr AND expr *\/\n+   -3,  \/* (195) expr ::= expr OR expr *\/\n+   -3,  \/* (196) expr ::= expr LT|GT|GE|LE expr *\/\n+   -3,  \/* (197) expr ::= expr EQ|NE expr *\/\n+   -3,  \/* (198) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n+   -3,  \/* (199) expr ::= expr PLUS|MINUS expr *\/\n+   -3,  \/* (200) expr ::= expr STAR|SLASH|REM expr *\/\n+   -3,  \/* (201) expr ::= expr CONCAT expr *\/\n+   -2,  \/* (202) likeop ::= NOT LIKE_KW|MATCH *\/\n+   -3,  \/* (203) expr ::= expr likeop expr *\/\n+   -5,  \/* (204) expr ::= expr likeop expr ESCAPE expr *\/\n+   -2,  \/* (205) expr ::= expr ISNULL|NOTNULL *\/\n+   -3,  \/* (206) expr ::= expr NOT NULL *\/\n+   -3,  \/* (207) expr ::= expr IS expr *\/\n+   -4,  \/* (208) expr ::= expr IS NOT expr *\/\n+   -2,  \/* (209) expr ::= NOT expr *\/\n+   -2,  \/* (210) expr ::= BITNOT expr *\/\n+   -2,  \/* (211) expr ::= PLUS|MINUS expr *\/\n+   -1,  \/* (212) between_op ::= BETWEEN *\/\n+   -2,  \/* (213) between_op ::= NOT BETWEEN *\/\n+   -5,  \/* (214) expr ::= expr between_op expr AND expr *\/\n+   -1,  \/* (215) in_op ::= IN *\/\n+   -2,  \/* (216) in_op ::= NOT IN *\/\n+   -5,  \/* (217) expr ::= expr in_op LP exprlist RP *\/\n+   -3,  \/* (218) expr ::= LP select RP *\/\n+   -5,  \/* (219) expr ::= expr in_op LP select RP *\/\n+   -5,  \/* (220) expr ::= expr in_op nm dbnm paren_exprlist *\/\n+   -4,  \/* (221) expr ::= EXISTS LP select RP *\/\n+   -5,  \/* (222) expr ::= CASE case_operand case_exprlist case_else END *\/\n+   -5,  \/* (223) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+   -4,  \/* (224) case_exprlist ::= WHEN expr THEN expr *\/\n+   -2,  \/* (225) case_else ::= ELSE expr *\/\n+    0,  \/* (226) case_else ::= *\/\n+   -1,  \/* (227) case_operand ::= expr *\/\n+    0,  \/* (228) case_operand ::= *\/\n+    0,  \/* (229) exprlist ::= *\/\n+   -3,  \/* (230) nexprlist ::= nexprlist COMMA expr *\/\n+   -1,  \/* (231) nexprlist ::= expr *\/\n+    0,  \/* (232) paren_exprlist ::= *\/\n+   -3,  \/* (233) paren_exprlist ::= LP exprlist RP *\/\n+  -12,  \/* (234) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n+   -1,  \/* (235) uniqueflag ::= UNIQUE *\/\n+    0,  \/* (236) uniqueflag ::= *\/\n+    0,  \/* (237) eidlist_opt ::= *\/\n+   -3,  \/* (238) eidlist_opt ::= LP eidlist RP *\/\n+   -5,  \/* (239) eidlist ::= eidlist COMMA nm collate sortorder *\/\n+   -3,  \/* (240) eidlist ::= nm collate sortorder *\/\n+    0,  \/* (241) collate ::= *\/\n+   -2,  \/* (242) collate ::= COLLATE ID|STRING *\/\n+   -4,  \/* (243) cmd ::= DROP INDEX ifexists fullname *\/\n+   -2,  \/* (244) cmd ::= VACUUM vinto *\/\n+   -3,  \/* (245) cmd ::= VACUUM nm vinto *\/\n+   -2,  \/* (246) vinto ::= INTO expr *\/\n+    0,  \/* (247) vinto ::= *\/\n+   -3,  \/* (248) cmd ::= PRAGMA nm dbnm *\/\n+   -5,  \/* (249) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n+   -6,  \/* (250) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n+   -5,  \/* (251) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n+   -6,  \/* (252) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n+   -2,  \/* (253) plus_num ::= PLUS INTEGER|FLOAT *\/\n+   -2,  \/* (254) minus_num ::= MINUS INTEGER|FLOAT *\/\n+   -5,  \/* (255) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n+  -11,  \/* (256) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n+   -1,  \/* (257) trigger_time ::= BEFORE|AFTER *\/\n+   -2,  \/* (258) trigger_time ::= INSTEAD OF *\/\n+    0,  \/* (259) trigger_time ::= *\/\n+   -1,  \/* (260) trigger_event ::= DELETE|INSERT *\/\n+   -1,  \/* (261) trigger_event ::= UPDATE *\/\n+   -3,  \/* (262) trigger_event ::= UPDATE OF idlist *\/\n+    0,  \/* (263) when_clause ::= *\/\n+   -2,  \/* (264) when_clause ::= WHEN expr *\/\n+   -3,  \/* (265) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n+   -2,  \/* (266) trigger_cmd_list ::= trigger_cmd SEMI *\/\n+   -3,  \/* (267) trnm ::= nm DOT nm *\/\n+   -3,  \/* (268) tridxby ::= INDEXED BY nm *\/\n+   -2,  \/* (269) tridxby ::= NOT INDEXED *\/\n+   -9,  \/* (270) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n+   -8,  \/* (271) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n+   -6,  \/* (272) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n+   -3,  \/* (273) trigger_cmd ::= scanpt select scanpt *\/\n+   -4,  \/* (274) expr ::= RAISE LP IGNORE RP *\/\n+   -6,  \/* (275) expr ::= RAISE LP raisetype COMMA nm RP *\/\n+   -1,  \/* (276) raisetype ::= ROLLBACK *\/\n+   -1,  \/* (277) raisetype ::= ABORT *\/\n+   -1,  \/* (278) raisetype ::= FAIL *\/\n+   -4,  \/* (279) cmd ::= DROP TRIGGER ifexists fullname *\/\n+   -6,  \/* (280) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n+   -3,  \/* (281) cmd ::= DETACH database_kw_opt expr *\/\n+    0,  \/* (282) key_opt ::= *\/\n+   -2,  \/* (283) key_opt ::= KEY expr *\/\n+   -1,  \/* (284) cmd ::= REINDEX *\/\n+   -3,  \/* (285) cmd ::= REINDEX nm dbnm *\/\n+   -1,  \/* (286) cmd ::= ANALYZE *\/\n+   -3,  \/* (287) cmd ::= ANALYZE nm dbnm *\/\n+   -6,  \/* (288) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n+   -7,  \/* (289) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n+   -6,  \/* (290) cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n+   -1,  \/* (291) add_column_fullname ::= fullname *\/\n+   -8,  \/* (292) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n+   -1,  \/* (293) cmd ::= create_vtab *\/\n+   -4,  \/* (294) cmd ::= create_vtab LP vtabarglist RP *\/\n+   -8,  \/* (295) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n+    0,  \/* (296) vtabarg ::= *\/\n+   -1,  \/* (297) vtabargtoken ::= ANY *\/\n+   -3,  \/* (298) vtabargtoken ::= lp anylist RP *\/\n+   -1,  \/* (299) lp ::= LP *\/\n+   -2,  \/* (300) with ::= WITH wqlist *\/\n+   -3,  \/* (301) with ::= WITH RECURSIVE wqlist *\/\n+   -1,  \/* (302) wqas ::= AS *\/\n+   -2,  \/* (303) wqas ::= AS MATERIALIZED *\/\n+   -3,  \/* (304) wqas ::= AS NOT MATERIALIZED *\/\n+   -6,  \/* (305) wqitem ::= nm eidlist_opt wqas LP select RP *\/\n+   -1,  \/* (306) wqlist ::= wqitem *\/\n+   -3,  \/* (307) wqlist ::= wqlist COMMA wqitem *\/\n+   -1,  \/* (308) windowdefn_list ::= windowdefn *\/\n+   -3,  \/* (309) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+   -5,  \/* (310) windowdefn ::= nm AS LP window RP *\/\n+   -5,  \/* (311) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   -6,  \/* (312) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   -4,  \/* (313) window ::= ORDER BY sortlist frame_opt *\/\n+   -5,  \/* (314) window ::= nm ORDER BY sortlist frame_opt *\/\n+   -1,  \/* (315) window ::= frame_opt *\/\n+   -2,  \/* (316) window ::= nm frame_opt *\/\n+    0,  \/* (317) frame_opt ::= *\/\n+   -3,  \/* (318) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+   -6,  \/* (319) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+   -1,  \/* (320) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n+   -1,  \/* (321) frame_bound_s ::= frame_bound *\/\n+   -2,  \/* (322) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+   -1,  \/* (323) frame_bound_e ::= frame_bound *\/\n+   -2,  \/* (324) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n+   -2,  \/* (325) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+   -2,  \/* (326) frame_bound ::= CURRENT ROW *\/\n+    0,  \/* (327) frame_exclude_opt ::= *\/\n+   -2,  \/* (328) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+   -2,  \/* (329) frame_exclude ::= NO OTHERS *\/\n+   -2,  \/* (330) frame_exclude ::= CURRENT ROW *\/\n+   -1,  \/* (331) frame_exclude ::= GROUP|TIES *\/\n+   -2,  \/* (332) window_clause ::= WINDOW windowdefn_list *\/\n+   -2,  \/* (333) filter_over ::= filter_clause over_clause *\/\n+   -1,  \/* (334) filter_over ::= over_clause *\/\n+   -1,  \/* (335) filter_over ::= filter_clause *\/\n+   -4,  \/* (336) over_clause ::= OVER LP window RP *\/\n+   -2,  \/* (337) over_clause ::= OVER nm *\/\n+   -5,  \/* (338) filter_clause ::= FILTER LP WHERE expr RP *\/\n+   -1,  \/* (339) input ::= cmdlist *\/\n+   -2,  \/* (340) cmdlist ::= cmdlist ecmd *\/\n+   -1,  \/* (341) cmdlist ::= ecmd *\/\n+   -1,  \/* (342) ecmd ::= SEMI *\/\n+   -2,  \/* (343) ecmd ::= cmdx SEMI *\/\n+   -3,  \/* (344) ecmd ::= explain cmdx SEMI *\/\n+    0,  \/* (345) trans_opt ::= *\/\n+   -1,  \/* (346) trans_opt ::= TRANSACTION *\/\n+   -2,  \/* (347) trans_opt ::= TRANSACTION nm *\/\n+   -1,  \/* (348) savepoint_opt ::= SAVEPOINT *\/\n+    0,  \/* (349) savepoint_opt ::= *\/\n+   -2,  \/* (350) cmd ::= create_table create_table_args *\/\n+   -1,  \/* (351) table_option_set ::= table_option *\/\n+   -4,  \/* (352) columnlist ::= columnlist COMMA columnname carglist *\/\n+   -2,  \/* (353) columnlist ::= columnname carglist *\/\n+   -1,  \/* (354) nm ::= ID|INDEXED *\/\n+   -1,  \/* (355) nm ::= STRING *\/\n+   -1,  \/* (356) nm ::= JOIN_KW *\/\n+   -1,  \/* (357) typetoken ::= typename *\/\n+   -1,  \/* (358) typename ::= ID|STRING *\/\n+   -1,  \/* (359) signed ::= plus_num *\/\n+   -1,  \/* (360) signed ::= minus_num *\/\n+   -2,  \/* (361) carglist ::= carglist ccons *\/\n+    0,  \/* (362) carglist ::= *\/\n+   -2,  \/* (363) ccons ::= NULL onconf *\/\n+   -4,  \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/\n+   -2,  \/* (365) ccons ::= AS generated *\/\n+   -2,  \/* (366) conslist_opt ::= COMMA conslist *\/\n+   -3,  \/* (367) conslist ::= conslist tconscomma tcons *\/\n+   -1,  \/* (368) conslist ::= tcons *\/\n+    0,  \/* (369) tconscomma ::= *\/\n+   -1,  \/* (370) defer_subclause_opt ::= defer_subclause *\/\n+   -1,  \/* (371) resolvetype ::= raisetype *\/\n+   -1,  \/* (372) selectnowith ::= oneselect *\/\n+   -1,  \/* (373) oneselect ::= values *\/\n+   -2,  \/* (374) sclp ::= selcollist COMMA *\/\n+   -1,  \/* (375) as ::= ID|STRING *\/\n+    0,  \/* (376) returning ::= *\/\n+   -1,  \/* (377) expr ::= term *\/\n+   -1,  \/* (378) likeop ::= LIKE_KW|MATCH *\/\n+   -1,  \/* (379) exprlist ::= nexprlist *\/\n+   -1,  \/* (380) nmnum ::= plus_num *\/\n+   -1,  \/* (381) nmnum ::= nm *\/\n+   -1,  \/* (382) nmnum ::= ON *\/\n+   -1,  \/* (383) nmnum ::= DELETE *\/\n+   -1,  \/* (384) nmnum ::= DEFAULT *\/\n+   -1,  \/* (385) plus_num ::= INTEGER|FLOAT *\/\n+    0,  \/* (386) foreach_clause ::= *\/\n+   -3,  \/* (387) foreach_clause ::= FOR EACH ROW *\/\n+   -1,  \/* (388) trnm ::= nm *\/\n+    0,  \/* (389) tridxby ::= *\/\n+   -1,  \/* (390) database_kw_opt ::= DATABASE *\/\n+    0,  \/* (391) database_kw_opt ::= *\/\n+    0,  \/* (392) kwcolumn_opt ::= *\/\n+   -1,  \/* (393) kwcolumn_opt ::= COLUMNKW *\/\n+   -1,  \/* (394) vtabarglist ::= vtabarg *\/\n+   -3,  \/* (395) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n+   -2,  \/* (396) vtabarg ::= vtabarg vtabargtoken *\/\n+    0,  \/* (397) anylist ::= *\/\n+   -4,  \/* (398) anylist ::= anylist LP anylist RP *\/\n+   -2,  \/* (399) anylist ::= anylist ANY *\/\n+    0,  \/* (400) with ::= *\/\n@@ -156813,48 +163017,0 @@\n-#ifndef NDEBUG\n-  if( yyTraceFILE && yyruleno<(int)(sizeof(yyRuleName)\/sizeof(yyRuleName[0])) ){\n-    yysize = yyRuleInfoNRhs[yyruleno];\n-    if( yysize ){\n-      fprintf(yyTraceFILE, \"%sReduce %d [%s]%s, pop back to state %d.\\n\",\n-        yyTracePrompt,\n-        yyruleno, yyRuleName[yyruleno],\n-        yyruleno<YYNRULE_WITH_ACTION ? \"\" : \" without external action\",\n-        yymsp[yysize].stateno);\n-    }else{\n-      fprintf(yyTraceFILE, \"%sReduce %d [%s]%s.\\n\",\n-        yyTracePrompt, yyruleno, yyRuleName[yyruleno],\n-        yyruleno<YYNRULE_WITH_ACTION ? \"\" : \" without external action\");\n-    }\n-  }\n-#endif \/* NDEBUG *\/\n-\n-  \/* Check that the stack is large enough to grow by a single entry\n-  ** if the RHS of the rule is empty.  This ensures that there is room\n-  ** enough on the stack to push the LHS value *\/\n-  if( yyRuleInfoNRhs[yyruleno]==0 ){\n-#ifdef YYTRACKMAXSTACKDEPTH\n-    if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){\n-      yypParser->yyhwm++;\n-      assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack));\n-    }\n-#endif\n-#if YYSTACKDEPTH>0\n-    if( yypParser->yytos>=yypParser->yystackEnd ){\n-      yyStackOverflow(yypParser);\n-      \/* The call to yyStackOverflow() above pops the stack until it is\n-      ** empty, causing the main parser loop to exit.  So the return value\n-      ** is never used and does not matter. *\/\n-      return 0;\n-    }\n-#else\n-    if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz-1] ){\n-      if( yyGrowStack(yypParser) ){\n-        yyStackOverflow(yypParser);\n-        \/* The call to yyStackOverflow() above pops the stack until it is\n-        ** empty, causing the main parser loop to exit.  So the return value\n-        ** is never used and does not matter. *\/\n-        return 0;\n-      }\n-      yymsp = yypParser->yytos;\n-    }\n-#endif\n-  }\n@@ -156883,1 +163039,1 @@\n-{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy192);}\n+{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy64);}\n@@ -156886,1 +163042,1 @@\n-{yymsp[1].minor.yy192 = TK_DEFERRED;}\n+{yymsp[1].minor.yy64 = TK_DEFERRED;}\n@@ -156891,2 +163047,2 @@\n-      case 306: \/* range_or_rows ::= RANGE|ROWS|GROUPS *\/ yytestcase(yyruleno==306);\n-{yymsp[0].minor.yy192 = yymsp[0].major; \/*A-overwrites-X*\/}\n+      case 320: \/* range_or_rows ::= RANGE|ROWS|GROUPS *\/ yytestcase(yyruleno==320);\n+{yymsp[0].minor.yy64 = yymsp[0].major; \/*A-overwrites-X*\/}\n@@ -156915,1 +163071,1 @@\n-   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy192,0,0,yymsp[-2].minor.yy192);\n+   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy64,0,0,yymsp[-2].minor.yy64);\n@@ -156923,8 +163079,7 @@\n-      case 21: \/* table_options ::= *\/ yytestcase(yyruleno==21);\n-      case 45: \/* autoinc ::= *\/ yytestcase(yyruleno==45);\n-      case 60: \/* init_deferred_pred_opt ::= *\/ yytestcase(yyruleno==60);\n-      case 70: \/* defer_subclause_opt ::= *\/ yytestcase(yyruleno==70);\n-      case 79: \/* ifexists ::= *\/ yytestcase(yyruleno==79);\n-      case 96: \/* distinct ::= *\/ yytestcase(yyruleno==96);\n-      case 232: \/* collate ::= *\/ yytestcase(yyruleno==232);\n-{yymsp[1].minor.yy192 = 0;}\n+      case 47: \/* autoinc ::= *\/ yytestcase(yyruleno==47);\n+      case 62: \/* init_deferred_pred_opt ::= *\/ yytestcase(yyruleno==62);\n+      case 72: \/* defer_subclause_opt ::= *\/ yytestcase(yyruleno==72);\n+      case 81: \/* ifexists ::= *\/ yytestcase(yyruleno==81);\n+      case 98: \/* distinct ::= *\/ yytestcase(yyruleno==98);\n+      case 241: \/* collate ::= *\/ yytestcase(yyruleno==241);\n+{yymsp[1].minor.yy64 = 0;}\n@@ -156933,1 +163088,1 @@\n-{yymsp[-2].minor.yy192 = 1;}\n+{yymsp[-2].minor.yy64 = 1;}\n@@ -156936,2 +163091,1 @@\n-      case 46: \/* autoinc ::= AUTOINCR *\/ yytestcase(yyruleno==46);\n-{yymsp[0].minor.yy192 = 1;}\n+{yymsp[0].minor.yy64 = pParse->db->init.busy==0;}\n@@ -156939,1 +163093,1 @@\n-      case 19: \/* create_table_args ::= LP columnlist conslist_opt RP table_options *\/\n+      case 19: \/* create_table_args ::= LP columnlist conslist_opt RP table_option_set *\/\n@@ -156941,1 +163095,1 @@\n-  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy192,0);\n+  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy51,0);\n@@ -156946,2 +163100,2 @@\n-  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy539);\n-  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy539);\n+  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy303);\n+  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy303);\n@@ -156950,1 +163104,8 @@\n-      case 22: \/* table_options ::= WITHOUT nm *\/\n+      case 21: \/* table_option_set ::= *\/\n+{yymsp[1].minor.yy51 = 0;}\n+        break;\n+      case 22: \/* table_option_set ::= table_option_set COMMA table_option *\/\n+{yylhsminor.yy51 = yymsp[-2].minor.yy51|yymsp[0].minor.yy51;}\n+  yymsp[-2].minor.yy51 = yylhsminor.yy51;\n+        break;\n+      case 23: \/* table_option ::= WITHOUT nm *\/\n@@ -156953,1 +163114,11 @@\n-    yymsp[-1].minor.yy192 = TF_WithoutRowid | TF_NoVisibleRowid;\n+    yymsp[-1].minor.yy51 = TF_WithoutRowid | TF_NoVisibleRowid;\n+  }else{\n+    yymsp[-1].minor.yy51 = 0;\n+    sqlite3ErrorMsg(pParse, \"unknown table option: %.*s\", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);\n+  }\n+}\n+        break;\n+      case 24: \/* table_option ::= nm *\/\n+{\n+  if( yymsp[0].minor.yy0.n==6 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,\"strict\",6)==0 ){\n+    yylhsminor.yy51 = TF_Strict;\n@@ -156955,1 +163126,1 @@\n-    yymsp[-1].minor.yy192 = 0;\n+    yylhsminor.yy51 = 0;\n@@ -156959,0 +163130,1 @@\n+  yymsp[0].minor.yy51 = yylhsminor.yy51;\n@@ -156960,2 +163132,2 @@\n-      case 23: \/* columnname ::= nm typetoken *\/\n-{sqlite3AddColumn(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);}\n+      case 25: \/* columnname ::= nm typetoken *\/\n+{sqlite3AddColumn(pParse,yymsp[-1].minor.yy0,yymsp[0].minor.yy0);}\n@@ -156963,3 +163135,3 @@\n-      case 24: \/* typetoken ::= *\/\n-      case 63: \/* conslist_opt ::= *\/ yytestcase(yyruleno==63);\n-      case 102: \/* as ::= *\/ yytestcase(yyruleno==102);\n+      case 26: \/* typetoken ::= *\/\n+      case 65: \/* conslist_opt ::= *\/ yytestcase(yyruleno==65);\n+      case 104: \/* as ::= *\/ yytestcase(yyruleno==104);\n@@ -156968,1 +163140,1 @@\n-      case 25: \/* typetoken ::= typename LP signed RP *\/\n+      case 27: \/* typetoken ::= typename LP signed RP *\/\n@@ -156973,1 +163145,1 @@\n-      case 26: \/* typetoken ::= typename LP signed COMMA signed RP *\/\n+      case 28: \/* typetoken ::= typename LP signed COMMA signed RP *\/\n@@ -156978,1 +163150,1 @@\n-      case 27: \/* typename ::= typename ID|STRING *\/\n+      case 29: \/* typename ::= typename ID|STRING *\/\n@@ -156981,1 +163153,1 @@\n-      case 28: \/* scanpt ::= *\/\n+      case 30: \/* scanpt ::= *\/\n@@ -156984,1 +163156,1 @@\n-  yymsp[1].minor.yy436 = yyLookaheadToken.z;\n+  yymsp[1].minor.yy600 = yyLookaheadToken.z;\n@@ -156987,1 +163159,1 @@\n-      case 29: \/* scantok ::= *\/\n+      case 31: \/* scantok ::= *\/\n@@ -156993,2 +163165,2 @@\n-      case 30: \/* ccons ::= CONSTRAINT nm *\/\n-      case 65: \/* tcons ::= CONSTRAINT nm *\/ yytestcase(yyruleno==65);\n+      case 32: \/* ccons ::= CONSTRAINT nm *\/\n+      case 67: \/* tcons ::= CONSTRAINT nm *\/ yytestcase(yyruleno==67);\n@@ -156997,2 +163169,2 @@\n-      case 31: \/* ccons ::= DEFAULT scantok term *\/\n-{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy202,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n+      case 33: \/* ccons ::= DEFAULT scantok term *\/\n+{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy626,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n@@ -157000,2 +163172,2 @@\n-      case 32: \/* ccons ::= DEFAULT LP expr RP *\/\n-{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy202,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}\n+      case 34: \/* ccons ::= DEFAULT LP expr RP *\/\n+{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy626,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}\n@@ -157003,2 +163175,2 @@\n-      case 33: \/* ccons ::= DEFAULT PLUS scantok term *\/\n-{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy202,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n+      case 35: \/* ccons ::= DEFAULT PLUS scantok term *\/\n+{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy626,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n@@ -157006,1 +163178,1 @@\n-      case 34: \/* ccons ::= DEFAULT MINUS scantok term *\/\n+      case 36: \/* ccons ::= DEFAULT MINUS scantok term *\/\n@@ -157008,1 +163180,1 @@\n-  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy202, 0);\n+  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy626, 0);\n@@ -157012,1 +163184,1 @@\n-      case 35: \/* ccons ::= DEFAULT scantok ID|INDEXED *\/\n+      case 37: \/* ccons ::= DEFAULT scantok ID|INDEXED *\/\n@@ -157022,2 +163194,2 @@\n-      case 36: \/* ccons ::= NOT NULL onconf *\/\n-{sqlite3AddNotNull(pParse, yymsp[0].minor.yy192);}\n+      case 38: \/* ccons ::= NOT NULL onconf *\/\n+{sqlite3AddNotNull(pParse, yymsp[0].minor.yy64);}\n@@ -157025,2 +163197,2 @@\n-      case 37: \/* ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n-{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy192,yymsp[0].minor.yy192,yymsp[-2].minor.yy192);}\n+      case 39: \/* ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n+{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy64,yymsp[0].minor.yy64,yymsp[-2].minor.yy64);}\n@@ -157028,2 +163200,2 @@\n-      case 38: \/* ccons ::= UNIQUE onconf *\/\n-{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy192,0,0,0,0,\n+      case 40: \/* ccons ::= UNIQUE onconf *\/\n+{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy64,0,0,0,0,\n@@ -157032,2 +163204,2 @@\n-      case 39: \/* ccons ::= CHECK LP expr RP *\/\n-{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy202);}\n+      case 41: \/* ccons ::= CHECK LP expr RP *\/\n+{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy626,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy0.z);}\n@@ -157035,2 +163207,2 @@\n-      case 40: \/* ccons ::= REFERENCES nm eidlist_opt refargs *\/\n-{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy242,yymsp[0].minor.yy192);}\n+      case 42: \/* ccons ::= REFERENCES nm eidlist_opt refargs *\/\n+{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy562,yymsp[0].minor.yy64);}\n@@ -157038,2 +163210,2 @@\n-      case 41: \/* ccons ::= defer_subclause *\/\n-{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy192);}\n+      case 43: \/* ccons ::= defer_subclause *\/\n+{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy64);}\n@@ -157041,1 +163213,1 @@\n-      case 42: \/* ccons ::= COLLATE ID|STRING *\/\n+      case 44: \/* ccons ::= COLLATE ID|STRING *\/\n@@ -157044,2 +163216,5 @@\n-      case 43: \/* generated ::= LP expr RP *\/\n-{sqlite3AddGenerated(pParse,yymsp[-1].minor.yy202,0);}\n+      case 45: \/* generated ::= LP expr RP *\/\n+{sqlite3AddGenerated(pParse,yymsp[-1].minor.yy626,0);}\n+        break;\n+      case 46: \/* generated ::= LP expr RP ID *\/\n+{sqlite3AddGenerated(pParse,yymsp[-2].minor.yy626,&yymsp[0].minor.yy0);}\n@@ -157047,2 +163222,2 @@\n-      case 44: \/* generated ::= LP expr RP ID *\/\n-{sqlite3AddGenerated(pParse,yymsp[-2].minor.yy202,&yymsp[0].minor.yy0);}\n+      case 48: \/* autoinc ::= AUTOINCR *\/\n+{yymsp[0].minor.yy64 = 1;}\n@@ -157050,2 +163225,2 @@\n-      case 47: \/* refargs ::= *\/\n-{ yymsp[1].minor.yy192 = OE_None*0x0101; \/* EV: R-19803-45884 *\/}\n+      case 49: \/* refargs ::= *\/\n+{ yymsp[1].minor.yy64 = OE_None*0x0101; \/* EV: R-19803-45884 *\/}\n@@ -157053,2 +163228,2 @@\n-      case 48: \/* refargs ::= refargs refarg *\/\n-{ yymsp[-1].minor.yy192 = (yymsp[-1].minor.yy192 & ~yymsp[0].minor.yy207.mask) | yymsp[0].minor.yy207.value; }\n+      case 50: \/* refargs ::= refargs refarg *\/\n+{ yymsp[-1].minor.yy64 = (yymsp[-1].minor.yy64 & ~yymsp[0].minor.yy83.mask) | yymsp[0].minor.yy83.value; }\n@@ -157056,2 +163231,2 @@\n-      case 49: \/* refarg ::= MATCH nm *\/\n-{ yymsp[-1].minor.yy207.value = 0;     yymsp[-1].minor.yy207.mask = 0x000000; }\n+      case 51: \/* refarg ::= MATCH nm *\/\n+{ yymsp[-1].minor.yy83.value = 0;     yymsp[-1].minor.yy83.mask = 0x000000; }\n@@ -157059,2 +163234,2 @@\n-      case 50: \/* refarg ::= ON INSERT refact *\/\n-{ yymsp[-2].minor.yy207.value = 0;     yymsp[-2].minor.yy207.mask = 0x000000; }\n+      case 52: \/* refarg ::= ON INSERT refact *\/\n+{ yymsp[-2].minor.yy83.value = 0;     yymsp[-2].minor.yy83.mask = 0x000000; }\n@@ -157062,2 +163237,2 @@\n-      case 51: \/* refarg ::= ON DELETE refact *\/\n-{ yymsp[-2].minor.yy207.value = yymsp[0].minor.yy192;     yymsp[-2].minor.yy207.mask = 0x0000ff; }\n+      case 53: \/* refarg ::= ON DELETE refact *\/\n+{ yymsp[-2].minor.yy83.value = yymsp[0].minor.yy64;     yymsp[-2].minor.yy83.mask = 0x0000ff; }\n@@ -157065,2 +163240,2 @@\n-      case 52: \/* refarg ::= ON UPDATE refact *\/\n-{ yymsp[-2].minor.yy207.value = yymsp[0].minor.yy192<<8;  yymsp[-2].minor.yy207.mask = 0x00ff00; }\n+      case 54: \/* refarg ::= ON UPDATE refact *\/\n+{ yymsp[-2].minor.yy83.value = yymsp[0].minor.yy64<<8;  yymsp[-2].minor.yy83.mask = 0x00ff00; }\n@@ -157068,2 +163243,2 @@\n-      case 53: \/* refact ::= SET NULL *\/\n-{ yymsp[-1].minor.yy192 = OE_SetNull;  \/* EV: R-33326-45252 *\/}\n+      case 55: \/* refact ::= SET NULL *\/\n+{ yymsp[-1].minor.yy64 = OE_SetNull;  \/* EV: R-33326-45252 *\/}\n@@ -157071,2 +163246,2 @@\n-      case 54: \/* refact ::= SET DEFAULT *\/\n-{ yymsp[-1].minor.yy192 = OE_SetDflt;  \/* EV: R-33326-45252 *\/}\n+      case 56: \/* refact ::= SET DEFAULT *\/\n+{ yymsp[-1].minor.yy64 = OE_SetDflt;  \/* EV: R-33326-45252 *\/}\n@@ -157074,2 +163249,2 @@\n-      case 55: \/* refact ::= CASCADE *\/\n-{ yymsp[0].minor.yy192 = OE_Cascade;  \/* EV: R-33326-45252 *\/}\n+      case 57: \/* refact ::= CASCADE *\/\n+{ yymsp[0].minor.yy64 = OE_Cascade;  \/* EV: R-33326-45252 *\/}\n@@ -157077,2 +163252,2 @@\n-      case 56: \/* refact ::= RESTRICT *\/\n-{ yymsp[0].minor.yy192 = OE_Restrict; \/* EV: R-33326-45252 *\/}\n+      case 58: \/* refact ::= RESTRICT *\/\n+{ yymsp[0].minor.yy64 = OE_Restrict; \/* EV: R-33326-45252 *\/}\n@@ -157080,2 +163255,2 @@\n-      case 57: \/* refact ::= NO ACTION *\/\n-{ yymsp[-1].minor.yy192 = OE_None;     \/* EV: R-33326-45252 *\/}\n+      case 59: \/* refact ::= NO ACTION *\/\n+{ yymsp[-1].minor.yy64 = OE_None;     \/* EV: R-33326-45252 *\/}\n@@ -157083,2 +163258,2 @@\n-      case 58: \/* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n-{yymsp[-2].minor.yy192 = 0;}\n+      case 60: \/* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n+{yymsp[-2].minor.yy64 = 0;}\n@@ -157086,4 +163261,4 @@\n-      case 59: \/* defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n-      case 74: \/* orconf ::= OR resolvetype *\/ yytestcase(yyruleno==74);\n-      case 162: \/* insert_cmd ::= INSERT orconf *\/ yytestcase(yyruleno==162);\n-{yymsp[-1].minor.yy192 = yymsp[0].minor.yy192;}\n+      case 61: \/* defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n+      case 76: \/* orconf ::= OR resolvetype *\/ yytestcase(yyruleno==76);\n+      case 171: \/* insert_cmd ::= INSERT orconf *\/ yytestcase(yyruleno==171);\n+{yymsp[-1].minor.yy64 = yymsp[0].minor.yy64;}\n@@ -157091,6 +163266,6 @@\n-      case 61: \/* init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n-      case 78: \/* ifexists ::= IF EXISTS *\/ yytestcase(yyruleno==78);\n-      case 204: \/* between_op ::= NOT BETWEEN *\/ yytestcase(yyruleno==204);\n-      case 207: \/* in_op ::= NOT IN *\/ yytestcase(yyruleno==207);\n-      case 233: \/* collate ::= COLLATE ID|STRING *\/ yytestcase(yyruleno==233);\n-{yymsp[-1].minor.yy192 = 1;}\n+      case 63: \/* init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n+      case 80: \/* ifexists ::= IF EXISTS *\/ yytestcase(yyruleno==80);\n+      case 213: \/* between_op ::= NOT BETWEEN *\/ yytestcase(yyruleno==213);\n+      case 216: \/* in_op ::= NOT IN *\/ yytestcase(yyruleno==216);\n+      case 242: \/* collate ::= COLLATE ID|STRING *\/ yytestcase(yyruleno==242);\n+{yymsp[-1].minor.yy64 = 1;}\n@@ -157098,2 +163273,2 @@\n-      case 62: \/* init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n-{yymsp[-1].minor.yy192 = 0;}\n+      case 64: \/* init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n+{yymsp[-1].minor.yy64 = 0;}\n@@ -157101,1 +163276,1 @@\n-      case 64: \/* tconscomma ::= COMMA *\/\n+      case 66: \/* tconscomma ::= COMMA *\/\n@@ -157104,2 +163279,2 @@\n-      case 66: \/* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n-{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy242,yymsp[0].minor.yy192,yymsp[-2].minor.yy192,0);}\n+      case 68: \/* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n+{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy562,yymsp[0].minor.yy64,yymsp[-2].minor.yy64,0);}\n@@ -157107,2 +163282,2 @@\n-      case 67: \/* tcons ::= UNIQUE LP sortlist RP onconf *\/\n-{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy242,yymsp[0].minor.yy192,0,0,0,0,\n+      case 69: \/* tcons ::= UNIQUE LP sortlist RP onconf *\/\n+{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy562,yymsp[0].minor.yy64,0,0,0,0,\n@@ -157111,2 +163286,2 @@\n-      case 68: \/* tcons ::= CHECK LP expr RP onconf *\/\n-{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy202);}\n+      case 70: \/* tcons ::= CHECK LP expr RP onconf *\/\n+{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy626,yymsp[-3].minor.yy0.z,yymsp[-1].minor.yy0.z);}\n@@ -157114,1 +163289,1 @@\n-      case 69: \/* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n+      case 71: \/* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n@@ -157116,2 +163291,2 @@\n-    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy242, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy242, yymsp[-1].minor.yy192);\n-    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy192);\n+    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy562, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy562, yymsp[-1].minor.yy64);\n+    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy64);\n@@ -157120,3 +163295,3 @@\n-      case 71: \/* onconf ::= *\/\n-      case 73: \/* orconf ::= *\/ yytestcase(yyruleno==73);\n-{yymsp[1].minor.yy192 = OE_Default;}\n+      case 73: \/* onconf ::= *\/\n+      case 75: \/* orconf ::= *\/ yytestcase(yyruleno==75);\n+{yymsp[1].minor.yy64 = OE_Default;}\n@@ -157124,2 +163299,2 @@\n-      case 72: \/* onconf ::= ON CONFLICT resolvetype *\/\n-{yymsp[-2].minor.yy192 = yymsp[0].minor.yy192;}\n+      case 74: \/* onconf ::= ON CONFLICT resolvetype *\/\n+{yymsp[-2].minor.yy64 = yymsp[0].minor.yy64;}\n@@ -157127,2 +163302,2 @@\n-      case 75: \/* resolvetype ::= IGNORE *\/\n-{yymsp[0].minor.yy192 = OE_Ignore;}\n+      case 77: \/* resolvetype ::= IGNORE *\/\n+{yymsp[0].minor.yy64 = OE_Ignore;}\n@@ -157130,3 +163305,3 @@\n-      case 76: \/* resolvetype ::= REPLACE *\/\n-      case 163: \/* insert_cmd ::= REPLACE *\/ yytestcase(yyruleno==163);\n-{yymsp[0].minor.yy192 = OE_Replace;}\n+      case 78: \/* resolvetype ::= REPLACE *\/\n+      case 172: \/* insert_cmd ::= REPLACE *\/ yytestcase(yyruleno==172);\n+{yymsp[0].minor.yy64 = OE_Replace;}\n@@ -157134,1 +163309,1 @@\n-      case 77: \/* cmd ::= DROP TABLE ifexists fullname *\/\n+      case 79: \/* cmd ::= DROP TABLE ifexists fullname *\/\n@@ -157136,1 +163311,1 @@\n-  sqlite3DropTable(pParse, yymsp[0].minor.yy47, 0, yymsp[-1].minor.yy192);\n+  sqlite3DropTable(pParse, yymsp[0].minor.yy607, 0, yymsp[-1].minor.yy64);\n@@ -157139,1 +163314,1 @@\n-      case 80: \/* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n+      case 82: \/* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n@@ -157141,1 +163316,1 @@\n-  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy242, yymsp[0].minor.yy539, yymsp[-7].minor.yy192, yymsp[-5].minor.yy192);\n+  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy562, yymsp[0].minor.yy303, yymsp[-7].minor.yy64, yymsp[-5].minor.yy64);\n@@ -157144,1 +163319,1 @@\n-      case 81: \/* cmd ::= DROP VIEW ifexists fullname *\/\n+      case 83: \/* cmd ::= DROP VIEW ifexists fullname *\/\n@@ -157146,1 +163321,1 @@\n-  sqlite3DropTable(pParse, yymsp[0].minor.yy47, 1, yymsp[-1].minor.yy192);\n+  sqlite3DropTable(pParse, yymsp[0].minor.yy607, 1, yymsp[-1].minor.yy64);\n@@ -157149,1 +163324,1 @@\n-      case 82: \/* cmd ::= select *\/\n+      case 84: \/* cmd ::= select *\/\n@@ -157151,3 +163326,3 @@\n-  SelectDest dest = {SRT_Output, 0, 0, 0, 0, 0};\n-  sqlite3Select(pParse, yymsp[0].minor.yy539, &dest);\n-  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy539);\n+  SelectDest dest = {SRT_Output, 0, 0, 0, 0, 0, 0};\n+  sqlite3Select(pParse, yymsp[0].minor.yy303, &dest);\n+  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy303);\n@@ -157156,11 +163331,2 @@\n-      case 83: \/* select ::= WITH wqlist selectnowith *\/\n-{\n-  Select *p = yymsp[0].minor.yy539;\n-  if( p ){\n-    p->pWith = yymsp[-1].minor.yy131;\n-    parserDoubleLinkSelect(pParse, p);\n-  }else{\n-    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy131);\n-  }\n-  yymsp[-2].minor.yy539 = p;\n-}\n+      case 85: \/* select ::= WITH wqlist selectnowith *\/\n+{yymsp[-2].minor.yy303 = attachWithToSelect(pParse,yymsp[0].minor.yy303,yymsp[-1].minor.yy43);}\n@@ -157168,11 +163334,2 @@\n-      case 84: \/* select ::= WITH RECURSIVE wqlist selectnowith *\/\n-{\n-  Select *p = yymsp[0].minor.yy539;\n-  if( p ){\n-    p->pWith = yymsp[-1].minor.yy131;\n-    parserDoubleLinkSelect(pParse, p);\n-  }else{\n-    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy131);\n-  }\n-  yymsp[-3].minor.yy539 = p;\n-}\n+      case 86: \/* select ::= WITH RECURSIVE wqlist selectnowith *\/\n+{yymsp[-3].minor.yy303 = attachWithToSelect(pParse,yymsp[0].minor.yy303,yymsp[-1].minor.yy43);}\n@@ -157180,1 +163337,1 @@\n-      case 85: \/* select ::= selectnowith *\/\n+      case 87: \/* select ::= selectnowith *\/\n@@ -157182,1 +163339,1 @@\n-  Select *p = yymsp[0].minor.yy539;\n+  Select *p = yymsp[0].minor.yy303;\n@@ -157186,1 +163343,1 @@\n-  yymsp[0].minor.yy539 = p; \/*A-overwrites-X*\/\n+  yymsp[0].minor.yy303 = p; \/*A-overwrites-X*\/\n@@ -157189,1 +163346,1 @@\n-      case 86: \/* selectnowith ::= selectnowith multiselect_op oneselect *\/\n+      case 88: \/* selectnowith ::= selectnowith multiselect_op oneselect *\/\n@@ -157191,2 +163348,2 @@\n-  Select *pRhs = yymsp[0].minor.yy539;\n-  Select *pLhs = yymsp[-2].minor.yy539;\n+  Select *pRhs = yymsp[0].minor.yy303;\n+  Select *pLhs = yymsp[-2].minor.yy303;\n@@ -157202,1 +163359,1 @@\n-    pRhs->op = (u8)yymsp[-1].minor.yy192;\n+    pRhs->op = (u8)yymsp[-1].minor.yy64;\n@@ -157206,1 +163363,1 @@\n-    if( yymsp[-1].minor.yy192!=TK_ALL ) pParse->hasCompound = 1;\n+    if( yymsp[-1].minor.yy64!=TK_ALL ) pParse->hasCompound = 1;\n@@ -157210,1 +163367,1 @@\n-  yymsp[-2].minor.yy539 = pRhs;\n+  yymsp[-2].minor.yy303 = pRhs;\n@@ -157213,3 +163370,3 @@\n-      case 87: \/* multiselect_op ::= UNION *\/\n-      case 89: \/* multiselect_op ::= EXCEPT|INTERSECT *\/ yytestcase(yyruleno==89);\n-{yymsp[0].minor.yy192 = yymsp[0].major; \/*A-overwrites-OP*\/}\n+      case 89: \/* multiselect_op ::= UNION *\/\n+      case 91: \/* multiselect_op ::= EXCEPT|INTERSECT *\/ yytestcase(yyruleno==91);\n+{yymsp[0].minor.yy64 = yymsp[0].major; \/*A-overwrites-OP*\/}\n@@ -157217,2 +163374,2 @@\n-      case 88: \/* multiselect_op ::= UNION ALL *\/\n-{yymsp[-1].minor.yy192 = TK_ALL;}\n+      case 90: \/* multiselect_op ::= UNION ALL *\/\n+{yymsp[-1].minor.yy64 = TK_ALL;}\n@@ -157220,1 +163377,1 @@\n-      case 90: \/* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n+      case 92: \/* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n@@ -157222,1 +163379,1 @@\n-  yymsp[-8].minor.yy539 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy242,yymsp[-5].minor.yy47,yymsp[-4].minor.yy202,yymsp[-3].minor.yy242,yymsp[-2].minor.yy202,yymsp[-1].minor.yy242,yymsp[-7].minor.yy192,yymsp[0].minor.yy202);\n+  yymsp[-8].minor.yy303 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy562,yymsp[-5].minor.yy607,yymsp[-4].minor.yy626,yymsp[-3].minor.yy562,yymsp[-2].minor.yy626,yymsp[-1].minor.yy562,yymsp[-7].minor.yy64,yymsp[0].minor.yy626);\n@@ -157225,1 +163382,1 @@\n-      case 91: \/* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n+      case 93: \/* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n@@ -157227,3 +163384,3 @@\n-  yymsp[-9].minor.yy539 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy242,yymsp[-6].minor.yy47,yymsp[-5].minor.yy202,yymsp[-4].minor.yy242,yymsp[-3].minor.yy202,yymsp[-1].minor.yy242,yymsp[-8].minor.yy192,yymsp[0].minor.yy202);\n-  if( yymsp[-9].minor.yy539 ){\n-    yymsp[-9].minor.yy539->pWinDefn = yymsp[-2].minor.yy303;\n+  yymsp[-9].minor.yy303 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy562,yymsp[-6].minor.yy607,yymsp[-5].minor.yy626,yymsp[-4].minor.yy562,yymsp[-3].minor.yy626,yymsp[-1].minor.yy562,yymsp[-8].minor.yy64,yymsp[0].minor.yy626);\n+  if( yymsp[-9].minor.yy303 ){\n+    yymsp[-9].minor.yy303->pWinDefn = yymsp[-2].minor.yy375;\n@@ -157231,1 +163388,1 @@\n-    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy303);\n+    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy375);\n@@ -157235,1 +163392,1 @@\n-      case 92: \/* values ::= VALUES LP nexprlist RP *\/\n+      case 94: \/* values ::= VALUES LP nexprlist RP *\/\n@@ -157237,1 +163394,1 @@\n-  yymsp[-3].minor.yy539 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy242,0,0,0,0,0,SF_Values,0);\n+  yymsp[-3].minor.yy303 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy562,0,0,0,0,0,SF_Values,0);\n@@ -157240,1 +163397,1 @@\n-      case 93: \/* values ::= values COMMA LP nexprlist RP *\/\n+      case 95: \/* values ::= values COMMA LP nexprlist RP *\/\n@@ -157242,2 +163399,2 @@\n-  Select *pRight, *pLeft = yymsp[-4].minor.yy539;\n-  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy242,0,0,0,0,0,SF_Values|SF_MultiValue,0);\n+  Select *pRight, *pLeft = yymsp[-4].minor.yy303;\n+  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy562,0,0,0,0,0,SF_Values|SF_MultiValue,0);\n@@ -157248,1 +163405,1 @@\n-    yymsp[-4].minor.yy539 = pRight;\n+    yymsp[-4].minor.yy303 = pRight;\n@@ -157250,1 +163407,1 @@\n-    yymsp[-4].minor.yy539 = pLeft;\n+    yymsp[-4].minor.yy303 = pLeft;\n@@ -157254,2 +163411,2 @@\n-      case 94: \/* distinct ::= DISTINCT *\/\n-{yymsp[0].minor.yy192 = SF_Distinct;}\n+      case 96: \/* distinct ::= DISTINCT *\/\n+{yymsp[0].minor.yy64 = SF_Distinct;}\n@@ -157257,2 +163414,2 @@\n-      case 95: \/* distinct ::= ALL *\/\n-{yymsp[0].minor.yy192 = SF_All;}\n+      case 97: \/* distinct ::= ALL *\/\n+{yymsp[0].minor.yy64 = SF_All;}\n@@ -157260,7 +163417,7 @@\n-      case 97: \/* sclp ::= *\/\n-      case 130: \/* orderby_opt ::= *\/ yytestcase(yyruleno==130);\n-      case 140: \/* groupby_opt ::= *\/ yytestcase(yyruleno==140);\n-      case 220: \/* exprlist ::= *\/ yytestcase(yyruleno==220);\n-      case 223: \/* paren_exprlist ::= *\/ yytestcase(yyruleno==223);\n-      case 228: \/* eidlist_opt ::= *\/ yytestcase(yyruleno==228);\n-{yymsp[1].minor.yy242 = 0;}\n+      case 99: \/* sclp ::= *\/\n+      case 132: \/* orderby_opt ::= *\/ yytestcase(yyruleno==132);\n+      case 142: \/* groupby_opt ::= *\/ yytestcase(yyruleno==142);\n+      case 229: \/* exprlist ::= *\/ yytestcase(yyruleno==229);\n+      case 232: \/* paren_exprlist ::= *\/ yytestcase(yyruleno==232);\n+      case 237: \/* eidlist_opt ::= *\/ yytestcase(yyruleno==237);\n+{yymsp[1].minor.yy562 = 0;}\n@@ -157268,1 +163425,1 @@\n-      case 98: \/* selcollist ::= sclp scanpt expr scanpt as *\/\n+      case 100: \/* selcollist ::= sclp scanpt expr scanpt as *\/\n@@ -157270,3 +163427,3 @@\n-   yymsp[-4].minor.yy242 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy242, yymsp[-2].minor.yy202);\n-   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy242, &yymsp[0].minor.yy0, 1);\n-   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy242,yymsp[-3].minor.yy436,yymsp[-1].minor.yy436);\n+   yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy562, yymsp[-2].minor.yy626);\n+   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy562, &yymsp[0].minor.yy0, 1);\n+   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy562,yymsp[-3].minor.yy600,yymsp[-1].minor.yy600);\n@@ -157275,1 +163432,1 @@\n-      case 99: \/* selcollist ::= sclp scanpt STAR *\/\n+      case 101: \/* selcollist ::= sclp scanpt STAR *\/\n@@ -157278,1 +163435,1 @@\n-  yymsp[-2].minor.yy242 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy242, p);\n+  yymsp[-2].minor.yy562 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy562, p);\n@@ -157281,1 +163438,1 @@\n-      case 100: \/* selcollist ::= sclp scanpt nm DOT STAR *\/\n+      case 102: \/* selcollist ::= sclp scanpt nm DOT STAR *\/\n@@ -157286,1 +163443,1 @@\n-  yymsp[-4].minor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy242, pDot);\n+  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562, pDot);\n@@ -157289,4 +163446,4 @@\n-      case 101: \/* as ::= AS nm *\/\n-      case 112: \/* dbnm ::= DOT nm *\/ yytestcase(yyruleno==112);\n-      case 244: \/* plus_num ::= PLUS INTEGER|FLOAT *\/ yytestcase(yyruleno==244);\n-      case 245: \/* minus_num ::= MINUS INTEGER|FLOAT *\/ yytestcase(yyruleno==245);\n+      case 103: \/* as ::= AS nm *\/\n+      case 114: \/* dbnm ::= DOT nm *\/ yytestcase(yyruleno==114);\n+      case 253: \/* plus_num ::= PLUS INTEGER|FLOAT *\/ yytestcase(yyruleno==253);\n+      case 254: \/* minus_num ::= MINUS INTEGER|FLOAT *\/ yytestcase(yyruleno==254);\n@@ -157295,2 +163452,3 @@\n-      case 103: \/* from ::= *\/\n-{yymsp[1].minor.yy47 = sqlite3DbMallocZero(pParse->db, sizeof(*yymsp[1].minor.yy47));}\n+      case 105: \/* from ::= *\/\n+      case 108: \/* stl_prefix ::= *\/ yytestcase(yyruleno==108);\n+{yymsp[1].minor.yy607 = 0;}\n@@ -157298,1 +163456,1 @@\n-      case 104: \/* from ::= FROM seltablist *\/\n+      case 106: \/* from ::= FROM seltablist *\/\n@@ -157300,2 +163458,2 @@\n-  yymsp[-1].minor.yy47 = yymsp[0].minor.yy47;\n-  sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy47);\n+  yymsp[-1].minor.yy607 = yymsp[0].minor.yy607;\n+  sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy607);\n@@ -157304,1 +163462,1 @@\n-      case 105: \/* stl_prefix ::= seltablist joinop *\/\n+      case 107: \/* stl_prefix ::= seltablist joinop *\/\n@@ -157306,1 +163464,1 @@\n-   if( ALWAYS(yymsp[-1].minor.yy47 && yymsp[-1].minor.yy47->nSrc>0) ) yymsp[-1].minor.yy47->a[yymsp[-1].minor.yy47->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy192;\n+   if( ALWAYS(yymsp[-1].minor.yy607 && yymsp[-1].minor.yy607->nSrc>0) ) yymsp[-1].minor.yy607->a[yymsp[-1].minor.yy607->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy64;\n@@ -157309,4 +163467,1 @@\n-      case 106: \/* stl_prefix ::= *\/\n-{yymsp[1].minor.yy47 = 0;}\n-        break;\n-      case 107: \/* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt *\/\n+      case 109: \/* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt *\/\n@@ -157314,2 +163469,2 @@\n-  yymsp[-6].minor.yy47 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy47,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy202,yymsp[0].minor.yy600);\n-  sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy47, &yymsp[-2].minor.yy0);\n+  yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);\n+  sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy607, &yymsp[-2].minor.yy0);\n@@ -157318,1 +163473,1 @@\n-      case 108: \/* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt *\/\n+      case 110: \/* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt *\/\n@@ -157320,2 +163475,2 @@\n-  yymsp[-8].minor.yy47 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy47,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy202,yymsp[0].minor.yy600);\n-  sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy47, yymsp[-4].minor.yy242);\n+  yymsp[-8].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy607,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);\n+  sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy607, yymsp[-4].minor.yy562);\n@@ -157324,1 +163479,1 @@\n-      case 109: \/* seltablist ::= stl_prefix LP select RP as on_opt using_opt *\/\n+      case 111: \/* seltablist ::= stl_prefix LP select RP as on_opt using_opt *\/\n@@ -157326,1 +163481,1 @@\n-    yymsp[-6].minor.yy47 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy47,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy539,yymsp[-1].minor.yy202,yymsp[0].minor.yy600);\n+    yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy303,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);\n@@ -157329,1 +163484,1 @@\n-      case 110: \/* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt *\/\n+      case 112: \/* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt *\/\n@@ -157331,7 +163486,7 @@\n-    if( yymsp[-6].minor.yy47==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy202==0 && yymsp[0].minor.yy600==0 ){\n-      yymsp[-6].minor.yy47 = yymsp[-4].minor.yy47;\n-    }else if( yymsp[-4].minor.yy47->nSrc==1 ){\n-      yymsp[-6].minor.yy47 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy47,0,0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy202,yymsp[0].minor.yy600);\n-      if( yymsp[-6].minor.yy47 ){\n-        struct SrcList_item *pNew = &yymsp[-6].minor.yy47->a[yymsp[-6].minor.yy47->nSrc-1];\n-        struct SrcList_item *pOld = yymsp[-4].minor.yy47->a;\n+    if( yymsp[-6].minor.yy607==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy626==0 && yymsp[0].minor.yy240==0 ){\n+      yymsp[-6].minor.yy607 = yymsp[-4].minor.yy607;\n+    }else if( yymsp[-4].minor.yy607->nSrc==1 ){\n+      yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,0,0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);\n+      if( yymsp[-6].minor.yy607 ){\n+        SrcItem *pNew = &yymsp[-6].minor.yy607->a[yymsp[-6].minor.yy607->nSrc-1];\n+        SrcItem *pOld = yymsp[-4].minor.yy607->a;\n@@ -157350,1 +163505,1 @@\n-      sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy47);\n+      sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy607);\n@@ -157353,3 +163508,3 @@\n-      sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy47);\n-      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy47,0,0,0,0,SF_NestedFrom,0);\n-      yymsp[-6].minor.yy47 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy47,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy202,yymsp[0].minor.yy600);\n+      sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy607);\n+      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy607,0,0,0,0,SF_NestedFrom,0);\n+      yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);\n@@ -157359,2 +163514,2 @@\n-      case 111: \/* dbnm ::= *\/\n-      case 125: \/* indexed_opt ::= *\/ yytestcase(yyruleno==125);\n+      case 113: \/* dbnm ::= *\/\n+      case 127: \/* indexed_opt ::= *\/ yytestcase(yyruleno==127);\n@@ -157363,1 +163518,1 @@\n-      case 113: \/* fullname ::= nm *\/\n+      case 115: \/* fullname ::= nm *\/\n@@ -157365,2 +163520,2 @@\n-  yylhsminor.yy47 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);\n-  if( IN_RENAME_OBJECT && yylhsminor.yy47 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy47->a[0].zName, &yymsp[0].minor.yy0);\n+  yylhsminor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);\n+  if( IN_RENAME_OBJECT && yylhsminor.yy607 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy607->a[0].zName, &yymsp[0].minor.yy0);\n@@ -157368,1 +163523,1 @@\n-  yymsp[0].minor.yy47 = yylhsminor.yy47;\n+  yymsp[0].minor.yy607 = yylhsminor.yy607;\n@@ -157370,1 +163525,1 @@\n-      case 114: \/* fullname ::= nm DOT nm *\/\n+      case 116: \/* fullname ::= nm DOT nm *\/\n@@ -157372,2 +163527,2 @@\n-  yylhsminor.yy47 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);\n-  if( IN_RENAME_OBJECT && yylhsminor.yy47 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy47->a[0].zName, &yymsp[0].minor.yy0);\n+  yylhsminor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);\n+  if( IN_RENAME_OBJECT && yylhsminor.yy607 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy607->a[0].zName, &yymsp[0].minor.yy0);\n@@ -157375,1 +163530,1 @@\n-  yymsp[-2].minor.yy47 = yylhsminor.yy47;\n+  yymsp[-2].minor.yy607 = yylhsminor.yy607;\n@@ -157377,2 +163532,2 @@\n-      case 115: \/* xfullname ::= nm *\/\n-{yymsp[0].minor.yy47 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); \/*A-overwrites-X*\/}\n+      case 117: \/* xfullname ::= nm *\/\n+{yymsp[0].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); \/*A-overwrites-X*\/}\n@@ -157380,2 +163535,2 @@\n-      case 116: \/* xfullname ::= nm DOT nm *\/\n-{yymsp[-2].minor.yy47 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n+      case 118: \/* xfullname ::= nm DOT nm *\/\n+{yymsp[-2].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n@@ -157383,1 +163538,1 @@\n-      case 117: \/* xfullname ::= nm DOT nm AS nm *\/\n+      case 119: \/* xfullname ::= nm DOT nm AS nm *\/\n@@ -157385,2 +163540,2 @@\n-   yymsp[-4].minor.yy47 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0); \/*A-overwrites-X*\/\n-   if( yymsp[-4].minor.yy47 ) yymsp[-4].minor.yy47->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n+   yymsp[-4].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0); \/*A-overwrites-X*\/\n+   if( yymsp[-4].minor.yy607 ) yymsp[-4].minor.yy607->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n@@ -157389,1 +163544,1 @@\n-      case 118: \/* xfullname ::= nm AS nm *\/\n+      case 120: \/* xfullname ::= nm AS nm *\/\n@@ -157391,2 +163546,2 @@\n-   yymsp[-2].minor.yy47 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0); \/*A-overwrites-X*\/\n-   if( yymsp[-2].minor.yy47 ) yymsp[-2].minor.yy47->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n+   yymsp[-2].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0); \/*A-overwrites-X*\/\n+   if( yymsp[-2].minor.yy607 ) yymsp[-2].minor.yy607->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n@@ -157395,2 +163550,2 @@\n-      case 119: \/* joinop ::= COMMA|JOIN *\/\n-{ yymsp[0].minor.yy192 = JT_INNER; }\n+      case 121: \/* joinop ::= COMMA|JOIN *\/\n+{ yymsp[0].minor.yy64 = JT_INNER; }\n@@ -157398,2 +163553,2 @@\n-      case 120: \/* joinop ::= JOIN_KW JOIN *\/\n-{yymsp[-1].minor.yy192 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  \/*X-overwrites-A*\/}\n+      case 122: \/* joinop ::= JOIN_KW JOIN *\/\n+{yymsp[-1].minor.yy64 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  \/*X-overwrites-A*\/}\n@@ -157401,2 +163556,2 @@\n-      case 121: \/* joinop ::= JOIN_KW nm JOIN *\/\n-{yymsp[-2].minor.yy192 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); \/*X-overwrites-A*\/}\n+      case 123: \/* joinop ::= JOIN_KW nm JOIN *\/\n+{yymsp[-2].minor.yy64 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); \/*X-overwrites-A*\/}\n@@ -157404,2 +163559,2 @@\n-      case 122: \/* joinop ::= JOIN_KW nm nm JOIN *\/\n-{yymsp[-3].minor.yy192 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);\/*X-overwrites-A*\/}\n+      case 124: \/* joinop ::= JOIN_KW nm nm JOIN *\/\n+{yymsp[-3].minor.yy64 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);\/*X-overwrites-A*\/}\n@@ -157407,6 +163562,7 @@\n-      case 123: \/* on_opt ::= ON expr *\/\n-      case 143: \/* having_opt ::= HAVING expr *\/ yytestcase(yyruleno==143);\n-      case 150: \/* where_opt ::= WHERE expr *\/ yytestcase(yyruleno==150);\n-      case 216: \/* case_else ::= ELSE expr *\/ yytestcase(yyruleno==216);\n-      case 237: \/* vinto ::= INTO expr *\/ yytestcase(yyruleno==237);\n-{yymsp[-1].minor.yy202 = yymsp[0].minor.yy202;}\n+      case 125: \/* on_opt ::= ON expr *\/\n+      case 145: \/* having_opt ::= HAVING expr *\/ yytestcase(yyruleno==145);\n+      case 152: \/* where_opt ::= WHERE expr *\/ yytestcase(yyruleno==152);\n+      case 154: \/* where_opt_ret ::= WHERE expr *\/ yytestcase(yyruleno==154);\n+      case 225: \/* case_else ::= ELSE expr *\/ yytestcase(yyruleno==225);\n+      case 246: \/* vinto ::= INTO expr *\/ yytestcase(yyruleno==246);\n+{yymsp[-1].minor.yy626 = yymsp[0].minor.yy626;}\n@@ -157414,8 +163570,9 @@\n-      case 124: \/* on_opt ::= *\/\n-      case 142: \/* having_opt ::= *\/ yytestcase(yyruleno==142);\n-      case 144: \/* limit_opt ::= *\/ yytestcase(yyruleno==144);\n-      case 149: \/* where_opt ::= *\/ yytestcase(yyruleno==149);\n-      case 217: \/* case_else ::= *\/ yytestcase(yyruleno==217);\n-      case 219: \/* case_operand ::= *\/ yytestcase(yyruleno==219);\n-      case 238: \/* vinto ::= *\/ yytestcase(yyruleno==238);\n-{yymsp[1].minor.yy202 = 0;}\n+      case 126: \/* on_opt ::= *\/\n+      case 144: \/* having_opt ::= *\/ yytestcase(yyruleno==144);\n+      case 146: \/* limit_opt ::= *\/ yytestcase(yyruleno==146);\n+      case 151: \/* where_opt ::= *\/ yytestcase(yyruleno==151);\n+      case 153: \/* where_opt_ret ::= *\/ yytestcase(yyruleno==153);\n+      case 226: \/* case_else ::= *\/ yytestcase(yyruleno==226);\n+      case 228: \/* case_operand ::= *\/ yytestcase(yyruleno==228);\n+      case 247: \/* vinto ::= *\/ yytestcase(yyruleno==247);\n+{yymsp[1].minor.yy626 = 0;}\n@@ -157423,1 +163580,1 @@\n-      case 126: \/* indexed_opt ::= INDEXED BY nm *\/\n+      case 128: \/* indexed_opt ::= INDEXED BY nm *\/\n@@ -157426,1 +163583,1 @@\n-      case 127: \/* indexed_opt ::= NOT INDEXED *\/\n+      case 129: \/* indexed_opt ::= NOT INDEXED *\/\n@@ -157429,2 +163586,2 @@\n-      case 128: \/* using_opt ::= USING LP idlist RP *\/\n-{yymsp[-3].minor.yy600 = yymsp[-1].minor.yy600;}\n+      case 130: \/* using_opt ::= USING LP idlist RP *\/\n+{yymsp[-3].minor.yy240 = yymsp[-1].minor.yy240;}\n@@ -157432,3 +163589,3 @@\n-      case 129: \/* using_opt ::= *\/\n-      case 164: \/* idlist_opt ::= *\/ yytestcase(yyruleno==164);\n-{yymsp[1].minor.yy600 = 0;}\n+      case 131: \/* using_opt ::= *\/\n+      case 173: \/* idlist_opt ::= *\/ yytestcase(yyruleno==173);\n+{yymsp[1].minor.yy240 = 0;}\n@@ -157436,3 +163593,3 @@\n-      case 131: \/* orderby_opt ::= ORDER BY sortlist *\/\n-      case 141: \/* groupby_opt ::= GROUP BY nexprlist *\/ yytestcase(yyruleno==141);\n-{yymsp[-2].minor.yy242 = yymsp[0].minor.yy242;}\n+      case 133: \/* orderby_opt ::= ORDER BY sortlist *\/\n+      case 143: \/* groupby_opt ::= GROUP BY nexprlist *\/ yytestcase(yyruleno==143);\n+{yymsp[-2].minor.yy562 = yymsp[0].minor.yy562;}\n@@ -157440,1 +163597,1 @@\n-      case 132: \/* sortlist ::= sortlist COMMA expr sortorder nulls *\/\n+      case 134: \/* sortlist ::= sortlist COMMA expr sortorder nulls *\/\n@@ -157442,2 +163599,2 @@\n-  yymsp[-4].minor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy242,yymsp[-2].minor.yy202);\n-  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy242,yymsp[-1].minor.yy192,yymsp[0].minor.yy192);\n+  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562,yymsp[-2].minor.yy626);\n+  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy562,yymsp[-1].minor.yy64,yymsp[0].minor.yy64);\n@@ -157446,1 +163603,1 @@\n-      case 133: \/* sortlist ::= expr sortorder nulls *\/\n+      case 135: \/* sortlist ::= expr sortorder nulls *\/\n@@ -157448,2 +163605,2 @@\n-  yymsp[-2].minor.yy242 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy202); \/*A-overwrites-Y*\/\n-  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy242,yymsp[-1].minor.yy192,yymsp[0].minor.yy192);\n+  yymsp[-2].minor.yy562 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy626); \/*A-overwrites-Y*\/\n+  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy562,yymsp[-1].minor.yy64,yymsp[0].minor.yy64);\n@@ -157452,2 +163609,2 @@\n-      case 134: \/* sortorder ::= ASC *\/\n-{yymsp[0].minor.yy192 = SQLITE_SO_ASC;}\n+      case 136: \/* sortorder ::= ASC *\/\n+{yymsp[0].minor.yy64 = SQLITE_SO_ASC;}\n@@ -157455,2 +163612,2 @@\n-      case 135: \/* sortorder ::= DESC *\/\n-{yymsp[0].minor.yy192 = SQLITE_SO_DESC;}\n+      case 137: \/* sortorder ::= DESC *\/\n+{yymsp[0].minor.yy64 = SQLITE_SO_DESC;}\n@@ -157458,3 +163615,3 @@\n-      case 136: \/* sortorder ::= *\/\n-      case 139: \/* nulls ::= *\/ yytestcase(yyruleno==139);\n-{yymsp[1].minor.yy192 = SQLITE_SO_UNDEFINED;}\n+      case 138: \/* sortorder ::= *\/\n+      case 141: \/* nulls ::= *\/ yytestcase(yyruleno==141);\n+{yymsp[1].minor.yy64 = SQLITE_SO_UNDEFINED;}\n@@ -157462,2 +163619,2 @@\n-      case 137: \/* nulls ::= NULLS FIRST *\/\n-{yymsp[-1].minor.yy192 = SQLITE_SO_ASC;}\n+      case 139: \/* nulls ::= NULLS FIRST *\/\n+{yymsp[-1].minor.yy64 = SQLITE_SO_ASC;}\n@@ -157465,2 +163622,2 @@\n-      case 138: \/* nulls ::= NULLS LAST *\/\n-{yymsp[-1].minor.yy192 = SQLITE_SO_DESC;}\n+      case 140: \/* nulls ::= NULLS LAST *\/\n+{yymsp[-1].minor.yy64 = SQLITE_SO_DESC;}\n@@ -157468,2 +163625,2 @@\n-      case 145: \/* limit_opt ::= LIMIT expr *\/\n-{yymsp[-1].minor.yy202 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy202,0);}\n+      case 147: \/* limit_opt ::= LIMIT expr *\/\n+{yymsp[-1].minor.yy626 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy626,0);}\n@@ -157471,2 +163628,2 @@\n-      case 146: \/* limit_opt ::= LIMIT expr OFFSET expr *\/\n-{yymsp[-3].minor.yy202 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy202,yymsp[0].minor.yy202);}\n+      case 148: \/* limit_opt ::= LIMIT expr OFFSET expr *\/\n+{yymsp[-3].minor.yy626 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);}\n@@ -157474,2 +163631,2 @@\n-      case 147: \/* limit_opt ::= LIMIT expr COMMA expr *\/\n-{yymsp[-3].minor.yy202 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy202,yymsp[-2].minor.yy202);}\n+      case 149: \/* limit_opt ::= LIMIT expr COMMA expr *\/\n+{yymsp[-3].minor.yy626 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy626,yymsp[-2].minor.yy626);}\n@@ -157477,1 +163634,1 @@\n-      case 148: \/* cmd ::= with DELETE FROM xfullname indexed_opt where_opt *\/\n+      case 150: \/* cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n@@ -157479,2 +163636,2 @@\n-  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy47, &yymsp[-1].minor.yy0);\n-  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy47,yymsp[0].minor.yy202,0,0);\n+  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy607, &yymsp[-1].minor.yy0);\n+  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy607,yymsp[0].minor.yy626,0,0);\n@@ -157483,1 +163640,7 @@\n-      case 151: \/* cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt *\/\n+      case 155: \/* where_opt_ret ::= RETURNING selcollist *\/\n+{sqlite3AddReturning(pParse,yymsp[0].minor.yy562); yymsp[-1].minor.yy626 = 0;}\n+        break;\n+      case 156: \/* where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n+{sqlite3AddReturning(pParse,yymsp[0].minor.yy562); yymsp[-3].minor.yy626 = yymsp[-2].minor.yy626;}\n+        break;\n+      case 157: \/* cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n@@ -157485,3 +163648,4 @@\n-  sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy47, &yymsp[-3].minor.yy0);\n-  sqlite3ExprListCheckLength(pParse,yymsp[-1].minor.yy242,\"set list\");\n-  sqlite3Update(pParse,yymsp[-4].minor.yy47,yymsp[-1].minor.yy242,yymsp[0].minor.yy202,yymsp[-5].minor.yy192,0,0,0);\n+  sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy607, &yymsp[-4].minor.yy0);\n+  sqlite3ExprListCheckLength(pParse,yymsp[-2].minor.yy562,\"set list\");\n+  yymsp[-5].minor.yy607 = sqlite3SrcListAppendList(pParse, yymsp[-5].minor.yy607, yymsp[-1].minor.yy607);\n+  sqlite3Update(pParse,yymsp[-5].minor.yy607,yymsp[-2].minor.yy562,yymsp[0].minor.yy626,yymsp[-6].minor.yy64,0,0,0);\n@@ -157490,1 +163654,1 @@\n-      case 152: \/* setlist ::= setlist COMMA nm EQ expr *\/\n+      case 158: \/* setlist ::= setlist COMMA nm EQ expr *\/\n@@ -157492,2 +163656,2 @@\n-  yymsp[-4].minor.yy242 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy242, yymsp[0].minor.yy202);\n-  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy242, &yymsp[-2].minor.yy0, 1);\n+  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy562, yymsp[0].minor.yy626);\n+  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy562, &yymsp[-2].minor.yy0, 1);\n@@ -157496,1 +163660,1 @@\n-      case 153: \/* setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n+      case 159: \/* setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n@@ -157498,1 +163662,1 @@\n-  yymsp[-6].minor.yy242 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy242, yymsp[-3].minor.yy600, yymsp[0].minor.yy202);\n+  yymsp[-6].minor.yy562 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy562, yymsp[-3].minor.yy240, yymsp[0].minor.yy626);\n@@ -157501,1 +163665,1 @@\n-      case 154: \/* setlist ::= nm EQ expr *\/\n+      case 160: \/* setlist ::= nm EQ expr *\/\n@@ -157503,2 +163667,2 @@\n-  yylhsminor.yy242 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy202);\n-  sqlite3ExprListSetName(pParse, yylhsminor.yy242, &yymsp[-2].minor.yy0, 1);\n+  yylhsminor.yy562 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy626);\n+  sqlite3ExprListSetName(pParse, yylhsminor.yy562, &yymsp[-2].minor.yy0, 1);\n@@ -157506,1 +163670,1 @@\n-  yymsp[-2].minor.yy242 = yylhsminor.yy242;\n+  yymsp[-2].minor.yy562 = yylhsminor.yy562;\n@@ -157508,1 +163672,1 @@\n-      case 155: \/* setlist ::= LP idlist RP EQ expr *\/\n+      case 161: \/* setlist ::= LP idlist RP EQ expr *\/\n@@ -157510,1 +163674,1 @@\n-  yymsp[-4].minor.yy242 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy600, yymsp[0].minor.yy202);\n+  yymsp[-4].minor.yy562 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy240, yymsp[0].minor.yy626);\n@@ -157513,1 +163677,1 @@\n-      case 156: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n+      case 162: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n@@ -157515,1 +163679,1 @@\n-  sqlite3Insert(pParse, yymsp[-3].minor.yy47, yymsp[-1].minor.yy539, yymsp[-2].minor.yy600, yymsp[-5].minor.yy192, yymsp[0].minor.yy318);\n+  sqlite3Insert(pParse, yymsp[-3].minor.yy607, yymsp[-1].minor.yy303, yymsp[-2].minor.yy240, yymsp[-5].minor.yy64, yymsp[0].minor.yy138);\n@@ -157518,1 +163682,1 @@\n-      case 157: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES *\/\n+      case 163: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n@@ -157520,1 +163684,1 @@\n-  sqlite3Insert(pParse, yymsp[-3].minor.yy47, 0, yymsp[-2].minor.yy600, yymsp[-5].minor.yy192, 0);\n+  sqlite3Insert(pParse, yymsp[-4].minor.yy607, 0, yymsp[-3].minor.yy240, yymsp[-6].minor.yy64, 0);\n@@ -157523,2 +163687,5 @@\n-      case 158: \/* upsert ::= *\/\n-{ yymsp[1].minor.yy318 = 0; }\n+      case 164: \/* upsert ::= *\/\n+{ yymsp[1].minor.yy138 = 0; }\n+        break;\n+      case 165: \/* upsert ::= RETURNING selcollist *\/\n+{ yymsp[-1].minor.yy138 = 0; sqlite3AddReturning(pParse,yymsp[0].minor.yy562); }\n@@ -157526,2 +163693,2 @@\n-      case 159: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt *\/\n-{ yymsp[-10].minor.yy318 = sqlite3UpsertNew(pParse->db,yymsp[-7].minor.yy242,yymsp[-5].minor.yy202,yymsp[-1].minor.yy242,yymsp[0].minor.yy202);}\n+      case 166: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n+{ yymsp[-11].minor.yy138 = sqlite3UpsertNew(pParse->db,yymsp[-8].minor.yy562,yymsp[-6].minor.yy626,yymsp[-2].minor.yy562,yymsp[-1].minor.yy626,yymsp[0].minor.yy138);}\n@@ -157529,2 +163696,2 @@\n-      case 160: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING *\/\n-{ yymsp[-7].minor.yy318 = sqlite3UpsertNew(pParse->db,yymsp[-4].minor.yy242,yymsp[-2].minor.yy202,0,0); }\n+      case 167: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n+{ yymsp[-8].minor.yy138 = sqlite3UpsertNew(pParse->db,yymsp[-5].minor.yy562,yymsp[-3].minor.yy626,0,0,yymsp[0].minor.yy138); }\n@@ -157532,2 +163699,2 @@\n-      case 161: \/* upsert ::= ON CONFLICT DO NOTHING *\/\n-{ yymsp[-3].minor.yy318 = sqlite3UpsertNew(pParse->db,0,0,0,0); }\n+      case 168: \/* upsert ::= ON CONFLICT DO NOTHING returning *\/\n+{ yymsp[-4].minor.yy138 = sqlite3UpsertNew(pParse->db,0,0,0,0,0); }\n@@ -157535,2 +163702,2 @@\n-      case 165: \/* idlist_opt ::= LP idlist RP *\/\n-{yymsp[-2].minor.yy600 = yymsp[-1].minor.yy600;}\n+      case 169: \/* upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n+{ yymsp[-7].minor.yy138 = sqlite3UpsertNew(pParse->db,0,0,yymsp[-2].minor.yy562,yymsp[-1].minor.yy626,0);}\n@@ -157538,2 +163705,2 @@\n-      case 166: \/* idlist ::= idlist COMMA nm *\/\n-{yymsp[-2].minor.yy600 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy600,&yymsp[0].minor.yy0);}\n+      case 170: \/* returning ::= RETURNING selcollist *\/\n+{sqlite3AddReturning(pParse,yymsp[0].minor.yy562);}\n@@ -157541,2 +163708,2 @@\n-      case 167: \/* idlist ::= nm *\/\n-{yymsp[0].minor.yy600 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); \/*A-overwrites-Y*\/}\n+      case 174: \/* idlist_opt ::= LP idlist RP *\/\n+{yymsp[-2].minor.yy240 = yymsp[-1].minor.yy240;}\n@@ -157544,2 +163711,2 @@\n-      case 168: \/* expr ::= LP expr RP *\/\n-{yymsp[-2].minor.yy202 = yymsp[-1].minor.yy202;}\n+      case 175: \/* idlist ::= idlist COMMA nm *\/\n+{yymsp[-2].minor.yy240 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy240,&yymsp[0].minor.yy0);}\n@@ -157547,3 +163714,2 @@\n-      case 169: \/* expr ::= ID|INDEXED *\/\n-      case 170: \/* expr ::= JOIN_KW *\/ yytestcase(yyruleno==170);\n-{yymsp[0].minor.yy202=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n+      case 176: \/* idlist ::= nm *\/\n+{yymsp[0].minor.yy240 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); \/*A-overwrites-Y*\/}\n@@ -157551,1 +163717,8 @@\n-      case 171: \/* expr ::= nm DOT nm *\/\n+      case 177: \/* expr ::= LP expr RP *\/\n+{yymsp[-2].minor.yy626 = yymsp[-1].minor.yy626;}\n+        break;\n+      case 178: \/* expr ::= ID|INDEXED *\/\n+      case 179: \/* expr ::= JOIN_KW *\/ yytestcase(yyruleno==179);\n+{yymsp[0].minor.yy626=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n+        break;\n+      case 180: \/* expr ::= nm DOT nm *\/\n@@ -157559,1 +163732,1 @@\n-  yylhsminor.yy202 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);\n+  yylhsminor.yy626 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);\n@@ -157561,1 +163734,1 @@\n-  yymsp[-2].minor.yy202 = yylhsminor.yy202;\n+  yymsp[-2].minor.yy626 = yylhsminor.yy626;\n@@ -157563,1 +163736,1 @@\n-      case 172: \/* expr ::= nm DOT nm DOT nm *\/\n+      case 181: \/* expr ::= nm DOT nm DOT nm *\/\n@@ -157573,1 +163746,1 @@\n-  yylhsminor.yy202 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);\n+  yylhsminor.yy626 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);\n@@ -157575,1 +163748,1 @@\n-  yymsp[-4].minor.yy202 = yylhsminor.yy202;\n+  yymsp[-4].minor.yy626 = yylhsminor.yy626;\n@@ -157577,3 +163750,3 @@\n-      case 173: \/* term ::= NULL|FLOAT|BLOB *\/\n-      case 174: \/* term ::= STRING *\/ yytestcase(yyruleno==174);\n-{yymsp[0].minor.yy202=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n+      case 182: \/* term ::= NULL|FLOAT|BLOB *\/\n+      case 183: \/* term ::= STRING *\/ yytestcase(yyruleno==183);\n+{yymsp[0].minor.yy626=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n@@ -157581,1 +163754,1 @@\n-      case 175: \/* term ::= INTEGER *\/\n+      case 184: \/* term ::= INTEGER *\/\n@@ -157583,1 +163756,1 @@\n-  yylhsminor.yy202 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);\n+  yylhsminor.yy626 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);\n@@ -157585,1 +163758,1 @@\n-  yymsp[0].minor.yy202 = yylhsminor.yy202;\n+  yymsp[0].minor.yy626 = yylhsminor.yy626;\n@@ -157587,1 +163760,1 @@\n-      case 176: \/* expr ::= VARIABLE *\/\n+      case 185: \/* expr ::= VARIABLE *\/\n@@ -157591,2 +163764,2 @@\n-    yymsp[0].minor.yy202 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);\n-    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy202, n);\n+    yymsp[0].minor.yy626 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);\n+    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy626, n);\n@@ -157601,1 +163774,1 @@\n-      yymsp[0].minor.yy202 = 0;\n+      yymsp[0].minor.yy626 = 0;\n@@ -157603,2 +163776,2 @@\n-      yymsp[0].minor.yy202 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);\n-      if( yymsp[0].minor.yy202 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy202->iTable);\n+      yymsp[0].minor.yy626 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);\n+      if( yymsp[0].minor.yy626 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy626->iTable);\n@@ -157609,1 +163782,1 @@\n-      case 177: \/* expr ::= expr COLLATE ID|STRING *\/\n+      case 186: \/* expr ::= expr COLLATE ID|STRING *\/\n@@ -157611,1 +163784,1 @@\n-  yymsp[-2].minor.yy202 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy202, &yymsp[0].minor.yy0, 1);\n+  yymsp[-2].minor.yy626 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy626, &yymsp[0].minor.yy0, 1);\n@@ -157614,1 +163787,1 @@\n-      case 178: \/* expr ::= CAST LP expr AS typetoken RP *\/\n+      case 187: \/* expr ::= CAST LP expr AS typetoken RP *\/\n@@ -157616,2 +163789,2 @@\n-  yymsp[-5].minor.yy202 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);\n-  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy202, yymsp[-3].minor.yy202, 0);\n+  yymsp[-5].minor.yy626 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);\n+  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy626, yymsp[-3].minor.yy626, 0);\n@@ -157620,1 +163793,1 @@\n-      case 179: \/* expr ::= ID|INDEXED LP distinct exprlist RP *\/\n+      case 188: \/* expr ::= ID|INDEXED LP distinct exprlist RP *\/\n@@ -157622,1 +163795,1 @@\n-  yylhsminor.yy202 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy242, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy192);\n+  yylhsminor.yy626 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy562, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy64);\n@@ -157624,1 +163797,1 @@\n-  yymsp[-4].minor.yy202 = yylhsminor.yy202;\n+  yymsp[-4].minor.yy626 = yylhsminor.yy626;\n@@ -157626,1 +163799,1 @@\n-      case 180: \/* expr ::= ID|INDEXED LP STAR RP *\/\n+      case 189: \/* expr ::= ID|INDEXED LP STAR RP *\/\n@@ -157628,1 +163801,1 @@\n-  yylhsminor.yy202 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);\n+  yylhsminor.yy626 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);\n@@ -157630,1 +163803,1 @@\n-  yymsp[-3].minor.yy202 = yylhsminor.yy202;\n+  yymsp[-3].minor.yy626 = yylhsminor.yy626;\n@@ -157632,1 +163805,1 @@\n-      case 181: \/* expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n+      case 190: \/* expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n@@ -157634,2 +163807,2 @@\n-  yylhsminor.yy202 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy242, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy192);\n-  sqlite3WindowAttach(pParse, yylhsminor.yy202, yymsp[0].minor.yy303);\n+  yylhsminor.yy626 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy562, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy64);\n+  sqlite3WindowAttach(pParse, yylhsminor.yy626, yymsp[0].minor.yy375);\n@@ -157637,1 +163810,1 @@\n-  yymsp[-5].minor.yy202 = yylhsminor.yy202;\n+  yymsp[-5].minor.yy626 = yylhsminor.yy626;\n@@ -157639,1 +163812,1 @@\n-      case 182: \/* expr ::= ID|INDEXED LP STAR RP filter_over *\/\n+      case 191: \/* expr ::= ID|INDEXED LP STAR RP filter_over *\/\n@@ -157641,2 +163814,2 @@\n-  yylhsminor.yy202 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);\n-  sqlite3WindowAttach(pParse, yylhsminor.yy202, yymsp[0].minor.yy303);\n+  yylhsminor.yy626 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);\n+  sqlite3WindowAttach(pParse, yylhsminor.yy626, yymsp[0].minor.yy375);\n@@ -157644,1 +163817,1 @@\n-  yymsp[-4].minor.yy202 = yylhsminor.yy202;\n+  yymsp[-4].minor.yy626 = yylhsminor.yy626;\n@@ -157646,1 +163819,1 @@\n-      case 183: \/* term ::= CTIME_KW *\/\n+      case 192: \/* term ::= CTIME_KW *\/\n@@ -157648,1 +163821,1 @@\n-  yylhsminor.yy202 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);\n+  yylhsminor.yy626 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);\n@@ -157650,1 +163823,1 @@\n-  yymsp[0].minor.yy202 = yylhsminor.yy202;\n+  yymsp[0].minor.yy626 = yylhsminor.yy626;\n@@ -157652,1 +163825,1 @@\n-      case 184: \/* expr ::= LP nexprlist COMMA expr RP *\/\n+      case 193: \/* expr ::= LP nexprlist COMMA expr RP *\/\n@@ -157654,4 +163827,4 @@\n-  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy242, yymsp[-1].minor.yy202);\n-  yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);\n-  if( yymsp[-4].minor.yy202 ){\n-    yymsp[-4].minor.yy202->x.pList = pList;\n+  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy562, yymsp[-1].minor.yy626);\n+  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);\n+  if( yymsp[-4].minor.yy626 ){\n+    yymsp[-4].minor.yy626->x.pList = pList;\n@@ -157659,1 +163832,1 @@\n-      yymsp[-4].minor.yy202->flags |= pList->a[0].pExpr->flags & EP_Propagate;\n+      yymsp[-4].minor.yy626->flags |= pList->a[0].pExpr->flags & EP_Propagate;\n@@ -157666,2 +163839,2 @@\n-      case 185: \/* expr ::= expr AND expr *\/\n-{yymsp[-2].minor.yy202=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy202,yymsp[0].minor.yy202);}\n+      case 194: \/* expr ::= expr AND expr *\/\n+{yymsp[-2].minor.yy626=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);}\n@@ -157669,8 +163842,8 @@\n-      case 186: \/* expr ::= expr OR expr *\/\n-      case 187: \/* expr ::= expr LT|GT|GE|LE expr *\/ yytestcase(yyruleno==187);\n-      case 188: \/* expr ::= expr EQ|NE expr *\/ yytestcase(yyruleno==188);\n-      case 189: \/* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/ yytestcase(yyruleno==189);\n-      case 190: \/* expr ::= expr PLUS|MINUS expr *\/ yytestcase(yyruleno==190);\n-      case 191: \/* expr ::= expr STAR|SLASH|REM expr *\/ yytestcase(yyruleno==191);\n-      case 192: \/* expr ::= expr CONCAT expr *\/ yytestcase(yyruleno==192);\n-{yymsp[-2].minor.yy202=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy202,yymsp[0].minor.yy202);}\n+      case 195: \/* expr ::= expr OR expr *\/\n+      case 196: \/* expr ::= expr LT|GT|GE|LE expr *\/ yytestcase(yyruleno==196);\n+      case 197: \/* expr ::= expr EQ|NE expr *\/ yytestcase(yyruleno==197);\n+      case 198: \/* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/ yytestcase(yyruleno==198);\n+      case 199: \/* expr ::= expr PLUS|MINUS expr *\/ yytestcase(yyruleno==199);\n+      case 200: \/* expr ::= expr STAR|SLASH|REM expr *\/ yytestcase(yyruleno==200);\n+      case 201: \/* expr ::= expr CONCAT expr *\/ yytestcase(yyruleno==201);\n+{yymsp[-2].minor.yy626=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);}\n@@ -157678,1 +163851,1 @@\n-      case 193: \/* likeop ::= NOT LIKE_KW|MATCH *\/\n+      case 202: \/* likeop ::= NOT LIKE_KW|MATCH *\/\n@@ -157681,1 +163854,1 @@\n-      case 194: \/* expr ::= expr likeop expr *\/\n+      case 203: \/* expr ::= expr likeop expr *\/\n@@ -157686,5 +163859,5 @@\n-  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy202);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy202);\n-  yymsp[-2].minor.yy202 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n-  if( bNot ) yymsp[-2].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy202, 0);\n-  if( yymsp[-2].minor.yy202 ) yymsp[-2].minor.yy202->flags |= EP_InfixFunc;\n+  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy626);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy626);\n+  yymsp[-2].minor.yy626 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n+  if( bNot ) yymsp[-2].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy626, 0);\n+  if( yymsp[-2].minor.yy626 ) yymsp[-2].minor.yy626->flags |= EP_InfixFunc;\n@@ -157693,1 +163866,1 @@\n-      case 195: \/* expr ::= expr likeop expr ESCAPE expr *\/\n+      case 204: \/* expr ::= expr likeop expr ESCAPE expr *\/\n@@ -157698,6 +163871,6 @@\n-  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy202);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy202);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy202);\n-  yymsp[-4].minor.yy202 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);\n-  if( bNot ) yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy202, 0);\n-  if( yymsp[-4].minor.yy202 ) yymsp[-4].minor.yy202->flags |= EP_InfixFunc;\n+  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy626);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy626);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy626);\n+  yymsp[-4].minor.yy626 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);\n+  if( bNot ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);\n+  if( yymsp[-4].minor.yy626 ) yymsp[-4].minor.yy626->flags |= EP_InfixFunc;\n@@ -157706,2 +163879,2 @@\n-      case 196: \/* expr ::= expr ISNULL|NOTNULL *\/\n-{yymsp[-1].minor.yy202 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy202,0);}\n+      case 205: \/* expr ::= expr ISNULL|NOTNULL *\/\n+{yymsp[-1].minor.yy626 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy626,0);}\n@@ -157709,2 +163882,2 @@\n-      case 197: \/* expr ::= expr NOT NULL *\/\n-{yymsp[-2].minor.yy202 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy202,0);}\n+      case 206: \/* expr ::= expr NOT NULL *\/\n+{yymsp[-2].minor.yy626 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy626,0);}\n@@ -157712,1 +163885,1 @@\n-      case 198: \/* expr ::= expr IS expr *\/\n+      case 207: \/* expr ::= expr IS expr *\/\n@@ -157714,2 +163887,2 @@\n-  yymsp[-2].minor.yy202 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy202,yymsp[0].minor.yy202);\n-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy202, yymsp[-2].minor.yy202, TK_ISNULL);\n+  yymsp[-2].minor.yy626 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);\n+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy626, yymsp[-2].minor.yy626, TK_ISNULL);\n@@ -157718,1 +163891,1 @@\n-      case 199: \/* expr ::= expr IS NOT expr *\/\n+      case 208: \/* expr ::= expr IS NOT expr *\/\n@@ -157720,2 +163893,2 @@\n-  yymsp[-3].minor.yy202 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy202,yymsp[0].minor.yy202);\n-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy202, yymsp[-3].minor.yy202, TK_NOTNULL);\n+  yymsp[-3].minor.yy626 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy626,yymsp[0].minor.yy626);\n+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy626, yymsp[-3].minor.yy626, TK_NOTNULL);\n@@ -157724,3 +163897,3 @@\n-      case 200: \/* expr ::= NOT expr *\/\n-      case 201: \/* expr ::= BITNOT expr *\/ yytestcase(yyruleno==201);\n-{yymsp[-1].minor.yy202 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy202, 0);\/*A-overwrites-B*\/}\n+      case 209: \/* expr ::= NOT expr *\/\n+      case 210: \/* expr ::= BITNOT expr *\/ yytestcase(yyruleno==210);\n+{yymsp[-1].minor.yy626 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy626, 0);\/*A-overwrites-B*\/}\n@@ -157728,1 +163901,1 @@\n-      case 202: \/* expr ::= PLUS|MINUS expr *\/\n+      case 211: \/* expr ::= PLUS|MINUS expr *\/\n@@ -157730,1 +163903,1 @@\n-  yymsp[-1].minor.yy202 = sqlite3PExpr(pParse, yymsp[-1].major==TK_PLUS ? TK_UPLUS : TK_UMINUS, yymsp[0].minor.yy202, 0);\n+  yymsp[-1].minor.yy626 = sqlite3PExpr(pParse, yymsp[-1].major==TK_PLUS ? TK_UPLUS : TK_UMINUS, yymsp[0].minor.yy626, 0);\n@@ -157734,3 +163907,3 @@\n-      case 203: \/* between_op ::= BETWEEN *\/\n-      case 206: \/* in_op ::= IN *\/ yytestcase(yyruleno==206);\n-{yymsp[0].minor.yy192 = 0;}\n+      case 212: \/* between_op ::= BETWEEN *\/\n+      case 215: \/* in_op ::= IN *\/ yytestcase(yyruleno==215);\n+{yymsp[0].minor.yy64 = 0;}\n@@ -157738,1 +163911,1 @@\n-      case 205: \/* expr ::= expr between_op expr AND expr *\/\n+      case 214: \/* expr ::= expr between_op expr AND expr *\/\n@@ -157740,5 +163913,5 @@\n-  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy202);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy202);\n-  yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy202, 0);\n-  if( yymsp[-4].minor.yy202 ){\n-    yymsp[-4].minor.yy202->x.pList = pList;\n+  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy626);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy626);\n+  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy626, 0);\n+  if( yymsp[-4].minor.yy626 ){\n+    yymsp[-4].minor.yy626->x.pList = pList;\n@@ -157748,1 +163921,1 @@\n-  if( yymsp[-3].minor.yy192 ) yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy202, 0);\n+  if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);\n@@ -157751,1 +163924,1 @@\n-      case 208: \/* expr ::= expr in_op LP exprlist RP *\/\n+      case 217: \/* expr ::= expr in_op LP exprlist RP *\/\n@@ -157753,1 +163926,1 @@\n-    if( yymsp[-1].minor.yy242==0 ){\n+    if( yymsp[-1].minor.yy562==0 ){\n@@ -157762,14 +163935,9 @@\n-      sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy202);\n-      yymsp[-4].minor.yy202 = sqlite3Expr(pParse->db, TK_INTEGER, yymsp[-3].minor.yy192 ? \"1\" : \"0\");\n-    }else if( yymsp[-1].minor.yy242->nExpr==1 && sqlite3ExprIsConstant(yymsp[-1].minor.yy242->a[0].pExpr) ){\n-      Expr *pRHS = yymsp[-1].minor.yy242->a[0].pExpr;\n-      yymsp[-1].minor.yy242->a[0].pExpr = 0;\n-      sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy242);\n-      pRHS = sqlite3PExpr(pParse, TK_UPLUS, pRHS, 0);\n-      yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_EQ, yymsp[-4].minor.yy202, pRHS);\n-      if( yymsp[-3].minor.yy192 ) yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy202, 0);\n-    }else{\n-      yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy202, 0);\n-      if( yymsp[-4].minor.yy202 ){\n-        yymsp[-4].minor.yy202->x.pList = yymsp[-1].minor.yy242;\n-        sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy202);\n+      sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy626);\n+      yymsp[-4].minor.yy626 = sqlite3Expr(pParse->db, TK_INTEGER, yymsp[-3].minor.yy64 ? \"1\" : \"0\");\n+    }else{\n+      Expr *pRHS = yymsp[-1].minor.yy562->a[0].pExpr;\n+      if( yymsp[-1].minor.yy562->nExpr==1 && sqlite3ExprIsConstant(pRHS) && yymsp[-4].minor.yy626->op!=TK_VECTOR ){\n+        yymsp[-1].minor.yy562->a[0].pExpr = 0;\n+        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy562);\n+        pRHS = sqlite3PExpr(pParse, TK_UPLUS, pRHS, 0);\n+        yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_EQ, yymsp[-4].minor.yy626, pRHS);\n@@ -157777,1 +163945,14 @@\n-        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy242);\n+        yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy626, 0);\n+        if( yymsp[-4].minor.yy626==0 ){\n+          sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy562);\n+        }else if( yymsp[-4].minor.yy626->pLeft->op==TK_VECTOR ){\n+          int nExpr = yymsp[-4].minor.yy626->pLeft->x.pList->nExpr;\n+          Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy562);\n+          if( pSelectRHS ){\n+            parserDoubleLinkSelect(pParse, pSelectRHS);\n+            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy626, pSelectRHS);\n+          }\n+        }else{\n+          yymsp[-4].minor.yy626->x.pList = yymsp[-1].minor.yy562;\n+          sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy626);\n+        }\n@@ -157779,1 +163960,1 @@\n-      if( yymsp[-3].minor.yy192 ) yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy202, 0);\n+      if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);\n@@ -157783,1 +163964,1 @@\n-      case 209: \/* expr ::= LP select RP *\/\n+      case 218: \/* expr ::= LP select RP *\/\n@@ -157785,2 +163966,2 @@\n-    yymsp[-2].minor.yy202 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n-    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy202, yymsp[-1].minor.yy539);\n+    yymsp[-2].minor.yy626 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n+    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy626, yymsp[-1].minor.yy303);\n@@ -157789,1 +163970,1 @@\n-      case 210: \/* expr ::= expr in_op LP select RP *\/\n+      case 219: \/* expr ::= expr in_op LP select RP *\/\n@@ -157791,3 +163972,3 @@\n-    yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy202, 0);\n-    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy202, yymsp[-1].minor.yy539);\n-    if( yymsp[-3].minor.yy192 ) yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy202, 0);\n+    yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy626, 0);\n+    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy626, yymsp[-1].minor.yy303);\n+    if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);\n@@ -157796,1 +163977,1 @@\n-      case 211: \/* expr ::= expr in_op nm dbnm paren_exprlist *\/\n+      case 220: \/* expr ::= expr in_op nm dbnm paren_exprlist *\/\n@@ -157800,4 +163981,4 @@\n-    if( yymsp[0].minor.yy242 )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy242);\n-    yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy202, 0);\n-    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy202, pSelect);\n-    if( yymsp[-3].minor.yy192 ) yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy202, 0);\n+    if( yymsp[0].minor.yy562 )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy562);\n+    yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy626, 0);\n+    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy626, pSelect);\n+    if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);\n@@ -157806,1 +163987,1 @@\n-      case 212: \/* expr ::= EXISTS LP select RP *\/\n+      case 221: \/* expr ::= EXISTS LP select RP *\/\n@@ -157809,2 +163990,2 @@\n-    p = yymsp[-3].minor.yy202 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);\n-    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy539);\n+    p = yymsp[-3].minor.yy626 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);\n+    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy303);\n@@ -157813,1 +163994,1 @@\n-      case 213: \/* expr ::= CASE case_operand case_exprlist case_else END *\/\n+      case 222: \/* expr ::= CASE case_operand case_exprlist case_else END *\/\n@@ -157815,4 +163996,4 @@\n-  yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy202, 0);\n-  if( yymsp[-4].minor.yy202 ){\n-    yymsp[-4].minor.yy202->x.pList = yymsp[-1].minor.yy202 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy242,yymsp[-1].minor.yy202) : yymsp[-2].minor.yy242;\n-    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy202);\n+  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy626, 0);\n+  if( yymsp[-4].minor.yy626 ){\n+    yymsp[-4].minor.yy626->x.pList = yymsp[-1].minor.yy626 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy562,yymsp[-1].minor.yy626) : yymsp[-2].minor.yy562;\n+    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy626);\n@@ -157820,2 +164001,2 @@\n-    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy242);\n-    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy202);\n+    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy562);\n+    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy626);\n@@ -157825,1 +164006,1 @@\n-      case 214: \/* case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+      case 223: \/* case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n@@ -157827,2 +164008,2 @@\n-  yymsp[-4].minor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy242, yymsp[-2].minor.yy202);\n-  yymsp[-4].minor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy242, yymsp[0].minor.yy202);\n+  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562, yymsp[-2].minor.yy626);\n+  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562, yymsp[0].minor.yy626);\n@@ -157831,1 +164012,1 @@\n-      case 215: \/* case_exprlist ::= WHEN expr THEN expr *\/\n+      case 224: \/* case_exprlist ::= WHEN expr THEN expr *\/\n@@ -157833,2 +164014,2 @@\n-  yymsp[-3].minor.yy242 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy202);\n-  yymsp[-3].minor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy242, yymsp[0].minor.yy202);\n+  yymsp[-3].minor.yy562 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy626);\n+  yymsp[-3].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy562, yymsp[0].minor.yy626);\n@@ -157837,2 +164018,2 @@\n-      case 218: \/* case_operand ::= expr *\/\n-{yymsp[0].minor.yy202 = yymsp[0].minor.yy202; \/*A-overwrites-X*\/}\n+      case 227: \/* case_operand ::= expr *\/\n+{yymsp[0].minor.yy626 = yymsp[0].minor.yy626; \/*A-overwrites-X*\/}\n@@ -157840,2 +164021,2 @@\n-      case 221: \/* nexprlist ::= nexprlist COMMA expr *\/\n-{yymsp[-2].minor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy242,yymsp[0].minor.yy202);}\n+      case 230: \/* nexprlist ::= nexprlist COMMA expr *\/\n+{yymsp[-2].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy562,yymsp[0].minor.yy626);}\n@@ -157843,2 +164024,2 @@\n-      case 222: \/* nexprlist ::= expr *\/\n-{yymsp[0].minor.yy242 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy202); \/*A-overwrites-Y*\/}\n+      case 231: \/* nexprlist ::= expr *\/\n+{yymsp[0].minor.yy562 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy626); \/*A-overwrites-Y*\/}\n@@ -157846,3 +164027,3 @@\n-      case 224: \/* paren_exprlist ::= LP exprlist RP *\/\n-      case 229: \/* eidlist_opt ::= LP eidlist RP *\/ yytestcase(yyruleno==229);\n-{yymsp[-2].minor.yy242 = yymsp[-1].minor.yy242;}\n+      case 233: \/* paren_exprlist ::= LP exprlist RP *\/\n+      case 238: \/* eidlist_opt ::= LP eidlist RP *\/ yytestcase(yyruleno==238);\n+{yymsp[-2].minor.yy562 = yymsp[-1].minor.yy562;}\n@@ -157850,1 +164031,1 @@\n-      case 225: \/* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n+      case 234: \/* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n@@ -157853,2 +164034,2 @@\n-                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy242, yymsp[-10].minor.yy192,\n-                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy202, SQLITE_SO_ASC, yymsp[-8].minor.yy192, SQLITE_IDXTYPE_APPDEF);\n+                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy562, yymsp[-10].minor.yy64,\n+                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy626, SQLITE_SO_ASC, yymsp[-8].minor.yy64, SQLITE_IDXTYPE_APPDEF);\n@@ -157860,3 +164041,3 @@\n-      case 226: \/* uniqueflag ::= UNIQUE *\/\n-      case 268: \/* raisetype ::= ABORT *\/ yytestcase(yyruleno==268);\n-{yymsp[0].minor.yy192 = OE_Abort;}\n+      case 235: \/* uniqueflag ::= UNIQUE *\/\n+      case 277: \/* raisetype ::= ABORT *\/ yytestcase(yyruleno==277);\n+{yymsp[0].minor.yy64 = OE_Abort;}\n@@ -157864,2 +164045,2 @@\n-      case 227: \/* uniqueflag ::= *\/\n-{yymsp[1].minor.yy192 = OE_None;}\n+      case 236: \/* uniqueflag ::= *\/\n+{yymsp[1].minor.yy64 = OE_None;}\n@@ -157867,1 +164048,1 @@\n-      case 230: \/* eidlist ::= eidlist COMMA nm collate sortorder *\/\n+      case 239: \/* eidlist ::= eidlist COMMA nm collate sortorder *\/\n@@ -157869,1 +164050,1 @@\n-  yymsp[-4].minor.yy242 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy242, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy192, yymsp[0].minor.yy192);\n+  yymsp[-4].minor.yy562 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy562, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy64, yymsp[0].minor.yy64);\n@@ -157872,1 +164053,1 @@\n-      case 231: \/* eidlist ::= nm collate sortorder *\/\n+      case 240: \/* eidlist ::= nm collate sortorder *\/\n@@ -157874,1 +164055,1 @@\n-  yymsp[-2].minor.yy242 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy192, yymsp[0].minor.yy192); \/*A-overwrites-Y*\/\n+  yymsp[-2].minor.yy562 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy64, yymsp[0].minor.yy64); \/*A-overwrites-Y*\/\n@@ -157877,2 +164058,2 @@\n-      case 234: \/* cmd ::= DROP INDEX ifexists fullname *\/\n-{sqlite3DropIndex(pParse, yymsp[0].minor.yy47, yymsp[-1].minor.yy192);}\n+      case 243: \/* cmd ::= DROP INDEX ifexists fullname *\/\n+{sqlite3DropIndex(pParse, yymsp[0].minor.yy607, yymsp[-1].minor.yy64);}\n@@ -157880,2 +164061,2 @@\n-      case 235: \/* cmd ::= VACUUM vinto *\/\n-{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy202);}\n+      case 244: \/* cmd ::= VACUUM vinto *\/\n+{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy626);}\n@@ -157883,2 +164064,2 @@\n-      case 236: \/* cmd ::= VACUUM nm vinto *\/\n-{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy202);}\n+      case 245: \/* cmd ::= VACUUM nm vinto *\/\n+{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy626);}\n@@ -157886,1 +164067,1 @@\n-      case 239: \/* cmd ::= PRAGMA nm dbnm *\/\n+      case 248: \/* cmd ::= PRAGMA nm dbnm *\/\n@@ -157889,1 +164070,1 @@\n-      case 240: \/* cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n+      case 249: \/* cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n@@ -157892,1 +164073,1 @@\n-      case 241: \/* cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n+      case 250: \/* cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n@@ -157895,1 +164076,1 @@\n-      case 242: \/* cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n+      case 251: \/* cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n@@ -157898,1 +164079,1 @@\n-      case 243: \/* cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n+      case 252: \/* cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n@@ -157901,1 +164082,1 @@\n-      case 246: \/* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n+      case 255: \/* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n@@ -157906,1 +164087,1 @@\n-  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy447, &all);\n+  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy95, &all);\n@@ -157909,1 +164090,1 @@\n-      case 247: \/* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n+      case 256: \/* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n@@ -157911,1 +164092,1 @@\n-  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy192, yymsp[-4].minor.yy230.a, yymsp[-4].minor.yy230.b, yymsp[-2].minor.yy47, yymsp[0].minor.yy202, yymsp[-10].minor.yy192, yymsp[-8].minor.yy192);\n+  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy64, yymsp[-4].minor.yy570.a, yymsp[-4].minor.yy570.b, yymsp[-2].minor.yy607, yymsp[0].minor.yy626, yymsp[-10].minor.yy64, yymsp[-8].minor.yy64);\n@@ -157915,2 +164096,2 @@\n-      case 248: \/* trigger_time ::= BEFORE|AFTER *\/\n-{ yymsp[0].minor.yy192 = yymsp[0].major; \/*A-overwrites-X*\/ }\n+      case 257: \/* trigger_time ::= BEFORE|AFTER *\/\n+{ yymsp[0].minor.yy64 = yymsp[0].major; \/*A-overwrites-X*\/ }\n@@ -157918,2 +164099,2 @@\n-      case 249: \/* trigger_time ::= INSTEAD OF *\/\n-{ yymsp[-1].minor.yy192 = TK_INSTEAD;}\n+      case 258: \/* trigger_time ::= INSTEAD OF *\/\n+{ yymsp[-1].minor.yy64 = TK_INSTEAD;}\n@@ -157921,2 +164102,2 @@\n-      case 250: \/* trigger_time ::= *\/\n-{ yymsp[1].minor.yy192 = TK_BEFORE; }\n+      case 259: \/* trigger_time ::= *\/\n+{ yymsp[1].minor.yy64 = TK_BEFORE; }\n@@ -157924,3 +164105,3 @@\n-      case 251: \/* trigger_event ::= DELETE|INSERT *\/\n-      case 252: \/* trigger_event ::= UPDATE *\/ yytestcase(yyruleno==252);\n-{yymsp[0].minor.yy230.a = yymsp[0].major; \/*A-overwrites-X*\/ yymsp[0].minor.yy230.b = 0;}\n+      case 260: \/* trigger_event ::= DELETE|INSERT *\/\n+      case 261: \/* trigger_event ::= UPDATE *\/ yytestcase(yyruleno==261);\n+{yymsp[0].minor.yy570.a = yymsp[0].major; \/*A-overwrites-X*\/ yymsp[0].minor.yy570.b = 0;}\n@@ -157928,2 +164109,2 @@\n-      case 253: \/* trigger_event ::= UPDATE OF idlist *\/\n-{yymsp[-2].minor.yy230.a = TK_UPDATE; yymsp[-2].minor.yy230.b = yymsp[0].minor.yy600;}\n+      case 262: \/* trigger_event ::= UPDATE OF idlist *\/\n+{yymsp[-2].minor.yy570.a = TK_UPDATE; yymsp[-2].minor.yy570.b = yymsp[0].minor.yy240;}\n@@ -157931,3 +164112,3 @@\n-      case 254: \/* when_clause ::= *\/\n-      case 273: \/* key_opt ::= *\/ yytestcase(yyruleno==273);\n-{ yymsp[1].minor.yy202 = 0; }\n+      case 263: \/* when_clause ::= *\/\n+      case 282: \/* key_opt ::= *\/ yytestcase(yyruleno==282);\n+{ yymsp[1].minor.yy626 = 0; }\n@@ -157935,3 +164116,3 @@\n-      case 255: \/* when_clause ::= WHEN expr *\/\n-      case 274: \/* key_opt ::= KEY expr *\/ yytestcase(yyruleno==274);\n-{ yymsp[-1].minor.yy202 = yymsp[0].minor.yy202; }\n+      case 264: \/* when_clause ::= WHEN expr *\/\n+      case 283: \/* key_opt ::= KEY expr *\/ yytestcase(yyruleno==283);\n+{ yymsp[-1].minor.yy626 = yymsp[0].minor.yy626; }\n@@ -157939,1 +164120,1 @@\n-      case 256: \/* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n+      case 265: \/* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n@@ -157941,3 +164122,3 @@\n-  assert( yymsp[-2].minor.yy447!=0 );\n-  yymsp[-2].minor.yy447->pLast->pNext = yymsp[-1].minor.yy447;\n-  yymsp[-2].minor.yy447->pLast = yymsp[-1].minor.yy447;\n+  assert( yymsp[-2].minor.yy95!=0 );\n+  yymsp[-2].minor.yy95->pLast->pNext = yymsp[-1].minor.yy95;\n+  yymsp[-2].minor.yy95->pLast = yymsp[-1].minor.yy95;\n@@ -157946,1 +164127,1 @@\n-      case 257: \/* trigger_cmd_list ::= trigger_cmd SEMI *\/\n+      case 266: \/* trigger_cmd_list ::= trigger_cmd SEMI *\/\n@@ -157948,2 +164129,2 @@\n-  assert( yymsp[-1].minor.yy447!=0 );\n-  yymsp[-1].minor.yy447->pLast = yymsp[-1].minor.yy447;\n+  assert( yymsp[-1].minor.yy95!=0 );\n+  yymsp[-1].minor.yy95->pLast = yymsp[-1].minor.yy95;\n@@ -157952,1 +164133,1 @@\n-      case 258: \/* trnm ::= nm DOT nm *\/\n+      case 267: \/* trnm ::= nm DOT nm *\/\n@@ -157960,1 +164141,1 @@\n-      case 259: \/* tridxby ::= INDEXED BY nm *\/\n+      case 268: \/* tridxby ::= INDEXED BY nm *\/\n@@ -157967,1 +164148,1 @@\n-      case 260: \/* tridxby ::= NOT INDEXED *\/\n+      case 269: \/* tridxby ::= NOT INDEXED *\/\n@@ -157974,3 +164155,3 @@\n-      case 261: \/* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt *\/\n-{yylhsminor.yy447 = sqlite3TriggerUpdateStep(pParse, &yymsp[-5].minor.yy0, yymsp[-2].minor.yy242, yymsp[-1].minor.yy202, yymsp[-6].minor.yy192, yymsp[-7].minor.yy0.z, yymsp[0].minor.yy436);}\n-  yymsp[-7].minor.yy447 = yylhsminor.yy447;\n+      case 270: \/* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n+{yylhsminor.yy95 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy607, yymsp[-3].minor.yy562, yymsp[-1].minor.yy626, yymsp[-7].minor.yy64, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy600);}\n+  yymsp[-8].minor.yy95 = yylhsminor.yy95;\n@@ -157978,1 +164159,1 @@\n-      case 262: \/* trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n+      case 271: \/* trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n@@ -157980,1 +164161,1 @@\n-   yylhsminor.yy447 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy600,yymsp[-2].minor.yy539,yymsp[-6].minor.yy192,yymsp[-1].minor.yy318,yymsp[-7].minor.yy436,yymsp[0].minor.yy436);\/*yylhsminor.yy447-overwrites-yymsp[-6].minor.yy192*\/\n+   yylhsminor.yy95 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy240,yymsp[-2].minor.yy303,yymsp[-6].minor.yy64,yymsp[-1].minor.yy138,yymsp[-7].minor.yy600,yymsp[0].minor.yy600);\/*yylhsminor.yy95-overwrites-yymsp[-6].minor.yy64*\/\n@@ -157982,1 +164163,1 @@\n-  yymsp[-7].minor.yy447 = yylhsminor.yy447;\n+  yymsp[-7].minor.yy95 = yylhsminor.yy95;\n@@ -157984,3 +164165,3 @@\n-      case 263: \/* trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n-{yylhsminor.yy447 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy202, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy436);}\n-  yymsp[-5].minor.yy447 = yylhsminor.yy447;\n+      case 272: \/* trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n+{yylhsminor.yy95 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy626, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy600);}\n+  yymsp[-5].minor.yy95 = yylhsminor.yy95;\n@@ -157988,3 +164169,3 @@\n-      case 264: \/* trigger_cmd ::= scanpt select scanpt *\/\n-{yylhsminor.yy447 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy539, yymsp[-2].minor.yy436, yymsp[0].minor.yy436); \/*yylhsminor.yy447-overwrites-yymsp[-1].minor.yy539*\/}\n-  yymsp[-2].minor.yy447 = yylhsminor.yy447;\n+      case 273: \/* trigger_cmd ::= scanpt select scanpt *\/\n+{yylhsminor.yy95 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy303, yymsp[-2].minor.yy600, yymsp[0].minor.yy600); \/*yylhsminor.yy95-overwrites-yymsp[-1].minor.yy303*\/}\n+  yymsp[-2].minor.yy95 = yylhsminor.yy95;\n@@ -157992,1 +164173,1 @@\n-      case 265: \/* expr ::= RAISE LP IGNORE RP *\/\n+      case 274: \/* expr ::= RAISE LP IGNORE RP *\/\n@@ -157994,3 +164175,3 @@\n-  yymsp[-3].minor.yy202 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);\n-  if( yymsp[-3].minor.yy202 ){\n-    yymsp[-3].minor.yy202->affExpr = OE_Ignore;\n+  yymsp[-3].minor.yy626 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);\n+  if( yymsp[-3].minor.yy626 ){\n+    yymsp[-3].minor.yy626->affExpr = OE_Ignore;\n@@ -158000,1 +164181,1 @@\n-      case 266: \/* expr ::= RAISE LP raisetype COMMA nm RP *\/\n+      case 275: \/* expr ::= RAISE LP raisetype COMMA nm RP *\/\n@@ -158002,3 +164183,3 @@\n-  yymsp[-5].minor.yy202 = sqlite3ExprAlloc(pParse->db, TK_RAISE, &yymsp[-1].minor.yy0, 1);\n-  if( yymsp[-5].minor.yy202 ) {\n-    yymsp[-5].minor.yy202->affExpr = (char)yymsp[-3].minor.yy192;\n+  yymsp[-5].minor.yy626 = sqlite3ExprAlloc(pParse->db, TK_RAISE, &yymsp[-1].minor.yy0, 1);\n+  if( yymsp[-5].minor.yy626 ) {\n+    yymsp[-5].minor.yy626->affExpr = (char)yymsp[-3].minor.yy64;\n@@ -158008,2 +164189,2 @@\n-      case 267: \/* raisetype ::= ROLLBACK *\/\n-{yymsp[0].minor.yy192 = OE_Rollback;}\n+      case 276: \/* raisetype ::= ROLLBACK *\/\n+{yymsp[0].minor.yy64 = OE_Rollback;}\n@@ -158011,2 +164192,2 @@\n-      case 269: \/* raisetype ::= FAIL *\/\n-{yymsp[0].minor.yy192 = OE_Fail;}\n+      case 278: \/* raisetype ::= FAIL *\/\n+{yymsp[0].minor.yy64 = OE_Fail;}\n@@ -158014,1 +164195,1 @@\n-      case 270: \/* cmd ::= DROP TRIGGER ifexists fullname *\/\n+      case 279: \/* cmd ::= DROP TRIGGER ifexists fullname *\/\n@@ -158016,1 +164197,1 @@\n-  sqlite3DropTrigger(pParse,yymsp[0].minor.yy47,yymsp[-1].minor.yy192);\n+  sqlite3DropTrigger(pParse,yymsp[0].minor.yy607,yymsp[-1].minor.yy64);\n@@ -158019,1 +164200,1 @@\n-      case 271: \/* cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n+      case 280: \/* cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n@@ -158021,1 +164202,1 @@\n-  sqlite3Attach(pParse, yymsp[-3].minor.yy202, yymsp[-1].minor.yy202, yymsp[0].minor.yy202);\n+  sqlite3Attach(pParse, yymsp[-3].minor.yy626, yymsp[-1].minor.yy626, yymsp[0].minor.yy626);\n@@ -158024,1 +164205,1 @@\n-      case 272: \/* cmd ::= DETACH database_kw_opt expr *\/\n+      case 281: \/* cmd ::= DETACH database_kw_opt expr *\/\n@@ -158026,1 +164207,1 @@\n-  sqlite3Detach(pParse, yymsp[0].minor.yy202);\n+  sqlite3Detach(pParse, yymsp[0].minor.yy626);\n@@ -158029,1 +164210,1 @@\n-      case 275: \/* cmd ::= REINDEX *\/\n+      case 284: \/* cmd ::= REINDEX *\/\n@@ -158032,1 +164213,1 @@\n-      case 276: \/* cmd ::= REINDEX nm dbnm *\/\n+      case 285: \/* cmd ::= REINDEX nm dbnm *\/\n@@ -158035,1 +164216,1 @@\n-      case 277: \/* cmd ::= ANALYZE *\/\n+      case 286: \/* cmd ::= ANALYZE *\/\n@@ -158038,1 +164219,1 @@\n-      case 278: \/* cmd ::= ANALYZE nm dbnm *\/\n+      case 287: \/* cmd ::= ANALYZE nm dbnm *\/\n@@ -158041,1 +164222,1 @@\n-      case 279: \/* cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n+      case 288: \/* cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n@@ -158043,1 +164224,1 @@\n-  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy47,&yymsp[0].minor.yy0);\n+  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy607,&yymsp[0].minor.yy0);\n@@ -158046,1 +164227,1 @@\n-      case 280: \/* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n+      case 289: \/* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n@@ -158052,1 +164233,6 @@\n-      case 281: \/* add_column_fullname ::= fullname *\/\n+      case 290: \/* cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n+{\n+  sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy607, &yymsp[0].minor.yy0);\n+}\n+        break;\n+      case 291: \/* add_column_fullname ::= fullname *\/\n@@ -158055,1 +164241,1 @@\n-  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy47);\n+  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy607);\n@@ -158058,1 +164244,1 @@\n-      case 282: \/* cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n+      case 292: \/* cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n@@ -158060,1 +164246,1 @@\n-  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy47, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n+  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy607, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n@@ -158063,1 +164249,1 @@\n-      case 283: \/* cmd ::= create_vtab *\/\n+      case 293: \/* cmd ::= create_vtab *\/\n@@ -158066,1 +164252,1 @@\n-      case 284: \/* cmd ::= create_vtab LP vtabarglist RP *\/\n+      case 294: \/* cmd ::= create_vtab LP vtabarglist RP *\/\n@@ -158069,1 +164255,1 @@\n-      case 285: \/* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n+      case 295: \/* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n@@ -158071,1 +164257,1 @@\n-    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy192);\n+    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy64);\n@@ -158074,1 +164260,1 @@\n-      case 286: \/* vtabarg ::= *\/\n+      case 296: \/* vtabarg ::= *\/\n@@ -158077,3 +164263,3 @@\n-      case 287: \/* vtabargtoken ::= ANY *\/\n-      case 288: \/* vtabargtoken ::= lp anylist RP *\/ yytestcase(yyruleno==288);\n-      case 289: \/* lp ::= LP *\/ yytestcase(yyruleno==289);\n+      case 297: \/* vtabargtoken ::= ANY *\/\n+      case 298: \/* vtabargtoken ::= lp anylist RP *\/ yytestcase(yyruleno==298);\n+      case 299: \/* lp ::= LP *\/ yytestcase(yyruleno==299);\n@@ -158082,3 +164268,17 @@\n-      case 290: \/* with ::= WITH wqlist *\/\n-      case 291: \/* with ::= WITH RECURSIVE wqlist *\/ yytestcase(yyruleno==291);\n-{ sqlite3WithPush(pParse, yymsp[0].minor.yy131, 1); }\n+      case 300: \/* with ::= WITH wqlist *\/\n+      case 301: \/* with ::= WITH RECURSIVE wqlist *\/ yytestcase(yyruleno==301);\n+{ sqlite3WithPush(pParse, yymsp[0].minor.yy43, 1); }\n+        break;\n+      case 302: \/* wqas ::= AS *\/\n+{yymsp[0].minor.yy534 = M10d_Any;}\n+        break;\n+      case 303: \/* wqas ::= AS MATERIALIZED *\/\n+{yymsp[-1].minor.yy534 = M10d_Yes;}\n+        break;\n+      case 304: \/* wqas ::= AS NOT MATERIALIZED *\/\n+{yymsp[-2].minor.yy534 = M10d_No;}\n+        break;\n+      case 305: \/* wqitem ::= nm eidlist_opt wqas LP select RP *\/\n+{\n+  yymsp[-5].minor.yy255 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy562, yymsp[-1].minor.yy303, yymsp[-3].minor.yy534); \/*A-overwrites-X*\/\n+}\n@@ -158086,1 +164286,1 @@\n-      case 292: \/* wqlist ::= nm eidlist_opt AS LP select RP *\/\n+      case 306: \/* wqlist ::= wqitem *\/\n@@ -158088,1 +164288,1 @@\n-  yymsp[-5].minor.yy131 = sqlite3WithAdd(pParse, 0, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy242, yymsp[-1].minor.yy539); \/*A-overwrites-X*\/\n+  yymsp[0].minor.yy43 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy255); \/*A-overwrites-X*\/\n@@ -158091,1 +164291,1 @@\n-      case 293: \/* wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP *\/\n+      case 307: \/* wqlist ::= wqlist COMMA wqitem *\/\n@@ -158093,1 +164293,1 @@\n-  yymsp[-7].minor.yy131 = sqlite3WithAdd(pParse, yymsp[-7].minor.yy131, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy242, yymsp[-1].minor.yy539);\n+  yymsp[-2].minor.yy43 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy43, yymsp[0].minor.yy255);\n@@ -158096,3 +164296,3 @@\n-      case 294: \/* windowdefn_list ::= windowdefn *\/\n-{ yylhsminor.yy303 = yymsp[0].minor.yy303; }\n-  yymsp[0].minor.yy303 = yylhsminor.yy303;\n+      case 308: \/* windowdefn_list ::= windowdefn *\/\n+{ yylhsminor.yy375 = yymsp[0].minor.yy375; }\n+  yymsp[0].minor.yy375 = yylhsminor.yy375;\n@@ -158100,1 +164300,1 @@\n-      case 295: \/* windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+      case 309: \/* windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n@@ -158102,4 +164302,4 @@\n-  assert( yymsp[0].minor.yy303!=0 );\n-  sqlite3WindowChain(pParse, yymsp[0].minor.yy303, yymsp[-2].minor.yy303);\n-  yymsp[0].minor.yy303->pNextWin = yymsp[-2].minor.yy303;\n-  yylhsminor.yy303 = yymsp[0].minor.yy303;\n+  assert( yymsp[0].minor.yy375!=0 );\n+  sqlite3WindowChain(pParse, yymsp[0].minor.yy375, yymsp[-2].minor.yy375);\n+  yymsp[0].minor.yy375->pNextWin = yymsp[-2].minor.yy375;\n+  yylhsminor.yy375 = yymsp[0].minor.yy375;\n@@ -158107,1 +164307,1 @@\n-  yymsp[-2].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-2].minor.yy375 = yylhsminor.yy375;\n@@ -158109,1 +164309,1 @@\n-      case 296: \/* windowdefn ::= nm AS LP window RP *\/\n+      case 310: \/* windowdefn ::= nm AS LP window RP *\/\n@@ -158111,2 +164311,2 @@\n-  if( ALWAYS(yymsp[-1].minor.yy303) ){\n-    yymsp[-1].minor.yy303->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);\n+  if( ALWAYS(yymsp[-1].minor.yy375) ){\n+    yymsp[-1].minor.yy375->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);\n@@ -158114,1 +164314,1 @@\n-  yylhsminor.yy303 = yymsp[-1].minor.yy303;\n+  yylhsminor.yy375 = yymsp[-1].minor.yy375;\n@@ -158116,1 +164316,1 @@\n-  yymsp[-4].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-4].minor.yy375 = yylhsminor.yy375;\n@@ -158118,1 +164318,1 @@\n-      case 297: \/* window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+      case 311: \/* window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n@@ -158120,1 +164320,1 @@\n-  yymsp[-4].minor.yy303 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy303, yymsp[-2].minor.yy242, yymsp[-1].minor.yy242, 0);\n+  yymsp[-4].minor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, yymsp[-2].minor.yy562, yymsp[-1].minor.yy562, 0);\n@@ -158123,1 +164323,1 @@\n-      case 298: \/* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+      case 312: \/* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n@@ -158125,1 +164325,1 @@\n-  yylhsminor.yy303 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy303, yymsp[-2].minor.yy242, yymsp[-1].minor.yy242, &yymsp[-5].minor.yy0);\n+  yylhsminor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, yymsp[-2].minor.yy562, yymsp[-1].minor.yy562, &yymsp[-5].minor.yy0);\n@@ -158127,1 +164327,1 @@\n-  yymsp[-5].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-5].minor.yy375 = yylhsminor.yy375;\n@@ -158129,1 +164329,1 @@\n-      case 299: \/* window ::= ORDER BY sortlist frame_opt *\/\n+      case 313: \/* window ::= ORDER BY sortlist frame_opt *\/\n@@ -158131,1 +164331,1 @@\n-  yymsp[-3].minor.yy303 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy303, 0, yymsp[-1].minor.yy242, 0);\n+  yymsp[-3].minor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, 0, yymsp[-1].minor.yy562, 0);\n@@ -158134,1 +164334,1 @@\n-      case 300: \/* window ::= nm ORDER BY sortlist frame_opt *\/\n+      case 314: \/* window ::= nm ORDER BY sortlist frame_opt *\/\n@@ -158136,1 +164336,1 @@\n-  yylhsminor.yy303 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy303, 0, yymsp[-1].minor.yy242, &yymsp[-4].minor.yy0);\n+  yylhsminor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, 0, yymsp[-1].minor.yy562, &yymsp[-4].minor.yy0);\n@@ -158138,1 +164338,1 @@\n-  yymsp[-4].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-4].minor.yy375 = yylhsminor.yy375;\n@@ -158140,2 +164340,2 @@\n-      case 301: \/* window ::= frame_opt *\/\n-      case 320: \/* filter_over ::= over_clause *\/ yytestcase(yyruleno==320);\n+      case 315: \/* window ::= frame_opt *\/\n+      case 334: \/* filter_over ::= over_clause *\/ yytestcase(yyruleno==334);\n@@ -158143,1 +164343,1 @@\n-  yylhsminor.yy303 = yymsp[0].minor.yy303;\n+  yylhsminor.yy375 = yymsp[0].minor.yy375;\n@@ -158145,1 +164345,1 @@\n-  yymsp[0].minor.yy303 = yylhsminor.yy303;\n+  yymsp[0].minor.yy375 = yylhsminor.yy375;\n@@ -158147,1 +164347,1 @@\n-      case 302: \/* window ::= nm frame_opt *\/\n+      case 316: \/* window ::= nm frame_opt *\/\n@@ -158149,1 +164349,1 @@\n-  yylhsminor.yy303 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy303, 0, 0, &yymsp[-1].minor.yy0);\n+  yylhsminor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, 0, 0, &yymsp[-1].minor.yy0);\n@@ -158151,1 +164351,1 @@\n-  yymsp[-1].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-1].minor.yy375 = yylhsminor.yy375;\n@@ -158153,1 +164353,1 @@\n-      case 303: \/* frame_opt ::= *\/\n+      case 317: \/* frame_opt ::= *\/\n@@ -158155,1 +164355,1 @@\n-  yymsp[1].minor.yy303 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);\n+  yymsp[1].minor.yy375 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);\n@@ -158158,1 +164358,1 @@\n-      case 304: \/* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+      case 318: \/* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n@@ -158160,1 +164360,1 @@\n-  yylhsminor.yy303 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy192, yymsp[-1].minor.yy77.eType, yymsp[-1].minor.yy77.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy58);\n+  yylhsminor.yy375 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy64, yymsp[-1].minor.yy81.eType, yymsp[-1].minor.yy81.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy534);\n@@ -158162,1 +164362,1 @@\n-  yymsp[-2].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-2].minor.yy375 = yylhsminor.yy375;\n@@ -158164,1 +164364,1 @@\n-      case 305: \/* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+      case 319: \/* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n@@ -158166,1 +164366,1 @@\n-  yylhsminor.yy303 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy192, yymsp[-3].minor.yy77.eType, yymsp[-3].minor.yy77.pExpr, yymsp[-1].minor.yy77.eType, yymsp[-1].minor.yy77.pExpr, yymsp[0].minor.yy58);\n+  yylhsminor.yy375 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy64, yymsp[-3].minor.yy81.eType, yymsp[-3].minor.yy81.pExpr, yymsp[-1].minor.yy81.eType, yymsp[-1].minor.yy81.pExpr, yymsp[0].minor.yy534);\n@@ -158168,1 +164368,1 @@\n-  yymsp[-5].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-5].minor.yy375 = yylhsminor.yy375;\n@@ -158170,4 +164370,4 @@\n-      case 307: \/* frame_bound_s ::= frame_bound *\/\n-      case 309: \/* frame_bound_e ::= frame_bound *\/ yytestcase(yyruleno==309);\n-{yylhsminor.yy77 = yymsp[0].minor.yy77;}\n-  yymsp[0].minor.yy77 = yylhsminor.yy77;\n+      case 321: \/* frame_bound_s ::= frame_bound *\/\n+      case 323: \/* frame_bound_e ::= frame_bound *\/ yytestcase(yyruleno==323);\n+{yylhsminor.yy81 = yymsp[0].minor.yy81;}\n+  yymsp[0].minor.yy81 = yylhsminor.yy81;\n@@ -158175,5 +164375,5 @@\n-      case 308: \/* frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-      case 310: \/* frame_bound_e ::= UNBOUNDED FOLLOWING *\/ yytestcase(yyruleno==310);\n-      case 312: \/* frame_bound ::= CURRENT ROW *\/ yytestcase(yyruleno==312);\n-{yylhsminor.yy77.eType = yymsp[-1].major; yylhsminor.yy77.pExpr = 0;}\n-  yymsp[-1].minor.yy77 = yylhsminor.yy77;\n+      case 322: \/* frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+      case 324: \/* frame_bound_e ::= UNBOUNDED FOLLOWING *\/ yytestcase(yyruleno==324);\n+      case 326: \/* frame_bound ::= CURRENT ROW *\/ yytestcase(yyruleno==326);\n+{yylhsminor.yy81.eType = yymsp[-1].major; yylhsminor.yy81.pExpr = 0;}\n+  yymsp[-1].minor.yy81 = yylhsminor.yy81;\n@@ -158181,3 +164381,3 @@\n-      case 311: \/* frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-{yylhsminor.yy77.eType = yymsp[0].major; yylhsminor.yy77.pExpr = yymsp[-1].minor.yy202;}\n-  yymsp[-1].minor.yy77 = yylhsminor.yy77;\n+      case 325: \/* frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+{yylhsminor.yy81.eType = yymsp[0].major; yylhsminor.yy81.pExpr = yymsp[-1].minor.yy626;}\n+  yymsp[-1].minor.yy81 = yylhsminor.yy81;\n@@ -158185,2 +164385,2 @@\n-      case 313: \/* frame_exclude_opt ::= *\/\n-{yymsp[1].minor.yy58 = 0;}\n+      case 327: \/* frame_exclude_opt ::= *\/\n+{yymsp[1].minor.yy534 = 0;}\n@@ -158188,2 +164388,2 @@\n-      case 314: \/* frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-{yymsp[-1].minor.yy58 = yymsp[0].minor.yy58;}\n+      case 328: \/* frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+{yymsp[-1].minor.yy534 = yymsp[0].minor.yy534;}\n@@ -158191,3 +164391,3 @@\n-      case 315: \/* frame_exclude ::= NO OTHERS *\/\n-      case 316: \/* frame_exclude ::= CURRENT ROW *\/ yytestcase(yyruleno==316);\n-{yymsp[-1].minor.yy58 = yymsp[-1].major; \/*A-overwrites-X*\/}\n+      case 329: \/* frame_exclude ::= NO OTHERS *\/\n+      case 330: \/* frame_exclude ::= CURRENT ROW *\/ yytestcase(yyruleno==330);\n+{yymsp[-1].minor.yy534 = yymsp[-1].major; \/*A-overwrites-X*\/}\n@@ -158195,2 +164395,2 @@\n-      case 317: \/* frame_exclude ::= GROUP|TIES *\/\n-{yymsp[0].minor.yy58 = yymsp[0].major; \/*A-overwrites-X*\/}\n+      case 331: \/* frame_exclude ::= GROUP|TIES *\/\n+{yymsp[0].minor.yy534 = yymsp[0].major; \/*A-overwrites-X*\/}\n@@ -158198,2 +164398,2 @@\n-      case 318: \/* window_clause ::= WINDOW windowdefn_list *\/\n-{ yymsp[-1].minor.yy303 = yymsp[0].minor.yy303; }\n+      case 332: \/* window_clause ::= WINDOW windowdefn_list *\/\n+{ yymsp[-1].minor.yy375 = yymsp[0].minor.yy375; }\n@@ -158201,1 +164401,1 @@\n-      case 319: \/* filter_over ::= filter_clause over_clause *\/\n+      case 333: \/* filter_over ::= filter_clause over_clause *\/\n@@ -158203,2 +164403,6 @@\n-  yymsp[0].minor.yy303->pFilter = yymsp[-1].minor.yy202;\n-  yylhsminor.yy303 = yymsp[0].minor.yy303;\n+  if( yymsp[0].minor.yy375 ){\n+    yymsp[0].minor.yy375->pFilter = yymsp[-1].minor.yy626;\n+  }else{\n+    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy626);\n+  }\n+  yylhsminor.yy375 = yymsp[0].minor.yy375;\n@@ -158206,1 +164410,1 @@\n-  yymsp[-1].minor.yy303 = yylhsminor.yy303;\n+  yymsp[-1].minor.yy375 = yylhsminor.yy375;\n@@ -158208,1 +164412,1 @@\n-      case 321: \/* filter_over ::= filter_clause *\/\n+      case 335: \/* filter_over ::= filter_clause *\/\n@@ -158210,4 +164414,4 @@\n-  yylhsminor.yy303 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n-  if( yylhsminor.yy303 ){\n-    yylhsminor.yy303->eFrmType = TK_FILTER;\n-    yylhsminor.yy303->pFilter = yymsp[0].minor.yy202;\n+  yylhsminor.yy375 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n+  if( yylhsminor.yy375 ){\n+    yylhsminor.yy375->eFrmType = TK_FILTER;\n+    yylhsminor.yy375->pFilter = yymsp[0].minor.yy626;\n@@ -158215,1 +164419,1 @@\n-    sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy202);\n+    sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy626);\n@@ -158218,1 +164422,1 @@\n-  yymsp[0].minor.yy303 = yylhsminor.yy303;\n+  yymsp[0].minor.yy375 = yylhsminor.yy375;\n@@ -158220,1 +164424,1 @@\n-      case 322: \/* over_clause ::= OVER LP window RP *\/\n+      case 336: \/* over_clause ::= OVER LP window RP *\/\n@@ -158222,2 +164426,2 @@\n-  yymsp[-3].minor.yy303 = yymsp[-1].minor.yy303;\n-  assert( yymsp[-3].minor.yy303!=0 );\n+  yymsp[-3].minor.yy375 = yymsp[-1].minor.yy375;\n+  assert( yymsp[-3].minor.yy375!=0 );\n@@ -158226,1 +164430,1 @@\n-      case 323: \/* over_clause ::= OVER nm *\/\n+      case 337: \/* over_clause ::= OVER nm *\/\n@@ -158228,3 +164432,3 @@\n-  yymsp[-1].minor.yy303 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n-  if( yymsp[-1].minor.yy303 ){\n-    yymsp[-1].minor.yy303->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);\n+  yymsp[-1].minor.yy375 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n+  if( yymsp[-1].minor.yy375 ){\n+    yymsp[-1].minor.yy375->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);\n@@ -158234,2 +164438,2 @@\n-      case 324: \/* filter_clause ::= FILTER LP WHERE expr RP *\/\n-{ yymsp[-4].minor.yy202 = yymsp[-1].minor.yy202; }\n+      case 338: \/* filter_clause ::= FILTER LP WHERE expr RP *\/\n+{ yymsp[-4].minor.yy626 = yymsp[-1].minor.yy626; }\n@@ -158238,60 +164442,62 @@\n-      \/* (325) input ::= cmdlist *\/ yytestcase(yyruleno==325);\n-      \/* (326) cmdlist ::= cmdlist ecmd *\/ yytestcase(yyruleno==326);\n-      \/* (327) cmdlist ::= ecmd (OPTIMIZED OUT) *\/ assert(yyruleno!=327);\n-      \/* (328) ecmd ::= SEMI *\/ yytestcase(yyruleno==328);\n-      \/* (329) ecmd ::= cmdx SEMI *\/ yytestcase(yyruleno==329);\n-      \/* (330) ecmd ::= explain cmdx SEMI (NEVER REDUCES) *\/ assert(yyruleno!=330);\n-      \/* (331) trans_opt ::= *\/ yytestcase(yyruleno==331);\n-      \/* (332) trans_opt ::= TRANSACTION *\/ yytestcase(yyruleno==332);\n-      \/* (333) trans_opt ::= TRANSACTION nm *\/ yytestcase(yyruleno==333);\n-      \/* (334) savepoint_opt ::= SAVEPOINT *\/ yytestcase(yyruleno==334);\n-      \/* (335) savepoint_opt ::= *\/ yytestcase(yyruleno==335);\n-      \/* (336) cmd ::= create_table create_table_args *\/ yytestcase(yyruleno==336);\n-      \/* (337) columnlist ::= columnlist COMMA columnname carglist *\/ yytestcase(yyruleno==337);\n-      \/* (338) columnlist ::= columnname carglist *\/ yytestcase(yyruleno==338);\n-      \/* (339) nm ::= ID|INDEXED *\/ yytestcase(yyruleno==339);\n-      \/* (340) nm ::= STRING *\/ yytestcase(yyruleno==340);\n-      \/* (341) nm ::= JOIN_KW *\/ yytestcase(yyruleno==341);\n-      \/* (342) typetoken ::= typename *\/ yytestcase(yyruleno==342);\n-      \/* (343) typename ::= ID|STRING *\/ yytestcase(yyruleno==343);\n-      \/* (344) signed ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=344);\n-      \/* (345) signed ::= minus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=345);\n-      \/* (346) carglist ::= carglist ccons *\/ yytestcase(yyruleno==346);\n-      \/* (347) carglist ::= *\/ yytestcase(yyruleno==347);\n-      \/* (348) ccons ::= NULL onconf *\/ yytestcase(yyruleno==348);\n-      \/* (349) ccons ::= GENERATED ALWAYS AS generated *\/ yytestcase(yyruleno==349);\n-      \/* (350) ccons ::= AS generated *\/ yytestcase(yyruleno==350);\n-      \/* (351) conslist_opt ::= COMMA conslist *\/ yytestcase(yyruleno==351);\n-      \/* (352) conslist ::= conslist tconscomma tcons *\/ yytestcase(yyruleno==352);\n-      \/* (353) conslist ::= tcons (OPTIMIZED OUT) *\/ assert(yyruleno!=353);\n-      \/* (354) tconscomma ::= *\/ yytestcase(yyruleno==354);\n-      \/* (355) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) *\/ assert(yyruleno!=355);\n-      \/* (356) resolvetype ::= raisetype (OPTIMIZED OUT) *\/ assert(yyruleno!=356);\n-      \/* (357) selectnowith ::= oneselect (OPTIMIZED OUT) *\/ assert(yyruleno!=357);\n-      \/* (358) oneselect ::= values *\/ yytestcase(yyruleno==358);\n-      \/* (359) sclp ::= selcollist COMMA *\/ yytestcase(yyruleno==359);\n-      \/* (360) as ::= ID|STRING *\/ yytestcase(yyruleno==360);\n-      \/* (361) expr ::= term (OPTIMIZED OUT) *\/ assert(yyruleno!=361);\n-      \/* (362) likeop ::= LIKE_KW|MATCH *\/ yytestcase(yyruleno==362);\n-      \/* (363) exprlist ::= nexprlist *\/ yytestcase(yyruleno==363);\n-      \/* (364) nmnum ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=364);\n-      \/* (365) nmnum ::= nm (OPTIMIZED OUT) *\/ assert(yyruleno!=365);\n-      \/* (366) nmnum ::= ON *\/ yytestcase(yyruleno==366);\n-      \/* (367) nmnum ::= DELETE *\/ yytestcase(yyruleno==367);\n-      \/* (368) nmnum ::= DEFAULT *\/ yytestcase(yyruleno==368);\n-      \/* (369) plus_num ::= INTEGER|FLOAT *\/ yytestcase(yyruleno==369);\n-      \/* (370) foreach_clause ::= *\/ yytestcase(yyruleno==370);\n-      \/* (371) foreach_clause ::= FOR EACH ROW *\/ yytestcase(yyruleno==371);\n-      \/* (372) trnm ::= nm *\/ yytestcase(yyruleno==372);\n-      \/* (373) tridxby ::= *\/ yytestcase(yyruleno==373);\n-      \/* (374) database_kw_opt ::= DATABASE *\/ yytestcase(yyruleno==374);\n-      \/* (375) database_kw_opt ::= *\/ yytestcase(yyruleno==375);\n-      \/* (376) kwcolumn_opt ::= *\/ yytestcase(yyruleno==376);\n-      \/* (377) kwcolumn_opt ::= COLUMNKW *\/ yytestcase(yyruleno==377);\n-      \/* (378) vtabarglist ::= vtabarg *\/ yytestcase(yyruleno==378);\n-      \/* (379) vtabarglist ::= vtabarglist COMMA vtabarg *\/ yytestcase(yyruleno==379);\n-      \/* (380) vtabarg ::= vtabarg vtabargtoken *\/ yytestcase(yyruleno==380);\n-      \/* (381) anylist ::= *\/ yytestcase(yyruleno==381);\n-      \/* (382) anylist ::= anylist LP anylist RP *\/ yytestcase(yyruleno==382);\n-      \/* (383) anylist ::= anylist ANY *\/ yytestcase(yyruleno==383);\n-      \/* (384) with ::= *\/ yytestcase(yyruleno==384);\n+      \/* (339) input ::= cmdlist *\/ yytestcase(yyruleno==339);\n+      \/* (340) cmdlist ::= cmdlist ecmd *\/ yytestcase(yyruleno==340);\n+      \/* (341) cmdlist ::= ecmd (OPTIMIZED OUT) *\/ assert(yyruleno!=341);\n+      \/* (342) ecmd ::= SEMI *\/ yytestcase(yyruleno==342);\n+      \/* (343) ecmd ::= cmdx SEMI *\/ yytestcase(yyruleno==343);\n+      \/* (344) ecmd ::= explain cmdx SEMI (NEVER REDUCES) *\/ assert(yyruleno!=344);\n+      \/* (345) trans_opt ::= *\/ yytestcase(yyruleno==345);\n+      \/* (346) trans_opt ::= TRANSACTION *\/ yytestcase(yyruleno==346);\n+      \/* (347) trans_opt ::= TRANSACTION nm *\/ yytestcase(yyruleno==347);\n+      \/* (348) savepoint_opt ::= SAVEPOINT *\/ yytestcase(yyruleno==348);\n+      \/* (349) savepoint_opt ::= *\/ yytestcase(yyruleno==349);\n+      \/* (350) cmd ::= create_table create_table_args *\/ yytestcase(yyruleno==350);\n+      \/* (351) table_option_set ::= table_option (OPTIMIZED OUT) *\/ assert(yyruleno!=351);\n+      \/* (352) columnlist ::= columnlist COMMA columnname carglist *\/ yytestcase(yyruleno==352);\n+      \/* (353) columnlist ::= columnname carglist *\/ yytestcase(yyruleno==353);\n+      \/* (354) nm ::= ID|INDEXED *\/ yytestcase(yyruleno==354);\n+      \/* (355) nm ::= STRING *\/ yytestcase(yyruleno==355);\n+      \/* (356) nm ::= JOIN_KW *\/ yytestcase(yyruleno==356);\n+      \/* (357) typetoken ::= typename *\/ yytestcase(yyruleno==357);\n+      \/* (358) typename ::= ID|STRING *\/ yytestcase(yyruleno==358);\n+      \/* (359) signed ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=359);\n+      \/* (360) signed ::= minus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=360);\n+      \/* (361) carglist ::= carglist ccons *\/ yytestcase(yyruleno==361);\n+      \/* (362) carglist ::= *\/ yytestcase(yyruleno==362);\n+      \/* (363) ccons ::= NULL onconf *\/ yytestcase(yyruleno==363);\n+      \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/ yytestcase(yyruleno==364);\n+      \/* (365) ccons ::= AS generated *\/ yytestcase(yyruleno==365);\n+      \/* (366) conslist_opt ::= COMMA conslist *\/ yytestcase(yyruleno==366);\n+      \/* (367) conslist ::= conslist tconscomma tcons *\/ yytestcase(yyruleno==367);\n+      \/* (368) conslist ::= tcons (OPTIMIZED OUT) *\/ assert(yyruleno!=368);\n+      \/* (369) tconscomma ::= *\/ yytestcase(yyruleno==369);\n+      \/* (370) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) *\/ assert(yyruleno!=370);\n+      \/* (371) resolvetype ::= raisetype (OPTIMIZED OUT) *\/ assert(yyruleno!=371);\n+      \/* (372) selectnowith ::= oneselect (OPTIMIZED OUT) *\/ assert(yyruleno!=372);\n+      \/* (373) oneselect ::= values *\/ yytestcase(yyruleno==373);\n+      \/* (374) sclp ::= selcollist COMMA *\/ yytestcase(yyruleno==374);\n+      \/* (375) as ::= ID|STRING *\/ yytestcase(yyruleno==375);\n+      \/* (376) returning ::= *\/ yytestcase(yyruleno==376);\n+      \/* (377) expr ::= term (OPTIMIZED OUT) *\/ assert(yyruleno!=377);\n+      \/* (378) likeop ::= LIKE_KW|MATCH *\/ yytestcase(yyruleno==378);\n+      \/* (379) exprlist ::= nexprlist *\/ yytestcase(yyruleno==379);\n+      \/* (380) nmnum ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=380);\n+      \/* (381) nmnum ::= nm (OPTIMIZED OUT) *\/ assert(yyruleno!=381);\n+      \/* (382) nmnum ::= ON *\/ yytestcase(yyruleno==382);\n+      \/* (383) nmnum ::= DELETE *\/ yytestcase(yyruleno==383);\n+      \/* (384) nmnum ::= DEFAULT *\/ yytestcase(yyruleno==384);\n+      \/* (385) plus_num ::= INTEGER|FLOAT *\/ yytestcase(yyruleno==385);\n+      \/* (386) foreach_clause ::= *\/ yytestcase(yyruleno==386);\n+      \/* (387) foreach_clause ::= FOR EACH ROW *\/ yytestcase(yyruleno==387);\n+      \/* (388) trnm ::= nm *\/ yytestcase(yyruleno==388);\n+      \/* (389) tridxby ::= *\/ yytestcase(yyruleno==389);\n+      \/* (390) database_kw_opt ::= DATABASE *\/ yytestcase(yyruleno==390);\n+      \/* (391) database_kw_opt ::= *\/ yytestcase(yyruleno==391);\n+      \/* (392) kwcolumn_opt ::= *\/ yytestcase(yyruleno==392);\n+      \/* (393) kwcolumn_opt ::= COLUMNKW *\/ yytestcase(yyruleno==393);\n+      \/* (394) vtabarglist ::= vtabarg *\/ yytestcase(yyruleno==394);\n+      \/* (395) vtabarglist ::= vtabarglist COMMA vtabarg *\/ yytestcase(yyruleno==395);\n+      \/* (396) vtabarg ::= vtabarg vtabargtoken *\/ yytestcase(yyruleno==396);\n+      \/* (397) anylist ::= *\/ yytestcase(yyruleno==397);\n+      \/* (398) anylist ::= anylist LP anylist RP *\/ yytestcase(yyruleno==398);\n+      \/* (399) anylist ::= anylist ANY *\/ yytestcase(yyruleno==399);\n+      \/* (400) with ::= *\/ yytestcase(yyruleno==400);\n@@ -158449,1 +164655,2 @@\n-  do{\n+  while(1){ \/* Exit by \"break\" *\/\n+    assert( yypParser->yytos>=yypParser->yystack );\n@@ -158453,2 +164660,45 @@\n-      yyact = yy_reduce(yypParser,yyact-YY_MIN_REDUCE,yymajor,\n-                        yyminor sqlite3ParserCTX_PARAM);\n+      unsigned int yyruleno = yyact - YY_MIN_REDUCE; \/* Reduce by this rule *\/\n+#ifndef NDEBUG\n+      assert( yyruleno<(int)(sizeof(yyRuleName)\/sizeof(yyRuleName[0])) );\n+      if( yyTraceFILE ){\n+        int yysize = yyRuleInfoNRhs[yyruleno];\n+        if( yysize ){\n+          fprintf(yyTraceFILE, \"%sReduce %d [%s]%s, pop back to state %d.\\n\",\n+            yyTracePrompt,\n+            yyruleno, yyRuleName[yyruleno],\n+            yyruleno<YYNRULE_WITH_ACTION ? \"\" : \" without external action\",\n+            yypParser->yytos[yysize].stateno);\n+        }else{\n+          fprintf(yyTraceFILE, \"%sReduce %d [%s]%s.\\n\",\n+            yyTracePrompt, yyruleno, yyRuleName[yyruleno],\n+            yyruleno<YYNRULE_WITH_ACTION ? \"\" : \" without external action\");\n+        }\n+      }\n+#endif \/* NDEBUG *\/\n+\n+      \/* Check that the stack is large enough to grow by a single entry\n+      ** if the RHS of the rule is empty.  This ensures that there is room\n+      ** enough on the stack to push the LHS value *\/\n+      if( yyRuleInfoNRhs[yyruleno]==0 ){\n+#ifdef YYTRACKMAXSTACKDEPTH\n+        if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){\n+          yypParser->yyhwm++;\n+          assert( yypParser->yyhwm ==\n+                  (int)(yypParser->yytos - yypParser->yystack));\n+        }\n+#endif\n+#if YYSTACKDEPTH>0\n+        if( yypParser->yytos>=yypParser->yystackEnd ){\n+          yyStackOverflow(yypParser);\n+          break;\n+        }\n+#else\n+        if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz-1] ){\n+          if( yyGrowStack(yypParser) ){\n+            yyStackOverflow(yypParser);\n+            break;\n+          }\n+        }\n+#endif\n+      }\n+      yyact = yy_reduce(yypParser,yyruleno,yymajor,yyminor sqlite3ParserCTX_PARAM);\n@@ -158510,5 +164760,4 @@\n-        while( yypParser->yytos >= yypParser->yystack\n-            && (yyact = yy_find_reduce_action(\n-                        yypParser->yytos->stateno,\n-                        YYERRORSYMBOL)) > YY_MAX_SHIFTREDUCE\n-        ){\n+        while( yypParser->yytos > yypParser->yystack ){\n+          yyact = yy_find_reduce_action(yypParser->yytos->stateno,\n+                                        YYERRORSYMBOL);\n+          if( yyact<=YY_MAX_SHIFTREDUCE ) break;\n@@ -158517,1 +164766,1 @@\n-        if( yypParser->yytos < yypParser->yystack || yymajor==0 ){\n+        if( yypParser->yytos <= yypParser->yystack || yymajor==0 ){\n@@ -158567,1 +164816,1 @@\n-  }while( yypParser->yytos>yypParser->yystack );\n+  }\n@@ -158628,2 +164877,2 @@\n-#define CC_KYWD       1    \/* Alphabetics or '_'.  Usable in a keyword *\/\n-#define CC_ID         2    \/* unicode characters usable in IDs *\/\n+#define CC_KYWD0      1    \/* First letter of a keyword *\/\n+#define CC_KYWD       2    \/* Alphabetics or '_'.  Usable in a keyword *\/\n@@ -158654,2 +164903,4 @@\n-#define CC_ILLEGAL   27    \/* Illegal character *\/\n-#define CC_NUL       28    \/* 0x00 *\/\n+#define CC_ID        27    \/* unicode characters usable in IDs *\/\n+#define CC_ILLEGAL   28    \/* Illegal character *\/\n+#define CC_NUL       29    \/* 0x00 *\/\n+#define CC_BOM       30    \/* First byte of UTF8 BOM:  0xEF 0xBB 0xBF *\/\n@@ -158660,2 +164911,2 @@\n-\/* 0x *\/   28, 27, 27, 27, 27, 27, 27, 27, 27,  7,  7, 27,  7,  7, 27, 27,\n-\/* 1x *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+\/* 0x *\/   29, 28, 28, 28, 28, 28, 28, 28, 28,  7,  7, 28,  7,  7, 28, 28,\n+\/* 1x *\/   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n@@ -158665,1 +164916,1 @@\n-\/* 5x *\/    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  9, 27, 27, 27,  1,\n+\/* 5x *\/    1,  1,  1,  1,  1,  1,  1,  1,  0,  2,  2,  9, 28, 28, 28,  2,\n@@ -158667,9 +164918,9 @@\n-\/* 7x *\/    1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1, 27, 10, 27, 25, 27,\n-\/* 8x *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-\/* 9x *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-\/* Ax *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-\/* Bx *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-\/* Cx *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-\/* Dx *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-\/* Ex *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-\/* Fx *\/    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2\n+\/* 7x *\/    1,  1,  1,  1,  1,  1,  1,  1,  0,  2,  2, 28, 10, 28, 25, 28,\n+\/* 8x *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+\/* 9x *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+\/* Ax *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+\/* Bx *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+\/* Cx *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+\/* Dx *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+\/* Ex *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 30,\n+\/* Fx *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27\n@@ -158679,16 +164930,16 @@\n-\/* 0x *\/   27, 27, 27, 27, 27,  7, 27, 27, 27, 27, 27, 27,  7,  7, 27, 27,\n-\/* 1x *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n-\/* 2x *\/   27, 27, 27, 27, 27,  7, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n-\/* 3x *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n-\/* 4x *\/    7, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 26, 12, 17, 20, 10,\n-\/* 5x *\/   24, 27, 27, 27, 27, 27, 27, 27, 27, 27, 15,  4, 21, 18, 19, 27,\n-\/* 6x *\/   11, 16, 27, 27, 27, 27, 27, 27, 27, 27, 27, 23, 22,  1, 13,  6,\n-\/* 7x *\/   27, 27, 27, 27, 27, 27, 27, 27, 27,  8,  5,  5,  5,  8, 14,  8,\n-\/* 8x *\/   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,\n-\/* 9x *\/   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,\n-\/* Ax *\/   27, 25,  1,  1,  1,  1,  1,  0,  1,  1, 27, 27, 27, 27, 27, 27,\n-\/* Bx *\/   27, 27, 27, 27, 27, 27, 27, 27, 27, 27,  9, 27, 27, 27, 27, 27,\n-\/* Cx *\/   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,\n-\/* Dx *\/   27,  1,  1,  1,  1,  1,  1,  1,  1,  1, 27, 27, 27, 27, 27, 27,\n-\/* Ex *\/   27, 27,  1,  1,  1,  1,  1,  0,  1,  1, 27, 27, 27, 27, 27, 27,\n-\/* Fx *\/    3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 27, 27, 27, 27, 27, 27,\n+\/* 0x *\/   29, 28, 28, 28, 28,  7, 28, 28, 28, 28, 28, 28,  7,  7, 28, 28,\n+\/* 1x *\/   28, 28, 28, 28, 28,  7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+\/* 2x *\/   28, 28, 28, 28, 28,  7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+\/* 3x *\/   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+\/* 4x *\/    7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 26, 12, 17, 20, 10,\n+\/* 5x *\/   24, 28, 28, 28, 28, 28, 28, 28, 28, 28, 15,  4, 21, 18, 19, 28,\n+\/* 6x *\/   11, 16, 28, 28, 28, 28, 28, 28, 28, 28, 28, 23, 22,  2, 13,  6,\n+\/* 7x *\/   28, 28, 28, 28, 28, 28, 28, 28, 28,  8,  5,  5,  5,  8, 14,  8,\n+\/* 8x *\/   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,\n+\/* 9x *\/   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,\n+\/* Ax *\/   28, 25,  1,  1,  1,  1,  1,  0,  2,  2, 28, 28, 28, 28, 28, 28,\n+\/* Bx *\/   28, 28, 28, 28, 28, 28, 28, 28, 28, 28,  9, 28, 28, 28, 28, 28,\n+\/* Cx *\/   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,\n+\/* Dx *\/   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,\n+\/* Ex *\/   28, 28,  1,  1,  1,  1,  1,  0,  2,  2, 28, 28, 28, 28, 28, 28,\n+\/* Fx *\/    3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 28, 28, 28, 28, 28, 28,\n@@ -158759,2 +165010,2 @@\n-\/* Hash score: 227 *\/\n-\/* zKWText[] encodes 984 bytes of keyword text in 648 bytes *\/\n+\/* Hash score: 231 *\/\n+\/* zKWText[] encodes 1007 bytes of keyword text in 667 bytes *\/\n@@ -158767,6 +165018,7 @@\n-\/*   PRAGMABORTUPDATEVALUESVIRTUALWAYSWHENWHERECURSIVEAFTERENAMEAND     *\/\n-\/*   EFERREDISTINCTAUTOINCREMENTCASTCOLUMNCOMMITCONFLICTCROSS           *\/\n-\/*   CURRENT_TIMESTAMPARTITIONDROPRECEDINGFAILASTFILTEREPLACEFIRST      *\/\n-\/*   FOLLOWINGFROMFULLIMITIFORDERESTRICTOTHERSOVERIGHTROLLBACKROWS      *\/\n-\/*   UNBOUNDEDUNIONUSINGVACUUMVIEWINDOWBYINITIALLYPRIMARY               *\/\n-static const char zKWText[647] = {\n+\/*   PRAGMATERIALIZEDEFERREDISTINCTUPDATEVALUESVIRTUALWAYSWHENWHERE     *\/\n+\/*   CURSIVEABORTAFTERENAMEANDROPARTITIONAUTOINCREMENTCASTCOLUMN        *\/\n+\/*   COMMITCONFLICTCROSSCURRENT_TIMESTAMPRECEDINGFAILASTFILTER          *\/\n+\/*   EPLACEFIRSTFOLLOWINGFROMFULLIMITIFORDERESTRICTOTHERSOVER           *\/\n+\/*   ETURNINGRIGHTROLLBACKROWSUNBOUNDEDUNIONUSINGVACUUMVIEWINDOWBY      *\/\n+\/*   INITIALLYPRIMARY                                                   *\/\n+static const char zKWText[666] = {\n@@ -158793,16 +165045,17 @@\n-  'A','B','O','R','T','U','P','D','A','T','E','V','A','L','U','E','S','V',\n-  'I','R','T','U','A','L','W','A','Y','S','W','H','E','N','W','H','E','R',\n-  'E','C','U','R','S','I','V','E','A','F','T','E','R','E','N','A','M','E',\n-  'A','N','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','A',\n-  'U','T','O','I','N','C','R','E','M','E','N','T','C','A','S','T','C','O',\n-  'L','U','M','N','C','O','M','M','I','T','C','O','N','F','L','I','C','T',\n-  'C','R','O','S','S','C','U','R','R','E','N','T','_','T','I','M','E','S',\n-  'T','A','M','P','A','R','T','I','T','I','O','N','D','R','O','P','R','E',\n-  'C','E','D','I','N','G','F','A','I','L','A','S','T','F','I','L','T','E',\n-  'R','E','P','L','A','C','E','F','I','R','S','T','F','O','L','L','O','W',\n-  'I','N','G','F','R','O','M','F','U','L','L','I','M','I','T','I','F','O',\n-  'R','D','E','R','E','S','T','R','I','C','T','O','T','H','E','R','S','O',\n-  'V','E','R','I','G','H','T','R','O','L','L','B','A','C','K','R','O','W',\n-  'S','U','N','B','O','U','N','D','E','D','U','N','I','O','N','U','S','I',\n-  'N','G','V','A','C','U','U','M','V','I','E','W','I','N','D','O','W','B',\n-  'Y','I','N','I','T','I','A','L','L','Y','P','R','I','M','A','R','Y',\n+  'A','T','E','R','I','A','L','I','Z','E','D','E','F','E','R','R','E','D',\n+  'I','S','T','I','N','C','T','U','P','D','A','T','E','V','A','L','U','E',\n+  'S','V','I','R','T','U','A','L','W','A','Y','S','W','H','E','N','W','H',\n+  'E','R','E','C','U','R','S','I','V','E','A','B','O','R','T','A','F','T',\n+  'E','R','E','N','A','M','E','A','N','D','R','O','P','A','R','T','I','T',\n+  'I','O','N','A','U','T','O','I','N','C','R','E','M','E','N','T','C','A',\n+  'S','T','C','O','L','U','M','N','C','O','M','M','I','T','C','O','N','F',\n+  'L','I','C','T','C','R','O','S','S','C','U','R','R','E','N','T','_','T',\n+  'I','M','E','S','T','A','M','P','R','E','C','E','D','I','N','G','F','A',\n+  'I','L','A','S','T','F','I','L','T','E','R','E','P','L','A','C','E','F',\n+  'I','R','S','T','F','O','L','L','O','W','I','N','G','F','R','O','M','F',\n+  'U','L','L','I','M','I','T','I','F','O','R','D','E','R','E','S','T','R',\n+  'I','C','T','O','T','H','E','R','S','O','V','E','R','E','T','U','R','N',\n+  'I','N','G','R','I','G','H','T','R','O','L','L','B','A','C','K','R','O',\n+  'W','S','U','N','B','O','U','N','D','E','D','U','N','I','O','N','U','S',\n+  'I','N','G','V','A','C','U','U','M','V','I','E','W','I','N','D','O','W',\n+  'B','Y','I','N','I','T','I','A','L','L','Y','P','R','I','M','A','R','Y',\n@@ -158812,10 +165065,10 @@\n-    84, 102, 132,  82, 114,  29,   0,   0,  91,   0,  85,  72,   0,\n-    53,  35,  86,  15,   0,  42,  94,  54, 126, 133,  19,   0,   0,\n-   138,   0,  40, 128,   0,  22, 104,   0,   9,   0,   0, 122,  80,\n-     0,  78,   6,   0,  65,  99, 145,   0, 134, 112,   0,   0,  48,\n-     0, 100,  24,   0,  17,   0,  27,  70,  23,  26,   5,  60, 140,\n-   107, 121,   0,  73, 101,  71, 143,  61, 119,  74,   0,  49,   0,\n-    11,  41,   0, 110,   0,   0,   0, 106,  10, 108, 113, 124,  14,\n-    50, 123,   0,  89,   0,  18, 120, 142,  56, 129, 137,  88,  83,\n-    37,  30, 125,   0,   0, 105,  51, 130, 127,   0,  34,   0,   0,\n-    44,   0,  95,  38,  39,   0,  20,  45, 116,  90,\n+    84,  92, 134,  82, 105,  29,   0,   0,  94,   0,  85,  72,   0,\n+    53,  35,  86,  15,   0,  42,  97,  54,  89, 135,  19,   0,   0,\n+   140,   0,  40, 129,   0,  22, 107,   0,   9,   0,   0, 123,  80,\n+     0,  78,   6,   0,  65, 103, 147,   0, 136, 115,   0,   0,  48,\n+     0,  90,  24,   0,  17,   0,  27,  70,  23,  26,   5,  60, 142,\n+   110, 122,   0,  73,  91,  71, 145,  61, 120,  74,   0,  49,   0,\n+    11,  41,   0, 113,   0,   0,   0, 109,  10, 111, 116, 125,  14,\n+    50, 124,   0, 100,   0,  18, 121, 144,  56, 130, 139,  88,  83,\n+    37,  30, 126,   0,   0, 108,  51, 131, 128,   0,  34,   0,   0,\n+   132,   0,  98,  38,  39,   0,  20,  45, 117,  93,\n@@ -158826,5 +165079,5 @@\n-static const unsigned char aKWNext[145] = {\n-     0,   0,   0,   0,   4,   0,  43,   0,   0, 103, 111,   0,   0,\n-     0,   2,   0,   0, 141,   0,   0,   0,  13,   0,   0,   0,   0,\n-   139,   0,   0, 118,  52,   0,   0, 135,  12,   0,   0,  62,   0,\n-   136,   0, 131,   0,   0,  36,   0,   0,  28,  77,   0,   0,   0,\n+static const unsigned char aKWNext[147] = {\n+     0,   0,   0,   0,   4,   0,  43,   0,   0, 106, 114,   0,   0,\n+     0,   2,   0,   0, 143,   0,   0,   0,  13,   0,   0,   0,   0,\n+   141,   0,   0, 119,  52,   0,   0, 137,  12,   0,   0,  62,   0,\n+   138,   0, 133,   0,   0,  36,   0,   0,  28,  77,   0,   0,   0,\n@@ -158832,7 +165085,7 @@\n-     0,  69,   0,   0,   0,   0,   0, 144,   3,   0,  58,   0,   1,\n-    75,   0,   0,   0,  31,   0,   0,   0,   0,   0,   0,  64,  66,\n-    63,   0,   0,   0,   0,  46,   0,  16,   0, 115,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,  81,  97,   0,   8,   0, 109,\n-    21,   7,  67,   0,  79,  93, 117,   0,   0,  68,   0,   0,  96,\n-     0,  55,   0,  76,   0,  92,  32,  33,  57,  25,   0,  98,   0,\n-     0,  87,\n+     0,  69,   0,   0,   0,   0,   0, 146,   3,   0,  58,   0,   1,\n+    75,   0,   0,   0,  31,   0,   0,   0,   0,   0, 127,   0, 104,\n+     0,  64,  66,  63,   0,   0,   0,   0,   0,  46,   0,  16,   8,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  81, 101,   0,\n+   112,  21,   7,  67,   0,  79,  96, 118,   0,   0,  68,   0,   0,\n+    99,  44,   0,  55,   0,  76,   0,  95,  32,  33,  57,  25,   0,\n+   102,   0,   0,  87,\n@@ -158841,1 +165094,1 @@\n-static const unsigned char aKWLen[145] = {\n+static const unsigned char aKWLen[147] = {\n@@ -158848,6 +165101,6 @@\n-     7,   6,  12,   9,   4,   6,   5,   4,   7,   6,   5,   6,   6,\n-     7,   6,   4,   5,   9,   5,   6,   3,   8,   8,   2,  13,   2,\n-     2,   4,   6,   6,   8,   5,  17,  12,   7,   9,   4,   9,   4,\n-     4,   6,   7,   5,   9,   4,   4,   5,   2,   5,   8,   6,   4,\n-     5,   8,   4,   3,   9,   5,   5,   6,   4,   6,   2,   2,   9,\n-     3,   7,\n+     7,   6,  12,   9,   4,   6,   5,   4,   7,   6,  12,   8,   8,\n+     2,   6,   6,   7,   6,   4,   5,   9,   5,   5,   6,   3,   4,\n+     9,  13,   2,   2,   4,   6,   6,   8,   5,  17,  12,   7,   9,\n+     4,   4,   6,   7,   5,   9,   4,   4,   5,   2,   5,   8,   6,\n+     4,   9,   5,   8,   4,   3,   9,   5,   5,   6,   4,   6,   2,\n+     2,   9,   3,   7,\n@@ -158857,1 +165110,1 @@\n-static const unsigned short int aKWOffset[145] = {\n+static const unsigned short int aKWOffset[147] = {\n@@ -158864,6 +165117,6 @@\n-   299, 306, 312, 324, 333, 335, 341, 346, 348, 355, 360, 365, 371,\n-   377, 382, 388, 392, 395, 404, 408, 414, 416, 423, 424, 431, 433,\n-   435, 444, 448, 454, 460, 468, 473, 473, 473, 489, 498, 501, 510,\n-   513, 517, 522, 529, 534, 543, 547, 550, 555, 557, 561, 569, 575,\n-   578, 583, 591, 591, 595, 604, 609, 614, 620, 623, 626, 629, 631,\n-   636, 640,\n+   299, 306, 312, 324, 333, 335, 341, 346, 348, 355, 359, 370, 377,\n+   378, 385, 391, 397, 402, 408, 412, 415, 424, 429, 433, 439, 441,\n+   444, 453, 455, 457, 466, 470, 476, 482, 490, 495, 495, 495, 511,\n+   520, 523, 527, 532, 539, 544, 553, 557, 560, 565, 567, 571, 579,\n+   585, 588, 597, 602, 610, 610, 614, 623, 628, 633, 639, 642, 645,\n+   648, 650, 655, 659,\n@@ -158872,1 +165125,1 @@\n-static const unsigned char aKWCode[145] = {\n+static const unsigned char aKWCode[147] = {\n@@ -158890,12 +165143,13 @@\n-  TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,     TK_ABORT,      TK_UPDATE,\n-  TK_VALUES,     TK_VIRTUAL,    TK_ALWAYS,     TK_WHEN,       TK_WHERE,\n-  TK_RECURSIVE,  TK_AFTER,      TK_RENAME,     TK_AND,        TK_DEFERRED,\n-  TK_DISTINCT,   TK_IS,         TK_AUTOINCR,   TK_TO,         TK_IN,\n-  TK_CAST,       TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,\n-  TK_CTIME_KW,   TK_CTIME_KW,   TK_CURRENT,    TK_PARTITION,  TK_DROP,\n-  TK_PRECEDING,  TK_FAIL,       TK_LAST,       TK_FILTER,     TK_REPLACE,\n-  TK_FIRST,      TK_FOLLOWING,  TK_FROM,       TK_JOIN_KW,    TK_LIMIT,\n-  TK_IF,         TK_ORDER,      TK_RESTRICT,   TK_OTHERS,     TK_OVER,\n-  TK_JOIN_KW,    TK_ROLLBACK,   TK_ROWS,       TK_ROW,        TK_UNBOUNDED,\n-  TK_UNION,      TK_USING,      TK_VACUUM,     TK_VIEW,       TK_WINDOW,\n-  TK_DO,         TK_BY,         TK_INITIALLY,  TK_ALL,        TK_PRIMARY,\n+  TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,     TK_MATERIALIZED, TK_DEFERRED,\n+  TK_DISTINCT,   TK_IS,         TK_UPDATE,     TK_VALUES,     TK_VIRTUAL,\n+  TK_ALWAYS,     TK_WHEN,       TK_WHERE,      TK_RECURSIVE,  TK_ABORT,\n+  TK_AFTER,      TK_RENAME,     TK_AND,        TK_DROP,       TK_PARTITION,\n+  TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,       TK_COLUMNKW,\n+  TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,   TK_CTIME_KW,\n+  TK_CURRENT,    TK_PRECEDING,  TK_FAIL,       TK_LAST,       TK_FILTER,\n+  TK_REPLACE,    TK_FIRST,      TK_FOLLOWING,  TK_FROM,       TK_JOIN_KW,\n+  TK_LIMIT,      TK_IF,         TK_ORDER,      TK_RESTRICT,   TK_OTHERS,\n+  TK_OVER,       TK_RETURNING,  TK_JOIN_KW,    TK_ROLLBACK,   TK_ROWS,\n+  TK_ROW,        TK_UNBOUNDED,  TK_UNION,      TK_USING,      TK_VACUUM,\n+  TK_VIEW,       TK_WINDOW,     TK_DO,         TK_BY,         TK_INITIALLY,\n+  TK_ALL,        TK_PRIMARY,\n@@ -158925,1 +165179,1 @@\n-**  21: IF\n+**  21: MATERIALIZED IF\n@@ -159021,1 +165275,1 @@\n-** 117: ON\n+** 117: RETURNING ON\n@@ -159039,1 +165293,1 @@\n-    i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127;\n+    i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n*1) % 127;\n@@ -159144,57 +165398,59 @@\n-      testcase( i==88 ); \/* ABORT *\/\n-      testcase( i==89 ); \/* UPDATE *\/\n-      testcase( i==90 ); \/* VALUES *\/\n-      testcase( i==91 ); \/* VIRTUAL *\/\n-      testcase( i==92 ); \/* ALWAYS *\/\n-      testcase( i==93 ); \/* WHEN *\/\n-      testcase( i==94 ); \/* WHERE *\/\n-      testcase( i==95 ); \/* RECURSIVE *\/\n-      testcase( i==96 ); \/* AFTER *\/\n-      testcase( i==97 ); \/* RENAME *\/\n-      testcase( i==98 ); \/* AND *\/\n-      testcase( i==99 ); \/* DEFERRED *\/\n-      testcase( i==100 ); \/* DISTINCT *\/\n-      testcase( i==101 ); \/* IS *\/\n-      testcase( i==102 ); \/* AUTOINCREMENT *\/\n-      testcase( i==103 ); \/* TO *\/\n-      testcase( i==104 ); \/* IN *\/\n-      testcase( i==105 ); \/* CAST *\/\n-      testcase( i==106 ); \/* COLUMN *\/\n-      testcase( i==107 ); \/* COMMIT *\/\n-      testcase( i==108 ); \/* CONFLICT *\/\n-      testcase( i==109 ); \/* CROSS *\/\n-      testcase( i==110 ); \/* CURRENT_TIMESTAMP *\/\n-      testcase( i==111 ); \/* CURRENT_TIME *\/\n-      testcase( i==112 ); \/* CURRENT *\/\n-      testcase( i==113 ); \/* PARTITION *\/\n-      testcase( i==114 ); \/* DROP *\/\n-      testcase( i==115 ); \/* PRECEDING *\/\n-      testcase( i==116 ); \/* FAIL *\/\n-      testcase( i==117 ); \/* LAST *\/\n-      testcase( i==118 ); \/* FILTER *\/\n-      testcase( i==119 ); \/* REPLACE *\/\n-      testcase( i==120 ); \/* FIRST *\/\n-      testcase( i==121 ); \/* FOLLOWING *\/\n-      testcase( i==122 ); \/* FROM *\/\n-      testcase( i==123 ); \/* FULL *\/\n-      testcase( i==124 ); \/* LIMIT *\/\n-      testcase( i==125 ); \/* IF *\/\n-      testcase( i==126 ); \/* ORDER *\/\n-      testcase( i==127 ); \/* RESTRICT *\/\n-      testcase( i==128 ); \/* OTHERS *\/\n-      testcase( i==129 ); \/* OVER *\/\n-      testcase( i==130 ); \/* RIGHT *\/\n-      testcase( i==131 ); \/* ROLLBACK *\/\n-      testcase( i==132 ); \/* ROWS *\/\n-      testcase( i==133 ); \/* ROW *\/\n-      testcase( i==134 ); \/* UNBOUNDED *\/\n-      testcase( i==135 ); \/* UNION *\/\n-      testcase( i==136 ); \/* USING *\/\n-      testcase( i==137 ); \/* VACUUM *\/\n-      testcase( i==138 ); \/* VIEW *\/\n-      testcase( i==139 ); \/* WINDOW *\/\n-      testcase( i==140 ); \/* DO *\/\n-      testcase( i==141 ); \/* BY *\/\n-      testcase( i==142 ); \/* INITIALLY *\/\n-      testcase( i==143 ); \/* ALL *\/\n-      testcase( i==144 ); \/* PRIMARY *\/\n+      testcase( i==88 ); \/* MATERIALIZED *\/\n+      testcase( i==89 ); \/* DEFERRED *\/\n+      testcase( i==90 ); \/* DISTINCT *\/\n+      testcase( i==91 ); \/* IS *\/\n+      testcase( i==92 ); \/* UPDATE *\/\n+      testcase( i==93 ); \/* VALUES *\/\n+      testcase( i==94 ); \/* VIRTUAL *\/\n+      testcase( i==95 ); \/* ALWAYS *\/\n+      testcase( i==96 ); \/* WHEN *\/\n+      testcase( i==97 ); \/* WHERE *\/\n+      testcase( i==98 ); \/* RECURSIVE *\/\n+      testcase( i==99 ); \/* ABORT *\/\n+      testcase( i==100 ); \/* AFTER *\/\n+      testcase( i==101 ); \/* RENAME *\/\n+      testcase( i==102 ); \/* AND *\/\n+      testcase( i==103 ); \/* DROP *\/\n+      testcase( i==104 ); \/* PARTITION *\/\n+      testcase( i==105 ); \/* AUTOINCREMENT *\/\n+      testcase( i==106 ); \/* TO *\/\n+      testcase( i==107 ); \/* IN *\/\n+      testcase( i==108 ); \/* CAST *\/\n+      testcase( i==109 ); \/* COLUMN *\/\n+      testcase( i==110 ); \/* COMMIT *\/\n+      testcase( i==111 ); \/* CONFLICT *\/\n+      testcase( i==112 ); \/* CROSS *\/\n+      testcase( i==113 ); \/* CURRENT_TIMESTAMP *\/\n+      testcase( i==114 ); \/* CURRENT_TIME *\/\n+      testcase( i==115 ); \/* CURRENT *\/\n+      testcase( i==116 ); \/* PRECEDING *\/\n+      testcase( i==117 ); \/* FAIL *\/\n+      testcase( i==118 ); \/* LAST *\/\n+      testcase( i==119 ); \/* FILTER *\/\n+      testcase( i==120 ); \/* REPLACE *\/\n+      testcase( i==121 ); \/* FIRST *\/\n+      testcase( i==122 ); \/* FOLLOWING *\/\n+      testcase( i==123 ); \/* FROM *\/\n+      testcase( i==124 ); \/* FULL *\/\n+      testcase( i==125 ); \/* LIMIT *\/\n+      testcase( i==126 ); \/* IF *\/\n+      testcase( i==127 ); \/* ORDER *\/\n+      testcase( i==128 ); \/* RESTRICT *\/\n+      testcase( i==129 ); \/* OTHERS *\/\n+      testcase( i==130 ); \/* OVER *\/\n+      testcase( i==131 ); \/* RETURNING *\/\n+      testcase( i==132 ); \/* RIGHT *\/\n+      testcase( i==133 ); \/* ROLLBACK *\/\n+      testcase( i==134 ); \/* ROWS *\/\n+      testcase( i==135 ); \/* ROW *\/\n+      testcase( i==136 ); \/* UNBOUNDED *\/\n+      testcase( i==137 ); \/* UNION *\/\n+      testcase( i==138 ); \/* USING *\/\n+      testcase( i==139 ); \/* VACUUM *\/\n+      testcase( i==140 ); \/* VIEW *\/\n+      testcase( i==141 ); \/* WINDOW *\/\n+      testcase( i==142 ); \/* DO *\/\n+      testcase( i==143 ); \/* BY *\/\n+      testcase( i==144 ); \/* INITIALLY *\/\n+      testcase( i==145 ); \/* ALL *\/\n+      testcase( i==146 ); \/* PRIMARY *\/\n@@ -159212,1 +165468,1 @@\n-#define SQLITE_N_KEYWORD 145\n+#define SQLITE_N_KEYWORD 147\n@@ -159504,0 +165760,1 @@\n+      \/* no break *\/ deliberate_fall_through\n@@ -159580,1 +165837,1 @@\n-    case CC_KYWD: {\n+    case CC_KYWD0: {\n@@ -159608,0 +165865,1 @@\n+      \/* no break *\/ deliberate_fall_through\n@@ -159609,0 +165867,1 @@\n+    case CC_KYWD:\n@@ -159613,0 +165872,8 @@\n+    case CC_BOM: {\n+      if( z[1]==0xbb && z[2]==0xbf ){\n+        *tokenType = TK_SPACE;\n+        return 3;\n+      }\n+      i = 1;\n+      break;\n+    }\n@@ -159642,0 +165909,1 @@\n+  Parse *pParentParse = 0;        \/* Outer parse context, if any *\/\n@@ -159677,1 +165945,1 @@\n-  pParse->pParentParse = db->pParse;\n+  pParentParse = db->pParse;\n@@ -159791,2 +166059,0 @@\n-\n-  if( pParse->pWithToFree ) sqlite3WithDelete(db, pParse->pWithToFree);\n@@ -159794,12 +166060,1 @@\n-  while( pParse->pAinc ){\n-    AutoincInfo *p = pParse->pAinc;\n-    pParse->pAinc = p->pNext;\n-    sqlite3DbFreeNN(db, p);\n-  }\n-  while( pParse->pZombieTab ){\n-    Table *p = pParse->pZombieTab;\n-    pParse->pZombieTab = p->pNextZombie;\n-    sqlite3DeleteTable(db, p);\n-  }\n-  db->pParse = pParse->pParentParse;\n-  pParse->pParentParse = 0;\n+  db->pParse = pParentParse;\n@@ -160358,1 +166613,0 @@\n-\n@@ -160538,1 +166792,1 @@\n-  MUTEX_LOGIC( sqlite3_mutex *pMaster; )       \/* The main static mutex *\/\n+  MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )      \/* The main static mutex *\/\n@@ -160578,1 +166832,1 @@\n-  ** This operation is protected by the STATIC_MASTER mutex.  Note that\n+  ** This operation is protected by the STATIC_MAIN mutex.  Note that\n@@ -160583,2 +166837,2 @@\n-  MUTEX_LOGIC( pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )\n-  sqlite3_mutex_enter(pMaster);\n+  MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n+  sqlite3_mutex_enter(pMainMtx);\n@@ -160602,1 +166856,1 @@\n-  sqlite3_mutex_leave(pMaster);\n+  sqlite3_mutex_leave(pMainMtx);\n@@ -160642,1 +166896,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -160663,1 +166917,1 @@\n-  sqlite3_mutex_enter(pMaster);\n+  sqlite3_mutex_enter(pMainMtx);\n@@ -160670,1 +166924,1 @@\n-  sqlite3_mutex_leave(pMaster);\n+  sqlite3_mutex_leave(pMainMtx);\n@@ -161057,1 +167311,1 @@\n-#ifdef SQLITE_ENABLE_DESERIALIZE\n+#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -161062,1 +167316,1 @@\n-#endif \/* SQLITE_ENABLE_DESERIALIZE *\/\n+#endif \/* SQLITE_OMIT_DESERIALIZE *\/\n@@ -161234,1 +167488,1 @@\n-    if( pBt && sqlite3BtreeIsInTrans(pBt) ){\n+    if( pBt && sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){\n@@ -161423,1 +167677,1 @@\n-SQLITE_API int sqlite3_changes(sqlite3 *db){\n+SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3 *db){\n@@ -161432,0 +167686,3 @@\n+SQLITE_API int sqlite3_changes(sqlite3 *db){\n+  return (int)sqlite3_changes64(db);\n+}\n@@ -161436,1 +167693,1 @@\n-SQLITE_API int sqlite3_total_changes(sqlite3 *db){\n+SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3 *db){\n@@ -161445,0 +167702,3 @@\n+SQLITE_API int sqlite3_total_changes(sqlite3 *db){\n+  return (int)sqlite3_total_changes64(db);\n+}\n@@ -161469,1 +167729,3 @@\n-  FuncDestructor *pDestructor = p->u.pDestructor;\n+  FuncDestructor *pDestructor;\n+  assert( (p->funcFlags & SQLITE_FUNC_BUILTIN)==0 );\n+  pDestructor = p->u.pDestructor;\n@@ -161539,1 +167801,1 @@\n-    db->xTrace(SQLITE_TRACE_CLOSE, db->pTraceArg, db, 0);\n+    db->trace.xV2(SQLITE_TRACE_CLOSE, db->pTraceArg, db, 0);\n@@ -161573,1 +167835,1 @@\n-  db->magic = SQLITE_MAGIC_ZOMBIE;\n+  db->eOpenState = SQLITE_STATE_ZOMBIE;\n@@ -161578,0 +167840,30 @@\n+\/*\n+** Return the transaction state for a single databse, or the maximum\n+** transaction state over all attached databases if zSchema is null.\n+*\/\n+SQLITE_API int sqlite3_txn_state(sqlite3 *db, const char *zSchema){\n+  int iDb, nDb;\n+  int iTxn = -1;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( !sqlite3SafetyCheckOk(db) ){\n+    (void)SQLITE_MISUSE_BKPT;\n+    return -1;\n+  }\n+#endif\n+  sqlite3_mutex_enter(db->mutex);\n+  if( zSchema ){\n+    nDb = iDb = sqlite3FindDbName(db, zSchema);\n+    if( iDb<0 ) nDb--;\n+  }else{\n+    iDb = 0;\n+    nDb = db->nDb-1;\n+  }\n+  for(; iDb<=nDb; iDb++){\n+    Btree *pBt = db->aDb[iDb].pBt;\n+    int x = pBt!=0 ? sqlite3BtreeTxnState(pBt) : SQLITE_TXN_NONE;\n+    if( x>iTxn ) iTxn = x;\n+  }\n+  sqlite3_mutex_leave(db->mutex);\n+  return iTxn;\n+}\n+\n@@ -161581,1 +167873,1 @@\n-** leaves the connection option if there are unfinalized prepared\n+** leaves the connection open if there are unfinalized prepared\n@@ -161607,1 +167899,1 @@\n-  if( db->magic!=SQLITE_MAGIC_ZOMBIE || connectionIsBusy(db) ){\n+  if( db->eOpenState!=SQLITE_STATE_ZOMBIE || connectionIsBusy(db) ){\n@@ -161693,1 +167985,1 @@\n-  db->magic = SQLITE_MAGIC_ERROR;\n+  db->eOpenState = SQLITE_STATE_ERROR;\n@@ -161702,0 +167994,3 @@\n+  if( db->xAutovacDestr ){\n+    db->xAutovacDestr(db->pAutovacPagesArg);\n+  }\n@@ -161703,1 +167998,1 @@\n-  db->magic = SQLITE_MAGIC_CLOSED;\n+  db->eOpenState = SQLITE_STATE_CLOSED;\n@@ -161738,1 +168033,1 @@\n-      if( sqlite3BtreeIsInTrans(p) ){\n+      if( sqlite3BtreeTxnState(p)==SQLITE_TXN_WRITE ){\n@@ -161756,1 +168051,1 @@\n-  db->flags &= ~(u64)SQLITE_DeferFKs;\n+  db->flags &= ~(u64)(SQLITE_DeferFKs|SQLITE_CorruptRdOnly);\n@@ -162091,1 +168386,1 @@\n-  if( !sqlite3SafetyCheckOk(db) && (db==0 || db->magic!=SQLITE_MAGIC_ZOMBIE) ){\n+  if( !sqlite3SafetyCheckOk(db) && (db==0 || db->eOpenState!=SQLITE_STATE_ZOMBIE) ){\n@@ -162120,1 +168415,0 @@\n-  int nName;\n@@ -162130,1 +168424,1 @@\n-   || (255<(nName = sqlite3Strlen30( zFunctionName)))\n+   || (255<sqlite3Strlen30(zFunctionName))\n@@ -162155,8 +168449,6 @@\n-  if( enc==SQLITE_UTF16 ){\n-    enc = SQLITE_UTF16NATIVE;\n-  }else if( enc==SQLITE_ANY ){\n-    int rc;\n-    rc = sqlite3CreateFunc(db, zFunctionName, nArg,\n-         (SQLITE_UTF8|extraFlags)^SQLITE_FUNC_UNSAFE,\n-         pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);\n-    if( rc==SQLITE_OK ){\n+  switch( enc ){\n+    case SQLITE_UTF16:\n+      enc = SQLITE_UTF16NATIVE;\n+      break;\n+    case SQLITE_ANY: {\n+      int rc;\n@@ -162164,1 +168456,1 @@\n-           (SQLITE_UTF16LE|extraFlags)^SQLITE_FUNC_UNSAFE,\n+           (SQLITE_UTF8|extraFlags)^SQLITE_FUNC_UNSAFE,\n@@ -162166,0 +168458,10 @@\n+      if( rc==SQLITE_OK ){\n+        rc = sqlite3CreateFunc(db, zFunctionName, nArg,\n+             (SQLITE_UTF16LE|extraFlags)^SQLITE_FUNC_UNSAFE,\n+             pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);\n+      }\n+      if( rc!=SQLITE_OK ){\n+        return rc;\n+      }\n+      enc = SQLITE_UTF16BE;\n+      break;\n@@ -162167,4 +168469,7 @@\n-    if( rc!=SQLITE_OK ){\n-      return rc;\n-    }\n-    enc = SQLITE_UTF16BE;\n+    case SQLITE_UTF8:\n+    case SQLITE_UTF16LE:\n+    case SQLITE_UTF16BE:\n+      break;\n+    default:\n+      enc = SQLITE_UTF8;\n+      break;\n@@ -162191,0 +168496,4 @@\n+  }else if( xSFunc==0 && xFinal==0 ){\n+    \/* Trying to delete a function that does not exist.  This is a no-op.\n+    ** https:\/\/sqlite.org\/forum\/forumpost\/726219164b *\/\n+    return SQLITE_OK;\n@@ -162263,1 +168572,1 @@\n-    assert( rc!=SQLITE_OK );\n+    assert( rc!=SQLITE_OK || (xStep==0 && xFinal==0) );\n@@ -162428,1 +168737,1 @@\n-  db->xTrace = (int(*)(u32,void*,void*,void*))xTrace;\n+  db->trace.xLegacy = xTrace;\n@@ -162452,1 +168761,1 @@\n-  db->xTrace = xTrace;\n+  db->trace.xV2 = xTrace;\n@@ -162589,0 +168898,28 @@\n+\/*\n+** Register a function to be invoked prior to each autovacuum that\n+** determines the number of pages to vacuum.\n+*\/\n+SQLITE_API int sqlite3_autovacuum_pages(\n+  sqlite3 *db,                 \/* Attach the hook to this database *\/\n+  unsigned int (*xCallback)(void*,const char*,u32,u32,u32),\n+  void *pArg,                  \/* Argument to the function *\/\n+  void (*xDestructor)(void*)   \/* Destructor for pArg *\/\n+){\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( !sqlite3SafetyCheckOk(db) ){\n+    if( xDestructor ) xDestructor(pArg);\n+    return SQLITE_MISUSE_BKPT;\n+  }\n+#endif\n+  sqlite3_mutex_enter(db->mutex);\n+  if( db->xAutovacDestr ){\n+    db->xAutovacDestr(db->pAutovacPagesArg);\n+  }\n+  db->xAutovacPages = xCallback;\n+  db->pAutovacPagesArg = pArg;\n+  db->xAutovacDestr = xDestructor;\n+  sqlite3_mutex_leave(db->mutex);\n+  return SQLITE_OK;\n+}\n+\n+\n@@ -162681,1 +169018,1 @@\n-  int iDb = SQLITE_MAX_ATTACHED;  \/* sqlite3.aDb[] index of db to checkpoint *\/\n+  int iDb;                        \/* Schema to checkpoint *\/\n@@ -162704,0 +169041,2 @@\n+  }else{\n+    iDb = SQLITE_MAX_DB;   \/* This means process all schemas *\/\n@@ -162752,1 +169091,1 @@\n-** If iDb is passed SQLITE_MAX_ATTACHED, then all attached databases are\n+** If iDb is passed SQLITE_MAX_DB then all attached databases are\n@@ -162767,0 +169106,2 @@\n+  testcase( iDb==SQLITE_MAX_ATTACHED ); \/* See forum post a006d86f72 *\/\n+  testcase( iDb==SQLITE_MAX_DB );\n@@ -162769,1 +169110,1 @@\n-    if( i==iDb || iDb==SQLITE_MAX_ATTACHED ){\n+    if( i==iDb || iDb==SQLITE_MAX_DB ){\n@@ -163107,0 +169448,2 @@\n+    }else if( newLimit<1 && limitId==SQLITE_LIMIT_LENGTH ){\n+      newLimit = 1;\n@@ -163378,1 +169721,1 @@\n-  while( zFilename[0] ){\n+  while( ALWAYS(zFilename!=0) && zFilename[0] ){\n@@ -163438,2 +169781,2 @@\n-  ** SQLITE_OPEN_PRIVATECACHE, and some reserved bits.  Silently mask\n-  ** off all other flags.\n+  ** SQLITE_OPEN_PRIVATECACHE, SQLITE_OPEN_EXRESCODE, and some reserved\n+  ** bits.  Silently mask off all other flags.\n@@ -163449,1 +169792,1 @@\n-               SQLITE_OPEN_MASTER_JOURNAL |\n+               SQLITE_OPEN_SUPER_JOURNAL |\n@@ -163474,1 +169817,1 @@\n-  db->errMask = 0xff;\n+  db->errMask = (flags & SQLITE_OPEN_EXRESCODE)!=0 ? 0xffffffff : 0xff;\n@@ -163476,1 +169819,1 @@\n-  db->magic = SQLITE_MAGIC_BUSY;\n+  db->eOpenState = SQLITE_STATE_BUSY;\n@@ -163488,0 +169831,7 @@\n+  db->init.azInit = sqlite3StdType; \/* Any array of string ptrs will do *\/\n+#ifdef SQLITE_ENABLE_SORTER_MMAP\n+  \/* Beginning with version 3.37.0, using the VFS xFetch() API to memory-map\n+  ** the temporary files used to do external sorts (see code in vdbesort.c)\n+  ** is disabled. It can still be used either by defining\n+  ** SQLITE_ENABLE_SORTER_MMAP at compile time or by using the\n+  ** SQLITE_TESTCTRL_SORTER_MMAP test-control at runtime. *\/\n@@ -163489,0 +169839,1 @@\n+#endif\n@@ -163636,1 +169987,1 @@\n-  db->magic = SQLITE_MAGIC_OPEN;\n+  db->eOpenState = SQLITE_STATE_OPEN;\n@@ -163698,2 +170049,2 @@\n-  assert( db!=0 || rc==SQLITE_NOMEM );\n-  if( rc==SQLITE_NOMEM ){\n+  assert( db!=0 || (rc&0xff)==SQLITE_NOMEM );\n+  if( (rc&0xff)==SQLITE_NOMEM ){\n@@ -163703,1 +170054,1 @@\n-    db->magic = SQLITE_MAGIC_SICK;\n+    db->eOpenState = SQLITE_STATE_SICK;\n@@ -163714,1 +170065,1 @@\n-  return rc & 0xff;\n+  return rc;\n@@ -164014,1 +170365,1 @@\n-  if( !pTab || pTab->pSelect ){\n+  if( !pTab || IsView(pTab) ){\n@@ -164025,1 +170376,1 @@\n-      if( 0==sqlite3StrICmp(pCol->zName, zColumnName) ){\n+      if( 0==sqlite3StrICmp(pCol->zCnName, zColumnName) ){\n@@ -164052,1 +170403,1 @@\n-    zCollSeq = pCol->zColl;\n+    zCollSeq = sqlite3ColumnColl(pCol);\n@@ -164159,0 +170510,1 @@\n+      int nSave = db->busyHandler.nBusy;\n@@ -164160,0 +170512,1 @@\n+      db->busyHandler.nBusy = nSave;\n@@ -164385,1 +170738,1 @@\n-      db->dbOptFlags = (u16)(va_arg(ap, int) & 0xffff);\n+      db->dbOptFlags = va_arg(ap, u32);\n@@ -164426,1 +170779,1 @@\n-    ** and tbl_name fields of the sqlite_master table.  This is normally\n+    ** and tbl_name fields of the sqlite_schema table.  This is normally\n@@ -164428,0 +170781,6 @@\n+    **\n+    ** 2020-07-22:  Disabling EXTRA_SCHEMA_CHECKS also disables the\n+    ** verification of rootpage numbers when parsing the schema.  This\n+    ** is useful to make it easier to reach strange internal error states\n+    ** during testing.  The EXTRA_SCHEMA_CHECKS setting is always enabled\n+    ** in production.\n@@ -164494,0 +170853,1 @@\n+      int iDb;\n@@ -164495,5 +170855,8 @@\n-      db->init.iDb = sqlite3FindDbName(db, va_arg(ap,const char*));\n-      db->init.busy = db->init.imposterTable = va_arg(ap,int);\n-      db->init.newTnum = va_arg(ap,int);\n-      if( db->init.busy==0 && db->init.newTnum>0 ){\n-        sqlite3ResetAllSchemasOfConnection(db);\n+      iDb = sqlite3FindDbName(db, va_arg(ap,const char*));\n+      if( iDb>=0 ){\n+        db->init.iDb = iDb;\n+        db->init.busy = db->init.imposterTable = va_arg(ap,int);\n+        db->init.newTnum = va_arg(ap,int);\n+        if( db->init.busy==0 && db->init.newTnum>0 ){\n+          sqlite3ResetAllSchemasOfConnection(db);\n+        }\n@@ -164536,0 +170899,68 @@\n+\n+    \/*  sqlite3_test_control(SQLITE_TESTCTRL_SEEK_COUNT,\n+    **    sqlite3 *db,    \/\/ Database connection\n+    **    u64 *pnSeek     \/\/ Write seek count here\n+    **  );\n+    **\n+    ** This test-control queries the seek-counter on the \"main\" database\n+    ** file.  The seek-counter is written into *pnSeek and is then reset.\n+    ** The seek-count is only available if compiled with SQLITE_DEBUG.\n+    *\/\n+    case SQLITE_TESTCTRL_SEEK_COUNT: {\n+      sqlite3 *db = va_arg(ap, sqlite3*);\n+      u64 *pn = va_arg(ap, sqlite3_uint64*);\n+      *pn = sqlite3BtreeSeekCount(db->aDb->pBt);\n+      (void)db;  \/* Silence harmless unused variable warning *\/\n+      break;\n+    }\n+\n+    \/*  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, op, ptr)\n+    **\n+    **  \"ptr\" is a pointer to a u32.\n+    **\n+    **   op==0       Store the current sqlite3SelectTrace in *ptr\n+    **   op==1       Set sqlite3SelectTrace to the value *ptr\n+    **   op==3       Store the current sqlite3WhereTrace in *ptr\n+    **   op==3       Set sqlite3WhereTrace to the value *ptr\n+    *\/\n+    case SQLITE_TESTCTRL_TRACEFLAGS: {\n+       int opTrace = va_arg(ap, int);\n+       u32 *ptr = va_arg(ap, u32*);\n+       switch( opTrace ){\n+         case 0:   *ptr = sqlite3SelectTrace;      break;\n+         case 1:   sqlite3SelectTrace = *ptr;      break;\n+         case 2:   *ptr = sqlite3WhereTrace;       break;\n+         case 3:   sqlite3WhereTrace = *ptr;       break;\n+       }\n+       break;\n+    }\n+\n+#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_WSD)\n+    \/* sqlite3_test_control(SQLITE_TESTCTRL_TUNE, id, *piValue)\n+    **\n+    ** If \"id\" is an integer between 1 and SQLITE_NTUNE then set the value\n+    ** of the id-th tuning parameter to *piValue.  If \"id\" is between -1\n+    ** and -SQLITE_NTUNE, then write the current value of the (-id)-th\n+    ** tuning parameter into *piValue.\n+    **\n+    ** Tuning parameters are for use during transient development builds,\n+    ** to help find the best values for constants in the query planner.\n+    ** Access tuning parameters using the Tuning(ID) macro.  Set the\n+    ** parameters in the CLI using \".testctrl tune ID VALUE\".\n+    **\n+    ** Transient use only.  Tuning parameters should not be used in\n+    ** checked-in code.\n+    *\/\n+    case SQLITE_TESTCTRL_TUNE: {\n+      int id = va_arg(ap, int);\n+      int *piValue = va_arg(ap, int*);\n+      if( id>0 && id<=SQLITE_NTUNE ){\n+        Tuning(id) = *piValue;\n+      }else if( id<0 && id>=-SQLITE_NTUNE ){\n+        *piValue = Tuning(-id);\n+      }else{\n+        rc = SQLITE_NOTFOUND;\n+      }\n+      break;\n+    }\n+#endif\n@@ -164643,1 +171074,1 @@\n-  while( zFilename[0] && (N--)>0 ){\n+  while( ALWAYS(zFilename) && zFilename[0] && (N--)>0 ){\n@@ -164686,0 +171117,1 @@\n+  if( zFilename==0 ) return 0;\n@@ -164689,0 +171121,1 @@\n+  if( zFilename==0 ) return 0;\n@@ -164691,1 +171124,1 @@\n-  while( zFilename[0] ){\n+  while( ALWAYS(zFilename) && zFilename[0] ){\n@@ -164702,1 +171135,1 @@\n-  zFilename += sqlite3Strlen30(zFilename) + 1;\n+  if( zFilename ) zFilename += sqlite3Strlen30(zFilename) + 1;\n@@ -164771,1 +171204,1 @@\n-      if( 0==sqlite3BtreeIsInTrans(pBt) ){\n+      if( SQLITE_TXN_WRITE!=sqlite3BtreeTxnState(pBt) ){\n@@ -164807,1 +171240,1 @@\n-      if( sqlite3BtreeIsInTrans(pBt)==0 ){\n+      if( sqlite3BtreeTxnState(pBt)!=SQLITE_TXN_WRITE ){\n@@ -164810,1 +171243,1 @@\n-        if( sqlite3BtreeIsInReadTrans(pBt) ){\n+        if( sqlite3BtreeTxnState(pBt)!=SQLITE_TXN_NONE ){\n@@ -164859,1 +171292,1 @@\n-    if( 0==sqlite3BtreeIsInReadTrans(pBt) ){\n+    if( SQLITE_TXN_NONE==sqlite3BtreeTxnState(pBt) ){\n@@ -164965,1 +171398,1 @@\n-  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) )\n+  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN)) )\n@@ -164970,1 +171403,1 @@\n-** is not NULL. This variable may only accessed while the STATIC_MASTER\n+** is not NULL. This variable may only accessed while the STATIC_MAIN\n@@ -165044,1 +171477,1 @@\n-** Obtain the STATIC_MASTER mutex.\n+** Obtain the STATIC_MAIN mutex.\n@@ -165047,1 +171480,1 @@\n-  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n+  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN));\n@@ -165052,1 +171485,1 @@\n-** Release the STATIC_MASTER mutex.\n+** Release the STATIC_MAIN mutex.\n@@ -165057,1 +171490,1 @@\n-  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n+  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN));\n@@ -165168,1 +171601,1 @@\n-  enterMutex();         \/* Enter STATIC_MASTER mutex *\/\n+  enterMutex();         \/* Enter STATIC_MAIN mutex *\/\n@@ -165251,1 +171684,1 @@\n-  leaveMutex();         \/* Leave STATIC_MASTER mutex *\/\n+  leaveMutex();         \/* Leave STATIC_MAIN mutex *\/\n@@ -165600,1 +172033,1 @@\n-\/* # include \"sqlite3ext.h\"  *\/\n+\/* # include \"sqlite3ext.h\" *\/\n@@ -165978,1 +172411,1 @@\n-#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n+#ifdef SQLITE_DEBUG\n@@ -165995,8 +172428,9 @@\n-#ifdef SQLITE_COVERAGE_TEST\n-# define ALWAYS(x) (1)\n-# define NEVER(X)  (0)\n-#elif defined(SQLITE_DEBUG)\n-# define ALWAYS(x) sqlite3Fts3Always((x)!=0)\n-# define NEVER(x) sqlite3Fts3Never((x)!=0)\n-SQLITE_PRIVATE int sqlite3Fts3Always(int b);\n-SQLITE_PRIVATE int sqlite3Fts3Never(int b);\n+#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n+# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1\n+#endif\n+#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)\n+# define ALWAYS(X)      (1)\n+# define NEVER(X)       (0)\n+#elif !defined(NDEBUG)\n+# define ALWAYS(X)      ((X)?1:(assert(0),0))\n+# define NEVER(X)       ((X)?(assert(0),1):0)\n@@ -166004,2 +172438,2 @@\n-# define ALWAYS(x) (x)\n-# define NEVER(x)  (x)\n+# define ALWAYS(X)      (X)\n+# define NEVER(X)       (X)\n@@ -166043,0 +172477,2 @@\n+#define deliberate_fall_through\n+\n@@ -166462,0 +172898,1 @@\n+SQLITE_PRIVATE void *sqlite3Fts3MallocZero(i64 nByte);\n@@ -166519,7 +172956,0 @@\n-#ifndef SQLITE_AMALGAMATION\n-# if defined(SQLITE_DEBUG)\n-SQLITE_PRIVATE int sqlite3Fts3Always(int b) { assert( b ); return b; }\n-SQLITE_PRIVATE int sqlite3Fts3Never(int b)  { assert( !b ); return b; }\n-# endif\n-#endif\n-\n@@ -166532,0 +172962,1 @@\n+#ifdef SQLITE_DEBUG\n@@ -166533,0 +172964,1 @@\n+#endif\n@@ -168103,1 +174535,1 @@\n-  sqlite3_int64 iChild;           \/* Block id of child node to descend to *\/\n+  u64 iChild;                     \/* Block id of child node to descend to *\/\n@@ -168119,2 +174551,2 @@\n-  zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);\n-  zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);\n+  zCsr += sqlite3Fts3GetVarintU(zCsr, &iChild);\n+  zCsr += sqlite3Fts3GetVarintU(zCsr, &iChild);\n@@ -168173,1 +174605,1 @@\n-      *piFirst = iChild;\n+      *piFirst = (i64)iChild;\n@@ -168178,1 +174610,1 @@\n-      *piLast = iChild;\n+      *piLast = (i64)iChild;\n@@ -168185,2 +174617,2 @@\n-  if( piFirst ) *piFirst = iChild;\n-  if( piLast ) *piLast = iChild;\n+  if( piFirst ) *piFirst = (i64)iChild;\n+  if( piLast ) *piLast = (i64)iChild;\n@@ -168274,1 +174706,1 @@\n-  assert( iVal-*piPrev > 0 || (*piPrev==0 && iVal==0) );\n+  assert_fts3_nc( iVal-*piPrev > 0 || (*piPrev==0 && iVal==0) );\n@@ -169685,1 +176117,1 @@\n-        \/* fall-through *\/\n+        \/* no break *\/ deliberate_fall_through\n@@ -169792,0 +176224,1 @@\n+  int rc;\n@@ -169796,2 +176229,0 @@\n-  TESTONLY( p->inTransaction = 1 );\n-  TESTONLY( p->mxSavepoint = -1; );\n@@ -169799,1 +176230,8 @@\n-  return fts3SetHasStat(p);\n+  rc = fts3SetHasStat(p);\n+#ifdef SQLITE_DEBUG\n+  if( rc==SQLITE_OK ){\n+    p->inTransaction = 1;\n+    p->mxSavepoint = -1;\n+  }\n+#endif\n+  return rc;\n@@ -169928,0 +176366,1 @@\n+            \/* no break *\/ deliberate_fall_through\n@@ -169929,0 +176368,1 @@\n+            \/* no break *\/ deliberate_fall_through\n@@ -169930,0 +176370,1 @@\n+            \/* no break *\/ deliberate_fall_through\n@@ -169931,0 +176372,1 @@\n+            \/* no break *\/ deliberate_fall_through\n@@ -170674,1 +177116,1 @@\n-  assert( p || *piDocid==0 );\n+  assert_fts3_nc( p || *piDocid==0 );\n@@ -171324,1 +177766,0 @@\n-    Fts3Expr **apOr;\n@@ -171329,1 +177770,0 @@\n-    apOr = (Fts3Expr **)&aTC[nToken];\n@@ -171334,0 +177774,1 @@\n+      Fts3Expr **apOr = (Fts3Expr **)&aTC[nToken];\n@@ -171414,4 +177855,6 @@\n-    assert( pPhrase->doclist.pList[nNew]=='\\0' );\n-    assert( nNew<=pPhrase->doclist.nList && nNew>0 );\n-    memset(&pPhrase->doclist.pList[nNew], 0, pPhrase->doclist.nList - nNew);\n-    pPhrase->doclist.nList = nNew;\n+    assert_fts3_nc( nNew<=pPhrase->doclist.nList && nNew>0 );\n+    if( nNew>=0 && nNew<=pPhrase->doclist.nList ){\n+      assert( pPhrase->doclist.pList[nNew]=='\\0' );\n+      memset(&pPhrase->doclist.pList[nNew], 0, pPhrase->doclist.nList - nNew);\n+      pPhrase->doclist.nList = nNew;\n+    }\n@@ -171537,2 +177980,2 @@\n-        assert( pLeft->bStart || pLeft->iDocid==pRight->iDocid );\n-        assert( pRight->bStart || pLeft->iDocid==pRight->iDocid );\n+        assert_fts3_nc( pLeft->bStart || pLeft->iDocid==pRight->iDocid );\n+        assert_fts3_nc( pRight->bStart || pLeft->iDocid==pRight->iDocid );\n@@ -171769,1 +178212,4 @@\n-          bHit = (pExpr->bEof==0 && pExpr->iDocid==pCsr->iPrevId);\n+          bHit = (\n+              pExpr->bEof==0 && pExpr->iDocid==pCsr->iPrevId\n+           && pExpr->pPhrase->doclist.nList>0\n+          );\n@@ -172032,1 +178478,2 @@\n-        assert( pRoot->bEof==0 );\n+        assert_fts3_nc( pRoot->bEof==0 );\n+        if( pRoot->bEof ) rc = FTS_CORRUPT_VTAB;\n@@ -172172,0 +178619,3 @@\n+      if( rc==SQLITE_OK && pNear->bEof!=bEofSave ){\n+        rc = FTS_CORRUPT_VTAB;\n+      }\n@@ -172594,0 +179044,1 @@\n+    rc = SQLITE_OK;\n@@ -172637,0 +179088,4 @@\n+          if( iCol<1 ){\n+            rc = SQLITE_CORRUPT_VTAB;\n+            break;\n+          }\n@@ -172645,1 +179100,0 @@\n-    rc = SQLITE_OK;\n@@ -172703,0 +179157,1 @@\n+  sqlite3_free(pCsr->zStop);\n@@ -172973,1 +179428,1 @@\n-static void *fts3MallocZero(sqlite3_int64 nByte){\n+SQLITE_PRIVATE void *sqlite3Fts3MallocZero(sqlite3_int64 nByte){\n@@ -173054,1 +179509,1 @@\n-      pRet = (Fts3Expr *)fts3MallocZero(nByte);\n+      pRet = (Fts3Expr *)sqlite3Fts3MallocZero(nByte);\n@@ -173309,1 +179764,1 @@\n-        pRet = (Fts3Expr *)fts3MallocZero(sizeof(Fts3Expr));\n+        pRet = (Fts3Expr *)sqlite3Fts3MallocZero(sizeof(Fts3Expr));\n@@ -173344,0 +179799,5 @@\n+#if !defined(SQLITE_MAX_EXPR_DEPTH)\n+      if( pParse->nNest>1000 ) return SQLITE_ERROR;\n+#elif SQLITE_MAX_EXPR_DEPTH>0\n+      if( pParse->nNest>SQLITE_MAX_EXPR_DEPTH ) return SQLITE_ERROR;\n+#endif\n@@ -173483,1 +179943,1 @@\n-          Fts3Expr *pNot = fts3MallocZero(sizeof(Fts3Expr));\n+          Fts3Expr *pNot = sqlite3Fts3MallocZero(sizeof(Fts3Expr));\n@@ -173517,1 +179977,1 @@\n-            pAnd = fts3MallocZero(sizeof(Fts3Expr));\n+            pAnd = sqlite3Fts3MallocZero(sizeof(Fts3Expr));\n@@ -176141,1 +182601,2 @@\n-    const char * const *azArg = (const char * const *)&azDequote[1];\n+    const char * const *azArg = 0;\n+    if( nDequote>1 ) azArg = (const char * const *)&azDequote[1];\n@@ -176752,1 +183213,3 @@\n-         \"  FROM %Q.'%q_segdir' WHERE level = ? AND idx < ?\",\n+         \"  FROM (SELECT * FROM %Q.'%q_segdir' \"\n+         \"        WHERE level = ? ORDER BY idx ASC LIMIT ?\"\n+         \"  )\",\n@@ -177744,2 +184207,12 @@\n-        pReader->zTerm = (char *)fts3HashKey(pElem);\n-        pReader->nTerm = fts3HashKeysize(pElem);\n+\n+        int nTerm = fts3HashKeysize(pElem);\n+        if( (nTerm+1)>pReader->nTermAlloc ){\n+          sqlite3_free(pReader->zTerm);\n+          pReader->zTerm = (char*)sqlite3_malloc((nTerm+1)*2);\n+          if( !pReader->zTerm ) return SQLITE_NOMEM;\n+          pReader->nTermAlloc = (nTerm+1)*2;\n+        }\n+        memcpy(pReader->zTerm, fts3HashKey(pElem), nTerm);\n+        pReader->zTerm[nTerm] = '\\0';\n+        pReader->nTerm = nTerm;\n+\n@@ -177998,3 +184471,1 @@\n-    if( !fts3SegReaderIsPending(pReader) ){\n-      sqlite3_free(pReader->zTerm);\n-    }\n+    sqlite3_free(pReader->zTerm);\n@@ -178216,1 +184687,1 @@\n-  assert( rc!=0 );\n+  assert_fts3_nc( rc!=0 );\n@@ -178412,2 +184883,2 @@\n-  UNUSED_PARAMETER(nNext);\n-  for(n=0; n<nPrev && zPrev[n]==zNext[n]; n++);\n+  for(n=0; n<nPrev && n<nNext && zPrev[n]==zNext[n]; n++);\n+  assert_fts3_nc( n<nNext );\n@@ -179264,0 +185735,13 @@\n+static int fts3GrowSegReaderBuffer(Fts3MultiSegReader *pCsr, int nReq){\n+  if( nReq>pCsr->nBuffer ){\n+    char *aNew;\n+    pCsr->nBuffer = nReq*2;\n+    aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer);\n+    if( !aNew ){\n+      return SQLITE_NOMEM;\n+    }\n+    pCsr->aBuffer = aNew;\n+  }\n+  return SQLITE_OK;\n+}\n+\n@@ -179398,9 +185882,3 @@\n-          if( nDoclist+nByte>pCsr->nBuffer ){\n-            char *aNew;\n-            pCsr->nBuffer = (nDoclist+nByte)*2;\n-            aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer);\n-            if( !aNew ){\n-              return SQLITE_NOMEM;\n-            }\n-            pCsr->aBuffer = aNew;\n-          }\n+\n+          rc = fts3GrowSegReaderBuffer(pCsr, nByte+nDoclist+FTS3_NODE_PADDING);\n+          if( rc ) return rc;\n@@ -179431,0 +185909,3 @@\n+        rc = fts3GrowSegReaderBuffer(pCsr, nDoclist+FTS3_NODE_PADDING);\n+        if( rc ) return rc;\n+        memset(&pCsr->aBuffer[nDoclist], 0, FTS3_NODE_PADDING);\n@@ -180182,1 +186663,1 @@\n-    if( rc==SQLITE_OK ){\n+    if( rc==SQLITE_OK && ALWAYS(p->term.a!=0) ){\n@@ -180576,1 +187057,5 @@\n-  res = (nCmp ? memcmp(zLhs, zRhs, nCmp) : 0);\n+  if( nCmp && ALWAYS(zLhs) && ALWAYS(zRhs) ){\n+    res = memcmp(zLhs, zRhs, nCmp);\n+  }else{\n+    res = 0;\n+  }\n@@ -180699,1 +187184,1 @@\n-      if( nHeight<1 || nHeight>FTS_MAX_APPENDABLE_HEIGHT ){\n+      if( nHeight<1 || nHeight>=FTS_MAX_APPENDABLE_HEIGHT ){\n@@ -180734,1 +187219,4 @@\n-            memcpy(pNode->key.a, reader.term.a, reader.term.n);\n+            assert_fts3_nc( reader.term.n>0 || reader.aNode==0 );\n+            if( reader.term.n>0 ){\n+              memcpy(pNode->key.a, reader.term.a, reader.term.n);\n+            }\n@@ -180741,1 +187229,1 @@\n-              rc = sqlite3Fts3ReadBlock(p, reader.iChild, &aBlock, &nBlock, 0);\n+              rc = sqlite3Fts3ReadBlock(p, reader.iChild, &aBlock, &nBlock,0);\n@@ -180744,1 +187232,1 @@\n-              );\n+                  );\n@@ -181217,1 +187705,1 @@\n-          memcpy(pHint->a, aHint, nHint);\n+          if( ALWAYS(pHint->a!=0) ) memcpy(pHint->a, aHint, nHint);\n@@ -182213,0 +188701,4 @@\n+#ifndef SQLITE_AMALGAMATION\n+typedef sqlite3_int64 i64;\n+#endif\n+\n@@ -182263,1 +188755,1 @@\n-  int iHead;                      \/* Next value in position list *\/\n+  i64 iHead;                      \/* Next value in position list *\/\n@@ -182265,1 +188757,1 @@\n-  int iTail;                      \/* Next value in trailing position list *\/\n+  i64 iTail;                      \/* Next value in trailing position list *\/\n@@ -182330,1 +188822,1 @@\n-  pRet = sqlite3_malloc64(nByte + nStr+1);\n+  pRet = sqlite3Fts3MallocZero(nByte + nStr+1);\n@@ -182332,1 +188824,0 @@\n-    memset(pRet, 0, nByte);\n@@ -182430,1 +188921,1 @@\n-static void fts3GetDeltaPosition(char **pp, int *piPos){\n+static void fts3GetDeltaPosition(char **pp, i64 *piPos){\n@@ -182539,1 +189030,1 @@\n-static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){\n+static void fts3SnippetAdvance(char **ppIter, i64 *piIter, int iNext){\n@@ -182542,1 +189033,1 @@\n-    int iIter = *piIter;\n+    i64 iIter = *piIter;\n@@ -182625,1 +189116,1 @@\n-      int iCsr = pPhrase->iTail;\n+      i64 iCsr = pPhrase->iTail;\n@@ -182671,1 +189162,1 @@\n-    int iFirst = 0;\n+    i64 iFirst = 0;\n@@ -182736,1 +189227,1 @@\n-  sIter.aPhrase = (SnippetPhrase *)sqlite3_malloc64(nByte);\n+  sIter.aPhrase = (SnippetPhrase *)sqlite3Fts3MallocZero(nByte);\n@@ -182740,1 +189231,0 @@\n-  memset(sIter.aPhrase, 0, nByte);\n@@ -183304,1 +189794,1 @@\n-  char *pRead = pIter->pRead;\n+  char *pRead;\n@@ -183308,0 +189798,2 @@\n+  if( NEVER(pIter==0) ) return 1;\n+  pRead = pIter->pRead;\n@@ -183341,1 +189833,1 @@\n-  aIter = sqlite3_malloc64(sizeof(LcsIterator) * pCsr->nPhrase);\n+  aIter = sqlite3Fts3MallocZero(sizeof(LcsIterator) * pCsr->nPhrase);\n@@ -183343,1 +189835,0 @@\n-  memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);\n@@ -183735,2 +190226,2 @@\n-  int iPos;                       \/* Position just read from pList *\/\n-  int iOff;                       \/* Offset of this term from read positions *\/\n+  i64 iPos;                       \/* Position just read from pList *\/\n+  i64 iOff;                       \/* Offset of this term from read positions *\/\n@@ -183755,1 +190246,1 @@\n-  int iPos = 0;                   \/* First position in position-list *\/\n+  i64 iPos = 0;                   \/* First position in position-list *\/\n@@ -183804,1 +190295,1 @@\n-  sCtx.aTerm = (TermOffset *)sqlite3_malloc64(sizeof(TermOffset)*nToken);\n+  sCtx.aTerm = (TermOffset *)sqlite3Fts3MallocZero(sizeof(TermOffset)*nToken);\n@@ -183825,3 +190316,2 @@\n-    \/* Initialize the contents of sCtx.aTerm[] for column iCol. There is\n-    ** no way that this operation can fail, so the return code from\n-    ** fts3ExprIterate() can be discarded.\n+    \/* Initialize the contents of sCtx.aTerm[] for column iCol. This\n+    ** operation may fail if the database contains corrupt records.\n@@ -183831,1 +190321,2 @@\n-    (void)fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void*)&sCtx);\n+    rc = fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void*)&sCtx);\n+    if( rc!=SQLITE_OK ) goto offsets_out;\n@@ -184232,0 +190723,1 @@\n+    pCsr->aInput = (const unsigned char*)\"\";\n@@ -184774,0 +191266,4 @@\n+#ifndef deliberate_fall_through\n+# define deliberate_fall_through\n+#endif\n+\n@@ -184824,0 +191320,19 @@\n+# if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n+#   define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1\n+# endif\n+# if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)\n+#   define ALWAYS(X)      (1)\n+#   define NEVER(X)       (0)\n+# elif !defined(NDEBUG)\n+#   define ALWAYS(X)      ((X)?1:(assert(0),0))\n+#   define NEVER(X)       ((X)?(assert(0),1):0)\n+# else\n+#   define ALWAYS(X)      (X)\n+#   define NEVER(X)       (X)\n+# endif\n+# define testcase(X)\n+#endif\n+#if !defined(SQLITE_DEBUG) && !defined(SQLITE_COVERAGE_TEST)\n+#  define VVA(X)\n+#else\n+#  define VVA(X) X\n@@ -184826,0 +191341,8 @@\n+\/*\n+** Some of the testcase() macros in this file are problematic for gcov\n+** in that they generate false-miss errors randomly.  This is a gcov problem,\n+** not a problem in this case.  But to work around it, we disable the\n+** problematic test cases for production builds.\n+*\/\n+#define json_testcase(X)\n+\n@@ -184882,0 +191405,1 @@\n+  u8 eU;                 \/* Which union element to use *\/\n@@ -184884,5 +191408,5 @@\n-    const char *zJContent; \/* Content for INT, REAL, and STRING *\/\n-    u32 iAppend;           \/* More terms for ARRAY and OBJECT *\/\n-    u32 iKey;              \/* Key for ARRAY objects in json_tree() *\/\n-    u32 iReplace;          \/* Replacement content for JNODE_REPLACE *\/\n-    JsonNode *pPatch;      \/* Node chain of patch for JNODE_PATCH *\/\n+    const char *zJContent; \/* 1: Content for INT, REAL, and STRING *\/\n+    u32 iAppend;           \/* 2: More terms for ARRAY and OBJECT *\/\n+    u32 iKey;              \/* 3: Key for ARRAY objects in json_tree() *\/\n+    u32 iReplace;          \/* 4: Replacement content for JNODE_REPLACE *\/\n+    JsonNode *pPatch;      \/* 5: Node chain of patch for JNODE_PATCH *\/\n@@ -185027,1 +191551,1 @@\n-  if( (N+p->nUsed+2 >= p->nAlloc) && jsonGrow(p,N+2)!=0 ) return;\n+  if( zIn==0 || ((N+p->nUsed+2 >= p->nAlloc) && jsonGrow(p,N+2)!=0) ) return;\n@@ -185166,0 +191690,1 @@\n+  assert( pNode!=0 );\n@@ -185167,1 +191692,2 @@\n-    if( pNode->jnFlags & JNODE_REPLACE ){\n+    if( (pNode->jnFlags & JNODE_REPLACE)!=0 && ALWAYS(aReplace!=0) ){\n+      assert( pNode->eU==4 );\n@@ -185171,0 +191697,1 @@\n+    assert( pNode->eU==5 );\n@@ -185189,0 +191716,1 @@\n+        assert( pNode->eU==1 );\n@@ -185192,1 +191720,1 @@\n-      \/* Fall through into the next case *\/\n+      \/* no break *\/ deliberate_fall_through\n@@ -185196,0 +191724,1 @@\n+      assert( pNode->eU==1 );\n@@ -185211,0 +191740,1 @@\n+        assert( pNode->eU==2 );\n@@ -185231,0 +191761,1 @@\n+        assert( pNode->eU==2 );\n@@ -185310,1 +191841,3 @@\n-      const char *z = pNode->u.zJContent;\n+      const char *z;\n+      assert( pNode->eU==1 );\n+      z = pNode->u.zJContent;\n@@ -185333,1 +191866,1 @@\n-      int_as_real: \/* fall through to real *\/;\n+      int_as_real: ; \/* no break *\/ deliberate_fall_through\n@@ -185338,1 +191871,3 @@\n-      const char *z = pNode->u.zJContent;\n+      const char *z;\n+      assert( pNode->eU==1 );\n+      z = pNode->u.zJContent;\n@@ -185341,0 +191876,1 @@\n+      assert( pNode->eU==1 );\n@@ -185351,0 +191887,1 @@\n+        assert( pNode->eU==1 );\n@@ -185358,0 +191895,1 @@\n+        assert( pNode->eU==1 );\n@@ -185364,1 +191902,1 @@\n-        const char *z = pNode->u.zJContent;\n+        const char *z;\n@@ -185367,0 +191905,2 @@\n+        assert( pNode->eU==1 );\n+        z = pNode->u.zJContent;\n@@ -185487,1 +192027,1 @@\n-  if( pParse->nNode>=pParse->nAlloc ){\n+  if( pParse->aNode==0 || pParse->nNode>=pParse->nAlloc ){\n@@ -185493,0 +192033,1 @@\n+  VVA( p->eU = zContent ? 1 : 0 );\n@@ -185560,0 +192101,1 @@\n+    memset(&pParse->aNode[iThis].u, 0, sizeof(pParse->aNode[iThis].u));\n@@ -185824,0 +192366,1 @@\n+  assert( pNode->eU==1 );\n@@ -185889,0 +192432,1 @@\n+      assert( pRoot->eU==2 );\n@@ -185903,0 +192447,1 @@\n+        assert( pRoot->eU==0 );\n@@ -185905,0 +192450,1 @@\n+        VVA( pRoot->eU = 2 );\n@@ -185927,0 +192473,1 @@\n+          assert( pBase->eU==2 );\n@@ -185960,0 +192507,1 @@\n+      assert( pRoot->eU==2 );\n@@ -185975,0 +192523,1 @@\n+        assert( pRoot->eU==0 );\n@@ -185977,0 +192526,1 @@\n+        VVA( pRoot->eU = 2 );\n@@ -186130,0 +192680,1 @@\n+    assert( x.aNode[i].eU==0 || x.aNode[i].eU==1 );\n@@ -186131,0 +192682,1 @@\n+      assert( x.aNode[i].eU==1 );\n@@ -186133,0 +192685,2 @@\n+    }else{\n+      assert( x.aNode[i].eU==0 );\n@@ -186315,0 +192869,1 @@\n+    assert( pPatch[i].eU==1 );\n@@ -186331,0 +192886,6 @@\n+            assert( pTarget[j+1].eU==0\n+                 || pTarget[j+1].eU==1\n+                 || pTarget[j+1].eU==2 );\n+            testcase( pTarget[j+1].eU==1 );\n+            testcase( pTarget[j+1].eU==2 );\n+            VVA( pTarget[j+1].eU = 5 );\n@@ -186346,0 +192907,2 @@\n+      assert( pParse->aNode[iRoot].eU==0 || pParse->aNode[iRoot].eU==2 );\n+      testcase( pParse->aNode[iRoot].eU==2 );\n@@ -186347,0 +192910,1 @@\n+      VVA( pParse->aNode[iRoot].eU = 2 );\n@@ -186349,0 +192913,2 @@\n+      assert( pParse->aNode[iPatch].eU==0 );\n+      VVA( pParse->aNode[iPatch].eU = 5 );\n@@ -186490,0 +193056,2 @@\n+      assert( pNode->eU==0 || pNode->eU==1 || pNode->eU==4 );\n+      json_testcase( pNode->eU!=0 && pNode->eU!=1 );\n@@ -186491,0 +193059,1 @@\n+      VVA( pNode->eU =  4 );\n@@ -186495,0 +193064,1 @@\n+    assert( x.aNode[0].eU==4 );\n@@ -186544,0 +193114,3 @@\n+      json_testcase( pNode->eU!=0 && pNode->eU!=1 && pNode->eU!=4 );\n+      assert( pNode->eU!=3 || pNode->eU!=5 );\n+      VVA( pNode->eU = 4 );\n@@ -186549,0 +193122,1 @@\n+    assert( x.aNode[0].eU==4 );\n@@ -186626,1 +193200,0 @@\n-      pStr->pCtx = ctx;\n@@ -186628,0 +193201,1 @@\n+    pStr->pCtx = ctx;\n@@ -186687,5 +193261,1 @@\n-  for(i=1; (c = z[i])!=',' || inStr || nNest; i++){\n-    if( i>=pStr->nUsed ){\n-      pStr->nUsed = 1;\n-      return;\n-    }\n+  for(i=1; i<pStr->nUsed && ((c = z[i])!=',' || inStr || nNest); i++){\n@@ -186701,2 +193271,7 @@\n-  pStr->nUsed -= i;\n-  memmove(&z[1], &z[i+1], (size_t)pStr->nUsed-1);\n+  if( i<pStr->nUsed ){\n+    pStr->nUsed -= i;\n+    memmove(&z[1], &z[i+1], (size_t)pStr->nUsed-1);\n+    z[pStr->nUsed] = 0;\n+  }else{\n+    pStr->nUsed = 1;\n+  }\n@@ -186730,1 +193305,0 @@\n-      pStr->pCtx = ctx;\n@@ -186732,0 +193306,1 @@\n+    pStr->pCtx = ctx;\n@@ -186898,0 +193473,3 @@\n+        assert( pUp->eU==0 || pUp->eU==3 );\n+        json_testcase( pUp->eU==3 );\n+        VVA( pUp->eU = 3 );\n@@ -186944,0 +193522,2 @@\n+    assert( pUp->eU==3 || (pUp->eU==0 && pUp->u.iKey==0) );\n+    testcase( pUp->eU==0 );\n@@ -186950,0 +193530,1 @@\n+    assert( pNode->eU==1 );\n@@ -186971,0 +193552,1 @@\n+          assert( p->sParse.aNode[p->sParse.aUp[p->i]].eU==3 );\n@@ -187020,0 +193602,1 @@\n+          assert( pThis->eU==1 );\n@@ -187036,0 +193619,1 @@\n+      \/* no break *\/ deliberate_fall_through\n@@ -187086,0 +193670,1 @@\n+    testcase( iCol==0 );\n@@ -187183,0 +193768,2 @@\n+      assert( pNode->eU==0 );\n+      VVA( pNode->eU = 3 );\n@@ -187425,1 +194012,5 @@\n-#ifndef SQLITE_AMALGAMATION\n+\/*\n+** If building separately, we will need some setup that is normally\n+** found in sqliteInt.h\n+*\/\n+#if !defined(SQLITE_AMALGAMATION)\n@@ -187438,0 +194029,2 @@\n+#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n+# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1\n@@ -187439,0 +194032,11 @@\n+#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)\n+# define ALWAYS(X)      (1)\n+# define NEVER(X)       (0)\n+#elif !defined(NDEBUG)\n+# define ALWAYS(X)      ((X)?1:(assert(0),0))\n+# define NEVER(X)       ((X)?(assert(0),1):0)\n+#else\n+# define ALWAYS(X)      (X)\n+# define NEVER(X)       (X)\n+#endif\n+#endif \/* !defined(SQLITE_AMALGAMATION) *\/\n@@ -187443,0 +194047,1 @@\n+\/* #include <stdlib.h> *\/\n@@ -187495,0 +194100,1 @@\n+#ifdef SQLITE_ENABLE_GEOPOLY\n@@ -187496,0 +194102,1 @@\n+#endif\n@@ -187777,1 +194384,23 @@\n-# define testcase(X)\n+# if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)\n+    unsigned int sqlite3RtreeTestcase = 0;\n+#   define testcase(X)  if( X ){ sqlite3RtreeTestcase += __LINE__; }\n+# else\n+#   define testcase(X)\n+# endif\n+#endif\n+\n+\/*\n+** Make sure that the compiler intrinsics we desire are enabled when\n+** compiling with an appropriate version of MSVC unless prevented by\n+** the SQLITE_DISABLE_INTRINSIC define.\n+*\/\n+#if !defined(SQLITE_DISABLE_INTRINSIC)\n+#  if defined(_MSC_VER) && _MSC_VER>=1400\n+#    if !defined(_WIN32_WCE)\n+\/* #      include <intrin.h> *\/\n+#      pragma intrinsic(_byteswap_ulong)\n+#      pragma intrinsic(_byteswap_uint64)\n+#    else\n+\/* #      include <cmnintrin.h> *\/\n+#    endif\n+#  endif\n@@ -188009,12 +194638,0 @@\n-\/*\n-** Check to see if pNode is the same as pParent or any of the parents\n-** of pParent.\n-*\/\n-static int nodeInParentChain(const RtreeNode *pNode, const RtreeNode *pParent){\n-  do{\n-    if( pNode==pParent ) return 1;\n-    pParent = pParent->pParent;\n-  }while( pParent );\n-  return 0;\n-}\n-\n@@ -188037,8 +194654,1 @@\n-    if( pParent && !pNode->pParent ){\n-      if( nodeInParentChain(pNode, pParent) ){\n-        RTREE_IS_CORRUPT(pRtree);\n-        return SQLITE_CORRUPT_VTAB;\n-      }\n-      pParent->nRef++;\n-      pNode->pParent = pParent;\n-    }else if( pParent && pNode->pParent && pParent!=pNode->pParent ){\n+    if( pParent && pParent!=pNode->pParent ){\n@@ -188102,1 +194712,1 @@\n-  if( pNode && iNode==1 ){\n+  if( rc==SQLITE_OK && pNode && iNode==1 ){\n@@ -188625,0 +195235,10 @@\n+    case RTREE_EQ:\n+      RTREE_DECODE_COORD(eInt, pCellData, val);\n+      \/* val now holds the lower bound of the coordinate pair *\/\n+      if( p->u.rValue>=val ){\n+        pCellData += 4;\n+        RTREE_DECODE_COORD(eInt, pCellData, val);\n+        \/* val now holds the upper bound of the coordinate pair *\/\n+        if( p->u.rValue<=val ) return;\n+      }\n+      break;\n@@ -188627,1 +195247,0 @@\n-    case RTREE_EQ:\n@@ -188631,2 +195250,1 @@\n-      if( p->op!=RTREE_EQ ) break;  \/* RTREE_LE and RTREE_LT end here *\/\n-      \/* Fall through for the RTREE_EQ case *\/\n+      break;\n@@ -188634,1 +195252,1 @@\n-    default: \/* RTREE_GT or RTREE_GE,  or fallthrough of RTREE_EQ *\/\n+    default:\n@@ -188639,0 +195257,1 @@\n+      break;\n@@ -188708,1 +195327,1 @@\n-  if( pParent ){\n+  if( ALWAYS(pParent) ){\n@@ -188710,0 +195329,3 @@\n+  }else{\n+    *piIndex = -1;\n+    return SQLITE_OK;\n@@ -188711,2 +195333,0 @@\n-  *piIndex = -1;\n-  return SQLITE_OK;\n@@ -188835,1 +195455,2 @@\n-      if( ii<RTREE_CACHE_SZ ){\n+      assert( ii==1 );\n+      if( ALWAYS(ii<RTREE_CACHE_SZ) ){\n@@ -188896,1 +195517,1 @@\n-  }else if( p->nPoint ){\n+  }else if( ALWAYS(p->nPoint) ){\n@@ -189037,1 +195658,1 @@\n-  if( rc==SQLITE_OK && p ){\n+  if( rc==SQLITE_OK && ALWAYS(p) ){\n@@ -189055,1 +195676,1 @@\n-  if( p==0 ) return SQLITE_OK;\n+  if( NEVER(p==0) ) return SQLITE_OK;\n@@ -189254,0 +195875,1 @@\n+      assert( pCsr->bPoint==0 );  \/* Due to the resetCursor() call above *\/\n@@ -189255,1 +195877,3 @@\n-      if( pNew==0 ) return SQLITE_NOMEM;\n+      if( NEVER(pNew==0) ){       \/* Because pCsr->bPoint was FALSE *\/\n+        return SQLITE_NOMEM;\n+      }\n@@ -189332,1 +195956,1 @@\n-     && p->iColumn==0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ\n+     && p->iColumn<=0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ\n@@ -189538,1 +196162,1 @@\n-    RtreeNode *pChild;\n+    RtreeNode *pChild = 0;\n@@ -189585,0 +196209,1 @@\n+  int rc;\n@@ -189590,1 +196215,7 @@\n-    if( (++cnt)>1000 || nodeParentIndex(pRtree, p, &iCell)  ){\n+    cnt++;\n+    if( NEVER(cnt>100) ){\n+      RTREE_IS_CORRUPT(pRtree);\n+      return SQLITE_CORRUPT_VTAB;\n+    }\n+    rc = nodeParentIndex(pRtree, p, &iCell);\n+    if( NEVER(rc!=SQLITE_OK) ){\n@@ -189879,0 +196510,4 @@\n+    RtreeNode *p;\n+    for(p=pNode; p; p=p->pParent){\n+      if( p==pChild ) return SQLITE_CORRUPT_VTAB;\n+    }\n@@ -189885,0 +196520,1 @@\n+  if( NEVER(pNode==0) ) return SQLITE_ERROR;\n@@ -189974,1 +196610,1 @@\n-    if( rc==SQLITE_OK ){\n+    if( ALWAYS(rc==SQLITE_OK) ){\n@@ -189977,0 +196613,1 @@\n+      assert( rc==SQLITE_OK );\n@@ -189978,1 +196615,1 @@\n-    if( rc!=SQLITE_OK ){\n+    if( NEVER(rc!=SQLITE_OK) ){\n@@ -190053,1 +196690,1 @@\n-      if( !pTest ){\n+      if( pTest==0 ){\n@@ -190084,0 +196721,1 @@\n+    testcase( rc!=SQLITE_OK );\n@@ -190306,1 +196944,1 @@\n-    if( rc==SQLITE_OK ){\n+    if( ALWAYS(rc==SQLITE_OK) ){\n@@ -190412,1 +197050,1 @@\n-    rc = nodeAcquire(pRtree, iChild, pRoot, &pChild);\n+    rc = nodeAcquire(pRtree, iChild, pRoot, &pChild);  \/* tag-20210916a *\/\n@@ -190747,1 +197385,1 @@\n-  i64 nRow = 0;\n+  i64 nRow = RTREE_MIN_ROWEST;\n@@ -190764,10 +197402,0 @@\n-    }else if( rc!=SQLITE_NOMEM ){\n-      rc = SQLITE_OK;\n-    }\n-\n-    if( rc==SQLITE_OK ){\n-      if( nRow==0 ){\n-        pRtree->nRowEst = RTREE_DEFAULT_ROWEST;\n-      }else{\n-        pRtree->nRowEst = MAX(nRow, RTREE_MIN_ROWEST);\n-      }\n@@ -190777,1 +197405,1 @@\n-\n+  pRtree->nRowEst = MAX(nRow, RTREE_MIN_ROWEST);\n@@ -190927,0 +197555,1 @@\n+#ifdef SQLITE_ENABLE_GEOPOLY\n@@ -190929,1 +197558,3 @@\n-        }else{\n+        }else\n+#endif\n+        {\n@@ -191194,0 +197825,1 @@\n+  if( node.zData==0 ) return;\n@@ -191233,0 +197865,1 @@\n+\n@@ -191237,1 +197870,5 @@\n-    sqlite3_result_int(ctx, readInt16(zBlob));\n+    if( zBlob ){\n+      sqlite3_result_int(ctx, readInt16(zBlob));\n+    }else{\n+      sqlite3_result_error_nomem(ctx);\n+    }\n@@ -191603,0 +198240,3 @@\n+    }else\n+    if( check.rc!=SQLITE_NOMEM ){\n+      check.rc = SQLITE_OK;\n@@ -191604,1 +198244,0 @@\n-    check.rc = SQLITE_OK;\n@@ -192018,0 +198657,1 @@\n+  testcase( pCtx==0 );\n@@ -192023,0 +198663,4 @@\n+    if( a==0 ){\n+      if( pCtx ) sqlite3_result_error_nomem(pCtx);\n+      return 0;\n+    }\n@@ -192396,0 +199040,2 @@\n+  }else if( aCoord ){\n+    memset(aCoord, 0, sizeof(RtreeCoord)*4);\n@@ -192786,1 +199432,1 @@\n-  rX = pThisEvent->x==0.0 ? -1.0 : 0.0;\n+  rX = pThisEvent && pThisEvent->x==0.0 ? -1.0 : 0.0;\n@@ -192845,1 +199491,1 @@\n-        pActive = pActive->pNext;\n+        pActive = ALWAYS(pActive) ? pActive->pNext : 0;\n@@ -192849,1 +199495,1 @@\n-            pSeg->pNext = pSeg->pNext->pNext;\n+            pSeg->pNext = ALWAYS(pSeg->pNext) ? pSeg->pNext->pNext : 0;\n@@ -193093,0 +199739,1 @@\n+      assert( argv[0]!=0 );\n@@ -193320,0 +199967,1 @@\n+    assert( aData[2]!=0 );\n@@ -193673,1 +200321,4 @@\n-  if( !pGeomCtx ) return SQLITE_NOMEM;\n+  if( !pGeomCtx ){\n+    if( xDestructor ) xDestructor(pContext);\n+    return SQLITE_NOMEM;\n+  }\n@@ -195244,0 +201895,7 @@\n+\/*\n+** Name of the URI option that causes RBU to take an exclusive lock as\n+** part of the incremental checkpoint operation.\n+*\/\n+#define RBU_EXCLUSIVE_CHECKPOINT \"rbu_exclusive_checkpoint\"\n+\n+\n@@ -196109,1 +202767,1 @@\n-      \"FROM sqlite_master \"\n+      \"FROM sqlite_schema \"\n@@ -196118,1 +202776,1 @@\n-        \"  FROM main.sqlite_master \"\n+        \"  FROM main.sqlite_schema \"\n@@ -196290,1 +202948,1 @@\n-**   if( no entry exists in sqlite_master ){\n+**   if( no entry exists in sqlite_schema ){\n@@ -196295,1 +202953,1 @@\n-**     if( the index that is the pk exists in sqlite_master ){\n+**     if( the index that is the pk exists in sqlite_schema ){\n@@ -196315,1 +202973,1 @@\n-  ** 0) SELECT count(*) FROM sqlite_master where name=%Q AND IsVirtual(%Q)\n+  ** 0) SELECT count(*) FROM sqlite_schema where name=%Q AND IsVirtual(%Q)\n@@ -196317,1 +202975,1 @@\n-  ** 2) SELECT count(*) FROM sqlite_master where name=%Q\n+  ** 2) SELECT count(*) FROM sqlite_schema where name=%Q\n@@ -196328,2 +202986,4 @@\n-          \"SELECT (sql LIKE 'create virtual%%'), rootpage\"\n-          \"  FROM sqlite_master\"\n+          \"SELECT \"\n+          \" (sql COLLATE nocase BETWEEN 'CREATE VIRTUAL' AND 'CREATE VIRTUAM'),\"\n+          \" rootpage\"\n+          \"  FROM sqlite_schema\"\n@@ -196352,1 +203012,1 @@\n-            \"SELECT rootpage FROM sqlite_master WHERE name = %Q\", zIdx\n+            \"SELECT rootpage FROM sqlite_schema WHERE name = %Q\", zIdx\n@@ -196754,1 +203414,3 @@\n-        if( zQuoted[0]=='N' ){\n+        if( zQuoted==0 ){\n+          p->rc = SQLITE_NOMEM;\n+        }else if( zQuoted[0]=='N' ){\n@@ -197172,1 +203834,1 @@\n-        \"SELECT name FROM sqlite_master WHERE rootpage = ?\"\n+        \"SELECT name FROM sqlite_schema WHERE rootpage = ?\"\n@@ -197345,1 +204007,1 @@\n-        \"SELECT trim(sql) FROM sqlite_master WHERE type='index' AND name=?\"\n+        \"SELECT trim(sql) FROM sqlite_schema WHERE type='index' AND name=?\"\n@@ -197859,1 +204521,1 @@\n-        pRet->iOalSz = (u32)sqlite3_column_int64(pStmt, 1);\n+        pRet->iOalSz = sqlite3_column_int64(pStmt, 1);\n@@ -197886,0 +204548,4 @@\n+**\n+** If argument dbMain is not NULL, then it is a database handle already\n+** open on the target database. Use this handle instead of opening a new\n+** one.\n@@ -197887,1 +204553,1 @@\n-static void rbuOpenDatabase(sqlite3rbu *p, int *pbRetry){\n+static void rbuOpenDatabase(sqlite3rbu *p, sqlite3 *dbMain, int *pbRetry){\n@@ -197890,0 +204556,1 @@\n+  assert( dbMain==0 || rbuIsVacuum(p)==0 );\n@@ -197893,0 +204560,1 @@\n+  p->dbMain = dbMain;\n@@ -197927,1 +204595,1 @@\n-          \"SELECT count(*) FROM stat.sqlite_master\"\n+          \"SELECT count(*) FROM stat.sqlite_schema\"\n@@ -198031,1 +204699,1 @@\n-  rbuMPrintfExec(p, p->dbMain, \"SELECT * FROM sqlite_master\");\n+  rbuMPrintfExec(p, p->dbMain, \"SELECT * FROM sqlite_schema\");\n@@ -198124,1 +204792,1 @@\n-      p->rc = sqlite3_exec(p->dbMain, \"SELECT * FROM sqlite_master\", 0, 0, 0);\n+      p->rc = sqlite3_exec(p->dbMain, \"SELECT * FROM sqlite_schema\", 0, 0, 0);\n@@ -198258,1 +204926,2 @@\n-** Take an EXCLUSIVE lock on the database file.\n+** Take an EXCLUSIVE lock on the database file. Return SQLITE_OK if\n+** successful, or an SQLite error code otherwise.\n@@ -198260,6 +204929,10 @@\n-static void rbuLockDatabase(sqlite3rbu *p){\n-  sqlite3_file *pReal = p->pTargetFd->pReal;\n-  assert( p->rc==SQLITE_OK );\n-  p->rc = pReal->pMethods->xLock(pReal, SQLITE_LOCK_SHARED);\n-  if( p->rc==SQLITE_OK ){\n-    p->rc = pReal->pMethods->xLock(pReal, SQLITE_LOCK_EXCLUSIVE);\n+static int rbuLockDatabase(sqlite3 *db){\n+  int rc = SQLITE_OK;\n+  sqlite3_file *fd = 0;\n+  sqlite3_file_control(db, \"main\", SQLITE_FCNTL_FILE_POINTER, &fd);\n+\n+  if( fd->pMethods ){\n+    rc = fd->pMethods->xLock(fd, SQLITE_LOCK_SHARED);\n+    if( rc==SQLITE_OK ){\n+      rc = fd->pMethods->xLock(fd, SQLITE_LOCK_EXCLUSIVE);\n+    }\n@@ -198267,0 +204940,11 @@\n+  return rc;\n+}\n+\n+\/*\n+** Return true if the database handle passed as the only argument\n+** was opened with the rbu_exclusive_checkpoint=1 URI parameter\n+** specified. Or false otherwise.\n+*\/\n+static int rbuExclusiveCheckpoint(sqlite3 *db){\n+  const char *zUri = sqlite3_db_filename(db, 0);\n+  return sqlite3_uri_boolean(zUri, RBU_EXCLUSIVE_CHECKPOINT, 0);\n@@ -198324,4 +205008,10 @@\n-    rbuLockDatabase(p);\n-    if( p->rc==SQLITE_OK ){\n-      rbuFileSuffix3(zBase, zWal);\n-      rbuFileSuffix3(zBase, zOal);\n+    sqlite3 *dbMain = 0;\n+    rbuFileSuffix3(zBase, zWal);\n+    rbuFileSuffix3(zBase, zOal);\n+\n+    \/* Re-open the databases. *\/\n+    rbuObjIterFinalize(&p->objiter);\n+    sqlite3_close(p->dbRbu);\n+    sqlite3_close(p->dbMain);\n+    p->dbMain = 0;\n+    p->dbRbu = 0;\n@@ -198329,6 +205019,5 @@\n-      \/* Re-open the databases. *\/\n-      rbuObjIterFinalize(&p->objiter);\n-      sqlite3_close(p->dbRbu);\n-      sqlite3_close(p->dbMain);\n-      p->dbMain = 0;\n-      p->dbRbu = 0;\n+    dbMain = rbuOpenDbhandle(p, p->zTarget, 1);\n+    if( dbMain ){\n+      assert( p->rc==SQLITE_OK );\n+      p->rc = rbuLockDatabase(dbMain);\n+    }\n@@ -198336,0 +205025,1 @@\n+    if( p->rc==SQLITE_OK ){\n@@ -198362,0 +205052,1 @@\n+    }\n@@ -198363,4 +205054,11 @@\n-      if( p->rc==SQLITE_OK ){\n-        rbuOpenDatabase(p, 0);\n-        rbuSetupCheckpoint(p, 0);\n-      }\n+    if( p->rc!=SQLITE_OK\n+     || rbuIsVacuum(p)\n+     || rbuExclusiveCheckpoint(dbMain)==0\n+    ){\n+      sqlite3_close(dbMain);\n+      dbMain = 0;\n+    }\n+\n+    if( p->rc==SQLITE_OK ){\n+      rbuOpenDatabase(p, dbMain, 0);\n+      rbuSetupCheckpoint(p, 0);\n@@ -198715,1 +205413,1 @@\n-      \"SELECT sql FROM sqlite_master WHERE sql!='' AND rootpage!=0\"\n+      \"SELECT sql FROM sqlite_schema WHERE sql!='' AND rootpage!=0\"\n@@ -198730,1 +205428,1 @@\n-        \"SELECT * FROM sqlite_master WHERE rootpage=0 OR rootpage IS NULL\"\n+        \"SELECT * FROM sqlite_schema WHERE rootpage=0 OR rootpage IS NULL\"\n@@ -198736,1 +205434,1 @@\n-        \"INSERT INTO sqlite_master VALUES(?,?,?,?,?)\"\n+        \"INSERT INTO sqlite_schema VALUES(?,?,?,?,?)\"\n@@ -198999,1 +205697,1 @@\n-      sqlite3_mprintf(\"SELECT count(*) FROM sqlite_master \"\n+      sqlite3_mprintf(\"SELECT count(*) FROM sqlite_schema \"\n@@ -199050,1 +205748,1 @@\n-          \"SELECT 1 FROM sqlite_master WHERE tbl_name = 'rbu_count'\"\n+          \"SELECT 1 FROM sqlite_schema WHERE tbl_name = 'rbu_count'\"\n@@ -199117,1 +205815,1 @@\n-      rbuOpenDatabase(p, &bRetry);\n+      rbuOpenDatabase(p, 0, &bRetry);\n@@ -199119,1 +205817,1 @@\n-        rbuOpenDatabase(p, 0);\n+        rbuOpenDatabase(p, 0, 0);\n@@ -199214,0 +205912,8 @@\n+        if( !rbuIsVacuum(p) && rbuExclusiveCheckpoint(p->dbMain) ){\n+          \/* If the rbu_exclusive_checkpoint=1 URI parameter was specified\n+          ** and an incremental checkpoint is being resumed, attempt an\n+          ** exclusive lock on the db file. If this fails, so be it.  *\/\n+          p->eStage = RBU_STAGE_DONE;\n+          rbuLockDatabase(p->dbMain);\n+          p->eStage = RBU_STAGE_CKPT;\n+        }\n@@ -199251,1 +205957,0 @@\n-  \/* TODO: Check that zTarget and zRbu are non-NULL *\/\n@@ -199962,5 +206667,8 @@\n-  if( pRbu && (pRbu->eStage==RBU_STAGE_OAL || pRbu->eStage==RBU_STAGE_MOVE) ){\n-    \/* Magic number 1 is the WAL_CKPT_LOCK lock. Preventing SQLite from\n-    ** taking this lock also prevents any checkpoints from occurring.\n-    ** todo: really, it's not clear why this might occur, as\n-    ** wal_autocheckpoint ought to be turned off.  *\/\n+  if( pRbu && (\n+       pRbu->eStage==RBU_STAGE_OAL\n+    || pRbu->eStage==RBU_STAGE_MOVE\n+    || pRbu->eStage==RBU_STAGE_DONE\n+  )){\n+    \/* Prevent SQLite from taking a shm-lock on the target file when it\n+    ** is supplying heap memory to the upper layer in place of *-shm\n+    ** segments. *\/\n@@ -199973,1 +206681,0 @@\n-\n@@ -199977,1 +206684,1 @@\n-        pRbu->mLock |= (1 << ofst);\n+        pRbu->mLock |= ((1<<n) - 1) << ofst;\n@@ -200124,7 +206831,2 @@\n-          \/* This call is to open a *-wal file. Intead, open the *-oal. This\n-          ** code ensures that the string passed to xOpen() is terminated by a\n-          ** pair of '\\0' bytes in case the VFS attempts to extract a URI\n-          ** parameter from it.  *\/\n-          const char *zBase = zName;\n-          size_t nCopy;\n-          char *zCopy;\n+          \/* This call is to open a *-wal file. Intead, open the *-oal. *\/\n+          size_t nOpen;\n@@ -200132,13 +206834,2 @@\n-            zBase = sqlite3_db_filename(pDb->pRbu->dbRbu, \"main\");\n-            zBase = sqlite3_filename_wal(zBase);\n-          }\n-          nCopy = strlen(zBase);\n-          zCopy = sqlite3_malloc64(nCopy+2);\n-          if( zCopy ){\n-            memcpy(zCopy, zBase, nCopy);\n-            zCopy[nCopy-3] = 'o';\n-            zCopy[nCopy] = '\\0';\n-            zCopy[nCopy+1] = '\\0';\n-            zOpen = (const char*)(pFd->zDel = zCopy);\n-          }else{\n-            rc = SQLITE_NOMEM;\n+            zOpen = sqlite3_db_filename(pDb->pRbu->dbRbu, \"main\");\n+            zOpen = sqlite3_filename_wal(zOpen);\n@@ -200146,0 +206837,2 @@\n+          nOpen = strlen(zOpen);\n+          ((char*)zOpen)[nOpen-3] = 'o';\n@@ -200466,0 +207159,9 @@\n+\/*\n+** The pager and btree modules arrange objects in memory so that there are\n+** always approximately 200 bytes of addressable memory following each page\n+** buffer. This way small buffer overreads caused by corrupt database pages\n+** do not cause undefined behaviour. This module pads each page buffer\n+** by the following number of bytes for the same purpose.\n+*\/\n+#define DBSTAT_PAGE_PADDING_BYTES 256\n+\n@@ -200533,1 +207235,1 @@\n-  DbPage *pPg;                    \/* Page content *\/\n+  u8 *aPg;                        \/* Page buffer from sqlite3_malloc() *\/\n@@ -200535,1 +207237,0 @@\n-\n@@ -200747,0 +207448,1 @@\n+  u8 *aPg = p->aPg;\n@@ -200748,1 +207450,0 @@\n-  sqlite3PagerUnref(p->pPg);\n@@ -200751,0 +207452,1 @@\n+  p->aPg = aPg;\n@@ -200755,1 +207457,4 @@\n-  sqlite3_reset(pCsr->pStmt);\n+  \/* In some circumstances, specifically if an OOM has occurred, the call\n+  ** to sqlite3_reset() may cause the pager to be reset (emptied). It is\n+  ** important that statClearPage() is called to free any page refs before\n+  ** this happens. dbsqlfuzz 9ed3e4e3816219d3509d711636c38542bf3f40b1. *\/\n@@ -200758,0 +207463,2 @@\n+    sqlite3_free(pCsr->aPage[i].aPg);\n+    pCsr->aPage[i].aPg = 0;\n@@ -200759,0 +207466,1 @@\n+  sqlite3_reset(pCsr->pStmt);\n@@ -200823,1 +207531,1 @@\n-  u8 *aData = sqlite3PagerGetData(p->pPg);\n+  u8 *aData = p->aPg;\n@@ -200894,1 +207602,1 @@\n-          if( iOff+nLocal>nUsable || nPayload>0x7fffffff ){\n+          if( iOff+nLocal+4>nUsable || nPayload>0x7fffffff ){\n@@ -200953,0 +207661,32 @@\n+\/*\n+** Load a copy of the page data for page iPg into the buffer belonging\n+** to page object pPg. Allocate the buffer if necessary. Return SQLITE_OK\n+** if successful, or an SQLite error code otherwise.\n+*\/\n+static int statGetPage(\n+  Btree *pBt,                     \/* Load page from this b-tree *\/\n+  u32 iPg,                        \/* Page number to load *\/\n+  StatPage *pPg                   \/* Load page into this object *\/\n+){\n+  int pgsz = sqlite3BtreeGetPageSize(pBt);\n+  DbPage *pDbPage = 0;\n+  int rc;\n+\n+  if( pPg->aPg==0 ){\n+    pPg->aPg = (u8*)sqlite3_malloc(pgsz + DBSTAT_PAGE_PADDING_BYTES);\n+    if( pPg->aPg==0 ){\n+      return SQLITE_NOMEM_BKPT;\n+    }\n+    memset(&pPg->aPg[pgsz], 0, DBSTAT_PAGE_PADDING_BYTES);\n+  }\n+\n+  rc = sqlite3PagerGet(sqlite3BtreePager(pBt), iPg, &pDbPage, 0);\n+  if( rc==SQLITE_OK ){\n+    const u8 *a = sqlite3PagerGetData(pDbPage);\n+    memcpy(pPg->aPg, a, pgsz);\n+    sqlite3PagerUnref(pDbPage);\n+  }\n+\n+  return rc;\n+}\n+\n@@ -200971,1 +207711,1 @@\n-  if( pCsr->aPage[0].pPg==0 ){\n+  if( pCsr->iPage<0 ){\n@@ -200983,1 +207723,1 @@\n-      rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg, 0);\n+      rc = statGetPage(pBt, iRoot, &pCsr->aPage[0]);\n@@ -201034,3 +207774,2 @@\n-      if( pCsr->iPage>0 ){\n-        pCsr->iPage--;\n-      }else if( pCsr->isAgg ){\n+      pCsr->iPage--;\n+      if( pCsr->isAgg && pCsr->iPage<0 ){\n@@ -201055,1 +207794,1 @@\n-    rc = sqlite3PagerGet(pPager, p[1].iPgno, &p[1].pPg, 0);\n+    rc = statGetPage(pBt, p[1].iPgno, &p[1]);\n@@ -201165,1 +207904,1 @@\n-        \"SELECT 'sqlite_master' AS name,1 AS rootpage,'table' AS type\"\n+        \"SELECT 'sqlite_schema' AS name,1 AS rootpage,'table' AS type\"\n@@ -201168,1 +207907,1 @@\n-        \" FROM \\\"%w\\\".sqlite_master WHERE rootpage!=0)\",\n+        \" FROM \\\"%w\\\".sqlite_schema WHERE rootpage!=0)\",\n@@ -201185,0 +207924,1 @@\n+    pCsr->iPage = -1;\n@@ -201758,0 +208498,1 @@\n+  int bEnableSize;                \/* True if changeset_size() enabled *\/\n@@ -201764,0 +208505,2 @@\n+  i64 nMalloc;                    \/* Number of bytes of data allocated *\/\n+  i64 nMaxChangesetSize;\n@@ -201806,0 +208549,1 @@\n+  int bSkipEmpty;                 \/* Skip noop UPDATE changes *\/\n@@ -202005,2 +208749,3 @@\n-  int op;                         \/* One of UPDATE, DELETE, INSERT *\/\n-  int bIndirect;                  \/* True if this change is \"indirect\" *\/\n+  u8 op;                          \/* One of UPDATE, DELETE, INSERT *\/\n+  u8 bIndirect;                   \/* True if this change is \"indirect\" *\/\n+  int nMaxSize;                   \/* Max size of eventual changeset record *\/\n@@ -202131,1 +208876,1 @@\n-          if( n ) memcpy(&aBuf[nVarint + 1], z, n);\n+          if( n>0 ) memcpy(&aBuf[nVarint + 1], z, n);\n@@ -202147,0 +208892,20 @@\n+\/*\n+** Allocate and return a pointer to a buffer nByte bytes in size. If\n+** pSession is not NULL, increase the sqlite3_session.nMalloc variable\n+** by the number of bytes allocated.\n+*\/\n+static void *sessionMalloc64(sqlite3_session *pSession, i64 nByte){\n+  void *pRet = sqlite3_malloc64(nByte);\n+  if( pSession ) pSession->nMalloc += sqlite3_msize(pRet);\n+  return pRet;\n+}\n+\n+\/*\n+** Free buffer pFree, which must have been allocated by an earlier\n+** call to sessionMalloc64(). If pSession is not NULL, decrease the\n+** sqlite3_session.nMalloc counter by the number of bytes freed.\n+*\/\n+static void sessionFree(sqlite3_session *pSession, void *pFree){\n+  if( pSession ) pSession->nMalloc -= sqlite3_msize(pFree);\n+  sqlite3_free(pFree);\n+}\n@@ -202614,1 +209379,5 @@\n-static int sessionGrowHash(int bPatchset, SessionTable *pTab){\n+static int sessionGrowHash(\n+  sqlite3_session *pSession,      \/* For memory accounting. May be NULL *\/\n+  int bPatchset,\n+  SessionTable *pTab\n+){\n@@ -202620,1 +209389,3 @@\n-    apNew = (SessionChange **)sqlite3_malloc64(sizeof(SessionChange *) * nNew);\n+    apNew = (SessionChange**)sessionMalloc64(\n+        pSession, sizeof(SessionChange*) * nNew\n+    );\n@@ -202641,1 +209412,1 @@\n-    sqlite3_free(pTab->apChange);\n+    sessionFree(pSession, pTab->apChange);\n@@ -202675,0 +209446,1 @@\n+  sqlite3_session *pSession,      \/* For memory accounting. May be NULL *\/\n@@ -202709,0 +209481,4 @@\n+      *pazCol = 0;\n+      *pabPK = 0;\n+      *pnCol = 0;\n+      if( pzTab ) *pzTab = 0;\n@@ -202714,1 +209490,7 @@\n-  if( !zPragma ) return SQLITE_NOMEM;\n+  if( !zPragma ){\n+    *pazCol = 0;\n+    *pabPK = 0;\n+    *pnCol = 0;\n+    if( pzTab ) *pzTab = 0;\n+    return SQLITE_NOMEM;\n+  }\n@@ -202718,1 +209500,7 @@\n-  if( rc!=SQLITE_OK ) return rc;\n+  if( rc!=SQLITE_OK ){\n+    *pazCol = 0;\n+    *pabPK = 0;\n+    *pnCol = 0;\n+    if( pzTab ) *pzTab = 0;\n+    return rc;\n+  }\n@@ -202729,1 +209517,1 @@\n-    pAlloc = sqlite3_malloc64(nByte);\n+    pAlloc = sessionMalloc64(pSession, nByte);\n@@ -202772,1 +209560,1 @@\n-    sqlite3_free(azCol);\n+    sessionFree(pSession, azCol);\n@@ -202794,1 +209582,1 @@\n-    pSession->rc = sessionTableInfo(pSession->db, pSession->zDb,\n+    pSession->rc = sessionTableInfo(pSession, pSession->db, pSession->zDb,\n@@ -202808,0 +209596,6 @@\n+\n+      if( pSession->bEnableSize ){\n+        pSession->nMaxChangesetSize += (\n+          1 + sessionVarintLen(pTab->nCol) + pTab->nCol + strlen(pTab->zName)+1\n+        );\n+      }\n@@ -202853,0 +209647,97 @@\n+static int sessionUpdateMaxSize(\n+  int op,\n+  sqlite3_session *pSession,      \/* Session object pTab is attached to *\/\n+  SessionTable *pTab,             \/* Table that change applies to *\/\n+  SessionChange *pC               \/* Update pC->nMaxSize *\/\n+){\n+  i64 nNew = 2;\n+  if( pC->op==SQLITE_INSERT ){\n+    if( op!=SQLITE_DELETE ){\n+      int ii;\n+      for(ii=0; ii<pTab->nCol; ii++){\n+        sqlite3_value *p = 0;\n+        pSession->hook.xNew(pSession->hook.pCtx, ii, &p);\n+        sessionSerializeValue(0, p, &nNew);\n+      }\n+    }\n+  }else if( op==SQLITE_DELETE ){\n+    nNew += pC->nRecord;\n+    if( sqlite3_preupdate_blobwrite(pSession->db)>=0 ){\n+      nNew += pC->nRecord;\n+    }\n+  }else{\n+    int ii;\n+    u8 *pCsr = pC->aRecord;\n+    for(ii=0; ii<pTab->nCol; ii++){\n+      int bChanged = 1;\n+      int nOld = 0;\n+      int eType;\n+      sqlite3_value *p = 0;\n+      pSession->hook.xNew(pSession->hook.pCtx, ii, &p);\n+      if( p==0 ){\n+        return SQLITE_NOMEM;\n+      }\n+\n+      eType = *pCsr++;\n+      switch( eType ){\n+        case SQLITE_NULL:\n+          bChanged = sqlite3_value_type(p)!=SQLITE_NULL;\n+          break;\n+\n+        case SQLITE_FLOAT:\n+        case SQLITE_INTEGER: {\n+          if( eType==sqlite3_value_type(p) ){\n+            sqlite3_int64 iVal = sessionGetI64(pCsr);\n+            if( eType==SQLITE_INTEGER ){\n+              bChanged = (iVal!=sqlite3_value_int64(p));\n+            }else{\n+              double dVal;\n+              memcpy(&dVal, &iVal, 8);\n+              bChanged = (dVal!=sqlite3_value_double(p));\n+            }\n+          }\n+          nOld = 8;\n+          pCsr += 8;\n+          break;\n+        }\n+\n+        default: {\n+          int nByte;\n+          nOld = sessionVarintGet(pCsr, &nByte);\n+          pCsr += nOld;\n+          nOld += nByte;\n+          assert( eType==SQLITE_TEXT || eType==SQLITE_BLOB );\n+          if( eType==sqlite3_value_type(p)\n+           && nByte==sqlite3_value_bytes(p)\n+           && (nByte==0 || 0==memcmp(pCsr, sqlite3_value_blob(p), nByte))\n+          ){\n+            bChanged = 0;\n+          }\n+          pCsr += nByte;\n+          break;\n+        }\n+      }\n+\n+      if( bChanged && pTab->abPK[ii] ){\n+        nNew = pC->nRecord + 2;\n+        break;\n+      }\n+\n+      if( bChanged ){\n+        nNew += 1 + nOld;\n+        sessionSerializeValue(0, p, &nNew);\n+      }else if( pTab->abPK[ii] ){\n+        nNew += 2 + nOld;\n+      }else{\n+        nNew += 2;\n+      }\n+    }\n+  }\n+\n+  if( nNew>pC->nMaxSize ){\n+    int nIncr = nNew - pC->nMaxSize;\n+    pC->nMaxSize = nNew;\n+    pSession->nMaxChangesetSize += nIncr;\n+  }\n+  return SQLITE_OK;\n+}\n@@ -202885,1 +209776,1 @@\n-  if( sessionGrowHash(0, pTab) ){\n+  if( sessionGrowHash(pSession, 0, pTab) ){\n@@ -202926,1 +209817,0 @@\n-      SessionChange *pChange; \/* New change object *\/\n@@ -202952,2 +209842,2 @@\n-      pChange = (SessionChange *)sqlite3_malloc64(nByte);\n-      if( !pChange ){\n+      pC = (SessionChange *)sessionMalloc64(pSession, nByte);\n+      if( !pC ){\n@@ -202957,2 +209847,2 @@\n-        memset(pChange, 0, sizeof(SessionChange));\n-        pChange->aRecord = (u8 *)&pChange[1];\n+        memset(pC, 0, sizeof(SessionChange));\n+        pC->aRecord = (u8 *)&pC[1];\n@@ -202973,1 +209863,1 @@\n-        sessionSerializeValue(&pChange->aRecord[nByte], p, &nByte);\n+        sessionSerializeValue(&pC->aRecord[nByte], p, &nByte);\n@@ -202978,1 +209868,1 @@\n-        pChange->bIndirect = 1;\n+        pC->bIndirect = 1;\n@@ -202980,4 +209870,4 @@\n-      pChange->nRecord = nByte;\n-      pChange->op = op;\n-      pChange->pNext = pTab->apChange[iHash];\n-      pTab->apChange[iHash] = pChange;\n+      pC->nRecord = nByte;\n+      pC->op = op;\n+      pC->pNext = pTab->apChange[iHash];\n+      pTab->apChange[iHash] = pC;\n@@ -202994,0 +209884,5 @@\n+\n+    assert( rc==SQLITE_OK );\n+    if( pSession->bEnableSize ){\n+      rc = sessionUpdateMaxSize(op, pSession, pTab, pC);\n+    }\n@@ -202996,0 +209891,1 @@\n+\n@@ -203028,1 +209924,5 @@\n-        for(pRet=pSession->pTable; pRet->pNext; pRet=pRet->pNext);\n+        pRet = pSession->pTable;\n+        while( ALWAYS(pRet) && pRet->pNext ){\n+          pRet = pRet->pNext;\n+        }\n+        assert( pRet!=0 );\n@@ -203325,1 +210225,1 @@\n-      rc = sessionTableInfo(db, zFrom, zTbl, &nCol, 0, &azCol, &abPK);\n+      rc = sessionTableInfo(0, db, zFrom, zTbl, &nCol, 0, &azCol, &abPK);\n@@ -203423,1 +210323,1 @@\n-static void sessionDeleteTable(SessionTable *pList){\n+static void sessionDeleteTable(sqlite3_session *pSession, SessionTable *pList){\n@@ -203435,1 +210335,1 @@\n-        sqlite3_free(p);\n+        sessionFree(pSession, p);\n@@ -203438,3 +210338,3 @@\n-    sqlite3_free((char*)pTab->azCol);  \/* cast works around VC++ bug *\/\n-    sqlite3_free(pTab->apChange);\n-    sqlite3_free(pTab);\n+    sessionFree(pSession, (char*)pTab->azCol);  \/* cast works around VC++ bug *\/\n+    sessionFree(pSession, pTab->apChange);\n+    sessionFree(pSession, pTab);\n@@ -203468,1 +210368,1 @@\n-  sessionDeleteTable(pSession->pTable);\n+  sessionDeleteTable(pSession, pSession->pTable);\n@@ -203470,1 +210370,3 @@\n-  \/* Free the session object itself. *\/\n+  \/* Assert that all allocations have been freed and then free the\n+  ** session object itself. *\/\n+  assert( pSession->nMalloc==0 );\n@@ -203517,1 +210419,2 @@\n-      pTab = (SessionTable *)sqlite3_malloc64(sizeof(SessionTable) + nName + 1);\n+      int nByte = sizeof(SessionTable) + nName + 1;\n+      pTab = (SessionTable*)sessionMalloc64(pSession, nByte);\n@@ -203547,2 +210450,4 @@\n-static int sessionBufferGrow(SessionBuffer *p, size_t nByte, int *pRc){\n-  if( *pRc==SQLITE_OK && (size_t)(p->nAlloc-p->nBuf)<nByte ){\n+static int sessionBufferGrow(SessionBuffer *p, i64 nByte, int *pRc){\n+#define SESSION_MAX_BUFFER_SZ (0x7FFFFF00 - 1)\n+  i64 nReq = p->nBuf + nByte;\n+  if( *pRc==SQLITE_OK && nReq>p->nAlloc ){\n@@ -203551,0 +210456,1 @@\n+\n@@ -203553,1 +210459,14 @@\n-    }while( (size_t)(nNew-p->nBuf)<nByte );\n+    }while( nNew<nReq );\n+\n+    \/* The value of SESSION_MAX_BUFFER_SZ is copied from the implementation\n+    ** of sqlite3_realloc64(). Allocations greater than this size in bytes\n+    ** always fail. It is used here to ensure that this routine can always\n+    ** allocate up to this limit - instead of up to the largest power of\n+    ** two smaller than the limit.  *\/\n+    if( nNew>SESSION_MAX_BUFFER_SZ ){\n+      nNew = SESSION_MAX_BUFFER_SZ;\n+      if( nNew<nReq ){\n+        *pRc = SQLITE_NOMEM;\n+        return 1;\n+      }\n+    }\n@@ -203782,0 +210701,1 @@\n+  assert( abPK!=0 );\n@@ -204086,1 +211006,2 @@\n-  assert( xOutput==0 || (pnChangeset==0 && ppChangeset==0 ) );\n+  assert( xOutput==0 || (pnChangeset==0 && ppChangeset==0) );\n+  assert( xOutput!=0 || (pnChangeset!=0 && ppChangeset!=0) );\n@@ -204092,0 +211013,1 @@\n+    assert( pnChangeset!=0  && ppChangeset!=0 );\n@@ -204105,2 +211027,2 @@\n-      int nCol;                   \/* Number of columns in table *\/\n-      u8 *abPK;                   \/* Primary key array *\/\n+      int nCol = 0;               \/* Number of columns in table *\/\n+      u8 *abPK = 0;               \/* Primary key array *\/\n@@ -204114,1 +211036,1 @@\n-      rc = sessionTableInfo(db, pSession->zDb, zName, &nCol, 0, &azCol, &abPK);\n+      rc = sessionTableInfo(0, db, pSession->zDb, zName, &nCol, 0,&azCol,&abPK);\n@@ -204144,0 +211066,1 @@\n+              assert( abPK!=0 );  \/* Because sessionSelectStmt() returned ok *\/\n@@ -204204,1 +211127,8 @@\n-  return sessionGenerateChangeset(pSession, 0, 0, 0, pnChangeset, ppChangeset);\n+  int rc;\n+\n+  if( pnChangeset==0 || ppChangeset==0 ) return SQLITE_MISUSE;\n+  rc = sessionGenerateChangeset(pSession, 0, 0, 0, pnChangeset,ppChangeset);\n+  assert( rc || pnChangeset==0\n+       || pSession->bEnableSize==0 || *pnChangeset<=pSession->nMaxChangesetSize\n+  );\n+  return rc;\n@@ -204215,0 +211145,1 @@\n+  if( xOutput==0 ) return SQLITE_MISUSE;\n@@ -204226,0 +211157,1 @@\n+  if( xOutput==0 ) return SQLITE_MISUSE;\n@@ -204241,0 +211173,1 @@\n+  if( pnPatchset==0 || ppPatchset==0 ) return SQLITE_MISUSE;\n@@ -204289,0 +211222,40 @@\n+\/*\n+** Return the amount of heap memory in use.\n+*\/\n+SQLITE_API sqlite3_int64 sqlite3session_memory_used(sqlite3_session *pSession){\n+  return pSession->nMalloc;\n+}\n+\n+\/*\n+** Configure the session object passed as the first argument.\n+*\/\n+SQLITE_API int sqlite3session_object_config(sqlite3_session *pSession, int op, void *pArg){\n+  int rc = SQLITE_OK;\n+  switch( op ){\n+    case SQLITE_SESSION_OBJCONFIG_SIZE: {\n+      int iArg = *(int*)pArg;\n+      if( iArg>=0 ){\n+        if( pSession->pTable ){\n+          rc = SQLITE_MISUSE;\n+        }else{\n+          pSession->bEnableSize = (iArg!=0);\n+        }\n+      }\n+      *(int*)pArg = pSession->bEnableSize;\n+      break;\n+    }\n+\n+    default:\n+      rc = SQLITE_MISUSE;\n+  }\n+\n+  return rc;\n+}\n+\n+\/*\n+** Return the maximum size of sqlite3session_changeset() output.\n+*\/\n+SQLITE_API sqlite3_int64 sqlite3session_changeset_size(sqlite3_session *pSession){\n+  return pSession->nMaxChangesetSize;\n+}\n+\n@@ -204298,1 +211271,2 @@\n-  int bInvert                     \/* True to invert changeset *\/\n+  int bInvert,                    \/* True to invert changeset *\/\n+  int bSkipEmpty                  \/* True to skip empty UPDATE changes *\/\n@@ -204319,0 +211293,1 @@\n+  pRet->bSkipEmpty = bSkipEmpty;\n@@ -204333,1 +211308,1 @@\n-  return sessionChangesetStart(pp, 0, 0, nChangeset, pChangeset, 0);\n+  return sessionChangesetStart(pp, 0, 0, nChangeset, pChangeset, 0, 0);\n@@ -204342,1 +211317,1 @@\n-  return sessionChangesetStart(pp, 0, 0, nChangeset, pChangeset, bInvert);\n+  return sessionChangesetStart(pp, 0, 0, nChangeset, pChangeset, bInvert, 0);\n@@ -204353,1 +211328,1 @@\n-  return sessionChangesetStart(pp, xInput, pIn, 0, 0, 0);\n+  return sessionChangesetStart(pp, xInput, pIn, 0, 0, 0, 0);\n@@ -204362,1 +211337,1 @@\n-  return sessionChangesetStart(pp, xInput, pIn, 0, 0, bInvert);\n+  return sessionChangesetStart(pp, xInput, pIn, 0, 0, bInvert, 0);\n@@ -204488,1 +211463,2 @@\n-  sqlite3_value **apOut           \/* Write values to this array *\/\n+  sqlite3_value **apOut,          \/* Write values to this array *\/\n+  int *pbEmpty\n@@ -204493,0 +211469,2 @@\n+  assert( pbEmpty==0 || *pbEmpty==0 );\n+  if( pbEmpty ) *pbEmpty = 1;\n@@ -204504,0 +211482,1 @@\n+          if( pbEmpty ) *pbEmpty = 0;\n@@ -204672,2 +211651,7 @@\n-  p->abPK = (u8*)&p->apValue[p->nCol*2];\n-  p->zTab = (char*)&p->abPK[p->nCol];\n+  if( p->apValue==0 ){\n+    p->abPK = 0;\n+    p->zTab = 0;\n+  }else{\n+    p->abPK = (u8*)&p->apValue[p->nCol*2];\n+    p->zTab = p->abPK ? (char*)&p->abPK[p->nCol] : 0;\n+  }\n@@ -204678,5 +211662,2 @@\n-** Advance the changeset iterator to the next change.\n-**\n-** If both paRec and pnRec are NULL, then this function works like the public\n-** API sqlite3changeset_next(). If SQLITE_ROW is returned, then the\n-** sqlite3changeset_new() and old() APIs may be used to query for values.\n+** Advance the changeset iterator to the next change. The differences between\n+** this function and sessionChangesetNext() are that\n@@ -204684,3 +211665,2 @@\n-** Otherwise, if paRec and pnRec are not NULL, then a pointer to the change\n-** record is written to *paRec before returning and the number of bytes in\n-** the record to *pnRec.\n+**   * If pbEmpty is not NULL and the change is a no-op UPDATE (an UPDATE\n+**     that modifies no columns), this function sets (*pbEmpty) to 1.\n@@ -204688,4 +211668,2 @@\n-** Either way, this function returns SQLITE_ROW if the iterator is\n-** successfully advanced to the next change in the changeset, an SQLite\n-** error code if an error occurs, or SQLITE_DONE if there are no further\n-** changes in the changeset.\n+**   * If the iterator is configured to skip no-op UPDATEs,\n+**     sessionChangesetNext() does that. This function does not.\n@@ -204693,1 +211671,1 @@\n-static int sessionChangesetNext(\n+static int sessionChangesetNextOne(\n@@ -204697,1 +211675,2 @@\n-  int *pbNew                      \/* If non-NULL, true if new table *\/\n+  int *pbNew,                     \/* If non-NULL, true if new table *\/\n+  int *pbEmpty\n@@ -204703,0 +211682,1 @@\n+  assert( pbEmpty==0 || *pbEmpty==0 );\n@@ -204775,1 +211755,1 @@\n-      p->rc = sessionReadRecord(&p->in, p->nCol, abPK, apOld);\n+      p->rc = sessionReadRecord(&p->in, p->nCol, abPK, apOld, 0);\n@@ -204781,1 +211761,1 @@\n-      p->rc = sessionReadRecord(&p->in, p->nCol, 0, apNew);\n+      p->rc = sessionReadRecord(&p->in, p->nCol, 0, apNew, pbEmpty);\n@@ -204808,0 +211788,31 @@\n+\/*\n+** Advance the changeset iterator to the next change.\n+**\n+** If both paRec and pnRec are NULL, then this function works like the public\n+** API sqlite3changeset_next(). If SQLITE_ROW is returned, then the\n+** sqlite3changeset_new() and old() APIs may be used to query for values.\n+**\n+** Otherwise, if paRec and pnRec are not NULL, then a pointer to the change\n+** record is written to *paRec before returning and the number of bytes in\n+** the record to *pnRec.\n+**\n+** Either way, this function returns SQLITE_ROW if the iterator is\n+** successfully advanced to the next change in the changeset, an SQLite\n+** error code if an error occurs, or SQLITE_DONE if there are no further\n+** changes in the changeset.\n+*\/\n+static int sessionChangesetNext(\n+  sqlite3_changeset_iter *p,      \/* Changeset iterator *\/\n+  u8 **paRec,                     \/* If non-NULL, store record pointer here *\/\n+  int *pnRec,                     \/* If non-NULL, store size of record here *\/\n+  int *pbNew                      \/* If non-NULL, true if new table *\/\n+){\n+  int bEmpty;\n+  int rc;\n+  do {\n+    bEmpty = 0;\n+    rc = sessionChangesetNextOne(p, paRec, pnRec, pbNew, &bEmpty);\n+  }while( rc==SQLITE_ROW && p->bSkipEmpty && bEmpty);\n+  return rc;\n+}\n+\n@@ -205080,1 +212091,1 @@\n-        rc = sessionReadRecord(pInput, nCol, 0, &apVal[0]);\n+        rc = sessionReadRecord(pInput, nCol, 0, &apVal[0], 0);\n@@ -205082,1 +212093,1 @@\n-          rc = sessionReadRecord(pInput, nCol, 0, &apVal[nCol]);\n+          rc = sessionReadRecord(pInput, nCol, 0, &apVal[nCol], 0);\n@@ -205126,1 +212137,1 @@\n-  if( pnInverted ){\n+  if( pnInverted && ALWAYS(ppInverted) ){\n@@ -205130,1 +212141,1 @@\n-  }else if( sOut.nBuf>0 ){\n+  }else if( sOut.nBuf>0 && ALWAYS(xOutput!=0) ){\n@@ -205183,0 +212194,8 @@\n+\n+typedef struct SessionUpdate SessionUpdate;\n+struct SessionUpdate {\n+  sqlite3_stmt *pStmt;\n+  u32 *aMask;\n+  SessionUpdate *pNext;\n+};\n+\n@@ -205187,1 +212206,0 @@\n-  sqlite3_stmt *pUpdate;          \/* UPDATE statement *\/\n@@ -205193,0 +212211,2 @@\n+  u32 *aUpdateMask;               \/* Used by sessionUpdateFind *\/\n+  SessionUpdate *pUp;\n@@ -205195,0 +212215,1 @@\n+  int bInvertConstraints;         \/* Invert when iterating constraints buffer *\/\n@@ -205201,0 +212222,161 @@\n+\/* Number of prepared UPDATE statements to cache. *\/\n+#define SESSION_UPDATE_CACHE_SZ 12\n+\n+\/*\n+** Find a prepared UPDATE statement suitable for the UPDATE step currently\n+** being visited by the iterator. The UPDATE is of the form:\n+**\n+**   UPDATE tbl SET col = ?, col2 = ? WHERE pk1 IS ? AND pk2 IS ?\n+*\/\n+static int sessionUpdateFind(\n+  sqlite3_changeset_iter *pIter,\n+  SessionApplyCtx *p,\n+  int bPatchset,\n+  sqlite3_stmt **ppStmt\n+){\n+  int rc = SQLITE_OK;\n+  SessionUpdate *pUp = 0;\n+  int nCol = pIter->nCol;\n+  int nU32 = (pIter->nCol+33)\/32;\n+  int ii;\n+\n+  if( p->aUpdateMask==0 ){\n+    p->aUpdateMask = sqlite3_malloc(nU32*sizeof(u32));\n+    if( p->aUpdateMask==0 ){\n+      rc = SQLITE_NOMEM;\n+    }\n+  }\n+\n+  if( rc==SQLITE_OK ){\n+    memset(p->aUpdateMask, 0, nU32*sizeof(u32));\n+    rc = SQLITE_CORRUPT;\n+    for(ii=0; ii<pIter->nCol; ii++){\n+      if( sessionChangesetNew(pIter, ii) ){\n+        p->aUpdateMask[ii\/32] |= (1<<(ii%32));\n+        rc = SQLITE_OK;\n+      }\n+    }\n+  }\n+\n+  if( rc==SQLITE_OK ){\n+    if( bPatchset ) p->aUpdateMask[nCol\/32] |= (1<<(nCol%32));\n+\n+    if( p->pUp ){\n+      int nUp = 0;\n+      SessionUpdate **pp = &p->pUp;\n+      while( 1 ){\n+        nUp++;\n+        if( 0==memcmp(p->aUpdateMask, (*pp)->aMask, nU32*sizeof(u32)) ){\n+          pUp = *pp;\n+          *pp = pUp->pNext;\n+          pUp->pNext = p->pUp;\n+          p->pUp = pUp;\n+          break;\n+        }\n+\n+        if( (*pp)->pNext ){\n+          pp = &(*pp)->pNext;\n+        }else{\n+          if( nUp>=SESSION_UPDATE_CACHE_SZ ){\n+            sqlite3_finalize((*pp)->pStmt);\n+            sqlite3_free(*pp);\n+            *pp = 0;\n+          }\n+          break;\n+        }\n+      }\n+    }\n+\n+    if( pUp==0 ){\n+      int nByte = sizeof(SessionUpdate) * nU32*sizeof(u32);\n+      int bStat1 = (sqlite3_stricmp(pIter->zTab, \"sqlite_stat1\")==0);\n+      pUp = (SessionUpdate*)sqlite3_malloc(nByte);\n+      if( pUp==0 ){\n+        rc = SQLITE_NOMEM;\n+      }else{\n+        const char *zSep = \"\";\n+        SessionBuffer buf;\n+\n+        memset(&buf, 0, sizeof(buf));\n+        pUp->aMask = (u32*)&pUp[1];\n+        memcpy(pUp->aMask, p->aUpdateMask, nU32*sizeof(u32));\n+\n+        sessionAppendStr(&buf, \"UPDATE main.\", &rc);\n+        sessionAppendIdent(&buf, pIter->zTab, &rc);\n+        sessionAppendStr(&buf, \" SET \", &rc);\n+\n+        \/* Create the assignments part of the UPDATE *\/\n+        for(ii=0; ii<pIter->nCol; ii++){\n+          if( p->abPK[ii]==0 && sessionChangesetNew(pIter, ii) ){\n+            sessionAppendStr(&buf, zSep, &rc);\n+            sessionAppendIdent(&buf, p->azCol[ii], &rc);\n+            sessionAppendStr(&buf, \" = ?\", &rc);\n+            sessionAppendInteger(&buf, ii*2+1, &rc);\n+            zSep = \", \";\n+          }\n+        }\n+\n+        \/* Create the WHERE clause part of the UPDATE *\/\n+        zSep = \"\";\n+        sessionAppendStr(&buf, \" WHERE \", &rc);\n+        for(ii=0; ii<pIter->nCol; ii++){\n+          if( p->abPK[ii] || (bPatchset==0 && sessionChangesetOld(pIter, ii)) ){\n+            sessionAppendStr(&buf, zSep, &rc);\n+            if( bStat1 && ii==1 ){\n+              assert( sqlite3_stricmp(p->azCol[ii], \"idx\")==0 );\n+              sessionAppendStr(&buf,\n+                  \"idx IS CASE \"\n+                  \"WHEN length(?4)=0 AND typeof(?4)='blob' THEN NULL \"\n+                  \"ELSE ?4 END \", &rc\n+              );\n+            }else{\n+              sessionAppendIdent(&buf, p->azCol[ii], &rc);\n+              sessionAppendStr(&buf, \" IS ?\", &rc);\n+              sessionAppendInteger(&buf, ii*2+2, &rc);\n+            }\n+            zSep = \" AND \";\n+          }\n+        }\n+\n+        if( rc==SQLITE_OK ){\n+          char *zSql = (char*)buf.aBuf;\n+          rc = sqlite3_prepare_v2(p->db, zSql, buf.nBuf, &pUp->pStmt, 0);\n+        }\n+\n+        if( rc!=SQLITE_OK ){\n+          sqlite3_free(pUp);\n+          pUp = 0;\n+        }else{\n+          pUp->pNext = p->pUp;\n+          p->pUp = pUp;\n+        }\n+        sqlite3_free(buf.aBuf);\n+      }\n+    }\n+  }\n+\n+  assert( (rc==SQLITE_OK)==(pUp!=0) );\n+  if( pUp ){\n+    *ppStmt = pUp->pStmt;\n+  }else{\n+    *ppStmt = 0;\n+  }\n+  return rc;\n+}\n+\n+\/*\n+** Free all cached UPDATE statements.\n+*\/\n+static void sessionUpdateFree(SessionApplyCtx *p){\n+  SessionUpdate *pUp;\n+  SessionUpdate *pNext;\n+  for(pUp=p->pUp; pUp; pUp=pNext){\n+    pNext = pUp->pNext;\n+    sqlite3_finalize(pUp->pStmt);\n+    sqlite3_free(pUp);\n+  }\n+  p->pUp = 0;\n+  sqlite3_free(p->aUpdateMask);\n+  p->aUpdateMask = 0;\n+}\n+\n@@ -205270,97 +212452,0 @@\n-\/*\n-** Formulate and prepare a statement to UPDATE a row from database db.\n-** Assuming a table structure like this:\n-**\n-**     CREATE TABLE x(a, b, c, d, PRIMARY KEY(a, c));\n-**\n-** The UPDATE statement looks like this:\n-**\n-**     UPDATE x SET\n-**     a = CASE WHEN ?2  THEN ?3  ELSE a END,\n-**     b = CASE WHEN ?5  THEN ?6  ELSE b END,\n-**     c = CASE WHEN ?8  THEN ?9  ELSE c END,\n-**     d = CASE WHEN ?11 THEN ?12 ELSE d END\n-**     WHERE a = ?1 AND c = ?7 AND (?13 OR\n-**       (?5==0 OR b IS ?4) AND (?11==0 OR d IS ?10) AND\n-**     )\n-**\n-** For each column in the table, there are three variables to bind:\n-**\n-**     ?(i*3+1)    The old.* value of the column, if any.\n-**     ?(i*3+2)    A boolean flag indicating that the value is being modified.\n-**     ?(i*3+3)    The new.* value of the column, if any.\n-**\n-** Also, a boolean flag that, if set to true, causes the statement to update\n-** a row even if the non-PK values do not match. This is required if the\n-** conflict-handler is invoked with CHANGESET_DATA and returns\n-** CHANGESET_REPLACE. This is variable \"?(nCol*3+1)\".\n-**\n-** If successful, SQLITE_OK is returned and SessionApplyCtx.pUpdate is left\n-** pointing to the prepared version of the SQL statement.\n-*\/\n-static int sessionUpdateRow(\n-  sqlite3 *db,                    \/* Database handle *\/\n-  const char *zTab,               \/* Table name *\/\n-  SessionApplyCtx *p              \/* Session changeset-apply context *\/\n-){\n-  int rc = SQLITE_OK;\n-  int i;\n-  const char *zSep = \"\";\n-  SessionBuffer buf = {0, 0, 0};\n-\n-  \/* Append \"UPDATE tbl SET \" *\/\n-  sessionAppendStr(&buf, \"UPDATE main.\", &rc);\n-  sessionAppendIdent(&buf, zTab, &rc);\n-  sessionAppendStr(&buf, \" SET \", &rc);\n-\n-  \/* Append the assignments *\/\n-  for(i=0; i<p->nCol; i++){\n-    sessionAppendStr(&buf, zSep, &rc);\n-    sessionAppendIdent(&buf, p->azCol[i], &rc);\n-    sessionAppendStr(&buf, \" = CASE WHEN ?\", &rc);\n-    sessionAppendInteger(&buf, i*3+2, &rc);\n-    sessionAppendStr(&buf, \" THEN ?\", &rc);\n-    sessionAppendInteger(&buf, i*3+3, &rc);\n-    sessionAppendStr(&buf, \" ELSE \", &rc);\n-    sessionAppendIdent(&buf, p->azCol[i], &rc);\n-    sessionAppendStr(&buf, \" END\", &rc);\n-    zSep = \", \";\n-  }\n-\n-  \/* Append the PK part of the WHERE clause *\/\n-  sessionAppendStr(&buf, \" WHERE \", &rc);\n-  for(i=0; i<p->nCol; i++){\n-    if( p->abPK[i] ){\n-      sessionAppendIdent(&buf, p->azCol[i], &rc);\n-      sessionAppendStr(&buf, \" = ?\", &rc);\n-      sessionAppendInteger(&buf, i*3+1, &rc);\n-      sessionAppendStr(&buf, \" AND \", &rc);\n-    }\n-  }\n-\n-  \/* Append the non-PK part of the WHERE clause *\/\n-  sessionAppendStr(&buf, \" (?\", &rc);\n-  sessionAppendInteger(&buf, p->nCol*3+1, &rc);\n-  sessionAppendStr(&buf, \" OR 1\", &rc);\n-  for(i=0; i<p->nCol; i++){\n-    if( !p->abPK[i] ){\n-      sessionAppendStr(&buf, \" AND (?\", &rc);\n-      sessionAppendInteger(&buf, i*3+2, &rc);\n-      sessionAppendStr(&buf, \"=0 OR \", &rc);\n-      sessionAppendIdent(&buf, p->azCol[i], &rc);\n-      sessionAppendStr(&buf, \" IS ?\", &rc);\n-      sessionAppendInteger(&buf, i*3+1, &rc);\n-      sessionAppendStr(&buf, \")\", &rc);\n-    }\n-  }\n-  sessionAppendStr(&buf, \")\", &rc);\n-\n-  if( rc==SQLITE_OK ){\n-    rc = sqlite3_prepare_v2(db, (char *)buf.aBuf, buf.nBuf, &p->pUpdate, 0);\n-  }\n-  sqlite3_free(buf.aBuf);\n-\n-  return rc;\n-}\n-\n-\n@@ -205447,11 +212532,0 @@\n-  if( rc==SQLITE_OK ){\n-    rc = sessionPrepare(db, &p->pUpdate,\n-        \"UPDATE main.sqlite_stat1 SET \"\n-        \"tbl = CASE WHEN ?2 THEN ?3 ELSE tbl END, \"\n-        \"idx = CASE WHEN ?5 THEN ?6 ELSE idx END, \"\n-        \"stat = CASE WHEN ?8 THEN ?9 ELSE stat END  \"\n-        \"WHERE tbl=?1 AND idx IS \"\n-        \"CASE WHEN length(?4)=0 AND typeof(?4)='blob' THEN NULL ELSE ?4 END \"\n-        \"AND (?10 OR ?8=0 OR stat IS ?7)\"\n-    );\n-  }\n@@ -205523,1 +212597,1 @@\n-      sqlite3_value *pVal;\n+      sqlite3_value *pVal = 0;\n@@ -205774,1 +212848,1 @@\n-  assert( p->pDelete && p->pUpdate && p->pInsert && p->pSelect );\n+  assert( p->pDelete && p->pInsert && p->pSelect );\n@@ -205814,0 +212888,4 @@\n+    sqlite3_stmt *pUp = 0;\n+    int bPatchset = (pbRetry==0 || pIter->bPatchset);\n+\n+    rc = sessionUpdateFind(pIter, p, bPatchset, &pUp);\n@@ -205819,4 +212897,2 @@\n-\n-      sqlite3_bind_int(p->pUpdate, i*3+2, !!pNew);\n-      if( pOld ){\n-        rc = sessionBindValue(p->pUpdate, i*3+1, pOld);\n+      if( p->abPK[i] || (bPatchset==0 && pOld) ){\n+        rc = sessionBindValue(pUp, i*2+2, pOld);\n@@ -205825,1 +212901,1 @@\n-        rc = sessionBindValue(p->pUpdate, i*3+3, pNew);\n+        rc = sessionBindValue(pUp, i*2+1, pNew);\n@@ -205828,3 +212904,0 @@\n-    if( rc==SQLITE_OK ){\n-      sqlite3_bind_int(p->pUpdate, nCol*3+1, pbRetry==0 || pIter->bPatchset);\n-    }\n@@ -205835,2 +212908,2 @@\n-    sqlite3_step(p->pUpdate);\n-    rc = sqlite3_reset(p->pUpdate);\n+    sqlite3_step(pUp);\n+    rc = sqlite3_reset(pUp);\n@@ -205967,1 +213040,3 @@\n-    rc = sessionChangesetStart(&pIter2, 0, 0, cons.nBuf, cons.aBuf, 0);\n+    rc = sessionChangesetStart(\n+        &pIter2, 0, 0, cons.nBuf, cons.aBuf, pApply->bInvertConstraints, 1\n+    );\n@@ -206034,0 +213109,1 @@\n+  sApply.bInvertConstraints = !!(flags & SQLITE_CHANGESETAPPLY_INVERT);\n@@ -206056,0 +213132,1 @@\n+      sessionUpdateFree(&sApply);\n@@ -206058,1 +213135,0 @@\n-      sqlite3_finalize(sApply.pUpdate);\n@@ -206063,1 +213139,0 @@\n-      sApply.pUpdate = 0;\n@@ -206091,1 +213166,1 @@\n-        rc = sessionTableInfo(\n+        rc = sessionTableInfo(0,\n@@ -206127,5 +213202,4 @@\n-            if((rc = sessionSelectRow(db, zTab, &sApply))\n-                || (rc = sessionUpdateRow(db, zTab, &sApply))\n-                || (rc = sessionDeleteRow(db, zTab, &sApply))\n-                || (rc = sessionInsertRow(db, zTab, &sApply))\n-              ){\n+            if( (rc = sessionSelectRow(db, zTab, &sApply))\n+             || (rc = sessionDeleteRow(db, zTab, &sApply))\n+             || (rc = sessionInsertRow(db, zTab, &sApply))\n+            ){\n@@ -206190,0 +213264,1 @@\n+  sessionUpdateFree(&sApply);\n@@ -206192,1 +213267,0 @@\n-  sqlite3_finalize(sApply.pUpdate);\n@@ -206223,2 +213297,2 @@\n-  int bInverse = !!(flags & SQLITE_CHANGESETAPPLY_INVERT);\n-  int rc = sessionChangesetStart(&pIter, 0, 0, nChangeset, pChangeset,bInverse);\n+  int bInv = !!(flags & SQLITE_CHANGESETAPPLY_INVERT);\n+  int rc = sessionChangesetStart(&pIter, 0, 0, nChangeset, pChangeset, bInv, 1);\n@@ -206282,1 +213356,1 @@\n-  int rc = sessionChangesetStart(&pIter, xInput, pIn, 0, 0, bInverse);\n+  int rc = sessionChangesetStart(&pIter, xInput, pIn, 0, 0, bInverse, 1);\n@@ -206570,1 +213644,1 @@\n-    if( sessionGrowHash(pIter->bPatchset, pTab) ){\n+    if( sessionGrowHash(0, pIter->bPatchset, pTab) ){\n@@ -206666,1 +213740,1 @@\n-    }else{\n+    }else if( ppOut ){\n@@ -206668,1 +213742,1 @@\n-      *pnOut = buf.nBuf;\n+      if( pnOut ) *pnOut = buf.nBuf;\n@@ -206756,1 +213830,1 @@\n-    sessionDeleteTable(pGrp->pList);\n+    sessionDeleteTable(0, pGrp->pList);\n@@ -206902,1 +213976,1 @@\n-        if( !pIter->abPK[i] ) bData = 1;\n+        if( !pIter->abPK[i] && a1[0] ) bData = 1;\n@@ -207068,1 +214142,1 @@\n-    }else{\n+    }else if( ppOut ){\n@@ -207157,1 +214231,1 @@\n-    sessionDeleteTable(p->grp.pList);\n+    sessionDeleteTable(0, p->grp.pList);\n@@ -207811,2 +214885,14 @@\n-#define ALWAYS(x) 1\n-#define NEVER(x) 0\n+\n+#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n+# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1\n+#endif\n+#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)\n+# define ALWAYS(X)      (1)\n+# define NEVER(X)       (0)\n+#elif !defined(NDEBUG)\n+# define ALWAYS(X)      ((X)?1:(assert(0),0))\n+# define NEVER(X)       ((X)?(assert(0),1):0)\n+#else\n+# define ALWAYS(X)      (X)\n+# define NEVER(X)       (X)\n+#endif\n@@ -207872,1 +214958,1 @@\n-#define fts5Memcmp(s1, s2, n) ((n)==0 ? 0 : memcmp((s1), (s2), (n)))\n+#define fts5Memcmp(s1, s2, n) ((n)<=0 ? 0 : memcmp((s1), (s2), (n)))\n@@ -207960,0 +215046,1 @@\n+  int ePattern;                   \/* FTS_PATTERN_XXX constant *\/\n@@ -207980,1 +215067,1 @@\n-#define FTS5_CURRENT_VERSION 4\n+#define FTS5_CURRENT_VERSION  4\n@@ -207986,4 +215073,3 @@\n-#define FTS5_DETAIL_FULL    0\n-#define FTS5_DETAIL_NONE    1\n-#define FTS5_DETAIL_COLUMNS 2\n-\n+#define FTS5_DETAIL_FULL      0\n+#define FTS5_DETAIL_NONE      1\n+#define FTS5_DETAIL_COLUMNS   2\n@@ -207991,0 +215077,3 @@\n+#define FTS5_PATTERN_NONE     0\n+#define FTS5_PATTERN_LIKE     65  \/* matches SQLITE_INDEX_CONSTRAINT_LIKE *\/\n+#define FTS5_PATTERN_GLOB     66  \/* matches SQLITE_INDEX_CONSTRAINT_GLOB *\/\n@@ -208208,0 +215297,3 @@\n+static void *sqlite3Fts5StructureRef(Fts5Index*);\n+static void sqlite3Fts5StructureRelease(void*);\n+static int sqlite3Fts5StructureTest(Fts5Index*, void*);\n@@ -208260,1 +215352,1 @@\n-static int sqlite3Fts5IndexIntegrityCheck(Fts5Index*, u64 cksum);\n+static int sqlite3Fts5IndexIntegrityCheck(Fts5Index*, u64 cksum, int bUseCksum);\n@@ -208330,2 +215422,1 @@\n-  Fts5Tokenizer**,\n-  fts5_tokenizer**,\n+  Fts5Config*,\n@@ -208415,1 +215506,1 @@\n-static int sqlite3Fts5StorageIntegrity(Fts5Storage *p);\n+static int sqlite3Fts5StorageIntegrity(Fts5Storage *p, int iArg);\n@@ -208460,0 +215551,1 @@\n+  int bPhraseToAnd,\n@@ -208465,0 +215557,7 @@\n+static int sqlite3Fts5ExprPattern(\n+  Fts5Config *pConfig,\n+  int bGlob,\n+  int iCol,\n+  const char *zText,\n+  Fts5Expr **pp\n+);\n@@ -208573,0 +215672,4 @@\n+static int sqlite3Fts5TokenizerPattern(\n+    int (*xCreate)(void*, const char**, int, Fts5Tokenizer**),\n+    Fts5Tokenizer *pTok\n+);\n@@ -208619,0 +215722,2 @@\n+\/* This file is automatically generated by Lemon from input grammar\n+** source file \"fts5parse.y\". *\/\n@@ -208643,2 +215748,0 @@\n-\/* #include <stdio.h> *\/\n-\/* #include <assert.h> *\/\n@@ -208674,5 +215777,20 @@\n-\/* These constants specify the various numeric values for terminal symbols\n-** in a format understandable to \"makeheaders\".  This section is blank unless\n-** \"lemon\" is run with the \"-m\" command-line option.\n-***************** Begin makeheaders token definitions *************************\/\n-\/**************** End makeheaders token definitions ***************************\/\n+\/* These constants specify the various numeric values for terminal symbols.\n+***************** Begin token definitions *************************************\/\n+#ifndef FTS5_OR\n+#define FTS5_OR                              1\n+#define FTS5_AND                             2\n+#define FTS5_NOT                             3\n+#define FTS5_TERM                            4\n+#define FTS5_COLON                           5\n+#define FTS5_MINUS                           6\n+#define FTS5_LCP                             7\n+#define FTS5_RCP                             8\n+#define FTS5_STRING                          9\n+#define FTS5_LP                             10\n+#define FTS5_RP                             11\n+#define FTS5_CARET                          12\n+#define FTS5_COMMA                          13\n+#define FTS5_PLUS                           14\n+#define FTS5_STAR                           15\n+#endif\n+\/**************** End token definitions ***************************************\/\n@@ -208959,0 +216077,1 @@\n+\/* #include <assert.h> *\/\n@@ -209375,1 +216494,1 @@\n-      assert( i>=0 && i<sizeof(fts5yy_action)\/sizeof(fts5yy_action[0]) );\n+      assert( i>=0 && i<(int)(sizeof(fts5yy_action)\/sizeof(fts5yy_action[0])) );\n@@ -209589,48 +216708,0 @@\n-#ifndef NDEBUG\n-  if( fts5yyTraceFILE && fts5yyruleno<(int)(sizeof(fts5yyRuleName)\/sizeof(fts5yyRuleName[0])) ){\n-    fts5yysize = fts5yyRuleInfoNRhs[fts5yyruleno];\n-    if( fts5yysize ){\n-      fprintf(fts5yyTraceFILE, \"%sReduce %d [%s]%s, pop back to state %d.\\n\",\n-        fts5yyTracePrompt,\n-        fts5yyruleno, fts5yyRuleName[fts5yyruleno],\n-        fts5yyruleno<fts5YYNRULE_WITH_ACTION ? \"\" : \" without external action\",\n-        fts5yymsp[fts5yysize].stateno);\n-    }else{\n-      fprintf(fts5yyTraceFILE, \"%sReduce %d [%s]%s.\\n\",\n-        fts5yyTracePrompt, fts5yyruleno, fts5yyRuleName[fts5yyruleno],\n-        fts5yyruleno<fts5YYNRULE_WITH_ACTION ? \"\" : \" without external action\");\n-    }\n-  }\n-#endif \/* NDEBUG *\/\n-\n-  \/* Check that the stack is large enough to grow by a single entry\n-  ** if the RHS of the rule is empty.  This ensures that there is room\n-  ** enough on the stack to push the LHS value *\/\n-  if( fts5yyRuleInfoNRhs[fts5yyruleno]==0 ){\n-#ifdef fts5YYTRACKMAXSTACKDEPTH\n-    if( (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm ){\n-      fts5yypParser->fts5yyhwm++;\n-      assert( fts5yypParser->fts5yyhwm == (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack));\n-    }\n-#endif\n-#if fts5YYSTACKDEPTH>0\n-    if( fts5yypParser->fts5yytos>=fts5yypParser->fts5yystackEnd ){\n-      fts5yyStackOverflow(fts5yypParser);\n-      \/* The call to fts5yyStackOverflow() above pops the stack until it is\n-      ** empty, causing the main parser loop to exit.  So the return value\n-      ** is never used and does not matter. *\/\n-      return 0;\n-    }\n-#else\n-    if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz-1] ){\n-      if( fts5yyGrowStack(fts5yypParser) ){\n-        fts5yyStackOverflow(fts5yypParser);\n-        \/* The call to fts5yyStackOverflow() above pops the stack until it is\n-        ** empty, causing the main parser loop to exit.  So the return value\n-        ** is never used and does not matter. *\/\n-        return 0;\n-      }\n-      fts5yymsp = fts5yypParser->fts5yytos;\n-    }\n-#endif\n-  }\n@@ -209939,1 +217010,2 @@\n-  do{\n+  while(1){ \/* Exit by \"break\" *\/\n+    assert( fts5yypParser->fts5yytos>=fts5yypParser->fts5yystack );\n@@ -209943,2 +217015,45 @@\n-      fts5yyact = fts5yy_reduce(fts5yypParser,fts5yyact-fts5YY_MIN_REDUCE,fts5yymajor,\n-                        fts5yyminor sqlite3Fts5ParserCTX_PARAM);\n+      unsigned int fts5yyruleno = fts5yyact - fts5YY_MIN_REDUCE; \/* Reduce by this rule *\/\n+#ifndef NDEBUG\n+      assert( fts5yyruleno<(int)(sizeof(fts5yyRuleName)\/sizeof(fts5yyRuleName[0])) );\n+      if( fts5yyTraceFILE ){\n+        int fts5yysize = fts5yyRuleInfoNRhs[fts5yyruleno];\n+        if( fts5yysize ){\n+          fprintf(fts5yyTraceFILE, \"%sReduce %d [%s]%s, pop back to state %d.\\n\",\n+            fts5yyTracePrompt,\n+            fts5yyruleno, fts5yyRuleName[fts5yyruleno],\n+            fts5yyruleno<fts5YYNRULE_WITH_ACTION ? \"\" : \" without external action\",\n+            fts5yypParser->fts5yytos[fts5yysize].stateno);\n+        }else{\n+          fprintf(fts5yyTraceFILE, \"%sReduce %d [%s]%s.\\n\",\n+            fts5yyTracePrompt, fts5yyruleno, fts5yyRuleName[fts5yyruleno],\n+            fts5yyruleno<fts5YYNRULE_WITH_ACTION ? \"\" : \" without external action\");\n+        }\n+      }\n+#endif \/* NDEBUG *\/\n+\n+      \/* Check that the stack is large enough to grow by a single entry\n+      ** if the RHS of the rule is empty.  This ensures that there is room\n+      ** enough on the stack to push the LHS value *\/\n+      if( fts5yyRuleInfoNRhs[fts5yyruleno]==0 ){\n+#ifdef fts5YYTRACKMAXSTACKDEPTH\n+        if( (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm ){\n+          fts5yypParser->fts5yyhwm++;\n+          assert( fts5yypParser->fts5yyhwm ==\n+                  (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack));\n+        }\n+#endif\n+#if fts5YYSTACKDEPTH>0\n+        if( fts5yypParser->fts5yytos>=fts5yypParser->fts5yystackEnd ){\n+          fts5yyStackOverflow(fts5yypParser);\n+          break;\n+        }\n+#else\n+        if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz-1] ){\n+          if( fts5yyGrowStack(fts5yypParser) ){\n+            fts5yyStackOverflow(fts5yypParser);\n+            break;\n+          }\n+        }\n+#endif\n+      }\n+      fts5yyact = fts5yy_reduce(fts5yypParser,fts5yyruleno,fts5yymajor,fts5yyminor sqlite3Fts5ParserCTX_PARAM);\n@@ -210000,5 +217115,4 @@\n-        while( fts5yypParser->fts5yytos >= fts5yypParser->fts5yystack\n-            && (fts5yyact = fts5yy_find_reduce_action(\n-                        fts5yypParser->fts5yytos->stateno,\n-                        fts5YYERRORSYMBOL)) > fts5YY_MAX_SHIFTREDUCE\n-        ){\n+        while( fts5yypParser->fts5yytos > fts5yypParser->fts5yystack ){\n+          fts5yyact = fts5yy_find_reduce_action(fts5yypParser->fts5yytos->stateno,\n+                                        fts5YYERRORSYMBOL);\n+          if( fts5yyact<=fts5YY_MAX_SHIFTREDUCE ) break;\n@@ -210007,1 +217121,1 @@\n-        if( fts5yypParser->fts5yytos < fts5yypParser->fts5yystack || fts5yymajor==0 ){\n+        if( fts5yypParser->fts5yytos <= fts5yypParser->fts5yystack || fts5yymajor==0 ){\n@@ -210057,1 +217171,1 @@\n-  }while( fts5yypParser->fts5yytos>fts5yypParser->fts5yystack );\n+  }\n@@ -210655,1 +217769,1 @@\n-  p = pApi->xGetAuxdata(pFts, 0);\n+  p = (Fts5Bm25Data*)pApi->xGetAuxdata(pFts, 0);\n@@ -210729,1 +217843,1 @@\n-  int rc = SQLITE_OK;             \/* Error code *\/\n+  int rc;                         \/* Error code *\/\n@@ -210761,10 +217875,2 @@\n-  \/* Determine the BM25 score for the current row. *\/\n-  for(i=0; rc==SQLITE_OK && i<pData->nPhrase; i++){\n-    score += pData->aIDF[i] * (\n-      ( aFreq[i] * (k1 + 1.0) ) \/\n-      ( aFreq[i] + k1 * (1 - b + b * D \/ pData->avgdl) )\n-    );\n-  }\n-\n-  \/* If no error has occurred, return the calculated score. Otherwise,\n-  ** throw an SQL exception.  *\/\n+  \/* Determine and return the BM25 score for the current row. Or, if an\n+  ** error has occurred, throw an exception. *\/\n@@ -210772,0 +217878,6 @@\n+    for(i=0; i<pData->nPhrase; i++){\n+      score += pData->aIDF[i] * (\n+          ( aFreq[i] * (k1 + 1.0) ) \/\n+          ( aFreq[i] + k1 * (1 - b + b * D \/ pData->avgdl) )\n+      );\n+    }\n@@ -210872,1 +217984,0 @@\n-  assert_nc( *pRc || nData>=0 );\n@@ -210982,1 +218093,1 @@\n-    int iVal;\n+    u32 iVal;\n@@ -210991,0 +218102,1 @@\n+      assert( iOff>=0 );\n@@ -210997,0 +218109,3 @@\n+      *piOff = iOff + ((iVal-2) & 0x7FFFFFFF);\n+    }else{\n+      *piOff = (iOff & (i64)0x7FFFFFFF<<32)+((iOff + (iVal-2)) & 0x7FFFFFFF);\n@@ -210998,1 +218113,0 @@\n-    *piOff = iOff + ((iVal-2) & 0x7FFFFFFF);\n@@ -211000,0 +218114,1 @@\n+    assert_nc( *piOff>=iOff );\n@@ -211038,5 +218153,9 @@\n-  static const i64 colmask = ((i64)(0x7FFFFFFF)) << 32;\n-  if( (iPos & colmask) != (*piPrev & colmask) ){\n-    pBuf->p[pBuf->n++] = 1;\n-    pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos>>32));\n-    *piPrev = (iPos & colmask);\n+  if( iPos>=*piPrev ){\n+    static const i64 colmask = ((i64)(0x7FFFFFFF)) << 32;\n+    if( (iPos & colmask) != (*piPrev & colmask) ){\n+      pBuf->p[pBuf->n++] = 1;\n+      pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos>>32));\n+      *piPrev = (iPos & colmask);\n+    }\n+    pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos-*piPrev)+2);\n+    *piPrev = iPos;\n@@ -211044,2 +218163,0 @@\n-  pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos-*piPrev)+2);\n-  *piPrev = iPos;\n@@ -211535,1 +218652,1 @@\n-              (const char**)azArg, (int)nArg, &pConfig->pTok, &pConfig->pTokApi,\n+              (const char**)azArg, (int)nArg, pConfig,\n@@ -211607,3 +218724,1 @@\n-  return sqlite3Fts5GetTokenizer(\n-      pGlobal, 0, 0, &pConfig->pTok, &pConfig->pTokApi, 0\n-  );\n+  return sqlite3Fts5GetTokenizer(pGlobal, 0, 0, pConfig, 0);\n@@ -211749,1 +218864,1 @@\n-  pRet->abUnindexed = (u8*)&pRet->azCol[nArg];\n+  pRet->abUnindexed = pRet->azCol ? (u8*)&pRet->azCol[nArg] : 0;\n@@ -211774,0 +218889,1 @@\n+      assert( zOne!=0 );\n@@ -211790,1 +218906,5 @@\n-          rc = fts5ConfigParseSpecial(pGlobal, pRet, zOne, zTwo?zTwo:\"\", pzErr);\n+          rc = fts5ConfigParseSpecial(pGlobal, pRet,\n+            ALWAYS(zOne)?zOne:\"\",\n+            zTwo?zTwo:\"\",\n+            pzErr\n+          );\n@@ -212301,0 +219421,1 @@\n+  int bPhraseToAnd;               \/* Convert \"a+b\" to \"a AND b\" *\/\n@@ -212307,0 +219428,1 @@\n+    assert( pParse->zErr==0 );\n@@ -212389,0 +219511,1 @@\n+  int bPhraseToAnd,\n@@ -212404,0 +219527,1 @@\n+  sParse.bPhraseToAnd = bPhraseToAnd;\n@@ -212446,0 +219570,1 @@\n+      pNew->bDesc = 0;\n@@ -212457,0 +219582,75 @@\n+\/*\n+** This function is only called when using the special 'trigram' tokenizer.\n+** Argument zText contains the text of a LIKE or GLOB pattern matched\n+** against column iCol. This function creates and compiles an FTS5 MATCH\n+** expression that will match a superset of the rows matched by the LIKE or\n+** GLOB. If successful, SQLITE_OK is returned. Otherwise, an SQLite error\n+** code.\n+*\/\n+static int sqlite3Fts5ExprPattern(\n+  Fts5Config *pConfig, int bGlob, int iCol, const char *zText, Fts5Expr **pp\n+){\n+  i64 nText = strlen(zText);\n+  char *zExpr = (char*)sqlite3_malloc64(nText*4 + 1);\n+  int rc = SQLITE_OK;\n+\n+  if( zExpr==0 ){\n+    rc = SQLITE_NOMEM;\n+  }else{\n+    char aSpec[3];\n+    int iOut = 0;\n+    int i = 0;\n+    int iFirst = 0;\n+\n+    if( bGlob==0 ){\n+      aSpec[0] = '_';\n+      aSpec[1] = '%';\n+      aSpec[2] = 0;\n+    }else{\n+      aSpec[0] = '*';\n+      aSpec[1] = '?';\n+      aSpec[2] = '[';\n+    }\n+\n+    while( i<=nText ){\n+      if( i==nText\n+       || zText[i]==aSpec[0] || zText[i]==aSpec[1] || zText[i]==aSpec[2]\n+      ){\n+        if( i-iFirst>=3 ){\n+          int jj;\n+          zExpr[iOut++] = '\"';\n+          for(jj=iFirst; jj<i; jj++){\n+            zExpr[iOut++] = zText[jj];\n+            if( zText[jj]=='\"' ) zExpr[iOut++] = '\"';\n+          }\n+          zExpr[iOut++] = '\"';\n+          zExpr[iOut++] = ' ';\n+        }\n+        if( zText[i]==aSpec[2] ){\n+          i += 2;\n+          if( zText[i-1]=='^' ) i++;\n+          while( i<nText && zText[i]!=']' ) i++;\n+        }\n+        iFirst = i+1;\n+      }\n+      i++;\n+    }\n+    if( iOut>0 ){\n+      int bAnd = 0;\n+      if( pConfig->eDetail!=FTS5_DETAIL_FULL ){\n+        bAnd = 1;\n+        if( pConfig->eDetail==FTS5_DETAIL_NONE ){\n+          iCol = pConfig->nCol;\n+        }\n+      }\n+      zExpr[iOut] = '\\0';\n+      rc = sqlite3Fts5ExprNew(pConfig, bAnd, iCol, zExpr, pp,pConfig->pzErrmsg);\n+    }else{\n+      *pp = 0;\n+    }\n+    sqlite3_free(zExpr);\n+  }\n+\n+  return rc;\n+}\n+\n@@ -212527,0 +219727,1 @@\n+  assert( pTerm );\n@@ -213594,2 +220795,2 @@\n-  while( pRoot->bNomatch ){\n-    assert( pRoot->bEof==0 && rc==SQLITE_OK );\n+  while( pRoot->bNomatch && rc==SQLITE_OK ){\n+    assert( pRoot->bEof==0 );\n@@ -213834,0 +221035,14 @@\n+static int parseGrowPhraseArray(Fts5Parse *pParse){\n+  if( (pParse->nPhrase % 8)==0 ){\n+    sqlite3_int64 nByte = sizeof(Fts5ExprPhrase*) * (pParse->nPhrase + 8);\n+    Fts5ExprPhrase **apNew;\n+    apNew = (Fts5ExprPhrase**)sqlite3_realloc64(pParse->apPhrase, nByte);\n+    if( apNew==0 ){\n+      pParse->rc = SQLITE_NOMEM;\n+      return SQLITE_NOMEM;\n+    }\n+    pParse->apPhrase = apNew;\n+  }\n+  return SQLITE_OK;\n+}\n+\n@@ -213869,10 +221084,3 @@\n-      if( (pParse->nPhrase % 8)==0 ){\n-        sqlite3_int64 nByte = sizeof(Fts5ExprPhrase*) * (pParse->nPhrase + 8);\n-        Fts5ExprPhrase **apNew;\n-        apNew = (Fts5ExprPhrase**)sqlite3_realloc64(pParse->apPhrase, nByte);\n-        if( apNew==0 ){\n-          pParse->rc = SQLITE_NOMEM;\n-          fts5ExprPhraseFree(sCtx.pPhrase);\n-          return 0;\n-        }\n-        pParse->apPhrase = apNew;\n+      if( parseGrowPhraseArray(pParse) ){\n+        fts5ExprPhraseFree(sCtx.pPhrase);\n+        return 0;\n@@ -213960,1 +221168,1 @@\n-  if( rc==SQLITE_OK ){\n+  if( rc==SQLITE_OK && ALWAYS(sCtx.pPhrase) ){\n@@ -214231,3 +221439,2 @@\n-    pParse->rc = SQLITE_ERROR;\n-    pParse->zErr = sqlite3_mprintf(\n-      \"fts5: column queries are not supported (detail=none)\"\n+    sqlite3Fts5ParseError(pParse,\n+        \"fts5: column queries are not supported (detail=none)\"\n@@ -214285,0 +221492,61 @@\n+\/*\n+** This function is used when parsing LIKE or GLOB patterns against\n+** trigram indexes that specify either detail=column or detail=none.\n+** It converts a phrase:\n+**\n+**     abc + def + ghi\n+**\n+** into an AND tree:\n+**\n+**     abc AND def AND ghi\n+*\/\n+static Fts5ExprNode *fts5ParsePhraseToAnd(\n+  Fts5Parse *pParse,\n+  Fts5ExprNearset *pNear\n+){\n+  int nTerm = pNear->apPhrase[0]->nTerm;\n+  int ii;\n+  int nByte;\n+  Fts5ExprNode *pRet;\n+\n+  assert( pNear->nPhrase==1 );\n+  assert( pParse->bPhraseToAnd );\n+\n+  nByte = sizeof(Fts5ExprNode) + nTerm*sizeof(Fts5ExprNode*);\n+  pRet = (Fts5ExprNode*)sqlite3Fts5MallocZero(&pParse->rc, nByte);\n+  if( pRet ){\n+    pRet->eType = FTS5_AND;\n+    pRet->nChild = nTerm;\n+    fts5ExprAssignXNext(pRet);\n+    pParse->nPhrase--;\n+    for(ii=0; ii<nTerm; ii++){\n+      Fts5ExprPhrase *pPhrase = (Fts5ExprPhrase*)sqlite3Fts5MallocZero(\n+          &pParse->rc, sizeof(Fts5ExprPhrase)\n+      );\n+      if( pPhrase ){\n+        if( parseGrowPhraseArray(pParse) ){\n+          fts5ExprPhraseFree(pPhrase);\n+        }else{\n+          pParse->apPhrase[pParse->nPhrase++] = pPhrase;\n+          pPhrase->nTerm = 1;\n+          pPhrase->aTerm[0].zTerm = sqlite3Fts5Strndup(\n+              &pParse->rc, pNear->apPhrase[0]->aTerm[ii].zTerm, -1\n+          );\n+          pRet->apChild[ii] = sqlite3Fts5ParseNode(pParse, FTS5_STRING,\n+              0, 0, sqlite3Fts5ParseNearset(pParse, 0, pPhrase)\n+          );\n+        }\n+      }\n+    }\n+\n+    if( pParse->rc ){\n+      sqlite3Fts5ParseNodeFree(pRet);\n+      pRet = 0;\n+    }else{\n+      sqlite3Fts5ParseNearsetFree(pNear);\n+    }\n+  }\n+\n+  return pRet;\n+}\n+\n@@ -214309,7 +221577,13 @@\n-    if( eType==FTS5_NOT ){\n-      nChild = 2;\n-    }else if( eType==FTS5_AND || eType==FTS5_OR ){\n-      nChild = 2;\n-      if( pLeft->eType==eType ) nChild += pLeft->nChild-1;\n-      if( pRight->eType==eType ) nChild += pRight->nChild-1;\n-    }\n+    if( eType==FTS5_STRING\n+     && pParse->bPhraseToAnd\n+     && pNear->apPhrase[0]->nTerm>1\n+    ){\n+      pRet = fts5ParsePhraseToAnd(pParse, pNear);\n+    }else{\n+      if( eType==FTS5_NOT ){\n+        nChild = 2;\n+      }else if( eType==FTS5_AND || eType==FTS5_OR ){\n+        nChild = 2;\n+        if( pLeft->eType==eType ) nChild += pLeft->nChild-1;\n+        if( pRight->eType==eType ) nChild += pRight->nChild-1;\n+      }\n@@ -214317,2 +221591,2 @@\n-    nByte = sizeof(Fts5ExprNode) + sizeof(Fts5ExprNode*)*(nChild-1);\n-    pRet = (Fts5ExprNode*)sqlite3Fts5MallocZero(&pParse->rc, nByte);\n+      nByte = sizeof(Fts5ExprNode) + sizeof(Fts5ExprNode*)*(nChild-1);\n+      pRet = (Fts5ExprNode*)sqlite3Fts5MallocZero(&pParse->rc, nByte);\n@@ -214320,11 +221594,12 @@\n-    if( pRet ){\n-      pRet->eType = eType;\n-      pRet->pNear = pNear;\n-      fts5ExprAssignXNext(pRet);\n-      if( eType==FTS5_STRING ){\n-        int iPhrase;\n-        for(iPhrase=0; iPhrase<pNear->nPhrase; iPhrase++){\n-          pNear->apPhrase[iPhrase]->pNode = pRet;\n-          if( pNear->apPhrase[iPhrase]->nTerm==0 ){\n-            pRet->xNext = 0;\n-            pRet->eType = FTS5_EOF;\n+      if( pRet ){\n+        pRet->eType = eType;\n+        pRet->pNear = pNear;\n+        fts5ExprAssignXNext(pRet);\n+        if( eType==FTS5_STRING ){\n+          int iPhrase;\n+          for(iPhrase=0; iPhrase<pNear->nPhrase; iPhrase++){\n+            pNear->apPhrase[iPhrase]->pNode = pRet;\n+            if( pNear->apPhrase[iPhrase]->nTerm==0 ){\n+              pRet->xNext = 0;\n+              pRet->eType = FTS5_EOF;\n+            }\n@@ -214332,1 +221607,0 @@\n-        }\n@@ -214334,15 +221608,13 @@\n-        if( pParse->pConfig->eDetail!=FTS5_DETAIL_FULL ){\n-          Fts5ExprPhrase *pPhrase = pNear->apPhrase[0];\n-          if( pNear->nPhrase!=1\n-           || pPhrase->nTerm>1\n-           || (pPhrase->nTerm>0 && pPhrase->aTerm[0].bFirst)\n-          ){\n-            assert( pParse->rc==SQLITE_OK );\n-            pParse->rc = SQLITE_ERROR;\n-            assert( pParse->zErr==0 );\n-            pParse->zErr = sqlite3_mprintf(\n-                \"fts5: %s queries are not supported (detail!=full)\",\n-                pNear->nPhrase==1 ? \"phrase\": \"NEAR\"\n-                );\n-            sqlite3_free(pRet);\n-            pRet = 0;\n+          if( pParse->pConfig->eDetail!=FTS5_DETAIL_FULL ){\n+            Fts5ExprPhrase *pPhrase = pNear->apPhrase[0];\n+            if( pNear->nPhrase!=1\n+                || pPhrase->nTerm>1\n+                || (pPhrase->nTerm>0 && pPhrase->aTerm[0].bFirst)\n+              ){\n+              sqlite3Fts5ParseError(pParse,\n+                  \"fts5: %s queries are not supported (detail!=full)\",\n+                  pNear->nPhrase==1 ? \"phrase\": \"NEAR\"\n+              );\n+              sqlite3_free(pRet);\n+              pRet = 0;\n+            }\n@@ -214350,0 +221622,3 @@\n+        }else{\n+          fts5ExprAddChildren(pRet, pLeft);\n+          fts5ExprAddChildren(pRet, pRight);\n@@ -214351,3 +221626,0 @@\n-      }else{\n-        fts5ExprAddChildren(pRet, pLeft);\n-        fts5ExprAddChildren(pRet, pRight);\n@@ -214431,0 +221703,1 @@\n+#ifdef SQLITE_TEST\n@@ -214574,2 +221847,11 @@\n-      int iCol = pNear->pColset->aiCol[0];\n-      zRet = fts5PrintfAppend(zRet, \"%s : \", pConfig->azCol[iCol]);\n+      int ii;\n+      Fts5Colset *pColset = pNear->pColset;\n+      if( pColset->nCol>1 ) zRet = fts5PrintfAppend(zRet, \"{\");\n+      for(ii=0; ii<pColset->nCol; ii++){\n+        zRet = fts5PrintfAppend(zRet, \"%s%s\",\n+            pConfig->azCol[pColset->aiCol[ii]], ii==pColset->nCol-1 ? \"\" : \" \"\n+        );\n+      }\n+      if( zRet ){\n+        zRet = fts5PrintfAppend(zRet, \"%s : \", pColset->nCol>1 ? \"}\" : \"\");\n+      }\n@@ -214698,1 +221980,1 @@\n-    rc = sqlite3Fts5ExprNew(pConfig, pConfig->nCol, zExpr, &pExpr, &zErr);\n+    rc = sqlite3Fts5ExprNew(pConfig, 0, pConfig->nCol, zExpr, &pExpr, &zErr);\n@@ -214788,0 +222070,1 @@\n+#endif \/* ifdef SQLITE_TEST *\/\n@@ -214794,0 +222077,1 @@\n+#ifdef SQLITE_TEST\n@@ -214811,0 +222095,4 @@\n+#else\n+  int rc = SQLITE_OK;\n+  UNUSED_PARAM2(pGlobal,db);\n+#endif\n@@ -214861,0 +222149,9 @@\n+\/*\n+** Clear the position lists associated with all phrases in the expression\n+** passed as the first argument. Argument bLive is true if the expression\n+** might be pointing to a real entry, otherwise it has just been reset.\n+**\n+** At present this function is only used for detail=col and detail=none\n+** fts5 tables. This implies that all phrases must be at most 1 token\n+** in size, as phrase matches are not supported without detail=full.\n+*\/\n@@ -214870,1 +222167,1 @@\n-      assert( pExpr->apExprPhrase[i]->nTerm==1 );\n+      assert( pExpr->apExprPhrase[i]->nTerm<=1 );\n@@ -215371,1 +222668,0 @@\n-    nIncr += p->nData;\n@@ -215404,0 +222700,1 @@\n+    u64 iDiff = (u64)iRowid - (u64)p->iRowid;\n@@ -215405,1 +222702,1 @@\n-    p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iRowid - p->iRowid);\n+    p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iDiff);\n@@ -215421,1 +222718,1 @@\n-      assert( iCol>=p->iCol );\n+      assert_nc( iCol>=p->iCol );\n@@ -216057,1 +223354,1 @@\n-  int iLeafOffset;                \/* Byte offset within current leaf *\/\n+  i64 iLeafOffset;                \/* Byte offset within current leaf *\/\n@@ -216226,2 +223523,5 @@\n-  int nCmp = MIN(pLeft->n, pRight->n);\n-  int res = fts5Memcmp(pLeft->p, pRight->p, nCmp);\n+  int nCmp, res;\n+  nCmp = MIN(pLeft->n, pRight->n);\n+  assert( nCmp<=0 || pLeft->p!=0 );\n+  assert( nCmp<=0 || pRight->p!=0 );\n+  res = fts5Memcmp(pLeft->p, pRight->p, nCmp);\n@@ -216323,0 +223623,1 @@\n+\n@@ -216447,0 +223748,52 @@\n+static void *sqlite3Fts5StructureRef(Fts5Index *p){\n+  fts5StructureRef(p->pStruct);\n+  return (void*)p->pStruct;\n+}\n+static void sqlite3Fts5StructureRelease(void *p){\n+  if( p ){\n+    fts5StructureRelease((Fts5Structure*)p);\n+  }\n+}\n+static int sqlite3Fts5StructureTest(Fts5Index *p, void *pStruct){\n+  if( p->pStruct!=(Fts5Structure*)pStruct ){\n+    return SQLITE_ABORT;\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Ensure that structure object (*pp) is writable.\n+**\n+** This function is a no-op if (*pRc) is not SQLITE_OK when it is called. If\n+** an error occurs, (*pRc) is set to an SQLite error code before returning.\n+*\/\n+static void fts5StructureMakeWritable(int *pRc, Fts5Structure **pp){\n+  Fts5Structure *p = *pp;\n+  if( *pRc==SQLITE_OK && p->nRef>1 ){\n+    i64 nByte = sizeof(Fts5Structure)+(p->nLevel-1)*sizeof(Fts5StructureLevel);\n+    Fts5Structure *pNew;\n+    pNew = (Fts5Structure*)sqlite3Fts5MallocZero(pRc, nByte);\n+    if( pNew ){\n+      int i;\n+      memcpy(pNew, p, nByte);\n+      for(i=0; i<p->nLevel; i++) pNew->aLevel[i].aSeg = 0;\n+      for(i=0; i<p->nLevel; i++){\n+        Fts5StructureLevel *pLvl = &pNew->aLevel[i];\n+        nByte = sizeof(Fts5StructureSegment) * pNew->aLevel[i].nSeg;\n+        pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(pRc, nByte);\n+        if( pLvl->aSeg==0 ){\n+          for(i=0; i<p->nLevel; i++){\n+            sqlite3_free(pNew->aLevel[i].aSeg);\n+          }\n+          sqlite3_free(pNew);\n+          return;\n+        }\n+        memcpy(pLvl->aSeg, p->aLevel[i].aSeg, nByte);\n+      }\n+      p->nRef--;\n+      pNew->nRef = 1;\n+    }\n+    *pp = pNew;\n+  }\n+}\n+\n@@ -216548,1 +223901,2 @@\n-**\n+** Add a level to the Fts5Structure.aLevel[] array of structure object\n+** (*ppStruct).\n@@ -216551,0 +223905,1 @@\n+  fts5StructureMakeWritable(pRc, ppStruct);\n@@ -217237,1 +224592,1 @@\n-  int iOff = pIter->iLeafOffset;\n+  i64 iOff = pIter->iLeafOffset;\n@@ -217270,1 +224625,1 @@\n-  int iOff = pIter->iLeafOffset;  \/* Offset to read at *\/\n+  i64 iOff = pIter->iLeafOffset;  \/* Offset to read at *\/\n@@ -217344,0 +224699,1 @@\n+    assert( pIter->pLeaf!=0 );\n@@ -217380,1 +224736,1 @@\n-    i64 iDelta = 0;\n+    u64 iDelta = 0;\n@@ -217395,1 +224751,1 @@\n-    i += fts5GetVarint(&a[i], (u64*)&iDelta);\n+    i += fts5GetVarint(&a[i], &iDelta);\n@@ -217446,2 +224802,6 @@\n-          pIter->pLeaf = pNew;\n-          pIter->iLeafOffset = iRowidOff;\n+          if( iRowidOff>=pNew->szLeaf ){\n+            p->rc = FTS5_CORRUPT;\n+          }else{\n+            pIter->pLeaf = pNew;\n+            pIter->iLeafOffset = iRowidOff;\n+          }\n@@ -217494,1 +224854,1 @@\n-    i64 iDelta;\n+    u64 iDelta;\n@@ -217503,1 +224863,1 @@\n-    fts5GetVarint(&a[iOff], (u64*)&iDelta);\n+    fts5GetVarint(&a[iOff], &iDelta);\n@@ -217696,5 +225056,1 @@\n-      ** code is inlined.\n-      **\n-      ** Later: Switched back to fts5SegIterLoadNPos() because it supports\n-      ** detail=none mode. Not ideal.\n-      *\/\n+      ** code is inlined.  *\/\n@@ -217702,2 +225058,1 @@\n-      assert( p->rc==SQLITE_OK );\n-      assert( pIter->iLeafOffset<=pIter->pLeaf->nn );\n+      assert_nc( pIter->iLeafOffset<=pIter->pLeaf->nn );\n@@ -217732,1 +225087,1 @@\n-    pLast = fts5DataRead(p, FTS5_SEGMENT_ROWID(iSegid, pgnoLast));\n+    pLast = fts5LeafRead(p, FTS5_SEGMENT_ROWID(iSegid, pgnoLast));\n@@ -217759,1 +225114,1 @@\n-        Fts5Data *pNew = fts5DataRead(p, iAbs);\n+        Fts5Data *pNew = fts5LeafRead(p, iAbs);\n@@ -217790,0 +225145,4 @@\n+    if( iOff>pLast->szLeaf ){\n+      p->rc = FTS5_CORRUPT;\n+      return;\n+    }\n@@ -217798,1 +225157,0 @@\n-\n@@ -217850,1 +225208,1 @@\n-  int iOff;\n+  u32 iOff;\n@@ -217852,2 +225210,1 @@\n-  int szLeaf = pIter->pLeaf->szLeaf;\n-  int n = pIter->pLeaf->nn;\n+  u32 n = (u32)pIter->pLeaf->nn;\n@@ -217859,1 +225216,1 @@\n-  int iPgidx;                     \/* Current offset in pgidx *\/\n+  u32 iPgidx;                     \/* Current offset in pgidx *\/\n@@ -217864,1 +225221,1 @@\n-  iPgidx = szLeaf;\n+  iPgidx = (u32)pIter->pLeaf->szLeaf;\n@@ -217930,1 +225287,1 @@\n-        iPgidx = pIter->pLeaf->szLeaf;\n+        iPgidx = (u32)pIter->pLeaf->szLeaf;\n@@ -217932,1 +225289,1 @@\n-        if( iOff<4 || iOff>=pIter->pLeaf->szLeaf ){\n+        if( iOff<4 || (i64)iOff>=pIter->pLeaf->szLeaf ){\n@@ -217938,1 +225295,1 @@\n-          n = pIter->pLeaf->nn;\n+          n = (u32)pIter->pLeaf->nn;\n@@ -217947,2 +225304,1 @@\n-  pIter->iLeafOffset = iOff + nNew;\n-  if( pIter->iLeafOffset>n || nNew<1 ){\n+  if( (i64)iOff+nNew>n || nNew<1 ){\n@@ -217952,0 +225308,1 @@\n+  pIter->iLeafOffset = iOff + nNew;\n@@ -218306,1 +225663,1 @@\n-    if( p->rc==SQLITE_OK ){\n+    if( p->rc==SQLITE_OK && ALWAYS(pIter->pLeaf!=0) ){\n@@ -218695,1 +226052,1 @@\n-  \/* This function does notmwork with detail=none databases. *\/\n+  \/* This function does not work with detail=none databases. *\/\n@@ -218708,0 +226065,3 @@\n+    }else if( pSeg->pSeg==0 ){\n+      p->rc = FTS5_CORRUPT;\n+      return;\n@@ -218735,0 +226095,2 @@\n+  assert( pBuf!=0 );\n+  assert( pSeg!=0 );\n@@ -218736,0 +226098,2 @@\n+    assert( pBuf->p!=0 );\n+    assert( pBuf->nSpace >= pBuf->n+pSeg->nPos+FTS5_DATA_ZERO_PADDING );\n@@ -218759,5 +226123,10 @@\n-** IN\/OUT parameter (*pa) points to a position list n bytes in size. If\n-** the position list contains entries for column iCol, then (*pa) is set\n-** to point to the sub-position-list for that column and the number of\n-** bytes in it returned. Or, if the argument position list does not\n-** contain any entries for column iCol, return 0.\n+** Parameter pPos points to a buffer containing a position list, size nPos.\n+** This function filters it according to pColset (which must be non-NULL)\n+** and sets pIter->base.pData\/nData to point to the new position list.\n+** If memory is required for the new position list, use buffer pIter->poslist.\n+** Or, if the new position list is a contiguous subset of the input, set\n+** pIter->base.pData\/nData to point directly to it.\n+**\n+** This function is a no-op if *pRc is other than SQLITE_OK when it is\n+** called. If an OOM error is encountered, *pRc is set to SQLITE_NOMEM\n+** before returning.\n@@ -218765,37 +226134,0 @@\n-static int fts5IndexExtractCol(\n-  const u8 **pa,                  \/* IN\/OUT: Pointer to poslist *\/\n-  int n,                          \/* IN: Size of poslist in bytes *\/\n-  int iCol                        \/* Column to extract from poslist *\/\n-){\n-  int iCurrent = 0;               \/* Anything before the first 0x01 is col 0 *\/\n-  const u8 *p = *pa;\n-  const u8 *pEnd = &p[n];         \/* One byte past end of position list *\/\n-\n-  while( iCol>iCurrent ){\n-    \/* Advance pointer p until it points to pEnd or an 0x01 byte that is\n-    ** not part of a varint. Note that it is not possible for a negative\n-    ** or extremely large varint to occur within an uncorrupted position\n-    ** list. So the last byte of each varint may be assumed to have a clear\n-    ** 0x80 bit.  *\/\n-    while( *p!=0x01 ){\n-      while( *p++ & 0x80 );\n-      if( p>=pEnd ) return 0;\n-    }\n-    *pa = p++;\n-    iCurrent = *p++;\n-    if( iCurrent & 0x80 ){\n-      p--;\n-      p += fts5GetVarint32(p, iCurrent);\n-    }\n-  }\n-  if( iCol!=iCurrent ) return 0;\n-\n-  \/* Advance pointer p until it points to pEnd or an 0x01 byte that is\n-  ** not part of a varint *\/\n-  while( p<pEnd && *p!=0x01 ){\n-    while( *p++ & 0x80 );\n-  }\n-\n-  return p - (*pa);\n-}\n-\n@@ -218806,1 +226138,1 @@\n-  Fts5Buffer *pBuf                \/* Output buffer *\/\n+  Fts5Iter *pIter\n@@ -218809,7 +226141,44 @@\n-    int i;\n-    fts5BufferZero(pBuf);\n-    for(i=0; i<pColset->nCol; i++){\n-      const u8 *pSub = pPos;\n-      int nSub = fts5IndexExtractCol(&pSub, nPos, pColset->aiCol[i]);\n-      if( nSub ){\n-        fts5BufferAppendBlob(pRc, pBuf, nSub, pSub);\n+    const u8 *p = pPos;\n+    const u8 *aCopy = p;\n+    const u8 *pEnd = &p[nPos];    \/* One byte past end of position list *\/\n+    int i = 0;\n+    int iCurrent = 0;\n+\n+    if( pColset->nCol>1 && sqlite3Fts5BufferSize(pRc, &pIter->poslist, nPos) ){\n+      return;\n+    }\n+\n+    while( 1 ){\n+      while( pColset->aiCol[i]<iCurrent ){\n+        i++;\n+        if( i==pColset->nCol ){\n+          pIter->base.pData = pIter->poslist.p;\n+          pIter->base.nData = pIter->poslist.n;\n+          return;\n+        }\n+      }\n+\n+      \/* Advance pointer p until it points to pEnd or an 0x01 byte that is\n+      ** not part of a varint *\/\n+      while( p<pEnd && *p!=0x01 ){\n+        while( *p++ & 0x80 );\n+      }\n+\n+      if( pColset->aiCol[i]==iCurrent ){\n+        if( pColset->nCol==1 ){\n+          pIter->base.pData = aCopy;\n+          pIter->base.nData = p-aCopy;\n+          return;\n+        }\n+        fts5BufferSafeAppendBlob(&pIter->poslist, aCopy, p-aCopy);\n+      }\n+      if( p>=pEnd ){\n+        pIter->base.pData = pIter->poslist.p;\n+        pIter->base.nData = pIter->poslist.n;\n+        return;\n+      }\n+      aCopy = p++;\n+      iCurrent = *p++;\n+      if( iCurrent & 0x80 ){\n+        p--;\n+        p += fts5GetVarint32(p, iCurrent);\n@@ -218819,0 +226188,1 @@\n+\n@@ -218938,10 +226308,3 @@\n-    if( pColset->nCol==1 ){\n-      pIter->base.nData = fts5IndexExtractCol(&a, pSeg->nPos,pColset->aiCol[0]);\n-      pIter->base.pData = a;\n-    }else{\n-      int *pRc = &pIter->pIndex->rc;\n-      fts5BufferZero(&pIter->poslist);\n-      fts5IndexExtractColset(pRc, pColset, a, pSeg->nPos, &pIter->poslist);\n-      pIter->base.pData = pIter->poslist.p;\n-      pIter->base.nData = pIter->poslist.n;\n-    }\n+    int *pRc = &pIter->pIndex->rc;\n+    fts5BufferZero(&pIter->poslist);\n+    fts5IndexExtractColset(pRc, pColset, a, pSeg->nPos, pIter);\n@@ -218960,0 +226323,1 @@\n+  assert( pIter!=0 || (*pRc)!=SQLITE_OK );\n@@ -219031,1 +226395,4 @@\n-  if( pNew==0 ) return;\n+  if( pNew==0 ){\n+    assert( p->rc!=SQLITE_OK );\n+    goto fts5MultiIterNew_post_check;\n+  }\n@@ -219095,0 +226462,4 @@\n+\n+fts5MultiIterNew_post_check:\n+  assert( (*ppOut)!=0 || p->rc!=SQLITE_OK );\n+  return;\n@@ -219142,1 +226513,2 @@\n-  assert( p->rc\n+  assert( pIter!=0 || p->rc!=SQLITE_OK );\n+  assert( p->rc!=SQLITE_OK\n@@ -219946,0 +227318,1 @@\n+  assert( pIter!=0 || p->rc!=SQLITE_OK );\n@@ -220046,1 +227419,1 @@\n-  if( p->rc==SQLITE_OK && p->pConfig->nAutomerge>0 ){\n+  if( p->rc==SQLITE_OK && p->pConfig->nAutomerge>0 && ALWAYS((*ppStruct)!=0) ){\n@@ -220169,1 +227542,1 @@\n-        i64 iDelta = 0;\n+        u64 iDelta = 0;\n@@ -220176,1 +227549,1 @@\n-          iOff += fts5GetVarint(&pDoclist[iOff], (u64*)&iDelta);\n+          iOff += fts5GetVarint(&pDoclist[iOff], &iDelta);\n@@ -220430,1 +227803,1 @@\n-  assert( pIter->aPoslist );\n+  assert( pIter->aPoslist || (p==0 && pIter->aPoslist==0) );\n@@ -220450,0 +227823,3 @@\n+    if( &pIter->aPoslist[pIter->nPoslist]>pIter->aEof ){\n+      pIter->aPoslist = 0;\n+    }\n@@ -220458,3 +227834,5 @@\n-  pIter->aPoslist = pBuf->p;\n-  pIter->aEof = &pBuf->p[pBuf->n];\n-  fts5DoclistIterNext(pIter);\n+  if( pBuf->n>0 ){\n+    pIter->aPoslist = pBuf->p;\n+    pIter->aEof = &pBuf->p[pBuf->n];\n+    fts5DoclistIterNext(pIter);\n+  }\n@@ -220514,1 +227892,2 @@\n-  Fts5Buffer *p2                  \/* Second list to merge *\/\n+  int nBuf,                       \/* Number of entries in apBuf[] *\/\n+  Fts5Buffer *aBuf                \/* Array of other lists to merge into p1 *\/\n@@ -220521,1 +227900,1 @@\n-\n+  Fts5Buffer *p2 = &aBuf[0];\n@@ -220523,0 +227902,2 @@\n+\n+  (void)nBuf;\n@@ -220524,0 +227905,1 @@\n+  assert( nBuf==1 );\n@@ -220550,0 +227932,38 @@\n+typedef struct PrefixMerger PrefixMerger;\n+struct PrefixMerger {\n+  Fts5DoclistIter iter;           \/* Doclist iterator *\/\n+  i64 iPos;                       \/* For iterating through a position list *\/\n+  int iOff;\n+  u8 *aPos;\n+  PrefixMerger *pNext;            \/* Next in docid\/poslist order *\/\n+};\n+\n+static void fts5PrefixMergerInsertByRowid(\n+  PrefixMerger **ppHead,\n+  PrefixMerger *p\n+){\n+  if( p->iter.aPoslist ){\n+    PrefixMerger **pp = ppHead;\n+    while( *pp && p->iter.iRowid>(*pp)->iter.iRowid ){\n+      pp = &(*pp)->pNext;\n+    }\n+    p->pNext = *pp;\n+    *pp = p;\n+  }\n+}\n+\n+static void fts5PrefixMergerInsertByPosition(\n+  PrefixMerger **ppHead,\n+  PrefixMerger *p\n+){\n+  if( p->iPos>=0 ){\n+    PrefixMerger **pp = ppHead;\n+    while( *pp && p->iPos>(*pp)->iPos ){\n+      pp = &(*pp)->pNext;\n+    }\n+    p->pNext = *pp;\n+    *pp = p;\n+  }\n+}\n+\n+\n@@ -220551,6 +227971,2 @@\n-** Buffers p1 and p2 contain doclists. This function merges the content\n-** of the two doclists together and sets buffer p1 to the result before\n-** returning.\n-**\n-** If an error occurs, an error code is left in p->rc. If an error has\n-** already occurred, this function is a no-op.\n+** Array aBuf[] contains nBuf doclists. These are all merged in with the\n+** doclist in buffer p1.\n@@ -220561,24 +227977,72 @@\n-  Fts5Buffer *p2                  \/* Second list to merge *\/\n-){\n-  if( p2->n ){\n-    i64 iLastRowid = 0;\n-    Fts5DoclistIter i1;\n-    Fts5DoclistIter i2;\n-    Fts5Buffer out = {0, 0, 0};\n-    Fts5Buffer tmp = {0, 0, 0};\n-\n-    \/* The maximum size of the output is equal to the sum of the two\n-    ** input sizes + 1 varint (9 bytes). The extra varint is because if the\n-    ** first rowid in one input is a large negative number, and the first in\n-    ** the other a non-negative number, the delta for the non-negative\n-    ** number will be larger on disk than the literal integer value\n-    ** was.\n-    **\n-    ** Or, if the input position-lists are corrupt, then the output might\n-    ** include up to 2 extra 10-byte positions created by interpreting -1\n-    ** (the value PoslistNext64() uses for EOF) as a position and appending\n-    ** it to the output. This can happen at most once for each input\n-    ** position-list, hence two 10 byte paddings.  *\/\n-    if( sqlite3Fts5BufferSize(&p->rc, &out, p1->n + p2->n + 9+10+10) ) return;\n-    fts5DoclistIterInit(p1, &i1);\n-    fts5DoclistIterInit(p2, &i2);\n+  int nBuf,                       \/* Number of buffers in array aBuf[] *\/\n+  Fts5Buffer *aBuf                \/* Other lists to merge in *\/\n+){\n+#define fts5PrefixMergerNextPosition(p) \\\n+  sqlite3Fts5PoslistNext64((p)->aPos,(p)->iter.nPoslist,&(p)->iOff,&(p)->iPos)\n+#define FTS5_MERGE_NLIST 16\n+  PrefixMerger aMerger[FTS5_MERGE_NLIST];\n+  PrefixMerger *pHead = 0;\n+  int i;\n+  int nOut = 0;\n+  Fts5Buffer out = {0, 0, 0};\n+  Fts5Buffer tmp = {0, 0, 0};\n+  i64 iLastRowid = 0;\n+\n+  \/* Initialize a doclist-iterator for each input buffer. Arrange them in\n+  ** a linked-list starting at pHead in ascending order of rowid. Avoid\n+  ** linking any iterators already at EOF into the linked list at all. *\/\n+  assert( nBuf+1<=sizeof(aMerger)\/sizeof(aMerger[0]) );\n+  memset(aMerger, 0, sizeof(PrefixMerger)*(nBuf+1));\n+  pHead = &aMerger[nBuf];\n+  fts5DoclistIterInit(p1, &pHead->iter);\n+  for(i=0; i<nBuf; i++){\n+    fts5DoclistIterInit(&aBuf[i], &aMerger[i].iter);\n+    fts5PrefixMergerInsertByRowid(&pHead, &aMerger[i]);\n+    nOut += aBuf[i].n;\n+  }\n+  if( nOut==0 ) return;\n+  nOut += p1->n + 9 + 10*nBuf;\n+\n+  \/* The maximum size of the output is equal to the sum of the\n+  ** input sizes + 1 varint (9 bytes). The extra varint is because if the\n+  ** first rowid in one input is a large negative number, and the first in\n+  ** the other a non-negative number, the delta for the non-negative\n+  ** number will be larger on disk than the literal integer value\n+  ** was.\n+  **\n+  ** Or, if the input position-lists are corrupt, then the output might\n+  ** include up to (nBuf+1) extra 10-byte positions created by interpreting -1\n+  ** (the value PoslistNext64() uses for EOF) as a position and appending\n+  ** it to the output. This can happen at most once for each input\n+  ** position-list, hence (nBuf+1) 10 byte paddings.  *\/\n+  if( sqlite3Fts5BufferSize(&p->rc, &out, nOut) ) return;\n+\n+  while( pHead ){\n+    fts5MergeAppendDocid(&out, iLastRowid, pHead->iter.iRowid);\n+\n+    if( pHead->pNext && iLastRowid==pHead->pNext->iter.iRowid ){\n+      \/* Merge data from two or more poslists *\/\n+      i64 iPrev = 0;\n+      int nTmp = FTS5_DATA_ZERO_PADDING;\n+      int nMerge = 0;\n+      PrefixMerger *pSave = pHead;\n+      PrefixMerger *pThis = 0;\n+      int nTail = 0;\n+\n+      pHead = 0;\n+      while( pSave && pSave->iter.iRowid==iLastRowid ){\n+        PrefixMerger *pNext = pSave->pNext;\n+        pSave->iOff = 0;\n+        pSave->iPos = 0;\n+        pSave->aPos = &pSave->iter.aPoslist[pSave->iter.nSize];\n+        fts5PrefixMergerNextPosition(pSave);\n+        nTmp += pSave->iter.nPoslist + 10;\n+        nMerge++;\n+        fts5PrefixMergerInsertByPosition(&pHead, pSave);\n+        pSave = pNext;\n+      }\n+\n+      if( pHead==0 || pHead->pNext==0 ){\n+        p->rc = FTS5_CORRUPT;\n+        break;\n+      }\n@@ -220586,16 +228050,5 @@\n-    while( 1 ){\n-      if( i1.iRowid<i2.iRowid ){\n-        \/* Copy entry from i1 *\/\n-        fts5MergeAppendDocid(&out, iLastRowid, i1.iRowid);\n-        fts5BufferSafeAppendBlob(&out, i1.aPoslist, i1.nPoslist+i1.nSize);\n-        fts5DoclistIterNext(&i1);\n-        if( i1.aPoslist==0 ) break;\n-        assert( out.n<=((i1.aPoslist-p1->p) + (i2.aPoslist-p2->p)+9+10+10) );\n-      }\n-      else if( i2.iRowid!=i1.iRowid ){\n-        \/* Copy entry from i2 *\/\n-        fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);\n-        fts5BufferSafeAppendBlob(&out, i2.aPoslist, i2.nPoslist+i2.nSize);\n-        fts5DoclistIterNext(&i2);\n-        if( i2.aPoslist==0 ) break;\n-        assert( out.n<=((i1.aPoslist-p1->p) + (i2.aPoslist-p2->p)+9+10+10) );\n+      \/* See the earlier comment in this function for an explanation of why\n+      ** corrupt input position lists might cause the output to consume\n+      ** at most nMerge*10 bytes of unexpected space. *\/\n+      if( sqlite3Fts5BufferSize(&p->rc, &tmp, nTmp+nMerge*10) ){\n+        break;\n@@ -220603,50 +228056,1 @@\n-      else{\n-        \/* Merge the two position lists. *\/\n-        i64 iPos1 = 0;\n-        i64 iPos2 = 0;\n-        int iOff1 = 0;\n-        int iOff2 = 0;\n-        u8 *a1 = &i1.aPoslist[i1.nSize];\n-        u8 *a2 = &i2.aPoslist[i2.nSize];\n-        int nCopy;\n-        u8 *aCopy;\n-\n-        i64 iPrev = 0;\n-        Fts5PoslistWriter writer;\n-        memset(&writer, 0, sizeof(writer));\n-\n-        \/* See the earlier comment in this function for an explanation of why\n-        ** corrupt input position lists might cause the output to consume\n-        ** at most 20 bytes of unexpected space. *\/\n-        fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);\n-        fts5BufferZero(&tmp);\n-        sqlite3Fts5BufferSize(&p->rc, &tmp, i1.nPoslist + i2.nPoslist + 10 + 10);\n-        if( p->rc ) break;\n-\n-        sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);\n-        sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);\n-        assert_nc( iPos1>=0 && iPos2>=0 );\n-\n-        if( iPos1<iPos2 ){\n-          sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);\n-          sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);\n-        }else{\n-          sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);\n-          sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);\n-        }\n-        if( iPos1>=0 && iPos2>=0 ){\n-          while( 1 ){\n-            if( iPos1<iPos2 ){\n-              if( iPos1!=iPrev ){\n-                sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);\n-              }\n-              sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);\n-              if( iPos1<0 ) break;\n-            }else{\n-              assert_nc( iPos2!=iPrev );\n-              sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);\n-              sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);\n-              if( iPos2<0 ) break;\n-            }\n-          }\n-        }\n+      fts5BufferZero(&tmp);\n@@ -220654,14 +228058,10 @@\n-        if( iPos1>=0 ){\n-          if( iPos1!=iPrev ){\n-            sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);\n-          }\n-          aCopy = &a1[iOff1];\n-          nCopy = i1.nPoslist - iOff1;\n-        }else{\n-          assert_nc( iPos2>=0 && iPos2!=iPrev );\n-          sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);\n-          aCopy = &a2[iOff2];\n-          nCopy = i2.nPoslist - iOff2;\n-        }\n-        if( nCopy>0 ){\n-          fts5BufferSafeAppendBlob(&tmp, aCopy, nCopy);\n+      pThis = pHead;\n+      pHead = pThis->pNext;\n+      sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, pThis->iPos);\n+      fts5PrefixMergerNextPosition(pThis);\n+      fts5PrefixMergerInsertByPosition(&pHead, pThis);\n+\n+      while( pHead->pNext ){\n+        pThis = pHead;\n+        if( pThis->iPos!=iPrev ){\n+          sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, pThis->iPos);\n@@ -220669,0 +228069,4 @@\n+        fts5PrefixMergerNextPosition(pThis);\n+        pHead = pThis->pNext;\n+        fts5PrefixMergerInsertByPosition(&pHead, pThis);\n+      }\n@@ -220670,6 +228074,24 @@\n-        \/* WRITEPOSLISTSIZE *\/\n-        assert_nc( tmp.n<=i1.nPoslist+i2.nPoslist );\n-        assert( tmp.n<=i1.nPoslist+i2.nPoslist+10+10 );\n-        if( tmp.n>i1.nPoslist+i2.nPoslist ){\n-          if( p->rc==SQLITE_OK ) p->rc = FTS5_CORRUPT;\n-          break;\n+      if( pHead->iPos!=iPrev ){\n+        sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, pHead->iPos);\n+      }\n+      nTail = pHead->iter.nPoslist - pHead->iOff;\n+\n+      \/* WRITEPOSLISTSIZE *\/\n+      assert_nc( tmp.n+nTail<=nTmp );\n+      assert( tmp.n+nTail<=nTmp+nMerge*10 );\n+      if( tmp.n+nTail>nTmp-FTS5_DATA_ZERO_PADDING ){\n+        if( p->rc==SQLITE_OK ) p->rc = FTS5_CORRUPT;\n+        break;\n+      }\n+      fts5BufferSafeAppendVarint(&out, (tmp.n+nTail) * 2);\n+      fts5BufferSafeAppendBlob(&out, tmp.p, tmp.n);\n+      if( nTail>0 ){\n+        fts5BufferSafeAppendBlob(&out, &pHead->aPos[pHead->iOff], nTail);\n+      }\n+\n+      pHead = pSave;\n+      for(i=0; i<nBuf+1; i++){\n+        PrefixMerger *pX = &aMerger[i];\n+        if( pX->iter.aPoslist && pX->iter.iRowid==iLastRowid ){\n+          fts5DoclistIterNext(&pX->iter);\n+          fts5PrefixMergerInsertByRowid(&pHead, pX);\n@@ -220677,7 +228099,0 @@\n-        fts5BufferSafeAppendVarint(&out, tmp.n * 2);\n-        fts5BufferSafeAppendBlob(&out, tmp.p, tmp.n);\n-        fts5DoclistIterNext(&i1);\n-        fts5DoclistIterNext(&i2);\n-        assert_nc( out.n<=(p1->n+p2->n+9) );\n-        if( i1.aPoslist==0 || i2.aPoslist==0 ) break;\n-        assert( out.n<=((i1.aPoslist-p1->p) + (i2.aPoslist-p2->p)+9+10+10) );\n@@ -220685,1 +228100,0 @@\n-    }\n@@ -220687,7 +228101,8 @@\n-    if( i1.aPoslist ){\n-      fts5MergeAppendDocid(&out, iLastRowid, i1.iRowid);\n-      fts5BufferSafeAppendBlob(&out, i1.aPoslist, i1.aEof - i1.aPoslist);\n-    }\n-    else if( i2.aPoslist ){\n-      fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);\n-      fts5BufferSafeAppendBlob(&out, i2.aPoslist, i2.aEof - i2.aPoslist);\n+    }else{\n+      \/* Copy poslist from pHead to output *\/\n+      PrefixMerger *pThis = pHead;\n+      Fts5DoclistIter *pI = &pThis->iter;\n+      fts5BufferSafeAppendBlob(&out, pI->aPoslist, pI->nPoslist+pI->nSize);\n+      fts5DoclistIterNext(pI);\n+      pHead = pThis->pNext;\n+      fts5PrefixMergerInsertByRowid(&pHead, pThis);\n@@ -220695,5 +228110,0 @@\n-    assert_nc( out.n<=(p1->n+p2->n+9) );\n-\n-    fts5BufferSet(&p->rc, p1, out.n, out.p);\n-    fts5BufferFree(&tmp);\n-    fts5BufferFree(&out);\n@@ -220701,0 +228111,5 @@\n+\n+  fts5BufferFree(p1);\n+  fts5BufferFree(&tmp);\n+  memset(&out.p[out.n], 0, FTS5_DATA_ZERO_PADDING);\n+  *p1 = out;\n@@ -220706,1 +228121,2 @@\n-  const u8 *pToken,               \/* Buffer containing prefix to match *\/\n+  int iIdx,                       \/* Index to scan for data *\/\n+  u8 *pToken,                     \/* Buffer containing prefix to match *\/\n@@ -220713,1 +228129,2 @@\n-  const int nBuf = 32;\n+  int nBuf = 32;\n+  int nMerge = 1;\n@@ -220715,1 +228132,1 @@\n-  void (*xMerge)(Fts5Index*, Fts5Buffer*, Fts5Buffer*);\n+  void (*xMerge)(Fts5Index*, Fts5Buffer*, int, Fts5Buffer*);\n@@ -220721,0 +228138,2 @@\n+    nMerge = FTS5_MERGE_NLIST-1;\n+    nBuf = nMerge*8;   \/* Sufficient to merge (16^8)==(2^32) lists *\/\n@@ -220740,0 +228159,21 @@\n+    if( iIdx!=0 ){\n+      int dummy = 0;\n+      const int f2 = FTS5INDEX_QUERY_SKIPEMPTY|FTS5INDEX_QUERY_NOOUTPUT;\n+      pToken[0] = FTS5_MAIN_PREFIX;\n+      fts5MultiIterNew(p, pStruct, f2, pColset, pToken, nToken, -1, 0, &p1);\n+      fts5IterSetOutputCb(&p->rc, p1);\n+      for(;\n+        fts5MultiIterEof(p, p1)==0;\n+        fts5MultiIterNext2(p, p1, &dummy)\n+      ){\n+        Fts5SegIter *pSeg = &p1->aSeg[ p1->aFirst[1].iFirst ];\n+        p1->xSetOutputs(p1, pSeg);\n+        if( p1->base.nData ){\n+          xAppend(p, p1->base.iRowid-iLastRowid, p1, &doclist);\n+          iLastRowid = p1->base.iRowid;\n+        }\n+      }\n+      fts5MultiIterFree(p1);\n+    }\n+\n+    pToken[0] = FTS5_MAIN_PREFIX + iIdx;\n@@ -220760,7 +228200,15 @@\n-          assert( i<nBuf );\n-          if( aBuf[i].n==0 ){\n-            fts5BufferSwap(&doclist, &aBuf[i]);\n-            fts5BufferZero(&doclist);\n-          }else{\n-            xMerge(p, &doclist, &aBuf[i]);\n-            fts5BufferZero(&aBuf[i]);\n+          int i1 = i*nMerge;\n+          int iStore;\n+          assert( i1+nMerge<=nBuf );\n+          for(iStore=i1; iStore<i1+nMerge; iStore++){\n+            if( aBuf[iStore].n==0 ){\n+              fts5BufferSwap(&doclist, &aBuf[iStore]);\n+              fts5BufferZero(&doclist);\n+              break;\n+            }\n+          }\n+          if( iStore==i1+nMerge ){\n+            xMerge(p, &doclist, nMerge, &aBuf[i1]);\n+            for(iStore=i1; iStore<i1+nMerge; iStore++){\n+              fts5BufferZero(&aBuf[iStore]);\n+            }\n@@ -220776,1 +228224,3 @@\n-    for(i=0; i<nBuf; i++){\n+    assert( (nBuf%nMerge)==0 );\n+    for(i=0; i<nBuf; i+=nMerge){\n+      int iFree;\n@@ -220778,1 +228228,4 @@\n-        xMerge(p, &doclist, &aBuf[i]);\n+        xMerge(p, &doclist, nMerge, &aBuf[i]);\n+      }\n+      for(iFree=i; iFree<i+nMerge; iFree++){\n+        fts5BufferFree(&aBuf[iFree]);\n@@ -220780,1 +228233,0 @@\n-      fts5BufferFree(&aBuf[i]);\n@@ -221035,0 +228487,1 @@\n+    int iPrefixIdx = 0;           \/* +1 prefix index *\/\n@@ -221056,1 +228509,3 @@\n-        if( pConfig->aPrefix[iIdx-1]==nChar ) break;\n+        int nIdxChar = pConfig->aPrefix[iIdx-1];\n+        if( nIdxChar==nChar ) break;\n+        if( nIdxChar==nChar+1 ) iPrefixIdx = iIdx;\n@@ -221073,7 +228528,10 @@\n-      buf.p[0] = FTS5_MAIN_PREFIX;\n-      fts5SetupPrefixIter(p, bDesc, buf.p, nToken+1, pColset, &pRet);\n-      assert( p->rc!=SQLITE_OK || pRet->pColset==0 );\n-      fts5IterSetOutputCb(&p->rc, pRet);\n-      if( p->rc==SQLITE_OK ){\n-        Fts5SegIter *pSeg = &pRet->aSeg[pRet->aFirst[1].iFirst];\n-        if( pSeg->pLeaf ) pRet->xSetOutputs(pRet, pSeg);\n+      fts5SetupPrefixIter(p, bDesc, iPrefixIdx, buf.p, nToken+1, pColset,&pRet);\n+      if( pRet==0 ){\n+        assert( p->rc!=SQLITE_OK );\n+      }else{\n+        assert( pRet->pColset==0 );\n+        fts5IterSetOutputCb(&p->rc, pRet);\n+        if( p->rc==SQLITE_OK ){\n+          Fts5SegIter *pSeg = &pRet->aSeg[pRet->aFirst[1].iFirst];\n+          if( pSeg->pLeaf ) pRet->xSetOutputs(pRet, pSeg);\n+        }\n@@ -221147,0 +228605,1 @@\n+  assert_nc( z || n<=1 );\n@@ -221148,1 +228607,1 @@\n-  return &z[1];\n+  return (z ? &z[1] : 0);\n@@ -221326,1 +228785,1 @@\n-  while( rc==SQLITE_OK && 0==sqlite3Fts5IterEof(pIter) ){\n+  while( rc==SQLITE_OK && ALWAYS(pIter!=0) && 0==sqlite3Fts5IterEof(pIter) ){\n@@ -221685,1 +229144,1 @@\n-static int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, u64 cksum){\n+static int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, u64 cksum, int bUseCksum){\n@@ -221691,0 +229150,1 @@\n+  int iLvl, iSeg;\n@@ -221701,0 +229161,4 @@\n+  if( pStruct==0 ){\n+    assert( p->rc!=SQLITE_OK );\n+    return fts5IndexReturn(p);\n+  }\n@@ -221703,7 +229167,4 @@\n-  if( pStruct ){\n-    int iLvl, iSeg;\n-    for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){\n-      for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){\n-        Fts5StructureSegment *pSeg = &pStruct->aLevel[iLvl].aSeg[iSeg];\n-        fts5IndexIntegrityCheckSegment(p, pSeg);\n-      }\n+  for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){\n+    for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){\n+      Fts5StructureSegment *pSeg = &pStruct->aLevel[iLvl].aSeg[iSeg];\n+      fts5IndexIntegrityCheckSegment(p, pSeg);\n@@ -221746,0 +229207,1 @@\n+      fts5BufferAppendBlob(&p->rc, &poslist, 4, (const u8*)\"\\0\\0\\0\\0\");\n@@ -221756,1 +229218,1 @@\n-  if( p->rc==SQLITE_OK && cksum!=cksum2 ) p->rc = FTS5_CORRUPT;\n+  if( p->rc==SQLITE_OK && bUseCksum && cksum!=cksum2 ) p->rc = FTS5_CORRUPT;\n@@ -221772,0 +229234,1 @@\n+#ifdef SQLITE_TEST\n@@ -221794,0 +229257,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221795,0 +229259,1 @@\n+#ifdef SQLITE_TEST\n@@ -221812,0 +229277,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221813,0 +229279,1 @@\n+#ifdef SQLITE_TEST\n@@ -221834,0 +229301,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221835,0 +229303,1 @@\n+#ifdef SQLITE_TEST\n@@ -221859,0 +229328,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221860,0 +229330,1 @@\n+#ifdef SQLITE_TEST\n@@ -221882,0 +229353,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221883,0 +229355,1 @@\n+#ifdef SQLITE_TEST\n@@ -221899,0 +229372,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221900,0 +229374,1 @@\n+#ifdef SQLITE_TEST\n@@ -221932,0 +229407,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221933,0 +229409,1 @@\n+#ifdef SQLITE_TEST\n@@ -221973,0 +229450,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -221974,0 +229452,1 @@\n+#ifdef SQLITE_TEST\n@@ -222182,0 +229661,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -222183,0 +229663,1 @@\n+#ifdef SQLITE_TEST\n@@ -222216,0 +229697,1 @@\n+#endif \/* SQLITE_TEST *\/\n@@ -222226,0 +229708,1 @@\n+#ifdef SQLITE_TEST\n@@ -222243,0 +229726,4 @@\n+#else\n+  return SQLITE_OK;\n+  UNUSED_PARAM(db);\n+#endif\n@@ -222278,0 +229765,1 @@\n+#ifdef SQLITE_DEBUG\n@@ -222279,0 +229767,1 @@\n+#endif\n@@ -222720,0 +230209,17 @@\n+static int fts5UsePatternMatch(\n+  Fts5Config *pConfig,\n+  struct sqlite3_index_constraint *p\n+){\n+  assert( FTS5_PATTERN_GLOB==SQLITE_INDEX_CONSTRAINT_GLOB );\n+  assert( FTS5_PATTERN_LIKE==SQLITE_INDEX_CONSTRAINT_LIKE );\n+  if( pConfig->ePattern==FTS5_PATTERN_GLOB && p->op==FTS5_PATTERN_GLOB ){\n+    return 1;\n+  }\n+  if( pConfig->ePattern==FTS5_PATTERN_LIKE\n+   && (p->op==FTS5_PATTERN_LIKE || p->op==FTS5_PATTERN_GLOB)\n+  ){\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n@@ -222749,1 +230255,3 @@\n-**   Match against other column:            \"<column-number>\"\n+**   Match against other column:            \"M<column-number>\"\n+**   LIKE  against other column:            \"L<column-number>\"\n+**   GLOB  against other column:            \"G<column-number>\"\n@@ -222810,1 +230318,1 @@\n-  idxStr = (char*)sqlite3_malloc(pInfo->nConstraint * 6 + 1);\n+  idxStr = (char*)sqlite3_malloc(pInfo->nConstraint * 8 + 1);\n@@ -222834,1 +230342,1 @@\n-        }else{\n+        }else if( iCol>=0 ){\n@@ -222836,6 +230344,4 @@\n-          idxStr[iIdxStr++] = 'm';\n-          if( iCol<nCol ){\n-            sqlite3_snprintf(6, &idxStr[iIdxStr], \"%d\", iCol);\n-            idxStr += strlen(&idxStr[iIdxStr]);\n-            assert( idxStr[iIdxStr]=='\\0' );\n-          }\n+          idxStr[iIdxStr++] = 'M';\n+          sqlite3_snprintf(6, &idxStr[iIdxStr], \"%d\", iCol);\n+          idxStr += strlen(&idxStr[iIdxStr]);\n+          assert( idxStr[iIdxStr]=='\\0' );\n@@ -222846,7 +230352,13 @@\n-    }\n-    else if( p->usable && bSeenEq==0\n-      && p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol<0\n-    ){\n-      idxStr[iIdxStr++] = '=';\n-      bSeenEq = 1;\n-      pInfo->aConstraintUsage[i].argvIndex = ++iCons;\n+    }else if( p->usable ){\n+      if( iCol>=0 && iCol<nCol && fts5UsePatternMatch(pConfig, p) ){\n+        assert( p->op==FTS5_PATTERN_LIKE || p->op==FTS5_PATTERN_GLOB );\n+        idxStr[iIdxStr++] = p->op==FTS5_PATTERN_LIKE ? 'L' : 'G';\n+        sqlite3_snprintf(6, &idxStr[iIdxStr], \"%d\", iCol);\n+        idxStr += strlen(&idxStr[iIdxStr]);\n+        pInfo->aConstraintUsage[i].argvIndex = ++iCons;\n+        assert( idxStr[iIdxStr]=='\\0' );\n+      }else if( bSeenEq==0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol<0 ){\n+        idxStr[iIdxStr++] = '=';\n+        bSeenEq = 1;\n+        pInfo->aConstraintUsage[i].argvIndex = ++iCons;\n+      }\n@@ -223485,1 +230997,1 @@\n-      case 'm': {\n+      case 'M': {\n@@ -223488,10 +231000,5 @@\n-\n-        if( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' ){\n-          iCol = 0;\n-          do{\n-            iCol = iCol*10 + (idxStr[iIdxStr]-'0');\n-            iIdxStr++;\n-          }while( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' );\n-        }else{\n-          iCol = pConfig->nCol;\n-        }\n+        iCol = 0;\n+        do{\n+          iCol = iCol*10 + (idxStr[iIdxStr]-'0');\n+          iIdxStr++;\n+        }while( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' );\n@@ -223507,1 +231014,1 @@\n-          rc = sqlite3Fts5ExprNew(pConfig, iCol, zText, &pExpr, pzErr);\n+          rc = sqlite3Fts5ExprNew(pConfig, 0, iCol, zText, &pExpr, pzErr);\n@@ -223517,0 +231024,19 @@\n+      case 'L':\n+      case 'G': {\n+        int bGlob = (idxStr[iIdxStr-1]=='G');\n+        const char *zText = (const char*)sqlite3_value_text(apVal[i]);\n+        iCol = 0;\n+        do{\n+          iCol = iCol*10 + (idxStr[iIdxStr]-'0');\n+          iIdxStr++;\n+        }while( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' );\n+        if( zText ){\n+          rc = sqlite3Fts5ExprPattern(pConfig, bGlob, iCol, zText, &pExpr);\n+        }\n+        if( rc==SQLITE_OK ){\n+          rc = sqlite3Fts5ExprAnd(&pCsr->pExpr, pExpr);\n+          pExpr = 0;\n+        }\n+        if( rc!=SQLITE_OK ) goto filter_out;\n+        break;\n+      }\n@@ -223591,1 +231117,2 @@\n-      if( pCsr->ePlan==FTS5_PLAN_ROWID ){\n+      if( pRowidEq!=0 ){\n+        assert( pCsr->ePlan==FTS5_PLAN_ROWID );\n@@ -223764,1 +231291,2 @@\n-    rc = sqlite3Fts5StorageIntegrity(pTab->pStorage);\n+    int iArg = sqlite3_value_int(pVal);\n+    rc = sqlite3Fts5StorageIntegrity(pTab->pStorage, iArg);\n@@ -224165,1 +231693,1 @@\n-          pCsr->nInstAlloc = pCsr->nInstAlloc ? pCsr->nInstAlloc*2 : 32;\n+          int nNewSize = pCsr->nInstAlloc ? pCsr->nInstAlloc*2 : 32;\n@@ -224167,1 +231695,1 @@\n-              pCsr->aInst, pCsr->nInstAlloc*sizeof(int)*3\n+              pCsr->aInst, nNewSize*sizeof(int)*3\n@@ -224171,0 +231699,1 @@\n+            pCsr->nInstAlloc = nNewSize;\n@@ -224172,0 +231701,1 @@\n+            nInst--;\n@@ -224395,1 +231925,2 @@\n-    pIter->b = &pIter->a[n];\n+    assert( pIter->a || n==0 );\n+    pIter->b = (pIter->a ? &pIter->a[n] : 0);\n@@ -224454,1 +231985,2 @@\n-      pIter->b = &pIter->a[n];\n+      assert( pIter->a || n==0 );\n+      pIter->b = (pIter->a ? &pIter->a[n] : 0);\n@@ -224462,1 +231994,2 @@\n-      pIter->b = &pIter->a[n];\n+      assert( pIter->a || n==0 );\n+      pIter->b = (pIter->a ? &pIter->a[n] : 0);\n@@ -224927,2 +232460,1 @@\n-  Fts5Tokenizer **ppTok,\n-  fts5_tokenizer **ppTokApi,\n+  Fts5Config *pConfig,\n@@ -224940,4 +232472,10 @@\n-    rc = pMod->x.xCreate(pMod->pUserData, &azArg[1], (nArg?nArg-1:0), ppTok);\n-    *ppTokApi = &pMod->x;\n-    if( rc!=SQLITE_OK && pzErr ){\n-      *pzErr = sqlite3_mprintf(\"error in tokenizer constructor\");\n+    rc = pMod->x.xCreate(\n+        pMod->pUserData, (azArg?&azArg[1]:0), (nArg?nArg-1:0), &pConfig->pTok\n+    );\n+    pConfig->pTokApi = &pMod->x;\n+    if( rc!=SQLITE_OK ){\n+      if( pzErr ) *pzErr = sqlite3_mprintf(\"error in tokenizer constructor\");\n+    }else{\n+      pConfig->ePattern = sqlite3Fts5TokenizerPattern(\n+          pMod->x.xCreate, pConfig->pTok\n+      );\n@@ -224948,2 +232486,2 @@\n-    *ppTokApi = 0;\n-    *ppTok = 0;\n+    pConfig->pTokApi = 0;\n+    pConfig->pTok = 0;\n@@ -224998,1 +232536,1 @@\n-  sqlite3_result_text(pCtx, \"fts5: 2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933cc8fd\", -1, SQLITE_TRANSIENT);\n+  sqlite3_result_text(pCtx, \"fts5: 2022-01-06 13:25:41 872ba256cbf61d9290b571c0e6d82a20c224ca3ad82971edc46b29818d5d17a0\", -1, SQLITE_TRANSIENT);\n@@ -225549,0 +233087,2 @@\n+      assert( pSeek==0 || apVal==0 );\n+      assert( pSeek!=0 || apVal!=0 );\n@@ -225552,1 +233092,1 @@\n-      }else{\n+      }else if( ALWAYS(apVal) ){\n@@ -225555,0 +233095,2 @@\n+      }else{\n+        continue;\n@@ -225561,0 +233103,3 @@\n+      if( p->aTotalSize[iCol-1]<0 ){\n+        rc = FTS5_CORRUPT;\n+      }\n@@ -225563,1 +233108,5 @@\n-  p->nTotalRow--;\n+  if( rc==SQLITE_OK && p->nTotalRow<1 ){\n+    rc = FTS5_CORRUPT;\n+  }else{\n+    p->nTotalRow--;\n+  }\n@@ -226006,1 +233555,1 @@\n-static int sqlite3Fts5StorageIntegrity(Fts5Storage *p){\n+static int sqlite3Fts5StorageIntegrity(Fts5Storage *p, int iArg){\n@@ -226008,1 +233557,1 @@\n-  int rc;                         \/* Return code *\/\n+  int rc = SQLITE_OK;             \/* Return code *\/\n@@ -226013,0 +233562,1 @@\n+  int bUseCksum;\n@@ -226021,18 +233571,12 @@\n-  \/* Generate the expected index checksum based on the contents of the\n-  ** %_content table. This block stores the checksum in ctx.cksum. *\/\n-  rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);\n-  if( rc==SQLITE_OK ){\n-    int rc2;\n-    while( SQLITE_ROW==sqlite3_step(pScan) ){\n-      int i;\n-      ctx.iRowid = sqlite3_column_int64(pScan, 0);\n-      ctx.szCol = 0;\n-      if( pConfig->bColumnsize ){\n-        rc = sqlite3Fts5StorageDocsize(p, ctx.iRowid, aColSize);\n-      }\n-      if( rc==SQLITE_OK && pConfig->eDetail==FTS5_DETAIL_NONE ){\n-        rc = sqlite3Fts5TermsetNew(&ctx.pTermset);\n-      }\n-      for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){\n-        if( pConfig->abUnindexed[i] ) continue;\n-        ctx.iCol = i;\n+  bUseCksum = (pConfig->eContent==FTS5_CONTENT_NORMAL\n+           || (pConfig->eContent==FTS5_CONTENT_EXTERNAL && iArg)\n+  );\n+  if( bUseCksum ){\n+    \/* Generate the expected index checksum based on the contents of the\n+    ** %_content table. This block stores the checksum in ctx.cksum. *\/\n+    rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);\n+    if( rc==SQLITE_OK ){\n+      int rc2;\n+      while( SQLITE_ROW==sqlite3_step(pScan) ){\n+        int i;\n+        ctx.iRowid = sqlite3_column_int64(pScan, 0);\n@@ -226040,12 +233584,2 @@\n-        if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n-          rc = sqlite3Fts5TermsetNew(&ctx.pTermset);\n-        }\n-        if( rc==SQLITE_OK ){\n-          const char *zText = (const char*)sqlite3_column_text(pScan, i+1);\n-          int nText = sqlite3_column_bytes(pScan, i+1);\n-          rc = sqlite3Fts5Tokenize(pConfig,\n-              FTS5_TOKENIZE_DOCUMENT,\n-              zText, nText,\n-              (void*)&ctx,\n-              fts5StorageIntegrityCallback\n-          );\n+        if( pConfig->bColumnsize ){\n+          rc = sqlite3Fts5StorageDocsize(p, ctx.iRowid, aColSize);\n@@ -226053,2 +233587,2 @@\n-        if( rc==SQLITE_OK && pConfig->bColumnsize && ctx.szCol!=aColSize[i] ){\n-          rc = FTS5_CORRUPT;\n+        if( rc==SQLITE_OK && pConfig->eDetail==FTS5_DETAIL_NONE ){\n+          rc = sqlite3Fts5TermsetNew(&ctx.pTermset);\n@@ -226056,4 +233590,25 @@\n-        aTotalSize[i] += ctx.szCol;\n-        if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n-          sqlite3Fts5TermsetFree(ctx.pTermset);\n-          ctx.pTermset = 0;\n+        for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){\n+          if( pConfig->abUnindexed[i] ) continue;\n+          ctx.iCol = i;\n+          ctx.szCol = 0;\n+          if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n+            rc = sqlite3Fts5TermsetNew(&ctx.pTermset);\n+          }\n+          if( rc==SQLITE_OK ){\n+            const char *zText = (const char*)sqlite3_column_text(pScan, i+1);\n+            int nText = sqlite3_column_bytes(pScan, i+1);\n+            rc = sqlite3Fts5Tokenize(pConfig,\n+                FTS5_TOKENIZE_DOCUMENT,\n+                zText, nText,\n+                (void*)&ctx,\n+                fts5StorageIntegrityCallback\n+            );\n+          }\n+          if( rc==SQLITE_OK && pConfig->bColumnsize && ctx.szCol!=aColSize[i] ){\n+            rc = FTS5_CORRUPT;\n+          }\n+          aTotalSize[i] += ctx.szCol;\n+          if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n+            sqlite3Fts5TermsetFree(ctx.pTermset);\n+            ctx.pTermset = 0;\n+          }\n@@ -226061,3 +233616,2 @@\n-      }\n-      sqlite3Fts5TermsetFree(ctx.pTermset);\n-      ctx.pTermset = 0;\n+        sqlite3Fts5TermsetFree(ctx.pTermset);\n+        ctx.pTermset = 0;\n@@ -226065,1 +233619,4 @@\n-      if( rc!=SQLITE_OK ) break;\n+        if( rc!=SQLITE_OK ) break;\n+      }\n+      rc2 = sqlite3_reset(pScan);\n+      if( rc==SQLITE_OK ) rc = rc2;\n@@ -226067,3 +233624,0 @@\n-    rc2 = sqlite3_reset(pScan);\n-    if( rc==SQLITE_OK ) rc = rc2;\n-  }\n@@ -226071,6 +233625,7 @@\n-  \/* Test that the \"totals\" (sometimes called \"averages\") record looks Ok *\/\n-  if( rc==SQLITE_OK ){\n-    int i;\n-    rc = fts5StorageLoadTotals(p, 0);\n-    for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){\n-      if( p->aTotalSize[i]!=aTotalSize[i] ) rc = FTS5_CORRUPT;\n+    \/* Test that the \"totals\" (sometimes called \"averages\") record looks Ok *\/\n+    if( rc==SQLITE_OK ){\n+      int i;\n+      rc = fts5StorageLoadTotals(p, 0);\n+      for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){\n+        if( p->aTotalSize[i]!=aTotalSize[i] ) rc = FTS5_CORRUPT;\n+      }\n@@ -226078,1 +233633,0 @@\n-  }\n@@ -226080,11 +233634,12 @@\n-  \/* Check that the %_docsize and %_content tables contain the expected\n-  ** number of rows.  *\/\n-  if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_NORMAL ){\n-    i64 nRow = 0;\n-    rc = fts5StorageCount(p, \"content\", &nRow);\n-    if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;\n-  }\n-  if( rc==SQLITE_OK && pConfig->bColumnsize ){\n-    i64 nRow = 0;\n-    rc = fts5StorageCount(p, \"docsize\", &nRow);\n-    if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;\n+    \/* Check that the %_docsize and %_content tables contain the expected\n+    ** number of rows.  *\/\n+    if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_NORMAL ){\n+      i64 nRow = 0;\n+      rc = fts5StorageCount(p, \"content\", &nRow);\n+      if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;\n+    }\n+    if( rc==SQLITE_OK && pConfig->bColumnsize ){\n+      i64 nRow = 0;\n+      rc = fts5StorageCount(p, \"docsize\", &nRow);\n+      if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;\n+    }\n@@ -226097,1 +233652,1 @@\n-    rc = sqlite3Fts5IndexIntegrityCheck(p->pIndex, ctx.cksum);\n+    rc = sqlite3Fts5IndexIntegrityCheck(p->pIndex, ctx.cksum, bUseCksum);\n@@ -226177,1 +233732,1 @@\n-  if( rc==SQLITE_OK ){\n+  if( pLookup ){\n@@ -226179,0 +233734,1 @@\n+    assert( rc==SQLITE_OK );\n@@ -226191,0 +233747,2 @@\n+  }else{\n+    assert( rc!=SQLITE_OK );\n@@ -227539,0 +235097,127 @@\n+\/**************************************************************************\n+** Start of trigram implementation.\n+*\/\n+typedef struct TrigramTokenizer TrigramTokenizer;\n+struct TrigramTokenizer {\n+  int bFold;                      \/* True to fold to lower-case *\/\n+};\n+\n+\/*\n+** Free a trigram tokenizer.\n+*\/\n+static void fts5TriDelete(Fts5Tokenizer *p){\n+  sqlite3_free(p);\n+}\n+\n+\/*\n+** Allocate a trigram tokenizer.\n+*\/\n+static int fts5TriCreate(\n+  void *pUnused,\n+  const char **azArg,\n+  int nArg,\n+  Fts5Tokenizer **ppOut\n+){\n+  int rc = SQLITE_OK;\n+  TrigramTokenizer *pNew = (TrigramTokenizer*)sqlite3_malloc(sizeof(*pNew));\n+  UNUSED_PARAM(pUnused);\n+  if( pNew==0 ){\n+    rc = SQLITE_NOMEM;\n+  }else{\n+    int i;\n+    pNew->bFold = 1;\n+    for(i=0; rc==SQLITE_OK && i<nArg; i+=2){\n+      const char *zArg = azArg[i+1];\n+      if( 0==sqlite3_stricmp(azArg[i], \"case_sensitive\") ){\n+        if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1] ){\n+          rc = SQLITE_ERROR;\n+        }else{\n+          pNew->bFold = (zArg[0]=='0');\n+        }\n+      }else{\n+        rc = SQLITE_ERROR;\n+      }\n+    }\n+    if( rc!=SQLITE_OK ){\n+      fts5TriDelete((Fts5Tokenizer*)pNew);\n+      pNew = 0;\n+    }\n+  }\n+  *ppOut = (Fts5Tokenizer*)pNew;\n+  return rc;\n+}\n+\n+\/*\n+** Trigram tokenizer tokenize routine.\n+*\/\n+static int fts5TriTokenize(\n+  Fts5Tokenizer *pTok,\n+  void *pCtx,\n+  int unusedFlags,\n+  const char *pText, int nText,\n+  int (*xToken)(void*, int, const char*, int, int, int)\n+){\n+  TrigramTokenizer *p = (TrigramTokenizer*)pTok;\n+  int rc = SQLITE_OK;\n+  char aBuf[32];\n+  const unsigned char *zIn = (const unsigned char*)pText;\n+  const unsigned char *zEof = &zIn[nText];\n+  u32 iCode;\n+\n+  UNUSED_PARAM(unusedFlags);\n+  while( 1 ){\n+    char *zOut = aBuf;\n+    int iStart = zIn - (const unsigned char*)pText;\n+    const unsigned char *zNext;\n+\n+    READ_UTF8(zIn, zEof, iCode);\n+    if( iCode==0 ) break;\n+    zNext = zIn;\n+    if( zIn<zEof ){\n+      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);\n+      WRITE_UTF8(zOut, iCode);\n+      READ_UTF8(zIn, zEof, iCode);\n+      if( iCode==0 ) break;\n+    }else{\n+      break;\n+    }\n+    if( zIn<zEof ){\n+      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);\n+      WRITE_UTF8(zOut, iCode);\n+      READ_UTF8(zIn, zEof, iCode);\n+      if( iCode==0 ) break;\n+      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);\n+      WRITE_UTF8(zOut, iCode);\n+    }else{\n+      break;\n+    }\n+    rc = xToken(pCtx, 0, aBuf, zOut-aBuf, iStart, iStart + zOut-aBuf);\n+    if( rc!=SQLITE_OK ) break;\n+    zIn = zNext;\n+  }\n+\n+  return rc;\n+}\n+\n+\/*\n+** Argument xCreate is a pointer to a constructor function for a tokenizer.\n+** pTok is a tokenizer previously created using the same method. This function\n+** returns one of FTS5_PATTERN_NONE, FTS5_PATTERN_LIKE or FTS5_PATTERN_GLOB\n+** indicating the style of pattern matching that the tokenizer can support.\n+** In practice, this is:\n+**\n+**     \"trigram\" tokenizer, case_sensitive=1 - FTS5_PATTERN_GLOB\n+**     \"trigram\" tokenizer, case_sensitive=0 (the default) - FTS5_PATTERN_LIKE\n+**     all other tokenizers - FTS5_PATTERN_NONE\n+*\/\n+static int sqlite3Fts5TokenizerPattern(\n+    int (*xCreate)(void*, const char**, int, Fts5Tokenizer**),\n+    Fts5Tokenizer *pTok\n+){\n+  if( xCreate==fts5TriCreate ){\n+    TrigramTokenizer *p = (TrigramTokenizer*)pTok;\n+    return p->bFold ? FTS5_PATTERN_LIKE : FTS5_PATTERN_GLOB;\n+  }\n+  return FTS5_PATTERN_NONE;\n+}\n+\n@@ -227550,0 +235235,1 @@\n+    { \"trigram\",   {fts5TriCreate, fts5TriDelete, fts5TriTokenize}},\n@@ -228342,0 +236028,1 @@\n+  aAscii[0] = 0;                  \/* 0x00 is never a token character *\/\n@@ -228344,0 +236031,1 @@\n+\n@@ -228751,0 +236439,1 @@\n+  void *pStruct;                  \/* From sqlite3Fts5StructureRef() *\/\n@@ -229064,1 +236753,1 @@\n-    int nByte = pFts5->pConfig->nCol * sizeof(i64)*2 + sizeof(Fts5VocabCursor);\n+    i64 nByte = pFts5->pConfig->nCol * sizeof(i64)*2 + sizeof(Fts5VocabCursor);\n@@ -229084,0 +236773,2 @@\n+  sqlite3Fts5StructureRelease(pCsr->pStruct);\n+  pCsr->pStruct = 0;\n@@ -229161,1 +236852,0 @@\n-  int rc = SQLITE_OK;\n@@ -229163,0 +236853,1 @@\n+  int rc;\n@@ -229164,0 +236855,2 @@\n+  rc = sqlite3Fts5StructureTest(pCsr->pFts5->pIndex, pCsr->pStruct);\n+  if( rc!=SQLITE_OK ) return rc;\n@@ -229337,0 +237030,3 @@\n+    if( rc==SQLITE_OK ){\n+      pCsr->pStruct = sqlite3Fts5StructureRef(pIndex);\n+    }\n@@ -229781,4 +237477,0 @@\n-#if __LINE__!=229781\n-#undef SQLITE_SOURCE_ID\n-#define SQLITE_SOURCE_ID      \"2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933calt2\"\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.c","additions":18878,"deletions":11186,"binary":false,"changes":30064,"status":"modified"},{"patch":"@@ -46,1 +46,24 @@\n-** Provide the ability to override linkage features of the interface.\n+** Facilitate override of interface linkage and calling conventions.\n+** Be aware that these macros may not be used within this particular\n+** translation of the amalgamation and its associated header file.\n+**\n+** The SQLITE_EXTERN and SQLITE_API macros are used to instruct the\n+** compiler that the target identifier should have external linkage.\n+**\n+** The SQLITE_CDECL macro is used to set the calling convention for\n+** public functions that accept a variable number of arguments.\n+**\n+** The SQLITE_APICALL macro is used to set the calling convention for\n+** public functions that accept a fixed number of arguments.\n+**\n+** The SQLITE_STDCALL macro is no longer used and is now deprecated.\n+**\n+** The SQLITE_CALLBACK macro is used to set the calling convention for\n+** function pointers.\n+**\n+** The SQLITE_SYSAPI macro is used to set the calling convention for\n+** functions provided by the operating system.\n+**\n+** Currently, the SQLITE_CDECL, SQLITE_APICALL, SQLITE_CALLBACK, and\n+** SQLITE_SYSAPI macros are used only when building for environments\n+** that require non-default calling conventions.\n@@ -126,3 +149,3 @@\n-#define SQLITE_VERSION        \"3.32.3\"\n-#define SQLITE_VERSION_NUMBER 3032003\n-#define SQLITE_SOURCE_ID      \"2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933cc8fd\"\n+#define SQLITE_VERSION        \"3.37.2\"\n+#define SQLITE_VERSION_NUMBER 3037002\n+#define SQLITE_SOURCE_ID      \"2022-01-06 13:25:41 872ba256cbf61d9290b571c0e6d82a20c224ca3ad82971edc46b29818d5d17a0\"\n@@ -507,0 +530,1 @@\n+#define SQLITE_IOERR_CORRUPTFS         (SQLITE_IOERR | (33<<8))\n@@ -539,0 +563,1 @@\n+#define SQLITE_CONSTRAINT_DATATYPE     (SQLITE_CONSTRAINT |(12<<8))\n@@ -552,0 +577,13 @@\n+**\n+** Only those flags marked as \"Ok for sqlite3_open_v2()\" may be\n+** used as the third argument to the [sqlite3_open_v2()] interface.\n+** The other flags have historically been ignored by sqlite3_open_v2(),\n+** though future versions of SQLite might change so that an error is\n+** raised if any of the disallowed bits are passed into sqlite3_open_v2().\n+** Applications should not depend on the historical behavior.\n+**\n+** Note in particular that passing the SQLITE_OPEN_EXCLUSIVE flag into\n+** [sqlite3_open_v2()] does *not* cause the underlying database file\n+** to be opened using O_EXCL.  Passing SQLITE_OPEN_EXCLUSIVE into\n+** [sqlite3_open_v2()] has historically be a no-op and might become an\n+** error in future versions of SQLite.\n@@ -567,1 +605,1 @@\n-#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  \/* VFS only *\/\n+#define SQLITE_OPEN_SUPER_JOURNAL    0x00004000  \/* VFS only *\/\n@@ -574,0 +612,1 @@\n+#define SQLITE_OPEN_EXRESCODE        0x02000000  \/* Extended result codes *\/\n@@ -576,0 +615,3 @@\n+\/* Legacy compatibility: *\/\n+#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  \/* VFS only *\/\n+\n@@ -873,1 +915,1 @@\n-** string containing the transactions master-journal file name. VFSes that\n+** string containing the transactions super-journal file name. VFSes that\n@@ -1127,0 +1169,17 @@\n+**\n+** <li>[[SQLITE_FCNTL_EXTERNAL_READER]]\n+** The EXPERIMENTAL [SQLITE_FCNTL_EXTERNAL_READER] opcode is used to detect\n+** whether or not there is a database client in another process with a wal-mode\n+** transaction open on the database or not. It is only available on unix.The\n+** (void*) argument passed with this file-control should be a pointer to a\n+** value of type (int). The integer value is set to 1 if the database is a wal\n+** mode database and there exists at least one client in another process that\n+** currently has an SQL transaction open on the database. It is set to 0 if\n+** the database is not a wal-mode db, or if there is no such connection in any\n+** other process. This opcode cannot be used to detect transactions opened\n+** by clients within the current process, only within other processes.\n+** <\/ul>\n+**\n+** <li>[[SQLITE_FCNTL_CKSM_FILE]]\n+** Used by the cksmvfs VFS module only.\n+** <\/ul>\n@@ -1166,0 +1225,2 @@\n+#define SQLITE_FCNTL_EXTERNAL_READER        40\n+#define SQLITE_FCNTL_CKSM_FILE              41\n@@ -1270,1 +1331,1 @@\n-** <li>  [SQLITE_OPEN_MASTER_JOURNAL]\n+** <li>  [SQLITE_OPEN_SUPER_JOURNAL]\n@@ -1648,1 +1709,1 @@\n-** SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokes\n+** SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes\n@@ -2114,1 +2175,7 @@\n-** which case the trigger setting is not reported back. <\/dd>\n+** which case the trigger setting is not reported back.\n+**\n+** <p>Originally this option disabled all triggers.  ^(However, since\n+** SQLite version 3.35.0, TEMP triggers are still allowed even if\n+** this option is off.  So, in other words, this option now only disables\n+** triggers in the main database schema or in the schemas of ATTACH-ed\n+** databases.)^ <\/dd>\n@@ -2125,1 +2192,7 @@\n-** which case the view setting is not reported back. <\/dd>\n+** which case the view setting is not reported back.\n+**\n+** <p>Originally this option disabled all views.  ^(However, since\n+** SQLite version 3.35.0, TEMP views are still allowed even if\n+** this option is off.  So, in other words, this option now only disables\n+** views in the main database schema or in the schemas of ATTACH-ed\n+** databases.)^ <\/dd>\n@@ -2286,2 +2359,1 @@\n-** assume that database schemas (the contents of the [sqlite_master] tables)\n-** are untainted by malicious content.\n+** assume that database schemas are untainted by malicious content.\n@@ -2433,1 +2505,1 @@\n-** ^This function returns the number of rows modified, inserted or\n+** ^These functions return the number of rows modified, inserted or\n@@ -2436,2 +2508,5 @@\n-** ^Executing any other type of SQL statement does not modify the value\n-** returned by this function.\n+** The two functions are identical except for the type of the return value\n+** and that if the number of rows modified by the most recent INSERT, UPDATE\n+** or DELETE is greater than the maximum value supported by type \"int\", then\n+** the return value of sqlite3_changes() is undefined. ^Executing any other\n+** type of SQL statement does not modify the value returned by these functions.\n@@ -2486,0 +2561,1 @@\n+SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3*);\n@@ -2491,1 +2567,1 @@\n-** ^This function returns the total number of rows inserted, modified or\n+** ^These functions return the total number of rows inserted, modified or\n@@ -2494,2 +2570,6 @@\n-** part of trigger programs. ^Executing any other type of SQL statement\n-** does not affect the value returned by sqlite3_total_changes().\n+** part of trigger programs. The two functions are identical except for the\n+** type of the return value and that if the number of rows modified by the\n+** connection exceeds the maximum value supported by type \"int\", then\n+** the return value of sqlite3_total_changes() is undefined. ^Executing\n+** any other type of SQL statement does not affect the value returned by\n+** sqlite3_total_changes().\n@@ -2523,0 +2603,1 @@\n+SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3*);\n@@ -3352,0 +3433,8 @@\n+** [[OPEN_EXRESCODE]] ^(<dt>[SQLITE_OPEN_EXRESCODE]<\/dt>\n+** <dd>The database connection comes up in \"extended result code mode\".\n+** In other words, the database behaves has if\n+** [sqlite3_extended_result_codes(db,1)] where called on the database\n+** connection as soon as the connection is created. In addition to setting\n+** the extended result code mode, this flag also causes [sqlite3_open_v2()]\n+** to return an extended result code.<\/dd>\n+**\n@@ -3359,1 +3448,9 @@\n-** then the behavior is undefined.\n+** then the behavior is undefined.  Historic versions of SQLite\n+** have silently ignored surplus bits in the flags parameter to\n+** sqlite3_open_v2(), however that behavior might not be carried through\n+** into future versions of SQLite and so applications should not rely\n+** upon it.  Note in particular that the SQLITE_OPEN_EXCLUSIVE flag is a no-op\n+** for sqlite3_open_v2().  The SQLITE_OPEN_EXCLUSIVE does *not* cause\n+** the open to fail if the database already exists.  The SQLITE_OPEN_EXCLUSIVE\n+** flag is intended for use by the [sqlite3_vfs|VFS interface] only, and not\n+** by sqlite3_open_v2().\n@@ -3499,0 +3596,1 @@\n+**          Use \"ro\" instead:  \"file:data.db?mode=ro\".\n@@ -3697,1 +3795,1 @@\n-** corruption or segfaults may occur. The value Y should be\n+** corruption or segfaults may occur. The value Y should not be\n@@ -4126,1 +4224,1 @@\n-** is obtained from [sqlite3_malloc()] and must be free by the application\n+** is obtained from [sqlite3_malloc()] and must be freed by the application\n@@ -4128,0 +4226,3 @@\n+**\n+** ^The sqlite3_normalized_sql() interface is only available if\n+** the [SQLITE_ENABLE_NORMALIZE] compile-time option is defined.\n@@ -4131,0 +4232,1 @@\n+#ifdef SQLITE_ENABLE_NORMALIZE\n@@ -4132,0 +4234,1 @@\n+#endif\n@@ -4166,0 +4269,9 @@\n+**\n+** ^This routine returns false if there is any possibility that the\n+** statement might change the database file.  ^A false return does\n+** not guarantee that the statement will change the database file.\n+** ^For example, an UPDATE statement might have a WHERE clause that\n+** makes it a no-op, but the sqlite3_stmt_readonly() result would still\n+** be false.  ^Similarly, a CREATE TABLE IF NOT EXISTS statement is a\n+** read-only no-op if the table already exists, but\n+** sqlite3_stmt_readonly() still returns false for such a statement.\n@@ -4335,12 +4447,16 @@\n-** ^The fifth argument to the BLOB and string binding interfaces\n-** is a destructor used to dispose of the BLOB or\n-** string after SQLite has finished with it.  ^The destructor is called\n-** to dispose of the BLOB or string even if the call to the bind API fails,\n-** except the destructor is not called if the third parameter is a NULL\n-** pointer or the fourth parameter is negative.\n-** ^If the fifth argument is\n-** the special value [SQLITE_STATIC], then SQLite assumes that the\n-** information is in static, unmanaged space and does not need to be freed.\n-** ^If the fifth argument has the value [SQLITE_TRANSIENT], then\n-** SQLite makes its own private copy of the data immediately, before\n-** the sqlite3_bind_*() routine returns.\n+** ^The fifth argument to the BLOB and string binding interfaces controls\n+** or indicates the lifetime of the object referenced by the third parameter.\n+** These three options exist:\n+** ^ (1) A destructor to dispose of the BLOB or string after SQLite has finished\n+** with it may be passed. ^It is called to dispose of the BLOB or string even\n+** if the call to the bind API fails, except the destructor is not called if\n+** the third parameter is a NULL pointer or the fourth parameter is negative.\n+** ^ (2) The special constant, [SQLITE_STATIC], may be passsed to indicate that\n+** the application remains responsible for disposing of the object. ^In this\n+** case, the object and the provided pointer to it must remain valid until\n+** either the prepared statement is finalized or the same SQL parameter is\n+** bound to something else, whichever occurs sooner.\n+** ^ (3) The constant, [SQLITE_TRANSIENT], may be passed to indicate that the\n+** object is to be copied prior to the return from sqlite3_bind_*(). ^The\n+** object and pointer to it must remain valid until then. ^SQLite will then\n+** manage the lifetime of its private copy.\n@@ -5088,1 +5204,0 @@\n-** <span style=\"background-color:#ffff90;\">\n@@ -5098,1 +5213,0 @@\n-** <\/span>\n@@ -6187,0 +6301,51 @@\n+\/*\n+** CAPI3REF: Determine the transaction state of a database\n+** METHOD: sqlite3\n+**\n+** ^The sqlite3_txn_state(D,S) interface returns the current\n+** [transaction state] of schema S in database connection D.  ^If S is NULL,\n+** then the highest transaction state of any schema on database connection D\n+** is returned.  Transaction states are (in order of lowest to highest):\n+** <ol>\n+** <li value=\"0\"> SQLITE_TXN_NONE\n+** <li value=\"1\"> SQLITE_TXN_READ\n+** <li value=\"2\"> SQLITE_TXN_WRITE\n+** <\/ol>\n+** ^If the S argument to sqlite3_txn_state(D,S) is not the name of\n+** a valid schema, then -1 is returned.\n+*\/\n+SQLITE_API int sqlite3_txn_state(sqlite3*,const char *zSchema);\n+\n+\/*\n+** CAPI3REF: Allowed return values from [sqlite3_txn_state()]\n+** KEYWORDS: {transaction state}\n+**\n+** These constants define the current transaction state of a database file.\n+** ^The [sqlite3_txn_state(D,S)] interface returns one of these\n+** constants in order to describe the transaction state of schema S\n+** in [database connection] D.\n+**\n+** <dl>\n+** [[SQLITE_TXN_NONE]] <dt>SQLITE_TXN_NONE<\/dt>\n+** <dd>The SQLITE_TXN_NONE state means that no transaction is currently\n+** pending.<\/dd>\n+**\n+** [[SQLITE_TXN_READ]] <dt>SQLITE_TXN_READ<\/dt>\n+** <dd>The SQLITE_TXN_READ state means that the database is currently\n+** in a read transaction.  Content has been read from the database file\n+** but nothing in the database file has changed.  The transaction state\n+** will advanced to SQLITE_TXN_WRITE if any changes occur and there are\n+** no other conflicting concurrent write transactions.  The transaction\n+** state will revert to SQLITE_TXN_NONE following a [ROLLBACK] or\n+** [COMMIT].<\/dd>\n+**\n+** [[SQLITE_TXN_WRITE]] <dt>SQLITE_TXN_WRITE<\/dt>\n+** <dd>The SQLITE_TXN_WRITE state means that the database is currently\n+** in a write transaction.  Content has been written to the database file\n+** but has not yet committed.  The transaction state will change to\n+** to SQLITE_TXN_NONE at the next [ROLLBACK] or [COMMIT].<\/dd>\n+*\/\n+#define SQLITE_TXN_NONE  0\n+#define SQLITE_TXN_READ  1\n+#define SQLITE_TXN_WRITE 2\n+\n@@ -6253,0 +6418,66 @@\n+\/*\n+** CAPI3REF: Autovacuum Compaction Amount Callback\n+** METHOD: sqlite3\n+**\n+** ^The sqlite3_autovacuum_pages(D,C,P,X) interface registers a callback\n+** function C that is invoked prior to each autovacuum of the database\n+** file.  ^The callback is passed a copy of the generic data pointer (P),\n+** the schema-name of the attached database that is being autovacuumed,\n+** the the size of the database file in pages, the number of free pages,\n+** and the number of bytes per page, respectively.  The callback should\n+** return the number of free pages that should be removed by the\n+** autovacuum.  ^If the callback returns zero, then no autovacuum happens.\n+** ^If the value returned is greater than or equal to the number of\n+** free pages, then a complete autovacuum happens.\n+**\n+** <p>^If there are multiple ATTACH-ed database files that are being\n+** modified as part of a transaction commit, then the autovacuum pages\n+** callback is invoked separately for each file.\n+**\n+** <p><b>The callback is not reentrant.<\/b> The callback function should\n+** not attempt to invoke any other SQLite interface.  If it does, bad\n+** things may happen, including segmentation faults and corrupt database\n+** files.  The callback function should be a simple function that\n+** does some arithmetic on its input parameters and returns a result.\n+**\n+** ^The X parameter to sqlite3_autovacuum_pages(D,C,P,X) is an optional\n+** destructor for the P parameter.  ^If X is not NULL, then X(P) is\n+** invoked whenever the database connection closes or when the callback\n+** is overwritten by another invocation of sqlite3_autovacuum_pages().\n+**\n+** <p>^There is only one autovacuum pages callback per database connection.\n+** ^Each call to the sqlite3_autovacuum_pages() interface overrides all\n+** previous invocations for that database connection.  ^If the callback\n+** argument (C) to sqlite3_autovacuum_pages(D,C,P,X) is a NULL pointer,\n+** then the autovacuum steps callback is cancelled.  The return value\n+** from sqlite3_autovacuum_pages() is normally SQLITE_OK, but might\n+** be some other error code if something goes wrong.  The current\n+** implementation will only return SQLITE_OK or SQLITE_MISUSE, but other\n+** return codes might be added in future releases.\n+**\n+** <p>If no autovacuum pages callback is specified (the usual case) or\n+** a NULL pointer is provided for the callback,\n+** then the default behavior is to vacuum all free pages.  So, in other\n+** words, the default behavior is the same as if the callback function\n+** were something like this:\n+**\n+** <blockquote><pre>\n+** &nbsp;   unsigned int demonstration_autovac_pages_callback(\n+** &nbsp;     void *pClientData,\n+** &nbsp;     const char *zSchema,\n+** &nbsp;     unsigned int nDbPage,\n+** &nbsp;     unsigned int nFreePage,\n+** &nbsp;     unsigned int nBytePerPage\n+** &nbsp;   ){\n+** &nbsp;     return nFreePage;\n+** &nbsp;   }\n+** <\/pre><\/blockquote>\n+*\/\n+SQLITE_API int sqlite3_autovacuum_pages(\n+  sqlite3 *db,\n+  unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),\n+  void*,\n+  void(*)(void*)\n+);\n+\n+\n@@ -6277,1 +6508,1 @@\n-** modified (i.e. sqlite_master and sqlite_sequence).)^\n+** modified (i.e. sqlite_sequence).)^\n@@ -7379,1 +7610,1 @@\n-** <li>  SQLITE_MUTEX_STATIC_MASTER\n+** <li>  SQLITE_MUTEX_STATIC_MAIN\n@@ -7581,1 +7812,1 @@\n-#define SQLITE_MUTEX_STATIC_MASTER    2\n+#define SQLITE_MUTEX_STATIC_MAIN      2\n@@ -7596,0 +7827,4 @@\n+\/* Legacy compatibility: *\/\n+#define SQLITE_MUTEX_STATIC_MASTER    2\n+\n+\n@@ -7709,1 +7944,4 @@\n-#define SQLITE_TESTCTRL_LAST                    29  \/* Largest TESTCTRL *\/\n+#define SQLITE_TESTCTRL_SEEK_COUNT              30\n+#define SQLITE_TESTCTRL_TRACEFLAGS              31\n+#define SQLITE_TESTCTRL_TUNE                    32\n+#define SQLITE_TESTCTRL_LAST                    32  \/* Largest TESTCTRL *\/\n@@ -8909,2 +9147,3 @@\n-** previously registered write-ahead log callback. ^Note that the\n-** [sqlite3_wal_autocheckpoint()] interface and the\n+** previously registered write-ahead log callback. ^The return value is\n+** a copy of the third parameter from the previous call, if any, or 0.\n+** ^Note that the [sqlite3_wal_autocheckpoint()] interface and the\n@@ -9189,1 +9428,1 @@\n-** method of a [virtual table], then it returns true if and only if the\n+** method of a [virtual table], then it might return true if the\n@@ -9191,2 +9430,3 @@\n-** column value will not change.  Applications might use this to substitute\n-** a return value that is less expensive to compute and that the corresponding\n+** column value will not change.  The virtual table implementation can use\n+** this hint as permission to substitute a return value that is less\n+** expensive to compute and that the corresponding\n@@ -9201,0 +9441,6 @@\n+**\n+** The sqlite3_vtab_nochange() routine is an optimization.  Virtual table\n+** implementations should continue to give a correct answer even if the\n+** sqlite3_vtab_nochange() interface were to always return false.  In the\n+** current implementation, the sqlite3_vtab_nochange() interface does always\n+** returns false for the enhanced [UPDATE FROM] statement.\n@@ -9342,0 +9588,1 @@\n+** METHOD: sqlite3\n@@ -9374,0 +9621,1 @@\n+** METHOD: sqlite3\n@@ -9391,1 +9639,1 @@\n-** system tables like sqlite_master or sqlite_stat1.\n+** system tables like sqlite_sequence or sqlite_stat1.\n@@ -9414,1 +9662,1 @@\n-** INSERT operations on rowid tables.\n+** DELETE operations on rowid tables.\n@@ -9452,0 +9700,9 @@\n+** When the [sqlite3_blob_write()] API is used to update a blob column,\n+** the pre-update hook is invoked with SQLITE_DELETE. This is because the\n+** in this case the new values are not available. In this case, when a\n+** callback made with op==SQLITE_DELETE is actuall a write using the\n+** sqlite3_blob_write() API, the [sqlite3_preupdate_blobwrite()] returns\n+** the index of the column being written. In other cases, where the\n+** pre-update hook is being invoked for some other reason, including a\n+** regular DELETE, sqlite3_preupdate_blobwrite() returns -1.\n+**\n@@ -9472,0 +9729,1 @@\n+SQLITE_API int sqlite3_preupdate_blobwrite(sqlite3 *);\n@@ -9476,0 +9734,1 @@\n+** METHOD: sqlite3\n@@ -9709,2 +9968,2 @@\n-** This interface is only available if SQLite is compiled with the\n-** [SQLITE_ENABLE_DESERIALIZE] option.\n+** This interface is omitted if SQLite is compiled with the\n+** [SQLITE_OMIT_DESERIALIZE] option.\n@@ -9757,0 +10016,4 @@\n+** It is not possible to deserialized into the TEMP database.  If the\n+** S argument to sqlite3_deserialize(D,S,P,N,M,F) is \"temp\" then the\n+** function returns SQLITE_ERROR.\n+**\n@@ -9761,2 +10024,2 @@\n-** This interface is only available if SQLite is compiled with the\n-** [SQLITE_ENABLE_DESERIALIZE] option.\n+** This interface is omitted if SQLite is compiled with the\n+** [SQLITE_OMIT_DESERIALIZE] option.\n@@ -10011,0 +10274,32 @@\n+\/*\n+** CAPIREF: Conigure a Session Object\n+** METHOD: sqlite3_session\n+**\n+** This method is used to configure a session object after it has been\n+** created. At present the only valid value for the second parameter is\n+** [SQLITE_SESSION_OBJCONFIG_SIZE].\n+**\n+** Arguments for sqlite3session_object_config()\n+**\n+** The following values may passed as the the 4th parameter to\n+** sqlite3session_object_config().\n+**\n+** <dt>SQLITE_SESSION_OBJCONFIG_SIZE <dd>\n+**   This option is used to set, clear or query the flag that enables\n+**   the [sqlite3session_changeset_size()] API. Because it imposes some\n+**   computational overhead, this API is disabled by default. Argument\n+**   pArg must point to a value of type (int). If the value is initially\n+**   0, then the sqlite3session_changeset_size() API is disabled. If it\n+**   is greater than 0, then the same API is enabled. Or, if the initial\n+**   value is less than zero, no change is made. In all cases the (int)\n+**   variable is set to 1 if the sqlite3session_changeset_size() API is\n+**   enabled following the current call, or 0 otherwise.\n+**\n+**   It is an error (SQLITE_MISUSE) to attempt to modify this setting after\n+**   the first table has been attached to the session object.\n+*\/\n+SQLITE_API int sqlite3session_object_config(sqlite3_session*, int op, void *pArg);\n+\n+\/*\n+*\/\n+#define SQLITE_SESSION_OBJCONFIG_SIZE 1\n@@ -10255,0 +10550,16 @@\n+\/*\n+** CAPI3REF: Return An Upper-limit For The Size Of The Changeset\n+** METHOD: sqlite3_session\n+**\n+** By default, this function always returns 0. For it to return\n+** a useful result, the sqlite3_session object must have been configured\n+** to enable this API using sqlite3session_object_config() with the\n+** SQLITE_SESSION_OBJCONFIG_SIZE verb.\n+**\n+** When enabled, this function returns an upper limit, in bytes, for the size\n+** of the changeset that might be produced if sqlite3session_changeset() were\n+** called. The final changeset size might be equal to or smaller than the\n+** size in bytes returned by this function.\n+*\/\n+SQLITE_API sqlite3_int64 sqlite3session_changeset_size(sqlite3_session *pSession);\n+\n@@ -10372,0 +10683,8 @@\n+\/*\n+** CAPI3REF: Query for the amount of heap memory used by a session object.\n+**\n+** This API returns the total amount of heap memory in bytes currently\n+** used by the session object passed as the only argument.\n+*\/\n+SQLITE_API sqlite3_int64 sqlite3session_memory_used(sqlite3_session *pSession);\n+\n@@ -10474,7 +10793,14 @@\n-** If argument pzTab is not NULL, then *pzTab is set to point to a\n-** nul-terminated utf-8 encoded string containing the name of the table\n-** affected by the current change. The buffer remains valid until either\n-** sqlite3changeset_next() is called on the iterator or until the\n-** conflict-handler function returns. If pnCol is not NULL, then *pnCol is\n-** set to the number of columns in the table affected by the change. If\n-** pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change\n+** Arguments pOp, pnCol and pzTab may not be NULL. Upon return, three\n+** outputs are set through these pointers:\n+**\n+** *pOp is set to one of [SQLITE_INSERT], [SQLITE_DELETE] or [SQLITE_UPDATE],\n+** depending on the type of change that the iterator currently points to;\n+**\n+** *pnCol is set to the number of columns in the table affected by the change; and\n+**\n+** *pzTab is set to point to a nul-terminated utf-8 encoded string containing\n+** the name of the table affected by the current change. The buffer remains\n+** valid until either sqlite3changeset_next() is called on the iterator\n+** or until the conflict-handler function returns.\n+**\n+** If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change\n@@ -10483,3 +10809,1 @@\n-** changes. Finally, if pOp is not NULL, then *pOp is set to one of\n-** [SQLITE_INSERT], [SQLITE_DELETE] or [SQLITE_UPDATE], depending on the\n-** type of change that the iterator currently points to.\n+** changes.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.h","additions":384,"deletions":60,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -338,0 +338,9 @@\n+  \/* Version 3.34.0 and later *\/\n+  int (*txn_state)(sqlite3*,const char*);\n+  \/* Version 3.36.1 and later *\/\n+  sqlite3_int64 (*changes64)(sqlite3*);\n+  sqlite3_int64 (*total_changes64)(sqlite3*);\n+  \/* Version 3.37.0 and later *\/\n+  int (*autovacuum_pages)(sqlite3*,\n+     unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),\n+     void*, void(*)(void*));\n@@ -642,0 +651,7 @@\n+\/* Version 3.34.0 and later *\/\n+#define sqlite3_txn_state              sqlite3_api->txn_state\n+\/* Version 3.36.1 and later *\/\n+#define sqlite3_changes64              sqlite3_api->changes64\n+#define sqlite3_total_changes64        sqlite3_api->total_changes64\n+\/* Version 3.37.0 and later *\/\n+#define sqlite3_autovacuum_pages       sqlite3_api->autovacuum_pages\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3ext.h","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}