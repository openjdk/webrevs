{"files":[{"patch":"@@ -552,2 +552,0 @@\n-  \/\/ Read header at the begining of cache\n-  uint header_size = sizeof(SCCHeader);\n@@ -556,5 +554,16 @@\n-    _C_load_buffer = NEW_C_HEAP_ARRAY(char, load_size + DATA_ALIGNMENT, mtCode);\n-    _load_buffer = align_up(_C_load_buffer, DATA_ALIGNMENT);\n-    uint n = (uint)::read(fd, _load_buffer, load_size);\n-    if (n != load_size) {\n-      log_warning(scc, init)(\"Failed to read %d bytes at address \" INTPTR_FORMAT \" from Startup Code Cache file '%s'\", load_size, p2i(_load_buffer), _cache_path);\n+    if (MmapCachedCode) {\n+      \/\/ Implementation note: the mapping is not read-only, because entries are updated in-place.\n+      \/\/ However, this mapping is MAP_PRIVATE, which means the changes to mapping do not reflect\n+      \/\/ in the backing file. TODO: Avoid in-place modifications, so we do not have to rely on this?\n+      _load_buffer = os::map_memory(fd, _cache_path, 0, nullptr, load_size,\n+                                   false,false, mtCode);\n+    } else {\n+      _C_load_buffer = NEW_C_HEAP_ARRAY(char, load_size + DATA_ALIGNMENT, mtCode);\n+      _load_buffer = align_up(_C_load_buffer, DATA_ALIGNMENT);\n+      uint n = (uint)::read(fd, _load_buffer, load_size);\n+      if (n != load_size) {\n+        _load_buffer = nullptr;\n+      }\n+    }\n+    if (_load_buffer == nullptr) {\n+      log_warning(scc, init)(\"Failed to read\/mmap %d bytes at address \" INTPTR_FORMAT \" from Startup Code Cache file '%s'\", load_size, p2i(_load_buffer), _cache_path);\n@@ -564,1 +573,1 @@\n-    log_info(scc, init)(\"Read %d bytes at address \" INTPTR_FORMAT \" from Startup Code Cache '%s'\", load_size, p2i(_load_buffer), _cache_path);\n+    log_info(scc, init)(\"Read\/mmaped %d bytes at address \" INTPTR_FORMAT \" from Startup Code Cache '%s'\", load_size, p2i(_load_buffer), _cache_path);\n@@ -773,4 +782,11 @@\n-  if (_C_load_buffer != nullptr) {\n-    FREE_C_HEAP_ARRAY(char, _C_load_buffer);\n-    _C_load_buffer = nullptr;\n-    _load_buffer = nullptr;\n+  if (MmapCachedCode) {\n+    if (_load_buffer != nullptr) {\n+      os::unmap_memory(_load_buffer, _load_size);\n+      _load_buffer = nullptr;\n+    }\n+  } else {\n+    if (_C_load_buffer != nullptr) {\n+      FREE_C_HEAP_ARRAY(char, _C_load_buffer);\n+      _C_load_buffer = nullptr;\n+      _load_buffer = nullptr;\n+    }\n","filename":"src\/hotspot\/share\/code\/SCCache.cpp","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -459,0 +459,3 @@\n+  product(bool, MmapCachedCode, NOT_WINDOWS(true) WINDOWS_ONLY(false),      \\\n+          \"Mmap cached code file instead of reading it fully at startup.\")  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}