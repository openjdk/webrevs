{"files":[{"patch":"@@ -51,0 +51,2 @@\n+const char* VM_Version::_features_names[MAX_CPU_FEATURES] = { nullptr };\n+\n@@ -72,0 +74,5 @@\n+#define SET_CPU_FEATURE_NAME(id, name, bit) \\\n+  _features_names[bit] = XSTR(name);\n+  CPU_FEATURE_FLAGS(SET_CPU_FEATURE_NAME)\n+#undef SET_CPU_FEATURE_NAME\n+\n@@ -206,1 +213,1 @@\n-    _features |= CPU_A53MAC;\n+    set_feature(CPU_A53MAC);\n@@ -246,1 +253,1 @@\n-  if (_features & (CPU_FP | CPU_ASIMD)) {\n+  if (supports_feature(CPU_FP) || supports_feature(CPU_ASIMD)) {\n@@ -409,1 +416,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -420,1 +427,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -431,1 +438,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -632,2 +639,2 @@\n-    _features &= ~CPU_SVE2;\n-    _features &= ~CPU_SVEBITPERM;\n+    clear_feature(CPU_SVE2);\n+    clear_feature(CPU_SVEBITPERM);\n@@ -636,1 +643,1 @@\n-    _features &= ~CPU_SVE;\n+    clear_feature(CPU_SVE);\n@@ -728,0 +735,64 @@\n+\n+void VM_Version::insert_features_names(uint64_t features, char* names_buf, size_t buf_size) {\n+  char* buf = names_buf;\n+  size_t buf_rem = buf_size;\n+  bool first = true;\n+  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n+    if (supports_feature(features, (VM_Version::Feature_Flag)i)) {\n+      int res = 0;\n+      if (first) {\n+        res = jio_snprintf(buf, buf_size, \"%s\", _features_names[i]);\n+      } else {\n+        res = jio_snprintf(buf, buf_size, \", %s\", _features_names[i]);\n+      }\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      buf += res;\n+      buf_rem -= res;\n+      first = false;\n+    }\n+  }\n+}\n+\n+void VM_Version::get_supported_cpu_features_name(char* names_buf, size_t buf_size) {\n+  insert_features_names(_features, names_buf, buf_size);\n+}\n+\n+void VM_Version::get_cpu_features_name(void* features_buffer, char* names_buf, size_t buf_size) {\n+  uint64_t features = *(uint64_t*)features_buffer;\n+  insert_features_names(features, names_buf, buf_size);\n+}\n+\n+void VM_Version::get_missing_features_name(void* features_buffer, char* missing_features_name, size_t buf_size) {\n+  uint64_t features_to_test = *(uint64_t*)features_buffer;\n+  char* buf = missing_features_name;\n+  size_t buf_rem = buf_size;\n+  bool first = true;\n+  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n+    Feature_Flag flag = (Feature_Flag)i;\n+    if (supports_feature(features_to_test, flag) && !supports_feature(flag)) {\n+      int res = 0;\n+      if (first) {\n+        res = jio_snprintf(buf, buf_size, \"%s\", _features_names[i]);\n+      } else {\n+        res = jio_snprintf(buf, buf_size, \", %s\", _features_names[i]);\n+      }\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      buf += res;\n+      buf_rem -= res;\n+      first = false;\n+    }\n+  }\n+}\n+\n+int VM_Version::cpu_features_size() {\n+  return sizeof(_features);\n+}\n+\n+void VM_Version::store_cpu_features(void* buf) {\n+  *(uint64_t*)buf = _features;\n+}\n+\n+bool VM_Version::supports_features(void* features_buffer) {\n+  uint64_t features_to_test = *(uint64_t*)features_buffer;\n+  return (_features & features_to_test) == features_to_test;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":79,"deletions":8,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define BIT_MASK(flag) (1ULL<<(flag))\n+\n@@ -64,0 +66,2 @@\n+  static void insert_features_names(uint64_t features, char* names_buf, size_t buf_size);\n+\n@@ -141,1 +145,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = bit,\n@@ -144,0 +148,1 @@\n+    MAX_CPU_FEATURES\n@@ -146,0 +151,4 @@\n+  STATIC_ASSERT(sizeof(_features) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+  static const char* _features_names[MAX_CPU_FEATURES];\n+\n@@ -148,1 +157,1 @@\n-  static bool supports_##name() { return (_features & CPU_##id) != 0; };\n+  static bool supports_##name() { return supports_feature(CPU_##id); }\n@@ -152,0 +161,13 @@\n+  static void set_feature(Feature_Flag flag) {\n+    _features |= BIT_MASK(flag);\n+  }\n+  static void clear_feature(Feature_Flag flag) {\n+    _features &= (~BIT_MASK(flag));\n+  }\n+  static bool supports_feature(Feature_Flag flag) {\n+    return (_features & BIT_MASK(flag)) != 0;\n+  }\n+  static bool supports_feature(uint64_t features, Feature_Flag flag) {\n+    return (features & BIT_MASK(flag)) != 0;\n+  }\n+\n@@ -202,0 +224,13 @@\n+\n+  static void get_supported_cpu_features_name(char* names_buf, size_t buf_size);\n+  static void get_cpu_features_name(void* features_buffer, char* names_buf, size_t buf_size);\n+  static void get_missing_features_name(void* features_buffer, char* missing_features_name, size_t buf_size);\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size();\n+\n+  \/\/ Stores cpu features representation in the provided buffer. This representation is arch dependent.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf);\n+\n+  static bool supports_features(void* features_to_test);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#define DECLARE_CPU_FEATURE_NAME(id, name, bit) name,\n+#define DECLARE_CPU_FEATURE_NAME(id, name, bit) XSTR(name),\n@@ -1111,1 +1111,1 @@\n-  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n+  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size, \/* use_front_comma *\/ true);\n@@ -3299,1 +3299,2 @@\n-void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen, bool use_front_comma) {\n+  bool first = true;\n@@ -3302,1 +3303,6 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n+      int res = 0;\n+      if (first && !use_front_comma) {\n+        res = jio_snprintf(buf, buflen, \"%s\", _features_names[i]);\n+      } else {\n+        res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n+      }\n@@ -3306,0 +3312,1 @@\n+      first = false;\n@@ -3309,0 +3316,43 @@\n+\n+void VM_Version::get_supported_cpu_features_name(char* names_buf, size_t buf_size) {\n+  insert_features_names(_features, names_buf, buf_size, \/* use_front_comma *\/ false);\n+}\n+\n+void VM_Version::get_cpu_features_name(void* features_buffer, char* names_buf, size_t buf_size) {\n+  VM_Features* features = (VM_Features*)features_buffer;\n+  insert_features_names(*features, names_buf, buf_size, \/* use_front_comma *\/ false);\n+}\n+\n+void VM_Version::get_missing_features_name(void* features_buffer, char* missing_features_name, size_t buf_size) {\n+  VM_Features* features_to_test = (VM_Features*)features_buffer;\n+  char* buf = missing_features_name;\n+  size_t buf_rem = buf_size;\n+  bool first = true;\n+  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n+    Feature_Flag flag = (Feature_Flag)i;\n+    if (features_to_test->supports_feature(flag) && !_features.supports_feature(flag)) {\n+      int res = 0;\n+      if (first) {\n+        res = jio_snprintf(buf, buf_size, \"%s\", _features_names[i]);\n+      } else {\n+        res = jio_snprintf(buf, buf_size, \", %s\", _features_names[i]);\n+      }\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      buf += res;\n+      buf_rem -= res;\n+    }\n+  }\n+}\n+\n+int VM_Version::cpu_features_size() {\n+  return sizeof(VM_Features);\n+}\n+\n+void VM_Version::store_cpu_features(void* buf) {\n+  memcpy(buf, &_features, sizeof(VM_Features));\n+}\n+\n+bool VM_Version::supports_features(void* features_buffer) {\n+  VM_Features* features_to_test = (VM_Features*)features_buffer;\n+  return _features.supports_features(features_to_test);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":54,"deletions":4,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -369,4 +369,4 @@\n-    decl(CX8,               \"cx8\",               0)  \/*  next bits are from cpuid 1 (EDX) *\/ \\\n-    decl(CMOV,              \"cmov\",              1)  \\\n-    decl(FXSR,              \"fxsr\",              2)  \\\n-    decl(HT,                \"ht\",                3)  \\\n+    decl(CX8,               cx8,               0)  \/*  next bits are from cpuid 1 (EDX) *\/ \\\n+    decl(CMOV,              cmov,              1)  \\\n+    decl(FXSR,              fxsr,              2)  \\\n+    decl(HT,                ht,                3)  \\\n@@ -374,2 +374,2 @@\n-    decl(MMX,               \"mmx\",               4)  \\\n-    decl(3DNOW_PREFETCH,    \"3dnowpref\",         5)  \/* Processor supports 3dnow prefetch and prefetchw instructions *\/ \\\n+    decl(MMX,               mmx,               4)  \\\n+    decl(3DNOW_PREFETCH,    3dnowpref,         5)  \/* Processor supports 3dnow prefetch and prefetchw instructions *\/ \\\n@@ -377,2 +377,2 @@\n-    decl(SSE,               \"sse\",               6)  \\\n-    decl(SSE2,              \"sse2\",              7)  \\\n+    decl(SSE,               sse,               6)  \\\n+    decl(SSE2,              sse2,              7)  \\\n@@ -380,4 +380,4 @@\n-    decl(SSE3,              \"sse3\",              8 ) \/* SSE3 comes from cpuid 1 (ECX) *\/ \\\n-    decl(SSSE3,             \"ssse3\",             9 ) \\\n-    decl(SSE4A,             \"sse4a\",             10) \\\n-    decl(SSE4_1,            \"sse4.1\",            11) \\\n+    decl(SSE3,              sse3,              8 ) \/* SSE3 comes from cpuid 1 (ECX) *\/ \\\n+    decl(SSSE3,             ssse3,             9 ) \\\n+    decl(SSE4A,             sse4a,             10) \\\n+    decl(SSE4_1,            sse4.1,            11) \\\n@@ -385,4 +385,4 @@\n-    decl(SSE4_2,            \"sse4.2\",            12) \\\n-    decl(POPCNT,            \"popcnt\",            13) \\\n-    decl(LZCNT,             \"lzcnt\",             14) \\\n-    decl(TSC,               \"tsc\",               15) \\\n+    decl(SSE4_2,            sse4.2,            12) \\\n+    decl(POPCNT,            popcnt,            13) \\\n+    decl(LZCNT,             lzcnt,             14) \\\n+    decl(TSC,               tsc,               15) \\\n@@ -390,4 +390,4 @@\n-    decl(TSCINV_BIT,        \"tscinvbit\",         16) \\\n-    decl(TSCINV,            \"tscinv\",            17) \\\n-    decl(AVX,               \"avx\",               18) \\\n-    decl(AVX2,              \"avx2\",              19) \\\n+    decl(TSCINV_BIT,        tscinvbit,         16) \\\n+    decl(TSCINV,            tscinv,            17) \\\n+    decl(AVX,               avx,               18) \\\n+    decl(AVX2,              avx2,              19) \\\n@@ -395,4 +395,4 @@\n-    decl(AES,               \"aes\",               20) \\\n-    decl(ERMS,              \"erms\",              21) \/* enhanced 'rep movsb\/stosb' instructions *\/ \\\n-    decl(CLMUL,             \"clmul\",             22) \/* carryless multiply for CRC *\/ \\\n-    decl(BMI1,              \"bmi1\",              23) \\\n+    decl(AES,               aes,               20) \\\n+    decl(ERMS,              erms,              21) \/* enhanced 'rep movsb\/stosb' instructions *\/ \\\n+    decl(CLMUL,             clmul,             22) \/* carryless multiply for CRC *\/ \\\n+    decl(BMI1,              bmi1,              23) \\\n@@ -400,4 +400,4 @@\n-    decl(BMI2,              \"bmi2\",              24) \\\n-    decl(RTM,               \"rtm\",               25) \/* Restricted Transactional Memory instructions *\/ \\\n-    decl(ADX,               \"adx\",               26) \\\n-    decl(AVX512F,           \"avx512f\",           27) \/* AVX 512bit foundation instructions *\/ \\\n+    decl(BMI2,              bmi2,              24) \\\n+    decl(RTM,               rtm,               25) \/* Restricted Transactional Memory instructions *\/ \\\n+    decl(ADX,               adx,               26) \\\n+    decl(AVX512F,           avx512f,           27) \/* AVX 512bit foundation instructions *\/ \\\n@@ -405,4 +405,4 @@\n-    decl(AVX512DQ,          \"avx512dq\",          28) \\\n-    decl(AVX512PF,          \"avx512pf\",          29) \\\n-    decl(AVX512ER,          \"avx512er\",          30) \\\n-    decl(AVX512CD,          \"avx512cd\",          31) \\\n+    decl(AVX512DQ,          avx512dq,          28) \\\n+    decl(AVX512PF,          avx512pf,          29) \\\n+    decl(AVX512ER,          avx512er,          30) \\\n+    decl(AVX512CD,          avx512cd,          31) \\\n@@ -410,4 +410,4 @@\n-    decl(AVX512BW,          \"avx512bw\",          32) \/* Byte and word vector instructions *\/ \\\n-    decl(AVX512VL,          \"avx512vl\",          33) \/* EVEX instructions with smaller vector length *\/ \\\n-    decl(SHA,               \"sha\",               34) \/* SHA instructions *\/ \\\n-    decl(FMA,               \"fma\",               35) \/* FMA instructions *\/ \\\n+    decl(AVX512BW,          avx512bw,          32) \/* Byte and word vector instructions *\/ \\\n+    decl(AVX512VL,          avx512vl,          33) \/* EVEX instructions with smaller vector length *\/ \\\n+    decl(SHA,               sha,               34) \/* SHA instructions *\/ \\\n+    decl(FMA,               fma,               35) \/* FMA instructions *\/ \\\n@@ -415,4 +415,4 @@\n-    decl(VZEROUPPER,        \"vzeroupper\",        36) \/* Vzeroupper instruction *\/ \\\n-    decl(AVX512_VPOPCNTDQ,  \"avx512_vpopcntdq\",  37) \/* Vector popcount *\/ \\\n-    decl(AVX512_VPCLMULQDQ, \"avx512_vpclmulqdq\", 38) \/* Vector carryless multiplication *\/ \\\n-    decl(AVX512_VAES,       \"avx512_vaes\",       39) \/* Vector AES instruction *\/ \\\n+    decl(VZEROUPPER,        vzeroupper,        36) \/* Vzeroupper instruction *\/ \\\n+    decl(AVX512_VPOPCNTDQ,  avx512_vpopcntdq,  37) \/* Vector popcount *\/ \\\n+    decl(AVX512_VPCLMULQDQ, avx512_vpclmulqdq, 38) \/* Vector carryless multiplication *\/ \\\n+    decl(AVX512_VAES,       avx512_vaes,       39) \/* Vector AES instruction *\/ \\\n@@ -420,4 +420,4 @@\n-    decl(AVX512_VNNI,       \"avx512_vnni\",       40) \/* Vector Neural Network Instructions *\/ \\\n-    decl(FLUSH,             \"clflush\",           41) \/* flush instruction *\/ \\\n-    decl(FLUSHOPT,          \"clflushopt\",        42) \/* flusopth instruction *\/ \\\n-    decl(CLWB,              \"clwb\",              43) \/* clwb instruction *\/ \\\n+    decl(AVX512_VNNI,       avx512_vnni,       40) \/* Vector Neural Network Instructions *\/ \\\n+    decl(FLUSH,             clflush,           41) \/* flush instruction *\/ \\\n+    decl(FLUSHOPT,          clflushopt,        42) \/* flusopth instruction *\/ \\\n+    decl(CLWB,              clwb,              43) \/* clwb instruction *\/ \\\n@@ -425,21 +425,21 @@\n-    decl(AVX512_VBMI2,      \"avx512_vbmi2\",      44) \/* VBMI2 shift left double instructions *\/ \\\n-    decl(AVX512_VBMI,       \"avx512_vbmi\",       45) \/* Vector BMI instructions *\/ \\\n-    decl(HV,                \"hv\",                46) \/* Hypervisor instructions *\/ \\\n-    decl(SERIALIZE,         \"serialize\",         47) \/* CPU SERIALIZE *\/ \\\n-    decl(RDTSCP,            \"rdtscp\",            48) \/* RDTSCP instruction *\/ \\\n-    decl(RDPID,             \"rdpid\",             49) \/* RDPID instruction *\/ \\\n-    decl(FSRM,              \"fsrm\",              50) \/* Fast Short REP MOV *\/ \\\n-    decl(GFNI,              \"gfni\",              51) \/* Vector GFNI instructions *\/ \\\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n-    decl(F16C,              \"f16c\",              53) \/* Half-precision and single precision FP conversion instructions*\/ \\\n-    decl(PKU,               \"pku\",               54) \/* Protection keys for user-mode pages *\/ \\\n-    decl(OSPKE,             \"ospke\",             55) \/* OS enables protection keys *\/ \\\n-    decl(CET_IBT,           \"cet_ibt\",           56) \/* Control Flow Enforcement - Indirect Branch Tracking *\/ \\\n-    decl(CET_SS,            \"cet_ss\",            57) \/* Control Flow Enforcement - Shadow Stack *\/ \\\n-    decl(AVX512_IFMA,       \"avx512_ifma\",       58) \/* Integer Vector FMA instructions*\/ \\\n-    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n-    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/ \\\n-    decl(SHA512,            \"sha512\",            61) \/* SHA512 instructions*\/ \\\n-    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/ \\\n-    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n-    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n+    decl(AVX512_VBMI2,      avx512_vbmi2,      44) \/* VBMI2 shift left double instructions *\/ \\\n+    decl(AVX512_VBMI,       avx512_vbmi,       45) \/* Vector BMI instructions *\/ \\\n+    decl(HV,                hv,                46) \/* Hypervisor instructions *\/ \\\n+    decl(SERIALIZE,         serialize,         47) \/* CPU SERIALIZE *\/ \\\n+    decl(RDTSCP,            rdtscp,            48) \/* RDTSCP instruction *\/ \\\n+    decl(RDPID,             rdpid,             49) \/* RDPID instruction *\/ \\\n+    decl(FSRM,              fsrm,              50) \/* Fast Short REP MOV *\/ \\\n+    decl(GFNI,              gfni,              51) \/* Vector GFNI instructions *\/ \\\n+    decl(AVX512_BITALG,     avx512_bitalg,     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(F16C,              f16c,              53) \/* Half-precision and single precision FP conversion instructions*\/ \\\n+    decl(PKU,               pku,               54) \/* Protection keys for user-mode pages *\/ \\\n+    decl(OSPKE,             ospke,             55) \/* OS enables protection keys *\/ \\\n+    decl(CET_IBT,           cet_ibt,           56) \/* Control Flow Enforcement - Indirect Branch Tracking *\/ \\\n+    decl(CET_SS,            cet_ss,            57) \/* Control Flow Enforcement - Shadow Stack *\/ \\\n+    decl(AVX512_IFMA,       avx512_ifma,       58) \/* Integer Vector FMA instructions*\/ \\\n+    decl(AVX_IFMA,          avx_ifma,          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n+    decl(APX_F,             apx_f,             60) \/* Intel Advanced Performance Extensions*\/ \\\n+    decl(SHA512,            sha512,            61) \/* SHA512 instructions*\/ \\\n+    decl(AVX512_FP16,       avx512_fp16,       62) \/* AVX512 FP16 ISA support*\/ \\\n+    decl(AVX10_1,           avx10_1,           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n+    decl(AVX10_2,           avx10_2,           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n@@ -486,0 +486,1 @@\n+\n@@ -507,0 +508,9 @@\n+\n+    bool supports_features(VM_Features* features_to_test) {\n+      for (int i = 0; i < features_bitmap_element_count(); i++) {\n+        if ((_features_bitmap[i] & features_to_test->_features_bitmap[i]) != features_to_test->_features_bitmap[i]) {\n+          return false;\n+       }\n+      }\n+      return true;\n+    }\n@@ -924,1 +934,1 @@\n-  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen, bool use_front_comma);\n@@ -1075,0 +1085,13 @@\n+\n+  static void get_supported_cpu_features_name(char* names_buf, size_t buf_size);\n+  static void get_cpu_features_name(void* features_buffer, char* names_buf, size_t buf_size);\n+  static void get_missing_features_name(void* features_buffer, char* missing_features_name, size_t buf_size);\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size();\n+\n+  \/\/ Stores cpu features representation in the provided buffer. This representation is arch dependent.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf);\n+\n+  static bool supports_features(void* features_to_test);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":89,"deletions":66,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -116,16 +116,16 @@\n-  static_assert(CPU_FP      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMD   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n-  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n-  static_assert(CPU_AES     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n-  static_assert(CPU_PMULL   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n-  static_assert(CPU_SHA1    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA2    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n-  static_assert(CPU_CRC32   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n-  static_assert(CPU_LSE     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n-  static_assert(CPU_DCPOP   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n-  static_assert(CPU_SHA3    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA512  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n-  static_assert(CPU_SVE     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n-  static_assert(CPU_PACA    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n-  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FP)      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMD)   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_EVTSTRM) == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_AES)     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PMULL)   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA1)    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA2)    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_CRC32)   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_LSE)     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_DCPOP)   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA3)    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA512)  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SVE)     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PACA)    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FPHP)    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMDHP) == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -150,2 +150,2 @@\n-  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;\n-  if (auxv2 & HWCAP2_SVEBITPERM) _features |= CPU_SVEBITPERM;\n+  if (auxv2 & HWCAP2_SVE2) set_feature(CPU_SVE2);\n+  if (auxv2 & HWCAP2_SVEBITPERM) set_feature(CPU_SVEBITPERM);\n@@ -185,1 +185,1 @@\n-            guarantee(_features & CPU_DCPOP, \"dcpop availability should be consistent\");\n+            guarantee(supports_feature(CPU_DCPOP), \"dcpop availability should be consistent\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-void AOTCodeCache::Config::record() {\n+void AOTCodeCache::Config::record(uint cpu_features_offset) {\n@@ -654,0 +654,1 @@\n+  _cpu_features_offset   = cpu_features_offset;\n@@ -656,1 +657,1 @@\n-bool AOTCodeCache::Config::verify() const {\n+bool AOTCodeCache::Config::verify(AOTCodeCache* cache) const {\n@@ -727,0 +728,20 @@\n+  char cpu_features[2048];\n+  VM_Version::get_supported_cpu_features_name(cpu_features, sizeof(cpu_features));\n+  log_debug(aot, codecache, init)(\"Available CPU features: %s\", cpu_features);\n+\n+  uint offset = _cpu_features_offset;\n+  uint cpu_features_size = *(uint *)cache->addr(offset);\n+  assert(cpu_features_size == (uint)VM_Version::cpu_features_size(), \"must be\");\n+  offset += sizeof(uint);\n+\n+  void* cached_cpu_features_buffer = (void *)cache->addr(offset);\n+  VM_Version::get_cpu_features_name(cached_cpu_features_buffer, cpu_features, sizeof(cpu_features));\n+  log_debug(aot, codecache, init)(\"CPU features recorded in AOTCodeCache: %s\", cpu_features);\n+\n+  if (!VM_Version::supports_features(cached_cpu_features_buffer)) {\n+    char missing_features_name[2048];\n+    VM_Version::get_missing_features_name(cached_cpu_features_buffer, missing_features_name, sizeof(missing_features_name));\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: required cpu features are missing: %s\", missing_features_name);\n+    return false;\n+  }\n+\n@@ -1090,0 +1111,13 @@\n+void AOTCodeCache::store_cpu_features(char*& buffer, uint buffer_size) {\n+  uint* size_ptr = (uint *)buffer;\n+  *size_ptr = buffer_size;\n+  buffer += sizeof(uint);\n+\n+  VM_Version::store_cpu_features(buffer);\n+  char cpu_features[4096];\n+  VM_Version::get_supported_cpu_features_name(cpu_features, sizeof(cpu_features));\n+  log_debug(aot, codecache, exit)(\"CPU features recorded in AOTCodeCache: %s\", cpu_features);\n+  buffer += buffer_size;\n+  buffer = align_up(buffer, DATA_ALIGNMENT);\n+}\n+\n@@ -1112,1 +1146,1 @@\n-    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header),  DATA_ALIGNMENT);\n+    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header), DATA_ALIGNMENT);\n@@ -1123,0 +1157,2 @@\n+    uint cpu_features_size = VM_Version::cpu_features_size();\n+    uint total_cpu_features_size = sizeof(uint) + cpu_features_size; \/\/ sizeof(uint) to store cpu_features_size\n@@ -1124,1 +1160,2 @@\n-                     code_alignment + search_size + preload_entries_size + entries_size;\n+                      code_alignment + search_size + preload_entries_size + entries_size +\n+                      align_up(total_cpu_features_size, DATA_ALIGNMENT);\n@@ -1127,3 +1164,0 @@\n-\n-    \/\/ Create ordered search table for entries [id, index];\n-    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n@@ -1135,0 +1169,8 @@\n+    uint cpu_features_offset = current - start;\n+    store_cpu_features(current, cpu_features_size);\n+    assert(is_aligned(current, DATA_ALIGNMENT), \"sanity check\");\n+    assert(current < start + total_size, \"sanity check\");\n+\n+    \/\/ Create ordered search table for entries [id, index];\n+    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n+\n@@ -1308,1 +1350,2 @@\n-                 C1_blobs_count, C2_blobs_count, stubs_count);\n+                 C1_blobs_count, C2_blobs_count,\n+                 stubs_count, cpu_features_offset);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":51,"deletions":8,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/sizes.hpp\"\n@@ -33,1 +35,0 @@\n-\n@@ -345,0 +346,1 @@\n+    uint _cpu_features_offset; \/\/ offset in the cache where cpu features are stored\n@@ -347,2 +349,2 @@\n-    void record();\n-    bool verify() const;\n+    void record(uint cpu_features_offset);\n+    bool verify(AOTCodeCache* cache) const;\n@@ -370,1 +372,1 @@\n-    Config _config;\n+    Config _config; \/\/ must be the last element as there is trailing data stored immediately after Config\n@@ -378,1 +380,2 @@\n-              uint C1_blobs_count, uint C2_blobs_count, uint stubs_count) {\n+              uint C1_blobs_count, uint C2_blobs_count,\n+              uint stubs_count, uint cpu_features_offset) {\n@@ -393,1 +396,1 @@\n-      _config.record();\n+      _config.record(cpu_features_offset);\n@@ -416,2 +419,2 @@\n-    bool verify_vm_config() const { \/\/ Called after Universe initialized\n-      return _config.verify();\n+    bool verify_vm_config(AOTCodeCache* cache) const { \/\/ Called after Universe initialized\n+      return _config.verify(cache);\n@@ -536,0 +539,2 @@\n+  void store_cpu_features(char*& buffer, uint buffer_size);\n+\n@@ -594,1 +599,1 @@\n-      return _cache->_load_header->verify_vm_config();\n+      return _cache->_load_header->verify_vm_config(_cache);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -232,0 +232,14 @@\n+\n+  static void get_supported_cpu_features_name(char* names_buf, size_t buf_size) { return; }\n+  static void get_cpu_features_name(void* features_buffer, char* names_buf, size_t buf_size) { return; }\n+  static void get_missing_features_name(void* features_buffer, char* missing_features_name, size_t buf_size) { return; }\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size() { return 0; }\n+\n+  \/\/ Stores arch dependent cpu features representation in the provided buffer.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf) { return; }\n+\n+  \/\/ features_to_test is an opaque object that stores arch specific representation of cpu features\n+  static bool supports_features(void* features_to_test) { return false; };\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}