{"files":[{"patch":"@@ -51,0 +51,2 @@\n+const char* VM_Version::_features_names[MAX_CPU_FEATURES] = { nullptr };\n+\n@@ -72,0 +74,5 @@\n+#define SET_CPU_FEATURE_NAME(id, name, bit) \\\n+  _features_names[bit] = XSTR(name);\n+  CPU_FEATURE_FLAGS(SET_CPU_FEATURE_NAME)\n+#undef SET_CPU_FEATURE_NAME\n+\n@@ -206,1 +213,1 @@\n-    _features |= CPU_A53MAC;\n+    set_feature(CPU_A53MAC);\n@@ -246,1 +253,1 @@\n-  if (_features & (CPU_FP | CPU_ASIMD)) {\n+  if (supports_feature(CPU_FP) || supports_feature(CPU_ASIMD)) {\n@@ -409,1 +416,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -420,1 +427,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -431,1 +438,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -632,2 +639,2 @@\n-    _features &= ~CPU_SVE2;\n-    _features &= ~CPU_SVEBITPERM;\n+    clear_feature(CPU_SVE2);\n+    clear_feature(CPU_SVEBITPERM);\n@@ -636,1 +643,1 @@\n-    _features &= ~CPU_SVE;\n+    clear_feature(CPU_SVE);\n@@ -728,0 +735,42 @@\n+\n+void VM_Version::insert_features_names(uint64_t features, CpuInfoBuffer& info_buffer) {\n+  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n+    if (supports_feature((VM_Version::Feature_Flag)i)) {\n+      return _features_names[i];\n+    } else {\n+      return (const char*)nullptr;\n+    }\n+  });\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+}\n+\n+void VM_Version::get_cpu_features_name(void* features_buffer, CpuInfoBuffer& info_buffer) {\n+  uint64_t features = *(uint64_t*)features_buffer;\n+  insert_features_names(features, info_buffer);\n+}\n+\n+void VM_Version::get_missing_features_name(void* features_buffer, CpuInfoBuffer& info_buffer) {\n+  uint64_t features_to_test = *(uint64_t*)features_buffer;\n+  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n+    Feature_Flag flag = (Feature_Flag)i;\n+    if (supports_feature(features_to_test, flag) && !supports_feature(flag)) {\n+      return _features_names[i];\n+    } else {\n+      return (const char*)nullptr;\n+    }\n+  });\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+}\n+\n+int VM_Version::cpu_features_size() {\n+  return sizeof(_features);\n+}\n+\n+void VM_Version::store_cpu_features(void* buf) {\n+  *(uint64_t*)buf = _features;\n+}\n+\n+bool VM_Version::supports_features(void* features_buffer) {\n+  uint64_t features_to_test = *(uint64_t*)features_buffer;\n+  return (_features & features_to_test) == features_to_test;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":57,"deletions":8,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define BIT_MASK(flag) (1ULL<<(flag))\n+\n@@ -64,0 +66,2 @@\n+  static void insert_features_names(uint64_t features, CpuInfoBuffer& info_buffer);\n+\n@@ -141,1 +145,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = bit,\n@@ -144,0 +148,1 @@\n+    MAX_CPU_FEATURES\n@@ -146,0 +151,4 @@\n+  STATIC_ASSERT(sizeof(_features) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+  static const char* _features_names[MAX_CPU_FEATURES];\n+\n@@ -148,1 +157,1 @@\n-  static bool supports_##name() { return (_features & CPU_##id) != 0; };\n+  static bool supports_##name() { return supports_feature(CPU_##id); }\n@@ -152,0 +161,13 @@\n+  static void set_feature(Feature_Flag flag) {\n+    _features |= BIT_MASK(flag);\n+  }\n+  static void clear_feature(Feature_Flag flag) {\n+    _features &= (~BIT_MASK(flag));\n+  }\n+  static bool supports_feature(Feature_Flag flag) {\n+    return (_features & BIT_MASK(flag)) != 0;\n+  }\n+  static bool supports_feature(uint64_t features, Feature_Flag flag) {\n+    return (features & BIT_MASK(flag)) != 0;\n+  }\n+\n@@ -202,0 +224,12 @@\n+\n+  static void get_cpu_features_name(void* features_buffer, CpuInfoBuffer& info_buffer);\n+  static void get_missing_features_name(void* features_buffer, CpuInfoBuffer& info_buffer);\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size();\n+\n+  \/\/ Stores cpu features representation in the provided buffer. This representation is arch dependent.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf);\n+\n+  static bool supports_features(void* features_to_test);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -50,1 +51,1 @@\n-#define DECLARE_CPU_FEATURE_NAME(id, name, bit) name,\n+#define DECLARE_CPU_FEATURE_NAME(id, name, bit) XSTR(name),\n@@ -1103,7 +1104,8 @@\n-  char buf[2048];\n-  size_t cpu_info_size = jio_snprintf(\n-              buf, sizeof(buf),\n-              \"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-              cores_per_cpu(), threads_per_core(),\n-              cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n-  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  CpuInfoBuffer info_buffer(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n+                                          cores_per_cpu(), threads_per_core(), cpu_family(),\n+                                          _model, _stepping, os::cpu_microcode_revision());\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+  info_buffer.append(\", \");\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+  int features_offset = info_buffer.length();\n+  insert_features_names(_features, info_buffer);\n@@ -1111,7 +1113,2 @@\n-  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n-\n-  _cpu_info_string = os::strdup(buf);\n-\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             cpu_info_size);\n+  _cpu_info_string = os::strdup(info_buffer.buffer());\n+  _features_string = _cpu_info_string + features_offset;\n@@ -3299,2 +3296,2 @@\n-void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n-  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, CpuInfoBuffer& info_buffer) {\n+  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n@@ -3302,4 +3299,3 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+      return _features_names[i];\n+    } else {\n+      return (const char*)nullptr;\n@@ -3307,1 +3303,35 @@\n-  }\n+  });\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+}\n+\n+void VM_Version::get_cpu_features_name(void* features_buffer, CpuInfoBuffer& info_buffer) {\n+  VM_Features* features = (VM_Features*)features_buffer;\n+  insert_features_names(*features, info_buffer);\n+}\n+\n+void VM_Version::get_missing_features_name(void* features_buffer, CpuInfoBuffer& info_buffer) {\n+  VM_Features* features_to_test = (VM_Features*)features_buffer;\n+  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n+    Feature_Flag flag = (Feature_Flag)i;\n+    if (features_to_test->supports_feature(flag) && !_features.supports_feature(flag)) {\n+      return _features_names[i];\n+    } else {\n+      return (const char*)nullptr;\n+    }\n+  });\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+}\n+\n+int VM_Version::cpu_features_size() {\n+  return sizeof(VM_Features);\n+}\n+\n+void VM_Version::store_cpu_features(void* buf) {\n+  VM_Features copy = _features;\n+  copy.clear_feature(CPU_HT); \/\/ HT does not result in incompatibility of aot code cache\n+  memcpy(buf, &copy, sizeof(VM_Features));\n+}\n+\n+bool VM_Version::supports_features(void* features_buffer) {\n+  VM_Features* features_to_test = (VM_Features*)features_buffer;\n+  return _features.supports_features(features_to_test);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":52,"deletions":22,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -369,4 +369,4 @@\n-    decl(CX8,               \"cx8\",               0)  \/*  next bits are from cpuid 1 (EDX) *\/ \\\n-    decl(CMOV,              \"cmov\",              1)  \\\n-    decl(FXSR,              \"fxsr\",              2)  \\\n-    decl(HT,                \"ht\",                3)  \\\n+    decl(CX8,               cx8,               0)  \/*  next bits are from cpuid 1 (EDX) *\/ \\\n+    decl(CMOV,              cmov,              1)  \\\n+    decl(FXSR,              fxsr,              2)  \\\n+    decl(HT,                ht,                3)  \\\n@@ -374,2 +374,2 @@\n-    decl(MMX,               \"mmx\",               4)  \\\n-    decl(3DNOW_PREFETCH,    \"3dnowpref\",         5)  \/* Processor supports 3dnow prefetch and prefetchw instructions *\/ \\\n+    decl(MMX,               mmx,               4)  \\\n+    decl(3DNOW_PREFETCH,    3dnowpref,         5)  \/* Processor supports 3dnow prefetch and prefetchw instructions *\/ \\\n@@ -377,2 +377,2 @@\n-    decl(SSE,               \"sse\",               6)  \\\n-    decl(SSE2,              \"sse2\",              7)  \\\n+    decl(SSE,               sse,               6)  \\\n+    decl(SSE2,              sse2,              7)  \\\n@@ -380,4 +380,4 @@\n-    decl(SSE3,              \"sse3\",              8 ) \/* SSE3 comes from cpuid 1 (ECX) *\/ \\\n-    decl(SSSE3,             \"ssse3\",             9 ) \\\n-    decl(SSE4A,             \"sse4a\",             10) \\\n-    decl(SSE4_1,            \"sse4.1\",            11) \\\n+    decl(SSE3,              sse3,              8 ) \/* SSE3 comes from cpuid 1 (ECX) *\/ \\\n+    decl(SSSE3,             ssse3,             9 ) \\\n+    decl(SSE4A,             sse4a,             10) \\\n+    decl(SSE4_1,            sse4.1,            11) \\\n@@ -385,4 +385,4 @@\n-    decl(SSE4_2,            \"sse4.2\",            12) \\\n-    decl(POPCNT,            \"popcnt\",            13) \\\n-    decl(LZCNT,             \"lzcnt\",             14) \\\n-    decl(TSC,               \"tsc\",               15) \\\n+    decl(SSE4_2,            sse4.2,            12) \\\n+    decl(POPCNT,            popcnt,            13) \\\n+    decl(LZCNT,             lzcnt,             14) \\\n+    decl(TSC,               tsc,               15) \\\n@@ -390,4 +390,4 @@\n-    decl(TSCINV_BIT,        \"tscinvbit\",         16) \\\n-    decl(TSCINV,            \"tscinv\",            17) \\\n-    decl(AVX,               \"avx\",               18) \\\n-    decl(AVX2,              \"avx2\",              19) \\\n+    decl(TSCINV_BIT,        tscinvbit,         16) \\\n+    decl(TSCINV,            tscinv,            17) \\\n+    decl(AVX,               avx,               18) \\\n+    decl(AVX2,              avx2,              19) \\\n@@ -395,4 +395,4 @@\n-    decl(AES,               \"aes\",               20) \\\n-    decl(ERMS,              \"erms\",              21) \/* enhanced 'rep movsb\/stosb' instructions *\/ \\\n-    decl(CLMUL,             \"clmul\",             22) \/* carryless multiply for CRC *\/ \\\n-    decl(BMI1,              \"bmi1\",              23) \\\n+    decl(AES,               aes,               20) \\\n+    decl(ERMS,              erms,              21) \/* enhanced 'rep movsb\/stosb' instructions *\/ \\\n+    decl(CLMUL,             clmul,             22) \/* carryless multiply for CRC *\/ \\\n+    decl(BMI1,              bmi1,              23) \\\n@@ -400,4 +400,4 @@\n-    decl(BMI2,              \"bmi2\",              24) \\\n-    decl(RTM,               \"rtm\",               25) \/* Restricted Transactional Memory instructions *\/ \\\n-    decl(ADX,               \"adx\",               26) \\\n-    decl(AVX512F,           \"avx512f\",           27) \/* AVX 512bit foundation instructions *\/ \\\n+    decl(BMI2,              bmi2,              24) \\\n+    decl(RTM,               rtm,               25) \/* Restricted Transactional Memory instructions *\/ \\\n+    decl(ADX,               adx,               26) \\\n+    decl(AVX512F,           avx512f,           27) \/* AVX 512bit foundation instructions *\/ \\\n@@ -405,4 +405,4 @@\n-    decl(AVX512DQ,          \"avx512dq\",          28) \\\n-    decl(AVX512PF,          \"avx512pf\",          29) \\\n-    decl(AVX512ER,          \"avx512er\",          30) \\\n-    decl(AVX512CD,          \"avx512cd\",          31) \\\n+    decl(AVX512DQ,          avx512dq,          28) \\\n+    decl(AVX512PF,          avx512pf,          29) \\\n+    decl(AVX512ER,          avx512er,          30) \\\n+    decl(AVX512CD,          avx512cd,          31) \\\n@@ -410,4 +410,4 @@\n-    decl(AVX512BW,          \"avx512bw\",          32) \/* Byte and word vector instructions *\/ \\\n-    decl(AVX512VL,          \"avx512vl\",          33) \/* EVEX instructions with smaller vector length *\/ \\\n-    decl(SHA,               \"sha\",               34) \/* SHA instructions *\/ \\\n-    decl(FMA,               \"fma\",               35) \/* FMA instructions *\/ \\\n+    decl(AVX512BW,          avx512bw,          32) \/* Byte and word vector instructions *\/ \\\n+    decl(AVX512VL,          avx512vl,          33) \/* EVEX instructions with smaller vector length *\/ \\\n+    decl(SHA,               sha,               34) \/* SHA instructions *\/ \\\n+    decl(FMA,               fma,               35) \/* FMA instructions *\/ \\\n@@ -415,4 +415,4 @@\n-    decl(VZEROUPPER,        \"vzeroupper\",        36) \/* Vzeroupper instruction *\/ \\\n-    decl(AVX512_VPOPCNTDQ,  \"avx512_vpopcntdq\",  37) \/* Vector popcount *\/ \\\n-    decl(AVX512_VPCLMULQDQ, \"avx512_vpclmulqdq\", 38) \/* Vector carryless multiplication *\/ \\\n-    decl(AVX512_VAES,       \"avx512_vaes\",       39) \/* Vector AES instruction *\/ \\\n+    decl(VZEROUPPER,        vzeroupper,        36) \/* Vzeroupper instruction *\/ \\\n+    decl(AVX512_VPOPCNTDQ,  avx512_vpopcntdq,  37) \/* Vector popcount *\/ \\\n+    decl(AVX512_VPCLMULQDQ, avx512_vpclmulqdq, 38) \/* Vector carryless multiplication *\/ \\\n+    decl(AVX512_VAES,       avx512_vaes,       39) \/* Vector AES instruction *\/ \\\n@@ -420,4 +420,4 @@\n-    decl(AVX512_VNNI,       \"avx512_vnni\",       40) \/* Vector Neural Network Instructions *\/ \\\n-    decl(FLUSH,             \"clflush\",           41) \/* flush instruction *\/ \\\n-    decl(FLUSHOPT,          \"clflushopt\",        42) \/* flusopth instruction *\/ \\\n-    decl(CLWB,              \"clwb\",              43) \/* clwb instruction *\/ \\\n+    decl(AVX512_VNNI,       avx512_vnni,       40) \/* Vector Neural Network Instructions *\/ \\\n+    decl(FLUSH,             clflush,           41) \/* flush instruction *\/ \\\n+    decl(FLUSHOPT,          clflushopt,        42) \/* flusopth instruction *\/ \\\n+    decl(CLWB,              clwb,              43) \/* clwb instruction *\/ \\\n@@ -425,21 +425,21 @@\n-    decl(AVX512_VBMI2,      \"avx512_vbmi2\",      44) \/* VBMI2 shift left double instructions *\/ \\\n-    decl(AVX512_VBMI,       \"avx512_vbmi\",       45) \/* Vector BMI instructions *\/ \\\n-    decl(HV,                \"hv\",                46) \/* Hypervisor instructions *\/ \\\n-    decl(SERIALIZE,         \"serialize\",         47) \/* CPU SERIALIZE *\/ \\\n-    decl(RDTSCP,            \"rdtscp\",            48) \/* RDTSCP instruction *\/ \\\n-    decl(RDPID,             \"rdpid\",             49) \/* RDPID instruction *\/ \\\n-    decl(FSRM,              \"fsrm\",              50) \/* Fast Short REP MOV *\/ \\\n-    decl(GFNI,              \"gfni\",              51) \/* Vector GFNI instructions *\/ \\\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n-    decl(F16C,              \"f16c\",              53) \/* Half-precision and single precision FP conversion instructions*\/ \\\n-    decl(PKU,               \"pku\",               54) \/* Protection keys for user-mode pages *\/ \\\n-    decl(OSPKE,             \"ospke\",             55) \/* OS enables protection keys *\/ \\\n-    decl(CET_IBT,           \"cet_ibt\",           56) \/* Control Flow Enforcement - Indirect Branch Tracking *\/ \\\n-    decl(CET_SS,            \"cet_ss\",            57) \/* Control Flow Enforcement - Shadow Stack *\/ \\\n-    decl(AVX512_IFMA,       \"avx512_ifma\",       58) \/* Integer Vector FMA instructions*\/ \\\n-    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n-    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/ \\\n-    decl(SHA512,            \"sha512\",            61) \/* SHA512 instructions*\/ \\\n-    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/ \\\n-    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n-    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n+    decl(AVX512_VBMI2,      avx512_vbmi2,      44) \/* VBMI2 shift left double instructions *\/ \\\n+    decl(AVX512_VBMI,       avx512_vbmi,       45) \/* Vector BMI instructions *\/ \\\n+    decl(HV,                hv,                46) \/* Hypervisor instructions *\/ \\\n+    decl(SERIALIZE,         serialize,         47) \/* CPU SERIALIZE *\/ \\\n+    decl(RDTSCP,            rdtscp,            48) \/* RDTSCP instruction *\/ \\\n+    decl(RDPID,             rdpid,             49) \/* RDPID instruction *\/ \\\n+    decl(FSRM,              fsrm,              50) \/* Fast Short REP MOV *\/ \\\n+    decl(GFNI,              gfni,              51) \/* Vector GFNI instructions *\/ \\\n+    decl(AVX512_BITALG,     avx512_bitalg,     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(F16C,              f16c,              53) \/* Half-precision and single precision FP conversion instructions*\/ \\\n+    decl(PKU,               pku,               54) \/* Protection keys for user-mode pages *\/ \\\n+    decl(OSPKE,             ospke,             55) \/* OS enables protection keys *\/ \\\n+    decl(CET_IBT,           cet_ibt,           56) \/* Control Flow Enforcement - Indirect Branch Tracking *\/ \\\n+    decl(CET_SS,            cet_ss,            57) \/* Control Flow Enforcement - Shadow Stack *\/ \\\n+    decl(AVX512_IFMA,       avx512_ifma,       58) \/* Integer Vector FMA instructions*\/ \\\n+    decl(AVX_IFMA,          avx_ifma,          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n+    decl(APX_F,             apx_f,             60) \/* Intel Advanced Performance Extensions*\/ \\\n+    decl(SHA512,            sha512,            61) \/* SHA512 instructions*\/ \\\n+    decl(AVX512_FP16,       avx512_fp16,       62) \/* AVX512 FP16 ISA support*\/ \\\n+    decl(AVX10_1,           avx10_1,           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n+    decl(AVX10_2,           avx10_2,           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n@@ -486,0 +486,1 @@\n+\n@@ -507,0 +508,9 @@\n+\n+    bool supports_features(VM_Features* features_to_test) {\n+      for (int i = 0; i < features_bitmap_element_count(); i++) {\n+        if ((_features_bitmap[i] & features_to_test->_features_bitmap[i]) != features_to_test->_features_bitmap[i]) {\n+          return false;\n+       }\n+      }\n+      return true;\n+    }\n@@ -924,1 +934,1 @@\n-  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+  static void insert_features_names(VM_Version::VM_Features features, CpuInfoBuffer& info_buffer);\n@@ -1075,0 +1085,12 @@\n+\n+  static void get_cpu_features_name(void* features_buffer, CpuInfoBuffer& info_buffer);\n+  static void get_missing_features_name(void* features_buffer, CpuInfoBuffer& info_buffer);\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size();\n+\n+  \/\/ Stores cpu features representation in the provided buffer. This representation is arch dependent.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf);\n+\n+  static bool supports_features(void* features_to_test);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":88,"deletions":66,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -116,16 +116,16 @@\n-  static_assert(CPU_FP      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMD   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n-  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n-  static_assert(CPU_AES     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n-  static_assert(CPU_PMULL   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n-  static_assert(CPU_SHA1    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA2    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n-  static_assert(CPU_CRC32   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n-  static_assert(CPU_LSE     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n-  static_assert(CPU_DCPOP   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n-  static_assert(CPU_SHA3    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA512  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n-  static_assert(CPU_SVE     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n-  static_assert(CPU_PACA    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n-  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FP)      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMD)   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_EVTSTRM) == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_AES)     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PMULL)   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA1)    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA2)    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_CRC32)   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_LSE)     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_DCPOP)   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA3)    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA512)  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SVE)     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PACA)    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FPHP)    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMDHP) == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -150,2 +150,2 @@\n-  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;\n-  if (auxv2 & HWCAP2_SVEBITPERM) _features |= CPU_SVEBITPERM;\n+  if (auxv2 & HWCAP2_SVE2) set_feature(CPU_SVE2);\n+  if (auxv2 & HWCAP2_SVEBITPERM) set_feature(CPU_SVEBITPERM);\n@@ -185,1 +185,1 @@\n-            guarantee(_features & CPU_DCPOP, \"dcpop availability should be consistent\");\n+            guarantee(supports_feature(CPU_DCPOP), \"dcpop availability should be consistent\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -621,1 +622,1 @@\n-void AOTCodeCache::Config::record() {\n+void AOTCodeCache::Config::record(uint cpu_features_offset) {\n@@ -657,4 +658,0 @@\n-#if !defined(ZERO) && (defined(IA32) || defined(AMD64))\n-  _useSSE                = UseSSE;\n-  _useAVX                = UseAVX;\n-#endif\n@@ -662,0 +659,1 @@\n+  _cpu_features_offset   = cpu_features_offset;\n@@ -664,1 +662,1 @@\n-bool AOTCodeCache::Config::verify() const {\n+bool AOTCodeCache::Config::verify(AOTCodeCache* cache) const {\n@@ -678,11 +676,0 @@\n-#if !defined(ZERO) && (defined(IA32) || defined(AMD64))\n-  if (UseSSE < _useSSE) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseSSE = %d vs current %d\", _useSSE, UseSSE);\n-    return false;\n-  }\n-  if (UseAVX < _useAVX) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseAVX = %d vs current %d\", _useAVX, UseAVX);\n-    return false;\n-  }\n-#endif\n-\n@@ -750,0 +737,26 @@\n+  LogStreamHandle(Debug, aot, codecache, init) log;\n+  if (log.is_enabled()) {\n+    log.print_cr(\"Available CPU features: %s\", VM_Version::features_string());\n+  }\n+\n+  uint offset = _cpu_features_offset;\n+  uint cpu_features_size = *(uint *)cache->addr(offset);\n+  assert(cpu_features_size == (uint)VM_Version::cpu_features_size(), \"must be\");\n+  offset += sizeof(uint);\n+\n+  void* cached_cpu_features_buffer = (void *)cache->addr(offset);\n+  if (log.is_enabled()) {\n+    CpuInfoBuffer msg_buffer;\n+    VM_Version::get_cpu_features_name(cached_cpu_features_buffer, msg_buffer);\n+    log.print_cr(\"CPU features recorded in AOTCodeCache: %s\", msg_buffer.buffer());\n+  }\n+\n+  if (!VM_Version::supports_features(cached_cpu_features_buffer)) {\n+    if (log.is_enabled()) {\n+      CpuInfoBuffer msg_buffer;\n+      VM_Version::get_missing_features_name(cached_cpu_features_buffer, msg_buffer);\n+      log.print_cr(\"AOT Code Cache disabled: required cpu features are missing: %s\", msg_buffer.buffer());\n+    }\n+    return false;\n+  }\n+\n@@ -1098,0 +1111,11 @@\n+void AOTCodeCache::store_cpu_features(char*& buffer, uint buffer_size) {\n+  uint* size_ptr = (uint *)buffer;\n+  *size_ptr = buffer_size;\n+  buffer += sizeof(uint);\n+\n+  VM_Version::store_cpu_features(buffer);\n+  log_debug(aot, codecache, exit)(\"CPU features recorded in AOTCodeCache: %s\", VM_Version::features_string());\n+  buffer += buffer_size;\n+  buffer = align_up(buffer, DATA_ALIGNMENT);\n+}\n+\n@@ -1120,1 +1144,1 @@\n-    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header),  DATA_ALIGNMENT);\n+    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header), DATA_ALIGNMENT);\n@@ -1131,0 +1155,2 @@\n+    uint cpu_features_size = VM_Version::cpu_features_size();\n+    uint total_cpu_features_size = sizeof(uint) + cpu_features_size; \/\/ sizeof(uint) to store cpu_features_size\n@@ -1132,1 +1158,2 @@\n-                     code_alignment + search_size + preload_entries_size + entries_size;\n+                      code_alignment + search_size + preload_entries_size + entries_size +\n+                      align_up(total_cpu_features_size, DATA_ALIGNMENT);\n@@ -1135,3 +1162,0 @@\n-\n-    \/\/ Create ordered search table for entries [id, index];\n-    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n@@ -1143,0 +1167,8 @@\n+    uint cpu_features_offset = current - start;\n+    store_cpu_features(current, cpu_features_size);\n+    assert(is_aligned(current, DATA_ALIGNMENT), \"sanity check\");\n+    assert(current < start + total_size, \"sanity check\");\n+\n+    \/\/ Create ordered search table for entries [id, index];\n+    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n+\n@@ -1316,1 +1348,2 @@\n-                 C1_blobs_count, C2_blobs_count, stubs_count);\n+                 C1_blobs_count, C2_blobs_count,\n+                 stubs_count, cpu_features_offset);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":56,"deletions":23,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/sizes.hpp\"\n@@ -33,1 +35,0 @@\n-\n@@ -329,4 +330,0 @@\n-#if defined(IA32) || defined(AMD64)\n-    int  _useSSE; \/\/ Hack before we record CPU features\n-    int  _useAVX;\n-#endif\n@@ -346,0 +343,1 @@\n+    uint _cpu_features_offset; \/\/ offset in the cache where cpu features are stored\n@@ -348,2 +346,2 @@\n-    void record();\n-    bool verify() const;\n+    void record(uint cpu_features_offset);\n+    bool verify(AOTCodeCache* cache) const;\n@@ -371,1 +369,1 @@\n-    Config _config;\n+    Config _config; \/\/ must be the last element as there is trailing data stored immediately after Config\n@@ -379,1 +377,2 @@\n-              uint C1_blobs_count, uint C2_blobs_count, uint stubs_count) {\n+              uint C1_blobs_count, uint C2_blobs_count,\n+              uint stubs_count, uint cpu_features_offset) {\n@@ -394,1 +393,1 @@\n-      _config.record();\n+      _config.record(cpu_features_offset);\n@@ -417,2 +416,2 @@\n-    bool verify_config() const { \/\/ Called after Universe initialized\n-      return _config.verify();\n+    bool verify_config(AOTCodeCache* cache) const { \/\/ Called after Universe initialized\n+      return _config.verify(cache);\n@@ -534,0 +533,2 @@\n+  void store_cpu_features(char*& buffer, uint buffer_size);\n+\n@@ -594,1 +595,1 @@\n-      return _load_header->verify_config();\n+      return _load_header->verify_config(this);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,0 +44,6 @@\n+#define CPU_INFO_BUF_SIZE 2048\n+\n+template<size_t bufsz> class FormatBuffer;\n+\n+using CpuInfoBuffer = FormatBuffer<CPU_INFO_BUF_SIZE>;\n+\n@@ -232,0 +238,13 @@\n+\n+  static void get_cpu_features_name(void* features_buffer, CpuInfoBuffer& info_buffer) { return; }\n+  static void get_missing_features_name(void* features_buffer, CpuInfoBuffer& info_buffer) { return; }\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size() { return 0; }\n+\n+  \/\/ Stores arch dependent cpu features representation in the provided buffer.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf) { return; }\n+\n+  \/\/ features_to_test is an opaque object that stores arch specific representation of cpu features\n+  static bool supports_features(void* features_to_test) { return false; };\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-  inline void append(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n+  inline FormatBuffer();\n+  inline int append(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n@@ -64,0 +65,20 @@\n+  int length() { return _len; }\n+  int overflow() { return _overflow; }\n+\n+  template<typename FN>\n+  void insert_string_list(int start, int limit, FN fn) {\n+    bool first = true;\n+    for (int i = start; i < limit; i++) {\n+      const char* str = fn(i);\n+      if (str == nullptr) {\n+        continue;\n+      }\n+      const char* comma = first ? \"\" : \", \";\n+      int result = append(\"%s%s\", comma, str);\n+      if (result < 0) {\n+        return;\n+      }\n+      first = false;\n+    }\n+    return;\n+  }\n@@ -68,3 +89,9 @@\n-\n- protected:\n-  inline FormatBuffer();\n+  int _len;\n+  bool _overflow;\n+\n+  bool check_overflow(int result) {\n+    if (result == -1) {\n+      _overflow = true;\n+    }\n+    return _overflow;\n+  }\n@@ -74,1 +101,1 @@\n-FormatBuffer<bufsz>::FormatBuffer(const char * format, ...) : FormatBufferBase(_buffer) {\n+FormatBuffer<bufsz>::FormatBuffer(const char * format, ...) : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n@@ -77,1 +104,1 @@\n-  jio_vsnprintf(_buf, bufsz, format, argp);\n+  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n@@ -79,0 +106,1 @@\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -82,2 +110,3 @@\n-FormatBuffer<bufsz>::FormatBuffer(FormatBufferDummy dummy, const char * format, va_list ap) : FormatBufferBase(_buffer) {\n-  jio_vsnprintf(_buf, bufsz, format, ap);\n+FormatBuffer<bufsz>::FormatBuffer(FormatBufferDummy dummy, const char * format, va_list ap) : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n+  int result = jio_vsnprintf(_buf, bufsz, format, ap);\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -87,1 +116,1 @@\n-FormatBuffer<bufsz>::FormatBuffer() : FormatBufferBase(_buffer) {\n+FormatBuffer<bufsz>::FormatBuffer() : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n@@ -95,1 +124,1 @@\n-  jio_vsnprintf(_buf, bufsz, format, argp);\n+  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n@@ -97,0 +126,1 @@\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -101,1 +131,2 @@\n-  jio_vsnprintf(_buf, bufsz, format, argp);\n+  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -105,1 +136,4 @@\n-void FormatBuffer<bufsz>::append(const char* format, ...) {\n+int FormatBuffer<bufsz>::append(const char* format, ...) {\n+  if (_overflow) {\n+    return -1;\n+  }\n@@ -108,2 +142,2 @@\n-  size_t len = strlen(_buf);\n-  char* buf_end = _buf + len;\n+  assert(_buf != nullptr, \"sanity check\");\n+  char* buf_end = _buf + _len;\n@@ -113,1 +147,1 @@\n-  jio_vsnprintf(buf_end, bufsz - len, format, argp);\n+  int result = jio_vsnprintf(buf_end, bufsz - _len, format, argp);\n@@ -115,0 +149,2 @@\n+  _len = check_overflow(result) ? bufsz-1 : _len+result;\n+  return result;\n","filename":"src\/hotspot\/share\/utilities\/formatBuffer.hpp","additions":51,"deletions":15,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary CPU feature compatibility test for AOT Code Cache\n+ * @requires vm.cds.supports.aot.code.caching\n+ * @requires vm.compMode != \"Xcomp\" & vm.compMode != \"Xint\"\n+ * @comment The test verifies AOT checks during VM startup and not code generation.\n+ *          No need to run it with -Xcomp.\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build AOTCodeX86CPUFeatureIncompatibilityTest JavacBenchApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *             JavacBenchApp\n+ *             JavacBenchApp$ClassFile\n+ *             JavacBenchApp$FileManager\n+ *             JavacBenchApp$SourceFile\n+ * @run driver AOTCodeX86CPUFeatureIncompatibilityTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTCodeX86CPUFeatureIncompatibilityTest {\n+    public static void main(String... args) throws Exception {\n+        testIncompatibleSSEFeature();\n+        testIncompatibleAVXFeature();\n+    }\n+\n+    \/\/ Minimum value of UseSSE required by JVM is 2. So the production run has to be executed with UseSSE=2.\n+    \/\/ To simulate the case of incmpatible SSE feature, we can run this test only on system with higher SSE level (sse3 or above).\n+    public static void testIncompatibleSSEFeature() throws Exception {\n+        if (checkSSE3Feature()) {\n+            new CDSAppTester(\"AOTCodeX86CPUFeatureIncompatibilityTest\") {\n+                @Override\n+                public String[] vmArgs(RunMode runMode) {\n+                    if (runMode == RunMode.PRODUCTION) {\n+                        return new String[] {\"-XX:UseSSE=2\", \"-Xlog:aot+codecache+init=debug\"};\n+                    }\n+                    return new String[] {};\n+                }\n+                @Override\n+                public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+                    if (runMode == RunMode.ASSEMBLY) {\n+                        out.shouldMatch(\"CPU features recorded in AOTCodeCache:.*sse3.*\");\n+                    } else if (runMode == RunMode.PRODUCTION) {\n+                        out.shouldMatch(\"AOT Code Cache disabled: required cpu features are missing:.*avx.*\");\n+                        out.shouldContain(\"Unable to use AOT Code Cache\");\n+                    }\n+                }\n+                @Override\n+                public String classpath(RunMode runMode) {\n+                    return \"app.jar\";\n+                }\n+                @Override\n+                public String[] appCommandLine(RunMode runMode) {\n+                    return new String[] {\n+                        \"JavacBenchApp\", \"10\"\n+                    };\n+                }\n+            }.runAOTWorkflow(\"--two-step-training\");\n+        } else {\n+            \/* SSE3 not supported on this system, nothing to do *\/\n+        }\n+    }\n+\n+    public static void testIncompatibleAVXFeature() throws Exception {\n+        if (checkAVXFeature()) {\n+            new CDSAppTester(\"AOTCodeX86CPUFeatureIncompatibilityTest\") {\n+                @Override\n+                public String[] vmArgs(RunMode runMode) {\n+                    if (runMode == RunMode.PRODUCTION) {\n+                        return new String[] {\"-XX:UseAVX=0\", \"-Xlog:aot+codecache+init=debug\"};\n+                    }\n+                    return new String[] {};\n+                }\n+                @Override\n+                public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+                    if (runMode == RunMode.ASSEMBLY) {\n+                        out.shouldMatch(\"CPU features recorded in AOTCodeCache:.*avx.*\");\n+                    } else if (runMode == RunMode.PRODUCTION) {\n+                        out.shouldMatch(\"AOT Code Cache disabled: required cpu features are missing:.*avx.*\");\n+                        out.shouldContain(\"Unable to use AOT Code Cache\");\n+                    }\n+                }\n+                @Override\n+                public String classpath(RunMode runMode) {\n+                    return \"app.jar\";\n+                }\n+                @Override\n+                public String[] appCommandLine(RunMode runMode) {\n+                    return new String[] {\n+                        \"JavacBenchApp\", \"10\"\n+                    };\n+                }\n+            }.runAOTWorkflow(\"--two-step-training\");\n+        } else {\n+            \/* AVX features not supported on this system, nothing to do *\/\n+        }\n+    }\n+\n+    static boolean checkAVXFeature() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:os+cpu=info\", \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldMatch(\"CPU:.*avx.*\");\n+        return output.matches(\"CPU:.*avx.*\");\n+    }\n+\n+    static boolean checkSSE3Feature() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:os+cpu=info\", \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldMatch(\"CPU:.*sse3.*\");\n+        return output.matches(\"CPU:.*sse3.*\");\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeX86CPUFeatureIncompatibilityTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -242,0 +242,15 @@\n+    public boolean matches(String regexp) {\n+        Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n+        String stdout = getStdout();\n+        Matcher matcher = pattern.matcher(stdout);\n+        if (matcher.find()) {\n+            return true;\n+        }\n+        String stderr = getStderr();\n+        matcher = pattern.matcher(stderr);\n+        if (matcher.find()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}