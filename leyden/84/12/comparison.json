{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -51,0 +52,2 @@\n+const char* VM_Version::_features_names[MAX_CPU_FEATURES] = { nullptr };\n+\n@@ -72,0 +75,5 @@\n+#define SET_CPU_FEATURE_NAME(id, name, bit) \\\n+  _features_names[bit] = XSTR(name);\n+  CPU_FEATURE_FLAGS(SET_CPU_FEATURE_NAME)\n+#undef SET_CPU_FEATURE_NAME\n+\n@@ -206,1 +214,1 @@\n-    _features |= CPU_A53MAC;\n+    set_feature(CPU_A53MAC);\n@@ -246,1 +254,1 @@\n-  if (_features & (CPU_FP | CPU_ASIMD)) {\n+  if (supports_feature(CPU_FP) || supports_feature(CPU_ASIMD)) {\n@@ -409,1 +417,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -420,1 +428,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -431,1 +439,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -632,2 +640,2 @@\n-    _features &= ~CPU_SVE2;\n-    _features &= ~CPU_SVEBITPERM;\n+    clear_feature(CPU_SVE2);\n+    clear_feature(CPU_SVEBITPERM);\n@@ -636,1 +644,1 @@\n-    _features &= ~CPU_SVE;\n+    clear_feature(CPU_SVE);\n@@ -640,2 +648,2 @@\n-  char buf[512];\n-  int buf_used_len = os::snprintf_checked(buf, sizeof(buf), \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n+  stringStream ss(512);\n+  ss.print(\"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n@@ -643,1 +651,1 @@\n-    os::snprintf_checked(buf + buf_used_len, sizeof(buf) - buf_used_len, \"(0x%03x)\", _model2);\n+    ss.print(\"(0x%03x)\", _model2);\n@@ -645,9 +653,3 @@\n-  size_t features_offset = strnlen(buf, sizeof(buf));\n-#define ADD_FEATURE_IF_SUPPORTED(id, name, bit)                 \\\n-  do {                                                          \\\n-    if (VM_Version::supports_##name()) strcat(buf, \", \" #name); \\\n-  } while(0);\n-  CPU_FEATURE_FLAGS(ADD_FEATURE_IF_SUPPORTED)\n-#undef ADD_FEATURE_IF_SUPPORTED\n-\n-  _cpu_info_string = os::strdup(buf);\n+  ss.print(\", \");\n+  int features_offset = (int)ss.size();\n+  insert_features_names(_features, ss);\n@@ -655,3 +657,2 @@\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             features_offset);\n+  _cpu_info_string = ss.as_string(true);\n+  _features_string = _cpu_info_string + features_offset;\n@@ -728,0 +729,46 @@\n+\n+void VM_Version::insert_features_names(uint64_t features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n+    }\n+    return (const char*)nullptr;\n+  }, \", \");\n+}\n+\n+void VM_Version::get_cpu_features_name(void* features_buffer, stringStream& ss) {\n+  uint64_t features = *(uint64_t*)features_buffer;\n+  insert_features_names(features, ss);\n+}\n+\n+void VM_Version::get_missing_features_name(void* features_buffer, stringStream& ss) {\n+  uint64_t features_to_test = *(uint64_t*)features_buffer;\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      Feature_Flag flag = (Feature_Flag)i;\n+      if (supports_feature(features_to_test, flag) && !supports_feature(flag)) {\n+        return _features_names[i];\n+      }\n+      i += 1;\n+    }\n+    return (const char*)nullptr;\n+  }, \", \");\n+}\n+\n+int VM_Version::cpu_features_size() {\n+  return sizeof(_features);\n+}\n+\n+void VM_Version::store_cpu_features(void* buf) {\n+  *(uint64_t*)buf = _features;\n+}\n+\n+bool VM_Version::supports_features(void* features_buffer) {\n+  uint64_t features_to_test = *(uint64_t*)features_buffer;\n+  return (_features & features_to_test) == features_to_test;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":70,"deletions":23,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+class stringStream;\n+\n+#define BIT_MASK(flag) (1ULL<<(flag))\n+\n@@ -64,0 +68,2 @@\n+  static void insert_features_names(uint64_t features, stringStream& ss);\n+\n@@ -141,1 +147,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = bit,\n@@ -144,0 +150,1 @@\n+    MAX_CPU_FEATURES\n@@ -146,0 +153,4 @@\n+  STATIC_ASSERT(sizeof(_features) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+  static const char* _features_names[MAX_CPU_FEATURES];\n+\n@@ -148,1 +159,1 @@\n-  static bool supports_##name() { return (_features & CPU_##id) != 0; };\n+  static bool supports_##name() { return supports_feature(CPU_##id); }\n@@ -152,0 +163,13 @@\n+  static void set_feature(Feature_Flag flag) {\n+    _features |= BIT_MASK(flag);\n+  }\n+  static void clear_feature(Feature_Flag flag) {\n+    _features &= (~BIT_MASK(flag));\n+  }\n+  static bool supports_feature(Feature_Flag flag) {\n+    return (_features & BIT_MASK(flag)) != 0;\n+  }\n+  static bool supports_feature(uint64_t features, Feature_Flag flag) {\n+    return (features & BIT_MASK(flag)) != 0;\n+  }\n+\n@@ -202,0 +226,12 @@\n+\n+  static void get_cpu_features_name(void* features_buffer, stringStream& ss);\n+  static void get_missing_features_name(void* features_buffer, stringStream& ss);\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size();\n+\n+  \/\/ Stores cpu features representation in the provided buffer. This representation is arch dependent.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf);\n+\n+  static bool supports_features(void* features_to_test);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -50,1 +51,1 @@\n-#define DECLARE_CPU_FEATURE_NAME(id, name, bit) name,\n+#define DECLARE_CPU_FEATURE_NAME(id, name, bit) XSTR(name),\n@@ -1103,7 +1104,7 @@\n-  char buf[2048];\n-  size_t cpu_info_size = jio_snprintf(\n-              buf, sizeof(buf),\n-              \"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-              cores_per_cpu(), threads_per_core(),\n-              cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n-  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  stringStream ss(2048);\n+  ss.print(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n+           cores_per_cpu(), threads_per_core(),\n+           cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n+  ss.print(\", \");\n+  int features_offset = (int)ss.size();\n+  insert_features_names(_features, ss);\n@@ -1111,7 +1112,2 @@\n-  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n-\n-  _cpu_info_string = os::strdup(buf);\n-\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             cpu_info_size);\n+  _cpu_info_string = ss.as_string(true);\n+  _features_string = _cpu_info_string + features_offset;\n@@ -3299,7 +3295,8 @@\n-void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n-  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n-    if (features.supports_feature((VM_Version::Feature_Flag)i)) {\n-      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (features.supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n@@ -3307,1 +3304,37 @@\n-  }\n+    return (const char*)nullptr;\n+  }, \", \");\n+}\n+\n+void VM_Version::get_cpu_features_name(void* features_buffer, stringStream& ss) {\n+  VM_Features* features = (VM_Features*)features_buffer;\n+  insert_features_names(*features, ss);\n+}\n+\n+void VM_Version::get_missing_features_name(void* features_buffer, stringStream& ss) {\n+  VM_Features* features_to_test = (VM_Features*)features_buffer;\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      Feature_Flag flag = (Feature_Flag)i;\n+      if (features_to_test->supports_feature(flag) && !_features.supports_feature(flag)) {\n+        return _features_names[i];\n+      }\n+      i += 1;\n+    }\n+    return (const char*)nullptr;\n+  }, \", \");\n+}\n+\n+int VM_Version::cpu_features_size() {\n+  return sizeof(VM_Features);\n+}\n+\n+void VM_Version::store_cpu_features(void* buf) {\n+  VM_Features copy = _features;\n+  copy.clear_feature(CPU_HT); \/\/ HT does not result in incompatibility of aot code cache\n+  memcpy(buf, &copy, sizeof(VM_Features));\n+}\n+\n+bool VM_Version::supports_features(void* features_buffer) {\n+  VM_Features* features_to_test = (VM_Features*)features_buffer;\n+  return _features.supports_features(features_to_test);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":56,"deletions":23,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class stringStream;\n+\n@@ -369,4 +371,4 @@\n-    decl(CX8,               \"cx8\",               0)  \/*  next bits are from cpuid 1 (EDX) *\/ \\\n-    decl(CMOV,              \"cmov\",              1)  \\\n-    decl(FXSR,              \"fxsr\",              2)  \\\n-    decl(HT,                \"ht\",                3)  \\\n+    decl(CX8,               cx8,               0)  \/*  next bits are from cpuid 1 (EDX) *\/ \\\n+    decl(CMOV,              cmov,              1)  \\\n+    decl(FXSR,              fxsr,              2)  \\\n+    decl(HT,                ht,                3)  \\\n@@ -374,2 +376,2 @@\n-    decl(MMX,               \"mmx\",               4)  \\\n-    decl(3DNOW_PREFETCH,    \"3dnowpref\",         5)  \/* Processor supports 3dnow prefetch and prefetchw instructions *\/ \\\n+    decl(MMX,               mmx,               4)  \\\n+    decl(3DNOW_PREFETCH,    3dnowpref,         5)  \/* Processor supports 3dnow prefetch and prefetchw instructions *\/ \\\n@@ -377,2 +379,2 @@\n-    decl(SSE,               \"sse\",               6)  \\\n-    decl(SSE2,              \"sse2\",              7)  \\\n+    decl(SSE,               sse,               6)  \\\n+    decl(SSE2,              sse2,              7)  \\\n@@ -380,4 +382,4 @@\n-    decl(SSE3,              \"sse3\",              8 ) \/* SSE3 comes from cpuid 1 (ECX) *\/ \\\n-    decl(SSSE3,             \"ssse3\",             9 ) \\\n-    decl(SSE4A,             \"sse4a\",             10) \\\n-    decl(SSE4_1,            \"sse4.1\",            11) \\\n+    decl(SSE3,              sse3,              8 ) \/* SSE3 comes from cpuid 1 (ECX) *\/ \\\n+    decl(SSSE3,             ssse3,             9 ) \\\n+    decl(SSE4A,             sse4a,             10) \\\n+    decl(SSE4_1,            sse4.1,            11) \\\n@@ -385,4 +387,4 @@\n-    decl(SSE4_2,            \"sse4.2\",            12) \\\n-    decl(POPCNT,            \"popcnt\",            13) \\\n-    decl(LZCNT,             \"lzcnt\",             14) \\\n-    decl(TSC,               \"tsc\",               15) \\\n+    decl(SSE4_2,            sse4.2,            12) \\\n+    decl(POPCNT,            popcnt,            13) \\\n+    decl(LZCNT,             lzcnt,             14) \\\n+    decl(TSC,               tsc,               15) \\\n@@ -390,4 +392,4 @@\n-    decl(TSCINV_BIT,        \"tscinvbit\",         16) \\\n-    decl(TSCINV,            \"tscinv\",            17) \\\n-    decl(AVX,               \"avx\",               18) \\\n-    decl(AVX2,              \"avx2\",              19) \\\n+    decl(TSCINV_BIT,        tscinvbit,         16) \\\n+    decl(TSCINV,            tscinv,            17) \\\n+    decl(AVX,               avx,               18) \\\n+    decl(AVX2,              avx2,              19) \\\n@@ -395,4 +397,4 @@\n-    decl(AES,               \"aes\",               20) \\\n-    decl(ERMS,              \"erms\",              21) \/* enhanced 'rep movsb\/stosb' instructions *\/ \\\n-    decl(CLMUL,             \"clmul\",             22) \/* carryless multiply for CRC *\/ \\\n-    decl(BMI1,              \"bmi1\",              23) \\\n+    decl(AES,               aes,               20) \\\n+    decl(ERMS,              erms,              21) \/* enhanced 'rep movsb\/stosb' instructions *\/ \\\n+    decl(CLMUL,             clmul,             22) \/* carryless multiply for CRC *\/ \\\n+    decl(BMI1,              bmi1,              23) \\\n@@ -400,4 +402,4 @@\n-    decl(BMI2,              \"bmi2\",              24) \\\n-    decl(RTM,               \"rtm\",               25) \/* Restricted Transactional Memory instructions *\/ \\\n-    decl(ADX,               \"adx\",               26) \\\n-    decl(AVX512F,           \"avx512f\",           27) \/* AVX 512bit foundation instructions *\/ \\\n+    decl(BMI2,              bmi2,              24) \\\n+    decl(RTM,               rtm,               25) \/* Restricted Transactional Memory instructions *\/ \\\n+    decl(ADX,               adx,               26) \\\n+    decl(AVX512F,           avx512f,           27) \/* AVX 512bit foundation instructions *\/ \\\n@@ -405,4 +407,4 @@\n-    decl(AVX512DQ,          \"avx512dq\",          28) \\\n-    decl(AVX512PF,          \"avx512pf\",          29) \\\n-    decl(AVX512ER,          \"avx512er\",          30) \\\n-    decl(AVX512CD,          \"avx512cd\",          31) \\\n+    decl(AVX512DQ,          avx512dq,          28) \\\n+    decl(AVX512PF,          avx512pf,          29) \\\n+    decl(AVX512ER,          avx512er,          30) \\\n+    decl(AVX512CD,          avx512cd,          31) \\\n@@ -410,4 +412,4 @@\n-    decl(AVX512BW,          \"avx512bw\",          32) \/* Byte and word vector instructions *\/ \\\n-    decl(AVX512VL,          \"avx512vl\",          33) \/* EVEX instructions with smaller vector length *\/ \\\n-    decl(SHA,               \"sha\",               34) \/* SHA instructions *\/ \\\n-    decl(FMA,               \"fma\",               35) \/* FMA instructions *\/ \\\n+    decl(AVX512BW,          avx512bw,          32) \/* Byte and word vector instructions *\/ \\\n+    decl(AVX512VL,          avx512vl,          33) \/* EVEX instructions with smaller vector length *\/ \\\n+    decl(SHA,               sha,               34) \/* SHA instructions *\/ \\\n+    decl(FMA,               fma,               35) \/* FMA instructions *\/ \\\n@@ -415,4 +417,4 @@\n-    decl(VZEROUPPER,        \"vzeroupper\",        36) \/* Vzeroupper instruction *\/ \\\n-    decl(AVX512_VPOPCNTDQ,  \"avx512_vpopcntdq\",  37) \/* Vector popcount *\/ \\\n-    decl(AVX512_VPCLMULQDQ, \"avx512_vpclmulqdq\", 38) \/* Vector carryless multiplication *\/ \\\n-    decl(AVX512_VAES,       \"avx512_vaes\",       39) \/* Vector AES instruction *\/ \\\n+    decl(VZEROUPPER,        vzeroupper,        36) \/* Vzeroupper instruction *\/ \\\n+    decl(AVX512_VPOPCNTDQ,  avx512_vpopcntdq,  37) \/* Vector popcount *\/ \\\n+    decl(AVX512_VPCLMULQDQ, avx512_vpclmulqdq, 38) \/* Vector carryless multiplication *\/ \\\n+    decl(AVX512_VAES,       avx512_vaes,       39) \/* Vector AES instruction *\/ \\\n@@ -420,4 +422,4 @@\n-    decl(AVX512_VNNI,       \"avx512_vnni\",       40) \/* Vector Neural Network Instructions *\/ \\\n-    decl(FLUSH,             \"clflush\",           41) \/* flush instruction *\/ \\\n-    decl(FLUSHOPT,          \"clflushopt\",        42) \/* flusopth instruction *\/ \\\n-    decl(CLWB,              \"clwb\",              43) \/* clwb instruction *\/ \\\n+    decl(AVX512_VNNI,       avx512_vnni,       40) \/* Vector Neural Network Instructions *\/ \\\n+    decl(FLUSH,             clflush,           41) \/* flush instruction *\/ \\\n+    decl(FLUSHOPT,          clflushopt,        42) \/* flusopth instruction *\/ \\\n+    decl(CLWB,              clwb,              43) \/* clwb instruction *\/ \\\n@@ -425,21 +427,21 @@\n-    decl(AVX512_VBMI2,      \"avx512_vbmi2\",      44) \/* VBMI2 shift left double instructions *\/ \\\n-    decl(AVX512_VBMI,       \"avx512_vbmi\",       45) \/* Vector BMI instructions *\/ \\\n-    decl(HV,                \"hv\",                46) \/* Hypervisor instructions *\/ \\\n-    decl(SERIALIZE,         \"serialize\",         47) \/* CPU SERIALIZE *\/ \\\n-    decl(RDTSCP,            \"rdtscp\",            48) \/* RDTSCP instruction *\/ \\\n-    decl(RDPID,             \"rdpid\",             49) \/* RDPID instruction *\/ \\\n-    decl(FSRM,              \"fsrm\",              50) \/* Fast Short REP MOV *\/ \\\n-    decl(GFNI,              \"gfni\",              51) \/* Vector GFNI instructions *\/ \\\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n-    decl(F16C,              \"f16c\",              53) \/* Half-precision and single precision FP conversion instructions*\/ \\\n-    decl(PKU,               \"pku\",               54) \/* Protection keys for user-mode pages *\/ \\\n-    decl(OSPKE,             \"ospke\",             55) \/* OS enables protection keys *\/ \\\n-    decl(CET_IBT,           \"cet_ibt\",           56) \/* Control Flow Enforcement - Indirect Branch Tracking *\/ \\\n-    decl(CET_SS,            \"cet_ss\",            57) \/* Control Flow Enforcement - Shadow Stack *\/ \\\n-    decl(AVX512_IFMA,       \"avx512_ifma\",       58) \/* Integer Vector FMA instructions*\/ \\\n-    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n-    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/ \\\n-    decl(SHA512,            \"sha512\",            61) \/* SHA512 instructions*\/ \\\n-    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/ \\\n-    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n-    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n+    decl(AVX512_VBMI2,      avx512_vbmi2,      44) \/* VBMI2 shift left double instructions *\/ \\\n+    decl(AVX512_VBMI,       avx512_vbmi,       45) \/* Vector BMI instructions *\/ \\\n+    decl(HV,                hv,                46) \/* Hypervisor instructions *\/ \\\n+    decl(SERIALIZE,         serialize,         47) \/* CPU SERIALIZE *\/ \\\n+    decl(RDTSCP,            rdtscp,            48) \/* RDTSCP instruction *\/ \\\n+    decl(RDPID,             rdpid,             49) \/* RDPID instruction *\/ \\\n+    decl(FSRM,              fsrm,              50) \/* Fast Short REP MOV *\/ \\\n+    decl(GFNI,              gfni,              51) \/* Vector GFNI instructions *\/ \\\n+    decl(AVX512_BITALG,     avx512_bitalg,     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(F16C,              f16c,              53) \/* Half-precision and single precision FP conversion instructions*\/ \\\n+    decl(PKU,               pku,               54) \/* Protection keys for user-mode pages *\/ \\\n+    decl(OSPKE,             ospke,             55) \/* OS enables protection keys *\/ \\\n+    decl(CET_IBT,           cet_ibt,           56) \/* Control Flow Enforcement - Indirect Branch Tracking *\/ \\\n+    decl(CET_SS,            cet_ss,            57) \/* Control Flow Enforcement - Shadow Stack *\/ \\\n+    decl(AVX512_IFMA,       avx512_ifma,       58) \/* Integer Vector FMA instructions*\/ \\\n+    decl(AVX_IFMA,          avx_ifma,          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n+    decl(APX_F,             apx_f,             60) \/* Intel Advanced Performance Extensions*\/ \\\n+    decl(SHA512,            sha512,            61) \/* SHA512 instructions*\/ \\\n+    decl(AVX512_FP16,       avx512_fp16,       62) \/* AVX512 FP16 ISA support*\/ \\\n+    decl(AVX10_1,           avx10_1,           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n+    decl(AVX10_2,           avx10_2,           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n@@ -486,0 +488,1 @@\n+\n@@ -507,0 +510,9 @@\n+\n+    bool supports_features(VM_Features* features_to_test) {\n+      for (int i = 0; i < features_bitmap_element_count(); i++) {\n+        if ((_features_bitmap[i] & features_to_test->_features_bitmap[i]) != features_to_test->_features_bitmap[i]) {\n+          return false;\n+       }\n+      }\n+      return true;\n+    }\n@@ -924,1 +936,1 @@\n-  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+  static void insert_features_names(VM_Version::VM_Features features, stringStream& ss);\n@@ -1075,0 +1087,12 @@\n+\n+  static void get_cpu_features_name(void* features_buffer, stringStream& ss);\n+  static void get_missing_features_name(void* features_buffer, stringStream& ss);\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size();\n+\n+  \/\/ Stores cpu features representation in the provided buffer. This representation is arch dependent.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf);\n+\n+  static bool supports_features(void* features_to_test);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":90,"deletions":66,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-  _features = CPU_FP | CPU_ASIMD;\n+  set_feature(CPU_FP);\n+  set_feature(CPU_ASIMD);\n@@ -78,1 +79,4 @@\n-  _features |= CPU_AES | CPU_PMULL | CPU_SHA1 | CPU_SHA2;\n+  set_feature(CPU_AES);\n+  set_feature(CPU_PMULL);\n+  set_feature(CPU_SHA1);\n+  set_feature(CPU_SHA2);\n@@ -81,1 +85,1 @@\n-    _features |= CPU_CRC32;\n+    set_feature(CPU_CRC32);\n@@ -85,1 +89,1 @@\n-    _features |= CPU_LSE;\n+    set_feature(CPU_LSE);\n@@ -89,1 +93,1 @@\n-    _features |= CPU_SHA512;\n+    set_feature(CPU_SHA512);\n@@ -93,1 +97,1 @@\n-    _features |= CPU_SHA3;\n+    set_feature(CPU_SHA3);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -116,16 +116,16 @@\n-  static_assert(CPU_FP      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMD   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n-  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n-  static_assert(CPU_AES     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n-  static_assert(CPU_PMULL   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n-  static_assert(CPU_SHA1    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA2    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n-  static_assert(CPU_CRC32   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n-  static_assert(CPU_LSE     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n-  static_assert(CPU_DCPOP   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n-  static_assert(CPU_SHA3    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA512  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n-  static_assert(CPU_SVE     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n-  static_assert(CPU_PACA    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n-  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FP)      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMD)   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_EVTSTRM) == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_AES)     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PMULL)   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA1)    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA2)    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_CRC32)   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_LSE)     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_DCPOP)   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA3)    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA512)  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SVE)     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PACA)    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FPHP)    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMDHP) == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -150,2 +150,2 @@\n-  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;\n-  if (auxv2 & HWCAP2_SVEBITPERM) _features |= CPU_SVEBITPERM;\n+  if (auxv2 & HWCAP2_SVE2) set_feature(CPU_SVE2);\n+  if (auxv2 & HWCAP2_SVEBITPERM) set_feature(CPU_SVEBITPERM);\n@@ -185,1 +185,1 @@\n-            guarantee(_features & CPU_DCPOP, \"dcpop availability should be consistent\");\n+            guarantee(supports_feature(CPU_DCPOP), \"dcpop availability should be consistent\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -201,0 +201,4 @@\n+  product(bool, AOTCodeCPUFeatureCheck, true, DIAGNOSTIC,                   \\\n+          \"Check CPU features during production run are compatible \"        \\\n+          \"with the CPU features used during the assembly phase.\")          \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -603,1 +604,1 @@\n-void AOTCodeCache::Config::record() {\n+void AOTCodeCache::Config::record(uint cpu_features_offset) {\n@@ -639,4 +640,0 @@\n-#if !defined(ZERO) && (defined(IA32) || defined(AMD64))\n-  _useSSE                = UseSSE;\n-  _useAVX                = UseAVX;\n-#endif\n@@ -644,0 +641,1 @@\n+  _cpu_features_offset   = cpu_features_offset;\n@@ -646,1 +644,1 @@\n-bool AOTCodeCache::Config::verify() const {\n+bool AOTCodeCache::Config::verify(AOTCodeCache* cache) const {\n@@ -660,11 +658,0 @@\n-#if !defined(ZERO) && (defined(IA32) || defined(AMD64))\n-  if (UseSSE < _useSSE) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseSSE = %d vs current %d\", _useSSE, UseSSE);\n-    return false;\n-  }\n-  if (UseAVX < _useAVX) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseAVX = %d vs current %d\", _useAVX, UseAVX);\n-    return false;\n-  }\n-#endif\n-\n@@ -732,0 +719,28 @@\n+  LogStreamHandle(Debug, aot, codecache, init) log;\n+  if (log.is_enabled()) {\n+    log.print_cr(\"Available CPU features: %s\", VM_Version::features_string());\n+  }\n+\n+  uint offset = _cpu_features_offset;\n+  uint cpu_features_size = *(uint *)cache->addr(offset);\n+  assert(cpu_features_size == (uint)VM_Version::cpu_features_size(), \"must be\");\n+  offset += sizeof(uint);\n+\n+  void* cached_cpu_features_buffer = (void *)cache->addr(offset);\n+  if (log.is_enabled()) {\n+    ResourceMark rm; \/\/ required for stringStream::as_string()\n+    stringStream ss;\n+    VM_Version::get_cpu_features_name(cached_cpu_features_buffer, ss);\n+    log.print_cr(\"CPU features recorded in AOTCodeCache: %s\", ss.as_string());\n+  }\n+\n+  if (AOTCodeCPUFeatureCheck && !VM_Version::supports_features(cached_cpu_features_buffer)) {\n+    if (log.is_enabled()) {\n+      ResourceMark rm; \/\/ required for stringStream::as_string()\n+      stringStream ss;\n+      VM_Version::get_missing_features_name(cached_cpu_features_buffer, ss);\n+      log.print_cr(\"AOT Code Cache disabled: required cpu features are missing: %s\", ss.as_string());\n+    }\n+    return false;\n+  }\n+\n@@ -1085,0 +1100,11 @@\n+void AOTCodeCache::store_cpu_features(char*& buffer, uint buffer_size) {\n+  uint* size_ptr = (uint *)buffer;\n+  *size_ptr = buffer_size;\n+  buffer += sizeof(uint);\n+\n+  VM_Version::store_cpu_features(buffer);\n+  log_debug(aot, codecache, exit)(\"CPU features recorded in AOTCodeCache: %s\", VM_Version::features_string());\n+  buffer += buffer_size;\n+  buffer = align_up(buffer, DATA_ALIGNMENT);\n+}\n+\n@@ -1107,1 +1133,1 @@\n-    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header),  DATA_ALIGNMENT);\n+    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header), DATA_ALIGNMENT);\n@@ -1116,0 +1142,2 @@\n+    uint cpu_features_size = VM_Version::cpu_features_size();\n+    uint total_cpu_features_size = sizeof(uint) + cpu_features_size; \/\/ sizeof(uint) to store cpu_features_size\n@@ -1117,1 +1145,2 @@\n-                      search_size + preload_entries_size + entries_size;\n+                      search_size + preload_entries_size + entries_size +\n+                      align_up(total_cpu_features_size, DATA_ALIGNMENT);\n@@ -1120,3 +1149,0 @@\n-\n-    \/\/ Create ordered search table for entries [id, index];\n-    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n@@ -1128,0 +1154,8 @@\n+    uint cpu_features_offset = current - start;\n+    store_cpu_features(current, cpu_features_size);\n+    assert(is_aligned(current, DATA_ALIGNMENT), \"sanity check\");\n+    assert(current < start + total_size, \"sanity check\");\n+\n+    \/\/ Create ordered search table for entries [id, index];\n+    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n+\n@@ -1247,1 +1281,2 @@\n-                 C1_blobs_count, C2_blobs_count, stubs_count);\n+                 C1_blobs_count, C2_blobs_count,\n+                 stubs_count, cpu_features_offset);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":58,"deletions":23,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/sizes.hpp\"\n@@ -33,1 +35,0 @@\n-\n@@ -323,4 +324,0 @@\n-#if defined(IA32) || defined(AMD64)\n-    int  _useSSE; \/\/ Hack before we record CPU features\n-    int  _useAVX;\n-#endif\n@@ -340,0 +337,1 @@\n+    uint _cpu_features_offset; \/\/ offset in the cache where cpu features are stored\n@@ -342,2 +340,2 @@\n-    void record();\n-    bool verify() const;\n+    void record(uint cpu_features_offset);\n+    bool verify(AOTCodeCache* cache) const;\n@@ -365,1 +363,1 @@\n-    Config _config;\n+    Config _config; \/\/ must be the last element as there is trailing data stored immediately after Config\n@@ -373,1 +371,2 @@\n-              uint C1_blobs_count, uint C2_blobs_count, uint stubs_count) {\n+              uint C1_blobs_count, uint C2_blobs_count,\n+              uint stubs_count, uint cpu_features_offset) {\n@@ -388,1 +387,1 @@\n-      _config.record();\n+      _config.record(cpu_features_offset);\n@@ -411,2 +410,2 @@\n-    bool verify_config() const { \/\/ Called after Universe initialized\n-      return _config.verify();\n+    bool verify_config(AOTCodeCache* cache) const { \/\/ Called after Universe initialized\n+      return _config.verify(cache);\n@@ -528,0 +527,2 @@\n+  void store_cpu_features(char*& buffer, uint buffer_size);\n+\n@@ -588,1 +589,1 @@\n-      return _load_header->verify_config();\n+      return _load_header->verify_config(this);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -328,13 +328,0 @@\n-const char* Abstract_VM_Version::extract_features_string(const char* cpu_info_string,\n-                                                         size_t cpu_info_string_len,\n-                                                         size_t features_offset) {\n-  assert(features_offset <= cpu_info_string_len, \"\");\n-  if (features_offset < cpu_info_string_len) {\n-    assert(cpu_info_string[features_offset + 0] == ',', \"\");\n-    assert(cpu_info_string[features_offset + 1] == ' ', \"\");\n-    return cpu_info_string + features_offset + 2; \/\/ skip initial \", \"\n-  } else {\n-    return \"\"; \/\/ empty\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class stringStream;\n@@ -135,3 +136,0 @@\n-  static const char* extract_features_string(const char* cpu_info_string,\n-                                             size_t cpu_info_string_len,\n-                                             size_t features_offset);\n@@ -232,0 +230,13 @@\n+\n+  static void get_cpu_features_name(void* features_buffer, stringStream& ss) { return; }\n+  static void get_missing_features_name(void* features_buffer, stringStream& ss) { return; }\n+\n+  \/\/ Returns number of bytes required to store cpu features representation\n+  static int cpu_features_size() { return 0; }\n+\n+  \/\/ Stores arch dependent cpu features representation in the provided buffer.\n+  \/\/ Size of the buffer must be same as returned by cpu_features_size()\n+  static void store_cpu_features(void* buf) { return; }\n+\n+  \/\/ features_to_test is an opaque object that stores arch specific representation of cpu features\n+  static bool supports_features(void* features_to_test) { return false; };\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -168,0 +168,14 @@\n+\n+   \/\/ Append strings returned by gen, separating each with separator.\n+   \/\/ Stops when gen returns null.\n+   template <typename Generator>\n+   void join(Generator gen, const char* separator) {\n+     bool first = true;\n+     const char* str = gen();\n+     while (str != nullptr) {\n+       const char* sep = first ? \"\" : separator;\n+       print(\"%s%s\", sep, str);\n+       first = false;\n+       str = gen();\n+     }\n+   }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary CPU feature compatibility test for AOT Code Cache\n+ * @requires vm.cds.supports.aot.code.caching\n+ * @requires vm.compMode != \"Xcomp\" & vm.compMode != \"Xint\"\n+ * @requires os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\"\n+ * @comment The test verifies AOT checks during VM startup and not code generation.\n+ *          No need to run it with -Xcomp.\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build AOTCodeCPUFeatureIncompatibilityTest JavacBenchApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *             JavacBenchApp\n+ *             JavacBenchApp$ClassFile\n+ *             JavacBenchApp$FileManager\n+ *             JavacBenchApp$SourceFile\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI AOTCodeCPUFeatureIncompatibilityTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+\n+public class AOTCodeCPUFeatureIncompatibilityTest {\n+    public static void main(String... args) throws Exception {\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+        if (Platform.isX64()) {\n+            \/\/ Minimum value of UseSSE required by JVM is 2. So the production run has to be executed with UseSSE=2.\n+            \/\/ To simulate the case of incmpatible SSE feature, we can run this test only on system with higher SSE level (sse3 or above).\n+            if (isSSE3Supported(cpuFeatures)) {\n+                testIncompatibleFeature(\"-XX:UseSSE=2\", \"sse3\");\n+            }\n+            if (isAVXSupported(cpuFeatures)) {\n+                testIncompatibleFeature(\"-XX:UseAVX=0\", \"avx\");\n+            }\n+\n+        \/*\n+         * Unfortunately -XX:-UseCRC32 does not clear the feature bit in VM_Version::_features!\n+         * Disable this test until it is fixed\n+        } else if (Platform.isAArch64()) {\n+            if (isCRC32Supported(cpuFeatures)) {\n+                testIncompatibleFeature(\"-XX:-UseCRC32\", \"crc32\");\n+            }\n+        *\/\n+        }\n+    }\n+\n+    \/\/ vmOption = command line option to disable CPU feature\n+    \/\/ featureName = name of the CPU feature used by the JVM in the log messages\n+    public static void testIncompatibleFeature(String vmOption, String featureName) throws Exception {\n+        new CDSAppTester(\"AOTCodeCPUFeatureIncompatibilityTest\") {\n+            @Override\n+            public String[] vmArgs(RunMode runMode) {\n+                if (runMode == RunMode.PRODUCTION) {\n+                    return new String[] {vmOption, \"-Xlog:aot+codecache+init=debug\"};\n+                }\n+                return new String[] {};\n+            }\n+            @Override\n+            public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+                if (runMode == RunMode.ASSEMBLY) {\n+                    out.shouldMatch(\"CPU features recorded in AOTCodeCache:.*\" + featureName + \".*\");\n+                } else if (runMode == RunMode.PRODUCTION) {\n+                    out.shouldMatch(\"AOT Code Cache disabled: required cpu features are missing:.*\" + featureName + \".*\");\n+                    out.shouldContain(\"Unable to use AOT Code Cache\");\n+                }\n+            }\n+            @Override\n+            public String classpath(RunMode runMode) {\n+                return \"app.jar\";\n+            }\n+            @Override\n+            public String[] appCommandLine(RunMode runMode) {\n+                return new String[] {\n+                    \"JavacBenchApp\", \"10\"\n+                };\n+            }\n+        }.runAOTWorkflow(\"--two-step-training\");\n+    }\n+\n+    \/\/ Only used on x86-64 platform\n+    static boolean isSSE3Supported(List<String> cpuFeatures) {\n+        return cpuFeatures.contains(\"sse3\");\n+    }\n+\n+    \/\/ Only used on x86-64 platform\n+    static boolean isAVXSupported(List<String> cpuFeatures) {\n+        return cpuFeatures.contains(\"avx\");\n+    }\n+\n+    \/\/ Only used on aarch64 platofrm\n+    static boolean isCRC32Supported(List<String> cpuFeatures) {\n+        return cpuFeatures.contains(\"crc32\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeCPUFeatureIncompatibilityTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -242,0 +242,15 @@\n+    public boolean matches(String regexp) {\n+        Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n+        String stdout = getStdout();\n+        Matcher matcher = pattern.matcher(stdout);\n+        if (matcher.find()) {\n+            return true;\n+        }\n+        String stderr = getStderr();\n+        matcher = pattern.matcher(stderr);\n+        if (matcher.find()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}