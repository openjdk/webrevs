{"files":[{"patch":"@@ -123,0 +123,20 @@\n+\n+#ifdef _LP64\n+  \/\/\n+  \/\/ By default, when using AOTClassLinking, use the CompressedOops::HeapBasedNarrowOop\n+  \/\/ mode so that AOT code can be always work regardless of runtime heap range.\n+  \/\/\n+  \/\/ If you are *absolutely sure* that the CompressedOops::mode() will be the same\n+  \/\/ between training and production runs (e.g., if you specify -Xmx128m for\n+  \/\/ both training and production runs, and you know the OS will always reserve\n+  \/\/ the heap under 4GB), you can explicitly disable this with:\n+  \/\/     java -XX:+UnlockDiagnosticVMOptions -XX:-UseCompatibleCompressedOops ...\n+  \/\/ However, this is risky and there's a chance that the production run will be slower\n+  \/\/ than expected because it is unable to load the AOT code cache.\n+  \/\/\n+  if (UseCompressedOops && AOTCodeCache::is_caching_enabled()) {\n+    FLAG_SET_ERGO_IF_DEFAULT(UseCompatibleCompressedOops, true);\n+  } else if (!FLAG_IS_DEFAULT(UseCompatibleCompressedOops)) {\n+    FLAG_SET_ERGO(UseCompatibleCompressedOops, false);\n+  }\n+#endif \/\/ _LP64\n@@ -768,16 +788,0 @@\n-  \/\/ Leyden temp work-around:\n-  \/\/\n-  \/\/ By default, when using CacheDataStore, use the HeapBasedNarrowOop mode so that\n-  \/\/ AOT code can be always work regardless of runtime heap range.\n-  \/\/\n-  \/\/ If you are *absolutely sure* that the CompressedOops::mode() will be the same\n-  \/\/ between training and production runs (e.g., if you specify -Xmx128m\n-  \/\/ for both training and production runs, and you know the OS will always reserve\n-  \/\/ the heap under 4GB), you can explicitly disable this with:\n-  \/\/     java -XX:-UseCompatibleCompressedOops -XX:CacheDataStore=...\n-  \/\/ However, this is risky and there's a chance that the production run will be slower\n-  \/\/ because it is unable to load the AOT code cache.\n-#ifdef _LP64\n-  \/\/ FLAG_SET_ERGO_IF_DEFAULT(UseCompatibleCompressedOops, true); \/\/ FIXME @iklam - merge with mainline - UseCompatibleCompressedOops\n-#endif\n-\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -4091,0 +4091,10 @@\n+  \/\/ Check card_table_base address first since it can point to any address\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  if (bs->is_a(BarrierSet::CardTableBarrierSet)) {\n+    if (addr == ci_card_table_address_as<address>()) {\n+      id = search_address(addr, _extrs_addr, _extrs_length);\n+      assert(id > 0 && _extrs_addr[id - _extrs_base] == addr, \"sanity\");\n+      return id;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -506,1 +506,2 @@\n-  if (reserved.end() > (char *)OopEncodingHeapMax) {\n+  if (reserved.end() > (char *)OopEncodingHeapMax || UseCompatibleCompressedOops) {\n+    assert((reserved.base() != nullptr), \"sanity\");\n@@ -552,2 +553,9 @@\n-  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > (char*)OopEncodingHeapMax) ?\n-    noaccess_prefix_size : 0;\n+  char* heap_end_address = aligned_heap_base_min_address + size;\n+\n+  bool unscaled  = false;\n+  bool zerobased = false;\n+  if (!UseCompatibleCompressedOops) { \/\/ heap base is not enforced\n+    unscaled  = (heap_end_address <= (char*)UnscaledOopHeapMax);\n+    zerobased = (heap_end_address <= (char*)OopEncodingHeapMax);\n+  }\n+  size_t noaccess_prefix = !zerobased ? noaccess_prefix_size : 0;\n@@ -558,1 +566,1 @@\n-  if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {\n+  if (!FLAG_IS_DEFAULT(HeapBaseMinAddress) || UseCompatibleCompressedOops) {\n@@ -580,1 +588,1 @@\n-    if (aligned_heap_base_min_address + size <= (char *)UnscaledOopHeapMax) {\n+    if (unscaled) {\n@@ -593,3 +601,3 @@\n-    if (aligned_heap_base_min_address + size <= zerobased_max && \/\/ Zerobased theoretical possible.\n-        ((!reserved.is_reserved()) ||                            \/\/ No previous try succeeded.\n-         (reserved.end() > zerobased_max))) {                    \/\/ Unscaled delivered an arbitrary address.\n+    if (zerobased &&                          \/\/ Zerobased theoretical possible.\n+        ((!reserved.is_reserved()) ||         \/\/ No previous try succeeded.\n+         (reserved.end() > zerobased_max))) { \/\/ Unscaled delivered an arbitrary address.\n@@ -661,0 +669,1 @@\n+    assert(!UseCompatibleCompressedOops, \"noaccess prefix is missing\");\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"}]}