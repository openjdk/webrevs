{"files":[{"patch":"@@ -162,0 +162,7 @@\n+By default, training runs end when the application terminates.  You have two other options to end training runs:\n+\n+- -XX:AOTEndTrainingOnMethodEntry=<method1,method2,...>[,count=100]\n+- jcmd \\<pid> AOT.end_training\n+\n+Note that AOTEndTrainingOnMethodEntry uses the same format as CompileOnly and the default count is 1\n+\n","filename":"README.md","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1401,0 +1402,10 @@\n+void InterpreterMacroAssembler::generate_runtime_upcalls_on_method_entry()\n+{\n+  address upcall = RuntimeUpcalls::on_method_entry_upcall_address();\n+  if (RuntimeUpcalls::does_upcall_need_method_parameter(upcall)) {\n+    get_method(c_rarg1);\n+    call_VM(noreg,upcall, c_rarg1);\n+  } else {\n+    call_VM(noreg,upcall);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -306,0 +306,3 @@\n+  \/\/ support for runtime upcalls\n+  void generate_runtime_upcalls_on_method_entry();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1153,1 +1153,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1272,0 +1272,4 @@\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n+  }\n+\n@@ -1576,1 +1580,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1721,0 +1725,5 @@\n+  \/\/ runtime upcalls\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1141,1 +1141,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1180,1 +1180,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1605,1 +1605,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -960,1 +960,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1357,1 +1357,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1304,1 +1304,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1660,1 +1660,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1932,0 +1933,11 @@\n+void InterpreterMacroAssembler::generate_runtime_upcalls_on_method_entry()\n+{\n+  address upcall = RuntimeUpcalls::on_method_entry_upcall_address();\n+  if (RuntimeUpcalls::does_upcall_need_method_parameter(upcall)) {\n+    get_method(c_rarg1);\n+    call_VM(noreg,upcall, c_rarg1);\n+  } else {\n+    call_VM(noreg,upcall);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -276,0 +276,3 @@\n+  \/\/ support for runtime upcalls\n+  void generate_runtime_upcalls_on_method_entry();\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -793,1 +793,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -919,0 +919,5 @@\n+  \/\/ runtime upcalls\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n+  }\n+\n@@ -1332,1 +1337,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1474,0 +1479,4 @@\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -4082,0 +4083,8 @@\n+  MethodDetails method_details(callee);\n+  RuntimeUpcallInfo* upcall = RuntimeUpcalls::get_first_upcall(RuntimeUpcallType::onMethodEntry, method_details);\n+  while (upcall != nullptr) {\n+    Values* args = new Values(0);\n+    append(new RuntimeCall(voidType, upcall->upcall_name(), upcall->upcall_address(), args));\n+    upcall = RuntimeUpcalls::get_next_upcall(RuntimeUpcallType::onMethodEntry, method_details, upcall);\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -2679,0 +2680,11 @@\n+  MethodDetails method_details(method());\n+  RuntimeUpcallInfo* upcall = RuntimeUpcalls::get_first_upcall(RuntimeUpcallType::onMethodEntry, method_details);\n+  while (upcall != nullptr) {\n+    BasicTypeList signature;\n+    signature.append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    \/\/ thread\n+    LIR_OprList* args = new LIR_OprList();\n+    args->append(getThreadPointer());\n+    call_runtime(&signature, args, upcall->upcall_address(), voidType, nullptr);\n+    upcall = RuntimeUpcalls::get_next_upcall(RuntimeUpcallType::onMethodEntry, method_details, upcall);\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -358,0 +359,6 @@\n+  \/\/ Runtime upcalls also has a map of addresses to names\n+  const char* upcall_name = RuntimeUpcalls::get_name_for_upcall_address(entry);\n+  if (upcall_name != nullptr) {\n+    return upcall_name;\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -674,0 +674,4 @@\n+bool CDSConfig::is_dumping_preimage_static_archive_with_triggers() {\n+  return (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry)) && is_dumping_preimage_static_archive();\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,3 +96,4 @@\n-  static bool is_dumping_classic_static_archive()            NOT_CDS_RETURN_(false); \/\/ -Xshare:dump\n-  static bool is_dumping_preimage_static_archive()           NOT_CDS_RETURN_(false); \/\/ 1st phase of -XX:CacheDataStore dumping\n-  static bool is_dumping_final_static_archive()              NOT_CDS_RETURN_(false); \/\/ 2nd phase of -XX:CacheDataStore dumping\n+  static bool is_dumping_classic_static_archive()                NOT_CDS_RETURN_(false); \/\/ -Xshare:dump\n+  static bool is_dumping_preimage_static_archive()               NOT_CDS_RETURN_(false); \/\/ 1st phase of -XX:CacheDataStore dumping\n+  static bool is_dumping_preimage_static_archive_with_triggers() NOT_CDS_RETURN_(false); \/\/ 1st phase of -XX:CacheDataStore dumping with triggers\n+  static bool is_dumping_final_static_archive()                  NOT_CDS_RETURN_(false); \/\/ 2nd phase of -XX:CacheDataStore dumping\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+\n+\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/cdsEndTrainingUpcall.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"compiler\/methodMatcher.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/runtimeUpcalls.hpp\"\n+\n+uint volatile  CDSEndTrainingUpcall::_count = 0;\n+uint           CDSEndTrainingUpcall::_limit = 1;\n+int  volatile  CDSEndTrainingUpcall::_triggered = 0;\n+BasicMatcher*  CDSEndTrainingUpcall::_matcher = nullptr;\n+\n+bool cdsEndTrainingUpcall_register_upcalls()\n+{\n+  if (!CDSConfig::is_dumping_preimage_static_archive_with_triggers()) {\n+    return true;\n+  }\n+  return CDSEndTrainingUpcall::register_upcalls();\n+}\n+\n+bool CDSEndTrainingUpcall::register_upcalls()\n+{\n+  if (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry)) {\n+    if (CDSEndTrainingUpcall::parse_vm_command(AOTEndTrainingOnMethodEntry)) {\n+      return RuntimeUpcalls::register_upcall(\n+            RuntimeUpcallType::onMethodEntry,\n+            \"end_training_check\",\n+            CDSEndTrainingUpcall::end_training_check,\n+            CDSEndTrainingUpcall::filter_method_callback\n+            );\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+JRT_ENTRY(void, CDSEndTrainingUpcall::end_training_check(JavaThread* current))\n+{\n+    if (_triggered == 0) {\n+      Atomic::inc(&_count);\n+      if(_count >= _limit) {\n+        CDSEndTrainingUpcall::end_training(current);\n+      }\n+    }\n+}\n+JRT_END\n+\n+bool CDSEndTrainingUpcall::end_training(JavaThread* current)\n+{\n+  if (_triggered == 0) {\n+    if (Atomic::cmpxchg(&_triggered, 0, 1) == 0) {\n+      MetaspaceShared::preload_and_dump(current);\n+      assert(!current->has_pending_exception(), \"Unexpected exception\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool CDSEndTrainingUpcall::filter_method_callback(MethodDetails& method_details)\n+{\n+  if (_matcher != nullptr) {\n+    return _matcher->match(method_details);\n+  }\n+  return false;\n+}\n+\n+bool CDSEndTrainingUpcall::parse_vm_command(ccstrlist command)\n+{\n+  assert(command != nullptr, \"sanity\");\n+  ResourceMark rm;\n+  const char* error_msg = nullptr;\n+  char* copy = os::strdup(command, mtInternal);\n+  char* line = copy;\n+  char* method_pattern;\n+  int num_patterns = 0;\n+  bool error = false;\n+  const char* seperator_str = \",\";\n+  const char* count_str = \"count=\";\n+  const size_t count_str_len = strlen(count_str);\n+  do {\n+    if (line[0] == '\\0') {\n+      break;\n+    }\n+    method_pattern = strtok_r(line, seperator_str, &line);\n+    if (method_pattern != nullptr) {\n+      \/\/ if method pattern starts with count=, then parse the count\n+      if (strncmp(method_pattern, count_str, count_str_len) == 0) {\n+        int number = atoi(method_pattern + count_str_len);\n+        if (number > 0) {\n+          CDSEndTrainingUpcall::set_limit((uint)number);\n+          continue;\n+        }\n+        error_msg = \"count must be a valid integer > 0\";\n+      } else {\n+        BasicMatcher* matcher = BasicMatcher::parse_method_pattern(method_pattern, error_msg, false);\n+        if (matcher != nullptr) {\n+          if (_matcher != nullptr) {\n+            matcher->set_next(_matcher);\n+          }\n+          _matcher = matcher;\n+          num_patterns++;\n+          continue;\n+        }\n+      }\n+    }\n+    ttyLocker ttyl;\n+    tty->print_cr(\"An error occurred during parsing AOTEndTrainingOnMethodEntry\");\n+    if (error_msg != nullptr) {\n+      tty->print_cr(\"Error: %s\", error_msg);\n+    }\n+    tty->print_cr(\"Line: '%s'\", command);\n+    error = true;\n+  } while (!error && method_pattern != nullptr && line != nullptr);\n+  os::free(copy);\n+  if (num_patterns == 0) {\n+    tty->print_cr(\"Error: No method patterns found in AOTEndTrainingOnMethodEntry\");\n+    error = true;\n+  }\n+  return !error;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/cds\/cdsEndTrainingUpcall.cpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_CDSENDTRAININGUPCALL_HPP\n+#define SHARE_CDS_CDSENDTRAININGUPCALL_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class BasicMatcher;\n+class MethodDetails;\n+class Symbol;\n+\n+class CDSEndTrainingUpcall : AllStatic {\n+private:\n+  static uint volatile  _count;\n+  static uint           _limit;\n+  static int  volatile  _triggered;\n+  static BasicMatcher*  _matcher;\n+\n+  static bool parse_vm_command(ccstrlist command);\n+  static void set_limit(uint limit) { _limit = limit; }\n+\n+public:\n+  static bool register_upcalls();\n+  static bool filter_method_callback(MethodDetails& method_details);\n+  static void end_training_check(TRAPS);\n+  static bool end_training(TRAPS);\n+  static void set_method_entry_limit(uint limit) { _limit = limit; }\n+};\n+\n+#endif \/\/ SHARE_CDS_CDSENDTRAININGUPCALL_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsEndTrainingUpcall.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -122,0 +122,4 @@\n+  product(ccstrlist, AOTEndTrainingOnMethodEntry, \"\",                       \\\n+          \"List of methods (pkg\/class.name) to trigger end of AOT \"         \\\n+          \"training run.  Optional ',count=N' where N is > 0\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+int volatile MetaspaceShared::_preimage_static_archive_dumped = 0;\n@@ -763,1 +764,1 @@\n-    \/\/ there's no need to force verification or resolve CP entries. \n+    \/\/ there's no need to force verification or resolve CP entries.\n@@ -893,0 +894,7 @@\n+bool MetaspaceShared::is_recording_preimage_static_archive() {\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      return _preimage_static_archive_dumped == 0;\n+  }\n+  return false;\n+}\n+\n@@ -894,0 +902,6 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    if (Atomic::cmpxchg(&_preimage_static_archive_dumped, 0, 1) != 0) {\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  static int volatile _preimage_static_archive_dumped;\n@@ -116,0 +117,2 @@\n+  static bool is_recording_preimage_static_archive() NOT_CDS_RETURN_(false);\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,7 +200,9 @@\n-  bool caller_sensitive()       const { return get_Method()->caller_sensitive();       }\n-  bool force_inline()           const { return get_Method()->force_inline();           }\n-  bool dont_inline()            const { return get_Method()->dont_inline();            }\n-  bool intrinsic_candidate()    const { return get_Method()->intrinsic_candidate();    }\n-  bool is_static_initializer()  const { return get_Method()->is_static_initializer();  }\n-  bool changes_current_thread() const { return get_Method()->changes_current_thread(); }\n-  bool deprecated()             const { return is_loaded() && get_Method()->deprecated(); }\n+  bool caller_sensitive()           const { return get_Method()->caller_sensitive();           }\n+  bool force_inline()               const { return get_Method()->force_inline();               }\n+  bool dont_inline()                const { return get_Method()->dont_inline();                }\n+  bool intrinsic_candidate()        const { return get_Method()->intrinsic_candidate();        }\n+  bool is_static_initializer()      const { return get_Method()->is_static_initializer();      }\n+  bool changes_current_thread()     const { return get_Method()->changes_current_thread();     }\n+  bool deprecated()                 const { return is_loaded() && get_Method()->deprecated();  }\n+  bool has_upcall_on_method_entry() const { return get_Method()->has_upcall_on_method_entry(); }\n+  bool has_upcall_on_method_exit()  const { return get_Method()->has_upcall_on_method_exit();  }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -363,0 +363,9 @@\n+bool MethodMatcher::matches(MethodDetails& method_details) const {\n+  if (match(method_details.class_name(), this->class_name(), _class_mode) &&\n+      match(method_details.method_name(), this->method_name(), _method_mode) &&\n+      ((this->signature() == nullptr) || match(method_details.signature(), this->signature(), Prefix))) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -407,0 +416,9 @@\n+bool BasicMatcher::match(MethodDetails& method_details) {\n+  for (BasicMatcher* current = this; current != nullptr; current = current->next()) {\n+    if (current->matches(method_details)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/methodDetails.hpp\"\n@@ -64,0 +65,1 @@\n+  bool matches(MethodDetails& method_details) const;\n@@ -86,0 +88,1 @@\n+  bool match(MethodDetails& method_details);\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,0 +90,6 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_AOTIsTraining(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL\n+JVM_AOTEndTraining(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,1 +174,4 @@\n-    return m->is_synchronized() ? native_synchronized : native;\n+    if (m->is_synchronized()) {\n+      return m->has_upcall_on_method_entry() ? native_synchronized_upcalls : native_synchronized;\n+    }\n+    return m->has_upcall_on_method_entry() ? native_upcalls : native;\n@@ -179,1 +182,1 @@\n-    return zerolocals_synchronized;\n+    return m->has_upcall_on_method_entry() ? zerolocals_synchronized_upcalls : zerolocals_synchronized;\n@@ -184,1 +187,1 @@\n-    return empty;\n+    return m->has_upcall_on_method_entry() ? empty_upcalls : empty;\n@@ -198,1 +201,1 @@\n-  return zerolocals;\n+  return m->has_upcall_on_method_entry() ? zerolocals_upcalls : zerolocals;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+    zerolocals_upcalls,                                         \/\/ method needs locals initialization & has runtime upcalls\n+    zerolocals_synchronized_upcalls,                            \/\/ method needs locals initialization & is synchronized & has runtime upcalls\n@@ -64,0 +66,2 @@\n+    native_upcalls,                                             \/\/ native method & has runtime upcalls\n+    native_synchronized_upcalls,                                \/\/ native method & is synchronized & has runtime upcalls\n@@ -65,0 +69,1 @@\n+    empty_upcalls,                                              \/\/ empty method & has runtime upcalls (code: _return)\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -188,0 +188,2 @@\n+  method_entry(zerolocals_upcalls)\n+  method_entry(zerolocals_synchronized_upcalls)\n@@ -189,0 +191,1 @@\n+  method_entry(empty_upcalls)\n@@ -224,0 +227,2 @@\n+  native_method_entry(native_upcalls)\n+  native_method_entry(native_synchronized_upcalls)\n@@ -410,0 +415,55 @@\n+bool TemplateInterpreterGenerator::is_synchronized_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::zerolocals_synchronized        : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_upcalls: \/\/ fall thru\n+    case Interpreter::native_synchronized            : \/\/ fall thru\n+    case Interpreter::native_synchronized_upcalls    :\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+bool TemplateInterpreterGenerator::is_runtime_upcalls_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::zerolocals_upcalls             : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_upcalls: \/\/ fall thru\n+    case Interpreter::native_upcalls                 : \/\/ fall thru\n+    case Interpreter::native_synchronized_upcalls    : \/\/ fall thru\n+    case Interpreter::empty_upcalls                  :\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+bool TemplateInterpreterGenerator::is_intrinsic_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::zerolocals                     : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized        : \/\/ fall thru\n+    case Interpreter::zerolocals_upcalls             : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_upcalls: \/\/ fall thru\n+    case Interpreter::native                         : \/\/ fall thru\n+    case Interpreter::native_synchronized            : \/\/ fall thru\n+    case Interpreter::native_upcalls                 : \/\/ fall thru\n+    case Interpreter::native_synchronized_upcalls    : \/\/ fall thru\n+    case Interpreter::empty                          : \/\/ fall thru\n+    case Interpreter::empty_upcalls                  : \/\/ fall thru\n+    case Interpreter::getter                         : \/\/ fall thru\n+    case Interpreter::setter                         : \/\/ fall thru\n+    case Interpreter::abstract                       :\n+      return false;\n+    default:\n+      return true;\n+  }\n+}\n+\n+bool TemplateInterpreterGenerator::is_abstract_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::abstract:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -413,2 +473,0 @@\n-  \/\/ determine code generation flags\n-  bool synchronized = false;\n@@ -417,12 +475,4 @@\n-  switch (kind) {\n-  case Interpreter::zerolocals             :                           break;\n-  case Interpreter::zerolocals_synchronized: synchronized = true;      break;\n-  case Interpreter::native                 :                           break;\n-  case Interpreter::native_synchronized    : synchronized = true;      break;\n-  case Interpreter::empty                  : break;\n-  case Interpreter::getter                 : break;\n-  case Interpreter::setter                 : break;\n-  case Interpreter::abstract               : entry_point = generate_abstract_entry(); break;\n-  default:\n-    entry_point = generate_intrinsic_entry(kind); \/\/ process the rest\n-    break;\n+  if (is_abstract_method(kind)) {\n+    entry_point = generate_abstract_entry();\n+  } else if (is_intrinsic_method(kind)) {\n+    entry_point = generate_intrinsic_entry(kind);\n@@ -435,0 +485,3 @@\n+  bool synchronized = is_synchronized_method(kind);\n+  bool upcalls = is_runtime_upcalls_method(kind);\n+\n@@ -436,10 +489,17 @@\n-  if (native) {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::native_synchronized : Interpreter::native);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_native_entry(synchronized);\n-    }\n-  } else {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::zerolocals_synchronized : Interpreter::zerolocals);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_normal_entry(synchronized);\n-    }\n+  if (!synchronized && !upcalls) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native\n+                                                     : Interpreter::zerolocals);\n+  } else if (synchronized && !upcalls) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_synchronized\n+                                                     : Interpreter::zerolocals_synchronized);\n+  } else if (!synchronized && upcalls) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_upcalls\n+                                                     : Interpreter::zerolocals_upcalls);\n+  } else if (synchronized && upcalls) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_synchronized_upcalls\n+                                                     : Interpreter::zerolocals_synchronized_upcalls);\n+  }\n+\n+  if (entry_point == nullptr) {\n+      entry_point = native ? generate_native_entry(synchronized, upcalls)\n+                           : generate_normal_entry(synchronized, upcalls);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":84,"deletions":24,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -86,0 +86,6 @@\n+  \/\/ helpers for method entry generation\n+  bool is_synchronized_method(AbstractInterpreter::MethodKind kind);\n+  bool is_runtime_upcalls_method(AbstractInterpreter::MethodKind kind);\n+  bool is_intrinsic_method(AbstractInterpreter::MethodKind kind);\n+  bool is_abstract_method(AbstractInterpreter::MethodKind kind);\n+\n@@ -92,2 +98,2 @@\n-  address generate_normal_entry(bool synchronized);\n-  address generate_native_entry(bool synchronized);\n+  address generate_normal_entry(bool synchronized, bool runtime_upcalls);\n+  address generate_native_entry(bool synchronized, bool runtime_upcalls);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-      entry_point = generate_native_entry(synchronized);\n+      entry_point = generate_native_entry(synchronized, false);\n@@ -129,1 +129,1 @@\n-      entry_point = generate_normal_entry(synchronized);\n+      entry_point = generate_normal_entry(synchronized, false);\n@@ -179,1 +179,1 @@\n-address ZeroInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address ZeroInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -183,1 +183,1 @@\n-address ZeroInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address ZeroInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  address generate_normal_entry(bool synchronized);\n-  address generate_native_entry(bool synchronized);\n+  address generate_normal_entry(bool synchronized, bool runtime_upcalls);\n+  address generate_native_entry(bool synchronized, bool runtime_upcalls);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1087,0 +1088,1 @@\n+    RuntimeUpcalls::install_upcalls(m);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1249,0 +1249,2 @@\n+  set_has_upcall_on_method_entry(false);\n+  set_has_upcall_on_method_exit(false);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+   status(has_upcall_on_method_entry  , 1 << 17) \\\n+   status(has_upcall_on_method_exit   , 1 << 18) \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -675,0 +675,3 @@\n+  \/\/----------- runtime upcalls support ----------------\n+  void install_on_method_entry_runtime_upcalls(ciMethod* method);\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1214,0 +1215,2 @@\n+  install_on_method_entry_runtime_upcalls(method());\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -37,0 +38,20 @@\n+void GraphKit::install_on_method_entry_runtime_upcalls(ciMethod* method) {\n+  MethodDetails method_details(method);\n+  RuntimeUpcallInfo* upcall = RuntimeUpcalls::get_first_upcall(RuntimeUpcallType::onMethodEntry, method_details);\n+  while (upcall != nullptr) {\n+    \/\/ Get base of thread-local storage area\n+    Node* thread = _gvn.transform( new ThreadLocalNode() );\n+    kill_dead_locals();\n+\n+    \/\/ For some reason, this call reads only raw memory.\n+    const TypeFunc *call_type   = OptoRuntime::runtime_up_call_Type();\n+    const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n+    make_runtime_call(RC_LEAF | RC_NARROW_MEM,\n+                      call_type, upcall->upcall_address(),\n+                      upcall->upcall_name(), raw_adr_type,\n+                      thread);\n+\n+    upcall = RuntimeUpcalls::get_next_upcall(RuntimeUpcallType::onMethodEntry, method_details, upcall);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1863,0 +1863,16 @@\n+\/\/-----------------------------------------------------------------------------\n+\/\/ runtime upcall support\n+const TypeFunc *OptoRuntime::runtime_up_call_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; \/\/ Thread-local storage\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -339,0 +339,3 @@\n+  \/\/ runtime upcalls support\n+  static const TypeFunc* runtime_up_call_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -247,0 +247,16 @@\n+JVM_LEAF_PROF(jboolean, JVM_AOTIsTraining, JVM_AOTIsTraining(JNIEnv *env))\n+#if INCLUDE_CDS\n+  return MetaspaceShared::is_recording_preimage_static_archive();\n+#else\n+  return JNI_FALSE;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY_PROF(void, JVM_AOTEndTraining, JVM_AOTEndTraining(JNIEnv *env))\n+#if INCLUDE_CDS\n+  if (MetaspaceShared::is_recording_preimage_static_archive()) {\n+    MetaspaceShared::preload_and_dump(THREAD);\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -381,0 +381,6 @@\n+  develop(ccstr, AddRuntimeUpcallsNOP, nullptr,                             \\\n+          \"Register a runtime upcall for testing.\"                          \\\n+          \"Format is '[upcallType]:[methodFilter]'\"                         \\\n+          \"where upcallType is one of 'onMethodEntry', 'onMethodExit'\"      \\\n+          \"and methodFilter is one of 'none', 'all'\")                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,0 +96,8 @@\n+\/\/ initialize upcalls before class loading\n+bool runtimeUpcalls_open_registration();\n+bool runtimeUpcallNop_register_upcalls();\n+#if INCLUDE_CDS\n+bool cdsEndTrainingUpcall_register_upcalls();\n+#endif \/\/ INCLUDE_CDS\n+bool runtimeUpcalls_close_registration();\n+\n@@ -174,0 +182,13 @@\n+\n+  \/\/ initialize upcalls before class loading \/ initialization\n+  runtimeUpcalls_open_registration();\n+  if (!runtimeUpcallNop_register_upcalls()) {\n+    return JNI_EINVAL;\n+  }\n+#if INCLUDE_CDS\n+  if (!cdsEndTrainingUpcall_register_upcalls()) {\n+    return JNI_EINVAL;\n+  }\n+#endif \/\/ INCLUDE_CDS\n+  runtimeUpcalls_close_registration();\n+\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"compiler\/abstractCompiler.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/methodDetails.hpp\"\n+\n+Symbol* MethodDetails::class_name() {\n+  if (_class_name == nullptr) {\n+    if (_method_handle != nullptr) {\n+      _class_name = (*_method_handle)->method_holder()->name();\n+    } else if (_ci_method != nullptr) {\n+      _class_name = _ci_method->holder()->name()->get_symbol();\n+    } else if (_method != nullptr) {\n+      _class_name = _method->method_holder()->name();\n+    }\n+  }\n+  return _class_name;\n+}\n+\n+Symbol* MethodDetails::method_name() {\n+  if (_method_name == nullptr) {\n+    if (_method_handle != nullptr) {\n+      _method_name = (*_method_handle)->name();\n+    } else if (_ci_method != nullptr) {\n+      _method_name = _ci_method->name()->get_symbol();\n+    } else if (_method != nullptr) {\n+      _method_name = _method->name();\n+    }\n+  }\n+  return _method_name;\n+}\n+\n+Symbol* MethodDetails::signature() {\n+  if (_signature == nullptr) {\n+    if (_method_handle != nullptr) {\n+      _signature = (*_method_handle)->signature();\n+    } else if (_ci_method != nullptr) {\n+      _signature = _ci_method->signature()->as_symbol()->get_symbol();\n+    } else if (_method != nullptr) {\n+      _signature = _method->signature();\n+    }\n+  }\n+  return _signature;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/methodDetails.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_METHOD_DETAILS_HPP\n+#define SHARE_RUNTIME_METHOD_DETAILS_HPP\n+\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/vmreg.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class ciMethod;\n+\n+class MethodDetails: public CHeapObj<mtInternal> {\n+private:\n+  const methodHandle* _method_handle;\n+  const ciMethod* _ci_method;\n+  const Method* _method;\n+\n+  Symbol* _class_name;\n+  Symbol* _method_name;\n+  Symbol* _signature;\n+\n+  MethodDetails(const methodHandle* method_handle, const ciMethod* ci_method, const Method* method) :\n+    _method_handle(method_handle), _ci_method(ci_method), _method(method),\n+    _class_name(nullptr), _method_name(nullptr), _signature(nullptr)\n+    {};\n+\n+public:\n+  MethodDetails(const methodHandle& method) :\n+    MethodDetails(&method, nullptr, nullptr) {}\n+\n+  MethodDetails(const methodHandle* method) :\n+    MethodDetails(method, nullptr, nullptr) {}\n+\n+  MethodDetails(const ciMethod* method) :\n+    MethodDetails(nullptr, method, nullptr) {}\n+\n+  MethodDetails(const Method* method) :\n+    MethodDetails(nullptr, nullptr, method) {}\n+\n+  Symbol* class_name();\n+  Symbol* method_name();\n+  Symbol* signature();\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_METHOD_DETAILS_HPP\n","filename":"src\/hotspot\/share\/runtime\/methodDetails.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/runtimeUpcallNop.hpp\"\n+#include \"runtime\/runtimeUpcalls.hpp\"\n+\n+bool RuntimeUpcallNop::_method_filter_result = false;\n+\n+bool runtimeUpcallNop_register_upcalls()\n+{\n+  return RuntimeUpcallNop::register_upcalls();\n+}\n+\n+bool RuntimeUpcallNop::register_upcalls()\n+{\n+  if(AddRuntimeUpcallsNOP == nullptr || FLAG_IS_DEFAULT(AddRuntimeUpcallsNOP)) return true;\n+\n+  const char* method_entry = \"onMethodEntry:\";\n+  const size_t method_entry_len = strlen(method_entry);\n+  const char* method_exit = \"onMethodExit:\";\n+  const size_t method_exit_len = strlen(method_exit);\n+\n+  const char* filter_all = \"all\";\n+  const size_t filter_all_len = strlen(filter_all);\n+  const char* filter_none = \"none\";\n+  const size_t filter_none_len = strlen(filter_none);\n+\n+  const char* filter_option = nullptr;\n+  RuntimeUpcallType upcall_type = RuntimeUpcallType::onMethodEntry;\n+  const char* command = AddRuntimeUpcallsNOP == nullptr ? \"\" : AddRuntimeUpcallsNOP;\n+\n+  if (strncmp(command, method_entry, method_entry_len) == 0) {\n+    filter_option = command + method_entry_len;\n+    upcall_type = RuntimeUpcallType::onMethodEntry;\n+  } else if (strncmp(command, method_exit, method_exit_len) == 0) {\n+    filter_option = command + method_exit_len;\n+    upcall_type = RuntimeUpcallType::onMethodExit;\n+  } else {\n+    ttyLocker ttyl;\n+    tty->print_cr(\"An error occurred during parsing AddRuntimeUpcallsNOP\");\n+    tty->print_cr(\"Error! Expected 'onMethodEntry:' or 'onMethodExit:'\");\n+    return false;\n+  }\n+\n+  assert(filter_option != nullptr, \"sanity\");\n+  if (strncmp(filter_option, filter_all, filter_all_len) == 0) {\n+    _method_filter_result = true;\n+  } else if (strncmp(filter_option, filter_none, filter_none_len) == 0) {\n+    _method_filter_result = false;\n+  } else {\n+    ttyLocker ttyl;\n+    tty->print_cr(\"An error occurred during parsing AddRuntimeUpcallsNOP\");\n+    tty->print_cr(\"Error! Expected 'all' or 'none'\");\n+    return false;\n+  }\n+\n+  if (RuntimeUpcalls::register_upcall(\n+        upcall_type,\n+        \"nop_method\",\n+        RuntimeUpcallNop::nop_method,\n+        RuntimeUpcallNop::filter_method_callback)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool RuntimeUpcallNop::filter_method_callback(MethodDetails& method_details)\n+{\n+  return _method_filter_result;\n+}\n+\n+JRT_ENTRY(void, RuntimeUpcallNop::nop_method(JavaThread* current))\n+{\n+}\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcallNop.cpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_RUNTIME_UPCALL_NOP_HPP\n+#define SHARE_RUNTIME_RUNTIME_UPCALL_NOP_HPP\n+\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class MethodDetails;\n+\n+class RuntimeUpcallNop : AllStatic {\n+private:\n+  static bool _method_filter_result;\n+public:\n+  static bool register_upcalls();\n+  static bool filter_method_callback(MethodDetails& method_details);\n+  static void nop_method(TRAPS);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_RUNTIME_UPCALL_NOP_HPP\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcallNop.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/methodDetails.hpp\"\n+#include \"runtime\/runtimeUpcalls.hpp\"\n+\n+GrowableArray<RuntimeUpcallInfo*>* RuntimeUpcalls::_upcalls[RuntimeUpcallType::numTypes];\n+RuntimeUpcalls::State RuntimeUpcalls::_state = RuntimeUpcalls::Uninitialized;\n+\n+bool runtimeUpcalls_open_registration() {\n+  return RuntimeUpcalls::open_upcall_registration();\n+}\n+\n+bool RuntimeUpcalls::open_upcall_registration() {\n+  assert(_state == Uninitialized, \"upcalls are already open\");\n+  for (int i = 0; i < RuntimeUpcallType::numTypes; i++) {\n+    RuntimeUpcalls::_upcalls[i] = nullptr;\n+  }\n+  _state = Open;\n+  return true;\n+}\n+\n+void runtimeUpcalls_close_registration() {\n+  RuntimeUpcalls::close_upcall_registration();\n+}\n+\n+void RuntimeUpcalls::close_upcall_registration() {\n+  assert(_state == Open, \"upcalls are not open\");\n+  _state = Closed;\n+}\n+\n+void RuntimeUpcalls::mark_for_upcalls(RuntimeUpcallType upcall_type, const methodHandle& method) {\n+  if (_upcalls[upcall_type] != nullptr) {\n+    MethodDetails method_details(method);\n+    for(RuntimeUpcallInfo* info : *(_upcalls[upcall_type])) {\n+      if(info->includes(method_details)) {\n+        switch(upcall_type) {\n+          case onMethodEntry: method->set_has_upcall_on_method_entry(true); break;\n+          case onMethodExit:  method->set_has_upcall_on_method_exit(true);  break;\n+          default:            ShouldNotReachHere();\n+        }\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+bool RuntimeUpcalls::register_upcall(RuntimeUpcallType upcall_type, RuntimeUpcallInfo* info) {\n+  assert(upcall_type != onMethodExit, \"Upcalls on method exit are not supported yet\");\n+  assert(info != nullptr, \"upcall info is null\");\n+  if (_upcalls[upcall_type] == nullptr) {\n+    _upcalls[upcall_type] = new (mtServiceability) GrowableArray<RuntimeUpcallInfo*>(1, mtServiceability);\n+  }\n+  info->set_index(_upcalls[upcall_type]->length());\n+  _upcalls[upcall_type]->append(info);\n+  return true;\n+}\n+\n+int RuntimeUpcalls::get_num_upcalls(RuntimeUpcallType upcall_type) {\n+  return (_upcalls[upcall_type] == nullptr) ? 0 : _upcalls[upcall_type]->length();\n+}\n+\n+void RuntimeUpcalls::upcall_redirect(RuntimeUpcallType upcall_type, JavaThread* current, Method* method) {\n+  MethodDetails method_details(method);\n+\n+  \/\/ This redirection occurs when there are more than one upcalls setup.  Currently each method is marked\n+  \/\/ to indicate either none, entry and\/or exit upcalls (two bits total); then we have to iterate over\n+  \/\/ all upcalls and test the method details to determine which upcalls to call.  This is not optimal.\n+  \/\/ One possible optimization is to use more bits to support more upcalls.  The method flags currently use 18\n+  \/\/ out of 32 bits, so there are still 14 bits available for use.  We could set a limit of say 4-8 entry\/exit\n+  \/\/ upcalls combined, leaving 10-6 bits for other uses.  This still requires a redirect here to determine\n+  \/\/ which upcalls to call, but it would be more efficient than the current implementation as we'd avoid the\n+  \/\/ method matching and simply map bits to indexes.\n+\n+  RuntimeUpcallInfo* upcall = get_first_upcall(upcall_type, method_details);\n+  while (upcall != nullptr) {\n+    upcall->upcall()(current);\n+    upcall = get_next_upcall(upcall_type, method_details, upcall);\n+  }\n+}\n+\n+JRT_BLOCK_ENTRY(void, RuntimeUpcalls::on_method_entry_upcall_redirect(JavaThread* current, Method* method)) {\n+    RuntimeUpcalls::upcall_redirect(onMethodEntry, current, method);\n+}\n+JRT_END\n+\n+JRT_BLOCK_ENTRY(void, RuntimeUpcalls::on_method_exit_upcall_redirect(JavaThread* current, Method* method)) {\n+    RuntimeUpcalls::upcall_redirect(onMethodExit, current, method);\n+}\n+JRT_END\n+\n+\/\/-------------------------------RuntimeUpcalls---------------------------------------\n+\n+void RuntimeUpcalls::install_upcalls(const methodHandle& method) {\n+  for (int i = 0; i < RuntimeUpcallType::numTypes; i++) {\n+      mark_for_upcalls(static_cast<RuntimeUpcallType>(i), method);\n+  }\n+}\n+\n+bool RuntimeUpcalls::register_upcall(RuntimeUpcallType upcall_type, const char* upcall_name, RuntimeUpcall upcall, RuntimeUpcallMethodFilterCallback method_filter_callback)\n+{\n+  assert(upcall_type < numTypes, \"invalid upcall type\");\n+  assert(_state == Open, \"upcalls are not open for registration\");\n+  if (_state != Open) return false;\n+  return register_upcall(upcall_type, RuntimeUpcallInfo::create(upcall_name, upcall, method_filter_callback));\n+}\n+\n+RuntimeUpcallInfo* RuntimeUpcalls::get_next_upcall(RuntimeUpcallType upcall_type, MethodDetails& method_details, RuntimeUpcallInfo* prev_upcall_info) {\n+  assert(upcall_type < numTypes, \"invalid upcall type\");\n+  if (_upcalls[upcall_type] != nullptr) {\n+    \/\/ simple case where there's only one upcall\n+    if (_upcalls[upcall_type]->length() == 1) {\n+      if (prev_upcall_info != nullptr) {\n+        return nullptr;\n+      }\n+      RuntimeUpcallInfo* upcall = _upcalls[upcall_type]->at(0);\n+      return upcall->includes(method_details) ? upcall : nullptr;\n+    }\n+\n+    \/\/ Resume from where we left off, unless we are the last entry.\n+    assert(prev_upcall_info == nullptr || (prev_upcall_info->get_index() >= 0 && prev_upcall_info->get_index() < _upcalls[upcall_type]->length()), \"invalid upcall index\");\n+    int index = (prev_upcall_info != nullptr) ? prev_upcall_info->get_index() + 1 : 0;\n+    for (int i = index; i < _upcalls[upcall_type]->length(); i++) {\n+      RuntimeUpcallInfo* upcall = _upcalls[upcall_type]->at(i);\n+      if (upcall->includes(method_details)) {\n+        return upcall;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+RuntimeUpcallInfo* RuntimeUpcalls::get_first_upcall(RuntimeUpcallType upcall_type, MethodDetails& method_details) {\n+  return get_next_upcall(upcall_type, method_details, nullptr);\n+}\n+\n+bool RuntimeUpcalls::does_upcall_need_method_parameter(address upcall_address)\n+{\n+  \/\/ Redirect needs the method parameter for filtering.\n+  if((upcall_address == CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_entry_upcall_redirect)) ||\n+     (upcall_address == CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_exit_upcall_redirect))) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+address RuntimeUpcalls::on_method_entry_upcall_address()\n+{\n+  \/\/ Optimized case when there's only one upcall (no need to redirect).\n+  if(_upcalls[onMethodEntry] != nullptr && _upcalls[onMethodEntry]->length() == 1) {\n+    return _upcalls[onMethodEntry]->at(0)->upcall_address();\n+  }\n+\n+  return CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_entry_upcall_redirect);\n+}\n+\n+address RuntimeUpcalls::on_method_exit_upcall_address()\n+{\n+  \/\/ Optimized case when there's only one upcall (no need to redirect).\n+  if(_upcalls[onMethodExit] != nullptr && _upcalls[onMethodExit]->length() == 1) {\n+    return _upcalls[onMethodExit]->at(0)->upcall_address();\n+  }\n+\n+  return CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_exit_upcall_redirect);\n+}\n+\n+const char* RuntimeUpcalls::get_name_for_upcall_address(address upcall_address)\n+{\n+  for(int i = 0; i < RuntimeUpcallType::numTypes; i++) {\n+    if (_upcalls[i] != nullptr) {\n+      for (int j = 0; j < _upcalls[i]->length(); j++) {\n+        RuntimeUpcallInfo* upcall = _upcalls[i]->at(j);\n+        if (upcall->upcall_address() == upcall_address) {\n+          return upcall->upcall_name();\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcalls.cpp","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_RUNTIME_UPCALLS_HPP\n+#define SHARE_RUNTIME_RUNTIME_UPCALLS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/methodDetails.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+enum RuntimeUpcallType{\n+  onMethodEntry = 0, \/\/ Upcalls triggered on method entry AFTER tracing\n+  onMethodExit,      \/\/ Not implemented yet\n+  numTypes\n+};\n+\n+typedef void (*RuntimeUpcall)(JavaThread* current);\n+typedef bool (*RuntimeUpcallMethodFilterCallback)(MethodDetails& method);\n+\n+class RuntimeUpcallInfo: public CHeapObj<mtInternal>{\n+  const char* _upcall_name;\n+  const RuntimeUpcall _upcall;\n+  const RuntimeUpcallMethodFilterCallback _method_filter;\n+  address _address;\n+  int _index;\n+\n+  RuntimeUpcallInfo(const char* upcall_name,\n+                    const RuntimeUpcall upcall,\n+                    const RuntimeUpcallMethodFilterCallback method_filter)\n+  : _upcall_name(upcall_name),\n+    _upcall(upcall),\n+    _method_filter(method_filter),\n+    _index(-1) {\n+    _address = CAST_FROM_FN_PTR(address, upcall);\n+  }\n+\n+private:\n+  friend class RuntimeUpcalls;\n+  void set_index(const int index) { _index = index; }\n+  int get_index() const { assert(_index >= 0, \"invalid index\"); return _index; }\n+\n+public:\n+  static RuntimeUpcallInfo* create(const char* upcall_name, const RuntimeUpcall upcall, const RuntimeUpcallMethodFilterCallback method_filter) {\n+    assert(upcall_name != nullptr, \"upcall name must be provided\");\n+    assert(upcall != nullptr, \"upcall must be provided\");\n+    assert(method_filter != nullptr, \"method filter must be provided\");\n+    return new RuntimeUpcallInfo(upcall_name, upcall, method_filter);\n+  }\n+\n+  RuntimeUpcall upcall() const { return _upcall; }\n+  const char* upcall_name() const { return _upcall_name; }\n+  address upcall_address() const { return _address; }\n+\n+  bool includes(MethodDetails& method_details) const {\n+    return _method_filter(method_details);\n+  }\n+};\n+\n+class RuntimeUpcalls: AllStatic {\n+private:\n+\n+  enum State {\n+    Uninitialized,\n+    Open,\n+    Closed\n+  };\n+\n+  static GrowableArray<RuntimeUpcallInfo*>* _upcalls[RuntimeUpcallType::numTypes];\n+  static State _state;\n+\n+  static void mark_for_upcalls(RuntimeUpcallType upcall_type, const methodHandle& method);\n+  static bool register_upcall(RuntimeUpcallType upcall_type, RuntimeUpcallInfo* info);\n+  static void upcall_redirect(RuntimeUpcallType upcall_type, JavaThread* current, Method* method);\n+\n+  static int  get_num_upcalls(RuntimeUpcallType upcall_type);\n+\n+  static void on_method_entry_upcall_redirect(JavaThread* current, Method* method);\n+  static void on_method_exit_upcall_redirect(JavaThread* current, Method* method);\n+\n+public:\n+\n+  static bool               open_upcall_registration();\n+  static bool               register_upcall(RuntimeUpcallType upcall_type, const char* upcall_name, RuntimeUpcall upcall, RuntimeUpcallMethodFilterCallback method_filter_callback = nullptr);\n+  static void               close_upcall_registration();\n+\n+  static void               install_upcalls(const methodHandle& method);\n+\n+  static RuntimeUpcallInfo* get_first_upcall(RuntimeUpcallType upcall_type, MethodDetails& method_details);\n+  static RuntimeUpcallInfo* get_next_upcall(RuntimeUpcallType upcall_type, MethodDetails& method_details, RuntimeUpcallInfo* prev_upcall_info = nullptr);\n+\n+  static address            on_method_entry_upcall_address();\n+  static address            on_method_exit_upcall_address();\n+\n+  static bool               does_upcall_need_method_parameter(address upcall_address);\n+\n+  static const char*        get_name_for_upcall_address(address upcall_address);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_RUNTIME_UPCALLS_HPP\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcalls.hpp","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsEndTrainingUpcall.hpp\"\n@@ -137,0 +138,3 @@\n+#if INCLUDE_CDS\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<AOTEndTrainingDCmd>(full_export, true, false));\n+#endif \/\/ INCLUDE_CDS\n@@ -995,0 +999,12 @@\n+#if INCLUDE_CDS\n+void AOTEndTrainingDCmd::execute(DCmdSource source, TRAPS) {\n+  if (!CDSConfig::is_dumping_preimage_static_archive()) {\n+    output()->print_cr(\"Error! Not a training run\");\n+  } else if (CDSEndTrainingUpcall::end_training(THREAD)) {\n+    output()->print_cr(\"Training ended successfully\");\n+  } else {\n+    output()->print_cr(\"Error! Failed to end training\");\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -398,0 +398,20 @@\n+#if INCLUDE_CDS\n+class AOTEndTrainingDCmd : public DCmd {\n+public:\n+  AOTEndTrainingDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"AOT.end_training\"; }\n+    static const char* description() {\n+      return \"End AOT training and create the cache.\";\n+    }\n+    static const char* impact() {\n+      return \"Medium: Pause time depends on number of loaded classes\";\n+    }\n+    static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+      return p;\n+    }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1928,0 +1928,12 @@\n+    \/**\n+     * Returns whether the AOT system is recording training data.\n+     *\n+     * @return  whether the AOT system is recording training data.\n+     *\/\n+    public static native boolean AOTIsTraining();\n+\n+    \/**\n+     * Will stop the recording of AOT training data.\n+     *\/\n+    public static native void AOTEndTraining();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -300,0 +300,13 @@\n+JNIEXPORT jboolean JNICALL\n+Java_java_lang_System_AOTIsTraining(JNIEnv *env, jclass ign)\n+{\n+    jboolean isTraining = JVM_AOTIsTraining(env);\n+    return isTraining;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_System_AOTEndTraining(JNIEnv *env, jclass ign)\n+{\n+    JVM_AOTEndTraining(env);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/System.c","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}