{"files":[{"patch":"@@ -28,1 +28,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -48,0 +47,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1402,2 +1402,9 @@\n-void InterpreterMacroAssembler::end_training_check() {\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::end_training_check));\n+void InterpreterMacroAssembler::generate_runtime_upcalls_on_method_entry()\n+{\n+  address upcall = RuntimeUpcalls::on_method_entry_upcall_address();\n+  if (RuntimeUpcalls::does_upcall_need_method_parameter(upcall)) {\n+    get_method(c_rarg1);\n+    call_VM(noreg,upcall, c_rarg1);\n+  } else {\n+    call_VM(noreg,upcall);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -306,2 +306,2 @@\n-  \/\/ support for AOT\n-  void end_training_check();\n+  \/\/ support for runtime upcalls\n+  void generate_runtime_upcalls_on_method_entry();\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1153,1 +1153,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1272,3 +1272,2 @@\n-  \/\/ AOT training run support\n-  if (end_training_trigger) {\n-    __ end_training_check();\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n@@ -1581,1 +1580,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1726,3 +1725,3 @@\n-  \/\/ AOT training run support\n-  if (end_training_trigger) {\n-    __ end_training_check();\n+  \/\/ runtime upcalls\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1141,1 +1141,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1180,1 +1180,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1605,1 +1605,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -960,1 +960,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1357,1 +1357,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1304,1 +1304,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1660,1 +1660,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1933,2 +1933,9 @@\n-void InterpreterMacroAssembler::end_training_check() {\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::end_training_check));\n+void InterpreterMacroAssembler::generate_runtime_upcalls_on_method_entry()\n+{\n+  address upcall = RuntimeUpcalls::on_method_entry_upcall_address();\n+  if (RuntimeUpcalls::does_upcall_need_method_parameter(upcall)) {\n+    get_method(c_rarg1);\n+    call_VM(noreg,upcall, c_rarg1);\n+  } else {\n+    call_VM(noreg,upcall);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -276,2 +276,2 @@\n-  \/\/ support for AOT\n-  void end_training_check();\n+  \/\/ support for runtime upcalls\n+  void generate_runtime_upcalls_on_method_entry();\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -793,1 +793,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -919,3 +919,3 @@\n-  \/\/ AOT training run support\n-  if (end_training_trigger) {\n-    __ end_training_check();\n+  \/\/ runtime upcalls\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n@@ -1337,1 +1337,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n@@ -1479,3 +1479,2 @@\n-  \/\/ AOT training run support\n-  if (end_training_trigger) {\n-    __ end_training_check();\n+  if (runtime_upcalls) {\n+    __ generate_runtime_upcalls_on_method_entry();\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -46,0 +45,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -4083,1 +4083,3 @@\n-  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers() && callee->is_end_training_trigger()) {\n+  MethodDetails methodDetails(callee);\n+  RuntimeUpcallInfo* upcall = RuntimeUpcalls::get_first_upcall(RuntimeUpcallType::onMethodEntry, methodDetails);\n+  while (upcall != nullptr) {\n@@ -4085,1 +4087,2 @@\n-    append(new RuntimeCall(voidType, \"end_training_check_c1\", CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c1), args));\n+    append(new RuntimeCall(voidType, upcall->upcall_name(), upcall->upcall_address(), args));\n+    upcall = RuntimeUpcalls::get_next_upcall(RuntimeUpcallType::onMethodEntry, methodDetails, upcall);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -2680,1 +2680,3 @@\n-  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers() && method()->is_end_training_trigger()) {\n+  MethodDetails methodDetails(method());\n+  RuntimeUpcallInfo* upcall = RuntimeUpcalls::get_first_upcall(RuntimeUpcallType::onMethodEntry, methodDetails);\n+  while (upcall != nullptr) {\n@@ -2685,1 +2687,2 @@\n-    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c1), voidType, nullptr);\n+    call_runtime(&signature, args, upcall->upcall_address(), voidType, nullptr);\n+    upcall = RuntimeUpcalls::get_next_upcall(RuntimeUpcallType::onMethodEntry, methodDetails, upcall);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -337,1 +338,0 @@\n-  FUNCTION_CASE(entry, SharedRuntime::end_training_check_c1);\n@@ -359,0 +359,6 @@\n+  \/\/ Runtime upcalls also has a map of addresses to names\n+  const char* upcall_name = RuntimeUpcalls::get_name_for_upcall_address(entry);\n+  if (upcall_name != nullptr) {\n+    return upcall_name;\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-  return _is_dumping_static_archive && CacheDataStore != nullptr && CDSPreimage == nullptr && !FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry);\n+  return (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry)) && is_dumping_preimage_static_archive();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/cdsEndTrainingUpcall.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"compiler\/methodMatcher.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/runtimeUpcalls.hpp\"\n+\n+uint volatile  CDSEndTrainingUpcall::_count = 0;\n+uint           CDSEndTrainingUpcall::_limit = 1;\n+int  volatile  CDSEndTrainingUpcall::_triggered = 0;\n+BasicMatcher*  CDSEndTrainingUpcall::_matcher = nullptr;\n+\n+bool cdsEndTrainingUpcall_register_upcalls()\n+{\n+  if (!CDSConfig::is_dumping_preimage_static_archive_with_triggers()) {\n+    return true;\n+  }\n+  return CDSEndTrainingUpcall::register_upcalls();\n+}\n+\n+bool CDSEndTrainingUpcall::register_upcalls() {\n+  if (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry)) {\n+    if (CDSEndTrainingUpcall::parse_vm_command(AOTEndTrainingOnMethodEntry)) {\n+      return RuntimeUpcalls::register_upcall(\n+            RuntimeUpcallType::onMethodEntry,\n+            \"end_training_check\",\n+            CDSEndTrainingUpcall::end_training_check,\n+            CDSEndTrainingUpcall::filter_method_callback\n+            );\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+JRT_ENTRY(void, CDSEndTrainingUpcall::end_training_check(JavaThread* current))\n+{\n+    if (_triggered == 0) {\n+      Atomic::inc(&_count);\n+      if(_count >= _limit) {\n+        CDSEndTrainingUpcall::end_training(current);\n+      }\n+    }\n+}\n+JRT_END\n+\n+bool CDSEndTrainingUpcall::end_training(JavaThread* current)\n+{\n+  if (_triggered == 0) {\n+    if (Atomic::cmpxchg(&_triggered, 0, 1) == 0) {\n+      MetaspaceShared::preload_and_dump(current);\n+      assert(!current->has_pending_exception(), \"Unexpected exception\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool CDSEndTrainingUpcall::filter_method_callback(MethodDetails& methodDetails)\n+{\n+  if (_matcher != nullptr) {\n+    return _matcher->match(methodDetails);\n+  }\n+  return false;\n+}\n+\n+bool CDSEndTrainingUpcall::parse_vm_command(ccstrlist command)\n+{\n+  assert(command != nullptr, \"sanity\");\n+  ResourceMark rm;\n+  const char* error_msg = nullptr;\n+  char* copy = os::strdup(command, mtInternal);\n+  char* line = copy;\n+  char* method_pattern;\n+  int num_patterns = 0;\n+  bool error = false;\n+  const char* seperatorStr = \",\";\n+  const char* countStr = \"count=\";\n+  const size_t countStrLen = strlen(countStr);\n+  do {\n+    if (line[0] == '\\0') {\n+      break;\n+    }\n+    method_pattern = strtok_r(line, seperatorStr, &line);\n+    if (method_pattern != nullptr) {\n+      \/\/ if method pattern starts with count=, then parse the count\n+      if (strncmp(method_pattern, countStr, countStrLen) == 0) {\n+        int number = atoi(method_pattern + countStrLen);\n+        if (number > 0) {\n+          CDSEndTrainingUpcall::set_limit((uint)number);\n+          continue;\n+        }\n+        error_msg = \"count must be a valid integer > 0\";\n+      } else {\n+        BasicMatcher* matcher = BasicMatcher::parse_method_pattern(method_pattern, error_msg, false);\n+        if (matcher != nullptr) {\n+          if (_matcher != nullptr) {\n+            matcher->set_next(_matcher);\n+          }\n+          _matcher = matcher;\n+          num_patterns++;\n+          continue;\n+        }\n+      }\n+    }\n+    ttyLocker ttyl;\n+    tty->print_cr(\"An error occurred during parsing AOTEndTrainingOnMethodEntry\");\n+    if (error_msg != nullptr) {\n+      tty->print_cr(\"Error: %s\", error_msg);\n+    }\n+    tty->print_cr(\"Line: '%s'\", command);\n+    error = true;\n+  } while (!error && method_pattern != nullptr && line != nullptr);\n+  os::free(copy);\n+  if (num_patterns == 0) {\n+    tty->print_cr(\"Error: No method patterns found in AOTEndTrainingOnMethodEntry\");\n+    error = true;\n+  }\n+  return !error;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/cds\/cdsEndTrainingUpcall.cpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_CDSENDTRAININGUPCALL_HPP\n+#define SHARE_CDS_CDSENDTRAININGUPCALL_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/#include \"code\/codeBlob.hpp\"\n+\/\/#include \"code\/vmreg.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class BasicMatcher;\n+class MethodDetails;\n+class Symbol;\n+\n+class CDSEndTrainingUpcall : AllStatic {\n+private:\n+  static uint volatile  _count;\n+  static uint           _limit;\n+  static int  volatile  _triggered;\n+  static BasicMatcher*  _matcher;\n+\n+  static bool parse_vm_command(ccstrlist command);\n+  static void set_limit(uint limit) { _limit = limit; }\n+\n+public:\n+  static bool register_upcalls();\n+  static bool filter_method_callback(MethodDetails& methodDetails);\n+  static void end_training_check(TRAPS);\n+  static bool end_training(TRAPS);\n+  static void set_method_entry_limit(uint limit) { _limit = limit; }\n+};\n+\n+#endif \/\/ SHARE_CDS_CDSENDTRAININGUPCALL_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsEndTrainingUpcall.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -200,8 +200,9 @@\n-  bool caller_sensitive()        const { return get_Method()->caller_sensitive();       }\n-  bool force_inline()            const { return get_Method()->force_inline();           }\n-  bool dont_inline()             const { return get_Method()->dont_inline();            }\n-  bool intrinsic_candidate()     const { return get_Method()->intrinsic_candidate();    }\n-  bool is_static_initializer()   const { return get_Method()->is_static_initializer();  }\n-  bool changes_current_thread()  const { return get_Method()->changes_current_thread(); }\n-  bool deprecated()              const { return is_loaded() && get_Method()->deprecated(); }\n-  bool is_end_training_trigger() const { return get_Method()->is_end_training_trigger(); }\n+  bool caller_sensitive()           const { return get_Method()->caller_sensitive();           }\n+  bool force_inline()               const { return get_Method()->force_inline();               }\n+  bool dont_inline()                const { return get_Method()->dont_inline();                }\n+  bool intrinsic_candidate()        const { return get_Method()->intrinsic_candidate();        }\n+  bool is_static_initializer()      const { return get_Method()->is_static_initializer();      }\n+  bool changes_current_thread()     const { return get_Method()->changes_current_thread();     }\n+  bool deprecated()                 const { return is_loaded() && get_Method()->deprecated();  }\n+  bool has_upcall_on_method_entry() const { return get_Method()->has_upcall_on_method_entry(); }\n+  bool has_upcall_on_method_exit()  const { return get_Method()->has_upcall_on_method_exit();  }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -502,4 +501,0 @@\n-bool CompilerOracle::should_trigger_end_of_training_at(const methodHandle& method) {\n-  return check_predicate(CompileCommandEnum::EndTrainingOnEnter, method);\n-}\n-\n@@ -1135,5 +1130,0 @@\n-  if (CDSPreimage == nullptr) {\n-    if (!CompilerOracle::parse_from_string(AOTEndTrainingOnMethodEntry, CompilerOracle::parse_aot_trigger)) {\n-      success = false;\n-    }\n-  }\n@@ -1160,1 +1150,1 @@\n-bool CompilerOracle::parse_for_command(char* line, CompileCommandEnum command, const char* error_prefix, uint* count) {\n+bool CompilerOracle::parse_compile_only(char* line) {\n@@ -1174,14 +1164,4 @@\n-      \/\/ if method pattern starts with count=, then parse the count\n-      if (count != nullptr && strncmp(method_pattern, \"count=\", 6) == 0) {\n-        int number = atoi(method_pattern + 6);\n-        if (number > 0) {\n-          *count = (uint)number;\n-          continue;\n-        }\n-        strcpy(error_buf, \"count must be a valid integer > 0\");\n-      } else {\n-        TypedMethodOptionMatcher* matcher = TypedMethodOptionMatcher::parse_method_pattern(method_pattern, error_buf, sizeof(error_buf));\n-        if (matcher != nullptr) {\n-          register_command(matcher, command, true);\n-          continue;\n-        }\n+      TypedMethodOptionMatcher* matcher = TypedMethodOptionMatcher::parse_method_pattern(method_pattern, error_buf, sizeof(error_buf));\n+      if (matcher != nullptr) {\n+        register_command(matcher, CompileCommandEnum::CompileOnly, true);\n+        continue;\n@@ -1191,1 +1171,1 @@\n-    tty->print_cr(\"%s: An error occurred during parsing\", error_prefix);\n+    tty->print_cr(\"CompileOnly: An error occurred during parsing\");\n@@ -1201,13 +1181,0 @@\n-bool CompilerOracle::parse_compile_only(char* line) {\n-  return parse_for_command(line, CompileCommandEnum::CompileOnly, \"CompileOnly\");\n-}\n-\n-bool CompilerOracle::parse_aot_trigger(char* line) {\n-  uint count = 0;\n-  bool result = parse_for_command(line, CompileCommandEnum::EndTrainingOnEnter, \"AOTEndTrainingOnMethodEntry\", &count);\n-  if (result && count > 0) {\n-    SharedRuntime::set_end_training_predicate(count);\n-  }\n-  return result;\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":6,"deletions":39,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  option(EndTrainingOnEnter, \"EndTrainingOnEnter\", Bool) \\\n@@ -137,3 +136,0 @@\n-  \/\/ Shared for parsing CompileOnly and AOTTrigger\n-  static bool parse_for_command(char* line, CompileCommandEnum command, const char* error_prefix, uint* count = nullptr);\n-\n@@ -173,3 +169,0 @@\n-  \/\/ Tells whether to 'trigger end of training' when executing method\n-  static bool should_trigger_end_of_training_at(const methodHandle& method);\n-\n@@ -204,1 +197,0 @@\n-  static bool parse_aot_trigger(char* line);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -305,3 +305,0 @@\n-  product(ccstrlist, AOTEndTrainingOnMethodEntry, \"\",                       \\\n-          \"List of methods (pkg\/class.name) to trigger end of AOT \"         \\\n-          \"training run.  Optional ',count=N' where N is > 0\")              \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -363,0 +363,9 @@\n+bool MethodMatcher::matches(MethodDetails& methodDetails) const {\n+  if (match(methodDetails.class_name(), this->class_name(), _class_mode) &&\n+      match(methodDetails.method_name(), this->method_name(), _method_mode) &&\n+      ((this->signature() == nullptr) || match(methodDetails.signature(), this->signature(), Prefix))) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -407,0 +416,9 @@\n+bool BasicMatcher::match(MethodDetails& methodDetails) {\n+  for (BasicMatcher* current = this; current != nullptr; current = current->next()) {\n+    if (current->matches(methodDetails)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/methodDetails.hpp\"\n@@ -64,0 +65,1 @@\n+  bool matches(MethodDetails& methodDetails) const;\n@@ -86,0 +88,1 @@\n+  bool match(MethodDetails& methodDetails);\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-      return m->is_end_training_trigger() ? native_synchronized_end_training_trigger : native_synchronized;\n+      return m->has_upcall_on_method_entry() ? native_synchronized_upcalls : native_synchronized;\n@@ -177,1 +177,1 @@\n-    return m->is_end_training_trigger() ? native_end_training_trigger : native;\n+    return m->has_upcall_on_method_entry() ? native_upcalls : native;\n@@ -182,1 +182,1 @@\n-    return m->is_end_training_trigger() ? zerolocals_synchronized_end_training_trigger : zerolocals_synchronized;\n+    return m->has_upcall_on_method_entry() ? zerolocals_synchronized_upcalls : zerolocals_synchronized;\n@@ -187,1 +187,1 @@\n-    return m->is_end_training_trigger() ? empty_end_training_trigger : empty;\n+    return m->has_upcall_on_method_entry() ? empty_upcalls : empty;\n@@ -201,1 +201,1 @@\n-  return m->is_end_training_trigger() ? zerolocals_end_training_trigger : zerolocals;\n+  return m->has_upcall_on_method_entry() ? zerolocals_upcalls : zerolocals;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-    zerolocals_end_training_trigger,                            \/\/ method needs locals initialization & is end training trigger\n-    zerolocals_synchronized_end_training_trigger,               \/\/ method needs locals initialization & is synchronized & is end training trigger\n+    zerolocals_upcalls,                                         \/\/ method needs locals initialization & has runtime upcalls\n+    zerolocals_synchronized_upcalls,                            \/\/ method needs locals initialization & is synchronized & has runtime upcalls\n@@ -66,2 +66,2 @@\n-    native_end_training_trigger,                                \/\/ native method & is end training trigger\n-    native_synchronized_end_training_trigger,                   \/\/ native method & is synchronized & is end training trigger\n+    native_upcalls,                                             \/\/ native method & has runtime upcalls\n+    native_synchronized_upcalls,                                \/\/ native method & is synchronized & has runtime upcalls\n@@ -69,1 +69,1 @@\n-    empty_end_training_trigger,                                 \/\/ empty method & is end training trigger (code: _return)\n+    empty_upcalls,                                              \/\/ empty method & has runtime upcalls (code: _return)\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1159,6 +1159,0 @@\n-JRT_ENTRY(void, InterpreterRuntime::end_training_check(JavaThread* current)) {\n-\n-    SharedRuntime::end_training_check(CHECK);\n-}\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,2 +95,0 @@\n-  static void end_training_check(JavaThread* current);\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -189,0 +188,2 @@\n+  method_entry(zerolocals_upcalls)\n+  method_entry(zerolocals_synchronized_upcalls)\n@@ -190,5 +191,1 @@\n-  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers()) {\n-    method_entry(zerolocals_end_training_trigger)\n-    method_entry(zerolocals_synchronized_end_training_trigger)\n-    method_entry(empty_end_training_trigger)\n-  }\n+  method_entry(empty_upcalls)\n@@ -230,4 +227,2 @@\n-  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers()) {\n-    native_method_entry(native_end_training_trigger)\n-    native_method_entry(native_synchronized_end_training_trigger)\n-  }\n+  native_method_entry(native_upcalls)\n+  native_method_entry(native_synchronized_upcalls)\n@@ -422,4 +417,4 @@\n-    case Interpreter::zerolocals_synchronized                     : \/\/ fall thru\n-    case Interpreter::zerolocals_synchronized_end_training_trigger: \/\/ fall thru\n-    case Interpreter::native_synchronized                         : \/\/ fall thru\n-    case Interpreter::native_synchronized_end_training_trigger    :\n+    case Interpreter::zerolocals_synchronized        : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_upcalls: \/\/ fall thru\n+    case Interpreter::native_synchronized            : \/\/ fall thru\n+    case Interpreter::native_synchronized_upcalls    :\n@@ -432,1 +427,1 @@\n-bool TemplateInterpreterGenerator::is_end_training_trigger_method(AbstractInterpreter::MethodKind kind) {\n+bool TemplateInterpreterGenerator::is_runtime_upcalls_method(AbstractInterpreter::MethodKind kind) {\n@@ -434,5 +429,5 @@\n-    case Interpreter::zerolocals_end_training_trigger             : \/\/ fall thru\n-    case Interpreter::zerolocals_synchronized_end_training_trigger: \/\/ fall thru\n-    case Interpreter::native_end_training_trigger                 : \/\/ fall thru\n-    case Interpreter::native_synchronized_end_training_trigger    : \/\/ fall thru\n-    case Interpreter::empty_end_training_trigger                  :\n+    case Interpreter::zerolocals_upcalls             : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_upcalls: \/\/ fall thru\n+    case Interpreter::native_upcalls                 : \/\/ fall thru\n+    case Interpreter::native_synchronized_upcalls    : \/\/ fall thru\n+    case Interpreter::empty_upcalls                  :\n@@ -447,13 +442,13 @@\n-    case Interpreter::zerolocals                                  : \/\/ fall thru\n-    case Interpreter::zerolocals_synchronized                     : \/\/ fall thru\n-    case Interpreter::zerolocals_end_training_trigger             : \/\/ fall thru\n-    case Interpreter::zerolocals_synchronized_end_training_trigger: \/\/ fall thru\n-    case Interpreter::native                                      : \/\/ fall thru\n-    case Interpreter::native_synchronized                         : \/\/ fall thru\n-    case Interpreter::native_end_training_trigger                 : \/\/ fall thru\n-    case Interpreter::native_synchronized_end_training_trigger    : \/\/ fall thru\n-    case Interpreter::empty                                       : \/\/ fall thru\n-    case Interpreter::empty_end_training_trigger                  : \/\/ fall thru\n-    case Interpreter::getter                                      : \/\/ fall thru\n-    case Interpreter::setter                                      : \/\/ fall thru\n-    case Interpreter::abstract                                    :\n+    case Interpreter::zerolocals                     : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized        : \/\/ fall thru\n+    case Interpreter::zerolocals_upcalls             : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_upcalls: \/\/ fall thru\n+    case Interpreter::native                         : \/\/ fall thru\n+    case Interpreter::native_synchronized            : \/\/ fall thru\n+    case Interpreter::native_upcalls                 : \/\/ fall thru\n+    case Interpreter::native_synchronized_upcalls    : \/\/ fall thru\n+    case Interpreter::empty                          : \/\/ fall thru\n+    case Interpreter::empty_upcalls                  : \/\/ fall thru\n+    case Interpreter::getter                         : \/\/ fall thru\n+    case Interpreter::setter                         : \/\/ fall thru\n+    case Interpreter::abstract                       :\n@@ -491,1 +486,1 @@\n-  bool end_training_trigger = is_end_training_trigger_method(kind);\n+  bool upcalls = is_runtime_upcalls_method(kind);\n@@ -494,1 +489,1 @@\n-  if (!synchronized && !end_training_trigger) {\n+  if (!synchronized && !upcalls) {\n@@ -497,1 +492,1 @@\n-  } else if (synchronized && !end_training_trigger) {\n+  } else if (synchronized && !upcalls) {\n@@ -500,6 +495,6 @@\n-  } else if (!synchronized && end_training_trigger) {\n-    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_end_training_trigger\n-                                                     : Interpreter::zerolocals_end_training_trigger);\n-  } else if (synchronized && end_training_trigger) {\n-    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_synchronized_end_training_trigger\n-                                                     : Interpreter::zerolocals_synchronized_end_training_trigger);\n+  } else if (!synchronized && upcalls) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_upcalls\n+                                                     : Interpreter::zerolocals_upcalls);\n+  } else if (synchronized && upcalls) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_synchronized_upcalls\n+                                                     : Interpreter::zerolocals_synchronized_upcalls);\n@@ -509,2 +504,2 @@\n-      entry_point = native ? generate_native_entry(synchronized, end_training_trigger)\n-                           : generate_normal_entry(synchronized, end_training_trigger);\n+      entry_point = native ? generate_native_entry(synchronized, upcalls)\n+                           : generate_normal_entry(synchronized, upcalls);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":39,"deletions":44,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  bool is_end_training_trigger_method(AbstractInterpreter::MethodKind kind);\n+  bool is_runtime_upcalls_method(AbstractInterpreter::MethodKind kind);\n@@ -98,2 +98,2 @@\n-  address generate_normal_entry(bool synchronized, bool end_training_trigger);\n-  address generate_native_entry(bool synchronized, bool end_training_trigger);\n+  address generate_normal_entry(bool synchronized, bool runtime_upcalls);\n+  address generate_native_entry(bool synchronized, bool runtime_upcalls);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-address ZeroInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n+address ZeroInterpreterGenerator::generate_native_entry(bool synchronized, bool runtime_upcalls) {\n@@ -183,1 +183,1 @@\n-address ZeroInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n+address ZeroInterpreterGenerator::generate_normal_entry(bool synchronized, bool runtime_upcalls) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  address generate_normal_entry(bool synchronized, bool end_training_trigger);\n-  address generate_native_entry(bool synchronized, bool end_training_trigger);\n+  address generate_normal_entry(bool synchronized, bool runtime_upcalls);\n+  address generate_native_entry(bool synchronized, bool runtime_upcalls);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"compiler\/compilerOracle.hpp\"\n@@ -93,0 +92,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1084,1 +1084,1 @@\n-  bool addingAOTTriggers = CDSConfig::is_dumping_preimage_static_archive_with_triggers();\n+\n@@ -1088,4 +1088,1 @@\n-\n-    if (addingAOTTriggers && CompilerOracle::should_trigger_end_of_training_at(m)) {\n-      m->set_is_end_training_trigger(true);\n-    }\n+    RuntimeUpcalls::install_upcalls(m);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1249,1 +1249,2 @@\n-  set_is_end_training_trigger(false);\n+  set_has_upcall_on_method_entry(false);\n+  set_has_upcall_on_method_exit(false);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-   status(is_end_training_trigger     , 1 << 17) \\\n+   status(has_upcall_on_method_entry  , 1 << 17) \\\n+   status(has_upcall_on_method_exit   , 1 << 18) \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -675,2 +675,2 @@\n-  \/\/---------------- AOT support --------------------\n-  void make_end_training_check();\n+  \/\/----------- runtime upcalls support ----------------\n+  void install_on_method_entry_runtime_upcalls(ciMethod* method);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -43,0 +42,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -1215,3 +1215,1 @@\n-  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers() && method()->is_end_training_trigger()) {\n-    make_end_training_check();\n-  }\n+  install_on_method_entry_runtime_upcalls(method());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/runtimeUpcalls.hpp\"\n@@ -37,4 +38,7 @@\n-void GraphKit::make_end_training_check() {\n-  const TypeFunc *call_type    = OptoRuntime::end_training_check_c2_Type();\n-  address         call_address = CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c2);\n-  const char     *call_name    = \"end_training_check_c2\";\n+void GraphKit::install_on_method_entry_runtime_upcalls(ciMethod* method) {\n+  MethodDetails methodDetails(method);\n+  RuntimeUpcallInfo* upcall = RuntimeUpcalls::get_first_upcall(RuntimeUpcallType::onMethodEntry, methodDetails);\n+  while (upcall != nullptr) {\n+    \/\/ Get base of thread-local storage area\n+    Node* thread = _gvn.transform( new ThreadLocalNode() );\n+    kill_dead_locals();\n@@ -42,2 +46,7 @@\n-  \/\/ Get base of thread-local storage area\n-  Node* thread = _gvn.transform( new ThreadLocalNode() );\n+    \/\/ For some reason, this call reads only raw memory.\n+    const TypeFunc *call_type   = OptoRuntime::runtime_up_call_Type();\n+    const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n+    make_runtime_call(RC_LEAF | RC_NARROW_MEM,\n+                      call_type, upcall->upcall_address(),\n+                      upcall->upcall_name(), raw_adr_type,\n+                      thread);\n@@ -45,8 +54,2 @@\n-  kill_dead_locals();\n-\n-  \/\/ For some reason, this call reads only raw memory.\n-  const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n-  make_runtime_call(RC_LEAF | RC_NARROW_MEM,\n-                    call_type, call_address,\n-                    call_name, raw_adr_type,\n-                    thread);\n+    upcall = RuntimeUpcalls::get_next_upcall(RuntimeUpcallType::onMethodEntry, methodDetails, upcall);\n+  }\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1864,2 +1864,2 @@\n-\/\/ AOT\n-const TypeFunc *OptoRuntime::end_training_check_c2_Type() {\n+\/\/ runtime upcall support\n+const TypeFunc *OptoRuntime::runtime_up_call_Type() {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -339,2 +339,2 @@\n-  \/\/ AOT\n-  static const TypeFunc* end_training_check_c2_Type();\n+  \/\/ runtime upcalls support\n+  static const TypeFunc* runtime_up_call_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,4 @@\n+  product(ccstrlist, AOTEndTrainingOnMethodEntry, \"\",                       \\\n+          \"List of methods (pkg\/class.name) to trigger end of AOT \"         \\\n+          \"training run.  Optional ',count=N' where N is > 0\")              \\\n+                                                                            \\\n@@ -381,0 +385,6 @@\n+  develop(ccstr, AddRuntimeUpcallsNOP, nullptr,                             \\\n+          \"Register a runtime upcall for testing.\"                          \\\n+          \"Format is '[upcallType]:[methodFilter]'\"                         \\\n+          \"where upcallType is one of 'onMethodEntry', 'onMethodExit'\"      \\\n+          \"and methodFilter is one of 'none', 'all'\")                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -96,0 +96,6 @@\n+\/\/ initialize upcalls before class loading\n+bool runtimeUpcalls_open_registration();\n+bool runtimeUpcallNop_register_upcalls();\n+bool cdsEndTrainingUpcall_register_upcalls();\n+bool runtimeUpcalls_close_registration();\n+\n@@ -174,0 +180,11 @@\n+\n+  \/\/ initialize upcalls before class loading \/ initialization\n+  runtimeUpcalls_open_registration();\n+  if (!runtimeUpcallNop_register_upcalls()) {\n+    return JNI_EINVAL;\n+  }\n+  if (!cdsEndTrainingUpcall_register_upcalls()) {\n+    return JNI_EINVAL;\n+  }\n+  runtimeUpcalls_close_registration();\n+\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"compiler\/abstractCompiler.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/methodDetails.hpp\"\n+\n+Symbol* MethodDetails::class_name() {\n+  if (_class_name == nullptr) {\n+    if (_methodHandle != nullptr) {\n+      _class_name = (*_methodHandle)->method_holder()->name();\n+    } else if (_ciMethod != nullptr) {\n+      _class_name = _ciMethod->holder()->name()->get_symbol();\n+    } else if (_method != nullptr) {\n+      _class_name = _method->method_holder()->name();\n+    }\n+  }\n+  return _class_name;\n+}\n+\n+Symbol* MethodDetails::method_name() {\n+  if (_method_name == nullptr) {\n+    if (_methodHandle != nullptr) {\n+      _method_name = (*_methodHandle)->name();\n+    } else if (_ciMethod != nullptr) {\n+      _method_name = _ciMethod->name()->get_symbol();\n+    } else if (_method != nullptr) {\n+      _method_name = _method->name();\n+    }\n+  }\n+  return _method_name;\n+}\n+\n+Symbol* MethodDetails::signature() {\n+  if (_signature == nullptr) {\n+    if (_methodHandle != nullptr) {\n+      _signature = (*_methodHandle)->signature();\n+    } else if (_ciMethod != nullptr) {\n+      _signature = _ciMethod->signature()->as_symbol()->get_symbol();\n+    } else if (_method != nullptr) {\n+      _signature = _method->signature();\n+    }\n+  }\n+  return _signature;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/methodDetails.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_METHOD_DETAILS_HPP\n+#define SHARE_RUNTIME_METHOD_DETAILS_HPP\n+\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/vmreg.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class ciMethod;\n+\n+class MethodDetails: public CHeapObj<mtInternal> {\n+private:\n+  const methodHandle* _methodHandle;\n+  const ciMethod* _ciMethod;\n+  const Method* _method;\n+\n+  Symbol* _class_name;\n+  Symbol* _method_name;\n+  Symbol* _signature;\n+\n+  MethodDetails(const methodHandle* methodHandle, const ciMethod* ciMethod, const Method* method) :\n+    _methodHandle(methodHandle), _ciMethod(ciMethod), _method(method),\n+    _class_name(nullptr), _method_name(nullptr), _signature(nullptr)\n+    {};\n+\n+public:\n+  MethodDetails(const methodHandle& method) :\n+    MethodDetails(&method, nullptr, nullptr) {}\n+\n+  MethodDetails(const methodHandle* method) :\n+    MethodDetails(method, nullptr, nullptr) {}\n+\n+  MethodDetails(const ciMethod* method) :\n+    MethodDetails(nullptr, method, nullptr) {}\n+\n+  MethodDetails(const Method* method) :\n+    MethodDetails(nullptr, nullptr, method) {}\n+\n+  Symbol* class_name();\n+  Symbol* method_name();\n+  Symbol* signature();\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_METHOD_DETAILS_HPP\n","filename":"src\/hotspot\/share\/runtime\/methodDetails.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/runtimeUpcallNop.hpp\"\n+#include \"runtime\/runtimeUpcalls.hpp\"\n+\n+bool RuntimeUpcallNop::methodFilterResult = false;\n+\n+bool runtimeUpcallNop_register_upcalls()\n+{\n+  if(FLAG_IS_DEFAULT(AddRuntimeUpcallsNOP)) return true;\n+\n+  const char* methodEntry = \"onMethodEntry:\";\n+  const size_t methodEntryLen = strlen(methodEntry);\n+  const char* methodExit = \"onMethodExit:\";\n+  const size_t methodExitLen = strlen(methodExit);\n+\n+  const char* filterAll = \"all\";\n+  const size_t filterAllLen = strlen(filterAll);\n+  const char* filterNone = \"none\";\n+  const size_t filterNoneLen = strlen(filterNone);\n+\n+  const char* filterOption = nullptr;\n+  RuntimeUpcallType upcallType = RuntimeUpcallType::onMethodEntry;\n+\n+  if (strncmp(AddRuntimeUpcallsNOP, methodEntry, methodEntryLen) == 0) {\n+    filterOption = AddRuntimeUpcallsNOP + methodEntryLen;\n+    upcallType = RuntimeUpcallType::onMethodEntry;\n+  } else if (strncmp(AddRuntimeUpcallsNOP, methodExit, methodExitLen) == 0) {\n+    filterOption = AddRuntimeUpcallsNOP + methodExitLen;\n+    upcallType = RuntimeUpcallType::onMethodExit;\n+  } else {\n+    ttyLocker ttyl;\n+    tty->print_cr(\"An error occurred during parsing AddRuntimeUpcallsNOP\");\n+    tty->print_cr(\"Error! Expected 'onMethodEntry:' or 'onMethodExit:'\");\n+    return false;\n+  }\n+\n+  assert(filterOption != nullptr, \"sanity\");\n+  if (strncmp(filterOption, filterAll, filterAllLen) == 0) {\n+    RuntimeUpcallNop::methodFilterResult = true;\n+  } else if (strncmp(filterOption, filterNone, filterNoneLen) == 0) {\n+    RuntimeUpcallNop::methodFilterResult = false;\n+  } else {\n+    ttyLocker ttyl;\n+    tty->print_cr(\"An error occurred during parsing AddRuntimeUpcallsNOP\");\n+    tty->print_cr(\"Error! Expected 'all' or 'none'\");\n+    return false;\n+  }\n+\n+  if (RuntimeUpcalls::register_upcall(\n+        upcallType,\n+        \"nop_method\",\n+        RuntimeUpcallNop::nop_method,\n+        RuntimeUpcallNop::filter_method_callback)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool RuntimeUpcallNop::filter_method_callback(MethodDetails& methodDetails)\n+{\n+  return methodFilterResult;\n+}\n+\n+JRT_ENTRY(void, RuntimeUpcallNop::nop_method(JavaThread* current))\n+{\n+}\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcallNop.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_RUNTIME_UPCALL_NOP_HPP\n+#define SHARE_RUNTIME_RUNTIME_UPCALL_NOP_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/#include \"code\/codeBlob.hpp\"\n+\/\/#include \"code\/vmreg.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class MethodDetails;\n+\n+class RuntimeUpcallNop : AllStatic {\n+public:\n+  static bool methodFilterResult;\n+  static bool filter_method_callback(MethodDetails& methodDetails);\n+  static void nop_method(TRAPS);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_RUNTIME_UPCALL_NOP_HPP\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcallNop.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/methodDetails.hpp\"\n+#include \"runtime\/runtimeUpcalls.hpp\"\n+\n+GrowableArray<RuntimeUpcallInfo*>* RuntimeUpcalls::_upcalls[RuntimeUpcallType::numTypes];\n+RuntimeUpcalls::State RuntimeUpcalls::_state = RuntimeUpcalls::Uninitialized;\n+\n+bool runtimeUpcalls_open_registration() {\n+  return RuntimeUpcalls::open_upcall_registration();\n+}\n+\n+bool RuntimeUpcalls::open_upcall_registration() {\n+  assert(_state == Uninitialized, \"upcalls are already open\");\n+  for (int i = 0; i < RuntimeUpcallType::numTypes; i++) {\n+    RuntimeUpcalls::_upcalls[i] = nullptr;\n+  }\n+  _state = Open;\n+  return true;\n+}\n+\n+void runtimeUpcalls_close_registration() {\n+  RuntimeUpcalls::close_upcall_registration();\n+}\n+\n+void RuntimeUpcalls::close_upcall_registration() {\n+  assert(_state == Open, \"upcalls are not open\");\n+  _state = Closed;\n+}\n+\n+void RuntimeUpcalls::mark_for_upcalls(RuntimeUpcallType upcallType, const methodHandle& method) {\n+  if (_upcalls[upcallType] != nullptr) {\n+    MethodDetails md(method);\n+    for(RuntimeUpcallInfo* info : *(_upcalls[upcallType])) {\n+      if(info->includes(md)) {\n+        switch(upcallType) {\n+          case onMethodEntry: method->set_has_upcall_on_method_entry(true); break;\n+          case onMethodExit:  method->set_has_upcall_on_method_exit(true);  break;\n+          default:            ShouldNotReachHere();\n+        }\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+bool RuntimeUpcalls::register_upcall(RuntimeUpcallType upcallType, RuntimeUpcallInfo* info) {\n+  assert(upcallType != onMethodExit, \"Upcalls on method exit are not supported yet\");\n+  assert(info != nullptr, \"upcall info is null\");\n+  if (_upcalls[upcallType] == nullptr) {\n+    _upcalls[upcallType] = new (mtServiceability) GrowableArray<RuntimeUpcallInfo*>(1, mtServiceability);\n+  }\n+  info->set_index(_upcalls[upcallType]->length());\n+  _upcalls[upcallType]->append(info);\n+  return true;\n+}\n+\n+int RuntimeUpcalls::get_num_upcalls(RuntimeUpcallType upcallType) {\n+  return (_upcalls[upcallType] == nullptr) ? 0 : _upcalls[upcallType]->length();\n+}\n+\n+void RuntimeUpcalls::upcall_redirect(RuntimeUpcallType upcallType, JavaThread* current, Method* method) {\n+  MethodDetails md(method);\n+\n+  \/\/ This redirection occurs when there are more than one upcalls setup.  Currently each method is marked\n+  \/\/ to indicate either none, entry and\/or exit upcalls (two bits total); then we have to iterate over\n+  \/\/ all upcalls and test the method details to determine which upcalls to call.  This is not optimal.\n+  \/\/ One possible optimization is to use more bits to support more upcalls.  The method flags currently use 18\n+  \/\/ out of 32 bits, so there are still 14 bits available for use.  We could set a limit of say 4-8 entry\/exit\n+  \/\/ upcalls combined, leaving 10-6 bits for other uses.  This still requires a redirect here to determine\n+  \/\/ which upcalls to call, but it would be more efficient than the current implementation as we'd avoid the\n+  \/\/ method matching and simply map bits to indexes.\n+\n+  RuntimeUpcallInfo* upcall = get_first_upcall(upcallType, md);\n+  while (upcall != nullptr) {\n+    upcall->upcall()(current);\n+    upcall = get_next_upcall(upcallType, md, upcall);\n+  }\n+}\n+\n+JRT_BLOCK_ENTRY(void, RuntimeUpcalls::on_method_entry_upcall_redirect(JavaThread* current, Method* method)) {\n+    RuntimeUpcalls::upcall_redirect(onMethodEntry, current, method);\n+}\n+JRT_END\n+\n+JRT_BLOCK_ENTRY(void, RuntimeUpcalls::on_method_exit_upcall_redirect(JavaThread* current, Method* method)) {\n+    RuntimeUpcalls::upcall_redirect(onMethodExit, current, method);\n+}\n+JRT_END\n+\n+\/\/-------------------------------RuntimeUpcalls---------------------------------------\n+\n+void RuntimeUpcalls::install_upcalls(const methodHandle& method) {\n+  for (int i = 0; i < RuntimeUpcallType::numTypes; i++) {\n+      mark_for_upcalls(static_cast<RuntimeUpcallType>(i), method);\n+  }\n+}\n+\n+bool RuntimeUpcalls::register_upcall(RuntimeUpcallType upcallType, const char* upcallName, RuntimeUpcall upcall, RuntimeUpcallMethodFilterCallback methodFilterCallback)\n+{\n+  assert(upcallType < numTypes, \"invalid upcall type\");\n+  assert(_state == Open, \"upcalls are not open for registration\");\n+  if (_state != Open) return false;\n+  return register_upcall(upcallType, RuntimeUpcallInfo::create(upcallName, upcall, methodFilterCallback));\n+}\n+\n+RuntimeUpcallInfo* RuntimeUpcalls::get_next_upcall(RuntimeUpcallType upcallType, MethodDetails& methodDetails, RuntimeUpcallInfo* prevUpcallInfo) {\n+  assert(upcallType < numTypes, \"invalid upcall type\");\n+  if (_upcalls[upcallType] != nullptr) {\n+    \/\/ simple case where there's only one upcall\n+    if (_upcalls[upcallType]->length() == 1) {\n+      if (prevUpcallInfo != nullptr) {\n+        return nullptr;\n+      }\n+      RuntimeUpcallInfo* upcall = _upcalls[upcallType]->at(0);\n+      return upcall->includes(methodDetails) ? upcall : nullptr;\n+    }\n+\n+    \/\/ Resume from where we left off, unless we are the last entry.\n+    assert(prevUpcallInfo == nullptr || (prevUpcallInfo->get_index() >= 0 && prevUpcallInfo->get_index() < _upcalls[upcallType]->length()), \"invalid upcall index\");\n+    int index = (prevUpcallInfo != nullptr) ? prevUpcallInfo->get_index() + 1 : 0;\n+    for (int i = index; i < _upcalls[upcallType]->length(); i++) {\n+      RuntimeUpcallInfo* upcall = _upcalls[upcallType]->at(i);\n+      if (upcall->includes(methodDetails)) {\n+        return upcall;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+RuntimeUpcallInfo* RuntimeUpcalls::get_first_upcall(RuntimeUpcallType upcallType, MethodDetails& methodDetails) {\n+  return get_next_upcall(upcallType, methodDetails, nullptr);\n+}\n+\n+bool RuntimeUpcalls::does_upcall_need_method_parameter(address upcall_address)\n+{\n+  \/\/ Redirect needs the method parameter for filtering.\n+  if((upcall_address == CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_entry_upcall_redirect)) ||\n+     (upcall_address == CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_exit_upcall_redirect))) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+address RuntimeUpcalls::on_method_entry_upcall_address()\n+{\n+  \/\/ Optimized case when there's only one upcall (no need to redirect).\n+  if(_upcalls[onMethodEntry] != nullptr && _upcalls[onMethodEntry]->length() == 1) {\n+    return _upcalls[onMethodEntry]->at(0)->upcall_address();\n+  }\n+\n+  return CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_entry_upcall_redirect);\n+}\n+\n+address RuntimeUpcalls::on_method_exit_upcall_address()\n+{\n+  \/\/ Optimized case when there's only one upcall (no need to redirect).\n+  if(_upcalls[onMethodExit] != nullptr && _upcalls[onMethodExit]->length() == 1) {\n+    return _upcalls[onMethodExit]->at(0)->upcall_address();\n+  }\n+\n+  return CAST_FROM_FN_PTR(address, RuntimeUpcalls::on_method_exit_upcall_redirect);\n+}\n+\n+const char* RuntimeUpcalls::get_name_for_upcall_address(address upcall_address)\n+{\n+  for(int i = 0; i < RuntimeUpcallType::numTypes; i++) {\n+    if (_upcalls[i] != nullptr) {\n+      for (int j = 0; j < _upcalls[i]->length(); j++) {\n+        RuntimeUpcallInfo* upcall = _upcalls[i]->at(j);\n+        if (upcall->upcall_address() == upcall_address) {\n+          return upcall->upcall_name();\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcalls.cpp","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_RUNTIME_UPCALLS_HPP\n+#define SHARE_RUNTIME_RUNTIME_UPCALLS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/methodDetails.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+enum RuntimeUpcallType{\n+  onMethodEntry = 0, \/\/ Upcalls triggered on method entry AFTER tracing\n+  onMethodExit,      \/\/ Not implemented yet \n+  numTypes\n+};\n+\n+typedef void (*RuntimeUpcall)(JavaThread* current);\n+typedef bool (*RuntimeUpcallMethodFilterCallback)(MethodDetails& method);\n+\n+class RuntimeUpcallInfo: public CHeapObj<mtInternal>{\n+  const char* _upcallName;\n+  const RuntimeUpcall _upcall;\n+  const RuntimeUpcallMethodFilterCallback _methodFilter;\n+  address _address;\n+  int _index;\n+\n+  RuntimeUpcallInfo(const char* upcallName,\n+                    const RuntimeUpcall upcall,\n+                    const RuntimeUpcallMethodFilterCallback methodFilter)\n+  : _upcallName(upcallName),\n+    _upcall(upcall),\n+    _methodFilter(methodFilter),\n+    _index(-1) {\n+    _address = CAST_FROM_FN_PTR(address, upcall);\n+  }\n+\n+private:\n+  friend class RuntimeUpcalls;\n+  void set_index(const int index) { _index = index; }\n+  int get_index() const { assert(_index >= 0, \"invalid index\"); return _index; }\n+\n+public:\n+  static RuntimeUpcallInfo* create(const char* upcallName, const RuntimeUpcall upcall, const RuntimeUpcallMethodFilterCallback methodFilter) {\n+    assert(upcallName != nullptr, \"upcall name must be provided\");\n+    assert(upcall != nullptr, \"upcall must be provided\");\n+    assert(methodFilter != nullptr, \"method filter must be provided\");\n+    return new RuntimeUpcallInfo(upcallName, upcall, methodFilter);\n+  }\n+\n+  RuntimeUpcall upcall() const { return _upcall; }\n+  const char* upcall_name() const { return _upcallName; }\n+  address upcall_address() const { return _address; }\n+\n+  bool includes(MethodDetails& methodDetails) const {\n+    return _methodFilter(methodDetails);\n+  }\n+};\n+\n+class RuntimeUpcalls: AllStatic {\n+private:\n+\n+  enum State {\n+    Uninitialized,\n+    Open,\n+    Closed\n+  };\n+\n+  static GrowableArray<RuntimeUpcallInfo*>* _upcalls[RuntimeUpcallType::numTypes];\n+  static State _state;\n+\n+  static void mark_for_upcalls(RuntimeUpcallType upcallType, const methodHandle& method);\n+  static bool register_upcall(RuntimeUpcallType upcallType, RuntimeUpcallInfo* info);\n+  static void upcall_redirect(RuntimeUpcallType upcallType, JavaThread* current, Method* method);\n+\n+  static int  get_num_upcalls(RuntimeUpcallType upcallType);\n+\n+  static void on_method_entry_upcall_redirect(JavaThread* current, Method* method);\n+  static void on_method_exit_upcall_redirect(JavaThread* current, Method* method);\n+\n+public:\n+\n+  static bool               open_upcall_registration();\n+  static bool               register_upcall(RuntimeUpcallType upcallType, const char* upcallName, RuntimeUpcall upcall, RuntimeUpcallMethodFilterCallback methodFilterCallback = nullptr);\n+  static void               close_upcall_registration();\n+\n+  static void               install_upcalls(const methodHandle& method);\n+\n+  static RuntimeUpcallInfo* get_first_upcall(RuntimeUpcallType upcallType, MethodDetails& methodDetails);\n+  static RuntimeUpcallInfo* get_next_upcall(RuntimeUpcallType upcallType, MethodDetails& methodDetails, RuntimeUpcallInfo* prevUpcallInfo = nullptr);\n+\n+  static address            on_method_entry_upcall_address();\n+  static address            on_method_exit_upcall_address();\n+\n+  static bool               does_upcall_need_method_parameter(address upcall_address);\n+\n+  static const char*        get_name_for_upcall_address(address upcall_address);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_RUNTIME_UPCALLS_HPP\n","filename":"src\/hotspot\/share\/runtime\/runtimeUpcalls.hpp","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -257,5 +256,0 @@\n-\/\/ For AOT\n-uint volatile SharedRuntime::_end_training_count = 0;\n-uint          SharedRuntime::_end_training_predicate = 1;\n-int  volatile SharedRuntime::_end_training_triggered = 0;\n-\n@@ -1412,37 +1406,0 @@\n-JRT_BLOCK_ENTRY(void, SharedRuntime::end_training_check_c1(JavaThread* current))\n-{\n-  JRT_BLOCK\n-    SharedRuntime::end_training_check(CHECK);\n-  JRT_BLOCK_END\n-}\n-JRT_END\n-\n-JRT_BLOCK_ENTRY(void, SharedRuntime::end_training_check_c2(JavaThread* current))\n-{\n-  JRT_BLOCK\n-    SharedRuntime::end_training_check(CHECK);\n-  JRT_BLOCK_END\n-}\n-JRT_END\n-\n-void SharedRuntime::end_training_check(TRAPS)\n-{\n-  if (_end_training_triggered == 0) {\n-    Atomic::inc(&_end_training_count);\n-    if(_end_training_count >= _end_training_predicate)\n-    {\n-      SharedRuntime::end_training(CHECK);\n-    }\n-  }\n-}\n-\n-void SharedRuntime::end_training(TRAPS)\n-{\n-  if (_end_training_triggered == 0) {\n-    if (Atomic::cmpxchg(&_end_training_triggered, 0, 1) == 0) {\n-      MetaspaceShared::preload_and_dump(CHECK);\n-      assert(!THREAD->has_pending_exception(), \"must be\");\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -373,7 +373,0 @@\n-  \/\/ AOT support\n-  static void end_training_check_c1(JavaThread* current);\n-  static void end_training_check_c2(JavaThread* current);\n-  static void end_training_check(TRAPS);\n-  static void end_training(TRAPS);\n-  static void set_end_training_predicate(uint predicate) { Atomic::store(&_end_training_predicate, predicate); }\n-\n@@ -381,6 +374,0 @@\n-\n-  \/\/ AOT\n-  static uint volatile _end_training_count;\n-  static uint          _end_training_predicate;\n-  static int  volatile _end_training_triggered;\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsEndTrainingUpcall.hpp\"\n@@ -59,1 +60,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -999,1 +999,3 @@\n-    output()->print_cr(\"Must be in training run\");\n+    output()->print_cr(\"Error! Not a training run\");\n+  } else if (CDSEndTrainingUpcall::end_training(THREAD)) {\n+    output()->print_cr(\"Training ended successfully\");\n@@ -1001,1 +1003,1 @@\n-    SharedRuntime::end_training(CHECK);\n+    output()->print_cr(\"Error! Failed to end training\");\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=no_trigger\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n- * @build LeydenEndTrainingTrigger\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n- * @run driver LeydenEndTrainingTrigger LEYDEN\n- *\/\n-\n-\/*\n- * @test id=trigger\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n- * @build LeydenEndTrainingTrigger\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n- * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod LEYDEN\n- *\/\n-\n-\/*\n- * @test id=trigger_count_1\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n- * @build LeydenEndTrainingTrigger\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n- * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 1 LEYDEN\n- *\/\n-\n-\/*\n- * @test id=trigger_count_2\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n- * @build LeydenEndTrainingTrigger\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n- * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 2 LEYDEN\n- *\/\n-\n-\/*\n- * @test id=trigger_count_3\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n- * @build LeydenEndTrainingTrigger\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n- * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 3 LEYDEN\n- *\/\n-\n-\/*\n- * @test id=trigger_count_99\n- * @requires vm.cds.write.archived.java.heap\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n- * @build LeydenEndTrainingTrigger\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n- * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 99 LEYDEN\n- *\/\n-\n-import java.util.Arrays;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.cds.CDSAppTester;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class LeydenEndTrainingTrigger {\n-    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n-    static final String mainClass = \"LeydenEndTrainingTriggerApp\";\n-    static final String vmCmdPrefix = \"-XX:AOTEndTrainingOnMethodEntry=\";\n-    static String triggerMethod = \"\";\n-    static int count = 0;\n-\n-    public static void main(String[] args) throws Exception {\n-        Tester t = new Tester();\n-        if (args.length > 1) {\n-            triggerMethod = vmCmdPrefix + args[0];\n-            args = Arrays.copyOfRange(args, 1, args.length);\n-        }\n-        if (args.length == 2) {\n-            triggerMethod += \",count=\" + args[0];\n-            count = Integer.parseInt(args[0]);\n-            args = Arrays.copyOfRange(args, 1, args.length);\n-        }\n-        t.run(args);\n-    }\n-\n-    static class Tester extends CDSAppTester {\n-        public Tester() {\n-            super(mainClass);\n-        }\n-\n-        @Override\n-        public String classpath(RunMode runMode) {\n-            return appJar;\n-        }\n-\n-        @Override\n-        public String[] appCommandLine(RunMode runMode) {\n-            return new String[] {\n-                mainClass, runMode.name()\n-            };\n-        }\n-\n-        @Override\n-        public String[] vmArgs(RunMode runMode) {\n-            if (runMode == RunMode.TRAINING && triggerMethod.length() > 0) {\n-                return new String[] { triggerMethod };\n-            }\n-            return new String[] {};\n-        }\n-\n-        @Override\n-        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n-            if (!runMode.isStaticDump()) {\n-                \/\/ always expect this output\n-                out.shouldContain(\"LeydenEndTrainingTriggerApp_line_1\");\n-                out.shouldContain(\"LeydenEndTrainingTriggerApp_line_2\");\n-                out.shouldContain(\"LeydenEndTrainingTriggerApp_line_3\");\n-            }\n-            if (runMode == RunMode.TRAINING) {\n-                \/\/ in training mode we expect the dump to be triggered\n-                \/\/ count controls where in the application output the dump occurs\n-                \/\/ so we test that the counts worked as expected (even the case where no trigger was specified)\n-                var lines = out.asLines();\n-                \/\/ find the line number that contains \"CacheDataStore dumping is complete\"\n-                var dumpComplete = lines.indexOf(\"CacheDataStore dumping is complete\");\n-                Asserts.assertNE(dumpComplete, -1, \"CacheDataStore dumping is complete not found\");\n-                var line1 = lines.indexOf(\"LeydenEndTrainingTriggerApp_line_1\");\n-                var line2 = lines.indexOf(\"LeydenEndTrainingTriggerApp_line_2\");\n-                var line3 = lines.indexOf(\"LeydenEndTrainingTriggerApp_line_3\");\n-\n-                if (triggerMethod.length() == 0) {\n-                    \/\/ no trigger, so dump should run after execution\n-                    Asserts.assertGT(dumpComplete, line3, \"dump \");\n-                } else {\n-                    switch(count) {\n-                        case 0:\n-                            \/\/ no count specified, default is 1 (ie first trigger)\n-                            Asserts.assertLT(dumpComplete, line1, \"dumpComplete should be before line 1 of application output\");\n-                            break;\n-                        case 1:\n-                            Asserts.assertLT(dumpComplete, line1, \"dumpComplete should be before line 1 of application output\");\n-                            break;\n-                        case 2:\n-                            Asserts.assertGT(dumpComplete, line1, \"dumpComplete should be after line 1 of application output\");\n-                            Asserts.assertLT(dumpComplete, line2, \"dumpComplete should be before line 2 of application output\");\n-                            break;\n-                        case 3:\n-                            Asserts.assertGT(dumpComplete, line2, \"dumpComplete should be after line 2 of application output\");\n-                            Asserts.assertLT(dumpComplete, line3, \"dumpComplete should be before line 3 of application output\");\n-                            break;\n-                        default:\n-                            Asserts.assertGT(dumpComplete, line3, \"dumpComplete should be after line 3 of application output\");\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-class LeydenEndTrainingTriggerApp {\n-    public static void triggerMethod(String text) {\n-        System.out.println(\"LeydenEndTrainingTriggerApp_line_\" + text);\n-    }\n-    public static void main(String args[]) {\n-        triggerMethod(\"1\");\n-        triggerMethod(\"2\");\n-        triggerMethod(\"3\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/leyden\/LeydenEndTrainingTrigger.java","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"}]}