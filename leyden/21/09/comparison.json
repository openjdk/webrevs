{"files":[{"patch":"@@ -162,0 +162,7 @@\n+By default, training runs end when the application terminates.  You have two other options to end training runs:\n+\n+- -XX:AOTEndTrainingOnMethodEntry=<method1,method2,...>[,count=100]\n+- jcmd \\<pid> AOT.end_training\n+\n+Note that AOTEndTrainingOnMethodEntry uses the same format as CompileOnly and the default count is 1\n+\n","filename":"README.md","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1401,0 +1402,3 @@\n+void InterpreterMacroAssembler::end_training_check() {\n+  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::end_training_check));\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -306,0 +306,3 @@\n+  \/\/ support for AOT\n+  void end_training_check();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1159,1 +1159,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n@@ -1278,0 +1278,5 @@\n+  \/\/ AOT training run support\n+  if (end_training_trigger) {\n+    __ end_training_check();\n+  }\n+\n@@ -1582,1 +1587,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n@@ -1727,0 +1732,5 @@\n+  \/\/ AOT training run support\n+  if (end_training_trigger) {\n+    __ end_training_check();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -806,1 +806,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n@@ -1140,1 +1140,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1179,1 +1179,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n@@ -1610,1 +1610,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -959,1 +959,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n@@ -1356,1 +1356,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1303,1 +1303,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n@@ -1659,1 +1659,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1933,0 +1934,4 @@\n+void InterpreterMacroAssembler::end_training_check() {\n+  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::end_training_check));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -276,0 +276,3 @@\n+  \/\/ support for AOT\n+  void end_training_check();\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -793,1 +793,1 @@\n-address TemplateInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n@@ -919,0 +919,5 @@\n+  \/\/ AOT training run support\n+  if (end_training_trigger) {\n+    __ end_training_check();\n+  }\n+\n@@ -1332,1 +1337,1 @@\n-address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address TemplateInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n@@ -1474,0 +1479,5 @@\n+  \/\/ AOT training run support\n+  if (end_training_trigger) {\n+    __ end_training_check();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -4073,0 +4074,5 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers() && callee->is_end_training_trigger()) {\n+    Values* args = new Values(0);\n+    append(new RuntimeCall(voidType, \"end_training_check_c1\", CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c1), args));\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -2679,0 +2680,8 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers() && method()->is_end_training_trigger()) {\n+    BasicTypeList signature;\n+    signature.append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    \/\/ thread\n+    LIR_OprList* args = new LIR_OprList();\n+    args->append(getThreadPointer());\n+    call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c1), voidType, nullptr);\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+  FUNCTION_CASE(entry, SharedRuntime::end_training_check_c1);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -674,0 +674,4 @@\n+bool CDSConfig::is_dumping_preimage_static_archive_with_triggers() {\n+  return _is_dumping_static_archive && CacheDataStore != nullptr && CDSPreimage == nullptr && !FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,3 +96,4 @@\n-  static bool is_dumping_classic_static_archive()            NOT_CDS_RETURN_(false); \/\/ -Xshare:dump\n-  static bool is_dumping_preimage_static_archive()           NOT_CDS_RETURN_(false); \/\/ 1st phase of -XX:CacheDataStore dumping\n-  static bool is_dumping_final_static_archive()              NOT_CDS_RETURN_(false); \/\/ 2nd phase of -XX:CacheDataStore dumping\n+  static bool is_dumping_classic_static_archive()                NOT_CDS_RETURN_(false); \/\/ -Xshare:dump\n+  static bool is_dumping_preimage_static_archive()               NOT_CDS_RETURN_(false); \/\/ 1st phase of -XX:CacheDataStore dumping\n+  static bool is_dumping_preimage_static_archive_with_triggers() NOT_CDS_RETURN_(false); \/\/ 1st phase of -XX:CacheDataStore dumping with triggers\n+  static bool is_dumping_final_static_archive()                  NOT_CDS_RETURN_(false); \/\/ 2nd phase of -XX:CacheDataStore dumping\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+int volatile MetaspaceShared::_preimage_static_archive_dumped = 0;\n@@ -875,0 +876,6 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    if (Atomic::cmpxchg(&_preimage_static_archive_dumped, 0, 1) != 0) {\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  static int volatile _preimage_static_archive_dumped;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -200,7 +200,8 @@\n-  bool caller_sensitive()       const { return get_Method()->caller_sensitive();       }\n-  bool force_inline()           const { return get_Method()->force_inline();           }\n-  bool dont_inline()            const { return get_Method()->dont_inline();            }\n-  bool intrinsic_candidate()    const { return get_Method()->intrinsic_candidate();    }\n-  bool is_static_initializer()  const { return get_Method()->is_static_initializer();  }\n-  bool changes_current_thread() const { return get_Method()->changes_current_thread(); }\n-  bool deprecated()             const { return is_loaded() && get_Method()->deprecated(); }\n+  bool caller_sensitive()        const { return get_Method()->caller_sensitive();       }\n+  bool force_inline()            const { return get_Method()->force_inline();           }\n+  bool dont_inline()             const { return get_Method()->dont_inline();            }\n+  bool intrinsic_candidate()     const { return get_Method()->intrinsic_candidate();    }\n+  bool is_static_initializer()   const { return get_Method()->is_static_initializer();  }\n+  bool changes_current_thread()  const { return get_Method()->changes_current_thread(); }\n+  bool deprecated()              const { return is_loaded() && get_Method()->deprecated(); }\n+  bool is_end_training_trigger() const { return get_Method()->is_end_training_trigger(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -501,0 +502,4 @@\n+bool CompilerOracle::should_trigger_end_of_training_at(const methodHandle& method) {\n+  return check_predicate(CompileCommandEnum::EndTrainingOnEnter, method);\n+}\n+\n@@ -1130,0 +1135,5 @@\n+  if (CDSPreimage == nullptr) {\n+    if (!CompilerOracle::parse_from_string(AOTEndTrainingOnMethodEntry, CompilerOracle::parse_aot_trigger)) {\n+      success = false;\n+    }\n+  }\n@@ -1150,1 +1160,1 @@\n-bool CompilerOracle::parse_compile_only(char* line) {\n+bool CompilerOracle::parse_for_command(char* line, CompileCommandEnum command, const char* error_prefix, uint* count) {\n@@ -1164,4 +1174,14 @@\n-      TypedMethodOptionMatcher* matcher = TypedMethodOptionMatcher::parse_method_pattern(method_pattern, error_buf, sizeof(error_buf));\n-      if (matcher != nullptr) {\n-        register_command(matcher, CompileCommandEnum::CompileOnly, true);\n-        continue;\n+      \/\/ if method pattern starts with count=, then parse the count\n+      if (count != nullptr && strncmp(method_pattern, \"count=\", 6) == 0) {\n+        int number = atoi(method_pattern + 6);\n+        if (number > 0) {\n+          *count = (uint)number;\n+          continue;\n+        }\n+        strcpy(error_buf, \"count must be a valid integer > 0\");\n+      } else {\n+        TypedMethodOptionMatcher* matcher = TypedMethodOptionMatcher::parse_method_pattern(method_pattern, error_buf, sizeof(error_buf));\n+        if (matcher != nullptr) {\n+          register_command(matcher, command, true);\n+          continue;\n+        }\n@@ -1171,1 +1191,1 @@\n-    tty->print_cr(\"CompileOnly: An error occurred during parsing\");\n+    tty->print_cr(\"%s: An error occurred during parsing\", error_prefix);\n@@ -1181,0 +1201,13 @@\n+bool CompilerOracle::parse_compile_only(char* line) {\n+  return parse_for_command(line, CompileCommandEnum::CompileOnly, \"CompileOnly\");\n+}\n+\n+bool CompilerOracle::parse_aot_trigger(char* line) {\n+  uint count = 0;\n+  bool result = parse_for_command(line, CompileCommandEnum::EndTrainingOnEnter, \"AOTEndTrainingOnMethodEntry\", &count);\n+  if (result && count > 0) {\n+    SharedRuntime::set_end_training_predicate(count);\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  option(EndTrainingOnEnter, \"EndTrainingOnEnter\", Bool) \\\n@@ -136,0 +137,3 @@\n+  \/\/ Shared for parsing CompileOnly and AOTTrigger\n+  static bool parse_for_command(char* line, CompileCommandEnum command, const char* error_prefix, uint* count = nullptr);\n+\n@@ -169,0 +173,3 @@\n+  \/\/ Tells whether to 'trigger end of training' when executing method\n+  static bool should_trigger_end_of_training_at(const methodHandle& method);\n+\n@@ -197,0 +204,1 @@\n+  static bool parse_aot_trigger(char* line);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -305,0 +305,3 @@\n+  product(ccstrlist, AOTEndTrainingOnMethodEntry, \"\",                       \\\n+          \"List of methods (pkg\/class.name) to trigger end of AOT \"         \\\n+          \"training run.  Optional ',count=N' where N is > 0\")              \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,1 +169,4 @@\n-    return m->is_synchronized() ? native_synchronized : native;\n+    if (m->is_synchronized()) {\n+      return m->is_end_training_trigger() ? native_synchronized_end_training_trigger : native_synchronized;\n+    }\n+    return m->is_end_training_trigger() ? native_end_training_trigger : native;\n@@ -174,1 +177,1 @@\n-    return zerolocals_synchronized;\n+    return m->is_end_training_trigger() ? zerolocals_synchronized_end_training_trigger : zerolocals_synchronized;\n@@ -179,1 +182,1 @@\n-    return empty;\n+    return m->is_end_training_trigger() ? empty_end_training_trigger : empty;\n@@ -193,1 +196,1 @@\n-  return zerolocals;\n+  return m->is_end_training_trigger() ? zerolocals_end_training_trigger : zerolocals;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+    zerolocals_end_training_trigger,                            \/\/ method needs locals initialization & is end training trigger\n+    zerolocals_synchronized_end_training_trigger,               \/\/ method needs locals initialization & is synchronized & is end training trigger\n@@ -64,0 +66,2 @@\n+    native_end_training_trigger,                                \/\/ native method & is end training trigger\n+    native_synchronized_end_training_trigger,                   \/\/ native method & is synchronized & is end training trigger\n@@ -65,0 +69,1 @@\n+    empty_end_training_trigger,                                 \/\/ empty method & is end training trigger (code: _return)\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1159,0 +1159,6 @@\n+JRT_ENTRY(void, InterpreterRuntime::end_training_check(JavaThread* current)) {\n+\n+    SharedRuntime::end_training_check(CHECK);\n+}\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+  static void end_training_check(JavaThread* current);\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -189,0 +190,5 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers()) {\n+    method_entry(zerolocals_end_training_trigger)\n+    method_entry(zerolocals_synchronized_end_training_trigger)\n+    method_entry(empty_end_training_trigger)\n+  }\n@@ -223,0 +229,4 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers()) {\n+    native_method_entry(native_end_training_trigger)\n+    native_method_entry(native_synchronized_end_training_trigger)\n+  }\n@@ -409,0 +419,55 @@\n+bool TemplateInterpreterGenerator::is_synchronized_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::zerolocals_synchronized                     : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_end_training_trigger: \/\/ fall thru\n+    case Interpreter::native_synchronized                         : \/\/ fall thru\n+    case Interpreter::native_synchronized_end_training_trigger    :\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+bool TemplateInterpreterGenerator::is_end_training_trigger_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::zerolocals_end_training_trigger             : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_end_training_trigger: \/\/ fall thru\n+    case Interpreter::native_end_training_trigger                 : \/\/ fall thru\n+    case Interpreter::native_synchronized_end_training_trigger    : \/\/ fall thru\n+    case Interpreter::empty_end_training_trigger                  :\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+bool TemplateInterpreterGenerator::is_intrinsic_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::zerolocals                                  : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized                     : \/\/ fall thru\n+    case Interpreter::zerolocals_end_training_trigger             : \/\/ fall thru\n+    case Interpreter::zerolocals_synchronized_end_training_trigger: \/\/ fall thru\n+    case Interpreter::native                                      : \/\/ fall thru\n+    case Interpreter::native_synchronized                         : \/\/ fall thru\n+    case Interpreter::native_end_training_trigger                 : \/\/ fall thru\n+    case Interpreter::native_synchronized_end_training_trigger    : \/\/ fall thru\n+    case Interpreter::empty                                       : \/\/ fall thru\n+    case Interpreter::empty_end_training_trigger                  : \/\/ fall thru\n+    case Interpreter::getter                                      : \/\/ fall thru\n+    case Interpreter::setter                                      : \/\/ fall thru\n+    case Interpreter::abstract                                    :\n+      return false;\n+    default:\n+      return true;\n+  }\n+}\n+\n+bool TemplateInterpreterGenerator::is_abstract_method(AbstractInterpreter::MethodKind kind) {\n+  switch (kind) {\n+    case Interpreter::abstract:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -412,2 +477,0 @@\n-  \/\/ determine code generation flags\n-  bool synchronized = false;\n@@ -416,12 +479,4 @@\n-  switch (kind) {\n-  case Interpreter::zerolocals             :                           break;\n-  case Interpreter::zerolocals_synchronized: synchronized = true;      break;\n-  case Interpreter::native                 :                           break;\n-  case Interpreter::native_synchronized    : synchronized = true;      break;\n-  case Interpreter::empty                  : break;\n-  case Interpreter::getter                 : break;\n-  case Interpreter::setter                 : break;\n-  case Interpreter::abstract               : entry_point = generate_abstract_entry(); break;\n-  default:\n-    entry_point = generate_intrinsic_entry(kind); \/\/ process the rest\n-    break;\n+  if (is_abstract_method(kind)) {\n+    entry_point = generate_abstract_entry();\n+  } else if (is_intrinsic_method(kind)) {\n+    entry_point = generate_intrinsic_entry(kind);\n@@ -434,0 +489,3 @@\n+  bool synchronized = is_synchronized_method(kind);\n+  bool end_training_trigger = is_end_training_trigger_method(kind);\n+\n@@ -435,10 +493,17 @@\n-  if (native) {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::native_synchronized : Interpreter::native);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_native_entry(synchronized);\n-    }\n-  } else {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::zerolocals_synchronized : Interpreter::zerolocals);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_normal_entry(synchronized);\n-    }\n+  if (!synchronized && !end_training_trigger) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native\n+                                                     : Interpreter::zerolocals);\n+  } else if (synchronized && !end_training_trigger) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_synchronized\n+                                                     : Interpreter::zerolocals_synchronized);\n+  } else if (!synchronized && end_training_trigger) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_end_training_trigger\n+                                                     : Interpreter::zerolocals_end_training_trigger);\n+  } else if (synchronized && end_training_trigger) {\n+    entry_point = Interpreter::entry_for_kind(native ? Interpreter::native_synchronized_end_training_trigger\n+                                                     : Interpreter::zerolocals_synchronized_end_training_trigger);\n+  }\n+\n+  if (entry_point == nullptr) {\n+      entry_point = native ? generate_native_entry(synchronized, end_training_trigger)\n+                           : generate_normal_entry(synchronized, end_training_trigger);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":89,"deletions":24,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -86,0 +86,6 @@\n+  \/\/ helpers for method entry generation\n+  bool is_synchronized_method(AbstractInterpreter::MethodKind kind);\n+  bool is_end_training_trigger_method(AbstractInterpreter::MethodKind kind);\n+  bool is_intrinsic_method(AbstractInterpreter::MethodKind kind);\n+  bool is_abstract_method(AbstractInterpreter::MethodKind kind);\n+\n@@ -92,2 +98,2 @@\n-  address generate_normal_entry(bool synchronized);\n-  address generate_native_entry(bool synchronized);\n+  address generate_normal_entry(bool synchronized, bool end_training_trigger);\n+  address generate_native_entry(bool synchronized, bool end_training_trigger);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      entry_point = generate_native_entry(synchronized);\n+      entry_point = generate_native_entry(synchronized, false);\n@@ -127,1 +127,1 @@\n-      entry_point = generate_normal_entry(synchronized);\n+      entry_point = generate_normal_entry(synchronized, false);\n@@ -177,1 +177,1 @@\n-address ZeroInterpreterGenerator::generate_native_entry(bool synchronized) {\n+address ZeroInterpreterGenerator::generate_native_entry(bool synchronized, bool end_training_trigger) {\n@@ -181,1 +181,1 @@\n-address ZeroInterpreterGenerator::generate_normal_entry(bool synchronized) {\n+address ZeroInterpreterGenerator::generate_normal_entry(bool synchronized, bool end_training_trigger) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  address generate_normal_entry(bool synchronized);\n-  address generate_native_entry(bool synchronized);\n+  address generate_normal_entry(bool synchronized, bool end_training_trigger);\n+  address generate_native_entry(bool synchronized, bool end_training_trigger);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -1077,1 +1078,1 @@\n-\n+  bool addingAOTTriggers = CDSConfig::is_dumping_preimage_static_archive_with_triggers();\n@@ -1082,0 +1083,4 @@\n+    if (addingAOTTriggers && CompilerOracle::should_trigger_end_of_training_at(m)) {\n+      m->set_is_end_training_trigger(true);\n+    }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1249,0 +1249,1 @@\n+  set_is_end_training_trigger(false);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+   status(is_end_training_trigger     , 1 << 17) \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -674,0 +674,3 @@\n+  \/\/---------------- AOT support --------------------\n+  void make_end_training_check();\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1214,0 +1215,4 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive_with_triggers() && method()->is_end_training_trigger()) {\n+    make_end_training_check();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,18 @@\n+void GraphKit::make_end_training_check() {\n+  const TypeFunc *call_type    = OptoRuntime::end_training_check_c2_Type();\n+  address         call_address = CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c2);\n+  const char     *call_name    = \"end_training_check_c2\";\n+\n+  \/\/ Get base of thread-local storage area\n+  Node* thread = _gvn.transform( new ThreadLocalNode() );\n+\n+  kill_dead_locals();\n+\n+  \/\/ For some reason, this call reads only raw memory.\n+  const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n+  make_runtime_call(RC_LEAF | RC_NARROW_MEM,\n+                    call_type, call_address,\n+                    call_name, raw_adr_type,\n+                    thread);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1819,0 +1819,16 @@\n+\/\/-----------------------------------------------------------------------------\n+\/\/ AOT\n+const TypeFunc *OptoRuntime::end_training_check_c2_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; \/\/ Thread-local storage\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -316,0 +316,3 @@\n+  \/\/ AOT\n+  static const TypeFunc* end_training_check_c2_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -250,0 +251,5 @@\n+\/\/ For AOT\n+uint volatile SharedRuntime::_end_training_count = 0;\n+uint          SharedRuntime::_end_training_predicate = 1;\n+int  volatile SharedRuntime::_end_training_triggered = 0;\n+\n@@ -1400,0 +1406,37 @@\n+JRT_BLOCK_ENTRY(void, SharedRuntime::end_training_check_c1(JavaThread* current))\n+{\n+  JRT_BLOCK\n+    SharedRuntime::end_training_check(CHECK);\n+  JRT_BLOCK_END\n+}\n+JRT_END\n+\n+JRT_BLOCK_ENTRY(void, SharedRuntime::end_training_check_c2(JavaThread* current))\n+{\n+  JRT_BLOCK\n+    SharedRuntime::end_training_check(CHECK);\n+  JRT_BLOCK_END\n+}\n+JRT_END\n+\n+void SharedRuntime::end_training_check(TRAPS)\n+{\n+  if (_end_training_triggered == 0) {\n+    Atomic::inc(&_end_training_count);\n+    if(_end_training_count >= _end_training_predicate)\n+    {\n+      SharedRuntime::end_training(CHECK);\n+    }\n+  }\n+}\n+\n+void SharedRuntime::end_training(TRAPS)\n+{\n+  if (_end_training_triggered == 0) {\n+    if (Atomic::cmpxchg(&_end_training_triggered, 0, 1) == 0) {\n+      MetaspaceShared::preload_and_dump(CHECK);\n+      assert(!THREAD->has_pending_exception(), \"must be\");\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -348,0 +348,7 @@\n+  \/\/ AOT support\n+  static void end_training_check_c1(JavaThread* current);\n+  static void end_training_check_c2(JavaThread* current);\n+  static void end_training_check(TRAPS);\n+  static void end_training(TRAPS);\n+  static void set_end_training_predicate(uint predicate) { Atomic::store(&_end_training_predicate, predicate); }\n+\n@@ -349,0 +356,6 @@\n+\n+  \/\/ AOT\n+  static uint volatile _end_training_count;\n+  static uint          _end_training_predicate;\n+  static int  volatile _end_training_triggered;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -137,0 +138,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<AOTEndTrainingDCmd>(full_export, true, false));\n@@ -994,0 +996,8 @@\n+void AOTEndTrainingDCmd::execute(DCmdSource source, TRAPS) {\n+  if (!CDSConfig::is_dumping_preimage_static_archive()) {\n+    output()->print_cr(\"Must be in training run\");\n+  } else {\n+    SharedRuntime::end_training(CHECK);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -398,0 +398,18 @@\n+class AOTEndTrainingDCmd : public DCmd {\n+public:\n+  AOTEndTrainingDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"AOT.end_training\"; }\n+    static const char* description() {\n+      return \"End AOT training and create the cache.\";\n+    }\n+    static const char* impact() {\n+      return \"Medium: Pause time depends on number of loaded classes\";\n+    }\n+    static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+      return p;\n+    }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=no_trigger\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build LeydenEndTrainingTrigger\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n+ * @run driver LeydenEndTrainingTrigger LEYDEN\n+ *\/\n+\n+\/*\n+ * @test id=trigger\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build LeydenEndTrainingTrigger\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n+ * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod LEYDEN\n+ *\/\n+\n+\/*\n+ * @test id=trigger_count_1\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build LeydenEndTrainingTrigger\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n+ * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 1 LEYDEN\n+ *\/\n+\n+\/*\n+ * @test id=trigger_count_2\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build LeydenEndTrainingTrigger\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n+ * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 2 LEYDEN\n+ *\/\n+\n+\/*\n+ * @test id=trigger_count_3\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build LeydenEndTrainingTrigger\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n+ * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 3 LEYDEN\n+ *\/\n+\n+\/*\n+ * @test id=trigger_count_99\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build LeydenEndTrainingTrigger\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar LeydenEndTrainingTriggerApp\n+ * @run driver LeydenEndTrainingTrigger LeydenEndTrainingTriggerApp.triggerMethod 99 LEYDEN\n+ *\/\n+\n+import java.util.Arrays;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class LeydenEndTrainingTrigger {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"LeydenEndTrainingTriggerApp\";\n+    static final String vmCmdPrefix = \"-XX:AOTEndTrainingOnMethodEntry=\";\n+    static String triggerMethod = \"\";\n+    static int count = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+        if (args.length > 1) {\n+            triggerMethod = vmCmdPrefix + args[0];\n+            args = Arrays.copyOfRange(args, 1, args.length);\n+        }\n+        if (args.length == 2) {\n+            triggerMethod += \",count=\" + args[0];\n+            count = Integer.parseInt(args[0]);\n+            args = Arrays.copyOfRange(args, 1, args.length);\n+        }\n+        t.run(args);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass, runMode.name()\n+            };\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.TRAINING && triggerMethod.length() > 0) {\n+                return new String[] { triggerMethod };\n+            }\n+            return new String[] {};\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            if (!runMode.isStaticDump()) {\n+                \/\/ always expect this output\n+                out.shouldContain(\"LeydenEndTrainingTriggerApp_line_1\");\n+                out.shouldContain(\"LeydenEndTrainingTriggerApp_line_2\");\n+                out.shouldContain(\"LeydenEndTrainingTriggerApp_line_3\");\n+            }\n+            if (runMode == RunMode.TRAINING) {\n+                \/\/ in training mode we expect the dump to be triggered\n+                \/\/ count controls where in the application output the dump occurs\n+                \/\/ so we test that the counts worked as expected (even the case where no trigger was specified)\n+                var lines = out.asLines();\n+                \/\/ find the line number that contains \"CacheDataStore dumping is complete\"\n+                var dumpComplete = lines.indexOf(\"CacheDataStore dumping is complete\");\n+                Asserts.assertNE(dumpComplete, -1, \"CacheDataStore dumping is complete not found\");\n+                var line1 = lines.indexOf(\"LeydenEndTrainingTriggerApp_line_1\");\n+                var line2 = lines.indexOf(\"LeydenEndTrainingTriggerApp_line_2\");\n+                var line3 = lines.indexOf(\"LeydenEndTrainingTriggerApp_line_3\");\n+\n+                if (triggerMethod.length() == 0) {\n+                    \/\/ no trigger, so dump should run after execution\n+                    Asserts.assertGT(dumpComplete, line3, \"dump \");\n+                } else {\n+                    switch(count) {\n+                        case 0:\n+                            \/\/ no count specified, default is 1 (ie first trigger)\n+                            Asserts.assertLT(dumpComplete, line1, \"dumpComplete should be before line 1 of application output\");\n+                            break;\n+                        case 1:\n+                            Asserts.assertLT(dumpComplete, line1, \"dumpComplete should be before line 1 of application output\");\n+                            break;\n+                        case 2:\n+                            Asserts.assertGT(dumpComplete, line1, \"dumpComplete should be after line 1 of application output\");\n+                            Asserts.assertLT(dumpComplete, line2, \"dumpComplete should be before line 2 of application output\");\n+                            break;\n+                        case 3:\n+                            Asserts.assertGT(dumpComplete, line2, \"dumpComplete should be after line 2 of application output\");\n+                            Asserts.assertLT(dumpComplete, line3, \"dumpComplete should be before line 3 of application output\");\n+                            break;\n+                        default:\n+                            Asserts.assertGT(dumpComplete, line3, \"dumpComplete should be after line 3 of application output\");\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+class LeydenEndTrainingTriggerApp {\n+    public static void triggerMethod(String text) {\n+        System.out.println(\"LeydenEndTrainingTriggerApp_line_\" + text);\n+    }\n+    public static void main(String args[]) {\n+        triggerMethod(\"1\");\n+        triggerMethod(\"2\");\n+        triggerMethod(\"3\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/leyden\/LeydenEndTrainingTrigger.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"}]}