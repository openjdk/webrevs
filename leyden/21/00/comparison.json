{"files":[{"patch":"@@ -162,0 +162,7 @@\n+By default, training runs end when the application terminates.  You have two other options to end training runs:\n+\n+- -XX:AOTEndTrainingOnMethodEntry=<method1,method2,...>[,count=100]\n+- jcmd \\<pid> AOT.end_training\n+\n+Note that AOTEndTrainingOnMethodEntry uses the same format as CompileOnly and the default count is 1\n+\n","filename":"README.md","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -1401,0 +1402,7 @@\n+void InterpreterMacroAssembler::end_training_check() {\n+  if (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry) && CDSPreimage == nullptr) {\n+    \/\/ this code will be used for all methods of the same type and so we can't\n+    \/\/ check the method flag while generating the code\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::end_training_check));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -306,0 +306,3 @@\n+  \/\/ support for AOT\n+  void end_training_check();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1275,0 +1275,3 @@\n+  \/\/ AOT training run support\n+  __ end_training_check();\n+\n@@ -1724,0 +1727,3 @@\n+  \/\/ AOT training run support\n+  __ end_training_check();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -1933,0 +1934,6 @@\n+void InterpreterMacroAssembler::end_training_check() {\n+  if (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry) && CDSPreimage == nullptr) {\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::end_training_check));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -276,0 +276,3 @@\n+  \/\/ support for AOT\n+  void end_training_check();\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -916,0 +916,3 @@\n+  \/\/ AOT training run support\n+  __ end_training_check();\n+\n@@ -1471,0 +1474,3 @@\n+  \/\/ AOT training run support\n+  __ end_training_check();\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -4067,0 +4068,7 @@\n+  if (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry) && CDSPreimage == nullptr) {\n+    if(callee->is_end_training_trigger()) {\n+      Values* args = new Values(0);\n+      append(new RuntimeCall(voidType, \"end_training_check_c1\", CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c1), args));\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -2667,0 +2668,10 @@\n+  if (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry) && CDSPreimage == nullptr) {\n+    if(method()->is_end_training_trigger()) {\n+      BasicTypeList signature;\n+      signature.append(LP64_ONLY(T_LONG) NOT_LP64(T_INT));    \/\/ thread\n+      LIR_OprList* args = new LIR_OprList();\n+      args->append(getThreadPointer());\n+      call_runtime(&signature, args, CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c1), voidType, nullptr);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+  FUNCTION_CASE(entry, SharedRuntime::end_training_check_c1);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -200,7 +200,8 @@\n-  bool caller_sensitive()       const { return get_Method()->caller_sensitive();       }\n-  bool force_inline()           const { return get_Method()->force_inline();           }\n-  bool dont_inline()            const { return get_Method()->dont_inline();            }\n-  bool intrinsic_candidate()    const { return get_Method()->intrinsic_candidate();    }\n-  bool is_static_initializer()  const { return get_Method()->is_static_initializer();  }\n-  bool changes_current_thread() const { return get_Method()->changes_current_thread(); }\n-  bool deprecated()             const { return is_loaded() && get_Method()->deprecated(); }\n+  bool caller_sensitive()        const { return get_Method()->caller_sensitive();       }\n+  bool force_inline()            const { return get_Method()->force_inline();           }\n+  bool dont_inline()             const { return get_Method()->dont_inline();            }\n+  bool intrinsic_candidate()     const { return get_Method()->intrinsic_candidate();    }\n+  bool is_static_initializer()   const { return get_Method()->is_static_initializer();  }\n+  bool changes_current_thread()  const { return get_Method()->changes_current_thread(); }\n+  bool deprecated()              const { return is_loaded() && get_Method()->deprecated(); }\n+  bool is_end_training_trigger() const { return get_Method()->is_end_training_trigger(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -517,4 +517,5 @@\n-  Method* method       () const { return _method; }\n-  bool is_native_method() const { return _method != nullptr && _method->is_native(); }\n-  bool is_java_method  () const { return _method != nullptr && !_method->is_native(); }\n-  bool is_osr_method   () const { return _entry_bci != InvocationEntryBci; }\n+  Method* method              () const { return _method; }\n+  bool is_native_method       () const { return _method != nullptr && _method->is_native(); }\n+  bool is_java_method         () const { return _method != nullptr && !_method->is_native(); }\n+  bool is_osr_method          () const { return _entry_bci != InvocationEntryBci; }\n+  bool is_end_training_trigger() const { return _method != nullptr && _method->is_end_training_trigger(); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -501,0 +502,4 @@\n+bool CompilerOracle::should_trigger_end_of_training_at(const methodHandle& method) {\n+  return check_predicate(CompileCommandEnum::EndTrainingOnEnter, method);\n+}\n+\n@@ -1130,0 +1135,5 @@\n+  if (CDSPreimage == nullptr) {\n+    if (!CompilerOracle::parse_from_string(AOTEndTrainingOnMethodEntry, CompilerOracle::parse_aot_trigger)) {\n+      success = false;\n+    }\n+  }\n@@ -1150,1 +1160,1 @@\n-bool CompilerOracle::parse_compile_only(char* line) {\n+bool CompilerOracle::parse_for_command(char* line, CompileCommandEnum command, const char* error_prefix, uint* count) {\n@@ -1164,4 +1174,14 @@\n-      TypedMethodOptionMatcher* matcher = TypedMethodOptionMatcher::parse_method_pattern(method_pattern, error_buf, sizeof(error_buf));\n-      if (matcher != nullptr) {\n-        register_command(matcher, CompileCommandEnum::CompileOnly, true);\n-        continue;\n+      \/\/ if method pattern starts with count=, then parse the count\n+      if (count != nullptr && strncmp(method_pattern, \"count=\", 6) == 0) {\n+        int number = atoi(method_pattern + 6);\n+        if (number > 0) {\n+          *count = (uint)number;\n+          continue;\n+        }\n+        strcpy(error_buf, \"count must be a valid integer > 0\");\n+      } else {\n+        TypedMethodOptionMatcher* matcher = TypedMethodOptionMatcher::parse_method_pattern(method_pattern, error_buf, sizeof(error_buf));\n+        if (matcher != nullptr) {\n+          register_command(matcher, command, true);\n+          continue;\n+        }\n@@ -1171,1 +1191,1 @@\n-    tty->print_cr(\"CompileOnly: An error occurred during parsing\");\n+    tty->print_cr(\"%s: An error occurred during parsing\", error_prefix);\n@@ -1181,0 +1201,13 @@\n+bool CompilerOracle::parse_compile_only(char* line) {\n+  return parse_for_command(line, CompileCommandEnum::CompileOnly, \"CompileOnly\");\n+}\n+\n+bool CompilerOracle::parse_aot_trigger(char* line) {\n+  uint count = 0;\n+  bool result = parse_for_command(line, CompileCommandEnum::EndTrainingOnEnter, \"AOTEndTrainingOnMethodEntry\", &count);\n+  if (result && count > 0) {\n+    SharedRuntime::set_end_training_predicate(count);\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  option(EndTrainingOnEnter, \"EndTrainingOnEnter\", Bool) \\\n@@ -136,0 +137,3 @@\n+  \/\/ Shared for parsing CompileOnly and AOTTrigger\n+  static bool parse_for_command(char* line, CompileCommandEnum command, const char* error_prefix, uint* count = nullptr);\n+\n@@ -169,0 +173,3 @@\n+  \/\/ Tells whether to 'trigger end of training' when executing method\n+  static bool should_trigger_end_of_training_at(const methodHandle& method);\n+\n@@ -197,0 +204,1 @@\n+  static bool parse_aot_trigger(char* line);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -305,0 +305,3 @@\n+  product(ccstrlist, AOTEndTrainingOnMethodEntry, \"\",                       \\\n+          \"List of methods (pkg\/class.name) to trigger end of AOT \"         \\\n+          \"training run.  Optional ',count=N' where N is > 0\")              \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1159,0 +1159,10 @@\n+JRT_ENTRY(void, InterpreterRuntime::end_training_check(JavaThread* current)) {\n+  LastFrameAccessor last_frame(current);\n+  ResourceMark rm(current);\n+  methodHandle m (current, last_frame.method());\n+  if(m->is_end_training_trigger()) {\n+    SharedRuntime::end_training_check(CHECK);\n+  }\n+}\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+  static void end_training_check(JavaThread* current);\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -85,0 +86,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -1077,0 +1079,3 @@\n+  ResourceMark rm(THREAD);\n+\n+  bool addingAOTTriggers = (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry)) && CDSPreimage == nullptr;\n@@ -1082,0 +1087,4 @@\n+    if (addingAOTTriggers && CompilerOracle::should_trigger_end_of_training_at(m)) {\n+      m->set_is_end_training_trigger(true);\n+    }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+   status(is_end_training_trigger     , 1 << 17) \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -674,0 +674,3 @@\n+  \/\/---------------- AOT support --------------------\n+  void make_end_training_check();\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -1210,0 +1211,6 @@\n+  if (!FLAG_IS_DEFAULT(AOTEndTrainingOnMethodEntry) && CDSPreimage == nullptr) {\n+    if (method()->is_end_training_trigger()) {\n+      make_end_training_check();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,18 @@\n+void GraphKit::make_end_training_check() {\n+  const TypeFunc *call_type    = OptoRuntime::end_training_check_c2_Type();\n+  address         call_address = CAST_FROM_FN_PTR(address, SharedRuntime::end_training_check_c2);\n+  const char     *call_name    = \"end_training_check_c2\";\n+\n+  \/\/ Get base of thread-local storage area\n+  Node* thread = _gvn.transform( new ThreadLocalNode() );\n+\n+  kill_dead_locals();\n+\n+  \/\/ For some reason, this call reads only raw memory.\n+  const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n+  make_runtime_call(RC_LEAF | RC_NARROW_MEM,\n+                    call_type, call_address,\n+                    call_name, raw_adr_type,\n+                    thread);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1819,0 +1819,16 @@\n+\/\/-----------------------------------------------------------------------------\n+\/\/ AOT\n+const TypeFunc *OptoRuntime::end_training_check_c2_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; \/\/ Thread-local storage\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -316,0 +316,3 @@\n+  \/\/ AOT\n+  static const TypeFunc* end_training_check_c2_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,0 +250,5 @@\n+\/\/ For AOT\n+uint volatile SharedRuntime::_end_training_count = 0;\n+uint          SharedRuntime::_end_training_predicate = 1;\n+int  volatile SharedRuntime::_end_training_triggered = 0;\n+\n@@ -1400,0 +1405,44 @@\n+JRT_BLOCK_ENTRY(void, SharedRuntime::end_training_check_c1(JavaThread* current))\n+{\n+  JRT_BLOCK\n+    SharedRuntime::end_training_check(CHECK);\n+  JRT_BLOCK_END\n+}\n+JRT_END\n+\n+JRT_BLOCK_ENTRY(void, SharedRuntime::end_training_check_c2(JavaThread* current))\n+{\n+  JRT_BLOCK\n+    SharedRuntime::end_training_check(CHECK);\n+  JRT_BLOCK_END\n+}\n+JRT_END\n+\n+void SharedRuntime::end_training_check(TRAPS)\n+{\n+  Atomic::inc(&_end_training_count);\n+  if(_end_training_count >= _end_training_predicate)\n+  {\n+    SharedRuntime::end_training(CHECK);\n+  }\n+}\n+\n+void SharedRuntime::end_training(TRAPS)\n+{\n+  \/\/ This should only execute once\n+  if (Atomic::cmpxchg(&_end_training_triggered, 0, 1) == 0) {\n+    JavaThread* current = THREAD;\n+    ResourceMark rm(current);\n+    Symbol* system_name  = vmSymbols::java_lang_System();\n+    Klass*  system_klass = SystemDictionary::resolve_or_fail(system_name, true \/*throw error*\/,  CHECK);\n+    JavaValue result(T_OBJECT);\n+    JavaCallArguments args;\n+    args.push_int(0);\n+    JavaCalls::call_static(&result,\n+                          system_klass,\n+                          vmSymbols::exit_method_name(),\n+                          vmSymbols::int_void_signature(),\n+                          &args, CHECK);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -348,0 +348,7 @@\n+  \/\/ AOT support\n+  static void end_training_check_c1(JavaThread* current);\n+  static void end_training_check_c2(JavaThread* current);\n+  static void end_training_check(TRAPS);\n+  static void end_training(TRAPS);\n+  static void set_end_training_predicate(uint predicate) { Atomic::store(&_end_training_predicate, predicate); }\n+\n@@ -349,0 +356,6 @@\n+\n+  \/\/ AOT\n+  static uint volatile _end_training_count;\n+  static uint          _end_training_predicate;\n+  static int  volatile _end_training_triggered;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<AOTEndTrainingDCmd>(full_export, true, false));\n@@ -994,0 +995,4 @@\n+void AOTEndTrainingDCmd::execute(DCmdSource source, TRAPS) {\n+  SharedRuntime::end_training(CHECK);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -398,0 +398,18 @@\n+class AOTEndTrainingDCmd : public DCmd {\n+public:\n+  AOTEndTrainingDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"AOT.end_training\"; }\n+    static const char* description() {\n+      return \"End AOT training and create the cache.\";\n+    }\n+    static const char* impact() {\n+      return \"High: [insert reason here]\";\n+    }\n+    static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+      return p;\n+    }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}