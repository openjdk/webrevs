{"files":[{"patch":"@@ -265,1 +265,1 @@\n-    if (AOTCodeCache::is_code_load_thread_on() && !StoreCachedCode) {\n+    if (AOTCodeCache::is_code_load_thread_on() && !AOTCodeCache::is_dumping_code()) {\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotCacheAccess.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+\n+size_t _aot_code_region_size = 0;\n+\n+bool AOTCacheAccess::can_generate_aot_code(address addr) {\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    return ArchiveBuilder::is_active() && ArchiveBuilder::current()->has_been_archived(addr);\n+  } else {\n+    \/\/ Old CDS+AOT workflow.\n+    return MetaspaceShared::is_in_shared_metaspace(addr);\n+  }\n+}\n+\n+bool AOTCacheAccess::can_generate_aot_code(InstanceKlass* ik) {\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    if (!ArchiveBuilder::is_active()) {\n+      return false;\n+    }\n+    ArchiveBuilder* builder = ArchiveBuilder::current();\n+    if (!builder->has_been_archived((address)ik)) {\n+      return false;\n+    }\n+    InstanceKlass* buffered_ik = builder->get_buffered_addr(ik);\n+    if (ik->is_shared_unregistered_class()) {\n+      return false;\n+    }\n+    return true;\n+  } else {\n+    \/\/ Old CDS+AOT workflow.\n+    return ik->is_shared() && !ik->is_shared_unregistered_class();\n+  }\n+}\n+\n+uint AOTCacheAccess::delta_from_shared_address_base(address addr) {\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    assert(ArchiveBuilder::is_active(), \"must be\");\n+    ArchiveBuilder* builder = ArchiveBuilder::current();\n+    address requested_addr = builder->to_requested(builder->get_buffered_addr(addr));\n+    return (uint)pointer_delta(requested_addr, (address)SharedBaseAddress, 1);\n+  } else {\n+    \/\/ Old CDS+AOT workflow.\n+    return (uint)pointer_delta(addr, (address)SharedBaseAddress, 1);\n+  }\n+}\n+\n+Method* AOTCacheAccess::method_in_aot_code(Method* m) {\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    assert(ArchiveBuilder::is_active(), \"must be\");\n+    ArchiveBuilder* builder = ArchiveBuilder::current();\n+    return builder->to_requested(builder->get_buffered_addr(m));\n+  } else {\n+    \/\/ Old CDS+AOT workflow.\n+    return m;\n+  }\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+int AOTCacheAccess::get_archived_object_permanent_index(oop obj) {\n+  return HeapShared::get_archived_object_permanent_index(obj);\n+}\n+\n+oop AOTCacheAccess::get_archived_object(int permanent_index) {\n+  oop o = HeapShared::get_archived_object(permanent_index);\n+  assert(oopDesc::is_oop_or_null(o), \"sanity\");\n+  return o;\n+}\n+\n+static void test_cds_heap_access_api_for_object(oop obj) {\n+  LogStreamHandle(Info, cds, jit) log;\n+\n+  obj->print_on(&log);\n+  log.cr();\n+\n+  int n = AOTCacheAccess::get_archived_object_permanent_index(obj); \/\/ call this when AOTCodeCaching is on\n+  if (n < 0) {\n+    log.print_cr(\"*** This object is not in CDS archive\");\n+  } else {\n+    log.print_cr(\"AOTCacheAccess::get_archived_object_permanent_index(s) = %d\", n);\n+    oop archived_obj = AOTCacheAccess::get_archived_object(n); \/\/ call this when AOTCodeCaching is on\n+    if (archived_obj == obj || archived_obj == HeapShared::orig_to_scratch_object(obj)) {\n+      log.print_cr(\"AOTCacheAccess::get_archived_object(%d) returns the same object, as expected\", n);\n+    } else {\n+      log.print_cr(\"Error!!! AOTCacheAccess::get_archived_object(%d) returns an unexpected object\", n);\n+      if (archived_obj == nullptr) {\n+        log.print_cr(\"--> null\");\n+      } else {\n+        archived_obj->print_on(&log);\n+        log.cr();\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ TEMP: examples for using the AOTCacheAccess::get_archived_object_permanent_index() and AOTCacheAccess::get_archived_object()\n+\/\/ APIs for the AOT compiler.\n+\n+void AOTCacheAccess::test_heap_access_api() {\n+  ResourceMark rm;\n+  const char* tests[] = {\n+    \"\",\n+    \"null\",\n+    \"NARROW\",\n+    \"not in cds\",\n+    nullptr,\n+  };\n+\n+  LogStreamHandle(Info, cds, jit) log;\n+\n+  int i;\n+  for (i = 0; tests[i] != nullptr; i++) {\n+    EXCEPTION_MARK;\n+    log.print_cr(\"Test %d ======================================== \\\"%s\\\"\", i, tests[i]);\n+    oop s = StringTable::intern(tests[i], CHECK);\n+    test_cds_heap_access_api_for_object(s);\n+  }\n+\n+  log.print_cr(\"Test %d ======================================== Universe::null_ptr_exception_instance()\", i);\n+  test_cds_heap_access_api_for_object(Universe::null_ptr_exception_instance());\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+\n+\/\/ new workflow only\n+void* AOTCacheAccess::allocate_from_code_cache(size_t size) {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+  return (void*)ArchiveBuilder::cc_region_alloc(size);\n+}\n+\n+size_t AOTCacheAccess::get_aot_code_region_size() {\n+  return _aot_code_region_size;\n+}\n+\n+void AOTCacheAccess::set_aot_code_region_size(size_t sz) {\n+  _aot_code_region_size = sz;\n+}\n+\n+bool AOTCacheAccess::is_aot_code_region_empty() {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+  return ArchiveBuilder::current()->cc_region()->is_empty();\n+}\n+\n+bool AOTCacheAccess::map_aot_code(ReservedSpace rs) {\n+  FileMapInfo* static_mapinfo = FileMapInfo::current_info();\n+  assert(UseSharedSpaces && static_mapinfo != nullptr, \"must be\");\n+  return static_mapinfo->map_aot_code_region(rs);\n+}\n+\n+void AOTCacheAccess::set_pointer(address* ptr, address value) {\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  if (value != nullptr && !builder->is_in_buffer_space(value)) {\n+    value = builder->get_buffered_addr(value);\n+  }\n+  *ptr = value;\n+  ArchivePtrMarker::mark_pointer(ptr);\n+}\n","filename":"src\/hotspot\/share\/cds\/aotCacheAccess.cpp","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCACHEACCESS_HPP\n+#define SHARE_CDS_AOTCACHEACCESS_HPP\n+\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class InstanceKlass;\n+class Klass;\n+class Method;\n+class ReservedSpace;\n+\n+class AOTCacheAccess : AllStatic {\n+private:\n+  static bool can_generate_aot_code(address addr) NOT_CDS_RETURN_(false);\n+public:\n+  static bool can_generate_aot_code(Method* m) {\n+    return can_generate_aot_code((address)m);\n+  }\n+  static bool can_generate_aot_code(Klass* k) {\n+    return can_generate_aot_code((address)k);\n+  }\n+  static bool can_generate_aot_code(InstanceKlass* ik) NOT_CDS_RETURN_(false);\n+\n+  static uint delta_from_shared_address_base(address addr);\n+  static Method* method_in_aot_code(Method* m) NOT_CDS_RETURN_(nullptr);\n+\n+  static int get_archived_object_permanent_index(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(-1);\n+  static oop get_archived_object(int permanent_index) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+\n+  static void test_heap_access_api() NOT_CDS_JAVA_HEAP_RETURN;\n+\n+  static void* allocate_from_code_cache(size_t size) NOT_CDS_RETURN_(nullptr);\n+\n+  static size_t get_aot_code_region_size() NOT_CDS_RETURN_(0);\n+  static void set_aot_code_region_size(size_t sz) NOT_CDS_RETURN;\n+\n+  static bool is_aot_code_region_empty() NOT_CDS_RETURN_(true);\n+  static bool map_aot_code(ReservedSpace rs) NOT_CDS_RETURN_(false);\n+\n+  template <typename T>\n+  static void set_pointer(T** ptr, T* value) {\n+    set_pointer((address*)ptr, (address)value);\n+  }\n+  static void set_pointer(address* ptr, address value);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCACHEACCESS_HPP\n","filename":"src\/hotspot\/share\/cds\/aotCacheAccess.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCacheAccess.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/cdsAccess.hpp\"\n@@ -121,1 +121,1 @@\n-    CDSAccess::test_heap_access_api();\n+    AOTCacheAccess::test_heap_access_api();\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"cds\/archiveBuilder.hpp\"\n-#include \"cds\/cdsAccess.hpp\"\n-#include \"cds\/cdsConfig.hpp\"\n-#include \"cds\/filemap.hpp\"\n-#include \"cds\/heapShared.hpp\"\n-#include \"cds\/metaspaceShared.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"memory\/virtualspace.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-\n-size_t _cached_code_size = 0;\n-\n-bool CDSAccess::can_generate_cached_code(address addr) {\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    return ArchiveBuilder::is_active() && ArchiveBuilder::current()->has_been_archived(addr);\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return MetaspaceShared::is_in_shared_metaspace(addr);\n-  }\n-}\n-\n-bool CDSAccess::can_generate_cached_code(InstanceKlass* ik) {\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    if (!ArchiveBuilder::is_active()) {\n-      return false;\n-    }\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    if (!builder->has_been_archived((address)ik)) {\n-      return false;\n-    }\n-    InstanceKlass* buffered_ik = builder->get_buffered_addr(ik);\n-    if (ik->is_shared_unregistered_class()) {\n-      return false;\n-    }\n-    return true;\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return ik->is_shared() && !ik->is_shared_unregistered_class();\n-  }\n-}\n-\n-uint CDSAccess::delta_from_shared_address_base(address addr) {\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    assert(ArchiveBuilder::is_active(), \"must be\");\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    address requested_addr = builder->to_requested(builder->get_buffered_addr(addr));\n-    return (uint)pointer_delta(requested_addr, (address)SharedBaseAddress, 1);\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return (uint)pointer_delta(addr, (address)SharedBaseAddress, 1);\n-  }\n-}\n-\n-Method* CDSAccess::method_in_cached_code(Method* m) {\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    assert(ArchiveBuilder::is_active(), \"must be\");\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    return builder->to_requested(builder->get_buffered_addr(m));\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return m;\n-  }\n-}\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-int CDSAccess::get_archived_object_permanent_index(oop obj) {\n-  return HeapShared::get_archived_object_permanent_index(obj);\n-}\n-\n-oop CDSAccess::get_archived_object(int permanent_index) {\n-  oop o = HeapShared::get_archived_object(permanent_index);\n-  assert(oopDesc::is_oop_or_null(o), \"sanity\");\n-  return o;\n-}\n-\n-static void test_cds_heap_access_api_for_object(oop obj) {\n-  LogStreamHandle(Info, cds, jit) log;\n-\n-  obj->print_on(&log);\n-  log.cr();\n-\n-  int n = CDSAccess::get_archived_object_permanent_index(obj); \/\/ call this when -XX:+StoreCachedCode\n-  if (n < 0) {\n-    log.print_cr(\"*** This object is not in CDS archive\");\n-  } else {\n-    log.print_cr(\"CDSAccess::get_archived_object_permanent_index(s) = %d\", n);\n-    oop archived_obj = CDSAccess::get_archived_object(n); \/\/ call this when -XX:+LoadCachedCode\n-    if (archived_obj == obj || archived_obj == HeapShared::orig_to_scratch_object(obj)) {\n-      log.print_cr(\"CDSAccess::get_archived_object(%d) returns the same object, as expected\", n);\n-    } else {\n-      log.print_cr(\"Error!!! CDSAccess::get_archived_object(%d) returns an unexpected object\", n);\n-      if (archived_obj == nullptr) {\n-        log.print_cr(\"--> null\");\n-      } else {\n-        archived_obj->print_on(&log);\n-        log.cr();\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ TEMP: examples for using the CDSAccess::get_archived_object_permanent_index() and CDSAccess::get_archived_object()\n-\/\/ APIs for the AOT compiler.\n-\n-void CDSAccess::test_heap_access_api() {\n-  ResourceMark rm;\n-  const char* tests[] = {\n-    \"\",\n-    \"null\",\n-    \"NARROW\",\n-    \"not in cds\",\n-    nullptr,\n-  };\n-\n-  LogStreamHandle(Info, cds, jit) log;\n-\n-  int i;\n-  for (i = 0; tests[i] != nullptr; i++) {\n-    EXCEPTION_MARK;\n-    log.print_cr(\"Test %d ======================================== \\\"%s\\\"\", i, tests[i]);\n-    oop s = StringTable::intern(tests[i], CHECK);\n-    test_cds_heap_access_api_for_object(s);\n-  }\n-\n-  log.print_cr(\"Test %d ======================================== Universe::null_ptr_exception_instance()\", i);\n-  test_cds_heap_access_api_for_object(Universe::null_ptr_exception_instance());\n-}\n-\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-\n-\/\/ new workflow only\n-void* CDSAccess::allocate_from_code_cache(size_t size) {\n-  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n-  return (void*)ArchiveBuilder::cc_region_alloc(size);\n-}\n-\n-size_t CDSAccess::get_cached_code_size() {\n-  return _cached_code_size;\n-}\n-\n-void CDSAccess::set_cached_code_size(size_t sz) {\n-  _cached_code_size = sz;\n-}\n-\n-bool CDSAccess::is_cached_code_region_empty() {\n-  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n-  return ArchiveBuilder::current()->cc_region()->is_empty();\n-}\n-\n-bool CDSAccess::map_cached_code(ReservedSpace rs) {\n-  FileMapInfo* static_mapinfo = FileMapInfo::current_info();\n-  assert(UseSharedSpaces && static_mapinfo != nullptr, \"must be\");\n-  return static_mapinfo->map_cached_code_region(rs);\n-}\n-\n-void CDSAccess::set_pointer(address* ptr, address value) {\n-  ArchiveBuilder* builder = ArchiveBuilder::current();\n-  if (value != nullptr && !builder->is_in_buffer_space(value)) {\n-    value = builder->get_buffered_addr(value);\n-  }\n-  *ptr = value;\n-  ArchivePtrMarker::mark_pointer(ptr);\n-}\n","filename":"src\/hotspot\/share\/cds\/cdsAccess.cpp","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CDS_CDSACCESS_HPP\n-#define SHARE_CDS_CDSACCESS_HPP\n-\n-#include \"cds\/archiveBuilder.hpp\"\n-#include \"cds\/archiveUtils.hpp\"\n-#include \"memory\/allStatic.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class InstanceKlass;\n-class Klass;\n-class Method;\n-class ReservedSpace;\n-\n-class CDSAccess : AllStatic {\n-private:\n-  static bool can_generate_cached_code(address addr) NOT_CDS_RETURN_(false);\n-public:\n-  static bool can_generate_cached_code(Method* m) {\n-    return can_generate_cached_code((address)m);\n-  }\n-  static bool can_generate_cached_code(Klass* k) {\n-    return can_generate_cached_code((address)k);\n-  }\n-  static bool can_generate_cached_code(InstanceKlass* ik) NOT_CDS_RETURN_(false);\n-\n-  static uint delta_from_shared_address_base(address addr);\n-  static Method* method_in_cached_code(Method* m) NOT_CDS_RETURN_(nullptr);\n-\n-  static int get_archived_object_permanent_index(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(-1);\n-  static oop get_archived_object(int permanent_index) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-\n-  static void test_heap_access_api() NOT_CDS_JAVA_HEAP_RETURN;\n-\n-  static void* allocate_from_code_cache(size_t size) NOT_CDS_RETURN_(nullptr);\n-\n-  static size_t get_cached_code_size() NOT_CDS_RETURN_(0);\n-  static void set_cached_code_size(size_t sz) NOT_CDS_RETURN;\n-\n-  static bool is_cached_code_region_empty() NOT_CDS_RETURN_(true);\n-  static bool map_cached_code(ReservedSpace rs) NOT_CDS_RETURN_(false);\n-\n-  template <typename T>\n-  static void set_pointer(T** ptr, T* value) {\n-    set_pointer((address*)ptr, (address)value);\n-  }\n-  static void set_pointer(address* ptr, address value);\n-};\n-\n-#endif \/\/ SHARE_CDS_CDSACCESS_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsAccess.hpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -645,2 +646,1 @@\n-      FLAG_SET_ERGO(StoreCachedCode, false);\n-      FLAG_SET_ERGO(LoadCachedCode, false);\n+      AOTCodeCache::disable_caching();\n@@ -650,5 +650,0 @@\n-  if (StoreCachedCode) {\n-    log_info(cds)(\"ArchiveAdapters is enabled\");\n-    FLAG_SET_ERGO_IF_DEFAULT(ArchiveAdapters, true);\n-  }\n-\n@@ -746,2 +741,1 @@\n-    FLAG_SET_ERGO(StoreCachedCode, false);\n-    FLAG_SET_ERGO(LoadCachedCode, false);\n+    AOTCodeCache::disable_caching();\n@@ -752,3 +746,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(StoreCachedCode, true);\n-    FLAG_SET_ERGO(LoadCachedCode, false);\n-    disable_dumping_cached_code(); \/\/ Cannot dump cached code until metadata and heap are dumped.\n+    AOTCodeCache::enable_caching();\n+    disable_dumping_aot_code(); \/\/ Cannot dump cached code until metadata and heap are dumped.\n@@ -759,2 +752,1 @@\n-    FLAG_SET_ERGO(StoreCachedCode, false);\n-    FLAG_SET_ERGO_IF_DEFAULT(LoadCachedCode, true);\n+    AOTCodeCache::enable_caching();\n@@ -769,2 +761,1 @@\n-    FLAG_SET_ERGO(StoreCachedCode, false);\n-    FLAG_SET_ERGO(LoadCachedCode, false);\n+    AOTCodeCache::disable_caching();\n@@ -808,1 +799,1 @@\n-      FLAG_SET_ERGO_IF_DEFAULT(LoadCachedCode, true);\n+      AOTCodeCache::enable_caching();\n@@ -849,2 +840,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(StoreCachedCode, true);\n-    if (StoreCachedCode) {\n+    AOTCodeCache::enable_caching(); \/\/ Update default settings\n+    if (AOTCodeCache::is_caching_enabled()) {\n@@ -852,1 +843,1 @@\n-      disable_dumping_cached_code();\n+      disable_dumping_aot_code();\n@@ -1181,1 +1172,1 @@\n-static bool _is_dumping_cached_code = true;\n+static bool _is_dumping_aot_code = true;\n@@ -1183,2 +1174,2 @@\n-bool CDSConfig::is_dumping_cached_code() {\n-  return _is_dumping_cached_code;\n+bool CDSConfig::is_dumping_aot_code() {\n+  return _is_dumping_aot_code;\n@@ -1187,2 +1178,2 @@\n-void CDSConfig::disable_dumping_cached_code() {\n-  _is_dumping_cached_code = false;\n+void CDSConfig::disable_dumping_aot_code() {\n+  _is_dumping_aot_code = false;\n@@ -1191,2 +1182,2 @@\n-void CDSConfig::enable_dumping_cached_code() {\n-  _is_dumping_cached_code = true;\n+void CDSConfig::enable_dumping_aot_code() {\n+  _is_dumping_aot_code = true;\n@@ -1196,1 +1187,1 @@\n-  return (ArchiveAdapters && is_dumping_final_static_archive());\n+  return (AOTAdapterCaching && is_dumping_final_static_archive());\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":19,"deletions":28,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -220,3 +220,3 @@\n-  static bool is_dumping_cached_code()                       NOT_CDS_RETURN_(false);\n-  static void disable_dumping_cached_code()                  NOT_CDS_RETURN;\n-  static void enable_dumping_cached_code()                   NOT_CDS_RETURN;\n+  static bool is_dumping_aot_code()                          NOT_CDS_RETURN_(false);\n+  static void disable_dumping_aot_code()                     NOT_CDS_RETURN;\n+  static void enable_dumping_aot_code()                      NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -178,0 +178,22 @@\n+  \/* AOT Code flags *\/                                                      \\\n+                                                                            \\\n+  product(bool, AOTCodeCaching, false, DIAGNOSTIC,                          \\\n+          \"Enable saving and restoring JIT comiled code in AOT cache\")      \\\n+                                                                            \\\n+  product(bool, AOTStubCaching, false, DIAGNOSTIC,                          \\\n+          \"Enable saving and restoring stubs and code blobs in AOT cache\")  \\\n+                                                                            \\\n+  product(bool, AOTAdapterCaching, false, DIAGNOSTIC,                       \\\n+          \"Enable saving and restoring i2c2i adapters in AOT cache\")        \\\n+                                                                            \\\n+  product(uint, AOTCodeMaxSize, 512*M, DIAGNOSTIC,                          \\\n+          \"Buffer size in bytes for AOT code caching\")                      \\\n+          range(1*M, max_jint)                                              \\\n+                                                                            \\\n+  product(bool, AbortVMOnAOTCodeFailure, false, DIAGNOSTIC,                 \\\n+          \"Abort VM on the first occurrence of AOT code load or store \"     \\\n+          \"failure. By default VM will continue execute without AOT code.\") \\\n+                                                                            \\\n+  develop(bool, TestAOTAdapterLinkFailure, false,                           \\\n+          \"Test failure of adapter linking when loading from AOT cache.\")   \\\n+                                                                            \\\n@@ -218,4 +240,0 @@\n-                                                                            \\\n-  product(bool, ArchiveAdapters, false,                                     \\\n-          \"Archive AdapterFingerPrint and AdapterHandlerEntry.\"             \\\n-          \"Requires AOT code cache\")                                        \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1293,1 +1293,1 @@\n-bool FileMapInfo::map_cached_code_region(ReservedSpace rs) {\n+bool FileMapInfo::map_aot_code_region(ReservedSpace rs) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-  bool map_cached_code_region(ReservedSpace rs);\n+  bool  map_aot_code_region(ReservedSpace rs);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCacheAccess.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"cds\/cdsAccess.hpp\"\n@@ -307,1 +307,1 @@\n-\/\/ and are accssed vis CDSAccess::get_archived_object(int).\n+\/\/ and are accssed vis AOTCacheAccess::get_archived_object(int).\n@@ -390,1 +390,1 @@\n-  int* table = (int*)CDSAccess::allocate_from_code_cache(count * sizeof(int));\n+  int* table = (int*)AOTCacheAccess::allocate_from_code_cache(count * sizeof(int));\n@@ -410,1 +410,1 @@\n-  CDSAccess::set_pointer(&_permanent_oop_offsets, table);\n+  AOTCacheAccess::set_pointer(&_permanent_oop_offsets, table);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCacheAccess.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"cds\/cdsAccess.hpp\"\n@@ -1078,1 +1078,1 @@\n-    if (StoreCachedCode) {\n+    if (AOTCodeCache::is_caching_enabled()) {\n@@ -1080,1 +1080,1 @@\n-        CDSAccess::test_heap_access_api();\n+        AOTCacheAccess::test_heap_access_api();\n@@ -1089,1 +1089,1 @@\n-      CDSConfig::enable_dumping_cached_code();\n+      CDSConfig::enable_dumping_aot_code();\n@@ -1097,1 +1097,1 @@\n-      CDSConfig::disable_dumping_cached_code();\n+      CDSConfig::disable_dumping_aot_code();\n@@ -1522,1 +1522,1 @@\n-    CDSAccess::set_cached_code_size(r->used_aligned());\n+    AOTCacheAccess::set_aot_code_region_size(r->used_aligned());\n@@ -2139,1 +2139,1 @@\n-    if (LoadCachedCode) {\n+    if (AOTCodeCache::is_dumping_code()) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"cds\/cdsAccess.hpp\"\n+#include \"cds\/aotCacheAccess.hpp\"\n@@ -120,3 +120,2 @@\n-static void exit_vm_on_load_failure() {\n-  \/\/ Treat AOTCodeCache warnings as error when RequireSharedSpaces is on.\n-  if (RequireSharedSpaces) {\n+static void load_failure() {\n+  if (AbortVMOnAOTCodeFailure) {\n@@ -125,0 +124,2 @@\n+  log_info(aot, codecache, init)(\"Unable to use AOT Code Cache.\");\n+  AOTCodeCache::disable_caching();\n@@ -127,5 +128,3 @@\n-static void exit_vm_on_store_failure() {\n-  \/\/ Treat AOTCodeCache warnings as error when RequireSharedSpaces is on.\n-  if (RequireSharedSpaces) {\n-    tty->print_cr(\"Unable to create startup cached code.\");\n-    \/\/ Failure during AOT code caching, we don't want to dump core\n+static void store_failure() {\n+  if (AbortVMOnAOTCodeFailure) {\n+    tty->print_cr(\"Unable to create AOT Code Cache.\");\n@@ -134,0 +133,2 @@\n+  log_info(aot, codecache, exit)(\"Unable to create AOT Code Cache.\");\n+  AOTCodeCache::disable_caching();\n@@ -136,0 +137,58 @@\n+\/\/ The sequence of AOT code caching flags and parametters settings.\n+\/\/\n+\/\/ 1. The initial AOT code caching flags setting is done\n+\/\/ during call to CDSConfig::check_vm_args_consistency().\n+\/\/\n+\/\/ 2. The earliest AOT code state check done in compilationPolicy_init()\n+\/\/ where we set number of compiler threads for AOT assembly phase.\n+\/\/\n+\/\/ 3. We determine presence of AOT code in AOT Cache in\n+\/\/ MetaspaceShared::open_static_archive() which is calles\n+\/\/ after compilationPolicy_init() but before codeCache_init().\n+\/\/\n+\/\/ 4. AOTCodeCache::initialize() is called during universe_init()\n+\/\/ and does final AOT state and flags settings.\n+\/\/\n+\/\/ 5. Finally AOTCodeCache::init2() is called after universe_init()\n+\/\/ when all GC settings are finalized.\n+\n+\/\/ Next methods determine which action we do with AOT code depending\n+\/\/ on phase of AOT process: assembly or production.\n+\n+bool AOTCodeCache::is_dumping_code() {\n+  return AOTCodeCaching && CDSConfig::is_dumping_final_static_archive();\n+}\n+bool AOTCodeCache::is_dumping_stub() {\n+  return AOTStubCaching && CDSConfig::is_dumping_final_static_archive();\n+}\n+bool AOTCodeCache::is_dumping_adapter() {\n+  return AOTAdapterCaching && CDSConfig::is_dumping_final_static_archive();\n+}\n+\n+bool AOTCodeCache::is_using_code() {\n+  return AOTCodeCaching && CDSConfig::is_using_archive();\n+}\n+bool AOTCodeCache::is_using_stub() {\n+  return AOTStubCaching && CDSConfig::is_using_archive();\n+}\n+bool AOTCodeCache::is_using_adapter() {\n+  return AOTAdapterCaching && CDSConfig::is_using_archive();\n+}\n+\n+void AOTCodeCache::enable_caching() {\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTCodeCaching, true);\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+}\n+\n+void AOTCodeCache::disable_caching() {\n+  FLAG_SET_ERGO(AOTCodeCaching, false);\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+  FLAG_SET_ERGO(AOTAdapterCaching, false);\n+}\n+\n+bool AOTCodeCache::is_caching_enabled() {\n+  return AOTCodeCaching || AOTStubCaching || AOTAdapterCaching;\n+}\n+\n+static uint _max_aot_code_size = 0;\n@@ -137,1 +196,1 @@\n-  return (uint)CachedCodeMaxSize;\n+  return _max_aot_code_size;\n@@ -140,0 +199,4 @@\n+\/\/ It is called from MetaspaceShared::initialize_shared_spaces()\n+\/\/ which is called from universe_init().\n+\/\/ At this point all AOT class linking seetings are finilized\n+\/\/ and AOT cache is open so we can map AOT code region.\n@@ -141,2 +204,17 @@\n-  if (LoadCachedCode && !UseSharedSpaces) {\n-    return;\n+  if (FLAG_IS_DEFAULT(AOTCache)) {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is not used: AOTCache is not specified.\");\n+    disable_caching();\n+    return; \/\/ AOTCache must be specified to dump and use AOT code\n+  }\n+  bool is_dumping = false;\n+  bool is_using   = false;\n+  if (CDSConfig::is_dumping_final_static_archive() && CDSConfig::is_dumping_aot_linked_classes()) {\n+    enable_caching();\n+    is_dumping = is_caching_enabled();\n+  } else if (CDSConfig::is_using_archive() && CDSConfig::is_using_aot_linked_classes()) {\n+    enable_caching();\n+    is_using = is_caching_enabled();\n+  } else {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is not used: AOT Class Linking is not used.\");\n+    disable_caching();\n+    return; \/\/ nothing to do\n@@ -144,3 +222,3 @@\n-  if (LoadCachedCode && CDSAccess::get_cached_code_size() == 0) {\n-    LoadCachedCode = false;\n-    return;\n+  if (!(is_dumping || is_using)) {\n+    disable_caching();\n+    return; \/\/ AOT code caching disabled on command line\n@@ -148,1 +226,1 @@\n-  if (StoreCachedCode || LoadCachedCode) {\n+  if (AOTCodeCaching) {\n@@ -150,1 +228,1 @@\n-      FLAG_SET_DEFAULT(ClassInitBarrierMode, 1);\n+      FLAG_SET_ERGO(ClassInitBarrierMode, 1);\n@@ -153,2 +231,2 @@\n-    log_info(aot, codecache, init)(\"Set ClassInitBarrierMode to 0 because StoreCachedCode and LoadCachedCode are false.\");\n-    FLAG_SET_DEFAULT(ClassInitBarrierMode, 0);\n+    log_info(aot, codecache, init)(\"Set ClassInitBarrierMode to 0 because AOTCodeCaching is false.\");\n+    FLAG_SET_ERGO(ClassInitBarrierMode, 0);\n@@ -156,4 +234,6 @@\n-  if (LoadCachedCode || StoreCachedCode) {\n-    if (!open_cache()) {\n-      exit_vm_on_load_failure();\n-      return;\n+  \/\/ Reserve AOT Cache region when we dumping AOT code.\n+  _max_aot_code_size = AOTCodeMaxSize;\n+  if (is_dumping && !FLAG_IS_DEFAULT(AOTCodeMaxSize)) {\n+    if (!is_aligned(AOTCodeMaxSize, os::vm_allocation_granularity())) {\n+      _max_aot_code_size = align_up(AOTCodeMaxSize, os::vm_allocation_granularity());\n+      log_debug(aot,codecache,init)(\"Max AOT Code Cache size is aligned up to %uK\", (int)(max_aot_code_size()\/K));\n@@ -161,3 +241,12 @@\n-    if (StoreCachedCode) {\n-      FLAG_SET_DEFAULT(FoldStableValues, false);\n-      FLAG_SET_DEFAULT(ForceUnreachable, true);\n+  }\n+  size_t aot_code_size = is_using ? AOTCacheAccess::get_aot_code_region_size() : 0;\n+  if (is_using && aot_code_size == 0) {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is empty\");\n+    disable_caching();\n+    return;\n+  }\n+  if (!open_cache(is_dumping, is_using)) {\n+    if (is_using) {\n+      load_failure();\n+    } else {\n+      store_failure();\n@@ -165,1 +254,5 @@\n-    FLAG_SET_DEFAULT(DelayCompilerStubsGeneration, false);\n+    return;\n+  }\n+  if (is_dumping) {\n+    FLAG_SET_DEFAULT(FoldStableValues, false);\n+    FLAG_SET_DEFAULT(ForceUnreachable, true);\n@@ -167,0 +260,1 @@\n+  FLAG_SET_DEFAULT(DelayCompilerStubsGeneration, false);\n@@ -169,0 +263,1 @@\n+\/\/ It is called after universe_init() when all GC settings are finalized.\n@@ -181,1 +276,2 @@\n-      exit_vm_on_load_failure();\n+      load_failure();\n+      return;\n@@ -184,3 +280,0 @@\n-  \/\/ initialize aot runtime constants as appropriate to this runtime\n-  AOTRuntimeConstants::initialize_from_runtime();\n-\n@@ -189,1 +282,2 @@\n-    exit_vm_on_load_failure();\n+    load_failure();\n+    return;\n@@ -192,0 +286,2 @@\n+  \/\/ initialize aot runtime constants as appropriate to this runtime\n+  AOTRuntimeConstants::initialize_from_runtime();\n@@ -201,1 +297,1 @@\n-  if (LoadCachedCode) {\n+  if (is_using_code()) {\n@@ -206,1 +302,1 @@\n-  if (StoreCachedCode) {\n+  if (is_dumping_code()) {\n@@ -214,1 +310,1 @@\n-    return (StoreCachedCode || LoadCachedCode) && UseC2asC3;\n+    return (AOTCodeCaching) && UseC2asC3;\n@@ -221,1 +317,1 @@\n-  return UseCodeLoadThread && LoadCachedCode;\n+  return UseCodeLoadThread && is_using_code();\n@@ -227,1 +323,1 @@\n-         CDSAccess::can_generate_cached_code(m->get_Method());\n+         AOTCacheAccess::can_generate_aot_code(m->get_Method());\n@@ -391,1 +487,1 @@\n-  return !is_on() || !StoreCachedCode \/\/ Restrict only when we generate cache\n+  return !is_on() || !is_dumping_code() \/\/ Restrict only when we generate cache\n@@ -398,2 +494,2 @@\n-bool AOTCodeCache::open_cache() {\n-  AOTCodeCache* cache = new AOTCodeCache();\n+bool AOTCodeCache::open_cache(bool is_dumping, bool is_using) {\n+  AOTCodeCache* cache = new AOTCodeCache(is_dumping, is_using);\n@@ -416,1 +512,1 @@\n-    CDSAccess::set_pointer(&_aot_code_data, aot_data);\n+    AOTCacheAccess::set_pointer(&_aot_code_data, aot_data);\n@@ -428,1 +524,1 @@\n-\/\/     allocated using CDSAccess::allocate_from_code_cache().\n+\/\/     allocated using AOTCacheAccess::allocate_from_code_cache().\n@@ -433,2 +529,2 @@\n-\/\/     - A pointer p that points to metadata. CDSAccess::can_generate_cached_code(p) must return true.\n-\/\/     - A pointer to a buffer returned by CDSAccess::allocate_from_code_cache().\n+\/\/     - A pointer p that points to metadata. AOTCacheAccess::can_generate_aot_code(p) must return true.\n+\/\/     - A pointer to a buffer returned by AOTCacheAccess::allocate_from_code_cache().\n@@ -436,1 +532,1 @@\n-\/\/     Such pointers must be stored using CDSAccess::set_pointer()\n+\/\/     Such pointers must be stored using AOTCacheAccess::set_pointer()\n@@ -438,1 +534,1 @@\n-\/\/ The buffers allocated by CDSAccess::allocate_from_code_cache() are in a contiguous region. At runtime, this\n+\/\/ The buffers allocated by AOTCacheAccess::allocate_from_code_cache() are in a contiguous region. At runtime, this\n@@ -443,1 +539,1 @@\n-static CachedCodeDirectory* _cached_code_directory = nullptr;\n+static CachedCodeDirectory* _aot_code_directory = nullptr;\n@@ -446,2 +542,2 @@\n-  assert(CDSAccess::is_cached_code_region_empty(), \"must be\");\n-  CachedCodeDirectory* dir = (CachedCodeDirectory*)CDSAccess::allocate_from_code_cache(sizeof(CachedCodeDirectory));\n+  assert(AOTCacheAccess::is_aot_code_region_empty(), \"must be\");\n+  CachedCodeDirectory* dir = (CachedCodeDirectory*)AOTCacheAccess::allocate_from_code_cache(sizeof(CachedCodeDirectory));\n@@ -454,1 +550,1 @@\n-AOTCodeCache::AOTCodeCache() {\n+AOTCodeCache::AOTCodeCache(bool is_dumping, bool is_using) {\n@@ -456,2 +552,2 @@\n-  _for_read  = LoadCachedCode;\n-  _for_write = StoreCachedCode;\n+  _for_read  = is_using;\n+  _for_write = is_dumping;\n@@ -483,1 +579,1 @@\n-    ReservedSpace rs = MemoryReserver::reserve(CDSAccess::get_cached_code_size(), mtCode);\n+    ReservedSpace rs = MemoryReserver::reserve(AOTCacheAccess::get_aot_code_region_size(), mtCode);\n@@ -485,1 +581,1 @@\n-      log_warning(aot, codecache, init)(\"Failed to reserved %u bytes of memory for mapping cached code region in AOT Cache\", (uint)CDSAccess::get_cached_code_size());\n+      log_warning(aot, codecache, init)(\"Failed to reserved %u bytes of memory for mapping cached code region in AOT Cache\", (uint)AOTCacheAccess::get_aot_code_region_size());\n@@ -489,1 +585,1 @@\n-    if (!CDSAccess::map_cached_code(rs)) {\n+    if (!AOTCacheAccess::map_aot_code(rs)) {\n@@ -494,2 +590,2 @@\n-    _cached_code_directory = (CachedCodeDirectory*)rs.base();\n-    _cached_code_directory->runtime_init_internal();\n+    _aot_code_directory = (CachedCodeDirectory*)rs.base();\n+    _aot_code_directory->runtime_init_internal();\n@@ -497,2 +593,2 @@\n-    _load_size = _cached_code_directory->_aot_code_size;\n-    _load_buffer = _cached_code_directory->_aot_code_data;\n+    _load_size = _aot_code_directory->_aot_code_size;\n+    _load_buffer = _aot_code_directory->_aot_code_data;\n@@ -507,1 +603,6 @@\n-    log_info(aot, codecache, init)(\"Read header from AOT Code Cache\");\n+    log_info (aot, codecache, init)(\"Loaded %u AOT code entries from AOT Code Cache\", _load_header->entries_count());\n+    log_debug(aot, codecache, init)(\"  Adapters:  total=%u\", _load_header->adapters_count());\n+    log_debug(aot, codecache, init)(\"  Blobs:     total=%u\", _load_header->blobs_count());\n+    log_debug(aot, codecache, init)(\"  Stubs:     total=%u\", _load_header->stubs_count());\n+    log_debug(aot, codecache, init)(\"  Nmethods:  total=%u\", _load_header->nmethods_count());\n+    log_debug(aot, codecache, init)(\"  AOT code cache size: %u bytes\", _load_header->cache_size());\n@@ -795,1 +896,1 @@\n-    log_warning(aot, codecache)(\"Failed to ensure %d bytes at offset %d in AOT Code Cache. Increase CachedCodeMaxSize.\",\n+    log_warning(aot, codecache)(\"Failed to ensure %d bytes at offset %d in AOT Code Cache. Increase AOTCodeMaxSize.\",\n@@ -798,1 +899,1 @@\n-    exit_vm_on_store_failure();\n+    store_failure();\n@@ -816,1 +917,1 @@\n-    log_warning(aot, codecache)(\"Failed to write %d bytes at offset %d to AOT Code Cache. Increase CachedCodeMaxSize.\",\n+    log_warning(aot, codecache)(\"Failed to write %d bytes at offset %d to AOT Code Cache. Increase AOTCodeMaxSize.\",\n@@ -819,1 +920,1 @@\n-    exit_vm_on_store_failure();\n+    store_failure();\n@@ -833,1 +934,1 @@\n-    _method = CDSAccess::method_in_cached_code(_method);\n+    _method = AOTCacheAccess::method_in_aot_code(_method);\n@@ -1052,1 +1153,1 @@\n-AOTCodeStats AOTCodeStats::add_cached_code_stats(AOTCodeStats stats1, AOTCodeStats stats2) {\n+AOTCodeStats AOTCodeStats::add_aot_code_stats(AOTCodeStats stats1, AOTCodeStats stats2) {\n@@ -1087,1 +1188,1 @@\n-    total_stats = AOTCodeStats::add_cached_code_stats(prev_stats, current_stats);\n+    total_stats = AOTCodeStats::add_aot_code_stats(prev_stats, current_stats);\n@@ -1128,2 +1229,2 @@\n-    _cached_code_directory = CachedCodeDirectory::create();\n-    assert(_cached_code_directory != nullptr, \"Sanity check\");\n+    _aot_code_directory = CachedCodeDirectory::create();\n+    assert(_aot_code_directory != nullptr, \"Sanity check\");\n@@ -1144,0 +1245,1 @@\n+    assert(total_size < max_aot_code_size(), \"AOT Code size (\" UINT32_FORMAT \" bytes) is greater than AOTCodeMaxSize(\" UINT32_FORMAT \" bytes).\", total_size, max_aot_code_size());\n@@ -1145,2 +1247,0 @@\n-    assert(total_size < max_aot_code_size(), \"Cached code region size (\" UINT32_FORMAT \" bytes) in AOT Code Cache is less than the required size (\" UINT32_FORMAT \" bytes).\",\n-           total_size, max_aot_code_size());\n@@ -1151,1 +1251,1 @@\n-    char* buffer = (char *)CDSAccess::allocate_from_code_cache(total_size + DATA_ALIGNMENT); \/\/ NEW_C_HEAP_ARRAY(char, total_size + DATA_ALIGNMENT, mtCode);\n+    char* buffer = (char *)AOTCacheAccess::allocate_from_code_cache(total_size + DATA_ALIGNMENT); \/\/ NEW_C_HEAP_ARRAY(char, total_size + DATA_ALIGNMENT, mtCode);\n@@ -1156,1 +1256,5 @@\n-\n+    uint adapters_count = 0;\n+    uint blobs_count = 0;\n+    uint stubs_count = 0;\n+    uint nmethods_count = 0;\n+    uint max_size = 0;\n@@ -1177,0 +1281,3 @@\n+          if (size > max_size) {\n+            max_size = size;\n+          }\n@@ -1189,0 +1296,11 @@\n+          AOTCodeEntry::Kind kind = _load_entries[i].kind();\n+          if (kind == AOTCodeEntry::Adapter) {\n+            adapters_count++;\n+          } else if (kind == AOTCodeEntry::Blob) {\n+            blobs_count++;\n+          } else if (kind == AOTCodeEntry::Stub) {\n+            stubs_count++;\n+          } else {\n+            assert(kind == AOTCodeEntry::Code, \"sanity\");\n+            nmethods_count++;\n+          }\n@@ -1213,0 +1331,3 @@\n+        if (size > max_size) {\n+          max_size = size;\n+        }\n@@ -1226,0 +1347,11 @@\n+        AOTCodeEntry::Kind kind = entries_address[i].kind();\n+        if (kind == AOTCodeEntry::Adapter) {\n+          adapters_count++;\n+        } else if (kind == AOTCodeEntry::Blob) {\n+          blobs_count++;\n+        } else if (kind == AOTCodeEntry::Stub) {\n+          stubs_count++;\n+        } else {\n+          assert(kind == AOTCodeEntry::Code, \"sanity\");\n+          nmethods_count++;\n+        }\n@@ -1270,0 +1402,6 @@\n+    assert(nmethods_count == (entries_count - (stubs_count + blobs_count + adapters_count)), \"sanity\");\n+    log_debug(aot, codecache, exit)(\"  Adapters:  total=%u\", adapters_count);\n+    log_debug(aot, codecache, exit)(\"  Blobs:     total=%u\", blobs_count);\n+    log_debug(aot, codecache, exit)(\"  Stubs:     total=%u\", stubs_count);\n+    log_debug(aot, codecache, exit)(\"  nmethods:  total=%u\", nmethods_count);\n+    log_debug(aot, codecache, exit)(\"  AOT code cache size: %u bytes, max entry's size: %u bytes\", size, max_size);\n@@ -1277,0 +1415,1 @@\n+                 adapters_count, blobs_count, stubs_count,\n@@ -1278,2 +1417,1 @@\n-    log_info(aot, codecache, init)(\"Wrote AOTCodeCache header to AOT Code Cache\");\n-    log_info(aot, codecache, exit)(\"Wrote %d bytes of data to AOT Code Cache\", size);\n+    log_info(aot, codecache, exit)(\"Wrote %d AOT code entries to AOT Code Cache\", entries_count);\n@@ -1281,1 +1419,1 @@\n-    _cached_code_directory->set_aot_code_data(size, start);\n+    _aot_code_directory->set_aot_code_data(size, start);\n@@ -1287,0 +1425,3 @@\n+  if (!is_using_stub()) {\n+    return false;\n+  }\n@@ -1304,1 +1445,1 @@\n-    exit_vm_on_load_failure();\n+    load_failure();\n@@ -1318,0 +1459,3 @@\n+  if (!is_dumping_stub()) {\n+    return false;\n+  }\n@@ -1588,1 +1732,1 @@\n-    if (_for_preload && !CDSAccess::can_generate_cached_code(ik)) {\n+    if (_for_preload && !AOTCacheAccess::can_generate_aot_code(ik)) {\n@@ -1602,1 +1746,1 @@\n-  if (can_use_meta_ptrs && CDSAccess::can_generate_cached_code(klass)) {\n+  if (can_use_meta_ptrs && AOTCacheAccess::can_generate_aot_code(klass)) {\n@@ -1613,1 +1757,1 @@\n-    uint klass_offset = CDSAccess::delta_from_shared_address_base((address)klass);\n+    uint klass_offset = AOTCacheAccess::delta_from_shared_address_base((address)klass);\n@@ -1696,1 +1840,1 @@\n-    if (_for_preload && !CDSAccess::can_generate_cached_code(ik)) {\n+    if (_for_preload && !AOTCacheAccess::can_generate_aot_code(ik)) {\n@@ -1708,1 +1852,1 @@\n-  if (can_use_meta_ptrs && CDSAccess::can_generate_cached_code(method)) {\n+  if (can_use_meta_ptrs && AOTCacheAccess::can_generate_aot_code(method)) {\n@@ -1714,1 +1858,1 @@\n-    uint method_offset = CDSAccess::delta_from_shared_address_base((address)method);\n+    uint method_offset = AOTCacheAccess::delta_from_shared_address_base((address)method);\n@@ -1993,0 +2137,3 @@\n+  if (!is_using_adapter()) {\n+    return false;\n+  }\n@@ -2068,0 +2215,7 @@\n+  if (!is_using_stub()) {\n+    return false;\n+  }\n+  AOTCodeCache* cache = open_for_read();\n+  if (cache == nullptr) {\n+    return false;\n+  }\n@@ -2075,4 +2229,0 @@\n-  AOTCodeCache* cache = open_for_read();\n-  if (cache == nullptr) {\n-    return false;\n-  }\n@@ -2105,1 +2255,1 @@\n-    exit_vm_on_load_failure();\n+    load_failure();\n@@ -2311,1 +2461,3 @@\n-  assert(CDSConfig::is_dumping_adapters(), \"must be\");\n+  if (!is_dumping_adapter()) {\n+    return false;\n+  }\n@@ -2425,0 +2577,3 @@\n+  if (!is_dumping_stub()) {\n+    return false;\n+  }\n@@ -2632,1 +2787,1 @@\n-    obj = CDSAccess::get_archived_object(k);\n+    obj = AOTCacheAccess::get_archived_object(k);\n@@ -2660,1 +2815,1 @@\n-    obj = CDSAccess::get_archived_object(k);\n+    obj = AOTCacheAccess::get_archived_object(k);\n@@ -2831,1 +2986,1 @@\n-    int k = CDSAccess::get_archived_object_permanent_index(obj);  \/\/ k >= 0 means obj is a \"permanent heap object\"\n+    int k = AOTCacheAccess::get_archived_object_permanent_index(obj);  \/\/ k >= 0 means obj is a \"permanent heap object\"\n@@ -2881,1 +3036,1 @@\n-    int k = CDSAccess::get_archived_object_permanent_index(obj);  \/\/ k >= 0 means obj is a \"permanent heap object\"\n+    int k = AOTCacheAccess::get_archived_object_permanent_index(obj);  \/\/ k >= 0 means obj is a \"permanent heap object\"\n@@ -3018,0 +3173,7 @@\n+  if (!is_using_code()) {\n+    return false;\n+  }\n+  AOTCodeCache* cache = open_for_read();\n+  if (cache == nullptr) {\n+    return false;\n+  }\n@@ -3025,4 +3187,0 @@\n-  AOTCodeCache* cache = open_for_read();\n-  if (cache == nullptr) {\n-    return false;\n-  }\n@@ -3369,1 +3527,4 @@\n-  if (!CDSConfig::is_dumping_cached_code()) {\n+  if (!is_dumping_code()) {\n+    return nullptr;\n+  }\n+  if (!CDSConfig::is_dumping_aot_code()) {\n@@ -3372,0 +3533,4 @@\n+  AOTCodeCache* cache = open_for_write();\n+  if (cache == nullptr) {\n+    return nullptr; \/\/ Cache file is closed\n+  }\n@@ -3387,4 +3552,0 @@\n-  AOTCodeCache* cache = open_for_write();\n-  if (cache == nullptr) {\n-    return nullptr; \/\/ Cache file is closed\n-  }\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":263,"deletions":102,"binary":false,"changes":365,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class AOTCodeCache;\n@@ -69,1 +70,0 @@\n-class AOTCodeCache;\n@@ -93,3 +93,3 @@\n-  Method*   _method;\n-  Kind   _kind;        \/\/\n-  uint   _id;          \/\/ vmIntrinsic::ID for stub or name's hash for nmethod\n+  Method*       _method;\n+  Kind   _kind;\n+  uint   _id;          \/\/ Adapter's id, vmIntrinsic::ID for stub or name's hash for nmethod\n@@ -384,0 +384,3 @@\n+    uint _adapters_count;\n+    uint _blobs_count;\n+    uint _stubs_count;\n@@ -391,0 +394,1 @@\n+              uint adapters_count, uint blobs_count, uint stubs_count,\n@@ -400,0 +404,3 @@\n+      _adapters_count = adapters_count;\n+      _blobs_count    = blobs_count;\n+      _stubs_count    = stubs_count;\n@@ -411,0 +418,4 @@\n+    uint adapters_count() const { return _adapters_count; }\n+    uint blobs_count()    const { return _blobs_count; }\n+    uint stubs_count()    const { return _stubs_count; }\n+    uint nmethods_count() const { return _entries_count - _stubs_count - _blobs_count - _adapters_count; }\n@@ -492,1 +503,1 @@\n-  AOTCodeCache();\n+  AOTCodeCache(bool is_dumping, bool is_using);\n@@ -586,1 +597,1 @@\n-  static bool open_cache();\n+  static bool open_cache(bool is_dumping, bool is_using);\n@@ -601,2 +612,13 @@\n-  static bool is_on_for_read()  { return is_on() && _cache->for_read(); }\n-  static bool is_on_for_write() { return is_on() && _cache->for_write(); }\n+  static bool is_on_for_read()  CDS_ONLY({ return is_on() && _cache->for_read(); }) NOT_CDS_RETURN_(false);\n+  static bool is_on_for_write() CDS_ONLY({ return is_on() && _cache->for_write(); }) NOT_CDS_RETURN_(false);\n+  static bool is_dumping_code() NOT_CDS_RETURN_(false);\n+  static bool is_dumping_stub() NOT_CDS_RETURN_(false);\n+  static bool is_dumping_adapter() NOT_CDS_RETURN_(false);\n+  static bool is_using_code() NOT_CDS_RETURN_(false);\n+  static bool is_using_stub() NOT_CDS_RETURN_(false);\n+  static bool is_using_adapter() NOT_CDS_RETURN_(false);\n+  static void enable_caching() NOT_CDS_RETURN;\n+  static void disable_caching() NOT_CDS_RETURN;\n+  static bool is_caching_enabled() NOT_CDS_RETURN_(false);\n+\n+\n@@ -684,1 +706,1 @@\n-  static AOTCodeStats add_cached_code_stats(AOTCodeStats stats1, AOTCodeStats stats2);\n+  static AOTCodeStats add_aot_code_stats(AOTCodeStats stats1, AOTCodeStats stats2);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":31,"deletions":9,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/cdsAccess.hpp\"\n+#include \"cds\/aotCacheAccess.hpp\"\n@@ -324,1 +324,1 @@\n-  const size_t cds_code_size = align_up(CDSAccess::get_cached_code_size(), min_size);\n+  const size_t cds_code_size = align_up(AOTCacheAccess::get_aot_code_region_size(), min_size);\n@@ -358,2 +358,2 @@\n-void* CodeCache::map_cached_code() {\n-  if (_cds_code_space.size() > 0 && CDSAccess::map_cached_code(_cds_code_space)) {\n+void* CodeCache::map_aot_code() {\n+  if (_cds_code_space.size() > 0 && AOTCacheAccess::map_aot_code(_cds_code_space)) {\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  static void* map_cached_code();\n+  static void* map_aot_code();\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-    if (StoreCachedCode) {\n+    if (AOTCodeCache::is_dumping_code()) {\n@@ -659,1 +659,1 @@\n-    if (StoreCachedCode) {\n+    if (AOTCodeCache::is_dumping_code()) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3106,1 +3106,1 @@\n-  if (LoadCachedCode || StoreCachedCode) {\n+  if (AOTCodeCaching) {\n@@ -3199,1 +3199,1 @@\n-  if (StoreCachedCode || LoadCachedCode) { \/\/ Check flags because AOT code cache could be closed already\n+  if (AOTCodeCaching) { \/\/ Check flags because AOT code cache could be closed already\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-  if (!SegmentedCodeCache && (LoadCachedCode || StoreCachedCode)) {\n+  if (!SegmentedCodeCache && (AOTCodeCaching || AOTStubCaching || AOTAdapterCaching)) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -402,6 +402,0 @@\n-  product(bool, StoreCachedCode, false,                                     \\\n-          \"Store cached compiled code\")                                     \\\n-                                                                            \\\n-  product(bool, LoadCachedCode, false,                                      \\\n-          \"Load cached compiled code\")                                      \\\n-                                                                            \\\n@@ -433,3 +427,0 @@\n-  product(uint, CachedCodeMaxSize, 10*M,                                    \\\n-          \"Buffer size in bytes for code caching\")                          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/cdsAccess.hpp\"\n@@ -222,1 +221,1 @@\n-  assert(CDSConfig::is_dumping_final_static_archive() && StoreCachedCode, \"sanity\");\n+  assert(AOTCodeCache::is_dumping_code(), \"sanity\");\n","filename":"src\/hotspot\/share\/compiler\/precompiler.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2979,4 +2979,0 @@\n-  if (StoreCachedCode) {\n-    FLAG_SET_ERGO_IF_DEFAULT(CachedCodeMaxSize, 512*M);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test of combinations of the AOT Code Caching diagnostic flags\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.flagless\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build AOTCodeFlags JavacBenchApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 JavacBenchApp\n+ *                 JavacBenchApp$ClassFile\n+ *                 JavacBenchApp$FileManager\n+ *                 JavacBenchApp$SourceFile\n+ * @run driver AOTCodeFlags\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTCodeFlags {\n+    public static int flag_sign = 0;\n+    public static void main(String... args) throws Exception {\n+        Tester t = new Tester();\n+        for (int i = 0; i < 2; i++) {\n+            flag_sign = i;\n+            t.run(new String[] {\"AOT\"});\n+        }\n+    }\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(\"AOTCodeFlags\" + flag_sign);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return \"app.jar\";\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            switch (runMode) {\n+            case RunMode.ASSEMBLY:\n+            case RunMode.PRODUCTION:\n+                return new String[] {\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-XX:\" + (flag_sign == 0 ? \"-\" : \"+\") + \"AOTAdapterCaching\",\n+                    \"-XX:\" + (flag_sign == 0 ? \"-\" : \"+\") + \"AOTStubCaching\",\n+                    \"-XX:\" + (flag_sign == 0 ? \"-\" : \"+\") + \"AOTCodeCaching\",\n+                    \"-Xlog:aot+codecache+init=debug\",\n+                    \"-Xlog:aot+codecache+exit=debug\",\n+                };\n+            }\n+            return new String[] {};\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                \"JavacBenchApp\", \"10\"\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (flag_sign == 0) {\n+                switch (runMode) {\n+                case RunMode.ASSEMBLY:\n+                case RunMode.PRODUCTION:\n+                    out.shouldNotContain(\"AOT code cache size: \");\n+                    break;\n+                }\n+\n+            } else {\n+                switch (runMode) {\n+                case RunMode.ASSEMBLY:\n+                case RunMode.PRODUCTION:\n+                    out.shouldContain(\"AOT code cache size: \");\n+                    break;\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}