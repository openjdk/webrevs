{"files":[{"patch":"@@ -1117,5 +1117,1 @@\n-  assert(_remarks == nullptr, \"Must 'clear()' before deleting!\");\n-}\n-\n-void AsmRemarks::init(AsmRemarks& asm_remarks) {\n-  asm_remarks._remarks = new AsmRemarkCollection();\n+  assert(_remarks == nullptr, \"must be\");\n@@ -1176,5 +1172,1 @@\n-  assert(_strings == nullptr, \"Must 'clear()' before deleting!\");\n-}\n-\n-void DbgStrings::init(DbgStrings& dbg_strings) {\n-  dbg_strings._strings = new DbgStringCollection();\n+  assert(_strings == nullptr, \"must be\");\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -429,2 +429,0 @@\n-  static void init(AsmRemarks& asm_remarks);\n-\n@@ -457,2 +455,0 @@\n-  static void init(DbgStrings& dbg_strings);\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"asm\/codeBuffer.hpp\"\n@@ -1601,2 +1600,2 @@\n-                                        code_offset, code_size, 0, 0,\n-                                        AOTCodeEntry::Stub, (uint32_t)id);\n+                                                code_offset, code_size,\n+                                                AOTCodeEntry::Stub, (uint32_t)id);\n@@ -1676,0 +1675,2 @@\n+  AOTCodeCache* cache = open_for_dump();\n+  assert(cache != nullptr, \"sanity check\");\n@@ -1755,3 +1756,3 @@\n-  uint archived_nm_offset = _write_position - entry_position;\n-  nmethod* archived_nm = (nmethod*)reserve_bytes(nm->size());\n-  if (archived_nm == nullptr) {\n+\n+  \/\/ Write CodeBlob\n+  if (!cache->align_write()) {\n@@ -1760,3 +1761,6 @@\n-  nm->copy_to((address)archived_nm);\n-\n-  archived_nm->prepare_for_archiving();\n+  uint blob_offset = cache->_write_position - entry_position;\n+  address archive_buffer = cache->reserve_bytes(nm->size());\n+  if (archive_buffer == nullptr) {\n+    return nullptr;\n+  }\n+  CodeBlob::archive_blob(nm, archive_buffer);\n@@ -1832,2 +1836,6 @@\n-  if (!write_oop_map_set(*nm)) {\n-    return nullptr;\n+  bool has_oop_maps = false;\n+  if (nm->oop_maps() != nullptr) {\n+    if (!cache->write_oop_map_set(*nm)) {\n+      return nullptr;\n+    }\n+    has_oop_maps = true;\n@@ -1856,1 +1864,1 @@\n-  if (!write_nmethod_loadtime_relocations(thread, nm, oop_list, metadata_list)) {\n+  if (!write_relocations(*nm, &oop_list, &metadata_list)) {\n@@ -1861,4 +1869,6 @@\n-  AOTCodeEntry* entry = new (this) AOTCodeEntry(entry_position, entry_size, name_offset, name_size,\n-                                        archived_nm_offset, 0, 0, 0,\n-                                        AOTCodeEntry::Code, hash, nm->content_begin(), comp_level, comp_id, decomp,\n-                                        nm->has_clinit_barriers(), for_preload, ignore_decompile);\n+  AOTCodeEntry* entry = new (this) AOTCodeEntry(AOTCodeEntry::Code, hash,\n+                                                entry_position, entry_size,\n+                                                name_offset, name_size,\n+                                                blob_offset, has_oop_maps,\n+                                                nm->content_begin(), comp_level, comp_id, decomp,\n+                                                nm->has_clinit_barriers(), for_preload, ignore_decompile);\n@@ -2138,1 +2148,1 @@\n-bool AOTCodeCache::write_relocations(CodeBlob& code_blob) {\n+bool AOTCodeCache::write_relocations(CodeBlob& code_blob, GrowableArray<Handle>* oop_list, GrowableArray<Metadata*>* metadata_list) {\n@@ -2146,0 +2156,41 @@\n+      break;\n+      case relocInfo::oop_type: {\n+        oop_Relocation* r = (oop_Relocation*)iter.reloc();\n+        if (r->oop_is_immediate()) {\n+          assert(oop_list != nullptr, \"sanity check\");\n+          \/\/ store index of oop in the reloc immediate oop list\n+          Handle h(JavaThread::current(), r->oop_value());\n+          int oop_idx = oop_list->find(h);\n+          assert(oop_idx != -1, \"sanity check\");\n+          reloc_data.at_put(idx, (uint)oop_idx);\n+        }\n+        break;\n+      }\n+      case relocInfo::metadata_type: {\n+        metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n+        if (r->metadata_is_immediate()) {\n+          assert(metadata_list != nullptr, \"sanity check\");\n+          \/\/ store index of metadata in the reloc immediate metadata list\n+          int metadata_idx = metadata_list->find(r->metadata_value());\n+          assert(metadata_idx != -1, \"sanity check\");\n+          reloc_data.at_put(idx, (uint)metadata_idx);\n+        }\n+        break;\n+      }\n+      case relocInfo::virtual_call_type:  \/\/ Fall through. They all call resolve_*_call blobs.\n+      case relocInfo::opt_virtual_call_type:\n+      case relocInfo::static_call_type: {\n+        CallRelocation* r = (CallRelocation*)iter.reloc();\n+        address dest = r->destination();\n+        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n+          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n+        }\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::trampoline_stub_type: {\n+        address dest = ((trampoline_stub_Relocation*)iter.reloc())->destination();\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::static_stub_type:\n@@ -2154,1 +2205,1 @@\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, &code_blob));\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n@@ -2163,1 +2214,1 @@\n-        reloc_data.at_put(idx, _table->id_for_address(target, iter, nullptr, &code_blob));\n+        reloc_data.at_put(idx, _table->id_for_address(target, iter, &code_blob));\n@@ -2170,0 +2221,4 @@\n+      case relocInfo::poll_type:\n+        break;\n+      case relocInfo::poll_return_type:\n+        break;\n@@ -2172,0 +2227,2 @@\n+      case relocInfo::entry_guard_type:\n+        break;\n@@ -2196,5 +2253,5 @@\n-void AOTCodeReader::apply_relocations(nmethod* nm, GrowableArray<Handle> &oop_list, GrowableArray<Metadata*> &metadata_list) {\n-  LogStreamHandle(Info, aot, codecache, reloc) log;\n-  uint buffer_offset = read_position();\n-  int count = *(int*)addr(buffer_offset);\n-  buffer_offset += sizeof(int);\n+void AOTCodeReader::fix_relocations(CodeBlob* code_blob, GrowableArray<Handle>* oop_list, GrowableArray<Metadata*>* metadata_list) {\n+  LogStreamHandle(Trace, aot, reloc) log;\n+  uint offset = read_position();\n+  int count = *(int*)addr(offset);\n+  offset += sizeof(int);\n@@ -2204,3 +2261,3 @@\n-  uint* reloc_data = (uint*)addr(buffer_offset);\n-  buffer_offset += (count * sizeof(uint));\n-  set_read_position(buffer_offset);\n+  uint* reloc_data = (uint*)addr(offset);\n+  offset += (count * sizeof(uint));\n+  set_read_position(offset);\n@@ -2208,1 +2265,1 @@\n-  RelocIterator iter(nm);\n+  RelocIterator iter(code_blob);\n@@ -2210,1 +2267,0 @@\n-\n@@ -2216,0 +2272,1 @@\n+        assert(code_blob->is_nmethod(), \"sanity check\");\n@@ -2218,1 +2275,2 @@\n-          Handle h = oop_list.at(reloc_data[j]);\n+          assert(oop_list != nullptr, \"sanity check\");\n+          Handle h = oop_list->at(reloc_data[j]);\n@@ -2226,0 +2284,1 @@\n+        assert(code_blob->is_nmethod(), \"sanity check\");\n@@ -2229,1 +2288,2 @@\n-          m = metadata_list.at(reloc_data[j]);\n+          assert(metadata_list != nullptr, \"sanity check\");\n+          m = metadata_list->at(reloc_data[j]);\n@@ -2233,1 +2293,1 @@\n-          m = nm->metadata_at(index);\n+          m = code_blob->as_nmethod()->metadata_at(index);\n@@ -2263,71 +2323,0 @@\n-      case relocInfo::runtime_call_w_cp_type:\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n-        \/\/address destination = iter.reloc()->value();\n-        break;\n-      case relocInfo::external_word_type: {\n-        address target = _cache->address_for_id(reloc_data[j]);\n-        \/\/ Add external address to global table\n-        int index = ExternalsRecorder::find_index(target);\n-        \/\/ Update index in relocation\n-        Relocation::add_jint(iter.data(), index);\n-        external_word_Relocation* reloc = (external_word_Relocation*)iter.reloc();\n-        assert(reloc->target() == target, \"sanity\");\n-        reloc->set_value(target); \/\/ Patch address in the code\n-        break;\n-      }\n-      case relocInfo::internal_word_type: {\n-        internal_word_Relocation* r = (internal_word_Relocation*)iter.reloc();\n-        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), nm->content_begin());\n-        break;\n-      }\n-      case relocInfo::section_word_type: {\n-        section_word_Relocation* r = (section_word_Relocation*)iter.reloc();\n-        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), nm->content_begin());\n-        break;\n-      }\n-      case relocInfo::poll_type:\n-        break;\n-      case relocInfo::poll_return_type:\n-        break;\n-      case relocInfo::post_call_nop_type:\n-        break;\n-      case relocInfo::entry_guard_type:\n-        break;\n-      default:\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n-        break;\n-    }\n-    if (log.is_enabled()) {\n-      iter.print_current_on(&log);\n-    }\n-    j++;\n-  }\n-  assert(j == count, \"must be\");\n-}\n-\n-\n-void AOTCodeReader::fix_relocations(CodeBlob* code_blob) {\n-  LogStreamHandle(Trace, aot, reloc) log;\n-  uint offset = read_position();\n-  int count = *(int*)addr(offset);\n-  offset += sizeof(int);\n-  if (log.is_enabled()) {\n-    log.print_cr(\"======== extra relocations count=%d\", count);\n-  }\n-  uint* reloc_data = (uint*)addr(offset);\n-  offset += (count * sizeof(uint));\n-  set_read_position(offset);\n-\n-  RelocIterator iter(code_blob);\n-  int j = 0;\n-  while (iter.next()) {\n-    switch (iter.type()) {\n-      case relocInfo::none:\n-        break;\n-      case relocInfo::runtime_call_type: {\n-        address dest = _cache->address_for_id(reloc_data[j]);\n-        if (dest != (address)-1) {\n-          ((CallRelocation*)iter.reloc())->set_destination(dest);\n-        }\n-        break;\n-      }\n@@ -2358,89 +2347,0 @@\n-      case relocInfo::post_call_nop_type:\n-        break;\n-      default:\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n-        break;\n-    }\n-    if (log.is_enabled()) {\n-      iter.print_current_on(&log);\n-    }\n-    j++;\n-  }\n-  assert(j == count, \"sanity\");\n-}\n-\n-bool AOTCodeCache::write_nmethod_loadtime_relocations(JavaThread* thread, nmethod* nm, GrowableArray<Handle>& oop_list, GrowableArray<Metadata*>& metadata_list) {\n-  LogStreamHandle(Info, aot, codecache, reloc) log;\n-  GrowableArray<uint> reloc_data;\n-  \/\/ Collect additional data\n-  RelocIterator iter(nm);\n-  bool has_immediate = false;\n-  while (iter.next()) {\n-    int idx = reloc_data.append(0); \/\/ default value\n-    switch (iter.type()) {\n-      case relocInfo::none:\n-      break;\n-      case relocInfo::oop_type: {\n-        oop_Relocation* r = (oop_Relocation*)iter.reloc();\n-        if (r->oop_is_immediate()) {\n-          \/\/ store index of oop in the reloc immediate oop list\n-          Handle h(thread, r->oop_value());\n-          int oop_idx = oop_list.find(h);\n-          assert(oop_idx != -1, \"sanity check\");\n-          reloc_data.at_put(idx, (uint)oop_idx);\n-          has_immediate = true;\n-        }\n-        break;\n-      }\n-      case relocInfo::metadata_type: {\n-        metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n-        if (r->metadata_is_immediate()) {\n-          \/\/ store index of metadata in the reloc immediate metadata list\n-          int metadata_idx = metadata_list.find(r->metadata_value());\n-          assert(metadata_idx != -1, \"sanity check\");\n-          reloc_data.at_put(idx, (uint)metadata_idx);\n-          has_immediate = true;\n-        }\n-        break;\n-      }\n-      case relocInfo::virtual_call_type:  \/\/ Fall through. They all call resolve_*_call blobs.\n-      case relocInfo::opt_virtual_call_type:\n-      case relocInfo::static_call_type: {\n-        CallRelocation* r = (CallRelocation*)iter.reloc();\n-        address dest = r->destination();\n-        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n-          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n-        }\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::trampoline_stub_type: {\n-        address dest = ((trampoline_stub_Relocation*)iter.reloc())->destination();\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::static_stub_type:\n-        break;\n-      case relocInfo::runtime_call_type: {\n-        \/\/ Record offset of runtime destination\n-        CallRelocation* r = (CallRelocation*)iter.reloc();\n-        address dest = r->destination();\n-        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n-          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n-        }\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::runtime_call_w_cp_type:\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n-        break;\n-      case relocInfo::external_word_type: {\n-        \/\/ Record offset of runtime target\n-        address target = ((external_word_Relocation*)iter.reloc())->target();\n-        reloc_data.at_put(idx, _table->id_for_address(target, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::internal_word_type:\n-        break;\n-      case relocInfo::section_word_type:\n-        break;\n@@ -2462,0 +2362,1 @@\n+    j++;\n@@ -2463,20 +2364,1 @@\n-\n-  \/\/ Write additional relocation data: uint per relocation\n-  \/\/ Write the count first\n-  int count = reloc_data.length();\n-  write_bytes(&count, sizeof(int));\n-  uint data_size = count * sizeof(uint);\n-  for (GrowableArrayIterator<uint> iter = reloc_data.begin();\n-       iter != reloc_data.end(); ++iter) {\n-    uint value = *iter;\n-    int n = write_bytes(&value, sizeof(uint));\n-    if (n != sizeof(uint)) {\n-      return false;\n-      break;\n-    }\n-  }\n-\n-  if (!align_write()) {\n-    return false;\n-  }\n-  return true; \/\/success;\n+  assert(j == count, \"sanity\");\n@@ -2512,53 +2394,0 @@\n-bool AOTCodeCache::write_debug_info(DebugInformationRecorder* recorder) {\n-  if (!align_write()) {\n-    return false;\n-  }\n-  \/\/ Don't call data_size() and pcs_size(). They will freeze OopRecorder.\n-  int data_size = recorder->stream()->position(); \/\/ In bytes\n-  uint n = write_bytes(&data_size, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  int pcs_length = recorder->pcs_length(); \/\/ In bytes\n-  n = write_bytes(&pcs_length, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  n = write_bytes(recorder->stream()->buffer(), data_size);\n-  if (n != (uint)data_size) {\n-    return false;\n-  }\n-  uint pcs_size = pcs_length * sizeof(PcDesc);\n-  n = write_bytes(recorder->pcs(), pcs_size);\n-  if (n != pcs_size) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n-DebugInformationRecorder* AOTCodeReader::read_debug_info(OopRecorder* oop_recorder) {\n-  uint code_offset = align_up(read_position(), DATA_ALIGNMENT);\n-  int data_size  = *(int*)addr(code_offset);\n-  code_offset   += sizeof(int);\n-  int pcs_length = *(int*)addr(code_offset);\n-  code_offset   += sizeof(int);\n-\n-  log_debug(aot, codecache)(\"======== read DebugInfo [%d, %d]:\", data_size, pcs_length);\n-\n-  \/\/ Aligned initial sizes\n-  int data_size_align  = align_up(data_size, DATA_ALIGNMENT);\n-  int pcs_length_align = pcs_length + 1;\n-  assert(sizeof(PcDesc) > DATA_ALIGNMENT, \"sanity\");\n-  DebugInformationRecorder* recorder = new DebugInformationRecorder(oop_recorder, data_size_align, pcs_length);\n-\n-  copy_bytes(addr(code_offset), recorder->stream()->buffer(), data_size_align);\n-  recorder->stream()->set_position(data_size);\n-  code_offset += data_size;\n-\n-  uint pcs_size = pcs_length * sizeof(PcDesc);\n-  copy_bytes(addr(code_offset), (address)recorder->pcs(), pcs_size);\n-  code_offset += pcs_size;\n-  set_read_position(code_offset);\n-  return recorder;\n-}\n-\n@@ -2578,30 +2407,0 @@\n-bool AOTCodeCache::write_metadata(OopRecorder* oop_recorder) {\n-  int metadata_count = oop_recorder->metadata_count();\n-  uint n = write_bytes(&metadata_count, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-\n-  log_debug(aot, codecache)(\"======== write metadata [%d]:\", metadata_count);\n-\n-  for (int i = 1; i < metadata_count; i++) { \/\/ skip first virtual nullptr\n-    Metadata* m = oop_recorder->metadata_at(i);\n-    LogStreamHandle(Debug, aot, codecache, metadata) log;\n-    if (log.is_enabled()) {\n-      log.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(m));\n-      if (m == (Metadata*)Universe::non_oop_word()) {\n-        log.print(\"non-metadata word\");\n-      } else if (m == nullptr) {\n-        log.print(\"nullptr-oop\");\n-      } else {\n-        Metadata::print_value_on_maybe_null(&log, m);\n-      }\n-      log.cr();\n-    }\n-    if (!write_metadata(m)) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -2647,43 +2446,0 @@\n-bool AOTCodeReader::read_metadata(OopRecorder* oop_recorder, ciMethod* target) {\n-  uint code_offset = read_position();\n-  int metadata_count = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  set_read_position(code_offset);\n-\n-  log_debug(aot, codecache)(\"======== read metadata [%d]:\", metadata_count);\n-\n-  if (metadata_count == 0) {\n-    return true;\n-  }\n-  {\n-    VM_ENTRY_MARK;\n-    methodHandle comp_method(THREAD, target->get_Method());\n-\n-    for (int i = 1; i < metadata_count; i++) {\n-      Metadata* m = read_metadata(comp_method);\n-      if (lookup_failed()) {\n-        return false;\n-      }\n-      if (oop_recorder->is_real(m)) {\n-        oop_recorder->find_index(m);\n-      } else {\n-        oop_recorder->allocate_metadata_index(m);\n-      }\n-      LogTarget(Debug, aot, codecache, metadata) log;\n-      if (log.is_enabled()) {\n-        LogStream ls(log);\n-        ls.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(m));\n-        if (m == (Metadata*)Universe::non_oop_word()) {\n-          ls.print(\"non-metadata word\");\n-        } else if (m == nullptr) {\n-          ls.print(\"nullptr-oop\");\n-        } else {\n-          Metadata::print_value_on_maybe_null(&ls, m);\n-        }\n-        ls.cr();\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -3158,29 +2914,0 @@\n-bool AOTCodeCache::write_oops(OopRecorder* oop_recorder) {\n-  int oop_count = oop_recorder->oop_count();\n-  uint n = write_bytes(&oop_count, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  log_debug(aot, codecache)(\"======== write oops [%d]:\", oop_count);\n-\n-  for (int i = 1; i < oop_count; i++) { \/\/ skip first virtual nullptr\n-    jobject jo = oop_recorder->oop_at(i);\n-    LogStreamHandle(Info, aot, codecache, oops) log;\n-    if (log.is_enabled()) {\n-      log.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(jo));\n-      if (jo == (jobject)Universe::non_oop_word()) {\n-        log.print(\"non-oop word\");\n-      } else if (jo == nullptr) {\n-        log.print(\"nullptr-oop\");\n-      } else {\n-        JNIHandles::resolve(jo)->print_value_on(&log);\n-      }\n-      log.cr();\n-    }\n-    if (!write_oop(jo)) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -3299,40 +3026,0 @@\n-bool AOTCodeReader::read_oops(OopRecorder* oop_recorder, ciMethod* target) {\n-  uint code_offset = read_position();\n-  int oop_count = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  set_read_position(code_offset);\n-  log_debug(aot, codecache)(\"======== read oops [%d]:\", oop_count);\n-  if (oop_count == 0) {\n-    return true;\n-  }\n-  {\n-    VM_ENTRY_MARK;\n-    methodHandle comp_method(THREAD, target->get_Method());\n-    for (int i = 1; i < oop_count; i++) {\n-      oop obj = read_oop(THREAD, comp_method);\n-      if (lookup_failed()) {\n-        return false;\n-      }\n-      jobject jo = JNIHandles::make_local(THREAD, obj);\n-      if (oop_recorder->is_real(jo)) {\n-        oop_recorder->find_index(jo);\n-      } else {\n-        oop_recorder->allocate_oop_index(jo);\n-      }\n-      LogStreamHandle(Debug, aot, codecache, oops) log;\n-      if (log.is_enabled()) {\n-        log.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(jo));\n-        if (jo == (jobject)Universe::non_oop_word()) {\n-          log.print(\"non-oop word\");\n-        } else if (jo == nullptr) {\n-          log.print(\"nullptr-oop\");\n-        } else {\n-          JNIHandles::resolve(jo)->print_value_on(&log);\n-        }\n-        log.cr();\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -3610,1 +3297,0 @@\n-#define _all_blobs_max 100\n@@ -3612,0 +3298,1 @@\n+#define _C1_blobs_max 50\n@@ -3613,2 +3300,2 @@\n-#define _C1_blobs_max (_all_blobs_max - _shared_blobs_max - _C2_blobs_max)\n-#define _all_max 380\n+#define _blobs_max (_shared_blobs_max+_C1_blobs_max+_C2_blobs_max)\n+#define _all_max (_extrs_max+_stubs_max+_blobs_max)\n@@ -3621,0 +3308,1 @@\n+#define _blobs_end  (_shared_blobs_base + _blobs_max)\n@@ -3635,0 +3323,3 @@\n+\n+  assert(_blobs_end <= _all_max, \"AOTCodeAddress table ranges need adjusting\");\n+\n@@ -3639,1 +3330,0 @@\n-  _stubs_length = 0;\n@@ -3857,1 +3547,1 @@\n-  log_info(aot, codecache, init)(\"early stubs recorded\");\n+  log_info(aot, codecache, init)(\"Early stubs recorded\");\n@@ -3865,3 +3555,1 @@\n-  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _all_blobs_max, mtCode);\n-\n-  \/\/ Divide _shared_blobs_addr array to chunks because they could be initialized in parrallel\n+  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n@@ -3872,1 +3560,1 @@\n-  _shared_blobs_length = 0;       \/\/ for shared blobs\n+  _shared_blobs_length = 0;\n@@ -3877,1 +3565,1 @@\n-  memset(blobs_addr, 0, sizeof(address)* _all_blobs_max);\n+  memset(blobs_addr, 0, sizeof(address)* _blobs_max);\n@@ -3901,0 +3589,5 @@\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_AbstractMethodError_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_NullPointerException_at_call_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_StackOverflowError_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -3903,1 +3596,2 @@\n-  log_info(aot, codecache,init)(\"Early shared blobs recorded\");\n+  _shared_blobs_complete = true;\n+  log_info(aot, codecache,init)(\"All shared blobs recorded\");\n@@ -3911,11 +3605,0 @@\n-  \/\/ final blobs\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_AbstractMethodError_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_NullPointerException_at_call_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_StackOverflowError_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_delayed_StackOverflowError_entry());\n-\n-  assert(_shared_blobs_length <= _all_blobs_max, \"increase _all_blobs_max to %d\", _shared_blobs_length);\n-\n-  _shared_blobs_complete = true;\n-  log_info(aot, codecache,init)(\"All shared blobs recorded\");\n@@ -4391,1 +4074,1 @@\n-int AOTCodeAddressTable::id_for_address(address addr, RelocIterator reloc, CodeBuffer* buffer, CodeBlob* blob) {\n+int AOTCodeAddressTable::id_for_address(address addr, RelocIterator reloc, CodeBlob* blob) {\n@@ -4479,4 +4162,0 @@\n-          if (buffer != nullptr) {\n-            buffer->print_on(tty);\n-            buffer->decode();\n-          }\n@@ -4510,1 +4189,0 @@\n-#undef _c_str_base\n@@ -4608,1 +4286,1 @@\n-  LogStreamHandle(Info, aot, codecache, exit) log;\n+  LogStreamHandle(Debug, aot, codecache, exit) log;\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":114,"deletions":436,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class CodeBuffer;\n@@ -105,4 +104,0 @@\n-  uint   _code_offset; \/\/ Start of code in cache\n-  uint   _code_size;   \/\/ Total size of all code sections\n-  uint   _reloc_offset;\/\/ Relocations\n-  uint   _reloc_size;  \/\/ Max size of relocations per code section\n@@ -111,0 +106,4 @@\n+  uint   _blob_offset; \/\/ Start of archived blob in the cache\n+  uint   _code_offset; \/\/ Start of code for an entry of type \"Stub\"\n+  uint   _code_size;   \/\/ Size of code for an entry of type \"Stub\"\n+\n@@ -123,0 +122,1 @@\n+\n@@ -124,0 +124,1 @@\n+  \/\/ this constructor is used only by AOTCodeEntry::Stub\n@@ -125,9 +126,3 @@\n-           uint code_offset, uint code_size,\n-           uint reloc_offset, uint reloc_size,\n-           Kind kind, uint id,\n-           address dumptime_content_start_addr = nullptr,\n-           uint comp_level = 0,\n-           uint comp_id = 0, uint decomp = 0,\n-           bool has_clinit_barriers = false,\n-           bool for_preload = false,\n-           bool ignore_decompile = false) {\n+               uint code_offset, uint code_size,\n+               Kind kind, uint id) {\n+    assert(kind == AOTCodeEntry::Stub, \"sanity check\");\n@@ -138,1 +133,0 @@\n-\n@@ -143,0 +137,1 @@\n+    _blob_offset  = code_offset; \/\/ unused\n@@ -145,2 +140,0 @@\n-    _reloc_offset = reloc_offset;\n-    _reloc_size   = reloc_size;\n@@ -148,1 +141,1 @@\n-    _dumptime_content_start_addr = dumptime_content_start_addr;\n+    _dumptime_content_start_addr = nullptr;\n@@ -150,4 +143,3 @@\n-\n-    _comp_level   = comp_level;\n-    _comp_id      = comp_id;\n-    _decompile    = decomp;\n+    _comp_level   = 0;\n+    _comp_id      = 0;\n+    _decompile    = 0;\n@@ -155,2 +147,2 @@\n-    _has_clinit_barriers = has_clinit_barriers;\n-    _for_preload  = for_preload;\n+    _has_clinit_barriers = false;\n+    _for_preload  = false;\n@@ -160,1 +152,1 @@\n-    _ignore_decompile = ignore_decompile;\n+    _ignore_decompile = true;\n@@ -167,1 +159,6 @@\n-               address dumptime_content_start_addr) {\n+               address dumptime_content_start_addr,\n+               uint comp_level = 0,\n+               uint comp_id = 0, uint decomp = 0,\n+               bool has_clinit_barriers = false,\n+               bool for_preload = false,\n+               bool ignore_decompile = false) {\n@@ -176,4 +173,3 @@\n-    _code_offset  = blob_offset;\n-    _code_size    = 0;\n-    _reloc_offset = 0;\n-    _reloc_size   = 0;\n+    _blob_offset  = blob_offset;\n+    _code_offset  = blob_offset; \/\/ unused\n+    _code_size    = 0; \/\/ unused\n@@ -184,3 +180,3 @@\n-    _comp_level   = 0;\n-    _comp_id      = 0;\n-    _decompile    = 0;\n+    _comp_level   = comp_level;\n+    _comp_id      = comp_id;\n+    _decompile    = decomp;\n@@ -188,2 +184,6 @@\n-    _has_clinit_barriers = false;\n-    _for_preload  = false;\n+    _has_clinit_barriers = has_clinit_barriers;\n+    _for_preload  = for_preload;\n+    _loaded       = false;\n+    _not_entrant  = false;\n+    _load_fail    = false;\n+\n@@ -193,1 +193,0 @@\n-    _ignore_decompile = true;\n@@ -217,0 +216,1 @@\n+  uint blob_offset()  const { return _blob_offset; }\n@@ -219,2 +219,0 @@\n-  uint reloc_offset() const { return _reloc_offset; }\n-  uint reloc_size()   const { return _reloc_size; }\n@@ -222,1 +220,0 @@\n-  uint blob_offset()  const { return _code_offset; }\n@@ -225,6 +222,0 @@\n-\n-  static bool is_valid_entry_kind(Kind kind) { return kind > None && kind < Kind_count; }\n-  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n-  static bool is_adapter(Kind kind) { return kind == Adapter; }\n-  bool is_code()  { return _kind == Code; }\n-\n@@ -252,0 +243,5 @@\n+\n+  static bool is_valid_entry_kind(Kind kind) { return kind > None && kind < Kind_count; }\n+  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n+  static bool is_adapter(Kind kind) { return kind == Adapter; }\n+  bool is_code()  { return _kind == Code; }\n@@ -306,1 +302,1 @@\n-  int  id_for_address(address addr, RelocIterator iter, CodeBuffer* buffer, CodeBlob* blob = nullptr);\n+  int  id_for_address(address addr, RelocIterator iter, CodeBlob* blob);\n@@ -567,2 +563,1 @@\n-  bool write_relocations(CodeBlob& code_blob);\n-  bool write_debug_info(DebugInformationRecorder* recorder);\n+  bool write_relocations(CodeBlob& code_blob, GrowableArray<Handle>* oop_list = nullptr, GrowableArray<Metadata*>* metadata_list = nullptr);\n@@ -572,1 +567,0 @@\n-  bool write_nmethod_loadtime_relocations(JavaThread* thread, nmethod* nm, GrowableArray<Handle>& oop_list, GrowableArray<Metadata*>& metadata_list);\n@@ -576,2 +570,0 @@\n-  bool read_oops(OopRecorder* oop_recorder, ciMethod* target);\n-  bool read_metadata(OopRecorder* oop_recorder, ciMethod* target);\n@@ -581,1 +573,0 @@\n-  bool write_oops(OopRecorder* oop_recorder);\n@@ -583,1 +574,0 @@\n-  bool write_metadata(OopRecorder* oop_recorder);\n@@ -711,1 +701,0 @@\n-  bool compile_blob(CodeBuffer* buffer, int* pc_offset);\n@@ -718,2 +707,0 @@\n-  DebugInformationRecorder* read_debug_info(OopRecorder* oop_recorder);\n-\n@@ -730,1 +717,1 @@\n-  void fix_relocations(CodeBlob* code_blob);\n+  void fix_relocations(CodeBlob* code_blob, GrowableArray<Handle>* oop_list = nullptr, GrowableArray<Metadata*>* metadata_list = nullptr) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":44,"deletions":57,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -306,1 +306,0 @@\n-      archived_asm_remarks.clear();\n@@ -308,1 +307,0 @@\n-      archived_dbg_strings.clear();\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1252,10 +1252,10 @@\n-void nmethod::restore_from_archive(nmethod* archived_nm,\n-                                   const methodHandle& method,\n-                                   int compile_id,\n-                                   address reloc_data,\n-                                   GrowableArray<Handle>& oop_list,\n-                                   GrowableArray<Metadata*>& metadata_list,\n-                                   ImmutableOopMapSet* oop_maps,\n-                                   address immutable_data,\n-                                   GrowableArray<Handle>& reloc_imm_oop_list,\n-                                   GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+nmethod* nmethod::restore(address code_cache_buffer,\n+                          const methodHandle& method,\n+                          int compile_id,\n+                          address reloc_data,\n+                          GrowableArray<Handle>& oop_list,\n+                          GrowableArray<Metadata*>& metadata_list,\n+                          ImmutableOopMapSet* oop_maps,\n+                          address immutable_data,\n+                          GrowableArray<Handle>& reloc_imm_oop_list,\n+                          GrowableArray<Metadata*>& reloc_imm_metadata_list,\n@@ -1263,2 +1263,2 @@\n-                                   AsmRemarks& archived_asm_remarks,\n-                                   DbgStrings& archived_dbg_strings,\n+                          AsmRemarks& archived_asm_remarks,\n+                          DbgStrings& archived_dbg_strings,\n@@ -1266,1 +1266,1 @@\n-                                   AOTCodeReader* aot_code_reader)\n+                          AOTCodeReader* aot_code_reader)\n@@ -1268,17 +1268,7 @@\n-  archived_nm->copy_to((address)this);\n-  set_name(\"nmethod\");\n-  set_method(method());\n-\n-  _compile_id = compile_id;\n-  \/\/ allocate _mutable_data before copying relocation data because relocation data is now stored as part of mutable data area\n-  if (archived_nm->mutable_data_size() > 0) {\n-    _mutable_data = (address)os::malloc(archived_nm->mutable_data_size(), mtCode);\n-    if (_mutable_data == nullptr) {\n-      vm_exit_out_of_memory(archived_nm->mutable_data_size(), OOM_MALLOC_ERROR, \"codebuffer: no space for mutable data\");\n-    }\n-  }\n-  memcpy((address)relocation_begin(), reloc_data, archived_nm->relocation_size());\n-  set_oop_maps(oop_maps);\n-  set_immutable_data(immutable_data);\n-  copy_values(&oop_list);\n-  copy_values(&metadata_list);\n+  CodeBlob::restore(code_cache_buffer, \"nmethod\", reloc_data, oop_maps);\n+  nmethod* nm = (nmethod*)code_cache_buffer;\n+  nm->set_method(method());\n+  nm->_compile_id = compile_id;\n+  nm->set_immutable_data(immutable_data);\n+  nm->copy_values(&oop_list);\n+  nm->copy_values(&metadata_list);\n@@ -1286,1 +1276,1 @@\n-  aot_code_reader->apply_relocations(this, reloc_imm_oop_list, reloc_imm_metadata_list);\n+  aot_code_reader->fix_relocations(nm, &reloc_imm_oop_list, &reloc_imm_metadata_list);\n@@ -1289,6 +1279,2 @@\n-  AsmRemarks::init(asm_remarks());\n-  use_remarks(archived_asm_remarks);\n-  archived_asm_remarks.clear();\n-  DbgStrings::init(dbg_strings());\n-  use_strings(archived_dbg_strings);\n-  archived_dbg_strings.clear();\n+  nm->use_remarks(archived_asm_remarks);\n+  nm->use_strings(archived_dbg_strings);\n@@ -1298,1 +1284,1 @@\n-  ICache::invalidate_range(code_begin(), code_size());\n+  ICache::invalidate_range(nm->code_begin(), nm->code_size());\n@@ -1301,1 +1287,1 @@\n-  _pc_desc_container = new PcDescContainer(scopes_pcs_begin());\n+  nm->_pc_desc_container = new PcDescContainer(nm->scopes_pcs_begin());\n@@ -1303,1 +1289,1 @@\n-  set_aot_code_entry(aot_code_reader->aot_code_entry());\n+  nm->set_aot_code_entry(aot_code_reader->aot_code_entry());\n@@ -1305,1 +1291,2 @@\n-  post_init();\n+  nm->post_init();\n+  return nm;\n@@ -1330,15 +1317,15 @@\n-    nm = (nmethod *)CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(archived_nm->comp_level()));\n-    if (nm != nullptr) {\n-      nm->restore_from_archive(archived_nm,\n-                               method,\n-                               compile_id,\n-                               reloc_data,\n-                               oop_list,\n-                               metadata_list,\n-                               oop_maps,\n-                               immutable_data,\n-                               reloc_imm_oop_list,\n-                               reloc_imm_metadata_list,\n-                               NOT_PRODUCT_ARG(asm_remarks)\n-                               NOT_PRODUCT_ARG(dbg_strings)\n-                               aot_code_reader);\n+    address code_cache_buffer = (address)CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(archived_nm->comp_level()));\n+    if (code_cache_buffer != nullptr) {\n+      nm = archived_nm->restore(code_cache_buffer,\n+                                method,\n+                                compile_id,\n+                                reloc_data,\n+                                oop_list,\n+                                metadata_list,\n+                                oop_maps,\n+                                immutable_data,\n+                                reloc_imm_oop_list,\n+                                reloc_imm_metadata_list,\n+                                NOT_PRODUCT_ARG(asm_remarks)\n+                                NOT_PRODUCT_ARG(dbg_strings)\n+                                aot_code_reader);\n@@ -4276,2 +4263,2 @@\n-void nmethod::prepare_for_archiving() {\n-  CodeBlob::prepare_for_archiving();\n+void nmethod::prepare_for_archiving_impl() {\n+  CodeBlob::prepare_for_archiving_impl();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":45,"deletions":58,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -487,10 +487,10 @@\n-  void restore_from_archive(nmethod* archived_nm,\n-                            const methodHandle& method,\n-                            int compile_id,\n-                            address reloc_data,\n-                            GrowableArray<Handle>& oop_list,\n-                            GrowableArray<Metadata*>& metadata_list,\n-                            ImmutableOopMapSet* oop_maps,\n-                            address immutable_data,\n-                            GrowableArray<Handle>& reloc_imm_oop_list,\n-                            GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+  nmethod* restore(address code_cache_buffer,\n+                   const methodHandle& method,\n+                   int compile_id,\n+                   address reloc_data,\n+                   GrowableArray<Handle>& oop_list,\n+                   GrowableArray<Metadata*>& metadata_list,\n+                   ImmutableOopMapSet* oop_maps,\n+                   address immutable_data,\n+                   GrowableArray<Handle>& reloc_imm_oop_list,\n+                   GrowableArray<Metadata*>& reloc_imm_metadata_list,\n@@ -498,2 +498,2 @@\n-                            AsmRemarks& asm_remarks,\n-                            DbgStrings& dbg_strings,\n+                   AsmRemarks& asm_remarks,\n+                   DbgStrings& dbg_strings,\n@@ -501,1 +501,1 @@\n-                            AOTCodeReader* aot_code_reader);\n+                   AOTCodeReader* aot_code_reader);\n@@ -1061,1 +1061,1 @@\n-  void prepare_for_archiving();\n+  void prepare_for_archiving_impl();\n@@ -1071,0 +1071,3 @@\n+    void prepare_for_archiving(CodeBlob* instance) const override {\n+      ((nmethod*)instance)->prepare_for_archiving_impl();\n+    };\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -184,1 +184,0 @@\n-  initialize_misc();\n@@ -186,3 +185,2 @@\n-    _code = cb->as_nmethod();\n-  } else {\n-    _code = nullptr;\n+    initialize(cb->as_nmethod(), nullptr, nullptr);\n+    return;\n@@ -190,0 +188,2 @@\n+  initialize_misc();\n+  _code = nullptr;\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}