{"files":[{"patch":"@@ -147,2 +147,0 @@\n-\n-  NOT_PRODUCT(clear_strings());\n@@ -1109,1 +1107,2 @@\n-AsmRemarks::AsmRemarks() : _remarks(new AsmRemarkCollection()) {\n+AsmRemarks::AsmRemarks() {\n+  init();\n@@ -1117,1 +1116,1 @@\n-  assert(_remarks == nullptr, \"Must 'clear()' before deleting!\");\n+  assert(_remarks == nullptr, \"must be\");\n@@ -1120,2 +1119,2 @@\n-void AsmRemarks::init(AsmRemarks& asm_remarks) {\n-  asm_remarks._remarks = new AsmRemarkCollection();\n+void AsmRemarks::init() {\n+  _remarks = new AsmRemarkCollection();\n@@ -1169,0 +1168,1 @@\n+  init();\n@@ -1176,1 +1176,1 @@\n-  assert(_strings == nullptr, \"Must 'clear()' before deleting!\");\n+  assert(_strings == nullptr, \"must be\");\n@@ -1179,2 +1179,2 @@\n-void DbgStrings::init(DbgStrings& dbg_strings) {\n-  dbg_strings._strings = new DbgStringCollection();\n+void DbgStrings::init() {\n+  _strings = new DbgStringCollection();\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  static void init(AsmRemarks& asm_remarks);\n+  void init();\n@@ -457,1 +457,1 @@\n-  static void init(DbgStrings& dbg_strings);\n+  void init();\n@@ -828,5 +828,0 @@\n-\n-  void clear_strings() {\n-    _asm_remarks.clear();\n-    _dbg_strings.clear();\n-  }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1117,1 +1117,1 @@\n-void ciEnv::register_aot_method(JavaThread* thread,\n+nmethod* ciEnv::register_aot_method(JavaThread* thread,\n@@ -1128,4 +1128,0 @@\n-#ifndef PRODUCT\n-                                AsmRemarks& asm_remarks,\n-                                DbgStrings& dbg_strings,\n-#endif \/* PRODUCT *\/\n@@ -1154,1 +1150,1 @@\n-      return;\n+      return nullptr;\n@@ -1168,2 +1164,0 @@\n-                              NOT_PRODUCT_ARG(asm_remarks)\n-                              NOT_PRODUCT_ARG(dbg_strings)\n@@ -1186,0 +1180,1 @@\n+  return nm;\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -375,16 +375,12 @@\n-  void register_aot_method(JavaThread* thread,\n-                           ciMethod* target,\n-                           AbstractCompiler* compiler,\n-                           nmethod* archived_nm,\n-                           address reloc_data,\n-                           GrowableArray<Handle>& oop_list,\n-                           GrowableArray<Metadata*>& metadata_list,\n-                           ImmutableOopMapSet* oopmaps,\n-                           address immutable_data,\n-                           GrowableArray<Handle>& reloc_imm_oop_list,\n-                           GrowableArray<Metadata*>& reloc_imm_metadata_list,\n-#ifndef PRODUCT\n-                           AsmRemarks& asm_remarks,\n-                           DbgStrings& dbg_strings,\n-#endif \/* PRODUCT *\/\n-                           AOTCodeReader* aot_code_reader);\n+  nmethod* register_aot_method(JavaThread* thread,\n+                               ciMethod* target,\n+                               AbstractCompiler* compiler,\n+                               nmethod* archived_nm,\n+                               address reloc_data,\n+                               GrowableArray<Handle>& oop_list,\n+                               GrowableArray<Metadata*>& metadata_list,\n+                               ImmutableOopMapSet* oopmaps,\n+                               address immutable_data,\n+                               GrowableArray<Handle>& reloc_imm_oop_list,\n+                               GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+                               AOTCodeReader* aot_code_reader);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"asm\/codeBuffer.hpp\"\n@@ -1419,1 +1418,1 @@\n-  if (!cache->write_asm_remarks(blob)) {\n+  if (!cache->write_asm_remarks(blob.asm_remarks(), \/* use_string_table *\/ true)) {\n@@ -1422,1 +1421,1 @@\n-  if (!cache->write_dbg_strings(blob)) {\n+  if (!cache->write_dbg_strings(blob.dbg_strings(), \/* use_string_table *\/ true)) {\n@@ -1494,1 +1493,1 @@\n-  uint offset = entry_position + _entry->blob_offset();\n+  uint offset = entry_position + _entry->code_offset();\n@@ -1507,7 +1506,0 @@\n-#ifndef PRODUCT\n-  AsmRemarks asm_remarks;\n-  read_asm_remarks(asm_remarks);\n-  DbgStrings dbg_strings;\n-  read_dbg_strings(dbg_strings);\n-#endif \/\/ PRODUCT\n-\n@@ -1518,4 +1510,0 @@\n-#ifndef PRODUCT\n-                                         , asm_remarks\n-                                         , dbg_strings\n-#endif\n@@ -1527,0 +1515,7 @@\n+#ifndef PRODUCT\n+  code_blob->asm_remarks().init();\n+  read_asm_remarks(code_blob->asm_remarks(), \/* use_string_table *\/ true);\n+  code_blob->dbg_strings().init();\n+  read_dbg_strings(code_blob->dbg_strings(), \/* use_string_table *\/ true);\n+#endif \/\/ PRODUCT\n+\n@@ -1604,2 +1599,2 @@\n-                                        code_offset, code_size, 0, 0,\n-                                        AOTCodeEntry::Stub, (uint32_t)id);\n+                                                code_offset, code_size,\n+                                                AOTCodeEntry::Stub, (uint32_t)id);\n@@ -1679,0 +1674,2 @@\n+  AOTCodeCache* cache = open_for_dump();\n+  assert(cache != nullptr, \"sanity check\");\n@@ -1758,6 +1755,0 @@\n-  uint archived_nm_offset = _write_position - entry_position;\n-  nmethod* archived_nm = (nmethod*)reserve_bytes(nm->size());\n-  if (archived_nm == nullptr) {\n-    return nullptr;\n-  }\n-  nm->copy_to((address)archived_nm);\n@@ -1765,30 +1756,2 @@\n-  archived_nm->prepare_for_archiving();\n-\n-#ifndef PRODUCT\n-  \/\/ Write asm remarks\n-  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n-  if (count_ptr == nullptr) {\n-    return nullptr;\n-  }\n-  uint count = 0;\n-  bool result = nm->asm_remarks().iterate([&] (uint offset, const char* str) -> bool {\n-    log_info(aot, codecache, nmethod)(\"asm remark offset=%d, str=%s\", offset, str);\n-    n = write_bytes(&offset, sizeof(uint));\n-    if (n != sizeof(uint)) {\n-      return false;\n-    }\n-    n = write_bytes(str, (uint)strlen(str) + 1);\n-    if (n != strlen(str) + 1) {\n-      return false;\n-    }\n-    count += 1;\n-    return true;\n-  });\n-  if (!result) {\n-    return nullptr;\n-  }\n-  *count_ptr = count;\n-\n-  \/\/ Write dbg strings\n-  count_ptr = (uint *)reserve_bytes(sizeof(uint));\n-  if (count_ptr == nullptr) {\n+  \/\/ Write CodeBlob\n+  if (!cache->align_write()) {\n@@ -1797,11 +1760,3 @@\n-  count = 0;\n-  result = nm->dbg_strings().iterate([&] (const char* str) -> bool {\n-    log_info(aot, codecache, nmethod)(\"dbg string[\" INTPTR_FORMAT \"]=%s\", p2i(str), str);\n-    n = write_bytes(str, (uint)strlen(str) + 1);\n-    if (n != strlen(str) + 1) {\n-      return false;\n-    }\n-    count += 1;\n-    return true;\n-  });\n-  if (!result) {\n+  uint blob_offset = cache->_write_position - entry_position;\n+  address archive_buffer = cache->reserve_bytes(nm->size());\n+  if (archive_buffer == nullptr) {\n@@ -1810,2 +1765,1 @@\n-  *count_ptr = count;\n-#endif \/* PRODUCT *\/\n+  CodeBlob::archive_blob(nm, archive_buffer);\n@@ -1835,2 +1789,6 @@\n-  if (!write_oop_map_set(*nm)) {\n-    return nullptr;\n+  bool has_oop_maps = false;\n+  if (nm->oop_maps() != nullptr) {\n+    if (!cache->write_oop_map_set(*nm)) {\n+      return nullptr;\n+    }\n+    has_oop_maps = true;\n@@ -1859,1 +1817,9 @@\n-  if (!write_nmethod_loadtime_relocations(thread, nm, oop_list, metadata_list)) {\n+  if (!write_relocations(*nm, &oop_list, &metadata_list)) {\n+    return nullptr;\n+  }\n+\n+#ifndef PRODUCT\n+  if (!cache->write_asm_remarks(nm->asm_remarks(), \/* use_string_table *\/ false)) {\n+    return nullptr;\n+  }\n+  if (!cache->write_dbg_strings(nm->dbg_strings(), \/* use_string_table *\/ false)) {\n@@ -1862,0 +1828,1 @@\n+#endif \/* PRODUCT *\/\n@@ -1864,4 +1831,6 @@\n-  AOTCodeEntry* entry = new (this) AOTCodeEntry(entry_position, entry_size, name_offset, name_size,\n-                                        archived_nm_offset, 0, 0, 0,\n-                                        AOTCodeEntry::Code, hash, nm->content_begin(), comp_level, comp_id, decomp,\n-                                        nm->has_clinit_barriers(), for_preload, ignore_decompile);\n+  AOTCodeEntry* entry = new (this) AOTCodeEntry(AOTCodeEntry::Code, hash,\n+                                                entry_position, entry_size,\n+                                                name_offset, name_size,\n+                                                blob_offset, has_oop_maps,\n+                                                nm->content_begin(), comp_level, comp_id, decomp,\n+                                                nm->has_clinit_barriers(), for_preload, ignore_decompile);\n@@ -1949,27 +1918,0 @@\n-#ifndef PRODUCT\n-  \/\/ Read asm remarks\n-  offset = read_position();\n-  uint count = *(uint *)addr(offset);\n-  offset += sizeof(uint);\n-  AsmRemarks asm_remarks;\n-  for (uint i = 0; i < count; i++) {\n-    uint remark_offset = *(uint *)addr(offset);\n-    offset += sizeof(uint);\n-    const char* remark = (const char*)addr(offset);\n-    offset += (uint)strlen(remark)+1;\n-    asm_remarks.insert(remark_offset, remark);\n-  }\n-  set_read_position(offset);\n-\n-  \/\/ Read dbg strings\n-  count = *(uint *)addr(offset);\n-  offset += sizeof(uint);\n-  DbgStrings dbg_strings;\n-  for (uint i = 0; i < count; i++) {\n-    const char* str = (const char*)addr(offset);\n-    offset += (uint)strlen(str)+1;\n-    dbg_strings.insert(str);\n-  }\n-  set_read_position(offset);\n-#endif \/* PRODUCT *\/\n-\n@@ -2015,14 +1957,12 @@\n-  env->register_aot_method(THREAD,\n-                           target,\n-                           compiler,\n-                           archived_nm,\n-                           reloc_data,\n-                           oop_list,\n-                           metadata_list,\n-                           oopmaps,\n-                           immutable_data,\n-                           reloc_immediate_oop_list,\n-                           reloc_immediate_metadata_list,\n-                           NOT_PRODUCT_ARG(asm_remarks)\n-                           NOT_PRODUCT_ARG(dbg_strings)\n-                           this);\n+  nm = env->register_aot_method(THREAD,\n+                                target,\n+                                compiler,\n+                                archived_nm,\n+                                reloc_data,\n+                                oop_list,\n+                                metadata_list,\n+                                oopmaps,\n+                                immutable_data,\n+                                reloc_immediate_oop_list,\n+                                reloc_immediate_metadata_list,\n+                                this);\n@@ -2036,1 +1976,0 @@\n-      nmethod* nm = target->get_Method()->code();\n@@ -2141,1 +2080,1 @@\n-bool AOTCodeCache::write_relocations(CodeBlob& code_blob) {\n+bool AOTCodeCache::write_relocations(CodeBlob& code_blob, GrowableArray<Handle>* oop_list, GrowableArray<Metadata*>* metadata_list) {\n@@ -2149,0 +2088,41 @@\n+      break;\n+      case relocInfo::oop_type: {\n+        oop_Relocation* r = (oop_Relocation*)iter.reloc();\n+        if (r->oop_is_immediate()) {\n+          assert(oop_list != nullptr, \"sanity check\");\n+          \/\/ store index of oop in the reloc immediate oop list\n+          Handle h(JavaThread::current(), r->oop_value());\n+          int oop_idx = oop_list->find(h);\n+          assert(oop_idx != -1, \"sanity check\");\n+          reloc_data.at_put(idx, (uint)oop_idx);\n+        }\n+        break;\n+      }\n+      case relocInfo::metadata_type: {\n+        metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n+        if (r->metadata_is_immediate()) {\n+          assert(metadata_list != nullptr, \"sanity check\");\n+          \/\/ store index of metadata in the reloc immediate metadata list\n+          int metadata_idx = metadata_list->find(r->metadata_value());\n+          assert(metadata_idx != -1, \"sanity check\");\n+          reloc_data.at_put(idx, (uint)metadata_idx);\n+        }\n+        break;\n+      }\n+      case relocInfo::virtual_call_type:  \/\/ Fall through. They all call resolve_*_call blobs.\n+      case relocInfo::opt_virtual_call_type:\n+      case relocInfo::static_call_type: {\n+        CallRelocation* r = (CallRelocation*)iter.reloc();\n+        address dest = r->destination();\n+        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n+          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n+        }\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::trampoline_stub_type: {\n+        address dest = ((trampoline_stub_Relocation*)iter.reloc())->destination();\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::static_stub_type:\n@@ -2157,1 +2137,1 @@\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, &code_blob));\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n@@ -2166,1 +2146,1 @@\n-        reloc_data.at_put(idx, _table->id_for_address(target, iter, nullptr, &code_blob));\n+        reloc_data.at_put(idx, _table->id_for_address(target, iter, &code_blob));\n@@ -2173,0 +2153,4 @@\n+      case relocInfo::poll_type:\n+        break;\n+      case relocInfo::poll_return_type:\n+        break;\n@@ -2175,0 +2159,2 @@\n+      case relocInfo::entry_guard_type:\n+        break;\n@@ -2199,5 +2185,5 @@\n-void AOTCodeReader::apply_relocations(nmethod* nm, GrowableArray<Handle> &oop_list, GrowableArray<Metadata*> &metadata_list) {\n-  LogStreamHandle(Info, aot, codecache, reloc) log;\n-  uint buffer_offset = read_position();\n-  int count = *(int*)addr(buffer_offset);\n-  buffer_offset += sizeof(int);\n+void AOTCodeReader::fix_relocations(CodeBlob* code_blob, GrowableArray<Handle>* oop_list, GrowableArray<Metadata*>* metadata_list) {\n+  LogStreamHandle(Trace, aot, reloc) log;\n+  uint offset = read_position();\n+  int count = *(int*)addr(offset);\n+  offset += sizeof(int);\n@@ -2207,3 +2193,3 @@\n-  uint* reloc_data = (uint*)addr(buffer_offset);\n-  buffer_offset += (count * sizeof(uint));\n-  set_read_position(buffer_offset);\n+  uint* reloc_data = (uint*)addr(offset);\n+  offset += (count * sizeof(uint));\n+  set_read_position(offset);\n@@ -2211,1 +2197,1 @@\n-  RelocIterator iter(nm);\n+  RelocIterator iter(code_blob);\n@@ -2213,1 +2199,0 @@\n-\n@@ -2219,0 +2204,1 @@\n+        assert(code_blob->is_nmethod(), \"sanity check\");\n@@ -2221,1 +2207,2 @@\n-          Handle h = oop_list.at(reloc_data[j]);\n+          assert(oop_list != nullptr, \"sanity check\");\n+          Handle h = oop_list->at(reloc_data[j]);\n@@ -2229,0 +2216,1 @@\n+        assert(code_blob->is_nmethod(), \"sanity check\");\n@@ -2232,1 +2220,2 @@\n-          m = metadata_list.at(reloc_data[j]);\n+          assert(metadata_list != nullptr, \"sanity check\");\n+          m = metadata_list->at(reloc_data[j]);\n@@ -2236,1 +2225,1 @@\n-          m = nm->metadata_at(index);\n+          m = code_blob->as_nmethod()->metadata_at(index);\n@@ -2266,71 +2255,0 @@\n-      case relocInfo::runtime_call_w_cp_type:\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n-        \/\/address destination = iter.reloc()->value();\n-        break;\n-      case relocInfo::external_word_type: {\n-        address target = _cache->address_for_id(reloc_data[j]);\n-        \/\/ Add external address to global table\n-        int index = ExternalsRecorder::find_index(target);\n-        \/\/ Update index in relocation\n-        Relocation::add_jint(iter.data(), index);\n-        external_word_Relocation* reloc = (external_word_Relocation*)iter.reloc();\n-        assert(reloc->target() == target, \"sanity\");\n-        reloc->set_value(target); \/\/ Patch address in the code\n-        break;\n-      }\n-      case relocInfo::internal_word_type: {\n-        internal_word_Relocation* r = (internal_word_Relocation*)iter.reloc();\n-        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), nm->content_begin());\n-        break;\n-      }\n-      case relocInfo::section_word_type: {\n-        section_word_Relocation* r = (section_word_Relocation*)iter.reloc();\n-        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), nm->content_begin());\n-        break;\n-      }\n-      case relocInfo::poll_type:\n-        break;\n-      case relocInfo::poll_return_type:\n-        break;\n-      case relocInfo::post_call_nop_type:\n-        break;\n-      case relocInfo::entry_guard_type:\n-        break;\n-      default:\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n-        break;\n-    }\n-    if (log.is_enabled()) {\n-      iter.print_current_on(&log);\n-    }\n-    j++;\n-  }\n-  assert(j == count, \"must be\");\n-}\n-\n-\n-void AOTCodeReader::fix_relocations(CodeBlob* code_blob) {\n-  LogStreamHandle(Trace, aot, reloc) log;\n-  uint offset = read_position();\n-  int count = *(int*)addr(offset);\n-  offset += sizeof(int);\n-  if (log.is_enabled()) {\n-    log.print_cr(\"======== extra relocations count=%d\", count);\n-  }\n-  uint* reloc_data = (uint*)addr(offset);\n-  offset += (count * sizeof(uint));\n-  set_read_position(offset);\n-\n-  RelocIterator iter(code_blob);\n-  int j = 0;\n-  while (iter.next()) {\n-    switch (iter.type()) {\n-      case relocInfo::none:\n-        break;\n-      case relocInfo::runtime_call_type: {\n-        address dest = _cache->address_for_id(reloc_data[j]);\n-        if (dest != (address)-1) {\n-          ((CallRelocation*)iter.reloc())->set_destination(dest);\n-        }\n-        break;\n-      }\n@@ -2361,89 +2279,0 @@\n-      case relocInfo::post_call_nop_type:\n-        break;\n-      default:\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n-        break;\n-    }\n-    if (log.is_enabled()) {\n-      iter.print_current_on(&log);\n-    }\n-    j++;\n-  }\n-  assert(j == count, \"sanity\");\n-}\n-\n-bool AOTCodeCache::write_nmethod_loadtime_relocations(JavaThread* thread, nmethod* nm, GrowableArray<Handle>& oop_list, GrowableArray<Metadata*>& metadata_list) {\n-  LogStreamHandle(Info, aot, codecache, reloc) log;\n-  GrowableArray<uint> reloc_data;\n-  \/\/ Collect additional data\n-  RelocIterator iter(nm);\n-  bool has_immediate = false;\n-  while (iter.next()) {\n-    int idx = reloc_data.append(0); \/\/ default value\n-    switch (iter.type()) {\n-      case relocInfo::none:\n-      break;\n-      case relocInfo::oop_type: {\n-        oop_Relocation* r = (oop_Relocation*)iter.reloc();\n-        if (r->oop_is_immediate()) {\n-          \/\/ store index of oop in the reloc immediate oop list\n-          Handle h(thread, r->oop_value());\n-          int oop_idx = oop_list.find(h);\n-          assert(oop_idx != -1, \"sanity check\");\n-          reloc_data.at_put(idx, (uint)oop_idx);\n-          has_immediate = true;\n-        }\n-        break;\n-      }\n-      case relocInfo::metadata_type: {\n-        metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n-        if (r->metadata_is_immediate()) {\n-          \/\/ store index of metadata in the reloc immediate metadata list\n-          int metadata_idx = metadata_list.find(r->metadata_value());\n-          assert(metadata_idx != -1, \"sanity check\");\n-          reloc_data.at_put(idx, (uint)metadata_idx);\n-          has_immediate = true;\n-        }\n-        break;\n-      }\n-      case relocInfo::virtual_call_type:  \/\/ Fall through. They all call resolve_*_call blobs.\n-      case relocInfo::opt_virtual_call_type:\n-      case relocInfo::static_call_type: {\n-        CallRelocation* r = (CallRelocation*)iter.reloc();\n-        address dest = r->destination();\n-        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n-          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n-        }\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::trampoline_stub_type: {\n-        address dest = ((trampoline_stub_Relocation*)iter.reloc())->destination();\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::static_stub_type:\n-        break;\n-      case relocInfo::runtime_call_type: {\n-        \/\/ Record offset of runtime destination\n-        CallRelocation* r = (CallRelocation*)iter.reloc();\n-        address dest = r->destination();\n-        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n-          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n-        }\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::runtime_call_w_cp_type:\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n-        break;\n-      case relocInfo::external_word_type: {\n-        \/\/ Record offset of runtime target\n-        address target = ((external_word_Relocation*)iter.reloc())->target();\n-        reloc_data.at_put(idx, _table->id_for_address(target, iter, nullptr, nm));\n-        break;\n-      }\n-      case relocInfo::internal_word_type:\n-        break;\n-      case relocInfo::section_word_type:\n-        break;\n@@ -2465,0 +2294,1 @@\n+    j++;\n@@ -2466,20 +2296,1 @@\n-\n-  \/\/ Write additional relocation data: uint per relocation\n-  \/\/ Write the count first\n-  int count = reloc_data.length();\n-  write_bytes(&count, sizeof(int));\n-  uint data_size = count * sizeof(uint);\n-  for (GrowableArrayIterator<uint> iter = reloc_data.begin();\n-       iter != reloc_data.end(); ++iter) {\n-    uint value = *iter;\n-    int n = write_bytes(&value, sizeof(uint));\n-    if (n != sizeof(uint)) {\n-      return false;\n-      break;\n-    }\n-  }\n-\n-  if (!align_write()) {\n-    return false;\n-  }\n-  return true; \/\/success;\n+  assert(j == count, \"sanity\");\n@@ -2515,53 +2326,0 @@\n-bool AOTCodeCache::write_debug_info(DebugInformationRecorder* recorder) {\n-  if (!align_write()) {\n-    return false;\n-  }\n-  \/\/ Don't call data_size() and pcs_size(). They will freeze OopRecorder.\n-  int data_size = recorder->stream()->position(); \/\/ In bytes\n-  uint n = write_bytes(&data_size, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  int pcs_length = recorder->pcs_length(); \/\/ In bytes\n-  n = write_bytes(&pcs_length, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  n = write_bytes(recorder->stream()->buffer(), data_size);\n-  if (n != (uint)data_size) {\n-    return false;\n-  }\n-  uint pcs_size = pcs_length * sizeof(PcDesc);\n-  n = write_bytes(recorder->pcs(), pcs_size);\n-  if (n != pcs_size) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n-DebugInformationRecorder* AOTCodeReader::read_debug_info(OopRecorder* oop_recorder) {\n-  uint code_offset = align_up(read_position(), DATA_ALIGNMENT);\n-  int data_size  = *(int*)addr(code_offset);\n-  code_offset   += sizeof(int);\n-  int pcs_length = *(int*)addr(code_offset);\n-  code_offset   += sizeof(int);\n-\n-  log_debug(aot, codecache)(\"======== read DebugInfo [%d, %d]:\", data_size, pcs_length);\n-\n-  \/\/ Aligned initial sizes\n-  int data_size_align  = align_up(data_size, DATA_ALIGNMENT);\n-  int pcs_length_align = pcs_length + 1;\n-  assert(sizeof(PcDesc) > DATA_ALIGNMENT, \"sanity\");\n-  DebugInformationRecorder* recorder = new DebugInformationRecorder(oop_recorder, data_size_align, pcs_length);\n-\n-  copy_bytes(addr(code_offset), recorder->stream()->buffer(), data_size_align);\n-  recorder->stream()->set_position(data_size);\n-  code_offset += data_size;\n-\n-  uint pcs_size = pcs_length * sizeof(PcDesc);\n-  copy_bytes(addr(code_offset), (address)recorder->pcs(), pcs_size);\n-  code_offset += pcs_size;\n-  set_read_position(code_offset);\n-  return recorder;\n-}\n-\n@@ -2581,30 +2339,0 @@\n-bool AOTCodeCache::write_metadata(OopRecorder* oop_recorder) {\n-  int metadata_count = oop_recorder->metadata_count();\n-  uint n = write_bytes(&metadata_count, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-\n-  log_debug(aot, codecache)(\"======== write metadata [%d]:\", metadata_count);\n-\n-  for (int i = 1; i < metadata_count; i++) { \/\/ skip first virtual nullptr\n-    Metadata* m = oop_recorder->metadata_at(i);\n-    LogStreamHandle(Debug, aot, codecache, metadata) log;\n-    if (log.is_enabled()) {\n-      log.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(m));\n-      if (m == (Metadata*)Universe::non_oop_word()) {\n-        log.print(\"non-metadata word\");\n-      } else if (m == nullptr) {\n-        log.print(\"nullptr-oop\");\n-      } else {\n-        Metadata::print_value_on_maybe_null(&log, m);\n-      }\n-      log.cr();\n-    }\n-    if (!write_metadata(m)) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -2650,43 +2378,0 @@\n-bool AOTCodeReader::read_metadata(OopRecorder* oop_recorder, ciMethod* target) {\n-  uint code_offset = read_position();\n-  int metadata_count = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  set_read_position(code_offset);\n-\n-  log_debug(aot, codecache)(\"======== read metadata [%d]:\", metadata_count);\n-\n-  if (metadata_count == 0) {\n-    return true;\n-  }\n-  {\n-    VM_ENTRY_MARK;\n-    methodHandle comp_method(THREAD, target->get_Method());\n-\n-    for (int i = 1; i < metadata_count; i++) {\n-      Metadata* m = read_metadata(comp_method);\n-      if (lookup_failed()) {\n-        return false;\n-      }\n-      if (oop_recorder->is_real(m)) {\n-        oop_recorder->find_index(m);\n-      } else {\n-        oop_recorder->allocate_metadata_index(m);\n-      }\n-      LogTarget(Debug, aot, codecache, metadata) log;\n-      if (log.is_enabled()) {\n-        LogStream ls(log);\n-        ls.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(m));\n-        if (m == (Metadata*)Universe::non_oop_word()) {\n-          ls.print(\"non-metadata word\");\n-        } else if (m == nullptr) {\n-          ls.print(\"nullptr-oop\");\n-        } else {\n-          Metadata::print_value_on_maybe_null(&ls, m);\n-        }\n-        ls.cr();\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -3161,29 +2846,0 @@\n-bool AOTCodeCache::write_oops(OopRecorder* oop_recorder) {\n-  int oop_count = oop_recorder->oop_count();\n-  uint n = write_bytes(&oop_count, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  log_debug(aot, codecache)(\"======== write oops [%d]:\", oop_count);\n-\n-  for (int i = 1; i < oop_count; i++) { \/\/ skip first virtual nullptr\n-    jobject jo = oop_recorder->oop_at(i);\n-    LogStreamHandle(Info, aot, codecache, oops) log;\n-    if (log.is_enabled()) {\n-      log.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(jo));\n-      if (jo == (jobject)Universe::non_oop_word()) {\n-        log.print(\"non-oop word\");\n-      } else if (jo == nullptr) {\n-        log.print(\"nullptr-oop\");\n-      } else {\n-        JNIHandles::resolve(jo)->print_value_on(&log);\n-      }\n-      log.cr();\n-    }\n-    if (!write_oop(jo)) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -3302,40 +2958,0 @@\n-bool AOTCodeReader::read_oops(OopRecorder* oop_recorder, ciMethod* target) {\n-  uint code_offset = read_position();\n-  int oop_count = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  set_read_position(code_offset);\n-  log_debug(aot, codecache)(\"======== read oops [%d]:\", oop_count);\n-  if (oop_count == 0) {\n-    return true;\n-  }\n-  {\n-    VM_ENTRY_MARK;\n-    methodHandle comp_method(THREAD, target->get_Method());\n-    for (int i = 1; i < oop_count; i++) {\n-      oop obj = read_oop(THREAD, comp_method);\n-      if (lookup_failed()) {\n-        return false;\n-      }\n-      jobject jo = JNIHandles::make_local(THREAD, obj);\n-      if (oop_recorder->is_real(jo)) {\n-        oop_recorder->find_index(jo);\n-      } else {\n-        oop_recorder->allocate_oop_index(jo);\n-      }\n-      LogStreamHandle(Debug, aot, codecache, oops) log;\n-      if (log.is_enabled()) {\n-        log.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(jo));\n-        if (jo == (jobject)Universe::non_oop_word()) {\n-          log.print(\"non-oop word\");\n-        } else if (jo == nullptr) {\n-          log.print(\"nullptr-oop\");\n-        } else {\n-          JNIHandles::resolve(jo)->print_value_on(&log);\n-        }\n-        log.cr();\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -3521,1 +3137,1 @@\n-bool AOTCodeCache::write_asm_remarks(CodeBlob& cb) {\n+bool AOTCodeCache::write_asm_remarks(AsmRemarks& asm_remarks, bool use_string_table) {\n@@ -3528,1 +3144,1 @@\n-  bool result = cb.asm_remarks().iterate([&] (uint offset, const char* str) -> bool {\n+  bool result = asm_remarks.iterate([&] (uint offset, const char* str) -> bool {\n@@ -3534,6 +3150,13 @@\n-    const char* cstr = add_C_string(str);\n-    int id = _table->id_for_C_string((address)cstr);\n-    assert(id != -1, \"asm remark string '%s' not found in AOTCodeAddressTable\", str);\n-    n = write_bytes(&id, sizeof(int));\n-    if (n != sizeof(int)) {\n-      return false;\n+    if (use_string_table) {\n+      const char* cstr = add_C_string(str);\n+      int id = _table->id_for_C_string((address)cstr);\n+      assert(id != -1, \"asm remark string '%s' not found in AOTCodeAddressTable\", str);\n+      n = write_bytes(&id, sizeof(int));\n+      if (n != sizeof(int)) {\n+        return false;\n+      }\n+    } else {\n+      n = write_bytes(str, (uint)strlen(str) + 1);\n+      if (n != strlen(str) + 1) {\n+        return false;\n+      }\n@@ -3548,1 +3171,1 @@\n-void AOTCodeReader::read_asm_remarks(AsmRemarks& asm_remarks) {\n+void AOTCodeReader::read_asm_remarks(AsmRemarks& asm_remarks, bool use_string_table) {\n@@ -3556,3 +3179,9 @@\n-    int remark_string_id = *(uint *)addr(offset);\n-    offset += sizeof(int);\n-    const char* remark = (const char*)_cache->address_for_C_string(remark_string_id);\n+    const char* remark = nullptr;\n+    if (use_string_table) {\n+      int remark_string_id = *(uint *)addr(offset);\n+      offset += sizeof(int);\n+      remark = (const char*)_cache->address_for_C_string(remark_string_id);\n+    } else {\n+      remark = (const char*)addr(offset);\n+      offset += (uint)strlen(remark)+1;\n+    }\n@@ -3564,1 +3193,1 @@\n-bool AOTCodeCache::write_dbg_strings(CodeBlob& cb) {\n+bool AOTCodeCache::write_dbg_strings(DbgStrings& dbg_strings, bool use_string_table) {\n@@ -3571,1 +3200,1 @@\n-  bool result = cb.dbg_strings().iterate([&] (const char* str) -> bool {\n+  bool result = dbg_strings.iterate([&] (const char* str) -> bool {\n@@ -3573,6 +3202,13 @@\n-    const char* cstr = add_C_string(str);\n-    int id = _table->id_for_C_string((address)cstr);\n-    assert(id != -1, \"db string '%s' not found in AOTCodeAddressTable\", str);\n-    uint n = write_bytes(&id, sizeof(int));\n-    if (n != sizeof(int)) {\n-      return false;\n+    if (use_string_table) {\n+      const char* cstr = add_C_string(str);\n+      int id = _table->id_for_C_string((address)cstr);\n+      assert(id != -1, \"db string '%s' not found in AOTCodeAddressTable\", str);\n+      uint n = write_bytes(&id, sizeof(int));\n+      if (n != sizeof(int)) {\n+        return false;\n+      }\n+    } else {\n+      uint n = write_bytes(str, (uint)strlen(str) + 1);\n+      if (n != strlen(str) + 1) {\n+        return false;\n+      }\n@@ -3587,1 +3223,1 @@\n-void AOTCodeReader::read_dbg_strings(DbgStrings& dbg_strings) {\n+void AOTCodeReader::read_dbg_strings(DbgStrings& dbg_strings, bool use_string_table) {\n@@ -3593,3 +3229,9 @@\n-    int string_id = *(uint *)addr(offset);\n-    offset += sizeof(int);\n-    const char* str = (const char*)_cache->address_for_C_string(string_id);\n+    const char* str = nullptr;\n+    if (use_string_table) {\n+      int string_id = *(uint *)addr(offset);\n+      offset += sizeof(int);\n+      str = (const char*)_cache->address_for_C_string(string_id);\n+    } else {\n+      str = (const char*)addr(offset);\n+      offset += (uint)strlen(str)+1;\n+    }\n@@ -3613,1 +3255,0 @@\n-#define _all_blobs_max 100\n@@ -3615,0 +3256,1 @@\n+#define _C1_blobs_max 50\n@@ -3616,2 +3258,2 @@\n-#define _C1_blobs_max (_all_blobs_max - _shared_blobs_max - _C2_blobs_max)\n-#define _all_max 450\n+#define _blobs_max (_shared_blobs_max+_C1_blobs_max+_C2_blobs_max)\n+#define _all_max (_extrs_max+_stubs_max+_blobs_max)\n@@ -3624,0 +3266,1 @@\n+#define _blobs_end  (_shared_blobs_base + _blobs_max)\n@@ -3638,0 +3281,3 @@\n+\n+  assert(_blobs_end <= _all_max, \"AOTCodeAddress table ranges need adjusting\");\n+\n@@ -3642,1 +3288,0 @@\n-  _stubs_length = 0;\n@@ -3860,1 +3505,1 @@\n-  log_info(aot, codecache, init)(\"early stubs recorded\");\n+  log_info(aot, codecache, init)(\"Early stubs recorded\");\n@@ -3868,3 +3513,1 @@\n-  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _all_blobs_max, mtCode);\n-\n-  \/\/ Divide _shared_blobs_addr array to chunks because they could be initialized in parrallel\n+  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n@@ -3875,1 +3518,1 @@\n-  _shared_blobs_length = 0;       \/\/ for shared blobs\n+  _shared_blobs_length = 0;\n@@ -3880,1 +3523,1 @@\n-  memset(blobs_addr, 0, sizeof(address)* _all_blobs_max);\n+  memset(blobs_addr, 0, sizeof(address)* _blobs_max);\n@@ -3904,0 +3547,5 @@\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_AbstractMethodError_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_NullPointerException_at_call_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_StackOverflowError_entry());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -3906,1 +3554,2 @@\n-  log_info(aot, codecache,init)(\"Early shared blobs recorded\");\n+  _shared_blobs_complete = true;\n+  log_info(aot, codecache,init)(\"All shared blobs recorded\");\n@@ -3914,11 +3563,0 @@\n-  \/\/ final blobs\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_AbstractMethodError_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_NullPointerException_at_call_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_StackOverflowError_entry());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::throw_delayed_StackOverflowError_entry());\n-\n-  assert(_shared_blobs_length <= _all_blobs_max, \"increase _all_blobs_max to %d\", _shared_blobs_length);\n-\n-  _shared_blobs_complete = true;\n-  log_info(aot, codecache,init)(\"All shared blobs recorded\");\n@@ -4398,1 +4036,1 @@\n-int AOTCodeAddressTable::id_for_address(address addr, RelocIterator reloc, CodeBuffer* buffer, CodeBlob* blob) {\n+int AOTCodeAddressTable::id_for_address(address addr, RelocIterator reloc, CodeBlob* blob) {\n@@ -4486,4 +4124,0 @@\n-          if (buffer != nullptr) {\n-            buffer->print_on(tty);\n-            buffer->decode();\n-          }\n@@ -4508,2 +4142,1 @@\n-#undef _all_blobs_max\n-#undef _blobs_max\n+#undef _shared_blobs_max\n@@ -4512,0 +4145,1 @@\n+#undef _blobs_max\n@@ -4514,1 +4148,1 @@\n-#undef _blobs_base\n+#undef _shared_blobs_base\n@@ -4517,1 +4151,1 @@\n-#undef _c_str_base\n+#undef _blobs_end\n@@ -4615,1 +4249,1 @@\n-  LogStreamHandle(Info, aot, codecache, exit) log;\n+  LogStreamHandle(Debug, aot, codecache, exit) log;\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":196,"deletions":562,"binary":false,"changes":758,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class CodeBuffer;\n@@ -105,0 +104,2 @@\n+  uint   _num_inlined_bytecodes;\n+\n@@ -107,3 +108,0 @@\n-  uint   _reloc_offset;\/\/ Relocations\n-  uint   _reloc_size;  \/\/ Max size of relocations per code section\n-  uint   _num_inlined_bytecodes;\n@@ -123,0 +121,1 @@\n+\n@@ -124,0 +123,1 @@\n+  \/\/ this constructor is used only by AOTCodeEntry::Stub\n@@ -125,9 +125,3 @@\n-           uint code_offset, uint code_size,\n-           uint reloc_offset, uint reloc_size,\n-           Kind kind, uint id,\n-           address dumptime_content_start_addr = nullptr,\n-           uint comp_level = 0,\n-           uint comp_id = 0, uint decomp = 0,\n-           bool has_clinit_barriers = false,\n-           bool for_preload = false,\n-           bool ignore_decompile = false) {\n+               uint code_offset, uint code_size,\n+               Kind kind, uint id) {\n+    assert(kind == AOTCodeEntry::Stub, \"sanity check\");\n@@ -138,1 +132,0 @@\n-\n@@ -145,2 +138,0 @@\n-    _reloc_offset = reloc_offset;\n-    _reloc_size   = reloc_size;\n@@ -148,1 +139,1 @@\n-    _dumptime_content_start_addr = dumptime_content_start_addr;\n+    _dumptime_content_start_addr = nullptr;\n@@ -150,4 +141,3 @@\n-\n-    _comp_level   = comp_level;\n-    _comp_id      = comp_id;\n-    _decompile    = decomp;\n+    _comp_level   = 0;\n+    _comp_id      = 0;\n+    _decompile    = 0;\n@@ -155,2 +145,2 @@\n-    _has_clinit_barriers = has_clinit_barriers;\n-    _for_preload  = for_preload;\n+    _has_clinit_barriers = false;\n+    _for_preload  = false;\n@@ -160,1 +150,1 @@\n-    _ignore_decompile = ignore_decompile;\n+    _ignore_decompile = true;\n@@ -167,1 +157,6 @@\n-               address dumptime_content_start_addr) {\n+               address dumptime_content_start_addr,\n+               uint comp_level = 0,\n+               uint comp_id = 0, uint decomp = 0,\n+               bool has_clinit_barriers = false,\n+               bool for_preload = false,\n+               bool ignore_decompile = false) {\n@@ -177,3 +172,1 @@\n-    _code_size    = 0;\n-    _reloc_offset = 0;\n-    _reloc_size   = 0;\n+    _code_size    = 0; \/\/ unused\n@@ -184,3 +177,3 @@\n-    _comp_level   = 0;\n-    _comp_id      = 0;\n-    _decompile    = 0;\n+    _comp_level   = comp_level;\n+    _comp_id      = comp_id;\n+    _decompile    = decomp;\n@@ -188,2 +181,6 @@\n-    _has_clinit_barriers = false;\n-    _for_preload  = false;\n+    _has_clinit_barriers = has_clinit_barriers;\n+    _for_preload  = for_preload;\n+    _loaded       = false;\n+    _not_entrant  = false;\n+    _load_fail    = false;\n+\n@@ -219,2 +216,0 @@\n-  uint reloc_offset() const { return _reloc_offset; }\n-  uint reloc_size()   const { return _reloc_size; }\n@@ -222,1 +217,0 @@\n-  uint blob_offset()  const { return _code_offset; }\n@@ -225,6 +219,0 @@\n-\n-  static bool is_valid_entry_kind(Kind kind) { return kind > None && kind < Kind_count; }\n-  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n-  static bool is_adapter(Kind kind) { return kind == Adapter; }\n-  bool is_code()  { return _kind == Code; }\n-\n@@ -252,0 +240,5 @@\n+\n+  static bool is_valid_entry_kind(Kind kind) { return kind > None && kind < Kind_count; }\n+  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n+  static bool is_adapter(Kind kind) { return kind == Adapter; }\n+  bool is_code()  { return _kind == Code; }\n@@ -306,1 +299,1 @@\n-  int  id_for_address(address addr, RelocIterator iter, CodeBuffer* buffer, CodeBlob* blob = nullptr);\n+  int  id_for_address(address addr, RelocIterator iter, CodeBlob* blob);\n@@ -567,2 +560,1 @@\n-  bool write_relocations(CodeBlob& code_blob);\n-  bool write_debug_info(DebugInformationRecorder* recorder);\n+  bool write_relocations(CodeBlob& code_blob, GrowableArray<Handle>* oop_list = nullptr, GrowableArray<Metadata*>* metadata_list = nullptr);\n@@ -572,1 +564,0 @@\n-  bool write_nmethod_loadtime_relocations(JavaThread* thread, nmethod* nm, GrowableArray<Handle>& oop_list, GrowableArray<Metadata*>& metadata_list);\n@@ -576,2 +567,0 @@\n-  bool read_oops(OopRecorder* oop_recorder, ciMethod* target);\n-  bool read_metadata(OopRecorder* oop_recorder, ciMethod* target);\n@@ -581,1 +570,0 @@\n-  bool write_oops(OopRecorder* oop_recorder);\n@@ -583,1 +571,0 @@\n-  bool write_metadata(OopRecorder* oop_recorder);\n@@ -588,2 +575,2 @@\n-  bool write_asm_remarks(CodeBlob& cb);\n-  bool write_dbg_strings(CodeBlob& cb);\n+  bool write_asm_remarks(AsmRemarks& asm_remarks, bool use_string_table);\n+  bool write_dbg_strings(DbgStrings& dbg_strings, bool use_string_table);\n@@ -711,1 +698,0 @@\n-  bool compile_blob(CodeBuffer* buffer, int* pc_offset);\n@@ -718,2 +704,0 @@\n-  DebugInformationRecorder* read_debug_info(OopRecorder* oop_recorder);\n-\n@@ -730,1 +714,1 @@\n-  void fix_relocations(CodeBlob* code_blob);\n+  void fix_relocations(CodeBlob* code_blob, GrowableArray<Handle>* oop_list = nullptr, GrowableArray<Metadata*>* metadata_list = nullptr) NOT_CDS_RETURN;\n@@ -732,2 +716,2 @@\n-  void read_asm_remarks(AsmRemarks& asm_remarks);\n-  void read_dbg_strings(DbgStrings& dbg_strings);\n+  void read_asm_remarks(AsmRemarks& asm_remarks, bool use_string_table) NOT_CDS_RETURN;\n+  void read_dbg_strings(DbgStrings& dbg_strings, bool use_string_table) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":42,"deletions":58,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -284,4 +284,0 @@\n-#ifndef PRODUCT\n-                           , AsmRemarks& archived_asm_remarks\n-                           , DbgStrings& archived_dbg_strings\n-#endif \/\/ PRODUCT\n@@ -304,6 +300,0 @@\n-#ifndef PRODUCT\n-      blob->use_remarks(archived_asm_remarks);\n-      archived_asm_remarks.clear();\n-      blob->use_strings(archived_dbg_strings);\n-      archived_dbg_strings.clear();\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -322,6 +322,1 @@\n-                          ImmutableOopMapSet* archived_oop_maps\n-#ifndef PRODUCT\n-                          , AsmRemarks& archived_asm_remarks\n-                          , DbgStrings& archived_dbg_strings\n-#endif \/\/ PRODUCT\n-                         );\n+                          ImmutableOopMapSet* archived_oop_maps);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1254,15 +1254,11 @@\n-void nmethod::restore_from_archive(nmethod* archived_nm,\n-                                   const methodHandle& method,\n-                                   int compile_id,\n-                                   address reloc_data,\n-                                   GrowableArray<Handle>& oop_list,\n-                                   GrowableArray<Metadata*>& metadata_list,\n-                                   ImmutableOopMapSet* oop_maps,\n-                                   address immutable_data,\n-                                   GrowableArray<Handle>& reloc_imm_oop_list,\n-                                   GrowableArray<Metadata*>& reloc_imm_metadata_list,\n-#ifndef PRODUCT\n-                                   AsmRemarks& archived_asm_remarks,\n-                                   DbgStrings& archived_dbg_strings,\n-#endif \/* PRODUCT *\/\n-                                   AOTCodeReader* aot_code_reader)\n+nmethod* nmethod::restore(address code_cache_buffer,\n+                          const methodHandle& method,\n+                          int compile_id,\n+                          address reloc_data,\n+                          GrowableArray<Handle>& oop_list,\n+                          GrowableArray<Metadata*>& metadata_list,\n+                          ImmutableOopMapSet* oop_maps,\n+                          address immutable_data,\n+                          GrowableArray<Handle>& reloc_imm_oop_list,\n+                          GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+                          AOTCodeReader* aot_code_reader)\n@@ -1270,17 +1266,7 @@\n-  archived_nm->copy_to((address)this);\n-  set_name(\"nmethod\");\n-  set_method(method());\n-\n-  _compile_id = compile_id;\n-  \/\/ allocate _mutable_data before copying relocation data because relocation data is now stored as part of mutable data area\n-  if (archived_nm->mutable_data_size() > 0) {\n-    _mutable_data = (address)os::malloc(archived_nm->mutable_data_size(), mtCode);\n-    if (_mutable_data == nullptr) {\n-      vm_exit_out_of_memory(archived_nm->mutable_data_size(), OOM_MALLOC_ERROR, \"codebuffer: no space for mutable data\");\n-    }\n-  }\n-  memcpy((address)relocation_begin(), reloc_data, archived_nm->relocation_size());\n-  set_oop_maps(oop_maps);\n-  set_immutable_data(immutable_data);\n-  copy_values(&oop_list);\n-  copy_values(&metadata_list);\n+  CodeBlob::restore(code_cache_buffer, \"nmethod\", reloc_data, oop_maps);\n+  nmethod* nm = (nmethod*)code_cache_buffer;\n+  nm->set_method(method());\n+  nm->_compile_id = compile_id;\n+  nm->set_immutable_data(immutable_data);\n+  nm->copy_values(&oop_list);\n+  nm->copy_values(&metadata_list);\n@@ -1288,1 +1274,1 @@\n-  aot_code_reader->apply_relocations(this, reloc_imm_oop_list, reloc_imm_metadata_list);\n+  aot_code_reader->fix_relocations(nm, &reloc_imm_oop_list, &reloc_imm_metadata_list);\n@@ -1291,7 +1277,5 @@\n-  AsmRemarks::init(asm_remarks());\n-  use_remarks(archived_asm_remarks);\n-  archived_asm_remarks.clear();\n-  DbgStrings::init(dbg_strings());\n-  use_strings(archived_dbg_strings);\n-  archived_dbg_strings.clear();\n-#endif \/* PRODUCT *\/\n+  nm->asm_remarks().init();\n+  aot_code_reader->read_asm_remarks(nm->asm_remarks(), \/* use_string_table *\/ false);\n+  nm->dbg_strings().init();\n+  aot_code_reader->read_dbg_strings(nm->dbg_strings(), \/* use_string_table *\/ false);\n+#endif\n@@ -1300,1 +1284,1 @@\n-  ICache::invalidate_range(code_begin(), code_size());\n+  ICache::invalidate_range(nm->code_begin(), nm->code_size());\n@@ -1303,1 +1287,1 @@\n-  _pc_desc_container = new PcDescContainer(scopes_pcs_begin());\n+  nm->_pc_desc_container = new PcDescContainer(nm->scopes_pcs_begin());\n@@ -1305,1 +1289,1 @@\n-  set_aot_code_entry(aot_code_reader->aot_code_entry());\n+  nm->set_aot_code_entry(aot_code_reader->aot_code_entry());\n@@ -1307,1 +1291,2 @@\n-  post_init();\n+  nm->post_init();\n+  return nm;\n@@ -1321,4 +1306,0 @@\n-#ifndef PRODUCT\n-                              AsmRemarks& asm_remarks,\n-                              DbgStrings& dbg_strings,\n-#endif \/* PRODUCT *\/\n@@ -1332,15 +1313,13 @@\n-    nm = (nmethod *)CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(archived_nm->comp_level()));\n-    if (nm != nullptr) {\n-      nm->restore_from_archive(archived_nm,\n-                               method,\n-                               compile_id,\n-                               reloc_data,\n-                               oop_list,\n-                               metadata_list,\n-                               oop_maps,\n-                               immutable_data,\n-                               reloc_imm_oop_list,\n-                               reloc_imm_metadata_list,\n-                               NOT_PRODUCT_ARG(asm_remarks)\n-                               NOT_PRODUCT_ARG(dbg_strings)\n-                               aot_code_reader);\n+    address code_cache_buffer = (address)CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(archived_nm->comp_level()));\n+    if (code_cache_buffer != nullptr) {\n+      nm = archived_nm->restore(code_cache_buffer,\n+                                method,\n+                                compile_id,\n+                                reloc_data,\n+                                oop_list,\n+                                metadata_list,\n+                                oop_maps,\n+                                immutable_data,\n+                                reloc_imm_oop_list,\n+                                reloc_imm_metadata_list,\n+                                aot_code_reader);\n@@ -4278,2 +4257,2 @@\n-void nmethod::prepare_for_archiving() {\n-  CodeBlob::prepare_for_archiving();\n+void nmethod::prepare_for_archiving_impl() {\n+  CodeBlob::prepare_for_archiving_impl();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":44,"deletions":65,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -487,15 +487,11 @@\n-  void restore_from_archive(nmethod* archived_nm,\n-                            const methodHandle& method,\n-                            int compile_id,\n-                            address reloc_data,\n-                            GrowableArray<Handle>& oop_list,\n-                            GrowableArray<Metadata*>& metadata_list,\n-                            ImmutableOopMapSet* oop_maps,\n-                            address immutable_data,\n-                            GrowableArray<Handle>& reloc_imm_oop_list,\n-                            GrowableArray<Metadata*>& reloc_imm_metadata_list,\n-#ifndef PRODUCT\n-                            AsmRemarks& asm_remarks,\n-                            DbgStrings& dbg_strings,\n-#endif \/* PRODUCT *\/\n-                            AOTCodeReader* aot_code_reader);\n+  nmethod* restore(address code_cache_buffer,\n+                   const methodHandle& method,\n+                   int compile_id,\n+                   address reloc_data,\n+                   GrowableArray<Handle>& oop_list,\n+                   GrowableArray<Metadata*>& metadata_list,\n+                   ImmutableOopMapSet* oop_maps,\n+                   address immutable_data,\n+                   GrowableArray<Handle>& reloc_imm_oop_list,\n+                   GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+                   AOTCodeReader* aot_code_reader);\n@@ -516,4 +512,0 @@\n-#ifndef PRODUCT\n-                              AsmRemarks& asm_remarks,\n-                              DbgStrings& dbg_strings,\n-#endif \/* PRODUCT *\/\n@@ -1061,1 +1053,1 @@\n-  void prepare_for_archiving();\n+  void prepare_for_archiving_impl();\n@@ -1071,0 +1063,3 @@\n+    void prepare_for_archiving(CodeBlob* instance) const override {\n+      ((nmethod*)instance)->prepare_for_archiving_impl();\n+    };\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-  initialize_misc();\n@@ -187,3 +186,2 @@\n-    _code = cb->as_nmethod();\n-  } else {\n-    _code = nullptr;\n+    initialize(cb->as_nmethod(), nullptr, nullptr);\n+    return;\n@@ -191,0 +189,2 @@\n+  initialize_misc();\n+  _code = nullptr;\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -396,0 +396,3 @@\n+  nmethod* preload_code() const {\n+    return _preload_code;\n+  }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}