{"files":[{"patch":"@@ -596,5 +596,1 @@\n-    if (UseNewCode) {\n-      finish_write_new();\n-    } else {\n-      finish_write();\n-    }\n+    finish_write();\n@@ -1074,15 +1070,6 @@\n-  if (UseNewCode) {\n-    if (entry->for_preload()) {\n-      count = _load_header->preload_entries_count();\n-      AOTCodeEntry* preload_entry = (AOTCodeEntry*)addr(_load_header->preload_entries_offset());\n-      for (; i < count; i++) {\n-        if (entry == &preload_entry[i]) {\n-          break;\n-        }\n-      }\n-    } else {\n-      count = _load_header->entries_count();\n-      for(; i < count; i++) {\n-        if (entry == &(_load_entries[i])) {\n-          break;\n-        }\n+  if (entry->for_preload()) {\n+    count = _load_header->preload_entries_count();\n+    AOTCodeEntry* preload_entry = (AOTCodeEntry*)addr(_load_header->preload_entries_offset());\n+    for (; i < count; i++) {\n+      if (entry == &preload_entry[i]) {\n+        break;\n@@ -1157,181 +1144,0 @@\n-  uint entries_count = 0; \/\/ Number of entrant (useful) code entries\n-  uint entries_offset = _write_position;\n-\n-  uint code_count = _store_entries_cnt;\n-  if (code_count > 0) {\n-    _aot_code_directory = CachedCodeDirectory::create();\n-    assert(_aot_code_directory != nullptr, \"Sanity check\");\n-\n-    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header), DATA_ALIGNMENT);\n-    uint search_count = code_count * 2;\n-    uint search_size = search_count * sizeof(uint);\n-    uint entries_size = (uint)align_up(code_count * sizeof(AOTCodeEntry), DATA_ALIGNMENT); \/\/ In bytes\n-    uint preload_entries_cnt = 0;\n-    uint* preload_entries = NEW_C_HEAP_ARRAY(uint, code_count, mtCode);\n-    uint preload_entries_size = code_count * sizeof(uint);\n-    \/\/ _write_position should include code and strings\n-    uint code_alignment = code_count * DATA_ALIGNMENT; \/\/ We align_up code size when storing it.\n-    uint cpu_features_size = VM_Version::cpu_features_size();\n-    uint total_cpu_features_size = sizeof(uint) + cpu_features_size; \/\/ sizeof(uint) to store cpu_features_size\n-    uint total_size = _write_position + header_size + code_alignment +\n-                      search_size + preload_entries_size + entries_size +\n-                      align_up(total_cpu_features_size, DATA_ALIGNMENT);\n-    assert(total_size < max_aot_code_size(), \"AOT Code size (\" UINT32_FORMAT \" bytes) is greater than AOTCodeMaxSize(\" UINT32_FORMAT \" bytes).\", total_size, max_aot_code_size());\n-\n-    \/\/ Allocate in AOT Cache buffer\n-    char* buffer = (char *)AOTCacheAccess::allocate_aot_code_region(total_size + DATA_ALIGNMENT);\n-    char* start = align_up(buffer, DATA_ALIGNMENT);\n-    char* current = start + header_size; \/\/ Skip header\n-\n-    uint cpu_features_offset = current - start;\n-    store_cpu_features(current, cpu_features_size);\n-    assert(is_aligned(current, DATA_ALIGNMENT), \"sanity check\");\n-    assert(current < start + total_size, \"sanity check\");\n-\n-    \/\/ Create ordered search table for entries [id, index];\n-    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n-\n-    AOTCodeEntry* entries_address = _store_entries; \/\/ Pointer to latest entry\n-    uint adapters_count = 0;\n-    uint shared_blobs_count = 0;\n-    uint C1_blobs_count = 0;\n-    uint C2_blobs_count = 0;\n-    uint stubs_count = 0;\n-    uint nmethods_count = 0;\n-    uint max_size = 0;\n-    \/\/ AOTCodeEntry entries were allocated in reverse in store buffer.\n-    \/\/ Process them in reverse order to cache first code first.\n-    for (int i = code_count - 1; i >= 0; i--) {\n-      AOTCodeEntry* entry = &entries_address[i];\n-      if (entry->load_fail()) {\n-        continue;\n-      }\n-      if (entry->not_entrant()) {\n-        log_info(aot, codecache, exit)(\"Not entrant new entry comp_id: %d, comp_level: %d, hash: \" UINT32_FORMAT_X_0 \"%s\",\n-                                       entry->comp_id(), entry->comp_level(), entry->id(), (entry->has_clinit_barriers() ? \", has clinit barriers\" : \"\"));\n-        if (entry->for_preload()) {\n-          \/\/ Skip not entrant preload code:\n-          \/\/ we can't pre-load code which may have failing dependencies.\n-          continue;\n-        }\n-        entry->set_entrant(); \/\/ Reset\n-      } else if (entry->for_preload()) {\n-        \/\/ record entrant first version code for pre-loading\n-        preload_entries[preload_entries_cnt++] = entries_count;\n-      }\n-      {\n-        uint size = align_up(entry->size(), DATA_ALIGNMENT);\n-        if (size > max_size) {\n-          max_size = size;\n-        }\n-        copy_bytes((_store_buffer + entry->offset()), (address)current, size);\n-        entry->set_offset(current - start); \/\/ New offset\n-        current += size;\n-        uint n = write_bytes(entry, sizeof(AOTCodeEntry));\n-        if (n != sizeof(AOTCodeEntry)) {\n-          FREE_C_HEAP_ARRAY(uint, search);\n-          return false;\n-        }\n-        search[entries_count*2 + 0] = entry->id();\n-        search[entries_count*2 + 1] = entries_count;\n-        entries_count++;\n-        AOTCodeEntry::Kind kind = entry->kind();\n-        if (kind == AOTCodeEntry::Adapter) {\n-          adapters_count++;\n-        } else if (kind == AOTCodeEntry::SharedBlob) {\n-          shared_blobs_count++;\n-        } else if (kind == AOTCodeEntry::C1Blob) {\n-          C1_blobs_count++;\n-        } else if (kind == AOTCodeEntry::C2Blob) {\n-          C2_blobs_count++;\n-        } else if (kind == AOTCodeEntry::Stub) {\n-          stubs_count++;\n-        } else {\n-          assert(kind == AOTCodeEntry::Nmethod, \"sanity\");\n-          nmethods_count++;\n-        }\n-      }\n-    }\n-\n-    if (entries_count == 0) {\n-      log_info(aot, codecache, exit)(\"AOT Code Cache was not created: no entires\");\n-      FREE_C_HEAP_ARRAY(uint, search);\n-      return true; \/\/ Nothing to write\n-    }\n-    assert(entries_count <= code_count, \"%d > %d\", entries_count, code_count);\n-    \/\/ Write strings\n-    if (strings_count > 0) {\n-      copy_bytes((_store_buffer + strings_offset), (address)current, strings_size);\n-      strings_offset = (current - start); \/\/ New offset\n-      current += strings_size;\n-    }\n-    uint preload_entries_offset = (current - start);\n-    preload_entries_size = preload_entries_cnt * sizeof(uint);\n-    if (preload_entries_size > 0) {\n-      copy_bytes((const char*)preload_entries, (address)current, preload_entries_size);\n-      current += preload_entries_size;\n-      log_info(aot, codecache, exit)(\"Wrote %d preload entries to AOT Code Cache\", preload_entries_cnt);\n-    }\n-    if (preload_entries != nullptr) {\n-      FREE_C_HEAP_ARRAY(uint, preload_entries);\n-    }\n-\n-    uint search_table_offset = current - start;\n-    \/\/ Sort and store search table\n-    qsort(search, entries_count, 2*sizeof(uint), uint_cmp);\n-    search_size = 2 * entries_count * sizeof(uint);\n-    copy_bytes((const char*)search, (address)current, search_size);\n-    FREE_C_HEAP_ARRAY(uint, search);\n-    current += search_size;\n-\n-    \/\/ Write entries\n-    current = align_up(current, DATA_ALIGNMENT);\n-    uint new_entries_offset = current - start;\n-    entries_size = entries_count * sizeof(AOTCodeEntry); \/\/ New size\n-    copy_bytes((_store_buffer + entries_offset), (address)current, entries_size);\n-    current += entries_size;\n-\n-    \/\/log_stats_on_exit();\n-\n-    uint size = (current - start);\n-    assert(size <= total_size, \"%d > %d\", size , total_size);\n-    uint blobs_count = shared_blobs_count + C1_blobs_count + C2_blobs_count;\n-    assert(nmethods_count == (entries_count - (stubs_count + blobs_count + adapters_count)), \"sanity\");\n-    log_debug(aot, codecache, exit)(\"  Adapters: total=%u\", adapters_count);\n-    log_debug(aot, codecache, exit)(\"  Shared Blobs: total=%u\", shared_blobs_count);\n-    log_debug(aot, codecache, exit)(\"  C1 Blobs: total=%u\", C1_blobs_count);\n-    log_debug(aot, codecache, exit)(\"  C2 Blobs: total=%u\", C2_blobs_count);\n-    log_debug(aot, codecache, exit)(\"  Stubs:    total=%u\", stubs_count);\n-    log_debug(aot, codecache, exit)(\"  Nmethods: total=%u\", nmethods_count);\n-    log_debug(aot, codecache, exit)(\"  AOT code cache size: %u bytes, max entry's size: %u bytes\", size, max_size);\n-\n-    \/\/ Finalize header\n-    AOTCodeCache::Header* header = (AOTCodeCache::Header*)start;\n-    header->init(size, (uint)strings_count, strings_offset,\n-                 entries_count, search_table_offset, new_entries_offset,\n-                 preload_entries_cnt, preload_entries_offset,\n-                 adapters_count, shared_blobs_count,\n-                 C1_blobs_count, C2_blobs_count,\n-                 stubs_count, cpu_features_offset);\n-\n-    log_info(aot, codecache, exit)(\"Wrote %d AOT code entries to AOT Code Cache\", entries_count);\n-\n-    _aot_code_directory->set_aot_code_data(size, start);\n-  }\n-  return true;\n-}\n-\n-bool AOTCodeCache::finish_write_new() {\n-  if (!align_write()) {\n-    return false;\n-  }\n-  uint strings_offset = _write_position;\n-  int strings_count = store_strings();\n-  if (strings_count < 0) {\n-    return false;\n-  }\n-  if (!align_write()) {\n-    return false;\n-  }\n-  uint strings_size = _write_position - strings_offset;\n-\n@@ -1448,1 +1254,1 @@\n-      log_info(aot, codecache, exit)(\"AOT Code Cache was not created: no entires\");\n+      log_info(aot, codecache, exit)(\"AOT Code Cache was not created: no entries\");\n@@ -2118,5 +1924,1 @@\n-  if (UseNewCode) {\n-    _cache->preload_aot_code_new(thread);\n-  } else {\n-    _cache->preload_aot_code(thread);\n-  }\n+  _cache->preload_aot_code(thread);\n@@ -2126,59 +1928,0 @@\n-  if (CompilationPolicy::compiler_count(CompLevel_full_optimization) == 0) {\n-    \/\/ Since we reuse the CompilerBroker API to install AOT code, we're required to have a JIT compiler for the\n-    \/\/ level we want (that is CompLevel_full_optimization).\n-    return;\n-  }\n-  TraceTime t1(\"Total time to preload AOT code\", &_t_totalPreload, enable_timers(), false);\n-  assert(_for_use, \"sanity\");\n-  uint count = _load_header->entries_count();\n-  if (_load_entries == nullptr) {\n-    \/\/ Read it\n-    _search_entries = (uint*)addr(_load_header->search_table_offset()); \/\/ [id, index]\n-    _load_entries = (AOTCodeEntry*)addr(_load_header->entries_offset());\n-    log_info(aot, codecache, init)(\"Read %d entries table at offset %d from AOT Code Cache\", count, _load_header->entries_offset());\n-  }\n-  uint preload_entries_count = _load_header->preload_entries_count();\n-  if (preload_entries_count > 0) {\n-    uint* entries_index = (uint*)addr(_load_header->preload_entries_offset());\n-    log_info(aot, codecache, init)(\"Load %d preload entries from AOT Code Cache\", preload_entries_count);\n-    uint count = MIN2(preload_entries_count, AOTCodeLoadStop);\n-    for (uint i = AOTCodeLoadStart; i < count; i++) {\n-      uint index = entries_index[i];\n-      AOTCodeEntry* entry = &(_load_entries[index]);\n-      if (entry->not_entrant()) {\n-        continue;\n-      }\n-      methodHandle mh(THREAD, entry->method());\n-      assert((mh.not_null() && MetaspaceShared::is_in_shared_metaspace((address)mh())), \"sanity\");\n-      if (skip_preload(mh)) {\n-        continue; \/\/ Exclude preloading for this method\n-      }\n-      assert(mh->method_holder()->is_loaded(), \"\");\n-      if (!mh->method_holder()->is_linked()) {\n-        assert(!HAS_PENDING_EXCEPTION, \"\");\n-        mh->method_holder()->link_class(THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          LogStreamHandle(Info, aot, codecache) log;\n-          if (log.is_enabled()) {\n-            ResourceMark rm;\n-            log.print(\"Linkage failed for %s: \", mh->method_holder()->external_name());\n-            THREAD->pending_exception()->print_value_on(&log);\n-            if (log_is_enabled(Debug, aot, codecache)) {\n-              THREAD->pending_exception()->print_on(&log);\n-            }\n-          }\n-          CLEAR_PENDING_EXCEPTION;\n-        }\n-      }\n-      if (mh->aot_code_entry() != nullptr) {\n-        \/\/ Second C2 compilation of the same method could happen for\n-        \/\/ different reasons without marking first entry as not entrant.\n-        continue; \/\/ Keep old entry to avoid issues\n-      }\n-      mh->set_aot_code_entry(entry);\n-      CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel_full_optimization, 0, false, CompileTask::Reason_Preload, CHECK);\n-    }\n-  }\n-}\n-\n-void AOTCodeCache::preload_aot_code_new(TRAPS) {\n@@ -4214,6 +3957,4 @@\n-    if (UseNewCode) {\n-      uint preload_count = cache->_load_header->preload_entries_count();\n-      AOTCodeEntry* preload_entries = (AOTCodeEntry*)cache->addr(cache->_load_header->preload_entries_offset());\n-      for (uint i = 0; i < preload_count; i++) {\n-        stats.collect_all_stats(&preload_entries[i]);\n-      }\n+    uint preload_count = cache->_load_header->preload_entries_count();\n+    AOTCodeEntry* preload_entries = (AOTCodeEntry*)cache->addr(cache->_load_header->preload_entries_offset());\n+    for (uint i = 0; i < preload_count; i++) {\n+      stats.collect_all_stats(&preload_entries[i]);\n@@ -4307,2 +4048,1 @@\n-    if (UseNewCode) {\n-      st->print_cr(\"\\nAOT Code Cache Preload entries\");\n+    st->print_cr(\"\\nAOT Code Cache Preload entries\");\n@@ -4310,4 +4050,4 @@\n-      uint preload_count = opened_cache->_load_header->preload_entries_count();\n-      AOTCodeEntry* preload_entries = (AOTCodeEntry*)opened_cache->addr(opened_cache->_load_header->preload_entries_offset());\n-      for (uint i = 0; i < preload_count; i++) {\n-        AOTCodeEntry* entry = &preload_entries[i];\n+    uint preload_count = opened_cache->_load_header->preload_entries_count();\n+    AOTCodeEntry* preload_entries = (AOTCodeEntry*)opened_cache->addr(opened_cache->_load_header->preload_entries_offset());\n+    for (uint i = 0; i < preload_count; i++) {\n+      AOTCodeEntry* entry = &preload_entries[i];\n@@ -4315,3 +4055,3 @@\n-        uint entry_position = entry->offset();\n-        uint name_offset = entry->name_offset() + entry_position;\n-        const char* saved_name = opened_cache->addr(name_offset);\n+      uint entry_position = entry->offset();\n+      uint name_offset = entry->name_offset() + entry_position;\n+      const char* saved_name = opened_cache->addr(name_offset);\n@@ -4319,6 +4059,6 @@\n-        st->print_cr(\"%4u: %10s Id:%u L%u size=%u '%s' %s%s%s\",\n-                     i, aot_code_entry_kind_name[entry->kind()], entry->id(), entry->comp_level(),\n-                     entry->size(),  saved_name,\n-                     entry->has_clinit_barriers() ? \" has_clinit_barriers\" : \"\",\n-                     entry->is_loaded()           ? \" loaded\"              : \"\",\n-                     entry->not_entrant()         ? \" not_entrant\"         : \"\");\n+      st->print_cr(\"%4u: %10s Id:%u L%u size=%u '%s' %s%s%s\",\n+                   i, aot_code_entry_kind_name[entry->kind()], entry->id(), entry->comp_level(),\n+                   entry->size(),  saved_name,\n+                   entry->has_clinit_barriers() ? \" has_clinit_barriers\" : \"\",\n+                   entry->is_loaded()           ? \" loaded\"              : \"\",\n+                   entry->not_entrant()         ? \" not_entrant\"         : \"\");\n@@ -4326,4 +4066,3 @@\n-        st->print_raw(\"         \");\n-        AOTCodeReader reader(opened_cache, entry, nullptr);\n-        reader.print_on(st);\n-      }\n+      st->print_raw(\"         \");\n+      AOTCodeReader reader(opened_cache, entry, nullptr);\n+      reader.print_on(st);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":30,"deletions":291,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -524,1 +524,0 @@\n-  void preload_aot_code_new(TRAPS);\n@@ -532,1 +531,0 @@\n-  bool finish_write_new();\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}