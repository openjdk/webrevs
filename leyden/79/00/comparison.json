{"files":[{"patch":"@@ -253,1 +253,1 @@\n-      MutexLocker notifier(thread, task->lock());\n+      MutexLocker notifier(thread, CompileTaskWait_lock);\n@@ -258,1 +258,1 @@\n-          \/\/ The waiting thread timed out and thus did not free the task.\n+          \/\/ The waiting thread timed out and thus did not delete the task.\n@@ -267,1 +267,1 @@\n-        task->lock()->notify_all();\n+        CompileTaskWait_lock->notify_all();\n@@ -271,2 +271,2 @@\n-      \/\/ The task can only be freed once the task lock is released.\n-      CompileTask::free(task);\n+      \/\/ The task can only be deleted once the task lock is released.\n+      delete task;\n@@ -277,3 +277,3 @@\n-    \/\/ By convention, the compiling thread is responsible for\n-    \/\/ recycling a non-blocking CompileTask.\n-    CompileTask::free(task);\n+    \/\/ By convention, the compiling thread is responsible for deleting\n+    \/\/ a non-blocking CompileTask.\n+    delete task;\n@@ -432,3 +432,3 @@\n- * Empties compilation queue by putting all compilation tasks onto\n- * a freelist. Furthermore, the method wakes up all threads that are\n- * waiting on a compilation task to finish. This can happen if background\n+ * Empties compilation queue by deleting all compilation tasks.\n+ * Furthermore, the method wakes up all threads that are waiting\n+ * on a compilation task to finish. This can happen if background\n@@ -437,1 +437,1 @@\n-void CompileQueue::free_all() {\n+void CompileQueue::delete_all() {\n@@ -449,1 +449,1 @@\n-      MutexLocker ct_lock(current->lock());\n+      MutexLocker ct_lock(CompileTaskWait_lock);\n@@ -454,1 +454,1 @@\n-        current->lock()->notify();\n+        CompileTaskWait_lock->notify_all();\n@@ -459,5 +459,4 @@\n-      \/\/ If no one was waiting for this task, we need to free it ourselves. In this case, the task\n-      \/\/ is also certainly unlocked, because, again, there is no waiter.\n-      \/\/ Otherwise, by convention, it's the waiters responsibility to free the task.\n-      \/\/ Put the task back on the freelist.\n-      CompileTask::free(current);\n+      \/\/ If no one was waiting for this task, we need to delete it ourselves.\n+      \/\/ In this case, the task is also certainly unlocked, because, again, there is no waiter.\n+      \/\/ Otherwise, by convention, it's the waiters responsibility to delete the task.\n+      delete current;\n@@ -1895,2 +1894,1 @@\n-  CompileTask* new_task = CompileTask::allocate();\n-  new_task->initialize(compile_id, method, osr_bci, comp_level,\n+  CompileTask* new_task = new CompileTask(compile_id, method, osr_bci, comp_level,\n@@ -1918,1 +1916,1 @@\n- * @return true if this thread needs to free\/recycle the task\n+ * @return true if this thread needs to delete the task\n@@ -1922,1 +1920,1 @@\n-  MonitorLocker ml(thread, task->lock());\n+  MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1990,1 +1988,1 @@\n-    MonitorLocker ml(thread, task->lock());\n+    MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -2001,1 +1999,1 @@\n-      CompileTask::free(task);\n+      delete task;\n@@ -2006,1 +2004,1 @@\n-    \/\/ completion is a stable property (until the task object is recycled).\n+    \/\/ completion is a stable property (until the task object is deleted).\n@@ -2009,1 +2007,1 @@\n-    \/\/ By convention, the waiter is responsible for recycling a\n+    \/\/ By convention, the waiter is responsible for deleting a\n@@ -2012,2 +2010,2 @@\n-    \/\/ be using this CompileTask; we can free it.\n-    CompileTask::free(task);\n+    \/\/ be using this CompileTask; we can delete it.\n+    delete task;\n@@ -2095,1 +2093,1 @@\n-      _c1_compile_queue->free_all();\n+      _c1_compile_queue->delete_all();\n@@ -2099,1 +2097,1 @@\n-      _c2_compile_queue->free_all();\n+      _c2_compile_queue->delete_all();\n@@ -2103,1 +2101,1 @@\n-      _c3_compile_queue->free_all();\n+      _c3_compile_queue->delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":30,"deletions":32,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-  void free_all();\n+  void delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  { MonitorLocker locker(CompileTaskAlloc_lock);\n+  { MutexLocker locker(CompileTaskAlloc_lock);\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-CompileTask*  CompileTask::_task_free_list = nullptr;\n@@ -42,69 +41,10 @@\n-\/**\n- * Allocate a CompileTask, from the free list if possible.\n- *\/\n-CompileTask* CompileTask::allocate() {\n-  MonitorLocker locker(CompileTaskAlloc_lock);\n-  CompileTask* task = nullptr;\n-\n-  if (_task_free_list != nullptr) {\n-    task = _task_free_list;\n-    _task_free_list = task->next();\n-    task->set_next(nullptr);\n-  } else {\n-    task = new CompileTask();\n-    task->set_next(nullptr);\n-    task->set_is_free(true);\n-  }\n-  assert(task->is_free(), \"Task must be free.\");\n-  task->set_is_free(false);\n-  _active_tasks++;\n-  return task;\n-}\n-\n-\/**\n-* Add a task to the free list.\n-*\/\n-void CompileTask::free(CompileTask* task) {\n-  MonitorLocker locker(CompileTaskAlloc_lock);\n-  if (!task->is_free()) {\n-    assert(!task->lock()->is_locked(), \"Should not be locked when freed\");\n-    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder))) {\n-      JNIHandles::destroy_weak_global(task->_method_holder);\n-    } else {\n-      JNIHandles::destroy_global(task->_method_holder);\n-    }\n-    if (task->_failure_reason_on_C_heap && task->_failure_reason != nullptr) {\n-      os::free((void*) task->_failure_reason);\n-    }\n-    task->_failure_reason = nullptr;\n-    task->_failure_reason_on_C_heap = false;\n-\n-    task->set_is_free(true);\n-    task->set_next(_task_free_list);\n-    _task_free_list = task;\n-    _active_tasks--;\n-    if (_active_tasks == 0) {\n-      locker.notify_all();\n-    }\n-  }\n-}\n-\n-void CompileTask::wait_for_no_active_tasks() {\n-  MonitorLocker locker(CompileTaskAlloc_lock);\n-  while (_active_tasks > 0) {\n-    locker.wait();\n-  }\n-}\n-\n-void CompileTask::initialize(int compile_id,\n-                             const methodHandle& method,\n-                             int osr_bci,\n-                             int comp_level,\n-                             int hot_count,\n-                             AOTCodeEntry* aot_code_entry,\n-                             CompileTask::CompileReason compile_reason,\n-                             CompileQueue* compile_queue,\n-                             bool requires_online_compilation,\n-                             bool is_blocking) {\n-  assert(!_lock->is_locked(), \"bad locking\");\n-\n+CompileTask::CompileTask(int compile_id,\n+                         const methodHandle& method,\n+                         int osr_bci,\n+                         int comp_level,\n+                         int hot_count,\n+                         AOTCodeEntry* aot_code_entry,\n+                         CompileTask::CompileReason compile_reason,\n+                         CompileQueue* compile_queue,\n+                         bool requires_online_compilation,\n+                         bool is_blocking) {\n@@ -163,0 +103,27 @@\n+\n+  Atomic::add(&_active_tasks, 1);\n+}\n+\n+CompileTask::~CompileTask() {\n+  if ((_method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder))) {\n+    JNIHandles::destroy_weak_global(_method_holder);\n+  } else {\n+    JNIHandles::destroy_global(_method_holder);\n+  }\n+  if (_failure_reason_on_C_heap && _failure_reason != nullptr) {\n+    os::free((void*) _failure_reason);\n+    _failure_reason = nullptr;\n+    _failure_reason_on_C_heap = false;\n+  }\n+\n+  if (Atomic::sub(&_active_tasks, 1) == 0) {\n+    MonitorLocker wait_ml(CompileTaskWait_lock);\n+    wait_ml.notify_all();\n+  }\n+}\n+\n+void CompileTask::wait_for_no_active_tasks() {\n+  MonitorLocker locker(CompileTaskWait_lock);\n+  while (Atomic::load(&_active_tasks) > 0) {\n+    locker.wait();\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":37,"deletions":70,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -97,1 +98,0 @@\n-  static CompileTask*  _task_free_list;\n@@ -99,1 +99,0 @@\n-  Monitor*             _lock;\n@@ -124,1 +123,0 @@\n-  bool                 _is_free;\n@@ -142,6 +140,1 @@\n-  CompileTask() : _failure_reason(nullptr), _failure_reason_on_C_heap(false) {\n-    \/\/ May hold MethodCompileQueue_lock\n-    _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n-  }\n-\n-  void initialize(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n+  CompileTask(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n@@ -152,0 +145,1 @@\n+  ~CompileTask();\n@@ -153,2 +147,0 @@\n-  static CompileTask* allocate();\n-  static void         free(CompileTask* task);\n@@ -211,1 +203,0 @@\n-  Monitor*     lock() const                      { return _lock; }\n@@ -216,1 +207,1 @@\n-    assert(_lock->owned_by_self(), \"must have lock to use waiting_for_completion_count()\");\n+    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use waiting_for_completion_count()\");\n@@ -221,1 +212,1 @@\n-    assert(_lock->owned_by_self(), \"must have lock to use inc_waiting_for_completion()\");\n+    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use inc_waiting_for_completion()\");\n@@ -226,1 +217,1 @@\n-    assert(_lock->owned_by_self(), \"must have lock to use dec_waiting_for_completion()\");\n+    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use dec_waiting_for_completion()\");\n@@ -255,2 +246,0 @@\n-  bool         is_free() const                   { return _is_free; }\n-  void         set_is_free(bool val)             { _is_free = val; }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+Monitor* CompileTaskWait_lock         = nullptr;\n@@ -93,1 +94,1 @@\n-Monitor* CompileTaskAlloc_lock        = nullptr;\n+Mutex*   CompileTaskAlloc_lock        = nullptr;\n@@ -366,1 +367,3 @@\n-  MUTEX_DEFL(CompileTaskAlloc_lock          , PaddedMonitor,  MethodCompileQueue_lock);\n+  MUTEX_DEFL(CompileTaskAlloc_lock          , PaddedMutex,   MethodCompileQueue_lock);\n+  MUTEX_DEFL(CompileTaskWait_lock           , PaddedMonitor, MethodCompileQueue_lock);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-extern Monitor* CompileTaskAlloc_lock;           \/\/ a lock held when CompileTasks are allocated\n+extern Mutex*   CompileTaskAlloc_lock;           \/\/ a lock held when CompileTasks are allocated\n+extern Monitor* CompileTaskWait_lock;            \/\/ a lock held when CompileTasks are waited\/notified\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}