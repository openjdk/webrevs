{"files":[{"patch":"@@ -4619,13 +4619,0 @@\n-\/\/ Card Table Byte Map Base\n-operand immByteMapBase()\n-%{\n-  \/\/ Get base of card map\n-  predicate(BarrierSet::barrier_set()->is_a(BarrierSet::CardTableBarrierSet) &&\n-            is_card_table_address((address)(n->get_ptr())));\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -7007,16 +6994,0 @@\n-\/\/ Load Byte Map Base Constant\n-\n-instruct loadByteMapBase(iRegPNoSp dst, immByteMapBase con)\n-%{\n-  match(Set dst con);\n-\n-  ins_cost(INSN_COST);\n-  format %{ \"adr  $dst, $con\\t# Byte Map Base\" %}\n-\n-  ins_encode %{\n-    __ load_byte_map_base($dst$$Register);\n-  %}\n-\n-  ins_pipe(ialu_imm);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -530,0 +530,1 @@\n+#if INCLUDE_CDS\n@@ -531,1 +532,0 @@\n-        \/\/ AOT code needs relocation info for card table base\n@@ -533,4 +533,0 @@\n-        if (is_card_table_address(b)) {\n-          __ lea(dest->as_register_lo(), ExternalAddress(b));\n-          break;\n-        }\n@@ -541,1 +537,0 @@\n-#if INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#if INCLUDE_CDS\n@@ -28,1 +27,0 @@\n-#endif\n@@ -586,1 +584,14 @@\n-  __ lsr(card_offset, card_offset, CardTable::card_shift());\n+#if INCLUDE_CDS\n+  \/\/ AOT code needs to load the barrier card shift from the aot\n+  \/\/ runtime constants area in the code cache otherwise we can compile\n+  \/\/ it as an immediate operand\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    address card_shift_address = (address)AOTRuntimeConstants::card_shift_address();\n+    __ lea(rscratch1, ExternalAddress(card_shift_address));\n+    __ ldrb(rscratch1, rscratch1);\n+    __ lsrv(card_offset, card_offset, rscratch1);\n+  } else\n+#endif\n+  {\n+    __ lsr(card_offset, card_offset, CardTable::card_shift());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -40,2 +41,14 @@\n-  __ lsr(obj, obj, CardTable::card_shift());\n-\n+#if INCLUDE_CDS\n+  \/\/ AOT code needs to load the barrier card shift from the aot\n+  \/\/ runtime constants area in the code cache otherwise we can compile\n+  \/\/ it as an immediate operand\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    address card_shift_address = (address)AOTRuntimeConstants::card_shift_address();\n+    __ lea(rscratch1, ExternalAddress(card_shift_address));\n+    __ ldrb(rscratch1, rscratch1);\n+    __ lsrv(obj, obj, rscratch1);\n+  } else\n+#endif\n+  {\n+    __ lsr(obj, obj, CardTable::card_shift());\n+  }\n@@ -66,2 +79,16 @@\n-  __ lsr(start, start, CardTable::card_shift());\n-  __ lsr(end, end, CardTable::card_shift());\n+#if INCLUDE_CDS\n+  \/\/ AOT code needs to load the barrier card shift from the aot\n+  \/\/ runtime constants area in the code cache otherwise we can compile\n+  \/\/ it as an immediate operand\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    address card_shift_address = (address)AOTRuntimeConstants::card_shift_address();\n+    __ lea(scratch, ExternalAddress(card_shift_address));\n+    __ ldrb(scratch, scratch);\n+    __ lsrv(start, start, scratch);\n+    __ lsrv(end, end, scratch);\n+  } else\n+#endif\n+  {\n+    __ lsr(start, start, CardTable::card_shift());\n+    __ lsr(end, end, CardTable::card_shift());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -5789,0 +5789,8 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    address byte_map_base_adr = AOTRuntimeConstants::card_table_address();\n+    lea(reg, ExternalAddress(byte_map_base_adr));\n+    ldr(reg, Address(reg));\n+    return;\n+  }\n+#endif\n@@ -5794,10 +5802,1 @@\n-#if INCLUDE_CDS\n-  if (AOTCodeCache::is_on_for_dump()) {\n-    \/\/ AOT code needs relocation info for card table base\n-    lea(reg, ExternalAddress(reinterpret_cast<address>(byte_map_base)));\n-  } else {\n-#endif\n-    mov(reg, (uint64_t)byte_map_base);\n-#if INCLUDE_CDS\n-  }\n-#endif\n+  mov(reg, (uint64_t)byte_map_base);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -134,0 +134,7 @@\n+\/\/ return a register that differs from reg1, reg2, reg3, reg4\n+inline Register pick_different_reg(Register reg1, Register reg2, Register reg3, Register reg4) {\n+  RegSet available = (RegSet::of(rscratch1, rscratch2, rax, rbx) + rdx -\n+                      RegSet::of(reg1, reg2, reg3, reg4));\n+  return *(available.begin());\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -533,0 +533,1 @@\n+#if INCLUDE_CDS\n@@ -534,1 +535,0 @@\n-        \/\/ AOTCodeCache needs relocation info for card table base\n@@ -536,4 +536,0 @@\n-        if (is_card_table_address(b)) {\n-          __ lea(dest->as_register_lo(), ExternalAddress(b));\n-          break;\n-        }\n@@ -544,1 +540,0 @@\n-#if INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -239,8 +239,0 @@\n-\/\/ return a register that differs from reg1, reg2, reg3 and is not rcx\n-\n-static Register pick_different_reg(Register reg1, Register reg2 = noreg, Register reg3= noreg, Register reg4 = noreg) {\n-  RegSet available = (RegSet::of(rscratch1, rscratch2, rax, rbx) + rdx -\n-                      RegSet::of(reg1, reg2, reg3, reg4));\n-  return *(available.begin());\n-}\n-\n@@ -256,0 +248,3 @@\n+  __ movptr(tmp, store_addr);                                    \/\/ tmp := store address\n+  __ xorptr(tmp, new_val);                                       \/\/ tmp := store address ^ new value\n+\n@@ -260,1 +255,1 @@\n-\n+  Register save = pick_different_reg(rcx, tmp, new_val, store_addr);\n@@ -262,13 +257,1 @@\n-    address grain_shift_addr = AOTRuntimeConstants::grain_shift_address();\n-    Register save = pick_different_reg(rcx, tmp, new_val, store_addr);\n-    __ push(save);\n-    __ movptr(save, store_addr);\n-    __ xorptr(save, new_val);\n-    __ push(rcx);\n-    __ lea(rcx, ExternalAddress(grain_shift_addr));\n-    __ movptr(rcx, Address(rcx, 0));\n-    __ shrptr(save);\n-    __ pop(rcx);\n-    __ mov(tmp, save);\n-    __ pop(save);\n-    __ jcc(Assembler::equal, done);\n+    __ shrptr_aotrc(tmp, save, AOTRuntimeConstants::grain_shift_address());\n@@ -278,2 +261,0 @@\n-    __ movptr(tmp, store_addr);                                    \/\/ tmp := store address\n-    __ xorptr(tmp, new_val);                                       \/\/ tmp := store address ^ new value\n@@ -281,1 +262,0 @@\n-    __ jcc(Assembler::equal, done);\n@@ -283,0 +263,1 @@\n+  __ jcc(Assembler::equal, done);\n@@ -291,0 +272,1 @@\n+\n@@ -296,11 +278,1 @@\n-    address card_shift_addr = AOTRuntimeConstants::card_shift_address();\n-    Register save = pick_different_reg(rcx, tmp);\n-    __ push(save);\n-    __ mov(save, tmp);\n-    __ push(rcx);\n-    __ lea(rcx, ExternalAddress(card_shift_addr));\n-    __ movptr(rcx, Address(rcx, 0));\n-    __ shrptr(save);\n-    __ pop(rcx);\n-    __ mov(tmp, save);\n-    __ pop(save);\n+    __ shrptr_aotrc(tmp, save, AOTRuntimeConstants::card_shift_address());\n@@ -314,0 +286,1 @@\n+#if INCLUDE_CDS\n@@ -315,3 +288,4 @@\n-    \/\/ AOT code needs relocation info for this address\n-    __ lea(tmp2, ExternalAddress((address)ct->card_table()->byte_map_base()));   \/\/ tmp2 := card table base address\n-  } else {\n+    __ movptr(tmp2, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n+  } else\n+#endif \/\/ INCLUDE_CDS\n+  {\n@@ -637,2 +611,2 @@\n-  const Register cardtable = rax;\n-  const Register card_addr = rcx;\n+  const Register cardtable = rcx;\n+  const Register card_addr = rax;\n@@ -641,1 +615,13 @@\n-  __ shrptr(card_addr, CardTable::card_shift());\n+#if INCLUDE_CDS\n+  \/\/ AOT code needs to load the barrier card shift from the aot\n+  \/\/ runtime constants area in the code cache otherwise we can compile\n+  \/\/ it as an immediate operand\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    \/\/ cardtable = rcx is not used yet\n+    __ mov32(rcx, ExternalAddress(AOTRuntimeConstants::card_shift_address()));\n+    __ shrptr(card_addr);\n+  } else\n+#endif \/\/ INCLUDE_CDS\n+  {\n+    __ shrptr(card_addr, CardTable::card_shift());\n+  }\n@@ -645,2 +631,1 @@\n-    \/\/ AOT code needs relocation info for this address\n-    __ lea(cardtable, ExternalAddress((address)ct->card_table()->byte_map_base()));\n+    __ movptr(cardtable, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":29,"deletions":44,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -63,2 +63,11 @@\n-  __ shrptr(addr, CardTable::card_shift());\n-  __ shrptr(end, CardTable::card_shift());\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    Register save = pick_different_reg(rcx, tmp, addr, end); \/\/ any could be rcx\n+    __ shrptr_aotrc(addr, save, AOTRuntimeConstants::card_shift_address());\n+    __ shrptr_aotrc(end, save, AOTRuntimeConstants::card_shift_address());\n+  } else\n+#endif\n+  {\n+    __ shrptr(addr, CardTable::card_shift());\n+    __ shrptr(end, CardTable::card_shift());\n+  }\n@@ -67,0 +76,1 @@\n+#if INCLUDE_CDS\n@@ -68,3 +78,4 @@\n-    \/\/ AOT code needs relocation info for this address\n-    __ lea(tmp, ExternalAddress((address)byte_map_base));\n-  } else {\n+    __ movptr(tmp, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n+  } else\n+#endif\n+  {\n@@ -90,1 +101,10 @@\n-  __ shrptr(obj, CardTable::card_shift());\n+#if INCLUDE_CDS\n+  Register save = obj == rscratch1 ? rscratch2 : rscratch1;\n+  precond(save != rcx);\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    __ shrptr_aotrc(obj, save, AOTRuntimeConstants::card_shift_address());\n+  } else\n+#endif\n+  {\n+    __ shrptr(obj, CardTable::card_shift());\n+  }\n@@ -100,0 +120,1 @@\n+#if INCLUDE_CDS\n@@ -101,4 +122,3 @@\n-    \/\/ AOT code needs relocation info for this address\n-    ExternalAddress cardtable((address)byte_map_base);\n-    Address index(noreg, obj, Address::times_1);\n-    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n+    __ push_ppx(save);\n+    __ movptr(save, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n+    card_addr = Address(save, obj, Address::times_1, 0);\n@@ -106,0 +126,1 @@\n+#endif\n@@ -128,0 +149,5 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    __ pop_ppx(save);\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":36,"deletions":10,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2527,0 +2527,18 @@\n+void MacroAssembler::shrptr_aotrc(Register reg, Register save, address adr) {\n+#if INCLUDE_CDS\n+  precond(AOTCodeCache::is_on_for_dump());\n+  \/\/ all aotrc field addresses should be registered in the AOTCodeCache address table\n+  assert(AOTRuntimeConstants::contains(adr), \"address out of range for data area\");\n+  push_ppx(save);\n+  movptr(save, reg); \/\/ reg could be rcx\n+  push_ppx(rcx);\n+  mov32(rcx, ExternalAddress(adr));\n+  shrptr(save);\n+  pop_ppx(rcx);\n+  movptr(reg, save);\n+  pop_ppx(save);\n+#else\n+  ShouldNotCallThis();\n+#endif\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -820,0 +820,2 @@\n+  void shrptr_aotrc(Register reg, Register save, address adr);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -340,11 +340,0 @@\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  if (bs->is_a(BarrierSet::CardTableBarrierSet)) {\n-    address byte_map_base = ci_card_table_address_as<address>();\n-    if (is_on_for_dump() && !external_word_Relocation::can_be_relocated(byte_map_base)) {\n-      \/\/ Bail out since we can't encode card table base address with relocation\n-      log_warning(aot, codecache, init)(\"Can't create AOT Code Cache because card table base address is not relocatable: \" INTPTR_FORMAT, p2i(byte_map_base));\n-      close();\n-      report_load_failure();\n-      return;\n-    }\n-  }\n@@ -3046,7 +3035,0 @@\n-\n-  \/\/ Record addresses of VM runtime methods and data structs\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  if (bs->is_a(BarrierSet::CardTableBarrierSet)) {\n-    SET_ADDRESS(_extrs, ci_card_table_address_as<address>());\n-  }\n-\n@@ -3728,7 +3710,1 @@\n-  if (bs->is_a(BarrierSet::CardTableBarrierSet)) {\n-    if (addr == ci_card_table_address_as<address>()) {\n-      id = search_address(addr, _extrs_addr, _extrs_length);\n-      assert(id > 0 && _extrs_addr[id - _extrs_base] == addr, \"sanity\");\n-      return id;\n-    }\n-  }\n+  guarantee(!bs->is_a(BarrierSet::CardTableBarrierSet) || addr != ci_card_table_address_as<address>(), \"sanity\");\n@@ -3831,0 +3807,2 @@\n+AOTRuntimeConstants AOTRuntimeConstants::_aot_runtime_constants;\n+\n@@ -3834,1 +3812,2 @@\n-    CardTableBarrierSet* ctbs = ((CardTableBarrierSet*)bs);\n+    CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n+    _aot_runtime_constants._card_table_address = ci_card_table_address_as<address>();\n@@ -3840,2 +3819,0 @@\n-AOTRuntimeConstants AOTRuntimeConstants::_aot_runtime_constants;\n-\n@@ -3843,0 +3820,1 @@\n+  card_table_address(),\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -834,2 +834,3 @@\n-  uint _grain_shift;\n-  uint _card_shift;\n+  address _card_table_address;\n+  uint    _grain_shift;\n+  uint    _card_shift;\n@@ -849,0 +850,1 @@\n+  static address card_table_address() { return (address)&_aot_runtime_constants._card_table_address; }\n@@ -856,0 +858,1 @@\n+  static address card_table_address()    { return nullptr; }\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -67,0 +68,1 @@\n+  assert(!aotCodeCache::is_on(), \"this path is not implemented\");\n@@ -70,0 +72,23 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    \/\/ AOT code needs to load the barrier card shift from the aot\n+    \/\/ runtime constants area.\n+#ifdef X86\n+    LIR_Opr card_shift = gen->shiftCountOpr(); \/\/ To use ECX register\n+#else \/\/ X86\n+    LIR_Opr card_shift = gen->new_register(T_INT);\n+#endif \/\/ X86\n+    LIR_Opr card_shift_addr = LIR_OprFact::intptrConst(AOTRuntimeConstants::card_shift_address());\n+    LIR_Opr card_shift_reg = gen->new_pointer_register();\n+    LIR_Address* card_shift_indirect = new LIR_Address(card_shift_reg, 0, T_INT);\n+    __ move(card_shift_addr, card_shift_reg);\n+    __ move(card_shift_indirect, card_shift);\n+    if (two_operand_lir_form) {\n+      LIR_Opr addr_opr = LIR_OprFact::address(new LIR_Address(addr, addr->type()));\n+      __ leal(addr_opr, tmp);\n+      __ unsigned_shift_right(tmp, card_shift, tmp, LIR_Opr::illegalOpr());\n+    } else {\n+      __ unsigned_shift_right(addr, card_shift, tmp, LIR_Opr::illegalOpr());\n+    }\n+  } else \/\/ AOTCodeCache::is_on_for_dump()\n+#endif \/\/ INCLUDE_CDS\n@@ -79,0 +104,12 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    \/\/ load the card table address from the AOT Runtime Constants area\n+    LIR_Opr byte_map_base_adr = LIR_OprFact::intptrConst(AOTRuntimeConstants::card_table_address());\n+    LIR_Opr byte_map_base_reg = gen->new_pointer_register();\n+    __ move(byte_map_base_adr, byte_map_base_reg);\n+    LIR_Address* byte_map_base_indirect = new LIR_Address(byte_map_base_reg, 0, T_LONG);\n+    \/\/LIR_Opr byte_map_base = gen->new_pointer_register();\n+    __ move(byte_map_base_indirect, byte_map_base_reg);\n+    card_addr = new LIR_Address(tmp, byte_map_base_reg, T_BYTE);\n+  } else\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -38,1 +39,12 @@\n-Node* CardTableBarrierSetC2::byte_map_base_node(GraphKit* kit) const {\n+Node* CardTableBarrierSetC2::card_shift_node(IdealKit* kit) const {\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    \/\/ load the card shift from the AOT Runtime Constants area\n+    Node* card_shift_adr = kit->makecon(TypeRawPtr::make(AOTRuntimeConstants::card_shift_address()));\n+    return kit->load_aot_const(card_shift_adr, TypeInt::POS);\n+  }\n+#endif\n+  return kit->ConI(CardTable::card_shift());\n+}\n+\n+Node* CardTableBarrierSetC2::byte_map_base_node(IdealKit* kit) const {\n@@ -40,0 +52,7 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    \/\/ load the card table address from the AOT Runtime Constants area\n+    Node* byte_map_base_adr = kit->makecon(TypeRawPtr::make(AOTRuntimeConstants::card_table_address()));\n+    return kit->load_aot_const(byte_map_base_adr, TypeRawPtr::NOTNULL);\n+  }\n+#endif\n@@ -41,5 +60,5 @@\n-   if (card_table_base != nullptr) {\n-     return kit->makecon(TypeRawPtr::make((address)card_table_base));\n-   } else {\n-     return kit->null();\n-   }\n+  if (card_table_base != nullptr) {\n+    return kit->makecon(TypeRawPtr::make((address)card_table_base));\n+  } else {\n+    return kit->makecon(Type::get_zero_type(T_ADDRESS));\n+  }\n@@ -89,1 +108,1 @@\n-  Node* card_offset = __ URShiftX(cast, __ ConI(CardTable::card_shift()));\n+  Node* card_offset = __ URShiftX(cast, card_shift_node(&ideal));\n@@ -92,1 +111,1 @@\n-  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset);\n+  Node* card_adr = __ AddP(__ top(), byte_map_base_node(&ideal), card_offset);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+class IdealKit;\n+\n@@ -38,1 +40,2 @@\n-  Node* byte_map_base_node(GraphKit* kit) const;\n+  Node* card_shift_node(IdealKit* kit) const;\n+  Node* byte_map_base_node(IdealKit* kit) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,0 +363,11 @@\n+\/\/ Load AOT runtime constant\n+Node* IdealKit::load_aot_const(Node* adr, const Type* t) {\n+  BasicType bt = t->basic_type();\n+  const TypePtr* adr_type = nullptr; \/\/ debug-mode-only argument\n+  DEBUG_ONLY(adr_type = C->get_adr_type(Compile::AliasIdxRaw));\n+  Node* ctl = (Node*)C->root(); \/\/ Raw memory access needs control\n+  Node* ld = LoadNode::make(_gvn, ctl, C->immutable_memory(), adr, adr_type, t, bt, MemNode::unordered,\n+                            LoadNode::DependsOnlyOnTest, false, false, false, false, 0);\n+  return transform(ld);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,3 @@\n+  \/\/ Load AOT runtime constant\n+  Node* load_aot_const(Node* adr, const Type* t);\n+\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}