{"files":[{"patch":"@@ -4619,13 +4619,0 @@\n-\/\/ Card Table Byte Map Base\n-operand immByteMapBase()\n-%{\n-  \/\/ Get base of card map\n-  predicate(BarrierSet::barrier_set()->is_a(BarrierSet::CardTableBarrierSet) &&\n-            is_card_table_address((address)(n->get_ptr())));\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -7007,16 +6994,0 @@\n-\/\/ Load Byte Map Base Constant\n-\n-instruct loadByteMapBase(iRegPNoSp dst, immByteMapBase con)\n-%{\n-  match(Set dst con);\n-\n-  ins_cost(INSN_COST);\n-  format %{ \"adr  $dst, $con\\t# Byte Map Base\" %}\n-\n-  ins_encode %{\n-    __ load_byte_map_base($dst$$Register);\n-  %}\n-\n-  ins_pipe(ialu_imm);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -530,0 +530,1 @@\n+#if INCLUDE_CDS\n@@ -531,1 +532,0 @@\n-        \/\/ AOT code needs relocation info for card table base\n@@ -533,4 +533,0 @@\n-        if (is_card_table_address(b)) {\n-          __ lea(dest->as_register_lo(), ExternalAddress(b));\n-          break;\n-        }\n@@ -541,1 +537,0 @@\n-#if INCLUDE_CDS\n@@ -546,1 +541,0 @@\n-#endif\n@@ -548,0 +542,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#if INCLUDE_CDS\n@@ -28,1 +27,0 @@\n-#endif\n@@ -237,16 +235,1 @@\n-\n-#if INCLUDE_CDS\n-  \/\/ AOT code needs to load the barrier card shift from the aot\n-  \/\/ runtime constants area in the code cache otherwise we can compile\n-  \/\/ it as an immediate operand\n-  if (AOTCodeCache::is_on_for_dump()) {\n-    address card_shift_address = (address)AOTRuntimeConstants::card_shift_address();\n-    __ lea(tmp2, ExternalAddress(card_shift_address));\n-    __ ldrb(tmp2, tmp2);\n-    __ lsrv(tmp1, store_addr, tmp2);                        \/\/ tmp1 := card address relative to card table base\n-  } else\n-#endif\n-  {\n-    __ lsr(tmp1, store_addr, CardTable::card_shift());     \/\/ tmp1 := card address relative to card table base\n-  }\n-\n+  __ lsr(tmp1, store_addr, CardTable::card_shift());     \/\/ tmp1 := card address relative to card table base\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-void CardTableBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj, Address dst) {\n-\n+void CardTableBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj, Address dst, Register rscratch) {\n+  precond(rscratch != noreg);\n@@ -44,1 +44,1 @@\n-  __ load_byte_map_base(rscratch1);\n+  __ load_byte_map_base(rscratch);\n@@ -48,1 +48,1 @@\n-    __ ldrb(rscratch2,  Address(obj, rscratch1));\n+    __ ldrb(rscratch2,  Address(obj, rscratch));\n@@ -50,1 +50,1 @@\n-    __ strb(zr, Address(obj, rscratch1));\n+    __ strb(zr, Address(obj, rscratch));\n@@ -53,1 +53,1 @@\n-    __ strb(zr, Address(obj, rscratch1));\n+    __ strb(zr, Address(obj, rscratch));\n@@ -91,1 +91,1 @@\n-      store_check(masm, dst.base(), dst);\n+      store_check(masm, dst.base(), dst, tmp2);\n@@ -94,1 +94,1 @@\n-      store_check(masm, tmp3, dst);\n+      store_check(masm, tmp3, dst, tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  void store_check(MacroAssembler* masm, Register obj, Address dst);\n+  void store_check(MacroAssembler* masm, Register obj, Address dst, Register rscratch);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5789,0 +5789,8 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    address byte_map_base_adr = AOTRuntimeConstants::card_table_address();\n+    lea(reg, ExternalAddress(byte_map_base_adr));\n+    ldr(reg, Address(reg));\n+    return;\n+  }\n+#endif\n@@ -5794,10 +5802,1 @@\n-#if INCLUDE_CDS\n-  if (AOTCodeCache::is_on_for_dump()) {\n-    \/\/ AOT code needs relocation info for card table base\n-    lea(reg, ExternalAddress(reinterpret_cast<address>(byte_map_base)));\n-  } else {\n-#endif\n-    mov(reg, (uint64_t)byte_map_base);\n-#if INCLUDE_CDS\n-  }\n-#endif\n+  mov(reg, (uint64_t)byte_map_base);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -533,0 +533,1 @@\n+#if INCLUDE_CDS\n@@ -534,1 +535,0 @@\n-        \/\/ AOTCodeCache needs relocation info for card table base\n@@ -536,4 +536,0 @@\n-        if (is_card_table_address(b)) {\n-          __ lea(dest->as_register_lo(), ExternalAddress(b));\n-          break;\n-        }\n@@ -544,1 +540,0 @@\n-#if INCLUDE_CDS\n@@ -549,1 +544,0 @@\n-#endif\n@@ -551,0 +545,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+  __ shrptr(tmp, CardTable::card_shift());                       \/\/ tmp := card address relative to card table base\n@@ -292,3 +293,2 @@\n-  \/\/ AOT code needs to load the barrier card shift from the aot\n-  \/\/ runtime constants area in the code cache otherwise we can compile\n-  \/\/ it as an immediate operand\n+  \/\/ Do not use ExternalAddress to load 'byte_map_base', since 'byte_map_base' is NOT\n+  \/\/ a valid address and therefore is not properly handled by the relocation code.\n@@ -296,11 +296,1 @@\n-    address card_shift_addr = AOTRuntimeConstants::card_shift_address();\n-    Register save = pick_different_reg(rcx, tmp);\n-    __ push(save);\n-    __ mov(save, tmp);\n-    __ push(rcx);\n-    __ lea(rcx, ExternalAddress(card_shift_addr));\n-    __ movptr(rcx, Address(rcx, 0));\n-    __ shrptr(save);\n-    __ pop(rcx);\n-    __ mov(tmp, save);\n-    __ pop(save);\n+    __ movptr(tmp2, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n@@ -310,8 +300,0 @@\n-    __ shrptr(tmp, CardTable::card_shift());                       \/\/ tmp := card address relative to card table base\n-  }\n-  \/\/ Do not use ExternalAddress to load 'byte_map_base', since 'byte_map_base' is NOT\n-  \/\/ a valid address and therefore is not properly handled by the relocation code.\n-  if (AOTCodeCache::is_on_for_dump()) {\n-    \/\/ AOT code needs relocation info for this address\n-    __ lea(tmp2, ExternalAddress((address)ct->card_table()->byte_map_base()));   \/\/ tmp2 := card table base address\n-  } else {\n@@ -642,0 +624,2 @@\n+\n+#if INCLUDE_CDS\n@@ -645,3 +629,4 @@\n-    \/\/ AOT code needs relocation info for this address\n-    __ lea(cardtable, ExternalAddress((address)ct->card_table()->byte_map_base()));\n-  } else {\n+    __ movptr(cardtable, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n+  } else\n+#endif \/\/ INCLUDE_CDS\n+  {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#if INCLUDE_CDS\n@@ -68,3 +69,4 @@\n-    \/\/ AOT code needs relocation info for this address\n-    __ lea(tmp, ExternalAddress((address)byte_map_base));\n-  } else {\n+    __ movptr(tmp, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n+  } else\n+#endif\n+  {\n@@ -82,1 +84,1 @@\n-void CardTableBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj, Address dst) {\n+void CardTableBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj, Address dst, Register rscratch) {\n@@ -93,0 +95,1 @@\n+  precond(rscratch != noreg);\n@@ -100,0 +103,1 @@\n+#if INCLUDE_CDS\n@@ -101,4 +105,2 @@\n-    \/\/ AOT code needs relocation info for this address\n-    ExternalAddress cardtable((address)byte_map_base);\n-    Address index(noreg, obj, Address::times_1);\n-    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n+    __ movptr(rscratch, ExternalAddress(AOTRuntimeConstants::card_table_address()));\n+    card_addr = Address(rscratch, obj, Address::times_1, 0);\n@@ -106,0 +108,1 @@\n+#endif\n@@ -115,1 +118,1 @@\n-    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n+    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch);\n@@ -144,1 +147,1 @@\n-      store_check(masm, dst.base(), dst);\n+      store_check(masm, dst.base(), dst, tmp2);\n@@ -147,1 +150,1 @@\n-      store_check(masm, tmp1, dst);\n+      store_check(masm, tmp1, dst, tmp2);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  void store_check(MacroAssembler* masm, Register obj, Address dst);\n+  void store_check(MacroAssembler* masm, Register obj, Address dst, Register rscratch);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -340,11 +340,0 @@\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  if (bs->is_a(BarrierSet::CardTableBarrierSet)) {\n-    address byte_map_base = ci_card_table_address_as<address>();\n-    if (is_on_for_dump() && !external_word_Relocation::can_be_relocated(byte_map_base)) {\n-      \/\/ Bail out since we can't encode card table base address with relocation\n-      log_warning(aot, codecache, init)(\"Can't create AOT Code Cache because card table base address is not relocatable: \" INTPTR_FORMAT, p2i(byte_map_base));\n-      close();\n-      report_load_failure();\n-      return;\n-    }\n-  }\n@@ -647,0 +636,1 @@\n+  _gcCardSize            = GCCardSizeInBytes;\n@@ -677,0 +667,5 @@\n+  if (_gcCardSize != (uint)GCCardSizeInBytes) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with GCCardSizeInBytes = %d vs current %d\", _gcCardSize, GCCardSizeInBytes);\n+    return false;\n+  }\n+\n@@ -3046,7 +3041,0 @@\n-\n-  \/\/ Record addresses of VM runtime methods and data structs\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  if (bs->is_a(BarrierSet::CardTableBarrierSet)) {\n-    SET_ADDRESS(_extrs, ci_card_table_address_as<address>());\n-  }\n-\n@@ -3728,7 +3716,1 @@\n-  if (bs->is_a(BarrierSet::CardTableBarrierSet)) {\n-    if (addr == ci_card_table_address_as<address>()) {\n-      id = search_address(addr, _extrs_addr, _extrs_length);\n-      assert(id > 0 && _extrs_addr[id - _extrs_base] == addr, \"sanity\");\n-      return id;\n-    }\n-  }\n+  guarantee(!bs->is_a(BarrierSet::CardTableBarrierSet) || addr != ci_card_table_address_as<address>(), \"sanity\");\n@@ -3831,0 +3813,2 @@\n+AOTRuntimeConstants AOTRuntimeConstants::_aot_runtime_constants;\n+\n@@ -3834,1 +3818,2 @@\n-    CardTableBarrierSet* ctbs = ((CardTableBarrierSet*)bs);\n+    CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n+    _aot_runtime_constants._card_table_address = ci_card_table_address_as<address>();\n@@ -3836,1 +3821,0 @@\n-    _aot_runtime_constants._card_shift = ctbs->card_shift();\n@@ -3840,2 +3824,0 @@\n-AOTRuntimeConstants AOTRuntimeConstants::_aot_runtime_constants;\n-\n@@ -3843,0 +3825,1 @@\n+  card_table_address(),\n@@ -3844,1 +3827,0 @@\n-  card_shift_address(),\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":12,"deletions":30,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -320,0 +320,1 @@\n+    uint _gcCardSize;\n@@ -834,2 +835,2 @@\n-  uint _grain_shift;\n-  uint _card_shift;\n+  address _card_table_address;\n+  uint    _grain_shift;\n@@ -849,0 +850,1 @@\n+  static address card_table_address() { return (address)&_aot_runtime_constants._card_table_address; }\n@@ -850,1 +852,0 @@\n-  static address card_shift_address() { return (address)&_aot_runtime_constants._card_shift; }\n@@ -856,0 +857,1 @@\n+  static address card_table_address()    { return nullptr; }\n@@ -857,1 +859,0 @@\n-  static address card_shift_address()    { return nullptr; }\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -67,0 +68,1 @@\n+  assert(!aotCodeCache::is_on(), \"this path is not implemented\");\n@@ -79,0 +81,12 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    \/\/ load the card table address from the AOT Runtime Constants area\n+    LIR_Opr byte_map_base_adr = LIR_OprFact::intptrConst(AOTRuntimeConstants::card_table_address());\n+    LIR_Opr byte_map_base_reg = gen->new_pointer_register();\n+    __ move(byte_map_base_adr, byte_map_base_reg);\n+    LIR_Address* byte_map_base_indirect = new LIR_Address(byte_map_base_reg, 0, T_LONG);\n+    \/\/LIR_Opr byte_map_base = gen->new_pointer_register();\n+    __ move(byte_map_base_indirect, byte_map_base_reg);\n+    card_addr = new LIR_Address(tmp, byte_map_base_reg, T_BYTE);\n+  } else\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -38,1 +39,1 @@\n-Node* CardTableBarrierSetC2::byte_map_base_node(GraphKit* kit) const {\n+Node* CardTableBarrierSetC2::byte_map_base_node(IdealKit* kit) const {\n@@ -40,0 +41,7 @@\n+#if INCLUDE_CDS\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    \/\/ load the card table address from the AOT Runtime Constants area\n+    Node* byte_map_base_adr = kit->makecon(TypeRawPtr::make(AOTRuntimeConstants::card_table_address()));\n+    return kit->load_aot_const(byte_map_base_adr, TypeRawPtr::NOTNULL);\n+  }\n+#endif\n@@ -41,5 +49,5 @@\n-   if (card_table_base != nullptr) {\n-     return kit->makecon(TypeRawPtr::make((address)card_table_base));\n-   } else {\n-     return kit->null();\n-   }\n+  if (card_table_base != nullptr) {\n+    return kit->makecon(TypeRawPtr::make((address)card_table_base));\n+  } else {\n+    return kit->makecon(Type::get_zero_type(T_ADDRESS));\n+  }\n@@ -92,1 +100,1 @@\n-  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset);\n+  Node* card_adr = __ AddP(__ top(), byte_map_base_node(&ideal), card_offset);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+class IdealKit;\n+\n@@ -38,1 +40,1 @@\n-  Node* byte_map_base_node(GraphKit* kit) const;\n+  Node* byte_map_base_node(IdealKit* kit) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,0 +363,11 @@\n+\/\/ Load AOT runtime constant\n+Node* IdealKit::load_aot_const(Node* adr, const Type* t) {\n+  BasicType bt = t->basic_type();\n+  const TypePtr* adr_type = nullptr; \/\/ debug-mode-only argument\n+  DEBUG_ONLY(adr_type = C->get_adr_type(Compile::AliasIdxRaw));\n+  Node* ctl = (Node*)C->root(); \/\/ Raw memory access needs control\n+  Node* ld = LoadNode::make(_gvn, ctl, C->immutable_memory(), adr, adr_type, t, bt, MemNode::unordered,\n+                            LoadNode::DependsOnlyOnTest, false, false, false, false, 0);\n+  return transform(ld);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,3 @@\n+  \/\/ Load AOT runtime constant\n+  Node* load_aot_const(Node* adr, const Type* t);\n+\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}