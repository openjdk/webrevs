{"files":[{"patch":"@@ -31,26 +31,64 @@\n- * A field may be annotated as stable if all of its component variables\n- * changes value at most once.\n- * A field's value counts as its component value.\n- * If the field is typed as an array, then all the non-null components\n- * of the array, of depth up to the rank of the field's array type,\n- * also count as component values.\n- * By extension, any variable (either array or field) which has annotated\n- * as stable is called a stable variable, and its non-null or non-zero\n- * value is called a stable value.\n- * <p>\n- * Since all fields begin with a default value of null for references\n- * (resp., zero for primitives), it follows that this annotation indicates\n- * that the first non-null (resp., non-zero) value stored in the field\n- * will never be changed.\n- * <p>\n- * If the field is not of an array type, there are no array elements,\n- * then the value indicated as stable is simply the value of the field.\n- * If the dynamic type of the field value is an array but the static type\n- * is not, the components of the array are <em>not<\/em> regarded as stable.\n- * <p>\n- * If the field is an array type, then both the field value and\n- * all the components of the field value (if the field value is non-null)\n- * are indicated to be stable.\n- * If the field type is an array type with rank {@code N > 1},\n- * then each component of the field value (if the field value is non-null),\n- * is regarded as a stable array of rank {@code N-1}.\n+ * A field may be annotated as \"stable\" to indicate that it is a\n+ * <em>stable variable<\/em>, expected to change value at most once.\n+ * The first value stored into the field (assuming it is not a\n+ * duplicate of the the field's default initial value), allows the VM\n+ * to assume that no more significant changes will occur.  This in\n+ * turn enables the VM to optimize the stable variable, treating uses\n+ * of it as constant values.  This behavior is a useful building block\n+ * for lazy evaluation or memoization of results.  In rare and subtle\n+ * use cases, stable fields may also assume on multiple values over\n+ * time, with effects to be described below.\n+ * <p>\n+ * For example, declaring two stable fields of type {@code int} and\n+ * {@code String} creates a pair of stable variables, initialized to\n+ * zero and the null reference (respectively).  Storing a non-zero\n+ * integer to the first field, or a non-null string to the second,\n+ * will enable the VM to expect that the stored value is now the\n+ * permanent value of the field, going forward.  This condition may be\n+ * used by the VM compiler to improve code quality more aggressively.\n+ * <p>\n+ * Since all heap variables begin with a default null value for\n+ * references (resp., zero for primitives), there is an ambiguity when\n+ * the VM discovers a stable variable holding a null or primitive zero\n+ * value.  Does the user intend the VM to constant fold that\n+ * (uninteresting) value?  Or is the user waiting until later to\n+ * assign another value to the variable?  The VM does not\n+ * systematically record stores of a default null (or primitive zero),\n+ * so there is no way for the VM to decide if a default field value is\n+ * an undisturbed initial default value, or has been overwritten with\n+ * an intentionally stored null (or primitive zero).  This is why the\n+ * programmer should store non-default values into stable variables,\n+ * if the consequent optimization is desired.\n+ * <p>\n+ * As a special case, if a stable field is declared as an array type\n+ * with one dimension, both the array as a whole, and its eventual\n+ * components, are treated as independent stable variables.  When a\n+ * reference to an array of length <i>N<\/i> is stored to the field,\n+ * then the array object itself is taken to be a constant, as with any\n+ * stable field.  But then all <i>N<\/i> of the array components are\n+ * <em>also<\/em> treated as independent stable variables.  Such a\n+ * stable array may contain any type, reference or primitive.\n+ * <p>\n+ * More generally, if a stable field is declared as an array type with\n+ * <em>D<\/em> dimensions, then all the non-null components of the\n+ * array, and of any sub-arrays up to a nesting depth less than\n+ * <em>D<\/em>, are treated as stable variables.  Thus, a stable field\n+ * declared as an array potentially defines a tree (of fixed depth\n+ * <em>D<\/em>) containing many stable variables, with each such stable\n+ * variable is independently considered for optimization.  In this\n+ * way, and depending on program execution, a single {@code Stable}\n+ * annotation can potentially create many independent stable\n+ * variables.  Since the top-level array reference is always stable,\n+ * it is in general a bad idea to resize the array, even while keeping\n+ * all existing components unchanged.  (This could be relaxed in the\n+ * future, to allow expansion of stable arrays, if there were a use\n+ * case that could deal correctly with races.)\n+ * <p>\n+ * As very simple example, a boolean variable is constant-folded only\n+ * when it is set to {@code true}.  Even this simple behavior is\n+ * sometimes useful for recording a permanent one-shot state change,\n+ * in such a way that the compiler can remove dead code associated\n+ * with the initial state.  It is in general a bad idea to reset\n+ * such a variable to {@code false}, since compiled code might have\n+ * \"frozen\" the {@code true} value, and will never detect the reset\n+ * value.\n@@ -61,1 +99,1 @@\n- * still conveys information regarding change of additional components values if\n+ * still conveys information regarding change of additional component values if\n@@ -64,3 +102,55 @@\n- * The HotSpot VM relies on this annotation to promote a non-null (resp.,\n- * non-zero) component value to a constant, thereby enabling superior\n- * optimizations of code depending on such a value (such as constant folding).\n+ * There are special times early in application startup when constant\n+ * folding of stable variables is disabled.  Specifically, the VM does\n+ * not observe the effects of any {@code @Stable} annotation until\n+ * after an AOT cache assembly phase (if any) has run to completion.\n+ * Therefore, during these early times, a stable variable can be\n+ * changed in any way, just like a regular mutable variable (field or\n+ * array component).  If a field is annotated {@code @Stable} but is\n+ * treated in this way during AOT cache assembly, that fact must be\n+ * clearly stated as a warning on the field declaration.  If there is\n+ * no such warning, maintainers can ignore this edge case.\n+ * <p>\n+ * In order to assist refactoring between {@code final} and\n+ * {@code @Stable} field declarations, the Java Memory Model\n+ * <em>freeze<\/em> operation is applied to both kinds of fields, when\n+ * the assignment occurs in a class or object initializer (i.e.,\n+ * static initialization code in {@code <clinit>} or constructor code\n+ * in {@code <init>}).  The freezing of a final or stable field is\n+ * (currently) triggered only when an actual assignment occurs, directly\n+ * from the initializer method ({@code <clinit>} or {@code <init>}).\n+ * It is implemented in HotSpot by an appropriate memory barrier\n+ * instruction at the return point of the initializer method.  In this\n+ * way, any non-null (or non-zero) value stored to a stable variable\n+ * (either field or array component) will appear without races to any\n+ * user of the class or object that has been initialized.\n+ * <p>\n+ * There is no such freeze operation applied to stable field stores in\n+ * any other context.  This implies that a constructor may choose to\n+ * initialize a stable variable, rather than \"leaving it for later\",\n+ * and that initial will be safely published, as if the field were\n+ * {@code final}.  The stored value may (or may not) contain\n+ * additional stable variables, not yet initialized.  Note that if a\n+ * stable variable is written outside of the code of a constructor (or\n+ * class initializer), then data races are possible, just the same as\n+ * if there were no {@code @Stable} annotation, and the field was a\n+ * regular mutable field.  In fact, the usual case for lazily\n+ * evaluated data structures is to assign to stable variables much\n+ * later than the enclosing data structure is created.  This means\n+ * that racing reads and writes might observe nulls (or primitive\n+ * zeroes) as well as non-default values.\n+ * <p>\n+ * Therefore, most code which reads stable variables should not assume\n+ * that the value has been set, and should dynamically test for a null\n+ * (or zero) value.  Code which cannot prove proper ordering of\n+ * initialization may use stable variables without performing the null\n+ * (or zero) test.  Code which omits the null (or zero) test should be\n+ * documented as to why the initialization order is reliable.  In\n+ * general, some sort of critical section for initialization should be\n+ * pointed out as provably preceding all uses of the (unchecked)\n+ * stable variable.  Examples of such a critical section would be a\n+ * constructor body which directly writes a final or stable variable,\n+ * or the AOT cache assembly phase as a whole.\n+ * <p>\n+ * The HotSpot VM relies on this annotation to promote a non-null (or\n+ * non-zero) stable variable use to a constant, thereby enabling superior\n+ * optimizations of code depending on the value (such as constant folding).\n@@ -74,7 +164,52 @@\n- * It is (currently) undefined what happens if a field annotated as stable\n- * is given a third value (by explicitly updating a stable field, a component of\n- * a stable array, or a final stable field via reflection or other means).\n- * Since the HotSpot VM promotes a non-null component value to constant, it may\n- * be that the Java memory model would appear to be broken, if such a constant\n- * (the second value of the field) is used as the value of the field even after\n- * the field value has changed (to a third value).\n+ * After constant folding, the compiler can make use of may aspects of\n+ * the object: Its dynamic type, its length (if it is an array), and\n+ * the values of its fields (if they are themselves constants, either\n+ * final or stable).  It is in general a bad idea to reset such\n+ * variables to any other value, since compiled code might have folded\n+ * an earlier stored value, and will never detect the reset value.\n+ * <p>\n+ * The HotSpot interpreter is not fully aware of stable annotations,\n+ * and treats annotated fields (and any affected arrays) as regular\n+ * mutable variables.  Thus, a field annotated as {@code @Stable} may\n+ * be given a series of values, by explicit assignment, by reflection,\n+ * or by some other means.  If the HotSpot compiler observes one of\n+ * these values, and constant-folds it in the setting of some\n+ * particular compilation task, then in some contexts (execution of\n+ * fully optimized code) the field will appear to have one\n+ * \"historical\" value, while in others (less optimized contexts) the\n+ * field will appear to have a more recent value.  (And it is no good\n+ * to try to \"reset\" a stable value by storing its default again,\n+ * because there is currently no way to find and deoptimize any and\n+ * all affected compiled code.)  Race conditions would make this even\n+ * more complex, since with races there is no definable \"most recent\"\n+ * value.\n+ * <p>\n+ * Note also each compiliation task makes its own decisions about\n+ * whether to observe stable variable values, and how aggressively to\n+ * constant-fold them.  And a method that uses a stable variable might\n+ * be inlined by many different compilation tasks.  The net result of\n+ * all this is that, if stable variables are multiply assigned, the\n+ * program execution may observe any \"historical\" value (if it was\n+ * captured by some particular compilation task), as well as a \"most\n+ * recent\" value observed by the interpreter or less-optimized code.\n+ * <p>\n+ * For all these reasons, a user who bends the rules for a stable\n+ * variable, by assigning several values to it, must state the\n+ * intended purposes carefully in warning documentation on the\n+ * relevant stable field declaration.  That user's code must function\n+ * correctly when observing any or all of the assigned values, at any\n+ * time.  Alternatively, field assignments must be constrained\n+ * appropriately so that unwanted values are not observable by\n+ * compiled code.\n+ * <p>\n+ * The {@code @Stable} annotation is intended for use in the JDK\n+ * implemention, and with the HotSpot VM, to support optimization of\n+ * classes and algorithms defined by the JDK.  Any class which uses\n+ * this annotation is responsible for constraining assignments in such\n+ * a way as not to violate API contracts of the class.  Such\n+ * constraints can be arranged using explicit atomic access\n+ * (sychronization, CAS, etc.), or by concealing the effects of\n+ * multiple assignments in some API-dependent way, or by providing\n+ * some other internal proof of correctness (accounting for any\n+ * possible racing API access), or by some appropriate disclaimer in\n+ * the API about undefined behavior.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/Stable.java","additions":172,"deletions":37,"binary":false,"changes":209,"status":"modified"}]}