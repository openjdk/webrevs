{"files":[{"patch":"@@ -33,5 +33,7 @@\n- * While the field contains its initial default (null or zero) value,\n- * the VM treats it as an ordinary mutable variable.  When the\n- * first value is stored into the field (assuming it is not a\n- * duplicate of the the field's default initial value), the VM may\n- * assume that no more significant changes will occur.  This in\n+ * All Java fields are initialized by the VM with a default value\n+ * (null or zero).  A properly used stable field will be set\n+ * just once to a non-default value, and keep that value forever.\n+ * While the field contains its default (null or zero) value,\n+ * the VM treats it as an ordinary mutable variable.  When a\n+ * non-default value is stored into the field, the VM is permitted\n+ * to assume that no more significant changes will occur.  This in\n@@ -68,5 +70,5 @@\n- * assign another value to the variable?  The VM does not\n- * systematically record stores of a default null (or primitive zero),\n- * so there is no way for the VM to decide if a default field value is\n- * an undisturbed initial default value, or has been overwritten with\n- * an intentionally stored null (or primitive zero).  This is why the\n+ * assign a permanent value to the variable?  The VM does not\n+ * systematically record stores of a null (resp., zero) to a stable variable,\n+ * so there is no way for the VM to decide if a field's current value is\n+ * its undisturbed initial value, or has been overwritten with\n+ * an intentionally stored null (resp., zero).  This is why the\n@@ -82,0 +84,9 @@\n+ * <p>\n+ * If an application requires constant folding of a stable variable\n+ * whose permanent value may be the default value (null or zero),\n+ * the variable can be refactored to add an extra indirection.\n+ * This would represent the default value in a non-null \"box\",\n+ * such as {@code Integer.valueOf(0)} or a lambda like\n+ * {@code ()->null}.  Such a refactoring should always be possible,\n+ * since stable variables should (obviously) never be part of public\n+ * APIs.\n@@ -133,1 +144,1 @@\n- * in a stable value is the string {@code \"S\"}.  All subarrays are\n+ * in any stable variable is the string {@code \"S\"}.  All subarrays are\n@@ -172,2 +183,3 @@\n- * As a very simple example, a stable boolean variable (i.e., stable\n- * field or stable boolean array element) might be constant-folded,\n+ * Note that a stable boolean variable (i.e., a stable\n+ * field like {@code INITIALIZED}, or a stable boolean\n+ * array element above) can be constant-folded,\n@@ -182,10 +194,0 @@\n- * <p>\n- * Stability of a variable and the constant folding of its default\n- * value (null or zero) are mutually exclusive, as explained above.\n- * So {@code final} field might be both null and also a constant, but\n- * not a stable field.  If an application requires constant folding of\n- * the default value, it can add an extra indirection to \"box\" the\n- * default value, such as {@code Integer.valueOf(0)} or a lambda like\n- * {@code ()->null}.  Such a refactoring should always be possible,\n- * since stable variables should (obviously) never be part of public\n- * APIs.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/Stable.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"}]}