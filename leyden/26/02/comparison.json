{"files":[{"patch":"@@ -31,26 +31,12 @@\n- * A field may be annotated as stable if all of its component variables\n- * changes value at most once.\n- * A field's value counts as its component value.\n- * If the field is typed as an array, then all the non-null components\n- * of the array, of depth up to the rank of the field's array type,\n- * also count as component values.\n- * By extension, any variable (either array or field) which has annotated\n- * as stable is called a stable variable, and its non-null or non-zero\n- * value is called a stable value.\n- * <p>\n- * Since all fields begin with a default value of null for references\n- * (resp., zero for primitives), it follows that this annotation indicates\n- * that the first non-null (resp., non-zero) value stored in the field\n- * will never be changed.\n- * <p>\n- * If the field is not of an array type, there are no array elements,\n- * then the value indicated as stable is simply the value of the field.\n- * If the dynamic type of the field value is an array but the static type\n- * is not, the components of the array are <em>not<\/em> regarded as stable.\n- * <p>\n- * If the field is an array type, then both the field value and\n- * all the components of the field value (if the field value is non-null)\n- * are indicated to be stable.\n- * If the field type is an array type with rank {@code N > 1},\n- * then each component of the field value (if the field value is non-null),\n- * is regarded as a stable array of rank {@code N-1}.\n+ * A field may be annotated as \"stable\" to indicate that it is a\n+ * <em>stable variable<\/em>, expected to change its value just once.\n+ * While the field contains its initial default (null or zero) value,\n+ * the VM treats it as an ordinary mutable variable.  When the\n+ * first value is stored into the field (assuming it is not a\n+ * duplicate of the the field's default initial value), the VM may\n+ * assume that no more significant changes will occur.  This in\n+ * turn enables the VM to optimize uses of the stable variable, treating\n+ * them as constant values.  This behavior is a useful building block\n+ * for lazy evaluation or memoization of results.  In rare and subtle\n+ * use cases, stable variables may also assume multiple values over\n+ * time, with effects as described below.\n@@ -58,0 +44,150 @@\n+ * <em>(Warning: the {@code @Stable} annotation is intended for use in the\n+ * JDK implemention, and with the HotSpot VM, to support optimization\n+ * of classes and algorithms defined by the JDK.  It is unavailable\n+ * outside the JDK.)<\/em>\n+ *\n+ * <h2><a id=\"lifecycle\"><\/a>Stable Variable Life Cycle<\/h2>\n+ *\n+ * For example, suppose a class has two non-final fields of type\n+ * {@code int} and {@code String}.  Annotating the field declarations\n+ * with {@code @Stable} creates a pair of stable variables.  The\n+ * fields are initialized to zero and the null reference,\n+ * respectively, in the usual way, but storing a non-zero integer in\n+ * the first field or a non-null reference in the second field will\n+ * enable the VM to expect that the stored value is now the permanent\n+ * value of the field, going forward.  This condition may be used by\n+ * the VM compiler to improve code quality more aggressively,\n+ * if the VM compiler runs after the stable variable has been\n+ * given a permanent value, and chooses to observe that value.\n+ * <p>\n+ * Since all heap variables begin with a default null value for\n+ * references (resp., zero for primitives), there is an ambiguity when\n+ * the VM discovers a stable variable holding a null or primitive zero\n+ * value.  Does the user intend the VM to constant fold that\n+ * (uninteresting) value?  Or is the user waiting until later to\n+ * assign another value to the variable?  The VM does not\n+ * systematically record stores of a default null (or primitive zero),\n+ * so there is no way for the VM to decide if a default field value is\n+ * an undisturbed initial default value, or has been overwritten with\n+ * an intentionally stored null (or primitive zero).  This is why the\n+ * programmer should store non-default values into stable variables,\n+ * if the consequent optimization is desired.\n+ * <p>\n+ * A stable variable may be assigned its permanent value inside a class or\n+ * object initializer, but in general (with lazy data structures)\n+ * stable variables are assigned much later.  Depending on the value\n+ * stored and what races are possible, safe publication may require\n+ * special handling with a {@code VarHandle} atomic method.\n+ * (See below.)\n+ *\n+ * <h2><a id=\"arrays\"><\/a>Stable Arrays<\/h2>\n+ *\n+ * So far, stable variables are fields, but they can be array\n+ * components as well.  If a stable field is declared as an array\n+ * type with one dimension, both that array as a whole, and its\n+ * eventual components, are treated as independent stable variables.\n+ * When a reference to an array of length <i>N<\/i> is stored to the\n+ * field, then the array object itself is taken to be a constant, as\n+ * with any stable field.  But then all <i>N<\/i> of the array\n+ * components are <em>also<\/em> treated as independent stable\n+ * variables.  Such a stable array may contain any type, reference or\n+ * primitive.  Such an array may be also marked {@code final}, and\n+ * initialized eagerly in the class or object initializer method.\n+ * Whether any (or all) of its components are also initialized eagerly\n+ * is up to the application.\n+ * <p>\n+ * More generally, if a stable field is declared as an array type with\n+ * <em>D<\/em> dimensions, then all the non-null components of the\n+ * array, and of any sub-arrays up to a nesting depth less than\n+ * <em>D<\/em>, are treated as stable variables.  Thus, a stable field\n+ * declared as an array potentially defines a tree (of fixed depth\n+ * <em>D<\/em>) containing many stable variables, with each such stable\n+ * variable being independently considered for optimization.  In this\n+ * way, and depending on program execution, a single {@code Stable}\n+ * annotation can potentially create many independent stable\n+ * variables.  Since the top-level array reference is always stable,\n+ * it is in general a bad idea to resize the array, even while keeping\n+ * all existing components unchanged.  (This could be relaxed in the\n+ * future, to allow expansion of stable arrays, if there were a use\n+ * case that could deal correctly with races.  But it would require\n+ * careful treatment by the compiler, to avoid folding the wrong\n+ * version of an array.  Anyway, there are other options, such as\n+ * tree structures, for organizing the expansion of bundles of stable\n+ * variables.)\n+ * <p>\n+ * An array is never intrinsically stable.  There is no change made to\n+ * an array as it is assigned to a stable variable of array type.\n+ * This is true even though after such an assignment, the compiler may\n+ * observe that array and treat its components as stable variables.\n+ * If the array is aliased to some other variable, uses via that\n+ * variable will not be treated as stable.  (Such aliasing is not\n+ * recommended!)  Also, storing an array into a stable variable will\n+ * not make that array's components into stable variables, unless the\n+ * variable into which it is stored is statically typed as an array,\n+ * in the declaration of the stable field which refers to that array,\n+ * directly or indirectly.\n+ *\n+ * <h2><a id=\"examples\"><\/a>Examples of Stable Variables<\/h2>\n+ *\n+ * In the following example, the only constant-foldable string stored\n+ * in a stable value is the string {@code \"S\"}.  All subarrays are\n+ * constant.\n+ *\n+ * <pre>{@code\n+ * @Stable String FIELD = null;  \/\/ no foldable value yet\n+ * @Stable int IDNUM = 0;  \/\/ no foldable value yet\n+ * @Stable boolean INITIALIZED = false;  \/\/ no foldable value yet\n+ * @Stable Object[] ARRAY = {\n+ *   \"S\",   \/\/ string \"S\" is foldable\n+ *   new String[] { \"X\", \"Y\" },  \/\/ array is foldable, not elements\n+ *   null  \/\/ null is not foldable\n+ * };\n+ * @Stable Object[][] MATRIX = {\n+ *   { \"S\", \"S\" },   \/\/ constant value\n+ *   { new String[] { \"X\", \"Y\" } },  \/\/ array is foldable, not elements\n+ *   { null, \"S\" },  \/\/ array is foldable, but not the null\n+ *   null       \/\/ could be a foldable subarray later\n+ * };\n+ * }<\/pre>\n+ *\n+ * When the following method is called, some of the above stable\n+ * variables will gain their permanent value, a constant-foldable\n+ * string \"S\", or a non-default primitive value.\n+ *\n+ * <pre>{@code\n+ * void publishSomeStables() {\n+ *   \/\/ store some more foldable \"S\" values:\n+ *   FIELD = \"S\";\n+ *   ARRAY[2] = \"S\";\n+ *   MATRIX[2][0] = \"S\";\n+ *   MATRIX[3] = new Object[] { \"S\", \"S\", null };\n+ *   \/\/ and store some foldable primitives:\n+ *   IDNUM = 42;\n+ *   INITIALIZED = true;\n+ * }\n+ * }<\/pre>\n+ *\n+ * <p>\n+ * As a very simple example, a stable boolean variable (i.e., stable\n+ * field or stable boolean array element) might be constant-folded,\n+ * but only after it is set to {@code true}.  Even this simple\n+ * optimization is sometimes useful for responding to a permanent\n+ * one-shot state change, in such a way that the compiler can remove\n+ * dead code associated with the initial state.  As with any stable\n+ * variable, it is in general a bad idea to reset such a variable to\n+ * its default (i.e., {@code false}), since compiled code might have\n+ * captured the {@code true} value as a constant, and as long as that\n+ * compiled code is in use, the reset value will go undetected.\n+ * <p>\n+ * Stability of a variable and the constant folding of its default\n+ * value (null or zero) are mutually exclusive, as explained above.\n+ * So {@code final} field might be both null and also a constant, but\n+ * not a stable field.  If an application requires constant folding of\n+ * the default value, it can add an extra indirection to \"box\" the\n+ * default value, such as {@code Integer.valueOf(0)} or a lambda like\n+ * {@code ()->null}.  Such a refactoring should always be possible,\n+ * since stable variables should (obviously) never be part of public\n+ * APIs.\n+ *\n+ * <h2><a id=\"final\"><\/a>Final Variables, Stable Variables, and Memory Effects<\/h2>\n+ *\n@@ -59,1 +195,1 @@\n- * Since final fields already behave as stable values, such an annotation\n+ * Since final fields already behave as stable variables, such an annotation\n@@ -61,1 +197,1 @@\n- * still conveys information regarding change of additional components values if\n+ * it conveys information regarding changes to additional component variables if\n@@ -64,17 +200,146 @@\n- * The HotSpot VM relies on this annotation to promote a non-null (resp.,\n- * non-zero) component value to a constant, thereby enabling superior\n- * optimizations of code depending on such a value (such as constant folding).\n- * More specifically, the HotSpot VM will process non-null stable fields (final\n- * or otherwise) in a similar manner to static final fields with respect to\n- * promoting the field's value to a constant.  Thus, placing aside the\n- * differences for null\/non-null values and arrays, a final stable field is\n- * treated as if it is really final from both the Java language and the HotSpot\n- * VM.\n- * <p>\n- * It is (currently) undefined what happens if a field annotated as stable\n- * is given a third value (by explicitly updating a stable field, a component of\n- * a stable array, or a final stable field via reflection or other means).\n- * Since the HotSpot VM promotes a non-null component value to constant, it may\n- * be that the Java memory model would appear to be broken, if such a constant\n- * (the second value of the field) is used as the value of the field even after\n- * the field value has changed (to a third value).\n+ * In order to assist refactoring between {@code final} and\n+ * {@code @Stable} field declarations, the Java Memory Model\n+ * <em>freeze<\/em> operation is applied to both kinds of fields, when\n+ * the assignment occurs in a class or object initializer (i.e.,\n+ * static initialization code in {@code <clinit>} or constructor code\n+ * in {@code <init>}).  The freezing of a final or stable field is\n+ * (currently) triggered only when an actual assignment occurs, directly\n+ * from the initializer method ({@code <clinit>} or {@code <init>}).\n+ * It is implemented in HotSpot by an appropriate memory barrier\n+ * instruction at the return point of the initializer method.  In this\n+ * way, any non-null (or non-zero) value stored to a stable variable\n+ * (either field or array component) will appear without races to any\n+ * user of the class or object that has been initialized.\n+ * <p>\n+ * (Note: The barrier used by a class initializer is part of the from\n+ * an unlocking operation mandated by JVMS 5.5, Step 10, while the\n+ * barrier action of an instance initializer is specified quite\n+ * differently, by JLS 17.5.1.  These two barriers have analogous\n+ * effects on static and non-static final and stable variables.)\n+ * <p>\n+ * There is no such JMM freeze operation applied to stable field stores in\n+ * any other context.  This implies that a constructor may choose to\n+ * initialize a stable variable, rather than \"leaving it for later\".\n+ * Such an initial value will be safely published, as if the field were\n+ * {@code final}.  The stored value may (or may not) contain\n+ * additional stable variables, not yet initialized.  Note that if a\n+ * stable variable is written outside of the code of a constructor (or\n+ * class initializer), then data races are possible, just the same as\n+ * if there were no {@code @Stable} annotation, and the field were a\n+ * regular mutable field.  In fact, the usual case for lazily\n+ * evaluated data structures is to assign to stable variables much\n+ * later than the enclosing data structure is created.  This means\n+ * that racing reads and writes might observe nulls (or primitive\n+ * zeroes) as well as non-default values.\n+ *\n+ * <h2><a id=\"usage\"><\/a>Proper Handling of Stable Variables<\/h2>\n+ *\n+ * A stable variable can appear to be in either of two states:\n+ * Uninitialized set to a foldable value.\n+ * Therfore, most code which reads stable variables should not assume\n+ * that the value has been set, and should dynamically test for a null\n+ * (or zero) value.  Code which cannot prove a previous initialization\n+ * must perform a null (or zero) test on a value loaded\n+ * from a stable variable.  Code which omits the null (or zero) test should be\n+ * documented as to why the initialization order is reliable.  In\n+ * general, some sort of critical section for initialization should be\n+ * documented, as provably preceding all uses of the (unchecked)\n+ * stable variable, or else reasons should be given why races are\n+ * benign, or some other proof given that races are either excluded or\n+ * benign.  See below for further discussion.\n+ * <p>\n+ * After constant folding, the compiler can make use of many aspects of\n+ * the object: its dynamic type, its length (if it is an array), and\n+ * the values of its fields (if they are themselves constants, either\n+ * final or stable).  It is in general a bad idea to reset such\n+ * variables to any other value, since compiled code might have folded\n+ * an earlier stored value, and will never detect the reset value.\n+ * <p>\n+ * The HotSpot interpreter is not fully aware of stable annotations,\n+ * and treats annotated fields (and any affected arrays) as regular\n+ * mutable variables.  Thus, a field annotated as {@code @Stable} may\n+ * be given a series of values, by explicit assignment, by reflection,\n+ * or by some other means.  If the HotSpot compiler constant-folds a\n+ * stable variable, then in some contexts (execution of fully\n+ * optimized code) the variable will appear to have one \"historical\"\n+ * value, observed, captured, and used within the compiled code to the\n+ * exclusion of any other possible values.  Meanwhile, in other less\n+ * optimized contexts, the stable variable will appear to have a more\n+ * recent value.  Race conditions, if allowed, will make this even\n+ * more complex, since with races there is no definable \"most recent\"\n+ * value across all threads.  The compiler can observe any racing\n+ * value, as it runs concurrently to the application, in its own\n+ * thread.\n+ * <p>\n+ * It is no good to try to \"reset\" a stable variable by storing its\n+ * default again, because there is (currently) no way to find and\n+ * deoptimize any and all affected compiled code.  If you need the\n+ * bookkeeping, try {@code SwitchPoint} or {@code MutableCallSite},\n+ * which both are able to reset compiled code that has captured an\n+ * intermediate state.\n+ * <p>\n+ * Note also each compilation task makes its own decisions about\n+ * whether to observe stable variable values, and how aggressively to\n+ * constant-fold them.  And a method that uses a stable variable might\n+ * be inlined by many different compilation tasks.  The net result of\n+ * all this is that, if stable variables are multiply assigned, the\n+ * program execution may observe any \"historical\" value (if it was\n+ * captured by some particular compilation task), as well as a \"most\n+ * recent\" value observed by the interpreter or less-optimized code.\n+ * <p>\n+ * For all these reasons, a user who bends the rules for a stable\n+ * variable, by assigning several values to it, must state the\n+ * intended purposes carefully in warning documentation on the\n+ * relevant stable field declaration.  That user's code must function\n+ * correctly when observing any or all of the assigned values, at any\n+ * time.  Alternatively, field assignments must be constrained\n+ * appropriately so that unwanted values are not observable by\n+ * compiled code.\n+ * <p>\n+ * Any class which uses this annotation is responsible for\n+ * constraining assignments in such a way as not to violate API\n+ * contracts of the class.  (If the chosen technique is unusual in\n+ * some way, it should be documented in a comment on the field.)  Such\n+ * constraints can be arranged in a variety of ways:\n+ * <ul><li> using the {@code VarHandle} API to perform an explicit\n+ * atomic operation such as {@code compareAndExchange},\n+ * {@code setRelease}, {@code releaseFence}, or the like.\n+ * <\/li><li> using regular variable access under explicit sychronization\n+ * <\/li><li> using some other kind of critical section to avoid races\n+ * which could affect compiled code\n+ * <\/li><li> allowing multiple assignments under benign races, but\n+ * only of some separately uniquified value\n+ * <\/li><li> allowing multiple assignments under benign races, but\n+ * only of semantically equivalent values, perhaps permitting\n+ * occasional duplication of cached values\n+ * <\/li><li> concealing the effects of multiple assignments in some\n+ * other API-dependent way\n+ * <\/li><li> providing some other internal proof of correctness, while\n+ * accounting for all possible racing API accesses\n+ * <\/li><li> making some appropriate disclaimer in the API about\n+ * undefined behavior\n+ * <\/li><\/ul>\n+ * <p>\n+ * There may be special times when constant folding of stable\n+ * variables is disabled.  Such times would amount to a critical\n+ * section locking out the compiler from reading stable variables.\n+ * During such a critical section, an uninitialized stable variable\n+ * can be changed in any way, just like a regular mutable variable\n+ * (field or array component).  It can even be reset to its default.\n+ * Specifically, this may happen during certain AOT operations.  If a\n+ * stable variable can be updated multiple times during such a\n+ * critical section, that fact must be clearly stated as a comment on\n+ * the field declaration.  (In the future, there may be explicit\n+ * AOT-related annotations to convey this use case.)  If there is no\n+ * such warning, maintainers can safely disregard the possibility of\n+ * an AOT critical section, since the author of the stable variable is\n+ * relying on one of the other techniques listed above.\n+ * <p>\n+ * It is possible to imagine markings for foldable methods or fields,\n+ * which can constant-fold a wider variety of states and values.  This\n+ * annotation does not readily extend to such things, for the simple\n+ * reason that extra VM bookkeeping would be required to record a\n+ * wider variety of candidate states for constant folding.  Such\n+ * higher-level mechanisms may be created in the future.  The present\n+ * low-level annotation is designed as a potential building block to\n+ * manage their bookkeeping.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/Stable.java","additions":310,"deletions":45,"binary":false,"changes":355,"status":"modified"}]}