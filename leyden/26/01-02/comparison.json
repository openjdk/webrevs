{"files":[{"patch":"@@ -42,1 +42,1 @@\n- * time, with effects to be described below.\n+ * time, with effects as described below.\n@@ -44,1 +44,1 @@\n- * (Warning: the {@code @Stable} annotation is intended for use in the\n+ * <em>(Warning: the {@code @Stable} annotation is intended for use in the\n@@ -47,9 +47,15 @@\n- * outside the JDK.)\n- * <p>\n- * For example, declaring two stable fields of type {@code int} and\n- * {@code String} creates a pair of stable variables, initialized to\n- * zero and the null reference (respectively).  Storing a non-zero\n- * integer to the first field, or a non-null string to the second,\n- * will enable the VM to expect that the stored value is now the\n- * permanent value of the field, going forward.  This condition may be\n- * used by the VM compiler to improve code quality more aggressively.\n+ * outside the JDK.)<\/em>\n+ *\n+ * <h2><a id=\"lifecycle\"><\/a>Stable Variable Life Cycle<\/h2>\n+ *\n+ * For example, suppose a class has two non-final fields of type\n+ * {@code int} and {@code String}.  Annotating the field declarations\n+ * with {@code @Stable} creates a pair of stable variables.  The\n+ * fields are initialized to zero and the null reference,\n+ * respectively, in the usual way, but storing a non-zero integer in\n+ * the first field or a non-null reference in the second field will\n+ * enable the VM to expect that the stored value is now the permanent\n+ * value of the field, going forward.  This condition may be used by\n+ * the VM compiler to improve code quality more aggressively,\n+ * if the VM compiler runs after the stable variable has been\n+ * given a permanent value, and chooses to observe that value.\n@@ -70,1 +76,1 @@\n- * A stable variable may be assigned its final value inside a class or\n+ * A stable variable may be assigned its permanent value inside a class or\n@@ -76,2 +82,5 @@\n- * <p>\n- * As an extended behavior, if a stable field is declared as an array\n+ *\n+ * <h2><a id=\"arrays\"><\/a>Stable Arrays<\/h2>\n+ *\n+ * So far, stable variables are fields, but they can be array\n+ * components as well.  If a stable field is declared as an array\n@@ -119,2 +128,6 @@\n- * directly or indirectly.  Thus, in the following example, the only\n- * constant-foldable string is {@code \"S\"}.  All subarrays are\n+ * directly or indirectly.\n+ *\n+ * <h2><a id=\"examples\"><\/a>Examples of Stable Variables<\/h2>\n+ *\n+ * In the following example, the only constant-foldable string stored\n+ * in a stable value is the string {@code \"S\"}.  All subarrays are\n@@ -124,0 +137,3 @@\n+ * @Stable String FIELD = null;  \/\/ no foldable value yet\n+ * @Stable int IDNUM = 0;  \/\/ no foldable value yet\n+ * @Stable boolean INITIALIZED = false;  \/\/ no foldable value yet\n@@ -125,3 +141,3 @@\n- *   \"S\",   \/\/ string \"S\" is stable\n- *   new String[] { \"X\", \"Y\" },  \/\/ array is stable, not elements\n- *   null  \/\/ null is default reference, not yet stable\n+ *   \"S\",   \/\/ string \"S\" is foldable\n+ *   new String[] { \"X\", \"Y\" },  \/\/ array is foldable, not elements\n+ *   null  \/\/ null is not foldable\n@@ -131,3 +147,3 @@\n- *   { new String[] { \"X\", \"Y\" } },  \/\/ both arrays stable, not elements\n- *   { null, \"S\" },  \/\/ array is stable, but not null\n- *   null       \/\/ not yet stable (could be stable array later)\n+ *   { new String[] { \"X\", \"Y\" } },  \/\/ array is foldable, not elements\n+ *   { null, \"S\" },  \/\/ array is foldable, but not the null\n+ *   null       \/\/ could be a foldable subarray later\n@@ -136,0 +152,18 @@\n+ *\n+ * When the following method is called, some of the above stable\n+ * variables will gain their permanent value, a constant-foldable\n+ * string \"S\", or a non-default primitive value.\n+ *\n+ * <pre>{@code\n+ * void publishSomeStables() {\n+ *   \/\/ store some more foldable \"S\" values:\n+ *   FIELD = \"S\";\n+ *   ARRAY[2] = \"S\";\n+ *   MATRIX[2][0] = \"S\";\n+ *   MATRIX[3] = new Object[] { \"S\", \"S\", null };\n+ *   \/\/ and store some foldable primitives:\n+ *   IDNUM = 42;\n+ *   INITIALIZED = true;\n+ * }\n+ * }<\/pre>\n+ *\n@@ -137,1 +171,1 @@\n- * As very simple example, a stable boolean variable (i.e., stable\n+ * As a very simple example, a stable boolean variable (i.e., stable\n@@ -157,1 +191,3 @@\n- * <p>\n+ *\n+ * <h2><a id=\"final\"><\/a>Final Variables, Stable Variables, and Memory Effects<\/h2>\n+ *\n@@ -178,0 +214,6 @@\n+ * (Note: The barrier used by a class initializer is part of the from\n+ * an unlocking operation mandated by JVMS 5.5, Step 10, while the\n+ * barrier action of an instance initializer is specified quite\n+ * differently, by JLS 17.5.1.  These two barriers have analogous\n+ * effects on static and non-static final and stable variables.)\n+ * <p>\n@@ -192,2 +234,6 @@\n- * <p>\n- * Therefore, most code which reads stable variables should not assume\n+ *\n+ * <h2><a id=\"usage\"><\/a>Proper Handling of Stable Variables<\/h2>\n+ *\n+ * A stable variable can appear to be in either of two states:\n+ * Uninitialized set to a foldable value.\n+ * Therfore, most code which reads stable variables should not assume\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/Stable.java","additions":72,"deletions":26,"binary":false,"changes":98,"status":"modified"}]}