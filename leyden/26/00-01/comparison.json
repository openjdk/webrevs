{"files":[{"patch":"@@ -32,6 +32,8 @@\n- * <em>stable variable<\/em>, expected to change value at most once.\n- * The first value stored into the field (assuming it is not a\n- * duplicate of the the field's default initial value), allows the VM\n- * to assume that no more significant changes will occur.  This in\n- * turn enables the VM to optimize the stable variable, treating uses\n- * of it as constant values.  This behavior is a useful building block\n+ * <em>stable variable<\/em>, expected to change its value just once.\n+ * While the field contains its initial default (null or zero) value,\n+ * the VM treats it as an ordinary mutable variable.  When the\n+ * first value is stored into the field (assuming it is not a\n+ * duplicate of the the field's default initial value), the VM may\n+ * assume that no more significant changes will occur.  This in\n+ * turn enables the VM to optimize uses of the stable variable, treating\n+ * them as constant values.  This behavior is a useful building block\n@@ -39,1 +41,1 @@\n- * use cases, stable fields may also assume on multiple values over\n+ * use cases, stable variables may also assume multiple values over\n@@ -42,0 +44,5 @@\n+ * (Warning: the {@code @Stable} annotation is intended for use in the\n+ * JDK implemention, and with the HotSpot VM, to support optimization\n+ * of classes and algorithms defined by the JDK.  It is unavailable\n+ * outside the JDK.)\n+ * <p>\n@@ -63,8 +70,19 @@\n- * As a special case, if a stable field is declared as an array type\n- * with one dimension, both the array as a whole, and its eventual\n- * components, are treated as independent stable variables.  When a\n- * reference to an array of length <i>N<\/i> is stored to the field,\n- * then the array object itself is taken to be a constant, as with any\n- * stable field.  But then all <i>N<\/i> of the array components are\n- * <em>also<\/em> treated as independent stable variables.  Such a\n- * stable array may contain any type, reference or primitive.\n+ * A stable variable may be assigned its final value inside a class or\n+ * object initializer, but in general (with lazy data structures)\n+ * stable variables are assigned much later.  Depending on the value\n+ * stored and what races are possible, safe publication may require\n+ * special handling with a {@code VarHandle} atomic method.\n+ * (See below.)\n+ * <p>\n+ * As an extended behavior, if a stable field is declared as an array\n+ * type with one dimension, both that array as a whole, and its\n+ * eventual components, are treated as independent stable variables.\n+ * When a reference to an array of length <i>N<\/i> is stored to the\n+ * field, then the array object itself is taken to be a constant, as\n+ * with any stable field.  But then all <i>N<\/i> of the array\n+ * components are <em>also<\/em> treated as independent stable\n+ * variables.  Such a stable array may contain any type, reference or\n+ * primitive.  Such an array may be also marked {@code final}, and\n+ * initialized eagerly in the class or object initializer method.\n+ * Whether any (or all) of its components are also initialized eagerly\n+ * is up to the application.\n@@ -78,1 +96,1 @@\n- * variable is independently considered for optimization.  In this\n+ * variable being independently considered for optimization.  In this\n@@ -85,1 +103,44 @@\n- * case that could deal correctly with races.)\n+ * case that could deal correctly with races.  But it would require\n+ * careful treatment by the compiler, to avoid folding the wrong\n+ * version of an array.  Anyway, there are other options, such as\n+ * tree structures, for organizing the expansion of bundles of stable\n+ * variables.)\n+ * <p>\n+ * An array is never intrinsically stable.  There is no change made to\n+ * an array as it is assigned to a stable variable of array type.\n+ * This is true even though after such an assignment, the compiler may\n+ * observe that array and treat its components as stable variables.\n+ * If the array is aliased to some other variable, uses via that\n+ * variable will not be treated as stable.  (Such aliasing is not\n+ * recommended!)  Also, storing an array into a stable variable will\n+ * not make that array's components into stable variables, unless the\n+ * variable into which it is stored is statically typed as an array,\n+ * in the declaration of the stable field which refers to that array,\n+ * directly or indirectly.  Thus, in the following example, the only\n+ * constant-foldable string is {@code \"S\"}.  All subarrays are\n+ * constant.\n+ *\n+ * <pre>{@code\n+ * @Stable Object[] ARRAY = {\n+ *   \"S\",   \/\/ string \"S\" is stable\n+ *   new String[] { \"X\", \"Y\" },  \/\/ array is stable, not elements\n+ *   null  \/\/ null is default reference, not yet stable\n+ * };\n+ * @Stable Object[][] MATRIX = {\n+ *   { \"S\", \"S\" },   \/\/ constant value\n+ *   { new String[] { \"X\", \"Y\" } },  \/\/ both arrays stable, not elements\n+ *   { null, \"S\" },  \/\/ array is stable, but not null\n+ *   null       \/\/ not yet stable (could be stable array later)\n+ * };\n+ * }<\/pre>\n+ * <p>\n+ * As very simple example, a stable boolean variable (i.e., stable\n+ * field or stable boolean array element) might be constant-folded,\n+ * but only after it is set to {@code true}.  Even this simple\n+ * optimization is sometimes useful for responding to a permanent\n+ * one-shot state change, in such a way that the compiler can remove\n+ * dead code associated with the initial state.  As with any stable\n+ * variable, it is in general a bad idea to reset such a variable to\n+ * its default (i.e., {@code false}), since compiled code might have\n+ * captured the {@code true} value as a constant, and as long as that\n+ * compiled code is in use, the reset value will go undetected.\n@@ -87,8 +148,9 @@\n- * As very simple example, a boolean variable is constant-folded only\n- * when it is set to {@code true}.  Even this simple behavior is\n- * sometimes useful for recording a permanent one-shot state change,\n- * in such a way that the compiler can remove dead code associated\n- * with the initial state.  It is in general a bad idea to reset\n- * such a variable to {@code false}, since compiled code might have\n- * \"frozen\" the {@code true} value, and will never detect the reset\n- * value.\n+ * Stability of a variable and the constant folding of its default\n+ * value (null or zero) are mutually exclusive, as explained above.\n+ * So {@code final} field might be both null and also a constant, but\n+ * not a stable field.  If an application requires constant folding of\n+ * the default value, it can add an extra indirection to \"box\" the\n+ * default value, such as {@code Integer.valueOf(0)} or a lambda like\n+ * {@code ()->null}.  Such a refactoring should always be possible,\n+ * since stable variables should (obviously) never be part of public\n+ * APIs.\n@@ -97,1 +159,1 @@\n- * Since final fields already behave as stable values, such an annotation\n+ * Since final fields already behave as stable variables, such an annotation\n@@ -99,1 +161,1 @@\n- * still conveys information regarding change of additional component values if\n+ * it conveys information regarding changes to additional component variables if\n@@ -102,11 +164,0 @@\n- * There are special times early in application startup when constant\n- * folding of stable variables is disabled.  Specifically, the VM does\n- * not observe the effects of any {@code @Stable} annotation until\n- * after an AOT cache assembly phase (if any) has run to completion.\n- * Therefore, during these early times, a stable variable can be\n- * changed in any way, just like a regular mutable variable (field or\n- * array component).  If a field is annotated {@code @Stable} but is\n- * treated in this way during AOT cache assembly, that fact must be\n- * clearly stated as a warning on the field declaration.  If there is\n- * no such warning, maintainers can ignore this edge case.\n- * <p>\n@@ -127,1 +178,1 @@\n- * There is no such freeze operation applied to stable field stores in\n+ * There is no such JMM freeze operation applied to stable field stores in\n@@ -129,2 +180,2 @@\n- * initialize a stable variable, rather than \"leaving it for later\",\n- * and that initial will be safely published, as if the field were\n+ * initialize a stable variable, rather than \"leaving it for later\".\n+ * Such an initial value will be safely published, as if the field were\n@@ -135,1 +186,1 @@\n- * if there were no {@code @Stable} annotation, and the field was a\n+ * if there were no {@code @Stable} annotation, and the field were a\n@@ -144,3 +195,3 @@\n- * (or zero) value.  Code which cannot prove proper ordering of\n- * initialization may use stable variables without performing the null\n- * (or zero) test.  Code which omits the null (or zero) test should be\n+ * (or zero) value.  Code which cannot prove a previous initialization\n+ * must perform a null (or zero) test on a value loaded\n+ * from a stable variable.  Code which omits the null (or zero) test should be\n@@ -149,17 +200,7 @@\n- * pointed out as provably preceding all uses of the (unchecked)\n- * stable variable.  Examples of such a critical section would be a\n- * constructor body which directly writes a final or stable variable,\n- * or the AOT cache assembly phase as a whole.\n- * <p>\n- * The HotSpot VM relies on this annotation to promote a non-null (or\n- * non-zero) stable variable use to a constant, thereby enabling superior\n- * optimizations of code depending on the value (such as constant folding).\n- * More specifically, the HotSpot VM will process non-null stable fields (final\n- * or otherwise) in a similar manner to static final fields with respect to\n- * promoting the field's value to a constant.  Thus, placing aside the\n- * differences for null\/non-null values and arrays, a final stable field is\n- * treated as if it is really final from both the Java language and the HotSpot\n- * VM.\n- * <p>\n- * After constant folding, the compiler can make use of may aspects of\n- * the object: Its dynamic type, its length (if it is an array), and\n+ * documented, as provably preceding all uses of the (unchecked)\n+ * stable variable, or else reasons should be given why races are\n+ * benign, or some other proof given that races are either excluded or\n+ * benign.  See below for further discussion.\n+ * <p>\n+ * After constant folding, the compiler can make use of many aspects of\n+ * the object: its dynamic type, its length (if it is an array), and\n@@ -175,9 +216,7 @@\n- * or by some other means.  If the HotSpot compiler observes one of\n- * these values, and constant-folds it in the setting of some\n- * particular compilation task, then in some contexts (execution of\n- * fully optimized code) the field will appear to have one\n- * \"historical\" value, while in others (less optimized contexts) the\n- * field will appear to have a more recent value.  (And it is no good\n- * to try to \"reset\" a stable value by storing its default again,\n- * because there is currently no way to find and deoptimize any and\n- * all affected compiled code.)  Race conditions would make this even\n+ * or by some other means.  If the HotSpot compiler constant-folds a\n+ * stable variable, then in some contexts (execution of fully\n+ * optimized code) the variable will appear to have one \"historical\"\n+ * value, observed, captured, and used within the compiled code to the\n+ * exclusion of any other possible values.  Meanwhile, in other less\n+ * optimized contexts, the stable variable will appear to have a more\n+ * recent value.  Race conditions, if allowed, will make this even\n@@ -185,1 +224,10 @@\n- * value.\n+ * value across all threads.  The compiler can observe any racing\n+ * value, as it runs concurrently to the application, in its own\n+ * thread.\n+ * <p>\n+ * It is no good to try to \"reset\" a stable variable by storing its\n+ * default again, because there is (currently) no way to find and\n+ * deoptimize any and all affected compiled code.  If you need the\n+ * bookkeeping, try {@code SwitchPoint} or {@code MutableCallSite},\n+ * which both are able to reset compiled code that has captured an\n+ * intermediate state.\n@@ -187,1 +235,1 @@\n- * Note also each compiliation task makes its own decisions about\n+ * Note also each compilation task makes its own decisions about\n@@ -205,11 +253,47 @@\n- * The {@code @Stable} annotation is intended for use in the JDK\n- * implemention, and with the HotSpot VM, to support optimization of\n- * classes and algorithms defined by the JDK.  Any class which uses\n- * this annotation is responsible for constraining assignments in such\n- * a way as not to violate API contracts of the class.  Such\n- * constraints can be arranged using explicit atomic access\n- * (sychronization, CAS, etc.), or by concealing the effects of\n- * multiple assignments in some API-dependent way, or by providing\n- * some other internal proof of correctness (accounting for any\n- * possible racing API access), or by some appropriate disclaimer in\n- * the API about undefined behavior.\n+ * Any class which uses this annotation is responsible for\n+ * constraining assignments in such a way as not to violate API\n+ * contracts of the class.  (If the chosen technique is unusual in\n+ * some way, it should be documented in a comment on the field.)  Such\n+ * constraints can be arranged in a variety of ways:\n+ * <ul><li> using the {@code VarHandle} API to perform an explicit\n+ * atomic operation such as {@code compareAndExchange},\n+ * {@code setRelease}, {@code releaseFence}, or the like.\n+ * <\/li><li> using regular variable access under explicit sychronization\n+ * <\/li><li> using some other kind of critical section to avoid races\n+ * which could affect compiled code\n+ * <\/li><li> allowing multiple assignments under benign races, but\n+ * only of some separately uniquified value\n+ * <\/li><li> allowing multiple assignments under benign races, but\n+ * only of semantically equivalent values, perhaps permitting\n+ * occasional duplication of cached values\n+ * <\/li><li> concealing the effects of multiple assignments in some\n+ * other API-dependent way\n+ * <\/li><li> providing some other internal proof of correctness, while\n+ * accounting for all possible racing API accesses\n+ * <\/li><li> making some appropriate disclaimer in the API about\n+ * undefined behavior\n+ * <\/li><\/ul>\n+ * <p>\n+ * There may be special times when constant folding of stable\n+ * variables is disabled.  Such times would amount to a critical\n+ * section locking out the compiler from reading stable variables.\n+ * During such a critical section, an uninitialized stable variable\n+ * can be changed in any way, just like a regular mutable variable\n+ * (field or array component).  It can even be reset to its default.\n+ * Specifically, this may happen during certain AOT operations.  If a\n+ * stable variable can be updated multiple times during such a\n+ * critical section, that fact must be clearly stated as a comment on\n+ * the field declaration.  (In the future, there may be explicit\n+ * AOT-related annotations to convey this use case.)  If there is no\n+ * such warning, maintainers can safely disregard the possibility of\n+ * an AOT critical section, since the author of the stable variable is\n+ * relying on one of the other techniques listed above.\n+ * <p>\n+ * It is possible to imagine markings for foldable methods or fields,\n+ * which can constant-fold a wider variety of states and values.  This\n+ * annotation does not readily extend to such things, for the simple\n+ * reason that extra VM bookkeeping would be required to record a\n+ * wider variety of candidate states for constant folding.  Such\n+ * higher-level mechanisms may be created in the future.  The present\n+ * low-level annotation is designed as a potential building block to\n+ * manage their bookkeeping.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/Stable.java","additions":168,"deletions":84,"binary":false,"changes":252,"status":"modified"}]}