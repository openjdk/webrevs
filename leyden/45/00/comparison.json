{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -40,0 +42,2 @@\n+DEBUG_ONLY(InstanceKlass* _aot_init_class = nullptr;)\n+\n@@ -324,0 +328,6 @@\n+#ifdef ASSERT\n+  if (ik == _aot_init_class) {\n+    return true;\n+  }\n+#endif\n+\n@@ -482,0 +492,30 @@\n+\n+#ifdef ASSERT\n+void AOTClassInitializer::init_test_class(TRAPS) {\n+  \/\/ -XX:AOTInitTestClass is used in regression tests for adding additional AOT-initialized classes\n+  \/\/ and heap objects into the AOT cache. The tests must be carefully written to avoid including\n+  \/\/ any classes that cannot be AOT-initialized.\n+  \/\/\n+  \/\/ -XX:AOTInitTestClass is NOT a general mechanism for including user-defined objects into\n+  \/\/ the AOT cache. Therefore, this option is NOT available in product JVM.\n+  if (AOTInitTestClass != nullptr && CDSConfig::is_initing_classes_at_dump_time()) {\n+    log_info(cds)(\"Debug build only: force initialization of AOTInitTestClass %s\", AOTInitTestClass);\n+    TempNewSymbol class_name = SymbolTable::new_symbol(AOTInitTestClass);\n+    Handle app_loader(THREAD, SystemDictionary::java_system_loader());\n+    Klass* k = SystemDictionary::resolve_or_null(class_name, app_loader, CHECK);\n+    if (k == nullptr) {\n+      vm_exit_during_initialization(\"AOTInitTestClass not found\", AOTInitTestClass);\n+    }\n+    if (!k->is_instance_klass()) {\n+      vm_exit_during_initialization(\"Invalid name for AOTInitTestClass\", AOTInitTestClass);\n+    }\n+\n+    _aot_init_class = InstanceKlass::cast(k);\n+    _aot_init_class->initialize(CHECK);\n+  }\n+}\n+\n+bool AOTClassInitializer::has_test_class() {\n+  return _aot_init_class != nullptr;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,4 @@\n+\n+  \/\/ Support for regression testing. Available in debug builds only.\n+  static void init_test_class(TRAPS) NOT_DEBUG_RETURN;\n+  static bool has_test_class() NOT_DEBUG({ return false; });\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,4 @@\n+  develop(ccstr, AOTInitTestClass, nullptr,                                 \\\n+          \"For JVM internal testing only. The specified class is stored \"   \\\n+          \"in the initialized state in the AOT cache \")                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -991,0 +991,2 @@\n+      \/\/ -XX:AOTInitTestClass must be used carefully in regression tests to\n+      \/\/ include only classes that are safe to aot-initialize.\n@@ -992,1 +994,2 @@\n-             HeapShared::is_lambda_proxy_klass(ik),\n+             HeapShared::is_lambda_proxy_klass(ik) ||\n+             AOTClassInitializer::has_test_class(),\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -791,0 +791,1 @@\n+  AOTClassInitializer::init_test_class(CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test various test cases for archived WeakReference objects.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.debug\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @comment TODO ...tested only against G1\n+ * @requires vm.gc.G1\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build WeakReferenceTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar weakref.jar\n+ *             WeakReferenceTestApp WeakReferenceTestApp$Inner ShouldNotBeAOTInited ShouldNotBeArchived SharedQueue\n+ * @run driver WeakReferenceTest AOT\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.ref.ReferenceQueue;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class WeakReferenceTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"weakref.jar\");\n+    static final String mainClass = \"WeakReferenceTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+        t.run(args);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-Xlog:gc,cds+class=debug\",\n+                    \"-XX:AOTInitTestClass=WeakReferenceTestApp\",\n+                    \"-Xlog:cds+map,cds+map+oops=trace:file=cds.oops.txt:none:filesize=0\",\n+                };\n+            } else {\n+                return new String[] {\n+                    \"-Xlog:gc\",\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                runMode.toString(),\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            out.shouldHaveExitValue(0);\n+            out.shouldNotContain(\"Unexpected exception:\");\n+        }\n+    }\n+}\n+\n+\/\/ TODO: Add test: cleaner should work in both assembly phase and production run\n+\n+class WeakReferenceTestApp {\n+    \/\/ This class is NOT aot-initialized\n+    static class Inner {\n+        static boolean WeakReferenceTestApp_clinit_executed;\n+    }\n+\n+    static {\n+        Inner.WeakReferenceTestApp_clinit_executed = true;\n+\n+        \/\/ During the assembly phase, this block of code is called during the assembly\n+        \/\/ phase (triggered by the -XX:AOTInitTestClass=WeakReferenceTestApp flag).\n+        \/\/ It runs the clinit_for_testXXX() method to set up the aot-initialized data structures\n+        \/\/ that are used by  each testXXX() function.\n+        \/\/\n+        \/\/ Note that this function is also called during the training run.\n+        \/\/ This function is NOT called during the production run, because WeakReferenceTestApp\n+        \/\/ is aot-initialized.\n+\n+        clinit_for_testCollectedInAssembly();\n+        clinit_for_testWeakReferenceCollection();\n+        clinit_for_testQueue();\n+    }\n+\n+    static WeakReference makeRef() {\n+        System.out.println(\"WeakReferenceTestApp::makeRef() is executed\");\n+        WeakReference r = new WeakReference(root);\n+        System.out.println(\"r.get() = \" + r.get());\n+\n+        ShouldNotBeAOTInited.doit();\n+        return r;\n+    }\n+\n+    static WeakReference makeRef2() {\n+        return new WeakReference(new WeakReferenceTestApp());\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            runTests(args);\n+        } catch (Throwable t) {\n+            System.err.println(\"Unexpected exception:\");\n+            t.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    static void runTests(String[] args) throws Exception {\n+        boolean isProduction = args[0].equals(\"PRODUCTION\");\n+\n+        if (isProduction && Inner.WeakReferenceTestApp_clinit_executed) {\n+            throw new RuntimeException(\"WeakReferenceTestApp should have been aot-inited\");\n+        }\n+\n+        if (isProduction) {\n+            \/\/ A GC should have happened before the heap objects are written into\n+            \/\/ the AOT cache. So any unreachable referents should have been collected.\n+        } else {\n+            \/\/ We are in the training run. Simulate the GC mentioned in the above comment,\n+            \/\/ so the test cases should observe the same states as in the production run.\n+            System.gc();\n+        }\n+\n+        testCollectedInAssembly(isProduction);\n+        testWeakReferenceCollection(isProduction);\n+        testQueue(isProduction);\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testCollectedInAssembly()\n+    static WeakReference refToCollectedObj;\n+\n+    static void clinit_for_testCollectedInAssembly() {\n+        \/\/ The referent will be GC-ed in the assembly run when the JVM forces a full GC.\n+        refToCollectedObj = new WeakReference(new String(\"collected in assembly\"));\n+    }\n+\n+    \/\/ [TEST CASE] Test the storage of a WeakReference whose referent has been collected during the assembly phase.\n+    static void testCollectedInAssembly(boolean isProduction) {\n+        System.out.println(\"refToCollectedObj.get() = \" + refToCollectedObj.get());\n+        System.out.println(\"refToCollectedObj.isEnqueued() = \" + refToCollectedObj.isEnqueued());\n+\n+        if (refToCollectedObj.get() != null) {\n+            throw new RuntimeException(\"refToCollectedObj.get() should have been GC'ed\");\n+        }\n+\n+        \/*\n+         * FIXME -- why does this fail, even in training run?\n+\n+        if (!refToCollectedObj.isEnqueued()) {\n+            throw new RuntimeException(\"refToCollectedObj.isEnqueued() should be true\");\n+        }\n+        *\/\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testWeakReferenceCollection()\n+    static Object root;\n+    static WeakReference ref;\n+\n+    static void clinit_for_testWeakReferenceCollection() {\n+        root = new WeakReferenceTestApp();\n+        ref = makeRef();\n+    }\n+\n+    \/\/ [TEST CASE] A WeakReference allocated in assembly phase should be collectable in the production run\n+    static void testWeakReferenceCollection(boolean isProduction) {\n+        WeakReference ref2 = makeRef2();\n+        System.out.println(\"ref.get() = \" + ref.get());   \/\/ created during assembly phase\n+        System.out.println(\"ref2.get() = \" + ref2.get()); \/\/ created during production run\n+\n+        if (ref.get() == null) {\n+            throw new RuntimeException(\"ref.get() should not be null\");\n+        }\n+        if (ref2.get() == null) {\n+            throw new RuntimeException(\"ref2.get() should not be null\");\n+        }\n+\n+        System.out.println(\"... running GC ...\");\n+        root = null;\n+        System.gc();\n+\n+        System.out.println(\"ref.get() = \" + ref.get());\n+        System.out.println(\"ref2.get() = \" + ref2.get());\n+\n+        if (ref.get() != null) {\n+            throw new RuntimeException(\"ref.get() should be null\");\n+        }\n+        if (ref2.get() != null) {\n+            throw new RuntimeException(\"ref2.get() should be null\");\n+        }\n+\n+        System.out.println(\"ShouldNotBeAOTInited.doit_executed = \" + ShouldNotBeAOTInited.doit_executed);\n+        if (isProduction && ShouldNotBeAOTInited.doit_executed) {\n+            throw new RuntimeException(\"ShouldNotBeAOTInited should not have been aot-inited\");\n+        }\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testQueue()\n+    static WeakReference refWithQueue;\n+    static SharedQueue sharedQueueInstance;\n+\n+    static void clinit_for_testQueue() {\n+        \/\/ Make sure SharedQueue is also cached in *initialized* state.\n+        sharedQueueInstance = SharedQueue.sharedQueueInstance;\n+\n+        refWithQueue = new WeakReference(String.class, SharedQueue.queue());\n+        ShouldNotBeArchived.ref = new WeakReference(ShouldNotBeArchived.instance, SharedQueue.queue());\n+\n+\n+        \/\/ Set to 2 in training run and assembly phase, but this state shouldn't be stored in\n+        \/\/ AOT cache.\n+        ShouldNotBeArchived.state = 2;\n+    }\n+\n+    \/\/ [TEST CASE] Unrelated WeakReferences shouldn't be cached even if they are registered with the same queue\n+    static void testQueue(boolean isProduction) {\n+        System.out.println(\"refWithQueue.get() = \" + refWithQueue.get());\n+        System.out.println(\"ShouldNotBeArchived.state = \" + ShouldNotBeArchived.state);\n+\n+        \/\/ [1] Although refWithQueue and ShouldNotBeArchived.ref are registered with the same queue, as both\n+        \/\/     of their referents are strongly referenced, they are not added to the queue's \"head\".\n+        \/\/     (Per javadoc: \"registered reference objects are appended by the garbage collector after the\n+        \/\/     appropriate reachability changes are detected\");\n+        \/\/ [2] When the assembly phase scans refWithQueue, it shouldn't discover ShouldNotBeArchived.ref (via the queue),\n+        \/\/     so ShouldNotBeArchived.ref should not be stored in the AOT cache.\n+        \/\/ [3] As a result, ShouldNotBeArchived should be cached in the *not initialized\" state. Its <clinit>\n+        \/\/     will be executed in the production run to set ShouldNotBeArchived.state to 1.\n+        if (isProduction && ShouldNotBeArchived.state != 1) {\n+            throw new RuntimeException(\"ShouldNotBeArchived should be 1 but is \" + ShouldNotBeArchived.state);\n+        }\n+    }\n+}\n+\n+class ShouldNotBeAOTInited {\n+    static WeakReference ref;\n+    static boolean doit_executed;\n+    static {\n+        System.out.println(\"ShouldNotBeAOTInited.<clinit> called\");\n+    }\n+    static void doit() {\n+        System.out.println(\"ShouldNotBeAOTInited.doit()> called\");\n+        doit_executed = true;\n+        ref = new WeakReference(new ShouldNotBeAOTInited());\n+    }\n+}\n+\n+class ShouldNotBeArchived {\n+    static ShouldNotBeArchived instance = new ShouldNotBeArchived();\n+    static WeakReference ref;\n+    static int state = 1;\n+}\n+\n+class SharedQueue {\n+    static SharedQueue sharedQueueInstance = new SharedQueue();\n+    private ReferenceQueue<Object> theQueue = new ReferenceQueue<Object>();\n+\n+    static ReferenceQueue<Object> queue() {\n+        return sharedQueueInstance.theQueue;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"}]}