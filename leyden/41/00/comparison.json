{"files":[{"patch":"@@ -345,0 +345,1 @@\n+         ik == vmClasses::Reference_klass() ||\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -620,3 +620,0 @@\n-\n-    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n-    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1007,0 +1007,1 @@\n+    assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n@@ -1022,10 +1023,0 @@\n-      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n-      \/\/ updated concurrently when we are saving their contents into a side table.\n-      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n-\n-      JavaValue result(T_VOID);\n-      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n-                             vmSymbols::createArchivedObjects(),\n-                             vmSymbols::void_method_signature(),\n-                             CHECK);\n-\n@@ -1037,0 +1028,1 @@\n+      JavaValue result(T_VOID);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5475,6 +5475,0 @@\n-  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n-    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -94,1 +93,1 @@\n-        final Object cache;\n+        final SoftReference<LambdaForm> cache;\n@@ -99,5 +98,1 @@\n-            if (USE_SOFT_CACHE) {\n-                cache = new SoftReference<LambdaForm>(result);\n-            } else {\n-                cache = result;\n-            }\n+            cache = new SoftReference<LambdaForm>(result);\n@@ -145,1 +140,0 @@\n-        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -147,5 +141,1 @@\n-            if (cache instanceof LambdaForm lf) {\n-                return lf;\n-            } else {\n-                return ((SoftReference<LambdaForm>)cache).get();\n-            }\n+            return cache.get();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -693,18 +693,0 @@\n-\n-    \/\/--- AOTCache support\n-\n-    \/**\n-     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n-     * use soft references to allow class unloading.\n-     *\n-     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n-     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n-     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n-     * Such classes will never be unloaded, so it's OK to use hard references.\n-     *\/\n-    static final boolean USE_SOFT_CACHE;\n-\n-    static {\n-        USE_SOFT_CACHE = Boolean.parseBoolean(\n-                System.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.HashMap;\n@@ -397,11 +396,0 @@\n-        if (archivedMethodTypes != null) {\n-            \/\/ If this JVM process reads from archivedMethodTypes, it never\n-            \/\/ modifies the table. So there's no need for synchronization.\n-            \/\/ See copyInternTable() below.\n-            assert CDS.isUsingArchive();\n-            MethodType mt = archivedMethodTypes.get(primordialMT);\n-            if (mt != null) {\n-                return mt;\n-            }\n-        }\n-\n@@ -410,0 +398,1 @@\n+        {\n@@ -411,0 +400,1 @@\n+        }\n@@ -428,1 +418,0 @@\n-    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1399,26 +1388,0 @@\n-\n-    static HashMap<MethodType,MethodType> copyInternTable() {\n-        HashMap<MethodType,MethodType> copy = new HashMap<>();\n-\n-        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n-            MethodType t = i.next();\n-            copy.put(t, t);\n-        }\n-\n-        return copy;\n-    }\n-\n-    \/\/ This is called from C code, at the very end of Java code execution\n-    \/\/ during the AOT cache assembly phase.\n-    static void createArchivedObjects() {\n-        \/\/ After the archivedMethodTypes field is assigned, this table\n-        \/\/ is never modified. So we don't need synchronization when reading from\n-        \/\/ it (which happens only in a future JVM process, never in the current process).\n-        \/\/\n-        \/\/ @implNote CDS.isDumpingStaticArchive() is mutually exclusive with\n-        \/\/ CDS.isUsingArchive(); at most one of them can return true for any given JVM\n-        \/\/ process.\n-        assert CDS.isDumpingStaticArchive();\n-        archivedMethodTypes = copyInternTable();\n-        internTable.clear();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -118,2 +117,0 @@\n-        } else if (entry instanceof MethodHandle mh) {\n-            return mh;\n@@ -131,5 +128,1 @@\n-        if (USE_SOFT_CACHE) {\n-            methodHandles[which] = new SoftReference<>(mh);\n-        } else {\n-            methodHandles[which] = mh;\n-        }\n+        methodHandles[which] = new SoftReference<>(mh);\n@@ -144,2 +137,0 @@\n-        } else if (entry instanceof LambdaForm lf) {\n-            return lf;\n@@ -157,5 +148,1 @@\n-        if (USE_SOFT_CACHE) {\n-            lambdaForms[which] = new SoftReference<>(form);\n-        } else {\n-            lambdaForms[which] = form;\n-        }\n+        lambdaForms[which] = new SoftReference<>(form);\n@@ -170,1 +157,0 @@\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -310,0 +310,4 @@\n+        runtimeSetup();\n+    }\n+\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}