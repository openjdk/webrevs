{"files":[{"patch":"@@ -334,0 +334,1 @@\n+         ik == vmClasses::Reference_klass() ||\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -628,3 +628,0 @@\n-\n-    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n-    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1059,0 +1059,1 @@\n+    assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n@@ -1074,10 +1075,0 @@\n-      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n-      \/\/ updated concurrently when we are saving their contents into a side table.\n-      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n-\n-      JavaValue result(T_VOID);\n-      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n-                             vmSymbols::createArchivedObjects(),\n-                             vmSymbols::void_method_signature(),\n-                             CHECK);\n-\n@@ -1089,0 +1080,1 @@\n+      JavaValue result(T_VOID);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5451,6 +5451,0 @@\n-  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n-    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -93,2 +92,1 @@\n-    private static final class Transform {\n-        final Object cache;\n+    private static final class Transform extends SoftReference<LambdaForm> {\n@@ -99,5 +97,1 @@\n-            if (USE_SOFT_CACHE) {\n-                cache = new SoftReference<LambdaForm>(result);\n-            } else {\n-                cache = result;\n-            }\n+            super(result);\n@@ -144,9 +138,0 @@\n-\n-        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-        public LambdaForm get() {\n-            if (cache instanceof LambdaForm lf) {\n-                return lf;\n-            } else {\n-                return ((SoftReference<LambdaForm>)cache).get();\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -668,18 +668,0 @@\n-\n-    \/\/--- AOTCache support\n-\n-    \/**\n-     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n-     * use soft references to allow class unloading.\n-     *\n-     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n-     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n-     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n-     * Such classes will never be unloaded, so it's OK to use hard references.\n-     *\/\n-    static final boolean USE_SOFT_CACHE;\n-\n-    static {\n-        USE_SOFT_CACHE = Boolean.parseBoolean(\n-                System.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n@@ -45,1 +43,0 @@\n-import jdk.internal.misc.CDS;\n@@ -397,11 +394,0 @@\n-        if (archivedMethodTypes != null) {\n-            \/\/ If this JVM process reads from archivedMethodTypes, it never\n-            \/\/ modifies the table. So there's no need for synchronization.\n-            \/\/ See copyInternTable() below.\n-            assert CDS.isUsingArchive();\n-            MethodType mt = archivedMethodTypes.get(primordialMT);\n-            if (mt != null) {\n-                return mt;\n-            }\n-        }\n-\n@@ -428,1 +414,0 @@\n-    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1399,26 +1384,0 @@\n-\n-    static HashMap<MethodType,MethodType> copyInternTable() {\n-        HashMap<MethodType,MethodType> copy = new HashMap<>();\n-\n-        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n-            MethodType t = i.next();\n-            copy.put(t, t);\n-        }\n-\n-        return copy;\n-    }\n-\n-    \/\/ This is called from C code, at the very end of Java code execution\n-    \/\/ during the AOT cache assembly phase.\n-    static void createArchivedObjects() {\n-        \/\/ After the archivedMethodTypes field is assigned, this table\n-        \/\/ is never modified. So we don't need synchronization when reading from\n-        \/\/ it (which happens only in a future JVM process, never in the current process).\n-        \/\/\n-        \/\/ @implNote CDS.isDumpingStaticArchive() is mutually exclusive with\n-        \/\/ CDS.isUsingArchive(); at most one of them can return true for any given JVM\n-        \/\/ process.\n-        assert CDS.isDumpingStaticArchive();\n-        archivedMethodTypes = copyInternTable();\n-        internTable.clear();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -55,1 +54,1 @@\n-    private final Object[] methodHandles;\n+    private final SoftReference<MethodHandle>[] methodHandles;\n@@ -65,1 +64,1 @@\n-    private final Object[] lambdaForms;\n+    private final SoftReference<LambdaForm>[] lambdaForms;\n@@ -113,1 +112,0 @@\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -115,8 +113,2 @@\n-        Object entry = methodHandles[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof MethodHandle mh) {\n-            return mh;\n-        } else {\n-            return ((SoftReference<MethodHandle>)entry).get();\n-        }\n+        SoftReference<MethodHandle> entry = methodHandles[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -131,5 +123,1 @@\n-        if (USE_SOFT_CACHE) {\n-            methodHandles[which] = new SoftReference<>(mh);\n-        } else {\n-            methodHandles[which] = mh;\n-        }\n+        methodHandles[which] = new SoftReference<>(mh);\n@@ -139,1 +127,0 @@\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -141,8 +128,2 @@\n-        Object entry = lambdaForms[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof LambdaForm lf) {\n-            return lf;\n-        } else {\n-            return ((SoftReference<LambdaForm>)entry).get();\n-        }\n+        SoftReference<LambdaForm> entry = lambdaForms[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -157,5 +138,1 @@\n-        if (USE_SOFT_CACHE) {\n-            lambdaForms[which] = new SoftReference<>(form);\n-        } else {\n-            lambdaForms[which] = form;\n-        }\n+        lambdaForms[which] = new SoftReference<>(form);\n@@ -170,1 +147,1 @@\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+     @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -211,2 +188,2 @@\n-            this.lambdaForms   = new Object[LF_LIMIT];\n-            this.methodHandles = new Object[MH_LIMIT];\n+            this.lambdaForms   = new SoftReference[LF_LIMIT];\n+            this.methodHandles = new SoftReference[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":11,"deletions":34,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -310,0 +310,4 @@\n+        runtimeSetup();\n+    }\n+\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}