{"files":[{"patch":"@@ -1083,1 +1083,1 @@\n-  if (this == nullptr) { \/\/ gcc complains 'nonnull' argument 'this' compared to nullptr \n+  if (this == nullptr) { \/\/ gcc complains 'nonnull' argument 'this' compared to nullptr\n@@ -1097,99 +1097,0 @@\n-\/\/ ----- CHeapString -----------------------------------------------------------\n-\n-class CHeapString : public CHeapObj<mtCode> {\n- public:\n-  CHeapString(const char* str) : _string(os::strdup(str)) {}\n- ~CHeapString() {\n-    os::free((void*)_string);\n-    _string = nullptr;\n-  }\n-  const char* string() const { return _string; }\n-\n- private:\n-  const char* _string;\n-};\n-\n-\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n-\n-class AsmRemarkCollection : public CHeapObj<mtCode> {\n- public:\n-  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n- ~AsmRemarkCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  AsmRemarkCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(uint offset, const char* remark);\n-  const char* lookup(uint offset) const;\n-  const char* next(uint offset) const;\n-\n-  bool is_empty() const { return _remarks == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* remark, uint offset) :\n-        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    uint offset;\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _remarks;\n-  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n-  \/\/ does not change the state of the list per se), supportig a simplistic\n-  \/\/ iteration scheme.\n-  mutable Cell* _next;\n-};\n-\n-\/\/ ----- DbgStringCollection ---------------------------------------------------\n-\n-class DbgStringCollection : public CHeapObj<mtCode> {\n- public:\n-  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n- ~DbgStringCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  DbgStringCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(const char* str);\n-  const char* lookup(const char* str) const;\n-\n-  bool is_empty() const { return _strings == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* dbgstr) :\n-        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _strings;\n-};\n-\n@@ -1207,0 +1108,3 @@\n+  if (_remarks != nullptr) {\n+    clear();\n+  }\n@@ -1210,0 +1114,4 @@\n+void AsmRemarks::init(AsmRemarks& asm_remarks) {\n+  asm_remarks._remarks = new AsmRemarkCollection();\n+}\n+\n@@ -1226,0 +1134,1 @@\n+  assert(_remarks != nullptr, \"sanity check\");\n@@ -1259,0 +1168,3 @@\n+  if (_strings != nullptr) {\n+    clear();\n+  }\n@@ -1262,0 +1174,4 @@\n+void DbgStrings::init(DbgStrings& dbg_strings) {\n+  dbg_strings._strings = new DbgStringCollection();\n+}\n+\n@@ -1278,0 +1194,1 @@\n+  assert(_strings != nullptr, \"sanity check\");\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":17,"deletions":100,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -294,2 +295,69 @@\n-class AsmRemarkCollection;\n-class DbgStringCollection;\n+class CHeapString : public CHeapObj<mtCode> {\n+ public:\n+  CHeapString(const char* str) : _string(os::strdup(str)) {}\n+ ~CHeapString() {\n+    os::free((void*)_string);\n+    _string = nullptr;\n+  }\n+  const char* string() const { return _string; }\n+\n+ private:\n+  const char* _string;\n+};\n+\n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+ public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+ ~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_remarks != nullptr) {\n+      Cell* tmp = _remarks;\n+      do {\n+        if(!function(tmp->offset, tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _remarks);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n@@ -307,0 +375,2 @@\n+  static void init(AsmRemarks& asm_remarks);\n+\n@@ -318,0 +388,3 @@\n+  template<typename Function>\n+  bool iterate(Function function) const { return _remarks->iterate(function); }\n+\n@@ -322,0 +395,51 @@\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+ public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+ ~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_strings != nullptr) {\n+      Cell* tmp = _strings;\n+      do {\n+        if (!function(tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _strings);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n+};\n+\n@@ -330,0 +454,2 @@\n+  static void init(DbgStrings& dbg_strings);\n+\n@@ -340,0 +466,3 @@\n+  template<typename Function>\n+  bool iterate(Function function) const { return _strings->iterate(function); }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":131,"deletions":2,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -981,0 +981,206 @@\n+\/\/ scc_entry != nullptr implies loading compiled code from AOT code cache\n+bool ciEnv::is_compilation_valid(JavaThread* thread, ciMethod* target, bool preload, bool install_code, CodeBuffer* code_buffer, SCCEntry* scc_entry) {\n+  methodHandle method(thread, target->get_Method());\n+\n+  \/\/ We require method counters to store some method state (max compilation levels) required by the compilation policy.\n+  if (!preload && method->get_method_counters(thread) == nullptr) {\n+    record_failure(\"can't create method counters\");\n+    if (code_buffer != nullptr) {\n+      code_buffer->free_blob();\n+    }\n+    return false;\n+  }\n+\n+  if (scc_entry != nullptr) {\n+    \/\/ Invalid compilation states:\n+    \/\/  - SCCache is closed, SCC entry is garbage.\n+    \/\/  - SCC entry indicates this shared code was marked invalid while it was loaded.\n+    if (!SCCache::is_on() || scc_entry->not_entrant()) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Change in Jvmti state may invalidate compilation.\n+  if (!failing() && jvmti_state_changed()) {\n+    record_failure(\"Jvmti state change invalidated dependencies\");\n+  }\n+\n+  \/\/ Change in DTrace flags may invalidate compilation.\n+  if (!failing() &&\n+      ( (!dtrace_method_probes() && DTraceMethodProbes) ||\n+        (!dtrace_alloc_probes() && DTraceAllocProbes) )) {\n+    record_failure(\"DTrace flags change invalidated dependencies\");\n+  }\n+\n+  if (!preload && !failing() && target->needs_clinit_barrier() &&\n+      target->holder()->is_in_error_state()) {\n+    record_failure(\"method holder is in error state\");\n+  }\n+\n+  if (!failing() && (scc_entry == nullptr)) {\n+    if (log() != nullptr) {\n+      \/\/ Log the dependencies which this compilation declares.\n+      dependencies()->log_all_dependencies();\n+    }\n+\n+    \/\/ Encode the dependencies now, so we can check them right away.\n+    dependencies()->encode_content_bytes();\n+  }\n+  \/\/ Check for {class loads, evolution, breakpoints, ...} during compilation\n+  if (!failing() && install_code) {\n+    \/\/ Check for {class loads, evolution, breakpoints, ...} during compilation\n+    validate_compile_task_dependencies(target);\n+    if (failing() && preload) {\n+      ResourceMark rm;\n+      char *method_name = method->name_and_sig_as_C_string();\n+      log_info(scc)(\"preload code for '%s' failed dependency check\", method_name);\n+    }\n+  }\n+\n+  if (failing()) {\n+    \/\/ While not a true deoptimization, it is a preemptive decompile.\n+    MethodData* mdo = method()->method_data();\n+    if (mdo != nullptr && _inc_decompile_count_on_failure) {\n+      mdo->inc_decompile_count();\n+    }\n+\n+    if (code_buffer != nullptr) {\n+      code_buffer->free_blob();\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void ciEnv::make_code_usable(JavaThread* thread, ciMethod* target, bool preload, int entry_bci, SCCEntry* scc_entry, nmethod* nm) {\n+  methodHandle method(thread, target->get_Method());\n+\n+  if (entry_bci == InvocationEntryBci) {\n+    if (TieredCompilation) {\n+      \/\/ If there is an old version we're done with it\n+      nmethod* old = method->code();\n+      if (TraceMethodReplacement && old != nullptr) {\n+        ResourceMark rm;\n+        char *method_name = method->name_and_sig_as_C_string();\n+        tty->print_cr(\"Replacing method %s\", method_name);\n+      }\n+      if (old != nullptr) {\n+        old->make_not_used();\n+      }\n+    }\n+\n+    LogTarget(Info, nmethod, install) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      char *method_name = method->name_and_sig_as_C_string();\n+      lt.print(\"Installing method (L%d) %s id=%d scc=%s%s%u\",\n+               task()->comp_level(), method_name, compile_id(),\n+               task()->is_scc() ? \"A\" : \"\", preload ? \"P\" : \"\",\n+               (scc_entry != nullptr ? scc_entry->offset() : 0));\n+    }\n+    \/\/ Allow the code to be executed\n+    MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+    if (nm->make_in_use()) {\n+#ifdef ASSERT\n+      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      if (bs_nm != nullptr && bs_nm->supports_entry_barrier(nm)) {\n+        if (!bs_nm->is_armed(nm)) {\n+          log_info(init)(\"nmethod %d %d not armed\", nm->compile_id(), nm->comp_level());\n+        }\n+      }\n+#endif \/\/ ASSERT\n+      if (preload) {\n+        method->set_preload_code(nm);\n+      }\n+      if (!preload || target->holder()->is_linked()) {\n+        method->set_code(method, nm);\n+      }\n+    }\n+  } else {\n+    LogTarget(Info, nmethod, install) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      char *method_name = method->name_and_sig_as_C_string();\n+      lt.print(\"Installing osr method (L%d) %s @ %d id=%u scc=%s%u\",\n+               task()->comp_level(), method_name, entry_bci, compile_id(),\n+               task()->is_scc() ? \"A\" : \"\",\n+               (scc_entry != nullptr ? scc_entry->offset() : 0));\n+    }\n+    MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+    if (nm->make_in_use()) {\n+      method->method_holder()->add_osr_nmethod(nm);\n+    }\n+  }\n+}\n+\n+void ciEnv::register_aot_method(ciMethod* target,\n+                                AbstractCompiler* compiler,\n+                                nmethod* archived_nm,\n+                                address reloc_data,\n+                                GrowableArray<oop>& oop_list,\n+                                GrowableArray<Metadata*>& metadata_list,\n+                                ImmutableOopMapSet* oopmaps,\n+                                address immutable_data,\n+                                GrowableArray<oop>& reloc_imm_oop_list,\n+                                GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+#ifndef PRODUCT\n+                                AsmRemarks& asm_remarks,\n+                                DbgStrings& dbg_strings,\n+#endif \/* PRODUCT *\/\n+                                SCCReader* scc_reader)\n+{\n+  SCCEntry* scc_entry = task()->scc_entry();\n+  assert(scc_entry != nullptr, \"must be\");\n+  VM_ENTRY_MARK;\n+  nmethod* nm = nullptr;\n+  {\n+    methodHandle method(THREAD, target->get_Method());\n+    bool preload = task()->preload(); \/\/ Code is preloaded before Java method execution\n+\n+    \/\/ Check if memory should be freed before allocation\n+    CodeCache::gc_on_allocation();\n+\n+    \/\/ To prevent compile queue updates.\n+    MutexLocker locker(THREAD, MethodCompileQueue_lock);\n+\n+    \/\/ Prevent InstanceKlass::add_to_hierarchy from running\n+    \/\/ and invalidating our dependencies until we install this method.\n+    \/\/ No safepoints are allowed. Otherwise, class redefinition can occur in between.\n+    MutexLocker ml(Compile_lock);\n+    NoSafepointVerifier nsv;\n+\n+    if (!is_compilation_valid(THREAD, target, preload, true \/*install_code*\/, nullptr \/*code_buffer*\/, scc_entry)) {\n+      return;\n+    }\n+\n+    nm = nmethod::new_nmethod(archived_nm,\n+                              method,\n+                              compiler,\n+                              reloc_data,\n+                              oop_list,\n+                              metadata_list,\n+                              oopmaps,\n+                              immutable_data,\n+                              reloc_imm_oop_list,\n+                              reloc_imm_metadata_list,\n+                              NOT_PRODUCT_ARG(asm_remarks)\n+                              NOT_PRODUCT_ARG(dbg_strings)\n+                              scc_reader);\n+\n+    if (nm != nullptr) {\n+      make_code_usable(THREAD, target, preload, InvocationEntryBci, scc_entry, nm);\n+    }\n+  }\n+\n+  NoSafepointVerifier nsv;\n+  if (nm != nullptr) {\n+    \/\/ Compilation succeeded, post what we know about it\n+    nm->post_compiled_method(task());\n+    task()->set_num_inlined_bytecodes(num_inlined_bytecodes());\n+  } else {\n+    \/\/ The CodeCache is full.\n+    record_failure(\"code cache is full\");\n+  }\n+  \/\/ safepoints are allowed again\n+}\n+\n@@ -1008,11 +1214,0 @@\n-    \/\/ We require method counters to store some method state (max compilation levels) required by the compilation policy.\n-    if (!preload && method->get_method_counters(THREAD) == nullptr) {\n-      record_failure(\"can't create method counters\");\n-      \/\/ All buffers in the CodeBuffer are allocated in the CodeCache.\n-      \/\/ If the code buffer is created on each compile attempt\n-      \/\/ as in C2, then it must be freed.\n-      \/\/ But keep shared code.\n-      code_buffer->free_blob();\n-      return;\n-    }\n-\n@@ -1031,58 +1226,1 @@\n-    if (scc_entry != nullptr) {\n-      \/\/ Invalid compilation states:\n-      \/\/  - SCCache is closed, SCC entry is garbage.\n-      \/\/  - SCC entry indicates this shared code was marked invalid while it was loaded.\n-      if (!SCCache::is_on() || scc_entry->not_entrant()) {\n-        code_buffer->free_blob();\n-        return;\n-      }\n-    }\n-\n-    \/\/ Change in Jvmti state may invalidate compilation.\n-    if (!failing() && jvmti_state_changed()) {\n-      record_failure(\"Jvmti state change invalidated dependencies\");\n-    }\n-\n-    \/\/ Change in DTrace flags may invalidate compilation.\n-    if (!failing() &&\n-        ( (!dtrace_method_probes() && DTraceMethodProbes) ||\n-          (!dtrace_alloc_probes() && DTraceAllocProbes) )) {\n-      record_failure(\"DTrace flags change invalidated dependencies\");\n-    }\n-\n-    if (!preload && !failing() && target->needs_clinit_barrier() &&\n-        target->holder()->is_in_error_state()) {\n-      record_failure(\"method holder is in error state\");\n-    }\n-\n-    if (!failing() && (scc_entry == nullptr)) {\n-      if (log() != nullptr) {\n-        \/\/ Log the dependencies which this compilation declares.\n-        dependencies()->log_all_dependencies();\n-      }\n-\n-      \/\/ Encode the dependencies now, so we can check them right away.\n-      dependencies()->encode_content_bytes();\n-    }\n-    \/\/ Check for {class loads, evolution, breakpoints, ...} during compilation\n-    if (!failing() && install_code) {\n-      \/\/ Check for {class loads, evolution, breakpoints, ...} during compilation\n-      validate_compile_task_dependencies(target);\n-      if (failing() && preload) {\n-        ResourceMark rm;\n-        char *method_name = method->name_and_sig_as_C_string();\n-        log_info(scc)(\"preload code for '%s' failed dependency check\", method_name);\n-      }\n-    }\n-\n-    if (failing()) {\n-      \/\/ While not a true deoptimization, it is a preemptive decompile.\n-      MethodData* mdo = method()->method_data();\n-      if (mdo != nullptr && _inc_decompile_count_on_failure) {\n-        mdo->inc_decompile_count();\n-      }\n-\n-      \/\/ All buffers in the CodeBuffer are allocated in the CodeCache.\n-      \/\/ If the code buffer is created on each compile attempt\n-      \/\/ as in C2, then it must be freed.\n-      code_buffer->free_blob();\n+    if (!is_compilation_valid(THREAD, target, preload, install_code, code_buffer, scc_entry)) {\n@@ -1095,30 +1233,0 @@\n-    if (scc_entry == nullptr) {\n-      scc_entry = SCCache::store_nmethod(method,\n-                             compile_id(),\n-                             entry_bci,\n-                             offsets,\n-                             orig_pc_offset,\n-                             debug_info(), dependencies(), code_buffer,\n-                             frame_words, oop_map_set,\n-                             handler_table, inc_table,\n-                             compiler,\n-                             CompLevel(task()->comp_level()),\n-                             has_clinit_barriers,\n-                             for_preload,\n-                             has_unsafe_access,\n-                             has_wide_vectors,\n-                             has_monitors,\n-                             has_scoped_access);\n-      if (scc_entry != nullptr) {\n-        scc_entry->set_inlined_bytecodes(num_inlined_bytecodes());\n-        if (has_clinit_barriers) {\n-          set_scc_clinit_barriers_entry(scc_entry); \/\/ Record it\n-          \/\/ Build second version of code without class initialization barriers\n-          code_buffer->free_blob();\n-          return;\n-        } else if (!for_preload) {\n-          SCCEntry* previous_entry = scc_clinit_barriers_entry();\n-          scc_entry->set_next(previous_entry); \/\/ Link it for case of deoptimization\n-        }\n-      }\n-    }\n@@ -1149,36 +1257,10 @@\n-      if (entry_bci == InvocationEntryBci) {\n-        if (TieredCompilation) {\n-          \/\/ If there is an old version we're done with it\n-          nmethod* old = method->code();\n-          if (TraceMethodReplacement && old != nullptr) {\n-            ResourceMark rm;\n-            char *method_name = method->name_and_sig_as_C_string();\n-            tty->print_cr(\"Replacing method %s\", method_name);\n-          }\n-          if (old != nullptr) {\n-            old->make_not_used();\n-          }\n-        }\n-\n-        LogTarget(Info, nmethod, install) lt;\n-        if (lt.is_enabled()) {\n-          ResourceMark rm;\n-          char *method_name = method->name_and_sig_as_C_string();\n-          lt.print(\"Installing method (L%d) %s id=%d scc=%s%s%u\",\n-                    task()->comp_level(), method_name, compile_id(),\n-                    task()->is_scc() ? \"A\" : \"\", preload ? \"P\" : \"\",\n-                    (scc_entry != nullptr ? scc_entry->offset() : 0));\n-        }\n-        \/\/ Allow the code to be executed\n-        MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n-        if (nm->make_in_use()) {\n-#ifdef ASSERT\n-          BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-          if (bs_nm != nullptr && bs_nm->supports_entry_barrier(nm)) {\n-            if (!bs_nm->is_armed(nm)) {\n-              log_info(init)(\"nmethod %d %d not armed\", nm->compile_id(), nm->comp_level());\n-            }\n-          }\n-#endif \/\/ ASSERT\n-          if (preload) {\n-            method->set_preload_code(nm);\n+      if (scc_entry == nullptr) {\n+        scc_entry = SCCache::store_nmethod(nm, compiler, for_preload);\n+        if (scc_entry != nullptr) {\n+          scc_entry->set_inlined_bytecodes(num_inlined_bytecodes());\n+          if (has_clinit_barriers) {\n+            set_scc_clinit_barriers_entry(scc_entry); \/\/ Record it\n+            return;\n+          } else if (!for_preload) {\n+            SCCEntry* previous_entry = scc_clinit_barriers_entry();\n+            scc_entry->set_next(previous_entry); \/\/ Link it for case of deoptimization\n@@ -1186,17 +1268,0 @@\n-          if (!preload || target->holder()->is_linked()) {\n-            method->set_code(method, nm);\n-          }\n-        }\n-      } else {\n-        LogTarget(Info, nmethod, install) lt;\n-        if (lt.is_enabled()) {\n-          ResourceMark rm;\n-          char *method_name = method->name_and_sig_as_C_string();\n-          lt.print(\"Installing osr method (L%d) %s @ %d id=%u scc=%s%u\",\n-                   task()->comp_level(), method_name, entry_bci, compile_id(),\n-                   task()->is_scc() ? \"A\" : \"\",\n-                   (scc_entry != nullptr ? scc_entry->offset() : 0));\n-        }\n-        MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n-        if (nm->make_in_use()) {\n-          method->method_holder()->add_osr_nmethod(nm);\n@@ -1205,0 +1270,1 @@\n+      make_code_usable(THREAD, target, preload, entry_bci, scc_entry, nm);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":218,"deletions":152,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class SCCReader;\n@@ -295,0 +296,6 @@\n+\n+  \/\/ Helper rountimes to factor out common code used by routines that register a method\n+  \/\/ i.e. register_aot_method() and register_method()\n+  bool is_compilation_valid(JavaThread* thread, ciMethod* target, bool preload, bool install_code, CodeBuffer* code_buffer, SCCEntry* scc_entry);\n+  void make_code_usable(JavaThread* thread, ciMethod* target, bool preload, int entry_bci, SCCEntry* scc_entry, nmethod* nm);\n+\n@@ -367,0 +374,17 @@\n+  \/\/ Register method loaded from AOT code cache\n+  void register_aot_method(ciMethod* target,\n+                           AbstractCompiler* compiler,\n+                           nmethod* archived_nm,\n+                           address reloc_data,\n+                           GrowableArray<oop>& oop_list,\n+                           GrowableArray<Metadata*>& metadata_list,\n+                           ImmutableOopMapSet* oopmaps,\n+                           address immutable_data,\n+                           GrowableArray<oop>& reloc_imm_oop_list,\n+                           GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+#ifndef PRODUCT\n+                           AsmRemarks& asm_remarks,\n+                           DbgStrings& dbg_strings,\n+#endif \/* PRODUCT *\/\n+                           SCCReader* scc_reader);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"asm\/codeBuffer.hpp\"\n@@ -723,1 +724,13 @@\n-void copy_bytes(const char* from, address to, uint size) {\n+bool SCCache::is_address_in_aot_cache(address p) {\n+  SCCache* cache = open_for_read();\n+  if (cache == nullptr) {\n+    return false;\n+  }\n+  if ((p >= (address)cache->cache_buffer()) &&\n+      (p < (address)(cache->cache_buffer() + cache->load_size()))) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static void copy_bytes(const char* from, address to, uint size) {\n@@ -775,0 +788,19 @@\n+\/\/ Check to see if AOT code cache has required space to store \"nbytes\" of data\n+address SCCache::reserve_bytes(uint nbytes) {\n+  assert(for_write(), \"Code Cache file is not created\");\n+  uint new_position = _write_position + nbytes;\n+  if (new_position >= (uint)((char*)_store_entries - _store_buffer)) {\n+    log_warning(scc)(\"Failed to ensure %d bytes at offset %d in AOT Code Cache. Increase CachedCodeMaxSize.\",\n+                     nbytes, _write_position);\n+    set_failed();\n+    exit_vm_on_store_failure();\n+    return nullptr;\n+  }\n+  address buffer = (address)(_store_buffer + _write_position);\n+  _write_position += nbytes;\n+  if (_store_size < _write_position) {\n+    _store_size = _write_position;\n+  }\n+  return buffer;\n+}\n+\n@@ -1330,2 +1362,2 @@\n-                                          code_offset, code_size, 0, 0,\n-                                          SCCEntry::Stub, (uint32_t)id);\n+                                        code_offset, code_size, 0, 0,\n+                                        SCCEntry::Stub, (uint32_t)id);\n@@ -1813,1 +1845,2 @@\n-            jobject jo = read_oop(THREAD, comp_method);\n+            oop obj = read_oop(THREAD, comp_method);\n+            jobject jo = JNIHandles::make_local(THREAD, obj);\n@@ -2334,2 +2367,2 @@\n-                                          code_offset, code_size, reloc_offset, reloc_size,\n-                                        SCCEntry::Adapter, id, 0);\n+                                         code_offset, code_size, reloc_offset, reloc_size,\n+                                         SCCEntry::Adapter, id);\n@@ -2444,2 +2477,2 @@\n-                                          code_offset, code_size, reloc_offset, reloc_size,\n-                                          SCCEntry::Blob, (uint32_t)999);\n+                                        code_offset, code_size, reloc_offset, reloc_size,\n+                                        SCCEntry::Blob, (uint32_t)999);\n@@ -2563,1 +2596,1 @@\n-jobject SCCReader::read_oop(JavaThread* thread, const methodHandle& comp_method) {\n+oop SCCReader::read_oop(JavaThread* thread, const methodHandle& comp_method) {\n@@ -2572,1 +2605,1 @@\n-    return (jobject)Universe::non_oop_word();\n+    return cast_to_oop(Universe::non_oop_word());\n@@ -2632,1 +2665,1 @@\n-  return JNIHandles::make_local(thread, obj);\n+  return obj;\n@@ -2648,1 +2681,1 @@\n-      jobject jo = read_oop(THREAD, comp_method);\n+      oop obj = read_oop(THREAD, comp_method);\n@@ -2652,0 +2685,1 @@\n+      jobject jo = JNIHandles::make_local(THREAD, obj);\n@@ -2756,0 +2790,5 @@\n+  oop obj = JNIHandles::resolve(jo);\n+  return write_oop(obj);\n+}\n+\n+bool SCCache::write_oop(oop obj) {\n@@ -2758,2 +2797,1 @@\n-  oop obj = JNIHandles::resolve(jo);\n-  if (jo == nullptr) {\n+  if (obj == nullptr) {\n@@ -2765,1 +2803,1 @@\n-  } else if (jo == (jobject)Universe::non_oop_word()) {\n+  } else if (cast_from_oop<void *>(obj) == Universe::non_oop_word()) {\n@@ -2978,0 +3016,1 @@\n+  assert(entry_bci == InvocationEntryBci, \"unexpected entry_bci=%d\", entry_bci);\n@@ -2980,0 +3019,1 @@\n+  task->mark_aot_load_start(os::elapsed_counter());\n@@ -3007,1 +3047,1 @@\n-  bool success = reader.compile(env, target, entry_bci, compiler);\n+  bool success = reader.compile_nmethod(env, target, compiler);\n@@ -3013,0 +3053,1 @@\n+  task->mark_aot_load_finish(os::elapsed_counter());\n@@ -3033,4 +3074,35 @@\n-bool SCCReader::compile(ciEnv* env, ciMethod* target, int entry_bci, AbstractCompiler* compiler) {\n-  uint entry_position = _entry->offset();\n-  uint code_offset = entry_position + _entry->code_offset();\n-  set_read_position(code_offset);\n+bool SCCReader::read_oop_metadata_list(ciMethod* target, GrowableArray<oop> &oop_list, GrowableArray<Metadata*> &metadata_list, OopRecorder* oop_recorder) {\n+  VM_ENTRY_MARK\n+  methodHandle comp_method(JavaThread::current(), target->get_Method());\n+  JavaThread* current = JavaThread::current();\n+  uint offset = read_position();\n+  int count = *(int *)addr(offset);\n+  offset += sizeof(int);\n+  set_read_position(offset);\n+  for (int i = 0; i < count; i++) {\n+    oop obj = read_oop(current, comp_method);\n+    if (lookup_failed()) {\n+      return false;\n+    }\n+    oop_list.append(obj);\n+    if (oop_recorder != nullptr) {\n+      jobject jo = JNIHandles::make_local(THREAD, obj);\n+      if (oop_recorder->is_real(jo)) {\n+        oop_recorder->find_index(jo);\n+      } else {\n+        oop_recorder->allocate_oop_index(jo);\n+      }\n+    }\n+    LogStreamHandle(Debug, scc, oops) log;\n+    if (log.is_enabled()) {\n+      log.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(obj));\n+      if (obj == Universe::non_oop_word()) {\n+        log.print(\"non-oop word\");\n+      } else if (obj == nullptr) {\n+        log.print(\"nullptr-oop\");\n+      } else {\n+        obj->print_value_on(&log);\n+      }\n+      log.cr();\n+    }\n+  }\n@@ -3038,7 +3110,33 @@\n-  \/\/ Read flags\n-  int flags = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  bool has_monitors      = (flags & 0x1) != 0;\n-  bool has_wide_vectors  = (flags & 0x2) != 0;\n-  bool has_unsafe_access = (flags & 0x4) != 0;\n-  bool has_scoped_access = (flags & 0x8) != 0;\n+  offset = read_position();\n+  count = *(int *)addr(offset);\n+  offset += sizeof(int);\n+  set_read_position(offset);\n+  for (int i = 0; i < count; i++) {\n+    Metadata* m = read_metadata(comp_method);\n+    if (lookup_failed()) {\n+      return false;\n+    }\n+    metadata_list.append(m);\n+    if (oop_recorder != nullptr) {\n+      if (oop_recorder->is_real(m)) {\n+        oop_recorder->find_index(m);\n+      } else {\n+        oop_recorder->allocate_metadata_index(m);\n+      }\n+    }\n+    LogTarget(Debug, scc, metadata) log;\n+    if (log.is_enabled()) {\n+      LogStream ls(log);\n+      ls.print(\"%d: \" INTPTR_FORMAT \" \", i, p2i(m));\n+      if (m == (Metadata*)Universe::non_oop_word()) {\n+        ls.print(\"non-metadata word\");\n+      } else if (m == nullptr) {\n+        ls.print(\"nullptr-oop\");\n+      } else {\n+        Metadata::print_value_on_maybe_null(&ls, m);\n+      }\n+      ls.cr();\n+    }\n+  }\n+  return true;\n+}\n@@ -3046,4 +3144,14 @@\n-  int orig_pc_offset = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  int frame_size = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n+ImmutableOopMapSet* SCCReader::read_oop_map_set() {\n+  uint offset = read_position();\n+  int size = *(int *)addr(offset);\n+  offset += sizeof(int);\n+  ImmutableOopMapSet* oopmaps = (ImmutableOopMapSet *)addr(offset);\n+  offset += size;\n+  set_read_position(offset);\n+  return oopmaps;\n+}\n+\n+bool SCCReader::compile_nmethod(ciEnv* env, ciMethod* target, AbstractCompiler* compiler) {\n+  CompileTask* task = env->task();\n+  SCCEntry *scc_entry = (SCCEntry*)_entry;\n+  nmethod* nm = nullptr;\n@@ -3051,3 +3159,4 @@\n-  \/\/ Read offsets\n-  CodeOffsets* offsets = (CodeOffsets*)addr(code_offset);\n-  code_offset += sizeof(CodeOffsets);\n+  uint entry_position = scc_entry->offset();\n+  uint archived_nm_offset = entry_position + scc_entry->code_offset();\n+  nmethod* archived_nm = (nmethod*)addr(archived_nm_offset);\n+  set_read_position(archived_nm_offset + archived_nm->size());\n@@ -3055,1 +3164,0 @@\n-  \/\/ Create Debug Information Recorder to record scopes, oopmaps, etc.\n@@ -3059,1 +3167,1 @@\n-  set_read_position(code_offset);\n+  uint offset = read_position();\n@@ -3061,6 +3169,11 @@\n-  \/\/ Write OopRecorder data\n-  if (!read_oops(oop_recorder, target)) {\n-    return false;\n-  }\n-  if (!read_metadata(oop_recorder, target)) {\n-    return false;\n+#ifndef PRODUCT\n+  \/\/ Read asm remarks\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  AsmRemarks asm_remarks;\n+  for (uint i = 0; i < count; i++) {\n+    uint remark_offset = *(uint *)addr(offset);\n+    offset += sizeof(uint);\n+    const char* remark = (const char*)addr(offset);\n+    offset += (uint)strlen(remark)+1;\n+    asm_remarks.insert(remark_offset, remark);\n@@ -3068,0 +3181,1 @@\n+  set_read_position(offset);\n@@ -3069,4 +3183,8 @@\n-  \/\/ Read Debug info\n-  DebugInformationRecorder* recorder = read_debug_info(oop_recorder);\n-  if (recorder == nullptr) {\n-    return false;\n+  \/\/ Read dbg strings\n+  count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  DbgStrings dbg_strings;\n+  for (uint i = 0; i < count; i++) {\n+    const char* str = (const char*)addr(offset);\n+    offset += (uint)strlen(str)+1;\n+    dbg_strings.insert(str);\n@@ -3074,1 +3192,2 @@\n-  env->set_debug_info(recorder);\n+  set_read_position(offset);\n+#endif \/* PRODUCT *\/\n@@ -3076,6 +3195,4 @@\n-  \/\/ Read Dependencies (compressed already)\n-  Dependencies* dependencies = new Dependencies(env);\n-  if (!read_dependencies(dependencies)) {\n-    return false;\n-  }\n-  env->set_dependencies(dependencies);\n+  offset = read_position();\n+  address reloc_data = (address)addr(offset);\n+  offset += archived_nm->relocation_size();\n+  set_read_position(offset);\n@@ -3083,5 +3200,3 @@\n-  \/\/ Read oop maps\n-  OopMapSet* oop_maps = read_oop_maps();\n-  if (oop_maps == nullptr) {\n-    return false;\n-  }\n+  \/\/ Read oops and metadata\n+  GrowableArray<oop> oop_list;\n+  GrowableArray<Metadata*> metadata_list;\n@@ -3089,10 +3204,2 @@\n-  \/\/ Read exception handles\n-  code_offset = read_position();\n-  int exc_table_length = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  ExceptionHandlerTable handler_table(MAX2(exc_table_length, 4));\n-  if (exc_table_length > 0) {\n-    handler_table.set_length(exc_table_length);\n-    uint exc_table_size = handler_table.size_in_bytes();\n-    copy_bytes(addr(code_offset), (address)handler_table.table(), exc_table_size);\n-    code_offset += exc_table_size;\n+  if (!read_oop_metadata_list(target, oop_list, metadata_list, oop_recorder)) {\n+   return false;\n@@ -3101,11 +3208,1 @@\n-  \/\/ Read null check table\n-  int nul_chk_length = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-  ImplicitExceptionTable nul_chk_table;\n-  if (nul_chk_length > 0) {\n-    nul_chk_table.set_size(nul_chk_length);\n-    nul_chk_table.set_len(nul_chk_length);\n-    uint nul_chk_size = nul_chk_table.size_in_bytes();\n-    copy_bytes(addr(code_offset), (address)nul_chk_table.data(), nul_chk_size - sizeof(implicit_null_entry));\n-    code_offset += nul_chk_size;\n-  }\n+  ImmutableOopMapSet* oopmaps = read_oop_map_set();\n@@ -3113,8 +3210,4 @@\n-  uint reloc_size = _entry->reloc_size();\n-  CodeBuffer buffer(\"Compile::Fill_buffer\", _entry->code_size(), reloc_size);\n-  buffer.initialize_oop_recorder(oop_recorder);\n-\n-  const char* name = addr(entry_position + _entry->name_offset());\n-\n-  \/\/ Create fake original CodeBuffer\n-  CodeBuffer orig_buffer(name);\n+  offset = read_position();\n+  address immutable_data = (address)addr(offset);\n+  offset += archived_nm->immutable_data_size();\n+  set_read_position(offset);\n@@ -3122,3 +3215,4 @@\n-  \/\/ Read code\n-  if (!read_code(&buffer, &orig_buffer, align_up(code_offset, DATA_ALIGNMENT))) {\n-    return false;\n+  GrowableArray<oop> reloc_immediate_oop_list;\n+  GrowableArray<Metadata*> reloc_immediate_metadata_list;\n+  if (!read_oop_metadata_list(target, reloc_immediate_oop_list, reloc_immediate_metadata_list, nullptr)) {\n+   return false;\n@@ -3127,16 +3221,4 @@\n-  \/\/ Read relocations\n-  uint reloc_offset = entry_position + _entry->reloc_offset();\n-  set_read_position(reloc_offset);\n-  if (!read_relocations(&buffer, &orig_buffer, oop_recorder, target)) {\n-    return false;\n-  }\n-\n-  log_info(scc, nmethod)(\"%d (L%d): Read nmethod '%s' from AOT Code Cache\", compile_id(), comp_level(), name);\n-#ifdef ASSERT\n-  LogStreamHandle(Debug, scc, nmethod) log;\n-  if (log.is_enabled()) {\n-    FlagSetting fs(PrintRelocations, true);\n-    buffer.print_on(&log);\n-    buffer.decode();\n-  }\n-#endif\n+  \/\/ Read Dependencies (compressed already)\n+  Dependencies* dependencies = new Dependencies(env);\n+  dependencies->set_content(immutable_data, archived_nm->dependencies_size());\n+  env->set_dependencies(dependencies);\n@@ -3148,1 +3230,0 @@\n-  \/\/ Register nmethod\n@@ -3150,14 +3231,13 @@\n-  env->register_method(target, entry_bci,\n-                       offsets, orig_pc_offset,\n-                       &buffer, frame_size,\n-                       oop_maps, &handler_table,\n-                       &nul_chk_table, compiler,\n-                       _entry->has_clinit_barriers(),\n-                       false,\n-                       has_unsafe_access,\n-                       has_wide_vectors,\n-                       has_monitors,\n-                       has_scoped_access,\n-                       0, true \/* install_code *\/,\n-                       (SCCEntry *)_entry);\n-  CompileTask* task = env->task();\n+  env->register_aot_method(target,\n+                           compiler,\n+                           archived_nm,\n+                           reloc_data,\n+                           oop_list,\n+                           metadata_list,\n+                           oopmaps,\n+                           immutable_data,\n+                           reloc_immediate_oop_list,\n+                           reloc_immediate_metadata_list,\n+                           NOT_PRODUCT_ARG(asm_remarks)\n+                           NOT_PRODUCT_ARG(dbg_strings)\n+                           this);\n@@ -3166,1 +3246,1 @@\n-    ((SCCEntry *)_entry)->set_loaded();\n+    scc_entry->set_loaded();\n@@ -3171,22 +3251,112 @@\n-\/\/ No concurency for writing to cache file because this method is called from\n-\/\/ ciEnv::register_method() under MethodCompileQueue_lock and Compile_lock locks.\n-SCCEntry* SCCache::store_nmethod(const methodHandle& method,\n-                     int comp_id,\n-                     int entry_bci,\n-                     CodeOffsets* offsets,\n-                     int orig_pc_offset,\n-                     DebugInformationRecorder* recorder,\n-                     Dependencies* dependencies,\n-                     CodeBuffer* buffer,\n-                     int frame_size,\n-                     OopMapSet* oop_maps,\n-                     ExceptionHandlerTable* handler_table,\n-                     ImplicitExceptionTable* nul_chk_table,\n-                     AbstractCompiler* compiler,\n-                     CompLevel comp_level,\n-                     bool has_clinit_barriers,\n-                     bool for_preload,\n-                     bool has_unsafe_access,\n-                     bool has_wide_vectors,\n-                     bool has_monitors,\n-                     bool has_scoped_access) {\n+void SCCReader::apply_relocations(nmethod* nm, GrowableArray<oop> &oop_list, GrowableArray<Metadata*> &metadata_list) {\n+  LogStreamHandle(Info, scc, reloc) log;\n+  uint buffer_offset = read_position();\n+  int count = *(int*)addr(buffer_offset);\n+  buffer_offset += sizeof(int);\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== extra relocations count=%d\", count);\n+  }\n+  uint* reloc_data = (uint*)addr(buffer_offset);\n+  buffer_offset += (count * sizeof(uint));\n+  set_read_position(buffer_offset);\n+\n+  RelocIterator iter(nm);\n+  int j = 0;\n+\n+  while (iter.next()) {\n+    switch (iter.type()) {\n+      case relocInfo::none:\n+        break;\n+      case relocInfo::oop_type: {\n+        oop_Relocation* r = (oop_Relocation*)iter.reloc();\n+        if (r->oop_is_immediate()) {\n+          r->set_value(cast_from_oop<address>(oop_list.at(reloc_data[j])));\n+        } else {\n+          r->fix_oop_relocation();\n+        }\n+        break;\n+      }\n+      case relocInfo::metadata_type: {\n+        metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n+        Metadata* m;\n+        if (r->metadata_is_immediate()) {\n+          m = metadata_list.at(reloc_data[j]);\n+        } else {\n+          \/\/ Get already updated value from nmethod.\n+          int index = r->metadata_index();\n+          m = nm->metadata_at(index);\n+        }\n+        r->set_value((address)m);\n+        break;\n+      }\n+      case relocInfo::virtual_call_type:   \/\/ Fall through. They all call resolve_*_call blobs.\n+      case relocInfo::opt_virtual_call_type:\n+      case relocInfo::static_call_type: {\n+        address dest = _cache->address_for_id(reloc_data[j]);\n+        if (dest != (address)-1) {\n+          ((CallRelocation*)iter.reloc())->set_destination(dest);\n+        }\n+        break;\n+      }\n+      case relocInfo::trampoline_stub_type: {\n+        address dest = _cache->address_for_id(reloc_data[j]);\n+        if (dest != (address)-1) {\n+          ((trampoline_stub_Relocation*)iter.reloc())->set_destination(dest);\n+        }\n+        break;\n+      }\n+      case relocInfo::static_stub_type:\n+        break;\n+      case relocInfo::runtime_call_type: {\n+        address dest = _cache->address_for_id(reloc_data[j]);\n+        if (dest != (address)-1) {\n+          ((CallRelocation*)iter.reloc())->set_destination(dest);\n+        }\n+        break;\n+      }\n+      case relocInfo::runtime_call_w_cp_type:\n+        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        \/\/address destination = iter.reloc()->value();\n+        break;\n+      case relocInfo::external_word_type: {\n+        address target = _cache->address_for_id(reloc_data[j]);\n+        \/\/ Add external address to global table\n+        int index = ExternalsRecorder::find_index(target);\n+        \/\/ Update index in relocation\n+        Relocation::add_jint(iter.data(), index);\n+        external_word_Relocation* reloc = (external_word_Relocation*)iter.reloc();\n+        assert(reloc->target() == target, \"sanity\");\n+        reloc->set_value(target); \/\/ Patch address in the code\n+        break;\n+      }\n+      case relocInfo::internal_word_type: {\n+        internal_word_Relocation* r = (internal_word_Relocation*)iter.reloc();\n+        r->fix_relocation_after_aot_load(scc_entry()->dumptime_content_start_addr(), nm->content_begin());\n+        break;\n+      }\n+      case relocInfo::section_word_type: {\n+        section_word_Relocation* r = (section_word_Relocation*)iter.reloc();\n+        r->fix_relocation_after_aot_load(scc_entry()->dumptime_content_start_addr(), nm->content_begin());\n+        break;\n+      }\n+      case relocInfo::poll_type:\n+        break;\n+      case relocInfo::poll_return_type:\n+        break;\n+      case relocInfo::post_call_nop_type:\n+        break;\n+      case relocInfo::entry_guard_type:\n+        break;\n+      default:\n+        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        break;\n+    }\n+    if (log.is_enabled()) {\n+      iter.print_current_on(&log);\n+    }\n+    j++;\n+  }\n+  assert(j == count, \"must be\");\n+}\n+\n+SCCEntry* SCCache::store_nmethod(nmethod* nm, AbstractCompiler* compiler, bool for_preload) {\n@@ -3196,1 +3366,1 @@\n-  if (entry_bci != InvocationEntryBci) {\n+  if (nm->is_osr_method()) {\n@@ -3199,4 +3369,8 @@\n-  if (compiler->is_c1() && (comp_level == CompLevel_simple || comp_level == CompLevel_limited_profile)) {\n-    \/\/ Cache tier1 compilations\n-  } else if (!compiler->is_c2()) {\n-    return nullptr; \/\/ Only C2 now\n+  if (!compiler->is_c1() && !compiler->is_c2()) {\n+    \/\/ Only c1 and c2 compilers\n+    return nullptr;\n+  }\n+  int comp_level = nm->comp_level();\n+  if (comp_level == CompLevel_full_profile) {\n+    \/\/ Do not cache C1 compiles with full profile i.e. tier3\n+    return nullptr;\n@@ -3204,0 +3378,2 @@\n+  assert(comp_level == CompLevel_simple || comp_level == CompLevel_limited_profile || comp_level == CompLevel_full_optimization, \"must be\");\n+\n@@ -3209,3 +3385,2 @@\n-  SCCEntry* entry = cache->write_nmethod(method, comp_id, entry_bci, offsets, orig_pc_offset, recorder, dependencies, buffer,\n-                                  frame_size, oop_maps, handler_table, nul_chk_table, compiler, comp_level,\n-                                  has_clinit_barriers, for_preload, has_unsafe_access, has_wide_vectors, has_monitors, has_scoped_access);\n+  SCCEntry* entry = nullptr;\n+  entry = cache->write_nmethod(nm, for_preload);\n@@ -3213,2 +3388,1 @@\n-    ResourceMark rm;\n-    log_warning(scc, nmethod)(\"%d (L%d): Cannot store nmethod '%s'\", comp_id, (int)comp_level, method->name_and_sig_as_C_string());\n+    log_info(scc, nmethod)(\"%d (L%d): nmethod store attempt failed\", nm->compile_id(), comp_level);\n@@ -3219,29 +3393,4 @@\n-SCCEntry* SCCache::write_nmethod(const methodHandle& method,\n-                                 int comp_id,\n-                                 int entry_bci,\n-                                 CodeOffsets* offsets,\n-                                 int orig_pc_offset,\n-                                 DebugInformationRecorder* recorder,\n-                                 Dependencies* dependencies,\n-                                 CodeBuffer* buffer,\n-                                 int frame_size,\n-                                 OopMapSet* oop_maps,\n-                                 ExceptionHandlerTable* handler_table,\n-                                 ImplicitExceptionTable* nul_chk_table,\n-                                 AbstractCompiler* compiler,\n-                                 CompLevel comp_level,\n-                                 bool has_clinit_barriers,\n-                                 bool for_preload,\n-                                 bool has_unsafe_access,\n-                                 bool has_wide_vectors,\n-                                 bool has_monitors,\n-                                 bool has_scoped_access) {\n-\/\/  if (method->is_hidden()) {\n-\/\/    ResourceMark rm;\n-\/\/    log_info(scc, nmethod)(\"%d (L%d): Skip hidden method '%s'\", comp_id, (int)comp_level, method->name_and_sig_as_C_string());\n-\/\/    return nullptr;\n-\/\/  }\n-  if (buffer->before_expand() != nullptr) {\n-    ResourceMark rm;\n-    log_warning(scc, nmethod)(\"%d (L%d): Skip nmethod with expanded buffer '%s'\", comp_id, (int)comp_level, method->name_and_sig_as_C_string());\n-    return nullptr;\n+bool SCCache::write_oops(nmethod* nm) {\n+  int count = nm->oops_count()-1;\n+  if (!write_bytes(&count, sizeof(int))) {\n+    return false;\n@@ -3249,7 +3398,4 @@\n-#ifdef ASSERT\n-  LogStreamHandle(Debug, scc, nmethod) log;\n-  if (log.is_enabled()) {\n-    tty->print_cr(\" == store_nmethod\");\n-    FlagSetting fs(PrintRelocations, true);\n-    buffer->print_on(&log);\n-    buffer->decode();\n+  for (oop* p = nm->oops_begin(); p < nm->oops_end(); p++) {\n+    if (!write_oop(*p)) {\n+      return false;\n+    }\n@@ -3257,5 +3403,36 @@\n-#endif\n-  assert(!has_clinit_barriers || _gen_preload_code, \"sanity\");\n-  Method* m = method();\n-  bool method_in_cds = MetaspaceShared::is_in_shared_metaspace((address)m); \/\/ herere\n-  InstanceKlass* holder = m->method_holder();\n+  return true;\n+}\n+\n+bool SCCache::write_metadata(nmethod* nm) {\n+  int count = nm->metadata_count()-1;\n+  if (!write_bytes(&count, sizeof(int))) {\n+    return false;\n+  }\n+  for (Metadata** p = nm->metadata_begin(); p < nm->metadata_end(); p++) {\n+    if (!write_metadata(*p)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool SCCache::write_oop_map_set(nmethod* nm) {\n+  ImmutableOopMapSet* oopmaps = nm->oop_maps();\n+  int oopmaps_size = oopmaps->nr_of_bytes();\n+  if (!write_bytes(&oopmaps_size, sizeof(int))) {\n+    return false;\n+  }\n+  uint n = write_bytes(oopmaps, oopmaps->nr_of_bytes());\n+  if (n != (uint)oopmaps->nr_of_bytes()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+SCCEntry* SCCache::write_nmethod(nmethod* nm, bool for_preload) {\n+  assert(!nm->has_clinit_barriers() || _gen_preload_code, \"sanity\");\n+  uint comp_id = nm->compile_id();\n+  uint comp_level = nm->comp_level();\n+  Method* method = nm->method();\n+  bool method_in_cds = MetaspaceShared::is_in_shared_metaspace((address)method);\n+  InstanceKlass* holder = method->method_holder();\n@@ -3276,1 +3453,1 @@\n-  _has_clinit_barriers = has_clinit_barriers;\n+  _has_clinit_barriers = nm->has_clinit_barriers();\n@@ -3281,2 +3458,0 @@\n-  _compile_id = comp_id;\n-  _comp_level = (int)comp_level;\n@@ -3303,1 +3478,1 @@\n-    const char* name   = method->name_and_sig_as_C_string();\n+    const char* name = method->name_and_sig_as_C_string();\n@@ -3307,1 +3482,1 @@\n-                           (has_clinit_barriers ? \", has clinit barriers\" : \"\"));\n+                           (nm->has_clinit_barriers() ? \", has clinit barriers\" : \"\"));\n@@ -3338,1 +3513,3 @@\n-  if (!align_write()) {\n+  uint archived_nm_offset = _write_position - entry_position;\n+  nmethod* archived_nm = (nmethod*)reserve_bytes(nm->size());\n+  if (archived_nm == nullptr) {\n@@ -3341,0 +3518,1 @@\n+  nm->copy_to((address)archived_nm);\n@@ -3342,1 +3520,1 @@\n-  uint code_offset = _write_position - entry_position;\n+  archived_nm->prepare_for_archiving();\n@@ -3344,6 +3522,4 @@\n-  int flags = (has_scoped_access ? 0x8 : 0) |\n-              (has_unsafe_access ? 0x4 : 0) |\n-              (has_wide_vectors  ? 0x2 : 0) |\n-              (has_monitors      ? 0x1 : 0);\n-  n = write_bytes(&flags, sizeof(int));\n-  if (n != sizeof(int)) {\n+#ifndef PRODUCT\n+  \/\/ Write asm remarks\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n@@ -3352,3 +3528,15 @@\n-\n-  n = write_bytes(&orig_pc_offset, sizeof(int));\n-  if (n != sizeof(int)) {\n+  uint count = 0;\n+  bool result = nm->asm_remarks().iterate([&] (uint offset, const char* str) -> bool {\n+    log_info(scc, nmethod)(\"asm remark offset=%d, str=%s\", offset, str);\n+    n = write_bytes(&offset, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+    }\n+    n = write_bytes(str, (uint)strlen(str) + 1);\n+    if (n != strlen(str) + 1) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  if (!result) {\n@@ -3357,0 +3545,1 @@\n+  *count_ptr = count;\n@@ -3358,2 +3547,16 @@\n-  n = write_bytes(&frame_size, sizeof(int));\n-  if (n != sizeof(int)) {\n+  \/\/ Write dbg strings\n+  count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return nullptr;\n+  }\n+  count = 0;\n+  result = nm->dbg_strings().iterate([&] (const char* str) -> bool {\n+    log_info(scc, nmethod)(\"dbg string=%s\", str);\n+    n = write_bytes(str, (uint)strlen(str) + 1);\n+    if (n != strlen(str) + 1) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  if (!result) {\n@@ -3362,0 +3565,5 @@\n+  *count_ptr = count;\n+  if (!result) {\n+    return nullptr;\n+  }\n+#endif \/* PRODUCT *\/\n@@ -3363,3 +3571,3 @@\n-  \/\/ Write offsets\n-  n = write_bytes(offsets, sizeof(CodeOffsets));\n-  if (n != sizeof(CodeOffsets)) {\n+  uint reloc_data_size = nm->relocation_size();\n+  n = write_bytes((address)nm->relocation_begin(), reloc_data_size);\n+  if (n != reloc_data_size) {\n@@ -3369,2 +3577,2 @@\n-  \/\/ Write OopRecorder data\n-  if (!write_oops(buffer->oop_recorder())) {\n+  \/\/ Write oops and metadata present in the nmethod's data region\n+  if (!write_oops(nm)) {\n@@ -3377,1 +3585,1 @@\n-  if (!write_metadata(buffer->oop_recorder())) {\n+  if (!write_metadata(nm)) {\n@@ -3385,15 +3593,1 @@\n-  \/\/ Write Debug info\n-  if (!write_debug_info(recorder)) {\n-    return nullptr;\n-  }\n-  \/\/ Write Dependencies\n-  int dependencies_size = (int)dependencies->size_in_bytes();\n-  n = write_bytes(&dependencies_size, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return nullptr;\n-  }\n-  if (!align_write()) {\n-    return nullptr;\n-  }\n-  n = write_bytes(dependencies->content_bytes(), dependencies_size);\n-  if (n != (uint)dependencies_size) {\n+  if (!write_oop_map_set(nm)) {\n@@ -3403,2 +3597,3 @@\n-  \/\/ Write oop maps\n-  if (!write_oop_maps(oop_maps)) {\n+  uint immutable_data_size = nm->immutable_data_size();\n+  n = write_bytes(nm->immutable_data_begin(), immutable_data_size);\n+  if (n != immutable_data_size) {\n@@ -3408,11 +3603,2 @@\n-  \/\/ Write exception handles\n-  int exc_table_length = handler_table->length();\n-  n = write_bytes(&exc_table_length, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return nullptr;\n-  }\n-  uint exc_table_size = handler_table->size_in_bytes();\n-  n = write_bytes(handler_table->table(), exc_table_size);\n-  if (n != exc_table_size) {\n-    return nullptr;\n-  }\n+  GrowableArray<oop> oop_list;\n+  GrowableArray<Metadata*> metadata_list;\n@@ -3420,24 +3606,2 @@\n-  \/\/ Write null check table\n-  int nul_chk_length = nul_chk_table->len();\n-  n = write_bytes(&nul_chk_length, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return nullptr;\n-  }\n-  uint nul_chk_size = nul_chk_table->size_in_bytes();\n-  n = write_bytes(nul_chk_table->data(), nul_chk_size);\n-  if (n != nul_chk_size) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Write code section\n-  if (!align_write()) {\n-    return nullptr;\n-  }\n-  uint code_size = 0;\n-  if (!write_code(buffer, code_size)) {\n-    return nullptr;\n-  }\n-  \/\/ Write relocInfo array\n-  uint reloc_offset = _write_position - entry_position;\n-  uint reloc_size = 0;\n-  if (!write_relocations(buffer, reloc_size)) {\n+  nm->create_reloc_immediates_list(oop_list, metadata_list);\n+  if (!write_nmethod_reloc_immediates(oop_list, metadata_list)) {\n@@ -3450,1 +3614,0 @@\n-  uint entry_size = _write_position - entry_position;\n@@ -3452,0 +3615,5 @@\n+  if (!write_nmethod_extra_relocations(nm, oop_list, metadata_list)) {\n+    return nullptr;\n+  }\n+\n+  uint entry_size = _write_position - entry_position;\n@@ -3453,3 +3621,3 @@\n-                                        code_offset, code_size, reloc_offset, reloc_size,\n-                                        SCCEntry::Code, hash, (uint)comp_level, (uint)comp_id, decomp,\n-                                        has_clinit_barriers, _for_preload, ignore_decompile);\n+                                        archived_nm_offset, 0, 0, 0,\n+                                        SCCEntry::Code, hash, nm->content_begin(), comp_level, comp_id, decomp,\n+                                        nm->has_clinit_barriers(), for_preload, ignore_decompile);\n@@ -3457,1 +3625,1 @@\n-    entry->set_method(m);\n+    entry->set_method(method);\n@@ -3460,1 +3628,1 @@\n-  if (has_clinit_barriers || _for_preload) {\n+  if (nm->has_clinit_barriers() || for_preload) {\n@@ -3467,0 +3635,1 @@\n+    const char* name = nm->method()->name_and_sig_as_C_string();\n@@ -3468,1 +3637,1 @@\n-                           comp_id, (int)comp_level, method->name_and_sig_as_C_string(), (_for_preload ? \" (for preload)\" : \"\"));\n+                           comp_id, (int)comp_level, name, (for_preload ? \" (for preload)\" : \"\"));\n@@ -3476,0 +3645,139 @@\n+bool SCCache::write_nmethod_extra_relocations(nmethod* nm, GrowableArray<oop>& oop_list, GrowableArray<Metadata*>& metadata_list) {\n+  LogStreamHandle(Info, scc, reloc) log;\n+  GrowableArray<uint> reloc_data;\n+  \/\/ Collect additional data\n+  RelocIterator iter(nm);\n+  bool has_immediate = false;\n+  while (iter.next()) {\n+    int idx = reloc_data.append(0); \/\/ default value\n+    switch (iter.type()) {\n+      case relocInfo::none:\n+      break;\n+      case relocInfo::oop_type: {\n+        oop_Relocation* r = (oop_Relocation*)iter.reloc();\n+        if (r->oop_is_immediate()) {\n+          \/\/ store index of oop in the reloc immediate oop list\n+          int oop_idx = oop_list.find(r->oop_value());\n+          assert(oop_idx != -1, \"sanity check\");\n+          reloc_data.at_put(idx, (uint)oop_idx);\n+          has_immediate = true;\n+        }\n+        break;\n+      }\n+      case relocInfo::metadata_type: {\n+        metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n+        if (r->metadata_is_immediate()) {\n+          \/\/ store index of metadata in the reloc immediate metadata list\n+          int metadata_idx = metadata_list.find(r->metadata_value());\n+          assert(metadata_idx != -1, \"sanity check\");\n+          reloc_data.at_put(idx, (uint)metadata_idx);\n+          has_immediate = true;\n+        }\n+        break;\n+      }\n+      case relocInfo::virtual_call_type:  \/\/ Fall through. They all call resolve_*_call blobs.\n+      case relocInfo::opt_virtual_call_type:\n+      case relocInfo::static_call_type: {\n+        CallRelocation* r = (CallRelocation*)iter.reloc();\n+        address dest = r->destination();\n+        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n+          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n+        }\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr));\n+        break;\n+      }\n+      case relocInfo::trampoline_stub_type: {\n+        address dest = ((trampoline_stub_Relocation*)iter.reloc())->destination();\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr));\n+        break;\n+      }\n+      case relocInfo::static_stub_type:\n+        break;\n+      case relocInfo::runtime_call_type: {\n+        \/\/ Record offset of runtime destination\n+        CallRelocation* r = (CallRelocation*)iter.reloc();\n+        address dest = r->destination();\n+        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n+          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n+        }\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, nullptr));\n+        break;\n+      }\n+      case relocInfo::runtime_call_w_cp_type:\n+        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        break;\n+      case relocInfo::external_word_type: {\n+        \/\/ Record offset of runtime target\n+        address target = ((external_word_Relocation*)iter.reloc())->target();\n+        reloc_data.at_put(idx, _table->id_for_address(target, iter, nullptr));\n+        break;\n+      }\n+      case relocInfo::internal_word_type:\n+        break;\n+      case relocInfo::section_word_type:\n+        break;\n+      case relocInfo::poll_type:\n+        break;\n+      case relocInfo::poll_return_type:\n+        break;\n+      case relocInfo::post_call_nop_type:\n+        break;\n+      case relocInfo::entry_guard_type:\n+        break;\n+      default:\n+        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        break;\n+    }\n+    if (log.is_enabled()) {\n+      iter.print_current_on(&log);\n+    }\n+  }\n+\n+  \/\/ Write additional relocation data: uint per relocation\n+  \/\/ Write the count first\n+  int count = reloc_data.length();\n+  write_bytes(&count, sizeof(int));\n+  uint data_size = count * sizeof(uint);\n+  for (GrowableArrayIterator<uint> iter = reloc_data.begin();\n+       iter != reloc_data.end(); ++iter) {\n+    uint value = *iter;\n+    int n = write_bytes(&value, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+      break;\n+    }\n+  }\n+\n+  if (!align_write()) {\n+    return false;\n+  }\n+  return true; \/\/success;\n+}\n+\n+bool SCCache::write_nmethod_reloc_immediates(GrowableArray<oop>& oop_list, GrowableArray<Metadata*>& metadata_list) {\n+  int count = oop_list.length();\n+  if (!write_bytes(&count, sizeof(int))) {\n+    return false;\n+  }\n+  for (GrowableArrayIterator<oop> iter = oop_list.begin();\n+       iter != oop_list.end(); ++iter) {\n+    oop obj = *iter;\n+    if (!write_oop(obj)) {\n+      return false;\n+    }\n+  }\n+\n+  count = metadata_list.length();\n+  if (!write_bytes(&count, sizeof(int))) {\n+    return false;\n+  }\n+  for (GrowableArrayIterator<Metadata*> iter = metadata_list.begin();\n+       iter != metadata_list.end(); ++iter) {\n+    Metadata* m = *iter;\n+    if (!write_metadata(m)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -3567,1 +3875,1 @@\n-      if (!entry->is_loaded()) {\n+      if (entry->is_code() && !entry->is_loaded()) {\n","filename":"src\/hotspot\/share\/code\/SCCache.cpp","additions":587,"deletions":279,"binary":false,"changes":866,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n@@ -50,0 +54,3 @@\n+template<typename E>\n+class GrowableArray;\n+class ImmutableOopMapSet;\n@@ -52,0 +59,1 @@\n+class Klass;\n@@ -53,0 +61,1 @@\n+class Metadata;\n@@ -54,0 +63,1 @@\n+class nmethod;\n@@ -183,1 +193,1 @@\n-\n+  address _dumptime_content_start_addr;\n@@ -188,1 +198,3 @@\n-           Kind kind, uint id, uint comp_level = 0,\n+           Kind kind, uint id,\n+           address dumptime_content_start_addr = nullptr,\n+           uint comp_level = 0,\n@@ -206,0 +218,3 @@\n+\n+    _dumptime_content_start_addr = dumptime_content_start_addr;\n+\n@@ -247,0 +262,3 @@\n+\n+  address dumptime_content_start_addr() const { return _dumptime_content_start_addr; }\n+\n@@ -368,1 +386,4 @@\n-  bool compile(ciEnv* env, ciMethod* target, int entry_bci, AbstractCompiler* compiler);\n+  SCCEntry* scc_entry() { return (SCCEntry*)_entry; }\n+\n+  \/\/ convenience method to convert offset in SCCEntry data to its address\n+  bool compile_nmethod(ciEnv* env, ciMethod* target, AbstractCompiler* compiler);\n@@ -382,1 +403,1 @@\n-  jobject read_oop(JavaThread* thread, const methodHandle& comp_method);\n+  oop read_oop(JavaThread* thread, const methodHandle& comp_method);\n@@ -387,0 +408,5 @@\n+  bool read_oop_metadata_list(ciMethod* target, GrowableArray<oop> &oop_list, GrowableArray<Metadata*> &metadata_list, OopRecorder* oop_recorder);\n+  void apply_relocations(nmethod* nm, GrowableArray<oop> &oop_list, GrowableArray<Metadata*> &metadata_list) NOT_CDS_RETURN;\n+\n+  ImmutableOopMapSet* read_oop_map_set();\n+\n@@ -439,20 +465,3 @@\n-  SCCEntry* write_nmethod(const methodHandle& method,\n-                          int compile_id,\n-                          int entry_bci,\n-                          CodeOffsets* offsets,\n-                          int orig_pc_offset,\n-                          DebugInformationRecorder* recorder,\n-                          Dependencies* dependencies,\n-                          CodeBuffer *code_buffer,\n-                          int frame_size,\n-                          OopMapSet* oop_maps,\n-                          ExceptionHandlerTable* handler_table,\n-                          ImplicitExceptionTable* nul_chk_table,\n-                          AbstractCompiler* compiler,\n-                          CompLevel comp_level,\n-                          bool has_clinit_barriers,\n-                          bool for_preload,\n-                          bool has_unsafe_access,\n-                          bool has_wide_vectors,\n-                          bool has_monitors,\n-                          bool has_scoped_access);\n+  address reserve_bytes(uint nbytes);\n+\n+  SCCEntry* write_nmethod(nmethod* nm, bool for_preload);\n@@ -487,0 +496,1 @@\n+  static bool is_address_in_aot_cache(address p) NOT_CDS_RETURN_(false);\n@@ -537,0 +547,4 @@\n+  bool write_oop_map_set(nmethod* nm);\n+  bool write_nmethod_reloc_immediates(GrowableArray<oop>& oop_list, GrowableArray<Metadata*>& metadata_list);\n+  bool write_nmethod_extra_relocations(nmethod* nm, GrowableArray<oop>& oop_list, GrowableArray<Metadata*>& metadata_list);\n+\n@@ -543,0 +557,1 @@\n+  bool write_oop(oop obj);\n@@ -546,0 +561,2 @@\n+  bool write_oops(nmethod* nm);\n+  bool write_metadata(nmethod* nm);\n@@ -554,21 +571,1 @@\n-\n-  static SCCEntry* store_nmethod(const methodHandle& method,\n-                     int compile_id,\n-                     int entry_bci,\n-                     CodeOffsets* offsets,\n-                     int orig_pc_offset,\n-                     DebugInformationRecorder* recorder,\n-                     Dependencies* dependencies,\n-                     CodeBuffer *code_buffer,\n-                     int frame_size,\n-                     OopMapSet* oop_maps,\n-                     ExceptionHandlerTable* handler_table,\n-                     ImplicitExceptionTable* nul_chk_table,\n-                     AbstractCompiler* compiler,\n-                     CompLevel comp_level,\n-                     bool has_clinit_barriers,\n-                     bool for_preload,\n-                     bool has_unsafe_access,\n-                     bool has_wide_vectors,\n-                     bool has_monitors,\n-                     bool has_scoped_access) NOT_CDS_RETURN_(nullptr);\n+  static SCCEntry* store_nmethod(nmethod* nm, AbstractCompiler* compiler, bool for_preload) NOT_CDS_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/code\/SCCache.hpp","additions":42,"deletions":45,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"code\/SCCache.hpp\"\n@@ -185,1 +186,1 @@\n-  if (_oop_maps != nullptr) {\n+  if (_oop_maps != nullptr && !SCCache::is_address_in_aot_cache((address)_oop_maps)) {\n@@ -213,0 +214,10 @@\n+void CodeBlob::prepare_for_archiving() {\n+  set_name(nullptr);\n+  _oop_maps = nullptr;\n+  _mutable_data = nullptr;\n+#ifndef PRODUCT\n+  asm_remarks().clear();\n+  dbg_strings().clear();\n+#endif \/* PRODUCT *\/\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/SCCache.hpp\"\n@@ -159,1 +160,1 @@\n-    assert(_oop_maps == nullptr, \"Not flushed\");\n+    assert(_oop_maps == nullptr || SCCache::is_address_in_aot_cache((address)_oop_maps), \"Not flushed\");\n@@ -247,0 +248,1 @@\n+  void set_oop_maps(ImmutableOopMapSet* p)       { _oop_maps = p; }\n@@ -281,0 +283,2 @@\n+\n+  void prepare_for_archiving();\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1135,0 +1135,25 @@\n+void nmethod::record_nmethod_dependency() {\n+  \/\/ To make dependency checking during class loading fast, record\n+  \/\/ the nmethod dependencies in the classes it is dependent on.\n+  \/\/ This allows the dependency checking code to simply walk the\n+  \/\/ class hierarchy above the loaded class, checking only nmethods\n+  \/\/ which are dependent on those classes.  The slow way is to\n+  \/\/ check every nmethod for dependencies which makes it linear in\n+  \/\/ the number of methods compiled.  For applications with a lot\n+  \/\/ classes the slow way is too slow.\n+  for (Dependencies::DepStream deps(this); deps.next(); ) {\n+    if (deps.type() == Dependencies::call_site_target_value) {\n+      \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n+      oop call_site = deps.argument_oop(0);\n+      MethodHandles::add_dependent_nmethod(call_site, this);\n+    } else {\n+      InstanceKlass* ik = deps.context_type();\n+      if (ik == nullptr) {\n+        continue;  \/\/ ignore things like evol_method\n+      }\n+      \/\/ record this nmethod as dependent on this klass\n+      ik->add_dependent_nmethod(this);\n+    }\n+  }\n+}\n+\n@@ -1201,23 +1226,2 @@\n-      \/\/ To make dependency checking during class loading fast, record\n-      \/\/ the nmethod dependencies in the classes it is dependent on.\n-      \/\/ This allows the dependency checking code to simply walk the\n-      \/\/ class hierarchy above the loaded class, checking only nmethods\n-      \/\/ which are dependent on those classes.  The slow way is to\n-      \/\/ check every nmethod for dependencies which makes it linear in\n-      \/\/ the number of methods compiled.  For applications with a lot\n-      \/\/ classes the slow way is too slow.\n-      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n-        if (deps.type() == Dependencies::call_site_target_value) {\n-          \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n-          oop call_site = deps.argument_oop(0);\n-          MethodHandles::add_dependent_nmethod(call_site, nm);\n-        } else {\n-          InstanceKlass* ik = deps.context_type();\n-          if (ik == nullptr) {\n-            continue;  \/\/ ignore things like evol_method\n-          }\n-          \/\/ record this nmethod as dependent on this klass\n-          ik->add_dependent_nmethod(nm);\n-        }\n-      }\n-      NOT_PRODUCT(if (nm != nullptr)  note_java_nmethod(nm));\n+      nm->record_nmethod_dependency();\n+      NOT_PRODUCT(note_java_nmethod(nm));\n@@ -1247,0 +1251,109 @@\n+void nmethod::restore_from_archive(nmethod* archived_nm,\n+                                   const methodHandle& method,\n+                                   address reloc_data,\n+                                   GrowableArray<oop>& oop_list,\n+                                   GrowableArray<Metadata*>& metadata_list,\n+                                   ImmutableOopMapSet* oop_maps,\n+                                   address immutable_data,\n+                                   GrowableArray<oop>& reloc_imm_oop_list,\n+                                   GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+#ifndef PRODUCT\n+                                   AsmRemarks& archived_asm_remarks,\n+                                   DbgStrings& archived_dbg_strings,\n+#endif \/* PRODUCT *\/\n+                                   SCCReader* scc_reader)\n+{\n+  archived_nm->copy_to((address)this);\n+  set_name(\"nmethod\");\n+  set_method(method());\n+\n+  \/\/ allocate _mutable_data before copying relocation data because relocation data is now stored as part of mutable data area\n+  if (archived_nm->mutable_data_size() > 0) {\n+    _mutable_data = (address)os::malloc(archived_nm->mutable_data_size(), mtCode);\n+    if (_mutable_data == nullptr) {\n+      vm_exit_out_of_memory(archived_nm->mutable_data_size(), OOM_MALLOC_ERROR, \"codebuffer: no space for mutable data\");\n+    }\n+  }\n+  memcpy((address)relocation_begin(), reloc_data, archived_nm->relocation_size());\n+  set_oop_maps(oop_maps);\n+  set_immutable_data(immutable_data);\n+  copy_values(&oop_list);\n+  copy_values(&metadata_list);\n+\n+  scc_reader->apply_relocations(this, reloc_imm_oop_list, reloc_imm_metadata_list);\n+\n+#ifndef PRODUCT\n+  AsmRemarks::init(asm_remarks());\n+  use_remarks(archived_asm_remarks);\n+  archived_asm_remarks.clear();\n+  DbgStrings::init(dbg_strings());\n+  use_strings(archived_dbg_strings);\n+  archived_dbg_strings.clear();\n+#endif \/* PRODUCT *\/\n+\n+  \/\/ Create cache after PcDesc data is copied - it will be used to initialize cache\n+  _pc_desc_container = new PcDescContainer(scopes_pcs_begin());\n+\n+  set_scc_entry(scc_reader->scc_entry());\n+\n+  post_init();\n+}\n+\n+nmethod* nmethod::new_nmethod(nmethod* archived_nm,\n+                              const methodHandle& method,\n+                              AbstractCompiler* compiler,\n+                              address reloc_data,\n+                              GrowableArray<oop>& oop_list,\n+                              GrowableArray<Metadata*>& metadata_list,\n+                              ImmutableOopMapSet* oop_maps,\n+                              address immutable_data,\n+                              GrowableArray<oop>& reloc_imm_oop_list,\n+                              GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+#ifndef PRODUCT\n+                              AsmRemarks& asm_remarks,\n+                              DbgStrings& dbg_strings,\n+#endif \/* PRODUCT *\/\n+                              SCCReader* scc_reader)\n+{\n+  nmethod* nm = nullptr;\n+  int nmethod_size = archived_nm->size();\n+  \/\/ create nmethod\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    nm = (nmethod *)CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(archived_nm->comp_level()));\n+    if (nm != nullptr) {\n+      nm->restore_from_archive(archived_nm,\n+                               method,\n+                               reloc_data,\n+                               oop_list,\n+                               metadata_list,\n+                               oop_maps,\n+                               immutable_data,\n+                               reloc_imm_oop_list,\n+                               reloc_imm_metadata_list,\n+                               NOT_PRODUCT_ARG(asm_remarks)\n+                               NOT_PRODUCT_ARG(dbg_strings)\n+                               scc_reader);\n+      nm->record_nmethod_dependency();\n+      NOT_PRODUCT(note_java_nmethod(nm));\n+    }\n+  }\n+  \/\/ Do verification and logging outside CodeCache_lock.\n+  if (nm != nullptr) {\n+#ifdef ASSERT\n+    LogTarget(Debug, scc, nmethod) log;\n+    if (log.is_enabled()) {\n+      LogStream out(log);\n+      out.print_cr(\"== new_nmethod 2\");\n+      FlagSetting fs(PrintRelocations, true);\n+      nm->print_on_impl(&out);\n+      nm->decode(&out);\n+    }\n+#endif\n+    \/\/ Safepoints in nmethod::verify aren't allowed because nm hasn't been installed yet.\n+    DEBUG_ONLY(nm->verify();)\n+    nm->log_new_nmethod();\n+  }\n+  return nm;\n+}\n+\n@@ -1764,0 +1877,8 @@\n+void nmethod::copy_values(GrowableArray<oop>* array) {\n+  int length = array->length();\n+  assert((address)(oops_begin() + length) <= (address)oops_end(), \"oops big enough\");\n+  oop* dest = oops_begin();\n+  for (int index = 0 ; index < length; index++) {\n+    dest[index] = array->at(index);\n+  }\n+}\n@@ -1811,0 +1932,19 @@\n+void nmethod::create_reloc_immediates_list(GrowableArray<oop>& oop_list, GrowableArray<Metadata*>& metadata_list) {\n+  RelocIterator iter(this);\n+  while (iter.next()) {\n+    if (iter.type() == relocInfo::oop_type) {\n+      oop_Relocation* reloc = iter.oop_reloc();\n+      if (reloc->oop_is_immediate()) {\n+        oop dest = reloc->oop_value();\n+        oop_list.append(dest);\n+      }\n+    } else if (iter.type() == relocInfo::metadata_type) {\n+      metadata_Relocation* reloc = iter.metadata_reloc();\n+      if (reloc->metadata_is_immediate()) {\n+        Metadata* m = reloc->metadata_value();\n+        metadata_list.append(m);\n+      }\n+    }\n+  }\n+}\n+\n@@ -2183,1 +2323,3 @@\n-  delete[] _compiled_ic_data;\n+  if (_compiled_ic_data != nullptr) {\n+    delete[] _compiled_ic_data;\n+  }\n@@ -2185,1 +2327,1 @@\n-  if (_immutable_data != blob_end()) {\n+  if (_immutable_data != data_end() && !SCCache::is_address_in_aot_cache((address)_oop_maps)) {\n@@ -2983,3 +3125,7 @@\n-  for (PcDesc* p = scopes_pcs_begin(); p < scopes_pcs_end(); p++) {\n-    if (! p->verify(this)) {\n-      tty->print_cr(\"\\t\\tin nmethod at \" INTPTR_FORMAT \" (pcs)\", p2i(this));\n+  \/\/ Verification can triggered during shutdown after SCCache is closed.\n+  \/\/ If the Scopes data is in the AOT code cache, then we should avoid verification during shutdown.\n+  if (!is_scc() || SCCache::is_on()) {\n+    for (PcDesc* p = scopes_pcs_begin(); p < scopes_pcs_end(); p++) {\n+      if (! p->verify(this)) {\n+        tty->print_cr(\"\\t\\tin nmethod at \" INTPTR_FORMAT \" (pcs)\", p2i(this));\n+      }\n@@ -2987,1 +3133,0 @@\n-  }\n@@ -2991,13 +3136,14 @@\n-  {\n-    \/\/ Verify that implicit exceptions that deoptimize have a PcDesc and OopMap\n-    ImmutableOopMapSet* oms = oop_maps();\n-    ImplicitExceptionTable implicit_table(this);\n-    for (uint i = 0; i < implicit_table.len(); i++) {\n-      int exec_offset = (int) implicit_table.get_exec_offset(i);\n-      if (implicit_table.get_exec_offset(i) == implicit_table.get_cont_offset(i)) {\n-        assert(pc_desc_at(code_begin() + exec_offset) != nullptr, \"missing PcDesc\");\n-        bool found = false;\n-        for (int i = 0, imax = oms->count(); i < imax; i++) {\n-          if (oms->pair_at(i)->pc_offset() == exec_offset) {\n-            found = true;\n-            break;\n+    {\n+      \/\/ Verify that implicit exceptions that deoptimize have a PcDesc and OopMap\n+      ImmutableOopMapSet* oms = oop_maps();\n+      ImplicitExceptionTable implicit_table(this);\n+      for (uint i = 0; i < implicit_table.len(); i++) {\n+        int exec_offset = (int) implicit_table.get_exec_offset(i);\n+        if (implicit_table.get_exec_offset(i) == implicit_table.get_cont_offset(i)) {\n+          assert(pc_desc_at(code_begin() + exec_offset) != nullptr, \"missing PcDesc\");\n+          bool found = false;\n+          for (int i = 0, imax = oms->count(); i < imax; i++) {\n+            if (oms->pair_at(i)->pc_offset() == exec_offset) {\n+              found = true;\n+              break;\n+            }\n@@ -3005,0 +3151,1 @@\n+          assert(found, \"missing oopmap\");\n@@ -3006,1 +3153,0 @@\n-        assert(found, \"missing oopmap\");\n@@ -3009,1 +3155,0 @@\n-  }\n@@ -3012,0 +3157,1 @@\n+  }\n@@ -3020,1 +3166,3 @@\n-  verify_scopes();\n+  if (!is_scc() || SCCache::is_on()) {\n+    verify_scopes();\n+  }\n@@ -4101,0 +4249,20 @@\n+\n+void nmethod::prepare_for_archiving() {\n+  CodeBlob::prepare_for_archiving();\n+  _deoptimization_generation = 0;\n+  _gc_epoch = 0;\n+  _method_profiling_count = 0;\n+  _osr_link = nullptr;\n+  _method = nullptr;\n+  _immutable_data = nullptr;\n+  _pc_desc_container = nullptr;\n+  _exception_cache = nullptr;\n+  _gc_data = nullptr;\n+  _oops_do_mark_link = nullptr;\n+  _compiled_ic_data = nullptr;\n+  _osr_entry_point = nullptr;\n+  _compile_id = -1;\n+  _deoptimization_status = not_marked;\n+  _is_unloading_state = 0;\n+  _state = not_installed;\n+}\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":213,"deletions":45,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class SCCReader;\n@@ -482,0 +483,17 @@\n+  void record_nmethod_dependency();\n+\n+  void restore_from_archive(nmethod* archived_nm,\n+                            const methodHandle& method,\n+                            address reloc_data,\n+                            GrowableArray<oop>& oop_list,\n+                            GrowableArray<Metadata*>& metadata_list,\n+                            ImmutableOopMapSet* oop_maps,\n+                            address immutable_data,\n+                            GrowableArray<oop>& reloc_imm_oop_list,\n+                            GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+#ifndef PRODUCT\n+                            AsmRemarks& asm_remarks,\n+                            DbgStrings& dbg_strings,\n+#endif \/* PRODUCT *\/\n+                            SCCReader* scc_reader);\n+\n@@ -483,0 +501,17 @@\n+  \/\/ create nmethod using archived nmethod from AOT code cache\n+  static nmethod* new_nmethod(nmethod* archived_nm,\n+                              const methodHandle& method,\n+                              AbstractCompiler* compiler,\n+                              address reloc_data,\n+                              GrowableArray<oop>& oop_list,\n+                              GrowableArray<Metadata*>& metadata_list,\n+                              ImmutableOopMapSet* oop_maps,\n+                              address immutable_data,\n+                              GrowableArray<oop>& reloc_imm_oop_list,\n+                              GrowableArray<Metadata*>& reloc_imm_metadata_list,\n+#ifndef PRODUCT\n+                              AsmRemarks& asm_remarks,\n+                              DbgStrings& dbg_strings,\n+#endif \/* PRODUCT *\/\n+                              SCCReader* scc_reader);\n+\n@@ -517,0 +552,4 @@\n+  void copy_to(address dest) {\n+    memcpy(dest, this, size());\n+  }\n+\n@@ -518,0 +557,1 @@\n+  uint16_t entry_bci   () const { return _entry_bci; }\n@@ -544,1 +584,1 @@\n-  address deopt_mh_handler_begin() const { return           header_begin() + _deopt_mh_handler_offset ; }\n+  address deopt_mh_handler_begin() const { return _deopt_mh_handler_offset != -1 ? (header_begin() + _deopt_mh_handler_offset) : nullptr; }\n@@ -560,0 +600,1 @@\n+  void set_immutable_data(address data) { _immutable_data = data; }\n@@ -731,0 +772,1 @@\n+  void copy_values(GrowableArray<oop>* array);\n@@ -747,0 +789,2 @@\n+  void create_reloc_immediates_list(GrowableArray<oop>& oop_list, GrowableArray<Metadata*>& metadata_list);\n+\n@@ -919,0 +963,1 @@\n+  void set_scc_entry(SCCEntry* entry) { _scc_entry = entry; }\n@@ -1016,0 +1061,2 @@\n+  void prepare_for_archiving();\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -151,1 +151,0 @@\n-\n@@ -774,0 +773,8 @@\n+void internal_word_Relocation::fix_relocation_after_aot_load(address orig_base_addr, address current_base_addr) {\n+  address target = _target;\n+  if (target == nullptr) {\n+    target = this->target();\n+    target = current_base_addr + (target - orig_base_addr);\n+  }\n+  set_value(target);\n+}\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1400,0 +1400,2 @@\n+  void fix_relocation_after_aot_load(address orig_base_addr, address current_base_addr);\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2626,1 +2626,0 @@\n-    bool install_code = true;\n@@ -2633,4 +2632,1 @@\n-      if (StoreCachedCode && task->is_precompiled()) {\n-        install_code = false; \/\/ not suitable in the current context\n-      }\n-      comp->compile_method(&ci_env, target, osr_bci, install_code, directive);\n+      comp->compile_method(&ci_env, target, osr_bci, true, directive);\n@@ -2650,1 +2646,1 @@\n-    if (!ci_env.failing() && !task->is_success() && install_code) {\n+    if (!ci_env.failing() && !task->is_success() && !task->is_precompiled()) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,0 +128,2 @@\n+  _aot_load_start = 0;\n+  _aot_load_finish = 0;\n@@ -254,1 +256,2 @@\n-                             jlong time_created, jlong time_queued, jlong time_started, jlong time_finished) {\n+                             jlong time_created, jlong time_queued, jlong time_started, jlong time_finished,\n+                             jlong aot_load_start, jlong aot_load_finish) {\n@@ -282,0 +285,7 @@\n+    { \/\/ Time to load from AOT code cache\n+      stringStream ss;\n+      if (aot_load_start != 0 && aot_load_finish != 0) {\n+        ss.print(\"A%.1f\", TimeHelper::counter_to_millis(aot_load_finish - aot_load_start));\n+      }\n+      st->print(\"%7s \", ss.freeze());\n+    }\n@@ -343,1 +353,1 @@\n-             compiler()->name(), msg, short_form, cr, _time_created, _time_queued, _time_started, _time_finished);\n+             compiler()->name(), msg, short_form, cr, _time_created, _time_queued, _time_started, _time_finished, _aot_load_start, _aot_load_finish);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  jlong                _aot_load_start;\n+  jlong                _aot_load_finish;\n@@ -235,1 +237,2 @@\n-\n+  void         mark_aot_load_start(jlong time)   { _aot_load_start = time; }\n+  void         mark_aot_load_finish(jlong time)  { _aot_load_finish = time; }\n@@ -273,1 +276,2 @@\n-                                      jlong time_created = 0, jlong time_queued = 0, jlong time_started = 0, jlong time_finished = 0);\n+                                      jlong time_created = 0, jlong time_queued = 0, jlong time_started = 0, jlong time_finished = 0,\n+                                      jlong aot_load_start = 0, jlong aot_load_finish = 0);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -299,3 +299,1 @@\n-#ifdef ASSERT\n-  int nr_of_bytes() const; \/\/ this is an expensive operation, only used in debug builds\n-#endif\n+  int nr_of_bytes() const; \/\/ this is an expensive operation, only used in debug builds and when storing aot compiled nmethods\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}