{"files":[{"patch":"@@ -5364,0 +5364,29 @@\n+static Register pick_different_tmp(Register dst, Register src) {\n+  auto tmps = RegSet::of(r0, r1, r2) - RegSet::of(src, dst);\n+  return *tmps.begin();\n+}\n+\n+void MacroAssembler::encode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift < 4, \"unexpected compressd klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst, subtract it formthe src and shift down\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    sub(dst, src, dst);\n+    lsr(dst, dst, shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    sub(dst, src, tmp);\n+    lsr(dst, dst, shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5365,0 +5394,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    encode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -5401,0 +5435,22 @@\n+void MacroAssembler::decode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift < 4, \"unexpected compressd klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst then add the offset with a suitable shift\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    add(dst, dst, src, LSL,  shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    add(dst, tmp,  src, LSL,  shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5404,0 +5460,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    decode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -6701,1 +6762,1 @@\n-  mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));\n+  mov(lr, ExternalAddress(CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper)));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -938,0 +938,2 @@\n+  void decode_klass_not_null_for_aot(Register dst, Register src);\n+  void encode_klass_not_null_for_aot(Register dst, Register src);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5407,1 +5407,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    }\n@@ -5418,1 +5422,6 @@\n-    mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+      negl(dst);\n+    } else {\n+      mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+    }\n@@ -5439,1 +5448,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    }\n@@ -5460,1 +5473,5 @@\n-        mov64(dst, (int64_t)CompressedKlassPointers::base());\n+        if (AOTCodeCache::is_on_for_dump()) {\n+          movptr(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+        } else {\n+          mov64(dst, (int64_t)CompressedKlassPointers::base());\n+        }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -42,6 +42,2 @@\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    return ArchiveBuilder::is_active() && ArchiveBuilder::current()->has_been_archived(addr);\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return MetaspaceShared::is_in_shared_metaspace(addr);\n-  }\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+  return ArchiveBuilder::is_active() && ArchiveBuilder::current()->has_been_archived(addr);\n@@ -51,16 +47,3 @@\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    if (!ArchiveBuilder::is_active()) {\n-      return false;\n-    }\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    if (!builder->has_been_archived((address)ik)) {\n-      return false;\n-    }\n-    InstanceKlass* buffered_ik = builder->get_buffered_addr(ik);\n-    if (ik->is_shared_unregistered_class()) {\n-      return false;\n-    }\n-    return true;\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return ik->is_shared() && !ik->is_shared_unregistered_class();\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+  if (!ArchiveBuilder::is_active()) {\n+    return false;\n@@ -68,11 +51,3 @@\n-}\n-\n-uint AOTCacheAccess::delta_from_shared_address_base(address addr) {\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    assert(ArchiveBuilder::is_active(), \"must be\");\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    address requested_addr = builder->to_requested(builder->get_buffered_addr(addr));\n-    return (uint)pointer_delta(requested_addr, (address)SharedBaseAddress, 1);\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return (uint)pointer_delta(addr, (address)SharedBaseAddress, 1);\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  if (!builder->has_been_archived((address)ik)) {\n+    return false;\n@@ -80,0 +55,5 @@\n+  InstanceKlass* buffered_ik = builder->get_buffered_addr(ik);\n+  if (ik->is_shared_unregistered_class()) {\n+    return false;\n+  }\n+  return true;\n@@ -82,9 +62,6 @@\n-Method* AOTCacheAccess::method_in_aot_code(Method* m) {\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    assert(ArchiveBuilder::is_active(), \"must be\");\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    return builder->to_requested(builder->get_buffered_addr(m));\n-  } else {\n-    \/\/ Old CDS+AOT workflow.\n-    return m;\n-  }\n+uint AOTCacheAccess::delta_from_base_address(address addr) {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+  assert(ArchiveBuilder::is_active(), \"must be\");\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  address requested_addr = builder->to_requested(builder->get_buffered_addr(addr));\n+  return (uint)pointer_delta(requested_addr, (address)MetaspaceShared::requested_base_address(), 1);\n","filename":"src\/hotspot\/share\/cds\/aotCacheAccess.cpp","additions":19,"deletions":42,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -51,2 +51,30 @@\n-  static uint delta_from_shared_address_base(address addr);\n-  static Method* method_in_aot_code(Method* m) NOT_CDS_RETURN_(nullptr);\n+  \/*\n+   * Used during an assembly run to compute the offset of the metadata object in the AOT Cache.\n+   * The input argument is the \"source\" address of a metadata object (Method\/Klass) loaded by the assembly JVM.\n+   * Computation of the offset requires mapping the supplied metadata object to its \"requested\" address\n+   * and subtracting that address from the requested base address.\n+   * See ArchiveBuilder.hpp for definition of \"source\" and \"requested\" address.\n+   *\/\n+  static uint delta_from_base_address(address addr);\n+\n+  \/*\n+   * Used during a production run to materialize a pointer to a Klass located in a loaded AOT Cache.\n+   * The offset argument identifies a delta from the AOT Cache's currently mapped base address to the start of the Klass object.\n+   * The offset is normally obtained by reading a value embedded in some other AOT-ed entry, like an AOT compiled code.\n+   *\/\n+  static Klass* convert_offset_to_klass(uint offset_from_base_addr) {\n+    Metadata* metadata = (Metadata*)((address)SharedBaseAddress + offset_from_base_addr);\n+    assert(metadata->is_klass(), \"sanity check\");\n+    return (Klass*)metadata;\n+  }\n+\n+  \/*\n+   * Used during a production run to materialize a pointer to a Method located in a loaded AOT Cache.\n+   * The offset argument identifies a delta from the AOT Cache's currently mapped base address to the start of the Method object.\n+   * The offset is normally obtained by reading a value embedded in some other AOT-ed entry, like an AOT compiled code.\n+   *\/\n+  static Method* convert_offset_to_method(uint offset_from_base_addr) {\n+    Metadata* metadata = (Metadata*)((address)SharedBaseAddress + offset_from_base_addr);\n+    assert(metadata->is_method(), \"sanity check\");\n+    return (Method*)metadata;\n+  }\n","filename":"src\/hotspot\/share\/cds\/aotCacheAccess.hpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1053,1 +1053,2 @@\n-    _method = AOTCacheAccess::method_in_aot_code(_method);\n+    _method_offset = AOTCacheAccess::delta_from_base_address((address)_method);\n+    _method = nullptr;\n@@ -1903,10 +1904,0 @@\n-  log_info(aot, codecache, nmethod)(\"%d (L%d): Read nmethod '%s' from AOT Code Cache\", compile_id(), comp_level(), name);\n-#ifdef ASSERT\n-  LogStreamHandle(Debug, aot, codecache, nmethod) log;\n-  if (log.is_enabled()) {\n-    FlagSetting fs(PrintRelocations, true);\n-    archived_nm->print_on(&log);\n-    archived_nm->decode2(&log);\n-  }\n-#endif\n-\n@@ -1935,0 +1926,10 @@\n+    log_info(aot, codecache, nmethod)(\"%d (L%d): Read nmethod '%s' from AOT Code Cache\", compile_id(), comp_level(), name);\n+#ifdef ASSERT\n+    LogStreamHandle(Debug, aot, codecache, nmethod) log;\n+    if (log.is_enabled()) {\n+      nmethod* nm = target->get_Method()->code();\n+      FlagSetting fs(PrintRelocations, true);\n+      nm->print_on(&log);\n+      nm->decode2(&log);\n+    }\n+#endif\n@@ -1936,0 +1937,1 @@\n+\n@@ -1996,0 +1998,2 @@\n+      Method* m = AOTCacheAccess::convert_offset_to_method(entry->method_offset());\n+      entry->set_method(m);\n@@ -2645,1 +2649,1 @@\n-    uint method_offset = AOTCacheAccess::delta_from_shared_address_base((address)method);\n+    uint method_offset = AOTCacheAccess::delta_from_base_address((address)method);\n@@ -2737,1 +2741,1 @@\n-    Method* m = (Method*)((address)SharedBaseAddress + method_offset);\n+    Method* m = AOTCacheAccess::convert_offset_to_method(method_offset);\n@@ -2885,1 +2889,1 @@\n-    uint klass_offset = AOTCacheAccess::delta_from_shared_address_base((address)klass);\n+    uint klass_offset = AOTCacheAccess::delta_from_base_address((address)klass);\n@@ -2968,1 +2972,1 @@\n-    Klass* k = (Klass*)((address)SharedBaseAddress + klass_offset);\n+    Klass* k = AOTCacheAccess::convert_offset_to_klass(klass_offset);\n@@ -3453,1 +3457,3 @@\n-\n+#if defined(AARCH64) && !defined(ZERO)\n+  SET_ADDRESS(_extrs, JavaThread::aarch64_get_thread_helper);\n+#endif\n@@ -3463,0 +3469,1 @@\n+  SET_ADDRESS(_extrs, CompressedKlassPointers::base_addr());\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  uint   _method_offset;\n@@ -207,0 +208,1 @@\n+  uint method_offset() const { return _method_offset; }\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  static address  base_addr()        { return (address)&_base; }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}