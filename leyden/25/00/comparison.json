{"files":[{"patch":"@@ -561,34 +561,0 @@\n-  if (VerifyAdapterCalls &&\n-      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n-#if 0\n-    \/\/ So, let's test for cascading c2i\/i2c adapters right now.\n-    \/\/  assert(Interpreter::contains($return_addr) ||\n-    \/\/         StubRoutines::contains($return_addr),\n-    \/\/         \"i2c adapter must return to an interpreter frame\");\n-    __ block_comment(\"verify_i2c { \");\n-    Label L_ok;\n-    if (Interpreter::code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  Interpreter::code()->code_start(), Interpreter::code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::initial_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::initial_stubs_code()->code_begin(),\n-                  StubRoutines::initial_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::final_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::final_stubs_code()->code_begin(),\n-                  StubRoutines::final_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    const char* msg = \"i2c adapter must return to an interpreter frame\";\n-    __ block_comment(msg);\n-    __ stop(msg);\n-    __ bind(L_ok);\n-    __ block_comment(\"} verify_i2ce \");\n-#endif\n-  }\n-\n@@ -715,6 +681,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -781,1 +747,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":41,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -616,6 +616,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -641,1 +641,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, nullptr);\n+  return;\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1147,6 +1147,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -1227,2 +1227,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry,\n-                                          c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -600,6 +600,7 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -663,1 +664,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2306,6 +2306,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -2365,1 +2365,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -710,13 +710,0 @@\n-static void range_check(MacroAssembler* masm, Register pc_reg, Register temp_reg,\n-                        address code_start, address code_end,\n-                        Label& L_ok) {\n-  Label L_fail;\n-  __ lea(temp_reg, AddressLiteral(code_start, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::belowEqual, L_fail);\n-  __ lea(temp_reg, AddressLiteral(code_end, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::below, L_ok);\n-  __ bind(L_fail);\n-}\n-\n@@ -752,32 +739,0 @@\n-  if (VerifyAdapterCalls &&\n-      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n-    \/\/ So, let's test for cascading c2i\/i2c adapters right now.\n-    \/\/  assert(Interpreter::contains($return_addr) ||\n-    \/\/         StubRoutines::contains($return_addr),\n-    \/\/         \"i2c adapter must return to an interpreter frame\");\n-    __ block_comment(\"verify_i2c { \");\n-    Label L_ok;\n-    if (Interpreter::code() != nullptr) {\n-      range_check(masm, rax, rdi,\n-                  Interpreter::code()->code_start(), Interpreter::code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::initial_stubs_code() != nullptr) {\n-      range_check(masm, rax, rdi,\n-                  StubRoutines::initial_stubs_code()->code_begin(),\n-                  StubRoutines::initial_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::final_stubs_code() != nullptr) {\n-      range_check(masm, rax, rdi,\n-                  StubRoutines::final_stubs_code()->code_begin(),\n-                  StubRoutines::final_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    const char* msg = \"i2c adapter must return to an interpreter frame\";\n-    __ block_comment(msg);\n-    __ stop(msg);\n-    __ bind(L_ok);\n-    __ block_comment(\"} verify_i2ce \");\n-  }\n-\n@@ -931,6 +886,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -974,1 +929,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, nullptr);\n+  return;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":8,"deletions":52,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -679,1 +679,0 @@\n-\n@@ -830,13 +829,0 @@\n-static void range_check(MacroAssembler* masm, Register pc_reg, Register temp_reg,\n-                        address code_start, address code_end,\n-                        Label& L_ok) {\n-  Label L_fail;\n-  __ lea(temp_reg, AddressLiteral(code_start, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::belowEqual, L_fail);\n-  __ lea(temp_reg, AddressLiteral(code_end, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::below, L_ok);\n-  __ bind(L_fail);\n-}\n-\n@@ -875,35 +861,0 @@\n-  if (VerifyAdapterCalls &&\n-      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n-    \/\/ So, let's test for cascading c2i\/i2c adapters right now.\n-    \/\/  assert(Interpreter::contains($return_addr) ||\n-    \/\/         StubRoutines::contains($return_addr),\n-    \/\/         \"i2c adapter must return to an interpreter frame\");\n-    __ block_comment(\"verify_i2c { \");\n-    \/\/ Pick up the return address\n-    __ movptr(rax, Address(rsp, 0));\n-    Label L_ok;\n-    if (Interpreter::code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  Interpreter::code()->code_start(),\n-                  Interpreter::code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::initial_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::initial_stubs_code()->code_begin(),\n-                  StubRoutines::initial_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::final_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::final_stubs_code()->code_begin(),\n-                  StubRoutines::final_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    const char* msg = \"i2c adapter must return to an interpreter frame\";\n-    __ block_comment(msg);\n-    __ stop(msg);\n-    __ bind(L_ok);\n-    __ block_comment(\"} verify_i2ce \");\n-  }\n-\n@@ -1054,6 +1005,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -1121,1 +1072,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":8,"deletions":56,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -54,12 +54,11 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(\n-                        MacroAssembler *masm,\n-                        int total_args_passed,\n-                        int comp_args_on_stack,\n-                        const BasicType *sig_bt,\n-                        const VMRegPair *regs,\n-                        AdapterFingerPrint *fingerprint) {\n-  return AdapterHandlerLibrary::new_entry(\n-    fingerprint,\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub));\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n+  handler->set_entry_points(CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            nullptr);\n+  return;\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -362,1 +362,2 @@\n-  _estimated_hashtable_bytes = symbol_table_est + dictionary_est + training_data_est;\n+  size_t adapter_data_est = AdapterHandlerLibrary::estimate_size_for_archive();\n+  _estimated_hashtable_bytes = symbol_table_est + dictionary_est + training_data_est + adapter_data_est;\n@@ -617,0 +618,7 @@\n+  } else if (ref->msotype() == MetaspaceObj::AdapterHandlerEntryType) {\n+    if (CDSConfig::is_dumping_adapters()) {\n+      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)ref->obj();\n+      return AdapterHandlerLibrary::is_abstract_method_adapter(entry) ? set_to_null : make_a_copy;\n+    } else {\n+      return set_to_null;\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"code\/SCCache.hpp\"\n@@ -545,0 +546,4 @@\n+      if (StoreCachedCode) {\n+        log_info(cds)(\"ArchiveAdapters is enabled\");\n+        FLAG_SET_ERGO_IF_DEFAULT(ArchiveAdapters, true);\n+      }\n@@ -870,0 +875,4 @@\n+\n+bool CDSConfig::is_dumping_adapters() {\n+  return (ArchiveAdapters && is_dumping_final_static_archive());\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  static bool is_dumping_adapters()                          NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,0 +171,4 @@\n+                                                                            \\\n+  product(bool, ArchiveAdapters, false,                                     \\\n+          \"Archive AdapterFingerPrint and AdapterHandlerEntry.\"             \\\n+          \"Requires AOT code cache\")                                        \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,0 +285,2 @@\n+  case MetaspaceObj::AdapterHandlerEntryType:\n+  case MetaspaceObj::AdapterFingerPrintType:\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -451,1 +451,0 @@\n-\n@@ -453,0 +452,2 @@\n+  AdapterHandlerLibrary::serialize_shared_table_header(soc);\n+\n@@ -559,0 +560,3 @@\n+  if (CDSConfig::is_dumping_adapters()) {\n+    AdapterHandlerLibrary::archive_adapter_table();\n+  }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-      st->print_cr(   \"  clinit:               \" JLONG_FORMAT_W(6) \"us \/ \" JLONG_FORMAT \" events\",\n+      st->print_cr(\"  clinit:                          \" JLONG_FORMAT_W(6) \"us \/ \" JLONG_FORMAT \" events\",\n@@ -155,1 +155,1 @@\n-      st->print_cr(\"  link methods:         \" JLONG_FORMAT_W(6) \"us \/ \" JLONG_FORMAT \" events\",\n+      st->print_cr(\"  link methods:                    \" JLONG_FORMAT_W(6) \"us \/ \" JLONG_FORMAT \" events\",\n@@ -157,1 +157,1 @@\n-      st->print_cr(\"  method adapters:      \" JLONG_FORMAT_W(6) \"us \/ \" JLONG_FORMAT \" events\",\n+      st->print_cr(\"  method adapters:                 \" JLONG_FORMAT_W(6) \"us \/ \" JLONG_FORMAT \" events\",\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -178,0 +178,7 @@\n+\n+  \/\/ initialize the table of external routines so we can save\n+  \/\/ generated code blobs that reference them\n+  init_extrs_table();\n+  \/\/ initialize the table of initial stubs so we can save\n+  \/\/ generated code blobs that reference them\n+  init_early_stubs_table();\n@@ -246,0 +253,2 @@\n+        \/\/ need a lock to traverse the code cache\n+        MutexLocker locker(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -583,1 +592,19 @@\n-void SCCache::init_table() {\n+void SCCache::init_extrs_table() {\n+  SCCache* cache = SCCache::cache();\n+  if (cache != nullptr && cache->_table != nullptr) {\n+    cache->_table->init_extrs();\n+  }\n+}\n+void SCCache::init_early_stubs_table() {\n+  SCCache* cache = SCCache::cache();\n+  if (cache != nullptr && cache->_table != nullptr) {\n+    cache->_table->init_early_stubs();\n+  }\n+}\n+void SCCache::init_shared_blobs_table() {\n+  SCCache* cache = SCCache::cache();\n+  if (cache != nullptr && cache->_table != nullptr) {\n+    cache->_table->init_shared_blobs();\n+  }\n+}\n+void SCCache::init_stubs_table() {\n@@ -586,1 +613,1 @@\n-    cache->_table->init();\n+    cache->_table->init_stubs();\n@@ -1115,0 +1142,6 @@\n+    uint stubs_count = 0;\n+    uint adapters_count = 0;\n+    uint shared_blobs_count = 0;\n+    uint c1_blobs_count = 0;\n+    uint opto_blobs_count = 0;\n+    uint total_blobs_count = 0;\n@@ -1134,0 +1167,14 @@\n+        } else if (entries_address[i].kind() == SCCEntry::Adapter) {\n+          adapters_count++;\n+        } else if (entries_address[i].kind() == SCCEntry::Stub) {\n+          stubs_count++;\n+        } else if (entries_address[i].kind() == SCCEntry::Blob) {\n+          total_blobs_count++;\n+          if (entries_address[i].comp_level() == CompLevel_none) {\n+            shared_blobs_count++;\n+          } else if (entries_address[i].comp_level() == CompLevel_simple) {\n+            c1_blobs_count++;\n+          } else {\n+            assert(entries_address[i].comp_level() == CompLevel_full_optimization, \"must be!\");\n+            opto_blobs_count++;\n+          }\n@@ -1232,1 +1279,6 @@\n-\n+    log_info(scc, exit)(\"  Stubs: total=%d\", stubs_count);\n+    log_info(scc, exit)(\"  Adapters: total=%d\", adapters_count);\n+    log_info(scc, exit)(\"  Shared Blobs: total=%d\",shared_blobs_count);\n+    log_info(scc, exit)(\"  C1 Blobs: total=%d\", c1_blobs_count);\n+    log_info(scc, exit)(\"  Opto Blobs: total=%d\", opto_blobs_count);\n+    log_info(scc, exit)(\"  All Blobs: total=%d\", total_blobs_count);\n@@ -1948,1 +2000,0 @@\n-  assert(buffer->blob() != nullptr, \"sanity\");\n@@ -1985,0 +2036,76 @@\n+bool SCCache::load_adapter(CodeBuffer* buffer, uint32_t id, const char* name, uint32_t offsets[4]) {\n+#ifdef ASSERT\n+  LogStreamHandle(Debug, scc, stubs) log;\n+  if (log.is_enabled()) {\n+    FlagSetting fs(PrintRelocations, true);\n+    buffer->print_on(&log);\n+  }\n+#endif\n+  SCCache* cache = open_for_read();\n+  if (cache == nullptr) {\n+    return false;\n+  }\n+  log_info(scc, stubs)(\"Looking up adapter %s (0x%x) in Startup Code Cache '%s'\",\n+                       name, id, _cache->cache_path());\n+  SCCEntry* entry = cache->find_entry(SCCEntry::Adapter, id);\n+  if (entry == nullptr) {\n+    return false;\n+  }\n+  SCCReader reader(cache, entry, nullptr);\n+  return reader.compile_adapter(buffer, name, offsets);\n+}\n+bool SCCReader::compile_adapter(CodeBuffer* buffer, const char* name, uint32_t offsets[4]) {\n+  uint entry_position = _entry->offset();\n+  \/\/ Read name\n+  uint name_offset = entry_position + _entry->name_offset();\n+  uint name_size = _entry->name_size(); \/\/ Includes '\/0'\n+  const char* stored_name = addr(name_offset);\n+  log_info(scc, stubs)(\"%d (L%d): Reading adapter '%s' from Startup Code Cache '%s'\",\n+                       compile_id(), comp_level(), name, _cache->cache_path());\n+  if (strncmp(stored_name, name, (name_size - 1)) != 0) {\n+    log_warning(scc)(\"%d (L%d): Saved adapter's name '%s' is different from '%s'\",\n+                     compile_id(), comp_level(), stored_name, name);\n+    \/\/ n.b. this is not fatal -- we have just seen a hash id clash\n+    \/\/ so no need to call cache->set_failed()\n+    return false;\n+  }\n+  \/\/ Create fake original CodeBuffer\n+  CodeBuffer orig_buffer(name);\n+  \/\/ Read code\n+  uint code_offset = entry_position + _entry->code_offset();\n+  if (!read_code(buffer, &orig_buffer, code_offset)) {\n+    return false;\n+  }\n+  \/\/ Read relocations\n+  uint reloc_offset = entry_position + _entry->reloc_offset();\n+  set_read_position(reloc_offset);\n+  if (!read_relocations(buffer, &orig_buffer, nullptr, nullptr)) {\n+    return false;\n+  }\n+  uint offset = read_position();\n+  int offsets_count = *(int*)addr(offset);\n+  offset += sizeof(int);\n+  assert(offsets_count == 4, \"wrong caller expectations\");\n+  set_read_position(offset);\n+  for (int i = 0; i < offsets_count; i++) {\n+    uint32_t arg = *(uint32_t*)addr(offset);\n+    offset += sizeof(uint32_t);\n+    log_debug(scc, stubs)(\"%d (L%d): Reading adapter '%s'  offsets[%d] == 0x%x from Startup Code Cache '%s'\",\n+                         compile_id(), comp_level(), stored_name, i, arg, _cache->cache_path());\n+    offsets[i] = arg;\n+  }\n+  log_debug(scc, stubs)(\"%d (L%d): Read adapter '%s' with '%d' args from Startup Code Cache '%s'\",\n+                       compile_id(), comp_level(), stored_name, offsets_count, _cache->cache_path());\n+#ifdef ASSERT\n+  LogStreamHandle(Debug, scc, stubs) log;\n+  if (log.is_enabled()) {\n+    FlagSetting fs(PrintRelocations, true);\n+    buffer->print_on(&log);\n+    buffer->decode();\n+  }\n+#endif\n+  \/\/ mark entry as loaded\n+  ((SCCEntry *)_entry)->set_loaded();\n+  return true;\n+}\n+\n@@ -2228,0 +2355,67 @@\n+bool SCCache::store_adapter(CodeBuffer* buffer, uint32_t id, const char* name, uint32_t offsets[4]) {\n+  assert(CDSConfig::is_dumping_adapters(), \"must be\");\n+  SCCache* cache = open_for_write();\n+  if (cache == nullptr) {\n+    return false;\n+  }\n+  log_info(scc, stubs)(\"Writing adapter '%s' (0x%x) to Startup Code Cache '%s'\", name, id, cache->_cache_path);\n+#ifdef ASSERT\n+  LogStreamHandle(Debug, scc, stubs) log;\n+  if (log.is_enabled()) {\n+    FlagSetting fs(PrintRelocations, true);\n+    buffer->print_on(&log);\n+    buffer->decode();\n+  }\n+#endif\n+  \/\/ we need to take a lock to stop C1 and C2 compiler threads racing to\n+  \/\/ write blobs in parallel with each other or with later nmethods\n+  \/\/ TODO - maybe move this up to selected callers so we only lock\n+  \/\/ when saving a c1 or opto blob\n+  MutexLocker ml(Compile_lock);\n+  if (!cache->align_write()) {\n+    return false;\n+  }\n+  uint entry_position = cache->_write_position;\n+  \/\/ Write name\n+  uint name_offset = cache->_write_position - entry_position;\n+  uint name_size = (uint)strlen(name) + 1; \/\/ Includes '\/0'\n+  uint n = cache->write_bytes(name, name_size);\n+  if (n != name_size) {\n+    return false;\n+  }\n+  \/\/ Write code section\n+  if (!cache->align_write()) {\n+    return false;\n+  }\n+  uint code_offset = cache->_write_position - entry_position;\n+  uint code_size = 0;\n+  if (!cache->write_code(buffer, code_size)) {\n+    return false;\n+  }\n+  \/\/ Write relocInfo array\n+  uint reloc_offset = cache->_write_position - entry_position;\n+  uint reloc_size = 0;\n+  if (!cache->write_relocations(buffer, reloc_size)) {\n+    return false;\n+  }\n+  int extras_count = 4;\n+  n = cache->write_bytes(&extras_count, sizeof(int));\n+  if (n != sizeof(int)) {\n+    return false;\n+  }\n+  for (int i = 0; i < 4; i++) {\n+    uint32_t arg = offsets[i];\n+    log_debug(scc, stubs)(\"Writing adapter '%s' (0x%x) offsets[%d] == 0x%x to Startup Code Cache '%s'\", name, id, i, arg, cache->_cache_path);\n+    n = cache->write_bytes(&arg, sizeof(uint32_t));\n+    if (n != sizeof(uint32_t)) {\n+      return false;\n+    }\n+  }\n+  uint entry_size = cache->_write_position - entry_position;\n+  SCCEntry* entry = new (cache) SCCEntry(entry_position, entry_size, name_offset, name_size,\n+                                          code_offset, code_size, reloc_offset, reloc_size,\n+                                        SCCEntry::Adapter, id, 0);\n+  log_info(scc, stubs)(\"Wrote adapter '%s' (0x%x) to Startup Code Cache '%s'\", name, id, cache->_cache_path);\n+  return true;\n+}\n+\n@@ -3369,1 +3563,1 @@\n-static void print_helper(outputStream* st, const char* name, int stats[6+3][6], int idx) {\n+static void print_helper(outputStream* st, const char* name, int stats[6+3+1][6], int idx) {\n@@ -3396,1 +3590,2 @@\n-    int stats[6 + 3][6] = {0};\n+    \/\/ Entries are None, Adapter, Stub, Blob x 3 levels, Code x 6 levels\n+    int stats[6 + 3 + 1][6] = {0};\n@@ -3426,0 +3621,1 @@\n+    print_helper(st, \"Adapters\", stats, SCCEntry::Adapter);\n@@ -3524,0 +3720,7 @@\n+\/\/ address table ids for generated routines, external addresses and C\n+\/\/ string addresses are partitioned into positive integer ranges\n+\/\/ defined by the following positive base and max values\n+\/\/ i.e. [_extrs_base, _extrs_base + _extrs_max -1],\n+\/\/      [_stubs_base, _stubs_base + _stubs_max -1],\n+\/\/      ...\n+\/\/      [_c_str_base, _c_str_base + _c_str_max -1],\n@@ -3526,2 +3729,2 @@\n-#define _blobs_max 100\n-#define _shared_blobs_max 24\n+#define _all_blobs_max 100\n+#define _blobs_max 24\n@@ -3529,1 +3732,1 @@\n-#define _C1_blobs_max (_blobs_max - _shared_blobs_max - _C2_blobs_max)\n+#define _C1_blobs_max (_all_blobs_max - _blobs_max - _C2_blobs_max)\n@@ -3532,0 +3735,11 @@\n+#define _c_str_max MAX_STR_COUNT\n+#define _extrs_base 0\n+#define _stubs_base (_extrs_base + _extrs_max)\n+#define _blobs_base (_stubs_base + _stubs_max)\n+#define _C1_blobs_base (_blobs_base + _blobs_max)\n+#define _C2_blobs_base (_C1_blobs_base + _C1_blobs_max)\n+#if (_C2_blobs_base >= _all_max)\n+#error SCAddress table ranges need adjusting\n+#endif\n+#define _c_str_base _all_max\n+\n@@ -3538,4 +3752,4 @@\n-static bool initializing = false;\n-void SCAddressTable::init() {\n-  if (_complete || initializing) return; \/\/ Done already\n-  initializing = true;\n+static bool initializing_extrs = false;\n+void SCAddressTable::init_extrs() {\n+  if (_extrs_complete || initializing_extrs) return; \/\/ Done already\n+  initializing_extrs = true;\n@@ -3543,6 +3757,0 @@\n-  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n-  _blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n-\n-  \/\/ Divide _blobs_addr array to chunks because they could be initialized in parrallel\n-  _C2_blobs_addr = _blobs_addr + _shared_blobs_max;\/\/ C2 blobs addresses stored after shared blobs\n-  _C1_blobs_addr = _C2_blobs_addr + _C2_blobs_max; \/\/ C1 blobs addresses stored after C2 blobs\n@@ -3552,4 +3760,0 @@\n-  _blobs_length = 0;       \/\/ for shared blobs\n-  _C1_blobs_length = 0;\n-  _C2_blobs_length = 0;\n-  _final_blobs_length = 0; \/\/ Depends on numnber of C1 blobs\n@@ -3584,0 +3788,13 @@\n+  SET_ADDRESS(_extrs, SharedRuntime::fixup_callers_callsite);\n+\n+  SET_ADDRESS(_extrs, SharedRuntime::log_jni_monitor_still_held);\n+  SET_ADDRESS(_extrs, SharedRuntime::rc_trace_method_entry);\n+  SET_ADDRESS(_extrs, SharedRuntime::reguard_yellow_pages);\n+  SET_ADDRESS(_extrs, SharedRuntime::dtrace_method_exit);\n+\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method_abstract);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method_ic_miss);\n+  SET_ADDRESS(_extrs, SharedRuntime::resolve_opt_virtual_call_C);\n+  SET_ADDRESS(_extrs, SharedRuntime::resolve_virtual_call_C);\n+  SET_ADDRESS(_extrs, SharedRuntime::resolve_static_call_C);\n@@ -3657,0 +3874,63 @@\n+\n+  _extrs_complete = true;\n+  log_info(scc,init)(\"External addresses recorded\");\n+}\n+\n+static bool initializing_early_stubs = false;\n+void SCAddressTable::init_early_stubs() {\n+  if (_complete || initializing_early_stubs) return; \/\/ Done already\n+  initializing_early_stubs = true;\n+  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n+  _stubs_length = 0;\n+  SET_ADDRESS(_stubs, StubRoutines::forward_exception_entry());\n+  _early_stubs_complete = true;\n+  log_info(scc,init)(\"early stubs recorded\");\n+}\n+\n+static bool initializing_shared_blobs = false;\n+void SCAddressTable::init_shared_blobs() {\n+  if (_complete || initializing_shared_blobs) return; \/\/ Done already\n+  initializing_shared_blobs = true;\n+  _blobs_addr = NEW_C_HEAP_ARRAY(address, _all_blobs_max, mtCode);\n+\n+  \/\/ Divide _blobs_addr array to chunks because they could be initialized in parrallel\n+  _C1_blobs_addr = _blobs_addr + _blobs_max;\/\/ C1 blobs addresses stored after shared blobs\n+  _C2_blobs_addr = _C1_blobs_addr + _C1_blobs_max; \/\/ C2 blobs addresses stored after C1 blobs\n+\n+  _blobs_length = 0;       \/\/ for shared blobs\n+  _C1_blobs_length = 0;\n+  _C2_blobs_length = 0;\n+\n+  \/\/ Blobs\n+  SET_ADDRESS(_blobs, SharedRuntime::get_handle_wrong_method_stub());\n+  SET_ADDRESS(_blobs, SharedRuntime::get_ic_miss_stub());\n+  SET_ADDRESS(_blobs, SharedRuntime::get_resolve_opt_virtual_call_stub());\n+  SET_ADDRESS(_blobs, SharedRuntime::get_resolve_virtual_call_stub());\n+  SET_ADDRESS(_blobs, SharedRuntime::get_resolve_static_call_stub());\n+  SET_ADDRESS(_blobs, SharedRuntime::deopt_blob()->entry_point());\n+  SET_ADDRESS(_blobs, SharedRuntime::polling_page_safepoint_handler_blob()->entry_point());\n+  SET_ADDRESS(_blobs, SharedRuntime::polling_page_return_handler_blob()->entry_point());\n+#ifdef COMPILER2\n+  SET_ADDRESS(_blobs, SharedRuntime::polling_page_vectors_safepoint_handler_blob()->entry_point());\n+#endif\n+\n+  assert(_blobs_length <= _blobs_max, \"increase _blobs_max to %d\", _blobs_length);\n+  log_info(scc,init)(\"Early shared blobs recorded\");\n+}\n+\n+static bool initializing_stubs = false;\n+void SCAddressTable::init_stubs() {\n+  if (_complete || initializing_stubs) return; \/\/ Done already\n+  initializing_stubs = true;\n+  \/\/ final blobs\n+  SET_ADDRESS(_blobs, SharedRuntime::throw_AbstractMethodError_entry());\n+  SET_ADDRESS(_blobs, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n+  SET_ADDRESS(_blobs, SharedRuntime::throw_NullPointerException_at_call_entry());\n+  SET_ADDRESS(_blobs, SharedRuntime::throw_StackOverflowError_entry());\n+  SET_ADDRESS(_blobs, SharedRuntime::throw_delayed_StackOverflowError_entry());\n+\n+  assert(_blobs_length <= _blobs_max, \"increase _blobs_max to %d\", _blobs_length);\n+\n+  _shared_blobs_complete = true;\n+  log_info(scc,init)(\"All shared blobs recorded\");\n+\n@@ -3659,1 +3939,0 @@\n-  SET_ADDRESS(_stubs, StubRoutines::forward_exception_entry());\n@@ -3822,21 +4101,0 @@\n-  \/\/ Blobs\n-  SET_ADDRESS(_blobs, SharedRuntime::get_handle_wrong_method_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::get_ic_miss_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::get_resolve_opt_virtual_call_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::get_resolve_virtual_call_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::get_resolve_static_call_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::deopt_blob()->entry_point());\n-  SET_ADDRESS(_blobs, SharedRuntime::polling_page_safepoint_handler_blob()->entry_point());\n-  SET_ADDRESS(_blobs, SharedRuntime::polling_page_return_handler_blob()->entry_point());\n-#ifdef COMPILER2\n-  SET_ADDRESS(_blobs, SharedRuntime::polling_page_vectors_safepoint_handler_blob()->entry_point());\n-#endif\n-\n-  SET_ADDRESS(_blobs, SharedRuntime::throw_AbstractMethodError_entry());\n-  SET_ADDRESS(_blobs, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n-  SET_ADDRESS(_blobs, SharedRuntime::throw_NullPointerException_at_call_entry());\n-  SET_ADDRESS(_blobs, SharedRuntime::throw_StackOverflowError_entry());\n-  SET_ADDRESS(_blobs, SharedRuntime::throw_delayed_StackOverflowError_entry());\n-\n-  assert(_blobs_length <= _shared_blobs_max, \"increase _shared_blobs_max to %d\", _blobs_length);\n-  _final_blobs_length = _blobs_length;\n@@ -3844,1 +4102,1 @@\n-  log_info(scc,init)(\"External addresses and stubs recorded\");\n+  log_info(scc,init)(\"Stubs recorded\");\n@@ -3877,1 +4135,0 @@\n-  _final_blobs_length = MAX2(_final_blobs_length, (_shared_blobs_max + _C2_blobs_length));\n@@ -3929,1 +4186,0 @@\n-  _final_blobs_length = MAX2(_final_blobs_length, (_shared_blobs_max + _C2_blobs_max + _C1_blobs_length));\n@@ -3935,6 +4191,0 @@\n-#undef _extrs_max\n-#undef _stubs_max\n-#undef _blobs_max\n-#undef _shared_blobs_max\n-#undef _C1_blobs_max\n-#undef _C2_blobs_max\n@@ -3954,0 +4204,1 @@\n+#ifdef PRODUCT\n@@ -3955,0 +4206,3 @@\n+#else\n+#define MAX_STR_COUNT 500\n+#endif\n@@ -4036,1 +4290,1 @@\n-  if (str != nullptr && _complete && (_opto_complete || _c1_complete)) {\n+  if (str != nullptr && _extrs_complete) {\n@@ -4100,2 +4354,2 @@\n-  if (!_complete) {\n-    fatal(\"SCA table is not complete\");\n+  if (!_extrs_complete) {\n+    fatal(\"SCA extrs table is not complete\");\n@@ -4107,2 +4361,3 @@\n-  if (id >= _all_max && idx < (_all_max + _C_strings_count)) {\n-    return address_for_C_string(idx - _all_max);\n+  \/\/ special case for symbols based relative to os::init\n+  if (id > (_c_str_base + _c_str_max)) {\n+    return (address)os::init + idx;\n@@ -4110,1 +4365,1 @@\n-  if (idx < 0 || id == (_extrs_length + _stubs_length + _final_blobs_length)) {\n+  if (idx < 0) {\n@@ -4113,2 +4368,9 @@\n-  if (idx > (_all_max + _C_strings_count)) {\n-    return (address)os::init + idx;\n+  \/\/ no need to compare unsigned id against 0\n+  if (\/* id >= _extrs_base && *\/ id < _extrs_length) {\n+    return _extrs_addr[id - _extrs_base];\n+  }\n+  if (id >= _stubs_base && id < _stubs_base + _stubs_length) {\n+    return _stubs_addr[id - _stubs_base];\n+  }\n+  if (id >= _blobs_base && id < _blobs_base + _blobs_length) {\n+    return _blobs_addr[id - _blobs_base];\n@@ -4116,2 +4378,2 @@\n-  if (id < _extrs_length) {\n-    return _extrs_addr[id];\n+  if (id >= _C1_blobs_base && id < _C1_blobs_base + _C1_blobs_length) {\n+    return _C1_blobs_addr[id - _C1_blobs_base];\n@@ -4119,3 +4381,2 @@\n-  id -= _extrs_length;\n-  if (id < _stubs_length) {\n-    return _stubs_addr[id];\n+  if (id >= _C2_blobs_base && id < _C2_blobs_base + _C2_blobs_length) {\n+    return _C2_blobs_addr[id - _C2_blobs_base];\n@@ -4123,3 +4384,2 @@\n-  id -= _stubs_length;\n-  if (id < _final_blobs_length) {\n-    return _blobs_addr[id];\n+  if (id >= _c_str_base && id < (_c_str_base + (uint)_C_strings_count)) {\n+    return address_for_C_string(id - _c_str_base);\n@@ -4127,0 +4387,1 @@\n+  fatal(\"Incorrect id %d for SCA table\", id);\n@@ -4135,1 +4396,1 @@\n-  if (!_complete) {\n+  if (!_extrs_complete) {\n@@ -4141,1 +4402,1 @@\n-    return id + _all_max;\n+    return id + _c_str_base;\n@@ -4154,1 +4415,1 @@\n-      id += _extrs_length;\n+      return _stubs_base + id;\n@@ -4159,0 +4420,1 @@\n+      int id_base = _blobs_base;\n@@ -4160,1 +4422,11 @@\n-      id = search_address(addr, _blobs_addr, _final_blobs_length);\n+       id = search_address(addr, _blobs_addr, _blobs_length);\n+      if (id == -1) {\n+        id_base = _C1_blobs_base;\n+        \/\/ search C1 blobs\n+        id = search_address(addr, _C1_blobs_addr, _C1_blobs_length);\n+      }\n+      if (id == -1) {\n+        id_base = _C2_blobs_base;\n+        \/\/ search C2 blobs\n+        id = search_address(addr, _C2_blobs_addr, _C2_blobs_length);\n+      }\n@@ -4164,1 +4436,1 @@\n-        id += _extrs_length + _stubs_length;\n+        return id_base + id;\n@@ -4200,0 +4472,2 @@\n+      } else {\n+        return _extrs_base + id;\n@@ -4206,0 +4480,13 @@\n+#undef _extrs_max\n+#undef _stubs_max\n+#undef _all_blobs_max\n+#undef _blobs_max\n+#undef _C1_blobs_max\n+#undef _C2_blobs_max\n+#undef _extrs_base\n+#undef _stubs_base\n+#undef _blobs_base\n+#undef _C1_blobs_base\n+#undef _C2_blobs_base\n+#undef _c_str_base\n+\n","filename":"src\/hotspot\/share\/code\/SCCache.cpp","additions":362,"deletions":75,"binary":false,"changes":437,"status":"modified"},{"patch":"@@ -148,3 +148,4 @@\n-    Stub = 1,\n-    Blob = 2,\n-    Code = 3\n+    Adapter = 1,\n+    Stub = 2,\n+    Blob = 3,\n+    Code = 4\n@@ -274,1 +275,0 @@\n-  uint     _final_blobs_length;\n@@ -276,0 +276,3 @@\n+  bool _extrs_complete;\n+  bool _early_stubs_complete;\n+  bool _shared_blobs_complete;\n@@ -285,0 +288,3 @@\n+    _extrs_complete = false;\n+    _early_stubs_complete = false;\n+    _shared_blobs_complete = false;\n@@ -290,1 +296,4 @@\n-  void init();\n+  void init_extrs();\n+  void init_early_stubs();\n+  void init_shared_blobs();\n+  void init_stubs();\n@@ -354,0 +363,2 @@\n+  bool compile_adapter(CodeBuffer* buffer, const char* name, uint32_t offsets[4]);\n+\n@@ -473,1 +484,4 @@\n-  static void init_table();\n+  static void init_extrs_table();\n+  static void init_early_stubs_table();\n+  static void init_shared_blobs_table();\n+  static void init_stubs_table();\n@@ -523,0 +537,3 @@\n+  static bool load_adapter(CodeBuffer* buffer, uint32_t id, const char* basic_sig, uint32_t offsets[4]);\n+  static bool store_adapter(CodeBuffer* buffer, uint32_t id, const char* basic_sig, uint32_t offsets[4]);\n+\n","filename":"src\/hotspot\/share\/code\/SCCache.hpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2046,5 +2046,0 @@\n-    \/\/ Perform per-thread and global initializations\n-    {\n-      MutexLocker only_one (thread, CompileThread_lock);\n-      SCCache::init_table();\n-    }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -321,1 +321,3 @@\n-  f(SharedClassPathEntry)\n+  f(SharedClassPathEntry) \\\n+  f(AdapterHandlerEntry) \\\n+  f(AdapterFingerPrint)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -402,0 +402,1 @@\n+  it->push(&_adapter);\n@@ -415,0 +416,3 @@\n+  if (CDSConfig::is_dumping_adapters() && _adapter != nullptr) {\n+    _adapter->remove_unshareable_info();\n+  }\n@@ -426,0 +430,4 @@\n+  if (_adapter != nullptr) {\n+    _adapter->restore_unshareable_info(CHECK);\n+    _from_compiled_entry = _adapter->get_c2i_entry();\n+  }\n@@ -1214,1 +1222,3 @@\n-  _adapter = nullptr;\n+  if (!CDSConfig::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+    _adapter = nullptr;\n+  }\n@@ -1259,0 +1269,3 @@\n+  \/\/ TODO: how to identify code cache full situation now that the adapter() can be\n+  \/\/ non-null if AOT cache is in use\n+#if 0\n@@ -1264,0 +1277,1 @@\n+#endif\n@@ -1269,1 +1283,1 @@\n-  assert(adapter() == nullptr, \"init'd to null\");\n+  assert(adapter() == nullptr || adapter()->is_linked(), \"init'd to null or restored from cache\");\n@@ -1290,1 +1304,3 @@\n-  (void) make_adapters(h_method, CHECK);\n+  if (_adapter == nullptr) {\n+    (void) make_adapters(h_method, CHECK);\n+  }\n@@ -1571,0 +1587,4 @@\n+  if (m->adapter() != nullptr) {\n+    m->adapter()->restore_unshareable_info(CHECK);\n+    m->set_from_compiled_entry(m->adapter()->get_c2i_entry());\n+  }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -592,0 +592,2 @@\n+      _final_profile = nullptr;\n+      _final_counters = nullptr;\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2024,0 +2024,3 @@\n+                                                                            \\\n+  develop(bool, TestAdapterLinkFailure, false,                              \\\n+          \"Test failure of adapter linking when loading from AOT cache.\")   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,0 +169,2 @@\n+  SCCache::init_shared_blobs_table();  \/\/ need this after generate_stubs\n+  SharedRuntime::init_adapter_library(); \/\/ do this after SCCache::init_shared_blobs_table\n@@ -207,0 +209,1 @@\n+  SCCache::init_stubs_table();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.inline.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n@@ -31,0 +34,1 @@\n+#include \"code\/SCCache.hpp\"\n@@ -159,2 +163,0 @@\n-  AdapterHandlerLibrary::initialize();\n-\n@@ -192,0 +194,4 @@\n+void SharedRuntime::init_adapter_library() {\n+  AdapterHandlerLibrary::initialize();\n+}\n+\n@@ -2260,1 +2266,2 @@\n-static int _hits;    \/\/ number of successful lookups\n+static int _archived_hits;    \/\/ number of successful lookups in archived table\n+static int _runtime_hits; \/\/ number of successful lookups in runtime table\n@@ -2266,1 +2273,1 @@\n-class AdapterFingerPrint : public CHeapObj<mtCode> {\n+class AdapterFingerPrint : public MetaspaceObj {\n@@ -2277,6 +2284,23 @@\n-  union {\n-    int  _compact[_compact_int_count];\n-    int* _fingerprint;\n-  } _value;\n-  int _length; \/\/ A negative length indicates the fingerprint is in the compact form,\n-               \/\/ Otherwise _value._fingerprint is the array.\n+  int _length;\n+  int _value[_compact_int_count];\n+\n+  \/\/ Private construtor. Use allocate() to get an instance.\n+  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {\n+    \/\/ Pack the BasicTypes with 8 per int\n+    _length = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    int sig_index = 0;\n+    for (int index = 0; index < _length; index++) {\n+      int value = 0;\n+      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n+        int bt = adapter_encoding(sig_bt[sig_index++]);\n+        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n+        value = (value << _basic_type_bits) | bt;\n+      }\n+      _value[index] = value;\n+    }\n+  }\n+\n+  \/\/ Call deallocate instead\n+  ~AdapterFingerPrint() {\n+    FreeHeap(this);\n+  }\n@@ -2319,18 +2343,6 @@\n- public:\n-  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {\n-    \/\/ The fingerprint is based on the BasicType signature encoded\n-    \/\/ into an array of ints with eight entries per int.\n-    int* ptr;\n-    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n-    if (len <= _compact_int_count) {\n-      assert(_compact_int_count == 3, \"else change next line\");\n-      _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;\n-      \/\/ Storing the signature encoded as signed chars hits about 98%\n-      \/\/ of the time.\n-      _length = -len;\n-      ptr = _value._compact;\n-    } else {\n-      _length = len;\n-      _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);\n-      ptr = _value._fingerprint;\n-    }\n+  void* operator new(size_t size, size_t fp_size) throw() {\n+    assert(fp_size >= size, \"sanity check\");\n+    void* p = AllocateHeap(fp_size, mtCode);\n+    memset(p, 0, fp_size);\n+    return p;\n+  }\n@@ -2338,8 +2350,12 @@\n-    \/\/ Now pack the BasicTypes with 8 per int\n-    int sig_index = 0;\n-    for (int index = 0; index < len; index++) {\n-      int value = 0;\n-      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n-        int bt = adapter_encoding(sig_bt[sig_index++]);\n-        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt;\n+  template<typename Function>\n+  void iterate_args(Function function) {\n+    for (int i = 0; i < length(); i++) {\n+      unsigned val = (unsigned)value(i);\n+      \/\/ args are packed so that first\/lower arguments are in the highest\n+      \/\/ bits of each int value, so iterate from highest to the lowest\n+      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n+        unsigned v = (val >> j) & _basic_type_mask;\n+        if (v == 0) {\n+          continue;\n+        }\n+        function(v);\n@@ -2347,1 +2363,0 @@\n-      ptr[index] = value;\n@@ -2351,4 +2366,13 @@\n-  ~AdapterFingerPrint() {\n-    if (_length > 0) {\n-      FREE_C_HEAP_ARRAY(int, _value._fingerprint);\n-    }\n+ public:\n+  static int allocation_size(int total_args_passed, BasicType* sig_bt) {\n+    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    return sizeof(AdapterFingerPrint) + (len > _compact_int_count ? (len - _compact_int_count) * sizeof(int) : 0);\n+  }\n+\n+  static AdapterFingerPrint* allocate(int total_args_passed, BasicType* sig_bt) {\n+    int size_in_bytes = allocation_size(total_args_passed, sig_bt);\n+    return new (size_in_bytes) AdapterFingerPrint(total_args_passed, sig_bt);\n+  }\n+\n+  static void deallocate(AdapterFingerPrint* fp) {\n+    fp->~AdapterFingerPrint();\n@@ -2358,4 +2382,1 @@\n-    if (_length < 0) {\n-      return _value._compact[index];\n-    }\n-    return _value._fingerprint[index];\n+    return _value[index];\n@@ -2363,0 +2384,1 @@\n+\n@@ -2369,1 +2391,1 @@\n-    return _length <= 0;\n+    return _length <= _compact_int_count;\n@@ -2376,1 +2398,2 @@\n-      hash = (hash << 8) ^ v ^ (hash >> 5);\n+      \/\/Add arithmetic operation to the hash, like +3 to improve hashing\n+      hash = ((hash << 8) ^ v ^ (hash >> 5)) + 3;\n@@ -2390,3 +2413,0 @@\n-#ifndef PRODUCT\n-  \/\/ Reconstitutes the basic type arguments from the fingerprint,\n-  \/\/ producing strings like LIJDF\n@@ -2396,25 +2416,7 @@\n-    for (int i = 0; i < length(); i++) {\n-      unsigned val = (unsigned)value(i);\n-      \/\/ args are packed so that first\/lower arguments are in the highest\n-      \/\/ bits of each int value, so iterate from highest to the lowest\n-      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n-        unsigned v = (val >> j) & _basic_type_mask;\n-        if (v == 0) {\n-          assert(i == length() - 1, \"Only expect zeroes in the last word\");\n-          continue;\n-        }\n-        if (long_prev) {\n-          long_prev = false;\n-          if (v == T_VOID) {\n-            st.print(\"J\");\n-          } else {\n-            st.print(\"L\");\n-          }\n-        }\n-        switch (v) {\n-          case T_INT:    st.print(\"I\");    break;\n-          case T_LONG:   long_prev = true; break;\n-          case T_FLOAT:  st.print(\"F\");    break;\n-          case T_DOUBLE: st.print(\"D\");    break;\n-          case T_VOID:   break;\n-          default: ShouldNotReachHere();\n+    iterate_args([&] (int arg) {\n+      if (long_prev) {\n+        long_prev = false;\n+        if (arg == T_VOID) {\n+          st.print(\"J\");\n+        } else {\n+          st.print(\"L\");\n@@ -2423,1 +2425,9 @@\n-    }\n+      switch (arg) {\n+        case T_INT:    st.print(\"I\");    break;\n+        case T_LONG:   long_prev = true; break;\n+        case T_FLOAT:  st.print(\"F\");    break;\n+        case T_DOUBLE: st.print(\"D\");    break;\n+        case T_VOID:   break;\n+        default: ShouldNotReachHere();\n+      }\n+    });\n@@ -2429,1 +2439,51 @@\n-#endif \/\/ !product\n+\n+  BasicType* as_basic_type(int& nargs) {\n+    nargs = 0;\n+    GrowableArray<BasicType> btarray;\n+    bool long_prev = false;\n+\n+    iterate_args([&] (int arg) {\n+      if (long_prev) {\n+        long_prev = false;\n+        if (arg == T_VOID) {\n+          btarray.append(T_LONG);\n+        } else {\n+          btarray.append(T_OBJECT); \/\/ it could be T_ARRAY; it shouldn't matter\n+        }\n+      }\n+      switch (arg) {\n+        case T_INT: \/\/ fallthrough\n+        case T_FLOAT: \/\/ fallthrough\n+        case T_DOUBLE:\n+        case T_VOID:\n+          btarray.append((BasicType)arg);\n+          break;\n+        case T_LONG:\n+          long_prev = true;\n+          break;\n+        default: ShouldNotReachHere();\n+      }\n+    });\n+\n+    if (long_prev) {\n+      btarray.append(T_OBJECT);\n+    }\n+\n+    nargs = btarray.length();\n+    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nargs);\n+    int index = 0;\n+    GrowableArrayIterator<BasicType> iter = btarray.begin();\n+    while (iter != btarray.end()) {\n+      sig_bt[index++] = *iter;\n+      ++iter;\n+    }\n+    assert(index == btarray.length(), \"sanity check\");\n+#ifdef ASSERT\n+    {\n+      AdapterFingerPrint* compare_fp = AdapterFingerPrint::allocate(nargs, sig_bt);\n+      assert(this->equals(compare_fp), \"sanity check\");\n+      AdapterFingerPrint::deallocate(compare_fp);\n+    }\n+#endif\n+    return sig_bt;\n+  }\n@@ -2434,6 +2494,0 @@\n-    }\n-    if (_length < 0) {\n-      assert(_compact_int_count == 3, \"else change next line\");\n-      return _value._compact[0] == other->_value._compact[0] &&\n-             _value._compact[1] == other->_value._compact[1] &&\n-             _value._compact[2] == other->_value._compact[2];\n@@ -2442,1 +2496,1 @@\n-        if (_value._fingerprint[i] != other->_value._fingerprint[i]) {\n+        if (_value[i] != other->_value[i]) {\n@@ -2450,0 +2504,5 @@\n+  \/\/ methods required by virtue of being a MetaspaceObj\n+  void metaspace_pointers_do(MetaspaceClosure* it) { return; \/* nothing to do here *\/ }\n+  int size() const { return (int)heap_word_size(sizeof(AdapterFingerPrint) + (_length > _compact_int_count ? (_length - _compact_int_count) * sizeof(int) : 0)); }\n+  MetaspaceObj::Type type() const { return AdapterFingerPrintType; }\n+\n@@ -2466,0 +2525,1 @@\n+static GrowableArray<AdapterHandlerEntry*>* _adapter_handler_list = nullptr;\n@@ -2468,1 +2528,1 @@\n-static AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {\n+AdapterHandlerEntry* AdapterHandlerLibrary::lookup(AdapterFingerPrint* fp) {\n@@ -2470,3 +2530,3 @@\n-  assert_lock_strong(AdapterHandlerLibrary_lock);\n-  AdapterFingerPrint fp(total_args_passed, sig_bt);\n-  AdapterHandlerEntry** entry = _adapter_handler_table->get(&fp);\n+#if INCLUDE_CDS\n+  \/\/ Search archived table first. It is read-only table so can be searched without lock\n+  AdapterHandlerEntry* entry = _archived_adapter_handler_table.lookup(fp, fp->compute_hash(), 0 \/* unused *\/);\n@@ -2475,2 +2535,4 @@\n-    if (fp.is_compact()) _compact++;\n-    _hits++;\n+    if (fp->is_compact()) {\n+      _compact++;\n+    }\n+    _archived_hits++;\n@@ -2478,1 +2540,11 @@\n-    return *entry;\n+    return entry;\n+  }\n+#endif \/\/ INCLUDE_CDS\n+  assert_lock_strong(AdapterHandlerLibrary_lock);\n+  AdapterHandlerEntry** entry_p = _adapter_handler_table->get(fp);\n+  if (entry_p != nullptr) {\n+#ifndef PRODUCT\n+    if (fp->is_compact()) _compact++;\n+    _runtime_hits++;\n+#endif\n+    return *entry_p;\n@@ -2492,2 +2564,3 @@\n-  st->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d compact %d\",\n-               _lookups, _equals, _hits, _compact);\n+  int total_hits = _archived_hits + _runtime_hits;\n+  st->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d (archived=%d+runtime=%d) compact %d\",\n+               _lookups, _equals, total_hits, _archived_hits, _runtime_hits, _compact);\n@@ -2505,0 +2578,3 @@\n+#if INCLUDE_CDS\n+ArchivedAdapterTable AdapterHandlerLibrary::_archived_adapter_handler_table;\n+#endif \/\/ INCLUDE_CDS\n@@ -2548,1 +2624,1 @@\n-    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, nullptr),\n+    _abstract_method_handler = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(0, nullptr),\n@@ -2553,1 +2629,1 @@\n-    _no_arg_handler = create_adapter(no_arg_blob, 0, nullptr, true);\n+    _no_arg_handler = create_simple_adapter(no_arg_blob, 0, nullptr);\n@@ -2556,1 +2632,1 @@\n-    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args, true);\n+    _obj_arg_handler = create_simple_adapter(obj_arg_blob, 1, obj_args);\n@@ -2559,1 +2635,1 @@\n-    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args, true);\n+    _int_arg_handler = create_simple_adapter(int_arg_blob, 1, int_args);\n@@ -2562,1 +2638,1 @@\n-    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args, true);\n+    _obj_int_arg_handler = create_simple_adapter(obj_int_arg_blob, 2, obj_int_args);\n@@ -2565,1 +2641,1 @@\n-    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args, true);\n+    _obj_obj_arg_handler = create_simple_adapter(obj_obj_arg_blob, 2, obj_obj_args);\n@@ -2568,4 +2644,4 @@\n-          obj_arg_blob != nullptr &&\n-          int_arg_blob != nullptr &&\n-          obj_int_arg_blob != nullptr &&\n-          obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n+           obj_arg_blob != nullptr &&\n+           int_arg_blob != nullptr &&\n+           obj_int_arg_blob != nullptr &&\n+           obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n@@ -2582,0 +2658,21 @@\n+AdapterHandlerEntry* AdapterHandlerLibrary::create_simple_adapter(AdapterBlob*& adapter_blob,\n+                                                                  int total_args_passed,\n+                                                                  BasicType* sig_bt) {\n+  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(total_args_passed, sig_bt);\n+  \/\/ We may find the adapter in the table if it is loaded from the AOT cache\n+  AdapterHandlerEntry* entry = lookup(fp);\n+  if (entry != nullptr) {\n+    assert(entry->is_shared() && !entry->is_linked(), \"Non null AdapterHandlerEntry should be in the AOT cache in unlinked state\");\n+    if (!link_adapter_handler(entry, adapter_blob)) {\n+      if (generate_adapter_code(adapter_blob, entry, total_args_passed, sig_bt, true)) {\n+        return nullptr;\n+      }\n+    }\n+    \/\/ AdapterFingerPrint is already in the cache, no need to keep this one\n+    AdapterFingerPrint::deallocate(fp);\n+  } else {\n+    entry = create_adapter(adapter_blob, fp, total_args_passed, sig_bt, true);\n+  }\n+  return entry;\n+}\n+\n@@ -2588,2 +2685,2 @@\n-  return new AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry,\n-                                 c2i_no_clinit_check_entry);\n+  return AdapterHandlerEntry::allocate(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry,\n+                                       c2i_no_clinit_check_entry);\n@@ -2699,1 +2796,2 @@\n-    entry = lookup(total_args_passed, sig_bt);\n+    AdapterFingerPrint *fp = AdapterFingerPrint::allocate(total_args_passed, sig_bt);\n+    entry = lookup(fp);\n@@ -2705,1 +2803,2 @@\n-        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, false);\n+        AdapterFingerPrint* comparison_fp = AdapterFingerPrint::allocate(total_args_passed, sig_bt);\n+        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, comparison_fp, total_args_passed, sig_bt, false);\n@@ -2708,0 +2807,1 @@\n+        AdapterFingerPrint::deallocate(comparison_fp);\n@@ -2712,0 +2812,1 @@\n+      AdapterFingerPrint::deallocate(fp);\n@@ -2715,1 +2816,1 @@\n-    entry = create_adapter(new_adapter, total_args_passed, sig_bt, \/* allocate_code_blob *\/ true);\n+    entry = create_adapter(new_adapter, fp, total_args_passed, sig_bt, \/* allocate_code_blob *\/ true);\n@@ -2725,6 +2826,10 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& new_adapter,\n-                                                           int total_args_passed,\n-                                                           BasicType* sig_bt,\n-                                                           bool allocate_code_blob) {\n-  if (log_is_enabled(Info, perf, class, link)) {\n-    ClassLoader::perf_method_adapters_count()->inc();\n+bool AdapterHandlerLibrary::lookup_aot_cache(AdapterHandlerEntry* handler, CodeBuffer* buffer) {\n+  ResourceMark rm;\n+  const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n+  const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+  uint32_t offsets[4];\n+  if (SCCache::load_adapter(buffer, id, name, offsets)) {\n+    address i2c_entry = buffer->insts_begin();\n+    assert(offsets[0] == 0, \"sanity check\");\n+    handler->set_entry_points(i2c_entry, i2c_entry + offsets[1], i2c_entry + offsets[2], i2c_entry + offsets[3]);\n+    return true;\n@@ -2732,0 +2837,2 @@\n+  return false;\n+}\n@@ -2733,5 +2840,19 @@\n-  \/\/ StubRoutines::_final_stubs_code is initialized after this function can be called. As a result,\n-  \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated prior\n-  \/\/ to all StubRoutines::_final_stubs_code being set. Checks refer to runtime range checks generated\n-  \/\/ in an I2C stub that ensure that an I2C stub is called from an interpreter frame or stubs.\n-  bool contains_all_checks = StubRoutines::final_stubs_code() != nullptr;\n+#ifndef PRODUCT\n+void AdapterHandlerLibrary::print_adapter_handler_info(AdapterHandlerEntry* handler, AdapterBlob* adapter_blob) {\n+  ttyLocker ttyl;\n+  ResourceMark rm;\n+  int insts_size = adapter_blob->code_size();\n+  handler->print_adapter_on(tty);\n+  tty->print_cr(\"i2c argument handler for: %s %s (%d bytes generated)\",\n+                handler->fingerprint()->as_basic_args_string(),\n+                handler->fingerprint()->as_string(), insts_size);\n+  tty->print_cr(\"c2i argument handler starts at \" INTPTR_FORMAT, p2i(handler->get_c2i_entry()));\n+  if (Verbose || PrintStubCode) {\n+    address first_pc = handler->base_address();\n+    if (first_pc != nullptr) {\n+      Disassembler::decode(first_pc, first_pc + insts_size, tty, &adapter_blob->asm_remarks());\n+      tty->cr();\n+    }\n+  }\n+}\n+#endif \/\/ PRODUCT\n@@ -2739,2 +2860,8 @@\n-  VMRegPair stack_regs[16];\n-  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n+bool AdapterHandlerLibrary::generate_adapter_code(AdapterBlob*& adapter_blob,\n+                                                  AdapterHandlerEntry* handler,\n+                                                  int total_args_passed,\n+                                                  BasicType* sig_bt,\n+                                                  bool allocate_code_blob) {\n+  if (log_is_enabled(Info, perf, class, link)) {\n+    ClassLoader::perf_method_adapters_count()->inc();\n+  }\n@@ -2742,2 +2869,0 @@\n-  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n-  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2748,11 +2873,4 @@\n-                                          sizeof(buffer_locs)\/sizeof(relocInfo));\n-\n-  \/\/ Make a C heap allocated version of the fingerprint to store in the adapter\n-  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);\n-  MacroAssembler _masm(&buffer);\n-  AdapterHandlerEntry* entry = SharedRuntime::generate_i2c2i_adapters(&_masm,\n-                                                total_args_passed,\n-                                                comp_args_on_stack,\n-                                                sig_bt,\n-                                                regs,\n-                                                fingerprint);\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+  MacroAssembler masm(&buffer);\n+  VMRegPair stack_regs[16];\n+  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n@@ -2760,0 +2878,19 @@\n+  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n+  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n+  SharedRuntime::generate_i2c2i_adapters(&masm,\n+                                         total_args_passed,\n+                                         comp_args_on_stack,\n+                                         sig_bt,\n+                                         regs,\n+                                         handler);\n+  if (CDSConfig::is_dumping_adapters()) {\n+    \/\/ try to save generated code\n+    const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n+    const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+    uint32_t offsets[4];\n+    offsets[0] = 0;\n+    offsets[1] = handler->get_c2i_entry() - handler->get_i2c_entry();\n+    offsets[2] = handler->get_c2i_unverified_entry() - handler->get_i2c_entry();\n+    offsets[3] = handler->get_c2i_no_clinit_check_entry() - handler->get_i2c_entry();\n+    SCCache::store_adapter(&buffer, id, name, offsets);\n+  }\n@@ -2762,1 +2899,1 @@\n-    entry->save_code(buf->code_begin(), buffer.insts_size());\n+    handler->save_code(buf->code_begin(), buffer.insts_size());\n@@ -2764,1 +2901,1 @@\n-      return entry;\n+      return true;\n@@ -2769,3 +2906,2 @@\n-  new_adapter = AdapterBlob::create(&buffer);\n-  NOT_PRODUCT(int insts_size = buffer.insts_size());\n-  if (new_adapter == nullptr) {\n+  adapter_blob = AdapterBlob::create(&buffer);\n+  if (adapter_blob == nullptr) {\n@@ -2775,0 +2911,19 @@\n+    return false;\n+  }\n+  handler->relocate(adapter_blob->content_begin());\n+#ifndef PRODUCT\n+  \/\/ debugging support\n+  if (PrintAdapterHandlers || PrintStubCode) {\n+    print_adapter_handler_info(handler, adapter_blob);\n+  }\n+#endif\n+  return true;\n+}\n+\n+AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& adapter_blob,\n+                                                           AdapterFingerPrint* fingerprint,\n+                                                           int total_args_passed,\n+                                                           BasicType* sig_bt,\n+                                                           bool allocate_code_blob) {\n+  AdapterHandlerEntry* handler = AdapterHandlerLibrary::new_entry(fingerprint);\n+  if (!generate_adapter_code(adapter_blob, handler, total_args_passed, sig_bt, allocate_code_blob)) {\n@@ -2777,1 +2932,29 @@\n-  entry->relocate(new_adapter->content_begin());\n+  assert_lock_strong(AdapterHandlerLibrary_lock);\n+  _adapter_handler_table->put(fingerprint, handler);\n+  return handler;\n+}\n+\n+#if INCLUDE_CDS\n+bool AdapterHandlerLibrary::link_adapter_handler(AdapterHandlerEntry* handler, AdapterBlob*& adapter_blob) {\n+#ifndef PRODUCT\n+  if (TestAdapterLinkFailure) {\n+    return false;\n+  }\n+#endif\n+  BufferBlob* buf = buffer_blob(); \/\/ the temporary code buffer in CodeCache\n+  CodeBuffer buffer(buf);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+\n+  if (!lookup_aot_cache(handler, &buffer)) {\n+    return false;\n+  }\n+  adapter_blob = AdapterBlob::create(&buffer);\n+  if (adapter_blob == nullptr) {\n+    \/\/ CodeCache is full, disable compilation\n+    \/\/ Ought to log this but compile log is only per compile thread\n+    \/\/ and we're some non descript Java thread.\n+    return false;\n+  }\n+  handler->relocate(adapter_blob->content_begin());\n@@ -2781,14 +2964,1 @@\n-    ttyLocker ttyl;\n-    entry->print_adapter_on(tty);\n-    tty->print_cr(\"i2c argument handler #%d for: %s %s (%d bytes generated)\",\n-                  _adapter_handler_table->number_of_entries(), fingerprint->as_basic_args_string(),\n-                  fingerprint->as_string(), insts_size);\n-    tty->print_cr(\"c2i argument handler starts at \" INTPTR_FORMAT, p2i(entry->get_c2i_entry()));\n-    if (Verbose || PrintStubCode) {\n-      address first_pc = entry->base_address();\n-      if (first_pc != nullptr) {\n-        Disassembler::decode(first_pc, first_pc + insts_size, tty\n-                             NOT_PRODUCT(COMMA &new_adapter->asm_remarks()));\n-        tty->cr();\n-      }\n-    }\n+    print_adapter_handler_info(handler, adapter_blob);\n@@ -2797,0 +2967,2 @@\n+  return true;\n+}\n@@ -2798,5 +2970,32 @@\n-  \/\/ Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)\n-  \/\/ The checks are inserted only if -XX:+VerifyAdapterCalls is specified.\n-  if (contains_all_checks || !VerifyAdapterCalls) {\n-    assert_lock_strong(AdapterHandlerLibrary_lock);\n-    _adapter_handler_table->put(fingerprint, entry);\n+class CopyAdapterTableToArchive : StackObj {\n+private:\n+  CompactHashtableWriter* _writer;\n+  ArchiveBuilder* _builder;\n+public:\n+  CopyAdapterTableToArchive(CompactHashtableWriter* writer) : _writer(writer),\n+                                                             _builder(ArchiveBuilder::current())\n+  {}\n+\n+  bool do_entry(AdapterFingerPrint* fp, AdapterHandlerEntry* entry) {\n+    LogStreamHandle(Trace, cds) lsh;\n+    if (ArchiveBuilder::current()->has_been_archived((address)entry)) {\n+      assert(ArchiveBuilder::current()->has_been_archived((address)fp), \"must be\");\n+      AdapterFingerPrint* buffered_fp = ArchiveBuilder::current()->get_buffered_addr(fp);\n+      assert(buffered_fp != nullptr,\"sanity check\");\n+      AdapterHandlerEntry* buffered_entry = ArchiveBuilder::current()->get_buffered_addr(entry);\n+      assert(buffered_entry != nullptr,\"sanity check\");\n+\n+      uint hash = fp->compute_hash();\n+      u4 delta = _builder->buffer_to_offset_u4((address)buffered_entry);\n+      _writer->add(hash, delta);\n+      if (lsh.is_enabled()) {\n+        address fp_runtime_addr = (address)buffered_fp + ArchiveBuilder::current()->buffer_to_requested_delta();\n+        address entry_runtime_addr = (address)buffered_entry + ArchiveBuilder::current()->buffer_to_requested_delta();\n+        log_trace(cds)(\"Added fp=%p, entry=%p to the archived adater table\", buffered_fp, buffered_entry);\n+      }\n+    } else {\n+      if (lsh.is_enabled()) {\n+        log_trace(cds)(\"Skipping adapter handler %p as it is not archived\", entry);\n+      }\n+    }\n+    return true;\n@@ -2804,1 +3003,4 @@\n-  return entry;\n+};\n+\n+size_t AdapterHandlerLibrary::estimate_size_for_archive() {\n+  return CompactHashtableWriter::estimate_size(_adapter_handler_table->number_of_entries());\n@@ -2807,0 +3009,13 @@\n+void AdapterHandlerLibrary::archive_adapter_table() {\n+  CompactHashtableStats stats;\n+  CompactHashtableWriter writer(_adapter_handler_table->number_of_entries(), &stats);\n+  CopyAdapterTableToArchive copy(&writer);\n+  _adapter_handler_table->iterate(&copy);\n+  writer.dump(&_archived_adapter_handler_table, \"archived adapter table\");\n+}\n+\n+void AdapterHandlerLibrary::serialize_shared_table_header(SerializeClosure* soc) {\n+  _archived_adapter_handler_table.serialize_header(soc);\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -2831,0 +3046,54 @@\n+void AdapterHandlerEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n+  LogStreamHandle(Trace, cds) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Iter(AdapterHandlerEntry): %p(%s)\", this, _fingerprint->as_basic_args_string());\n+    lsh.cr();\n+  }\n+  it->push(&_fingerprint);\n+}\n+\n+#if INCLUDE_CDS\n+void AdapterHandlerEntry::remove_unshareable_info() {\n+  set_entry_points(nullptr, nullptr, nullptr, nullptr, false);\n+}\n+\n+void AdapterHandlerEntry::restore_unshareable_info(TRAPS) {\n+  PerfTraceElapsedTime timer(ClassLoader::perf_method_adapters_time());\n+  \/\/ A fixed set of simple adapters are eagerly linked during JVM initialization\n+  \/\/ in AdapterHandlerTable::initialize().\n+  \/\/ Others may already have been linked because they are shared by other methods.\n+  if (is_linked()) {\n+    return;\n+  }\n+  AdapterBlob* adapter_blob = nullptr;\n+  {\n+    MutexLocker mu(AdapterHandlerLibrary_lock);\n+    assert(_fingerprint != nullptr, \"_fingerprint must not be null\");\n+#ifdef ASSERT\n+    AdapterHandlerEntry* entry = AdapterHandlerLibrary::lookup(_fingerprint);\n+    assert(entry == this, \"sanity check\");\n+#endif\n+    if (!AdapterHandlerLibrary::link_adapter_handler(this, adapter_blob)) {\n+      ResourceMark rm;\n+      log_warning(cds)(\"Failed to link AdapterHandlerEntry to its code in the AOT code cache\");\n+      int nargs;\n+      BasicType* bt = _fingerprint->as_basic_type(nargs);\n+      if (!AdapterHandlerLibrary::generate_adapter_code(adapter_blob, this, nargs, bt, true)) {\n+        if (!is_init_completed()) {\n+          \/\/ Don't throw exceptions during VM initialization because java.lang.* classes\n+          \/\/ might not have been initialized, causing problems when constructing the\n+          \/\/ Java exception object.\n+          vm_exit_during_initialization(\"Out of space in CodeCache for adapters\");\n+        } else {\n+          THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), \"Out of space in CodeCache for adapters\");\n+        }\n+      }\n+    }\n+  }\n+  \/\/ Outside of the lock\n+  if (adapter_blob != nullptr) {\n+    post_adapter_creation(adapter_blob, this);\n+  }\n+  assert(_linked, \"AdapterHandlerEntry must now be linked\");\n+}\n+#endif \/\/ INCLUDE_CDS\n@@ -2833,1 +3102,0 @@\n-  delete _fingerprint;\n@@ -3149,0 +3417,9 @@\n+const char* AdapterHandlerLibrary::name(AdapterFingerPrint* fingerprint) {\n+  return fingerprint->as_basic_args_string();\n+}\n+\n+uint32_t AdapterHandlerLibrary::id(AdapterFingerPrint* fingerprint) {\n+  unsigned int hash = fingerprint->compute_hash();\n+  return hash;\n+}\n+\n@@ -3183,0 +3460,7 @@\n+bool AdapterHandlerLibrary::is_abstract_method_adapter(AdapterHandlerEntry* entry) {\n+  if (entry == _abstract_method_handler) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":445,"deletions":161,"binary":false,"changes":606,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/compactHashtable.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"memory\/metaspaceClosure.hpp\"\n@@ -119,0 +121,1 @@\n+  static void init_adapter_library();\n@@ -469,6 +472,6 @@\n-  static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *_masm,\n-                                                      int total_args_passed,\n-                                                      int max_arg,\n-                                                      const BasicType *sig_bt,\n-                                                      const VMRegPair *regs,\n-                                                      AdapterFingerPrint* fingerprint);\n+  static void generate_i2c2i_adapters(MacroAssembler *_masm,\n+                               int total_args_passed,\n+                               int max_arg,\n+                               const BasicType *sig_bt,\n+                               const VMRegPair *regs,\n+                               AdapterHandlerEntry* handler);\n@@ -677,1 +680,1 @@\n-class AdapterHandlerEntry : public CHeapObj<mtCode> {\n+class AdapterHandlerEntry : public MetaspaceObj {\n@@ -686,0 +689,1 @@\n+  bool    _linked;\n@@ -701,1 +705,2 @@\n-    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry)\n+    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry),\n+    _linked(false)\n@@ -710,0 +715,16 @@\n+  static AdapterHandlerEntry* allocate(AdapterFingerPrint* fingerprint,\n+                                       address i2c_entry,\n+                                       address c2i_entry,\n+                                       address c2i_unverified_entry,\n+                                       address c2i_no_clinit_check_entry)\n+  {\n+    return new (mtCode) AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  }\n+  void set_entry_points(address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry, bool linked = true) {\n+    _i2c_entry = i2c_entry;\n+    _c2i_entry = c2i_entry;\n+    _c2i_unverified_entry = c2i_unverified_entry;\n+    _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;\n+    _linked = linked;\n+  }\n+\n@@ -715,0 +736,1 @@\n+  bool is_linked() const { return _linked; }\n@@ -728,0 +750,7 @@\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  int size() const {return (int)heap_word_size(sizeof(AdapterHandlerEntry)); }\n+  MetaspaceObj::Type type() const { return AdapterHandlerEntryType; }\n+\n+  void remove_unshareable_info() NOT_CDS_RETURN;\n+  void restore_unshareable_info(TRAPS) NOT_CDS_RETURN;\n@@ -730,0 +759,4 @@\n+#if INCLUDE_CDS\n+class ArchivedAdapterTable;\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -740,1 +773,3 @@\n-\n+#if INCLUDE_CDS\n+  static ArchivedAdapterTable _archived_adapter_handler_table;\n+#endif \/\/ INCLUDE_CDS\n@@ -743,0 +778,5 @@\n+  static AdapterHandlerEntry* create_simple_adapter(AdapterBlob*& new_adapter,\n+                                                    int total_args_passed,\n+                                                    BasicType* sig_bt);\n+  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n+  static bool lookup_aot_cache(AdapterHandlerEntry* handler, CodeBuffer* buffer);\n@@ -744,0 +784,1 @@\n+                                             AdapterFingerPrint* fingerprint,\n@@ -747,1 +788,3 @@\n-  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n+#ifndef PRODUCT\n+  static void print_adapter_handler_info(AdapterHandlerEntry* handler, AdapterBlob* adapter_blob);\n+#endif \/\/ PRODUCT\n@@ -751,3 +794,3 @@\n-                                        address i2c_entry,\n-                                        address c2i_entry,\n-                                        address c2i_unverified_entry,\n+                                        address i2c_entry = nullptr,\n+                                        address c2i_entry = nullptr,\n+                                        address c2i_unverified_entry = nullptr,\n@@ -757,0 +800,6 @@\n+  static AdapterHandlerEntry* lookup(AdapterFingerPrint* fp);\n+  static bool generate_adapter_code(AdapterBlob*& adapter_blob,\n+                                    AdapterHandlerEntry* handler,\n+                                    int total_args_passed,\n+                                    BasicType* sig_bt,\n+                                    bool allocate_code_blob);\n@@ -761,0 +810,2 @@\n+  static const char* name(AdapterFingerPrint* fingerprint);\n+  static uint32_t id(AdapterFingerPrint* fingerprint);\n@@ -765,0 +816,9 @@\n+  static bool is_abstract_method_adapter(AdapterHandlerEntry* adapter);\n+\n+  static bool link_adapter_handler(AdapterHandlerEntry* handler, AdapterBlob*& adapter_blob) NOT_CDS_RETURN_(false);\n+  static size_t estimate_size_for_archive() NOT_CDS_RETURN_(0);\n+  static void archive_adapter_table() NOT_CDS_RETURN;\n+  static void serialize_shared_table_header(SerializeClosure* soc) NOT_CDS_RETURN;\n+  static bool EQUALS(AdapterHandlerEntry* entry, AdapterFingerPrint* fp, int len_unused) {\n+    return entry->fingerprint() == fp;\n+  }\n@@ -767,0 +827,7 @@\n+#if INCLUDE_CDS\n+class ArchivedAdapterTable : public OffsetCompactHashtable<\n+  AdapterFingerPrint*,\n+  AdapterHandlerEntry*,\n+  AdapterHandlerLibrary::EQUALS> {};\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":80,"deletions":13,"binary":false,"changes":93,"status":"modified"}]}