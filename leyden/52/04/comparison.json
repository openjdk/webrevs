{"files":[{"patch":"@@ -101,0 +101,1 @@\n+#include \"services\/management.hpp\"\n@@ -118,0 +119,1 @@\n+jlong MetaspaceShared::_preimage_static_archive_recording_duration = 0;\n@@ -976,0 +978,11 @@\n+jlong MetaspaceShared::get_preimage_static_archive_recording_duration() {\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    if (_preimage_static_archive_recording_duration == 0) {\n+      \/\/ The recording has not yet finished so return the current elapsed time.\n+      return Management::ticks_to_ms(os::elapsed_counter());\n+    }\n+    return _preimage_static_archive_recording_duration;\n+  }\n+  return 0;\n+}\n+\n@@ -981,0 +994,1 @@\n+    _preimage_static_archive_recording_duration = Management::ticks_to_ms(os::elapsed_counter());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  static jlong _preimage_static_archive_recording_duration;\n@@ -119,0 +120,1 @@\n+  static jlong get_preimage_static_archive_recording_duration() NOT_CDS_RETURN_(0);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jboolean JNICALL\n@@ -96,0 +96,6 @@\n+JNIEXPORT jstring JNICALL\n+JVM_AOTGetMode(JNIEnv *env);\n+\n+JNIEXPORT jlong JNICALL\n+JVM_AOTGetRecordingDuration(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-JVM_ENTRY_PROF(void, JVM_AOTEndTraining, JVM_AOTEndTraining(JNIEnv *env))\n+JVM_ENTRY_PROF(jboolean, JVM_AOTEndTraining, JVM_AOTEndTraining(JNIEnv *env))\n@@ -245,0 +245,1 @@\n+    return JNI_TRUE;\n@@ -246,0 +247,22 @@\n+  return JNI_FALSE;\n+#else\n+  return JNI_FALSE;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY_PROF(jstring, JVM_AOTGetMode, JVM_AOTGetMode(JNIEnv *env))\n+  HandleMark hm(THREAD);\n+#if INCLUDE_CDS\n+  const char* mode = AOTMode == nullptr ? \"auto\" : AOTMode;\n+  Handle h = java_lang_String::create_from_platform_dependent_str(mode, CHECK_NULL);\n+  return (jstring) JNIHandles::make_local(THREAD, h());\n+#else\n+  return nullptr;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_LEAF_PROF(jlong, JVM_AOTGetRecordingDuration, JVM_AOTGetRecordingDuration(JNIEnv *env))\n+#if INCLUDE_CDS\n+  return MetaspaceShared::get_preimage_static_archive_recording_duration();\n+#else\n+  return 0;\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -51,0 +51,6 @@\n+    \/\/ AOT Subsytem\n+    public String  getAOTMode();\n+    public boolean isAOTRecording();\n+    public long    getAOTRecordingDuration();\n+    public boolean endAOTRecording();\n+\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagement.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -120,0 +120,6 @@\n+    \/\/ AOT Subsystem\n+    public native String  getAOTMode();\n+    public native boolean isAOTRecording();\n+    public native long    getAOTRecordingDuration();\n+    public native boolean endAOTRecording();\n+\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,0 +104,28 @@\n+JNIEXPORT jstring JNICALL\n+Java_sun_management_VMManagementImpl_getAOTMode\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return JVM_AOTGetMode(env);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_management_VMManagementImpl_isAOTRecording\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return JVM_AOTIsTraining(env);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getAOTRecordingDuration\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return JVM_AOTGetRecordingDuration(env);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_management_VMManagementImpl_endAOTRecording\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return JVM_AOTEndTraining(env);\n+}\n+\n","filename":"src\/java.management\/share\/native\/libmanagement\/VMManagementImpl.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.management.internal;\n+\n+import javax.management.ObjectName;\n+import jdk.management.AOTCacheMXBean;\n+import sun.management.Util;\n+import sun.management.VMManagement;\n+\n+\/**\n+  * Implementation class for the AOT Cache subsystem.\n+  *\n+  * ManagementFactory.getRuntimeMXBean() returns an instance\n+  * of this class.\n+  *\/\n+public class AOTCacheImpl implements AOTCacheMXBean {\n+\n+    private final VMManagement jvm;\n+    \/**\n+      * Constructor of AOTCacheImpl class.\n+      *\/\n+      AOTCacheImpl(VMManagement vm) {\n+         this.jvm = vm;\n+     }\n+\n+     public String getMode() {\n+         return jvm.getAOTMode();\n+     }\n+\n+     public boolean isRecording() {\n+         return jvm.isAOTRecording();\n+     }\n+\n+     public long getRecordingDuration(){\n+         return jvm.getAOTRecordingDuration();\n+     }\n+\n+     public boolean endRecording(){\n+         return jvm.endAOTRecording();\n+     }\n+\n+     public ObjectName getObjectName() {\n+         return Util.newObjectName(\"jdk.management:type=AOTCache\");\n+     }\n+}\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/AOTCacheImpl.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.management.AOTCacheMXBean;\n@@ -162,0 +163,35 @@\n+        \/**\n+        * AOTCacheMXBean.\n+        *\/\n+        initMBeanList.add(new PlatformComponent<AOTCacheMXBean>() {\n+            private final Set<Class<? extends AOTCacheMXBean>> mbeanInterfaces =\n+                    Set.of(AOTCacheMXBean.class);\n+            private final Set<String> mbeanInterfaceNames =\n+                    Set.of(AOTCacheMXBean.class.getName());\n+            private AOTCacheMXBean impl;\n+\n+            @Override\n+            public Set<Class<? extends AOTCacheMXBean>> mbeanInterfaces() {\n+                return mbeanInterfaces;\n+            }\n+\n+            @Override\n+            public Set<String> mbeanInterfaceNames() {\n+                return mbeanInterfaceNames;\n+            }\n+\n+            @Override\n+            public String getObjectNamePattern() {\n+                return \"jdk.management:type=AOTCache\";\n+            }\n+\n+            @Override\n+            public Map<String, AOTCacheMXBean> nameToMBeanMap() {\n+                AOTCacheMXBean impl = this.impl;\n+                if (impl == null) {\n+                    this.impl = impl = new AOTCacheImpl(ManagementFactoryHelper.getVMManagement());\n+                }\n+                return Map.of(\"jdk.management:type=AOTCache\", impl);\n+            }\n+        });\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.management;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.PlatformManagedObject;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.management.MBeanServer;\n+import javax.management.ObjectName;\n+\n+\/**\n+ * Management interface for the JDK's AOT system.\n+ *\n+ * <p> {@code AOTCacheMXBean} supports inspection of the current AOT mode, as well as monitoring\n+ * the current recording length. It also supports dynamically ending the current recording.\n+ *\n+ * <p> The management interface is registered with the platform {@link MBeanServer\n+ * MBeanServer}. The {@link ObjectName ObjectName} that uniquely identifies the management\n+ * interface within the {@code MBeanServer} is: \"jdk.management:type=AOTCache\".\n+ *\n+ * <p> Direct access to the MXBean interface can be obtained with\n+ * {@link ManagementFactory#getPlatformMXBean(Class)}.\n+ *\n+ * @since 25\n+ *\/\n+public interface AOTCacheMXBean extends PlatformManagedObject {\n+     \/**\n+      * Returns the string representing the current AOT mode of\n+      * operation.\n+      *\n+      * @return the string representing the current AOT mode.\n+      *\/\n+      public String getMode();\n+\n+      \/**\n+       * Tests if a recording is in progress.\n+       *\n+       * @return {@code true} if a recording is in progress; {@code false} otherwise.\n+       *\/\n+      public boolean isRecording();\n+\n+      \/**\n+       * If a recording is in progress or has been completed, then returns the duration in milliseconds\n+       *\n+       * @return duration of the recording in milliseconds.\n+       *\/\n+      public long getRecordingDuration();\n+\n+      \/**\n+       * If a recording is in progress, then ends the recording.\n+       *\n+       * @return {@code true} if a recording was stopped; {@code false} otherwise.\n+       *\/\n+      public boolean endRecording();\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.management\/share\/classes\/jdk\/management\/AOTCacheMXBean.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=aot\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @modules java.management\n+ * @build EndTrainingWithAOTCacheMXBean\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar MyTestApp ShouldBeCached ShouldNotBeCached\n+ * @run driver EndTrainingWithAOTCacheMXBean AOT\n+ *\/\n+\n+\/*\n+ * @test id=leyden\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @modules jdk.management\n+ * @build EndTrainingWithAOTCacheMXBean\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar MyTestApp ShouldBeCached ShouldNotBeCached\n+ * @run driver EndTrainingWithAOTCacheMXBean LEYDEN\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.lang.management.ManagementFactory;\n+import jdk.management.AOTCacheMXBean;\n+\n+public class EndTrainingWithAOTCacheMXBean {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"MyTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ We want to test the entry count implementation in both interpreter and compiler.\n+        new Tester().run(args);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:cds+class=debug\",\n+                \"--add-modules=jdk.management\"\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass, runMode.name(),\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            var name = runMode.name();\n+            if (runMode.isApplicationExecuted()) {\n+                out.shouldContain(\"Hello Leyden \" + name);\n+                out.shouldContain(\"ShouldBeCached.dummy()\");\n+                out.shouldContain(\"ShouldNotBeCached.dummy()\");\n+                if(runMode == RunMode.TRAINING || runMode == RunMode.TRAINING0) {\n+                    if (isLeydenWorkflow()) {\n+                        out.shouldContain(\"AOTMode = auto\");\n+                    } else {\n+                        out.shouldContain(\"AOTMode = record\");\n+                    }\n+                    out.shouldContain(\"Confirmed is recording\");\n+                    out.shouldContain(\"Confirmed recording duration > 0\");\n+                    out.shouldContain(\"Stopped recording successfully after an additional 10ms\");\n+                    out.shouldContain(\"Last recording duration > than previous duration\");\n+                    out.shouldContain(\"Confirmed recording stopped\");\n+                    out.shouldContain(\"Confirmed recording duration has not changed after 10ms\");\n+                } else if (runMode == RunMode.TRAINING1 || runMode == RunMode.ASSEMBLY) {\n+                    out.shouldNotContain(\"Hello Leyden \");\n+                } else if (runMode == RunMode.PRODUCTION) {\n+                    if (isLeydenWorkflow()) {\n+                        out.shouldContain(\"AOTMode = auto\");\n+                    } else {\n+                        out.shouldContain(\"AOTMode = on\");\n+                    }\n+                    out.shouldContain(\"Confirmed is not recording\");\n+                    out.shouldContain(\"Confirmed recording duration == 0\");\n+                }\n+                out.shouldNotContain(\"Thread interrupted\");\n+                out.shouldNotContain(\"Failed to stop recording\");\n+            }\n+            if (isDumping(runMode)) {\n+                out.shouldMatch(\"cds,class.* ShouldBeCached\");\n+                out.shouldNotMatch(\"cds,class.* ShouldNotBeCached\");\n+            }\n+        }\n+    }\n+}\n+\n+class MyTestApp {\n+    public static void main(String args[]) throws Exception {\n+        System.out.println(\"Hello Leyden \" + args[0]);\n+        var aotBean = ManagementFactory.getPlatformMXBean(AOTCacheMXBean.class);\n+        if (aotBean == null) {\n+            System.out.println(\"AOTCacheMXBean is not available\");\n+            return;\n+        }\n+        ShouldBeCached.dummy();\n+        System.out.println(\"AOTMode = \" + aotBean.getMode());\n+        if (aotBean.isRecording()) {\n+            try {\n+                System.out.println(\"Confirmed is recording\");\n+                var initialDuration = aotBean.getRecordingDuration();\n+                System.out.println(\"Confirmed recording duration > 0\");\n+                Thread.sleep(10);\n+                if (aotBean.endRecording()) {\n+                    System.out.println(\"Stopped recording successfully after an additional 10ms\");\n+                    if (!aotBean.isRecording()) {\n+                        System.out.println(\"Confirmed recording stopped\");\n+                    }\n+                    var recordingDuration = aotBean.getRecordingDuration();\n+                    if (recordingDuration > initialDuration) {\n+                        System.out.println(\"Last recording duration > than previous duration\");\n+                    }\n+                    Thread.sleep(10);\n+                    var lastDuration = aotBean.getRecordingDuration();\n+                    if (lastDuration == recordingDuration) {\n+                        System.out.println(\"Confirmed recording duration has not changed after 10ms\");\n+                    }\n+                } else {\n+                    System.out.println(\"Failed to stop recording\");\n+                }\n+            } catch (InterruptedException e) {\n+                System.out.println(\"Thread interrupted\");\n+            }\n+        } else {\n+            System.out.println(\"Confirmed is not recording\");\n+            var recordingDuration = aotBean.getRecordingDuration();\n+            if (recordingDuration == 0) {\n+                System.out.println(\"Confirmed recording duration == 0\");\n+            }\n+        }\n+        ShouldNotBeCached.dummy();\n+    }\n+}\n+\n+class ShouldBeCached {\n+    static void dummy() {\n+        System.out.println(\"ShouldBeCached.dummy()\");\n+    }\n+}\n+\n+class ShouldNotBeCached {\n+    static void dummy() {\n+        System.out.println(\"ShouldNotBeCached.dummy()\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/leyden\/EndTrainingWithAOTCacheMXBean.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}