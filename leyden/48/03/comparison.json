{"files":[{"patch":"@@ -4459,0 +4459,19 @@\n+\n+void SCCache::block_loading(Method* method, CompLevel comp_level) {\n+  SCCache* cache = open_for_read();\n+  if (cache == nullptr) {\n+    return;\n+  }\n+\n+  ReadingMark rdmk;\n+  if (rdmk.failed()) {\n+    \/\/ Cache is closed, cannot touch anything.\n+    return;\n+  }\n+\n+  Thread* current = Thread::current();\n+  HandleMark hm(current);\n+  methodHandle mh(current, method);\n+  SCCEntry* scc_entry = cache->find_code_entry(mh, comp_level);\n+  cache->invalidate_entry(scc_entry);\n+}\n","filename":"src\/hotspot\/share\/code\/SCCache.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -555,0 +555,2 @@\n+  static void block_loading(Method* method, CompLevel comp_level);\n+\n","filename":"src\/hotspot\/share\/code\/SCCache.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2078,0 +2078,9 @@\n+    if (preloaded() && method() != nullptr) {\n+      \/\/ Preload code was decompiled, possibly due to a trap. Preload code should not\n+      \/\/ normally have traps, but some are still there. Since preload code is compiled\n+      \/\/ more conservatively, we assume that non-preload code would trap again in similar\n+      \/\/ conditions. Therefore, there is no point in trying to load it. Instead, wait for\n+      \/\/ normal compilation to occur.\n+      SCCache::block_loading(method(), CompLevel_full_optimization);\n+    }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}