{"files":[{"patch":"@@ -42,1 +42,0 @@\n-  CompLevel _search_level;\n@@ -48,2 +47,2 @@\n-  PrecompileIterator(CompLevel comp_level, bool for_preload, CompLevel search_level, JavaThread* thread)\n-  : _comp_level(comp_level), _search_level(search_level), _for_preload(for_preload), _thread(thread) {\n+  PrecompileIterator(CompLevel comp_level, bool for_preload, JavaThread* thread)\n+  : _comp_level(comp_level), _for_preload(for_preload), _thread(thread) {\n@@ -59,2 +58,3 @@\n-      return false; \/\/ excluded\n-    } else if (directives->PrecompileRecordedOption > 0) {\n+      return false;\n+    }\n+    if (directives->PrecompileRecordedOption > 0) {\n@@ -63,2 +63,19 @@\n-    int cid = compile_id(m, _search_level);\n-    return (cid < INT_MAX);\n+    int high_top_level = highest_top_level(m);\n+    switch (_comp_level) {\n+      case CompLevel_simple:\n+      case CompLevel_full_optimization:\n+        \/\/ For final C1\/C2 compilations, we only compile when there was relevant compilation during training.\n+        return _comp_level == high_top_level;\n+      case CompLevel_limited_profile:\n+        \/\/ For profiled C1 compilations, generate limited profile when there was limited\/full\n+        \/\/ profiled compilation in training.\n+        return CompLevel_limited_profile <= high_top_level && high_top_level <= CompLevel_full_profile;\n+      case CompLevel_full_profile:\n+        \/\/ We do not include C1 full profiled methods at this time.\n+        \/\/ TODO: See if it is profitable to do so.\n+        return false;\n+      default:\n+        assert(false, \"Missed the case: %d\", _comp_level);\n+    }\n+    \/\/ Do not include methods by default.\n+    return false;\n@@ -79,2 +96,2 @@\n-      if (mtd->has_holder() && include((Method*)mtd->holder())) {\n-        _methods.push((Method*)mtd->holder());\n+      if (mtd->has_holder() && include(mtd->holder())) {\n+        _methods.push(mtd->holder());\n@@ -85,7 +102,3 @@\n-  static int compile_id(Method* m, int level) {\n-    MethodTrainingData* mtd = m->method_holder()->is_loaded() ? MethodTrainingData::find(methodHandle(Thread::current(), m)) : nullptr;\n-    if (mtd != nullptr && mtd->highest_level() == level) {\n-      CompileTrainingData* ctd = mtd->last_toplevel_compile(level);\n-      if (ctd != nullptr) {\n-        return ctd->compile_id();\n-      }\n+  static MethodTrainingData* method_training_data(Method* m) {\n+    if (m->method_holder()->is_loaded()) {\n+      return MethodTrainingData::find(methodHandle(Thread::current(), m));\n@@ -93,15 +106,1 @@\n-    return INT_MAX; \/\/ treat as the last compilation\n-  }\n-\n-  static int compare_by_compile_id(Method** m1, Method** m2, CompLevel comp_level) {\n-    int id1 = compile_id(*m1, comp_level);\n-    int id2 = compile_id(*m2, comp_level);\n-    return (id1 - id2);\n-  }\n-\n-  static int compare_by_compile_id_tier1(Method** m1, Method** m2) {\n-    return compare_by_compile_id(m1, m2, CompLevel_simple);\n-  }\n-\n-  static int compare_by_compile_id_tier2(Method** m1, Method** m2) {\n-    return compare_by_compile_id(m1, m2, CompLevel_limited_profile);\n+    return nullptr;\n@@ -110,2 +109,6 @@\n-  static int compare_by_compile_id_tier3(Method** m1, Method** m2) {\n-    return compare_by_compile_id(m1, m2, CompLevel_full_profile);\n+  static int highest_top_level(Method* m) {\n+    MethodTrainingData* mtd = method_training_data(m);\n+    if (mtd != nullptr) {\n+      return mtd->highest_top_level();\n+    }\n+    return 0;\n@@ -114,2 +117,11 @@\n-  static int compare_by_compile_id_tier4(Method** m1, Method** m2) {\n-    return compare_by_compile_id(m1, m2, CompLevel_full_optimization);\n+  \/\/ We sort methods by compile ID, presuming the methods that compiled earlier\n+  \/\/ are more important. This only matters for preload code, which is loaded\n+  \/\/ asynchronously; other levels are sorted for better consistency between training\n+  \/\/ runs. Since we can accept methods from multiple levels, we use the compile ID\n+  \/\/ from the lowest level.\n+  static int compare_methods(Method** m1, Method** m2) {\n+    int c1 = compile_id(*m1);\n+    int c2 = compile_id(*m2);\n+    if (c1 < c2) return -1;\n+    if (c1 > c2) return +1;\n+    return 0;\n@@ -118,8 +130,11 @@\n-  void sort_methods_by_compile_id() {\n-    switch(_search_level) {\n-      case CompLevel_simple:            _methods.sort(&compare_by_compile_id_tier1); break;\n-      case CompLevel_limited_profile:   _methods.sort(&compare_by_compile_id_tier2); break;\n-      case CompLevel_full_profile:      _methods.sort(&compare_by_compile_id_tier3); break;\n-      case CompLevel_full_optimization: _methods.sort(&compare_by_compile_id_tier4); break;\n-\n-      default: fatal(\"%d\", _search_level);\n+  static int compile_id(Method* m) {\n+    \/\/ Methods without recorded compilations are treated as \"compiled last\"\n+    int id = INT_MAX;\n+    MethodTrainingData* mtd = method_training_data(m);\n+    if (mtd != nullptr) {\n+      for (int level = CompLevel_simple; level <= CompilationPolicy::highest_compile_level(); level++) {\n+        CompileTrainingData* ctd = mtd->last_toplevel_compile(level);\n+        if (ctd != nullptr) {\n+          id = MIN2(id, ctd->compile_id());\n+        }\n+      }\n@@ -127,0 +142,1 @@\n+    return id;\n@@ -169,1 +185,1 @@\n-        log.print(\"] [%d] (%s)\", AOTCodeCache::store_entries_cnt(), (is_success ? \"success\" : \"FAILED\"));\n+        log.print(\"] {%d} [%d] (%s)\", compile_id(m), AOTCodeCache::store_entries_cnt(), (is_success ? \"success\" : \"FAILED\"));\n@@ -178,1 +194,1 @@\n-    sort_methods_by_compile_id();\n+    _methods.sort(&compare_methods);\n@@ -185,1 +201,1 @@\n-void Precompiler::compile_aot_code(CompLevel search_level, bool for_preload, CompLevel comp_level, TRAPS) {\n+void Precompiler::compile_aot_code(CompLevel comp_level, bool for_preload, TRAPS) {\n@@ -187,1 +203,1 @@\n-  PrecompileIterator pi(comp_level, for_preload, search_level, THREAD);\n+  PrecompileIterator pi(comp_level, for_preload, THREAD);\n@@ -217,2 +233,6 @@\n-    if (ClassInitBarrierMode > 0) { \/\/ Preload code is enabled\n-      compile_aot_code(CompLevel_full_optimization, true, CompLevel_full_optimization, CHECK);\n+    CompLevel highest_level = CompilationPolicy::highest_compile_level();\n+    if (highest_level >= CompLevel_full_optimization && ClassInitBarrierMode > 0) {\n+      compile_aot_code(CompLevel_full_optimization, true, CHECK);\n+    }\n+    for (int level = CompLevel_simple; level <= highest_level; level++) {\n+      compile_aot_code((CompLevel)level, false, CHECK);\n@@ -220,4 +240,0 @@\n-    compile_aot_code(CompLevel_full_optimization, false, CompLevel_full_optimization, CHECK);\n-    compile_aot_code(CompLevel_full_profile,      false, CompLevel_limited_profile,   CHECK);\n-    compile_aot_code(CompLevel_limited_profile,   false, CompLevel_limited_profile,   CHECK);\n-    compile_aot_code(CompLevel_simple,            false, CompLevel_simple,            CHECK);\n@@ -234,1 +250,1 @@\n-      PrecompileIterator pi(CompLevel_full_optimization, true \/*for_preload*\/, CompLevel_full_optimization, THREAD);\n+      PrecompileIterator pi(CompLevel_full_optimization, true \/*for_preload*\/, THREAD);\n@@ -240,5 +256,1 @@\n-      CompLevel comp_level = (CompLevel)level;\n-      if (comp_level == CompLevel_full_profile) {\n-        comp_level = CompLevel_limited_profile;\n-      }\n-      PrecompileIterator pi(comp_level, false \/*for_preload*\/, (CompLevel)level, THREAD);\n+      PrecompileIterator pi((CompLevel)level, false \/*for_preload*\/, THREAD);\n","filename":"src\/hotspot\/share\/compiler\/precompiler.cpp","additions":71,"deletions":59,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  static void compile_aot_code(CompLevel search_level, bool for_preload, CompLevel comp_level, TRAPS);\n+  static void compile_aot_code(CompLevel comp_level, bool for_preload, TRAPS);\n","filename":"src\/hotspot\/share\/compiler\/precompiler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}