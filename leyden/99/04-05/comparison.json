{"files":[{"patch":"@@ -36,1 +36,0 @@\n-#include \"oops\/methodCounters.hpp\"\n@@ -97,2 +96,2 @@\n-      if (mtd->has_holder() && include((Method*)mtd->holder())) {\n-        _methods.push((Method*)mtd->holder());\n+      if (mtd->has_holder() && include(mtd->holder())) {\n+        _methods.push(mtd->holder());\n@@ -118,2 +117,16 @@\n-  static size_t counts(Method* m) {\n-    size_t count = 0;\n+  \/\/ We sort methods by compile ID, presuming the methods that compiled earlier\n+  \/\/ are more important. This only matters for preload code, which is loaded\n+  \/\/ asynchronously; other levels are sorted for better consistency between training\n+  \/\/ runs. Since we can accept methods from multiple levels, we use the compile ID\n+  \/\/ from the lowest level.\n+  static int compare_methods(Method** m1, Method** m2) {\n+    int c1 = compile_id(*m1);\n+    int c2 = compile_id(*m2);\n+    if (c1 < c2) return -1;\n+    if (c1 > c2) return +1;\n+    return 0;\n+  }\n+\n+  static int compile_id(Method* m) {\n+    \/\/ Methods without recorded compilations are treated as \"compiled last\"\n+    int id = INT_MAX;\n@@ -122,9 +135,5 @@\n-      MethodData* md = mtd->final_profile();\n-      if (md != nullptr) {\n-        count += md->backedge_count();\n-        count += md->invocation_count();\n-      }\n-      MethodCounters* mc = mtd->final_counters();\n-      if (mc != nullptr) {\n-        count += mc->invocation_count();\n-        count += mc->backedge_count();\n+      for (int level = CompLevel_simple; level <= CompilationPolicy::highest_compile_level(); level++) {\n+        CompileTrainingData* ctd = mtd->last_toplevel_compile(level);\n+        if (ctd != nullptr) {\n+          id = MIN2(id, ctd->compile_id());\n+        }\n@@ -133,16 +142,1 @@\n-    return count;\n-  }\n-\n-  static int compare_methods(Method** m1, Method** m2) {\n-    \/\/ Hottest methods go first.\n-    size_t c1 = counts(*m1);\n-    size_t c2 = counts(*m2);\n-    if (c1 > c2) return -1;\n-    if (c1 < c2) return +1;\n-\n-    \/\/ Otherwise, break the tie by code size: largest methods go first.\n-    size_t s1 = (*m1)->code_size();\n-    size_t s2 = (*m2)->code_size();\n-    if (s1 > s2) return -1;\n-    if (s1 < s2) return +1;\n-    return 0;\n+    return id;\n@@ -191,1 +185,1 @@\n-        log.print(\"] {%zu} [%d] (%s)\", counts(m), AOTCodeCache::store_entries_cnt(), (is_success ? \"success\" : \"FAILED\"));\n+        log.print(\"] {%d} [%d] (%s)\", compile_id(m), AOTCodeCache::store_entries_cnt(), (is_success ? \"success\" : \"FAILED\"));\n","filename":"src\/hotspot\/share\/compiler\/precompiler.cpp","additions":25,"deletions":31,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -133,14 +133,0 @@\n-  int invocation_count() {\n-    if (invocation_counter()->carry()) {\n-      return InvocationCounter::count_limit;\n-    }\n-    return invocation_counter()->count();\n-  }\n-\n-  int backedge_count() {\n-    if (backedge_counter()->carry()) {\n-      return InvocationCounter::count_limit;\n-    }\n-    return backedge_counter()->count();\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/methodCounters.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -786,1 +786,0 @@\n-  MethodCounters* final_counters() const { return _final_counters; }\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}