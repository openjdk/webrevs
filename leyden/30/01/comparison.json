{"files":[{"patch":"@@ -420,2 +420,6 @@\n-  while (!_queue.empty()) {\n-    CompileTask* task = _queue.pop();\n+\n+  bool added_stale_tasks = false;\n+  bool added_new_tasks = false;\n+\n+  CompileTask* task;\n+  while ((task = _queue.pop()) != nullptr) {\n@@ -427,0 +431,1 @@\n+      added_stale_tasks = true;\n@@ -429,0 +434,1 @@\n+      added_new_tasks = true;\n@@ -431,0 +437,12 @@\n+\n+  if (added_stale_tasks && !added_new_tasks) {\n+    \/\/ We have added stale tasks. There might be waiters that want\n+    \/\/ the notification these tasks have failed. Normally, this would\n+    \/\/ be done by a compiler thread that would perform the purge at\n+    \/\/ the end of some compilation. But, if we never added any tasks,\n+    \/\/ there is no guarantee compilers would run and do the purge.\n+    \/\/ Do the purge here and now to unblock the waiters.\n+    \/\/ NOTE: The call below recurses back to this method, unless\n+    \/\/ we explicitly ask it not to.\n+    purge_stale_tasks(\/* do_transfer_pending = *\/ false);\n+  }\n@@ -544,1 +562,1 @@\n-void CompileQueue::purge_stale_tasks() {\n+void CompileQueue::purge_stale_tasks(bool do_transfer_pending) {\n@@ -562,1 +580,3 @@\n-    transfer_pending(); \/\/ transfer pending after reacquiring MCQ lock\n+    if (do_transfer_pending) {\n+      transfer_pending(); \/\/ transfer pending after reacquiring MCQ lock\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  void purge_stale_tasks();\n+  void purge_stale_tasks(bool do_transfer_pending = true);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}