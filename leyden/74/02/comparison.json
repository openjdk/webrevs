{"files":[{"patch":"@@ -206,4 +206,17 @@\n-   MonitorLocker locker(THREAD, TrainingReplayQueue_lock);\n-   while (!_training_replay_queue.is_empty_unlocked()) {\n-     locker.wait(); \/\/ let the replay training thread drain the queue\n-   }\n+  if (!TrainingData::have_data()) {\n+    \/\/ No training data, nothing to do.\n+    return;\n+  }\n+  TrainingReplayThread* replay_thread = TrainingReplayThread::instance();\n+  assert(replay_thread != nullptr, \"Should be present\");\n+  replay_thread->set_should_terminate();\n+\n+  MonitorLocker locker(THREAD, TrainingReplayQueue_lock);\n+  int wait = 1;\n+  while (!_training_replay_queue.is_empty_unlocked() && !replay_thread->is_terminated()) {\n+    \/\/ Let the replay training thread drain the queue and terminate.\n+    \/\/ We need to re-check periodically, since we would not be notified\n+    \/\/ when queue goes empty or thread terminates.\n+    locker.wait(wait);\n+    wait = MIN2(100, wait * 2);\n+  }\n@@ -235,0 +248,2 @@\n+    } else if (TrainingReplayThread::instance()->should_terminate()) {\n+      return;\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -87,2 +87,1 @@\n-    while(is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n-      locker.notify_all(); \/\/ notify that queue is empty\n+    while (is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,0 +213,2 @@\n+TrainingReplayThread* volatile TrainingReplayThread::_instance = nullptr;\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,0 +501,3 @@\n+  static TrainingReplayThread* volatile _instance;\n+  bool volatile _should_terminate;\n+\n@@ -502,0 +505,1 @@\n+\n@@ -503,1 +507,9 @@\n-  TrainingReplayThread() : JavaThread(&training_replay_thread_entry) { }\n+  TrainingReplayThread() : JavaThread(&training_replay_thread_entry), _should_terminate(false) {\n+    bool succ = Atomic::replace_if_null(&_instance, this);\n+    assert(succ, \"Installation should succeed\");\n+  }\n+\n+  static TrainingReplayThread* instance() { return Atomic::load(&_instance); }\n+\n+  void set_should_terminate() { Atomic::store(&_should_terminate, true); }\n+  bool should_terminate()     { return Atomic::load(&_should_terminate); }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}