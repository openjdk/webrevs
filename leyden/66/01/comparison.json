{"files":[{"patch":"@@ -269,0 +269,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::Blob, (uint)OptoStubId::exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -272,1 +278,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -277,0 +282,1 @@\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n@@ -278,9 +284,0 @@\n-  int pc_offset = 0;\n-  if (AOTCodeCache::load_exception_blob(&buffer, &pc_offset)) {\n-    OopMapSet* oop_maps = new OopMapSet();\n-    oop_maps->add_gc_map(pc_offset, new OopMap(SimpleRuntimeFrame::framesize, 0));\n-\n-    \/\/ Set exception blob\n-    _exception_blob =  ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n-    return _exception_blob;\n-  }\n@@ -288,1 +285,0 @@\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n@@ -334,2 +330,1 @@\n-  pc_offset = the_pc - start;\n-  oop_maps->add_gc_map(pc_offset, new OopMap(SimpleRuntimeFrame::framesize, 0));\n+  oop_maps->add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));\n@@ -376,1 +371,0 @@\n-  AOTCodeCache::store_exception_blob(&buffer, pc_offset);\n@@ -378,1 +372,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::Blob, (uint)OptoStubId::exception_id, name);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1537,138 +1537,0 @@\n-bool AOTCodeCache::store_exception_blob(CodeBuffer* buffer, int pc_offset) {\n-  if (!is_dumping_stub()) {\n-    return false;\n-  }\n-  AOTCodeCache* cache = open_for_dump();\n-  if (cache == nullptr) {\n-    return false;\n-  }\n-  log_info(aot, codecache, stubs)(\"Writing blob '%s' to AOT Code Cache\", buffer->name());\n-\n-#ifdef ASSERT\n-  LogStreamHandle(Debug, aot, codecache, nmethod) log;\n-  if (log.is_enabled()) {\n-    FlagSetting fs(PrintRelocations, true);\n-    buffer->print_on(&log);\n-    buffer->decode();\n-  }\n-#endif\n-  \/\/ we need to take a lock to prevent race between compiler thread generating blob and the main thread generating adapter\n-  MutexLocker ml(Compile_lock);\n-  if (!cache->align_write()) {\n-    return false;\n-  }\n-  uint entry_position = cache->_write_position;\n-\n-  \/\/ Write pc_offset\n-  uint n = cache->write_bytes(&pc_offset, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-\n-  \/\/ Write name\n-  const char* name = buffer->name();\n-  uint name_offset = cache->_write_position - entry_position;\n-  uint name_size = (uint)strlen(name) + 1; \/\/ Includes '\/0'\n-  n = cache->write_bytes(name, name_size);\n-  if (n != name_size) {\n-    return false;\n-  }\n-\n-  \/\/ Write code section\n-  if (!cache->align_write()) {\n-    return false;\n-  }\n-  uint code_offset = cache->_write_position - entry_position;\n-  uint code_size = 0;\n-  if (!cache->write_code(buffer, code_size)) {\n-    return false;\n-  }\n-  \/\/ Write relocInfo array\n-  uint reloc_offset = cache->_write_position - entry_position;\n-  uint reloc_size = 0;\n-  if (!cache->write_relocations(buffer, reloc_size)) {\n-    return false;\n-  }\n-\n-  uint entry_size = cache->_write_position - entry_position;\n-  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_position, entry_size, name_offset, name_size,\n-                                        code_offset, code_size, reloc_offset, reloc_size,\n-                                        AOTCodeEntry::Blob, (uint32_t)999);\n-  log_info(aot, codecache, stubs)(\"Wrote stub '%s' to AOT Code Cache\", name);\n-  return true;\n-}\n-\n-bool AOTCodeCache::load_exception_blob(CodeBuffer* buffer, int* pc_offset) {\n-  if (!is_using_stub()) {\n-    return false;\n-  }\n-  AOTCodeCache* cache = open_for_use();\n-  if (cache == nullptr) {\n-    return false;\n-  }\n-#ifdef ASSERT\n-  LogStreamHandle(Debug, aot, codecache, nmethod) log;\n-  if (log.is_enabled()) {\n-    FlagSetting fs(PrintRelocations, true);\n-    buffer->print_on(&log);\n-  }\n-#endif\n-  AOTCodeEntry* entry = cache->find_entry(AOTCodeEntry::Blob, 999);\n-  if (entry == nullptr) {\n-    return false;\n-  }\n-  AOTCodeReader reader(cache, entry, nullptr);\n-  return reader.compile_blob(buffer, pc_offset);\n-}\n-\n-bool AOTCodeReader::compile_blob(CodeBuffer* buffer, int* pc_offset) {\n-  uint entry_position = _entry->offset();\n-\n-  \/\/ Read pc_offset\n-  *pc_offset = *(int*)addr(entry_position);\n-\n-  \/\/ Read name\n-  uint name_offset = entry_position + _entry->name_offset();\n-  uint name_size = _entry->name_size(); \/\/ Includes '\/0'\n-  const char* name = addr(name_offset);\n-\n-  log_info(aot, codecache, stubs)(\"%d (L%d): Reading blob '%s' with pc_offset %d from AOT Code Cache\",\n-                       compile_id(), comp_level(), name, *pc_offset);\n-\n-  if (strncmp(buffer->name(), name, (name_size - 1)) != 0) {\n-    log_warning(aot, codecache)(\"%d (L%d): Saved blob's name '%s' is different from '%s'\",\n-                                compile_id(), comp_level(), name, buffer->name());\n-    ((AOTCodeCache*)_cache)->set_failed();\n-    report_load_failure();\n-    return false;\n-  }\n-\n-  \/\/ Create fake original CodeBuffer\n-  CodeBuffer orig_buffer(name);\n-\n-  \/\/ Read code\n-  uint code_offset = entry_position + _entry->code_offset();\n-  if (!read_code(buffer, &orig_buffer, code_offset)) {\n-    return false;\n-  }\n-\n-  \/\/ Read relocations\n-  uint reloc_offset = entry_position + _entry->reloc_offset();\n-  set_read_position(reloc_offset);\n-  if (!read_relocations(buffer, &orig_buffer, nullptr, nullptr)) {\n-    return false;\n-  }\n-\n-  log_info(aot, codecache, stubs)(\"%d (L%d): Read blob '%s' from AOT Code Cache\",\n-                       compile_id(), comp_level(), name);\n-#ifdef ASSERT\n-  LogStreamHandle(Debug, aot, codecache, nmethod) log;\n-  if (log.is_enabled()) {\n-    FlagSetting fs(PrintRelocations, true);\n-    buffer->print_on(&log);\n-    buffer->decode();\n-  }\n-#endif\n-  return true;\n-}\n-\n@@ -1866,1 +1728,1 @@\n-  if (!write_oop_map_set(nm)) {\n+  if (!write_oop_map_set(*nm)) {\n@@ -2169,259 +2031,0 @@\n-bool AOTCodeCache::write_code(CodeBuffer* buffer, uint& code_size) {\n-  assert(_write_position == align_up(_write_position, DATA_ALIGNMENT), \"%d not aligned to %d\", _write_position, DATA_ALIGNMENT);\n-  \/\/assert(buffer->blob() != nullptr, \"sanity\");\n-  uint code_offset = _write_position;\n-  uint cb_total_size = (uint)buffer->total_content_size();\n-  \/\/ Write information about Code sections first.\n-  AOTCodeSection aot_cs[CodeBuffer::SECT_LIMIT];\n-  uint aot_cs_size = (uint)(sizeof(AOTCodeSection) * CodeBuffer::SECT_LIMIT);\n-  uint offset = align_up(aot_cs_size, DATA_ALIGNMENT);\n-  uint total_size = 0;\n-  for (int i = 0; i < (int)CodeBuffer::SECT_LIMIT; i++) {\n-    const CodeSection* cs = buffer->code_section(i);\n-    assert(cs->mark() == nullptr, \"CodeSection::_mark is not implemented\");\n-    uint cs_size = (uint)cs->size();\n-    aot_cs[i]._size = cs_size;\n-    aot_cs[i]._origin_address = (cs_size == 0) ? nullptr : cs->start();\n-    aot_cs[i]._offset = (cs_size == 0) ? 0 : (offset + total_size);\n-    assert(cs->mark() == nullptr, \"CodeSection::_mark is not implemented\");\n-    total_size += align_up(cs_size, DATA_ALIGNMENT);\n-  }\n-  uint n = write_bytes(aot_cs, aot_cs_size);\n-  if (n != aot_cs_size) {\n-    return false;\n-  }\n-  if (!align_write()) {\n-    return false;\n-  }\n-  assert(_write_position == (code_offset + offset), \"%d  != (%d + %d)\", _write_position, code_offset, offset);\n-  for (int i = 0; i < (int)CodeBuffer::SECT_LIMIT; i++) {\n-    const CodeSection* cs = buffer->code_section(i);\n-    uint cs_size = (uint)cs->size();\n-    if (cs_size == 0) {\n-      continue;  \/\/ skip trivial section\n-    }\n-    assert((_write_position - code_offset) == aot_cs[i]._offset, \"%d != %d\", _write_position, aot_cs[i]._offset);\n-    \/\/ Write code\n-    n = write_bytes(cs->start(), cs_size);\n-    if (n != cs_size) {\n-      return false;\n-    }\n-    if (!align_write()) {\n-      return false;\n-    }\n-  }\n-  assert((_write_position - code_offset) == (offset + total_size), \"(%d - %d) != (%d + %d)\", _write_position, code_offset, offset, total_size);\n-  code_size = total_size;\n-  return true;\n-}\n-\n-bool AOTCodeReader::read_code(CodeBuffer* buffer, CodeBuffer* orig_buffer, uint code_offset) {\n-  assert(code_offset == align_up(code_offset, DATA_ALIGNMENT), \"%d not aligned to %d\", code_offset, DATA_ALIGNMENT);\n-  AOTCodeSection* aot_cs = (AOTCodeSection*)addr(code_offset);\n-  for (int i = 0; i < (int)CodeBuffer::SECT_LIMIT; i++) {\n-    CodeSection* cs = buffer->code_section(i);\n-    \/\/ Read original section size and address.\n-    uint orig_size = aot_cs[i]._size;\n-    log_debug(aot, codecache)(\"======== read code section %d [%d]:\", i, orig_size);\n-    uint orig_size_align = align_up(orig_size, DATA_ALIGNMENT);\n-    if (i != (int)CodeBuffer::SECT_INSTS) {\n-      buffer->initialize_section_size(cs, orig_size_align);\n-    }\n-    if (orig_size_align > (uint)cs->capacity()) { \/\/ Will not fit\n-      log_info(aot, codecache)(\"%d (L%d): original code section %d size %d > current capacity %d\",\n-                       compile_id(), comp_level(), i, orig_size, cs->capacity());\n-      return false;\n-    }\n-    if (orig_size == 0) {\n-      assert(cs->size() == 0, \"should match\");\n-      continue;  \/\/ skip trivial section\n-    }\n-    address orig_start = aot_cs[i]._origin_address;\n-\n-    \/\/ Populate fake original buffer (no code allocation in CodeCache).\n-    \/\/ It is used for relocations to calculate sections addesses delta.\n-    CodeSection* orig_cs = orig_buffer->code_section(i);\n-    assert(!orig_cs->is_allocated(), \"This %d section should not be set\", i);\n-    orig_cs->initialize(orig_start, orig_size);\n-\n-    \/\/ Load code to new buffer.\n-    address code_start = cs->start();\n-    copy_bytes(addr(aot_cs[i]._offset + code_offset), code_start, orig_size_align);\n-    cs->set_end(code_start + orig_size);\n-  }\n-\n-  return true;\n-}\n-\n-bool AOTCodeCache::write_relocations(CodeBuffer* buffer, uint& all_reloc_size) {\n-  uint all_reloc_count = 0;\n-  for (int i = 0; i < (int)CodeBuffer::SECT_LIMIT; i++) {\n-    CodeSection* cs = buffer->code_section(i);\n-    uint reloc_count = cs->has_locs() ? cs->locs_count() : 0;\n-    all_reloc_count += reloc_count;\n-  }\n-  all_reloc_size = all_reloc_count * sizeof(relocInfo);\n-  bool success = true;\n-  uint* reloc_data = NEW_C_HEAP_ARRAY(uint, all_reloc_count, mtCode);\n-  for (int i = 0; i < (int)CodeBuffer::SECT_LIMIT; i++) {\n-    CodeSection* cs = buffer->code_section(i);\n-    int reloc_count = cs->has_locs() ? cs->locs_count() : 0;\n-    uint n = write_bytes(&reloc_count, sizeof(int));\n-    if (n != sizeof(int)) {\n-      success = false;\n-      break;\n-    }\n-    if (reloc_count == 0) {\n-      continue;\n-    }\n-    \/\/ Write _locs_point (as offset from start)\n-    int locs_point_off = cs->locs_point_off();\n-    n = write_bytes(&locs_point_off, sizeof(int));\n-    if (n != sizeof(int)) {\n-      success = false;\n-      break;\n-    }\n-    relocInfo* reloc_start = cs->locs_start();\n-    uint reloc_size      = reloc_count * sizeof(relocInfo);\n-    n = write_bytes(reloc_start, reloc_size);\n-    if (n != reloc_size) {\n-      success = false;\n-      break;\n-    }\n-    LogStreamHandle(Info, aot, codecache, reloc) log;\n-    if (log.is_enabled()) {\n-      log.print_cr(\"======== write code section %d relocations [%d]:\", i, reloc_count);\n-    }\n-    \/\/ Collect additional data\n-    RelocIterator iter(cs);\n-    bool has_immediate = false;\n-    int j = 0;\n-    while (iter.next()) {\n-      reloc_data[j] = 0; \/\/ initialize\n-      switch (iter.type()) {\n-        case relocInfo::none:\n-          break;\n-        case relocInfo::oop_type: {\n-          oop_Relocation* r = (oop_Relocation*)iter.reloc();\n-          if (r->oop_is_immediate()) {\n-            reloc_data[j] = (uint)j; \/\/ Indication that we need to restore immediate\n-            has_immediate = true;\n-          }\n-          break;\n-        }\n-        case relocInfo::metadata_type: {\n-          metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n-          if (r->metadata_is_immediate()) {\n-            reloc_data[j] = (uint)j; \/\/ Indication that we need to restore immediate\n-            has_immediate = true;\n-          }\n-          break;\n-        }\n-        case relocInfo::virtual_call_type:  \/\/ Fall through. They all call resolve_*_call blobs.\n-        case relocInfo::opt_virtual_call_type:\n-        case relocInfo::static_call_type: {\n-          CallRelocation* r = (CallRelocation*)iter.reloc();\n-          address dest = r->destination();\n-          if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n-            dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n-          }\n-          reloc_data[j] = _table->id_for_address(dest, iter, buffer);\n-          break;\n-        }\n-        case relocInfo::trampoline_stub_type: {\n-          address dest = ((trampoline_stub_Relocation*)iter.reloc())->destination();\n-          reloc_data[j] = _table->id_for_address(dest, iter, buffer);\n-          break;\n-        }\n-        case relocInfo::static_stub_type:\n-          break;\n-        case relocInfo::runtime_call_type: {\n-          \/\/ Record offset of runtime destination\n-          CallRelocation* r = (CallRelocation*)iter.reloc();\n-          address dest = r->destination();\n-          if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n-            dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n-          }\n-          reloc_data[j] = _table->id_for_address(dest, iter, buffer);\n-          break;\n-        }\n-        case relocInfo::runtime_call_w_cp_type:\n-          fatal(\"runtime_call_w_cp_type unimplemented\");\n-          break;\n-        case relocInfo::external_word_type: {\n-          \/\/ Record offset of runtime target\n-          address target = ((external_word_Relocation*)iter.reloc())->target();\n-          reloc_data[j] = _table->id_for_address(target, iter, buffer);\n-          break;\n-        }\n-        case relocInfo::internal_word_type:\n-          break;\n-        case relocInfo::section_word_type:\n-          break;\n-        case relocInfo::poll_type:\n-          break;\n-        case relocInfo::poll_return_type:\n-          break;\n-        case relocInfo::post_call_nop_type:\n-          break;\n-        case relocInfo::entry_guard_type:\n-          break;\n-        default:\n-          fatal(\"relocation %d unimplemented\", (int)iter.type());\n-          break;\n-      }\n-      if (log.is_enabled()) {\n-        iter.print_current_on(&log);\n-      }\n-      j++;\n-    }\n-    assert(j <= (int)reloc_count, \"sanity\");\n-    \/\/ Write additional relocation data: uint per relocation\n-    uint data_size = reloc_count * sizeof(uint);\n-    n = write_bytes(reloc_data, data_size);\n-    if (n != data_size) {\n-      success = false;\n-      break;\n-    }\n-    if (has_immediate) {\n-      \/\/ Save information about immediates in this Code Section\n-      RelocIterator iter_imm(cs);\n-      int j = 0;\n-      while (iter_imm.next()) {\n-        switch (iter_imm.type()) {\n-          case relocInfo::oop_type: {\n-            oop_Relocation* r = (oop_Relocation*)iter_imm.reloc();\n-            if (r->oop_is_immediate()) {\n-              assert(reloc_data[j] == (uint)j, \"should be\");\n-              jobject jo = *(jobject*)(r->oop_addr()); \/\/ Handle currently\n-              if (!write_oop(jo)) {\n-                success = false;\n-              }\n-            }\n-            break;\n-          }\n-          case relocInfo::metadata_type: {\n-            metadata_Relocation* r = (metadata_Relocation*)iter_imm.reloc();\n-            if (r->metadata_is_immediate()) {\n-              assert(reloc_data[j] == (uint)j, \"should be\");\n-              Metadata* m = r->metadata_value();\n-              if (!write_metadata(m)) {\n-                success = false;\n-              }\n-            }\n-            break;\n-          }\n-          default:\n-            break;\n-        }\n-        if (!success) {\n-          break;\n-        }\n-        j++;\n-      } \/\/ while (iter_imm.next())\n-    } \/\/ if (has_immediate)\n-  } \/\/ for(i < SECT_LIMIT)\n-  FREE_C_HEAP_ARRAY(uint, reloc_data);\n-  return success;\n-}\n-\n@@ -2484,154 +2087,0 @@\n-\/\/ Repair the pc relative information in the code after load\n-bool AOTCodeReader::read_relocations(CodeBuffer* buffer, CodeBuffer* orig_buffer,\n-                                     OopRecorder* oop_recorder, ciMethod* target) {\n-  bool success = true;\n-  for (int i = 0; i < (int)CodeBuffer::SECT_LIMIT; i++) {\n-    uint code_offset = read_position();\n-    int reloc_count = *(int*)addr(code_offset);\n-    code_offset += sizeof(int);\n-    if (reloc_count == 0) {\n-      set_read_position(code_offset);\n-      continue;\n-    }\n-    \/\/ Read _locs_point (as offset from start)\n-    int locs_point_off = *(int*)addr(code_offset);\n-    code_offset += sizeof(int);\n-    uint reloc_size = reloc_count * sizeof(relocInfo);\n-    CodeSection* cs  = buffer->code_section(i);\n-    if (cs->locs_capacity() < reloc_count) {\n-      cs->expand_locs(reloc_count);\n-    }\n-    relocInfo* reloc_start = cs->locs_start();\n-    copy_bytes(addr(code_offset), (address)reloc_start, reloc_size);\n-    code_offset += reloc_size;\n-    cs->set_locs_end(reloc_start + reloc_count);\n-    cs->set_locs_point(cs->start() + locs_point_off);\n-\n-    \/\/ Read additional relocation data: uint per relocation\n-    uint  data_size  = reloc_count * sizeof(uint);\n-    uint* reloc_data = (uint*)addr(code_offset);\n-    code_offset += data_size;\n-    set_read_position(code_offset);\n-    LogStreamHandle(Info, aot, codecache, reloc) log;\n-    if (log.is_enabled()) {\n-      log.print_cr(\"======== read code section %d relocations [%d]:\", i, reloc_count);\n-    }\n-    RelocIterator iter(cs);\n-    int j = 0;\n-    while (iter.next()) {\n-      switch (iter.type()) {\n-        case relocInfo::none:\n-          break;\n-        case relocInfo::oop_type: {\n-          VM_ENTRY_MARK;\n-          oop_Relocation* r = (oop_Relocation*)iter.reloc();\n-          if (r->oop_is_immediate()) {\n-            assert(reloc_data[j] == (uint)j, \"should be\");\n-            methodHandle comp_method(THREAD, target->get_Method());\n-            oop obj = read_oop(THREAD, comp_method);\n-            jobject jo = JNIHandles::make_local(THREAD, obj);\n-            if (lookup_failed()) {\n-              success = false;\n-              break;\n-            }\n-            r->set_value((address)jo);\n-          } else if (false) {\n-            \/\/ Get already updated value from OopRecorder.\n-            assert(oop_recorder != nullptr, \"sanity\");\n-            int index = r->oop_index();\n-            jobject jo = oop_recorder->oop_at(index);\n-            oop obj = JNIHandles::resolve(jo);\n-            r->set_value(*reinterpret_cast<address*>(&obj));\n-          }\n-          break;\n-        }\n-        case relocInfo::metadata_type: {\n-          VM_ENTRY_MARK;\n-          metadata_Relocation* r = (metadata_Relocation*)iter.reloc();\n-          Metadata* m;\n-          if (r->metadata_is_immediate()) {\n-            assert(reloc_data[j] == (uint)j, \"should be\");\n-            methodHandle comp_method(THREAD, target->get_Method());\n-            m = read_metadata(comp_method);\n-            if (lookup_failed()) {\n-              success = false;\n-              break;\n-            }\n-          } else {\n-            \/\/ Get already updated value from OopRecorder.\n-            assert(oop_recorder != nullptr, \"sanity\");\n-            int index = r->metadata_index();\n-            m = oop_recorder->metadata_at(index);\n-          }\n-          r->set_value((address)m);\n-          break;\n-        }\n-        case relocInfo::virtual_call_type:   \/\/ Fall through. They all call resolve_*_call blobs.\n-        case relocInfo::opt_virtual_call_type:\n-        case relocInfo::static_call_type: {\n-          address dest = _cache->address_for_id(reloc_data[j]);\n-          if (dest != (address)-1) {\n-            ((CallRelocation*)iter.reloc())->set_destination(dest);\n-          }\n-          break;\n-        }\n-        case relocInfo::trampoline_stub_type: {\n-          address dest = _cache->address_for_id(reloc_data[j]);\n-          if (dest != (address)-1) {\n-            ((trampoline_stub_Relocation*)iter.reloc())->set_destination(dest);\n-          }\n-          break;\n-        }\n-        case relocInfo::static_stub_type:\n-          break;\n-        case relocInfo::runtime_call_type: {\n-          address dest = _cache->address_for_id(reloc_data[j]);\n-          if (dest != (address)-1) {\n-            ((CallRelocation*)iter.reloc())->set_destination(dest);\n-          }\n-          break;\n-        }\n-        case relocInfo::runtime_call_w_cp_type:\n-          fatal(\"runtime_call_w_cp_type unimplemented\");\n-          \/\/address destination = iter.reloc()->value();\n-          break;\n-        case relocInfo::external_word_type: {\n-          address target = _cache->address_for_id(reloc_data[j]);\n-          \/\/ Add external address to global table\n-          int index = ExternalsRecorder::find_index(target);\n-          \/\/ Update index in relocation\n-          Relocation::add_jint(iter.data(), index);\n-          external_word_Relocation* reloc = (external_word_Relocation*)iter.reloc();\n-          assert(reloc->target() == target, \"sanity\");\n-          reloc->set_value(target); \/\/ Patch address in the code\n-          iter.reloc()->fix_relocation_after_move(orig_buffer, buffer);\n-          break;\n-        }\n-        case relocInfo::internal_word_type:\n-          iter.reloc()->fix_relocation_after_move(orig_buffer, buffer);\n-          break;\n-        case relocInfo::section_word_type:\n-          iter.reloc()->fix_relocation_after_move(orig_buffer, buffer);\n-          break;\n-        case relocInfo::poll_type:\n-          break;\n-        case relocInfo::poll_return_type:\n-          break;\n-        case relocInfo::post_call_nop_type:\n-          break;\n-        case relocInfo::entry_guard_type:\n-          break;\n-        default:\n-          fatal(\"relocation %d unimplemented\", (int)iter.type());\n-          break;\n-      }\n-      if (success && log.is_enabled()) {\n-        iter.print_current_on(&log);\n-      }\n-      j++;\n-    }\n-    assert(j <= (int)reloc_count, \"sanity\");\n-  }\n-  return success;\n-}\n-\n@@ -2750,0 +2199,1 @@\n+\n@@ -3004,60 +2454,0 @@\n-bool AOTCodeCache::write_oop_maps(OopMapSet* oop_maps) {\n-  uint om_count = oop_maps->size();\n-  uint n = write_bytes(&om_count, sizeof(int));\n-  if (n != sizeof(int)) {\n-    return false;\n-  }\n-  for (int i = 0; i < (int)om_count; i++) {\n-    OopMap* om = oop_maps->at(i);\n-    int data_size = om->data_size();\n-    n = write_bytes(&data_size, sizeof(int));\n-    if (n != sizeof(int)) {\n-      return false;\n-    }\n-    n = write_bytes(om, sizeof(OopMap));\n-    if (n != sizeof(OopMap)) {\n-      return false;\n-    }\n-    n = write_bytes(om->data(), (uint)data_size);\n-    if (n != (uint)data_size) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-OopMapSet* AOTCodeReader::read_oop_maps() {\n-  uint code_offset = read_position();\n-  int om_count = *(int*)addr(code_offset);\n-  code_offset += sizeof(int);\n-\n-  log_debug(aot, codecache)(\"======== read oop maps [%d]:\", om_count);\n-\n-  OopMapSet* oop_maps = new OopMapSet(om_count);\n-  for (int i = 0; i < (int)om_count; i++) {\n-    int data_size = *(int*)addr(code_offset);\n-    code_offset += sizeof(int);\n-\n-    OopMap* oop_map = new OopMap(data_size);\n-    \/\/ Preserve allocated stream\n-    CompressedWriteStream* stream = oop_map->write_stream();\n-\n-    \/\/ Read data which overwrites default data\n-    copy_bytes(addr(code_offset), (address)oop_map, sizeof(OopMap));\n-    code_offset += sizeof(OopMap);\n-    stream->set_position(data_size);\n-    oop_map->set_write_stream(stream);\n-    if (data_size > 0) {\n-      copy_bytes(addr(code_offset), (address)(oop_map->data()), (uint)data_size);\n-      code_offset += data_size;\n-    }\n-#ifdef ASSERT\n-    oop_map->_locs_length = 0;\n-    oop_map->_locs_used   = nullptr;\n-#endif\n-    oop_maps->add(oop_map);\n-  }\n-  set_read_position(code_offset);\n-  return oop_maps;\n-}\n-\n@@ -3980,13 +3370,0 @@\n-bool AOTCodeCache::write_oop_map_set(nmethod* nm) {\n-  ImmutableOopMapSet* oopmaps = nm->oop_maps();\n-  int oopmaps_size = oopmaps->nr_of_bytes();\n-  if (!write_bytes(&oopmaps_size, sizeof(int))) {\n-    return false;\n-  }\n-  uint n = write_bytes(oopmaps, oopmaps->nr_of_bytes());\n-  if (n != (uint)oopmaps->nr_of_bytes()) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":2,"deletions":625,"binary":false,"changes":627,"status":"modified"},{"patch":"@@ -540,2 +540,0 @@\n-  bool write_code(CodeBuffer* buffer, uint& code_size);\n-  bool write_relocations(CodeBuffer* buffer, uint& reloc_size);\n@@ -544,1 +542,0 @@\n-  bool write_oop_maps(OopMapSet* oop_maps);\n@@ -546,1 +543,0 @@\n-  bool write_oop_map_set(nmethod* nm);\n@@ -564,3 +560,0 @@\n-  static bool load_exception_blob(CodeBuffer* buffer, int* pc_offset) NOT_CDS_RETURN_(false);\n-  static bool store_exception_blob(CodeBuffer* buffer, int pc_offset) NOT_CDS_RETURN_(false);\n-\n@@ -570,2 +563,2 @@\n-                              int entry_offset_count,\n-                              int* entry_offsets) NOT_CDS_RETURN_(false);\n+                              int entry_offset_count = 0,\n+                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n@@ -575,2 +568,2 @@\n-                                  int entry_offset_count,\n-                                  int* entry_offsets) NOT_CDS_RETURN_(nullptr);\n+                                  int entry_offset_count = 0,\n+                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n@@ -620,1 +613,0 @@\n-\n@@ -694,2 +686,0 @@\n-  bool read_code(CodeBuffer* buffer, CodeBuffer* orig_buffer, uint code_offset);\n-  bool read_relocations(CodeBuffer* buffer, CodeBuffer* orig_buffer, OopRecorder* oop_recorder, ciMethod* target);\n@@ -697,1 +687,0 @@\n-  OopMapSet* read_oop_maps();\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+  ExceptionBlob* as_exception_blob() const    { assert(is_exception_stub(), \"must be exception stub\"); return (ExceptionBlob*) this; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -554,4 +554,0 @@\n-  void copy_to(address dest) {\n-    memcpy(dest, this, size());\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}