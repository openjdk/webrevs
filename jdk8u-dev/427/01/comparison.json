{"files":[{"patch":"@@ -565,1 +565,2 @@\n-            SctpNet.preClose(fdVal);\n+            if (state != ChannelState.KILLED)\n+                SctpNet.preClose(fdVal);\n","filename":"jdk\/src\/solaris\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -292,1 +292,2 @@\n-            SctpNet.preClose(fdVal);\n+            if (state != ChannelState.KILLED)\n+                SctpNet.preClose(fdVal);\n","filename":"jdk\/src\/solaris\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -269,1 +269,2 @@\n-            SctpNet.preClose(fdVal);\n+            if (state != ChannelState.KILLED)\n+                SctpNet.preClose(fdVal);\n","filename":"jdk\/src\/solaris\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8238274\n+ * @summary Potential leak file descriptor for SCTP\n+ * @library \/lib\/testlibrary\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm\/timeout=250 CloseDescriptors\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.lang.management.ManagementFactory;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Optional;\n+import com.sun.nio.sctp.SctpChannel;\n+import com.sun.nio.sctp.SctpServerChannel;\n+\n+import jdk.testlibrary.Utils;\n+\n+public class CloseDescriptors {\n+    private static Selector selector;\n+    private static final int LOOP = 10;\n+    private static final int LIMIT_LINES = 3;\n+    private static SelectorThread selThread;\n+    private static boolean finished = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Util.isSCTPSupported()) {\n+            System.out.println(\"SCTP protocol is not supported\");\n+            System.out.println(\"Test cannot be run\");\n+            return;\n+        }\n+\n+        List<String> lsofDirs = Utils.listOf(\"\/usr\/bin\", \"\/usr\/sbin\");\n+\n+        Optional<Path> lsof = lsofDirs.stream()\n+                            .map(s -> Paths.get(s, \"lsof\"))\n+                            .filter(f -> Files.isExecutable(f))\n+                            .findFirst();\n+        if (!lsof.isPresent()) {\n+            System.out.println(\"Cannot locate lsof in \" + lsofDirs);\n+            System.out.println(\"Test cannot be run\");\n+            return;\n+        }\n+\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            int port = ss.getLocalPort();\n+\n+            Server server = new Server(port);\n+            server.start();\n+\n+            selector = Selector.open();\n+\n+            selThread = new SelectorThread();\n+            selThread.start();\n+\n+            \/\/ give time for the server and selector to start\n+            Thread.sleep(100);\n+            for (int i = 0 ; i < 100 ; ++i) {\n+                System.out.println(i);\n+                doIt(port);\n+                Thread.sleep(100);\n+            }\n+            System.out.println(\"end\");\n+            if (!check()) {\n+                cleanup(port);\n+                throw new RuntimeException(\"Failed: detected unclosed FD.\");\n+            }\n+            cleanup(port);\n+            server.join();\n+            selThread.join();\n+        }\n+    }\n+\n+    private static void doIt(int port) throws Exception {\n+        InetSocketAddress sa = new InetSocketAddress(\"localhost\", port);\n+\n+        for (int i = 0 ; i < LOOP ; ++i) {\n+            System.out.println(\"  \" + i);\n+            try (SctpChannel channel = SctpChannel.open(sa, 1, 1)) {\n+                channel.configureBlocking(false);\n+\n+                SelectionKey key = selThread.regChannel(channel);\n+\n+                key.cancel();\n+                selector.wakeup();\n+            }\n+            catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            Thread.sleep(200);\n+        }\n+    }\n+\n+    private static boolean check() throws Exception {\n+        String vmName = ManagementFactory.getRuntimeMXBean().getName();\n+        long myPid = Long.parseLong(vmName.split(\"@\")[0]);\n+        ProcessBuilder pb = new ProcessBuilder(\n+                        \"lsof\", \"-U\", \"-a\", \"-p\", Long.toString(myPid));\n+        pb.redirectErrorStream(true);\n+        Process p = pb.start();\n+        p.waitFor();\n+        if (p.exitValue() != 0) {\n+            return false;\n+        }\n+\n+        boolean result = true;\n+        try (BufferedReader br = new BufferedReader(new InputStreamReader(\n+            p.getInputStream()))) {\n+            int count = 0;\n+            String line = br.readLine();\n+            while (line != null) {\n+                System.out.println(line);\n+                count++;\n+                if (count > LIMIT_LINES) {\n+                    result = false;\n+                }\n+                line = br.readLine();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static void cleanup(int port) throws IOException {\n+        finished = true;\n+        InetSocketAddress sa = new InetSocketAddress(\"localhost\", port);\n+        SctpChannel channel = SctpChannel.open(sa, 1, 1);\n+        channel.close();\n+    }\n+\n+    private static class SelectorThread extends Thread {\n+        private Object lock = new Object();\n+        private SctpChannel channel;\n+        private SelectionKey key;\n+\n+        public SelectionKey regChannel(SctpChannel ch) throws Exception {\n+            synchronized (lock) {\n+                channel = ch;\n+                selector.wakeup();\n+                lock.wait();\n+            }\n+            return key;\n+        }\n+\n+        public void run() {\n+            try {\n+                while (!finished) {\n+                    selector.select(1000);\n+                    synchronized (lock) {\n+                        if (channel != null) {\n+                            key = channel.register(selector, SelectionKey.OP_READ);\n+                            channel = null;\n+                            lock.notify();\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    private static class Server extends Thread {\n+        private int port;\n+\n+        public Server(int port) { this.port = port; }\n+\n+        public void run() {\n+            try {\n+                SctpServerChannel ss = SctpServerChannel.open();\n+                InetSocketAddress sa = new InetSocketAddress(\"localhost\", port);\n+                ss.bind(sa);\n+                while (!finished) {\n+                    SctpChannel soc = ss.accept();\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+}\n","filename":"jdk\/test\/com\/sun\/nio\/sctp\/SctpChannel\/CloseDescriptors.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"}]}