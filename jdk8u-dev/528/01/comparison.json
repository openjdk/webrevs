{"files":[{"patch":"@@ -836,0 +836,89 @@\n+\n+Node* MaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn) {\n+  bool is_int = gvn.type(a)->isa_int();\n+  assert(is_int || gvn.type(a)->isa_long(), \"int or long inputs\");\n+  assert(is_int == (gvn.type(b)->isa_int() != NULL), \"inconsistent inputs\");\n+  if (!is_unsigned) {\n+    if (is_max) {\n+      if (is_int) {\n+        Node* res =  gvn.transform(new (gvn.C) MaxINode(a, b));\n+        assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n+        return res;\n+      } else {\n+        Node* cmp = gvn.transform(new (gvn.C) CmpLNode(a, b));\n+        Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+        return gvn.transform(new (gvn.C) CMoveLNode(bol, a, b, t->is_long()));\n+      }\n+    } else {\n+      if (is_int) {\n+        Node* res =  gvn.transform(new (gvn.C) MinINode(a, b));\n+        assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n+        return res;\n+      } else {\n+        Node* cmp = gvn.transform(new (gvn.C) CmpLNode(b, a));\n+        Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+        return gvn.transform(new (gvn.C) CMoveLNode(bol, a, b, t->is_long()));\n+      }\n+    }\n+  } else {\n+    if (is_max) {\n+      if (is_int) {\n+        Node* cmp = gvn.transform(new (gvn.C) CmpUNode(a, b));\n+        Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+        return gvn.transform(new (gvn.C) CMoveINode(bol, a, b, t->is_int()));\n+      } else {\n+        Node* cmp = gvn.transform(new (gvn.C) CmpULNode(a, b));\n+        Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+        return gvn.transform(new (gvn.C) CMoveLNode(bol, a, b, t->is_long()));\n+      }\n+    } else {\n+      if (is_int) {\n+        Node* cmp = gvn.transform(new (gvn.C) CmpUNode(b, a));\n+        Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+        return gvn.transform(new (gvn.C) CMoveINode(bol, a, b, t->is_int()));\n+      } else {\n+        Node* cmp = gvn.transform(new (gvn.C) CmpULNode(b, a));\n+        Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+        return gvn.transform(new (gvn.C) CMoveLNode(bol, a, b, t->is_long()));\n+      }\n+    }\n+  }\n+}\n+\n+Node* MaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn) {\n+  bool is_int = gvn.type(a)->isa_int();\n+  assert(is_int || gvn.type(a)->isa_long(), \"int or long inputs\");\n+  assert(is_int == (gvn.type(b)->isa_int() != NULL), \"inconsistent inputs\");\n+  Node* zero = NULL;\n+  if (is_int) {\n+    zero = gvn.intcon(0);\n+  } else {\n+    zero = gvn.longcon(0);\n+  }\n+  if (is_max) {\n+    if (is_int) {\n+      Node* cmp = gvn.transform(new (gvn.C) CmpINode(a, b));\n+      Node* sub = gvn.transform(new (gvn.C) SubINode(a, b));\n+      Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+      return gvn.transform(new (gvn.C) CMoveINode(bol, sub, zero, t->is_int()));\n+    } else {\n+      Node* cmp = gvn.transform(new (gvn.C) CmpLNode(a, b));\n+      Node* sub = gvn.transform(new (gvn.C) SubLNode(a, b));\n+      Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+      return gvn.transform(new (gvn.C) CMoveLNode(bol, sub, zero, t->is_long()));\n+    }\n+  } else {\n+    if (is_int) {\n+      Node* cmp = gvn.transform(new (gvn.C) CmpINode(b, a));\n+      Node* sub = gvn.transform(new (gvn.C) SubINode(a, b));\n+      Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+      return gvn.transform(new (gvn.C) CMoveINode(bol, sub, zero, t->is_int()));\n+    } else {\n+      Node* cmp = gvn.transform(new (gvn.C) CmpLNode(b, a));\n+      Node* sub = gvn.transform(new (gvn.C) SubLNode(a, b));\n+      Node* bol = gvn.transform(new (gvn.C) BoolNode(cmp, BoolTest::lt));\n+      return gvn.transform(new (gvn.C) CMoveLNode(bol, sub, zero, t->is_long()));\n+    }\n+  }\n+}\n+\n","filename":"hotspot\/src\/share\/vm\/opto\/addnode.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -220,0 +220,4 @@\n+private:\n+  static Node* build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn);\n+  static Node* build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn);\n+\n@@ -223,0 +227,26 @@\n+\n+  static Node* unsigned_max(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n+    return build_min_max(a, b, true, true, t, gvn);\n+  }\n+\n+  static Node* unsigned_min(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n+    return build_min_max(a, b, false, true, t, gvn);\n+  }\n+\n+  static Node* signed_max(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n+    return build_min_max(a, b, true, false, t, gvn);\n+  }\n+\n+  static Node* signed_min(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n+    return build_min_max(a, b, false, false, t, gvn);\n+  }\n+\n+  \/\/ max(a-b, 0)\n+  static Node* max_diff_with_zero(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n+    return build_min_max_diff_with_zero(a, b, true, t, gvn);\n+  }\n+\n+  \/\/ min(a-b, 0)\n+  static Node* min_diff_with_zero(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n+    return build_min_max_diff_with_zero(a, b, false, t, gvn);\n+  }\n","filename":"hotspot\/src\/share\/vm\/opto\/addnode.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1547,1 +1547,3 @@\n-  \/\/ Clamp the limit to handle integer under-\/overflows.\n+  \/\/ Clamp the limit to handle integer under-\/overflows by using long values.\n+  \/\/ We only convert the limit back to int when we handled under-\/overflows.\n+  \/\/ Note that all values are longs in the following computations.\n@@ -1549,1 +1551,3 @@\n-  \/\/   MIN(old_limit, MAX(limit, min_jint))\n+  \/\/   INT(MINL(old_limit, MAXL(limit, min_jint)))\n+  \/\/   - integer underflow of limit: MAXL chooses min_jint.\n+  \/\/   - integer overflow of limit: MINL chooses old_limit (<= MAX_INT < limit)\n@@ -1551,2 +1555,20 @@\n-  \/\/   MAX(old_limit, MIN(limit, max_jint))\n-  Node* cmp = new (C) CmpLNode(limit, _igvn.longcon(is_positive_stride ? min_jint : max_jint));\n+  \/\/   INT(MAXL(old_limit, MINL(limit, max_jint)))\n+  \/\/   - integer overflow of limit: MINL chooses max_jint.\n+  \/\/   - integer underflow of limit: MAXL chooses old_limit (>= MIN_INT > limit)\n+  \/\/ INT() is finally converting the limit back to an integer value.\n+\n+  \/\/ We use CMove nodes to implement long versions of min\/max (MINL\/MAXL).\n+  \/\/ We use helper methods for inner MINL\/MAXL which return CMoveL nodes to keep a long value for the outer MINL\/MAXL comparison:\n+  Node* inner_result_long;\n+  if (is_positive_stride) {\n+    inner_result_long = MaxNode::signed_max(limit, _igvn.longcon(min_jint), TypeLong::LONG, _igvn);\n+  } else {\n+    inner_result_long = MaxNode::signed_min(limit, _igvn.longcon(max_jint), TypeLong::LONG, _igvn);\n+  }\n+  set_subtree_ctrl(inner_result_long);\n+\n+  \/\/ Outer MINL\/MAXL:\n+  \/\/ The comparison is done with long values but the result is the converted back to int by using CmovI.\n+  Node* old_limit_long = new (C) ConvI2LNode(old_limit);\n+  register_new_node(old_limit_long, pre_ctrl);\n+  Node* cmp = new (C) CmpLNode(old_limit_long, limit);\n@@ -1554,1 +1576,1 @@\n-  Node* bol = new (C) BoolNode(cmp, is_positive_stride ? BoolTest::lt : BoolTest::gt);\n+  Node* bol = new (C) BoolNode(cmp, is_positive_stride ? BoolTest::gt : BoolTest::lt);\n@@ -1556,7 +1578,3 @@\n-  limit = new (C) ConvL2INode(limit);\n-  register_new_node(limit, pre_ctrl);\n-  limit = new (C) CMoveINode(bol, limit, _igvn.intcon(is_positive_stride ? min_jint : max_jint), TypeInt::INT);\n-  register_new_node(limit, pre_ctrl);\n-\n-  limit = is_positive_stride ? (Node*)(new (C) MinINode(old_limit, limit))\n-                             : (Node*)(new (C) MaxINode(old_limit, limit));\n+  Node* inner_result_int = new (C) ConvL2INode(inner_result_long); \/\/ Could under-\/overflow but that's fine as comparison was done with CmpL\n+  register_new_node(inner_result_int, pre_ctrl);\n+  limit = new (C) CMoveINode(bol, old_limit, inner_result_int, TypeInt::INT);\n","filename":"hotspot\/src\/share\/vm\/opto\/loopTransform.cpp","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262017\n+ * @summary Dominator failure because ConvL2I node becomes TOP due to missing overflow\/underflow handling in range check elimination\n+ *          in PhaseIdealLoop::add_constraint().\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,compiler.rangechecks.TestRangeCheckLimits::*\n+ *                   compiler.rangechecks.TestRangeCheckLimits\n+ *\/\n+\n+ package compiler.rangechecks;\n+\n+ public class TestRangeCheckLimits {\n+    static int a = 400;\n+    static volatile int b;\n+    static long lFld;\n+    static int iFld;\n+\n+    public static void main(String[] k) {\n+        \/\/ Test all cases in PhaseIdealLoop::add_constraint().\n+        testPositiveCaseMainLoop();\n+        testNegativeCaseMainLoop();\n+        testPositiveCasePreLoop();\n+        testNegativeCasePreLoop();\n+    }\n+\n+    public static void testPositiveCaseMainLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n+                j = g - 5;\n+                if (j > Integer.MAX_VALUE - 1) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+\n+\n+    public static void testPositiveCasePreLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n+                j = g + 5;\n+                if (j > 180) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+\n+    public static void testNegativeCaseMainLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 8; g < 168; g += 2) {\n+                j = g;\n+                if (j < 5) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 168) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+\n+\n+    public static void testNegativeCasePreLoop() {\n+        int e, f, g = 0, h[] = new int[a];\n+        double i[] = new double[a];\n+        long j = 9;\n+        Helper.init(h, 3);\n+        for (e = 5; e < 154; e++) {\n+            for (f = 1; f < 169; f += 2) {\n+                b = e;\n+            }\n+            i[1] = b;\n+            for (g = 168; g > 8; g -= 2) {\n+                j = g - 5;\n+                if (j > Integer.MAX_VALUE - 1) {\n+                    switch (3) {\n+                        case 3:\n+                    }\n+                }\n+            }\n+        }\n+        if (g != 8) {\n+            throw new RuntimeException(\"fail\");\n+        }\n+        lFld = j;\n+    }\n+}\n+\n+class Helper {\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/compiler\/rangechecks\/TestRangeCheckLimits.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}