{"files":[{"patch":"@@ -175,0 +175,10 @@\n+\t<LI><P><B>http.keepAlive.time.server<\/B> and\n+        <B>http.keepAlive.time.proxy<\/B> <\/P>\n+\t<P>These properties modify the behavior of the HTTP keepalive cache in the case\n+        where the server (or proxy) has not specified a keepalive time. If the\n+        property is set in this case, then idle connections will be closed after the\n+        specified number of seconds. If the property is set, and the server does\n+        specify a keepalive time in a \"Keep-Alive\" response header, then the time specified\n+        by the server is used. If the property is not set and also the server\n+        does not specify a keepalive time, then connections are kept alive for an\n+        implementation defined time, assuming {@code http.keepAlive} is {@code true}.<\/P>\n","filename":"jdk\/src\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,7 +117,7 @@\n-    \/**Idle timeout value, in milliseconds. Zero means infinity,\n-     * iff keepingAlive=true.\n-     * Unfortunately, we can't always believe this one.  If I'm connected\n-     * through a Netscape proxy to a server that sent me a keep-alive\n-     * time of 15 sec, the proxy unilaterally terminates my connection\n-     * after 5 sec.  So we have to hard code our effective timeout to\n-     * 4 sec for the case where we're using a proxy. *SIGH*\n+    \/*\n+     * The timeout if specified by the server. Following values possible\n+     *  0: the server specified no keep alive headers\n+     * -1: the server provided \"Connection: keep-alive\" but did not specify a\n+     *     a particular time in a \"Keep-Alive:\" headers\n+     * Positive values are the number of seconds specified by the server\n+     * in a \"Keep-Alive\" header\n@@ -819,1 +819,9 @@\n-                        keepAliveTimeout = p.findInt(\"timeout\", usingProxy?60:5);\n+                        if (keepAliveConnections < 0) {\n+                            keepAliveConnections = usingProxy?50:5;\n+                        }\n+                        keepAliveTimeout = p.findInt(\"timeout\", -1);\n+                        if (keepAliveTimeout < -1) {\n+                            \/\/ if the server specified a negative (invalid) value\n+                            \/\/ then we set to -1, which is equivalent to no value\n+                            keepAliveTimeout = -1;\n+                        }\n@@ -1073,0 +1081,4 @@\n+    public boolean getUsingProxy() {\n+        return usingProxy;\n+    }\n+\n","filename":"jdk\/src\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import sun.net.www.protocol.http.HttpURLConnection;\n+import sun.util.logging.PlatformLogger;\n@@ -53,0 +55,26 @@\n+    \/\/ Keep alive time set according to priority specified here:\n+    \/\/ 1. If server specifies a time with a Keep-Alive header\n+    \/\/ 2. If user specifies a time with system property below\n+    \/\/ 3. Default values which depend on proxy vs server and whether\n+    \/\/    a Connection: keep-alive header was sent by server\n+\n+    \/\/ name suffixed with \"server\" or \"proxy\"\n+    private static final String keepAliveProp = \"http.keepAlive.time.\";\n+\n+    private static final int userKeepAliveServer;\n+    private static final int userKeepAliveProxy;\n+\n+    static final PlatformLogger logger = HttpURLConnection.getHttpLogger();\n+\n+    @SuppressWarnings(\"removal\")\n+    static int getUserKeepAliveSeconds(String type) {\n+        int v = AccessController.doPrivileged(\n+            new GetIntegerAction(keepAliveProp+type, -1)).intValue();\n+        return v < -1 ? -1 : v;\n+    }\n+\n+    static {\n+        userKeepAliveServer = getUserKeepAliveSeconds(\"server\");\n+        userKeepAliveProxy = getUserKeepAliveSeconds(\"proxy\");\n+    }\n+\n@@ -130,4 +158,23 @@\n-            v = new ClientVector(keepAliveTimeout > 0 ?\n-                                 keepAliveTimeout * 1000 : LIFETIME);\n-            v.put(http);\n-            super.put(key, v);\n+                if (keepAliveTimeout == 0) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ same default for server and proxy\n+                        keepAliveTimeout = 5;\n+                    }\n+                } else if (keepAliveTimeout == -1) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ different default for server and proxy\n+                        keepAliveTimeout = http.getUsingProxy() ? 60 : 5;\n+                    }\n+                }\n+                \/\/ at this point keepAliveTimeout is the number of seconds to keep\n+                \/\/ alive, which could be 0, if the user specified 0 for the property\n+                assert keepAliveTimeout >= 0;\n+                if (keepAliveTimeout == 0) {\n+                    http.closeServer();\n+                } else {\n+                    v = new ClientVector(keepAliveTimeout * 1000);\n+                    v.put(http);\n+                    super.put(key, v);\n+                }\n@@ -139,0 +186,5 @@\n+    \/\/ returns the keep alive set by user in system property or -1 if not set\n+    private static int getUserKeepAlive(boolean isProxy) {\n+        return isProxy ? userKeepAliveProxy : userKeepAliveServer;\n+    }\n+\n@@ -255,0 +307,5 @@\n+                if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+                    String msg = \"cached HttpClient was idle for \"\n+                        + Long.toString(currentTime - e.idleStartTime);\n+                    KeepAliveCache.logger.finest(msg);\n+                }\n","filename":"jdk\/src\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291637\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 timeout\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 max\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class B8291637 {\n+    static CompletableFuture<Boolean> passed = new CompletableFuture<>();\n+\n+    static class Server extends Thread {\n+        final ServerSocket serverSocket;\n+        final int port;\n+        final String param; \/\/ the parameter to test \"max\" or \"timeout\"\n+        volatile Socket s;\n+\n+        public Server(String param) throws IOException {\n+            serverSocket = new ServerSocket(0);\n+            port = serverSocket.getLocalPort();\n+            setDaemon(true);\n+            this.param = param;\n+        }\n+\n+        public int getPort() {\n+            return port;\n+        }\n+\n+        public void close() {\n+            try {\n+                serverSocket.close();\n+                if (s != null)\n+                    s.close();\n+            } catch (IOException e) {}\n+        }\n+\n+        static void readRequest(Socket s) throws IOException {\n+            InputStream is = s.getInputStream();\n+            is.read();\n+            while (is.available() > 0)\n+                is.read();\n+        }\n+\n+        public void run() {\n+            try {\n+                while (true) {\n+                    s = serverSocket.accept();\n+                    readRequest(s);\n+                    OutputStream os = s.getOutputStream();\n+                    String resp = \"\" +\n+                            \"HTTP\/1.1 200 OK\\r\\n\" +\n+                            \"Content-Length: 11\\r\\n\" +\n+                            \"Connection: Keep-Alive\\r\\n\" +\n+                            \"Keep-Alive: \" + param + \"=-10\\r\\n\" + \/\/ invalid negative value\n+                            \"\\r\\n\" +\n+                            \"Hello World\";\n+                    os.write(resp.getBytes(StandardCharsets.ISO_8859_1));\n+                    os.flush();\n+                    InputStream is = s.getInputStream();\n+                    long l1 = System.currentTimeMillis();\n+                    is.read();\n+                    long l2 = System.currentTimeMillis();\n+                    long diff = (l2 - l1) \/ 1000;\n+                    \/*\n+                     * timeout is set to 20 seconds. If bug is still present\n+                     * then the timeout will occur the first time the keep alive\n+                     * thread wakes up which is after 5 seconds. This allows\n+                     * very large leeway with slow running hardware.\n+                     *\n+                     * Same behavior should occur in case of max=-1 with the bug\n+                     *\/\n+                    if (diff < 19) {\n+                        passed.complete(false);\n+                    } else {\n+                        passed.complete(true);\n+                    }\n+                    System.out.println(\"Time diff = \" + diff);\n+                }\n+            } catch (Throwable t) {\n+                System.err.println(\"Server exception terminating: \" + t);\n+                passed.completeExceptionally(t);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Server server = new Server(args[0]);\n+        int port = server.getPort();\n+        server.start();\n+        URL url = new URL(\"http:\/\/127.0.0.1:\" + Integer.toString(port) + \"\/\");\n+        HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n+        InputStream i = urlc.getInputStream();\n+        int c,count=0;\n+        byte[] buf = new byte[256];\n+        while ((c=i.read(buf)) != -1) {\n+            count+=c;\n+        }\n+        i.close();\n+        System.out.println(\"Read \" + count );\n+        try {\n+            if (!passed.get()) {\n+                throw new RuntimeException(\"Test failed\");\n+            } else {\n+                System.out.println(\"Test passed\");\n+            }\n+        } finally {\n+            server.close();\n+        }\n+    }\n+}\n","filename":"jdk\/test\/sun\/net\/www\/http\/KeepAliveCache\/B8291637.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/lib\/testlibrary\n+ * @bug 8278067\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=30 KeepAliveProperty long\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=1 KeepAliveProperty short\n+ * @run main\/othervm -ea -Dhttp.keepAlive.time.server=0 KeepAliveProperty short\n+ *\/\n+\n+import java.net.*;\n+import java.io.*;\n+import java.nio.charset.*;\n+import java.util.logging.*;\n+import jdk.testlibrary.net.URIBuilder;\n+import static java.net.Proxy.NO_PROXY;\n+\n+public class KeepAliveProperty {\n+\n+    static volatile boolean pass = false;\n+\n+    static class Server extends Thread {\n+        final ServerSocket server;\n+\n+        Server (ServerSocket server) {\n+            super ();\n+            this.server = server;\n+        }\n+\n+        void readAll (Socket s) throws IOException {\n+            byte[] buf = new byte [128];\n+            int c;\n+            String request = \"\";\n+            InputStream is = s.getInputStream ();\n+            while ((c=is.read(buf)) > 0) {\n+                request += new String(buf, 0, c, StandardCharsets.US_ASCII);\n+                if (request.contains(\"\\r\\n\\r\\n\")) {\n+                    return;\n+                }\n+            }\n+            if (c == -1)\n+                throw new IOException(\"Socket closed\");\n+        }\n+\n+        Socket s = null;\n+        String BODY;\n+        String CLEN;\n+        PrintStream out;\n+\n+        public void run() {\n+            try {\n+                s = server.accept();\n+                readAll(s);\n+\n+                BODY = \"Hello world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+                out = new PrintStream(new BufferedOutputStream(s.getOutputStream() ));\n+\n+                \/* send the header *\/\n+                out.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out.print(CLEN);\n+                out.print(\"\\r\\n\");\n+                out.print(BODY);\n+                out.flush();\n+            } catch (Exception e) {\n+                pass = false;\n+                try {\n+                    if (s != null)\n+                        s.close();\n+                    server.close();\n+                } catch (IOException unused) {}\n+                return;\n+            }\n+\n+            \/\/ second request may legitimately fail\n+\n+            try (Socket s2 = s; ServerSocket server2 = server; PrintStream out2 = out) {\n+                \/\/ wait for second request.\n+                readAll(s2);\n+\n+                BODY = \"Goodbye world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+\n+                \/* send the header *\/\n+                out2.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out2.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out2.print(CLEN);\n+                out2.print(\"\\r\\n\");\n+                out2.print(BODY);\n+                out2.flush();\n+                pass = !expectClose;\n+                if (!pass) System.out.println(\"Failed: expected close\");\n+            } catch (Exception e) {\n+                pass = expectClose;\n+                if (!pass) System.out.println(\"Failed: did not expect close\");\n+            }\n+        }\n+    }\n+\n+    static String fetch(URL url) throws Exception {\n+        InputStream in = url.openConnection(NO_PROXY).getInputStream();\n+        String s = \"\";\n+        byte b[] = new byte[128];\n+        int n;\n+        do {\n+            n = in.read(b);\n+            if (n > 0)\n+                s += new String(b, 0, n, StandardCharsets.US_ASCII);\n+        } while (n > 0);\n+        in.close();\n+        return s;\n+    }\n+\n+    static volatile boolean expectClose;\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ exercise the logging code\n+        Logger logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+        logger.setLevel(Level.FINEST);\n+        ConsoleHandler h = new ConsoleHandler();\n+        h.setLevel(Level.FINEST);\n+        logger.addHandler(h);\n+\n+        expectClose = args[0].equals(\"short\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ServerSocket ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n+        Server s = new Server(ss);\n+        s.start();\n+\n+        URL url = URIBuilder.newBuilder()\n+            .scheme(\"http\")\n+            .loopback()\n+            .port(ss.getLocalPort())\n+            .toURL();\n+        System.out.println(\"URL: \" + url);\n+\n+        if (!fetch(url).equals(\"Hello world\"))\n+            throw new RuntimeException(\"Failed on first request\");\n+\n+        \/\/ Wait a while to see if connection is closed\n+        Thread.sleep(3 * 1000);\n+\n+        try {\n+            if (!fetch(url).equals(\"Goodbye world\"))\n+                throw new RuntimeException(\"Failed on second request\");\n+        } catch (Exception e) {\n+            if (!expectClose)\n+                throw e;\n+        }\n+\n+        if (!pass)\n+            throw new RuntimeException(\"Failed in server\");\n+    }\n+}\n","filename":"jdk\/test\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}