{"files":[{"patch":"@@ -267,5 +267,11 @@\n-            \/\/ Check the response\n-            if (debug != null &&\n-                con.getResponseCode() != HttpURLConnection.HTTP_OK) {\n-                debug.println(\"Received HTTP error: \" + con.getResponseCode()\n-                    + \" - \" + con.getResponseMessage());\n+            \/\/ Check the response.  Non-200 codes will generate an exception\n+            \/\/ but path validation may complete successfully if revocation info\n+            \/\/ can be obtained elsewhere (e.g. CRL).\n+            int respCode = con.getResponseCode();\n+            if (respCode != HttpURLConnection.HTTP_OK) {\n+                String msg = \"Received HTTP error: \" + respCode + \" - \" +\n+                        con.getResponseMessage();\n+                if (debug != null) {\n+                    debug.println(msg);\n+                }\n+                throw new IOException(msg);\n@@ -273,1 +279,0 @@\n-            InputStream in = con.getInputStream();\n@@ -276,2 +281,17 @@\n-            if (contentLength == -1) {\n-                contentLength = Integer.MAX_VALUE;\n+            if (contentLength == -1){\n+                \/\/ read all available content from the input stream\n+                InputStream in = con.getInputStream();\n+                final int initialBufferSize = 2048;\n+                byte[] response = new byte[initialBufferSize];\n+                int total = 0;\n+                while (true) {\n+                    int read = in.read(response, total, response.length - total);\n+                    if (read == -1){\n+                        break;\n+                    }\n+                    total += read;\n+                    if (total == response.length){\n+                        response = Arrays.copyOf(response, 2 * response.length);\n+                    }\n+                }\n+                return Arrays.copyOf(response, total);\n@@ -279,10 +299,16 @@\n-            byte[] response = new byte[contentLength > 2048 ? 2048 : contentLength];\n-\n-            int total = 0;\n-            while (total < contentLength) {\n-                int count = in.read(response, total, response.length - total);\n-                if (count < 0)\n-                    break;\n-                total += count;\n-                if (total == response.length && total < contentLength) {\n-                    response = Arrays.copyOf(response, total * 2);\n+            else {\n+                \/\/ read exactly contentLength bytes from the input stream\n+                InputStream in = con.getInputStream();\n+                byte[] response = new byte[contentLength];\n+                int total = 0;\n+                while (total < contentLength) {\n+                    int read = in.read(response, total, contentLength - total);\n+                    if (read == -1){\n+                        String msg = \"ACTUAL content length = \" + total + \" vs. \" +\n+                            contentLength + \" EXPECTED\";\n+                        if (debug != null) {\n+                            debug.println(msg);\n+                        }\n+                        throw new IOException(msg);\n+                    }\n+                    total += read;\n@@ -290,0 +316,1 @@\n+                return response;\n@@ -291,1 +318,0 @@\n-            return  Arrays.copyOf(response, total);\n","filename":"jdk\/src\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":45,"deletions":19,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -121,5 +122,4 @@\n-            for (int i = 0; (i < 100 && !ocspResponder.isServerReady()); i++) {\n-                Thread.sleep(50);\n-            }\n-            if (!ocspResponder.isServerReady()) {\n-                throw new RuntimeException(\"Server not ready yet\");\n+            boolean readyStatus =\n+                    ocspResponder.awaitServerReady(5, TimeUnit.SECONDS);\n+            if (!readyStatus) {\n+                throw new RuntimeException(\"Server not ready\");\n","filename":"jdk\/test\/java\/security\/cert\/CertPathValidator\/OCSP\/GetAndPostTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    private volatile boolean serverReady = false;\n+    private CountDownLatch serverReady = new CountDownLatch(1);\n@@ -96,0 +96,1 @@\n+    private boolean omitContentLength = false;\n@@ -225,3 +226,0 @@\n-                    \/\/ Singal ready\n-                    serverReady = true;\n-\n@@ -233,0 +231,4 @@\n+                    \/\/ Decrement the latch, allowing any waiting entities\n+                    \/\/ to proceed with their requests.\n+                    serverReady.countDown();\n+\n@@ -266,1 +268,1 @@\n-                    serverReady = false;\n+                    serverReady = new CountDownLatch(1);\n@@ -506,1 +508,1 @@\n-        if (serverReady) {\n+        if (serverReady.getCount() == 0) {\n@@ -516,1 +518,5 @@\n-     * Use to check if OCSP server is ready to accept connection.\n+     * Allow SimpleOCSPServer consumers to wait for the server to be in\n+     * the ready state before sending requests.\n+     *\n+     * @param timeout the length of time to wait for the server to be ready\n+     * @param unit the unit of time applied to the timeout parameter\n@@ -518,1 +524,5 @@\n-     * @return true if server ready, false otherwise\n+     * @return true if the server enters the ready state, false if the\n+     *      timeout period elapses while the caller is waiting for the server\n+     *      to become ready.\n+     *\n+     * @throws InterruptedException if the current thread is interrupted.\n@@ -520,2 +530,3 @@\n-    public boolean isServerReady() {\n-        return serverReady;\n+    public boolean awaitServerReady(long timeout, TimeUnit unit)\n+            throws InterruptedException {\n+        return serverReady.await(timeout, unit);\n@@ -540,0 +551,13 @@\n+    \/**\n+     * Setting to control whether HTTP responses have the Content-Length\n+     * field asserted or not.\n+     *\n+     * @param isDisabled true if the Content-Length field should not be\n+     *        asserted, false otherwise.\n+     *\/\n+    public void setDisableContentLength(boolean isDisabled) {\n+        if (!started) {\n+            omitContentLength = isDisabled;\n+        }\n+    }\n+\n@@ -785,2 +809,5 @@\n-            sb.append(\"Content-Length: \").append(respBytes.length);\n-            sb.append(\"\\r\\n\\r\\n\");\n+            if (!omitContentLength) {\n+                sb.append(\"Content-Length: \").append(respBytes.length).\n+                        append(\"\\r\\n\");\n+            }\n+            sb.append(\"\\r\\n\");\n","filename":"jdk\/test\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -565,5 +565,3 @@\n-        for (int i = 0; (i < 100 && !rootOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -618,5 +616,3 @@\n-        for (int i = 0; (i < 100 && !intOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        readyStatus = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n","filename":"jdk\/test\/javax\/net\/ssl\/Stapling\/HttpsUrlConnClient.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,5 +508,3 @@\n-        for (int i = 0; (i < 100 && !rootOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -561,5 +559,3 @@\n-        for (int i = 0; (i < 100 && !intOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        readyStatus = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n","filename":"jdk\/test\/javax\/net\/ssl\/Stapling\/SSLEngineWithStapling.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,5 +435,3 @@\n-        for (int i = 0; (i < 100 && !rootOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Root OCSP responder not ready yet\");\n+        boolean rootOcspReady = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!rootOcspReady) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -497,6 +495,5 @@\n-        for (int i = 0; (i < 100 && (!intOcsp.isServerReady() ||\n-                !rootOcsp.isServerReady())); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady() || !rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        \/\/ Wait up to 5 seconds for each server\n+        boolean rootOcspReady = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        boolean intOcspReady = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!rootOcspReady || !intOcspReady) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -566,6 +563,5 @@\n-        for (int i = 0; (i < 100 && (!intOcsp.isServerReady() ||\n-                        !rootOcsp.isServerReady())); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady() || !rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        \/\/ Wait up to 5 seconds for each server\n+        boolean rootOcspReady = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        boolean intOcspReady = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!rootOcspReady || !intOcspReady) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -605,6 +601,5 @@\n-        for (int i = 0; (i < 100 && (!intOcsp.isServerReady() ||\n-                        !rootOcsp.isServerReady())); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady() || !rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        \/\/ Wait up to 5 seconds for each server\n+        boolean rootOcspReady = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        boolean intOcspReady = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!rootOcspReady || !intOcspReady) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -657,6 +652,5 @@\n-        for (int i = 0; (i < 100 && (!intOcsp.isServerReady() ||\n-                !rootOcsp.isServerReady())); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady() || !rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        \/\/ Wait up to 5 seconds for each server\n+        rootOcspReady = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        intOcspReady = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!rootOcspReady || !intOcspReady) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -962,5 +956,3 @@\n-        for (int i = 0; (i < 100 && !rootOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -1015,5 +1007,3 @@\n-        for (int i = 0; (i < 100 && !intOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        readyStatus = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n","filename":"jdk\/test\/javax\/net\/ssl\/Stapling\/SSLSocketWithStapling.java","additions":30,"deletions":40,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -699,5 +699,3 @@\n-        for (int i = 0; (i < 100 && !rootOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -752,5 +750,3 @@\n-        for (int i = 0; (i < 100 && !intOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        readyStatus = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n","filename":"jdk\/test\/javax\/net\/ssl\/Stapling\/StapleEnableProps.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296343\n+ * @summary CPVE thrown on missing content-length in OCSP response\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.provider.certpath\n+ *          java.base\/sun.security.util\n+ * @library ..\/..\/..\/..\/..\/java\/security\/testlibrary\n+ * @build CertificateBuilder SimpleOCSPServer\n+ * @run main\/othervm OCSPNoContentLength\n+ *\/\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PublicKey;\n+import java.security.cert.*;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.testlibrary.CertificateBuilder;\n+\n+public class OCSPNoContentLength {\n+\n+    static String passwd = \"passphrase\";\n+    static String ROOT_ALIAS = \"root\";\n+    static String EE_ALIAS = \"endentity\";\n+\n+    \/\/ Enable debugging for additional output\n+    static final boolean debug = false;\n+\n+    \/\/ PKI components we will need for this test\n+    static X509Certificate rootCert;        \/\/ The root CA certificate\n+    static X509Certificate eeCert;          \/\/ The end entity certificate\n+    static KeyStore rootKeystore;           \/\/ Root CA Keystore\n+    static KeyStore eeKeystore;             \/\/ End Entity Keystore\n+    static KeyStore trustStore;             \/\/ SSL Client trust store\n+    static SimpleOCSPServer rootOcsp;       \/\/ Root CA OCSP Responder\n+    static int rootOcspPort;                \/\/ Port number for root OCSP\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        try {\n+            createPKI();\n+\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            CertPath path = cf.generateCertPath(\n+                Collections.unmodifiableList(\n+                    new ArrayList<Certificate>() {{ add(eeCert); }}\n+                )\n+            );\n+            log(\"%s\", path);\n+\n+            TrustAnchor anchor = new TrustAnchor(rootCert, null);\n+            log(\"%s\", anchor);\n+            Set<TrustAnchor> anchors = Collections.unmodifiableSet(\n+                new HashSet<TrustAnchor>() {{ add(anchor); }}\n+            );\n+\n+            CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n+            PKIXParameters params = new PKIXParameters(anchors);\n+            PKIXRevocationChecker prc =\n+                (PKIXRevocationChecker)validator.getRevocationChecker();\n+            params.addCertPathChecker(prc);\n+\n+            validator.validate(path, params);\n+        } finally {\n+            rootOcsp.stop();\n+        }\n+    }\n+\n+\n+    \/**\n+     * Creates the PKI components necessary for this test, including\n+     * Root CA, Intermediate CA and SSL server certificates, the keystores\n+     * for each entity, a client trust store, and starts the OCSP responders.\n+     *\/\n+    private static void createPKI() throws Exception {\n+        CertificateBuilder cbld = new CertificateBuilder();\n+        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"EC\");\n+        keyGen.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+        KeyStore.Builder keyStoreBuilder =\n+                KeyStore.Builder.newInstance(\"PKCS12\", null,\n+                        new KeyStore.PasswordProtection(passwd.toCharArray()));\n+\n+        \/\/ Generate Root and EE keys\n+        KeyPair rootCaKP = keyGen.genKeyPair();\n+        log(\"Generated Root CA KeyPair\");\n+        KeyPair eeKP = keyGen.genKeyPair();\n+        log(\"Generated End Entity KeyPair\");\n+\n+        \/\/ Set up the Root CA Cert\n+        cbld.setSubjectName(\"CN=Root CA Cert, O=SomeCompany\");\n+        cbld.setPublicKey(rootCaKP.getPublic());\n+        cbld.setSerialNumber(new BigInteger(\"1\"));\n+        \/\/ Make a 3 year validity starting from 60 days ago\n+        long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(60);\n+        long end = start + TimeUnit.DAYS.toMillis(1085);\n+        cbld.setValidity(new Date(start), new Date(end));\n+        addCommonExts(cbld, rootCaKP.getPublic(), rootCaKP.getPublic());\n+        addCommonCAExts(cbld);\n+        \/\/ Make our Root CA Cert!\n+        rootCert = cbld.build(null, rootCaKP.getPrivate(),\n+                \"SHA256withECDSA\");\n+        log(\"Root CA Created:\\n%s\", certInfo(rootCert));\n+\n+        \/\/ Now build a keystore and add the keys and cert\n+        rootKeystore = keyStoreBuilder.getKeyStore();\n+        Certificate[] rootChain = {rootCert};\n+        rootKeystore.setKeyEntry(ROOT_ALIAS, rootCaKP.getPrivate(),\n+                passwd.toCharArray(), rootChain);\n+\n+        \/\/ Now fire up the OCSP responder\n+        rootOcsp = new SimpleOCSPServer(rootKeystore, passwd, ROOT_ALIAS, null);\n+        rootOcsp.enableLog(debug);\n+        rootOcsp.setNextUpdateInterval(3600);\n+        rootOcsp.setDisableContentLength(true);\n+        rootOcsp.start();\n+\n+        \/\/ Wait 5 seconds for server ready\n+        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n+        }\n+\n+        rootOcspPort = rootOcsp.getPort();\n+        String rootRespURI = \"http:\/\/localhost:\" + rootOcspPort;\n+        log(\"Root OCSP Responder URI is %s\", rootRespURI);\n+\n+        \/\/ Now that we have the root keystore and OCSP responder we can\n+        \/\/ create our end entity certificate\n+        cbld.reset();\n+        cbld.setSubjectName(\"CN=SSLCertificate, O=SomeCompany\");\n+        cbld.setPublicKey(eeKP.getPublic());\n+        cbld.setSerialNumber(new BigInteger(\"4096\"));\n+        \/\/ Make a 1 year validity starting from 7 days ago\n+        start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);\n+        end = start + TimeUnit.DAYS.toMillis(365);\n+        cbld.setValidity(new Date(start), new Date(end));\n+\n+        \/\/ Add extensions\n+        addCommonExts(cbld, eeKP.getPublic(), rootCaKP.getPublic());\n+        boolean[] kuBits = {true, false, false, false, false, false,\n+                false, false, false};\n+        cbld.addKeyUsageExt(kuBits);\n+        List<String> ekuOids = new ArrayList<>();\n+        ekuOids.add(\"1.3.6.1.5.5.7.3.1\");\n+        ekuOids.add(\"1.3.6.1.5.5.7.3.2\");\n+        cbld.addExtendedKeyUsageExt(ekuOids);\n+        cbld.addSubjectAltNameDNSExt(Collections.singletonList(\"localhost\"));\n+        cbld.addAIAExt(Collections.singletonList(rootRespURI));\n+        \/\/ Make our End Entity Cert!\n+        eeCert = cbld.build(rootCert, rootCaKP.getPrivate(),\n+                \"SHA256withECDSA\");\n+        log(\"SSL Certificate Created:\\n%s\", certInfo(eeCert));\n+\n+        \/\/ Provide end entity cert revocation info to the Root CA\n+        \/\/ OCSP responder.\n+        Map<BigInteger, SimpleOCSPServer.CertStatusInfo> revInfo =\n+                new HashMap<>();\n+        revInfo.put(eeCert.getSerialNumber(),\n+                new SimpleOCSPServer.CertStatusInfo(\n+                        SimpleOCSPServer.CertStatus.CERT_STATUS_GOOD));\n+        rootOcsp.updateStatusDb(revInfo);\n+\n+        \/\/ Now build a keystore and add the keys, chain and root cert as a TA\n+        eeKeystore = keyStoreBuilder.getKeyStore();\n+        Certificate[] eeChain = {eeCert, rootCert};\n+        eeKeystore.setKeyEntry(EE_ALIAS, eeKP.getPrivate(),\n+                passwd.toCharArray(), eeChain);\n+        eeKeystore.setCertificateEntry(ROOT_ALIAS, rootCert);\n+\n+        \/\/ And finally a Trust Store for the client\n+        trustStore = keyStoreBuilder.getKeyStore();\n+        trustStore.setCertificateEntry(ROOT_ALIAS, rootCert);\n+    }\n+\n+    private static void addCommonExts(CertificateBuilder cbld,\n+            PublicKey subjKey, PublicKey authKey) throws IOException {\n+        cbld.addSubjectKeyIdExt(subjKey);\n+        cbld.addAuthorityKeyIdExt(authKey);\n+    }\n+\n+    private static void addCommonCAExts(CertificateBuilder cbld)\n+            throws IOException {\n+        cbld.addBasicConstraintsExt(true, true, -1);\n+        \/\/ Set key usage bits for digitalSignature, keyCertSign and cRLSign\n+        boolean[] kuBitSettings = {true, false, false, false, false, true,\n+                true, false, false};\n+        cbld.addKeyUsageExt(kuBitSettings);\n+    }\n+\n+    \/**\n+     * Helper routine that dumps only a few cert fields rather than\n+     * the whole toString() output.\n+     *\n+     * @param cert an X509Certificate to be displayed\n+     *\n+     * @return the String output of the issuer, subject and\n+     * serial number\n+     *\/\n+    private static String certInfo(X509Certificate cert) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Issuer: \").append(cert.getIssuerX500Principal()).\n+                append(\"\\n\");\n+        sb.append(\"Subject: \").append(cert.getSubjectX500Principal()).\n+                append(\"\\n\");\n+        sb.append(\"Serial: \").append(cert.getSerialNumber()).append(\"\\n\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Log a message on stdout\n+     *\n+     * @param format the format string for the log entry\n+     * @param args zero or more arguments corresponding to the format string\n+     *\/\n+    private static void log(String format, Object ... args) {\n+        System.out.format(format + \"\\n\", args);\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/provider\/certpath\/OCSP\/OCSPNoContentLength.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -307,5 +307,3 @@\n-        for (int i = 0; (i < 100 && !rootOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!rootOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n@@ -360,5 +358,3 @@\n-        for (int i = 0; (i < 100 && !intOcsp.isServerReady()); i++) {\n-            Thread.sleep(50);\n-        }\n-        if (!intOcsp.isServerReady()) {\n-            throw new RuntimeException(\"Server not ready yet\");\n+        readyStatus = intOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n","filename":"jdk\/test\/sun\/security\/ssl\/Stapling\/java.base\/sun\/security\/ssl\/StatusResponseManagerTests.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}