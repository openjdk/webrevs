{"files":[{"patch":"@@ -95,0 +95,1 @@\n+    private final boolean forceEnd64;\n@@ -115,0 +116,1 @@\n+        this.forceEnd64 = \"true\".equals(env.get(\"forceZIP64End\"));\n@@ -120,1 +122,1 @@\n-                    new END().write(os, 0);\n+                    new END().write(os, 0, forceEnd64);\n@@ -1017,21 +1019,24 @@\n-                    if (end.cenlen == ZIP64_MINVAL ||\n-                        end.cenoff == ZIP64_MINVAL ||\n-                        end.centot == ZIP64_MINVAL32)\n-                    {\n-                        \/\/ need to find the zip64 end;\n-                        byte[] loc64 = new byte[ZIP64_LOCHDR];\n-                        if (readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)\n-                            != loc64.length) {\n-                            return end;\n-                        }\n-                        long end64pos = ZIP64_LOCOFF(loc64);\n-                        byte[] end64buf = new byte[ZIP64_ENDHDR];\n-                        if (readFullyAt(end64buf, 0, end64buf.length, end64pos)\n-                            != end64buf.length) {\n-                            return end;\n-                        }\n-                        \/\/ end64 found, re-calcualte everything.\n-                        end.cenlen = ZIP64_ENDSIZ(end64buf);\n-                        end.cenoff = ZIP64_ENDOFF(end64buf);\n-                        end.centot = (int)ZIP64_ENDTOT(end64buf); \/\/ assume total < 2g\n-                        end.endpos = end64pos;\n+                    \/\/ try if there is zip64 end;\n+                    byte[] loc64 = new byte[ZIP64_LOCHDR];\n+                    if (end.endpos < ZIP64_LOCHDR ||\n+                        readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)\n+                        != loc64.length ||\n+                        !locator64SigAt(loc64, 0)) {\n+                        return end;\n+                    }\n+                    long end64pos = ZIP64_LOCOFF(loc64);\n+                    byte[] end64buf = new byte[ZIP64_ENDHDR];\n+                    if (readFullyAt(end64buf, 0, end64buf.length, end64pos)\n+                        != end64buf.length ||\n+                        !end64SigAt(end64buf, 0)) {\n+                        return end;\n+                    }\n+                    \/\/ end64 found,\n+                    long cenlen64 = ZIP64_ENDSIZ(end64buf);\n+                    long cenoff64 = ZIP64_ENDOFF(end64buf);\n+                    long centot64 = ZIP64_ENDTOT(end64buf);\n+                    \/\/ double-check\n+                    if (cenlen64 != end.cenlen && end.cenlen != ZIP64_MINVAL ||\n+                        cenoff64 != end.cenoff && end.cenoff != ZIP64_MINVAL ||\n+                        centot64 != end.centot && end.centot != ZIP64_MINVAL32) {\n+                        return end;\n@@ -1039,0 +1044,5 @@\n+                    \/\/ to use the end64 values\n+                    end.cenlen = cenlen64;\n+                    end.cenoff = cenoff64;\n+                    end.centot = (int)centot64; \/\/ assume total < 2g\n+                    end.endpos = end64pos;\n@@ -1204,1 +1214,1 @@\n-        \/\/System.out.printf(\"->sync(%s) starting....!%n\", toString());\n+        \/\/ System.out.printf(\"->sync(%s) starting....!%n\", toString());\n@@ -1295,1 +1305,1 @@\n-            end.write(os, written);\n+            end.write(os, written, forceEnd64);\n@@ -1852,2 +1862,2 @@\n-        void write(OutputStream os, long offset) throws IOException {\n-            boolean hasZip64 = false;\n+        void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {\n+            boolean hasZip64 = forceEnd64; \/\/ false;\n@@ -1878,2 +1888,2 @@\n-                writeLong(os, centot);            \/\/ number of directory entires on disk\n-                writeLong(os, centot);            \/\/ number of directory entires\n+                writeLong(os, centot);            \/\/ number of directory entries on disk\n+                writeLong(os, centot);            \/\/ number of directory entries\n","filename":"jdk\/src\/share\/demo\/nio\/zipfs\/src\/com\/sun\/nio\/zipfs\/ZipFileSystem.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -388,0 +388,3 @@\n+    if (endpos < ZIP64_LOCHDR) {\n+        return -1;\n+    }\n@@ -570,0 +573,2 @@\n+    jlong cenlen64, cenoff64, centot64;\n+    unsigned char end64buf[ZIP64_ENDHDR];\n@@ -597,7 +602,13 @@\n-    if (cenlen == ZIP64_MAGICVAL || cenoff == ZIP64_MAGICVAL ||\n-        total == ZIP64_MAGICCOUNT) {\n-        unsigned char end64buf[ZIP64_ENDHDR];\n-        if ((end64pos = findEND64(zip, end64buf, endpos)) != -1) {\n-            cenlen = ZIP64_ENDSIZ(end64buf);\n-            cenoff = ZIP64_ENDOFF(end64buf);\n-            total = (jint)ZIP64_ENDTOT(end64buf);\n+    if ((end64pos = findEND64(zip, end64buf, endpos)) != -1) {\n+        \/\/ end64 candidate found,\n+        cenlen64 = ZIP64_ENDSIZ(end64buf);\n+        cenoff64 = ZIP64_ENDOFF(end64buf);\n+        centot64 = ZIP64_ENDTOT(end64buf);\n+        \/\/ double-check\n+        if ((cenlen64 == cenlen || cenlen == ZIP64_MAGICVAL) &&\n+            (cenoff64 == cenoff || cenoff == ZIP64_MAGICVAL) &&\n+            (centot64 == total || total == ZIP64_MAGICCOUNT)) {\n+            \/\/ to use the end64 values\n+            cenlen = cenlen64;\n+            cenoff = cenoff64;\n+            total = (jint)centot64;\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zip_util.c","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8184993\n+ * @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8184993 8186464\n@@ -34,0 +34,1 @@\n+import java.net.URI;\n@@ -35,0 +36,3 @@\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n@@ -38,0 +42,4 @@\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n@@ -40,0 +48,4 @@\n+import sun.misc.IOUtils;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -147,2 +159,0 @@\n-\n-\n@@ -156,0 +166,49 @@\n+\n+        \/\/ read a zip file with ZIP64 end\n+        Path path = Paths.get(System.getProperty(\"test.dir\", \"\"), \"end64.zip\");\n+        try {\n+            URI uri = URI.create(\"jar:\" + path.toUri());\n+            Map<String, Object> env = new HashMap<>();\n+            env.put(\"create\", \"true\");\n+            env.put(\"forceZIP64End\", \"true\");\n+            try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {\n+                Files.write(fs.getPath(\"hello\"), \"hello\".getBytes());\n+            }\n+            try (ZipFile zf = new ZipFile(path.toFile())) {\n+                if (!\"hello\".equals(new String(IOUtils.readAllBytes(zf.getInputStream(new ZipEntry(\"hello\"))),\n+                                               US_ASCII)))\n+                    throw new RuntimeException(\"zipfile: read entry failed\");\n+            } catch (IOException x) {\n+                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+            }\n+            try (FileSystem fs = FileSystems.newFileSystem(uri, Collections.emptyMap())) {\n+                if (!\"hello\".equals(new String(Files.readAllBytes(fs.getPath(\"hello\")))))\n+                    throw new RuntimeException(\"zipfs: read entry failed\");\n+            } catch (IOException x) {\n+                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+            }\n+        } finally {\n+            Files.deleteIfExists(path);\n+        }\n+\n+        \/\/ read a zip file created via \"echo hello | zip dst.zip -\", which uses\n+        \/\/ ZIP64 end record\n+        if (Files.notExists(Paths.get(\"\/usr\/bin\/zip\")))\n+            return;\n+        try {\n+            Process zip = new ProcessBuilder(\"zip\", path.toString().toString(), \"-\").start();\n+            OutputStream os = zip.getOutputStream();\n+            os.write(\"hello\".getBytes(US_ASCII));\n+            os.close();\n+            zip.waitFor();\n+            if (zip.exitValue() == 0 && Files.exists(path)) {\n+                try (ZipFile zf = new ZipFile(path.toFile())) {\n+                    if (!\"hello\".equals(new String(IOUtils.readAllBytes(zf.getInputStream(new ZipEntry(\"-\"))))))\n+                        throw new RuntimeException(\"zipfile: read entry failed\");\n+                } catch (IOException x) {\n+                    throw new RuntimeException(\"zipfile: zip64 end failed\");\n+                }\n+            }\n+        } finally {\n+            Files.deleteIfExists(path);\n+        }\n","filename":"jdk\/test\/java\/util\/zip\/ZipFile\/ReadZip.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"}]}