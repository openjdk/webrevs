{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import java.time.ZonedDateTime;\n@@ -47,0 +46,1 @@\n+import java.time.ZonedDateTime;\n@@ -49,0 +49,1 @@\n+import java.util.Collection;\n@@ -60,1 +61,0 @@\n-import java.util.regex.Pattern;\n@@ -62,0 +62,1 @@\n+import java.util.regex.Pattern;\n@@ -103,0 +104,1 @@\n+    private final List<Pattern> disabledPatterns;\n@@ -138,0 +140,7 @@\n+        \/\/ Support patterns only for jdk.tls.disabledAlgorithms\n+        if (PROPERTY_TLS_DISABLED_ALGS.equals(propertyName)) {\n+            disabledPatterns = getDisabledPatterns();\n+        } else {\n+            disabledPatterns = null;\n+        }\n+\n@@ -974,1 +983,3 @@\n-        result = checkAlgorithm(disabledAlgorithms, algorithm, decomposer);\n+        \/\/ We won't check patterns if algorithm check fails.\n+        result = checkAlgorithm(disabledAlgorithms, algorithm, decomposer)\n+                && checkDisabledPatterns(algorithm);\n@@ -979,0 +990,35 @@\n+    private boolean checkDisabledPatterns(final String algorithm) {\n+        return disabledPatterns == null || disabledPatterns.stream().noneMatch(\n+                p -> p.matcher(algorithm).matches());\n+    }\n+\n+    private List<Pattern> getDisabledPatterns() {\n+        List<Pattern> ret = null;\n+        List<String> patternStrings = new ArrayList<>(4);\n+\n+        for (String p : disabledAlgorithms) {\n+            if (p.contains(\"*\")) {\n+                if (!p.startsWith(\"TLS_\")) {\n+                    throw new IllegalArgumentException(\n+                            \"Wildcard pattern must start with \\\"TLS_\\\"\");\n+                }\n+                patternStrings.add(p);\n+            }\n+        }\n+\n+        if (!patternStrings.isEmpty()) {\n+            ret = new ArrayList<>(patternStrings.size());\n+\n+            for (String p : patternStrings) {\n+                \/\/ Exclude patterns from algorithm code flow.\n+                disabledAlgorithms.remove(p);\n+\n+                \/\/ Ignore all regex characters but asterisk.\n+                ret.add(Pattern.compile(\n+                        \"^\\\\Q\" + p.replace(\"*\", \"\\\\E.*\\\\Q\") + \"\\\\E$\"));\n+            }\n+        }\n+\n+        return ret;\n+    }\n+\n","filename":"jdk\/src\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":50,"deletions":4,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -698,1 +698,5 @@\n-# syntax of the disabled algorithm string.\n+# syntax of the disabled algorithm string. Additionally, TLS cipher suites\n+# can be disabled with this property using one or more \"*\" wildcard characters.\n+# For example, \"TLS_RSA_*\" disables all cipher suites that start with\n+# \"TLS_RSA_\". Only cipher suites starting with \"TLS_\" are allowed to have\n+# wildcard characters.\n@@ -708,0 +712,1 @@\n+#       rsa_pkcs1_sha1, secp224r1, TLS_RSA_*\n@@ -1311,1 +1316,1 @@\n-#jdk.jndi.object.factoriesFilter=*\n\\ No newline at end of file\n+#jdk.jndi.object.factoriesFilter=*\n","filename":"jdk\/src\/share\/lib\/security\/java.security-macosx","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSession;\n+\n+\/**\n+ * This is not a test. Actual tests are implemented by concrete subclasses.\n+ * The abstract class AbstractDisableCipherSuites provides a base framework\n+ * for testing cipher suite disablement.\n+ *\/\n+public abstract class AbstractDisableCipherSuites {\n+\n+    private static final byte RECTYPE_HS = 0x16;\n+    private static final byte HSMSG_CLIHELLO = 0x01;\n+    private static final ByteBuffer CLIOUTBUF =\n+            ByteBuffer.wrap(\"Client Side\".getBytes());\n+\n+    \/**\n+     * Create an engine with the default set of cipher suites enabled and make\n+     * sure none of the disabled suites are present in the client hello.\n+     *\n+     * @param disabledSuiteIds the {@code List} of disabled cipher suite IDs\n+     *      to be checked for.\n+     *\n+     * @return true if the test passed (No disabled suites), false otherwise\n+     *\/\n+    protected boolean testDefaultCase(List<Integer> disabledSuiteIds)\n+            throws Exception {\n+        System.err.println(\"\\nTest: Default SSLEngine suite set\");\n+        SSLEngine ssle = makeEngine();\n+        if (getDebug()) {\n+            listCiphers(\"Suite set upon creation\", ssle);\n+        }\n+        SSLEngineResult clientResult;\n+        ByteBuffer cTOs = makeClientBuf(ssle);\n+        clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n+        if (getDebug()) {\n+            dumpResult(\"ClientHello: \", clientResult);\n+        }\n+        cTOs.flip();\n+        boolean foundSuite = areSuitesPresentCH(cTOs, disabledSuiteIds);\n+        if (foundSuite) {\n+            System.err.println(\"FAIL: Found disabled suites!\");\n+            return false;\n+        } else {\n+            System.err.println(\"PASS: No disabled suites found.\");\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Create an engine and set only disabled cipher suites.\n+     * The engine should not create the client hello message since the only\n+     * available suites to assert in the client hello are disabled ones.\n+     *\n+     * @param disabledSuiteNames an array of cipher suite names that\n+     *      should be disabled cipher suites.\n+     *\n+     * @return true if the engine throws SSLHandshakeException during client\n+     *      hello creation, false otherwise.\n+     *\/\n+    protected boolean testEngOnlyDisabled(String[] disabledSuiteNames)\n+            throws Exception {\n+        System.err.println(\n+                \"\\nTest: SSLEngine configured with only disabled suites\");\n+        try {\n+            SSLEngine ssle = makeEngine();\n+            ssle.setEnabledCipherSuites(disabledSuiteNames);\n+            if (getDebug()) {\n+                listCiphers(\"Suite set upon creation\", ssle);\n+            }\n+            SSLEngineResult clientResult;\n+            ByteBuffer cTOs = makeClientBuf(ssle);\n+            clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n+            if (getDebug()) {\n+                dumpResult(\"ClientHello: \", clientResult);\n+            }\n+            cTOs.flip();\n+        } catch (SSLHandshakeException shse) {\n+            System.err.println(\"PASS: Caught expected exception: \" + shse);\n+            return true;\n+        }\n+        System.err.println(\"FAIL: Expected SSLHandshakeException not thrown\");\n+        return false;\n+    }\n+\n+    \/**\n+     * Create an engine and add some disabled suites to the default\n+     * set of cipher suites.  Make sure none of the disabled suites show up\n+     * in the client hello even though they were explicitly added.\n+     *\n+     * @param disabledNames an array of cipher suite names that\n+     *      should be disabled cipher suites.\n+     * @param disabledIds the {@code List} of disabled cipher suite IDs\n+     *      to be checked for.\n+     *\n+     * @return true if the test passed (No disabled suites), false otherwise\n+     *\/\n+    protected boolean testEngAddDisabled(String[] disabledNames,\n+                                         List<Integer> disabledIds) throws Exception {\n+        System.err.println(\"\\nTest: SSLEngine with disabled suites added\");\n+        SSLEngine ssle = makeEngine();\n+\n+        \/\/ Add disabled suites to the existing engine's set of enabled suites\n+        String[] initialSuites = ssle.getEnabledCipherSuites();\n+        String[] plusDisSuites = Arrays.copyOf(initialSuites,\n+                                               initialSuites.length + disabledNames.length);\n+        System.arraycopy(disabledNames, 0, plusDisSuites,\n+                         initialSuites.length, disabledNames.length);\n+        ssle.setEnabledCipherSuites(plusDisSuites);\n+\n+        if (getDebug()) {\n+            listCiphers(\"Suite set upon creation\", ssle);\n+        }\n+        SSLEngineResult clientResult;\n+        ByteBuffer cTOs = makeClientBuf(ssle);\n+        clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n+        if (getDebug()) {\n+            dumpResult(\"ClientHello: \", clientResult);\n+        }\n+        cTOs.flip();\n+        boolean foundDisabled = areSuitesPresentCH(cTOs, disabledIds);\n+        if (foundDisabled) {\n+            System.err.println(\"FAIL: Found disabled suites!\");\n+            return false;\n+        } else {\n+            System.err.println(\"PASS: No disabled suites found.\");\n+            return true;\n+        }\n+    }\n+\n+    protected String getProtocol() {\n+        return \"TLSv1.2\";\n+    }\n+\n+    private SSLEngine makeEngine() throws GeneralSecurityException {\n+        SSLContext ctx = SSLContext.getInstance(getProtocol());\n+        ctx.init(null, null, null);\n+        return ctx.createSSLEngine();\n+    }\n+\n+    private static ByteBuffer makeClientBuf(SSLEngine ssle) {\n+        ssle.setUseClientMode(true);\n+        ssle.setNeedClientAuth(false);\n+        SSLSession sess = ssle.getSession();\n+        ByteBuffer cTOs = ByteBuffer.allocateDirect(sess.getPacketBufferSize());\n+        return cTOs;\n+    }\n+\n+    private static void listCiphers(String prefix, SSLEngine ssle) {\n+        System.err.println(prefix + \"\\n---------------\");\n+        String[] suites = ssle.getEnabledCipherSuites();\n+        for (String suite : suites) {\n+            System.err.println(suite);\n+        }\n+        System.err.println(\"---------------\");\n+    }\n+\n+    \/**\n+     * Walk a TLS 1.2 or earlier ClientHello looking for any of the suites\n+     * in the suiteIdList.\n+     *\n+     * @param clientHello a ByteBuffer containing the ClientHello message as\n+     *      a complete TLS record.  The position of the buffer should be\n+     *      at the first byte of the TLS record header.\n+     * @param suiteIdList a List of integer values corresponding to\n+     *      TLS cipher suite identifiers.\n+     *\n+     * @return true if at least one of the suites in {@code suiteIdList}\n+     * is found in the ClientHello's cipher suite list\n+     *\n+     * @throws IOException if the data in the {@code clientHello}\n+     *      buffer is not a TLS handshake message or is not a client hello.\n+     *\/\n+    private boolean areSuitesPresentCH(ByteBuffer clientHello,\n+                                       List<Integer> suiteIdList) throws IOException {\n+        byte val;\n+\n+        \/\/ Process the TLS Record\n+        val = clientHello.get();\n+        if (val != RECTYPE_HS) {\n+            throw new IOException(\n+                    \"Not a handshake record, type = \" + val);\n+        }\n+\n+        \/\/ Just skip over the version and length\n+        clientHello.position(clientHello.position() + 4);\n+\n+        \/\/ Check the handshake message type\n+        val = clientHello.get();\n+        if (val != HSMSG_CLIHELLO) {\n+            throw new IOException(\n+                    \"Not a ClientHello handshake message, type = \" + val);\n+        }\n+\n+        \/\/ Skip over the length\n+        clientHello.position(clientHello.position() + 3);\n+\n+        \/\/ Skip over the protocol version (2) and random (32);\n+        clientHello.position(clientHello.position() + 34);\n+\n+        \/\/ Skip past the session ID (variable length <= 32)\n+        int len = Byte.toUnsignedInt(clientHello.get());\n+        if (len > 32) {\n+            throw new IOException(\"Session ID is too large, len = \" + len);\n+        }\n+        clientHello.position(clientHello.position() + len);\n+\n+        \/\/ Finally, we are at the cipher suites.  Walk the list and place them\n+        \/\/ into a List.\n+        int csLen = Short.toUnsignedInt(clientHello.getShort());\n+        if (csLen % 2 != 0) {\n+            throw new IOException(\"CipherSuite length is invalid, len = \" +\n+                                          csLen);\n+        }\n+        int csCount = csLen \/ 2;\n+        List<Integer> csSuiteList = new ArrayList<>(csCount);\n+        log(\"Found following suite IDs in hello:\");\n+        for (int i = 0; i < csCount; i++) {\n+            int curSuite = Short.toUnsignedInt(clientHello.getShort());\n+            log(String.format(\"Suite ID: 0x%04x\", curSuite));\n+            csSuiteList.add(curSuite);\n+        }\n+\n+        \/\/ Now check to see if any of the suites passed in match what is in\n+        \/\/ the suite list.\n+        boolean foundMatch = false;\n+        for (Integer cs : suiteIdList) {\n+            if (csSuiteList.contains(cs)) {\n+                System.err.format(\"Found match for suite ID 0x%04x\\n\", cs);\n+                foundMatch = true;\n+                break;\n+            }\n+        }\n+\n+        \/\/ We don't care about the rest of the ClientHello message.\n+        \/\/ Rewind and return whether we found a match or not.\n+        clientHello.rewind();\n+        return foundMatch;\n+    }\n+\n+    private static void dumpResult(String str, SSLEngineResult result) {\n+        System.err.println(\"The format of the SSLEngineResult is: \\n\" +\n+                                   \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n+                                   \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+        System.err.println(str + result.getStatus() + \"\/\" + hsStatus + \", \" +\n+                                   result.bytesConsumed() + \"\/\" + result.bytesProduced() + \" bytes\");\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            System.err.println(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private void log(String str) {\n+        if (getDebug()) {\n+            System.err.println(str);\n+        }\n+    }\n+\n+    protected boolean getDebug() {\n+        return false;\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/ssl\/CipherSuite\/AbstractDisableCipherSuites.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341964\n+ * @summary Add mechanism to disable different parts of TLS cipher suite\n+ * @run testng\/othervm TLSCipherSuiteWildCardMatchingDisablePartsOfCipherSuite\n+ *\/\n+\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.security.Security;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TLSCipherSuiteWildCardMatchingDisablePartsOfCipherSuite extends\n+        AbstractDisableCipherSuites {\n+\n+    private static final String SECURITY_PROPERTY = \"jdk.tls.disabledAlgorithms\";\n+    private static final String TEST_ALGORITHMS =\n+            \"TLS_RSA_*,\"\n+                    + \" TLS_ECDH*WITH_AES_256_GCM_*,\"\n+                    + \" TLS_*_anon_WITH_AES_*_SHA,\"\n+                    + \" TLS_.*\"; \/\/ This pattern should not disable anything\n+    private static final String[] CIPHER_SUITES = new String[] {\n+            \"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n+            \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n+            \"TLS_RSA_WITH_AES_256_CBC_SHA256\",\n+            \"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\",\n+            \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n+            \"TLS_DH_anon_WITH_AES_128_CBC_SHA\",\n+            \"TLS_ECDH_anon_WITH_AES_256_CBC_SHA\"\n+    };\n+    static final List<Integer> CIPHER_SUITES_IDS = Arrays.asList(\n+            0x009D,\n+            0x009C,\n+            0x003D,\n+            0xC02E,\n+            0xC02C,\n+            0x0034,\n+            0xC018\n+    );\n+\n+    @BeforeTest\n+    void setUp() throws Exception {\n+        Security.setProperty(SECURITY_PROPERTY, TEST_ALGORITHMS);\n+    }\n+\n+    @Test\n+    public void testDefault() throws Exception {\n+        assertTrue(testDefaultCase(CIPHER_SUITES_IDS));\n+    }\n+\n+    @Test\n+    public void testAddDisabled() throws Exception {\n+        assertTrue(testEngAddDisabled(CIPHER_SUITES, CIPHER_SUITES_IDS));\n+    }\n+\n+    @Test\n+    public void testOnlyDisabled() throws Exception {\n+        assertTrue(testEngOnlyDisabled(CIPHER_SUITES));\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/ssl\/CipherSuite\/TLSCipherSuiteWildCardMatchingDisablePartsOfCipherSuite.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341964\n+ * @summary Add mechanism to disable different parts of TLS cipher suite\n+ * @run testng\/othervm TLSCipherSuiteWildCardMatchingIllegalArgument\n+ *\/\n+\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.fail;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.security.Security;\n+\n+import javax.net.ssl.SSLContext;\n+\n+\/**\n+ * SSLContext loads \"jdk.tls.disabledAlgorithms\" system property statically\n+ * when it's being loaded into memory, so we can't call\n+ * Security.setProperty(\"jdk.tls.disabledAlgorithms\") more than once per test\n+ * class. Thus, we need a separate test class each time we need to modify\n+ * \"jdk.tls.disabledAlgorithms\" config value for testing.\n+ *\/\n+public class TLSCipherSuiteWildCardMatchingIllegalArgument {\n+\n+    private static final String SECURITY_PROPERTY =\n+            \"jdk.tls.disabledAlgorithms\";\n+    private static final String TEST_ALGORITHMS = \"ECDHE_*_WITH_AES_256_GCM_*\";\n+\n+    @BeforeTest\n+    void setUp() throws Exception {\n+        Security.setProperty(SECURITY_PROPERTY, TEST_ALGORITHMS);\n+    }\n+\n+    @Test\n+    public void testChainedBefore() throws Exception {\n+        try {\n+            SSLContext.getInstance(\"TLS\");\n+            fail(\"No IllegalArgumentException was thrown\");\n+        } catch (ExceptionInInitializerError e) {\n+            assertEquals(IllegalArgumentException.class,\n+                         e.getCause().getClass());\n+            assertEquals(\"Wildcard pattern must start with \\\"TLS_\\\"\",\n+                         e.getCause().getMessage());\n+        }\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/ssl\/CipherSuite\/TLSCipherSuiteWildCardMatchingIllegalArgument.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}