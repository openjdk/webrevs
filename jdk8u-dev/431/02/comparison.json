{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+  private static Type uint64tType;\n@@ -195,0 +196,44 @@\n+     public boolean isCcstr() {\n+        return type.equals(\"ccstr\");\n+     }\n+\n+     public String getCcstr() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isCcstr(), \"not a ccstr flag!\");\n+        }\n+        return CStringUtilities.getString(addr.getAddressAt(0));\n+     }\n+\n+     public boolean isCcstrlist() {\n+        return type.equals(\"ccstrlist\");\n+     }\n+\n+     public String getCcstrlist() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isCcstrlist(), \"not a ccstrlist flag!\");\n+        }\n+        return CStringUtilities.getString(addr.getAddressAt(0));\n+     }\n+\n+     public boolean isDouble() {\n+        return type.equals(\"double\");\n+     }\n+\n+     public double getDouble() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isDouble(), \"not a double flag!\");\n+        }\n+        return addr.getJDoubleAt(0);\n+     }\n+\n+     public boolean isUint64t() {\n+        return type.equals(\"uint64_t\");\n+     }\n+\n+     public long getUint64t() {\n+        if (Assert.ASSERTS_ENABLED) {\n+           Assert.that(isUint64t(), \"not an uint64_t flag!\");\n+        }\n+        return addr.getCIntegerAt(0, uint64tType.getSize(), true);\n+     }\n+\n@@ -201,1 +246,27 @@\n-           return new Long(getUIntx()).toString();\n+           return longToUnsignedString(getUIntx());\n+        } else if (isCcstr()) {\n+           String str = getCcstr();\n+           if (str != null) {\n+              str = \"\\\"\" + str + \"\\\"\";\n+           }\n+           return str;\n+        } else if (isCcstrlist()) {\n+           String str = getCcstrlist();\n+           if (str != null) {\n+              str = \"\\\"\" + str + \"\\\"\";\n+           }\n+           return str;\n+        } else if (isDouble()) {\n+           return new Double(getDouble()).toString();\n+        } else if (isUint64t()) {\n+           return longToUnsignedString(getUint64t());\n+        } else {\n+           throw new WrongTypeException(\"Unknown type: \" + type + \" (\" + name + \")\");\n+        }\n+     }\n+\n+     \/** This is an alternative to Long.toUnsignedString(long i)\n+         Required to build with the boot JDK7. *\/\n+     private String longToUnsignedString(long i) {\n+        if (i >= 0) {\n+           return Long.toString(i);\n@@ -203,1 +274,3 @@\n-           return null;\n+           long quot = (i >>> 1) \/ 5;\n+           long rem = i - quot * 10;\n+           return Long.toString(quot) + rem;\n@@ -328,0 +401,1 @@\n+    uint64tType = db.lookupType(\"uint64_t\");\n","filename":"hotspot\/agent\/src\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":77,"deletions":3,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -456,2 +456,2 @@\n-\/\/ bool, intx, uintx, ccstr.\n-\/\/ The type \"ccstr\" is an alias for \"const char*\" and is used\n+\/\/ bool, intx, uintx, ccstr, ccstrlist, double, or uint64_t.\n+\/\/ The type \"ccstr\" and \"ccstrlist\" are an alias for \"const char*\" and is used\n","filename":"hotspot\/src\/share\/vm\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @comment This test does not work because the Serviceability\/sa test framework is not backported.\n+ *          This test addition should be integrated when the test framework is backported in the future.\n+ * @bug 8190198\n+ * @bug 8217612\n+ * @summary Test clhsdb flags command\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @run main\/othervm ClhsdbFlags\n+ *\/\n+\n+public class ClhsdbFlags {\n+\n+    public static void runBasicTest() throws Exception {\n+        System.out.println(\"Starting ClhsdbFlags basic test\");\n+\n+        LingeredApp theApp = null;\n+        try {\n+            ClhsdbLauncher test = new ClhsdbLauncher();\n+            List<String> vmArgs = new ArrayList<String>();\n+            vmArgs.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            vmArgs.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+            vmArgs.add(\"-XX:-MaxFDLimit\");\n+            vmArgs.addAll(Utils.getVmOptions());\n+            theApp = LingeredApp.startApp(vmArgs);\n+            System.out.println(\"Started LingeredApp with pid \" + theApp.getPid());\n+\n+            List<String> cmds = List.of(\n+                    \"flags\", \"flags -nd\",\n+                    \"flags UnlockDiagnosticVMOptions\", \"flags MaxFDLimit\",\n+                    \"flags MaxJavaStackTraceDepth\");\n+\n+            Map<String, List<String>> expStrMap = new HashMap<>();\n+            expStrMap.put(\"flags\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\",\n+                    \"MaxFDLimit = false\",\n+                    \"MaxJavaStackTraceDepth = 1024\",\n+                    \"VerifyMergedCPBytecodes\",\n+                    \"ConcGCThreads\", \"UseThreadPriorities\",\n+                    \"ShowHiddenFrames\"));\n+            expStrMap.put(\"flags -nd\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\",\n+                    \"MaxFDLimit = false\",\n+                    \"InitialHeapSize\",\n+                    \"MaxHeapSize\"));\n+            expStrMap.put(\"flags UnlockDiagnosticVMOptions\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\"));\n+            expStrMap.put(\"flags MaxFDLimit\", List.of(\n+                    \"MaxFDLimit = false\"));\n+            expStrMap.put(\"flags MaxJavaStackTraceDepth\", List.of(\n+                    \"MaxJavaStackTraceDepth = 1024\"));\n+\n+            test.run(theApp.getPid(), cmds, expStrMap, null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Test ERROR \" + ex, ex);\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+    public static void runAllTypesTest() throws Exception {\n+        System.out.println(\"Starting ClhsdbFlags all types test\");\n+\n+        LingeredApp theApp = null;\n+        try {\n+            ClhsdbLauncher test = new ClhsdbLauncher();\n+            List<String> vmArgs = new ArrayList<String>();\n+            vmArgs.add(\"-XX:+UnlockDiagnosticVMOptions\");   \/\/ bool\n+            vmArgs.add(\"-XX:ActiveProcessorCount=1\");       \/\/ int\n+            vmArgs.add(\"-XX:ParallelGCThreads=1\");          \/\/ uint\n+            vmArgs.add(\"-XX:MaxJavaStackTraceDepth=1024\");  \/\/ intx\n+            vmArgs.add(\"-XX:LogEventsBufferEntries=10\");    \/\/ uintx\n+            vmArgs.add(\"-XX:HeapSizePerGCThread=32m\");      \/\/ size_t\n+            vmArgs.add(\"-XX:NativeMemoryTracking=off\");     \/\/ ccstr\n+            vmArgs.add(\"-XX:OnError='echo error'\");         \/\/ ccstrlist\n+            vmArgs.add(\"-XX:CompileThresholdScaling=1.0\");  \/\/ double\n+            vmArgs.add(\"-XX:ErrorLogTimeout=120\");          \/\/ uint64_t\n+            vmArgs.addAll(Utils.getVmOptions());\n+            theApp = LingeredApp.startApp(vmArgs);\n+            System.out.println(\"Started LingeredApp with pid \" + theApp.getPid());\n+\n+            List<String> cmds = List.of(\"flags\");\n+\n+            Map<String, List<String>> expStrMap = new HashMap<>();\n+            expStrMap.put(\"flags\", List.of(\n+                    \"UnlockDiagnosticVMOptions = true\",\n+                    \"ActiveProcessorCount = 1\",\n+                    \"ParallelGCThreads = 1\",\n+                    \"MaxJavaStackTraceDepth = 1024\",\n+                    \"LogEventsBufferEntries = 10\",\n+                    \"HeapSizePerGCThread = 3\",\n+                    \"NativeMemoryTracking = \\\"off\\\"\",\n+                    \"OnError = \\\"'echo error'\\\"\",\n+                    \"CompileThresholdScaling = 1.0\",\n+                    \"ErrorLogTimeout = 120\"));\n+\n+            test.run(theApp.getPid(), cmds, expStrMap, null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Test ERROR \" + ex, ex);\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runBasicTest();\n+        runAllTypesTest();\n+    }\n+}\n","filename":"hotspot\/test\/serviceability\/sa\/ClhsdbFlags.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"}]}