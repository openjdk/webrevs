{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1455,1 +1455,1 @@\n-void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n+static void* dll_load_library(const char *filename, char *ebuf, int ebuflen) {\n@@ -1483,0 +1483,20 @@\n+\/\/ Load library named <filename>\n+\/\/ If filename matches <name>.so, and loading fails, repeat with <name>.a.\n+void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n+  void* result = nullptr;\n+  char* const file_path = strdup(filename);\n+  char* const pointer_to_dot = strrchr(file_path, '.');\n+  const char old_extension[] = \".so\";\n+  const char new_extension[] = \".a\";\n+  STATIC_ASSERT(sizeof(old_extension) >= sizeof(new_extension));\n+  \/\/ First try to load the existing file.\n+  result = dll_load_library(filename, ebuf, ebuflen);\n+  \/\/ If the load fails,we try to reload by changing the extension to .a for .so files only.\n+  \/\/ Shared object in .so format dont have braces, hence they get removed for archives with members.\n+  if (result == nullptr && pointer_to_dot != nullptr && strcmp(pointer_to_dot, old_extension) == 0) {\n+    snprintf(pointer_to_dot, sizeof(old_extension), \"%s\", new_extension);\n+    result = dll_load_library(file_path, ebuf, ebuflen);\n+  }\n+  FREE_C_HEAP_ARRAY(char, file_path);\n+  return result;\n+}\n","filename":"hotspot\/src\/os\/aix\/vm\/os_aix.cpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}