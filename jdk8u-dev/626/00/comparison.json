{"files":[{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.math.BigInteger;\n-import java.security.*;\n-import java.security.cert.*;\n-import java.time.*;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import sun.security.validator.Validator;\n-import sun.security.validator.ValidatorException;\n-\n-\/**\n- * @test\n- * @bug 8337664 8341059\n- * @summary Check that TLS Server certificates chaining back to distrusted\n- *          Entrust roots are invalid\n- * @library \/lib\/security\n- * @run main\/othervm Distrust after policyOn invalid\n- * @run main\/othervm Distrust after policyOff valid\n- * @run main\/othervm Distrust before policyOn valid\n- * @run main\/othervm Distrust before policyOff valid\n- *\/\n-\n-public class Distrust {\n-\n-    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n-    private static CertificateFactory cf;\n-\n-    \/\/ Each of the roots have a test certificate chain stored in a file\n-    \/\/ named \"<root>-chain.pem\".\n-    private static String[] rootsToTest = new String[] {\n-        \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n-        \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n-        \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\" };\n-\n-    \/\/ A date that is after the restrictions take effect\n-    private static final Date NOVEMBER_12_2024 =\n-        Date.from(LocalDate.of(2024, 11, 12)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the restrictions take effect\n-    private static final Date BEFORE_NOVEMBER_12_2024 =\n-        Date.from(LocalDate.of(2024, 11, 12)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        boolean before = args[0].equals(\"before\");\n-        boolean policyOn = args[1].equals(\"policyOn\");\n-        boolean isValid = args[2].equals(\"valid\");\n-\n-        if (!policyOn) {\n-            \/\/ disable policy (default is on)\n-            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n-        }\n-\n-        Date notBefore = before ? BEFORE_NOVEMBER_12_2024 : NOVEMBER_12_2024;\n-\n-        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n-        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n-        for (String test : rootsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-    }\n-\n-    private static X509TrustManager getTMF(String type,\n-            PKIXBuilderParameters params) throws Exception {\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n-        if (params == null) {\n-            tmf.init((KeyStore)null);\n-        } else {\n-            tmf.init(new CertPathTrustManagerParameters(params));\n-        }\n-        TrustManager[] tms = tmf.getTrustManagers();\n-        for (TrustManager tm : tms) {\n-            X509TrustManager xtm = (X509TrustManager)tm;\n-            return xtm;\n-        }\n-        throw new Exception(\"No TrustManager for \" + type);\n-    }\n-\n-    private static PKIXBuilderParameters getParams() throws Exception {\n-        PKIXBuilderParameters pbp =\n-            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n-                                      new X509CertSelector());\n-        pbp.setRevocationEnabled(false);\n-        return pbp;\n-    }\n-\n-    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n-                               Date notBefore, boolean valid) throws Exception {\n-        \/\/ Check if TLS Server certificate (the first element of the chain)\n-        \/\/ is issued after the specified notBefore date (should be rejected\n-        \/\/ unless distrust property is false). To do this, we need to\n-        \/\/ fake the notBefore date since none of the test certs are issued\n-        \/\/ after then.\n-        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n-\n-        try {\n-            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n-            if (!valid) {\n-                throw new Exception(\"chain should be invalid\");\n-            }\n-        } catch (CertificateException ce) {\n-            \/\/ expired TLS certificates should not be treated as failure\n-            if (expired(ce)) {\n-                System.err.println(\"Test is N\/A, chain is expired\");\n-                return;\n-            }\n-            if (valid) {\n-                throw new Exception(\"Unexpected exception, chain \" +\n-                                    \"should be valid\", ce);\n-            }\n-            if (ce instanceof ValidatorException) {\n-                ValidatorException ve = (ValidatorException)ce;\n-                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n-                    ce.printStackTrace(System.err);\n-                    throw new Exception(\"Unexpected exception: \" + ce);\n-                }\n-            } else {\n-                throw new Exception(\"Unexpected exception: \" + ce);\n-            }\n-        }\n-    }\n-\n-    \/\/ check if a cause of exception is an expired cert\n-    private static boolean expired(CertificateException ce) {\n-        if (ce instanceof CertificateExpiredException) {\n-            return true;\n-        }\n-        Throwable t = ce.getCause();\n-        while (t != null) {\n-            if (t instanceof CertificateExpiredException) {\n-                return true;\n-            }\n-            t = t.getCause();\n-        }\n-        return false;\n-    }\n-\n-    private static X509Certificate[] loadCertificateChain(String name)\n-            throws Exception {\n-        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n-                                                  name + \"-chain.pem\")) {\n-            Collection<X509Certificate> certs =\n-                (Collection<X509Certificate>)cf.generateCertificates(in);\n-            return certs.toArray(new X509Certificate[0]);\n-        }\n-    }\n-\n-    private static class DistrustedTLSServerCert extends X509Certificate {\n-        private final X509Certificate cert;\n-        private final Date notBefore;\n-        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n-            this.cert = cert;\n-            this.notBefore = notBefore;\n-        }\n-        public Set<String> getCriticalExtensionOIDs() {\n-           return cert.getCriticalExtensionOIDs();\n-        }\n-        public byte[] getExtensionValue(String oid) {\n-            return cert.getExtensionValue(oid);\n-        }\n-        public Set<String> getNonCriticalExtensionOIDs() {\n-            return cert.getNonCriticalExtensionOIDs();\n-        }\n-        public boolean hasUnsupportedCriticalExtension() {\n-            return cert.hasUnsupportedCriticalExtension();\n-        }\n-        public void checkValidity() throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public void checkValidity(Date date) throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public int getVersion() { return cert.getVersion(); }\n-        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n-        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n-        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n-        public Date getNotBefore() { return notBefore; }\n-        public Date getNotAfter() { return cert.getNotAfter(); }\n-        public byte[] getTBSCertificate() throws CertificateEncodingException {\n-            return cert.getTBSCertificate();\n-        }\n-        public byte[] getSignature() { return cert.getSignature(); }\n-        public String getSigAlgName() { return cert.getSigAlgName(); }\n-        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n-        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n-        public boolean[] getIssuerUniqueID() {\n-            return cert.getIssuerUniqueID();\n-        }\n-        public boolean[] getSubjectUniqueID() {\n-            return cert.getSubjectUniqueID();\n-        }\n-        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n-        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n-        public byte[] getEncoded() throws CertificateEncodingException {\n-            return cert.getEncoded();\n-        }\n-        public void verify(PublicKey key) throws CertificateException,\n-            InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key);\n-        }\n-        public void verify(PublicKey key, String sigProvider) throws\n-            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key, sigProvider);\n-        }\n-        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n-        public String toString() { return cert.toString(); }\n-    }\n-}\n","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/Distrust.java","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -1,289 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.math.BigInteger;\n-import java.security.*;\n-import java.security.cert.*;\n-import java.time.*;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import sun.security.validator.Validator;\n-import sun.security.validator.ValidatorException;\n-\n-\/**\n- * @test\n- * @bug 8207258 8216280\n- * @summary Check that TLS Server certificates chaining back to distrusted\n- *          Symantec roots are invalid\n- * @library \/lib\/security\n- * @run main\/othervm Distrust after policyOn invalid\n- * @run main\/othervm Distrust after policyOff valid\n- * @run main\/othervm Distrust before policyOn valid\n- * @run main\/othervm Distrust before policyOff valid\n- *\/\n-\n-public class Distrust {\n-\n-    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n-    private static CertificateFactory cf;\n-\n-    \/\/ Each of the roots have a test certificate chain stored in a file\n-    \/\/ named \"<root>-chain.pem\".\n-    private static String[] rootsToTest = new String[] {\n-        \"geotrustprimarycag2\", \"geotrustprimarycag3\",\n-        \"geotrustuniversalca\", \"thawteprimaryrootca\", \"thawteprimaryrootcag2\",\n-        \"thawteprimaryrootcag3\", \"verisignclass3g3ca\", \"verisignclass3g4ca\",\n-        \"verisignclass3g5ca\", \"verisignuniversalrootca\" };\n-\n-    \/\/ Each of the subCAs with a delayed distrust date have a test certificate\n-    \/\/ chain stored in a file named \"<subCA>-chain.pem\".\n-    private static String[] subCAsToTest = new String[]{\"appleistca8g1\"};\n-\n-    \/\/ A date that is after the restrictions take affect\n-    private static final Date APRIL_17_2019 =\n-        Date.from(LocalDate.of(2019, 4, 17)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the restrictions take affect\n-    private static final Date BEFORE_APRIL_17_2019 =\n-        Date.from(LocalDate.of(2019, 4, 17)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    \/\/ A date that is after the subCA restrictions take affect\n-    private static final Date JANUARY_1_2020 =\n-        Date.from(LocalDate.of(2020, 1, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the subCA restrictions take affect\n-    private static final Date BEFORE_JANUARY_1_2020 =\n-        Date.from(LocalDate.of(2020, 1, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        boolean before = args[0].equals(\"before\");\n-        boolean policyOn = args[1].equals(\"policyOn\");\n-        boolean isValid = args[2].equals(\"valid\");\n-\n-        if (!policyOn) {\n-            \/\/ disable policy (default is on)\n-            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n-        }\n-\n-        Date notBefore = before ? BEFORE_APRIL_17_2019 : APRIL_17_2019;\n-\n-        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n-        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n-        for (String test : rootsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-\n-        \/\/ test chain if params are passed to TrustManager\n-        System.err.println(\"Testing verisignuniversalrootca with params\");\n-        testTM(getTMF(\"PKIX\", getParams()),\n-               loadCertificateChain(\"verisignuniversalrootca\"),\n-               notBefore, isValid);\n-\n-        \/\/ test code-signing chain (should be valid as restrictions don't apply)\n-        System.err.println(\"Testing verisignclass3g5ca code-signing chain\");\n-        Validator v = Validator.getInstance(Validator.TYPE_PKIX,\n-                                            Validator.VAR_CODE_SIGNING,\n-                                            getParams());\n-        \/\/ set validation date so this will still pass when cert expires\n-        v.setValidationDate(new Date(1544197375493l));\n-        v.validate(loadCertificateChain(\"verisignclass3g5ca-codesigning\"));\n-\n-        \/\/ test chains issued through subCAs\n-        notBefore = before ? BEFORE_JANUARY_1_2020 : JANUARY_1_2020;\n-        for (String test : subCAsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-    }\n-\n-    private static X509TrustManager getTMF(String type,\n-            PKIXBuilderParameters params) throws Exception {\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n-        if (params == null) {\n-            tmf.init((KeyStore)null);\n-        } else {\n-            tmf.init(new CertPathTrustManagerParameters(params));\n-        }\n-        TrustManager[] tms = tmf.getTrustManagers();\n-        for (TrustManager tm : tms) {\n-            X509TrustManager xtm = (X509TrustManager)tm;\n-            return xtm;\n-        }\n-        throw new Exception(\"No TrustManager for \" + type);\n-    }\n-\n-    private static PKIXBuilderParameters getParams() throws Exception {\n-        PKIXBuilderParameters pbp =\n-            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n-                                      new X509CertSelector());\n-        pbp.setRevocationEnabled(false);\n-        return pbp;\n-    }\n-\n-    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n-                               Date notBefore, boolean valid) throws Exception {\n-        \/\/ Check if TLS Server certificate (the first element of the chain)\n-        \/\/ is issued after the specified notBefore date (should be rejected\n-        \/\/ unless distrust property is false). To do this, we need to\n-        \/\/ fake the notBefore date since none of the test certs are issued\n-        \/\/ after then.\n-        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n-\n-        try {\n-            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n-            if (!valid) {\n-                throw new Exception(\"chain should be invalid\");\n-            }\n-        } catch (CertificateException ce) {\n-            \/\/ expired TLS certificates should not be treated as failure\n-            if (expired(ce)) {\n-                System.err.println(\"Test is N\/A, chain is expired\");\n-                return;\n-            }\n-            if (valid) {\n-                throw new Exception(\"Unexpected exception, chain \" +\n-                                    \"should be valid\", ce);\n-            }\n-            if (ce instanceof ValidatorException) {\n-                ValidatorException ve = (ValidatorException)ce;\n-                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n-                    ce.printStackTrace(System.err);\n-                    throw new Exception(\"Unexpected exception: \" + ce);\n-                }\n-            } else {\n-                throw new Exception(\"Unexpected exception: \" + ce);\n-            }\n-        }\n-    }\n-\n-    \/\/ check if a cause of exception is an expired cert\n-    private static boolean expired(CertificateException ce) {\n-        if (ce instanceof CertificateExpiredException) {\n-            return true;\n-        }\n-        Throwable t = ce.getCause();\n-        while (t != null) {\n-            if (t instanceof CertificateExpiredException) {\n-                return true;\n-            }\n-            t = t.getCause();\n-        }\n-        return false;\n-    }\n-\n-    private static X509Certificate[] loadCertificateChain(String name)\n-            throws Exception {\n-        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n-                                                  name + \"-chain.pem\")) {\n-            Collection<X509Certificate> certs =\n-                (Collection<X509Certificate>)cf.generateCertificates(in);\n-            return certs.toArray(new X509Certificate[0]);\n-        }\n-    }\n-\n-    private static class DistrustedTLSServerCert extends X509Certificate {\n-        private final X509Certificate cert;\n-        private final Date notBefore;\n-        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n-            this.cert = cert;\n-            this.notBefore = notBefore;\n-        }\n-        public Set<String> getCriticalExtensionOIDs() {\n-           return cert.getCriticalExtensionOIDs();\n-        }\n-        public byte[] getExtensionValue(String oid) {\n-            return cert.getExtensionValue(oid);\n-        }\n-        public Set<String> getNonCriticalExtensionOIDs() {\n-            return cert.getNonCriticalExtensionOIDs();\n-        }\n-        public boolean hasUnsupportedCriticalExtension() {\n-            return cert.hasUnsupportedCriticalExtension();\n-        }\n-        public void checkValidity() throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public void checkValidity(Date date) throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public int getVersion() { return cert.getVersion(); }\n-        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n-        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n-        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n-        public Date getNotBefore() { return notBefore; }\n-        public Date getNotAfter() { return cert.getNotAfter(); }\n-        public byte[] getTBSCertificate() throws CertificateEncodingException {\n-            return cert.getTBSCertificate();\n-        }\n-        public byte[] getSignature() { return cert.getSignature(); }\n-        public String getSigAlgName() { return cert.getSigAlgName(); }\n-        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n-        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n-        public boolean[] getIssuerUniqueID() {\n-            return cert.getIssuerUniqueID();\n-        }\n-        public boolean[] getSubjectUniqueID() {\n-            return cert.getSubjectUniqueID();\n-        }\n-        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n-        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n-        public byte[] getEncoded() throws CertificateEncodingException {\n-            return cert.getEncoded();\n-        }\n-        public void verify(PublicKey key) throws CertificateException,\n-            InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key);\n-        }\n-        public void verify(PublicKey key, String sigProvider) throws\n-            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key, sigProvider);\n-        }\n-        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n-        public String toString() { return cert.toString(); }\n-    }\n-}\n","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/Distrust.java","additions":0,"deletions":289,"binary":false,"changes":289,"status":"deleted"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import javax.net.ssl.*;\n+import sun.security.validator.Validator;\n+import sun.security.validator.ValidatorException;\n+\n+\/**\n+ * Helper class that provides methods to facilitate testing of distrusted roots.\n+ *\/\n+\n+public final class Distrust {\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+    private static CertificateFactory cf;\n+\n+    private final boolean before;\n+    private final boolean policyOn;\n+    private final boolean isValid;\n+\n+    public Distrust(String[] args) {\n+        before = args[0].equals(\"before\");\n+        policyOn = args[1].equals(\"policyOn\");\n+        isValid = args[2].equals(\"valid\");\n+\n+        if (!policyOn) {\n+            \/\/ disable policy (default is on)\n+            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n+        }\n+    }\n+\n+    public Date getNotBefore(ZonedDateTime distrustDate) {\n+        ZonedDateTime notBefore = before ? distrustDate.minusSeconds(1) : distrustDate;\n+        return Date.from(notBefore.toInstant());\n+    }\n+\n+    public void testCodeSigningChain(String certPath, String name, Date validationDate)\n+            throws Exception {\n+        System.err.println(\"Testing \" + name + \" code-signing chain\");\n+        Validator v = Validator.getInstance(Validator.TYPE_PKIX,\n+                Validator.VAR_CODE_SIGNING,\n+                getParams());\n+        \/\/ set validation date so this will still pass when cert expires\n+        v.setValidationDate(validationDate);\n+        v.validate(loadCertificateChain(certPath, name));\n+    }\n+\n+    public void testCertificateChain(String certPath, Date notBefore, X509TrustManager[] tms,\n+                                     String... tests) throws Exception {\n+        for (String test : tests) {\n+            System.err.println(\"Testing \" + test);\n+            X509Certificate[] chain = loadCertificateChain(certPath, test);\n+            for (X509TrustManager tm : tms) {\n+                testTM(tm, chain, notBefore, isValid);\n+            }\n+        }\n+    }\n+\n+    public X509TrustManager getTMF(String type, PKIXBuilderParameters params) throws Exception {\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n+        if (params == null) {\n+            tmf.init((KeyStore) null);\n+        } else {\n+            tmf.init(new CertPathTrustManagerParameters(params));\n+        }\n+        TrustManager[] tms = tmf.getTrustManagers();\n+        for (TrustManager tm : tms) {\n+            return (X509TrustManager) tm;\n+        }\n+        throw new RuntimeException(\"No TrustManager for \" + type);\n+    }\n+\n+    public PKIXBuilderParameters getParams() throws Exception {\n+        PKIXBuilderParameters pbp =\n+                new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n+                        new X509CertSelector());\n+        pbp.setRevocationEnabled(false);\n+        return pbp;\n+    }\n+\n+    public void testTM(X509TrustManager xtm, X509Certificate[] chain,\n+                              Date notBefore, boolean valid) {\n+        \/\/ Check if TLS Server certificate (the first element of the chain)\n+        \/\/ is issued after the specified notBefore date (should be rejected\n+        \/\/ unless distrust property is false). To do this, we need to\n+        \/\/ fake the notBefore date since none of the test certs are issued\n+        \/\/ after then.\n+        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n+\n+        \/\/ Wrap the intermediate and root CA certs in NonExpiringTLSServerCert\n+        \/\/ so it will never throw a CertificateExpiredException\n+        for (int i = 1; i < chain.length; i++) {\n+            chain[i] = new NonExpiringTLSServerCert(chain[i]);\n+        }\n+\n+        try {\n+            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n+            if (!valid) {\n+                throw new RuntimeException(\"chain should be invalid\");\n+            }\n+        } catch (CertificateException ce) {\n+            if (valid) {\n+                throw new RuntimeException(\"Unexpected exception, chain \" +\n+                        \"should be valid\", ce);\n+            }\n+            if (ce instanceof ValidatorException) {\n+                ValidatorException ve = (ValidatorException) ce;\n+                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n+                    ce.printStackTrace(System.err);\n+                    throw new RuntimeException(\"Unexpected exception: \" + ce);\n+                }\n+            } else {\n+                throw new RuntimeException(ce);\n+            }\n+        }\n+    }\n+\n+    private X509Certificate[] loadCertificateChain(String certPath, String name)\n+            throws Exception {\n+        if (cf == null) {\n+            cf = CertificateFactory.getInstance(\"X.509\");\n+        }\n+        try (InputStream in = new FileInputStream(TEST_SRC + File.separator + certPath +\n+                File.separator + name + \"-chain.pem\")) {\n+            Collection<X509Certificate> certs =\n+                    (Collection<X509Certificate>) cf.generateCertificates(in);\n+            return certs.toArray(new X509Certificate[0]);\n+        }\n+    }\n+\n+    private static class NonExpiringTLSServerCert extends X509Certificate {\n+        private final X509Certificate cert;\n+        NonExpiringTLSServerCert(X509Certificate cert) {\n+            this.cert = cert;\n+        }\n+        public Set<String> getCriticalExtensionOIDs() {\n+            return cert.getCriticalExtensionOIDs();\n+        }\n+        public byte[] getExtensionValue(String oid) {\n+            return cert.getExtensionValue(oid);\n+        }\n+        public Set<String> getNonCriticalExtensionOIDs() {\n+            return cert.getNonCriticalExtensionOIDs();\n+        }\n+        public boolean hasUnsupportedCriticalExtension() {\n+            return cert.hasUnsupportedCriticalExtension();\n+        }\n+        public void checkValidity() {\n+            \/\/ always pass\n+        }\n+        public void checkValidity(Date date) {\n+            \/\/ always pass\n+        }\n+        public int getVersion() { return cert.getVersion(); }\n+        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n+        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n+        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n+        public Date getNotBefore() { return cert.getNotBefore(); }\n+        public Date getNotAfter() { return cert.getNotAfter(); }\n+        public byte[] getTBSCertificate() throws CertificateEncodingException {\n+            return cert.getTBSCertificate();\n+        }\n+        public byte[] getSignature() { return cert.getSignature(); }\n+        public String getSigAlgName() { return cert.getSigAlgName(); }\n+        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n+        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n+        public boolean[] getIssuerUniqueID() {\n+            return cert.getIssuerUniqueID();\n+        }\n+        public boolean[] getSubjectUniqueID() {\n+            return cert.getSubjectUniqueID();\n+        }\n+        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n+        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            return cert.getEncoded();\n+        }\n+        public void verify(PublicKey key) throws CertificateException,\n+                InvalidKeyException, NoSuchAlgorithmException,\n+                NoSuchProviderException, SignatureException {\n+            cert.verify(key);\n+        }\n+        public void verify(PublicKey key, String sigProvider) throws\n+                CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n+                NoSuchProviderException, SignatureException {\n+            cert.verify(key, sigProvider);\n+        }\n+        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n+        public String toString() { return cert.toString(); }\n+    }\n+\n+    private static class DistrustedTLSServerCert extends NonExpiringTLSServerCert {\n+        private final Date notBefore;\n+        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n+            super(cert);\n+            this.notBefore = notBefore;\n+        }\n+        public Date getNotBefore() { return notBefore; }\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Distrust.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.time.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+\/**\n+ * @test\n+ * @bug 8337664 8341059\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Entrust roots are invalid\n+ * @library \/lib\/security\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Entrust after policyOn invalid\n+ * @run main\/othervm Entrust after policyOff valid\n+ * @run main\/othervm Entrust before policyOn valid\n+ * @run main\/othervm Entrust before policyOff valid\n+ *\/\n+\n+public class Entrust {\n+\n+    private static final String certPath = \"chains\" + File.separator + \"entrust\";\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static String[] rootsToTest = new String[]{\n+            \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n+            \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n+            \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\"};\n+\n+    \/\/ Date when the restrictions take effect\n+    private static final ZonedDateTime DISTRUST_DATE =\n+            LocalDate.of(2024, 11, 12).atStartOfDay(ZoneOffset.UTC);\n+\n+    public static void main(String[] args) throws Exception {\n+        Distrust distrust = new Distrust(args);\n+\n+        X509TrustManager[] tms = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", null),\n+                distrust.getTMF(\"SunX509\", null)\n+        };\n+\n+        Date notBefore = distrust.getNotBefore(DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, rootsToTest);\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Entrust.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.File;\n+import java.time.*;\n+import java.util.*;\n+\n+\n+\/**\n+ * @test\n+ * @bug 8207258 8216280\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Symantec roots are invalid\n+ * @library \/lib\/security\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Symantec after policyOn invalid\n+ * @run main\/othervm Symantec after policyOff valid\n+ * @run main\/othervm Symantec before policyOn valid\n+ * @run main\/othervm Symantec before policyOff valid\n+ *\/\n+\n+public class Symantec {\n+\n+    private static final String certPath = \"chains\" + File.separator + \"symantec\";\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static final String[] rootsToTest = new String[]{\n+            \"geotrustprimarycag2\", \"geotrustprimarycag3\", \"geotrustuniversalca\",\n+            \"thawteprimaryrootca\", \"thawteprimaryrootcag2\", \"thawteprimaryrootcag3\",\n+            \"verisignclass3g3ca\", \"verisignclass3g4ca\", \"verisignclass3g5ca\",\n+            \"verisignuniversalrootca\"\n+    };\n+\n+    \/\/ Each of the subCAs with a delayed distrust date have a test certificate\n+    \/\/ chain stored in a file named \"<subCA>-chain.pem\".\n+    private static String[] subCAsToTest = new String[]{\"appleistca8g1\"};\n+\n+    \/\/ Date when the restrictions take effect\n+    private static final ZonedDateTime ROOTS_DISTRUST_DATE =\n+            LocalDate.of(2019, 4, 17).atStartOfDay(ZoneOffset.UTC);\n+\n+    \/\/ Date when the subCA restrictions take effect\n+    private static final ZonedDateTime SUBCA_DISTRUST_DATE =\n+            LocalDate.of(2020, 1, 1).atStartOfDay(ZoneOffset.UTC);\n+\n+    public static void main(String[] args) throws Exception {\n+        Distrust distrust = new Distrust(args);\n+        X509TrustManager[] tms = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", null),\n+                distrust.getTMF(\"SunX509\", null)\n+        };\n+\n+        \/\/ test chains issued through roots\n+        Date notBefore = distrust.getNotBefore(ROOTS_DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, rootsToTest);\n+\n+        \/\/ test chain if params are passed to TrustManager\n+        System.err.println(\"Testing verisignuniversalrootca with params\");\n+        X509TrustManager[] tmsParams = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", distrust.getParams())\n+        };\n+        distrust.testCertificateChain(certPath, notBefore, tmsParams,\n+                \"verisignuniversalrootca\");\n+\n+        \/\/ test code-signing chain (should be valid as restrictions don't apply)\n+        Date validationDate = new Date(1544197375493L);\n+        distrust.testCodeSigningChain(certPath, \"verisignclass3g5ca-codesigning\", validationDate);\n+\n+        \/\/ test chains issued through subCAs\n+        notBefore = distrust.getNotBefore(SUBCA_DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, subCAsToTest);\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Symantec.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustcommercialca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustcommercialca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustnetworkingca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustnetworkingca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustpremiumca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustpremiumeccca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumeccca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrust2048ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrust2048ca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustevca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustevca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcaec1-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcaec1-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag2-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcag4-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag4-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/appleistca8g1-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/appleistca8g1-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustprimarycag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustprimarycag2-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustprimarycag3-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustprimarycag3-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustuniversalca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustuniversalca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootcag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootcag2-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootcag3-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootcag3-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g3ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g3ca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g4ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g4ca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g5ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g5ca-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g5ca-codesigning-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g5ca-codesigning-chain.pem","status":"renamed"},{"patch":"","filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignuniversalrootca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignuniversalrootca-chain.pem","status":"renamed"}]}