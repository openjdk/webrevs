{"files":[{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.13, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.13, October 13th, 2022\n+  version 1.3.1, January 22, 2024\n@@ -3053,1 +3053,1 @@\n-  Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n","filename":"THIRD_PARTY_README","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.11, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.11, January 15th, 2017\n+  version 1.3.1, January 22, 2024\n","filename":"corba\/THIRD_PARTY_README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.11, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.11, January 15th, 2017\n+  version 1.3.1, January 22, 2024\n","filename":"hotspot\/THIRD_PARTY_README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.11, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.11, January 15th, 2017\n+  version 1.3.1, January 22, 2024\n","filename":"jaxp\/THIRD_PARTY_README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.11, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.11, January 15th, 2017\n+  version 1.3.1, January 22, 2024\n","filename":"jaxws\/THIRD_PARTY_README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.11, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.11, January 15th, 2017\n+  version 1.3.1, January 22, 2024\n","filename":"jdk\/THIRD_PARTY_README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,103 @@\n+Changes in 1.3.1 (22 Jan 2024)\n+- Reject overflows of zip header fields in minizip\n+- Fix bug in inflateSync() for data held in bit buffer\n+- Add LIT_MEM define to use more memory for a small deflate speedup\n+- Fix decision on the emission of Zip64 end records in minizip\n+- Add bounds checking to ERR_MSG() macro, used by zError()\n+- Neutralize zip file traversal attacks in miniunz\n+- Fix a bug in ZLIB_DEBUG compiles in check_match()\n+- Various portability and appearance improvements\n+\n+Changes in 1.3 (18 Aug 2023)\n+- Remove K&R function definitions and zlib2ansi\n+- Fix bug in deflateBound() for level 0 and memLevel 9\n+- Fix bug when gzungetc() is used immediately after gzopen()\n+- Fix bug when using gzflush() with a very small buffer\n+- Fix crash when gzsetparams() attempted for transparent write\n+- Fix test\/example.c to work with FORCE_STORED\n+- Rewrite of zran in examples (see zran.c version history)\n+- Fix minizip to allow it to open an empty zip file\n+- Fix reading disk number start on zip64 files in minizip\n+- Fix logic error in minizip argument processing\n+- Add minizip testing to Makefile\n+- Read multiple bytes instead of byte-by-byte in minizip unzip.c\n+- Add memory sanitizer to configure (--memory)\n+- Various portability improvements\n+- Various documentation improvements\n+- Various spelling and typo corrections\n+\n+Changes in 1.2.13 (13 Oct 2022)\n+- Fix configure issue that discarded provided CC definition\n+- Correct incorrect inputs provided to the CRC functions\n+- Repair prototypes and exporting of new CRC functions\n+- Fix inflateBack to detect invalid input with distances too far\n+- Have infback() deliver all of the available output up to any error\n+- Fix a bug when getting a gzip header extra field with inflate()\n+- Fix bug in block type selection when Z_FIXED used\n+- Tighten deflateBound bounds\n+- Remove deleted assembler code references\n+- Various portability and appearance improvements\n+\n+Changes in 1.2.12 (27 Mar 2022)\n+- Cygwin does not have _wopen(), so do not create gzopen_w() there\n+- Permit a deflateParams() parameter change as soon as possible\n+- Limit hash table inserts after switch from stored deflate\n+- Fix bug when window full in deflate_stored()\n+- Fix CLEAR_HASH macro to be usable as a single statement\n+- Avoid a conversion error in gzseek when off_t type too small\n+- Have Makefile return non-zero error code on test failure\n+- Avoid some conversion warnings in gzread.c and gzwrite.c\n+- Update use of errno for newer Windows CE versions\n+- Small speedup to inflate [psumbera]\n+- Return an error if the gzputs string length can't fit in an int\n+- Add address checking in clang to -w option of configure\n+- Don't compute check value for raw inflate if asked to validate\n+- Handle case where inflateSync used when header never processed\n+- Avoid the use of ptrdiff_t\n+- Avoid an undefined behavior of memcpy() in gzappend()\n+- Avoid undefined behaviors of memcpy() in gz*printf()\n+- Avoid an undefined behavior of memcpy() in _tr_stored_block()\n+- Make the names in functions declarations identical to definitions\n+- Remove old assembler code in which bugs have manifested\n+- Fix deflateEnd() to not report an error at start of raw deflate\n+- Add legal disclaimer to README\n+- Emphasize the need to continue decompressing gzip members\n+- Correct the initialization requirements for deflateInit2()\n+- Fix a bug that can crash deflate on some input when using Z_FIXED\n+- Assure that the number of bits for deflatePrime() is valid\n+- Use a structure to make globals in enough.c evident\n+- Use a macro for the printf format of big_t in enough.c\n+- Clean up code style in enough.c, update version\n+- Use inline function instead of macro for index in enough.c\n+- Clarify that prefix codes are counted in enough.c\n+- Show all the codes for the maximum tables size in enough.c\n+- Add gznorm.c example, which normalizes gzip files\n+- Fix the zran.c example to work on a multiple-member gzip file\n+- Add tables for crc32_combine(), to speed it up by a factor of 200\n+- Add crc32_combine_gen() and crc32_combine_op() for fast combines\n+- Speed up software CRC-32 computation by a factor of 1.5 to 3\n+- Use atomic test and set, if available, for dynamic CRC tables\n+- Don't bother computing check value after successful inflateSync()\n+- Correct comment in crc32.c\n+- Add use of the ARMv8 crc32 instructions when requested\n+- Use ARM crc32 instructions if the ARM architecture has them\n+- Explicitly note that the 32-bit check values are 32 bits\n+- Avoid adding empty gzip member after gzflush with Z_FINISH\n+- Fix memory leak on error in gzlog.c\n+- Fix error in comment on the polynomial representation of a byte\n+- Clarify gz* function interfaces, referring to parameter names\n+- Change macro name in inflate.c to avoid collision in VxWorks\n+- Correct typo in blast.c\n+- Improve portability of contrib\/minizip\n+- Fix indentation in minizip's zip.c\n+- Replace black\/white with allow\/block. (theresa-m)\n+- minizip warning fix if MAXU32 already defined. (gvollant)\n+- Fix unztell64() in minizip to work past 4GB. (Daniël Hörchner)\n+- Clean up minizip to reduce warnings for testing\n+- Add fallthrough comments for gcc\n+- Eliminate use of ULL constants\n+- Separate out address sanitizing from warnings in configure\n+- Remove destructive aspects of make distclean\n+- Check for cc masquerading as gcc or clang in configure\n+- Fix crc32.c to compile local functions only if used\n+\n@@ -99,1 +202,1 @@\n-- Suport i686 and amd64 assembler builds in CMakeLists.txt\n+- Support i686 and amd64 assembler builds in CMakeLists.txt\n@@ -299,1 +402,1 @@\n-- Improve inflateSync() documentation to note indeterminancy\n+- Improve inflateSync() documentation to note indeterminacy\n@@ -306,1 +409,1 @@\n-- Add debug records in assmebler code [Londer]\n+- Add debug records in assembler code [Londer]\n@@ -514,1 +617,1 @@\n-- Moved nintendods directory from contrib to .\n+- Moved nintendods directory from contrib to root\n@@ -688,1 +791,1 @@\n-  discovering the vulnerability and providing test cases.\n+  discovering the vulnerability and providing test cases\n@@ -724,1 +827,1 @@\n-  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html.\n+  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html\n@@ -795,1 +898,1 @@\n-- Add a note to puff.c on no distance codes case.\n+- Add a note to puff.c on no distance codes case\n@@ -973,1 +1076,1 @@\n-- Enchance comments in zlib.h on what happens if gzprintf() tries to\n+- Enhance comments in zlib.h on what happens if gzprintf() tries to\n@@ -1039,1 +1142,1 @@\n-- ZFREE was repeated on same allocation on some error conditions.\n+- ZFREE was repeated on same allocation on some error conditions\n@@ -1044,1 +1147,1 @@\n-  less than 32K.\n+  less than 32K\n@@ -1046,1 +1149,1 @@\n-  of 256 bytes. (A complete fix will be available in 1.1.5).\n+  of 256 bytes. (A complete fix will be available in 1.1.5)\n@@ -1120,1 +1223,1 @@\n-  matches in deflate_slow.\n+  matches in deflate_slow\n@@ -1151,1 +1254,1 @@\n-  the declaration of FAR (Gilles VOllant)\n+  the declaration of FAR (Gilles Vollant)\n@@ -1165,1 +1268,1 @@\n-  trees.h, compile with GEN_TREES_H and run \"make test\".\n+  trees.h, compile with GEN_TREES_H and run \"make test\"\n@@ -1204,2 +1307,2 @@\n-  Andy Buckler for finding this one).\n-- In minigzip, pass transparently also the first byte for .Z files.\n+  Andy Buckler for finding this one)\n+- In minigzip, pass transparently also the first byte for .Z files\n@@ -1209,1 +1312,1 @@\n-- make static libraries by default in configure, add --shared option.\n+- make static libraries by default in configure, add --shared option\n@@ -1221,1 +1324,1 @@\n-        386 asm code replacing longest_match().\n+        386 asm code replacing longest_match()\n@@ -1229,1 +1332,1 @@\n-        How to use compress(), uncompress() and the gz* functions from VB.\n+        How to use compress(), uncompress() and the gz* functions from VB\n@@ -1238,2 +1341,2 @@\n-- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.\n-- Use default memcpy for Symantec MSDOS compiler.\n+- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code\n+- Use default memcpy for Symantec MSDOS compiler\n@@ -1252,1 +1355,1 @@\n-- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).\n+- use variable z_verbose for tracing in debug mode (L. Peter Deutsch)\n@@ -1262,1 +1365,1 @@\n-- Avoid expanded $Id$. Use \"rcs -kb\" or \"cvs admin -kb\" to avoid Id expansion.\n+- Avoid expanded $Id$. Use \"rcs -kb\" or \"cvs admin -kb\" to avoid Id expansion\n@@ -1283,1 +1386,1 @@\n-  on to attempt decompressing extra garbage data. This affected minigzip too.\n+  on to attempt decompressing extra garbage data. This affected minigzip too\n@@ -1313,1 +1416,1 @@\n-- fix deflateParams() which could generate bad compressed data.\n+- fix deflateParams() which could generate bad compressed data\n@@ -1334,1 +1437,1 @@\n-  and compression strategy.\n+  and compression strategy\n@@ -1373,1 +1476,1 @@\n-- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...\n+- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc.\n@@ -1376,1 +1479,1 @@\n-- allow \"a\" as mode in gzopen.\n+- allow \"a\" as mode in gzopen\n@@ -1382,1 +1485,1 @@\n-- added a dimension to all arrays (Borland C can't count).\n+- added a dimension to all arrays (Borland C can't count)\n@@ -1385,1 +1488,1 @@\n-- Watcom C pretends to be Microsoft C small model even in 32 bit mode.\n+- Watcom C pretends to be Microsoft C small model even in 32 bit mode\n@@ -1388,1 +1491,1 @@\n-     (what's wrong with far data in far model?).\n+     (what's wrong with far data in far model?)\n@@ -1395,1 +1498,1 @@\n-  not completely flushed in rare occasions).\n+  not completely flushed in rare occasions)\n@@ -1397,1 +1500,1 @@\n-  (it's now sufficient to set MAX_WBITS in zconf.h).\n+  (it's now sufficient to set MAX_WBITS in zconf.h)\n@@ -1399,1 +1502,1 @@\n-  typedefs and because voidnp was not near in large model).\n+  typedefs and because voidnp was not near in large model)\n@@ -1408,1 +1511,1 @@\n-- For deflate with flush, flush even if no more input is provided.\n+- For deflate with flush, flush even if no more input is provided\n@@ -1413,1 +1516,1 @@\n-- allow renaming of Byte, uInt, etc... with #define.\n+- allow renaming of Byte, uInt, etc... with #define\n@@ -1432,1 +1535,1 @@\n-- optimized inflate on stored blocks.\n+- optimized inflate on stored blocks\n@@ -1450,1 +1553,1 @@\n-- moved MAX_WBITS to zconf.h because users might want to change that.\n+- moved MAX_WBITS to zconf.h because users might want to change that\n@@ -1459,1 +1562,1 @@\n-  is incompatible with previous versions of zlib which returned Z_OK.\n+  is incompatible with previous versions of zlib which returned Z_OK\n@@ -1469,1 +1572,1 @@\n-  TurboC large model.\n+  TurboC large model\n@@ -1472,1 +1575,1 @@\n-- Added full inflate support.\n+- Added full inflate support\n@@ -1475,1 +1578,1 @@\n-  incompatible with previous versions; see zlib.h for the new usage.\n+  incompatible with previous versions; see zlib.h for the new usage\n@@ -1478,1 +1581,1 @@\n-- workaround for a bug in TurboC. example and minigzip now work on MSDOS.\n+- workaround for a bug in TurboC. example and minigzip now work on MSDOS\n@@ -1483,1 +1586,1 @@\n-- added transparent reading of non-gziped files in gzread.\n+- added transparent reading of non-gziped files in gzread\n@@ -1485,1 +1588,1 @@\n-- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).\n+- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose)\n@@ -1491,1 +1594,1 @@\n-  not yet Z_FULL_FLUSH.\n+  not yet Z_FULL_FLUSH\n@@ -1493,1 +1596,1 @@\n-- added opaque object for zalloc and zfree.\n+- added opaque object for zalloc and zfree\n@@ -1495,3 +1598,3 @@\n-- added a variable zlib_version for consistency checking.\n-- renamed the 'filter' parameter of deflateInit2 as 'strategy'.\n-  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.\n+- added a variable zlib_version for consistency checking\n+- renamed the 'filter' parameter of deflateInit2 as 'strategy'\n+  Added Z_FILTERED and Z_HUFFMAN_ONLY constants\n@@ -1500,1 +1603,1 @@\n-- avoid \"zip\" everywhere, use zlib instead of ziplib.\n+- avoid \"zip\" everywhere, use zlib instead of ziplib\n@@ -1502,1 +1605,1 @@\n-  if compression method == 8.\n+  if compression method == 8\n@@ -1505,1 +1608,1 @@\n-- added the method parameter for deflateInit2.\n+- added the method parameter for deflateInit2\n@@ -1507,1 +1610,1 @@\n-- simplied considerably deflateInit and inflateInit by not supporting\n+- simplified considerably deflateInit and inflateInit by not supporting\n@@ -1509,1 +1612,1 @@\n-  and inflateInit2.\n+  and inflateInit2\n@@ -1513,1 +1616,1 @@\n-- use Z_FINISH instead of deflateEnd to finish compression.\n+- use Z_FINISH instead of deflateEnd to finish compression\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/ChangeLog","additions":159,"deletions":56,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-zlib 1.2.13 is a general purpose data compression library.  All the code is\n+zlib 1.3.1 is a general purpose data compression library.  All the code is\n@@ -32,1 +32,1 @@\n-http:\/\/marknelson.us\/1997\/01\/01\/zlib-engine\/ .\n+https:\/\/marknelson.us\/posts\/1997\/01\/01\/zlib-engine.html .\n@@ -34,1 +34,1 @@\n-The changes made in version 1.2.13 are documented in the file ChangeLog.\n+The changes made in version 1.3.1 are documented in the file ChangeLog.\n@@ -38,2 +38,2 @@\n-zlib is available in Java using the java.util.zip package, documented at\n-http:\/\/java.sun.com\/developer\/technicalArticles\/Programming\/compression\/ .\n+zlib is available in Java using the java.util.zip package. Follow the API\n+Documentation link at: https:\/\/docs.oracle.com\/search\/?q=java.util.zip .\n@@ -41,3 +41,2 @@\n-A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is available\n-at CPAN (Comprehensive Perl Archive Network) sites, including\n-http:\/\/search.cpan.org\/~pmqs\/IO-Compress-Zlib\/ .\n+A Perl interface to zlib and bzip2 written by Paul Marquess <pmqs@cpan.org>\n+can be found at https:\/\/github.com\/pmqs\/IO-Compress .\n@@ -67,1 +66,1 @@\n-- On Digital Unix 4.0D (formely OSF\/1) on AlphaServer, the cc option -std1 is\n+- On Digital Unix 4.0D (formerly OSF\/1) on AlphaServer, the cc option -std1 is\n@@ -87,1 +86,1 @@\n- (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+ (C) 1995-2024 Jean-loup Gailly and Mark Adler\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/README","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,7 +46,2 @@\n-int ZEXPORT compress2(dest, destLen, source, sourceLen, level)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong sourceLen;\n-    int level;\n-{\n+int ZEXPORT compress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                      uLong sourceLen, int level) {\n@@ -92,6 +87,2 @@\n-int ZEXPORT compress(dest, destLen, source, sourceLen)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong sourceLen;\n-{\n+int ZEXPORT compress(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                     uLong sourceLen) {\n@@ -105,3 +96,1 @@\n-uLong ZEXPORT compressBound(sourceLen)\n-    uLong sourceLen;\n-{\n+uLong ZEXPORT compressBound(uLong sourceLen) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/compress.c","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -79,1 +79,1 @@\n-   \" deflate 1.2.13 Copyright 1995-2022 Jean-loup Gailly and Mark Adler \";\n+   \" deflate 1.3.1 Copyright 1995-2024 Jean-loup Gailly and Mark Adler \";\n@@ -87,3 +87,0 @@\n-\/* ===========================================================================\n- *  Function prototypes.\n- *\/\n@@ -97,1 +94,1 @@\n-typedef block_state (*compress_func) OF((deflate_state *s, int flush));\n+typedef block_state (*compress_func)(deflate_state *s, int flush);\n@@ -100,5 +97,2 @@\n-local int deflateStateCheck      OF((z_streamp strm));\n-local void slide_hash     OF((deflate_state *s));\n-local void fill_window    OF((deflate_state *s));\n-local block_state deflate_stored OF((deflate_state *s, int flush));\n-local block_state deflate_fast   OF((deflate_state *s, int flush));\n+local block_state deflate_stored(deflate_state *s, int flush);\n+local block_state deflate_fast(deflate_state *s, int flush);\n@@ -106,13 +100,1 @@\n-local block_state deflate_slow   OF((deflate_state *s, int flush));\n-#endif\n-local block_state deflate_rle    OF((deflate_state *s, int flush));\n-local block_state deflate_huff   OF((deflate_state *s, int flush));\n-local void lm_init        OF((deflate_state *s));\n-local void putShortMSB    OF((deflate_state *s, uInt b));\n-local void flush_pending  OF((z_streamp strm));\n-local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));\n-local uInt longest_match  OF((deflate_state *s, IPos cur_match));\n-\n-#ifdef ZLIB_DEBUG\n-local  void check_match OF((deflate_state *s, IPos start, IPos match,\n-                            int length));\n+local block_state deflate_slow(deflate_state *s, int flush);\n@@ -120,0 +102,2 @@\n+local block_state deflate_rle(deflate_state *s, int flush);\n+local block_state deflate_huff(deflate_state *s, int flush);\n@@ -222,3 +206,6 @@\n-local void slide_hash(s)\n-    deflate_state *s;\n-{\n+#if defined(__has_feature)\n+#  if __has_feature(memory_sanitizer)\n+     __attribute__((no_sanitize(\"memory\")))\n+#  endif\n+#endif\n+local void slide_hash(deflate_state *s) {\n@@ -248,0 +235,159 @@\n+\/* ===========================================================================\n+ * Read a new buffer from the current input stream, update the adler32\n+ * and total number of bytes read.  All deflate() input goes through\n+ * this function so some applications may wish to modify it to avoid\n+ * allocating a large strm->next_in buffer and copying from it.\n+ * (See also flush_pending()).\n+ *\/\n+local unsigned read_buf(z_streamp strm, Bytef *buf, unsigned size) {\n+    unsigned len = strm->avail_in;\n+\n+    if (len > size) len = size;\n+    if (len == 0) return 0;\n+\n+    strm->avail_in  -= len;\n+\n+    zmemcpy(buf, strm->next_in, len);\n+    if (strm->state->wrap == 1) {\n+        strm->adler = adler32(strm->adler, buf, len);\n+    }\n+#ifdef GZIP\n+    else if (strm->state->wrap == 2) {\n+        strm->adler = crc32(strm->adler, buf, len);\n+    }\n+#endif\n+    strm->next_in  += len;\n+    strm->total_in += len;\n+\n+    return len;\n+}\n+\n+\/* ===========================================================================\n+ * Fill the window when the lookahead becomes insufficient.\n+ * Updates strstart and lookahead.\n+ *\n+ * IN assertion: lookahead < MIN_LOOKAHEAD\n+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n+ *    At least one byte has been read, or avail_in == 0; reads are\n+ *    performed for at least two bytes (required for the zip translate_eol\n+ *    option -- not supported here).\n+ *\/\n+local void fill_window(deflate_state *s) {\n+    unsigned n;\n+    unsigned more;    \/* Amount of free space at the end of the window. *\/\n+    uInt wsize = s->w_size;\n+\n+    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n+\n+    do {\n+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n+\n+        \/* Deal with !@#$% 64K limit: *\/\n+        if (sizeof(int) <= 2) {\n+            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n+                more = wsize;\n+\n+            } else if (more == (unsigned)(-1)) {\n+                \/* Very unlikely, but possible on 16 bit machine if\n+                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n+                 *\/\n+                more--;\n+            }\n+        }\n+\n+        \/* If the window is almost full and there is insufficient lookahead,\n+         * move the upper half to the lower one to make room in the upper half.\n+         *\/\n+        if (s->strstart >= wsize + MAX_DIST(s)) {\n+\n+            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);\n+            s->match_start -= wsize;\n+            s->strstart    -= wsize; \/* we now have strstart >= MAX_DIST *\/\n+            s->block_start -= (long) wsize;\n+            if (s->insert > s->strstart)\n+                s->insert = s->strstart;\n+            slide_hash(s);\n+            more += wsize;\n+        }\n+        if (s->strm->avail_in == 0) break;\n+\n+        \/* If there was no sliding:\n+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n+         *    more == window_size - lookahead - strstart\n+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n+         * => more >= window_size - 2*WSIZE + 2\n+         * In the BIG_MEM or MMAP case (not yet supported),\n+         *   window_size == input_size + MIN_LOOKAHEAD  &&\n+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n+         * Otherwise, window_size == 2*WSIZE so more >= 2.\n+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n+         *\/\n+        Assert(more >= 2, \"more < 2\");\n+\n+        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n+        s->lookahead += n;\n+\n+        \/* Initialize the hash value now that we have some input: *\/\n+        if (s->lookahead + s->insert >= MIN_MATCH) {\n+            uInt str = s->strstart - s->insert;\n+            s->ins_h = s->window[str];\n+            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);\n+#if MIN_MATCH != 3\n+            Call UPDATE_HASH() MIN_MATCH-3 more times\n+#endif\n+            while (s->insert) {\n+                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n+#ifndef FASTEST\n+                s->prev[str & s->w_mask] = s->head[s->ins_h];\n+#endif\n+                s->head[s->ins_h] = (Pos)str;\n+                str++;\n+                s->insert--;\n+                if (s->lookahead + s->insert < MIN_MATCH)\n+                    break;\n+            }\n+        }\n+        \/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n+         * but this is not important since only literal bytes will be emitted.\n+         *\/\n+\n+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n+\n+    \/* If the WIN_INIT bytes after the end of the current data have never been\n+     * written, then zero those bytes in order to avoid memory check reports of\n+     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n+     * the longest match routines.  Update the high water mark for the next\n+     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n+     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n+     *\/\n+    if (s->high_water < s->window_size) {\n+        ulg curr = s->strstart + (ulg)(s->lookahead);\n+        ulg init;\n+\n+        if (s->high_water < curr) {\n+            \/* Previous high water mark below current data -- zero WIN_INIT\n+             * bytes or up to end of window, whichever is less.\n+             *\/\n+            init = s->window_size - curr;\n+            if (init > WIN_INIT)\n+                init = WIN_INIT;\n+            zmemzero(s->window + curr, (unsigned)init);\n+            s->high_water = curr + init;\n+        }\n+        else if (s->high_water < (ulg)curr + WIN_INIT) {\n+            \/* High water mark at or above current data, but below current data\n+             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n+             * to end of window, whichever is less.\n+             *\/\n+            init = (ulg)curr + WIN_INIT - s->high_water;\n+            if (init > s->window_size - s->high_water)\n+                init = s->window_size - s->high_water;\n+            zmemzero(s->window + s->high_water, (unsigned)init);\n+            s->high_water += init;\n+        }\n+    }\n+\n+    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n+           \"not enough room for search\");\n+}\n+\n@@ -249,6 +395,2 @@\n-int ZEXPORT deflateInit_(strm, level, version, stream_size)\n-    z_streamp strm;\n-    int level;\n-    const char *version;\n-    int stream_size;\n-{\n+int ZEXPORT deflateInit_(z_streamp strm, int level, const char *version,\n+                         int stream_size) {\n@@ -261,11 +403,3 @@\n-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n-                  version, stream_size)\n-    z_streamp strm;\n-    int  level;\n-    int  method;\n-    int  windowBits;\n-    int  memLevel;\n-    int  strategy;\n-    const char *version;\n-    int stream_size;\n-{\n+int ZEXPORT deflateInit2_(z_streamp strm, int level, int method,\n+                          int windowBits, int memLevel, int strategy,\n+                          const char *version, int stream_size) {\n@@ -386,1 +520,1 @@\n-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n+    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);\n@@ -396,0 +530,5 @@\n+#ifdef LIT_MEM\n+    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));\n+    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n+    s->sym_end = s->lit_bufsize - 1;\n+#else\n@@ -398,0 +537,1 @@\n+#endif\n@@ -413,3 +553,1 @@\n-local int deflateStateCheck(strm)\n-    z_streamp strm;\n-{\n+local int deflateStateCheck(z_streamp strm) {\n@@ -436,5 +574,2 @@\n-int ZEXPORT deflateSetDictionary(strm, dictionary, dictLength)\n-    z_streamp strm;\n-    const Bytef *dictionary;\n-    uInt  dictLength;\n-{\n+int ZEXPORT deflateSetDictionary(z_streamp strm, const Bytef *dictionary,\n+                                 uInt  dictLength) {\n@@ -505,5 +640,2 @@\n-int ZEXPORT deflateGetDictionary(strm, dictionary, dictLength)\n-    z_streamp strm;\n-    Bytef *dictionary;\n-    uInt  *dictLength;\n-{\n+int ZEXPORT deflateGetDictionary(z_streamp strm, Bytef *dictionary,\n+                                 uInt *dictLength) {\n@@ -527,3 +659,1 @@\n-int ZEXPORT deflateResetKeep(strm)\n-    z_streamp strm;\n-{\n+int ZEXPORT deflateResetKeep(z_streamp strm) {\n@@ -564,0 +694,24 @@\n+\/* ===========================================================================\n+ * Initialize the \"longest match\" routines for a new zlib stream\n+ *\/\n+local void lm_init(deflate_state *s) {\n+    s->window_size = (ulg)2L*s->w_size;\n+\n+    CLEAR_HASH(s);\n+\n+    \/* Set the default configuration parameters:\n+     *\/\n+    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n+    s->good_match       = configuration_table[s->level].good_length;\n+    s->nice_match       = configuration_table[s->level].nice_length;\n+    s->max_chain_length = configuration_table[s->level].max_chain;\n+\n+    s->strstart = 0;\n+    s->block_start = 0L;\n+    s->lookahead = 0;\n+    s->insert = 0;\n+    s->match_length = s->prev_length = MIN_MATCH-1;\n+    s->match_available = 0;\n+    s->ins_h = 0;\n+}\n+\n@@ -565,3 +719,1 @@\n-int ZEXPORT deflateReset(strm)\n-    z_streamp strm;\n-{\n+int ZEXPORT deflateReset(z_streamp strm) {\n@@ -577,4 +729,1 @@\n-int ZEXPORT deflateSetHeader(strm, head)\n-    z_streamp strm;\n-    gz_headerp head;\n-{\n+int ZEXPORT deflateSetHeader(z_streamp strm, gz_headerp head) {\n@@ -588,5 +737,1 @@\n-int ZEXPORT deflatePending(strm, pending, bits)\n-    unsigned *pending;\n-    int *bits;\n-    z_streamp strm;\n-{\n+int ZEXPORT deflatePending(z_streamp strm, unsigned *pending, int *bits) {\n@@ -602,5 +747,1 @@\n-int ZEXPORT deflatePrime(strm, bits, value)\n-    z_streamp strm;\n-    int bits;\n-    int value;\n-{\n+int ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {\n@@ -612,0 +753,5 @@\n+#ifdef LIT_MEM\n+    if (bits < 0 || bits > 16 ||\n+        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))\n+        return Z_BUF_ERROR;\n+#else\n@@ -615,0 +761,1 @@\n+#endif\n@@ -629,5 +776,1 @@\n-int ZEXPORT deflateParams(strm, level, strategy)\n-    z_streamp strm;\n-    int level;\n-    int strategy;\n-{\n+int ZEXPORT deflateParams(z_streamp strm, int level, int strategy) {\n@@ -678,7 +821,2 @@\n-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)\n-    z_streamp strm;\n-    int good_length;\n-    int max_lazy;\n-    int nice_length;\n-    int max_chain;\n-{\n+int ZEXPORT deflateTune(z_streamp strm, int good_length, int max_lazy,\n+                        int nice_length, int max_chain) {\n@@ -720,4 +858,1 @@\n-uLong ZEXPORT deflateBound(strm, sourceLen)\n-    z_streamp strm;\n-    uLong sourceLen;\n-{\n+uLong ZEXPORT deflateBound(z_streamp strm, uLong sourceLen) {\n@@ -779,1 +914,2 @@\n-        return (s->w_bits <= s->hash_bits ? fixedlen : storelen) + wraplen;\n+        return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +\n+               wraplen;\n@@ -792,4 +928,1 @@\n-local void putShortMSB(s, b)\n-    deflate_state *s;\n-    uInt b;\n-{\n+local void putShortMSB(deflate_state *s, uInt b) {\n@@ -806,3 +939,1 @@\n-local void flush_pending(strm)\n-    z_streamp strm;\n-{\n+local void flush_pending(z_streamp strm) {\n@@ -839,4 +970,1 @@\n-int ZEXPORT deflate(strm, flush)\n-    z_streamp strm;\n-    int flush;\n-{\n+int ZEXPORT deflate(z_streamp strm, int flush) {\n@@ -1154,3 +1282,1 @@\n-int ZEXPORT deflateEnd(strm)\n-    z_streamp strm;\n-{\n+int ZEXPORT deflateEnd(z_streamp strm) {\n@@ -1180,4 +1306,1 @@\n-int ZEXPORT deflateCopy(dest, source)\n-    z_streamp dest;\n-    z_streamp source;\n-{\n+int ZEXPORT deflateCopy(z_streamp dest, z_streamp source) {\n@@ -1185,0 +1308,2 @@\n+    (void)dest;\n+    (void)source;\n@@ -1208,1 +1333,1 @@\n-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n+    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);\n@@ -1219,1 +1344,1 @@\n-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n+    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);\n@@ -1222,0 +1347,4 @@\n+#ifdef LIT_MEM\n+    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));\n+    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);\n+#else\n@@ -1223,0 +1352,1 @@\n+#endif\n@@ -1232,60 +1362,0 @@\n-\/* ===========================================================================\n- * Read a new buffer from the current input stream, update the adler32\n- * and total number of bytes read.  All deflate() input goes through\n- * this function so some applications may wish to modify it to avoid\n- * allocating a large strm->next_in buffer and copying from it.\n- * (See also flush_pending()).\n- *\/\n-local unsigned read_buf(strm, buf, size)\n-    z_streamp strm;\n-    Bytef *buf;\n-    unsigned size;\n-{\n-    unsigned len = strm->avail_in;\n-\n-    if (len > size) len = size;\n-    if (len == 0) return 0;\n-\n-    strm->avail_in  -= len;\n-\n-    zmemcpy(buf, strm->next_in, len);\n-    if (strm->state->wrap == 1) {\n-        strm->adler = adler32(strm->adler, buf, len);\n-    }\n-#ifdef GZIP\n-    else if (strm->state->wrap == 2) {\n-        strm->adler = crc32(strm->adler, buf, len);\n-    }\n-#endif\n-    strm->next_in  += len;\n-    strm->total_in += len;\n-\n-    return len;\n-}\n-\n-\/* ===========================================================================\n- * Initialize the \"longest match\" routines for a new zlib stream\n- *\/\n-local void lm_init(s)\n-    deflate_state *s;\n-{\n-    s->window_size = (ulg)2L*s->w_size;\n-\n-    CLEAR_HASH(s);\n-\n-    \/* Set the default configuration parameters:\n-     *\/\n-    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n-    s->good_match       = configuration_table[s->level].good_length;\n-    s->nice_match       = configuration_table[s->level].nice_length;\n-    s->max_chain_length = configuration_table[s->level].max_chain;\n-\n-    s->strstart = 0;\n-    s->block_start = 0L;\n-    s->lookahead = 0;\n-    s->insert = 0;\n-    s->match_length = s->prev_length = MIN_MATCH-1;\n-    s->match_available = 0;\n-    s->ins_h = 0;\n-}\n-\n@@ -1302,4 +1372,1 @@\n-local uInt longest_match(s, cur_match)\n-    deflate_state *s;\n-    IPos cur_match;                             \/* current match *\/\n-{\n+local uInt longest_match(deflate_state *s, IPos cur_match) {\n@@ -1453,4 +1520,1 @@\n-local uInt longest_match(s, cur_match)\n-    deflate_state *s;\n-    IPos cur_match;                             \/* current match *\/\n-{\n+local uInt longest_match(deflate_state *s, IPos cur_match) {\n@@ -1517,5 +1581,1 @@\n-local void check_match(s, start, match, length)\n-    deflate_state *s;\n-    IPos start, match;\n-    int length;\n-{\n+local void check_match(deflate_state *s, IPos start, IPos match, int length) {\n@@ -1523,4 +1583,12 @@\n-    if (zmemcmp(s->window + match,\n-                s->window + start, length) != EQUAL) {\n-        fprintf(stderr, \" start %u, match %u, length %d\\n\",\n-                start, match, length);\n+    Bytef *back = s->window + (int)match, *here = s->window + start;\n+    IPos len = length;\n+    if (match == (IPos)-1) {\n+        \/* match starts one byte before the current window -- just compare the\n+           subsequent length-1 bytes *\/\n+        back++;\n+        here++;\n+        len--;\n+    }\n+    if (zmemcmp(back, here, len) != EQUAL) {\n+        fprintf(stderr, \" start %u, match %d, length %d\\n\",\n+                start, (int)match, length);\n@@ -1528,2 +1596,2 @@\n-            fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n-        } while (--length != 0);\n+            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);\n+        } while (--len != 0);\n@@ -1541,131 +1609,0 @@\n-\/* ===========================================================================\n- * Fill the window when the lookahead becomes insufficient.\n- * Updates strstart and lookahead.\n- *\n- * IN assertion: lookahead < MIN_LOOKAHEAD\n- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n- *    At least one byte has been read, or avail_in == 0; reads are\n- *    performed for at least two bytes (required for the zip translate_eol\n- *    option -- not supported here).\n- *\/\n-local void fill_window(s)\n-    deflate_state *s;\n-{\n-    unsigned n;\n-    unsigned more;    \/* Amount of free space at the end of the window. *\/\n-    uInt wsize = s->w_size;\n-\n-    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n-\n-    do {\n-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n-\n-        \/* Deal with !@#$% 64K limit: *\/\n-        if (sizeof(int) <= 2) {\n-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n-                more = wsize;\n-\n-            } else if (more == (unsigned)(-1)) {\n-                \/* Very unlikely, but possible on 16 bit machine if\n-                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n-                 *\/\n-                more--;\n-            }\n-        }\n-\n-        \/* If the window is almost full and there is insufficient lookahead,\n-         * move the upper half to the lower one to make room in the upper half.\n-         *\/\n-        if (s->strstart >= wsize + MAX_DIST(s)) {\n-\n-            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);\n-            s->match_start -= wsize;\n-            s->strstart    -= wsize; \/* we now have strstart >= MAX_DIST *\/\n-            s->block_start -= (long) wsize;\n-            if (s->insert > s->strstart)\n-                s->insert = s->strstart;\n-            slide_hash(s);\n-            more += wsize;\n-        }\n-        if (s->strm->avail_in == 0) break;\n-\n-        \/* If there was no sliding:\n-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n-         *    more == window_size - lookahead - strstart\n-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n-         * => more >= window_size - 2*WSIZE + 2\n-         * In the BIG_MEM or MMAP case (not yet supported),\n-         *   window_size == input_size + MIN_LOOKAHEAD  &&\n-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n-         * Otherwise, window_size == 2*WSIZE so more >= 2.\n-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n-         *\/\n-        Assert(more >= 2, \"more < 2\");\n-\n-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n-        s->lookahead += n;\n-\n-        \/* Initialize the hash value now that we have some input: *\/\n-        if (s->lookahead + s->insert >= MIN_MATCH) {\n-            uInt str = s->strstart - s->insert;\n-            s->ins_h = s->window[str];\n-            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);\n-#if MIN_MATCH != 3\n-            Call UPDATE_HASH() MIN_MATCH-3 more times\n-#endif\n-            while (s->insert) {\n-                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n-#ifndef FASTEST\n-                s->prev[str & s->w_mask] = s->head[s->ins_h];\n-#endif\n-                s->head[s->ins_h] = (Pos)str;\n-                str++;\n-                s->insert--;\n-                if (s->lookahead + s->insert < MIN_MATCH)\n-                    break;\n-            }\n-        }\n-        \/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n-         * but this is not important since only literal bytes will be emitted.\n-         *\/\n-\n-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n-\n-    \/* If the WIN_INIT bytes after the end of the current data have never been\n-     * written, then zero those bytes in order to avoid memory check reports of\n-     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n-     * the longest match routines.  Update the high water mark for the next\n-     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n-     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n-     *\/\n-    if (s->high_water < s->window_size) {\n-        ulg curr = s->strstart + (ulg)(s->lookahead);\n-        ulg init;\n-\n-        if (s->high_water < curr) {\n-            \/* Previous high water mark below current data -- zero WIN_INIT\n-             * bytes or up to end of window, whichever is less.\n-             *\/\n-            init = s->window_size - curr;\n-            if (init > WIN_INIT)\n-                init = WIN_INIT;\n-            zmemzero(s->window + curr, (unsigned)init);\n-            s->high_water = curr + init;\n-        }\n-        else if (s->high_water < (ulg)curr + WIN_INIT) {\n-            \/* High water mark at or above current data, but below current data\n-             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n-             * to end of window, whichever is less.\n-             *\/\n-            init = (ulg)curr + WIN_INIT - s->high_water;\n-            if (init > s->window_size - s->high_water)\n-                init = s->window_size - s->high_water;\n-            zmemzero(s->window + s->high_water, (unsigned)init);\n-            s->high_water += init;\n-        }\n-    }\n-\n-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n-           \"not enough room for search\");\n-}\n-\n@@ -1714,4 +1651,1 @@\n-local block_state deflate_stored(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_stored(deflate_state *s, int flush) {\n@@ -1901,4 +1835,1 @@\n-local block_state deflate_fast(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_fast(deflate_state *s, int flush) {\n@@ -2003,4 +1934,1 @@\n-local block_state deflate_slow(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_slow(deflate_state *s, int flush) {\n@@ -2134,4 +2062,1 @@\n-local block_state deflate_rle(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_rle(deflate_state *s, int flush) {\n@@ -2208,4 +2133,1 @@\n-local block_state deflate_huff(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_huff(deflate_state *s, int flush) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/deflate.c","additions":267,"deletions":345,"binary":false,"changes":612,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2018 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -50,0 +50,4 @@\n+\/* define LIT_MEM to slightly increase the speed of deflate (order 1% to 2%) at\n+   the cost of a larger memory footprint *\/\n+\/* #define LIT_MEM *\/\n+\n@@ -244,0 +248,6 @@\n+#ifdef LIT_MEM\n+#   define LIT_BUFS 5\n+    ushf *d_buf;          \/* buffer for distances *\/\n+    uchf *l_buf;          \/* buffer for literals\/lengths *\/\n+#else\n+#   define LIT_BUFS 4\n@@ -245,0 +255,1 @@\n+#endif\n@@ -266,1 +277,1 @@\n-    uInt sym_next;      \/* running index in sym_buf *\/\n+    uInt sym_next;      \/* running index in symbol buffer *\/\n@@ -318,8 +329,8 @@\n-void ZLIB_INTERNAL _tr_init OF((deflate_state *s));\n-int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));\n-void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,\n-                        ulg stored_len, int last));\n-void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));\n-void ZLIB_INTERNAL _tr_align OF((deflate_state *s));\n-void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,\n-                        ulg stored_len, int last));\n+void ZLIB_INTERNAL _tr_init(deflate_state *s);\n+int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc);\n+void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n+                                   ulg stored_len, int last);\n+void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s);\n+void ZLIB_INTERNAL _tr_align(deflate_state *s);\n+void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n+                                    ulg stored_len, int last);\n@@ -345,0 +356,19 @@\n+#ifdef LIT_MEM\n+# define _tr_tally_lit(s, c, flush) \\\n+  { uch cc = (c); \\\n+    s->d_buf[s->sym_next] = 0; \\\n+    s->l_buf[s->sym_next++] = cc; \\\n+    s->dyn_ltree[cc].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+   }\n+# define _tr_tally_dist(s, distance, length, flush) \\\n+  { uch len = (uch)(length); \\\n+    ush dist = (ush)(distance); \\\n+    s->d_buf[s->sym_next] = dist; \\\n+    s->l_buf[s->sym_next++] = len; \\\n+    dist--; \\\n+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n+    s->dyn_dtree[d_code(dist)].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+  }\n+#else\n@@ -364,0 +394,1 @@\n+#endif\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/deflate.h","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -35,3 +35,1 @@\n-int ZEXPORT gzclose(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzclose(gzFile file) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/gzclose.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -34,3 +34,2 @@\n-#  ifdef _FILE_OFFSET_BITS\n-#    undef _FILE_OFFSET_BITS\n-#  endif\n+#  undef _FILE_OFFSET_BITS\n+#  undef _TIME_BITS\n@@ -146,2 +145,2 @@\n-  extern voidp  malloc OF((uInt size));\n-  extern void   free   OF((voidpf ptr));\n+  extern voidp  malloc(uInt size);\n+  extern void   free(voidpf ptr);\n@@ -165,4 +164,4 @@\n-    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n-    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));\n-    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));\n-    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));\n+    ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n+    ZEXTERN z_off64_t ZEXPORT gzseek64(gzFile, z_off64_t, int);\n+    ZEXTERN z_off64_t ZEXPORT gztell64(gzFile);\n+    ZEXTERN z_off64_t ZEXPORT gzoffset64(gzFile);\n@@ -230,1 +229,1 @@\n-void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));\n+void ZLIB_INTERNAL gz_error(gz_statep, int, const char *);\n@@ -232,1 +231,1 @@\n-char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));\n+char ZLIB_INTERNAL *gz_strwinerror(DWORD error);\n@@ -238,6 +237,2 @@\n-#ifdef INT_MAX\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)\n-#else\n-unsigned ZLIB_INTERNAL gz_intmax OF((void));\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n-#endif\n+unsigned ZLIB_INTERNAL gz_intmax(void);\n+#define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/gzguts.h","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -42,4 +42,0 @@\n-\/* Local functions *\/\n-local void gz_reset OF((gz_statep));\n-local gzFile gz_open OF((const void *, int, const char *));\n-\n@@ -57,3 +53,1 @@\n-char ZLIB_INTERNAL *gz_strwinerror(error)\n-     DWORD error;\n-{\n+char ZLIB_INTERNAL *gz_strwinerror(DWORD error) {\n@@ -99,3 +93,1 @@\n-local void gz_reset(state)\n-    gz_statep state;\n-{\n+local void gz_reset(gz_statep state) {\n@@ -117,5 +109,1 @@\n-local gzFile gz_open(path, fd, mode)\n-    const void *path;\n-    int fd;\n-    const char *mode;\n-{\n+local gzFile gz_open(const void *path, int fd, const char *mode) {\n@@ -296,4 +284,1 @@\n-gzFile ZEXPORT gzopen(path, mode)\n-    const char *path;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzopen(const char *path, const char *mode) {\n@@ -304,4 +289,1 @@\n-gzFile ZEXPORT gzopen64(path, mode)\n-    const char *path;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzopen64(const char *path, const char *mode) {\n@@ -312,4 +294,1 @@\n-gzFile ZEXPORT gzdopen(fd, mode)\n-    int fd;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzdopen(int fd, const char *mode) {\n@@ -333,4 +312,1 @@\n-gzFile ZEXPORT gzopen_w(path, mode)\n-    const wchar_t *path;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzopen_w(const wchar_t *path, const char *mode) {\n@@ -342,4 +318,1 @@\n-int ZEXPORT gzbuffer(file, size)\n-    gzFile file;\n-    unsigned size;\n-{\n+int ZEXPORT gzbuffer(gzFile file, unsigned size) {\n@@ -362,2 +335,2 @@\n-    if (size < 2)\n-        size = 2;               \/* need two bytes to check magic header *\/\n+    if (size < 8)\n+        size = 8;               \/* needed to behave well with flushing *\/\n@@ -369,3 +342,1 @@\n-int ZEXPORT gzrewind(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzrewind(gzFile file) {\n@@ -392,5 +363,1 @@\n-z_off64_t ZEXPORT gzseek64(file, offset, whence)\n-    gzFile file;\n-    z_off64_t offset;\n-    int whence;\n-{\n+z_off64_t ZEXPORT gzseek64(gzFile file, z_off64_t offset, int whence) {\n@@ -469,5 +436,1 @@\n-z_off_t ZEXPORT gzseek(file, offset, whence)\n-    gzFile file;\n-    z_off_t offset;\n-    int whence;\n-{\n+z_off_t ZEXPORT gzseek(gzFile file, z_off_t offset, int whence) {\n@@ -481,3 +444,1 @@\n-z_off64_t ZEXPORT gztell64(file)\n-    gzFile file;\n-{\n+z_off64_t ZEXPORT gztell64(gzFile file) {\n@@ -498,3 +459,1 @@\n-z_off_t ZEXPORT gztell(file)\n-    gzFile file;\n-{\n+z_off_t ZEXPORT gztell(gzFile file) {\n@@ -508,3 +467,1 @@\n-z_off64_t ZEXPORT gzoffset64(file)\n-    gzFile file;\n-{\n+z_off64_t ZEXPORT gzoffset64(gzFile file) {\n@@ -531,3 +488,1 @@\n-z_off_t ZEXPORT gzoffset(file)\n-    gzFile file;\n-{\n+z_off_t ZEXPORT gzoffset(gzFile file) {\n@@ -541,3 +496,1 @@\n-int ZEXPORT gzeof(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzeof(gzFile file) {\n@@ -558,4 +511,1 @@\n-const char * ZEXPORT gzerror(file, errnum)\n-    gzFile file;\n-    int *errnum;\n-{\n+const char * ZEXPORT gzerror(gzFile file, int *errnum) {\n@@ -579,3 +529,1 @@\n-void ZEXPORT gzclearerr(file)\n-    gzFile file;\n-{\n+void ZEXPORT gzclearerr(gzFile file) {\n@@ -605,5 +553,1 @@\n-void ZLIB_INTERNAL gz_error(state, err, msg)\n-    gz_statep state;\n-    int err;\n-    const char *msg;\n-{\n+void ZLIB_INTERNAL gz_error(gz_statep state, int err, const char *msg) {\n@@ -646,1 +590,0 @@\n-#ifndef INT_MAX\n@@ -651,5 +594,5 @@\n-unsigned ZLIB_INTERNAL gz_intmax()\n-{\n-    unsigned p, q;\n-\n-    p = 1;\n+unsigned ZLIB_INTERNAL gz_intmax(void) {\n+#ifdef INT_MAX\n+    return INT_MAX;\n+#else\n+    unsigned p = 1, q;\n@@ -662,1 +605,0 @@\n-}\n@@ -664,0 +606,1 @@\n+}\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/gzlib.c","additions":28,"deletions":85,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,9 +32,0 @@\n-\/* Local functions *\/\n-local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));\n-local int gz_avail OF((gz_statep));\n-local int gz_look OF((gz_statep));\n-local int gz_decomp OF((gz_statep));\n-local int gz_fetch OF((gz_statep));\n-local int gz_skip OF((gz_statep, z_off64_t));\n-local z_size_t gz_read OF((gz_statep, voidp, z_size_t));\n-\n@@ -45,6 +36,2 @@\n-local int gz_load(state, buf, len, have)\n-    gz_statep state;\n-    unsigned char *buf;\n-    unsigned len;\n-    unsigned *have;\n-{\n+local int gz_load(gz_statep state, unsigned char *buf, unsigned len,\n+                  unsigned *have) {\n@@ -80,3 +67,1 @@\n-local int gz_avail(state)\n-    gz_statep state;\n-{\n+local int gz_avail(gz_statep state) {\n@@ -115,3 +100,1 @@\n-local int gz_look(state)\n-    gz_statep state;\n-{\n+local int gz_look(gz_statep state) {\n@@ -197,3 +180,1 @@\n-local int gz_decomp(state)\n-    gz_statep state;\n-{\n+local int gz_decomp(gz_statep state) {\n@@ -251,3 +232,1 @@\n-local int gz_fetch(state)\n-    gz_statep state;\n-{\n+local int gz_fetch(gz_statep state) {\n@@ -281,4 +260,1 @@\n-local int gz_skip(state, len)\n-    gz_statep state;\n-    z_off64_t len;\n-{\n+local int gz_skip(gz_statep state, z_off64_t len) {\n@@ -316,5 +292,1 @@\n-local z_size_t gz_read(state, buf, len)\n-    gz_statep state;\n-    voidp buf;\n-    z_size_t len;\n-{\n+local z_size_t gz_read(gz_statep state, voidp buf, z_size_t len) {\n@@ -397,5 +369,1 @@\n-int ZEXPORT gzread(file, buf, len)\n-    gzFile file;\n-    voidp buf;\n-    unsigned len;\n-{\n+int ZEXPORT gzread(gzFile file, voidp buf, unsigned len) {\n@@ -433,6 +401,1 @@\n-z_size_t ZEXPORT gzfread(buf, size, nitems, file)\n-    voidp buf;\n-    z_size_t size;\n-    z_size_t nitems;\n-    gzFile file;\n-{\n+z_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems, gzFile file) {\n@@ -469,3 +432,1 @@\n-int ZEXPORT gzgetc(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzgetc(gzFile file) {\n@@ -496,3 +457,1 @@\n-int ZEXPORT gzgetc_(file)\n-gzFile file;\n-{\n+int ZEXPORT gzgetc_(gzFile file) {\n@@ -503,4 +462,1 @@\n-int ZEXPORT gzungetc(c, file)\n-    int c;\n-    gzFile file;\n-{\n+int ZEXPORT gzungetc(int c, gzFile file) {\n@@ -514,0 +470,4 @@\n+    \/* in case this was just opened, set up the input buffer *\/\n+    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n+        (void)gz_look(state);\n+\n@@ -563,5 +523,1 @@\n-char * ZEXPORT gzgets(file, buf, len)\n-    gzFile file;\n-    char *buf;\n-    int len;\n-{\n+char * ZEXPORT gzgets(gzFile file, char *buf, int len) {\n@@ -627,3 +583,1 @@\n-int ZEXPORT gzdirect(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzdirect(gzFile file) {\n@@ -647,3 +601,1 @@\n-int ZEXPORT gzclose_r(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzclose_r(gzFile file) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/gzread.c","additions":20,"deletions":68,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -32,6 +32,0 @@\n-\/* Local functions *\/\n-local int gz_init OF((gz_statep));\n-local int gz_comp OF((gz_statep, int));\n-local int gz_zero OF((gz_statep, z_off64_t));\n-local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));\n-\n@@ -41,3 +35,1 @@\n-local int gz_init(state)\n-    gz_statep state;\n-{\n+local int gz_init(gz_statep state) {\n@@ -97,4 +89,1 @@\n-local int gz_comp(state, flush)\n-    gz_statep state;\n-    int flush;\n-{\n+local int gz_comp(gz_statep state, int flush) {\n@@ -178,4 +167,1 @@\n-local int gz_zero(state, len)\n-    gz_statep state;\n-    z_off64_t len;\n-{\n+local int gz_zero(gz_statep state, z_off64_t len) {\n@@ -211,5 +197,1 @@\n-local z_size_t gz_write(state, buf, len)\n-    gz_statep state;\n-    voidpc buf;\n-    z_size_t len;\n-{\n+local z_size_t gz_write(gz_statep state, voidpc buf, z_size_t len) {\n@@ -279,5 +261,1 @@\n-int ZEXPORT gzwrite(file, buf, len)\n-    gzFile file;\n-    voidpc buf;\n-    unsigned len;\n-{\n+int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len) {\n@@ -307,6 +285,2 @@\n-z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)\n-    voidpc buf;\n-    z_size_t size;\n-    z_size_t nitems;\n-    gzFile file;\n-{\n+z_size_t ZEXPORT gzfwrite(voidpc buf, z_size_t size, z_size_t nitems,\n+                          gzFile file) {\n@@ -337,4 +311,1 @@\n-int ZEXPORT gzputc(file, c)\n-    gzFile file;\n-    int c;\n-{\n+int ZEXPORT gzputc(gzFile file, int c) {\n@@ -385,4 +356,1 @@\n-int ZEXPORT gzputs(file, s)\n-    gzFile file;\n-    const char *s;\n-{\n+int ZEXPORT gzputs(gzFile file, const char *s) {\n@@ -415,2 +383,1 @@\n-int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)\n-{\n+int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va) {\n@@ -487,2 +454,1 @@\n-int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)\n-{\n+int ZEXPORTVA gzprintf(gzFile file, const char *format, ...) {\n@@ -501,7 +467,4 @@\n-int ZEXPORTVA gzprintf(file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)\n-    gzFile file;\n-    const char *format;\n-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n-{\n+int ZEXPORTVA gzprintf(gzFile file, const char *format, int a1, int a2, int a3,\n+                       int a4, int a5, int a6, int a7, int a8, int a9, int a10,\n+                       int a11, int a12, int a13, int a14, int a15, int a16,\n+                       int a17, int a18, int a19, int a20) {\n@@ -589,4 +552,1 @@\n-int ZEXPORT gzflush(file, flush)\n-    gzFile file;\n-    int flush;\n-{\n+int ZEXPORT gzflush(gzFile file, int flush) {\n@@ -621,5 +581,1 @@\n-int ZEXPORT gzsetparams(file, level, strategy)\n-    gzFile file;\n-    int level;\n-    int strategy;\n-{\n+int ZEXPORT gzsetparams(gzFile file, int level, int strategy) {\n@@ -636,1 +592,1 @@\n-    if (state->mode != GZ_WRITE || state->err != Z_OK)\n+    if (state->mode != GZ_WRITE || state->err != Z_OK || state->direct)\n@@ -663,3 +619,1 @@\n-int ZEXPORT gzclose_w(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzclose_w(gzFile file) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/gzwrite.c","additions":19,"deletions":65,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-\/* function prototypes *\/\n-local void fixedtables OF((struct inflate_state FAR *state));\n-\n@@ -52,7 +49,3 @@\n-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)\n-z_streamp strm;\n-int windowBits;\n-unsigned char FAR *window;\n-const char *version;\n-int stream_size;\n-{\n+int ZEXPORT inflateBackInit_(z_streamp strm, int windowBits,\n+                             unsigned char FAR *window, const char *version,\n+                             int stream_size) {\n@@ -107,3 +100,1 @@\n-local void fixedtables(state)\n-struct inflate_state FAR *state;\n-{\n+local void fixedtables(struct inflate_state FAR *state) {\n@@ -275,7 +266,2 @@\n-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)\n-z_streamp strm;\n-in_func in;\n-void FAR *in_desc;\n-out_func out;\n-void FAR *out_desc;\n-{\n+int ZEXPORT inflateBack(z_streamp strm, in_func in, void FAR *in_desc,\n+                        out_func out, void FAR *out_desc) {\n@@ -659,3 +645,1 @@\n-int ZEXPORT inflateBackEnd(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateBackEnd(z_streamp strm) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/infback.c","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -74,4 +74,1 @@\n-void ZLIB_INTERNAL inflate_fast(strm, start)\n-z_streamp strm;\n-unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n-{\n+void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/inffast.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));\n+void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start);\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/inffast.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,14 +118,1 @@\n-\/* function prototypes *\/\n-local int inflateStateCheck OF((z_streamp strm));\n-local void fixedtables OF((struct inflate_state FAR *state));\n-local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,\n-                           unsigned copy));\n-#ifdef BUILDFIXED\n-   void makefixed OF((void));\n-#endif\n-local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,\n-                              unsigned len));\n-\n-local int inflateStateCheck(strm)\n-z_streamp strm;\n-{\n+local int inflateStateCheck(z_streamp strm) {\n@@ -143,3 +130,1 @@\n-int ZEXPORT inflateResetKeep(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateResetKeep(z_streamp strm) {\n@@ -169,3 +154,1 @@\n-int ZEXPORT inflateReset(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateReset(z_streamp strm) {\n@@ -182,4 +165,1 @@\n-int ZEXPORT inflateReset2(strm, windowBits)\n-z_streamp strm;\n-int windowBits;\n-{\n+int ZEXPORT inflateReset2(z_streamp strm, int windowBits) {\n@@ -222,6 +202,2 @@\n-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)\n-z_streamp strm;\n-int windowBits;\n-const char *version;\n-int stream_size;\n-{\n+int ZEXPORT inflateInit2_(z_streamp strm, int windowBits,\n+                          const char *version, int stream_size) {\n@@ -266,5 +242,2 @@\n-int ZEXPORT inflateInit_(strm, version, stream_size)\n-z_streamp strm;\n-const char *version;\n-int stream_size;\n-{\n+int ZEXPORT inflateInit_(z_streamp strm, const char *version,\n+                         int stream_size) {\n@@ -274,5 +247,1 @@\n-int ZEXPORT inflatePrime(strm, bits, value)\n-z_streamp strm;\n-int bits;\n-int value;\n-{\n+int ZEXPORT inflatePrime(z_streamp strm, int bits, int value) {\n@@ -282,0 +251,2 @@\n+    if (bits == 0)\n+        return Z_OK;\n@@ -305,3 +276,1 @@\n-local void fixedtables(state)\n-struct inflate_state FAR *state;\n-{\n+local void fixedtables(struct inflate_state FAR *state) {\n@@ -369,1 +338,1 @@\n-void makefixed()\n+void makefixed(void)\n@@ -423,5 +392,1 @@\n-local int updatewindow(strm, end, copy)\n-z_streamp strm;\n-const Bytef *end;\n-unsigned copy;\n-{\n+local int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {\n@@ -649,4 +614,1 @@\n-int ZEXPORT inflate(strm, flush)\n-z_streamp strm;\n-int flush;\n-{\n+int ZEXPORT inflate(z_streamp strm, int flush) {\n@@ -1328,3 +1290,1 @@\n-int ZEXPORT inflateEnd(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateEnd(z_streamp strm) {\n@@ -1342,5 +1302,2 @@\n-int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)\n-z_streamp strm;\n-Bytef *dictionary;\n-uInt *dictLength;\n-{\n+int ZEXPORT inflateGetDictionary(z_streamp strm, Bytef *dictionary,\n+                                 uInt *dictLength) {\n@@ -1365,5 +1322,2 @@\n-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)\n-z_streamp strm;\n-const Bytef *dictionary;\n-uInt dictLength;\n-{\n+int ZEXPORT inflateSetDictionary(z_streamp strm, const Bytef *dictionary,\n+                                 uInt dictLength) {\n@@ -1400,4 +1354,1 @@\n-int ZEXPORT inflateGetHeader(strm, head)\n-z_streamp strm;\n-gz_headerp head;\n-{\n+int ZEXPORT inflateGetHeader(z_streamp strm, gz_headerp head) {\n@@ -1428,5 +1379,2 @@\n-local unsigned syncsearch(have, buf, len)\n-unsigned FAR *have;\n-const unsigned char FAR *buf;\n-unsigned len;\n-{\n+local unsigned syncsearch(unsigned FAR *have, const unsigned char FAR *buf,\n+                          unsigned len) {\n@@ -1451,3 +1399,1 @@\n-int ZEXPORT inflateSync(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateSync(z_streamp strm) {\n@@ -1468,1 +1414,1 @@\n-        state->hold <<= state->bits & 7;\n+        state->hold >>= state->bits & 7;\n@@ -1509,3 +1455,1 @@\n-int ZEXPORT inflateSyncPoint(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateSyncPoint(z_streamp strm) {\n@@ -1519,4 +1463,1 @@\n-int ZEXPORT inflateCopy(dest, source)\n-z_streamp dest;\n-z_streamp source;\n-{\n+int ZEXPORT inflateCopy(z_streamp dest, z_streamp source) {\n@@ -1566,4 +1507,1 @@\n-int ZEXPORT inflateUndermine(strm, subvert)\n-z_streamp strm;\n-int subvert;\n-{\n+int ZEXPORT inflateUndermine(z_streamp strm, int subvert) {\n@@ -1584,4 +1522,1 @@\n-int ZEXPORT inflateValidate(strm, check)\n-z_streamp strm;\n-int check;\n-{\n+int ZEXPORT inflateValidate(z_streamp strm, int check) {\n@@ -1599,3 +1534,1 @@\n-long ZEXPORT inflateMark(strm)\n-z_streamp strm;\n-{\n+long ZEXPORT inflateMark(z_streamp strm) {\n@@ -1612,3 +1545,1 @@\n-unsigned long ZEXPORT inflateCodesUsed(strm)\n-z_streamp strm;\n-{\n+unsigned long ZEXPORT inflateCodesUsed(z_streamp strm) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/inflate.c","additions":31,"deletions":100,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Mark Adler\n+ * Copyright (C) 1995-2024 Mark Adler\n@@ -36,1 +36,1 @@\n-   \" inflate 1.2.13 Copyright 1995-2022 Mark Adler \";\n+   \" inflate 1.3.1 Copyright 1995-2024 Mark Adler \";\n@@ -56,8 +56,3 @@\n-int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)\n-codetype type;\n-unsigned short FAR *lens;\n-unsigned codes;\n-code FAR * FAR *table;\n-unsigned FAR *bits;\n-unsigned short FAR *work;\n-{\n+int ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n+                                unsigned codes, code FAR * FAR *table,\n+                                unsigned FAR *bits, unsigned short FAR *work) {\n@@ -89,1 +84,1 @@\n-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 194, 65};\n+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 77};\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/inftrees.c","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-   returns returns 852, and \"enough 30 6 15\" for distance codes returns 592.\n-   The initial root table size (9 or 6) is found in the fifth argument of the\n+   returns 852, and \"enough 30 6 15\" for distance codes returns 592. The\n+   initial root table size (9 or 6) is found in the fifth argument of the\n@@ -84,3 +84,3 @@\n-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,\n-                             unsigned codes, code FAR * FAR *table,\n-                             unsigned FAR *bits, unsigned short FAR *work));\n+int ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n+                                unsigned codes, code FAR * FAR *table,\n+                                unsigned FAR *bits, unsigned short FAR *work);\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/inftrees.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Changes from zlib 1.2.13\n+Changes from zlib 1.3.1\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/patches\/ChangeLog_java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2021 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -149,1 +149,7 @@\n-local const static_tree_desc  static_l_desc =\n+#ifdef NO_INIT_GLOBAL_POINTERS\n+#  define TCONST\n+#else\n+#  define TCONST const\n+#endif\n+\n+local TCONST static_tree_desc static_l_desc =\n@@ -152,1 +158,1 @@\n-local const static_tree_desc  static_d_desc =\n+local TCONST static_tree_desc static_d_desc =\n@@ -155,1 +161,1 @@\n-local const static_tree_desc  static_bl_desc =\n+local TCONST static_tree_desc static_bl_desc =\n@@ -159,1 +165,12 @@\n- * Local (static) routines in this file.\n+ * Output a short LSB first on the stream.\n+ * IN assertion: there is enough room in pendingBuf.\n+ *\/\n+#define put_short(s, w) { \\\n+    put_byte(s, (uch)((w) & 0xff)); \\\n+    put_byte(s, (uch)((ush)(w) >> 8)); \\\n+}\n+\n+\/* ===========================================================================\n+ * Reverse the first len bits of a code, using straightforward code (a faster\n+ * method would use a table)\n+ * IN assertion: 1 <= len <= 15\n@@ -161,0 +178,8 @@\n+local unsigned bi_reverse(unsigned code, int len) {\n+    register unsigned res = 0;\n+    do {\n+        res |= code & 1;\n+        code >>= 1, res <<= 1;\n+    } while (--len > 0);\n+    return res >> 1;\n+}\n@@ -162,17 +187,69 @@\n-local void tr_static_init OF((void));\n-local void init_block     OF((deflate_state *s));\n-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));\n-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));\n-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));\n-local void build_tree     OF((deflate_state *s, tree_desc *desc));\n-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));\n-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));\n-local int  build_bl_tree  OF((deflate_state *s));\n-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,\n-                              int blcodes));\n-local void compress_block OF((deflate_state *s, const ct_data *ltree,\n-                              const ct_data *dtree));\n-local int  detect_data_type OF((deflate_state *s));\n-local unsigned bi_reverse OF((unsigned code, int len));\n-local void bi_windup      OF((deflate_state *s));\n-local void bi_flush       OF((deflate_state *s));\n+\/* ===========================================================================\n+ * Flush the bit buffer, keeping at most 7 bits in it.\n+ *\/\n+local void bi_flush(deflate_state *s) {\n+    if (s->bi_valid == 16) {\n+        put_short(s, s->bi_buf);\n+        s->bi_buf = 0;\n+        s->bi_valid = 0;\n+    } else if (s->bi_valid >= 8) {\n+        put_byte(s, (Byte)s->bi_buf);\n+        s->bi_buf >>= 8;\n+        s->bi_valid -= 8;\n+    }\n+}\n+\n+\/* ===========================================================================\n+ * Flush the bit buffer and align the output on a byte boundary\n+ *\/\n+local void bi_windup(deflate_state *s) {\n+    if (s->bi_valid > 8) {\n+        put_short(s, s->bi_buf);\n+    } else if (s->bi_valid > 0) {\n+        put_byte(s, (Byte)s->bi_buf);\n+    }\n+    s->bi_buf = 0;\n+    s->bi_valid = 0;\n+#ifdef ZLIB_DEBUG\n+    s->bits_sent = (s->bits_sent + 7) & ~7;\n+#endif\n+}\n+\n+\/* ===========================================================================\n+ * Generate the codes for a given tree and bit counts (which need not be\n+ * optimal).\n+ * IN assertion: the array bl_count contains the bit length statistics for\n+ * the given tree and the field len is set for all tree elements.\n+ * OUT assertion: the field code is set for all tree elements of non\n+ *     zero code length.\n+ *\/\n+local void gen_codes(ct_data *tree, int max_code, ushf *bl_count) {\n+    ush next_code[MAX_BITS+1]; \/* next code value for each bit length *\/\n+    unsigned code = 0;         \/* running code value *\/\n+    int bits;                  \/* bit index *\/\n+    int n;                     \/* code index *\/\n+\n+    \/* The distribution counts are first used to generate the code values\n+     * without bit reversal.\n+     *\/\n+    for (bits = 1; bits <= MAX_BITS; bits++) {\n+        code = (code + bl_count[bits - 1]) << 1;\n+        next_code[bits] = (ush)code;\n+    }\n+    \/* Check that the bit counts in bl_count are consistent. The last code\n+     * must be all ones.\n+     *\/\n+    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n+            \"inconsistent bit counts\");\n+    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n+\n+    for (n = 0;  n <= max_code; n++) {\n+        int len = tree[n].Len;\n+        if (len == 0) continue;\n+        \/* Now reverse the bits *\/\n+        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);\n+\n+        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n+            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));\n+    }\n+}\n@@ -181,1 +258,1 @@\n-local void gen_trees_header OF((void));\n+local void gen_trees_header(void);\n@@ -194,9 +271,0 @@\n-\/* ===========================================================================\n- * Output a short LSB first on the stream.\n- * IN assertion: there is enough room in pendingBuf.\n- *\/\n-#define put_short(s, w) { \\\n-    put_byte(s, (uch)((w) & 0xff)); \\\n-    put_byte(s, (uch)((ush)(w) >> 8)); \\\n-}\n-\n@@ -208,7 +276,1 @@\n-local void send_bits      OF((deflate_state *s, int value, int length));\n-\n-local void send_bits(s, value, length)\n-    deflate_state *s;\n-    int value;  \/* value to send *\/\n-    int length; \/* number of bits *\/\n-{\n+local void send_bits(deflate_state *s, int value, int length) {\n@@ -256,2 +318,1 @@\n-local void tr_static_init()\n-{\n+local void tr_static_init(void) {\n@@ -350,2 +411,1 @@\n-void gen_trees_header()\n-{\n+void gen_trees_header(void) {\n@@ -400,0 +460,16 @@\n+\/* ===========================================================================\n+ * Initialize a new block.\n+ *\/\n+local void init_block(deflate_state *s) {\n+    int n; \/* iterates over tree elements *\/\n+\n+    \/* Initialize the trees. *\/\n+    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n+    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n+    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n+\n+    s->dyn_ltree[END_BLOCK].Freq = 1;\n+    s->opt_len = s->static_len = 0L;\n+    s->sym_next = s->matches = 0;\n+}\n+\n@@ -403,3 +479,1 @@\n-void ZLIB_INTERNAL _tr_init(s)\n-    deflate_state *s;\n-{\n+void ZLIB_INTERNAL _tr_init(deflate_state *s) {\n@@ -428,18 +502,0 @@\n-\/* ===========================================================================\n- * Initialize a new block.\n- *\/\n-local void init_block(s)\n-    deflate_state *s;\n-{\n-    int n; \/* iterates over tree elements *\/\n-\n-    \/* Initialize the trees. *\/\n-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n-\n-    s->dyn_ltree[END_BLOCK].Freq = 1;\n-    s->opt_len = s->static_len = 0L;\n-    s->sym_next = s->matches = 0;\n-}\n-\n@@ -475,5 +531,1 @@\n-local void pqdownheap(s, tree, k)\n-    deflate_state *s;\n-    ct_data *tree;  \/* the tree to restore *\/\n-    int k;               \/* node to move down *\/\n-{\n+local void pqdownheap(deflate_state *s, ct_data *tree, int k) {\n@@ -510,4 +562,1 @@\n-local void gen_bitlen(s, desc)\n-    deflate_state *s;\n-    tree_desc *desc;    \/* the tree descriptor *\/\n-{\n+local void gen_bitlen(deflate_state *s, tree_desc *desc) {\n@@ -588,42 +637,3 @@\n-\/* ===========================================================================\n- * Generate the codes for a given tree and bit counts (which need not be\n- * optimal).\n- * IN assertion: the array bl_count contains the bit length statistics for\n- * the given tree and the field len is set for all tree elements.\n- * OUT assertion: the field code is set for all tree elements of non\n- *     zero code length.\n- *\/\n-local void gen_codes(tree, max_code, bl_count)\n-    ct_data *tree;             \/* the tree to decorate *\/\n-    int max_code;              \/* largest code with non zero frequency *\/\n-    ushf *bl_count;            \/* number of codes at each bit length *\/\n-{\n-    ush next_code[MAX_BITS+1]; \/* next code value for each bit length *\/\n-    unsigned code = 0;         \/* running code value *\/\n-    int bits;                  \/* bit index *\/\n-    int n;                     \/* code index *\/\n-\n-    \/* The distribution counts are first used to generate the code values\n-     * without bit reversal.\n-     *\/\n-    for (bits = 1; bits <= MAX_BITS; bits++) {\n-        code = (code + bl_count[bits - 1]) << 1;\n-        next_code[bits] = (ush)code;\n-    }\n-    \/* Check that the bit counts in bl_count are consistent. The last code\n-     * must be all ones.\n-     *\/\n-    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n-            \"inconsistent bit counts\");\n-    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n-\n-    for (n = 0;  n <= max_code; n++) {\n-        int len = tree[n].Len;\n-        if (len == 0) continue;\n-        \/* Now reverse the bits *\/\n-        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);\n-\n-        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n-            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));\n-    }\n-}\n+#ifdef DUMP_BL_TREE\n+#  include <stdio.h>\n+#endif\n@@ -639,4 +649,1 @@\n-local void build_tree(s, desc)\n-    deflate_state *s;\n-    tree_desc *desc; \/* the tree descriptor *\/\n-{\n+local void build_tree(deflate_state *s, tree_desc *desc) {\n@@ -727,5 +734,1 @@\n-local void scan_tree(s, tree, max_code)\n-    deflate_state *s;\n-    ct_data *tree;   \/* the tree to be scanned *\/\n-    int max_code;    \/* and its largest code of non zero frequency *\/\n-{\n+local void scan_tree(deflate_state *s, ct_data *tree, int max_code) {\n@@ -772,5 +775,1 @@\n-local void send_tree(s, tree, max_code)\n-    deflate_state *s;\n-    ct_data *tree; \/* the tree to be scanned *\/\n-    int max_code;       \/* and its largest code of non zero frequency *\/\n-{\n+local void send_tree(deflate_state *s, ct_data *tree, int max_code) {\n@@ -823,3 +822,1 @@\n-local int build_bl_tree(s)\n-    deflate_state *s;\n-{\n+local int build_bl_tree(deflate_state *s) {\n@@ -858,4 +855,2 @@\n-local void send_all_trees(s, lcodes, dcodes, blcodes)\n-    deflate_state *s;\n-    int lcodes, dcodes, blcodes; \/* number of codes for each tree *\/\n-{\n+local void send_all_trees(deflate_state *s, int lcodes, int dcodes,\n+                          int blcodes) {\n@@ -887,6 +882,2 @@\n-void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)\n-    deflate_state *s;\n-    charf *buf;       \/* input block *\/\n-    ulg stored_len;   \/* length of input block *\/\n-    int last;         \/* one if this is the last block for a file *\/\n-{\n+void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n+                                    ulg stored_len, int last) {\n@@ -911,3 +902,1 @@\n-void ZLIB_INTERNAL _tr_flush_bits(s)\n-    deflate_state *s;\n-{\n+void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s) {\n@@ -921,3 +910,1 @@\n-void ZLIB_INTERNAL _tr_align(s)\n-    deflate_state *s;\n-{\n+void ZLIB_INTERNAL _tr_align(deflate_state *s) {\n@@ -932,0 +919,96 @@\n+\/* ===========================================================================\n+ * Send the block data compressed using the given Huffman trees\n+ *\/\n+local void compress_block(deflate_state *s, const ct_data *ltree,\n+                          const ct_data *dtree) {\n+    unsigned dist;      \/* distance of matched string *\/\n+    int lc;             \/* match length or unmatched char (if dist == 0) *\/\n+    unsigned sx = 0;    \/* running index in symbol buffers *\/\n+    unsigned code;      \/* the code to send *\/\n+    int extra;          \/* number of extra bits to send *\/\n+\n+    if (s->sym_next != 0) do {\n+#ifdef LIT_MEM\n+        dist = s->d_buf[sx];\n+        lc = s->l_buf[sx++];\n+#else\n+        dist = s->sym_buf[sx++] & 0xff;\n+        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n+        lc = s->sym_buf[sx++];\n+#endif\n+        if (dist == 0) {\n+            send_code(s, lc, ltree); \/* send a literal byte *\/\n+            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n+        } else {\n+            \/* Here, lc is the match length - MIN_MATCH *\/\n+            code = _length_code[lc];\n+            send_code(s, code + LITERALS + 1, ltree);   \/* send length code *\/\n+            extra = extra_lbits[code];\n+            if (extra != 0) {\n+                lc -= base_length[code];\n+                send_bits(s, lc, extra);       \/* send the extra length bits *\/\n+            }\n+            dist--; \/* dist is now the match distance - 1 *\/\n+            code = d_code(dist);\n+            Assert (code < D_CODES, \"bad d_code\");\n+\n+            send_code(s, code, dtree);       \/* send the distance code *\/\n+            extra = extra_dbits[code];\n+            if (extra != 0) {\n+                dist -= (unsigned)base_dist[code];\n+                send_bits(s, dist, extra);   \/* send the extra distance bits *\/\n+            }\n+        } \/* literal or match pair ? *\/\n+\n+        \/* Check for no overlay of pending_buf on needed symbols *\/\n+#ifdef LIT_MEM\n+        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\");\n+#else\n+        Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n+#endif\n+\n+    } while (sx < s->sym_next);\n+\n+    send_code(s, END_BLOCK, ltree);\n+}\n+\n+\/* ===========================================================================\n+ * Check if the data type is TEXT or BINARY, using the following algorithm:\n+ * - TEXT if the two conditions below are satisfied:\n+ *    a) There are no non-portable control characters belonging to the\n+ *       \"block list\" (0..6, 14..25, 28..31).\n+ *    b) There is at least one printable character belonging to the\n+ *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n+ * - BINARY otherwise.\n+ * - The following partially-portable control characters form a\n+ *   \"gray list\" that is ignored in this detection algorithm:\n+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n+ * IN assertion: the fields Freq of dyn_ltree are set.\n+ *\/\n+local int detect_data_type(deflate_state *s) {\n+    \/* block_mask is the bit mask of block-listed bytes\n+     * set bits 0..6, 14..25, and 28..31\n+     * 0xf3ffc07f = binary 11110011111111111100000001111111\n+     *\/\n+    unsigned long block_mask = 0xf3ffc07fUL;\n+    int n;\n+\n+    \/* Check for non-textual (\"block-listed\") bytes. *\/\n+    for (n = 0; n <= 31; n++, block_mask >>= 1)\n+        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))\n+            return Z_BINARY;\n+\n+    \/* Check for textual (\"allow-listed\") bytes. *\/\n+    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0\n+            || s->dyn_ltree[13].Freq != 0)\n+        return Z_TEXT;\n+    for (n = 32; n < LITERALS; n++)\n+        if (s->dyn_ltree[n].Freq != 0)\n+            return Z_TEXT;\n+\n+    \/* There are no \"block-listed\" or \"allow-listed\" bytes:\n+     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n+     *\/\n+    return Z_BINARY;\n+}\n+\n@@ -936,6 +1019,2 @@\n-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)\n-    deflate_state *s;\n-    charf *buf;       \/* input block, or NULL if too old *\/\n-    ulg stored_len;   \/* length of input block *\/\n-    int last;         \/* one if this is the last block for a file *\/\n-{\n+void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n+                                   ulg stored_len, int last) {\n@@ -1038,5 +1117,5 @@\n-int ZLIB_INTERNAL _tr_tally(s, dist, lc)\n-    deflate_state *s;\n-    unsigned dist;  \/* distance of matched string *\/\n-    unsigned lc;    \/* match length - MIN_MATCH or unmatched char (dist==0) *\/\n-{\n+int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc) {\n+#ifdef LIT_MEM\n+    s->d_buf[s->sym_next] = (ush)dist;\n+    s->l_buf[s->sym_next++] = (uch)lc;\n+#else\n@@ -1046,0 +1125,1 @@\n+#endif\n@@ -1062,144 +1142,0 @@\n-\n-\/* ===========================================================================\n- * Send the block data compressed using the given Huffman trees\n- *\/\n-local void compress_block(s, ltree, dtree)\n-    deflate_state *s;\n-    const ct_data *ltree; \/* literal tree *\/\n-    const ct_data *dtree; \/* distance tree *\/\n-{\n-    unsigned dist;      \/* distance of matched string *\/\n-    int lc;             \/* match length or unmatched char (if dist == 0) *\/\n-    unsigned sx = 0;    \/* running index in sym_buf *\/\n-    unsigned code;      \/* the code to send *\/\n-    int extra;          \/* number of extra bits to send *\/\n-\n-    if (s->sym_next != 0) do {\n-        dist = s->sym_buf[sx++] & 0xff;\n-        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n-        lc = s->sym_buf[sx++];\n-        if (dist == 0) {\n-            send_code(s, lc, ltree); \/* send a literal byte *\/\n-            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n-        } else {\n-            \/* Here, lc is the match length - MIN_MATCH *\/\n-            code = _length_code[lc];\n-            send_code(s, code + LITERALS + 1, ltree);   \/* send length code *\/\n-            extra = extra_lbits[code];\n-            if (extra != 0) {\n-                lc -= base_length[code];\n-                send_bits(s, lc, extra);       \/* send the extra length bits *\/\n-            }\n-            dist--; \/* dist is now the match distance - 1 *\/\n-            code = d_code(dist);\n-            Assert (code < D_CODES, \"bad d_code\");\n-\n-            send_code(s, code, dtree);       \/* send the distance code *\/\n-            extra = extra_dbits[code];\n-            if (extra != 0) {\n-                dist -= (unsigned)base_dist[code];\n-                send_bits(s, dist, extra);   \/* send the extra distance bits *\/\n-            }\n-        } \/* literal or match pair ? *\/\n-\n-        \/* Check that the overlay between pending_buf and sym_buf is ok: *\/\n-        Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n-\n-    } while (sx < s->sym_next);\n-\n-    send_code(s, END_BLOCK, ltree);\n-}\n-\n-\/* ===========================================================================\n- * Check if the data type is TEXT or BINARY, using the following algorithm:\n- * - TEXT if the two conditions below are satisfied:\n- *    a) There are no non-portable control characters belonging to the\n- *       \"block list\" (0..6, 14..25, 28..31).\n- *    b) There is at least one printable character belonging to the\n- *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n- * - BINARY otherwise.\n- * - The following partially-portable control characters form a\n- *   \"gray list\" that is ignored in this detection algorithm:\n- *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n- * IN assertion: the fields Freq of dyn_ltree are set.\n- *\/\n-local int detect_data_type(s)\n-    deflate_state *s;\n-{\n-    \/* block_mask is the bit mask of block-listed bytes\n-     * set bits 0..6, 14..25, and 28..31\n-     * 0xf3ffc07f = binary 11110011111111111100000001111111\n-     *\/\n-    unsigned long block_mask = 0xf3ffc07fUL;\n-    int n;\n-\n-    \/* Check for non-textual (\"block-listed\") bytes. *\/\n-    for (n = 0; n <= 31; n++, block_mask >>= 1)\n-        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))\n-            return Z_BINARY;\n-\n-    \/* Check for textual (\"allow-listed\") bytes. *\/\n-    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0\n-            || s->dyn_ltree[13].Freq != 0)\n-        return Z_TEXT;\n-    for (n = 32; n < LITERALS; n++)\n-        if (s->dyn_ltree[n].Freq != 0)\n-            return Z_TEXT;\n-\n-    \/* There are no \"block-listed\" or \"allow-listed\" bytes:\n-     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n-     *\/\n-    return Z_BINARY;\n-}\n-\n-\/* ===========================================================================\n- * Reverse the first len bits of a code, using straightforward code (a faster\n- * method would use a table)\n- * IN assertion: 1 <= len <= 15\n- *\/\n-local unsigned bi_reverse(code, len)\n-    unsigned code; \/* the value to invert *\/\n-    int len;       \/* its bit length *\/\n-{\n-    register unsigned res = 0;\n-    do {\n-        res |= code & 1;\n-        code >>= 1, res <<= 1;\n-    } while (--len > 0);\n-    return res >> 1;\n-}\n-\n-\/* ===========================================================================\n- * Flush the bit buffer, keeping at most 7 bits in it.\n- *\/\n-local void bi_flush(s)\n-    deflate_state *s;\n-{\n-    if (s->bi_valid == 16) {\n-        put_short(s, s->bi_buf);\n-        s->bi_buf = 0;\n-        s->bi_valid = 0;\n-    } else if (s->bi_valid >= 8) {\n-        put_byte(s, (Byte)s->bi_buf);\n-        s->bi_buf >>= 8;\n-        s->bi_valid -= 8;\n-    }\n-}\n-\n-\/* ===========================================================================\n- * Flush the bit buffer and align the output on a byte boundary\n- *\/\n-local void bi_windup(s)\n-    deflate_state *s;\n-{\n-    if (s->bi_valid > 8) {\n-        put_short(s, s->bi_buf);\n-    } else if (s->bi_valid > 0) {\n-        put_byte(s, (Byte)s->bi_buf);\n-    }\n-    s->bi_buf = 0;\n-    s->bi_valid = 0;\n-#ifdef ZLIB_DEBUG\n-    s->bits_sent = (s->bits_sent + 7) & ~7;\n-#endif\n-}\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/trees.c","additions":239,"deletions":303,"binary":false,"changes":542,"status":"modified"},{"patch":"@@ -51,6 +51,2 @@\n-int ZEXPORT uncompress2(dest, destLen, source, sourceLen)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong *sourceLen;\n-{\n+int ZEXPORT uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                        uLong *sourceLen) {\n@@ -110,6 +106,2 @@\n-int ZEXPORT uncompress(dest, destLen, source, sourceLen)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong sourceLen;\n-{\n+int ZEXPORT uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                       uLong sourceLen) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/uncompr.c","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));\n-\n@@ -87,5 +85,1 @@\n-uLong ZEXPORT adler32_z(adler, buf, len)\n-    uLong adler;\n-    const Bytef *buf;\n-    z_size_t len;\n-{\n+uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf, z_size_t len) {\n@@ -158,5 +152,1 @@\n-uLong ZEXPORT adler32(adler, buf, len)\n-    uLong adler;\n-    const Bytef *buf;\n-    uInt len;\n-{\n+uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len) {\n@@ -167,5 +157,1 @@\n-local uLong adler32_combine_(adler1, adler2, len2)\n-    uLong adler1;\n-    uLong adler2;\n-    z_off64_t len2;\n-{\n+local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2) {\n@@ -196,5 +182,1 @@\n-uLong ZEXPORT adler32_combine(adler1, adler2, len2)\n-    uLong adler1;\n-    uLong adler2;\n-    z_off_t len2;\n-{\n+uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2, z_off_t len2) {\n@@ -204,5 +186,1 @@\n-uLong ZEXPORT adler32_combine64(adler1, adler2, len2)\n-    uLong adler1;\n-    uLong adler2;\n-    z_off64_t len2;\n-{\n+uLong ZEXPORT adler32_combine64(uLong adler1, uLong adler2, z_off64_t len2) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/zadler32.c","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -268,1 +268,5 @@\n-   typedef unsigned long z_size_t;\n+#  ifdef _WIN64\n+     typedef unsigned long long z_size_t;\n+#  else\n+     typedef unsigned long z_size_t;\n+#  endif\n@@ -323,8 +327,0 @@\n-#ifndef Z_ARG \/* function prototypes for stdarg *\/\n-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)\n-#    define Z_ARG(args)  args\n-#  else\n-#    define Z_ARG(args)  ()\n-#  endif\n-#endif\n-\n@@ -547,1 +543,1 @@\n-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)\n+#  if defined(_WIN32) && !defined(__GNUC__)\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/zconf.h","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -130,13 +130,0 @@\n-\/* Local functions. *\/\n-local z_crc_t multmodp OF((z_crc_t a, z_crc_t b));\n-local z_crc_t x2nmodp OF((z_off64_t n, unsigned k));\n-\n-#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))\n-    local z_word_t byte_swap OF((z_word_t word));\n-#endif\n-\n-#if defined(W) && !defined(ARMCRC32)\n-    local z_crc_t crc_word OF((z_word_t data));\n-    local z_word_t crc_word_big OF((z_word_t data));\n-#endif\n-\n@@ -150,3 +137,1 @@\n-local z_word_t byte_swap(word)\n-    z_word_t word;\n-{\n+local z_word_t byte_swap(z_word_t word) {\n@@ -173,0 +158,14 @@\n+#ifdef DYNAMIC_CRC_TABLE\n+\/* =========================================================================\n+ * Table of powers of x for combining CRC-32s, filled in by make_crc_table()\n+ * below.\n+ *\/\n+   local z_crc_t FAR x2n_table[32];\n+#else\n+\/* =========================================================================\n+ * Tables for byte-wise and braided CRC-32 calculations, and a table of powers\n+ * of x for combining CRC-32s, all made by make_crc_table().\n+ *\/\n+#  include \"crc32.h\"\n+#endif\n+\n@@ -176,1 +175,20 @@\n-#ifdef DYNAMIC_CRC_TABLE\n+\/*\n+  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,\n+  reflected. For speed, this requires that a not be zero.\n+ *\/\n+local z_crc_t multmodp(z_crc_t a, z_crc_t b) {\n+    z_crc_t m, p;\n+\n+    m = (z_crc_t)1 << 31;\n+    p = 0;\n+    for (;;) {\n+        if (a & m) {\n+            p ^= b;\n+            if ((a & (m - 1)) == 0)\n+                break;\n+        }\n+        m >>= 1;\n+        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n+    }\n+    return p;\n+}\n@@ -178,0 +196,22 @@\n+\/*\n+  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been\n+  initialized.\n+ *\/\n+local z_crc_t x2nmodp(z_off64_t n, unsigned k) {\n+    z_crc_t p;\n+\n+    p = (z_crc_t)1 << 31;           \/* x^0 == 1 *\/\n+    while (n) {\n+        if (n & 1)\n+            p = multmodp(x2n_table[k & 31], p);\n+        n >>= 1;\n+        k++;\n+    }\n+    return p;\n+}\n+\n+#ifdef DYNAMIC_CRC_TABLE\n+\/* =========================================================================\n+ * Build the tables for byte-wise and braided CRC-32 calculations, and a table\n+ * of powers of x for combining CRC-32s.\n+ *\/\n@@ -179,2 +219,0 @@\n-local z_crc_t FAR x2n_table[32];\n-local void make_crc_table OF((void));\n@@ -185,1 +223,1 @@\n-   local void braid OF((z_crc_t [][256], z_word_t [][256], int, int));\n+   local void braid(z_crc_t [][256], z_word_t [][256], int, int);\n@@ -188,3 +226,3 @@\n-   local void write_table OF((FILE *, const z_crc_t FAR *, int));\n-   local void write_table32hi OF((FILE *, const z_word_t FAR *, int));\n-   local void write_table64 OF((FILE *, const z_word_t FAR *, int));\n+   local void write_table(FILE *, const z_crc_t FAR *, int);\n+   local void write_table32hi(FILE *, const z_word_t FAR *, int);\n+   local void write_table64(FILE *, const z_word_t FAR *, int);\n@@ -203,1 +241,0 @@\n-local void once OF((once_t *, void (*)(void)));\n@@ -223,4 +260,1 @@\n-local void once(state, init)\n-    once_t *state;\n-    void (*init)(void);\n-{\n+local void once(once_t *state, void (*init)(void)) {\n@@ -249,4 +283,1 @@\n-local int test_and_set OF((int volatile *));\n-local int test_and_set(flag)\n-    int volatile *flag;\n-{\n+local int test_and_set(int volatile *flag) {\n@@ -261,4 +292,1 @@\n-local void once(state, init)\n-    once_t *state;\n-    void (*init)(void);\n-{\n+local void once(once_t *state, void (*init)(void)) {\n@@ -306,2 +334,1 @@\n-local void make_crc_table()\n-{\n+local void make_crc_table(void) {\n@@ -474,5 +501,1 @@\n-local void write_table(out, table, k)\n-    FILE *out;\n-    const z_crc_t FAR *table;\n-    int k;\n-{\n+local void write_table(FILE *out, const z_crc_t FAR *table, int k) {\n@@ -491,5 +514,1 @@\n-local void write_table32hi(out, table, k)\n-FILE *out;\n-const z_word_t FAR *table;\n-int k;\n-{\n+local void write_table32hi(FILE *out, const z_word_t FAR *table, int k) {\n@@ -511,5 +530,1 @@\n-local void write_table64(out, table, k)\n-    FILE *out;\n-    const z_word_t FAR *table;\n-    int k;\n-{\n+local void write_table64(FILE *out, const z_word_t FAR *table, int k) {\n@@ -525,2 +540,1 @@\n-int main()\n-{\n+int main(void) {\n@@ -538,6 +552,1 @@\n-local void braid(ltl, big, n, w)\n-    z_crc_t ltl[][256];\n-    z_word_t big[][256];\n-    int n;\n-    int w;\n-{\n+local void braid(z_crc_t ltl[][256], z_word_t big[][256], int n, int w) {\n@@ -558,6 +567,0 @@\n-#else \/* !DYNAMIC_CRC_TABLE *\/\n-\/* ========================================================================\n- * Tables for byte-wise and braided CRC-32 calculations, and a table of powers\n- * of x for combining CRC-32s, all made by make_crc_table().\n- *\/\n-#include \"crc32.h\"\n@@ -566,49 +569,0 @@\n-\/* ========================================================================\n- * Routines used for CRC calculation. Some are also required for the table\n- * generation above.\n- *\/\n-\n-\/*\n-  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,\n-  reflected. For speed, this requires that a not be zero.\n- *\/\n-local z_crc_t multmodp(a, b)\n-    z_crc_t a;\n-    z_crc_t b;\n-{\n-    z_crc_t m, p;\n-\n-    m = (z_crc_t)1 << 31;\n-    p = 0;\n-    for (;;) {\n-        if (a & m) {\n-            p ^= b;\n-            if ((a & (m - 1)) == 0)\n-                break;\n-        }\n-        m >>= 1;\n-        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n-    }\n-    return p;\n-}\n-\n-\/*\n-  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been\n-  initialized.\n- *\/\n-local z_crc_t x2nmodp(n, k)\n-    z_off64_t n;\n-    unsigned k;\n-{\n-    z_crc_t p;\n-\n-    p = (z_crc_t)1 << 31;           \/* x^0 == 1 *\/\n-    while (n) {\n-        if (n & 1)\n-            p = multmodp(x2n_table[k & 31], p);\n-        n >>= 1;\n-        k++;\n-    }\n-    return p;\n-}\n-\n@@ -619,2 +573,1 @@\n-const z_crc_t FAR * ZEXPORT get_crc_table()\n-{\n+const z_crc_t FAR * ZEXPORT get_crc_table(void) {\n@@ -646,5 +599,2 @@\n-unsigned long ZEXPORT crc32_z(crc, buf, len)\n-    unsigned long crc;\n-    const unsigned char FAR *buf;\n-    z_size_t len;\n-{\n+unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n+                              z_size_t len) {\n@@ -750,3 +700,1 @@\n-local z_crc_t crc_word(data)\n-    z_word_t data;\n-{\n+local z_crc_t crc_word(z_word_t data) {\n@@ -759,3 +707,1 @@\n-local z_word_t crc_word_big(data)\n-    z_word_t data;\n-{\n+local z_word_t crc_word_big(z_word_t data) {\n@@ -772,5 +718,2 @@\n-unsigned long ZEXPORT crc32_z(crc, buf, len)\n-    unsigned long crc;\n-    const unsigned char FAR *buf;\n-    z_size_t len;\n-{\n+unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n+                              z_size_t len) {\n@@ -808,2 +751,2 @@\n-           processors can change the endianess at execution time. If the\n-           compiler knows what the endianess will be, it can optimize out the\n+           processors can change the endianness at execution time. If the\n+           compiler knows what the endianness will be, it can optimize out the\n@@ -1096,5 +1039,2 @@\n-unsigned long ZEXPORT crc32(crc, buf, len)\n-    unsigned long crc;\n-    const unsigned char FAR *buf;\n-    uInt len;\n-{\n+unsigned long ZEXPORT crc32(unsigned long crc, const unsigned char FAR *buf,\n+                            uInt len) {\n@@ -1105,5 +1045,1 @@\n-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)\n-    uLong crc1;\n-    uLong crc2;\n-    z_off64_t len2;\n-{\n+uLong ZEXPORT crc32_combine64(uLong crc1, uLong crc2, z_off64_t len2) {\n@@ -1117,5 +1053,1 @@\n-uLong ZEXPORT crc32_combine(crc1, crc2, len2)\n-    uLong crc1;\n-    uLong crc2;\n-    z_off_t len2;\n-{\n+uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2) {\n@@ -1126,3 +1058,1 @@\n-uLong ZEXPORT crc32_combine_gen64(len2)\n-    z_off64_t len2;\n-{\n+uLong ZEXPORT crc32_combine_gen64(z_off64_t len2) {\n@@ -1136,3 +1066,1 @@\n-uLong ZEXPORT crc32_combine_gen(len2)\n-    z_off_t len2;\n-{\n+uLong ZEXPORT crc32_combine_gen(z_off_t len2) {\n@@ -1143,5 +1071,1 @@\n-uLong ZEXPORT crc32_combine_op(crc1, crc2, op)\n-    uLong crc1;\n-    uLong crc2;\n-    uLong op;\n-{\n+uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/zcrc32.c","additions":86,"deletions":162,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-  version 1.2.13, October 13th, 2022\n+  version 1.3.1, January 22nd, 2024\n@@ -28,1 +28,1 @@\n-  Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -64,2 +64,2 @@\n-#define ZLIB_VERSION \"1.2.13\"\n-#define ZLIB_VERNUM 0x12d0\n+#define ZLIB_VERSION \"1.3.1\"\n+#define ZLIB_VERNUM 0x1310\n@@ -67,2 +67,2 @@\n-#define ZLIB_VER_MINOR 2\n-#define ZLIB_VER_REVISION 13\n+#define ZLIB_VER_MINOR 3\n+#define ZLIB_VER_REVISION 1\n@@ -105,2 +105,2 @@\n-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));\n-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));\n+typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);\n+typedef void   (*free_func)(voidpf opaque, voidpf address);\n@@ -244,1 +244,1 @@\n-ZEXTERN const char * ZEXPORT zlibVersion OF((void));\n+ZEXTERN const char * ZEXPORT zlibVersion(void);\n@@ -252,1 +252,1 @@\n-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));\n+ZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);\n@@ -257,1 +257,1 @@\n-   allocation functions.\n+   allocation functions.  total_in, total_out, adler, and msg are initialized.\n@@ -274,1 +274,1 @@\n-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));\n+ZEXTERN int ZEXPORT deflate(z_streamp strm, int flush);\n@@ -347,2 +347,2 @@\n-  avail_out is greater than six to avoid repeated flush markers due to\n-  avail_out == 0 on return.\n+  avail_out is greater than six when the flush marker begins, in order to avoid\n+  repeated flush markers upon calling deflate() again when avail_out == 0.\n@@ -387,1 +387,1 @@\n-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));\n+ZEXTERN int ZEXPORT deflateEnd(z_streamp strm);\n@@ -402,1 +402,1 @@\n-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateInit(z_streamp strm);\n@@ -410,1 +410,2 @@\n-   them to use default allocation functions.\n+   them to use default allocation functions.  total_in, total_out, adler, and\n+   msg are initialized.\n@@ -424,1 +425,1 @@\n-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));\n+ZEXTERN int ZEXPORT inflate(z_streamp strm, int flush);\n@@ -544,1 +545,1 @@\n-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateEnd(z_streamp strm);\n@@ -562,6 +563,6 @@\n-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,\n-                                     int  level,\n-                                     int  method,\n-                                     int  windowBits,\n-                                     int  memLevel,\n-                                     int  strategy));\n+ZEXTERN int ZEXPORT deflateInit2(z_streamp strm,\n+                                 int level,\n+                                 int method,\n+                                 int windowBits,\n+                                 int memLevel,\n+                                 int strategy);\n@@ -634,3 +635,3 @@\n-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,\n-                                             const Bytef *dictionary,\n-                                             uInt  dictLength));\n+ZEXTERN int ZEXPORT deflateSetDictionary(z_streamp strm,\n+                                         const Bytef *dictionary,\n+                                         uInt  dictLength);\n@@ -678,3 +679,3 @@\n-ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,\n-                                             Bytef *dictionary,\n-                                             uInt  *dictLength));\n+ZEXTERN int ZEXPORT deflateGetDictionary(z_streamp strm,\n+                                         Bytef *dictionary,\n+                                         uInt  *dictLength);\n@@ -700,2 +701,2 @@\n-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,\n-                                    z_streamp source));\n+ZEXTERN int ZEXPORT deflateCopy(z_streamp dest,\n+                                z_streamp source);\n@@ -718,1 +719,1 @@\n-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));\n+ZEXTERN int ZEXPORT deflateReset(z_streamp strm);\n@@ -723,1 +724,1 @@\n-   set unchanged.\n+   set unchanged.  total_in, total_out, adler, and msg are initialized.\n@@ -729,3 +730,3 @@\n-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,\n-                                      int level,\n-                                      int strategy));\n+ZEXTERN int ZEXPORT deflateParams(z_streamp strm,\n+                                  int level,\n+                                  int strategy);\n@@ -756,1 +757,1 @@\n-   applied to the the data compressed after deflateParams().\n+   applied to the data compressed after deflateParams().\n@@ -767,5 +768,5 @@\n-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,\n-                                    int good_length,\n-                                    int max_lazy,\n-                                    int nice_length,\n-                                    int max_chain));\n+ZEXTERN int ZEXPORT deflateTune(z_streamp strm,\n+                                int good_length,\n+                                int max_lazy,\n+                                int nice_length,\n+                                int max_chain);\n@@ -784,2 +785,2 @@\n-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,\n-                                       uLong sourceLen));\n+ZEXTERN uLong ZEXPORT deflateBound(z_streamp strm,\n+                                   uLong sourceLen);\n@@ -799,3 +800,3 @@\n-ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,\n-                                       unsigned *pending,\n-                                       int *bits));\n+ZEXTERN int ZEXPORT deflatePending(z_streamp strm,\n+                                   unsigned *pending,\n+                                   int *bits);\n@@ -814,3 +815,3 @@\n-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,\n-                                     int bits,\n-                                     int value));\n+ZEXTERN int ZEXPORT deflatePrime(z_streamp strm,\n+                                 int bits,\n+                                 int value);\n@@ -831,2 +832,2 @@\n-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,\n-                                         gz_headerp head));\n+ZEXTERN int ZEXPORT deflateSetHeader(z_streamp strm,\n+                                     gz_headerp head);\n@@ -848,2 +849,3 @@\n-   the time set to zero, and os set to 255, with no extra, name, or comment\n-   fields.  The gzip header is returned to the default state by deflateReset().\n+   the time set to zero, and os set to the current operating system, with no\n+   extra, name, or comment fields.  The gzip header is returned to the default\n+   state by deflateReset().\n@@ -856,2 +858,2 @@\n-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,\n-                                     int  windowBits));\n+ZEXTERN int ZEXPORT inflateInit2(z_streamp strm,\n+                                 int windowBits);\n@@ -910,3 +912,3 @@\n-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,\n-                                             const Bytef *dictionary,\n-                                             uInt  dictLength));\n+ZEXTERN int ZEXPORT inflateSetDictionary(z_streamp strm,\n+                                         const Bytef *dictionary,\n+                                         uInt  dictLength);\n@@ -933,3 +935,3 @@\n-ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,\n-                                             Bytef *dictionary,\n-                                             uInt  *dictLength));\n+ZEXTERN int ZEXPORT inflateGetDictionary(z_streamp strm,\n+                                         Bytef *dictionary,\n+                                         uInt  *dictLength);\n@@ -948,1 +950,1 @@\n-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateSync(z_streamp strm);\n@@ -961,4 +963,4 @@\n-   In the success case, the application may save the current current value of\n-   total_in which indicates where valid compressed data was found.  In the\n-   error case, the application may repeatedly call inflateSync, providing more\n-   input each time, until success or end of the input data.\n+   In the success case, the application may save the current value of total_in\n+   which indicates where valid compressed data was found.  In the error case,\n+   the application may repeatedly call inflateSync, providing more input each\n+   time, until success or end of the input data.\n@@ -967,2 +969,2 @@\n-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,\n-                                    z_streamp source));\n+ZEXTERN int ZEXPORT inflateCopy(z_streamp dest,\n+                                z_streamp source);\n@@ -983,1 +985,1 @@\n-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateReset(z_streamp strm);\n@@ -988,0 +990,1 @@\n+   total_in, total_out, adler, and msg are initialized.\n@@ -993,2 +996,2 @@\n-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,\n-                                      int windowBits));\n+ZEXTERN int ZEXPORT inflateReset2(z_streamp strm,\n+                                  int windowBits);\n@@ -1007,3 +1010,3 @@\n-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,\n-                                     int bits,\n-                                     int value));\n+ZEXTERN int ZEXPORT inflatePrime(z_streamp strm,\n+                                 int bits,\n+                                 int value);\n@@ -1028,1 +1031,1 @@\n-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));\n+ZEXTERN long ZEXPORT inflateMark(z_streamp strm);\n@@ -1056,2 +1059,2 @@\n-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,\n-                                         gz_headerp head));\n+ZEXTERN int ZEXPORT inflateGetHeader(z_streamp strm,\n+                                     gz_headerp head);\n@@ -1097,2 +1100,2 @@\n-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,\n-                                        unsigned char FAR *window));\n+ZEXTERN int ZEXPORT inflateBackInit(z_streamp strm, int windowBits,\n+                                    unsigned char FAR *window);\n@@ -1118,3 +1121,3 @@\n-typedef unsigned (*in_func) OF((void FAR *,\n-                                z_const unsigned char FAR * FAR *));\n-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));\n+typedef unsigned (*in_func)(void FAR *,\n+                            z_const unsigned char FAR * FAR *);\n+typedef int (*out_func)(void FAR *, unsigned char FAR *, unsigned);\n@@ -1122,3 +1125,3 @@\n-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,\n-                                    in_func in, void FAR *in_desc,\n-                                    out_func out, void FAR *out_desc));\n+ZEXTERN int ZEXPORT inflateBack(z_streamp strm,\n+                                in_func in, void FAR *in_desc,\n+                                out_func out, void FAR *out_desc);\n@@ -1192,1 +1195,1 @@\n-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateBackEnd(z_streamp strm);\n@@ -1200,1 +1203,1 @@\n-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));\n+ZEXTERN uLong ZEXPORT zlibCompileFlags(void);\n@@ -1253,2 +1256,2 @@\n-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,\n-                                 const Bytef *source, uLong sourceLen));\n+ZEXTERN int ZEXPORT compress(Bytef *dest,   uLongf *destLen,\n+                             const Bytef *source, uLong sourceLen);\n@@ -1268,3 +1271,3 @@\n-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,\n-                                  const Bytef *source, uLong sourceLen,\n-                                  int level));\n+ZEXTERN int ZEXPORT compress2(Bytef *dest,   uLongf *destLen,\n+                              const Bytef *source, uLong sourceLen,\n+                              int level);\n@@ -1284,1 +1287,1 @@\n-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));\n+ZEXTERN uLong ZEXPORT compressBound(uLong sourceLen);\n@@ -1291,2 +1294,2 @@\n-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,\n-                                   const Bytef *source, uLong sourceLen));\n+ZEXTERN int ZEXPORT uncompress(Bytef *dest,   uLongf *destLen,\n+                               const Bytef *source, uLong sourceLen);\n@@ -1309,2 +1312,2 @@\n-ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,\n-                                    const Bytef *source, uLong *sourceLen));\n+ZEXTERN int ZEXPORT uncompress2(Bytef *dest,   uLongf *destLen,\n+                                const Bytef *source, uLong *sourceLen);\n@@ -1329,1 +1332,1 @@\n-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));\n+ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);\n@@ -1366,1 +1369,1 @@\n-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));\n+ZEXTERN gzFile ZEXPORT gzdopen(int fd, const char *mode);\n@@ -1389,1 +1392,1 @@\n-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));\n+ZEXTERN int ZEXPORT gzbuffer(gzFile file, unsigned size);\n@@ -1405,1 +1408,1 @@\n-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));\n+ZEXTERN int ZEXPORT gzsetparams(gzFile file, int level, int strategy);\n@@ -1416,1 +1419,1 @@\n-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));\n+ZEXTERN int ZEXPORT gzread(gzFile file, voidp buf, unsigned len);\n@@ -1446,2 +1449,2 @@\n-ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,\n-                                     gzFile file));\n+ZEXTERN z_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems,\n+                                 gzFile file);\n@@ -1472,1 +1475,1 @@\n-ZEXTERN int ZEXPORT gzwrite OF((gzFile file, voidpc buf, unsigned len));\n+ZEXTERN int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len);\n@@ -1478,2 +1481,2 @@\n-ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,\n-                                      z_size_t nitems, gzFile file));\n+ZEXTERN z_size_t ZEXPORT gzfwrite(voidpc buf, z_size_t size,\n+                                  z_size_t nitems, gzFile file);\n@@ -1492,1 +1495,1 @@\n-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));\n+ZEXTERN int ZEXPORTVA gzprintf(gzFile file, const char *format, ...);\n@@ -1507,1 +1510,1 @@\n-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));\n+ZEXTERN int ZEXPORT gzputs(gzFile file, const char *s);\n@@ -1515,1 +1518,1 @@\n-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));\n+ZEXTERN char * ZEXPORT gzgets(gzFile file, char *buf, int len);\n@@ -1529,1 +1532,1 @@\n-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));\n+ZEXTERN int ZEXPORT gzputc(gzFile file, int c);\n@@ -1535,1 +1538,1 @@\n-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));\n+ZEXTERN int ZEXPORT gzgetc(gzFile file);\n@@ -1544,1 +1547,1 @@\n-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));\n+ZEXTERN int ZEXPORT gzungetc(int c, gzFile file);\n@@ -1556,1 +1559,1 @@\n-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));\n+ZEXTERN int ZEXPORT gzflush(gzFile file, int flush);\n@@ -1572,2 +1575,2 @@\n-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,\n-                                   z_off_t offset, int whence));\n+ZEXTERN z_off_t ZEXPORT gzseek(gzFile file,\n+                               z_off_t offset, int whence);\n@@ -1591,1 +1594,1 @@\n-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));\n+ZEXTERN int ZEXPORT    gzrewind(gzFile file);\n@@ -1599,1 +1602,1 @@\n-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));\n+ZEXTERN z_off_t ZEXPORT    gztell(gzFile file);\n@@ -1610,1 +1613,1 @@\n-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));\n+ZEXTERN z_off_t ZEXPORT gzoffset(gzFile file);\n@@ -1619,1 +1622,1 @@\n-ZEXTERN int ZEXPORT gzeof OF((gzFile file));\n+ZEXTERN int ZEXPORT gzeof(gzFile file);\n@@ -1634,1 +1637,1 @@\n-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));\n+ZEXTERN int ZEXPORT gzdirect(gzFile file);\n@@ -1655,1 +1658,1 @@\n-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));\n+ZEXTERN int ZEXPORT    gzclose(gzFile file);\n@@ -1668,2 +1671,2 @@\n-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));\n-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));\n+ZEXTERN int ZEXPORT gzclose_r(gzFile file);\n+ZEXTERN int ZEXPORT gzclose_w(gzFile file);\n@@ -1680,1 +1683,1 @@\n-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));\n+ZEXTERN const char * ZEXPORT gzerror(gzFile file, int *errnum);\n@@ -1696,1 +1699,1 @@\n-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));\n+ZEXTERN void ZEXPORT gzclearerr(gzFile file);\n@@ -1713,1 +1716,1 @@\n-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));\n+ZEXTERN uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len);\n@@ -1733,2 +1736,2 @@\n-ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,\n-                                    z_size_t len));\n+ZEXTERN uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf,\n+                                z_size_t len);\n@@ -1740,2 +1743,2 @@\n-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,\n-                                          z_off_t len2));\n+ZEXTERN uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2,\n+                                      z_off_t len2);\n@@ -1751,1 +1754,1 @@\n-ZEXTERN uLong ZEXPORT crc32 OF((uLong crc, const Bytef *buf, uInt len));\n+ZEXTERN uLong ZEXPORT crc32(uLong crc, const Bytef *buf, uInt len);\n@@ -1769,2 +1772,2 @@\n-ZEXTERN uLong ZEXPORT crc32_z OF((uLong crc, const Bytef *buf,\n-                                  z_size_t len));\n+ZEXTERN uLong ZEXPORT crc32_z(uLong crc, const Bytef *buf,\n+                              z_size_t len);\n@@ -1776,1 +1779,1 @@\n-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));\n+ZEXTERN uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2);\n@@ -1782,1 +1785,1 @@\n-   len2.\n+   len2. len2 must be non-negative.\n@@ -1786,1 +1789,1 @@\n-ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t len2));\n+ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t len2);\n@@ -1789,1 +1792,1 @@\n-   crc32_combine_op().\n+   crc32_combine_op(). len2 must be non-negative.\n@@ -1792,1 +1795,1 @@\n-ZEXTERN uLong ZEXPORT crc32_combine_op OF((uLong crc1, uLong crc2, uLong op));\n+ZEXTERN uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op);\n@@ -1805,14 +1808,14 @@\n-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,\n-                                     const char *version, int stream_size));\n-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,\n-                                     const char *version, int stream_size));\n-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,\n-                                      int windowBits, int memLevel,\n-                                      int strategy, const char *version,\n-                                      int stream_size));\n-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,\n-                                      const char *version, int stream_size));\n-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,\n-                                         unsigned char FAR *window,\n-                                         const char *version,\n-                                         int stream_size));\n+ZEXTERN int ZEXPORT deflateInit_(z_streamp strm, int level,\n+                                 const char *version, int stream_size);\n+ZEXTERN int ZEXPORT inflateInit_(z_streamp strm,\n+                                 const char *version, int stream_size);\n+ZEXTERN int ZEXPORT deflateInit2_(z_streamp strm, int  level, int  method,\n+                                  int windowBits, int memLevel,\n+                                  int strategy, const char *version,\n+                                  int stream_size);\n+ZEXTERN int ZEXPORT inflateInit2_(z_streamp strm, int  windowBits,\n+                                  const char *version, int stream_size);\n+ZEXTERN int ZEXPORT inflateBackInit_(z_streamp strm, int windowBits,\n+                                     unsigned char FAR *window,\n+                                     const char *version,\n+                                     int stream_size);\n@@ -1863,1 +1866,1 @@\n-ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  \/* backward compatibility *\/\n+ZEXTERN int ZEXPORT gzgetc_(gzFile file);       \/* backward compatibility *\/\n@@ -1880,7 +1883,7 @@\n-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));\n-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));\n-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));\n-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off64_t));\n+   ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n+   ZEXTERN z_off64_t ZEXPORT gzseek64(gzFile, z_off64_t, int);\n+   ZEXTERN z_off64_t ZEXPORT gztell64(gzFile);\n+   ZEXTERN z_off64_t ZEXPORT gzoffset64(gzFile);\n+   ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off64_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off64_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off64_t);\n@@ -1908,7 +1911,7 @@\n-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));\n-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));\n-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));\n-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));\n-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));\n-     ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));\n+     ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n+     ZEXTERN z_off_t ZEXPORT gzseek64(gzFile, z_off_t, int);\n+     ZEXTERN z_off_t ZEXPORT gztell64(gzFile);\n+     ZEXTERN z_off_t ZEXPORT gzoffset64(gzFile);\n+     ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off_t);\n+     ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off_t);\n+     ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off_t);\n@@ -1917,7 +1920,7 @@\n-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));\n-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));\n-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));\n-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));\n-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));\n+   ZEXTERN gzFile ZEXPORT gzopen(const char *, const char *);\n+   ZEXTERN z_off_t ZEXPORT gzseek(gzFile, z_off_t, int);\n+   ZEXTERN z_off_t ZEXPORT gztell(gzFile);\n+   ZEXTERN z_off_t ZEXPORT gzoffset(gzFile);\n+   ZEXTERN uLong ZEXPORT adler32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t);\n@@ -1928,3 +1931,3 @@\n-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));\n+   ZEXTERN uLong ZEXPORT adler32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t);\n@@ -1935,8 +1938,8 @@\n-ZEXTERN const char   * ZEXPORT zError           OF((int));\n-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));\n-ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));\n-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));\n-ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));\n-ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF((z_streamp));\n-ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));\n-ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));\n+ZEXTERN const char   * ZEXPORT zError(int);\n+ZEXTERN int            ZEXPORT inflateSyncPoint(z_streamp);\n+ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table(void);\n+ZEXTERN int            ZEXPORT inflateUndermine(z_streamp, int);\n+ZEXTERN int            ZEXPORT inflateValidate(z_streamp, int);\n+ZEXTERN unsigned long  ZEXPORT inflateCodesUsed(z_streamp);\n+ZEXTERN int            ZEXPORT inflateResetKeep(z_streamp);\n+ZEXTERN int            ZEXPORT deflateResetKeep(z_streamp);\n@@ -1944,2 +1947,2 @@\n-ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,\n-                                            const char *mode));\n+ZEXTERN gzFile         ZEXPORT gzopen_w(const wchar_t *path,\n+                                        const char *mode);\n@@ -1949,3 +1952,3 @@\n-ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,\n-                                                  const char *format,\n-                                                  va_list va));\n+ZEXTERN int            ZEXPORTVA gzvprintf(gzFile file,\n+                                           const char *format,\n+                                           va_list va);\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/zlib.h","additions":197,"deletions":194,"binary":false,"changes":391,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-const char * ZEXPORT zlibVersion()\n-{\n+const char * ZEXPORT zlibVersion(void) {\n@@ -56,2 +55,1 @@\n-uLong ZEXPORT zlibCompileFlags()\n-{\n+uLong ZEXPORT zlibCompileFlags(void) {\n@@ -148,3 +146,1 @@\n-void ZLIB_INTERNAL z_error(m)\n-    char *m;\n-{\n+void ZLIB_INTERNAL z_error(char *m) {\n@@ -159,3 +155,1 @@\n-const char * ZEXPORT zError(err)\n-    int err;\n-{\n+const char * ZEXPORT zError(int err) {\n@@ -175,5 +169,1 @@\n-void ZLIB_INTERNAL zmemcpy(dest, source, len)\n-    Bytef* dest;\n-    const Bytef* source;\n-    uInt  len;\n-{\n+void ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len) {\n@@ -186,5 +176,1 @@\n-int ZLIB_INTERNAL zmemcmp(s1, s2, len)\n-    const Bytef* s1;\n-    const Bytef* s2;\n-    uInt  len;\n-{\n+int ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len) {\n@@ -199,4 +185,1 @@\n-void ZLIB_INTERNAL zmemzero(dest, len)\n-    Bytef* dest;\n-    uInt  len;\n-{\n+void ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len) {\n@@ -243,2 +226,1 @@\n-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)\n-{\n+voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n@@ -269,2 +251,1 @@\n-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)\n-{\n+void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n@@ -306,2 +287,1 @@\n-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size)\n-{\n+voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size) {\n@@ -312,2 +292,1 @@\n-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)\n-{\n+void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n@@ -326,3 +305,3 @@\n-extern voidp  malloc OF((uInt size));\n-extern voidp  calloc OF((uInt items, uInt size));\n-extern void   free   OF((voidpf ptr));\n+extern voidp malloc(uInt size);\n+extern voidp calloc(uInt items, uInt size);\n+extern void free(voidpf ptr);\n@@ -331,5 +310,1 @@\n-voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)\n-    voidpf opaque;\n-    unsigned items;\n-    unsigned size;\n-{\n+voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n@@ -341,4 +316,1 @@\n-void ZLIB_INTERNAL zcfree(opaque, ptr)\n-    voidpf opaque;\n-    voidpf ptr;\n-{\n+void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/zutil.c","additions":16,"deletions":44,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -83,1 +83,1 @@\n-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]\n+#define ERR_MSG(err) z_errmsg[(err) < -6 || (err) > 2 ? 9 : 2 - (err)]\n@@ -164,1 +164,1 @@\n-#if defined(MACOS) || defined(TARGET_OS_MAC)\n+#if defined(MACOS)\n@@ -166,9 +166,0 @@\n-#  ifndef Z_SOLO\n-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n-#      include <unix.h> \/* for fdopen *\/\n-#    else\n-#      ifndef fdopen\n-#        define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#      endif\n-#    endif\n-#  endif\n@@ -197,12 +188,0 @@\n-#if defined(_BEOS_) || defined(RISCOS)\n-#  define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#endif\n-\n-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX\n-#  if defined(_WIN32_WCE)\n-#    define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#  else\n-#    define fdopen(fd,type)  _fdopen(fd,type)\n-#  endif\n-#endif\n-\n@@ -218,3 +197,3 @@\n-    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));\n-    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));\n-    ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));\n+    ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off_t);\n+    ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off_t);\n+    ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off_t);\n@@ -259,3 +238,3 @@\n-   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));\n-   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));\n-   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));\n+   void ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len);\n+   int ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len);\n+   void ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len);\n@@ -268,1 +247,1 @@\n-   extern void ZLIB_INTERNAL z_error OF((char *m));\n+   extern void ZLIB_INTERNAL z_error(char *m);\n@@ -285,3 +264,3 @@\n-   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,\n-                                    unsigned size));\n-   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));\n+   voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items,\n+                                unsigned size);\n+   void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr);\n","filename":"jdk\/src\/share\/native\/java\/util\/zip\/zlib\/zutil.h","additions":13,"deletions":34,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.11, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.11, January 15th, 2017\n+  version 1.3.1, January 22, 2024\n","filename":"langtools\/THIRD_PARTY_README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-%% This notice is provided with respect to zlib v1.2.11, which may be included \n+%% This notice is provided with respect to zlib v1.3.1, which may be included\n@@ -3051,1 +3051,1 @@\n-  version 1.2.11, January 15th, 2017\n+  version 1.3.1, January 22, 2024\n","filename":"nashorn\/THIRD_PARTY_README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}