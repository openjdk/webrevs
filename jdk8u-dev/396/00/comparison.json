{"files":[{"patch":"@@ -1133,0 +1133,1 @@\n+template bool ciMethod::has_option_value<double>(const char* option, double& value);\n","filename":"hotspot\/src\/share\/vm\/ci\/ciMethod.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+  DoubleType,\n@@ -200,0 +201,4 @@\n+template<> OptionType get_type_for<double>() {\n+  return DoubleType;\n+}\n+\n@@ -299,0 +304,9 @@\n+template<>\n+void TypedMethodOptionMatcher<double>::print() {\n+  ttyLocker ttyl;\n+  print_base();\n+  tty->print(\" double %s\", _option);\n+  tty->print(\" = %f\", _value);\n+  tty->cr();\n+};\n+\n@@ -392,0 +406,1 @@\n+template bool CompilerOracle::has_option_value<double>(methodHandle method, const char* option, double& value);\n@@ -609,0 +624,14 @@\n+    } else if (strcmp(type, \"double\") == 0) {\n+      char buffer[2][256];\n+      \/\/ Decimal separator '.' has been replaced with ' ' or '\/' earlier,\n+      \/\/ so read integer and fraction part of double value separately.\n+      if (sscanf(line, \"%*[ \\t]%255[0-9]%*[ \/\\t]%255[0-9]%n\", buffer[0], buffer[1], &bytes_read) == 2) {\n+        char value[512] = \"\";\n+        strncat(value, buffer[0], 255);\n+        strcat(value, \".\");\n+        strncat(value, buffer[1], 255);\n+        total_bytes_read += bytes_read;\n+        return add_option_string(c_name, c_match, m_name, m_match, signature, flag, atof(value));\n+      } else {\n+        jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s\", flag, type);\n+      }\n@@ -699,2 +728,1 @@\n-      \/\/ Type (1) is used to support ciMethod::has_option(\"someflag\")\n-      \/\/ (i.e., to check if a flag \"someflag\" is enabled for a method).\n+      \/\/ Type (1) is used to enable a boolean flag for a method.\n@@ -703,1 +731,1 @@\n-      \/\/ the following types: intx, uintx, bool, ccstr, and ccstrlist.\n+      \/\/ the following types: intx, uintx, bool, ccstr, ccstrlist, and double.\n@@ -721,0 +749,1 @@\n+            || strcmp(option, \"double\") == 0\n","filename":"hotspot\/src\/share\/vm\/compiler\/compilerOracle.cpp","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-\/\/ bool, intx, uintx, ccstr.\n+\/\/ bool, intx, uintx, ccstr, double, or uint64_t.\n","filename":"hotspot\/src\/share\/vm\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.oracle.java.testlibrary.*;\n+\n+\/*\n+ * @test CheckCompileCommandOption\n+ * @bug 8055286 8056964 8059847\n+ * @summary \"Checks parsing of -XX:+CompileCommand=option\"\n+ * @library \/testlibrary\n+ * @run main CheckCompileCommandOption\n+ *\/\n+\n+public class CheckCompileCommandOption {\n+\n+    \/\/ Currently, two types of trailing options can be used with\n+    \/\/ -XX:CompileCommand=option\n+    \/\/\n+    \/\/ (1) CompileCommand=option,Klass::method,flag\n+    \/\/ (2) CompileCommand=option,Klass::method,type,flag,value\n+    \/\/\n+    \/\/ Type (1) is used to enable a boolean flag for a method.\n+    \/\/\n+    \/\/ Type (2) is used to support flags with a value. Values can\n+    \/\/ have the the following types: intx, uintx, bool, ccstr,\n+    \/\/ ccstrlist, and double.\n+\n+    private static final String[][] TYPE_1_ARGUMENTS = {\n+        {\n+            \"-XX:CompileCommand=option,com\/oracle\/Test.test,MyBoolOption1\",\n+            \"-XX:CompileCommand=option,com\/oracle\/Test,test,MyBoolOption2\",\n+            \"-XX:CompileCommand=option,com.oracle.Test::test,MyBoolOption3\",\n+            \"-XX:CompileCommand=option,com\/oracle\/Test::test,MyBoolOption4\",\n+            \"-version\"\n+        },\n+        {\n+            \"-XX:CompileCommand=option,com\/oracle\/Test.test,MyBoolOption1,MyBoolOption2\",\n+            \"-version\"\n+        },\n+        {\n+            \"-XX:CompileCommand=option,com\/oracle\/Test,test,MyBoolOption1,MyBoolOption2\",\n+            \"-version\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_1_EXPECTED_OUTPUTS = {\n+        {\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption1 = true\",\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption2 = true\",\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption3 = true\",\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption4 = true\"\n+        },\n+        {\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption1 = true\",\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption2 = true\",\n+        },\n+        {\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption1 = true\",\n+            \"CompilerOracle: option com\/oracle\/Test.test bool MyBoolOption2 = true\",\n+        }\n+    };\n+\n+    private static final String[][] TYPE_2_ARGUMENTS = {\n+        {\n+            \"-XX:CompileCommand=option,Test::test,ccstrlist,MyListOption,_foo,_bar\",\n+            \"-XX:CompileCommand=option,Test::test,ccstr,MyStrOption,_foo\",\n+            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption,false\",\n+            \"-XX:CompileCommand=option,Test::test,intx,MyIntxOption,-1\",\n+            \"-XX:CompileCommand=option,Test::test,uintx,MyUintxOption,1\",\n+            \"-XX:CompileCommand=option,Test::test,MyFlag\",\n+            \"-XX:CompileCommand=option,Test::test,double,MyDoubleOption,1.123\",\n+            \"-version\"\n+        },\n+        {\n+            \"-XX:CompileCommand=option,Test.test,double,MyDoubleOption,1.123\",\n+            \"-version\"\n+        },\n+        {\n+            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption,false,intx,MyIntxOption,-1,uintx,MyUintxOption,1,MyFlag,double,MyDoubleOption,1.123\",\n+            \"-version\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_2_EXPECTED_OUTPUTS = {\n+        {\n+            \"CompilerOracle: option Test.test const char* MyListOption = '_foo _bar'\",\n+            \"CompilerOracle: option Test.test const char* MyStrOption = '_foo'\",\n+            \"CompilerOracle: option Test.test bool MyBoolOption = false\",\n+            \"CompilerOracle: option Test.test intx MyIntxOption = -1\",\n+            \"CompilerOracle: option Test.test uintx MyUintxOption = 1\",\n+            \"CompilerOracle: option Test.test bool MyFlag = true\",\n+            \"CompilerOracle: option Test.test double MyDoubleOption = 1.123000\"\n+        },\n+        {\n+            \"CompilerOracle: option Test.test double MyDoubleOption = 1.123000\"\n+        },\n+        {\n+            \"CompilerOracle: option Test.test bool MyBoolOption = false\",\n+            \"CompilerOracle: option Test.test intx MyIntxOption = -1\",\n+            \"CompilerOracle: option Test.test uintx MyUintxOption = 1\",\n+            \"CompilerOracle: option Test.test bool MyFlag = true\",\n+            \"CompilerOracle: option Test.test double MyDoubleOption = 1.123000\",\n+        }\n+    };\n+\n+    private static final String[][] TYPE_2_INVALID_ARGUMENTS = {\n+        {\n+            \/\/ bool flag name missing\n+            \"-XX:CompileCommand=option,Test::test,bool\",\n+            \"-version\"\n+        },\n+        {\n+            \/\/ bool flag value missing\n+            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption\",\n+            \"-version\"\n+        },\n+        {\n+            \/\/ wrong value for bool flag\n+            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption,100\",\n+            \"-version\"\n+        },\n+        {\n+            \/\/ intx flag name missing\n+            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption,false,intx\",\n+            \"-version\"\n+        },\n+        {\n+            \/\/ intx flag value missing\n+            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption,false,intx,MyIntOption\",\n+            \"-version\"\n+        },\n+        {\n+            \/\/ wrong value for intx flag\n+            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption,false,intx,MyIntOption,true\",\n+            \"-version\"\n+        },\n+        {\n+            \/\/ wrong value for flag double flag\n+            \"-XX:CompileCommand=option,Test::test,double,MyDoubleOption,1\",\n+            \"-version\"\n+        }\n+    };\n+\n+    private static void verifyValidOption(String[] arguments, String[] expected_outputs) throws Exception {\n+        ProcessBuilder pb;\n+        OutputAnalyzer out;\n+\n+        pb = ProcessTools.createJavaProcessBuilder(arguments);\n+        out = new OutputAnalyzer(pb.start());\n+\n+        for (String expected_output : expected_outputs) {\n+            out.shouldContain(expected_output);\n+        }\n+\n+        out.shouldNotContain(\"CompilerOracle: unrecognized line\");\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    private static void verifyInvalidOption(String[] arguments) throws Exception {\n+        ProcessBuilder pb;\n+        OutputAnalyzer out;\n+\n+        pb = ProcessTools.createJavaProcessBuilder(arguments);\n+        out = new OutputAnalyzer(pb.start());\n+\n+        out.shouldContain(\"CompilerOracle: unrecognized line\");\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (TYPE_1_ARGUMENTS.length != TYPE_1_EXPECTED_OUTPUTS.length) {\n+            throw new RuntimeException(\"Test is set up incorrectly: length of arguments and expected outputs for type (1) options does not match.\");\n+        }\n+\n+        if (TYPE_2_ARGUMENTS.length != TYPE_2_EXPECTED_OUTPUTS.length) {\n+            throw new RuntimeException(\"Test is set up incorrectly: length of arguments and expected outputs for type (2) options does not match.\");\n+        }\n+\n+        \/\/ Check if type (1) options are parsed correctly\n+        for (int i = 0; i < TYPE_1_ARGUMENTS.length; i++) {\n+            verifyValidOption(TYPE_1_ARGUMENTS[i], TYPE_1_EXPECTED_OUTPUTS[i]);\n+        }\n+\n+        \/\/ Check if type (2) options are parsed correctly\n+        for (int i = 0; i < TYPE_2_ARGUMENTS.length; i++) {\n+            verifyValidOption(TYPE_2_ARGUMENTS[i], TYPE_2_EXPECTED_OUTPUTS[i]);\n+        }\n+\n+        \/\/ Check if error is reported for invalid type (2) options\n+        \/\/ (flags with type information specified)\n+        for (String[] arguments: TYPE_2_INVALID_ARGUMENTS) {\n+            verifyInvalidOption(arguments);\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/compiler\/oracle\/CheckCompileCommandOption.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"}]}