{"files":[{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 5054016\n+ * @summary get the failure immediately when writing individual chunks over socket fail\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import static java.lang.System.out;\n+\n+public class CheckError {\n+\n+    static int BUFFER_SIZE = 8192; \/\/ 8k\n+    static int TOTAL_BYTES = 1 * 1024 * 1024; \/\/ 1M\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        HTTPServer server = new HTTPServer();\n+        server.start();\n+        int port = server.getPort();\n+        out.println(\"Server listening on \" + port);\n+\n+\n+        URL url = new URL(\"http:\/\/localhost:\" + port);\n+        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n+        conn.setRequestMethod(\"POST\");\n+        conn.setDoOutput(true);\n+        conn.setChunkedStreamingMode(1024);\n+\n+        out.println(\"sending \" + TOTAL_BYTES + \" bytes\");\n+\n+        int byteAtOnce;\n+        int sendingBytes = TOTAL_BYTES;\n+        byte[] buffer = getBuffer(BUFFER_SIZE);\n+        try (OutputStream toServer = conn.getOutputStream()) {\n+            while (sendingBytes > 0) {\n+                if (sendingBytes > BUFFER_SIZE) {\n+                    byteAtOnce = BUFFER_SIZE;\n+                } else {\n+                    byteAtOnce = sendingBytes;\n+                }\n+                toServer.write(buffer, 0, byteAtOnce);\n+                sendingBytes -= byteAtOnce;\n+                out.print((TOTAL_BYTES - sendingBytes) + \" was sent. \");\n+                toServer.flush();\n+                \/\/ gives the server thread time to read, and eventually close;\n+                Thread.sleep(500);\n+            }\n+        } catch (IOException expected) {\n+            \/\/ Expected IOException due to server.close()\n+            out.println(\"PASSED. Caught expected: \" + expected);\n+            return;\n+        }\n+\n+        \/\/ Expected IOException not received. FAIL\n+        throw new RuntimeException(\"Failed: Expected IOException not received\");\n+    }\n+\n+    static byte[] getBuffer(int size) {\n+        byte[] buffer = new byte[size];\n+        for (int i = 0; i < size; i++)\n+            buffer[i] = (byte)i;\n+        return buffer;\n+    }\n+\n+    static class HTTPServer extends Thread {\n+\n+        final ServerSocket serverSocket;\n+\n+        HTTPServer() throws IOException {\n+            serverSocket = new ServerSocket(0);\n+        }\n+\n+        int getPort() {\n+            return serverSocket.getLocalPort();\n+        }\n+\n+        public void run() {\n+            try (Socket client = serverSocket.accept()) {\n+\n+                InputStream in = client.getInputStream();\n+                BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n+                String line;\n+                do {\n+                    line = reader.readLine();\n+                    out.println(\"Server: \" + line);\n+                } while (line != null && line.length() > 0);\n+\n+                System.out.println(\"Server: receiving some data\");\n+                \/\/ just read some data, then close the connection\n+                in.read(new byte[1024]);\n+\n+                in.close();\n+                client.close();\n+                out.println(\"Server closed socket\");\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+}\n","filename":"jdk\/test\/sun\/net\/www\/http\/ChunkedOutputStream\/CheckError.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 5054016\n- * @run main\/othervm\/timeout=300 checkError\n- * @summary get the failure immediately when writing individual chunks over socket fail\n- *\/\n-\n-import java.io.*;\n-import java.net.*;\n-import java.util.StringTokenizer;\n-\n-\n-public class checkError {\n-    static final int TEST_PASSED = 95;\n-    static final int TEST_FAILED = 97;\n-\n-    static int testStatus = TEST_PASSED;\n-\n-    static String serverName = \"localhost\";\n-    static int bufferSize = 8192; \/\/ 8k\n-    static int totalBytes = 1048576; \/\/ 1M\n-\n-    static int j = 0;\n-\n-    static public Object threadStarting = new Object();\n-    static public Object threadWaiting = new Object();\n-\n-\n-    public static void main(String[] args) throws Exception {\n-        HttpURLConnection conn = null;\n-        OutputStream toServer = null;\n-        byte[] buffer = null;\n-        HTTPServer server = null;\n-        synchronized(threadWaiting) {\n-            System.out.println(\"HTTP-client>Starting default Http-server\");\n-            synchronized(threadStarting) {\n-                server = new HTTPServer();\n-                server.start();\n-                try {\n-                    System.out.println(\"waiting server to be start\");\n-                    threadStarting.wait();\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            int port = server.getPort();\n-            URL url = new URL(\"http:\/\/\" + serverName + \":\" + port);\n-            conn = (HttpURLConnection )url.openConnection();\n-            conn.setRequestMethod(\"POST\");\n-            conn.setDoOutput(true);\n-\n-            System.out.println(\"assigning 1024 to the chunk length\");\n-            conn.setChunkedStreamingMode(1024);\n-            conn.connect();\n-\n-            toServer = conn.getOutputStream();\n-            buffer = getThickBuffer(bufferSize);\n-            System.out.println(\"sending \" + totalBytes + \" bytes\");\n-        }\n-\n-        int byteAtOnce = 0;\n-        int sendingBytes = totalBytes;\n-        try {\n-            while (sendingBytes > 0) {\n-                if (sendingBytes > bufferSize) {\n-                    byteAtOnce = bufferSize;\n-                } else {\n-                    byteAtOnce = sendingBytes;\n-                }\n-                toServer.write(buffer, 0, byteAtOnce);\n-                sendingBytes -= byteAtOnce;\n-                \/\/ System.out.println((totalBytes - sendingBytes) + \" was sent\");\n-                toServer.flush();\n-            }\n-        } catch (OutOfMemoryError e) {\n-            e.printStackTrace();\n-            System.out.println(\"***ERR***> UNEXPECTED error: \" + e);\n-            testStatus = TEST_FAILED;\n-            testExit();\n-        } catch (IOException e) {\n-            \/\/ e.printStackTrace();\n-            \/\/ this is the expected IOException\n-            \/\/ due to server.close()\n-            testStatus = TEST_PASSED;\n-            testExit();\n-        } finally {\n-            toServer.close();\n-        }\n-\n-        \/\/ we have not received the expected IOException\n-        \/\/ test fail\n-        testStatus = TEST_FAILED;\n-        testExit();\n-\n-    }\n-\n-    static void testExit() {\n-        if (testStatus == TEST_FAILED) {\n-            throw new RuntimeException(\"Test Failed: haven't received the expected IOException\");\n-        } else {\n-            System.out.println(\"TEST PASSED\");\n-        }\n-        System.exit(testStatus);\n-    }\n-\n-    static byte[] getThickBuffer(int size) {\n-\n-        byte[] buffer = new byte[size];\n-\n-        for (int i = 0; i < size; i++) {\n-            if (j > 9)\n-                j = 0;\n-            String s = Integer.toString(j);\n-            buffer[i] = (byte )s.charAt(0);\n-            j++;\n-        }\n-\n-        return buffer;\n-    }\n-}\n-\n-\n-class HTTPServer extends Thread {\n-\n-    static volatile boolean isCompleted;\n-\n-    Socket client;\n-    ServerSocket serverSocket;\n-\n-    int getPort() {\n-        return serverSocket.getLocalPort();\n-    }\n-\n-    public void run() {\n-\n-        synchronized(checkError.threadStarting) {\n-\n-            try {\n-                serverSocket = new ServerSocket(0, 100);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                checkError.testStatus = checkError.TEST_FAILED;\n-                return;\n-            }\n-            checkError.threadStarting.notify();\n-        }\n-\n-        try {\n-            client = serverSocket.accept();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            checkError.testStatus = checkError.TEST_FAILED;\n-            return;\n-        }\n-\n-        System.out.println(\"Server started\");\n-\n-        BufferedReader in = null;\n-        PrintStream out = null;\n-        InputStreamReader reader = null;\n-        String version = null;\n-        String line;\n-        String method;\n-\n-        synchronized(checkError.threadWaiting) {\n-            try {\n-                reader = new InputStreamReader(client.getInputStream());\n-                in = new BufferedReader(reader);\n-                line = in.readLine();\n-\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                checkError.testStatus = checkError.TEST_FAILED;\n-                return;\n-            }\n-            StringTokenizer st = new StringTokenizer(line);\n-            method = st.nextToken();\n-            String fileName = st.nextToken();\n-\n-            \/\/ save version for replies\n-            if (st.hasMoreTokens()) version = st.nextToken();\n-\n-            System.out.println(\"HTTP version: \" + version);\n-\n-        }\n-\n-        try {\n-\n-            while (line != null && line.length() > 0) {\n-                line = in.readLine();\n-                System.out.println(line);\n-            }\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-            checkError.testStatus = checkError.TEST_FAILED;\n-            return;\n-        }\n-\n-        if (method.equals(\"POST\")) {\n-            System.out.println(\"receiving data\");\n-            byte[] buf = new byte[1024];\n-            try {\n-                \/\/reading bytes until chunk whose size is zero,\n-                \/\/ see 19.4.6 Introduction of Transfer-Encoding in RFC2616\n-                int count = 0;\n-                while (count <=5) {\n-                    count++;\n-                    in.readLine();\n-                }\n-\n-                System.out.println(\"Server socket is closed\");\n-                in.close();\n-                client.close();\n-                serverSocket.close();\n-\n-            } catch (IOException e) {\n-                e.printStackTrace();\n-                checkError.testStatus = checkError.TEST_FAILED;\n-                return;\n-            } catch (OutOfMemoryError e) {\n-                e.printStackTrace();\n-                checkError.testStatus = checkError.TEST_FAILED;\n-                return;\n-            }\n-\n-        }\n-    }\n-\n-}\n","filename":"jdk\/test\/sun\/net\/www\/http\/ChunkedOutputStream\/checkError.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"}]}