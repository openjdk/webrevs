{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,4 @@\n+    \/* A cache mapping code signers to the algorithms used to digest jar\n+       entries, and whether or not the algorithms are permitted. *\/\n+    private Map<CodeSigner[], Map<String, Boolean>> signersToAlgs;\n+\n@@ -108,0 +112,1 @@\n+        signersToAlgs = new HashMap<>();\n@@ -247,1 +252,2 @@\n-                je.signers = mev.verify(verifiedSigners, sigFileSigners);\n+                je.signers = mev.verify(verifiedSigners, sigFileSigners,\n+                                        signersToAlgs);\n","filename":"jdk\/src\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,1 +195,2 @@\n-                Hashtable<String, CodeSigner[]> sigFileSigners)\n+                Hashtable<String, CodeSigner[]> sigFileSigners,\n+                Map<CodeSigner[], Map<String, Boolean>> signersToAlgs)\n@@ -210,2 +211,7 @@\n-        JarConstraintsParameters params =\n-            getParams(verifiedSigners, sigFileSigners);\n+        CodeSigner[] entrySigners = sigFileSigners.get(name);\n+        Map<String, Boolean> algsPermittedStatus =\n+            algsPermittedStatusForSigners(signersToAlgs, entrySigners);\n+        \/\/ Flag that indicates if only disabled algorithms are used and jar\n+        \/\/ entry should be treated as unsigned.\n+        boolean disabledAlgs = true;\n+        JarConstraintsParameters params = null;\n@@ -215,9 +221,8 @@\n-            if (params != null) {\n-                try {\n-                    params.setExtendedExceptionMsg(JarFile.MANIFEST_NAME,\n-                        name + \" entry\");\n-                    DisabledAlgorithmConstraints.jarConstraints()\n-                           .permits(digest.getAlgorithm(), params, false);\n-                } catch (GeneralSecurityException e) {\n-                    if (debug != null) {\n-                        debug.println(\"Digest algorithm is restricted: \" + e);\n+            String digestAlg = digest.getAlgorithm();\n+\n+            \/\/ Check if this algorithm is permitted, skip if false.\n+            if (algsPermittedStatus != null) {\n+                Boolean permitted = algsPermittedStatus.get(digestAlg);\n+                if (permitted == null) {\n+                    if (params == null) {\n+                        params = new JarConstraintsParameters(entrySigners);\n@@ -225,1 +230,8 @@\n-                    return null;\n+                    if (!checkConstraints(digestAlg, params)) {\n+                        algsPermittedStatus.put(digestAlg, Boolean.FALSE);\n+                        continue;\n+                    } else {\n+                        algsPermittedStatus.put(digestAlg, Boolean.TRUE);\n+                    }\n+                } else if (!permitted) {\n+                    continue;\n@@ -228,0 +240,4 @@\n+\n+            \/\/ A non-disabled algorithm was used.\n+            disabledAlgs = false;\n+\n@@ -233,1 +249,1 @@\n-                                   name + \" digest=\" + digest.getAlgorithm());\n+                                   name + \" digest=\" + digestAlg);\n@@ -239,2 +255,2 @@\n-            if (!MessageDigest.isEqual(theHash, manHash))\n-                throw new SecurityException(digest.getAlgorithm()+\n+            if (!MessageDigest.isEqual(theHash, manHash)) {\n+                throw new SecurityException(digestAlg +\n@@ -242,0 +258,7 @@\n+            }\n+        }\n+\n+        \/\/ If there were only disabled algorithms used, return null and jar\n+        \/\/ entry will be treated as unsigned.\n+        if (disabledAlgs) {\n+            return null;\n@@ -252,22 +275,10 @@\n-    \/**\n-     * Get constraints parameters for JAR. The constraints should be\n-     * checked against all code signers. Returns the parameters,\n-     * or null if the signers for this entry have already been checked\n-     * or there are no signers for this entry.\n-     *\/\n-    private JarConstraintsParameters getParams(\n-            Map<String, CodeSigner[]> verifiedSigners,\n-            Map<String, CodeSigner[]> sigFileSigners) {\n-\n-        \/\/ verifiedSigners is usually preloaded with the Manifest's signers.\n-        \/\/ If verifiedSigners contains the Manifest, then it will have all of\n-        \/\/ the signers of the JAR. But if it doesn't then we need to fallback\n-        \/\/ and check verifiedSigners to see if the signers of this entry have\n-        \/\/ been checked already.\n-        if (verifiedSigners.containsKey(manifestFileName)) {\n-            if (verifiedSigners.size() > 1) {\n-                \/\/ this means we already checked it previously\n-                return null;\n-            } else {\n-                return new JarConstraintsParameters(\n-                    verifiedSigners.get(manifestFileName));\n+    \/\/ Gets the algorithms permitted status for the signers of this entry.\n+    private static Map<String, Boolean> algsPermittedStatusForSigners(\n+            Map<CodeSigner[], Map<String, Boolean>> signersToAlgs,\n+            CodeSigner[] signers) {\n+        if (signers != null) {\n+            Map<String, Boolean> algs = signersToAlgs.get(signers);\n+            \/\/ create new HashMap if absent\n+            if (algs == null) {\n+                algs = new HashMap<>();\n+                signersToAlgs.put(signers, algs);\n@@ -275,1 +286,15 @@\n-        } else {\n+            return algs;\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Checks the algorithm constraints against the signers of this entry.\n+    private boolean checkConstraints(String algorithm,\n+        JarConstraintsParameters params) {\n+        try {\n+            params.setExtendedExceptionMsg(JarFile.MANIFEST_NAME,\n+                name + \" entry\");\n+            DisabledAlgorithmConstraints.jarConstraints()\n+                   .permits(algorithm, params, false);\n+            return true;\n+        } catch (GeneralSecurityException e) {\n@@ -277,7 +302,1 @@\n-                debug.println(manifestFileName + \" not present in verifiedSigners\");\n-            }\n-            CodeSigner[] signers = sigFileSigners.get(name);\n-            if (signers == null || verifiedSigners.containsValue(signers)) {\n-                return null;\n-            } else {\n-                return new JarConstraintsParameters(signers);\n+                debug.println(\"Digest algorithm is restricted: \" + e);\n@@ -285,0 +304,1 @@\n+            return false;\n","filename":"jdk\/src\/share\/classes\/sun\/security\/util\/ManifestEntryVerifier.java","additions":67,"deletions":47,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278851\n+ * @summary Check that jar entry with at least one non-disabled digest\n+ *          algorithm in manifest is treated as signed\n+ * @library \/lib\/testlibrary \/lib\/security\n+ * @build jdk.testlibrary.JarUtils\n+ *        jdk.testlibrary.Utils\n+ * @run main\/othervm JarWithOneNonDisabledDigestAlg\n+ *\/\n+\n+import java.io.InputStream;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.security.CodeSigner;\n+import java.security.KeyStore;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.zip.ZipFile;\n+\n+import jdk.testlibrary.JarUtils;\n+\n+public class JarWithOneNonDisabledDigestAlg {\n+\n+    private static final String PASS = \"changeit\";\n+    private static final String TESTFILE1 = \"testfile1\";\n+    private static final String TESTFILE2 = \"testfile2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        SecurityUtils.removeFromDisabledAlgs(\"jdk.jar.disabledAlgorithms\",\n+            Arrays.asList(\"SHA1\"));\n+        Files.write(Paths.get(TESTFILE1), TESTFILE1.getBytes());\n+        JarUtils.createJarFile(Paths.get(\"unsigned.jar\"), Paths.get(\".\"),\n+            Paths.get(TESTFILE1));\n+\n+        genkeypair(\"-alias SHA1 -sigalg SHA1withRSA\");\n+        genkeypair(\"-alias SHA256 -sigalg SHA256withRSA\");\n+\n+        \/\/ Sign JAR twice with same signer but different digest algorithms\n+        \/\/ so that each entry in manifest file contains two digest values.\n+        signJarFile(\"SHA1\", \"MD5\", \"unsigned.jar\", \"signed.jar\");\n+        signJarFile(\"SHA1\", \"SHA1\", \"signed.jar\", \"signed2.jar\");\n+        checkThatJarIsSigned(\"signed2.jar\", false);\n+\n+        \/\/ add another file to the JAR\n+        Files.write(Paths.get(TESTFILE2), \"testFile2\".getBytes());\n+        JarUtils.updateJar(\"signed2.jar\", \"signed3.jar\", TESTFILE2);\n+        Files.move(Paths.get(\"signed3.jar\"), Paths.get(\"signed2.jar\"), StandardCopyOption.REPLACE_EXISTING);\n+\n+        \/\/ Sign again with different signer (SHA256) and SHA-1 digestalg.\n+        \/\/ TESTFILE1 should have two signers and TESTFILE2 should have one\n+        \/\/ signer.\n+        signJarFile(\"SHA256\", \"SHA1\", \"signed2.jar\", \"multi-signed.jar\");\n+\n+        checkThatJarIsSigned(\"multi-signed.jar\", true);\n+    }\n+\n+    private static KeyStore.PrivateKeyEntry getEntry(KeyStore ks, String alias)\n+        throws Exception {\n+\n+        return (KeyStore.PrivateKeyEntry)\n+            ks.getEntry(alias,\n+                new KeyStore.PasswordProtection(PASS.toCharArray()));\n+    }\n+\n+    private static void genkeypair(String cmd) throws Exception {\n+        cmd = \"-genkeypair -keystore keystore -storepass \" + PASS +\n+              \" -keypass \" + PASS + \" -keyalg rsa -dname CN=Duke \" + cmd;\n+        sun.security.tools.keytool.Main.main(cmd.split(\" \"));\n+    }\n+\n+    private static void signJarFile(String alias,\n+        String digestAlg, String inputFile, String outputFile)\n+        throws Exception {\n+\n+        \/\/ create a backup file as the signed file will be in-place\n+        Path from = Paths.get(inputFile);\n+        Path backup = Files.createTempFile(inputFile, \"jar\");\n+        Path output = Paths.get(outputFile);\n+\n+        Files.copy(from, backup, StandardCopyOption.REPLACE_EXISTING);\n+\n+        \/\/ sign the jar\n+        sun.security.tools.jarsigner.Main.main(\n+                (\"-keystore keystore -storepass \" + PASS +\n+                 \" -digestalg \" + digestAlg + \" \" + inputFile + \" \" +\n+                 alias).split(\" \"));\n+\n+        Files.copy(from, output, StandardCopyOption.REPLACE_EXISTING);\n+        Files.copy(backup, from, StandardCopyOption.REPLACE_EXISTING);\n+    }\n+\n+    private static void checkThatJarIsSigned(String jarFile, boolean multi)\n+        throws Exception {\n+\n+        try (JarFile jf = new JarFile(jarFile, true)) {\n+            Enumeration<JarEntry> entries = jf.entries();\n+            while (entries.hasMoreElements()) {\n+                JarEntry entry = entries.nextElement();\n+                if (entry.isDirectory() || isSigningRelated(entry.getName())) {\n+                    continue;\n+                }\n+                InputStream is = jf.getInputStream(entry);\n+                while (is.read() != -1);\n+                CodeSigner[] signers = entry.getCodeSigners();\n+                if (signers == null) {\n+                    throw new Exception(\"JarEntry \" + entry.getName() +\n+                        \" is not signed\");\n+                } else if (multi) {\n+                    if (entry.getName().equals(TESTFILE1) &&\n+                        signers.length != 2) {\n+                        throw new Exception(\"Unexpected number of signers \" +\n+                            \"for \" + entry.getName() + \": \" + signers.length);\n+                    } else if (entry.getName().equals(TESTFILE2) &&\n+                        signers.length != 1) {\n+                        throw new Exception(\"Unexpected number of signers \" +\n+                            \"for \" + entry.getName() + \": \" + signers.length);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isSigningRelated(String name) {\n+        name = name.toUpperCase(Locale.ENGLISH);\n+        if (!name.startsWith(\"META-INF\/\")) {\n+            return false;\n+        }\n+        name = name.substring(9);\n+        if (name.indexOf('\/') != -1) {\n+            return false;\n+        }\n+        return name.endsWith(\".SF\")\n+            || name.endsWith(\".DSA\")\n+            || name.endsWith(\".RSA\")\n+            || name.endsWith(\".EC\")\n+            || name.equals(\"MANIFEST.MF\");\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/tools\/jarsigner\/disdigest\/JarWithOneNonDisabledDigestAlg.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"}]}