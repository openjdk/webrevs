{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,1 +507,1 @@\n-        if (special1 || special2) {\n+        if (special1 && special2) {\n","filename":"jdk\/src\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolderManager2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8305072\n+ * @requires (os.family == \"windows\")\n+ * @summary Verifies consistency of Win32ShellFolder2.compareTo\n+ * @run main\/othervm Win32FolderSort\n+ *\/\n+public class Win32FolderSort {\n+    public static void main(String[] args) throws Exception {\n+        Class<?> folderManager = Class.forName(\"sun.awt.shell.Win32ShellFolderManager2\");\n+        Class<?> folder = Class.forName(\"sun.awt.shell.Win32ShellFolder2\");\n+\n+        Method getDesktop = folderManager.getDeclaredMethod(\"getDesktop\");\n+        getDesktop.setAccessible(true);\n+        Method getPersonal = folderManager.getDeclaredMethod(\"getPersonal\");\n+        getPersonal.setAccessible(true);\n+\n+        Method createShellFolder = folderManager.getDeclaredMethod(\"createShellFolder\", folder, File.class);\n+        createShellFolder.setAccessible(true);\n+\n+        Method isFileSystem = folder.getMethod(\"isFileSystem\");\n+        isFileSystem.setAccessible(true);\n+        Method isSpecial = folder.getMethod(\"isSpecial\");\n+        isSpecial.setAccessible(true);\n+        Method getChildByPath = folder.getDeclaredMethod(\"getChildByPath\", String.class);\n+        getChildByPath.setAccessible(true);\n+\n+        File desktop = (File) getDesktop.invoke(null);\n+        File personal = (File) getPersonal.invoke(null);\n+        if (!((Boolean) isSpecial.invoke(personal))) {\n+            throw new RuntimeException(\"personal is not special\");\n+        }\n+        File fakePersonal = (File) getChildByPath.invoke(desktop, personal.getPath());\n+        if (fakePersonal == null) {\n+            fakePersonal = (File) createShellFolder.invoke(null, desktop,\n+                                                           new File(personal.getPath()));\n+        }\n+        if ((Boolean) isSpecial.invoke(fakePersonal)) {\n+            throw new RuntimeException(\"fakePersonal is special\");\n+        }\n+        File homeDir = (File) createShellFolder.invoke(null, desktop,\n+                                                       new File(System.getProperty(\"user.home\")));\n+\n+        File[] files = {fakePersonal, personal, homeDir};\n+        for (File f : files) {\n+            if (!((Boolean) isFileSystem.invoke(f))) {\n+                throw new RuntimeException(f + \" is not on file system\");\n+            }\n+        }\n+\n+        List<String> errors = new ArrayList<>(2);\n+        for (File f1 : files) {\n+            for (File f2 : files) {\n+                for (File f3 : files) {\n+                    String result = verifyCompareTo(f1, f2, f3);\n+                    if (result != null) {\n+                        String error = result + \"\\nwhere\"\n+                                       + \"\\n  a = \" + formatFile(f1, isSpecial)\n+                                       + \"\\n  b = \" + formatFile(f2, isSpecial)\n+                                       + \"\\n  c = \" + formatFile(f3, isSpecial);\n+                        errors.add(error);\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+        System.out.println(\"Unsorted:\");\n+        for (File f : files) {\n+            System.out.println(formatFile(f, isSpecial));\n+        }\n+        System.out.println();\n+\n+        Arrays.sort(files);\n+        System.out.println(\"Sorted:\");\n+        for (File f : files) {\n+            System.out.println(formatFile(f, isSpecial));\n+        }\n+\n+\n+        if (!errors.isEmpty()) {\n+            System.err.println(\"Implementation of Win32ShellFolder2.compareTo is inconsistent:\");\n+            errors.forEach(System.err::println);\n+            throw new RuntimeException(\"Inconsistencies found: \" + errors.size()\n+                                       + \" - \" + errors.get(0));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies consistency of {@code Comparable} implementation.\n+     *\n+     * @param a the first object\n+     * @param b the second object\n+     * @param c the third object\n+     * @return error message if inconsistency is found,\n+     *         or {@code null } otherwise\n+     *\/\n+    private static String verifyCompareTo(File a, File b, File c) {\n+        \/\/ a < b & b < c => a < c\n+        if (a.compareTo(b) < 0 && b.compareTo(c) < 0) {\n+            if (a.compareTo(c) >= 0) {\n+                return \"a < b & b < c but a >= c\";\n+            }\n+        }\n+\n+        \/\/ a > b & b > c => a > c\n+        if (a.compareTo(b) > 0 && b.compareTo(c) > 0) {\n+            if (a.compareTo(c) <= 0) {\n+                return \"a > b & b > c but a <= c\";\n+            }\n+        }\n+\n+        \/\/ a = b & b = c => a = c\n+        if (a.compareTo(b) == 0 && b.compareTo(c) == 0) {\n+            if (a.compareTo(c) != 0) {\n+                return \"a = b & b = c but a != c\";\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private static String formatFile(File f, Method isSpecial)\n+            throws InvocationTargetException, IllegalAccessException {\n+        return f + \"(\" + isSpecial.invoke(f) + \")\";\n+    }\n+}\n","filename":"jdk\/test\/javax\/swing\/JFileChooser\/FileSystemView\/Win32FolderSort.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}