{"files":[{"patch":"@@ -1036,1 +1036,1 @@\n-## The FreeType Project: Freetype v2.10.0\n+## The FreeType Project: Freetype v2.10.1\n@@ -1571,0 +1571,103 @@\n+#########################################################################\n+\n+--- fthash.c and fthash.h are covered by the following notices ---\n+\n+\/*\n+ * Copyright 2000 Computing Research Labs, New Mexico State University\n+ * Copyright 2001-2015\n+ *   Francesco Zappa Nardelli\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a\n+ * copy of this software and associated documentation files (the \"Software\"),\n+ * to deal in the Software without restriction, including without limitation\n+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+ * and\/or sell copies of the Software, and to permit persons to whom the\n+ * Software is furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n+ * THE COMPUTING RESEARCH LAB OR NEW MEXICO STATE UNIVERSITY BE LIABLE FOR ANY\n+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+ * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ *\/\n+\n+  \/**************************************************************************\n+   *\n+   * This file is based on code from bdf.c,v 1.22 2000\/03\/16 20:08:50\n+   *\n+   * taken from Mark Leisher's xmbdfed package\n+   *\n+   *\/\n+   \n+--- FreeType 2 PSaux module is covered by the following notices ---\n+\n+Copyright 2006-2014 Adobe Systems Incorporated.\n+\n+This software, and all works of authorship, whether in source or\n+object code form as indicated by the copyright notice(s) included\n+herein (collectively, the \"Work\") is made available, and may only be\n+used, modified, and distributed under the FreeType Project License,\n+LICENSE.TXT.  Additionally, subject to the terms and conditions of the\n+FreeType Project License, each contributor to the Work hereby grants\n+to any individual or legal entity exercising permissions granted by\n+the FreeType Project License and this section (hereafter, \"You\" or\n+\"Your\") a perpetual, worldwide, non-exclusive, no-charge,\n+royalty-free, irrevocable (except as stated in this section) patent\n+license to make, have made, use, offer to sell, sell, import, and\n+otherwise transfer the Work, where such license applies only to those\n+patent claims licensable by such contributor that are necessarily\n+infringed by their contribution(s) alone or by combination of their\n+contribution(s) with the Work to which such contribution(s) was\n+submitted.  If You institute patent litigation against any entity\n+(including a cross-claim or counterclaim in a lawsuit) alleging that\n+the Work or a contribution incorporated within the Work constitutes\n+direct or contributory patent infringement, then any patent licenses\n+granted to You under this License for that Work shall terminate as of\n+the date such litigation is filed.\n+\n+By using, modifying, or distributing the Work you indicate that you\n+have read and understood the terms and conditions of the\n+FreeType Project License as well as those provided in this section,\n+and you accept them fully.\n+\n+#########################################################################\n+\n+\n+--- FreeType 2 PSaux module is covered by the following notices ---\n+\n+Copyright 2006-2014 Adobe Systems Incorporated.\n+\n+This software, and all works of authorship, whether in source or\n+object code form as indicated by the copyright notice(s) included\n+herein (collectively, the \"Work\") is made available, and may only be\n+used, modified, and distributed under the FreeType Project License,\n+LICENSE.TXT.  Additionally, subject to the terms and conditions of the\n+FreeType Project License, each contributor to the Work hereby grants\n+to any individual or legal entity exercising permissions granted by\n+the FreeType Project License and this section (hereafter, \"You\" or\n+\"Your\") a perpetual, worldwide, non-exclusive, no-charge,\n+royalty-free, irrevocable (except as stated in this section) patent\n+license to make, have made, use, offer to sell, sell, import, and\n+otherwise transfer the Work, where such license applies only to those\n+patent claims licensable by such contributor that are necessarily\n+infringed by their contribution(s) alone or by combination of their\n+contribution(s) with the Work to which such contribution(s) was\n+submitted.  If You institute patent litigation against any entity\n+(including a cross-claim or counterclaim in a lawsuit) alleging that\n+the Work or a contribution incorporated within the Work constitutes\n+direct or contributory patent infringement, then any patent licenses\n+granted to You under this License for that Work shall terminate as of\n+the date such litigation is filed.\n+\n+By using, modifying, or distributing the Work you indicate that you\n+have read and understood the terms and conditions of the\n+FreeType Project License as well as those provided in this section,\n+and you accept them fully.\n+\n+#########################################################################\n+\n","filename":"THIRD_PARTY_README","additions":104,"deletions":1,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-   *     'https:\/\/www.microsoft.com\/typography\/otspec\/recom.htm',\n+   *     'https:\/\/www.microsoft.com\/typography\/otspec\/recom.htm#non-standard-symbol-fonts',\n@@ -1769,0 +1769,7 @@\n+   *     [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of\n+   *     OpenType variation fonts for a selected instance are internally\n+   *     handled as 26.6 fractional font units but returned as (rounded)\n+   *     integers, as expected.  To get unrounded font units, don't use\n+   *     @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and\n+   *     scale it, using the font's `units_per_EM` value as the ppem.\n+   *\n@@ -3935,2 +3942,2 @@\n-  FT_Get_Name_Index( FT_Face     face,\n-                     FT_String*  glyph_name );\n+  FT_Get_Name_Index( FT_Face           face,\n+                     const FT_String*  glyph_name );\n@@ -4777,1 +4784,1 @@\n-#define FREETYPE_PATCH  0\n+#define FREETYPE_PATCH  1\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/freetype.h","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -247,0 +247,2 @@\n+FT_BEGIN_HEADER\n+\n@@ -277,0 +279,2 @@\n+FT_END_HEADER\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/fterrors.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-   *   was used in @FT_Load_Glyph() or @FT_Load_Char().\n+   *   was used in @FT_Load_Glyph or @FT_Load_Char.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftglyph.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-   *     The scanline's y~coordinate.\n+   *     The scanline's upward y~coordinate.\n@@ -948,2 +948,2 @@\n-   *     not set, the target pixmap's buffer _must_ be zeroed before\n-   *     rendering.\n+   *     _not_ set, the target pixmap's buffer _must_ be zeroed before\n+   *     rendering and the output will be clipped to its size.\n@@ -956,5 +956,2 @@\n-   *     @FT_Raster_Params structure.\n-   *\n-   *     Note that by default, the glyph bitmap is clipped to the target\n-   *     pixmap, except in direct rendering mode where all spans are\n-   *     generated if no clipping box is set.\n+   *     @FT_Raster_Params structure.  Otherwise, the `clip_box` is\n+   *     effectively set to the bounding box and all spans are generated.\n@@ -981,1 +978,2 @@\n-   *   A structure to hold the arguments used by a raster's render function.\n+   *   A structure to hold the parameters used by a raster's render function,\n+   *   passed as an argument to @FT_Outline_Render.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftimage.h","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -626,1 +626,1 @@\n-  typedef void\n+  typedef FT_Error\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftmodapi.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -469,2 +469,0 @@\n-   *   This function uses an @FT_Raster_Params structure as an argument,\n-   *   allowing advanced features like direct composition, translucency, etc.\n@@ -488,2 +486,4 @@\n-   *   You should know what you are doing and how @FT_Raster_Params works to\n-   *   use this function.\n+   *   This advanced function uses @FT_Raster_Params as an argument,\n+   *   allowing FreeType rasterizer to be used for direct composition,\n+   *   translucency, etc.  You should know how to set up @FT_Raster_Params\n+   *   for this function to work.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftoutln.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -381,0 +381,1 @@\n+#pragma intrinsic( _BitScanReverse )\n@@ -388,1 +389,0 @@\n-    \/* not available in older VC versions *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftcalc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,0 @@\n-                                            FT_Render_Mode  render_mode,\n@@ -288,1 +287,0 @@\n-                     FT_Render_Mode       mode,\n@@ -944,2 +942,2 @@\n-  (*FT_Face_GetGlyphNameIndexFunc)( FT_Face     face,\n-                                    FT_String*  glyph_name );\n+  (*FT_Face_GetGlyphNameIndexFunc)( FT_Face           face,\n+                                    const FT_String*  glyph_name );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftobjs.h","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -168,0 +168,11 @@\n+  \/*\n+   *    function      acts on      increases  does range   for    emits\n+   *                                pointer    checking   frames  error\n+   *  -------------------------------------------------------------------\n+   *   FT_PEEK_XXX  buffer pointer      no         no        no     no\n+   *   FT_NEXT_XXX  buffer pointer     yes         no        no     no\n+   *   FT_GET_XXX   stream->cursor     yes        yes       yes     no\n+   *   FT_READ_XXX  stream->pos        yes        yes        no    yes\n+   *\/\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftstream.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+FT_TRACE_DEF( sfwoff )    \/* WOFF format handler     (sfwoff.c)   *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/fttrace.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#define FT_INTERNAL_WOFF_TYPES_H          <freetype\/internal\/wofftypes.h>\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/internal.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,4 +99,4 @@\n-    (*add)( PS_Table  table,\n-            FT_Int    idx,\n-            void*     object,\n-            FT_UInt   length );\n+    (*add)( PS_Table     table,\n+            FT_Int       idx,\n+            const void*  object,\n+            FT_UInt      length );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/psaux.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-  (*FT_GlyphDict_NameIndexFunc)( FT_Face     face,\n-                                 FT_String*  glyph_name );\n+  (*FT_GlyphDict_NameIndexFunc)( FT_Face           face,\n+                                 const FT_String*  glyph_name );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svgldict.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include FT_INTERNAL_WOFF_TYPES_H\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/sfnt.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-    FT_UShort*   char_index;\n-    FT_String**  char_name;\n+    FT_UShort*         char_index;\n+    const FT_String**  char_name;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/t1types.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,75 +153,0 @@\n-  \/**************************************************************************\n-   *\n-   * @struct:\n-   *   WOFF_HeaderRec\n-   *\n-   * @description:\n-   *   WOFF file format header.\n-   *\n-   * @fields:\n-   *   See\n-   *\n-   *     https:\/\/www.w3.org\/TR\/WOFF\/#WOFFHeader\n-   *\/\n-  typedef struct  WOFF_HeaderRec_\n-  {\n-    FT_ULong   signature;\n-    FT_ULong   flavor;\n-    FT_ULong   length;\n-    FT_UShort  num_tables;\n-    FT_UShort  reserved;\n-    FT_ULong   totalSfntSize;\n-    FT_UShort  majorVersion;\n-    FT_UShort  minorVersion;\n-    FT_ULong   metaOffset;\n-    FT_ULong   metaLength;\n-    FT_ULong   metaOrigLength;\n-    FT_ULong   privOffset;\n-    FT_ULong   privLength;\n-\n-  } WOFF_HeaderRec, *WOFF_Header;\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @struct:\n-   *   WOFF_TableRec\n-   *\n-   * @description:\n-   *   This structure describes a given table of a WOFF font.\n-   *\n-   * @fields:\n-   *   Tag ::\n-   *     A four-bytes tag describing the table.\n-   *\n-   *   Offset ::\n-   *     The offset of the table from the start of the WOFF font in its\n-   *     resource.\n-   *\n-   *   CompLength ::\n-   *     Compressed table length (in bytes).\n-   *\n-   *   OrigLength ::\n-   *     Uncompressed table length (in bytes).\n-   *\n-   *   CheckSum ::\n-   *     The table checksum.  This value can be ignored.\n-   *\n-   *   OrigOffset ::\n-   *     The uncompressed table file offset.  This value gets computed while\n-   *     constructing the (uncompressed) SFNT header.  It is not contained in\n-   *     the WOFF file.\n-   *\/\n-  typedef struct  WOFF_TableRec_\n-  {\n-    FT_ULong  Tag;           \/* table ID                  *\/\n-    FT_ULong  Offset;        \/* table file offset         *\/\n-    FT_ULong  CompLength;    \/* compressed table length   *\/\n-    FT_ULong  OrigLength;    \/* uncompressed table length *\/\n-    FT_ULong  CheckSum;      \/* uncompressed checksum     *\/\n-\n-    FT_ULong  OrigOffset;    \/* uncompressed table file offset *\/\n-                             \/* (not in the WOFF file)         *\/\n-  } WOFF_TableRec, *WOFF_Table;\n-\n-\n@@ -1398,2 +1323,4 @@\n-   *     in unscaled font units.  Comes from the 'cvt~' table.  Ignored for\n-   *     Type 2 fonts.\n+   *     in unscaled font units (in 26.6 format).  Comes from the 'cvt~'\n+   *     table.  Ignored for Type 2 fonts.\n+   *\n+   *     If varied by the `CVAR' table, non-integer values are possible.\n@@ -1636,1 +1563,1 @@\n-    FT_Short*             cvt;\n+    FT_Int32*             cvt;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/tttypes.h","additions":5,"deletions":78,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/****************************************************************************\n+ *\n+ * wofftypes.h\n+ *\n+ *   Basic WOFF\/WOFF2 type definitions and interface (specification\n+ *   only).\n+ *\n+ * Copyright (C) 1996-2019 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef WOFFTYPES_H_\n+#define WOFFTYPES_H_\n+\n+\n+#include <ft2build.h>\n+#include FT_TRUETYPE_TABLES_H\n+#include FT_INTERNAL_OBJECTS_H\n+\n+\n+FT_BEGIN_HEADER\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   WOFF_HeaderRec\n+   *\n+   * @description:\n+   *   WOFF file format header.\n+   *\n+   * @fields:\n+   *   See\n+   *\n+   *     https:\/\/www.w3.org\/TR\/WOFF\/#WOFFHeader\n+   *\/\n+  typedef struct  WOFF_HeaderRec_\n+  {\n+    FT_ULong   signature;\n+    FT_ULong   flavor;\n+    FT_ULong   length;\n+    FT_UShort  num_tables;\n+    FT_UShort  reserved;\n+    FT_ULong   totalSfntSize;\n+    FT_UShort  majorVersion;\n+    FT_UShort  minorVersion;\n+    FT_ULong   metaOffset;\n+    FT_ULong   metaLength;\n+    FT_ULong   metaOrigLength;\n+    FT_ULong   privOffset;\n+    FT_ULong   privLength;\n+\n+  } WOFF_HeaderRec, *WOFF_Header;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   WOFF_TableRec\n+   *\n+   * @description:\n+   *   This structure describes a given table of a WOFF font.\n+   *\n+   * @fields:\n+   *   Tag ::\n+   *     A four-bytes tag describing the table.\n+   *\n+   *   Offset ::\n+   *     The offset of the table from the start of the WOFF font in its\n+   *     resource.\n+   *\n+   *   CompLength ::\n+   *     Compressed table length (in bytes).\n+   *\n+   *   OrigLength ::\n+   *     Uncompressed table length (in bytes).\n+   *\n+   *   CheckSum ::\n+   *     The table checksum.  This value can be ignored.\n+   *\n+   *   OrigOffset ::\n+   *     The uncompressed table file offset.  This value gets computed while\n+   *     constructing the (uncompressed) SFNT header.  It is not contained in\n+   *     the WOFF file.\n+   *\/\n+  typedef struct  WOFF_TableRec_\n+  {\n+    FT_ULong  Tag;           \/* table ID                  *\/\n+    FT_ULong  Offset;        \/* table file offset         *\/\n+    FT_ULong  CompLength;    \/* compressed table length   *\/\n+    FT_ULong  OrigLength;    \/* uncompressed table length *\/\n+    FT_ULong  CheckSum;      \/* uncompressed checksum     *\/\n+\n+    FT_ULong  OrigOffset;    \/* uncompressed table file offset *\/\n+                             \/* (not in the WOFF file)         *\/\n+  } WOFF_TableRec, *WOFF_Table;\n+\n+\n+FT_END_HEADER\n+\n+#endif \/* WOFFTYPES_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/wofftypes.h","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -299,0 +299,4 @@\n+    '\\xE1', '\\xA0', '\\xB3', ' ', '\\xE1', '\\xA0', '\\xB4', ' ', '\\xE1', '\\xA0', '\\xB6', ' ', '\\xE1', '\\xA0', '\\xBD', ' ', '\\xE1', '\\xA1', '\\x82', ' ', '\\xE1', '\\xA1', '\\x8A', ' ', '\\xE2', '\\x80', '\\x8D', '\\xE1', '\\xA1', '\\xA1', '\\xE2', '\\x80', '\\x8D', ' ', '\\xE2', '\\x80', '\\x8D', '\\xE1', '\\xA1', '\\xB3', '\\xE2', '\\x80', '\\x8D',  \/* ᠳ ᠴ ᠶ ᠽ ᡂ ᡊ ‍ᡡ‍ ‍ᡳ‍ *\/\n+    '\\0',\n+    '\\xE1', '\\xA1', '\\x83',  \/* ᡃ *\/\n+    '\\0',\n@@ -652,0 +656,3 @@\n+    { AF_BLUE_STRING_MONGOLIAN_TOP_BASE,    AF_BLUE_PROPERTY_LATIN_TOP },\n+    { AF_BLUE_STRING_MONGOLIAN_BOTTOM_BASE, 0                          },\n+    { AF_BLUE_STRING_MAX,                   0                          },\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -395,0 +395,5 @@\n+  AF_BLUE_STRING_MONGOLIAN_TOP_BASE\n+    \"ᠳ ᠴ ᠶ ᠽ ᡂ ᡊ ‍ᡡ‍ ‍ᡳ‍\"\n+  AF_BLUE_STRING_MONGOLIAN_BOTTOM_BASE\n+    \"ᡃ\"\n+\n@@ -950,0 +955,5 @@\n+  AF_BLUE_STRINGSET_MONG\n+    { AF_BLUE_STRING_MONGOLIAN_TOP_BASE,    AF_BLUE_PROPERTY_LATIN_TOP }\n+    { AF_BLUE_STRING_MONGOLIAN_BOTTOM_BASE, 0                          }\n+    { AF_BLUE_STRING_MAX,                   0                          }\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.dat","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -215,50 +215,52 @@\n-    AF_BLUE_STRING_MYANMAR_TOP = 3614,\n-    AF_BLUE_STRING_MYANMAR_BOTTOM = 3646,\n-    AF_BLUE_STRING_MYANMAR_ASCENDER = 3678,\n-    AF_BLUE_STRING_MYANMAR_DESCENDER = 3706,\n-    AF_BLUE_STRING_NKO_TOP = 3738,\n-    AF_BLUE_STRING_NKO_BOTTOM = 3762,\n-    AF_BLUE_STRING_NKO_SMALL_TOP = 3777,\n-    AF_BLUE_STRING_NKO_SMALL_BOTTOM = 3786,\n-    AF_BLUE_STRING_OL_CHIKI = 3798,\n-    AF_BLUE_STRING_OLD_TURKIC_TOP = 3822,\n-    AF_BLUE_STRING_OLD_TURKIC_BOTTOM = 3837,\n-    AF_BLUE_STRING_OSAGE_CAPITAL_TOP = 3857,\n-    AF_BLUE_STRING_OSAGE_CAPITAL_BOTTOM = 3897,\n-    AF_BLUE_STRING_OSAGE_CAPITAL_DESCENDER = 3927,\n-    AF_BLUE_STRING_OSAGE_SMALL_TOP = 3942,\n-    AF_BLUE_STRING_OSAGE_SMALL_BOTTOM = 3982,\n-    AF_BLUE_STRING_OSAGE_SMALL_ASCENDER = 4022,\n-    AF_BLUE_STRING_OSAGE_SMALL_DESCENDER = 4047,\n-    AF_BLUE_STRING_OSMANYA_TOP = 4062,\n-    AF_BLUE_STRING_OSMANYA_BOTTOM = 4102,\n-    AF_BLUE_STRING_SAURASHTRA_TOP = 4142,\n-    AF_BLUE_STRING_SAURASHTRA_BOTTOM = 4174,\n-    AF_BLUE_STRING_SHAVIAN_TOP = 4194,\n-    AF_BLUE_STRING_SHAVIAN_BOTTOM = 4204,\n-    AF_BLUE_STRING_SHAVIAN_DESCENDER = 4229,\n-    AF_BLUE_STRING_SHAVIAN_SMALL_TOP = 4239,\n-    AF_BLUE_STRING_SHAVIAN_SMALL_BOTTOM = 4274,\n-    AF_BLUE_STRING_SINHALA_TOP = 4289,\n-    AF_BLUE_STRING_SINHALA_BOTTOM = 4321,\n-    AF_BLUE_STRING_SINHALA_DESCENDER = 4353,\n-    AF_BLUE_STRING_SUNDANESE_TOP = 4397,\n-    AF_BLUE_STRING_SUNDANESE_BOTTOM = 4421,\n-    AF_BLUE_STRING_SUNDANESE_DESCENDER = 4453,\n-    AF_BLUE_STRING_TAI_VIET_TOP = 4461,\n-    AF_BLUE_STRING_TAI_VIET_BOTTOM = 4481,\n-    AF_BLUE_STRING_TAMIL_TOP = 4493,\n-    AF_BLUE_STRING_TAMIL_BOTTOM = 4525,\n-    AF_BLUE_STRING_TELUGU_TOP = 4557,\n-    AF_BLUE_STRING_TELUGU_BOTTOM = 4585,\n-    AF_BLUE_STRING_THAI_TOP = 4613,\n-    AF_BLUE_STRING_THAI_BOTTOM = 4637,\n-    AF_BLUE_STRING_THAI_ASCENDER = 4665,\n-    AF_BLUE_STRING_THAI_LARGE_ASCENDER = 4677,\n-    AF_BLUE_STRING_THAI_DESCENDER = 4689,\n-    AF_BLUE_STRING_THAI_LARGE_DESCENDER = 4705,\n-    AF_BLUE_STRING_THAI_DIGIT_TOP = 4713,\n-    AF_BLUE_STRING_TIFINAGH = 4725,\n-    AF_BLUE_STRING_VAI_TOP = 4757,\n-    AF_BLUE_STRING_VAI_BOTTOM = 4789,\n-    af_blue_1_1 = 4820,\n+    AF_BLUE_STRING_MONGOLIAN_TOP_BASE = 3614,\n+    AF_BLUE_STRING_MONGOLIAN_BOTTOM_BASE = 3658,\n+    AF_BLUE_STRING_MYANMAR_TOP = 3662,\n+    AF_BLUE_STRING_MYANMAR_BOTTOM = 3694,\n+    AF_BLUE_STRING_MYANMAR_ASCENDER = 3726,\n+    AF_BLUE_STRING_MYANMAR_DESCENDER = 3754,\n+    AF_BLUE_STRING_NKO_TOP = 3786,\n+    AF_BLUE_STRING_NKO_BOTTOM = 3810,\n+    AF_BLUE_STRING_NKO_SMALL_TOP = 3825,\n+    AF_BLUE_STRING_NKO_SMALL_BOTTOM = 3834,\n+    AF_BLUE_STRING_OL_CHIKI = 3846,\n+    AF_BLUE_STRING_OLD_TURKIC_TOP = 3870,\n+    AF_BLUE_STRING_OLD_TURKIC_BOTTOM = 3885,\n+    AF_BLUE_STRING_OSAGE_CAPITAL_TOP = 3905,\n+    AF_BLUE_STRING_OSAGE_CAPITAL_BOTTOM = 3945,\n+    AF_BLUE_STRING_OSAGE_CAPITAL_DESCENDER = 3975,\n+    AF_BLUE_STRING_OSAGE_SMALL_TOP = 3990,\n+    AF_BLUE_STRING_OSAGE_SMALL_BOTTOM = 4030,\n+    AF_BLUE_STRING_OSAGE_SMALL_ASCENDER = 4070,\n+    AF_BLUE_STRING_OSAGE_SMALL_DESCENDER = 4095,\n+    AF_BLUE_STRING_OSMANYA_TOP = 4110,\n+    AF_BLUE_STRING_OSMANYA_BOTTOM = 4150,\n+    AF_BLUE_STRING_SAURASHTRA_TOP = 4190,\n+    AF_BLUE_STRING_SAURASHTRA_BOTTOM = 4222,\n+    AF_BLUE_STRING_SHAVIAN_TOP = 4242,\n+    AF_BLUE_STRING_SHAVIAN_BOTTOM = 4252,\n+    AF_BLUE_STRING_SHAVIAN_DESCENDER = 4277,\n+    AF_BLUE_STRING_SHAVIAN_SMALL_TOP = 4287,\n+    AF_BLUE_STRING_SHAVIAN_SMALL_BOTTOM = 4322,\n+    AF_BLUE_STRING_SINHALA_TOP = 4337,\n+    AF_BLUE_STRING_SINHALA_BOTTOM = 4369,\n+    AF_BLUE_STRING_SINHALA_DESCENDER = 4401,\n+    AF_BLUE_STRING_SUNDANESE_TOP = 4445,\n+    AF_BLUE_STRING_SUNDANESE_BOTTOM = 4469,\n+    AF_BLUE_STRING_SUNDANESE_DESCENDER = 4501,\n+    AF_BLUE_STRING_TAI_VIET_TOP = 4509,\n+    AF_BLUE_STRING_TAI_VIET_BOTTOM = 4529,\n+    AF_BLUE_STRING_TAMIL_TOP = 4541,\n+    AF_BLUE_STRING_TAMIL_BOTTOM = 4573,\n+    AF_BLUE_STRING_TELUGU_TOP = 4605,\n+    AF_BLUE_STRING_TELUGU_BOTTOM = 4633,\n+    AF_BLUE_STRING_THAI_TOP = 4661,\n+    AF_BLUE_STRING_THAI_BOTTOM = 4685,\n+    AF_BLUE_STRING_THAI_ASCENDER = 4713,\n+    AF_BLUE_STRING_THAI_LARGE_ASCENDER = 4725,\n+    AF_BLUE_STRING_THAI_DESCENDER = 4737,\n+    AF_BLUE_STRING_THAI_LARGE_DESCENDER = 4753,\n+    AF_BLUE_STRING_THAI_DIGIT_TOP = 4761,\n+    AF_BLUE_STRING_TIFINAGH = 4773,\n+    AF_BLUE_STRING_VAI_TOP = 4805,\n+    AF_BLUE_STRING_VAI_BOTTOM = 4837,\n+    af_blue_1_1 = 4868,\n@@ -358,18 +360,19 @@\n-    AF_BLUE_STRINGSET_MYMR = 179,\n-    AF_BLUE_STRINGSET_NKOO = 184,\n-    AF_BLUE_STRINGSET_NONE = 189,\n-    AF_BLUE_STRINGSET_OLCK = 190,\n-    AF_BLUE_STRINGSET_ORKH = 193,\n-    AF_BLUE_STRINGSET_OSGE = 196,\n-    AF_BLUE_STRINGSET_OSMA = 204,\n-    AF_BLUE_STRINGSET_SAUR = 207,\n-    AF_BLUE_STRINGSET_SHAW = 210,\n-    AF_BLUE_STRINGSET_SINH = 216,\n-    AF_BLUE_STRINGSET_SUND = 220,\n-    AF_BLUE_STRINGSET_TAML = 224,\n-    AF_BLUE_STRINGSET_TAVT = 227,\n-    AF_BLUE_STRINGSET_TELU = 230,\n-    AF_BLUE_STRINGSET_TFNG = 233,\n-    AF_BLUE_STRINGSET_THAI = 236,\n-    AF_BLUE_STRINGSET_VAII = 244,\n-    af_blue_2_1 = 247,\n+    AF_BLUE_STRINGSET_MONG = 179,\n+    AF_BLUE_STRINGSET_MYMR = 182,\n+    AF_BLUE_STRINGSET_NKOO = 187,\n+    AF_BLUE_STRINGSET_NONE = 192,\n+    AF_BLUE_STRINGSET_OLCK = 193,\n+    AF_BLUE_STRINGSET_ORKH = 196,\n+    AF_BLUE_STRINGSET_OSGE = 199,\n+    AF_BLUE_STRINGSET_OSMA = 207,\n+    AF_BLUE_STRINGSET_SAUR = 210,\n+    AF_BLUE_STRINGSET_SHAW = 213,\n+    AF_BLUE_STRINGSET_SINH = 219,\n+    AF_BLUE_STRINGSET_SUND = 223,\n+    AF_BLUE_STRINGSET_TAML = 227,\n+    AF_BLUE_STRINGSET_TAVT = 230,\n+    AF_BLUE_STRINGSET_TELU = 233,\n+    AF_BLUE_STRINGSET_TFNG = 236,\n+    AF_BLUE_STRINGSET_THAI = 239,\n+    AF_BLUE_STRINGSET_VAII = 247,\n+    af_blue_2_1 = 250,\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.h","additions":71,"deletions":68,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -1187,0 +1187,2 @@\n+        if ( !seg )\n+          goto Skip_Loop;\n@@ -1242,1 +1244,1 @@\n-              edge->link  = edge2;\n+              edge->link = edge2;\n@@ -1249,0 +1251,1 @@\n+      Skip_Loop:\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afcjk.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -446,0 +446,1 @@\n+  Again:\n@@ -473,0 +474,10 @@\n+\n+          \/* internal error code -1 indicates   *\/\n+          \/* that no blue zones have been found *\/\n+          if ( error == -1 )\n+          {\n+            style = (AF_Style)( globals->glyph_styles[gindex] &\n+                                AF_STYLE_UNASSIGNED           );\n+            goto Again;\n+          }\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afglobal.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -152,0 +152,3 @@\n+      {\n+        FT_TRACE5(( \"standard character missing;\"\n+                    \" using fallback stem widths\\n\" ));\n@@ -153,0 +156,1 @@\n+      }\n@@ -315,1 +319,1 @@\n-  static void\n+  static int\n@@ -984,2 +988,0 @@\n-    \/* we finally check whether blue zones are ordered; *\/\n-    \/* `ref' and `shoot' values of two blue zones must not overlap *\/\n@@ -988,0 +990,3 @@\n+      \/* we finally check whether blue zones are ordered;            *\/\n+      \/* `ref' and `shoot' values of two blue zones must not overlap *\/\n+\n@@ -1036,0 +1041,4 @@\n+\n+      FT_TRACE5(( \"\\n\" ));\n+\n+      return 0;\n@@ -1037,0 +1046,8 @@\n+    else\n+    {\n+      \/* disable hinting for the current style if there are no blue zones *\/\n+\n+      AF_FaceGlobals  globals = metrics->root.globals;\n+      FT_UShort*      gstyles = globals->glyph_styles;\n+\n+      FT_Long  i;\n@@ -1038,1 +1055,0 @@\n-    FT_TRACE5(( \"\\n\" ));\n@@ -1040,1 +1056,13 @@\n-    return;\n+      FT_TRACE5(( \"no blue zones found:\"\n+                  \" hinting disabled for this style\\n\" ));\n+\n+      for ( i = 0; i < globals->glyph_count; i++ )\n+      {\n+        if ( ( gstyles[i] & AF_STYLE_MASK ) == sc->style )\n+          gstyles[i] = AF_STYLE_NONE_DFLT;\n+      }\n+\n+      FT_TRACE5(( \"\\n\" ));\n+\n+      return 1;\n+    }\n@@ -1119,0 +1147,2 @@\n+    FT_Error  error = FT_Err_Ok;\n+\n@@ -1127,1 +1157,6 @@\n-      af_latin_metrics_init_blues( metrics, face );\n+      if ( af_latin_metrics_init_blues( metrics, face ) )\n+      {\n+        \/* use internal error code to indicate missing blue zones *\/\n+        error = -1;\n+        goto Exit;\n+      }\n@@ -1131,0 +1166,1 @@\n+  Exit:\n@@ -1132,1 +1168,1 @@\n-    return FT_Err_Ok;\n+    return error;\n@@ -1446,2 +1482,2 @@\n-                    blue->flags & AF_LATIN_BLUE_ACTIVE ? \"\"\n-                                                       : \" (inactive)\",\n+                    ( blue->flags & AF_LATIN_BLUE_ACTIVE ) ? \"\"\n+                                                           : \" (inactive)\",\n@@ -1451,2 +1487,2 @@\n-                    blue->flags & AF_LATIN_BLUE_ACTIVE ? \"\"\n-                                                       : \" (inactive)\" ));\n+                    ( blue->flags & AF_LATIN_BLUE_ACTIVE ) ? \"\"\n+                                                           : \" (inactive)\" ));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/aflatin.c","additions":47,"deletions":11,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -667,0 +667,15 @@\n+  const AF_Script_UniRangeRec  af_mong_uniranges[] =\n+  {\n+    AF_UNIRANGE_REC(  0x1800,  0x18AF ),  \/* Mongolian            *\/\n+    AF_UNIRANGE_REC( 0x11660, 0x1167F ),  \/* Mongolian Supplement *\/\n+    AF_UNIRANGE_REC(       0,       0 )\n+  };\n+\n+  const AF_Script_UniRangeRec  af_mong_nonbase_uniranges[] =\n+  {\n+    AF_UNIRANGE_REC(  0x1885,  0x1886 ),\n+    AF_UNIRANGE_REC(  0x18A9,  0x18A9 ),\n+    AF_UNIRANGE_REC(       0,       0 )\n+  };\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afranges.c","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -246,0 +246,6 @@\n+  SCRIPT( mong, MONG,\n+          \"Mongolian\",\n+          HB_SCRIPT_MONGOLIAN,\n+          HINTING_TOP_TO_BOTTOM,\n+          \"\\xE1\\xA1\\x82 \\xE1\\xA0\\xAA\" ) \/* ᡂ ᠪ *\/\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afscript.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -325,0 +325,7 @@\n+  STYLE( mong_dflt, MONG_DFLT,\n+         \"Mongolian default style\",\n+         AF_WRITING_SYSTEM_LATIN,\n+         AF_SCRIPT_MONG,\n+         AF_BLUE_STRINGSET_MONG,\n+         AF_COVERAGE_DEFAULT )\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afstyles.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -322,3 +322,3 @@\n-        q4 = ( q4 + q3 ) \/ 8;\n-        q3 = q3 \/ 4;\n-        q2 = q2 \/ 2;\n+        q4 = ( q4 + q3 ) >> 3;\n+        q3 = q3 >> 2;\n+        q2 = q2 >> 1;\n@@ -333,3 +333,3 @@\n-        q1 = ( q1 + q2 ) \/ 8;\n-        q2 = q2 \/ 4;\n-        q3 = q3 \/ 2;\n+        q1 = ( q1 + q2 ) >> 3;\n+        q2 = q2 >> 2;\n+        q3 = q3 >> 1;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftbbox.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -925,4 +925,7 @@\n-    FT_TRACE5(( \"  final bitmap: (%d, %d) -- (%d, %d); %d x %d\\n\",\n-      final_llx \/ 64, final_lly \/ 64,\n-      final_urx \/ 64, final_ury \/ 64,\n-      final_width, final_rows ));\n+    if ( final_width && final_rows )\n+      FT_TRACE5(( \"  final bitmap: (%d, %d) -- (%d, %d); %d x %d\\n\",\n+        final_llx \/ 64, final_lly \/ 64,\n+        final_urx \/ 64, final_ury \/ 64,\n+        final_width, final_rows ));\n+    else\n+      FT_TRACE5(( \"  final bitmap: empty\\n\" ));\n@@ -931,0 +934,3 @@\n+    if ( !( final_width && final_rows ) )\n+      return FT_Err_Ok;               \/* nothing to do *\/\n+\n@@ -974,0 +980,1 @@\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftbitmap.c","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -179,0 +179,3 @@\n+\n+      if ( !*p )\n+        break;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftinit.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-                     FT_Render_Mode       mode,\n@@ -87,0 +86,1 @@\n+    FT_Byte   mode   = bitmap->pixel_mode;\n@@ -94,1 +94,1 @@\n-    if ( mode == FT_RENDER_MODE_LCD && width >= 2 )\n+    if ( mode == FT_PIXEL_MODE_LCD && width >= 2 )\n@@ -137,1 +137,1 @@\n-    else if ( mode == FT_RENDER_MODE_LCD_V && height >= 2 )\n+    else if ( mode == FT_PIXEL_MODE_LCD_V && height >= 2 )\n@@ -186,1 +186,0 @@\n-                         FT_Render_Mode  mode,\n@@ -193,0 +192,1 @@\n+    FT_Byte   mode   = bitmap->pixel_mode;\n@@ -209,1 +209,1 @@\n-    if ( mode == FT_RENDER_MODE_LCD && width >= 3 )\n+    if ( mode == FT_PIXEL_MODE_LCD && width >= 3 )\n@@ -246,1 +246,1 @@\n-    else if ( mode == FT_RENDER_MODE_LCD_V && height >= 3 )\n+    else if ( mode == FT_PIXEL_MODE_LCD_V && height >= 3 )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftlcdfil.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4062,2 +4062,2 @@\n-  FT_Get_Name_Index( FT_Face     face,\n-                     FT_String*  glyph_name )\n+  FT_Get_Name_Index( FT_Face           face,\n+                     const FT_String*  glyph_name )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftobjs.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-#define SCALED( x )  ( ( (x) < 0 ? -( -(x) << shift )             \\\n-                                 :  (  (x) << shift ) ) - delta )\n+#define SCALED( x )  ( (x) * ( 1L << shift ) - delta )\n@@ -624,0 +623,10 @@\n+    \/* preset clip_box for direct mode *\/\n+    if ( params->flags & FT_RASTER_FLAG_DIRECT    &&\n+         !( params->flags & FT_RASTER_FLAG_CLIP ) )\n+    {\n+      params->clip_box.xMin = cbox.xMin >> 6;\n+      params->clip_box.yMin = cbox.yMin >> 6;\n+      params->clip_box.xMax = ( cbox.xMax + 63 ) >> 6;\n+      params->clip_box.yMax = ( cbox.yMax + 63 ) >> 6;\n+    }\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftoutln.c","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -89,4 +89,5 @@\n-    b = base[1].x;\n-    a = base[3].x = ( base[2].x + b ) \/ 2;\n-    b = base[1].x = ( base[0].x + b ) \/ 2;\n-    base[2].x = ( a + b ) \/ 2;\n+    a = base[0].x + base[1].x;\n+    b = base[1].x + base[2].x;\n+    base[3].x = b >> 1;\n+    base[2].x = ( a + b ) >> 2;\n+    base[1].x = a >> 1;\n@@ -95,4 +96,5 @@\n-    b = base[1].y;\n-    a = base[3].y = ( base[2].y + b ) \/ 2;\n-    b = base[1].y = ( base[0].y + b ) \/ 2;\n-    base[2].y = ( a + b ) \/ 2;\n+    a = base[0].y + base[1].y;\n+    b = base[1].y + base[2].y;\n+    base[3].y = b >> 1;\n+    base[2].y = ( a + b ) >> 2;\n+    base[1].y = a >> 1;\n@@ -156,1 +158,1 @@\n-    FT_Pos  a, b, c, d;\n+    FT_Pos  a, b, c;\n@@ -160,8 +162,10 @@\n-    c = base[1].x;\n-    d = base[2].x;\n-    base[1].x = a = ( base[0].x + c ) \/ 2;\n-    base[5].x = b = ( base[3].x + d ) \/ 2;\n-    c = ( c + d ) \/ 2;\n-    base[2].x = a = ( a + c ) \/ 2;\n-    base[4].x = b = ( b + c ) \/ 2;\n-    base[3].x = ( a + b ) \/ 2;\n+    a = base[0].x + base[1].x;\n+    b = base[1].x + base[2].x;\n+    c = base[2].x + base[3].x;\n+    base[5].x = c >> 1;\n+    c += b;\n+    base[4].x = c >> 2;\n+    base[1].x = a >> 1;\n+    a += b;\n+    base[2].x = a >> 2;\n+    base[3].x = ( a + c ) >> 3;\n@@ -170,8 +174,10 @@\n-    c = base[1].y;\n-    d = base[2].y;\n-    base[1].y = a = ( base[0].y + c ) \/ 2;\n-    base[5].y = b = ( base[3].y + d ) \/ 2;\n-    c = ( c + d ) \/ 2;\n-    base[2].y = a = ( a + c ) \/ 2;\n-    base[4].y = b = ( b + c ) \/ 2;\n-    base[3].y = ( a + b ) \/ 2;\n+    a = base[0].y + base[1].y;\n+    b = base[1].y + base[2].y;\n+    c = base[2].y + base[3].y;\n+    base[5].y = c >> 1;\n+    c += b;\n+    base[4].y = c >> 2;\n+    base[1].y = a >> 1;\n+    a += b;\n+    base[2].y = a >> 2;\n+    base[3].y = ( a + c ) >> 3;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftstroke.c","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -384,2 +384,2 @@\n-  cff_get_name_index( CFF_Face    face,\n-                      FT_String*  glyph_name )\n+  cff_get_name_index( CFF_Face          face,\n+                      const FT_String*  glyph_name )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffdrivr.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -965,1 +965,1 @@\n-          cffface->style_name = cff_strcpy( memory, (char *)\"Regular\" );\n+          cffface->style_name = cff_strcpy( memory, \"Regular\" );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffobjs.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,17 @@\n+#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n+  static void\n+  finalize_t2_strings( FT_Memory  memory,\n+                       void*      data,\n+                       void*      user )\n+  {\n+    CFF_T2_String  t2 = (CFF_T2_String)data;\n+\n+\n+    FT_UNUSED( user );\n+\n+    memory->free( memory, t2->start );\n+    memory->free( memory, data );\n+  }\n+#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n+\n+\n@@ -87,0 +104,52 @@\n+\n+#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n+    FT_List_Finalize( &parser->t2_strings,\n+                      finalize_t2_strings,\n+                      memory,\n+                      NULL );\n+#endif\n+  }\n+\n+\n+  \/* Assuming `first >= last'. *\/\n+\n+  static FT_Error\n+  cff_parser_within_limits( CFF_Parser  parser,\n+                            FT_Byte*    first,\n+                            FT_Byte*    last )\n+  {\n+#ifndef CFF_CONFIG_OPTION_OLD_ENGINE\n+\n+    \/* Fast path for regular FreeType builds with the \"new\" engine; *\/\n+    \/*   `first >= parser->start' can be assumed.                   *\/\n+\n+    FT_UNUSED( first );\n+\n+    return last < parser->limit ? FT_Err_Ok : FT_THROW( Invalid_Argument );\n+\n+#else \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n+\n+    FT_ListNode  node;\n+\n+\n+    if ( first >= parser->start &&\n+         last  <  parser->limit )\n+      return FT_Err_Ok;\n+\n+    node = parser->t2_strings.head;\n+\n+    while ( node )\n+    {\n+      CFF_T2_String  t2 = (CFF_T2_String)node->data;\n+\n+\n+      if ( first >= t2->start &&\n+           last  <  t2->limit )\n+        return FT_Err_Ok;\n+\n+      node = node->next;\n+    }\n+\n+    return FT_THROW( Invalid_Argument );\n+\n+#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n@@ -92,2 +161,2 @@\n-  cff_parse_integer( FT_Byte*  start,\n-                     FT_Byte*  limit )\n+  cff_parse_integer( CFF_Parser  parser,\n+                     FT_Byte*    start )\n@@ -102,1 +171,1 @@\n-      if ( p + 2 > limit )\n+      if ( cff_parser_within_limits( parser, p, p + 1 ) )\n@@ -109,1 +178,1 @@\n-      if ( p + 4 > limit )\n+      if ( cff_parser_within_limits( parser, p, p + 3 ) )\n@@ -123,1 +192,1 @@\n-      if ( p + 1 > limit )\n+      if ( cff_parser_within_limits( parser, p, p ) )\n@@ -130,1 +199,1 @@\n-      if ( p + 1 > limit )\n+      if ( cff_parser_within_limits( parser, p, p ) )\n@@ -179,4 +248,4 @@\n-  cff_parse_real( FT_Byte*  start,\n-                  FT_Byte*  limit,\n-                  FT_Long   power_ten,\n-                  FT_Long*  scaling )\n+  cff_parse_real( CFF_Parser  parser,\n+                  FT_Byte*    start,\n+                  FT_Long     power_ten,\n+                  FT_Long*    scaling )\n@@ -217,1 +286,1 @@\n-        if ( p >= limit )\n+        if ( cff_parser_within_limits( parser, p, p ) )\n@@ -254,1 +323,1 @@\n-          if ( p >= limit )\n+          if ( cff_parser_within_limits( parser, p, p ) )\n@@ -293,1 +362,1 @@\n-          if ( p >= limit )\n+          if ( cff_parser_within_limits( parser, p, p ) )\n@@ -460,1 +529,1 @@\n-      return cff_parse_real( *d, parser->limit, 0, NULL ) >> 16;\n+      return cff_parse_real( parser, *d, 0, NULL ) >> 16;\n@@ -486,1 +555,1 @@\n-      return cff_parse_integer( *d, parser->limit );\n+      return cff_parse_integer( parser, *d );\n@@ -497,1 +566,1 @@\n-      return cff_parse_real( *d, parser->limit, scaling, NULL );\n+      return cff_parse_real( parser, *d, scaling, NULL );\n@@ -500,1 +569,1 @@\n-      FT_Long  val = cff_parse_integer( *d, parser->limit );\n+      FT_Long  val = cff_parse_integer( parser, *d );\n@@ -565,1 +634,1 @@\n-      return cff_parse_real( *d, parser->limit, 0, scaling );\n+      return cff_parse_real( parser, *d, 0, scaling );\n@@ -572,1 +641,1 @@\n-      number = cff_parse_integer( d[0], d[1] );\n+      number = cff_parse_integer( parser, d[0] );\n@@ -1125,12 +1194,0 @@\n-#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n-  static void\n-  destruct_t2s_item( FT_Memory  memory,\n-                     void*      data,\n-                     void*      user )\n-  {\n-    FT_UNUSED( user );\n-    memory->free( memory, data );\n-  }\n-#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n-\n-\n@@ -1150,5 +1207,0 @@\n-\n-    FT_ListRec  t2s;\n-\n-\n-    FT_ZERO( &t2s );\n@@ -1215,3 +1267,5 @@\n-        FT_Fixed*    stack;\n-        FT_ListNode  node;\n-        FT_Byte*     q;\n+        FT_Fixed*     stack;\n+        FT_ListNode   node;\n+        CFF_T2_String t2;\n+        size_t        t2_size;\n+        FT_Byte*      q;\n@@ -1264,0 +1318,9 @@\n+        FT_List_Add( &parser->t2_strings, node );\n+\n+        t2 = (CFF_T2_String)memory->alloc( memory,\n+                                           sizeof ( CFF_T2_StringRec ) );\n+        if ( !t2 )\n+          goto Out_Of_Memory_Error;\n+\n+        node->data = t2;\n+\n@@ -1266,2 +1329,4 @@\n-        q = (FT_Byte*)memory->alloc( memory,\n-                                     5 * ( decoder.top - decoder.stack ) );\n+\n+        t2_size = 5 * ( decoder.top - decoder.stack );\n+\n+        q = (FT_Byte*)memory->alloc( memory, t2_size );\n@@ -1271,3 +1336,2 @@\n-        node->data = q;\n-\n-        FT_List_Add( &t2s, node );\n+        t2->start = q;\n+        t2->limit = q + t2_size;\n@@ -1534,3 +1598,0 @@\n-#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n-    FT_List_Finalize( &t2s, destruct_t2s_item, memory, NULL );\n-#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffparse.c","additions":108,"deletions":47,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n+    FT_ListRec  t2_strings;\n+#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n+\n@@ -133,0 +137,9 @@\n+#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n+  typedef struct  CFF_T2_String_\n+  {\n+    FT_Byte*  start;\n+    FT_Byte*  limit;\n+\n+  } CFF_T2_StringRec, *CFF_T2_String;\n+#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffparse.h","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -956,1 +956,2 @@\n-        \/* fall through since we only support kern data *\/\n+        \/* we only support kern data, so ... *\/\n+        \/* fall through                      *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/afmparse.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,2 +75,1 @@\n-          ( (x) < 0 ? -( ( -(x) + 0x2000 ) >> 14 )                       \\\n-                    :  ( (  (x) + 0x2000 ) >> 14 ) )\n+          ( ( (x) + 0x2000 - ( (x) < 0 ) ) >> 14 )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psfixed.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -277,3 +277,0 @@\n-      FT_Service_CFFLoad  cffload = (FT_Service_CFFLoad)font->cffload;\n-\n-\n@@ -287,0 +284,3 @@\n+        FT_Service_CFFLoad  cffload = (FT_Service_CFFLoad)font->cffload;\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psfont.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -177,4 +177,4 @@\n-  ps_table_add( PS_Table  table,\n-                FT_Int    idx,\n-                void*     object,\n-                FT_UInt   length )\n+  ps_table_add( PS_Table     table,\n+                FT_Int       idx,\n+                const void*  object,\n+                FT_UInt      length )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psobjs.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,4 +56,4 @@\n-  ps_table_add( PS_Table  table,\n-                FT_Int    idx,\n-                void*     object,\n-                FT_UInt   length );\n+  ps_table_add( PS_Table     table,\n+                FT_Int       idx,\n+                const void*  object,\n+                FT_UInt      length );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psobjs.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-#define RAS_ARG        \/* void *\/\n+#define RAS_ARG        void\n@@ -549,2 +549,1 @@\n-  static black_TWorker  cur_ras;\n-#define ras  cur_ras\n+  static black_TWorker  ras;\n@@ -664,1 +663,0 @@\n-    ras.cProfile->flags  = 0;\n@@ -917,4 +915,5 @@\n-    b = base[1].x;\n-    a = base[3].x = ( base[2].x + b ) \/ 2;\n-    b = base[1].x = ( base[0].x + b ) \/ 2;\n-    base[2].x = ( a + b ) \/ 2;\n+    a = base[0].x + base[1].x;\n+    b = base[1].x + base[2].x;\n+    base[3].x = b >> 1;\n+    base[2].x = ( a + b ) >> 2;\n+    base[1].x = a >> 1;\n@@ -923,4 +922,5 @@\n-    b = base[1].y;\n-    a = base[3].y = ( base[2].y + b ) \/ 2;\n-    b = base[1].y = ( base[0].y + b ) \/ 2;\n-    base[2].y = ( a + b ) \/ 2;\n+    a = base[0].y + base[1].y;\n+    b = base[1].y + base[2].y;\n+    base[3].y = b >> 1;\n+    base[2].y = ( a + b ) >> 2;\n+    base[1].y = a >> 1;\n@@ -950,1 +950,1 @@\n-    Long  a, b, c, d;\n+    Long  a, b, c;\n@@ -954,8 +954,10 @@\n-    c = base[1].x;\n-    d = base[2].x;\n-    base[1].x = a = ( base[0].x + c + 1 ) >> 1;\n-    base[5].x = b = ( base[3].x + d + 1 ) >> 1;\n-    c = ( c + d + 1 ) >> 1;\n-    base[2].x = a = ( a + c + 1 ) >> 1;\n-    base[4].x = b = ( b + c + 1 ) >> 1;\n-    base[3].x = ( a + b + 1 ) >> 1;\n+    a = base[0].x + base[1].x;\n+    b = base[1].x + base[2].x;\n+    c = base[2].x + base[3].x;\n+    base[5].x = c >> 1;\n+    c += b;\n+    base[4].x = c >> 2;\n+    base[1].x = a >> 1;\n+    a += b;\n+    base[2].x = a >> 2;\n+    base[3].x = ( a + c ) >> 3;\n@@ -964,8 +966,10 @@\n-    c = base[1].y;\n-    d = base[2].y;\n-    base[1].y = a = ( base[0].y + c + 1 ) >> 1;\n-    base[5].y = b = ( base[3].y + d + 1 ) >> 1;\n-    c = ( c + d + 1 ) >> 1;\n-    base[2].y = a = ( a + c + 1 ) >> 1;\n-    base[4].y = b = ( b + c + 1 ) >> 1;\n-    base[3].y = ( a + b + 1 ) >> 1;\n+    a = base[0].y + base[1].y;\n+    b = base[1].y + base[2].y;\n+    c = base[2].y + base[3].y;\n+    base[5].y = c >> 1;\n+    c += b;\n+    base[4].y = c >> 2;\n+    base[1].y = a >> 1;\n+    a += b;\n+    base[2].y = a >> 2;\n+    base[3].y = ( a + c ) >> 3;\n@@ -2787,1 +2791,1 @@\n-        while ( P_Left )\n+        while ( P_Left && P_Right )\n@@ -2888,1 +2892,1 @@\n-    while ( P_Left )\n+    while ( P_Left && P_Right )\n@@ -3260,0 +3264,1 @@\n+#ifndef FT_STATIC_RASTER\n@@ -3261,0 +3266,1 @@\n+#endif\n@@ -3302,2 +3308,2 @@\n-    worker->buff     = buffer;\n-    worker->sizeBuff = (&buffer)[1]; \/* Points to right after buffer. *\/\n+    ras.buff     = buffer;\n+    ras.sizeBuff = (&buffer)[1]; \/* Points to right after buffer. *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/raster\/ftraster.c","additions":39,"deletions":33,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -185,2 +185,2 @@\n-  sfnt_get_name_index( FT_Face     face,\n-                       FT_String*  glyph_name )\n+  sfnt_get_name_index( FT_Face           face,\n+                       const FT_String*  glyph_name )\n@@ -378,0 +378,1 @@\n+        \/* fall through *\/\n@@ -380,0 +381,1 @@\n+        \/* fall through *\/\n@@ -386,0 +388,1 @@\n+        \/* fall through *\/\n@@ -389,0 +392,1 @@\n+        \/* fall through *\/\n@@ -391,0 +395,1 @@\n+        \/* fall through *\/\n@@ -393,0 +398,1 @@\n+        \/* fall through *\/\n@@ -399,0 +405,1 @@\n+        \/* fall through *\/\n@@ -402,0 +409,1 @@\n+        \/* fall through *\/\n@@ -404,0 +412,1 @@\n+        \/* fall through *\/\n@@ -406,0 +415,1 @@\n+        \/* fall through *\/\n@@ -412,0 +422,1 @@\n+        \/* fall through *\/\n@@ -415,0 +426,1 @@\n+        \/* fall through *\/\n@@ -417,0 +429,1 @@\n+        \/* fall through *\/\n@@ -419,0 +432,1 @@\n+        \/* fall through *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfdriver.c","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"sfwoff.h\"\n@@ -30,1 +31,0 @@\n-#include FT_GZIP_H\n@@ -340,397 +340,0 @@\n-#define WRITE_USHORT( p, v )                \\\n-          do                                \\\n-          {                                 \\\n-            *(p)++ = (FT_Byte)( (v) >> 8 ); \\\n-            *(p)++ = (FT_Byte)( (v) >> 0 ); \\\n-                                            \\\n-          } while ( 0 )\n-\n-#define WRITE_ULONG( p, v )                  \\\n-          do                                 \\\n-          {                                  \\\n-            *(p)++ = (FT_Byte)( (v) >> 24 ); \\\n-            *(p)++ = (FT_Byte)( (v) >> 16 ); \\\n-            *(p)++ = (FT_Byte)( (v) >>  8 ); \\\n-            *(p)++ = (FT_Byte)( (v) >>  0 ); \\\n-                                             \\\n-          } while ( 0 )\n-\n-\n-  static void\n-  sfnt_stream_close( FT_Stream  stream )\n-  {\n-    FT_Memory  memory = stream->memory;\n-\n-\n-    FT_FREE( stream->base );\n-\n-    stream->size  = 0;\n-    stream->base  = NULL;\n-    stream->close = NULL;\n-  }\n-\n-\n-  FT_CALLBACK_DEF( int )\n-  compare_offsets( const void*  a,\n-                   const void*  b )\n-  {\n-    WOFF_Table  table1 = *(WOFF_Table*)a;\n-    WOFF_Table  table2 = *(WOFF_Table*)b;\n-\n-    FT_ULong  offset1 = table1->Offset;\n-    FT_ULong  offset2 = table2->Offset;\n-\n-\n-    if ( offset1 > offset2 )\n-      return 1;\n-    else if ( offset1 < offset2 )\n-      return -1;\n-    else\n-      return 0;\n-  }\n-\n-\n-  \/* Replace `face->root.stream' with a stream containing the extracted *\/\n-  \/* SFNT of a WOFF font.                                               *\/\n-\n-  static FT_Error\n-  woff_open_font( FT_Stream  stream,\n-                  TT_Face    face )\n-  {\n-    FT_Memory       memory = stream->memory;\n-    FT_Error        error  = FT_Err_Ok;\n-\n-    WOFF_HeaderRec  woff;\n-    WOFF_Table      tables  = NULL;\n-    WOFF_Table*     indices = NULL;\n-\n-    FT_ULong        woff_offset;\n-\n-    FT_Byte*        sfnt        = NULL;\n-    FT_Stream       sfnt_stream = NULL;\n-\n-    FT_Byte*        sfnt_header;\n-    FT_ULong        sfnt_offset;\n-\n-    FT_Int          nn;\n-    FT_ULong        old_tag = 0;\n-\n-    static const FT_Frame_Field  woff_header_fields[] =\n-    {\n-#undef  FT_STRUCTURE\n-#define FT_STRUCTURE  WOFF_HeaderRec\n-\n-      FT_FRAME_START( 44 ),\n-        FT_FRAME_ULONG ( signature ),\n-        FT_FRAME_ULONG ( flavor ),\n-        FT_FRAME_ULONG ( length ),\n-        FT_FRAME_USHORT( num_tables ),\n-        FT_FRAME_USHORT( reserved ),\n-        FT_FRAME_ULONG ( totalSfntSize ),\n-        FT_FRAME_USHORT( majorVersion ),\n-        FT_FRAME_USHORT( minorVersion ),\n-        FT_FRAME_ULONG ( metaOffset ),\n-        FT_FRAME_ULONG ( metaLength ),\n-        FT_FRAME_ULONG ( metaOrigLength ),\n-        FT_FRAME_ULONG ( privOffset ),\n-        FT_FRAME_ULONG ( privLength ),\n-      FT_FRAME_END\n-    };\n-\n-\n-    FT_ASSERT( stream == face->root.stream );\n-    FT_ASSERT( FT_STREAM_POS() == 0 );\n-\n-    if ( FT_STREAM_READ_FIELDS( woff_header_fields, &woff ) )\n-      return error;\n-\n-    \/* Make sure we don't recurse back here or hit TTC code. *\/\n-    if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )\n-      return FT_THROW( Invalid_Table );\n-\n-    \/* Miscellaneous checks. *\/\n-    if ( woff.length != stream->size                              ||\n-         woff.num_tables == 0                                     ||\n-         44 + woff.num_tables * 20UL >= woff.length               ||\n-         12 + woff.num_tables * 16UL >= woff.totalSfntSize        ||\n-         ( woff.totalSfntSize & 3 ) != 0                          ||\n-         ( woff.metaOffset == 0 && ( woff.metaLength != 0     ||\n-                                     woff.metaOrigLength != 0 ) ) ||\n-         ( woff.metaLength != 0 && woff.metaOrigLength == 0 )     ||\n-         ( woff.privOffset == 0 && woff.privLength != 0 )         )\n-    {\n-      FT_ERROR(( \"woff_font_open: invalid WOFF header\\n\" ));\n-      return FT_THROW( Invalid_Table );\n-    }\n-\n-    \/* Don't trust `totalSfntSize' before thorough checks. *\/\n-    if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||\n-         FT_NEW( sfnt_stream )                         )\n-      goto Exit;\n-\n-    sfnt_header = sfnt;\n-\n-    \/* Write sfnt header. *\/\n-    {\n-      FT_UInt  searchRange, entrySelector, rangeShift, x;\n-\n-\n-      x             = woff.num_tables;\n-      entrySelector = 0;\n-      while ( x )\n-      {\n-        x            >>= 1;\n-        entrySelector += 1;\n-      }\n-      entrySelector--;\n-\n-      searchRange = ( 1 << entrySelector ) * 16;\n-      rangeShift  = woff.num_tables * 16 - searchRange;\n-\n-      WRITE_ULONG ( sfnt_header, woff.flavor );\n-      WRITE_USHORT( sfnt_header, woff.num_tables );\n-      WRITE_USHORT( sfnt_header, searchRange );\n-      WRITE_USHORT( sfnt_header, entrySelector );\n-      WRITE_USHORT( sfnt_header, rangeShift );\n-    }\n-\n-    \/* While the entries in the sfnt header must be sorted by the *\/\n-    \/* tag value, the tables themselves are not.  We thus have to *\/\n-    \/* sort them by offset and check that they don't overlap.     *\/\n-\n-    if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||\n-         FT_NEW_ARRAY( indices, woff.num_tables ) )\n-      goto Exit;\n-\n-    FT_TRACE2(( \"\\n\"\n-                \"  tag    offset    compLen  origLen  checksum\\n\"\n-                \"  -------------------------------------------\\n\" ));\n-\n-    if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )\n-      goto Exit;\n-\n-    for ( nn = 0; nn < woff.num_tables; nn++ )\n-    {\n-      WOFF_Table  table = tables + nn;\n-\n-      table->Tag        = FT_GET_TAG4();\n-      table->Offset     = FT_GET_ULONG();\n-      table->CompLength = FT_GET_ULONG();\n-      table->OrigLength = FT_GET_ULONG();\n-      table->CheckSum   = FT_GET_ULONG();\n-\n-      FT_TRACE2(( \"  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\\n\",\n-                  (FT_Char)( table->Tag >> 24 ),\n-                  (FT_Char)( table->Tag >> 16 ),\n-                  (FT_Char)( table->Tag >> 8  ),\n-                  (FT_Char)( table->Tag       ),\n-                  table->Offset,\n-                  table->CompLength,\n-                  table->OrigLength,\n-                  table->CheckSum ));\n-\n-      if ( table->Tag <= old_tag )\n-      {\n-        FT_FRAME_EXIT();\n-\n-        FT_ERROR(( \"woff_font_open: table tags are not sorted\\n\" ));\n-        error = FT_THROW( Invalid_Table );\n-        goto Exit;\n-      }\n-\n-      old_tag     = table->Tag;\n-      indices[nn] = table;\n-    }\n-\n-    FT_FRAME_EXIT();\n-\n-    \/* Sort by offset. *\/\n-\n-    ft_qsort( indices,\n-              woff.num_tables,\n-              sizeof ( WOFF_Table ),\n-              compare_offsets );\n-\n-    \/* Check offsets and lengths. *\/\n-\n-    woff_offset = 44 + woff.num_tables * 20L;\n-    sfnt_offset = 12 + woff.num_tables * 16L;\n-\n-    for ( nn = 0; nn < woff.num_tables; nn++ )\n-    {\n-      WOFF_Table  table = indices[nn];\n-\n-\n-      if ( table->Offset != woff_offset                         ||\n-           table->CompLength > woff.length                      ||\n-           table->Offset > woff.length - table->CompLength      ||\n-           table->OrigLength > woff.totalSfntSize               ||\n-           sfnt_offset > woff.totalSfntSize - table->OrigLength ||\n-           table->CompLength > table->OrigLength                )\n-      {\n-        FT_ERROR(( \"woff_font_open: invalid table offsets\\n\" ));\n-        error = FT_THROW( Invalid_Table );\n-        goto Exit;\n-      }\n-\n-      table->OrigOffset = sfnt_offset;\n-\n-      \/* The offsets must be multiples of 4. *\/\n-      woff_offset += ( table->CompLength + 3 ) & ~3U;\n-      sfnt_offset += ( table->OrigLength + 3 ) & ~3U;\n-    }\n-\n-    \/*\n-     * Final checks!\n-     *\n-     * We don't decode and check the metadata block.\n-     * We don't check table checksums either.\n-     * But other than those, I think we implement all\n-     * `MUST' checks from the spec.\n-     *\/\n-\n-    if ( woff.metaOffset )\n-    {\n-      if ( woff.metaOffset != woff_offset                  ||\n-           woff.metaOffset + woff.metaLength > woff.length )\n-      {\n-        FT_ERROR(( \"woff_font_open:\"\n-                   \" invalid `metadata' offset or length\\n\" ));\n-        error = FT_THROW( Invalid_Table );\n-        goto Exit;\n-      }\n-\n-      \/* We have padding only ... *\/\n-      woff_offset += woff.metaLength;\n-    }\n-\n-    if ( woff.privOffset )\n-    {\n-      \/* ... if it isn't the last block. *\/\n-      woff_offset = ( woff_offset + 3 ) & ~3U;\n-\n-      if ( woff.privOffset != woff_offset                  ||\n-           woff.privOffset + woff.privLength > woff.length )\n-      {\n-        FT_ERROR(( \"woff_font_open: invalid `private' offset or length\\n\" ));\n-        error = FT_THROW( Invalid_Table );\n-        goto Exit;\n-      }\n-\n-      \/* No padding for the last block. *\/\n-      woff_offset += woff.privLength;\n-    }\n-\n-    if ( sfnt_offset != woff.totalSfntSize ||\n-         woff_offset != woff.length        )\n-    {\n-      FT_ERROR(( \"woff_font_open: invalid `sfnt' table structure\\n\" ));\n-      error = FT_THROW( Invalid_Table );\n-      goto Exit;\n-    }\n-\n-    \/* Now use `totalSfntSize'. *\/\n-    if ( FT_REALLOC( sfnt,\n-                     12 + woff.num_tables * 16UL,\n-                     woff.totalSfntSize ) )\n-      goto Exit;\n-\n-    sfnt_header = sfnt + 12;\n-\n-    \/* Write the tables. *\/\n-\n-    for ( nn = 0; nn < woff.num_tables; nn++ )\n-    {\n-      WOFF_Table  table = tables + nn;\n-\n-\n-      \/* Write SFNT table entry. *\/\n-      WRITE_ULONG( sfnt_header, table->Tag );\n-      WRITE_ULONG( sfnt_header, table->CheckSum );\n-      WRITE_ULONG( sfnt_header, table->OrigOffset );\n-      WRITE_ULONG( sfnt_header, table->OrigLength );\n-\n-      \/* Write table data. *\/\n-      if ( FT_STREAM_SEEK( table->Offset )     ||\n-           FT_FRAME_ENTER( table->CompLength ) )\n-        goto Exit;\n-\n-      if ( table->CompLength == table->OrigLength )\n-      {\n-        \/* Uncompressed data; just copy. *\/\n-        ft_memcpy( sfnt + table->OrigOffset,\n-                   stream->cursor,\n-                   table->OrigLength );\n-      }\n-      else\n-      {\n-#ifdef FT_CONFIG_OPTION_USE_ZLIB\n-\n-        \/* Uncompress with zlib. *\/\n-        FT_ULong  output_len = table->OrigLength;\n-\n-\n-        error = FT_Gzip_Uncompress( memory,\n-                                    sfnt + table->OrigOffset, &output_len,\n-                                    stream->cursor, table->CompLength );\n-        if ( error )\n-          goto Exit;\n-        if ( output_len != table->OrigLength )\n-        {\n-          FT_ERROR(( \"woff_font_open: compressed table length mismatch\\n\" ));\n-          error = FT_THROW( Invalid_Table );\n-          goto Exit;\n-        }\n-\n-#else \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n-\n-        error = FT_THROW( Unimplemented_Feature );\n-        goto Exit;\n-\n-#endif \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n-      }\n-\n-      FT_FRAME_EXIT();\n-\n-      \/* We don't check whether the padding bytes in the WOFF file are     *\/\n-      \/* actually '\\0'.  For the output, however, we do set them properly. *\/\n-      sfnt_offset = table->OrigOffset + table->OrigLength;\n-      while ( sfnt_offset & 3 )\n-      {\n-        sfnt[sfnt_offset] = '\\0';\n-        sfnt_offset++;\n-      }\n-    }\n-\n-    \/* Ok!  Finally ready.  Swap out stream and return. *\/\n-    FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );\n-    sfnt_stream->memory = stream->memory;\n-    sfnt_stream->close  = sfnt_stream_close;\n-\n-    FT_Stream_Free(\n-      face->root.stream,\n-      ( face->root.face_flags & FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );\n-\n-    face->root.stream = sfnt_stream;\n-\n-    face->root.face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;\n-\n-  Exit:\n-    FT_FREE( tables );\n-    FT_FREE( indices );\n-\n-    if ( error )\n-    {\n-      FT_FREE( sfnt );\n-      FT_Stream_Close( sfnt_stream );\n-      FT_FREE( sfnt_stream );\n-    }\n-\n-    return error;\n-  }\n-\n-\n-#undef WRITE_USHORT\n-#undef WRITE_ULONG\n-\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfobjs.c","additions":1,"deletions":398,"binary":false,"changes":399,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-#endif \/* SFDRIVER_H_ *\/\n+#endif \/* SFOBJS_H_ *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,434 @@\n+\/****************************************************************************\n+ *\n+ * sfwoff.c\n+ *\n+ *   WOFF format management (base).\n+ *\n+ * Copyright (C) 1996-2019 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#include <ft2build.h>\n+#include \"sfwoff.h\"\n+#include FT_TRUETYPE_TAGS_H\n+#include FT_INTERNAL_DEBUG_H\n+#include FT_INTERNAL_STREAM_H\n+#include FT_GZIP_H\n+\n+\n+  \/**************************************************************************\n+   *\n+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit\n+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print\/log\n+   * messages during execution.\n+   *\/\n+#undef  FT_COMPONENT\n+#define FT_COMPONENT  sfwoff\n+\n+\n+#define WRITE_USHORT( p, v )                \\\n+          do                                \\\n+          {                                 \\\n+            *(p)++ = (FT_Byte)( (v) >> 8 ); \\\n+            *(p)++ = (FT_Byte)( (v) >> 0 ); \\\n+                                            \\\n+          } while ( 0 )\n+\n+#define WRITE_ULONG( p, v )                  \\\n+          do                                 \\\n+          {                                  \\\n+            *(p)++ = (FT_Byte)( (v) >> 24 ); \\\n+            *(p)++ = (FT_Byte)( (v) >> 16 ); \\\n+            *(p)++ = (FT_Byte)( (v) >>  8 ); \\\n+            *(p)++ = (FT_Byte)( (v) >>  0 ); \\\n+                                             \\\n+          } while ( 0 )\n+\n+\n+  static void\n+  sfnt_stream_close( FT_Stream  stream )\n+  {\n+    FT_Memory  memory = stream->memory;\n+\n+\n+    FT_FREE( stream->base );\n+\n+    stream->size  = 0;\n+    stream->base  = NULL;\n+    stream->close = NULL;\n+  }\n+\n+\n+  FT_CALLBACK_DEF( int )\n+  compare_offsets( const void*  a,\n+                   const void*  b )\n+  {\n+    WOFF_Table  table1 = *(WOFF_Table*)a;\n+    WOFF_Table  table2 = *(WOFF_Table*)b;\n+\n+    FT_ULong  offset1 = table1->Offset;\n+    FT_ULong  offset2 = table2->Offset;\n+\n+\n+    if ( offset1 > offset2 )\n+      return 1;\n+    else if ( offset1 < offset2 )\n+      return -1;\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* Replace `face->root.stream' with a stream containing the extracted *\/\n+  \/* SFNT of a WOFF font.                                               *\/\n+\n+  FT_LOCAL_DEF( FT_Error )\n+  woff_open_font( FT_Stream  stream,\n+                  TT_Face    face )\n+  {\n+    FT_Memory       memory = stream->memory;\n+    FT_Error        error  = FT_Err_Ok;\n+\n+    WOFF_HeaderRec  woff;\n+    WOFF_Table      tables  = NULL;\n+    WOFF_Table*     indices = NULL;\n+\n+    FT_ULong        woff_offset;\n+\n+    FT_Byte*        sfnt        = NULL;\n+    FT_Stream       sfnt_stream = NULL;\n+\n+    FT_Byte*        sfnt_header;\n+    FT_ULong        sfnt_offset;\n+\n+    FT_Int          nn;\n+    FT_ULong        old_tag = 0;\n+\n+    static const FT_Frame_Field  woff_header_fields[] =\n+    {\n+#undef  FT_STRUCTURE\n+#define FT_STRUCTURE  WOFF_HeaderRec\n+\n+      FT_FRAME_START( 44 ),\n+        FT_FRAME_ULONG ( signature ),\n+        FT_FRAME_ULONG ( flavor ),\n+        FT_FRAME_ULONG ( length ),\n+        FT_FRAME_USHORT( num_tables ),\n+        FT_FRAME_USHORT( reserved ),\n+        FT_FRAME_ULONG ( totalSfntSize ),\n+        FT_FRAME_USHORT( majorVersion ),\n+        FT_FRAME_USHORT( minorVersion ),\n+        FT_FRAME_ULONG ( metaOffset ),\n+        FT_FRAME_ULONG ( metaLength ),\n+        FT_FRAME_ULONG ( metaOrigLength ),\n+        FT_FRAME_ULONG ( privOffset ),\n+        FT_FRAME_ULONG ( privLength ),\n+      FT_FRAME_END\n+    };\n+\n+\n+    FT_ASSERT( stream == face->root.stream );\n+    FT_ASSERT( FT_STREAM_POS() == 0 );\n+\n+    if ( FT_STREAM_READ_FIELDS( woff_header_fields, &woff ) )\n+      return error;\n+\n+    \/* Make sure we don't recurse back here or hit TTC code. *\/\n+    if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )\n+      return FT_THROW( Invalid_Table );\n+\n+    \/* Miscellaneous checks. *\/\n+    if ( woff.length != stream->size                              ||\n+         woff.num_tables == 0                                     ||\n+         44 + woff.num_tables * 20UL >= woff.length               ||\n+         12 + woff.num_tables * 16UL >= woff.totalSfntSize        ||\n+         ( woff.totalSfntSize & 3 ) != 0                          ||\n+         ( woff.metaOffset == 0 && ( woff.metaLength != 0     ||\n+                                     woff.metaOrigLength != 0 ) ) ||\n+         ( woff.metaLength != 0 && woff.metaOrigLength == 0 )     ||\n+         ( woff.privOffset == 0 && woff.privLength != 0 )         )\n+    {\n+      FT_ERROR(( \"woff_font_open: invalid WOFF header\\n\" ));\n+      return FT_THROW( Invalid_Table );\n+    }\n+\n+    \/* Don't trust `totalSfntSize' before thorough checks. *\/\n+    if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||\n+         FT_NEW( sfnt_stream )                         )\n+      goto Exit;\n+\n+    sfnt_header = sfnt;\n+\n+    \/* Write sfnt header. *\/\n+    {\n+      FT_UInt  searchRange, entrySelector, rangeShift, x;\n+\n+\n+      x             = woff.num_tables;\n+      entrySelector = 0;\n+      while ( x )\n+      {\n+        x            >>= 1;\n+        entrySelector += 1;\n+      }\n+      entrySelector--;\n+\n+      searchRange = ( 1 << entrySelector ) * 16;\n+      rangeShift  = woff.num_tables * 16 - searchRange;\n+\n+      WRITE_ULONG ( sfnt_header, woff.flavor );\n+      WRITE_USHORT( sfnt_header, woff.num_tables );\n+      WRITE_USHORT( sfnt_header, searchRange );\n+      WRITE_USHORT( sfnt_header, entrySelector );\n+      WRITE_USHORT( sfnt_header, rangeShift );\n+    }\n+\n+    \/* While the entries in the sfnt header must be sorted by the *\/\n+    \/* tag value, the tables themselves are not.  We thus have to *\/\n+    \/* sort them by offset and check that they don't overlap.     *\/\n+\n+    if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||\n+         FT_NEW_ARRAY( indices, woff.num_tables ) )\n+      goto Exit;\n+\n+    FT_TRACE2(( \"\\n\"\n+                \"  tag    offset    compLen  origLen  checksum\\n\"\n+                \"  -------------------------------------------\\n\" ));\n+\n+    if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )\n+      goto Exit;\n+\n+    for ( nn = 0; nn < woff.num_tables; nn++ )\n+    {\n+      WOFF_Table  table = tables + nn;\n+\n+      table->Tag        = FT_GET_TAG4();\n+      table->Offset     = FT_GET_ULONG();\n+      table->CompLength = FT_GET_ULONG();\n+      table->OrigLength = FT_GET_ULONG();\n+      table->CheckSum   = FT_GET_ULONG();\n+\n+      FT_TRACE2(( \"  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\\n\",\n+                  (FT_Char)( table->Tag >> 24 ),\n+                  (FT_Char)( table->Tag >> 16 ),\n+                  (FT_Char)( table->Tag >> 8  ),\n+                  (FT_Char)( table->Tag       ),\n+                  table->Offset,\n+                  table->CompLength,\n+                  table->OrigLength,\n+                  table->CheckSum ));\n+\n+      if ( table->Tag <= old_tag )\n+      {\n+        FT_FRAME_EXIT();\n+\n+        FT_ERROR(( \"woff_font_open: table tags are not sorted\\n\" ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+\n+      old_tag     = table->Tag;\n+      indices[nn] = table;\n+    }\n+\n+    FT_FRAME_EXIT();\n+\n+    \/* Sort by offset. *\/\n+\n+    ft_qsort( indices,\n+              woff.num_tables,\n+              sizeof ( WOFF_Table ),\n+              compare_offsets );\n+\n+    \/* Check offsets and lengths. *\/\n+\n+    woff_offset = 44 + woff.num_tables * 20L;\n+    sfnt_offset = 12 + woff.num_tables * 16L;\n+\n+    for ( nn = 0; nn < woff.num_tables; nn++ )\n+    {\n+      WOFF_Table  table = indices[nn];\n+\n+\n+      if ( table->Offset != woff_offset                         ||\n+           table->CompLength > woff.length                      ||\n+           table->Offset > woff.length - table->CompLength      ||\n+           table->OrigLength > woff.totalSfntSize               ||\n+           sfnt_offset > woff.totalSfntSize - table->OrigLength ||\n+           table->CompLength > table->OrigLength                )\n+      {\n+        FT_ERROR(( \"woff_font_open: invalid table offsets\\n\" ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+\n+      table->OrigOffset = sfnt_offset;\n+\n+      \/* The offsets must be multiples of 4. *\/\n+      woff_offset += ( table->CompLength + 3 ) & ~3U;\n+      sfnt_offset += ( table->OrigLength + 3 ) & ~3U;\n+    }\n+\n+    \/*\n+     * Final checks!\n+     *\n+     * We don't decode and check the metadata block.\n+     * We don't check table checksums either.\n+     * But other than those, I think we implement all\n+     * `MUST' checks from the spec.\n+     *\/\n+\n+    if ( woff.metaOffset )\n+    {\n+      if ( woff.metaOffset != woff_offset                  ||\n+           woff.metaOffset + woff.metaLength > woff.length )\n+      {\n+        FT_ERROR(( \"woff_font_open:\"\n+                   \" invalid `metadata' offset or length\\n\" ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+\n+      \/* We have padding only ... *\/\n+      woff_offset += woff.metaLength;\n+    }\n+\n+    if ( woff.privOffset )\n+    {\n+      \/* ... if it isn't the last block. *\/\n+      woff_offset = ( woff_offset + 3 ) & ~3U;\n+\n+      if ( woff.privOffset != woff_offset                  ||\n+           woff.privOffset + woff.privLength > woff.length )\n+      {\n+        FT_ERROR(( \"woff_font_open: invalid `private' offset or length\\n\" ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+\n+      \/* No padding for the last block. *\/\n+      woff_offset += woff.privLength;\n+    }\n+\n+    if ( sfnt_offset != woff.totalSfntSize ||\n+         woff_offset != woff.length        )\n+    {\n+      FT_ERROR(( \"woff_font_open: invalid `sfnt' table structure\\n\" ));\n+      error = FT_THROW( Invalid_Table );\n+      goto Exit;\n+    }\n+\n+    \/* Now use `totalSfntSize'. *\/\n+    if ( FT_REALLOC( sfnt,\n+                     12 + woff.num_tables * 16UL,\n+                     woff.totalSfntSize ) )\n+      goto Exit;\n+\n+    sfnt_header = sfnt + 12;\n+\n+    \/* Write the tables. *\/\n+\n+    for ( nn = 0; nn < woff.num_tables; nn++ )\n+    {\n+      WOFF_Table  table = tables + nn;\n+\n+\n+      \/* Write SFNT table entry. *\/\n+      WRITE_ULONG( sfnt_header, table->Tag );\n+      WRITE_ULONG( sfnt_header, table->CheckSum );\n+      WRITE_ULONG( sfnt_header, table->OrigOffset );\n+      WRITE_ULONG( sfnt_header, table->OrigLength );\n+\n+      \/* Write table data. *\/\n+      if ( FT_STREAM_SEEK( table->Offset )     ||\n+           FT_FRAME_ENTER( table->CompLength ) )\n+        goto Exit;\n+\n+      if ( table->CompLength == table->OrigLength )\n+      {\n+        \/* Uncompressed data; just copy. *\/\n+        ft_memcpy( sfnt + table->OrigOffset,\n+                   stream->cursor,\n+                   table->OrigLength );\n+      }\n+      else\n+      {\n+#ifdef FT_CONFIG_OPTION_USE_ZLIB\n+\n+        \/* Uncompress with zlib. *\/\n+        FT_ULong  output_len = table->OrigLength;\n+\n+\n+        error = FT_Gzip_Uncompress( memory,\n+                                    sfnt + table->OrigOffset, &output_len,\n+                                    stream->cursor, table->CompLength );\n+        if ( error )\n+          goto Exit;\n+        if ( output_len != table->OrigLength )\n+        {\n+          FT_ERROR(( \"woff_font_open: compressed table length mismatch\\n\" ));\n+          error = FT_THROW( Invalid_Table );\n+          goto Exit;\n+        }\n+\n+#else \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n+\n+        error = FT_THROW( Unimplemented_Feature );\n+        goto Exit;\n+\n+#endif \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n+      }\n+\n+      FT_FRAME_EXIT();\n+\n+      \/* We don't check whether the padding bytes in the WOFF file are     *\/\n+      \/* actually '\\0'.  For the output, however, we do set them properly. *\/\n+      sfnt_offset = table->OrigOffset + table->OrigLength;\n+      while ( sfnt_offset & 3 )\n+      {\n+        sfnt[sfnt_offset] = '\\0';\n+        sfnt_offset++;\n+      }\n+    }\n+\n+    \/* Ok!  Finally ready.  Swap out stream and return. *\/\n+    FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );\n+    sfnt_stream->memory = stream->memory;\n+    sfnt_stream->close  = sfnt_stream_close;\n+\n+    FT_Stream_Free(\n+      face->root.stream,\n+      ( face->root.face_flags & FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );\n+\n+    face->root.stream = sfnt_stream;\n+\n+    face->root.face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;\n+\n+  Exit:\n+    FT_FREE( tables );\n+    FT_FREE( indices );\n+\n+    if ( error )\n+    {\n+      FT_FREE( sfnt );\n+      FT_Stream_Close( sfnt_stream );\n+      FT_FREE( sfnt_stream );\n+    }\n+\n+    return error;\n+  }\n+\n+\n+#undef WRITE_USHORT\n+#undef WRITE_ULONG\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfwoff.c","additions":434,"deletions":0,"binary":false,"changes":434,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/****************************************************************************\n+ *\n+ * sfwoff.h\n+ *\n+ *   WOFFF format management (specification).\n+ *\n+ * Copyright (C) 1996-2019 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef SFWOFF_H_\n+#define SFWOFF_H_\n+\n+\n+#include <ft2build.h>\n+#include FT_INTERNAL_SFNT_H\n+#include FT_INTERNAL_OBJECTS_H\n+\n+\n+FT_BEGIN_HEADER\n+\n+\n+  FT_LOCAL( FT_Error )\n+  woff_open_font( FT_Stream  stream,\n+                  TT_Face    face );\n+\n+\n+FT_END_HEADER\n+\n+#endif \/* SFWOFF_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfwoff.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -2371,2 +2371,0 @@\n-        {\n-          gindex = 0;\n@@ -2374,1 +2372,0 @@\n-        }\n@@ -3664,1 +3661,1 @@\n-    FT_String*  PSname;\n+    FT_String*  PSname = NULL;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcmap.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-        if ( table_pos + 4 > table_end )\n+        if ( table_pos + 2 > table_end )\n@@ -295,1 +295,3 @@\n-          if ( !FT_STREAM_SEEK( table_pos ) )\n+          if ( FT_STREAM_SEEK( table_pos ) )\n+            *abearing = 0;\n+          else\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttmtx.c","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-   * coverage of the outline on each pixel cell.\n+   * coverage of the outline on each pixel cell by straight segments.\n@@ -61,0 +61,8 @@\n+   * Bézier segments are flattened by splitting them until their deviation\n+   * from straight line becomes much smaller than a pixel.  Therefore, the\n+   * pixel coverage by a Bézier curve is calculated approximately.  To\n+   * estimate the deviation, we use the distance from the control point\n+   * to the conic chord centre or the cubic chord trisection.  These\n+   * distances vanish fast after each split.  In the conic case, they vanish\n+   * predictably and the number of necessary splits can be calculated.\n+   *\n@@ -70,1 +78,1 @@\n-   *   each pixel cell.\n+   *   each pixel cell by straight segments.\n@@ -78,1 +86,1 @@\n-   * - For small (< 20) pixel sizes, it is faster than the standard\n+   * - For small (< 80) pixel sizes, it is faster than the standard\n@@ -330,5 +338,0 @@\n-#undef FLOOR\n-#undef CEILING\n-#undef TRUNC\n-#undef SCALED\n-\n@@ -336,5 +339,2 @@\n-#define TRUNC( x )      ( (TCoord)( (x) >> PIXEL_BITS ) )\n-#define SUBPIXELS( x )  ( (TPos)(x) * ONE_PIXEL )\n-#define FLOOR( x )      ( (x) & -ONE_PIXEL )\n-#define CEILING( x )    ( ( (x) + ONE_PIXEL - 1 ) & -ONE_PIXEL )\n-#define ROUND( x )      ( ( (x) + ONE_PIXEL \/ 2 ) & -ONE_PIXEL )\n+#define TRUNC( x )      (TCoord)( (x) >> PIXEL_BITS )\n+#define FRACT( x )      (TCoord)( (x) & ( ONE_PIXEL - 1 ) )\n@@ -391,3 +391,3 @@\n-#define FT_UDIV( a, b )                                        \\\n-  ( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) >>   \\\n-    ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )\n+#define FT_UDIV( a, b )                                                \\\n+  (TCoord)( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) >>   \\\n+            ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )\n@@ -435,0 +435,3 @@\n+  \/* FT_Span buffer size for direct rendering only *\/\n+#define FT_MAX_GRAY_SPANS  10\n+\n@@ -468,0 +471,2 @@\n+    FT_Span              spans[FT_MAX_GRAY_SPANS];\n+    int                  num_spans;\n@@ -519,1 +524,1 @@\n-   * Record the current cell in the table.\n+   * Record the current cell in the linked list.\n@@ -529,1 +534,1 @@\n-    for (;;)\n+    while ( ( cell = *pcell ) )\n@@ -531,2 +536,1 @@\n-      cell = *pcell;\n-      if ( !cell || cell->x > x )\n+      if ( cell->x > x )\n@@ -580,3 +584,0 @@\n-    if ( ex < ras.min_ex )\n-      ex = ras.min_ex - 1;\n-\n@@ -589,1 +590,1 @@\n-    ras.ex    = ex;\n+    ras.ex    = FT_MAX( ex, ras.min_ex - 1 );\n@@ -625,2 +626,2 @@\n-    fx1   = (TCoord)( x1 - SUBPIXELS( ex1 ) );\n-    fx2   = (TCoord)( x2 - SUBPIXELS( ex2 ) );\n+    fx1   = FRACT( x1 );\n+    fx2   = FRACT( x2 );\n@@ -653,0 +654,3 @@\n+    \/* the fractional part of y-delta is mod\/dx. It is essential to *\/\n+    \/* keep track of its accumulation for accurate rendering.       *\/\n+    \/* XXX: y-delta and x-delta below should be related.            *\/\n@@ -718,2 +722,2 @@\n-    fy1 = (TCoord)( ras.y - SUBPIXELS( ey1 ) );\n-    fy2 = (TCoord)( to_y - SUBPIXELS( ey2 ) );\n+    fy1 = FRACT( ras.y );\n+    fy2 = FRACT( to_y );\n@@ -735,1 +739,1 @@\n-      TCoord  two_fx = (TCoord)( ( ras.x - SUBPIXELS( ex ) ) << 1 );\n+      TCoord  two_fx = FRACT( ras.x ) << 1;\n@@ -790,0 +794,2 @@\n+    \/* the fractional part of x-delta is mod\/dy. It is essential to *\/\n+    \/* keep track of its accumulation for accurate rendering.       *\/\n@@ -846,2 +852,3 @@\n-    TPos    dx, dy, fx1, fy1, fx2, fy2;\n-    TCoord  ex1, ex2, ey1, ey2;\n+    TPos    dx, dy;\n+    TCoord  fx1, fy1, fx2, fy2;\n+    TCoord  ex1, ey1, ex2, ey2;\n@@ -861,2 +868,2 @@\n-    fx1 = ras.x - SUBPIXELS( ex1 );\n-    fy1 = ras.y - SUBPIXELS( ey1 );\n+    fx1 = FRACT( ras.x );\n+    fy1 = FRACT( ras.y );\n@@ -871,2 +878,2 @@\n-      ex1 = ex2;\n-      gray_set_cell( RAS_VAR_ ex1, ey1 );\n+      gray_set_cell( RAS_VAR_ ex2, ey2 );\n+      goto End;\n@@ -899,1 +906,1 @@\n-      TPos  prod = dx * fy1 - dy * fx1;\n+      TPos  prod = dx * (TPos)fy1 - dy * (TPos)fx1;\n@@ -913,1 +920,1 @@\n-          fy2 = (TPos)FT_UDIV( -prod, -dx );\n+          fy2 = FT_UDIV( -prod, -dx );\n@@ -925,1 +932,1 @@\n-          fx2 = (TPos)FT_UDIV( -prod, dy );\n+          fx2 = FT_UDIV( -prod, dy );\n@@ -938,1 +945,1 @@\n-          fy2 = (TPos)FT_UDIV( prod, dx );\n+          fy2 = FT_UDIV( prod, dx );\n@@ -948,1 +955,1 @@\n-          fx2 = (TPos)FT_UDIV( prod, -dy );\n+          fx2 = FT_UDIV( prod, -dy );\n@@ -962,2 +969,2 @@\n-    fx2 = to_x - SUBPIXELS( ex2 );\n-    fy2 = to_y - SUBPIXELS( ey2 );\n+    fx2 = FRACT( to_x );\n+    fy2 = FRACT( to_y );\n@@ -982,4 +989,5 @@\n-    b = base[1].x;\n-    a = base[3].x = ( base[2].x + b ) \/ 2;\n-    b = base[1].x = ( base[0].x + b ) \/ 2;\n-    base[2].x = ( a + b ) \/ 2;\n+    a = base[0].x + base[1].x;\n+    b = base[1].x + base[2].x;\n+    base[3].x = b >> 1;\n+    base[2].x = ( a + b ) >> 2;\n+    base[1].x = a >> 1;\n@@ -988,4 +996,5 @@\n-    b = base[1].y;\n-    a = base[3].y = ( base[2].y + b ) \/ 2;\n-    b = base[1].y = ( base[0].y + b ) \/ 2;\n-    base[2].y = ( a + b ) \/ 2;\n+    a = base[0].y + base[1].y;\n+    b = base[1].y + base[2].y;\n+    base[3].y = b >> 1;\n+    base[2].y = ( a + b ) >> 2;\n+    base[1].y = a >> 1;\n@@ -1045,2 +1054,2 @@\n-      split = 1;\n-      while ( ( draw & split ) == 0 )\n+      split = draw & ( -draw );  \/* isolate the rightmost 1-bit *\/\n+      while ( ( split >>= 1 ) )\n@@ -1050,1 +1059,0 @@\n-        split <<= 1;\n@@ -1063,1 +1071,1 @@\n-    TPos  a, b, c, d;\n+    TPos  a, b, c;\n@@ -1067,8 +1075,10 @@\n-    c = base[1].x;\n-    d = base[2].x;\n-    base[1].x = a = ( base[0].x + c ) \/ 2;\n-    base[5].x = b = ( base[3].x + d ) \/ 2;\n-    c = ( c + d ) \/ 2;\n-    base[2].x = a = ( a + c ) \/ 2;\n-    base[4].x = b = ( b + c ) \/ 2;\n-    base[3].x = ( a + b ) \/ 2;\n+    a = base[0].x + base[1].x;\n+    b = base[1].x + base[2].x;\n+    c = base[2].x + base[3].x;\n+    base[5].x = c >> 1;\n+    c += b;\n+    base[4].x = c >> 2;\n+    base[1].x = a >> 1;\n+    a += b;\n+    base[2].x = a >> 2;\n+    base[3].x = ( a + c ) >> 3;\n@@ -1077,8 +1087,10 @@\n-    c = base[1].y;\n-    d = base[2].y;\n-    base[1].y = a = ( base[0].y + c ) \/ 2;\n-    base[5].y = b = ( base[3].y + d ) \/ 2;\n-    c = ( c + d ) \/ 2;\n-    base[2].y = a = ( a + c ) \/ 2;\n-    base[4].y = b = ( b + c ) \/ 2;\n-    base[3].y = ( a + b ) \/ 2;\n+    a = base[0].y + base[1].y;\n+    b = base[1].y + base[2].y;\n+    c = base[2].y + base[3].y;\n+    base[5].y = c >> 1;\n+    c += b;\n+    base[4].y = c >> 2;\n+    base[1].y = a >> 1;\n+    a += b;\n+    base[2].y = a >> 2;\n+    base[3].y = ( a + c ) >> 3;\n@@ -1095,3 +1107,0 @@\n-    TPos        dx, dy, dx_, dy_;\n-    TPos        dx1, dy1, dx2, dy2;\n-    TPos        L, s, s_limit;\n@@ -1126,39 +1135,7 @@\n-      \/* Decide whether to split or draw. See `Rapid Termination          *\/\n-      \/* Evaluation for Recursive Subdivision of Bezier Curves' by Thomas *\/\n-      \/* F. Hain, at                                                      *\/\n-      \/* http:\/\/www.cis.southalabama.edu\/~hain\/general\/Publications\/Bezier\/Camera-ready%20CISST02%202.pdf *\/\n-\n-      \/* dx and dy are x and y components of the P0-P3 chord vector. *\/\n-      dx = dx_ = arc[3].x - arc[0].x;\n-      dy = dy_ = arc[3].y - arc[0].y;\n-\n-      L = FT_HYPOT( dx_, dy_ );\n-\n-      \/* Avoid possible arithmetic overflow below by splitting. *\/\n-      if ( L > 32767 )\n-        goto Split;\n-\n-      \/* Max deviation may be as much as (s\/L) * 3\/4 (if Hain's v = 1). *\/\n-      s_limit = L * (TPos)( ONE_PIXEL \/ 6 );\n-\n-      \/* s is L * the perpendicular distance from P1 to the line P0-P3. *\/\n-      dx1 = arc[1].x - arc[0].x;\n-      dy1 = arc[1].y - arc[0].y;\n-      s = FT_ABS( SUB_LONG( MUL_LONG( dy, dx1 ), MUL_LONG( dx, dy1 ) ) );\n-\n-      if ( s > s_limit )\n-        goto Split;\n-\n-      \/* s is L * the perpendicular distance from P2 to the line P0-P3. *\/\n-      dx2 = arc[2].x - arc[0].x;\n-      dy2 = arc[2].y - arc[0].y;\n-      s = FT_ABS( SUB_LONG( MUL_LONG( dy, dx2 ), MUL_LONG( dx, dy2 ) ) );\n-\n-      if ( s > s_limit )\n-        goto Split;\n-\n-      \/* Split super curvy segments where the off points are so far\n-         from the chord that the angles P0-P1-P3 or P0-P2-P3 become\n-         acute as detected by appropriate dot products. *\/\n-      if ( dx1 * ( dx1 - dx ) + dy1 * ( dy1 - dy ) > 0 ||\n-           dx2 * ( dx2 - dx ) + dy2 * ( dy2 - dy ) > 0 )\n+      \/* with each split, control points quickly converge towards  *\/\n+      \/* chord trisection points and the vanishing distances below *\/\n+      \/* indicate when the segment is flat enough to draw          *\/\n+      if ( FT_ABS( 2 * arc[0].x - 3 * arc[1].x + arc[3].x ) > ONE_PIXEL \/ 2 ||\n+           FT_ABS( 2 * arc[0].y - 3 * arc[1].y + arc[3].y ) > ONE_PIXEL \/ 2 ||\n+           FT_ABS( arc[0].x - 3 * arc[2].x + 2 * arc[3].x ) > ONE_PIXEL \/ 2 ||\n+           FT_ABS( arc[0].y - 3 * arc[2].y + 2 * arc[3].y ) > ONE_PIXEL \/ 2 )\n@@ -1239,2 +1216,0 @@\n-    if ( coverage < 0 )\n-      coverage = -coverage - 1;\n@@ -1250,1 +1225,1 @@\n-    else\n+    else  \/* default non-zero winding rule *\/\n@@ -1252,1 +1227,3 @@\n-      \/* normal non-zero winding rule *\/\n+      if ( coverage < 0 )\n+        coverage = ~coverage;  \/* the same as -coverage - 1 *\/\n+\n@@ -1257,1 +1234,1 @@\n-    if ( ras.render_span )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n+    if ( ras.num_spans >= 0 )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n@@ -1259,1 +1236,1 @@\n-      FT_Span  span;\n+      FT_Span*  span = ras.spans + ras.num_spans++;\n@@ -1262,3 +1239,3 @@\n-      span.x        = (short)x;\n-      span.len      = (unsigned short)acount;\n-      span.coverage = (unsigned char)coverage;\n+      span->x        = (short)x;\n+      span->len      = (unsigned short)acount;\n+      span->coverage = (unsigned char)coverage;\n@@ -1266,1 +1243,6 @@\n-      ras.render_span( y, 1, &span, ras.render_span_data );\n+      if ( ras.num_spans == FT_MAX_GRAY_SPANS )\n+      {\n+        \/* flush the span buffer and reset the count *\/\n+        ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );\n+        ras.num_spans = 0;\n+      }\n@@ -1280,8 +1262,23 @@\n-      case 7: *q++ = c;\n-      case 6: *q++ = c;\n-      case 5: *q++ = c;\n-      case 4: *q++ = c;\n-      case 3: *q++ = c;\n-      case 2: *q++ = c;\n-      case 1: *q   = c;\n-      case 0: break;\n+      case 7:\n+        *q++ = c;\n+        \/* fall through *\/\n+      case 6:\n+        *q++ = c;\n+        \/* fall through *\/\n+      case 5:\n+        *q++ = c;\n+        \/* fall through *\/\n+      case 4:\n+        *q++ = c;\n+        \/* fall through *\/\n+      case 3:\n+        *q++ = c;\n+        \/* fall through *\/\n+      case 2:\n+        *q++ = c;\n+        \/* fall through *\/\n+      case 1:\n+        *q = c;\n+        \/* fall through *\/\n+      case 0:\n+        break;\n@@ -1325,0 +1322,7 @@\n+\n+      if ( ras.num_spans > 0 )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n+      {\n+        \/* flush the span buffer and reset the count *\/\n+        ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );\n+        ras.num_spans = 0;\n+      }\n@@ -1374,1 +1378,1 @@\n-#define SCALED( x )  ( ( (x) << shift ) - delta )\n+#define SCALED( x )  ( (x) * ( 1L << shift ) - delta )\n@@ -1634,1 +1638,1 @@\n-    volatile int  error = 0;\n+    int  error;\n@@ -1758,1 +1762,0 @@\n-    FT_BBox            clip;\n@@ -1795,0 +1798,6 @@\n+      ras.num_spans        = 0;\n+\n+      ras.min_ex = params->clip_box.xMin;\n+      ras.min_ey = params->clip_box.yMin;\n+      ras.max_ex = params->clip_box.xMax;\n+      ras.max_ey = params->clip_box.yMax;\n@@ -1819,1 +1828,1 @@\n-    }\n+      ras.num_spans        = -1;  \/* invalid *\/\n@@ -1821,11 +1830,4 @@\n-    \/* compute clipping box *\/\n-    if ( params->flags & FT_RASTER_FLAG_DIRECT &&\n-         params->flags & FT_RASTER_FLAG_CLIP   )\n-      clip = params->clip_box;\n-    else\n-    {\n-      \/* compute clip box from target pixmap *\/\n-      clip.xMin = 0;\n-      clip.yMin = 0;\n-      clip.xMax = (FT_Pos)target_map->width;\n-      clip.yMax = (FT_Pos)target_map->rows;\n+      ras.min_ex = 0;\n+      ras.min_ey = 0;\n+      ras.max_ex = (FT_Pos)target_map->width;\n+      ras.max_ey = (FT_Pos)target_map->rows;\n@@ -1834,6 +1836,1 @@\n-    \/* clip to target bitmap, exit if nothing to do *\/\n-    ras.min_ex = clip.xMin;\n-    ras.min_ey = clip.yMin;\n-    ras.max_ex = clip.xMax;\n-    ras.max_ey = clip.yMax;\n-\n+    \/* exit if nothing to do *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/smooth\/ftgrays.c","additions":148,"deletions":151,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-        lcd_filter_func( bitmap, mode, lcd_weights );\n+        lcd_filter_func( bitmap, lcd_weights );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/smooth\/ftsmooth.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,9 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+#define IS_DEFAULT_INSTANCE( _face )             \\\n+          ( !( FT_IS_NAMED_INSTANCE( _face ) ||  \\\n+               FT_IS_VARIATION( _face )      ) )\n+#else\n+#define IS_DEFAULT_INSTANCE( _face )  1\n+#endif\n+\n+\n@@ -930,0 +939,5 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+    FT_Memory   memory    = loader->face->root.memory;\n+    FT_Vector*  unrounded = NULL;\n+#endif\n+\n@@ -950,2 +964,1 @@\n-    if ( FT_IS_NAMED_INSTANCE( FT_FACE( loader->face ) ) ||\n-         FT_IS_VARIATION( FT_FACE( loader->face ) )      )\n+    if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )\n@@ -953,0 +966,3 @@\n+      if ( FT_NEW_ARRAY( unrounded, n_points ) )\n+        goto Exit;\n+\n@@ -957,0 +973,1 @@\n+                                          unrounded,\n@@ -961,0 +978,3 @@\n+\n+      \/* XXX: change all FreeType modules to store `linear' and `vadvance' *\/\n+      \/*      in 26.6 format before the `base' module scales them to 16.16 *\/\n@@ -962,2 +982,2 @@\n-        loader->linear = outline->points[n_points - 3].x -\n-                         outline->points[n_points - 4].x;\n+        loader->linear = FT_PIX_ROUND( unrounded[n_points - 3].x -\n+                                       unrounded[n_points - 4].x ) \/ 64;\n@@ -965,2 +985,2 @@\n-        loader->vadvance = outline->points[n_points - 1].x -\n-                           outline->points[n_points - 2].x;\n+        loader->vadvance = FT_PIX_ROUND( unrounded[n_points - 1].x -\n+                                         unrounded[n_points - 2].x ) \/ 64;\n@@ -969,1 +989,1 @@\n-        return error;\n+        goto Exit;\n@@ -1024,0 +1044,8 @@\n+          {\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+            FT_Vector*  orig_points = outline->points;\n+\n+\n+            if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )\n+              outline->points = unrounded;\n+#endif\n@@ -1028,0 +1056,5 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+            if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )\n+              outline->points = orig_points;\n+#endif\n+          }\n@@ -1048,1 +1081,2 @@\n-        for ( ; vec < limit; vec++ )\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+        if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )\n@@ -1050,2 +1084,17 @@\n-          vec->x = FT_MulFix( vec->x, x_scale );\n-          vec->y = FT_MulFix( vec->y, y_scale );\n+          FT_Vector*  u = unrounded;\n+\n+\n+          for ( ; vec < limit; vec++, u++ )\n+          {\n+            vec->x = ( FT_MulFix( u->x, x_scale ) + 32 ) >> 6;\n+            vec->y = ( FT_MulFix( u->y, y_scale ) + 32 ) >> 6;\n+          }\n+        }\n+        else\n+#endif \/* TT_CONFIG_OPTION_GX_VAR_SUPPORT *\/\n+        {\n+          for ( ; vec < limit; vec++ )\n+          {\n+            vec->x = FT_MulFix( vec->x, x_scale );\n+            vec->y = FT_MulFix( vec->y, y_scale );\n+          }\n@@ -1083,0 +1132,5 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+  Exit:\n+    FT_FREE( unrounded );\n+#endif\n+\n@@ -1684,0 +1738,3 @@\n+        \/* unrounded values *\/\n+        FT_Vector  unrounded[4] = { {0, 0}, {0, 0}, {0, 0}, {0, 0} };\n+\n@@ -1705,0 +1762,1 @@\n+                                            unrounded,\n@@ -1722,1 +1780,2 @@\n-          loader->linear = loader->pp2.x - loader->pp1.x;\n+          loader->linear = FT_PIX_ROUND( unrounded[1].x -\n+                                         unrounded[0].x ) \/ 64;\n@@ -1724,1 +1783,2 @@\n-          loader->vadvance = loader->pp4.x - loader->pp3.x;\n+          loader->vadvance = FT_PIX_ROUND( unrounded[3].x -\n+                                           unrounded[2].x ) \/ 64;\n@@ -1864,3 +1924,4 @@\n-        FT_Vector*  points   = NULL;\n-        char*       tags     = NULL;\n-        short*      contours = NULL;\n+        FT_Vector*  points    = NULL;\n+        char*       tags      = NULL;\n+        short*      contours  = NULL;\n+        FT_Vector*  unrounded = NULL;\n@@ -1880,3 +1941,4 @@\n-        if ( FT_NEW_ARRAY( points, outline.n_points )   ||\n-             FT_NEW_ARRAY( tags, outline.n_points )     ||\n-             FT_NEW_ARRAY( contours, outline.n_points ) )\n+        if ( FT_NEW_ARRAY( points, outline.n_points )    ||\n+             FT_NEW_ARRAY( tags, outline.n_points )      ||\n+             FT_NEW_ARRAY( contours, outline.n_points )  ||\n+             FT_NEW_ARRAY( unrounded, outline.n_points ) )\n@@ -1931,0 +1993,1 @@\n+                             unrounded,\n@@ -1958,1 +2021,3 @@\n-          loader->linear = loader->pp2.x - loader->pp1.x;\n+          loader->linear =\n+            FT_PIX_ROUND( unrounded[outline.n_points - 3].x -\n+                          unrounded[outline.n_points - 4].x ) \/ 64;\n@@ -1960,1 +2025,3 @@\n-          loader->vadvance = loader->pp4.x - loader->pp3.x;\n+          loader->vadvance =\n+            FT_PIX_ROUND( unrounded[outline.n_points - 1].x -\n+                          unrounded[outline.n_points - 2].x ) \/ 64;\n@@ -1966,0 +2033,1 @@\n+        FT_FREE( unrounded );\n@@ -2091,0 +2159,1 @@\n+             subglyph                        &&\n@@ -2614,5 +2683,0 @@\n-        FT_UInt  i;\n-\n-\n-        for ( i = 0; i < size->cvt_size; i++ )\n-          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );\n@@ -2721,7 +2785,0 @@\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-#define IS_DEFAULT_INSTANCE  ( !( FT_IS_NAMED_INSTANCE( glyph->face ) ||  \\\n-                                  FT_IS_VARIATION( glyph->face )      ) )\n-#else\n-#define IS_DEFAULT_INSTANCE  1\n-#endif\n-\n@@ -2736,1 +2793,1 @@\n-         IS_DEFAULT_INSTANCE                     )\n+         IS_DEFAULT_INSTANCE( glyph->face )      )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttgload.c","additions":90,"deletions":33,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -71,6 +71,10 @@\n-#define FT_fdot14ToFixed( x )                \\\n-        ( (FT_Fixed)( (FT_ULong)(x) << 2 ) )\n-#define FT_intToFixed( i )                    \\\n-        ( (FT_Fixed)( (FT_ULong)(i) << 16 ) )\n-#define FT_fixedToInt( x )                                   \\\n-        ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) >> 16 ) )\n+#define FT_fdot14ToFixed( x )                  \\\n+          ( (FT_Fixed)( (FT_ULong)(x) << 2 ) )\n+#define FT_intToFixed( i )                      \\\n+          ( (FT_Fixed)( (FT_ULong)(i) << 16 ) )\n+#define FT_fdot6ToFixed( i )                    \\\n+          ( (FT_Fixed)( (FT_ULong)(i) << 10 ) )\n+#define FT_fixedToInt( x )                          \\\n+          ( (FT_Short)( ( (x) + 0x8000U ) >> 16 ) )\n+#define FT_fixedToFdot6( x )                    \\\n+          ( (FT_Pos)( ( (x) + 0x200 ) >> 10 ) )\n@@ -400,3 +404,4 @@\n-        \/* convert to Fixed *\/\n-        segment->correspondence[j].fromCoord = FT_GET_SHORT() * 4;\n-        segment->correspondence[j].toCoord   = FT_GET_SHORT() * 4;\n+        segment->correspondence[j].fromCoord =\n+          FT_fdot14ToFixed( FT_GET_SHORT() );\n+        segment->correspondence[j].toCoord =\n+          FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -1619,1 +1624,1 @@\n-            FT_GET_SHORT() * 4;                 \/* convert to FT_Fixed *\/\n+            FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -3057,1 +3062,1 @@\n-    if ( instance_index > 0 && mmvar->namedstyle )\n+    if ( instance_index > 0 )\n@@ -3083,0 +3088,4 @@\n+      {\n+        \/* internal error code -1 means `no change' *\/\n+        if ( error == -1 )\n+          error = FT_Err_Ok;\n@@ -3084,0 +3093,1 @@\n+      }\n@@ -3106,0 +3116,15 @@\n+  static FT_Error\n+  tt_cvt_ready_iterator( FT_ListNode  node,\n+                         void*        user )\n+  {\n+    TT_Size  size = (TT_Size)node->data;\n+\n+    FT_UNUSED( user );\n+\n+\n+    size->cvt_ready = -1;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+\n@@ -3136,0 +3161,2 @@\n+    FT_Face  root = &face->root;\n+\n@@ -3264,2 +3291,1 @@\n-          tuple_coords[j] = FT_GET_SHORT() * 4;  \/* convert from        *\/\n-                                                 \/* short frac to fixed *\/\n+          tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -3296,1 +3322,1 @@\n-          im_start_coords[j] = FT_GET_SHORT() * 4;\n+          im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -3298,1 +3324,1 @@\n-          im_end_coords[j] = FT_GET_SHORT() * 4;\n+          im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -3363,1 +3389,1 @@\n-                        ( FT_intToFixed( face->cvt[j] ) +\n+                        ( FT_fdot6ToFixed( face->cvt[j] ) +\n@@ -3365,1 +3391,1 @@\n-                        ( FT_intToFixed( face->cvt[j] ) +\n+                        ( FT_fdot6ToFixed( face->cvt[j] ) +\n@@ -3405,1 +3431,1 @@\n-                        ( FT_intToFixed( face->cvt[pindex] ) +\n+                        ( FT_fdot6ToFixed( face->cvt[pindex] ) +\n@@ -3407,1 +3433,1 @@\n-                        ( FT_intToFixed( face->cvt[pindex] ) +\n+                        ( FT_fdot6ToFixed( face->cvt[pindex] ) +\n@@ -3432,1 +3458,1 @@\n-      face->cvt[i] += FT_fixedToInt( cvt_deltas[i] );\n+      face->cvt[i] += FT_fixedToFdot6( cvt_deltas[i] );\n@@ -3445,0 +3471,6 @@\n+    \/* iterate over all FT_Size objects and set `cvt_ready' to -1 *\/\n+    \/* to trigger rescaling of all CVT values                     *\/\n+    FT_List_Iterate( &root->sizes_list,\n+                     tt_cvt_ready_iterator,\n+                     NULL );\n+\n@@ -3672,0 +3704,5 @@\n+   * @Output:\n+   *   unrounded ::\n+   *     An array with `n_points' elements that is filled with unrounded\n+   *     point coordinates (in 26.6 format).\n+   *\n@@ -3679,0 +3716,1 @@\n+                              FT_Vector*   unrounded,\n@@ -3720,0 +3758,6 @@\n+    for ( i = 0; i < n_points; i++ )\n+    {\n+      unrounded[i].x = INT_TO_F26DOT6( outline->points[i].x );\n+      unrounded[i].y = INT_TO_F26DOT6( outline->points[i].y );\n+    }\n+\n@@ -3810,2 +3854,1 @@\n-          tuple_coords[j] = FT_GET_SHORT() * 4;   \/* convert from        *\/\n-                                                  \/* short frac to fixed *\/\n+          tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -3831,1 +3874,1 @@\n-          im_start_coords[j] = FT_GET_SHORT() * 4;\n+          im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -3833,1 +3876,1 @@\n-          im_end_coords[j] = FT_GET_SHORT() * 4;\n+          im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n@@ -4067,0 +4110,3 @@\n+      unrounded[i].x += FT_fixedToFdot6( point_deltas_x[i] );\n+      unrounded[i].y += FT_fixedToFdot6( point_deltas_y[i] );\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttgxvar.c","additions":70,"deletions":24,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -419,0 +419,1 @@\n+                              FT_Vector*   unrounded,\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttgxvar.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -657,15 +657,16 @@\n-    \/*  SVTCA  y  *\/  PACK( 0, 0 ),\n-    \/*  SVTCA  x  *\/  PACK( 0, 0 ),\n-    \/*  SPvTCA y  *\/  PACK( 0, 0 ),\n-    \/*  SPvTCA x  *\/  PACK( 0, 0 ),\n-    \/*  SFvTCA y  *\/  PACK( 0, 0 ),\n-    \/*  SFvTCA x  *\/  PACK( 0, 0 ),\n-    \/*  SPvTL \/\/  *\/  PACK( 2, 0 ),\n-    \/*  SPvTL +   *\/  PACK( 2, 0 ),\n-    \/*  SFvTL \/\/  *\/  PACK( 2, 0 ),\n-    \/*  SFvTL +   *\/  PACK( 2, 0 ),\n-    \/*  SPvFS     *\/  PACK( 2, 0 ),\n-    \/*  SFvFS     *\/  PACK( 2, 0 ),\n-    \/*  GPv       *\/  PACK( 0, 2 ),\n-    \/*  GFv       *\/  PACK( 0, 2 ),\n-    \/*  SFvTPv    *\/  PACK( 0, 0 ),\n+    \/* 0x00 *\/\n+    \/*  SVTCA[0]  *\/  PACK( 0, 0 ),\n+    \/*  SVTCA[1]  *\/  PACK( 0, 0 ),\n+    \/*  SPVTCA[0] *\/  PACK( 0, 0 ),\n+    \/*  SPVTCA[1] *\/  PACK( 0, 0 ),\n+    \/*  SFVTCA[0] *\/  PACK( 0, 0 ),\n+    \/*  SFVTCA[1] *\/  PACK( 0, 0 ),\n+    \/*  SPVTL[0]  *\/  PACK( 2, 0 ),\n+    \/*  SPVTL[1]  *\/  PACK( 2, 0 ),\n+    \/*  SFVTL[0]  *\/  PACK( 2, 0 ),\n+    \/*  SFVTL[1]  *\/  PACK( 2, 0 ),\n+    \/*  SPVFS     *\/  PACK( 2, 0 ),\n+    \/*  SFVFS     *\/  PACK( 2, 0 ),\n+    \/*  GPV       *\/  PACK( 0, 2 ),\n+    \/*  GFV       *\/  PACK( 0, 2 ),\n+    \/*  SFVTPV    *\/  PACK( 0, 0 ),\n@@ -674,0 +675,1 @@\n+    \/* 0x10 *\/\n@@ -687,2 +689,2 @@\n-    \/*  SCvTCi    *\/  PACK( 1, 0 ),\n-    \/*  SSwCi     *\/  PACK( 1, 0 ),\n+    \/*  SCVTCI    *\/  PACK( 1, 0 ),\n+    \/*  SSWCI     *\/  PACK( 1, 0 ),\n@@ -691,0 +693,1 @@\n+    \/* 0x20 *\/\n@@ -698,1 +701,1 @@\n-    \/*  AlignPTS  *\/  PACK( 2, 0 ),\n+    \/*  ALIGNPTS  *\/  PACK( 2, 0 ),\n@@ -708,0 +711,1 @@\n+    \/* 0x30 *\/\n@@ -720,1 +724,1 @@\n-    \/*  AlignRP   *\/  PACK( 0, 0 ), \/* loops *\/\n+    \/*  ALIGNRP   *\/  PACK( 0, 0 ), \/* loops *\/\n@@ -725,2 +729,3 @@\n-    \/*  NPushB    *\/  PACK( 0, 0 ),\n-    \/*  NPushW    *\/  PACK( 0, 0 ),\n+    \/* 0x40 *\/\n+    \/*  NPUSHB    *\/  PACK( 0, 0 ),\n+    \/*  NPUSHW    *\/  PACK( 0, 0 ),\n@@ -729,2 +734,2 @@\n-    \/*  WCvtP     *\/  PACK( 2, 0 ),\n-    \/*  RCvt      *\/  PACK( 1, 1 ),\n+    \/*  WCVTP     *\/  PACK( 2, 0 ),\n+    \/*  RCVT      *\/  PACK( 1, 1 ),\n@@ -738,2 +743,2 @@\n-    \/*  FlipON    *\/  PACK( 0, 0 ),\n-    \/*  FlipOFF   *\/  PACK( 0, 0 ),\n+    \/*  FLIPON    *\/  PACK( 0, 0 ),\n+    \/*  FLIPOFF   *\/  PACK( 0, 0 ),\n@@ -742,0 +747,1 @@\n+    \/* 0x50 *\/\n@@ -755,1 +761,1 @@\n-    \/*  DeltaP1   *\/  PACK( 1, 0 ),\n+    \/*  DELTAP1   *\/  PACK( 1, 0 ),\n@@ -759,0 +765,1 @@\n+    \/* 0x60 *\/\n@@ -776,6 +783,7 @@\n-    \/*  WCvtF     *\/  PACK( 2, 0 ),\n-    \/*  DeltaP2   *\/  PACK( 1, 0 ),\n-    \/*  DeltaP3   *\/  PACK( 1, 0 ),\n-    \/*  DeltaCn[0] *\/ PACK( 1, 0 ),\n-    \/*  DeltaCn[1] *\/ PACK( 1, 0 ),\n-    \/*  DeltaCn[2] *\/ PACK( 1, 0 ),\n+    \/* 0x70 *\/\n+    \/*  WCVTF     *\/  PACK( 2, 0 ),\n+    \/*  DELTAP2   *\/  PACK( 1, 0 ),\n+    \/*  DELTAP3   *\/  PACK( 1, 0 ),\n+    \/*  DELTAC1   *\/  PACK( 1, 0 ),\n+    \/*  DELTAC2   *\/  PACK( 1, 0 ),\n+    \/*  DELTAC3   *\/  PACK( 1, 0 ),\n@@ -783,1 +791,1 @@\n-    \/*  S45Round  *\/  PACK( 1, 0 ),\n+    \/*  S45ROUND  *\/  PACK( 1, 0 ),\n@@ -793,3 +801,4 @@\n-    \/*  FlipPT    *\/  PACK( 0, 0 ), \/* loops *\/\n-    \/*  FlipRgON  *\/  PACK( 2, 0 ),\n-    \/*  FlipRgOFF *\/  PACK( 2, 0 ),\n+    \/* 0x80 *\/\n+    \/*  FLIPPT    *\/  PACK( 0, 0 ), \/* loops *\/\n+    \/*  FLIPRGON  *\/  PACK( 2, 0 ),\n+    \/*  FLIPRGOFF *\/  PACK( 2, 0 ),\n@@ -798,4 +807,4 @@\n-    \/*  ScanCTRL  *\/  PACK( 1, 0 ),\n-    \/*  SDPvTL[0] *\/  PACK( 2, 0 ),\n-    \/*  SDPvTL[1] *\/  PACK( 2, 0 ),\n-    \/*  GetINFO   *\/  PACK( 1, 1 ),\n+    \/*  SCANCTRL  *\/  PACK( 1, 0 ),\n+    \/*  SDPVTL[0] *\/  PACK( 2, 0 ),\n+    \/*  SDPVTL[1] *\/  PACK( 2, 0 ),\n+    \/*  GETINFO   *\/  PACK( 1, 1 ),\n@@ -806,2 +815,2 @@\n-    \/*  ScanTYPE  *\/  PACK( 1, 0 ),\n-    \/*  InstCTRL  *\/  PACK( 2, 0 ),\n+    \/*  SCANTYPE  *\/  PACK( 1, 0 ),\n+    \/*  INSTCTRL  *\/  PACK( 2, 0 ),\n@@ -810,0 +819,1 @@\n+    \/* 0x90 *\/\n@@ -827,0 +837,1 @@\n+    \/* 0xA0 *\/\n@@ -844,17 +855,19 @@\n-    \/*  PushB[0]  *\/  PACK( 0, 1 ),\n-    \/*  PushB[1]  *\/  PACK( 0, 2 ),\n-    \/*  PushB[2]  *\/  PACK( 0, 3 ),\n-    \/*  PushB[3]  *\/  PACK( 0, 4 ),\n-    \/*  PushB[4]  *\/  PACK( 0, 5 ),\n-    \/*  PushB[5]  *\/  PACK( 0, 6 ),\n-    \/*  PushB[6]  *\/  PACK( 0, 7 ),\n-    \/*  PushB[7]  *\/  PACK( 0, 8 ),\n-    \/*  PushW[0]  *\/  PACK( 0, 1 ),\n-    \/*  PushW[1]  *\/  PACK( 0, 2 ),\n-    \/*  PushW[2]  *\/  PACK( 0, 3 ),\n-    \/*  PushW[3]  *\/  PACK( 0, 4 ),\n-    \/*  PushW[4]  *\/  PACK( 0, 5 ),\n-    \/*  PushW[5]  *\/  PACK( 0, 6 ),\n-    \/*  PushW[6]  *\/  PACK( 0, 7 ),\n-    \/*  PushW[7]  *\/  PACK( 0, 8 ),\n-\n+    \/* 0xB0 *\/\n+    \/*  PUSHB[0]  *\/  PACK( 0, 1 ),\n+    \/*  PUSHB[1]  *\/  PACK( 0, 2 ),\n+    \/*  PUSHB[2]  *\/  PACK( 0, 3 ),\n+    \/*  PUSHB[3]  *\/  PACK( 0, 4 ),\n+    \/*  PUSHB[4]  *\/  PACK( 0, 5 ),\n+    \/*  PUSHB[5]  *\/  PACK( 0, 6 ),\n+    \/*  PUSHB[6]  *\/  PACK( 0, 7 ),\n+    \/*  PUSHB[7]  *\/  PACK( 0, 8 ),\n+    \/*  PUSHW[0]  *\/  PACK( 0, 1 ),\n+    \/*  PUSHW[1]  *\/  PACK( 0, 2 ),\n+    \/*  PUSHW[2]  *\/  PACK( 0, 3 ),\n+    \/*  PUSHW[3]  *\/  PACK( 0, 4 ),\n+    \/*  PUSHW[4]  *\/  PACK( 0, 5 ),\n+    \/*  PUSHW[5]  *\/  PACK( 0, 6 ),\n+    \/*  PUSHW[6]  *\/  PACK( 0, 7 ),\n+    \/*  PUSHW[7]  *\/  PACK( 0, 8 ),\n+\n+    \/* 0xC0 *\/\n@@ -878,0 +891,1 @@\n+    \/* 0xD0 *\/\n@@ -895,0 +909,1 @@\n+    \/* 0xE0 *\/\n@@ -912,0 +927,1 @@\n+    \/* 0xF0 *\/\n@@ -940,15 +956,16 @@\n-    \"7 SVTCA y\",\n-    \"7 SVTCA x\",\n-    \"8 SPvTCA y\",\n-    \"8 SPvTCA x\",\n-    \"8 SFvTCA y\",\n-    \"8 SFvTCA x\",\n-    \"8 SPvTL ||\",\n-    \"7 SPvTL +\",\n-    \"8 SFvTL ||\",\n-    \"7 SFvTL +\",\n-    \"5 SPvFS\",\n-    \"5 SFvFS\",\n-    \"3 GPv\",\n-    \"3 GFv\",\n-    \"6 SFvTPv\",\n+    \/* 0x00 *\/\n+    \"8 SVTCA[y]\",\n+    \"8 SVTCA[x]\",\n+    \"9 SPVTCA[y]\",\n+    \"9 SPVTCA[x]\",\n+    \"9 SFVTCA[y]\",\n+    \"9 SFVTCA[x]\",\n+    \"9 SPVTL[||]\",\n+    \"8 SPVTL[+]\",\n+    \"9 SFVTL[||]\",\n+    \"8 SFVTL[+]\",\n+    \"5 SPVFS\",\n+    \"5 SFVFS\",\n+    \"3 GPV\",\n+    \"3 GFV\",\n+    \"6 SFVTPV\",\n@@ -957,0 +974,1 @@\n+    \/* 0x10 *\/\n@@ -970,2 +988,2 @@\n-    \"6 SCvTCi\",\n-    \"5 SSwCi\",\n+    \"6 SCVTCI\",\n+    \"5 SSWCI\",\n@@ -974,0 +992,1 @@\n+    \/* 0x20 *\/\n@@ -981,1 +1000,1 @@\n-    \"8 AlignPTS\",\n+    \"8 ALIGNPTS\",\n@@ -988,11 +1007,12 @@\n-    \"7 MDAP[0]\",\n-    \"7 MDAP[1]\",\n-\n-    \"6 IUP[0]\",\n-    \"6 IUP[1]\",\n-    \"6 SHP[0]\",\n-    \"6 SHP[1]\",\n-    \"6 SHC[0]\",\n-    \"6 SHC[1]\",\n-    \"6 SHZ[0]\",\n-    \"6 SHZ[1]\",\n+    \"6 MDAP[]\",\n+    \"9 MDAP[rnd]\",\n+\n+    \/* 0x30 *\/\n+    \"6 IUP[y]\",\n+    \"6 IUP[x]\",\n+    \"8 SHP[rp2]\",\n+    \"8 SHP[rp1]\",\n+    \"8 SHC[rp2]\",\n+    \"8 SHC[rp1]\",\n+    \"8 SHZ[rp2]\",\n+    \"8 SHZ[rp1]\",\n@@ -1001,3 +1021,3 @@\n-    \"8 MSIRP[0]\",\n-    \"8 MSIRP[1]\",\n-    \"7 AlignRP\",\n+    \"7 MSIRP[]\",\n+    \"A MSIRP[rp0]\",\n+    \"7 ALIGNRP\",\n@@ -1005,2 +1025,2 @@\n-    \"7 MIAP[0]\",\n-    \"7 MIAP[1]\",\n+    \"6 MIAP[]\",\n+    \"9 MIAP[rnd]\",\n@@ -1008,2 +1028,3 @@\n-    \"6 NPushB\",\n-    \"6 NPushW\",\n+    \/* 0x40 *\/\n+    \"6 NPUSHB\",\n+    \"6 NPUSHW\",\n@@ -1012,4 +1033,4 @@\n-    \"5 WCvtP\",\n-    \"4 RCvt\",\n-    \"5 GC[0]\",\n-    \"5 GC[1]\",\n+    \"5 WCVTP\",\n+    \"4 RCVT\",\n+    \"8 GC[curr]\",\n+    \"8 GC[orig]\",\n@@ -1017,2 +1038,2 @@\n-    \"5 MD[0]\",\n-    \"5 MD[1]\",\n+    \"8 MD[curr]\",\n+    \"8 MD[orig]\",\n@@ -1021,2 +1042,2 @@\n-    \"6 FlipON\",\n-    \"7 FlipOFF\",\n+    \"6 FLIPON\",\n+    \"7 FLIPOFF\",\n@@ -1025,0 +1046,1 @@\n+    \/* 0x50 *\/\n@@ -1038,1 +1060,1 @@\n-    \"7 DeltaP1\",\n+    \"7 DELTAP1\",\n@@ -1042,0 +1064,1 @@\n+    \/* 0x60 *\/\n@@ -1050,15 +1073,16 @@\n-    \"8 ROUND[0]\",\n-    \"8 ROUND[1]\",\n-    \"8 ROUND[2]\",\n-    \"8 ROUND[3]\",\n-    \"9 NROUND[0]\",\n-    \"9 NROUND[1]\",\n-    \"9 NROUND[2]\",\n-    \"9 NROUND[3]\",\n-\n-    \"5 WCvtF\",\n-    \"7 DeltaP2\",\n-    \"7 DeltaP3\",\n-    \"A DeltaCn[0]\",\n-    \"A DeltaCn[1]\",\n-    \"A DeltaCn[2]\",\n+    \"8 ROUND[G]\",\n+    \"8 ROUND[B]\",\n+    \"8 ROUND[W]\",\n+    \"7 ROUND[]\",\n+    \"9 NROUND[G]\",\n+    \"9 NROUND[B]\",\n+    \"9 NROUND[W]\",\n+    \"8 NROUND[]\",\n+\n+    \/* 0x70 *\/\n+    \"5 WCVTF\",\n+    \"7 DELTAP2\",\n+    \"7 DELTAP3\",\n+    \"7 DELTAC1\",\n+    \"7 DELTAC2\",\n+    \"7 DELTAC3\",\n@@ -1066,1 +1090,1 @@\n-    \"8 S45Round\",\n+    \"8 S45ROUND\",\n@@ -1076,3 +1100,4 @@\n-    \"6 FlipPT\",\n-    \"8 FlipRgON\",\n-    \"9 FlipRgOFF\",\n+    \/* 0x80 *\/\n+    \"6 FLIPPT\",\n+    \"8 FLIPRGON\",\n+    \"9 FLIPRGOFF\",\n@@ -1081,4 +1106,4 @@\n-    \"8 ScanCTRL\",\n-    \"9 SDPvTL[0]\",\n-    \"9 SDPvTL[1]\",\n-    \"7 GetINFO\",\n+    \"8 SCANCTRL\",\n+    \"A SDPVTL[||]\",\n+    \"9 SDPVTL[+]\",\n+    \"7 GETINFO\",\n@@ -1089,2 +1114,2 @@\n-    \"8 ScanTYPE\",\n-    \"8 InstCTRL\",\n+    \"8 SCANTYPE\",\n+    \"8 INSTCTRL\",\n@@ -1093,0 +1118,1 @@\n+    \/* 0x90 *\/\n@@ -1095,1 +1121,1 @@\n-    \"6 GETVAR\",\n+    \"C GETVARIATION\",\n@@ -1115,0 +1141,1 @@\n+    \/* 0xA0 *\/\n@@ -1132,17 +1159,19 @@\n-    \"8 PushB[0]\",\n-    \"8 PushB[1]\",\n-    \"8 PushB[2]\",\n-    \"8 PushB[3]\",\n-    \"8 PushB[4]\",\n-    \"8 PushB[5]\",\n-    \"8 PushB[6]\",\n-    \"8 PushB[7]\",\n-    \"8 PushW[0]\",\n-    \"8 PushW[1]\",\n-    \"8 PushW[2]\",\n-    \"8 PushW[3]\",\n-    \"8 PushW[4]\",\n-    \"8 PushW[5]\",\n-    \"8 PushW[6]\",\n-    \"8 PushW[7]\",\n-\n+    \/* 0xB0 *\/\n+    \"8 PUSHB[0]\",\n+    \"8 PUSHB[1]\",\n+    \"8 PUSHB[2]\",\n+    \"8 PUSHB[3]\",\n+    \"8 PUSHB[4]\",\n+    \"8 PUSHB[5]\",\n+    \"8 PUSHB[6]\",\n+    \"8 PUSHB[7]\",\n+    \"8 PUSHW[0]\",\n+    \"8 PUSHW[1]\",\n+    \"8 PUSHW[2]\",\n+    \"8 PUSHW[3]\",\n+    \"8 PUSHW[4]\",\n+    \"8 PUSHW[5]\",\n+    \"8 PUSHW[6]\",\n+    \"8 PUSHW[7]\",\n+\n+    \/* 0xC0 *\/\n@@ -1152,1 +1181,1 @@\n-    \"7 MDRP[?]\",\n+    \"6 MDRP[]\",\n@@ -1156,1 +1185,1 @@\n-    \"8 MDRP[r?]\",\n+    \"7 MDRP[r]\",\n@@ -1160,1 +1189,1 @@\n-    \"8 MDRP[m?]\",\n+    \"7 MDRP[m]\",\n@@ -1164,1 +1193,1 @@\n-    \"9 MDRP[mr?]\",\n+    \"8 MDRP[mr]\",\n@@ -1166,0 +1195,1 @@\n+    \/* 0xD0 *\/\n@@ -1169,1 +1199,1 @@\n-    \"8 MDRP[p?]\",\n+    \"7 MDRP[p]\",\n@@ -1173,1 +1203,1 @@\n-    \"9 MDRP[pr?]\",\n+    \"8 MDRP[pr]\",\n@@ -1177,1 +1207,1 @@\n-    \"9 MDRP[pm?]\",\n+    \"8 MDRP[pm]\",\n@@ -1181,1 +1211,1 @@\n-    \"A MDRP[pmr?]\",\n+    \"9 MDRP[pmr]\",\n@@ -1183,0 +1213,1 @@\n+    \/* 0xE0 *\/\n@@ -1186,1 +1217,1 @@\n-    \"7 MIRP[?]\",\n+    \"6 MIRP[]\",\n@@ -1190,1 +1221,1 @@\n-    \"8 MIRP[r?]\",\n+    \"7 MIRP[r]\",\n@@ -1194,1 +1225,1 @@\n-    \"8 MIRP[m?]\",\n+    \"7 MIRP[m]\",\n@@ -1198,1 +1229,1 @@\n-    \"9 MIRP[mr?]\",\n+    \"8 MIRP[mr]\",\n@@ -1200,0 +1231,1 @@\n+    \/* 0xF0 *\/\n@@ -1203,1 +1235,1 @@\n-    \"8 MIRP[p?]\",\n+    \"7 MIRP[p]\",\n@@ -1207,1 +1239,1 @@\n-    \"9 MIRP[pr?]\",\n+    \"8 MIRP[pr]\",\n@@ -1211,1 +1243,1 @@\n-    \"9 MIRP[pm?]\",\n+    \"8 MIRP[pm]\",\n@@ -1215,1 +1247,1 @@\n-    \"A MIRP[pmr?]\"\n+    \"9 MIRP[pmr]\"\n@@ -1665,0 +1697,26 @@\n+  \/*\n+   *\n+   * Apple's TrueType specification at\n+   *\n+   *   https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM02\/Chap2.html#order\n+   *\n+   * gives the following order of operations in instructions that move\n+   * points.\n+   *\n+   *   - check single width cut-in (MIRP, MDRP)\n+   *\n+   *   - check control value cut-in (MIRP, MIAP)\n+   *\n+   *   - apply engine compensation (MIRP, MDRP)\n+   *\n+   *   - round distance (MIRP, MDRP) or value (MIAP, MDAP)\n+   *\n+   *   - check minimum distance (MIRP,MDRP)\n+   *\n+   *   - move point (MIRP, MDRP, MIAP, MSIRP, MDAP)\n+   *\n+   * For rounding instructions, engine compensation happens before rounding.\n+   *\n+   *\/\n+\n+\n@@ -1889,1 +1947,0 @@\n-\n@@ -1907,6 +1964,0 @@\n-   *\n-   * @Note:\n-   *   The TrueType specification says very few about the relationship\n-   *   between rounding and engine compensation.  However, it seems from\n-   *   the description of super round that we should add the compensation\n-   *   before rounding.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttinterp.c","additions":221,"deletions":170,"binary":false,"changes":391,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  tt_check_trickyness_family( FT_String*  name )\n+  tt_check_trickyness_family( const FT_String*  name )\n@@ -940,0 +940,1 @@\n+    FT_UInt         i;\n@@ -941,0 +942,14 @@\n+    \/* unscaled CVT values are already stored in 26.6 format *\/\n+    FT_Fixed  scale = size->ttmetrics.scale >> 6;\n+\n+\n+    \/* Scale the cvt values to the new ppem.            *\/\n+    \/* By default, we use the y ppem value for scaling. *\/\n+    FT_TRACE6(( \"CVT values:\\n\" ));\n+    for ( i = 0; i < size->cvt_size; i++ )\n+    {\n+      size->cvt[i] = FT_MulFix( face->cvt[i], scale );\n+      FT_TRACE6(( \"  %3d: %f (%f)\\n\",\n+                  i, face->cvt[i] \/ 64.0, size->cvt[i] \/ 64.0 ));\n+    }\n+    FT_TRACE6(( \"\\n\" ));\n@@ -1097,5 +1112,11 @@\n-      \/* set default engine compensation *\/\n-      tt_metrics->compensations[0] = 0;   \/* gray     *\/\n-      tt_metrics->compensations[1] = 0;   \/* black    *\/\n-      tt_metrics->compensations[2] = 0;   \/* white    *\/\n-      tt_metrics->compensations[3] = 0;   \/* reserved *\/\n+      \/* Set default engine compensation.  Value 3 is not described *\/\n+      \/* in the OpenType specification (as of Mai 2019), but Greg   *\/\n+      \/* says that MS handles it the same as `gray'.                *\/\n+      \/*                                                            *\/\n+      \/* The Apple specification says that the compensation for     *\/\n+      \/* `gray' is always zero.  FreeType doesn't do any            *\/\n+      \/* compensation at all.                                       *\/\n+      tt_metrics->compensations[0] = 0;   \/* gray             *\/\n+      tt_metrics->compensations[1] = 0;   \/* black            *\/\n+      tt_metrics->compensations[2] = 0;   \/* white            *\/\n+      tt_metrics->compensations[3] = 0;   \/* the same as gray *\/\n@@ -1174,1 +1195,0 @@\n-      TT_Face  face = (TT_Face)size->root.face;\n@@ -1177,11 +1197,0 @@\n-      \/* Scale the cvt values to the new ppem.            *\/\n-      \/* By default, we use the y ppem value for scaling. *\/\n-      FT_TRACE6(( \"CVT values:\\n\" ));\n-      for ( i = 0; i < size->cvt_size; i++ )\n-      {\n-        size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );\n-        FT_TRACE6(( \"  %3d: %d (%f)\\n\",\n-                    i, face->cvt[i], size->cvt[i] \/ 64.0 ));\n-      }\n-      FT_TRACE6(( \"\\n\" ));\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttobjs.c","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -355,2 +355,2 @@\n-      FT_Short*  cur   = face->cvt;\n-      FT_Short*  limit = cur + face->cvt_size;\n+      FT_Int32*  cur   = face->cvt;\n+      FT_Int32*  limit = cur + face->cvt_size;\n@@ -360,1 +360,1 @@\n-        *cur = FT_GET_SHORT();\n+        *cur = FT_GET_SHORT() * 64;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttpload.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-  t1_get_name_index( T1_Face     face,\n-                     FT_String*  glyph_name )\n+  t1_get_name_index( T1_Face           face,\n+                     const FT_String*  glyph_name )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1driver.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1510,6 +1510,1 @@\n-      {\n-        char*  notdef = (char *)\".notdef\";\n-\n-\n-        (void)T1_Add_Table( char_table, n, notdef, 8 );\n-      }\n+        (void)T1_Add_Table( char_table, n, \".notdef\", 8 );\n@@ -2150,1 +2145,0 @@\n-      char*    notdef_name    = (char *)\".notdef\";\n@@ -2165,1 +2159,1 @@\n-      error = T1_Add_Table( name_table, 0, notdef_name, 8 );\n+      error = T1_Add_Table( name_table, 0, \".notdef\", 8 );\n@@ -2636,2 +2630,1 @@\n-      FT_Int    charcode, idx, min_char, max_char;\n-      FT_Byte*  glyph_name;\n+      FT_Int  charcode, idx, min_char, max_char;\n@@ -2651,1 +2644,2 @@\n-        FT_Byte*  char_name;\n+        const FT_String*  char_name =\n+              (const FT_String*)loader.encoding_table.elements[charcode];\n@@ -2655,1 +2649,1 @@\n-        type1->encoding.char_name [charcode] = (char *)\".notdef\";\n+        type1->encoding.char_name [charcode] = \".notdef\";\n@@ -2657,1 +2651,0 @@\n-        char_name = loader.encoding_table.elements[charcode];\n@@ -2661,3 +2654,4 @@\n-            glyph_name = (FT_Byte*)type1->glyph_names[idx];\n-            if ( ft_strcmp( (const char*)char_name,\n-                            (const char*)glyph_name ) == 0 )\n+            const FT_String*  glyph_name = type1->glyph_names[idx];\n+\n+\n+            if ( ft_strcmp( char_name, glyph_name ) == 0 )\n@@ -2666,1 +2660,1 @@\n-              type1->encoding.char_name [charcode] = (char*)glyph_name;\n+              type1->encoding.char_name [charcode] = glyph_name;\n@@ -2670,2 +2664,1 @@\n-              if ( ft_strcmp( (const char*)\".notdef\",\n-                              (const char*)glyph_name ) != 0 )\n+              if ( ft_strcmp( \".notdef\", glyph_name ) != 0 )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1load.c","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"}]}