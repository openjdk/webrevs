{"files":[{"patch":"@@ -58,0 +58,1 @@\n+#include \"jvm.h\"\n@@ -379,3 +380,3 @@\n- * Macro to perform a blocking IO operation. Restarts\n- * automatically if interrupted by signal (other than\n- * our wakeup signal)\n+ * Macro to perform a blocking IO operation.\n+ * If interrupted by signal (other than our wakeup signal), and if RETRY is true,\n+ * then restarts automatically\n@@ -383,14 +384,14 @@\n-#define BLOCKING_IO_RETURN_INT(FD, FUNC) {      \\\n-    int ret;                                    \\\n-    threadEntry_t self;                         \\\n-    fdEntry_t *fdEntry = getFdEntry(FD);        \\\n-    if (fdEntry == NULL) {                      \\\n-        errno = EBADF;                          \\\n-        return -1;                              \\\n-    }                                           \\\n-    do {                                        \\\n-        startOp(fdEntry, &self);                \\\n-        ret = FUNC;                             \\\n-        endOp(fdEntry, &self);                  \\\n-    } while (ret == -1 && errno == EINTR);      \\\n-    return ret;                                 \\\n+#define BLOCKING_IO_RETURN_INT(FD, FUNC, RETRY) {     \\\n+    int ret;                                          \\\n+    threadEntry_t self;                               \\\n+    fdEntry_t *fdEntry = getFdEntry(FD);              \\\n+    if (fdEntry == NULL) {                            \\\n+        errno = EBADF;                                \\\n+        return -1;                                    \\\n+    }                                                 \\\n+    do {                                              \\\n+        startOp(fdEntry, &self);                      \\\n+        ret = FUNC;                                   \\\n+        endOp(fdEntry, &self);                        \\\n+    } while ((RETRY) && ret == -1 && errno == EINTR); \\\n+    return ret;                                       \\\n@@ -400,1 +401,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n+    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0), JNI_TRUE );\n@@ -404,1 +405,1 @@\n-    BLOCKING_IO_RETURN_INT(s, recv(s, buf, len, MSG_NONBLOCK));\n+    BLOCKING_IO_RETURN_INT(s, recv(s, buf, len, MSG_NONBLOCK), JNI_TRUE );\n@@ -408,1 +409,1 @@\n-    BLOCKING_IO_RETURN_INT( s, readv(s, vector, count) );\n+    BLOCKING_IO_RETURN_INT( s, readv(s, vector, count), JNI_TRUE );\n@@ -414,1 +415,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &socklen) );\n+    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &socklen), JNI_TRUE );\n@@ -419,1 +420,1 @@\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n+    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags), JNI_TRUE );\n@@ -423,1 +424,1 @@\n-    BLOCKING_IO_RETURN_INT( s, writev(s, vector, count) );\n+    BLOCKING_IO_RETURN_INT( s, writev(s, vector, count), JNI_TRUE );\n@@ -428,1 +429,1 @@\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n+    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen), JNI_TRUE );\n@@ -433,1 +434,1 @@\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, &socklen) );\n+    BLOCKING_IO_RETURN_INT( s, accept(s, addr, &socklen), JNI_TRUE );\n@@ -493,1 +494,1 @@\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n+    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout), JNI_FALSE );\n@@ -499,1 +500,1 @@\n-                            select(s, readfds, writefds, exceptfds, timeout) );\n+                            select(s, readfds, writefds, exceptfds, timeout), JNI_TRUE );\n","filename":"jdk\/src\/aix\/native\/java\/net\/aix_close.c","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"jvm.h\"\n@@ -350,3 +351,3 @@\n- * Macro to perform a blocking IO operation. Restarts\n- * automatically if interrupted by signal (other than\n- * our wakeup signal)\n+ * Macro to perform a blocking IO operation.\n+ * If interrupted by signal (other than our wakeup signal), and if RETRY is true,\n+ * then restarts automatically\n@@ -354,14 +355,14 @@\n-#define BLOCKING_IO_RETURN_INT(FD, FUNC) {      \\\n-    int ret;                                    \\\n-    threadEntry_t self;                         \\\n-    fdEntry_t *fdEntry = getFdEntry(FD);        \\\n-    if (fdEntry == NULL) {                      \\\n-        errno = EBADF;                          \\\n-        return -1;                              \\\n-    }                                           \\\n-    do {                                        \\\n-        startOp(fdEntry, &self);                \\\n-        ret = FUNC;                             \\\n-        endOp(fdEntry, &self);                  \\\n-    } while (ret == -1 && errno == EINTR);      \\\n-    return ret;                                 \\\n+#define BLOCKING_IO_RETURN_INT(FD, FUNC, RETRY) {     \\\n+    int ret;                                          \\\n+    threadEntry_t self;                               \\\n+    fdEntry_t *fdEntry = getFdEntry(FD);              \\\n+    if (fdEntry == NULL) {                            \\\n+        errno = EBADF;                                \\\n+        return -1;                                    \\\n+    }                                                 \\\n+    do {                                              \\\n+        startOp(fdEntry, &self);                      \\\n+        ret = FUNC;                                   \\\n+        endOp(fdEntry, &self);                        \\\n+    } while ((RETRY) && ret == -1 && errno == EINTR); \\\n+    return ret;                                       \\\n@@ -371,1 +372,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n+    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0), JNI_TRUE );\n@@ -375,1 +376,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT));\n+    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT), JNI_TRUE );\n@@ -379,1 +380,1 @@\n-    BLOCKING_IO_RETURN_INT( s, readv(s, vector, count) );\n+    BLOCKING_IO_RETURN_INT( s, readv(s, vector, count), JNI_TRUE );\n@@ -385,1 +386,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, (socklen_t *)fromlen) );\n+    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, (socklen_t *)fromlen), JNI_TRUE );\n@@ -389,1 +390,1 @@\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n+    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags), JNI_TRUE );\n@@ -393,1 +394,1 @@\n-    BLOCKING_IO_RETURN_INT( s, writev(s, vector, count) );\n+    BLOCKING_IO_RETURN_INT( s, writev(s, vector, count), JNI_TRUE );\n@@ -398,1 +399,1 @@\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n+    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen), JNI_TRUE );\n@@ -406,1 +407,1 @@\n-    BLOCKING_IO_RETURN_INT( s, error );\n+    BLOCKING_IO_RETURN_INT( s, error, JNI_FALSE );\n@@ -410,1 +411,1 @@\n-    BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen) );\n+    BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen), JNI_TRUE );\n@@ -415,1 +416,1 @@\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n+    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout), JNI_FALSE );\n@@ -421,1 +422,1 @@\n-                            select(s, readfds, writefds, exceptfds, timeout) );\n+                            select(s, readfds, writefds, exceptfds, timeout), JNI_TRUE );\n","filename":"jdk\/src\/solaris\/native\/java\/net\/bsd_close.c","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"jvm.h\"\n@@ -346,3 +347,3 @@\n- * Macro to perform a blocking IO operation. Restarts\n- * automatically if interrupted by signal (other than\n- * our wakeup signal)\n+ * Macro to perform a blocking IO operation.\n+ * If interrupted by signal (other than our wakeup signal), and if RETRY is true,\n+ * then restarts automatically\n@@ -350,14 +351,14 @@\n-#define BLOCKING_IO_RETURN_INT(FD, FUNC) {      \\\n-    int ret;                                    \\\n-    threadEntry_t self;                         \\\n-    fdEntry_t *fdEntry = getFdEntry(FD);        \\\n-    if (fdEntry == NULL) {                      \\\n-        errno = EBADF;                          \\\n-        return -1;                              \\\n-    }                                           \\\n-    do {                                        \\\n-        startOp(fdEntry, &self);                \\\n-        ret = FUNC;                             \\\n-        endOp(fdEntry, &self);                  \\\n-    } while (ret == -1 && errno == EINTR);      \\\n-    return ret;                                 \\\n+#define BLOCKING_IO_RETURN_INT(FD, FUNC, RETRY) {     \\\n+    int ret;                                          \\\n+    threadEntry_t self;                               \\\n+    fdEntry_t *fdEntry = getFdEntry(FD);              \\\n+    if (fdEntry == NULL) {                            \\\n+        errno = EBADF;                                \\\n+        return -1;                                    \\\n+    }                                                 \\\n+    do {                                              \\\n+        startOp(fdEntry, &self);                      \\\n+        ret = FUNC;                                   \\\n+        endOp(fdEntry, &self);                        \\\n+    } while ((RETRY) && ret == -1 && errno == EINTR); \\\n+    return ret;                                       \\\n@@ -367,1 +368,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n+    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0), JNI_TRUE );\n@@ -371,1 +372,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT) );\n+    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT), JNI_TRUE );\n@@ -375,1 +376,1 @@\n-    BLOCKING_IO_RETURN_INT( s, readv(s, vector, count) );\n+    BLOCKING_IO_RETURN_INT( s, readv(s, vector, count), JNI_TRUE );\n@@ -381,1 +382,1 @@\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &socklen) );\n+    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &socklen), JNI_TRUE );\n@@ -386,1 +387,1 @@\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n+    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags), JNI_TRUE );\n@@ -390,1 +391,1 @@\n-    BLOCKING_IO_RETURN_INT( s, writev(s, vector, count) );\n+    BLOCKING_IO_RETURN_INT( s, writev(s, vector, count), JNI_TRUE );\n@@ -395,1 +396,1 @@\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n+    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen), JNI_TRUE );\n@@ -400,1 +401,1 @@\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, &socklen) );\n+    BLOCKING_IO_RETURN_INT( s, accept(s, addr, &socklen), JNI_TRUE );\n@@ -405,1 +406,1 @@\n-    BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen) );\n+    BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen), JNI_TRUE );\n@@ -410,1 +411,1 @@\n-    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout) );\n+    BLOCKING_IO_RETURN_INT( ufds[0].fd, poll(ufds, nfds, timeout), JNI_FALSE );\n@@ -416,1 +417,1 @@\n-                            select(s, readfds, writefds, exceptfds, timeout) );\n+                            select(s, readfds, writefds, exceptfds, timeout), JNI_TRUE );\n","filename":"jdk\/src\/solaris\/native\/java\/net\/linux_close.c","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8312065\n+ * @summary Socket.connect does not timeout as expected when profiling (i.e. keep receiving signal)\n+ * @requires (os.family != \"windows\")\n+ * @build B8312065\n+ * @run shell B8312065.sh\n+ *\/\n+\n+import sun.misc.Signal;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class B8312065 {\n+    public static void main(String[] args) throws Exception {\n+        System.loadLibrary(\"NativeThread\");\n+\n+        \/\/ Setup SIGPIPE handler\n+        Signal.handle(new Signal(\"PIPE\"), System.out::println);\n+\n+        long osThreadId = NativeThread.getID();\n+\n+        int timeoutMillis = 2000;\n+        int n = 10;\n+        Thread t = new Thread(() -> {\n+            \/\/ Send SIGPIPE to the thread every second\n+            for (int i = 0; i < n; i++) {\n+                if (NativeThread.signal(osThreadId, NativeThread.SIGPIPE) != 0) {\n+                    System.out.println(\"Test FAILED: failed to send signal\");\n+                    System.exit(1);\n+                }\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException e) {\n+                    System.out.println(\"Test FAILED: unexpected interrupt\");\n+                    System.exit(1);\n+                }\n+            }\n+            System.out.println(\"Test FAILED: Socket.connect blocked \" + n + \" seconds, \" +\n+                    \"expected around \" + timeoutMillis \/ 1000 + \" seconds\");\n+            System.exit(1);\n+        });\n+        t.setDaemon(true);\n+        t.start();\n+\n+        long startTime = System.nanoTime();\n+\n+        try {\n+            Socket socket = new Socket();\n+            \/\/ There is no good way to mock SocketTimeoutException, just assume 192.168.255.255 is not in use\n+            socket.connect(new InetSocketAddress(\"192.168.255.255\", 8080), timeoutMillis);\n+        } catch (SocketTimeoutException e) {\n+            long duration = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n+            if (duration >= timeoutMillis) {\n+                System.out.println(\"Test passed\");\n+            } else {\n+                System.out.println(\"Test FAILED: duration \" + duration + \" ms, expected >= \" + timeoutMillis + \" ms\");\n+                System.exit(1);\n+            }\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/net\/Socket\/B8312065.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+#!\/bin\/bash\n+\n+set -ex\n+\n+if [ \"x$TESTGCC\" = \"x\" ]; then\n+  TESTGCC=$(readlink -f $(which gcc))\n+fi\n+\n+if [ \"x$TESTGCC\" = \"x\" ]; then\n+  echo \"WARNING: gcc not found. Cannot execute test.\" 2>&1\n+  exit 1;\n+fi\n+\n+if [ \"x$TESTROOT\" = \"x\" ]; then\n+  echo \"TESTROOT pointintg to top level sources is not set. that is fatal\"\n+  exit 2;\n+fi\n+\n+if [ \"x$TESTJAVA\" = \"x\" ]; then\n+  TESTJAVA=$(dirname $(dirname $(readlink -f $(which java))))\n+fi\n+\n+JDK_TOPDIR=\"${TESTROOT}\/..\"\n+JAVA=\"${TESTJAVA}\/bin\/java\"\n+TEST_ENV_SH=\"${JDK_TOPDIR}\/..\/hotspot\/test\/test_env.sh\"\n+\n+ls -l \"${TEST_ENV_SH}\"\n+set +e\n+  . \"${TEST_ENV_SH}\"\n+set -e\n+\n+\"${TESTGCC}\" \\\n+    -fPIC \\\n+    -shared \\\n+    ${CFLAGBITS} \\\n+    -o ${TESTCLASSES}\/libNativeThread.so \\\n+    -I${JDK_TOPDIR}\/src\/share\/bin \\\n+    -I${JDK_TOPDIR}\/src\/share\/javavm\/export \\\n+    -I${JDK_TOPDIR}\/src\/macosx\/javavm\/export \\\n+    -I${JDK_TOPDIR}\/src\/solaris\/bin \\\n+    ${TESTSRC}\/libNativeThread.c\n+\n+\"${JAVA}\" -Dtest.jdk=${TESTJAVA} \\\n+          -Dtest.nativepath=${TESTCLASSES} \\\n+          -Djava.library.path=${TESTCLASSES} \\\n+          -cp ${TESTCLASSPATH}:${TESTCLASSES} B8312065\n","filename":"jdk\/test\/java\/net\/Socket\/B8312065.sh","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class NativeThread {\n+\n+    public static final int SIGPIPE;\n+\n+    static {\n+        SIGPIPE = getSIGPIPE();\n+    }\n+\n+    public static native long getID();\n+\n+    public static native int signal(long threadId, int sig);\n+\n+    private static native int getSIGPIPE();\n+}\n","filename":"jdk\/test\/java\/net\/Socket\/NativeThread.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include<jni.h>\n+#include<signal.h>\n+#include<stdlib.h>\n+#if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+#include <pthread.h>\n+#endif\n+\n+\/*\n+ * Class:     NativeThread\n+ * Method:    getID\n+ * Signature: ()J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_NativeThread_getID(JNIEnv *env, jclass class)\n+{\n+    #if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+        return (jlong)pthread_self();\n+    #else\n+        return 0;\n+    #endif\n+}\n+\n+\/*\n+ * Class:     NativeThread\n+ * Method:    signal\n+ * Signature: (JI)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_NativeThread_signal(JNIEnv *env, jclass class, jlong thread, jint sig)\n+{\n+    #if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+        return pthread_kill((pthread_t)thread, sig);\n+    #else\n+        return 0;\n+    #endif\n+}\n+\n+\/*\n+ * Class:     NativeThread\n+ * Method:    getSIGPIPE\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_NativeThread_getSIGPIPE(JNIEnv *env, jclass class)\n+{\n+    #if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+        return SIGPIPE;\n+    #else\n+        return 0;\n+    #endif\n+}\n","filename":"jdk\/test\/java\/net\/Socket\/libNativeThread.c","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}