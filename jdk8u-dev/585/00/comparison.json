{"files":[{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/lib\/testlibrary\n@@ -33,1 +34,3 @@\n-import java.util.Properties;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n@@ -39,0 +42,2 @@\n+import jdk.testlibrary.net.URIBuilder;\n+\n@@ -57,1 +62,7 @@\n-        ServerSocket serverSock = new ServerSocket(serverPort);\n+        \/\/ Create unbound server socket\n+        ServerSocket serverSock = new ServerSocket();\n+\n+        \/\/ And bind it to the loopback address\n+        SocketAddress sockAddr = new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0);\n+        serverSock.bind(sockAddr);\n@@ -109,1 +120,7 @@\n-        env.put(Context.PROVIDER_URL, \"ldap:\/\/localhost:\" + serverPort);\n+        \/\/ Construct the provider URL\n+        String providerURL = URIBuilder.newBuilder()\n+                .scheme(\"ldap\")\n+                .loopback()\n+                .port(serverPort)\n+                .build().toString();\n+        env.put(Context.PROVIDER_URL, providerURL);\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/BalancedParentheses.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,1 +26,0 @@\n- * @run main\/othervm DeadSSLLdapTimeoutTest\n@@ -29,0 +28,3 @@\n+ * @library \/lib\/testlibrary\n+ * @build DeadSSLSocketFactory\n+ * @run main\/othervm DeadSSLLdapTimeoutTest\n@@ -31,1 +33,4 @@\n-import java.net.Socket;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n@@ -33,0 +38,2 @@\n+import java.net.Socket;\n+import java.net.SocketAddress;\n@@ -34,4 +41,3 @@\n-import java.io.*;\n-import javax.naming.*;\n-import javax.naming.directory.*;\n-import java.util.List;\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n@@ -39,1 +45,0 @@\n-import java.util.ArrayList;\n@@ -41,7 +46,1 @@\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.CountDownLatch;\n@@ -49,0 +48,1 @@\n+import javax.naming.directory.InitialDirContext;\n@@ -51,1 +51,2 @@\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import jdk.testlibrary.net.URIBuilder;\n+\n@@ -60,1 +61,0 @@\n-    private int HANGING_TEST_TIMEOUT = 20_000;\n@@ -63,1 +63,3 @@\n-        this.server = new DeadSSLServer();\n+        SocketAddress sockAddr = new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0);\n+        this.server = new DeadSSLServer(sockAddr);\n@@ -67,3 +69,1 @@\n-    public void performOp(InitialContext ctx) throws NamingException {}\n-\n-    public void handleNamingException(NamingException e, long start, long end) {\n+    public void handleNamingException(NamingException e) {\n@@ -74,1 +74,1 @@\n-            e.printStackTrace();\n+            System.out.println(\"PASS: Observed expected SocketTimeoutException\");\n@@ -80,0 +80,1 @@\n+            System.out.println(\"PASS: Observed expected SSLHandshakeException\/EOFException\");\n@@ -95,0 +96,1 @@\n+        System.err.println(\"FAIL: Unexpected exception was observed:\" + e.getMessage());\n@@ -109,2 +111,0 @@\n-        ScheduledFuture killer = null;\n-        long start = System.nanoTime();\n@@ -113,2 +113,1 @@\n-            while(!server.accepting())\n-                Thread.sleep(200); \/\/ allow the server to start up\n+            server.serverStarted.await(); \/\/ Wait for the server to start-up\n@@ -117,2 +116,7 @@\n-            env.put(Context.PROVIDER_URL, \"ldap:\/\/localhost:\" +\n-                    server.getLocalPort());\n+            env.put(Context.PROVIDER_URL,\n+                    URIBuilder.newBuilder()\n+                            .scheme(\"ldap\")\n+                            .loopback()\n+                            .port(server.getLocalPort())\n+                            .buildUnchecked().toString()\n+            );\n@@ -120,0 +124,1 @@\n+            long start = System.nanoTime();\n@@ -122,1 +127,0 @@\n-                performOp(ctx);\n@@ -128,1 +132,1 @@\n-                handleNamingException(e, start, end);\n+                handleNamingException(e);\n@@ -130,2 +134,2 @@\n-                if (killer != null && !killer.isDone())\n-                    killer.cancel(true);\n+                \/\/ Stop the server side thread\n+                server.testDone.countDown();\n@@ -136,1 +140,1 @@\n-        } catch (IOException|InterruptedException e) {\n+        } catch (IOException | InterruptedException e) {\n@@ -144,4 +148,12 @@\n-    boolean accepting = false;\n-\n-    public DeadSSLServer() throws IOException {\n-        this.serverSock = new ServerSocket(0);\n+    \/\/ Latch to be used by client to wait for server to start\n+    CountDownLatch serverStarted = new CountDownLatch(1);\n+\n+    \/\/ Latch to be used by server thread to wait for client to finish testing\n+    CountDownLatch testDone = new CountDownLatch(1);\n+\n+    public DeadSSLServer(SocketAddress socketAddress) throws IOException {\n+        \/\/ create unbound server socket\n+        ServerSocket srvSock = new ServerSocket();\n+        \/\/ bind it to the address provided\n+        srvSock.bind(socketAddress);\n+        this.serverSock = srvSock;\n@@ -152,4 +164,45 @@\n-        while(true) {\n-            try {\n-                accepting = true;\n-                Socket socket = serverSock.accept();\n+        \/\/ Signal client to proceed with the test\n+        serverStarted.countDown();\n+        while (true) {\n+            try (Socket acceptedSocket = serverSock.accept()) {\n+                System.err.println(\"Accepted connection:\" + acceptedSocket);\n+                int iteration = 0;\n+                \/\/ Wait for socket to get opened by DeadSSLSocketFactory and connected to the test server\n+                while (iteration++ < 20) {\n+                    if (DeadSSLSocketFactory.firstCreatedSocket.get() != null &&\n+                        DeadSSLSocketFactory.firstCreatedSocket.get().isConnected()) {\n+                        break;\n+                    }\n+                    try {\n+                        TimeUnit.MILLISECONDS.sleep(50);\n+                    } catch (InterruptedException ie) {\n+                    }\n+                }\n+                Socket clientSideSocket = DeadSSLSocketFactory.firstCreatedSocket.get();\n+                System.err.printf(\"Got SSLSocketFactory connection after %d iterations: %s%n\",\n+                        iteration, clientSideSocket);\n+\n+                if (clientSideSocket == null || !clientSideSocket.isConnected()) {\n+                    \/\/ If after 1000 ms client side connection is not opened - probably other local process\n+                    \/\/ tried to connect to the test server socket. Close current connection and retry accept.\n+                    continue;\n+                } else {\n+                    \/\/ Check if accepted socket is connected to the LDAP client\n+                    if (acceptedSocket.getLocalPort() == clientSideSocket.getPort() &&\n+                            acceptedSocket.getPort() == clientSideSocket.getLocalPort() &&\n+                            acceptedSocket.getInetAddress().equals(clientSideSocket.getLocalAddress())) {\n+                        System.err.println(\"Accepted connection is originated from LDAP client:\" + acceptedSocket);\n+                        try {\n+                            \/\/ Give LDAP client time to fully establish the connection.\n+                            \/\/ When client is done - the accepted socket will be closed\n+                            testDone.await();\n+                        } catch (InterruptedException e) {\n+                        }\n+                        break;\n+                    } else {\n+                        \/\/ If accepted socket is not from the LDAP client - the accepted connection will be closed and new\n+                        \/\/ one will be accepted\n+                        System.err.println(\"SSLSocketFactory connection has been established, but originated not from\" +\n+                                \" the test's LDAP client:\" + acceptedSocket);\n+                    }\n+                }\n@@ -157,1 +210,1 @@\n-                break;\n+                System.err.println(\"Server socket. Failure to accept connection:\" + e.getMessage());\n@@ -166,4 +219,0 @@\n-    public boolean accepting() {\n-        return accepting;\n-    }\n-\n@@ -176,0 +225,5 @@\n+    \/\/ com.sun.jndi.ldap.connect.timeout value to set\n+    static final String CONNECT_TIMEOUT_MS = \"10\";\n+\n+    \/\/ com.sun.jndi.ldap.read.timeout value to set\n+    static final String READ_TIMEOUT_MS = \"3000\";\n@@ -180,1 +234,1 @@\n-            \"com.sun.jndi.ldap.LdapCtxFactory\");\n+                \"com.sun.jndi.ldap.LdapCtxFactory\");\n@@ -185,3 +239,0 @@\n-\n-        InitialContext ctx = null;\n-\n@@ -196,1 +247,4 @@\n-        System.out.println(\"Running connect timeout test with 10ms connect timeout, 3000ms read timeout & SSL\");\n+        System.out.printf(\"Running connect timeout test with %sms connect timeout,\" +\n+                          \" %sms read timeout & SSL%n\",\n+                          CONNECT_TIMEOUT_MS, READ_TIMEOUT_MS);\n+\n@@ -198,2 +252,7 @@\n-        sslenv.put(\"com.sun.jndi.ldap.connect.timeout\", \"10\");\n-        sslenv.put(\"com.sun.jndi.ldap.read.timeout\", \"3000\");\n+        \/\/ Setup connect timeout environment property\n+        sslenv.put(\"com.sun.jndi.ldap.connect.timeout\", CONNECT_TIMEOUT_MS);\n+        \/\/ Setup read timeout environment property\n+        sslenv.put(\"com.sun.jndi.ldap.read.timeout\", READ_TIMEOUT_MS);\n+        \/\/ Setup DeadSSLSocketFactory to track the client's first LDAP connection\n+        sslenv.put(\"java.naming.ldap.factory.socket\", \"DeadSSLSocketFactory\");\n+        \/\/ Use SSL protocol\n@@ -201,2 +260,0 @@\n-        boolean testFailed =\n-            (new DeadServerTimeoutSSLTest(sslenv).call()) ? false : true;\n@@ -204,0 +261,1 @@\n+        boolean testFailed = !new DeadServerTimeoutSSLTest(sslenv).call();\n@@ -207,1 +265,0 @@\n-\n@@ -209,1 +266,0 @@\n-\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/DeadSSLLdapTimeoutTest.java","additions":113,"deletions":57,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.SocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * A custom socket factory used to override the default socket factory and track the LDAP client connection.\n+ * Factory can create only one SSLSocket. See the DeadServerTimeoutSSLTest test.\n+ *\/\n+public class DeadSSLSocketFactory extends SocketFactory {\n+    \/\/ Client socket that is used by LDAP connection\n+    public static AtomicReference<SSLSocket> firstCreatedSocket = new AtomicReference<>();\n+\n+    \/\/ Boolean to track if connection socket has been opened\n+    public static AtomicBoolean isConnectionOpened = new AtomicBoolean(false);\n+\n+    \/\/ Default SSLSocketFactory that will be used for SSL socket creation\n+    final SSLSocketFactory factory = (SSLSocketFactory)SSLSocketFactory.getDefault();\n+\n+    \/\/ Create unconnected socket\n+    public Socket createSocket() throws IOException {\n+        if (!isConnectionOpened.getAndSet(true)) {\n+            System.err.println(\"DeadSSLSocketFactory: Creating unconnected socket\");\n+            firstCreatedSocket.set((SSLSocket) factory.createSocket());\n+            return firstCreatedSocket.get();\n+        } else {\n+            throw new RuntimeException(\"DeadSSLSocketFactory only allows creation of one SSL socket\");\n+        }\n+    }\n+\n+    public DeadSSLSocketFactory() {\n+        System.err.println(\"DeadSSLSocketFactory: Constructor call\");\n+    }\n+\n+    public static SocketFactory getDefault() {\n+        System.err.println(\"DeadSSLSocketFactory: acquiring DeadSSLSocketFactory as default socket factory\");\n+        return new DeadSSLSocketFactory();\n+    }\n+\n+    @Override\n+    public Socket createSocket(String host, int port) throws IOException {\n+        \/\/ Not used by DeadSSLLdapTimeoutTest\n+        return factory.createSocket(host, port);\n+    }\n+\n+    @Override\n+    public Socket createSocket(String host, int port, InetAddress localHost,\n+                               int localPort) throws IOException {\n+        \/\/ Not used by DeadSSLLdapTimeoutTest\n+        return factory.createSocket(host, port, localHost, localPort);\n+    }\n+\n+    @Override\n+    public Socket createSocket(InetAddress host, int port) throws IOException {\n+        \/\/ Not used by DeadSSLLdapTimeoutTest\n+        return factory.createSocket(host, port);\n+    }\n+\n+    @Override\n+    public Socket createSocket(InetAddress address, int port,\n+                               InetAddress localAddress, int localPort) throws IOException {\n+        \/\/ Not used by DeadSSLLdapTimeoutTest\n+        return factory.createSocket(address, port, localAddress, localPort);\n+    }\n+}\n+\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/DeadSSLSocketFactory.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- * @library ..\/..\/lib\/\n+ * @library \/lib\/testlibrary ..\/..\/lib\/\n@@ -42,0 +42,2 @@\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n@@ -43,0 +45,1 @@\n+import java.net.SocketAddress;\n@@ -44,0 +47,1 @@\n+import jdk.testlibrary.net.URIBuilder;\n@@ -48,1 +52,14 @@\n-        ServerSocket serverSocket = new ServerSocket(0);\n+        \/\/ Create unbound server socket\n+        ServerSocket serverSocket = new ServerSocket();\n+\n+        \/\/ Bind it to the loopback address\n+        SocketAddress sockAddr = new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0);\n+        serverSocket.bind(sockAddr);\n+\n+        \/\/ Construct the provider URL for LDAPTestUtils\n+        String providerURL = URIBuilder.newBuilder()\n+                .scheme(\"ldap\")\n+                .loopback()\n+                .port(serverSocket.getLocalPort())\n+                .buildUnchecked().toString();\n@@ -53,2 +70,2 @@\n-        env = LDAPTestUtils\n-                .initEnv(serverSocket, AddNewEntry.class.getName(), args, true);\n+        env = LDAPTestUtils.initEnv(serverSocket, providerURL,\n+                         AddNewEntry.class.getName(), args, true);\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/blits\/AddTests\/AddNewEntry.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-            String[] args) {\n+                                                    String[] args) {\n@@ -58,1 +58,6 @@\n-            String testname, String[] args, boolean authInfo) {\n+                                                    String testname, String[] args, boolean authInfo) {\n+        return initEnv(socket, null, testname, args, authInfo);\n+    }\n+\n+    public static Hashtable<Object, Object> initEnv(ServerSocket socket, String providerUrl,\n+                                                    String testname, String[] args, boolean authInfo) {\n@@ -106,2 +111,3 @@\n-                env.put(\"java.naming.provider.url\",\n-                        \"ldap:\/\/localhost:\" + socket.getLocalPort());\n+                String url = providerUrl != null ? providerUrl :\n+                        \"ldap:\/\/localhost:\" + socket.getLocalPort();\n+                env.put(\"java.naming.provider.url\", url);\n","filename":"jdk\/test\/com\/sun\/jndi\/ldap\/lib\/LDAPTestUtils.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}