{"files":[{"patch":"@@ -78,0 +78,1 @@\n+     * kflag: keep existing file\n@@ -80,1 +81,1 @@\n-    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, nflag, pflag;\n+    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, nflag, pflag, kflag;\n@@ -400,0 +401,3 @@\n+                case 'k':\n+                    kflag = true;\n+                    break;\n@@ -434,0 +438,4 @@\n+        if (kflag && !xflag) {\n+            warn(formatMsg(\"warn.option.is.ignored\", \"-k\/k\"));\n+        }\n+\n@@ -1061,0 +1069,6 @@\n+            if (f.exists() && kflag) {\n+                if (vflag) {\n+                    output(formatMsg(\"out.kept\", name));\n+                }\n+                return rc;\n+            }\n@@ -1283,0 +1297,7 @@\n+    \/**\n+     * Print a warning message\n+     *\/\n+    void warn(String s) {\n+        err.println(s);\n+    }\n+\n","filename":"jdk\/src\/share\/classes\/sun\/tools\/jar\/Main.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+warn.option.is.ignored=\\\n+        Warning: The {0} option is not valid with current usage, will be ignored.\n@@ -65,0 +67,2 @@\n+out.kept=\\\n+        \\ \\ skipped: {0} exists\n@@ -75,1 +79,4 @@\n-\\ \\   -x  extract named (or all) files from archive\\n\\\n+\\ \\   -x, Extract named (or all) files from the archive.\\n\\\n+\\ \\       If a file with the same name appears more than once in\\n\\\n+\\ \\       the archive, each copy will be extracted, with later copies\\n\\\n+\\ \\       overwriting (replacing) earlier copies unless -k is specified.\\n\\\n@@ -88,0 +95,7 @@\n+Operation modifiers valid only in extract mode:\\n\\\n+\\ \\   -k  Do not overwrite existing files.\\n\\\n+\\ \\       If a Jar file entry with the same name exists in the target\\n\\\n+\\ \\       directory, the existing file will not be overwritten.\\n\\\n+\\ \\       As a result, if a file appears more than once in an\\n\\\n+\\ \\       archive, later copies will not overwrite earlier copies.\\n\\\n+\\ \\       Also note that some file system can be case insensitive.\\n\\\n","filename":"jdk\/src\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335912\n+ * @summary test extract jar files overwrite existing files behavior\n+ * @library \/test\/lib \/lib\/testlibrary\n+ * @build jdk.test.lib.Platform\n+ *        jdk.testlibrary.FileUtils\n+ * @run junit\/othervm ExtractFilesTest\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import jdk.testlibrary.FileUtils;\n+import sun.tools.jar.Main;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+public class ExtractFilesTest {\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream out = new PrintStream(baos);\n+\n+    @BeforeAll\n+    public void setupJar() throws IOException {\n+        mkdir(\"test1 test2\");\n+        echo(\"testfile1\", \"test1\/testfile1\");\n+        echo(\"testfile2\", \"test2\/testfile2\");\n+        jar(\"cf test.jar -C test1 . -C test2 .\");\n+        rm(\"test1 test2\");\n+    }\n+\n+    @AfterAll\n+    public void cleanup() {\n+        rm(\"test.jar\");\n+    }\n+\n+    \/**\n+     * Regular clean extract with expected output.\n+     *\/\n+    @Test\n+    public void testExtract() throws IOException {\n+        jar(\"xvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assertions.assertArrayEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    \/**\n+     * Extract should overwrite existing file as default behavior.\n+     *\/\n+    @Test\n+    public void testOverwrite() throws IOException {\n+        touch(\"testfile1\");\n+        jar(\"xvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        Assertions.assertEquals(\"testfile1\", cat(\"testfile1\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assertions.assertArrayEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    \/**\n+     * Extract with legacy style option `k` should preserve existing files.\n+     *\/\n+    @Test\n+    public void testKeptOldFile() throws IOException {\n+        touch(\"testfile1\");\n+        jar(\"xkvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: testfile1 exists\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        Assertions.assertEquals(\"\", cat(\"testfile1\"));\n+        Assertions.assertEquals(\"testfile2\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assertions.assertArrayEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    \/**\n+     * Extract with gnu style -k should preserve existing files.\n+     *\/\n+    @Test\n+    public void testGnuOptionsKeptOldFile() throws IOException {\n+        touch(\"testfile1 testfile2\");\n+        jar(\"-xkvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: testfile1 exists\" + nl +\n+                \"  skipped: testfile2 exists\" + nl;\n+        Assertions.assertEquals(\"\", cat(\"testfile1\"));\n+        Assertions.assertEquals(\"\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assertions.assertArrayEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    \/**\n+     * Test jar will issue warning when use keep option in non-extraction mode.\n+     *\/\n+    @Test\n+    public void testWarningOnInvalidKeepOption() throws IOException {\n+        String err = jar(\"tkf test.jar\");\n+        println();\n+\n+        String output = \"META-INF\/\" + nl +\n+                \"META-INF\/MANIFEST.MF\" + nl +\n+                \"testfile1\" + nl +\n+                \"testfile2\" + nl;\n+\n+        Assertions.assertArrayEquals(baos.toByteArray(), output.getBytes());\n+        Assertions.assertEquals(\"Warning: The -k\/k option is not valid with current usage, will be ignored.\" + nl, err);\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Paths.get(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void mkdir(String cmdline) {\n+        System.out.println(\"mkdir -p \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createDirectories(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void touch(String cmdline) {\n+        System.out.println(\"touch \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createFile(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void echo(String text, String path) {\n+        System.out.println(\"echo '\" + text + \"' > \" + path);\n+        try {\n+            Path p = Paths.get(\".\", path.split(\"\/\"));\n+            Files.write(p, text.getBytes());\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    private String cat(String path) {\n+        System.out.println(\"cat \" + path);\n+        try {\n+            return new String(Files.readAllBytes(Paths.get(path)));\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private String jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            if (!new Main(out, err, \"jar\").run(cmdline.split(\" +\"))) {\n+                throw new IOException(baes.toString());\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+        return baes.toString();\n+    }\n+\n+    private void println() throws IOException {\n+        System.out.println(new String(baos.toByteArray()));\n+    }\n+}\n","filename":"jdk\/test\/tools\/jar\/ExtractFilesTest.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335912\n+ * @summary test extract jar with multpile manifest files\n+ * @library \/test\/lib \/lib\/testlibrary\n+ * @build jdk.test.lib.Platform\n+ *        jdk.testlibrary.FileUtils\n+ * @run junit\/othervm MultipleManifestTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.testlibrary.FileUtils;\n+import sun.tools.jar.Main;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+class MultipleManifestTest {\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream jarOut = new PrintStream(baos);\n+\n+    static final Path zip = Paths.get(\"MultipleManifestTest.jar\");\n+    static final String jdkVendor = System.getProperty(\"java.vendor\");\n+    static final String jdkVersion = System.getProperty(\"java.version\");\n+    static final String MANIFEST1 = \"Manifest-Version: 1.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST2 = \"Manifest-Version: 2.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    static final String MANIFEST3 = \"Manifest-Version: 3.0\"\n+            + System.lineSeparator()\n+            + \"Created-By: \" + jdkVersion + \" (\" + jdkVendor + \")\";\n+    private static final String META_INF = \"META-INF\/\";\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterAll\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Create a JAR with the Manifest as the 1st, 2nd and 4th entry\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeAll\n+    public void writeManifestAsFirstSecondAndFourthEntry() throws IOException {\n+        int locPosA, locPosB, cenPos;\n+        System.out.printf(\"%n%n*****Creating Jar with the Manifest as the 1st, 2nd and 4th entry*****%n%n\");\n+        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n+        try (ZipOutputStream zos = new ZipOutputStream(out)) {\n+            zos.putNextEntry(new ZipEntry(JarFile.MANIFEST_NAME));\n+            zos.write(MANIFEST1.getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosA = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"AANIFEST.MF\"));\n+            zos.write(MANIFEST2.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zos.write(\"entry1\".getBytes(StandardCharsets.UTF_8));\n+            zos.closeEntry();\n+            locPosB = out.size();\n+            zos.putNextEntry(new ZipEntry(META_INF + \"BANIFEST.MF\"));\n+            zos.write(MANIFEST3.getBytes(StandardCharsets.UTF_8));\n+            zos.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zos.write(\"hello entry2\".getBytes(StandardCharsets.UTF_8));\n+            zos.flush();\n+            cenPos = out.size();\n+        }\n+        byte[] template = out.toByteArray();\n+        \/\/ ISO_8859_1 to keep the 8-bit value\n+        String s = new String(template, StandardCharsets.ISO_8859_1);\n+        \/\/ change META-INF\/AANIFEST.MF to META-INF\/MANIFEST.MF\n+        int loc = s.indexOf(\"AANIFEST.MF\", locPosA);\n+        int cen = s.indexOf(\"AANIFEST.MF\", cenPos);\n+        template[loc] = template[cen] = (byte) 'M';\n+        \/\/ change META-INF\/BANIFEST.MF to META-INF\/MANIFEST.MF\n+        loc = s.indexOf(\"BANIFEST.MF\", locPosB);\n+        cen = s.indexOf(\"BANIFEST.MF\", cenPos);\n+        template[loc] = template[cen] = (byte) 'M';\n+        Files.write(zip, template);\n+    }\n+\n+    @AfterEach\n+    public void removeExtractedFiles() {\n+        rm(\"META-INF entry1.txt entry2.txt\");\n+    }\n+\n+    \/**\n+     * Extract by default should have the last manifest.\n+     *\/\n+    @Test\n+    public void testOverwrite() throws IOException {\n+        jar(\"xvf \" + zip.toString());\n+        println();\n+        Assertions.assertEquals(\"3.0\", getManifestVersion());\n+        String output = \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: entry1.txt\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: entry2.txt\" + nl;\n+        Assertions.assertArrayEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    \/**\n+     * Extract with k option should have first manifest.\n+     *\/\n+    @Test\n+    public void testKeptOldFile() throws IOException {\n+        jar(\"xkvf \" + zip.toString());\n+        println();\n+        Assertions.assertEquals(\"1.0\", getManifestVersion());\n+        String output = \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: META-INF\/MANIFEST.MF exists\" + nl +\n+                \" inflated: entry1.txt\" + nl +\n+                \"  skipped: META-INF\/MANIFEST.MF exists\" + nl +\n+                \" inflated: entry2.txt\" + nl;\n+        Assertions.assertArrayEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    private String getManifestVersion() throws IOException {\n+        try (InputStream is = Files.newInputStream(Paths.get(JarFile.MANIFEST_NAME))) {\n+            Manifest manifest = new Manifest(is);\n+            return manifest.getMainAttributes().getValue(Attributes.Name.MANIFEST_VERSION);\n+        }\n+    }\n+\n+    private void jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        try {\n+            if (!new Main(jarOut, err, \"jar\").run(cmdline.split(\" +\"))) {\n+                throw new IOException(baes.toString());\n+            }\n+        } finally {\n+            System.setErr(saveErr);\n+        }\n+    }\n+\n+    private void println() throws IOException {\n+        System.out.println(new String(baos.toByteArray()));\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Paths.get(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"jdk\/test\/tools\/jar\/MultipleManifestTest.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"}]}