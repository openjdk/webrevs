{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,4 +306,2 @@\n-        int value = t->as_IntConstant()->value();\n-        int shift = t2->as_IntConstant()->value() & 31;\n-        jint mask = ~(~0 << (32 - shift));\n-        if (shift == 0) mask = ~0;\n+        jint value = t->as_IntConstant()->value();\n+        jint shift = t2->as_IntConstant()->value();\n@@ -311,3 +309,3 @@\n-          case Bytecodes::_ishl:  set_constant(value << shift); return;\n-          case Bytecodes::_ishr:  set_constant(value >> shift); return;\n-          case Bytecodes::_iushr: set_constant((value >> shift) & mask); return;\n+          case Bytecodes::_ishl:  set_constant(java_shift_left(value, shift)); return;\n+          case Bytecodes::_ishr:  set_constant(java_shift_right(value, shift)); return;\n+          case Bytecodes::_iushr: set_constant(java_shift_right_unsigned(value, shift)); return;\n@@ -317,3 +315,1 @@\n-        int shift = t2->as_IntConstant()->value() & 63;\n-        jlong mask = ~(~jlong_cast(0) << (64 - shift));\n-        if (shift == 0) mask = ~jlong_cast(0);\n+        jint shift = t2->as_IntConstant()->value();\n@@ -321,3 +317,3 @@\n-          case Bytecodes::_lshl:  set_constant(value << shift); return;\n-          case Bytecodes::_lshr:  set_constant(value >> shift); return;\n-          case Bytecodes::_lushr: set_constant((value >> shift) & mask); return;\n+          case Bytecodes::_lshl:  set_constant(java_shift_left(value, shift)); return;\n+          case Bytecodes::_lshr:  set_constant(java_shift_right(value, shift)); return;\n+          case Bytecodes::_lushr: set_constant(java_shift_right_unsigned(value, shift)); return;\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_Canonicalizer.cpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1283,0 +1283,36 @@\n+#ifdef ASSERT\n+#define RHS_MASK_ASSERT(rhs_mask)                       \\\n+  if (rhs_mask != 31 && rhs_mask != 63) {               \\\n+    basic_fatal(\"rhs_mask assertion failed.\");          \\\n+  }\n+#else\n+#define RHS_MASK_ASSERT(rhs_mask)\n+#endif\n+\n+\/\/ Provide integer shift operations with Java semantics.  No overflow\n+\/\/ issues - left shifts simply discard shifted out bits.  No undefined\n+\/\/ behavior for large or negative shift quantities; instead the actual\n+\/\/ shift distance is the argument modulo the lhs value's size in bits.\n+\/\/ No undefined or implementation defined behavior for shifting negative\n+\/\/ values; left shift discards bits, right shift sign extends.  We use\n+\/\/ the same safe conversion technique as above for java_add and friends.\n+#define JAVA_INTEGER_SHIFT_OP(OP, NAME, TYPE, XTYPE)    \\\n+inline TYPE NAME (TYPE lhs, jint rhs) {                 \\\n+  const uint rhs_mask = (sizeof(TYPE) * 8) - 1;         \\\n+  RHS_MASK_ASSERT(rhs_mask)                             \\\n+  XTYPE xres = static_cast<XTYPE>(lhs);                 \\\n+  xres OP ## = (rhs & rhs_mask);                        \\\n+  return reinterpret_cast<TYPE&>(xres);                 \\\n+}\n+\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jlong, julong)\n+\/\/ For signed shift right, assume C++ implementation >> sign extends.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jint, jint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jlong, jlong)\n+\/\/ For >>> use C++ unsigned >>.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jlong, julong)\n+\n+#undef JAVA_INTEGER_SHIFT_OP\n+\n","filename":"hotspot\/src\/share\/vm\/utilities\/globalDefinitions.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"}]}