{"files":[{"patch":"@@ -304,0 +304,1 @@\n+        String alg = AuthTimeWithHash.DEFAULT_HASH_ALG;\n@@ -306,1 +307,1 @@\n-            hash = MessageDigest.getInstance(\"MD5\")\n+            hash = MessageDigest.getInstance(AuthTimeWithHash.realAlg(alg))\n@@ -309,1 +310,1 @@\n-            throw new AssertionError(\"Impossible\");\n+            throw new AssertionError(\"Impossible \" + alg);\n@@ -322,0 +323,1 @@\n+                alg,\n","filename":"jdk\/src\/share\/classes\/sun\/security\/krb5\/KrbApReq.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-            st.nextToken();\n+            String hashAlg = st.nextToken();\n@@ -126,1 +126,1 @@\n-                    client, server, ctime, cusec, hash);\n+                    client, server, ctime, cusec, hashAlg, hash);\n","filename":"jdk\/src\/share\/classes\/sun\/security\/krb5\/internal\/rcache\/AuthTime.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import sun.security.action.GetPropertyAction;\n+\n@@ -37,0 +39,24 @@\n+    \/\/ The hash algorithm can be \"HASH\" or \"SHA256\".\n+    public static final String DEFAULT_HASH_ALG;\n+\n+    static {\n+        if (GetPropertyAction.privilegedGetProperty(\n+                \"jdk.krb5.rcache.useMD5\", \"false\").equals(\"true\")) {\n+            DEFAULT_HASH_ALG = \"HASH\";\n+        } else {\n+            DEFAULT_HASH_ALG = \"SHA256\";\n+        }\n+    }\n+\n+    public static String realAlg(String alg) {\n+        switch (alg) {\n+            case \"HASH\":\n+                return \"MD5\";\n+            case \"SHA256\":\n+                return \"SHA-256\";\n+            default:\n+                throw new AssertionError(alg + \" is not HASH or SHA256\");\n+        }\n+    }\n+\n+    final String hashAlg;\n@@ -43,1 +69,1 @@\n-            int ctime, int cusec, String hash) {\n+            int ctime, int cusec, String hashAlg, String hash) {\n@@ -45,0 +71,1 @@\n+        this.hashAlg = hashAlg;\n@@ -59,0 +86,1 @@\n+                && Objects.equals(hashAlg, that.hashAlg)\n@@ -91,0 +119,13 @@\n+    \/**\n+     * Compares with a possibly old style object. Used\n+     * in DflCache$Storage#loadAndCheck.\n+     * @return true if all AuthTime fields are the same but different hash\n+     *\/\n+    public boolean sameTimeDiffHash(AuthTimeWithHash old) {\n+        if (!this.isSameIgnoresHash(old)) {\n+            return false;\n+        }\n+        return this.hashAlg.equals(old.hashAlg) &&\n+                !this.hash.equals(old.hash);\n+    }\n+\n@@ -115,1 +156,1 @@\n-            sstring = String.format(\"HASH:%s %d:%s %d:%s\", hash,\n+            sstring = String.format(\"%s:%s %d:%s %d:%s\", hashAlg, hash,\n","filename":"jdk\/src\/share\/classes\/sun\/security\/krb5\/internal\/rcache\/AuthTimeWithHash.java","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+ *\n+ * Update: New version can use other hash algorithms.\n@@ -310,1 +312,1 @@\n-                        } else if (time.isSameIgnoresHash(a)) {\n+                        } else if (time.sameTimeDiffHash((AuthTimeWithHash)a)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/krb5\/internal\/rcache\/DflCache.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                new AuthTimeWithHash(client, server, time(-400), 0, hash(\"1\"));\n+                new AuthTimeWithHash(client, server, time(-400), 0, \"HASH\", hash(\"1\"));\n@@ -52,1 +52,1 @@\n-                new AuthTimeWithHash(client, server, time(0), 0, hash(\"4\"));\n+                new AuthTimeWithHash(client, server, time(0), 0, \"HASH\", hash(\"4\"));\n@@ -58,1 +58,1 @@\n-            a1 = new AuthTimeWithHash(client, server, time(-400), 0, hash(\"\"));\n+            a1 = new AuthTimeWithHash(client, server, time(-400), 0, \"HASH\", hash(\"\"));\n","filename":"jdk\/test\/sun\/security\/krb5\/auto\/ReplayCacheExpunge.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-                \"1111111111111111\");\n+                \"HASH\", \"1111111111111111\");\n@@ -53,1 +53,1 @@\n-                \"2222222222222222\");\n+                \"HASH\", \"2222222222222222\");\n","filename":"jdk\/test\/sun\/security\/krb5\/auto\/ReplayCachePrecise.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7152176\n+ * @bug 7152176 8168518\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=100 -Dsun.net.spi.nameservice.provider.1=ns,mock ReplayCacheTestProc\n+ * @run main\/othervm\/timeout=300 -Dsun.net.spi.nameservice.provider.1=ns,mock ReplayCacheTestProc\n@@ -41,0 +41,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -42,0 +43,4 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Platform;\n@@ -43,1 +48,0 @@\n-import sun.security.krb5.internal.APReq;\n@@ -46,1 +50,21 @@\n-\/\/ This test runs multiple acceptor Procs to mimin AP-REQ replays.\n+\/**\n+ * This test runs multiple acceptor Procs to mimic AP-REQ replays.\n+ * These system properties are supported:\n+ *\n+ * - test.libs on what types of acceptors to use\n+ *   Format: CSV of (J|N|N<suffix>=<libname>|J<suffix>=<launcher>)\n+ *   Default: J,N on Solaris and Linux where N is available, or J\n+ *   Example: J,N,N14=\/krb5-1.14\/lib\/libgssapi_krb5.so,J8=\/java8\/bin\/java\n+ *\n+ * - test.runs on manual runs. If empty, a iterate through all pattern\n+ *   Format: (req# | client# service#) acceptor# expected, ...\n+ *   Default: null\n+ *   Example: c0s0Jav,c1s1N14av,r0Jbx means 0th req is new c0->s0 sent to Ja,\n+ *            1st req is new c1 to s1 sent to N14a,\n+ *            2nd req is old (0th replayed) sent to Jb.\n+ *            a\/b at the end of acceptor is different acceptors of the same lib\n+ *\n+ * - test.autoruns on number of automatic runs\n+ *   Format: number\n+ *   Default: 100\n+ *\/\n@@ -49,2 +73,2 @@\n-    private static Proc[] ps;\n-    private static Proc pc;\n+    private static Proc[] pa;   \/\/ all acceptors\n+    private static Proc pi;     \/\/ the single initiator\n@@ -61,0 +85,10 @@\n+    private static MessageDigest md5, sha256;\n+\n+    static {\n+        try {\n+            md5 = MessageDigest.getInstance(\"MD5\");\n+            sha256 = MessageDigest.getInstance(\"SHA-256\");\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new AssertionError(\"Impossible\", nsae);\n+        }\n+    }\n@@ -62,1 +96,1 @@\n-    private static int uid;\n+    private static long uid;\n@@ -67,12 +101,9 @@\n-            int ns = 5;     \/\/ number of servers\n-            int nu = 5;     \/\/ number of users\n-            int nx = 50;    \/\/ number of experiments\n-            int np = 5;     \/\/ number of peers (services)\n-            int mode = 0;   \/\/ native(1), random(0), java(-1)\n-            boolean random = true;      \/\/ random experiments choreograph\n-\n-            \/\/ Do not test interop with native GSS on some platforms\n-            String os = System.getProperty(\"os.name\", \"???\");\n-            if (!os.startsWith(\"SunOS\") && !os.startsWith(\"Linux\")) {\n-                mode = -1;\n-            }\n+            int nc = 5;     \/\/ number of clients\n+            int ns = 5;     \/\/ number of services\n+            String[] libs;  \/\/ available acceptor types:\n+                            \/\/ J: java\n+                            \/\/ J<suffix>=<java launcher>: another java\n+                            \/\/ N: default native lib\n+                            \/\/ N<suffix>=<libname>: another native lib\n+            Ex[] result;\n+            int numPerType = 2; \/\/ number of acceptors per type\n@@ -90,2 +121,2 @@\n-            for (int i=0; i<nu; i++) {\n-                kdc.addPrincipal(user(i), OneKDC.PASS);\n+            for (int i=0; i<nc; i++) {\n+                kdc.addPrincipal(client(i), OneKDC.PASS);\n@@ -94,2 +125,2 @@\n-            for (int i=0; i<np; i++) {\n-                kdc.addPrincipalRandKey(peer(i));\n+            for (int i=0; i<ns; i++) {\n+                kdc.addPrincipalRandKey(service(i));\n@@ -101,5 +132,16 @@\n-            if (mode != -1) {\n-                \/\/ A special native server to check basic sanity\n-                if (ns(-1).waitFor() != 0) {\n-                    Proc.d(\"Native mode sanity check failed, revert to java\");\n-                    mode = -1;\n+            \/\/ User-provided libs\n+            String userLibs = System.getProperty(\"test.libs\");\n+\n+            if (userLibs != null) {\n+                libs = userLibs.split(\",\");\n+            } else {\n+                if (Platform.isOSX() || Platform.isWindows()) {\n+                    \/\/ macOS uses Heimdal and Windows has no native lib\n+                    libs = new String[]{\"J\"};\n+                } else {\n+                    if (acceptor(\"N\", \"sanity\").waitFor() != 0) {\n+                        Proc.d(\"Native mode sanity check failed, only java\");\n+                        libs = new String[]{\"J\"};\n+                    } else {\n+                        libs = new String[]{\"J\", \"N\"};\n+                    }\n@@ -109,2 +151,2 @@\n-            pc = Proc.create(\"ReplayCacheTestProc\").debug(\"C\")\n-                    .args(\"client\")\n+            pi = Proc.create(\"ReplayCacheTestProc\").debug(\"C\")\n+                    .args(\"initiator\")\n@@ -112,2 +154,0 @@\n-            ps = new Proc[ns];\n-            Ex[] result = new Ex[nx];\n@@ -115,3 +155,2 @@\n-            if (!random) {\n-                \/\/ 2 experiments, 2 server, 1 peer, 1 user\n-                nx = 2; ns = 2; np = 1; nu = 1;\n+            int na = libs.length * numPerType;  \/\/ total number of acceptors\n+            pa = new Proc[na];\n@@ -119,2 +158,5 @@\n-                \/\/ Creates reqs from user# to peer#\n-                req(0, 0);\n+            \/\/ Acceptors, numPerType for 1st, numForType for 2nd, ...\n+            for (int i=0; i<na; i++) {\n+                pa[i] = acceptor(libs[i\/numPerType],\n+                        \"\" + (char)('a' + i%numPerType));\n+            }\n@@ -122,3 +164,2 @@\n-                \/\/ Creates server#\n-                ps[0] = ns(0);\n-                ps[1] = js(1);\n+            \/\/ Manual runs\n+            String userRuns = System.getProperty(\"test.runs\");\n@@ -126,4 +167,3 @@\n-                \/\/ Runs ex# using req# to server# with expected result\n-                result[0] = round(0, 0, 0, true);\n-                result[1] = round(1, 0, 1, false);\n-            } else {\n+            if (userRuns == null) {\n+                result = new Ex[Integer.parseInt(\n+                        System.getProperty(\"test.autoruns\", \"100\"))];\n@@ -131,4 +171,9 @@\n-                for (int i=0; i<ns; i++) {\n-                    boolean useNative = (mode == 1) ? true\n-                            : (mode == -1 ? false : r.nextBoolean());\n-                    ps[i] = useNative?ns(i):js(i);\n+                for (int i = 0; i < result.length; i++) {\n+                    boolean expected = reqs.isEmpty() || r.nextBoolean();\n+                    result[i] = new Ex(\n+                            i,\n+                            expected ?\n+                                    req(r.nextInt(nc), r.nextInt(ns)) :\n+                                    r.nextInt(reqs.size()),\n+                            pa[r.nextInt(na)],\n+                            expected);\n@@ -136,12 +181,20 @@\n-                for (int i=0; i<nx; i++) {\n-                    result[i] = new Ex();\n-                    int old;    \/\/ which req to send\n-                    boolean expected;\n-                    if (reqs.isEmpty() || r.nextBoolean()) {\n-                        Proc.d(\"Console get new AP-REQ\");\n-                        old = req(r.nextInt(nu), r.nextInt(np));\n-                        expected = true;\n-                    } else {\n-                        Proc.d(\"Console resue old\");\n-                        old = r.nextInt(reqs.size());\n-                        expected = false;\n+            } else if (userRuns.isEmpty()) {\n+                int count = 0;\n+                result = new Ex[libs.length * libs.length];\n+                for (int i = 0; i < libs.length; i++) {\n+                    result[count] = new Ex(\n+                            count,\n+                            req(0, 0),\n+                            pa[i * numPerType],\n+                            true);\n+                    count++;\n+                    for (int j = 0; j < libs.length; j++) {\n+                        if (i == j) {\n+                            continue;\n+                        }\n+                        result[count] = new Ex(\n+                                count,\n+                                i,\n+                                pa[j * numPerType],\n+                                false);\n+                        count++;\n@@ -149,4 +202,17 @@\n-                    int s = r.nextInt(ns);\n-                    Proc.d(\"Console send to \" + s);\n-                    result[i] = round(i, old, s, expected);\n-                    Proc.d(\"Console sees \" + result[i].actual);\n+                }\n+            } else {\n+                String[] runs = userRuns.split(\",\");\n+                result = new Ex[runs.length];\n+                for (int i = 0; i < runs.length; i++) {\n+                    UserRun run = new UserRun(runs[i]);\n+                    result[i] = new Ex(\n+                            i,\n+                            run.req() == -1 ?\n+                                    req(run.client(), run.service()) :\n+                                    result[run.req()].req,\n+                            Arrays.stream(pa)\n+                                    .filter(p -> p.debug().equals(run.acceptor()))\n+                                    .findFirst()\n+                                    .orElseThrow(() -> new Exception(\n+                                            \"no acceptor named \" + run.acceptor())),\n+                            run.success());\n@@ -156,3 +222,2 @@\n-            pc.println(\"END\");\n-            for (int i=0; i<ns; i++) {\n-                ps[i].println(\"END\");\n+            for (Ex x : result) {\n+                x.run();\n@@ -160,1 +225,6 @@\n-            System.out.println(\"Result\\n======\");\n+\n+            pi.println(\"END\");\n+            for (int i=0; i<na; i++) {\n+                pa[i].println(\"END\");\n+            }\n+            System.out.println(\"\\nAll Test Results\\n================\");\n@@ -162,1 +232,3 @@\n-            for (int i=0; i<nx; i++) {\n+            System.out.println(\"        req**  client    service  acceptor   Result\");\n+            System.out.println(\"----  -------  ------  ---------  --------  -------\");\n+            for (int i=0; i<result.length; i++) {\n@@ -165,1 +237,1 @@\n-                System.out.printf(\"%3d: %s (%2d): u%d h%d %s %s   %s %2d\\n\",\n+                System.out.printf(\"%3d:    %3d%s      c%d    s%d %4s  %8s   %s  %s\\n\",\n@@ -167,6 +239,32 @@\n-                        result[i].expected?\"----\":\"    \",\n-                        result[i].old,\n-                        result[i].user, result[i].peer, result[i].server,\n-                        result[i].actual?\"Good\":\"Bad \",\n-                        out?\"   \":\"xxx\",\n-                        result[i].csize);\n+                        result[i].req,\n+                        result[i].expected ? \"**\" : \"  \",\n+                        reqs.get(result[i].req).client,\n+                        reqs.get(result[i].req).service,\n+                        \"(\" + result[i].csize + \")\",\n+                        result[i].acceptor.debug(),\n+                        result[i].actual ? \"++\" : \"--\",\n+                        out ? \"   \" : \"xxx\");\n+            }\n+\n+            System.out.println(\"\\nPath of Reqs\\n============\");\n+            for (int j=0; ; j++) {\n+                boolean found = false;\n+                for (int i=0; i<result.length; i++) {\n+                    if (result[i].req == j) {\n+                        if (!found) {\n+                            System.out.printf(\"%3d (c%s -> s%s): \", j,\n+                                    reqs.get(j).client, reqs.get(j).service);\n+                        }\n+                        System.out.printf(\"%s%s(%d)%s\",\n+                                found ? \" -> \" : \"\",\n+                                result[i].acceptor.debug(),\n+                                i,\n+                                result[i].actual != result[i].expected ?\n+                                        \"xxx\" : \"\");\n+                        found = true;\n+                    }\n+                }\n+                System.out.println();\n+                if (!found) {\n+                    break;\n+                }\n@@ -175,1 +273,1 @@\n-        } else if (args[0].equals(\"N-1\")) {\n+        } else if (args[0].equals(\"Nsanity\")) {\n@@ -180,1 +278,1 @@\n-        } else if (args[0].equals(\"client\")) {\n+        } else if (args[0].equals(\"initiator\")) {\n@@ -194,0 +292,4 @@\n+            Proc.d(System.getProperty(\"java.vm.version\"));\n+            Proc.d(System.getProperty(\"sun.security.jgss.native\"));\n+            Proc.d(System.getProperty(\"sun.security.jgss.lib\"));\n+            Proc.d(\"---------------------------------\\n\");\n@@ -199,1 +301,1 @@\n-                Proc.d(\"Server \" + args[0] + \" sees \" + title);\n+                Proc.d(\"Server sees \" + title);\n@@ -206,1 +308,1 @@\n-                    Proc.d(args[0] + \" Good\");\n+                    Proc.d(\"Good\");\n@@ -209,1 +311,1 @@\n-                    Proc.d(args[0] + \" Bad\");\n+                    Proc.d(\"Bad\");\n@@ -224,3 +326,3 @@\n-    \/\/ returns the user name\n-    private static String user(int p) {\n-        return \"USER\" + p;\n+    \/\/ returns the client name\n+    private static String client(int p) {\n+        return \"client\" + p;\n@@ -228,3 +330,4 @@\n-    \/\/ returns the peer name\n-    private static String peer(int p) {\n-        return \"host\" + p + \"\/\" + HOST;\n+\n+    \/\/ returns the service name\n+    private static String service(int p) {\n+        return \"service\" + p + \"\/\" + HOST;\n@@ -232,1 +335,2 @@\n-    \/\/ returns the dfl name for a host\n+\n+    \/\/ returns the dfl name for a service\n@@ -234,1 +338,1 @@\n-        return cwd + \"host\" + p + (uid == -1 ? \"\" : (\"_\"+uid));\n+        return \"service\" + p + (uid == -1 ? \"\" : (\"_\"+uid));\n@@ -236,0 +340,1 @@\n+\n@@ -237,3 +342,3 @@\n-    private static int req(int user, int peer) throws Exception {\n-        pc.println(user(user) + \" \" + peer(peer));\n-        Req req = new Req(user, peer, pc.readData());\n+    private static int req(int client, int service) throws Exception {\n+        pi.println(client(client) + \" \" + service(service));\n+        Req req = new Req(client, service, pi.readData());\n@@ -243,24 +348,13 @@\n-    \/\/ carries out a round of experiment\n-    \/\/ i: ex#, old: which req, server: which server, expected: result?\n-    private static Ex round(int i, int old, int server, boolean expected)\n-            throws Exception {\n-        ps[server].println(\"TEST\");\n-        ps[server].println(reqs.get(old).msg);\n-        String reply = ps[server].readData();\n-        Ex result = new Ex();\n-        result.i = i;\n-        result.expected = expected;\n-        result.server = ps[server].debug();\n-        result.actual = Boolean.valueOf(reply);\n-        result.user = reqs.get(old).user;\n-        result.peer = reqs.get(old).peer;\n-        result.old = old;\n-        result.csize = csize(result.peer);\n-        result.hash = hash(reqs.get(old).msg);\n-        if (new File(dfl(result.peer)).exists()) {\n-            Files.copy(Paths.get(dfl(result.peer)), Paths.get(\n-                String.format(\"%03d-USER%d-host%d-%s-%s\",\n-                    i, result.user, result.peer, result.server,\n-                    result.actual)\n-                + \"-\" + result.hash),\n-                StandardCopyOption.COPY_ATTRIBUTES);\n+\n+    \/\/ create a acceptor\n+    private static Proc acceptor(String type, String suffix) throws Exception {\n+        Proc p;\n+        String label;\n+        String lib;\n+        int pos = type.indexOf('=');\n+        if (pos < 0) {\n+            label = type;\n+            lib = null;\n+        } else {\n+            label = type.substring(0, pos);\n+            lib = type.substring(pos + 1);\n@@ -268,25 +362,31 @@\n-        return result;\n-    }\n-    \/\/ create a native server\n-    private static Proc ns(int i) throws Exception {\n-        return Proc.create(\"ReplayCacheTestProc\")\n-                .args(\"N\"+i)\n-                .env(\"KRB5_CONFIG\", OneKDC.KRB5_CONF)\n-                .env(\"KRB5_KTNAME\", OneKDC.KTAB)\n-                .env(\"KRB5RCACHEDIR\", cwd)\n-                .prop(\"sun.security.jgss.native\", \"true\")\n-                .prop(\"javax.security.auth.useSubjectCredsOnly\", \"false\")\n-                .prop(\"sun.security.nativegss.debug\", \"true\")\n-                .prop(\"sun.net.spi.nameservice.provider.1\", \"ns,mock\")\n-                .debug(\"N\"+i)\n-                .start();\n-    }\n-    \/\/ creates a java server\n-    private static Proc js(int i) throws Exception {\n-        return Proc.create(\"ReplayCacheTestProc\")\n-                .debug(\"S\"+i)\n-                .args(\"S\"+i)\n-                .prop(\"sun.security.krb5.rcache\", \"dfl\")\n-                .prop(\"java.io.tmpdir\", cwd)\n-                .prop(\"sun.net.spi.nameservice.provider.1\", \"ns,mock\")\n-                .start();\n+        if (type.startsWith(\"J\")) {\n+            if (lib == null) {\n+                p = Proc.create(\"ReplayCacheTestProc\");\n+            } else {\n+                p = Proc.create(\"ReplayCacheTestProc\", lib);\n+            }\n+            p.prop(\"sun.security.krb5.rcache\", \"dfl\")\n+                    .prop(\"java.io.tmpdir\", cwd)\n+                    .prop(\"sun.net.spi.nameservice.provider.1\", \"ns,mock\");\n+            String useMD5 = System.getProperty(\"jdk.krb5.rcache.useMD5\");\n+            if (useMD5 != null) {\n+                p.prop(\"jdk.krb5.rcache.useMD5\", useMD5);\n+            }\n+        } else {\n+            p = Proc.create(\"ReplayCacheTestProc\")\n+                    .env(\"KRB5_CONFIG\", OneKDC.KRB5_CONF)\n+                    .env(\"KRB5_KTNAME\", OneKDC.KTAB)\n+                    .env(\"KRB5RCACHEDIR\", cwd)\n+                    .prop(\"sun.security.jgss.native\", \"true\")\n+                    .prop(\"javax.security.auth.useSubjectCredsOnly\", \"false\")\n+                    .prop(\"sun.security.nativegss.debug\", \"true\")\n+                    .prop(\"sun.net.spi.nameservice.provider.1\", \"ns,mock\");\n+            if (lib != null) {\n+                String libDir = lib.substring(0, lib.lastIndexOf('\/'));\n+                p.prop(\"sun.security.jgss.lib\", lib)\n+                        .env(\"DYLD_LIBRARY_PATH\", libDir)\n+                        .env(\"LD_LIBRARY_PATH\", libDir);\n+            }\n+        }\n+        Proc.d(label+suffix+\" started\");\n+        return p.args(label+suffix).debug(label+suffix).start();\n@@ -294,0 +394,1 @@\n+\n@@ -295,2 +396,2 @@\n-    private static String hash(String req) throws Exception {\n-        byte[] data = Base64.getDecoder().decode(req);\n+    private static void record(String label, Req req) throws Exception {\n+        byte[] data = Base64.getDecoder().decode(req.msg);\n@@ -298,1 +399,13 @@\n-        byte[] hash = MessageDigest.getInstance(\"MD5\").digest(new APReq(data).authenticator.getBytes());\n+\n+        try (PrintStream ps = new PrintStream(\n+                new FileOutputStream(\"log.txt\", true))) {\n+            ps.printf(\"%s:\\nmsg: %s\\nMD5: %s\\nSHA-256: %s\\n\\n\",\n+                    label,\n+                    req.msg,\n+                    hex(md5.digest(data)),\n+                    hex(sha256.digest(data)));\n+        }\n+    }\n+\n+    \/\/ Returns a compact hexdump for a byte array\n+    private static String hex(byte[] hash) {\n@@ -307,0 +420,1 @@\n+\n@@ -310,1 +424,1 @@\n-                Paths.get(dfl(p)), StandardOpenOption.READ)) {\n+                Paths.get(cwd, dfl(p)), StandardOpenOption.READ)) {\n@@ -325,0 +439,1 @@\n+\n@@ -328,0 +443,2 @@\n+        int req;            \/\/ which ap-req to send\n+        Proc acceptor;      \/\/ which acceptor to send to\n@@ -329,0 +446,1 @@\n+\n@@ -330,5 +448,0 @@\n-        int old;            \/\/ which ap-req to send\n-        String server;      \/\/ which server to send to\n-        String hash;        \/\/ the hash of req\n-        int user;           \/\/ which initiator\n-        int peer;           \/\/ which acceptor\n@@ -336,0 +449,27 @@\n+        String hash;        \/\/ the hash of req\n+\n+        Ex(int i, int req, Proc acceptor, boolean expected) {\n+            this.i = i;\n+            this.req = req;\n+            this.acceptor = acceptor;\n+            this.expected = expected;\n+        }\n+\n+        void run() throws Exception {\n+            Req r = reqs.get(req);\n+            acceptor.println(\"TEST\");\n+            acceptor.println(r.msg);\n+            String reply = acceptor.readData();\n+\n+            actual = Boolean.valueOf(reply);\n+            csize = csize(r.service);\n+\n+            String label = String.format(\"%03d-CLIENT%d-SERVICE%d-%s-%s\",\n+                    i, r.client, r.service, acceptor.debug(), actual);\n+\n+            record(label, r);\n+            if (new File(cwd, dfl(r.service)).exists()) {\n+                Files.copy(Paths.get(cwd, dfl(r.service)), Paths.get(label),\n+                        StandardCopyOption.COPY_ATTRIBUTES);\n+            }\n+        }\n@@ -337,0 +477,1 @@\n+\n@@ -340,3 +481,3 @@\n-        int user;           \/\/ which initiator\n-        int peer;           \/\/ which accceptor\n-        Req(int user, int peer, String msg) {\n+        int client;         \/\/ which client\n+        int service;        \/\/ which service\n+        Req(int client, int service, String msg) {\n@@ -344,2 +485,21 @@\n-            this.user= user;\n-            this.peer = peer;\n+            this.client= client;\n+            this.service = service;\n+        }\n+    }\n+\n+    private static class UserRun {\n+        static final Pattern p\n+                = Pattern.compile(\"(c(\\\\d)+s(\\\\d+)|r(\\\\d+))(.*)(.)\");\n+        final Matcher m;\n+\n+        UserRun(String run) { m = p.matcher(run); m.find(); }\n+\n+        int req() { return group(4); }\n+        int client() { return group(2); }\n+        int service() { return group(3); }\n+        String acceptor() { return m.group(5); }\n+        boolean success() { return m.group(6).equals(\"v\"); }\n+\n+        int group(int i) {\n+            String g = m.group(i);\n+            return g == null ? -1 : Integer.parseInt(g);\n","filename":"jdk\/test\/sun\/security\/krb5\/auto\/ReplayCacheTestProc.java","additions":315,"deletions":155,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+#\n+# Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 8168518\n+# @library ..\/..\/..\/..\/java\/security\/testlibrary\/ \/test\/lib\n+# @run main\/othervm\/timeout=300 -Dsun.net.spi.nameservice.provider.1=ns,mock -Djdk.krb5.rcache.useMD5=true ReplayCacheTestProc\n+# @summary  testing jdk.krb5.rcache.useMD5. This action is put in a separate\n+#           test so that ReplayCacheTestProc.java can be launched with special\n+#           test.* system properties easily.\n","filename":"jdk\/test\/sun\/security\/krb5\/auto\/rcache_usemd5.sh","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"}]}