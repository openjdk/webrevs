{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,4 +106,6 @@\n-    static final String JAVA_FILE_EXT  = \".java\";\n-    static final String CLASS_FILE_EXT = \".class\";\n-    static final String JAR_FILE_EXT   = \".jar\";\n-    static final String EXE_FILE_EXT   = \".exe\";\n+    static final String JAVA_FILE_EXT   = \".java\";\n+    static final String CLASS_FILE_EXT  = \".class\";\n+    static final String JAR_FILE_EXT    = \".jar\";\n+    static final String EXE_FILE_EXT    = \".exe\";\n+    static final String MAC_DSYM_EXT    = \".dsym\";\n+    static final String NIX_DBGINFO_EXT = \".debuginfo\";\n@@ -509,0 +511,37 @@\n+    static class ToolFilter implements FileFilter {\n+        final List<String> exclude = new ArrayList<>();\n+        protected ToolFilter(String... exclude) {\n+            for (String x : exclude) {\n+                String str = x + ((isWindows) ? EXE_FILE_EXT : \"\");\n+                this.exclude.add(str.toLowerCase());\n+            }\n+        }\n+\n+        @Override\n+        public boolean accept(File pathname) {\n+            if (!pathname.isFile() || !pathname.canExecute()) {\n+                return false;\n+            }\n+            String name = pathname.getName().toLowerCase();\n+            if (isWindows) {\n+                if (!name.endsWith(EXE_FILE_EXT)) {\n+                    return false;\n+                }\n+            } else if (isMacOSX) {\n+                if (name.endsWith(MAC_DSYM_EXT)) {\n+                    return false;\n+                }\n+            } else {\n+                if (name.endsWith(NIX_DBGINFO_EXT)) {\n+                    return false;\n+                }\n+            }\n+            for (String x : exclude) {\n+                if (name.endsWith(x)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n","filename":"jdk\/test\/tools\/launcher\/TestHelper.java","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.io.FileFilter;\n-import java.util.Map;\n@@ -38,0 +36,1 @@\n+import java.util.HashSet;\n@@ -39,0 +38,2 @@\n+import java.util.Map;\n+import java.util.Set;\n@@ -230,28 +231,0 @@\n-\n-    static class ToolFilter implements FileFilter {\n-        final Iterable<String> exclude ;\n-        protected ToolFilter(String... exclude) {\n-            List<String> tlist = new ArrayList<>();\n-            this.exclude = tlist;\n-            for (String x : exclude) {\n-                String str = x + ((isWindows) ? EXE_FILE_EXT : \"\");\n-                tlist.add(str.toLowerCase());\n-            }\n-        }\n-        @Override\n-        public boolean accept(File pathname) {\n-            if (!pathname.isFile() || !pathname.canExecute()) {\n-                return false;\n-            }\n-            String name = pathname.getName().toLowerCase();\n-            if (isWindows && !name.endsWith(EXE_FILE_EXT)) {\n-                return false;\n-            }\n-            for (String x : exclude) {\n-                if (name.endsWith(x)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-    }\n","filename":"jdk\/test\/tools\/launcher\/VersionCheck.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -440,14 +440,108 @@\n-  ifeq ($$($1_STATIC_LIBRARY),)\n-    ifneq ($$($1_DEBUG_SYMBOLS),)\n-      ifeq ($(ENABLE_DEBUG_SYMBOLS), true)\n-        ifneq ($$($1_OUTPUT_DIR),$$($1_OBJECT_DIR))\n-          ifeq ($(OPENJDK_TARGET_OS), macosx)\n-            # MacOS debug symbols are in %.dSYM directories\n-            $$($1_OUTPUT_DIR)\/$$($1_BASENAME).dSYM\/Contents\/Info.plist : $$($1_OBJECT_DIR)\/$$($1_BASENAME).dSYM\/Contents\/Info.plist\n-\t\tmkdir -p $$(@D)\n-\t\t$(CP) $$< $$@\n-            $$($1_OUTPUT_DIR)\/$$($1_BASENAME).dSYM\/Contents\/Resources\/DWARF\/$$($1_BASENAME) : $$($1_OBJECT_DIR)\/$$($1_BASENAME).dSYM\/Contents\/Resources\/DWARF\/$$($1_BASENAME)\n-\t\tmkdir -p $$(@D)\n-\t\t$(CP) $$< $$@\n-            $$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).diz : $$($1_OBJECT_DIR)\/$$($1_NOSUFFIX).diz\n-\t\t$(CP) $$< $$@\n+\n+  ifneq ($$($1_COPY_DEBUG_SYMBOLS), false)\n+    $1_COPY_DEBUG_SYMBOLS := $(COPY_DEBUG_SYMBOLS)\n+  endif\n+\n+  ifneq ($$($1_ZIP_EXTERNAL_DEBUG_SYMBOLS), false)\n+    $1_ZIP_EXTERNAL_DEBUG_SYMBOLS := $(ZIP_EXTERNAL_DEBUG_SYMBOLS)\n+  endif\n+\n+  ifeq ($$($1_COPY_DEBUG_SYMBOLS), true)\n+    ifneq ($$($1_DEBUG_SYMBOLS), false)\n+      # Only copy debug symbols for dynamic libraries and programs.\n+      ifneq ($$($1_TYPE), STATIC_LIBRARY)\n+        # Generate debuginfo files.\n+        ifeq ($(OPENJDK_TARGET_OS), windows)\n+          $1_EXTRA_LDFLAGS += -debug \"-pdb:$$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).pdb\" \\\n+              \"-map:$$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).map\"\n+          ifeq ($(SHIP_DEBUG_SYMBOLS), public)\n+            $1_EXTRA_LDFLAGS += \"-pdbstripped:$$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).stripped.pdb\"\n+          endif\n+          $1_DEBUGINFO_FILES := $$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).pdb \\\n+              $$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).map\n+\n+        else ifneq ($(findstring $(OPENJDK_TARGET_OS), linux solaris), )\n+          $1_DEBUGINFO_FILES := $$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).debuginfo\n+          # Setup the command line creating debuginfo files, to be run after linking.\n+          # It cannot be run separately since it updates the original target file\n+          $1_CREATE_DEBUGINFO_CMDS := \\\n+              $$($1_OBJCOPY) --only-keep-debug $$($1_TARGET) $$($1_DEBUGINFO_FILES) $$(NEWLINE) \\\n+              $(CD) $$($1_OUTPUT_DIR) && \\\n+                  $$($1_OBJCOPY) --add-gnu-debuglink=$$($1_DEBUGINFO_FILES) $$($1_TARGET)\n+\n+        else ifeq ($(OPENJDK_TARGET_OS), macosx)\n+          $1_DEBUGINFO_FILES := \\\n+              $$($1_OUTPUT_DIR)\/$$($1_BASENAME).dSYM\/Contents\/Info.plist \\\n+              $$($1_OUTPUT_DIR)\/$$($1_BASENAME).dSYM\/Contents\/Resources\/DWARF\/$$($1_BASENAME)\n+          $1_CREATE_DEBUGINFO_CMDS := \\\n+              $(DSYMUTIL) --out $$($1_OUTPUT_DIR)\/$$($1_BASENAME).dSYM $$($1_TARGET)\n+        endif # OPENJDK_TARGET_OS\n+\n+        # Since the link rule creates more than one file that we want to track,\n+        # we have to use some tricks to get make to cooperate. To properly\n+        # trigger downstream dependants of $$($1_DEBUGINFO_FILES), we must have\n+        # a recipe in the rule below. To avoid rerunning the recipe every time\n+        # have it touch the target. If a debuginfo file is deleted by something\n+        # external, explicitly delete the TARGET to trigger a rebuild of both.\n+        ifneq ($$(wildcard $$($1_DEBUGINFO_FILES)), $$($1_DEBUGINFO_FILES))\n+          $$(call LogDebug, Deleting $$($1_BASENAME) because debuginfo files are missing)\n+          $$(shell $(RM) $$($1_TARGET))\n+        endif\n+        $$($1_DEBUGINFO_FILES): $$($1_TARGET)\n+\t\t$$(if $$(CORRECT_FUNCTION_IN_RECIPE_EVALUATION), \\\n+\t\t  $$(if $$(wildcard $$@), , $$(error $$@ was not created for $$<)) \\\n+\t\t)\n+\t\t$(TOUCH) $$@\n+\n+        $1 += $$($1_DEBUGINFO_FILES)\n+\n+        ifeq ($$($1_ZIP_EXTERNAL_DEBUG_SYMBOLS), true)\n+          $1_DEBUGINFO_ZIP := $$($1_OUTPUT_DIR)\/$$($1_NOSUFFIX).diz\n+          $1 += $$($1_DEBUGINFO_ZIP)\n+\n+          # The dependency on TARGET is needed for debuginfo files\n+          # to be rebuilt properly.\n+          $$($1_DEBUGINFO_ZIP): $$($1_DEBUGINFO_FILES) $$($1_TARGET)\n+\t\t$(CD) $$($1_OUTPUT_DIR) && \\\n+\t\t    $(ZIPEXE) -q -r $$@ $$(subst $$($1_OUTPUT_DIR)\/,, $$($1_DEBUGINFO_FILES))\n+\n+        endif\n+       endif # !STATIC_LIBRARY\n+    endif # $1_DEBUG_SYMBOLS != false\n+  endif # COPY_DEBUG_SYMBOLS\n+\n+  # Unless specifically set, stripping should only happen if symbols are also\n+  # being copied.\n+  $$(call SetIfEmpty, $1_STRIP_SYMBOLS, $$($1_COPY_DEBUG_SYMBOLS))\n+\n+  ifneq ($$($1_STRIP_SYMBOLS), false)\n+    ifneq ($$($1_STRIP), )\n+      # Default to using the global STRIPFLAGS. Allow for overriding with an empty value\n+      $1_STRIPFLAGS ?= $(STRIPFLAGS)\n+      $1_STRIP_CMD := $$($1_STRIP) $$($1_STRIPFLAGS) $$($1_TARGET)\n+    endif\n+  endif\n+\n+  ifeq ($$($1_TYPE), STATIC_LIBRARY)\n+    $1_VARDEPS := $$($1_AR) $$($1_ARFLAGS) $$($1_LIBS) \\\n+        $$($1_EXTRA_LIBS)\n+    $1_VARDEPS_FILE := $$(call DependOnVariable, $1_VARDEPS, \\\n+        $$($1_OBJECT_DIR)\/$$($1_NOSUFFIX).vardeps)\n+\n+    # Generating a static library, ie object file archive.\n+    ifeq ($(STATIC_BUILD), true)\n+      ifeq ($$($1_USE_MAPFILE_FOR_SYMBOLS), true)\n+        STATIC_MAPFILE_DEP := $$($1_MAPFILE)\n+      endif\n+    endif\n+\n+    $1_TARGET_DEPS := $$($1_ALL_OBJS) $$($1_RES) $$($1_VARDEPS_FILE) $$(STATIC_MAPFILE_DEP)\n+\n+    $$($1_TARGET): $$($1_TARGET_DEPS)\n+\t$$(call LogInfo, Building static library $$($1_BASENAME))\n+\t$$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_link, \\\n+\t    $$($1_AR) $$($1_ARFLAGS) $(AR_OUT_OPTION)$$($1_TARGET) $$($1_ALL_OBJS) \\\n+\t        $$($1_RES))\n+        ifeq ($(STATIC_BUILD), true)\n+          ifeq ($$($1_USE_MAPFILE_FOR_SYMBOLS), true)\n+\t    $(CP) $$($1_MAPFILE) $$(@D)\/$$(basename $$(@F)).symbols\n","filename":"make\/common\/NativeCompilation.gmk","additions":109,"deletions":15,"binary":false,"changes":124,"status":"modified"}]}