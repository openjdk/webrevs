{"files":[{"patch":"@@ -175,0 +175,10 @@\n+\t<LI><P><B>http.keepAlive.time.server<\/B> and\n+\t<B>http.keepAlive.time.proxy<\/B> <\/P>\n+\t<P>These properties modify the behavior of the HTTP keepalive cache in the case\n+\twhere the server (or proxy) has not specified a keepalive time. If the\n+\tproperty is set in this case, then idle connections will be closed after the\n+\tspecified number of seconds. If the property is set, and the server does\n+\tspecify a keepalive time in a \"Keep-Alive\" response header, then the time specified\n+\tby the server is used. If the property is not set and also the server\n+\tdoes not specify a keepalive time, then connections are kept alive for an\n+\timplementation defined time, assuming {@code http.keepAlive} is {@code true}.<\/P>\n","filename":"jdk\/src\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,7 +117,7 @@\n-    \/**Idle timeout value, in milliseconds. Zero means infinity,\n-     * iff keepingAlive=true.\n-     * Unfortunately, we can't always believe this one.  If I'm connected\n-     * through a Netscape proxy to a server that sent me a keep-alive\n-     * time of 15 sec, the proxy unilaterally terminates my connection\n-     * after 5 sec.  So we have to hard code our effective timeout to\n-     * 4 sec for the case where we're using a proxy. *SIGH*\n+    \/*\n+     * The timeout if specified by the server. Following values possible\n+     *  0: the server specified no keep alive headers\n+     * -1: the server provided \"Connection: keep-alive\" but did not specify a\n+     *     a particular time in a \"Keep-Alive:\" headers\n+     * Positive values are the number of seconds specified by the server\n+     * in a \"Keep-Alive\" header\n@@ -819,1 +819,1 @@\n-                        keepAliveTimeout = p.findInt(\"timeout\", usingProxy?60:5);\n+                        keepAliveTimeout = p.findInt(\"timeout\", -1);\n@@ -1073,0 +1073,4 @@\n+    public boolean getUsingProxy() {\n+        return usingProxy;\n+    }\n+\n","filename":"jdk\/src\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayDeque;\n@@ -32,1 +38,5 @@\n-import java.net.URL;\n+import java.util.List;\n+\n+import sun.security.action.GetIntegerAction;\n+import sun.net.www.protocol.http.HttpURLConnection;\n+import sun.util.logging.PlatformLogger;\n@@ -45,0 +55,26 @@\n+    \/\/ Keep alive time set according to priority specified here:\n+    \/\/ 1. If server specifies a time with a Keep-Alive header\n+    \/\/ 2. If user specifies a time with system property below\n+    \/\/ 3. Default values which depend on proxy vs server and whether\n+    \/\/    a Connection: keep-alive header was sent by server\n+\n+    \/\/ name suffixed with \"server\" or \"proxy\"\n+    private static final String keepAliveProp = \"http.keepAlive.time.\";\n+\n+    private static final int userKeepAliveServer;\n+    private static final int userKeepAliveProxy;\n+\n+    static final PlatformLogger logger = HttpURLConnection.getHttpLogger();\n+\n+    @SuppressWarnings(\"removal\")\n+    static int getUserKeepAliveSeconds(String type) {\n+        int v = AccessController.doPrivileged(\n+            new GetIntegerAction(keepAliveProp+type, -1)).intValue();\n+        return v < -1 ? -1 : v;\n+    }\n+\n+    static {\n+        userKeepAliveServer = getUserKeepAliveSeconds(\"server\");\n+        userKeepAliveProxy = getUserKeepAliveSeconds(\"proxy\");\n+    }\n+\n@@ -55,3 +91,2 @@\n-            result = java.security.AccessController.doPrivileged(\n-                new sun.security.action.GetIntegerAction(\"http.maxConnections\",\n-                                                         MAX_CONNECTIONS))\n+            result = AccessController.doPrivileged(\n+                new GetIntegerAction(\"http.maxConnections\", MAX_CONNECTIONS))\n@@ -59,1 +94,1 @@\n-            if (result <= 0)\n+            if (result <= 0) {\n@@ -61,0 +96,1 @@\n+            }\n@@ -62,1 +98,1 @@\n-            return result;\n+        return result;\n@@ -95,2 +131,1 @@\n-            java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<Void>() {\n+            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n@@ -123,4 +158,23 @@\n-            v = new ClientVector(keepAliveTimeout > 0?\n-                                 keepAliveTimeout*1000 : LIFETIME);\n-            v.put(http);\n-            super.put(key, v);\n+                if (keepAliveTimeout == 0) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ same default for server and proxy\n+                        keepAliveTimeout = 5;\n+                    }\n+                } else if (keepAliveTimeout == -1) {\n+                    keepAliveTimeout = getUserKeepAlive(http.getUsingProxy());\n+                    if (keepAliveTimeout == -1) {\n+                        \/\/ different default for server and proxy\n+                        keepAliveTimeout = http.getUsingProxy() ? 60 : 5;\n+                    }\n+                }\n+                \/\/ at this point keepAliveTimeout is the number of seconds to keep\n+                \/\/ alive, which could be 0, if the user specified 0 for the property\n+                assert keepAliveTimeout >= 0;\n+                if (keepAliveTimeout == 0) {\n+                    http.closeServer();\n+                } else {\n+                    v = new ClientVector(keepAliveTimeout * 1000);\n+                    v.put(http);\n+                    super.put(key, v);\n+                }\n@@ -132,0 +186,5 @@\n+    \/\/ returns the keep alive set by user in system property or -1 if not set\n+    private static int getUserKeepAlive(boolean isProxy) {\n+        return isProxy ? userKeepAliveProxy : userKeepAliveServer;\n+    }\n+\n@@ -133,1 +192,1 @@\n-    public synchronized void remove (HttpClient h, Object obj) {\n+    public synchronized void remove(HttpClient h, Object obj) {\n@@ -138,1 +197,1 @@\n-            if (v.empty()) {\n+            if (v.isEmpty()) {\n@@ -174,10 +233,0 @@\n-            synchronized (this) {\n-                \/* Remove all unused HttpClients.  Starting from the\n-                 * bottom of the stack (the least-recently used first).\n-                 * REMIND: It'd be nice to not remove *all* connections\n-                 * that aren't presently in use.  One could have been added\n-                 * a second ago that's still perfectly valid, and we're\n-                 * needlessly axing it.  But it's not clear how to do this\n-                 * cleanly, and doing it right may be more trouble than it's\n-                 * worth.\n-                 *\/\n@@ -185,0 +234,2 @@\n+            \/\/ Remove all outdated HttpClients.\n+            synchronized (this) {\n@@ -186,3 +237,1 @@\n-\n-                ArrayList<KeepAliveKey> keysToRemove\n-                    = new ArrayList<KeepAliveKey>();\n+                List<KeepAliveKey> keysToRemove = new ArrayList<>();\n@@ -193,4 +242,2 @@\n-                        int i;\n-\n-                        for (i = 0; i < v.size(); i++) {\n-                            KeepAliveEntry e = v.elementAt(i);\n+                        KeepAliveEntry e = v.peek();\n+                        while (e != null) {\n@@ -198,2 +245,2 @@\n-                                HttpClient h = e.hc;\n-                                h.closeServer();\n+                                v.poll();\n+                                e.hc.closeServer();\n@@ -203,0 +250,1 @@\n+                            e = v.peek();\n@@ -204,1 +252,0 @@\n-                        v.subList(0, i).clear();\n@@ -206,1 +253,1 @@\n-                        if (v.size() == 0) {\n+                        if (v.isEmpty()) {\n@@ -216,3 +263,1 @@\n-        } while (size() > 0);\n-\n-        return;\n+        } while (!isEmpty());\n@@ -224,2 +269,1 @@\n-    private void writeObject(java.io.ObjectOutputStream stream)\n-    throws IOException {\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n@@ -229,2 +273,3 @@\n-    private void readObject(java.io.ObjectInputStream stream)\n-    throws IOException, ClassNotFoundException {\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException\n+    {\n@@ -238,3 +283,1 @@\n-\n-\n-class ClientVector extends java.util.Stack<KeepAliveEntry> {\n+class ClientVector extends ArrayDeque<KeepAliveEntry> {\n@@ -246,3 +289,1 @@\n-\n-\n-    ClientVector (int nap) {\n+    ClientVector(int nap) {\n@@ -253,1 +294,1 @@\n-        if (empty()) {\n+        if (isEmpty()) {\n@@ -255,13 +296,0 @@\n-        } else {\n-            \/\/ Loop until we find a connection that has not timed out\n-            HttpClient hc = null;\n-            long currentTime = System.currentTimeMillis();\n-            do {\n-                KeepAliveEntry e = pop();\n-                if ((currentTime - e.idleStartTime) > nap) {\n-                    e.hc.closeServer();\n-                } else {\n-                    hc = e.hc;\n-                }\n-            } while ((hc== null) && (!empty()));\n-            return hc;\n@@ -269,0 +297,18 @@\n+\n+        \/\/ Loop until we find a connection that has not timed out\n+        HttpClient hc = null;\n+        long currentTime = System.currentTimeMillis();\n+        do {\n+            KeepAliveEntry e = pop();\n+            if ((currentTime - e.idleStartTime) > nap) {\n+                e.hc.closeServer();\n+            } else {\n+                hc = e.hc;\n+                if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+                    String msg = \"cached HttpClient was idle for \"\n+                        + Long.toString(currentTime - e.idleStartTime);\n+                    KeepAliveCache.logger.finest(msg);\n+                }\n+            }\n+        } while ((hc == null) && (!isEmpty()));\n+        return hc;\n@@ -280,0 +326,10 @@\n+    \/* remove an HttpClient *\/\n+    synchronized boolean remove(HttpClient h) {\n+        for (KeepAliveEntry curr : this) {\n+            if (curr.hc == h) {\n+                return super.remove(curr);\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -283,2 +339,1 @@\n-    private void writeObject(java.io.ObjectOutputStream stream)\n-    throws IOException {\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n@@ -288,2 +343,3 @@\n-    private void readObject(java.io.ObjectInputStream stream)\n-    throws IOException, ClassNotFoundException {\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException\n+    {\n@@ -294,1 +350,0 @@\n-\n","filename":"jdk\/src\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":123,"deletions":68,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/lib\/testlibrary\n+ * @bug 8278067\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=30 KeepAliveProperty long\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=1 KeepAliveProperty short\n+ * @run main\/othervm -ea -Dhttp.keepAlive.time.server=0 KeepAliveProperty short\n+ *\/\n+\n+import java.net.*;\n+import java.io.*;\n+import java.nio.charset.*;\n+import java.util.logging.*;\n+import jdk.testlibrary.net.URIBuilder;\n+import static java.net.Proxy.NO_PROXY;\n+\n+public class KeepAliveProperty {\n+\n+    static volatile boolean pass = false;\n+\n+    static class Server extends Thread {\n+        final ServerSocket server;\n+\n+        Server (ServerSocket server) {\n+            super ();\n+            this.server = server;\n+        }\n+\n+        void readAll (Socket s) throws IOException {\n+            byte[] buf = new byte [128];\n+            int c;\n+            String request = \"\";\n+            InputStream is = s.getInputStream ();\n+            while ((c=is.read(buf)) > 0) {\n+                request += new String(buf, 0, c, StandardCharsets.US_ASCII);\n+                if (request.contains(\"\\r\\n\\r\\n\")) {\n+                    return;\n+                }\n+            }\n+            if (c == -1)\n+                throw new IOException(\"Socket closed\");\n+        }\n+\n+        Socket s = null;\n+        String BODY;\n+        String CLEN;\n+        PrintStream out;\n+\n+        public void run() {\n+            try {\n+                s = server.accept();\n+                readAll(s);\n+\n+                BODY = \"Hello world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+                out = new PrintStream(new BufferedOutputStream(s.getOutputStream() ));\n+\n+                \/* send the header *\/\n+                out.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out.print(CLEN);\n+                out.print(\"\\r\\n\");\n+                out.print(BODY);\n+                out.flush();\n+            } catch (Exception e) {\n+                pass = false;\n+                try {\n+                    if (s != null)\n+                        s.close();\n+                    server.close();\n+                } catch (IOException unused) {}\n+                return;\n+            }\n+\n+            \/\/ second request may legitimately fail\n+\n+            try (Socket s2 = s; ServerSocket server2 = server; PrintStream out2 = out) {\n+                \/\/ wait for second request.\n+                readAll(s2);\n+\n+                BODY = \"Goodbye world\";\n+                CLEN = \"Content-Length: \" + BODY.length() + \"\\r\\n\";\n+\n+                \/* send the header *\/\n+                out2.print(\"HTTP\/1.1 200 OK\\r\\n\");\n+                out2.print(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+                out2.print(CLEN);\n+                out2.print(\"\\r\\n\");\n+                out2.print(BODY);\n+                out2.flush();\n+                pass = !expectClose;\n+                if (!pass) System.out.println(\"Failed: expected close\");\n+            } catch (Exception e) {\n+                pass = expectClose;\n+                if (!pass) System.out.println(\"Failed: did not expect close\");\n+            }\n+        }\n+    }\n+\n+    static String fetch(URL url) throws Exception {\n+        InputStream in = url.openConnection(NO_PROXY).getInputStream();\n+        String s = \"\";\n+        byte b[] = new byte[128];\n+        int n;\n+        do {\n+            n = in.read(b);\n+            if (n > 0)\n+                s += new String(b, 0, n, StandardCharsets.US_ASCII);\n+        } while (n > 0);\n+        in.close();\n+        return s;\n+    }\n+\n+    static volatile boolean expectClose;\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ exercise the logging code\n+        Logger logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+        logger.setLevel(Level.FINEST);\n+        ConsoleHandler h = new ConsoleHandler();\n+        h.setLevel(Level.FINEST);\n+        logger.addHandler(h);\n+\n+        expectClose = args[0].equals(\"short\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ServerSocket ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n+        Server s = new Server(ss);\n+        s.start();\n+\n+        URL url = URIBuilder.newBuilder()\n+            .scheme(\"http\")\n+            .loopback()\n+            .port(ss.getLocalPort())\n+            .toURL();\n+        System.out.println(\"URL: \" + url);\n+\n+        if (!fetch(url).equals(\"Hello world\"))\n+            throw new RuntimeException(\"Failed on first request\");\n+\n+        \/\/ Wait a while to see if connection is closed\n+        Thread.sleep(3 * 1000);\n+\n+        try {\n+            if (!fetch(url).equals(\"Goodbye world\"))\n+                throw new RuntimeException(\"Failed on second request\");\n+        } catch (Exception e) {\n+            if (!expectClose)\n+                throw e;\n+        }\n+\n+        if (!pass)\n+            throw new RuntimeException(\"Failed in server\");\n+    }\n+}\n","filename":"jdk\/test\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}