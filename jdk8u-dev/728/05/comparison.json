{"files":[{"patch":"@@ -1031,1 +1031,1 @@\n-%% This notice is provided with respect to Freetype v2.9 which may be \n+%% This notice is provided with respect to Freetype v2.13.3 which may be\n@@ -1036,1 +1036,1 @@\n-## The FreeType Project: Freetype v2.10.4\n+## The FreeType Project: Freetype v2.13.3\n@@ -1058,1 +1058,21 @@\n-                   The FreeType Project LICENSE\n+\n+Copyright (C) 1996-2024 by David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2007-2024 by Dereg Clegg and Michael Toftdal.\n+Copyright (C) 1996-2024 by Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2022-2024 by David Turner, Robert Wilhelm, Werner Lemberg, George Williams, and\n+Copyright (C) 2004-2024 by Masatake YAMATO and Redhat K.K.\n+Copyright (C) 2007-2024 by Derek Clegg and Michael Toftdal.\n+Copyright (C) 2003-2024 by Masatake YAMATO, Red Hat K.K.,\n+Copyright (C) 1996-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n+Copyright (C) 2007-2024 by David Turner.\n+Copyright (C) 2022-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+Copyright (C) 2007-2024 by Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.\n+Copyright (C) 2008-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and suzuki toshiya.\n+Copyright (C) 2013-2024 by Google, Inc.\n+Copyright (C) 2019-2024 by Nikhil Ramakrishnan, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2009-2024 by Oran Agra and Mickey Gabel.\n+Copyright (C) 2018-2024 by David Turner, Robert Wilhelm, Dominik Röttsches, and Werner Lemberg.\n+Copyright (C) 2004-2024 by David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.\n+\n+\n+                    The FreeType Project LICENSE\n@@ -1223,1 +1243,1 @@\n-    http:\/\/www.freetype.org\n+    https:\/\/www.freetype.org\n@@ -1571,39 +1591,30 @@\n-#########################################################################\n-\n---- fthash.c and fthash.h are covered by the following notices ---\n-\n-\/*\n- * Copyright 2000 Computing Research Labs, New Mexico State University\n- * Copyright 2001-2015\n- *   Francesco Zappa Nardelli\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a\n- * copy of this software and associated documentation files (the \"Software\"),\n- * to deal in the Software without restriction, including without limitation\n- * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n- * and\/or sell copies of the Software, and to permit persons to whom the\n- * Software is furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n- * THE COMPUTING RESEARCH LAB OR NEW MEXICO STATE UNIVERSITY BE LIABLE FOR ANY\n- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n- * THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n- *\/\n-\n-  \/**************************************************************************\n-   *\n-   * This file is based on code from bdf.c,v 1.22 2000\/03\/16 20:08:50\n-   *\n-   * taken from Mark Leisher's xmbdfed package\n-   *\n-   *\/\n-   \n---- FreeType 2 PSaux module is covered by the following notices ---\n-\n-Copyright 2006-2014 Adobe Systems Incorporated.\n+```\n+\n+### Additional Freetype Attributions\n+```\n+\n+---------------------------------\n+The below applies to the following file(s):\n+libfreetype\/src\/psaux\/psarrst.c\n+libfreetype\/src\/psaux\/psarrst.h\n+libfreetype\/src\/psaux\/psblues.c\n+libfreetype\/src\/psaux\/psblues.h\n+libfreetype\/src\/psaux\/pserror.c\n+libfreetype\/src\/psaux\/pserror.h\n+libfreetype\/src\/psaux\/psfixed.h\n+libfreetype\/src\/psaux\/psfont.c\n+libfreetype\/src\/psaux\/psfont.h\n+libfreetype\/src\/psaux\/psft.c\n+libfreetype\/src\/psaux\/psft.h\n+libfreetype\/src\/psaux\/psglue.h\n+libfreetype\/src\/psaux\/pshints.c\n+libfreetype\/src\/psaux\/pshints.h\n+libfreetype\/src\/psaux\/psintrp.c\n+libfreetype\/src\/psaux\/psintrp.h\n+libfreetype\/src\/psaux\/psread.c\n+libfreetype\/src\/psaux\/psread.h\n+libfreetype\/src\/psaux\/psstack.c\n+libfreetype\/src\/psaux\/psstack.h\n+libfreetype\/src\/psaux\/pstypes.h\n+\n+Copyright (C) 2006-2014 Adobe Systems Incorporated.\n@@ -1638,1 +1649,0 @@\n-#########################################################################\n@@ -1640,0 +1650,1 @@\n+```\n@@ -1641,1 +1652,2 @@\n---- FreeType 2 PSaux module is covered by the following notices ---\n+### MIT License\n+```\n@@ -1643,1 +1655,4 @@\n-Copyright 2006-2014 Adobe Systems Incorporated.\n+---------------------------------\n+The below applies to the following file(s):\n+libfreetype\/include\/freetype\/internal\/fthash.h\n+libfreetype\/src\/base\/fthash.c\n@@ -1645,21 +1660,2 @@\n-This software, and all works of authorship, whether in source or\n-object code form as indicated by the copyright notice(s) included\n-herein (collectively, the \"Work\") is made available, and may only be\n-used, modified, and distributed under the FreeType Project License,\n-LICENSE.TXT.  Additionally, subject to the terms and conditions of the\n-FreeType Project License, each contributor to the Work hereby grants\n-to any individual or legal entity exercising permissions granted by\n-the FreeType Project License and this section (hereafter, \"You\" or\n-\"Your\") a perpetual, worldwide, non-exclusive, no-charge,\n-royalty-free, irrevocable (except as stated in this section) patent\n-license to make, have made, use, offer to sell, sell, import, and\n-otherwise transfer the Work, where such license applies only to those\n-patent claims licensable by such contributor that are necessarily\n-infringed by their contribution(s) alone or by combination of their\n-contribution(s) with the Work to which such contribution(s) was\n-submitted.  If You institute patent litigation against any entity\n-(including a cross-claim or counterclaim in a lawsuit) alleging that\n-the Work or a contribution incorporated within the Work constitutes\n-direct or contributory patent infringement, then any patent licenses\n-granted to You under this License for that Work shall terminate as of\n-the date such litigation is filed.\n+Copyright (C) 2000 Computing Research Labs, New Mexico State University\n+Copyright (C) 2001-2015\n@@ -1667,4 +1663,19 @@\n-By using, modifying, or distributing the Work you indicate that you\n-have read and understood the terms and conditions of the\n-FreeType Project License as well as those provided in this section,\n-and you accept them fully.\n+  Francesco Zappa Nardelli\n+\n+Permission is hereby granted, free of charge, to any person obtaining a\n+copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the\n+Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n+THE COMPUTING RESEARCH LAB OR NEW MEXICO STATE UNIVERSITY BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n+THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n@@ -1672,1 +1683,0 @@\n-#########################################################################\n","filename":"THIRD_PARTY_README","additions":82,"deletions":72,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-This is important because presently on Linux and Solaris the build\n+This is important because presently on Linux the build\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/UPDATING.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/ftconfig.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -780,0 +780,12 @@\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_OTSVG_H\n+   *\n+   * @description:\n+   *   A macro used in `#include` statements to name the file containing the\n+   *   FreeType~2 API which handles the OpenType 'SVG~' glyphs.\n+   *\/\n+#define FT_OTSVG_H  <freetype\/otsvg.h>\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/ftheader.h","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+\/\/ FT_USE_MODULE( FT_Driver_ClassRec, bdf_driver_class )\n@@ -25,1 +26,0 @@\n-FT_USE_MODULE( FT_Renderer_Class, ft_raster1_renderer_class )\n@@ -28,1 +28,4 @@\n-\/\/ FT_USE_MODULE( FT_Driver_ClassRec, bdf_driver_class )\n+FT_USE_MODULE( FT_Renderer_Class, ft_raster1_renderer_class )\n+\/\/ FT_USE_MODULE( FT_Renderer_Class, ft_sdf_renderer_class )\n+\/\/ FT_USE_MODULE( FT_Renderer_Class, ft_bitmap_sdf_renderer_class )\n+\/\/ FT_USE_MODULE( FT_Renderer_Class, ft_svg_renderer_class )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/ftmodule.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -108,2 +108,1 @@\n-   *                       cff:no-stem-darkening=1 \\\n-   *                       autofitter:warping=1\n+   *                       cff:no-stem-darkening=1\n@@ -223,0 +222,4 @@\n+   *\n+   *   If you use the GNU make build system directly (that is, without the\n+   *   `configure` script) and you define this macro, you also have to pass\n+   *   `SYSTEM_ZLIB=yes` as an argument to make.\n@@ -434,0 +437,17 @@\n+  \/**************************************************************************\n+   *\n+   * Logging\n+   *\n+   *   Compiling FreeType in debug or trace mode makes FreeType write error\n+   *   and trace log messages to `stderr`.  Enabling this macro\n+   *   automatically forces the `FT_DEBUG_LEVEL_ERROR` and\n+   *   `FT_DEBUG_LEVEL_TRACE` macros and allows FreeType to write error and\n+   *   trace log messages to a file instead of `stderr`.  For writing logs\n+   *   to a file, FreeType uses an the external `dlg` library (the source\n+   *   code is in `src\/dlg`).\n+   *\n+   *   This option needs a C99 compiler.\n+   *\/\n+\/* #define FT_DEBUG_LOGGING *\/\n+\n+\n@@ -444,3 +464,3 @@\n-   *     _af_debug_disable_horz_hints\n-   *     _af_debug_disable_vert_hints\n-   *     _af_debug_disable_blue_hints\n+   *     af_debug_disable_horz_hints_\n+   *     af_debug_disable_vert_hints_\n+   *     af_debug_disable_blue_hints_\n@@ -463,1 +483,1 @@\n-   *     _af_debug_hints\n+   *     af_debug_hints_\n@@ -510,0 +530,14 @@\n+  \/**************************************************************************\n+   *\n+   * OpenType SVG Glyph Support\n+   *\n+   *   Setting this macro enables support for OpenType SVG glyphs.  By\n+   *   default, FreeType can only fetch SVG documents.  However, it can also\n+   *   render them if external rendering hook functions are plugged in at\n+   *   runtime.\n+   *\n+   *   More details on the hooks can be found in file `otsvg.h`.\n+   *\/\n+\/* #define FT_CONFIG_OPTION_SVG *\/\n+\n+\n@@ -553,1 +587,1 @@\n-   * load and enumerate the glyph Postscript names in a TrueType or OpenType\n+   * load and enumerate Postscript names of glyphs in a TrueType or OpenType\n@@ -556,3 +590,3 @@\n-   * Note that when you do not compile the 'psnames' module by undefining the\n-   * above `FT_CONFIG_OPTION_POSTSCRIPT_NAMES`, the 'sfnt' module will\n-   * contain additional code used to read the PS Names table from a font.\n+   * Note that if you do not compile the 'psnames' module by undefining the\n+   * above `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` macro, the 'sfnt' module will\n+   * contain additional code to read the PostScript name table from a font.\n@@ -630,26 +664,1 @@\n-   * details on the LEAN option.\n-   *\n-   * There are three possible values.\n-   *\n-   * Value 1:\n-   *   This value is associated with the 'Infinality' moniker, contributed by\n-   *   an individual nicknamed Infinality with the goal of making TrueType\n-   *   fonts render better than on Windows.  A high amount of configurability\n-   *   and flexibility, down to rules for single glyphs in fonts, but also\n-   *   very slow.  Its experimental and slow nature and the original\n-   *   developer losing interest meant that this option was never enabled in\n-   *   default builds.\n-   *\n-   *   The corresponding interpreter version is v38.\n-   *\n-   * Value 2:\n-   *   The new default mode for the TrueType driver.  The Infinality code\n-   *   base was stripped to the bare minimum and all configurability removed\n-   *   in the name of speed and simplicity.  The configurability was mainly\n-   *   aimed at legacy fonts like 'Arial', 'Times New Roman', or 'Courier'.\n-   *   Legacy fonts are fonts that modify vertical stems to achieve clean\n-   *   black-and-white bitmaps.  The new mode focuses on applying a minimal\n-   *   set of rules to all fonts indiscriminately so that modern and web\n-   *   fonts render well while legacy fonts render okay.\n-   *\n-   *   The corresponding interpreter version is v40.\n+   * details on this option.\n@@ -657,3 +666,4 @@\n-   * Value 3:\n-   *   Compile both, making both v38 and v40 available (the latter is the\n-   *   default).\n+   * The new default mode focuses on applying a minimal set of rules to all\n+   * fonts indiscriminately so that modern and web fonts render well while\n+   * legacy fonts render okay.  The corresponding interpreter version is v40.\n+   * The so-called Infinality mode (v38) is no longer available in FreeType.\n@@ -674,3 +684,1 @@\n-\/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1         *\/\n-#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  2\n-\/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  ( 1 | 2 ) *\/\n+#define TT_CONFIG_OPTION_SUBPIXEL_HINTING\n@@ -708,0 +716,18 @@\n+  \/**************************************************************************\n+   *\n+   * Define `TT_CONFIG_OPTION_NO_BORING_EXPANSION` if you want to exclude\n+   * support for 'boring' OpenType specification expansions.\n+   *\n+   *   https:\/\/github.com\/harfbuzz\/boring-expansion-spec\n+   *\n+   * Right now, the following features are covered:\n+   *\n+   *   - 'avar' version 2.0\n+   *\n+   * Most likely, this is a temporary configuration option to be removed in\n+   * the near future, since it is assumed that eventually those features are\n+   * added to the OpenType standard.\n+   *\/\n+\/* #define TT_CONFIG_OPTION_NO_BORING_EXPANSION *\/\n+\n+\n@@ -734,0 +760,16 @@\n+  \/**************************************************************************\n+   *\n+   * Option `TT_CONFIG_OPTION_GPOS_KERNING` enables a basic GPOS kerning\n+   * implementation (for TrueType fonts only).  With this defined, FreeType\n+   * is able to get kerning pair data from the GPOS 'kern' feature as well as\n+   * legacy 'kern' tables; without this defined, FreeType will only be able\n+   * to use legacy 'kern' tables.\n+   *\n+   * Note that FreeType does not support more advanced GPOS layout features;\n+   * even the 'kern' feature implemented here doesn't handle more\n+   * sophisticated kerning variants.  Use a higher-level library like\n+   * HarfBuzz instead for that.\n+   *\/\n+\/* #define TT_CONFIG_OPTION_GPOS_KERNING *\/\n+\n+\n@@ -895,18 +937,0 @@\n-  \/**************************************************************************\n-   *\n-   * Compile 'autofit' module with warp hinting.  The idea of the warping\n-   * code is to slightly scale and shift a glyph within a single dimension so\n-   * that as much of its segments are aligned (more or less) on the grid.  To\n-   * find out the optimal scaling and shifting value, various parameter\n-   * combinations are tried and scored.\n-   *\n-   * You can switch warping on and off with the `warping` property of the\n-   * auto-hinter (see file `ftdriver.h` for more information; by default it\n-   * is switched off).\n-   *\n-   * This experimental option is not active if the rendering mode is\n-   * `FT_RENDER_MODE_LIGHT`.\n-   *\/\n-#define AF_CONFIG_OPTION_USE_WARPER\n-\n-\n@@ -946,1 +970,1 @@\n-   * The next three macros are defined if native TrueType hinting is\n+   * The next two macros are defined if native TrueType hinting is\n@@ -951,1 +975,0 @@\n-\n@@ -953,5 +976,0 @@\n-#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 1\n-#define  TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-#endif\n-\n-#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 2\n@@ -961,0 +979,14 @@\n+\n+\n+  \/*\n+   * The TT_SUPPORT_COLRV1 macro is defined to indicate to clients that this\n+   * version of FreeType has support for 'COLR' v1 API.  This definition is\n+   * useful to FreeType clients that want to build in support for 'COLR' v1\n+   * depending on a tip-of-tree checkout before it is officially released in\n+   * FreeType, and while the feature cannot yet be tested against using\n+   * version macros.  Don't change this macro.  This may be removed once the\n+   * feature is in a FreeType release version and version macros can be used\n+   * to test for availability.\n+   *\/\n+#ifdef TT_CONFIG_OPTION_COLOR_LAYERS\n+#define  TT_SUPPORT_COLRV1\n@@ -992,1 +1024,0 @@\n-FT_END_HEADER\n@@ -994,0 +1025,1 @@\n+FT_END_HEADER\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/ftoption.h","additions":101,"deletions":69,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -46,1 +46,2 @@\n-   * platforms the library has been tested on.\n+   * platforms the library has been tested on.  We also check `ULLONG_MAX`\n+   * to see whether we can use 64-bit `long long` later on.\n@@ -69,0 +70,9 @@\n+#ifdef LLONG_MAX\n+#define FT_LLONG_MAX   LLONG_MAX\n+#endif\n+#ifdef LLONG_MIN\n+#define FT_LLONG_MIN   LLONG_MIN\n+#endif\n+#ifdef ULLONG_MAX\n+#define FT_ULLONG_MAX  ULLONG_MAX\n+#endif\n@@ -104,7 +114,7 @@\n-#define FT_FILE     FILE\n-#define ft_fclose   fclose\n-#define ft_fopen    fopen\n-#define ft_fread    fread\n-#define ft_fseek    fseek\n-#define ft_ftell    ftell\n-#define ft_sprintf  sprintf\n+#define FT_FILE      FILE\n+#define ft_fclose    fclose\n+#define ft_fopen     fopen\n+#define ft_fread     fread\n+#define ft_fseek     fseek\n+#define ft_ftell     ftell\n+#define ft_snprintf  snprintf\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/ftstdlib.h","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -63,0 +63,12 @@\n+#ifndef FT_SIZEOF_LONG_LONG\n+\n+  \/* The size of a `long long` type if available *\/\n+#if defined( FT_ULLONG_MAX ) && FT_ULLONG_MAX >= 0xFFFFFFFFFFFFFFFFULL\n+#define FT_SIZEOF_LONG_LONG  ( 64 \/ FT_CHAR_BIT )\n+#else\n+#define FT_SIZEOF_LONG_LONG  0\n+#endif\n+\n+#endif \/* !defined(FT_SIZEOF_LONG_LONG) *\/\n+\n+\n@@ -177,2 +189,1 @@\n-  \/* determine whether we have a 64-bit `int` type for platforms without *\/\n-  \/* Autoconf                                                            *\/\n+  \/* determine whether we have a 64-bit integer type *\/\n@@ -181,2 +192,0 @@\n-  \/* `FT_LONG64` must be defined if a 64-bit type is available *\/\n-#define FT_LONG64\n@@ -186,0 +195,5 @@\n+#elif FT_SIZEOF_LONG_LONG >= ( 64 \/ FT_CHAR_BIT )\n+\n+#define FT_INT64   long long int\n+#define FT_UINT64  unsigned long long int\n+\n@@ -195,7 +209,1 @@\n-#if defined( __STDC_VERSION__ ) && __STDC_VERSION__ >= 199901L\n-\n-#define FT_LONG64\n-#define FT_INT64   long long int\n-#define FT_UINT64  unsigned long long int\n-\n-#elif defined( _MSC_VER ) && _MSC_VER >= 900 \/* Visual C++ (and Intel C++) *\/\n+#if defined( _MSC_VER ) && _MSC_VER >= 900 \/* Visual C++ (and Intel C++) *\/\n@@ -204,1 +212,0 @@\n-#define FT_LONG64\n@@ -214,1 +221,0 @@\n-#define FT_LONG64\n@@ -218,1 +224,1 @@\n-#elif defined( __WATCOMC__ )   \/* Watcom C++ *\/\n+#elif defined( __WATCOMC__ ) && __WATCOMC__ >= 1100  \/* Watcom C++ *\/\n@@ -220,1 +226,2 @@\n-  \/* Watcom doesn't provide 64-bit data types *\/\n+#define FT_INT64   long long int\n+#define FT_UINT64  unsigned long long int\n@@ -224,1 +231,0 @@\n-#define FT_LONG64\n@@ -231,1 +237,0 @@\n-#define FT_LONG64\n@@ -235,1 +240,1 @@\n-#endif \/* __STDC_VERSION__ >= 199901L *\/\n+#endif \/* !__STDC__ *\/\n@@ -239,1 +244,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/integer-types.h","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/mac-support.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020 by\n+ * Copyright (C) 2020-2024 by\n@@ -106,0 +106,1 @@\n+\n@@ -118,0 +119,17 @@\n+  \/*\n+   * Support for casts in both C and C++.\n+   *\/\n+#ifdef __cplusplus\n+#define FT_STATIC_CAST( type, var )       static_cast<type>(var)\n+#define FT_REINTERPRET_CAST( type, var )  reinterpret_cast<type>(var)\n+\n+#define FT_STATIC_BYTE_CAST( type, var )                         \\\n+          static_cast<type>( static_cast<unsigned char>( var ) )\n+#else\n+#define FT_STATIC_CAST( type, var )       (type)(var)\n+#define FT_REINTERPRET_CAST( type, var )  (type)(var)\n+\n+#define FT_STATIC_BYTE_CAST( type, var )  (type)(unsigned char)(var)\n+#endif\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/config\/public-macros.h","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -33,0 +33,28 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   preamble\n+   *\n+   * @title:\n+   *   Preamble\n+   *\n+   * @abstract:\n+   *   What FreeType is and isn't\n+   *\n+   * @description:\n+   *   FreeType is a library that provides access to glyphs in font files.  It\n+   *   scales the glyph images and their metrics to a requested size, and it\n+   *   rasterizes the glyph images to produce pixel or subpixel alpha coverage\n+   *   bitmaps.\n+   *\n+   *   Note that FreeType is _not_ a text layout engine.  You have to use\n+   *   higher-level libraries like HarfBuzz, Pango, or ICU for that.\n+   *\n+   *   Note also that FreeType does _not_ perform alpha blending or\n+   *   compositing the resulting bitmaps or pixmaps by itself.  Use your\n+   *   favourite graphics library (for example, Cairo or Skia) to further\n+   *   process FreeType's output.\n+   *\n+   *\/\n+\n+\n@@ -77,10 +105,0 @@\n-\n-  \/*************************************************************************\/\n-  \/*************************************************************************\/\n-  \/*                                                                       *\/\n-  \/*                        B A S I C   T Y P E S                          *\/\n-  \/*                                                                       *\/\n-  \/*************************************************************************\/\n-  \/*************************************************************************\/\n-\n-\n@@ -90,1 +108,1 @@\n-   *   base_interface\n+   *   font_testing_macros\n@@ -93,1 +111,1 @@\n-   *   Base Interface\n+   *   Font Testing Macros\n@@ -96,1 +114,1 @@\n-   *   The FreeType~2 base font interface.\n+   *   Macros to test various properties of fonts.\n@@ -99,13 +117,1 @@\n-   *   This section describes the most important public high-level API\n-   *   functions of FreeType~2.\n-   *\n-   * @order:\n-   *   FT_Library\n-   *   FT_Face\n-   *   FT_Size\n-   *   FT_GlyphSlot\n-   *   FT_CharMap\n-   *   FT_Encoding\n-   *   FT_ENC_TAG\n-   *\n-   *   FT_FaceRec\n+   *   Macros to test the most important font properties.\n@@ -113,15 +119,3 @@\n-   *   FT_FACE_FLAG_SCALABLE\n-   *   FT_FACE_FLAG_FIXED_SIZES\n-   *   FT_FACE_FLAG_FIXED_WIDTH\n-   *   FT_FACE_FLAG_HORIZONTAL\n-   *   FT_FACE_FLAG_VERTICAL\n-   *   FT_FACE_FLAG_COLOR\n-   *   FT_FACE_FLAG_SFNT\n-   *   FT_FACE_FLAG_CID_KEYED\n-   *   FT_FACE_FLAG_TRICKY\n-   *   FT_FACE_FLAG_KERNING\n-   *   FT_FACE_FLAG_MULTIPLE_MASTERS\n-   *   FT_FACE_FLAG_VARIATION\n-   *   FT_FACE_FLAG_GLYPH_NAMES\n-   *   FT_FACE_FLAG_EXTERNAL_STREAM\n-   *   FT_FACE_FLAG_HINTER\n+   *   It is recommended to use these high-level macros instead of directly\n+   *   testing the corresponding flags, which are scattered over various\n+   *   structures.\n@@ -129,0 +123,1 @@\n+   * @order:\n@@ -136,0 +131,3 @@\n+   *   FT_HAS_SVG\n+   *   FT_HAS_SBIX\n+   *   FT_HAS_SBIX_OVERLAY\n@@ -145,2 +143,4 @@\n-   *   FT_STYLE_FLAG_BOLD\n-   *   FT_STYLE_FLAG_ITALIC\n+   *\/\n+\n+\n+  \/**************************************************************************\n@@ -148,2 +148,2 @@\n-   *   FT_SizeRec\n-   *   FT_Size_Metrics\n+   * @section:\n+   *   library_setup\n@@ -151,3 +151,2 @@\n-   *   FT_GlyphSlotRec\n-   *   FT_Glyph_Metrics\n-   *   FT_SubGlyph\n+   * @title:\n+   *   Library Setup\n@@ -155,1 +154,9 @@\n-   *   FT_Bitmap_Size\n+   * @abstract:\n+   *   Functions to start and end the usage of the FreeType library.\n+   *\n+   * @description:\n+   *   Functions to start and end the usage of the FreeType library.\n+   *\n+   *   Note that @FT_Library_Version and @FREETYPE_XXX are of limited use\n+   *   because even a new release of FreeType with only documentation\n+   *   changes increases the version number.\n@@ -157,0 +164,2 @@\n+   * @order:\n+   *   FT_Library\n@@ -160,0 +169,27 @@\n+   *   FT_Library_Version\n+   *   FREETYPE_XXX\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   face_creation\n+   *\n+   * @title:\n+   *   Face Creation\n+   *\n+   * @abstract:\n+   *   Functions to manage fonts.\n+   *\n+   * @description:\n+   *   The functions and structures collected in this section operate on\n+   *   fonts globally.\n+   *\n+   * @order:\n+   *   FT_Face\n+   *   FT_FaceRec\n+   *   FT_FACE_FLAG_XXX\n+   *   FT_STYLE_FLAG_XXX\n+   *\n@@ -167,0 +203,1 @@\n+   *   FT_OPEN_XXX\n@@ -171,0 +208,25 @@\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   sizing_and_scaling\n+   *\n+   * @title:\n+   *   Sizing and Scaling\n+   *\n+   * @abstract:\n+   *   Functions to manage font sizes.\n+   *\n+   * @description:\n+   *   The functions and structures collected in this section are related to\n+   *   selecting and manipulating the size of a font globally.\n+   *\n+   * @order:\n+   *   FT_Size\n+   *   FT_SizeRec\n+   *   FT_Size_Metrics\n+   *\n+   *   FT_Bitmap_Size\n+   *\n@@ -178,0 +240,1 @@\n+   *\n@@ -179,6 +242,1 @@\n-   *   FT_Load_Glyph\n-   *   FT_Get_Char_Index\n-   *   FT_Get_First_Char\n-   *   FT_Get_Next_Char\n-   *   FT_Get_Name_Index\n-   *   FT_Load_Char\n+   *   FT_Get_Transform\n@@ -186,27 +244,17 @@\n-   *   FT_OPEN_MEMORY\n-   *   FT_OPEN_STREAM\n-   *   FT_OPEN_PATHNAME\n-   *   FT_OPEN_DRIVER\n-   *   FT_OPEN_PARAMS\n-   *\n-   *   FT_LOAD_DEFAULT\n-   *   FT_LOAD_RENDER\n-   *   FT_LOAD_MONOCHROME\n-   *   FT_LOAD_LINEAR_DESIGN\n-   *   FT_LOAD_NO_SCALE\n-   *   FT_LOAD_NO_HINTING\n-   *   FT_LOAD_NO_BITMAP\n-   *   FT_LOAD_NO_AUTOHINT\n-   *   FT_LOAD_COLOR\n-   *\n-   *   FT_LOAD_VERTICAL_LAYOUT\n-   *   FT_LOAD_IGNORE_TRANSFORM\n-   *   FT_LOAD_FORCE_AUTOHINT\n-   *   FT_LOAD_NO_RECURSE\n-   *   FT_LOAD_PEDANTIC\n-   *\n-   *   FT_LOAD_TARGET_NORMAL\n-   *   FT_LOAD_TARGET_LIGHT\n-   *   FT_LOAD_TARGET_MONO\n-   *   FT_LOAD_TARGET_LCD\n-   *   FT_LOAD_TARGET_LCD_V\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   glyph_retrieval\n+   *\n+   * @title:\n+   *   Glyph Retrieval\n+   *\n+   * @abstract:\n+   *   Functions to manage glyphs.\n+   *\n+   * @description:\n+   *   The functions and structures collected in this section operate on\n+   *   single glyphs, of which @FT_Load_Glyph is most important.\n@@ -214,0 +262,7 @@\n+   * @order:\n+   *   FT_GlyphSlot\n+   *   FT_GlyphSlotRec\n+   *   FT_Glyph_Metrics\n+   *\n+   *   FT_Load_Glyph\n+   *   FT_LOAD_XXX\n@@ -215,0 +270,1 @@\n+   *   FT_LOAD_TARGET_XXX\n@@ -221,2 +277,0 @@\n-   *   FT_Get_Glyph_Name\n-   *   FT_Get_Postscript_Name\n@@ -224,0 +278,25 @@\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   character_mapping\n+   *\n+   * @title:\n+   *   Character Mapping\n+   *\n+   * @abstract:\n+   *   Functions to manage character-to-glyph maps.\n+   *\n+   * @description:\n+   *   This section holds functions and structures that are related to\n+   *   mapping character input codes to glyph indices.\n+   *\n+   *   Note that for many scripts the simplistic approach used by FreeType\n+   *   of mapping a single character to a single glyph is not valid or\n+   *   possible!  In general, a higher-level library like HarfBuzz or ICU\n+   *   should be used for handling text strings.\n+   *\n+   * @order:\n+   *   FT_CharMap\n@@ -225,0 +304,3 @@\n+   *   FT_Encoding\n+   *   FT_ENC_TAG\n+   *\n@@ -229,0 +311,29 @@\n+   *   FT_Get_Char_Index\n+   *   FT_Get_First_Char\n+   *   FT_Get_Next_Char\n+   *   FT_Load_Char\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   information_retrieval\n+   *\n+   * @title:\n+   *   Information Retrieval\n+   *\n+   * @abstract:\n+   *   Functions to retrieve font and glyph information.\n+   *\n+   * @description:\n+   *   Functions to retrieve font and glyph information.  Only some very\n+   *   basic data is covered; see also the chapter on the format-specific\n+   *   API for more.\n+   *\n+   *\n+   * @order:\n+   *   FT_Get_Name_Index\n+   *   FT_Get_Glyph_Name\n+   *   FT_Get_Postscript_Name\n@@ -230,0 +341,1 @@\n+   *   FT_FSTYPE_XXX\n@@ -231,0 +343,19 @@\n+   *   FT_SUBGLYPH_FLAG_XXX\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   other_api_data\n+   *\n+   * @title:\n+   *   Other API Data\n+   *\n+   * @abstract:\n+   *   Other structures, enumerations, and macros.\n+   *\n+   * @description:\n+   *   Other structures, enumerations, and macros.  Deprecated functions are\n+   *   also listed here.\n@@ -232,0 +363,1 @@\n+   * @order:\n@@ -236,7 +368,1 @@\n-   *   FT_FACE_FLAG_XXX\n-   *   FT_STYLE_FLAG_XXX\n-   *   FT_OPEN_XXX\n-   *   FT_LOAD_XXX\n-   *   FT_LOAD_TARGET_XXX\n-   *   FT_SUBGLYPH_FLAG_XXX\n-   *   FT_FSTYPE_XXX\n+   *   FT_SubGlyph\n@@ -245,0 +371,2 @@\n+   *   FT_Face_CheckTrueTypePatents\n+   *   FT_Face_SetUnpatentedHinting\n@@ -249,0 +377,16 @@\n+  \/*************************************************************************\/\n+  \/*************************************************************************\/\n+  \/*                                                                       *\/\n+  \/*                        B A S I C   T Y P E S                          *\/\n+  \/*                                                                       *\/\n+  \/*************************************************************************\/\n+  \/*************************************************************************\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   glyph_retrieval\n+   *\n+   *\/\n+\n@@ -316,0 +460,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   sizing_and_scaling\n+   *\n+   *\/\n+\n@@ -376,0 +527,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   library_setup\n+   *\n+   *\/\n+\n@@ -450,1 +608,1 @@\n-   *   base_interface\n+   *   face_creation\n@@ -486,0 +644,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   sizing_and_scaling\n+   *\n+   *\/\n+\n@@ -496,3 +661,3 @@\n-   *   An @FT_Face has one _active_ @FT_Size object that is used by functions\n-   *   like @FT_Load_Glyph to determine the scaling transformation that in\n-   *   turn is used to load and hint glyphs and metrics.\n+   *   An @FT_Face has one _active_ `FT_Size` object that is used by\n+   *   functions like @FT_Load_Glyph to determine the scaling transformation\n+   *   that in turn is used to load and hint glyphs and metrics.\n@@ -500,1 +665,2 @@\n-   *   You can use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size\n+   *   A newly created `FT_Size` object contains only meaningless zero values.\n+   *   You must use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size\n@@ -502,1 +668,2 @@\n-   *   values) of the active @FT_Size.\n+   *   values) of the active `FT_Size`.  Otherwise, the scaling and hinting\n+   *   will not be performed.\n@@ -516,0 +683,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   glyph_retrieval\n+   *\n+   *\/\n+\n@@ -535,0 +709,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   character_mapping\n+   *\n+   *\/\n+\n@@ -590,5 +771,6 @@\n-#define FT_ENC_TAG( value, a, b, c, d )         \\\n-          value = ( ( (FT_UInt32)(a) << 24 ) |  \\\n-                    ( (FT_UInt32)(b) << 16 ) |  \\\n-                    ( (FT_UInt32)(c) <<  8 ) |  \\\n-                      (FT_UInt32)(d)         )\n+\n+#define FT_ENC_TAG( value, a, b, c, d )                             \\\n+          value = ( ( FT_STATIC_BYTE_CAST( FT_UInt32, a ) << 24 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( FT_UInt32, b ) << 16 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( FT_UInt32, c ) <<  8 ) | \\\n+                      FT_STATIC_BYTE_CAST( FT_UInt32, d )         )\n@@ -610,1 +792,1 @@\n-   *   repertories (i.e., charsets), and not text encoding methods (e.g.,\n+   *   repertoires (i.e., charsets), and not text encoding methods (e.g.,\n@@ -704,5 +886,10 @@\n-   *   By default, FreeType enables a Unicode charmap and tags it with\n-   *   `FT_ENCODING_UNICODE` when it is either provided or can be generated\n-   *   from PostScript glyph name dictionaries in the font file.  All other\n-   *   encodings are considered legacy and tagged only if explicitly defined\n-   *   in the font file.  Otherwise, `FT_ENCODING_NONE` is used.\n+   *   When loading a font, FreeType makes a Unicode charmap active if\n+   *   possible (either if the font provides such a charmap, or if FreeType\n+   *   can synthesize one from PostScript glyph name dictionaries; in either\n+   *   case, the charmap is tagged with `FT_ENCODING_UNICODE`).  If such a\n+   *   charmap is synthesized, it is placed at the first position of the\n+   *   charmap array.\n+   *\n+   *   All other encodings are considered legacy and tagged only if\n+   *   explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is\n+   *   used.\n@@ -738,1 +925,1 @@\n-   *   `TT_MAC_LANGID_FARSI` means the Farsi variant the Arabic encoding.\n+   *   `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding.\n@@ -836,0 +1023,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   other_api_data\n+   *\n+   *\/\n+\n@@ -851,0 +1045,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   face_creation\n+   *\n+   *\/\n+\n@@ -877,1 +1078,1 @@\n-   *     Bit 31 is always zero (this is, `face_index` is always a positive\n+   *     Bit 31 is always zero (that is, `face_index` is always a positive\n@@ -895,1 +1096,1 @@\n-   *     (sub)font.  Bit 31 is always zero (this is, `style_flags` is always\n+   *     (sub)font.  Bit 31 is always zero (that is, `style_flags` is always\n@@ -961,1 +1162,1 @@\n-   *     Note that the bounding box does not vary in OpenType variable fonts\n+   *     Note that the bounding box does not vary in OpenType variation fonts\n@@ -1049,3 +1250,3 @@\n-    \/*# The following member variables (down to `underline_thickness`) *\/\n-    \/*# are only relevant to scalable outlines; cf. @FT_Bitmap_Size    *\/\n-    \/*# for bitmap fonts.                                              *\/\n+    \/* The following member variables (down to `underline_thickness`) *\/\n+    \/* are only relevant to scalable outlines; cf. @FT_Bitmap_Size    *\/\n+    \/* for bitmap fonts.                                              *\/\n@@ -1069,1 +1270,1 @@\n-    \/*@private begin *\/\n+    \/* private fields, internal to FreeType *\/\n@@ -1082,2 +1283,0 @@\n-    \/*@private end *\/\n-\n@@ -1126,3 +1325,7 @@\n-   *     function always return the vector (0,0).  Note that FreeType doesn't\n-   *     handle kerning data from the SFNT 'GPOS' table (as present in many\n-   *     OpenType fonts).\n+   *     function always returns the vector (0,0).\n+   *\n+   *     Note that for TrueType fonts only, FreeType supports both the 'kern'\n+   *     table and the basic, pair-wise kerning feature from the 'GPOS' table\n+   *     (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled), though FreeType does\n+   *     not support the more advanced GPOS layout features; use a library\n+   *     like HarfBuzz for those instead.\n@@ -1166,1 +1369,1 @@\n-   *     Note that CID-keyed fonts that are in an SFNT wrapper (this is, all\n+   *     Note that CID-keyed fonts that are in an SFNT wrapper (that is, all\n@@ -1172,1 +1375,1 @@\n-   *     The face is 'tricky', this is, it always needs the font format's\n+   *     The face is 'tricky', that is, it always needs the font format's\n@@ -1194,2 +1397,15 @@\n-   *     @FT_Set_Var_Design_Coordinates, or @FT_Set_Var_Blend_Coordinates.\n-   *     This flag is unset by a call to @FT_Set_Named_Instance.\n+   *     @FT_Set_Var_Design_Coordinates, @FT_Set_Var_Blend_Coordinates, or\n+   *     @FT_Set_MM_WeightVector to select a non-default instance.\n+   *\n+   *   FT_FACE_FLAG_SVG ::\n+   *     [Since 2.12] The face has an 'SVG~' OpenType table.\n+   *\n+   *   FT_FACE_FLAG_SBIX ::\n+   *     [Since 2.12] The face has an 'sbix' OpenType table *and* outlines.\n+   *     For such fonts, @FT_FACE_FLAG_SCALABLE is not set by default to\n+   *     retain backward compatibility.\n+   *\n+   *   FT_FACE_FLAG_SBIX_OVERLAY ::\n+   *     [Since 2.12] The face has an 'sbix' OpenType table where outlines\n+   *     should be drawn on top of bitmap strikes.\n+   *\n@@ -1213,0 +1429,3 @@\n+#define FT_FACE_FLAG_SVG               ( 1L << 16 )\n+#define FT_FACE_FLAG_SBIX              ( 1L << 17 )\n+#define FT_FACE_FLAG_SBIX_OVERLAY      ( 1L << 18 )\n@@ -1215,0 +1434,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   font_testing_macros\n+   *\n+   *\/\n+\n@@ -1324,0 +1550,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   other_api_data\n+   *\n+   *\/\n+\n@@ -1333,2 +1566,9 @@\n-#define FT_HAS_FAST_GLYPHS( face )  0\n-\n+#define FT_HAS_FAST_GLYPHS( face )  0\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   font_testing_macros\n+   *\n+   *\/\n@@ -1394,2 +1634,2 @@\n-   *   @FT_Set_MM_Design_Coordinates, @FT_Set_Var_Design_Coordinates, or\n-   *   @FT_Set_Var_Blend_Coordinates.\n+   *   @FT_Set_MM_Design_Coordinates, @FT_Set_Var_Design_Coordinates,\n+   *   @FT_Set_Var_Blend_Coordinates, or @FT_Set_MM_WeightVector.\n@@ -1453,0 +1693,125 @@\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_HAS_SVG\n+   *\n+   * @description:\n+   *   A macro that returns true whenever a face object contains an 'SVG~'\n+   *   OpenType table.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+#define FT_HAS_SVG( face ) \\\n+          ( !!( (face)->face_flags & FT_FACE_FLAG_SVG ) )\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_HAS_SBIX\n+   *\n+   * @description:\n+   *   A macro that returns true whenever a face object contains an 'sbix'\n+   *   OpenType table *and* outline glyphs.\n+   *\n+   *   Currently, FreeType only supports bitmap glyphs in PNG format for this\n+   *   table (i.e., JPEG and TIFF formats are unsupported, as are\n+   *   Apple-specific formats not part of the OpenType specification).\n+   *\n+   * @note:\n+   *   For backward compatibility, a font with an 'sbix' table is treated as\n+   *   a bitmap-only face.  Using @FT_Open_Face with\n+   *   @FT_PARAM_TAG_IGNORE_SBIX, an application can switch off 'sbix'\n+   *   handling so that the face is treated as an ordinary outline font with\n+   *   scalable outlines.\n+   *\n+   *   Here is some pseudo code that roughly illustrates how to implement\n+   *   'sbix' handling according to the OpenType specification.\n+   *\n+   * ```\n+   *   if ( FT_HAS_SBIX( face ) )\n+   *   {\n+   *     \/\/ open font as a scalable one without sbix handling\n+   *     FT_Face       face2;\n+   *     FT_Parameter  param = { FT_PARAM_TAG_IGNORE_SBIX, NULL };\n+   *     FT_Open_Args  args  = { FT_OPEN_PARAMS | ...,\n+   *                             ...,\n+   *                             1, &param };\n+   *\n+   *\n+   *     FT_Open_Face( library, &args, 0, &face2 );\n+   *\n+   *     <sort `face->available_size` as necessary into\n+   *      `preferred_sizes`[*]>\n+   *\n+   *     for ( i = 0; i < face->num_fixed_sizes; i++ )\n+   *     {\n+   *       size = preferred_sizes[i].size;\n+   *\n+   *       error = FT_Set_Pixel_Sizes( face, size, size );\n+   *       <error handling omitted>\n+   *\n+   *       \/\/ check whether we have a glyph in a bitmap strike\n+   *       error = FT_Load_Glyph( face,\n+   *                              glyph_index,\n+   *                              FT_LOAD_SBITS_ONLY          |\n+   *                              FT_LOAD_BITMAP_METRICS_ONLY );\n+   *       if ( error == FT_Err_Invalid_Argument )\n+   *         continue;\n+   *       else if ( error )\n+   *         <other error handling omitted>\n+   *       else\n+   *         break;\n+   *     }\n+   *\n+   *     if ( i != face->num_fixed_sizes )\n+   *       <load embedded bitmap with `FT_Load_Glyph`,\n+   *        scale it, display it, etc.>\n+   *\n+   *     if ( i == face->num_fixed_sizes  ||\n+   *          FT_HAS_SBIX_OVERLAY( face ) )\n+   *       <use `face2` to load outline glyph with `FT_Load_Glyph`,\n+   *        scale it, display it on top of the bitmap, etc.>\n+   *   }\n+   * ```\n+   *\n+   * [*] Assuming a target value of 400dpi and available strike sizes 100,\n+   * 200, 300, and 400dpi, a possible order might be [400, 200, 300, 100]:\n+   * scaling 200dpi to 400dpi usually gives better results than scaling\n+   * 300dpi to 400dpi; it is also much faster.  However, scaling 100dpi to\n+   * 400dpi can yield a too pixelated result, thus the preference might be\n+   * 300dpi over 100dpi.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+#define FT_HAS_SBIX( face ) \\\n+          ( !!( (face)->face_flags & FT_FACE_FLAG_SBIX ) )\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_HAS_SBIX_OVERLAY\n+   *\n+   * @description:\n+   *   A macro that returns true whenever a face object contains an 'sbix'\n+   *   OpenType table with bit~1 in its `flags` field set, instructing the\n+   *   application to overlay the bitmap strike with the corresponding\n+   *   outline glyph.  See @FT_HAS_SBIX for pseudo code how to use it.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+#define FT_HAS_SBIX_OVERLAY( face ) \\\n+          ( !!( (face)->face_flags & FT_FACE_FLAG_SBIX_OVERLAY ) )\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   face_creation\n+   *\n+   *\/\n+\n@@ -1479,0 +1844,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   other_api_data\n+   *\n+   *\/\n+\n@@ -1491,0 +1863,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   sizing_and_scaling\n+   *\n+   *\/\n+\n@@ -1642,0 +2021,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   other_api_data\n+   *\n+   *\/\n+\n@@ -1673,0 +2059,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   glyph_retrieval\n+   *\n+   *\/\n+\n@@ -1717,1 +2110,1 @@\n-   *     WYSIWYG layout.  Only relevant for outline glyphs.\n+   *     WYSIWYG layout.  Only relevant for scalable glyphs.\n@@ -1723,1 +2116,1 @@\n-   *     WYSIWYG layout.  Only relevant for outline glyphs.\n+   *     WYSIWYG layout.  Only relevant for scalable glyphs.\n@@ -1917,0 +2310,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   library_setup\n+   *\n+   *\/\n+\n@@ -1974,0 +2374,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   face_creation\n+   *\n+   *\/\n+\n@@ -2068,1 +2475,2 @@\n-   *     A pointer to an 8-bit file pathname.  The pointer is not owned by\n+   *     A pointer to an 8-bit file pathname, which must be a C~string (i.e.,\n+   *     no null bytes except at the very end).  The pointer is not owned by\n@@ -2087,2 +2495,1 @@\n-   *   The stream type is determined by the contents of `flags` that are\n-   *   tested in the following order by @FT_Open_Face:\n+   *   The stream type is determined by the contents of `flags`:\n@@ -2101,0 +2508,3 @@\n+   *   If none of the above bits are set or if multiple are set at the same\n+   *   time, the flags are invalid and @FT_Open_Face fails.\n+   *\n@@ -2153,0 +2563,7 @@\n+   *   The `pathname` string should be recognizable as such by a standard\n+   *   `fopen` call on your system; in particular, this means that `pathname`\n+   *   must not contain null bytes.  If that is not sufficient to address all\n+   *   file name possibilities (for example, to handle wide character file\n+   *   names on Windows in UTF-16 encoding) you might use @FT_Open_Face to\n+   *   pass a memory array or a stream object instead.\n+   *\n@@ -2266,1 +2683,1 @@\n-   *   One @FT_Library instance can have multiple face objects, this is,\n+   *   One @FT_Library instance can have multiple face objects, that is,\n@@ -2273,0 +2690,4 @@\n+   *   If `FT_OPEN_STREAM` is set in `args->flags`, the stream in\n+   *   `args->stream` is automatically closed before this function returns\n+   *   any error (including `FT_Err_Invalid_Argument`).\n+   *\n@@ -2404,2 +2825,2 @@\n-  FT_Attach_Stream( FT_Face        face,\n-                    FT_Open_Args*  parameters );\n+  FT_Attach_Stream( FT_Face              face,\n+                    const FT_Open_Args*  parameters );\n@@ -2431,0 +2852,1 @@\n+   *\n@@ -2460,0 +2882,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   sizing_and_scaling\n+   *\n+   *\/\n+\n@@ -2489,1 +2918,1 @@\n-   *   if the default instance is active (this is, no glyph variation takes\n+   *   if the default instance is active (that is, no glyph variation takes\n@@ -2655,2 +3084,2 @@\n-   *   to normalize zero-valued widths, heights, or resolutions (which lead\n-   *   to errors in most cases).\n+   *   to normalize zero-valued widths, heights, or resolutions, which are\n+   *   treated as @FT_LOAD_NO_SCALE.\n@@ -2752,0 +3181,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   glyph_retrieval\n+   *\n+   *\/\n+\n@@ -2772,1 +3208,1 @@\n-   *     constants can be used to control the glyph loading process (e.g.,\n+   *     flags can be used to control the glyph loading process (e.g.,\n@@ -2780,2 +3216,4 @@\n-   *   The loaded glyph may be transformed.  See @FT_Set_Transform for the\n-   *   details.\n+   *   For proper scaling and hinting, the active @FT_Size object owned by\n+   *   the face has to be meaningfully initialized by calling\n+   *   @FT_Set_Char_Size before this function, for example.  The loaded\n+   *   glyph may be transformed.  See @FT_Set_Transform for the details.\n@@ -2784,1 +3222,1 @@\n-   *   for invalid CID values (this is, for CID values that don't have a\n+   *   for invalid CID values (that is, for CID values that don't have a\n@@ -2798,0 +3236,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   character_mapping\n+   *\n+   *\/\n+\n@@ -2841,0 +3286,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   glyph_retrieval\n+   *\n+   *\/\n+\n@@ -2871,0 +3323,2 @@\n+   *     This flag is also assumed if @FT_Size owned by the face was not\n+   *     properly initialized.\n@@ -2883,1 +3337,1 @@\n-   *     when the glyph are rendered in any of the anti-aliased modes.  See\n+   *     when the glyphs are rendered in any of the anti-aliased modes.  See\n@@ -2901,0 +3355,9 @@\n+   *   FT_LOAD_SBITS_ONLY ::\n+   *     [Since 2.12] This is the opposite of @FT_LOAD_NO_BITMAP, more or\n+   *     less: @FT_Load_Glyph returns `FT_Err_Invalid_Argument` if the face\n+   *     contains a bitmap strike for the given size (or the strike selected\n+   *     by @FT_Select_Size) but there is no glyph in the strike.\n+   *\n+   *     Note that this load flag was part of FreeType since version 2.0.6\n+   *     but previously tagged as internal.\n+   *\n@@ -2957,10 +3420,19 @@\n-   *     Load colored glyphs.  There are slight differences depending on the\n-   *     font format.\n-   *\n-   *     [Since 2.5] Load embedded color bitmap images.  The resulting color\n-   *     bitmaps, if available, will have the @FT_PIXEL_MODE_BGRA format,\n-   *     with pre-multiplied color channels.  If the flag is not set and\n-   *     color bitmaps are found, they are converted to 256-level gray\n-   *     bitmaps, using the @FT_PIXEL_MODE_GRAY format.\n-   *\n-   *     [Since 2.10, experimental] If the glyph index contains an entry in\n+   *     Load colored glyphs.  FreeType searches in the following order;\n+   *     there are slight differences depending on the font format.\n+   *\n+   *     [Since 2.5] Load embedded color bitmap images (provided\n+   *     @FT_LOAD_NO_BITMAP is not set).  The resulting color bitmaps, if\n+   *     available, have the @FT_PIXEL_MODE_BGRA format, with pre-multiplied\n+   *     color channels.  If the flag is not set and color bitmaps are found,\n+   *     they are converted to 256-level gray bitmaps, using the\n+   *     @FT_PIXEL_MODE_GRAY format.\n+   *\n+   *     [Since 2.12] If the glyph index maps to an entry in the face's\n+   *     'SVG~' table, load the associated SVG document from this table and\n+   *     set the `format` field of @FT_GlyphSlotRec to @FT_GLYPH_FORMAT_SVG\n+   *     ([since 2.13.1] provided @FT_LOAD_NO_SVG is not set).  Note that\n+   *     FreeType itself can't render SVG documents; however, the library\n+   *     provides hooks to seamlessly integrate an external renderer.  See\n+   *     sections @ot_svg_driver and @svg_fonts for more.\n+   *\n+   *     [Since 2.10, experimental] If the glyph index maps to an entry in\n@@ -2971,1 +3443,3 @@\n-   *     is mainly for convenience; for full control of color layers use\n+   *     is mainly for convenience and works only for glyphs in 'COLR' v0\n+   *     tables (or glyphs in 'COLR' v1 tables that exclusively use v0\n+   *     features).  For full control of color layers use\n@@ -2976,0 +3450,3 @@\n+   *   FT_LOAD_NO_SVG ::\n+   *     [Since 2.13.1] Ignore SVG glyph data when loading.\n+   *\n@@ -3022,9 +3499,9 @@\n-#define FT_LOAD_NO_SCALE                     ( 1L << 0 )\n-#define FT_LOAD_NO_HINTING                   ( 1L << 1 )\n-#define FT_LOAD_RENDER                       ( 1L << 2 )\n-#define FT_LOAD_NO_BITMAP                    ( 1L << 3 )\n-#define FT_LOAD_VERTICAL_LAYOUT              ( 1L << 4 )\n-#define FT_LOAD_FORCE_AUTOHINT               ( 1L << 5 )\n-#define FT_LOAD_CROP_BITMAP                  ( 1L << 6 )\n-#define FT_LOAD_PEDANTIC                     ( 1L << 7 )\n-#define FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH  ( 1L << 9 )\n+#define FT_LOAD_NO_SCALE                     ( 1L << 0  )\n+#define FT_LOAD_NO_HINTING                   ( 1L << 1  )\n+#define FT_LOAD_RENDER                       ( 1L << 2  )\n+#define FT_LOAD_NO_BITMAP                    ( 1L << 3  )\n+#define FT_LOAD_VERTICAL_LAYOUT              ( 1L << 4  )\n+#define FT_LOAD_FORCE_AUTOHINT               ( 1L << 5  )\n+#define FT_LOAD_CROP_BITMAP                  ( 1L << 6  )\n+#define FT_LOAD_PEDANTIC                     ( 1L << 7  )\n+#define FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH  ( 1L << 9  )\n@@ -3035,0 +3512,1 @@\n+#define FT_LOAD_SBITS_ONLY                   ( 1L << 14 )\n@@ -3040,0 +3518,1 @@\n+#define FT_LOAD_NO_SVG                       ( 1L << 24 )\n@@ -3044,2 +3523,2 @@\n-#define FT_LOAD_ADVANCE_ONLY                 ( 1L << 8 )\n-#define FT_LOAD_SBITS_ONLY                   ( 1L << 14 )\n+#define FT_LOAD_ADVANCE_ONLY                 ( 1L << 8  )\n+#define FT_LOAD_SVG_ONLY                     ( 1L << 23 )\n@@ -3135,1 +3614,1 @@\n-#define FT_LOAD_TARGET_( x )   ( (FT_Int32)( (x) & 15 ) << 16 )\n+#define FT_LOAD_TARGET_( x )   ( FT_STATIC_CAST( FT_Int32, (x) & 15 ) << 16 )\n@@ -3154,1 +3633,3 @@\n-#define FT_LOAD_TARGET_MODE( x )  ( (FT_Render_Mode)( ( (x) >> 16 ) & 15 ) )\n+#define FT_LOAD_TARGET_MODE( x )                               \\\n+          FT_STATIC_CAST( FT_Render_Mode, ( (x) >> 16 ) & 15 )\n+\n@@ -3156,0 +3637,6 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   sizing_and_scaling\n+   *\n+   *\/\n@@ -3175,1 +3662,2 @@\n-   *     A pointer to the translation vector.  Use `NULL` for the null vector.\n+   *     A pointer to the translation vector.  Use `NULL` for the null\n+   *     vector.\n@@ -3179,1 +3667,1 @@\n-   *   @FT_Matrix coefficients are only 16.16 fixed point values, which can\n+   *   @FT_Matrix coefficients are only 16.16 fixed-point values, which can\n@@ -3198,0 +3686,40 @@\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Transform\n+   *\n+   * @description:\n+   *   Return the transformation that is applied to glyph images when they\n+   *   are loaded into a glyph slot through @FT_Load_Glyph.  See\n+   *   @FT_Set_Transform for more details.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the source face object.\n+   *\n+   * @output:\n+   *   matrix ::\n+   *     A pointer to a transformation's 2x2 matrix.  Set this to NULL if you\n+   *     are not interested in the value.\n+   *\n+   *   delta ::\n+   *     A pointer to a translation vector.  Set this to NULL if you are not\n+   *     interested in the value.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Get_Transform( FT_Face     face,\n+                    FT_Matrix*  matrix,\n+                    FT_Vector*  delta );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   glyph_retrieval\n+   *\n+   *\/\n+\n@@ -3216,0 +3744,4 @@\n+   *   The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256\n+   *   distance values, indicating the signed distance from the grid position\n+   *   to the nearest outline.\n+   *\n@@ -3241,0 +3773,7 @@\n+   *   FT_RENDER_MODE_SDF ::\n+   *     The positive (unsigned) 8-bit bitmap values can be converted to the\n+   *     single-channel signed distance field (SDF) by subtracting 128, with\n+   *     the positive and negative results corresponding to the inside and\n+   *     the outside of a glyph contour, respectively.  The distance units are\n+   *     arbitrarily determined by an adjustable @spread property.\n+   *\n@@ -3242,1 +3781,1 @@\n-   *   The selected render mode only affects vector glyphs of a font.\n+   *   The selected render mode only affects scalable vector glyphs of a font.\n@@ -3246,0 +3785,1 @@\n+   *\n@@ -3254,0 +3794,1 @@\n+    FT_RENDER_MODE_SDF,\n@@ -3285,1 +3826,1 @@\n-   *     with flag @FT_LOAD_COLOR makes FT_Render_Glyph provide a default\n+   *     with flag @FT_LOAD_COLOR makes `FT_Render_Glyph` provide a default\n@@ -3295,3 +3836,0 @@\n-   *   To get meaningful results, font scaling values must be set with\n-   *   functions like @FT_Set_Char_Size before calling `FT_Render_Glyph`.\n-   *\n@@ -3341,1 +3879,2 @@\n-   *   To correctly composite an antialiased pixel of a glyph onto a surface,\n+   *   To correctly composite an anti-aliased pixel of a glyph onto a\n+   *   surface,\n@@ -3452,96 +3991,4 @@\n-   *   Only horizontal layouts (left-to-right & right-to-left) are supported\n-   *   by this method.  Other layouts, or more sophisticated kernings, are\n-   *   out of the scope of this API function -- they can be implemented\n-   *   through format-specific interfaces.\n-   *\n-   *   Kerning for OpenType fonts implemented in a 'GPOS' table is not\n-   *   supported; use @FT_HAS_KERNING to find out whether a font has data\n-   *   that can be extracted with `FT_Get_Kerning`.\n-   *\/\n-  FT_EXPORT( FT_Error )\n-  FT_Get_Kerning( FT_Face     face,\n-                  FT_UInt     left_glyph,\n-                  FT_UInt     right_glyph,\n-                  FT_UInt     kern_mode,\n-                  FT_Vector  *akerning );\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @function:\n-   *   FT_Get_Track_Kerning\n-   *\n-   * @description:\n-   *   Return the track kerning for a given face object at a given size.\n-   *\n-   * @input:\n-   *   face ::\n-   *     A handle to a source face object.\n-   *\n-   *   point_size ::\n-   *     The point size in 16.16 fractional points.\n-   *\n-   *   degree ::\n-   *     The degree of tightness.  Increasingly negative values represent\n-   *     tighter track kerning, while increasingly positive values represent\n-   *     looser track kerning.  Value zero means no track kerning.\n-   *\n-   * @output:\n-   *   akerning ::\n-   *     The kerning in 16.16 fractional points, to be uniformly applied\n-   *     between all glyphs.\n-   *\n-   * @return:\n-   *   FreeType error code.  0~means success.\n-   *\n-   * @note:\n-   *   Currently, only the Type~1 font driver supports track kerning, using\n-   *   data from AFM files (if attached with @FT_Attach_File or\n-   *   @FT_Attach_Stream).\n-   *\n-   *   Only very few AFM files come with track kerning data; please refer to\n-   *   Adobe's AFM specification for more details.\n-   *\/\n-  FT_EXPORT( FT_Error )\n-  FT_Get_Track_Kerning( FT_Face    face,\n-                        FT_Fixed   point_size,\n-                        FT_Int     degree,\n-                        FT_Fixed*  akerning );\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @function:\n-   *   FT_Get_Glyph_Name\n-   *\n-   * @description:\n-   *   Retrieve the ASCII name of a given glyph in a face.  This only works\n-   *   for those faces where @FT_HAS_GLYPH_NAMES(face) returns~1.\n-   *\n-   * @input:\n-   *   face ::\n-   *     A handle to a source face object.\n-   *\n-   *   glyph_index ::\n-   *     The glyph index.\n-   *\n-   *   buffer_max ::\n-   *     The maximum number of bytes available in the buffer.\n-   *\n-   * @output:\n-   *   buffer ::\n-   *     A pointer to a target buffer where the name is copied to.\n-   *\n-   * @return:\n-   *   FreeType error code.  0~means success.\n-   *\n-   * @note:\n-   *   An error is returned if the face doesn't provide glyph names or if the\n-   *   glyph index is invalid.  In all cases of failure, the first byte of\n-   *   `buffer` is set to~0 to indicate an empty name.\n-   *\n-   *   The glyph name is truncated to fit within the buffer if it is too\n-   *   long.  The returned string is always zero-terminated.\n-   *\n-   *   Be aware that FreeType reorders glyph indices internally so that glyph\n-   *   index~0 always corresponds to the 'missing glyph' (called '.notdef').\n+   *   Only horizontal layouts (left-to-right & right-to-left) are supported\n+   *   by this method.  Other layouts, or more sophisticated kernings, are\n+   *   out of the scope of this API function -- they can be implemented\n+   *   through format-specific interfaces.\n@@ -3549,2 +3996,20 @@\n-   *   This function always returns an error if the config macro\n-   *   `FT_CONFIG_OPTION_NO_GLYPH_NAMES` is not defined in `ftoption.h`.\n+   *   Note that, for TrueType fonts only, this can extract data from both\n+   *   the 'kern' table and the basic, pair-wise kerning feature from the\n+   *   GPOS table (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled), though\n+   *   FreeType does not support the more advanced GPOS layout features; use\n+   *   a library like HarfBuzz for those instead.  If a font has both a\n+   *   'kern' table and kern features of a GPOS table, the 'kern' table will\n+   *   be used.\n+   *\n+   *   Also note for right-to-left scripts, the functionality may differ for\n+   *   fonts with GPOS tables vs. 'kern' tables.  For GPOS, right-to-left\n+   *   fonts typically use both a placement offset and an advance for pair\n+   *   positioning, which this API does not support, so it would output\n+   *   kerning values of zero; though if the right-to-left font used only\n+   *   advances in GPOS pair positioning, then this API could output kerning\n+   *   values for it, but it would use `left_glyph` to mean the first glyph\n+   *   for that case.  Whereas 'kern' tables are always advance-only and\n+   *   always store the left glyph first.\n+   *\n+   *   Use @FT_HAS_KERNING to find out whether a font has data that can be\n+   *   extracted with `FT_Get_Kerning`.\n@@ -3553,4 +4018,5 @@\n-  FT_Get_Glyph_Name( FT_Face     face,\n-                     FT_UInt     glyph_index,\n-                     FT_Pointer  buffer,\n-                     FT_UInt     buffer_max );\n+  FT_Get_Kerning( FT_Face     face,\n+                  FT_UInt     left_glyph,\n+                  FT_UInt     right_glyph,\n+                  FT_UInt     kern_mode,\n+                  FT_Vector  *akerning );\n@@ -3562,1 +4028,1 @@\n-   *   FT_Get_Postscript_Name\n+   *   FT_Get_Track_Kerning\n@@ -3565,2 +4031,1 @@\n-   *   Retrieve the ASCII PostScript name of a given face, if available.\n-   *   This only works with PostScript, TrueType, and OpenType fonts.\n+   *   Return the track kerning for a given face object at a given size.\n@@ -3570,1 +4035,14 @@\n-   *     A handle to the source face object.\n+   *     A handle to a source face object.\n+   *\n+   *   point_size ::\n+   *     The point size in 16.16 fractional points.\n+   *\n+   *   degree ::\n+   *     The degree of tightness.  Increasingly negative values represent\n+   *     tighter track kerning, while increasingly positive values represent\n+   *     looser track kerning.  Value zero means no track kerning.\n+   *\n+   * @output:\n+   *   akerning ::\n+   *     The kerning in 16.16 fractional points, to be uniformly applied\n+   *     between all glyphs.\n@@ -3573,1 +4051,1 @@\n-   *   A pointer to the face's PostScript name.  `NULL` if unavailable.\n+   *   FreeType error code.  0~means success.\n@@ -3576,1 +4054,3 @@\n-   *   The returned pointer is owned by the face and is destroyed with it.\n+   *   Currently, only the Type~1 font driver supports track kerning, using\n+   *   data from AFM files (if attached with @FT_Attach_File or\n+   *   @FT_Attach_Stream).\n@@ -3578,4 +4058,11 @@\n-   *   For variation fonts, this string changes if you select a different\n-   *   instance, and you have to call `FT_Get_PostScript_Name` again to\n-   *   retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating\n-   *   PostScript Names for Fonts Using OpenType Font Variations'.\n+   *   Only very few AFM files come with track kerning data; please refer to\n+   *   Adobe's AFM specification for more details.\n+   *\/\n+  FT_EXPORT( FT_Error )\n+  FT_Get_Track_Kerning( FT_Face    face,\n+                        FT_Fixed   point_size,\n+                        FT_Int     degree,\n+                        FT_Fixed*  akerning );\n+\n+\n+  \/**************************************************************************\n@@ -3583,1 +4070,2 @@\n-   *     https:\/\/download.macromedia.com\/pub\/developer\/opentype\/tech-notes\/5902.AdobePSNameGeneration.html\n+   * @section:\n+   *   character_mapping\n@@ -3585,5 +4073,0 @@\n-   *   [Since 2.9] Special PostScript names for named instances are only\n-   *   returned if the named instance is set with @FT_Set_Named_Instance (and\n-   *   the font has corresponding entries in its 'fvar' table).  If\n-   *   @FT_IS_VARIATION returns true, the algorithmically derived PostScript\n-   *   name is provided, not looking up special entries for named instances.\n@@ -3591,3 +4074,0 @@\n-  FT_EXPORT( const char* )\n-  FT_Get_Postscript_Name( FT_Face  face );\n-\n@@ -3811,0 +4291,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   face_creation\n+   *\n+   *\/\n+\n@@ -3909,0 +4396,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   information_retrieval\n+   *\n+   *\/\n+\n@@ -3915,1 +4409,2 @@\n-   *   Return the glyph index of a given glyph name.\n+   *   Return the glyph index of a given glyph name.  This only works\n+   *   for those faces where @FT_HAS_GLYPH_NAMES returns true.\n@@ -3926,0 +4421,10 @@\n+   *\n+   * @note:\n+   *   Acceptable glyph names might come from the [Adobe Glyph\n+   *   List](https:\/\/github.com\/adobe-type-tools\/agl-aglfn).  See\n+   *   @FT_Get_Glyph_Name for the inverse functionality.\n+   *\n+   *   This function has limited capabilities if the config macro\n+   *   `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:\n+   *   It then works only for fonts that actually embed glyph names (which\n+   *   many recent OpenType fonts do not).\n@@ -3932,0 +4437,86 @@\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Glyph_Name\n+   *\n+   * @description:\n+   *   Retrieve the ASCII name of a given glyph in a face.  This only works\n+   *   for those faces where @FT_HAS_GLYPH_NAMES returns true.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to a source face object.\n+   *\n+   *   glyph_index ::\n+   *     The glyph index.\n+   *\n+   *   buffer_max ::\n+   *     The maximum number of bytes available in the buffer.\n+   *\n+   * @output:\n+   *   buffer ::\n+   *     A pointer to a target buffer where the name is copied to.\n+   *\n+   * @return:\n+   *   FreeType error code.  0~means success.\n+   *\n+   * @note:\n+   *   An error is returned if the face doesn't provide glyph names or if the\n+   *   glyph index is invalid.  In all cases of failure, the first byte of\n+   *   `buffer` is set to~0 to indicate an empty name.\n+   *\n+   *   The glyph name is truncated to fit within the buffer if it is too\n+   *   long.  The returned string is always zero-terminated.\n+   *\n+   *   Be aware that FreeType reorders glyph indices internally so that glyph\n+   *   index~0 always corresponds to the 'missing glyph' (called '.notdef').\n+   *\n+   *   This function has limited capabilities if the config macro\n+   *   `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:\n+   *   It then works only for fonts that actually embed glyph names (which\n+   *   many recent OpenType fonts do not).\n+   *\/\n+  FT_EXPORT( FT_Error )\n+  FT_Get_Glyph_Name( FT_Face     face,\n+                     FT_UInt     glyph_index,\n+                     FT_Pointer  buffer,\n+                     FT_UInt     buffer_max );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Postscript_Name\n+   *\n+   * @description:\n+   *   Retrieve the ASCII PostScript name of a given face, if available.\n+   *   This only works with PostScript, TrueType, and OpenType fonts.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the source face object.\n+   *\n+   * @return:\n+   *   A pointer to the face's PostScript name.  `NULL` if unavailable.\n+   *\n+   * @note:\n+   *   The returned pointer is owned by the face and is destroyed with it.\n+   *\n+   *   For variation fonts, this string changes if you select a different\n+   *   instance, and you have to call `FT_Get_PostScript_Name` again to\n+   *   retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating\n+   *   PostScript Names for Fonts Using OpenType Font Variations'.\n+   *\n+   *     https:\/\/download.macromedia.com\/pub\/developer\/opentype\/tech-notes\/5902.AdobePSNameGeneration.html\n+   *\n+   *   [Since 2.9] Special PostScript names for named instances are only\n+   *   returned if the named instance is set with @FT_Set_Named_Instance (and\n+   *   the font has corresponding entries in its 'fvar' table or is the\n+   *   default named instance).  If @FT_IS_VARIATION returns true, the\n+   *   algorithmically derived PostScript name is provided, not looking up\n+   *   special entries for named instances.\n+   *\/\n+  FT_EXPORT( const char* )\n+  FT_Get_Postscript_Name( FT_Face  face );\n+\n+\n@@ -4018,169 +4609,0 @@\n-  \/**************************************************************************\n-   *\n-   * @section:\n-   *   layer_management\n-   *\n-   * @title:\n-   *   Glyph Layer Management\n-   *\n-   * @abstract:\n-   *   Retrieving and manipulating OpenType's 'COLR' table data.\n-   *\n-   * @description:\n-   *   The functions described here allow access of colored glyph layer data\n-   *   in OpenType's 'COLR' tables.\n-   *\/\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @struct:\n-   *   FT_LayerIterator\n-   *\n-   * @description:\n-   *   This iterator object is needed for @FT_Get_Color_Glyph_Layer.\n-   *\n-   * @fields:\n-   *   num_layers ::\n-   *     The number of glyph layers for the requested glyph index.  Will be\n-   *     set by @FT_Get_Color_Glyph_Layer.\n-   *\n-   *   layer ::\n-   *     The current layer.  Will be set by @FT_Get_Color_Glyph_Layer.\n-   *\n-   *   p ::\n-   *     An opaque pointer into 'COLR' table data.  The caller must set this\n-   *     to `NULL` before the first call of @FT_Get_Color_Glyph_Layer.\n-   *\/\n-  typedef struct  FT_LayerIterator_\n-  {\n-    FT_UInt   num_layers;\n-    FT_UInt   layer;\n-    FT_Byte*  p;\n-\n-  } FT_LayerIterator;\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @function:\n-   *   FT_Get_Color_Glyph_Layer\n-   *\n-   * @description:\n-   *   This is an interface to the 'COLR' table in OpenType fonts to\n-   *   iteratively retrieve the colored glyph layers associated with the\n-   *   current glyph slot.\n-   *\n-   *     https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n-   *\n-   *   The glyph layer data for a given glyph index, if present, provides an\n-   *   alternative, multi-color glyph representation: Instead of rendering\n-   *   the outline or bitmap with the given glyph index, glyphs with the\n-   *   indices and colors returned by this function are rendered layer by\n-   *   layer.\n-   *\n-   *   The returned elements are ordered in the z~direction from bottom to\n-   *   top; the 'n'th element should be rendered with the associated palette\n-   *   color and blended on top of the already rendered layers (elements 0,\n-   *   1, ..., n-1).\n-   *\n-   * @input:\n-   *   face ::\n-   *     A handle to the parent face object.\n-   *\n-   *   base_glyph ::\n-   *     The glyph index the colored glyph layers are associated with.\n-   *\n-   * @inout:\n-   *   iterator ::\n-   *     An @FT_LayerIterator object.  For the first call you should set\n-   *     `iterator->p` to `NULL`.  For all following calls, simply use the\n-   *     same object again.\n-   *\n-   * @output:\n-   *   aglyph_index ::\n-   *     The glyph index of the current layer.\n-   *\n-   *   acolor_index ::\n-   *     The color index into the font face's color palette of the current\n-   *     layer.  The value 0xFFFF is special; it doesn't reference a palette\n-   *     entry but indicates that the text foreground color should be used\n-   *     instead (to be set up by the application outside of FreeType).\n-   *\n-   *     The color palette can be retrieved with @FT_Palette_Select.\n-   *\n-   * @return:\n-   *   Value~1 if everything is OK.  If there are no more layers (or if there\n-   *   are no layers at all), value~0 gets returned.  In case of an error,\n-   *   value~0 is returned also.\n-   *\n-   * @note:\n-   *   This function is necessary if you want to handle glyph layers by\n-   *   yourself.  In particular, functions that operate with @FT_GlyphRec\n-   *   objects (like @FT_Get_Glyph or @FT_Glyph_To_Bitmap) don't have access\n-   *   to this information.\n-   *\n-   *   Note that @FT_Render_Glyph is able to handle colored glyph layers\n-   *   automatically if the @FT_LOAD_COLOR flag is passed to a previous call\n-   *   to @FT_Load_Glyph.  [This is an experimental feature.]\n-   *\n-   * @example:\n-   *   ```\n-   *     FT_Color*         palette;\n-   *     FT_LayerIterator  iterator;\n-   *\n-   *     FT_Bool  have_layers;\n-   *     FT_UInt  layer_glyph_index;\n-   *     FT_UInt  layer_color_index;\n-   *\n-   *\n-   *     error = FT_Palette_Select( face, palette_index, &palette );\n-   *     if ( error )\n-   *       palette = NULL;\n-   *\n-   *     iterator.p  = NULL;\n-   *     have_layers = FT_Get_Color_Glyph_Layer( face,\n-   *                                             glyph_index,\n-   *                                             &layer_glyph_index,\n-   *                                             &layer_color_index,\n-   *                                             &iterator );\n-   *\n-   *     if ( palette && have_layers )\n-   *     {\n-   *       do\n-   *       {\n-   *         FT_Color  layer_color;\n-   *\n-   *\n-   *         if ( layer_color_index == 0xFFFF )\n-   *           layer_color = text_foreground_color;\n-   *         else\n-   *           layer_color = palette[layer_color_index];\n-   *\n-   *         \/\/ Load and render glyph `layer_glyph_index', then\n-   *         \/\/ blend resulting pixmap (using color `layer_color')\n-   *         \/\/ with previously created pixmaps.\n-   *\n-   *       } while ( FT_Get_Color_Glyph_Layer( face,\n-   *                                           glyph_index,\n-   *                                           &layer_glyph_index,\n-   *                                           &layer_color_index,\n-   *                                           &iterator ) );\n-   *     }\n-   *   ```\n-   *\/\n-  FT_EXPORT( FT_Bool )\n-  FT_Get_Color_Glyph_Layer( FT_Face            face,\n-                            FT_UInt            base_glyph,\n-                            FT_UInt           *aglyph_index,\n-                            FT_UInt           *acolor_index,\n-                            FT_LayerIterator*  iterator );\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @section:\n-   *   base_interface\n-   *\n-   *\/\n-\n@@ -4270,0 +4692,1 @@\n+   *\n@@ -4363,0 +4786,1 @@\n+   *\n@@ -4399,0 +4823,1 @@\n+   *\n@@ -4430,0 +4855,1 @@\n+   *\n@@ -4463,0 +4889,1 @@\n+   *\n@@ -4497,0 +4924,1 @@\n+   *\n@@ -4516,1 +4944,2 @@\n-   *   on 16.16 fixed-float numbers or 2d vectors.\n+   *   on 16.16 fixed-point numbers or 2D vectors.  FreeType does not use\n+   *   floating-point data types.\n@@ -4720,22 +5149,1 @@\n-   *   version\n-   *\n-   * @title:\n-   *   FreeType Version\n-   *\n-   * @abstract:\n-   *   Functions and macros related to FreeType versions.\n-   *\n-   * @description:\n-   *   Note that those functions and macros are of limited use because even a\n-   *   new release of FreeType with only documentation changes increases the\n-   *   version number.\n-   *\n-   * @order:\n-   *   FT_Library_Version\n-   *\n-   *   FREETYPE_MAJOR\n-   *   FREETYPE_MINOR\n-   *   FREETYPE_PATCH\n-   *\n-   *   FT_Face_CheckTrueTypePatents\n-   *   FT_Face_SetUnpatentedHinting\n+   *   library_setup\n@@ -4745,1 +5153,0 @@\n-\n@@ -4769,2 +5176,2 @@\n-#define FREETYPE_MINOR  10\n-#define FREETYPE_PATCH  4\n+#define FREETYPE_MINOR  13\n+#define FREETYPE_PATCH  3\n@@ -4812,0 +5219,7 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   other_api_data\n+   *\n+   *\/\n+\n@@ -4832,0 +5246,1 @@\n+   *\n@@ -4860,0 +5275,1 @@\n+   *\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/freetype.h","additions":911,"deletions":495,"binary":false,"changes":1406,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftadvanc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftbbox.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftbitmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+   *   preamble\n@@ -33,1 +34,0 @@\n-   *   version\n@@ -35,1 +35,21 @@\n-   *   base_interface\n+   *   library_setup\n+   *   face_creation\n+   *   font_testing_macros\n+   *   sizing_and_scaling\n+   *   glyph_retrieval\n+   *   character_mapping\n+   *   information_retrieval\n+   *   other_api_data\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @chapter:\n+   *   extended_api\n+   *\n+   * @title:\n+   *   Extended API\n+   *\n+   * @sections:\n@@ -64,0 +84,1 @@\n+   *   svg_fonts\n@@ -84,0 +105,1 @@\n+   *   ot_svg_driver\n@@ -126,0 +148,1 @@\n+   *   debugging_apis\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftchapters.h","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2024 by\n@@ -305,0 +305,1354 @@\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   layer_management\n+   *\n+   * @title:\n+   *   Glyph Layer Management\n+   *\n+   * @abstract:\n+   *   Retrieving and manipulating OpenType's 'COLR' table data.\n+   *\n+   * @description:\n+   *   The functions described here allow access of colored glyph layer data\n+   *   in OpenType's 'COLR' tables.\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_LayerIterator\n+   *\n+   * @description:\n+   *   This iterator object is needed for @FT_Get_Color_Glyph_Layer.\n+   *\n+   * @fields:\n+   *   num_layers ::\n+   *     The number of glyph layers for the requested glyph index.  Will be\n+   *     set by @FT_Get_Color_Glyph_Layer.\n+   *\n+   *   layer ::\n+   *     The current layer.  Will be set by @FT_Get_Color_Glyph_Layer.\n+   *\n+   *   p ::\n+   *     An opaque pointer into 'COLR' table data.  The caller must set this\n+   *     to `NULL` before the first call of @FT_Get_Color_Glyph_Layer.\n+   *\/\n+  typedef struct  FT_LayerIterator_\n+  {\n+    FT_UInt   num_layers;\n+    FT_UInt   layer;\n+    FT_Byte*  p;\n+\n+  } FT_LayerIterator;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Color_Glyph_Layer\n+   *\n+   * @description:\n+   *   This is an interface to the 'COLR' table in OpenType fonts to\n+   *   iteratively retrieve the colored glyph layers associated with the\n+   *   current glyph slot.\n+   *\n+   *     https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n+   *\n+   *   The glyph layer data for a given glyph index, if present, provides an\n+   *   alternative, multi-color glyph representation: Instead of rendering\n+   *   the outline or bitmap with the given glyph index, glyphs with the\n+   *   indices and colors returned by this function are rendered layer by\n+   *   layer.\n+   *\n+   *   The returned elements are ordered in the z~direction from bottom to\n+   *   top; the 'n'th element should be rendered with the associated palette\n+   *   color and blended on top of the already rendered layers (elements 0,\n+   *   1, ..., n-1).\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index the colored glyph layers are associated with.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     An @FT_LayerIterator object.  For the first call you should set\n+   *     `iterator->p` to `NULL`.  For all following calls, simply use the\n+   *     same object again.\n+   *\n+   * @output:\n+   *   aglyph_index ::\n+   *     The glyph index of the current layer.\n+   *\n+   *   acolor_index ::\n+   *     The color index into the font face's color palette of the current\n+   *     layer.  The value 0xFFFF is special; it doesn't reference a palette\n+   *     entry but indicates that the text foreground color should be used\n+   *     instead (to be set up by the application outside of FreeType).\n+   *\n+   *     The color palette can be retrieved with @FT_Palette_Select.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If there are no more layers (or if there\n+   *   are no layers at all), value~0 gets returned.  In case of an error,\n+   *   value~0 is returned also.\n+   *\n+   * @note:\n+   *   This function is necessary if you want to handle glyph layers by\n+   *   yourself.  In particular, functions that operate with @FT_GlyphRec\n+   *   objects (like @FT_Get_Glyph or @FT_Glyph_To_Bitmap) don't have access\n+   *   to this information.\n+   *\n+   *   Note that @FT_Render_Glyph is able to handle colored glyph layers\n+   *   automatically if the @FT_LOAD_COLOR flag is passed to a previous call\n+   *   to @FT_Load_Glyph.  [This is an experimental feature.]\n+   *\n+   * @example:\n+   *   ```\n+   *     FT_Color*         palette;\n+   *     FT_LayerIterator  iterator;\n+   *\n+   *     FT_Bool  have_layers;\n+   *     FT_UInt  layer_glyph_index;\n+   *     FT_UInt  layer_color_index;\n+   *\n+   *\n+   *     error = FT_Palette_Select( face, palette_index, &palette );\n+   *     if ( error )\n+   *       palette = NULL;\n+   *\n+   *     iterator.p  = NULL;\n+   *     have_layers = FT_Get_Color_Glyph_Layer( face,\n+   *                                             glyph_index,\n+   *                                             &layer_glyph_index,\n+   *                                             &layer_color_index,\n+   *                                             &iterator );\n+   *\n+   *     if ( palette && have_layers )\n+   *     {\n+   *       do\n+   *       {\n+   *         FT_Color  layer_color;\n+   *\n+   *\n+   *         if ( layer_color_index == 0xFFFF )\n+   *           layer_color = text_foreground_color;\n+   *         else\n+   *           layer_color = palette[layer_color_index];\n+   *\n+   *         \/\/ Load and render glyph `layer_glyph_index', then\n+   *         \/\/ blend resulting pixmap (using color `layer_color')\n+   *         \/\/ with previously created pixmaps.\n+   *\n+   *       } while ( FT_Get_Color_Glyph_Layer( face,\n+   *                                           glyph_index,\n+   *                                           &layer_glyph_index,\n+   *                                           &layer_color_index,\n+   *                                           &iterator ) );\n+   *     }\n+   *   ```\n+   *\n+   * @since:\n+   *   2.10\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Color_Glyph_Layer( FT_Face            face,\n+                            FT_UInt            base_glyph,\n+                            FT_UInt           *aglyph_index,\n+                            FT_UInt           *acolor_index,\n+                            FT_LayerIterator*  iterator );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_PaintFormat\n+   *\n+   * @description:\n+   *   Enumeration describing the different paint format types of the v1\n+   *   extensions to the 'COLR' table, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *\n+   *   The enumeration values loosely correspond with the format numbers of\n+   *   the specification: FreeType always returns a fully specified 'Paint'\n+   *   structure for the 'Transform', 'Translate', 'Scale', 'Rotate', and\n+   *   'Skew' table types even though the specification has different formats\n+   *   depending on whether or not a center is specified, whether the scale\n+   *   is uniform in x and y~direction or not, etc.  Also, only non-variable\n+   *   format identifiers are listed in this enumeration; as soon as support\n+   *   for variable 'COLR' v1 fonts is implemented, interpolation is\n+   *   performed dependent on axis coordinates, which are configured on the\n+   *   @FT_Face through @FT_Set_Var_Design_Coordinates.  This implies that\n+   *   always static, readily interpolated values are returned in the 'Paint'\n+   *   structures.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef enum  FT_PaintFormat_\n+  {\n+    FT_COLR_PAINTFORMAT_COLR_LAYERS     = 1,\n+    FT_COLR_PAINTFORMAT_SOLID           = 2,\n+    FT_COLR_PAINTFORMAT_LINEAR_GRADIENT = 4,\n+    FT_COLR_PAINTFORMAT_RADIAL_GRADIENT = 6,\n+    FT_COLR_PAINTFORMAT_SWEEP_GRADIENT  = 8,\n+    FT_COLR_PAINTFORMAT_GLYPH           = 10,\n+    FT_COLR_PAINTFORMAT_COLR_GLYPH      = 11,\n+    FT_COLR_PAINTFORMAT_TRANSFORM       = 12,\n+    FT_COLR_PAINTFORMAT_TRANSLATE       = 14,\n+    FT_COLR_PAINTFORMAT_SCALE           = 16,\n+    FT_COLR_PAINTFORMAT_ROTATE          = 24,\n+    FT_COLR_PAINTFORMAT_SKEW            = 28,\n+    FT_COLR_PAINTFORMAT_COMPOSITE       = 32,\n+    FT_COLR_PAINT_FORMAT_MAX            = 33,\n+    FT_COLR_PAINTFORMAT_UNSUPPORTED     = 255\n+\n+  } FT_PaintFormat;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorStopIterator\n+   *\n+   * @description:\n+   *   This iterator object is needed for @FT_Get_Colorline_Stops.  It keeps\n+   *   state while iterating over the stops of an @FT_ColorLine, representing\n+   *   the `ColorLine` struct of the v1 extensions to 'COLR', see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  Do not manually\n+   *   modify fields of this iterator.\n+   *\n+   * @fields:\n+   *   num_color_stops ::\n+   *     The number of color stops for the requested glyph index.  Set by\n+   *     @FT_Get_Paint.\n+   *\n+   *   current_color_stop ::\n+   *     The current color stop.  Set by @FT_Get_Colorline_Stops.\n+   *\n+   *   p ::\n+   *     An opaque pointer into 'COLR' table data.  Set by @FT_Get_Paint.\n+   *     Updated by @FT_Get_Colorline_Stops.\n+   *\n+   *   read_variable ::\n+   *     A boolean keeping track of whether variable color lines are to be\n+   *     read.  Set by @FT_Get_Paint.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_ColorStopIterator_\n+  {\n+    FT_UInt  num_color_stops;\n+    FT_UInt  current_color_stop;\n+\n+    FT_Byte*  p;\n+\n+    FT_Bool  read_variable;\n+\n+  } FT_ColorStopIterator;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorIndex\n+   *\n+   * @description:\n+   *   A structure representing a `ColorIndex` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *\n+   * @fields:\n+   *   palette_index ::\n+   *     The palette index into a 'CPAL' palette.\n+   *\n+   *   alpha ::\n+   *     Alpha transparency value multiplied with the value from 'CPAL'.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_ColorIndex_\n+  {\n+    FT_UInt16   palette_index;\n+    FT_F2Dot14  alpha;\n+\n+  } FT_ColorIndex;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorStop\n+   *\n+   * @description:\n+   *   A structure representing a `ColorStop` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *\n+   * @fields:\n+   *   stop_offset ::\n+   *     The stop offset along the gradient, expressed as a 16.16 fixed-point\n+   *     coordinate.\n+   *\n+   *   color ::\n+   *     The color information for this stop, see @FT_ColorIndex.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_ColorStop_\n+  {\n+    FT_Fixed       stop_offset;\n+    FT_ColorIndex  color;\n+\n+  } FT_ColorStop;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_PaintExtend\n+   *\n+   * @description:\n+   *   An enumeration representing the 'Extend' mode of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *   It describes how the gradient fill continues at the other boundaries.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef enum  FT_PaintExtend_\n+  {\n+    FT_COLR_PAINT_EXTEND_PAD     = 0,\n+    FT_COLR_PAINT_EXTEND_REPEAT  = 1,\n+    FT_COLR_PAINT_EXTEND_REFLECT = 2\n+\n+  } FT_PaintExtend;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorLine\n+   *\n+   * @description:\n+   *   A structure representing a `ColorLine` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *   It describes a list of color stops along the defined gradient.\n+   *\n+   * @fields:\n+   *   extend ::\n+   *     The extend mode at the outer boundaries, see @FT_PaintExtend.\n+   *\n+   *   color_stop_iterator ::\n+   *     The @FT_ColorStopIterator used to enumerate and retrieve the\n+   *     actual @FT_ColorStop's.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_ColorLine_\n+  {\n+    FT_PaintExtend        extend;\n+    FT_ColorStopIterator  color_stop_iterator;\n+\n+  } FT_ColorLine;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_Affine23\n+   *\n+   * @description:\n+   *   A structure used to store a 2x3 matrix.  Coefficients are in\n+   *   16.16 fixed-point format.  The computation performed is\n+   *\n+   *   ```\n+   *     x' = x*xx + y*xy + dx\n+   *     y' = x*yx + y*yy + dy\n+   *   ```\n+   *\n+   * @fields:\n+   *   xx ::\n+   *     Matrix coefficient.\n+   *\n+   *   xy ::\n+   *     Matrix coefficient.\n+   *\n+   *   dx ::\n+   *     x translation.\n+   *\n+   *   yx ::\n+   *     Matrix coefficient.\n+   *\n+   *   yy ::\n+   *     Matrix coefficient.\n+   *\n+   *   dy ::\n+   *     y translation.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_Affine_23_\n+  {\n+    FT_Fixed  xx, xy, dx;\n+    FT_Fixed  yx, yy, dy;\n+\n+  } FT_Affine23;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_Composite_Mode\n+   *\n+   * @description:\n+   *   An enumeration listing the 'COLR' v1 composite modes used in\n+   *   @FT_PaintComposite.  For more details on each paint mode, see\n+   *   'https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators'.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef enum  FT_Composite_Mode_\n+  {\n+    FT_COLR_COMPOSITE_CLEAR          = 0,\n+    FT_COLR_COMPOSITE_SRC            = 1,\n+    FT_COLR_COMPOSITE_DEST           = 2,\n+    FT_COLR_COMPOSITE_SRC_OVER       = 3,\n+    FT_COLR_COMPOSITE_DEST_OVER      = 4,\n+    FT_COLR_COMPOSITE_SRC_IN         = 5,\n+    FT_COLR_COMPOSITE_DEST_IN        = 6,\n+    FT_COLR_COMPOSITE_SRC_OUT        = 7,\n+    FT_COLR_COMPOSITE_DEST_OUT       = 8,\n+    FT_COLR_COMPOSITE_SRC_ATOP       = 9,\n+    FT_COLR_COMPOSITE_DEST_ATOP      = 10,\n+    FT_COLR_COMPOSITE_XOR            = 11,\n+    FT_COLR_COMPOSITE_PLUS           = 12,\n+    FT_COLR_COMPOSITE_SCREEN         = 13,\n+    FT_COLR_COMPOSITE_OVERLAY        = 14,\n+    FT_COLR_COMPOSITE_DARKEN         = 15,\n+    FT_COLR_COMPOSITE_LIGHTEN        = 16,\n+    FT_COLR_COMPOSITE_COLOR_DODGE    = 17,\n+    FT_COLR_COMPOSITE_COLOR_BURN     = 18,\n+    FT_COLR_COMPOSITE_HARD_LIGHT     = 19,\n+    FT_COLR_COMPOSITE_SOFT_LIGHT     = 20,\n+    FT_COLR_COMPOSITE_DIFFERENCE     = 21,\n+    FT_COLR_COMPOSITE_EXCLUSION      = 22,\n+    FT_COLR_COMPOSITE_MULTIPLY       = 23,\n+    FT_COLR_COMPOSITE_HSL_HUE        = 24,\n+    FT_COLR_COMPOSITE_HSL_SATURATION = 25,\n+    FT_COLR_COMPOSITE_HSL_COLOR      = 26,\n+    FT_COLR_COMPOSITE_HSL_LUMINOSITY = 27,\n+    FT_COLR_COMPOSITE_MAX            = 28\n+\n+  } FT_Composite_Mode;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_OpaquePaint\n+   *\n+   * @description:\n+   *   A structure representing an offset to a `Paint` value stored in any\n+   *   of the paint tables of a 'COLR' v1 font.  Compare Offset<24> there.\n+   *   When 'COLR' v1 paint tables represented by FreeType objects such as\n+   *   @FT_PaintColrLayers, @FT_PaintComposite, or @FT_PaintTransform\n+   *   reference downstream nested paint tables, we do not immediately\n+   *   retrieve them but encapsulate their location in this type.  Use\n+   *   @FT_Get_Paint to retrieve the actual @FT_COLR_Paint object that\n+   *   describes the details of the respective paint table.\n+   *\n+   * @fields:\n+   *   p ::\n+   *     An internal offset to a Paint table, needs to be set to NULL before\n+   *     passing this struct as an argument to @FT_Get_Paint.\n+   *\n+   *   insert_root_transform ::\n+   *     An internal boolean to track whether an initial root transform is\n+   *     to be provided.  Do not set this value.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_Opaque_Paint_\n+  {\n+    FT_Byte*  p;\n+    FT_Bool   insert_root_transform;\n+  } FT_OpaquePaint;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintColrLayers\n+   *\n+   * @description:\n+   *   A structure representing a `PaintColrLayers` table of a 'COLR' v1\n+   *   font.  This table describes a set of layers that are to be composited\n+   *   with composite mode `FT_COLR_COMPOSITE_SRC_OVER`.  The return value\n+   *   of this function is an @FT_LayerIterator initialized so that it can\n+   *   be used with @FT_Get_Paint_Layers to retrieve the @FT_OpaquePaint\n+   *   objects as references to each layer.\n+   *\n+   * @fields:\n+   *   layer_iterator ::\n+   *     The layer iterator that describes the layers of this paint.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintColrLayers_\n+  {\n+    FT_LayerIterator  layer_iterator;\n+\n+  } FT_PaintColrLayers;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintSolid\n+   *\n+   * @description:\n+   *   A structure representing a `PaintSolid` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *   Using a `PaintSolid` value means that the glyph layer filled with\n+   *   this paint is solid-colored and does not contain a gradient.\n+   *\n+   * @fields:\n+   *   color ::\n+   *     The color information for this solid paint, see @FT_ColorIndex.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintSolid_\n+  {\n+    FT_ColorIndex  color;\n+\n+  } FT_PaintSolid;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintLinearGradient\n+   *\n+   * @description:\n+   *   A structure representing a `PaintLinearGradient` value of the 'COLR'\n+   *   v1 extensions, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  The glyph\n+   *   layer filled with this paint is drawn filled with a linear gradient.\n+   *\n+   * @fields:\n+   *   colorline ::\n+   *     The @FT_ColorLine information for this paint, i.e., the list of\n+   *     color stops along the gradient.\n+   *\n+   *   p0 ::\n+   *     The starting point of the gradient definition in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   p1 ::\n+   *     The end point of the gradient definition in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   p2 ::\n+   *     Optional point~p2 to rotate the gradient in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *     Otherwise equal to~p0.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintLinearGradient_\n+  {\n+    FT_ColorLine  colorline;\n+\n+    \/* TODO: Potentially expose those as x0, y0 etc. *\/\n+    FT_Vector  p0;\n+    FT_Vector  p1;\n+    FT_Vector  p2;\n+\n+  } FT_PaintLinearGradient;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintRadialGradient\n+   *\n+   * @description:\n+   *   A structure representing a `PaintRadialGradient` value of the 'COLR'\n+   *   v1 extensions, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  The glyph\n+   *   layer filled with this paint is drawn filled with a radial gradient.\n+   *\n+   * @fields:\n+   *   colorline ::\n+   *     The @FT_ColorLine information for this paint, i.e., the list of\n+   *     color stops along the gradient.\n+   *\n+   *   c0 ::\n+   *     The center of the starting point of the radial gradient in font\n+   *     units represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   r0 ::\n+   *     The radius of the starting circle of the radial gradient in font\n+   *     units represented as a 16.16 fixed-point value.\n+   *\n+   *   c1 ::\n+   *     The center of the end point of the radial gradient in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   r1 ::\n+   *     The radius of the end circle of the radial gradient in font\n+   *     units represented as a 16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintRadialGradient_\n+  {\n+    FT_ColorLine  colorline;\n+\n+    FT_Vector  c0;\n+    FT_Pos     r0;\n+    FT_Vector  c1;\n+    FT_Pos     r1;\n+\n+  } FT_PaintRadialGradient;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintSweepGradient\n+   *\n+   * @description:\n+   *   A structure representing a `PaintSweepGradient` value of the 'COLR'\n+   *   v1 extensions, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  The glyph\n+   *   layer filled with this paint is drawn filled with a sweep gradient\n+   *   from `start_angle` to `end_angle`.\n+   *\n+   * @fields:\n+   *   colorline ::\n+   *     The @FT_ColorLine information for this paint, i.e., the list of\n+   *     color stops along the gradient.\n+   *\n+   *   center ::\n+   *     The center of the sweep gradient in font units represented as a\n+   *     vector of 16.16 fixed-point values.\n+   *\n+   *   start_angle ::\n+   *     The start angle of the sweep gradient in 16.16 fixed-point\n+   *     format specifying degrees divided by 180.0 (as in the\n+   *     spec).  Multiply by 180.0f to receive degrees value.  Values are\n+   *     given counter-clockwise, starting from the (positive) y~axis.\n+   *\n+   *   end_angle ::\n+   *     The end angle of the sweep gradient in 16.16 fixed-point\n+   *     format specifying degrees divided by 180.0 (as in the\n+   *     spec).  Multiply by 180.0f to receive degrees value.  Values are\n+   *     given counter-clockwise, starting from the (positive) y~axis.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintSweepGradient_\n+  {\n+    FT_ColorLine  colorline;\n+\n+    FT_Vector  center;\n+    FT_Fixed   start_angle;\n+    FT_Fixed   end_angle;\n+\n+  } FT_PaintSweepGradient;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintGlyph\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintGlyph` paint table.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An opaque paint object pointing to a `Paint` table that serves as\n+   *     the fill for the glyph ID.\n+   *\n+   *   glyphID ::\n+   *     The glyph ID from the 'glyf' table, which serves as the contour\n+   *     information that is filled with paint.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintGlyph_\n+  {\n+    FT_OpaquePaint  paint;\n+    FT_UInt         glyphID;\n+\n+  } FT_PaintGlyph;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintColrGlyph\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintColorGlyph` paint table.\n+   *\n+   * @fields:\n+   *   glyphID ::\n+   *     The glyph ID from the `BaseGlyphV1List` table that is drawn for\n+   *     this paint.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintColrGlyph_\n+  {\n+    FT_UInt  glyphID;\n+\n+  } FT_PaintColrGlyph;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintTransform\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintTransform` paint table.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An opaque paint that is subject to being transformed.\n+   *\n+   *   affine ::\n+   *     A 2x3 transformation matrix in @FT_Affine23 format containing\n+   *     16.16 fixed-point values.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintTransform_\n+  {\n+    FT_OpaquePaint  paint;\n+    FT_Affine23     affine;\n+\n+  } FT_PaintTransform;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintTranslate\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintTranslate` paint table.\n+   *   Used for translating downstream paints by a given x and y~delta.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     rotated.\n+   *\n+   *   dx ::\n+   *     Translation in x~direction in font units represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   dy ::\n+   *     Translation in y~direction in font units represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintTranslate_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  dx;\n+    FT_Fixed  dy;\n+\n+  } FT_PaintTranslate;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintScale\n+   *\n+   * @description:\n+   *   A structure representing all of the 'COLR' v1 'PaintScale*' paint\n+   *   tables.  Used for scaling downstream paints by a given x and y~scale,\n+   *   with a given center.  This structure is used for all 'PaintScale*'\n+   *   types that are part of specification; fields of this structure are\n+   *   filled accordingly.  If there is a center, the center values are set,\n+   *   otherwise they are set to the zero coordinate.  If the source font\n+   *   file has 'PaintScaleUniform*' set, the scale values are set\n+   *   accordingly to the same value.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     scaled.\n+   *\n+   *   scale_x ::\n+   *     Scale factor in x~direction represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   scale_y ::\n+   *     Scale factor in y~direction represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   center_x ::\n+   *     x~coordinate of center point to scale from represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   center_y ::\n+   *     y~coordinate of center point to scale from represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintScale_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  scale_x;\n+    FT_Fixed  scale_y;\n+\n+    FT_Fixed  center_x;\n+    FT_Fixed  center_y;\n+\n+  } FT_PaintScale;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintRotate\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintRotate` paint table.  Used\n+   *   for rotating downstream paints with a given center and angle.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     rotated.\n+   *\n+   *   angle ::\n+   *     The rotation angle that is to be applied in degrees divided by\n+   *     180.0 (as in the spec) represented as a 16.16 fixed-point\n+   *     value.  Multiply by 180.0f to receive degrees value.\n+   *\n+   *   center_x ::\n+   *     The x~coordinate of the pivot point of the rotation in font\n+   *     units represented as a 16.16 fixed-point value.\n+   *\n+   *   center_y ::\n+   *     The y~coordinate of the pivot point of the rotation in font\n+   *     units represented as a 16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+\n+  typedef struct  FT_PaintRotate_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  angle;\n+\n+    FT_Fixed  center_x;\n+    FT_Fixed  center_y;\n+\n+  } FT_PaintRotate;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintSkew\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintSkew` paint table.  Used\n+   *   for skewing or shearing downstream paints by a given center and\n+   *   angle.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     skewed.\n+   *\n+   *   x_skew_angle ::\n+   *     The skewing angle in x~direction in degrees divided by 180.0\n+   *     (as in the spec) represented as a 16.16 fixed-point\n+   *     value. Multiply by 180.0f to receive degrees.\n+   *\n+   *   y_skew_angle ::\n+   *     The skewing angle in y~direction in degrees divided by 180.0\n+   *     (as in the spec) represented as a 16.16 fixed-point\n+   *     value.  Multiply by 180.0f to receive degrees.\n+   *\n+   *   center_x ::\n+   *     The x~coordinate of the pivot point of the skew in font units\n+   *     represented as a 16.16 fixed-point value.\n+   *\n+   *   center_y ::\n+   *     The y~coordinate of the pivot point of the skew in font units\n+   *     represented as a 16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintSkew_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  x_skew_angle;\n+    FT_Fixed  y_skew_angle;\n+\n+    FT_Fixed  center_x;\n+    FT_Fixed  center_y;\n+\n+  } FT_PaintSkew;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintComposite\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintComposite` paint table.\n+   *   Used for compositing two paints in a 'COLR' v1 directed acyclic graph.\n+   *\n+   * @fields:\n+   *   source_paint ::\n+   *     An @FT_OpaquePaint object referencing the source that is to be\n+   *     composited.\n+   *\n+   *   composite_mode ::\n+   *     An @FT_Composite_Mode enum value determining the composition\n+   *     operation.\n+   *\n+   *   backdrop_paint ::\n+   *     An @FT_OpaquePaint object referencing the backdrop paint that\n+   *     `source_paint` is composited onto.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_PaintComposite_\n+  {\n+    FT_OpaquePaint     source_paint;\n+    FT_Composite_Mode  composite_mode;\n+    FT_OpaquePaint     backdrop_paint;\n+\n+  } FT_PaintComposite;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @union:\n+   *   FT_COLR_Paint\n+   *\n+   * @description:\n+   *   A union object representing format and details of a paint table of a\n+   *   'COLR' v1 font, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  Use\n+   *   @FT_Get_Paint to retrieve a @FT_COLR_Paint for an @FT_OpaquePaint\n+   *   object.\n+   *\n+   * @fields:\n+   *   format ::\n+   *     The gradient format for this Paint structure.\n+   *\n+   *   u ::\n+   *     Union of all paint table types:\n+   *\n+   *       * @FT_PaintColrLayers\n+   *       * @FT_PaintGlyph\n+   *       * @FT_PaintSolid\n+   *       * @FT_PaintLinearGradient\n+   *       * @FT_PaintRadialGradient\n+   *       * @FT_PaintSweepGradient\n+   *       * @FT_PaintTransform\n+   *       * @FT_PaintTranslate\n+   *       * @FT_PaintRotate\n+   *       * @FT_PaintSkew\n+   *       * @FT_PaintComposite\n+   *       * @FT_PaintColrGlyph\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_COLR_Paint_\n+  {\n+    FT_PaintFormat format;\n+\n+    union\n+    {\n+      FT_PaintColrLayers      colr_layers;\n+      FT_PaintGlyph           glyph;\n+      FT_PaintSolid           solid;\n+      FT_PaintLinearGradient  linear_gradient;\n+      FT_PaintRadialGradient  radial_gradient;\n+      FT_PaintSweepGradient   sweep_gradient;\n+      FT_PaintTransform       transform;\n+      FT_PaintTranslate       translate;\n+      FT_PaintScale           scale;\n+      FT_PaintRotate          rotate;\n+      FT_PaintSkew            skew;\n+      FT_PaintComposite       composite;\n+      FT_PaintColrGlyph       colr_glyph;\n+\n+    } u;\n+\n+  } FT_COLR_Paint;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_Color_Root_Transform\n+   *\n+   * @description:\n+   *   An enumeration to specify whether @FT_Get_Color_Glyph_Paint is to\n+   *   return a root transform to configure the client's graphics context\n+   *   matrix.\n+   *\n+   * @values:\n+   *   FT_COLOR_INCLUDE_ROOT_TRANSFORM ::\n+   *     Do include the root transform as the initial @FT_COLR_Paint object.\n+   *\n+   *   FT_COLOR_NO_ROOT_TRANSFORM ::\n+   *     Do not output an initial root transform.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef enum  FT_Color_Root_Transform_\n+  {\n+    FT_COLOR_INCLUDE_ROOT_TRANSFORM,\n+    FT_COLOR_NO_ROOT_TRANSFORM,\n+\n+    FT_COLOR_ROOT_TRANSFORM_MAX\n+\n+  } FT_Color_Root_Transform;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ClipBox\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 'ClipBox' table.  'COLR' v1\n+   *   glyphs may optionally define a clip box for aiding allocation or\n+   *   defining a maximum drawable region.  Use @FT_Get_Color_Glyph_ClipBox\n+   *   to retrieve it.\n+   *\n+   * @fields:\n+   *   bottom_left ::\n+   *     The bottom left corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   *   top_left ::\n+   *     The top left corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   *   top_right ::\n+   *     The top right corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   *   bottom_right ::\n+   *     The bottom right corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  typedef struct  FT_ClipBox_\n+  {\n+    FT_Vector  bottom_left;\n+    FT_Vector  top_left;\n+    FT_Vector  top_right;\n+    FT_Vector  bottom_right;\n+\n+  } FT_ClipBox;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Color_Glyph_Paint\n+   *\n+   * @description:\n+   *   This is the starting point and interface to color gradient\n+   *   information in a 'COLR' v1 table in OpenType fonts to recursively\n+   *   retrieve the paint tables for the directed acyclic graph of a colored\n+   *   glyph, given a glyph ID.\n+   *\n+   *     https:\/\/github.com\/googlefonts\/colr-gradients-spec\n+   *\n+   *   In a 'COLR' v1 font, each color glyph defines a directed acyclic\n+   *   graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,\n+   *   `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this\n+   *   function and specifying a glyph ID, one retrieves the root paint\n+   *   table for this glyph ID.\n+   *\n+   *   This function allows control whether an initial root transform is\n+   *   returned to configure scaling, transform, and translation correctly\n+   *   on the client's graphics context.  The initial root transform is\n+   *   computed and returned according to the values configured for @FT_Size\n+   *   and @FT_Set_Transform on the @FT_Face object, see below for details\n+   *   of the `root_transform` parameter.  This has implications for a\n+   *   client 'COLR' v1 implementation: When this function returns an\n+   *   initially computed root transform, at the time of executing the\n+   *   @FT_PaintGlyph operation, the contours should be retrieved using\n+   *   @FT_Load_Glyph at unscaled, untransformed size.  This is because the\n+   *   root transform applied to the graphics context will take care of\n+   *   correct scaling.\n+   *\n+   *   Alternatively, to allow hinting of contours, at the time of executing\n+   *   @FT_Load_Glyph, the current graphics context transformation matrix\n+   *   can be decomposed into a scaling matrix and a remainder, and\n+   *   @FT_Load_Glyph can be used to retrieve the contours at scaled size.\n+   *   Care must then be taken to blit or clip to the graphics context with\n+   *   taking this remainder transformation into account.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index for which to retrieve the root paint table.\n+   *\n+   *   root_transform ::\n+   *     Specifies whether an initially computed root is returned by the\n+   *     @FT_PaintTransform operation to account for the activated size\n+   *     (see @FT_Activate_Size) and the configured transform and translate\n+   *     (see @FT_Set_Transform).\n+   *\n+   *     This root transform is returned before nodes of the glyph graph of\n+   *     the font are returned.  Subsequent @FT_COLR_Paint structures\n+   *     contain unscaled and untransformed values.  The inserted root\n+   *     transform enables the client application to apply an initial\n+   *     transform to its graphics context.  When executing subsequent\n+   *     FT_COLR_Paint operations, values from @FT_COLR_Paint operations\n+   *     will ultimately be correctly scaled because of the root transform\n+   *     applied to the graphics context.  Use\n+   *     @FT_COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use\n+   *     @FT_COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be\n+   *     useful when traversing the 'COLR' v1 glyph graph and reaching a\n+   *     @FT_PaintColrGlyph.  When recursing into @FT_PaintColrGlyph and\n+   *     painting that inline, no additional root transform is needed as it\n+   *     has already been applied to the graphics context at the beginning\n+   *     of drawing this glyph.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The @FT_OpaquePaint object that references the actual paint table.\n+   *\n+   *     The respective actual @FT_COLR_Paint object is retrieved via\n+   *     @FT_Get_Paint.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If no color glyph is found, or the root\n+   *   paint could not be retrieved, value~0 gets returned.  In case of an\n+   *   error, value~0 is returned also.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Color_Glyph_Paint( FT_Face                  face,\n+                            FT_UInt                  base_glyph,\n+                            FT_Color_Root_Transform  root_transform,\n+                            FT_OpaquePaint*          paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Color_Glyph_ClipBox\n+   *\n+   * @description:\n+   *   Search for a 'COLR' v1 clip box for the specified `base_glyph` and\n+   *   fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information\n+   *   if one is found.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index for which to retrieve the clip box.\n+   *\n+   * @output:\n+   *   clip_box ::\n+   *     The clip box for the requested `base_glyph` if one is found.  The\n+   *     clip box is computed taking scale and transformations configured on\n+   *     the @FT_Face into account.  @FT_ClipBox contains @FT_Vector values\n+   *     in 26.6 format.\n+   *\n+   * @return:\n+   *   Value~1 if a clip box is found.  If no clip box is found or an error\n+   *   occured, value~0 is returned.\n+   *\n+   * @note:\n+   *   To retrieve the clip box in font units, reset scale to units-per-em\n+   *   and remove transforms configured using @FT_Set_Transform.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Color_Glyph_ClipBox( FT_Face      face,\n+                              FT_UInt      base_glyph,\n+                              FT_ClipBox*  clip_box );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Paint_Layers\n+   *\n+   * @description:\n+   *   Access the layers of a `PaintColrLayers` table.\n+   *\n+   *   If the root paint of a color glyph, or a nested paint of a 'COLR'\n+   *   glyph is a `PaintColrLayers` table, this function retrieves the\n+   *   layers of the `PaintColrLayers` table.\n+   *\n+   *   The @FT_PaintColrLayers object contains an @FT_LayerIterator, which\n+   *   is used here to iterate over the layers.  Each layer is returned as\n+   *   an @FT_OpaquePaint object, which then can be used with @FT_Get_Paint\n+   *   to retrieve the actual paint object.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     The @FT_LayerIterator from an @FT_PaintColrLayers object, for which\n+   *     the layers are to be retrieved.  The internal state of the iterator\n+   *     is incremented after one call to this function for retrieving one\n+   *     layer.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The @FT_OpaquePaint object that references the actual paint table.\n+   *     The respective actual @FT_COLR_Paint object is retrieved via\n+   *     @FT_Get_Paint.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 gets returned when the paint\n+   *   object can not be retrieved or any other error occurs.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Paint_Layers( FT_Face            face,\n+                       FT_LayerIterator*  iterator,\n+                       FT_OpaquePaint*    paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Colorline_Stops\n+   *\n+   * @description:\n+   *   This is an interface to color gradient information in a 'COLR' v1\n+   *   table in OpenType fonts to iteratively retrieve the gradient and\n+   *   solid fill information for colored glyph layers for a specified glyph\n+   *   ID.\n+   *\n+   *     https:\/\/github.com\/googlefonts\/colr-gradients-spec\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     The retrieved @FT_ColorStopIterator, configured on an @FT_ColorLine,\n+   *     which in turn got retrieved via paint information in\n+   *     @FT_PaintLinearGradient or @FT_PaintRadialGradient.\n+   *\n+   * @output:\n+   *   color_stop ::\n+   *     Color index and alpha value for the retrieved color stop.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If there are no more color stops,\n+   *   value~0 gets returned.  In case of an error, value~0 is returned\n+   *   also.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Colorline_Stops( FT_Face                face,\n+                          FT_ColorStop*          color_stop,\n+                          FT_ColorStopIterator*  iterator );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *  FT_Get_Paint\n+   *\n+   * @description:\n+   *   Access the details of a paint using an @FT_OpaquePaint opaque paint\n+   *   object, which internally stores the offset to the respective `Paint`\n+   *   object in the 'COLR' table.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   opaque_paint ::\n+   *     The opaque paint object for which the underlying @FT_COLR_Paint\n+   *     data is to be retrieved.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The specific @FT_COLR_Paint object containing information coming\n+   *     from one of the font's `Paint*` tables.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 if no details can be found for\n+   *   this paint or any other error occured.\n+   *\n+   * @since:\n+   *   2.13\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Paint( FT_Face         face,\n+                FT_OpaquePaint  opaque_paint,\n+                FT_COLR_Paint*  paint );\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftcolor.h","additions":1355,"deletions":1,"binary":false,"changes":1356,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n@@ -56,4 +56,4 @@\n-   *   (experimental), @darkening-parameters (experimental), @warping\n-   *   (experimental), @glyph-to-script-map (experimental), @fallback-script\n-   *   (experimental), and @default-script (experimental), as documented in\n-   *   the @properties section.\n+   *   (experimental), @darkening-parameters (experimental),\n+   *   @glyph-to-script-map (experimental), @fallback-script (experimental),\n+   *   and @default-script (experimental), as documented in the @properties\n+   *   section.\n@@ -87,1 +87,1 @@\n-   *   **Hinting and antialiasing principles of the new engine**\n+   *   **Hinting and anti-aliasing principles of the new engine**\n@@ -91,1 +91,1 @@\n-   *   amount of antialiasing applied to them, while placing vertical\n+   *   amount of anti-aliasing applied to them, while placing vertical\n@@ -95,1 +95,1 @@\n-   *   'antialiasing' means that stems are not positioned exactly on pixel\n+   *   'anti-aliasing' means that stems are not positioned exactly on pixel\n@@ -111,1 +111,1 @@\n-   *   One of the reasons to not hint horizontally is antialiasing for LCD\n+   *   One of the reasons to not hint horizontally is anti-aliasing for LCD\n@@ -119,1 +119,1 @@\n-   *   designs.  Even when the rasterizer uses greyscale antialiasing instead\n+   *   designs.  Even when the rasterizer uses greyscale anti-aliasing instead\n@@ -137,1 +137,1 @@\n-   *   Hstems (this is, hint values defined in the font to help align\n+   *   Hstems (that is, hint values defined in the font to help align\n@@ -215,4 +215,1 @@\n-   *   and @FT_Property_Get.  The following lists the available properties\n-   *   together with the necessary macros and structures.\n-   *\n-   *   The TrueType driver's module name is 'truetype'.\n+   *   and @FT_Property_Get.\n@@ -220,2 +217,3 @@\n-   *   A single property @interpreter-version is available, as documented in\n-   *   the @properties section.\n+   *   The TrueType driver's module name is 'truetype'; a single property\n+   *   @interpreter-version is available, as documented in the @properties\n+   *   section.\n@@ -223,2 +221,2 @@\n-   *   We start with a list of definitions, kindly provided by Greg\n-   *   Hitchcock.\n+   *   To help understand the differences between interpreter versions, we\n+   *   introduce a list of definitions, kindly provided by Greg Hitchcock.\n@@ -303,0 +301,25 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   ot_svg_driver\n+   *\n+   * @title:\n+   *   The SVG driver\n+   *\n+   * @abstract:\n+   *   Controlling the external rendering of OT-SVG glyphs.\n+   *\n+   * @description:\n+   *   By default, FreeType can only load the 'SVG~' table of OpenType fonts\n+   *   if configuration macro `FT_CONFIG_OPTION_SVG` is defined.  To make it\n+   *   render SVG glyphs, an external SVG rendering library is needed.  All\n+   *   details on the interface between FreeType and the external library\n+   *   via function hooks can be found in section @svg_fonts.\n+   *\n+   *   The OT-SVG driver's module name is 'ot-svg'; it supports a single\n+   *   property called @svg-hooks, documented below in the @properties\n+   *   section.\n+   *\n+   *\/\n+\n+\n@@ -365,6 +388,2 @@\n-   *   For the 'cff' module, the default engine is 'freetype' if\n-   *   `CFF_CONFIG_OPTION_OLD_ENGINE` is defined, and 'adobe' otherwise.\n-   *\n-   *   For both the 'type1' and 't1cid' modules, the default engine is\n-   *   'freetype' if `T1_CONFIG_OPTION_OLD_ENGINE` is defined, and 'adobe'\n-   *   otherwise.\n+   *   For the 'cff' module, the default engine is 'adobe'.  For both the\n+   *   'type1' and 't1cid' modules, the default engine is 'adobe', too.\n@@ -430,1 +449,1 @@\n-   *   switched off by default (this is, `no-stem-darkening` is set to TRUE\n+   *   switched off by default (that is, `no-stem-darkening` is set to TRUE\n@@ -635,5 +654,2 @@\n-   *     Version~38 corresponds to MS rasterizer v.1.9; it is roughly\n-   *     equivalent to the hinting provided by DirectWrite ClearType (as can\n-   *     be found, for example, in the Internet Explorer~9 running on\n-   *     Windows~7).  It is used in FreeType to select the 'Infinality'\n-   *     subpixel hinting code.  The code may be removed in a future version.\n+   *     Version~38 is the same Version~40. The original 'Infinality' code is\n+   *     no longer available.\n@@ -805,0 +821,107 @@\n+  \/**************************************************************************\n+   *\n+   * @property:\n+   *   spread\n+   *\n+   * @description:\n+   *   This property of the 'sdf' and 'bsdf' renderers defines how the signed\n+   *   distance field (SDF) is represented in the output bitmap.  The output\n+   *   values are calculated as follows, '128 * ( SDF \/ spread + 1 )', with\n+   *   the result clamped to the 8-bit range [0..255].  Therefore, 'spread'\n+   *   is also the maximum euclidean distance from the edge after which the\n+   *   values are clamped.  The spread is specified in pixels with the\n+   *   default value of 8.  For accurate SDF texture mapping (interpolation),\n+   *   the spread should be large enough to accommodate the target grid unit.\n+   *\n+   * @example:\n+   *   The following example code demonstrates how to set the SDF spread\n+   *   (omitting the error handling).\n+   *\n+   *   ```\n+   *     FT_Library  library;\n+   *     FT_Int      spread = 2;\n+   *\n+   *\n+   *     FT_Init_FreeType( &library );\n+   *\n+   *     FT_Property_Set( library, \"sdf\", \"spread\", &spread );\n+   *   ```\n+   *\n+   * @note:\n+   *   FreeType has two rasterizers for generating SDF, namely:\n+   *\n+   *   1. `sdf` for generating SDF directly from glyph's outline, and\n+   *\n+   *   2. `bsdf` for generating SDF from rasterized bitmaps.\n+   *\n+   *   Depending on the glyph type (i.e., outline or bitmap), one of the two\n+   *   rasterizers is chosen at runtime and used for generating SDFs.  To\n+   *   force the use of `bsdf` you should render the glyph with any of the\n+   *   FreeType's other rendering modes (e.g., `FT_RENDER_MODE_NORMAL`) and\n+   *   then re-render with `FT_RENDER_MODE_SDF`.\n+   *\n+   *   There are some issues with stability and possible failures of the SDF\n+   *   renderers (specifically `sdf`).\n+   *\n+   *   1. The `sdf` rasterizer is sensitive to really small features (e.g.,\n+   *      sharp turns that are less than 1~pixel) and imperfections in the\n+   *      glyph's outline, causing artifacts in the final output.\n+   *\n+   *   2. The `sdf` rasterizer has limited support for handling intersecting\n+   *      contours and *cannot* handle self-intersecting contours whatsoever.\n+   *      Self-intersection happens when a single connected contour\n+   *      intersects itself at some point; having these in your font\n+   *      definitely poses a problem to the rasterizer and cause artifacts,\n+   *      too.\n+   *\n+   *   3. Generating SDF for really small glyphs may result in undesirable\n+   *      output; the pixel grid (which stores distance information) becomes\n+   *      too coarse.\n+   *\n+   *   4. Since the output buffer is normalized, precision at smaller spreads\n+   *      is greater than precision at larger spread values because the\n+   *      output range of [0..255] gets mapped to a smaller SDF range.  A\n+   *      spread of~2 should be sufficient in most cases.\n+   *\n+   *   Points (1) and (2) can be avoided by using the `bsdf` rasterizer,\n+   *   which is more stable than the `sdf` rasterizer in general.\n+   *\n+   * @since:\n+   *   2.11\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @property:\n+   *   svg-hooks\n+   *\n+   * @description:\n+   *   Set up the interface between FreeType and an extern SVG rendering\n+   *   library like 'librsvg'.  All details on the function hooks can be\n+   *   found in section @svg_fonts.\n+   *\n+   * @example:\n+   *   The following example code expects that the four hook functions\n+   *   `svg_*` are defined elsewhere.  Error handling is omitted, too.\n+   *\n+   *   ```\n+   *     FT_Library  library;\n+   *     SVG_RendererHooks  hooks = {\n+   *                          (SVG_Lib_Init_Func)svg_init,\n+   *                          (SVG_Lib_Free_Func)svg_free,\n+   *                          (SVG_Lib_Render_Func)svg_render,\n+   *                          (SVG_Lib_Preset_Slot_Func)svg_preset_slot };\n+   *\n+   *\n+   *     FT_Init_FreeType( &library );\n+   *\n+   *     FT_Property_Set( library, \"ot-svg\",\n+   *                               \"svg-hooks\", &hooks );\n+   *   ```\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+\n+\n@@ -1169,1 +1292,1 @@\n-   *   **Experimental only**\n+   *   **Obsolete**\n@@ -1171,3 +1294,3 @@\n-   *   If FreeType gets compiled with option `AF_CONFIG_OPTION_USE_WARPER` to\n-   *   activate the warp hinting code in the auto-hinter, this property\n-   *   switches warping on and off.\n+   *   This property was always experimental and probably never worked\n+   *   correctly.  It was entirely removed from the FreeType~2 sources.  This\n+   *   entry is only here for historical reference.\n@@ -1175,2 +1298,2 @@\n-   *   Warping only works in 'normal' auto-hinting mode replacing it.  The\n-   *   idea of the code is to slightly scale and shift a glyph along the\n+   *   Warping only worked in 'normal' auto-hinting mode replacing it.  The\n+   *   idea of the code was to slightly scale and shift a glyph along the\n@@ -1178,1 +1301,1 @@\n-   *   much of its segments are aligned (more or less) to the grid.  To find\n+   *   much of its segments were aligned (more or less) to the grid.  To find\n@@ -1180,31 +1303,1 @@\n-   *   combinations are tried and scored.\n-   *\n-   *   By default, warping is off.\n-   *\n-   * @note:\n-   *   This property can be used with @FT_Property_Get also.\n-   *\n-   *   This property can be set via the `FREETYPE_PROPERTIES` environment\n-   *   variable (using values 1 and 0 for 'on' and 'off', respectively).\n-   *\n-   *   The warping code can also change advance widths.  Have a look at the\n-   *   `lsb_delta` and `rsb_delta` fields in the @FT_GlyphSlotRec structure\n-   *   for details on improving inter-glyph distances while rendering.\n-   *\n-   *   Since warping is a global property of the auto-hinter it is best to\n-   *   change its value before rendering any face.  Otherwise, you should\n-   *   reload all faces that get auto-hinted in 'normal' hinting mode.\n-   *\n-   * @example:\n-   *   This example shows how to switch on warping (omitting the error\n-   *   handling).\n-   *\n-   *   ```\n-   *     FT_Library  library;\n-   *     FT_Bool     warping = 1;\n-   *\n-   *\n-   *     FT_Init_FreeType( &library );\n-   *\n-   *     FT_Property_Set( library, \"autofitter\", \"warping\", &warping );\n-   *   ```\n+   *   combinations were tried and scored.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftdriver.h","additions":162,"deletions":69,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -104,0 +104,2 @@\n+  FT_ERRORDEF_( Invalid_SVG_Document,                        0x18,\n+                \"invalid SVG document\" )\n@@ -237,0 +239,2 @@\n+  FT_ERRORDEF_( Missing_SVG_Hooks,                           0x9E,\n+                \"SVG hooks have not been set\" )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/fterrdef.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -32,1 +32,1 @@\n-   *   `freetype.h` defines the handling of FreeType's enumeration\n+   *   `freetype.h`) defines the handling of FreeType's enumeration\n@@ -284,0 +284,2 @@\n+  \/* *\/\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/fterrors.h","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftgasp.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -129,1 +129,1 @@\n-   *   sub-class of @FT_Glyph, and a pointer to @FT_BitmapGlyphRec.\n+   *   'sub-class' of @FT_Glyph, and a pointer to @FT_BitmapGlyphRec.\n@@ -145,1 +145,1 @@\n-   *     The root @FT_Glyph fields.\n+   *     The root fields of @FT_Glyph.\n@@ -184,1 +184,1 @@\n-   *   sub-class of @FT_Glyph, and a pointer to @FT_OutlineGlyphRec.\n+   *   'sub-class' of @FT_Glyph, and a pointer to @FT_OutlineGlyphRec.\n@@ -225,0 +225,86 @@\n+  \/**************************************************************************\n+   *\n+   * @type:\n+   *   FT_SvgGlyph\n+   *\n+   * @description:\n+   *   A handle to an object used to model an SVG glyph.  This is a\n+   *   'sub-class' of @FT_Glyph, and a pointer to @FT_SvgGlyphRec.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct FT_SvgGlyphRec_*  FT_SvgGlyph;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_SvgGlyphRec\n+   *\n+   * @description:\n+   *   A structure used for OT-SVG glyphs.  This is a 'sub-class' of\n+   *   @FT_GlyphRec.\n+   *\n+   * @fields:\n+   *   root ::\n+   *     The root @FT_GlyphRec fields.\n+   *\n+   *   svg_document ::\n+   *     A pointer to the SVG document.\n+   *\n+   *   svg_document_length ::\n+   *     The length of `svg_document`.\n+   *\n+   *   glyph_index ::\n+   *     The index of the glyph to be rendered.\n+   *\n+   *   metrics ::\n+   *     A metrics object storing the size information.\n+   *\n+   *   units_per_EM ::\n+   *     The size of the EM square.\n+   *\n+   *   start_glyph_id ::\n+   *     The first glyph ID in the glyph range covered by this document.\n+   *\n+   *   end_glyph_id ::\n+   *     The last glyph ID in the glyph range covered by this document.\n+   *\n+   *   transform ::\n+   *     A 2x2 transformation matrix to apply to the glyph while rendering\n+   *     it.\n+   *\n+   *   delta ::\n+   *     Translation to apply to the glyph while rendering.\n+   *\n+   * @note:\n+   *   The Glyph Management API requires @FT_Glyph or its 'sub-class' to have\n+   *   all the information needed to completely define the glyph's rendering.\n+   *   Outline-based glyphs can directly apply transformations to the outline\n+   *   but this is not possible for an SVG document that hasn't been parsed.\n+   *   Therefore, the transformation is stored along with the document.  In\n+   *   the absence of a 'ViewBox' or 'Width'\/'Height' attribute, the size of\n+   *   the ViewPort should be assumed to be 'units_per_EM'.\n+   *\/\n+  typedef struct  FT_SvgGlyphRec_\n+  {\n+    FT_GlyphRec  root;\n+\n+    FT_Byte*  svg_document;\n+    FT_ULong  svg_document_length;\n+\n+    FT_UInt  glyph_index;\n+\n+    FT_Size_Metrics  metrics;\n+    FT_UShort        units_per_EM;\n+\n+    FT_UShort  start_glyph_id;\n+    FT_UShort  end_glyph_id;\n+\n+    FT_Matrix  transform;\n+    FT_Vector  delta;\n+\n+  } FT_SvgGlyphRec;\n+\n+\n@@ -272,1 +358,1 @@\n-   *     A handle to the glyph object.\n+   *     A handle to the glyph object.  `NULL` in case of error.\n@@ -302,1 +388,1 @@\n-   *     A handle to the target glyph object.  0~in case of error.\n+   *     A handle to the target glyph object.  `NULL` in case of error.\n@@ -330,1 +416,1 @@\n-   *     1\/64th of a pixel.\n+   *     1\/64 of a pixel.\n@@ -340,3 +426,3 @@\n-  FT_Glyph_Transform( FT_Glyph    glyph,\n-                      FT_Matrix*  matrix,\n-                      FT_Vector*  delta );\n+  FT_Glyph_Transform( FT_Glyph          glyph,\n+                      const FT_Matrix*  matrix,\n+                      const FT_Vector*  delta );\n@@ -417,1 +503,1 @@\n-   *     1\/64th of pixels if it is grid-fitted.\n+   *     1\/64 of pixels if it is grid-fitted.\n@@ -501,1 +587,1 @@\n-   *   The first parameter is a pointer to an @FT_Glyph handle, that will be\n+   *   The first parameter is a pointer to an @FT_Glyph handle that will be\n@@ -503,1 +589,1 @@\n-   *   you would use (omitting error handling):\n+   *   you would do something like the following (omitting error handling).\n@@ -520,1 +606,1 @@\n-   *                                     0, 1 );\n+   *                                   0, 1 );\n@@ -535,1 +621,1 @@\n-   *   Here is another example, again without error handling:\n+   *   Here is another example, again without error handling.\n@@ -572,4 +658,4 @@\n-  FT_Glyph_To_Bitmap( FT_Glyph*       the_glyph,\n-                      FT_Render_Mode  render_mode,\n-                      FT_Vector*      origin,\n-                      FT_Bool         destroy );\n+  FT_Glyph_To_Bitmap( FT_Glyph*         the_glyph,\n+                      FT_Render_Mode    render_mode,\n+                      const FT_Vector*  origin,\n+                      FT_Bool           destroy );\n@@ -588,1 +674,1 @@\n-   *     A handle to the target glyph object.\n+   *     A handle to the target glyph object.  Can be `NULL`.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftglyph.h","additions":106,"deletions":20,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftgzip.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -22,1 +22,6 @@\n-   *       FT_Outlines into FT_Bitmaps.\n+   *       `FT_Outline`s into `FT_Bitmap`s.\n+   *\n+   * Note: This file can be used for `STANDALONE_` compilation of raster\n+   *       (B\/W) and smooth (anti-aliased) renderers.  Therefore, it must\n+   *       rely on standard variable types only instead of aliases in\n+   *       `fttypes.h`.\n@@ -31,5 +36,0 @@\n-  \/* STANDALONE_ is from ftgrays.c *\/\n-#ifndef STANDALONE_\n-#endif\n-\n-\n@@ -204,0 +204,5 @@\n+  \/* *\/\n+\n+  \/* For debugging, the @FT_Pixel_Mode enumeration must stay in sync *\/\n+  \/* with the `pixel_modes` array in file `ftobjs.c`.                *\/\n+\n@@ -259,0 +264,6 @@\n+   *\n+   * @note:\n+   *   `width` and `rows` refer to the *physical* size of the bitmap, not the\n+   *   *logical* one.  For example, if @FT_Pixel_Mode is set to\n+   *   `FT_PIXEL_MODE_LCD`, the logical width is a just a third of the\n+   *   physical one.\n@@ -315,1 +326,1 @@\n-   *     the 'SCANMODE' instruction).\n+   *     the 'SCANTYPE' instruction).\n@@ -338,2 +349,2 @@\n-    short       n_contours;      \/* number of contours in glyph        *\/\n-    short       n_points;        \/* number of points in the glyph      *\/\n+    unsigned short   n_contours;  \/* number of contours in glyph        *\/\n+    unsigned short   n_points;    \/* number of points in the glyph      *\/\n@@ -341,3 +352,3 @@\n-    FT_Vector*  points;          \/* the outline's points               *\/\n-    char*       tags;            \/* the points flags                   *\/\n-    short*      contours;        \/* the contour end points             *\/\n+    FT_Vector*       points;      \/* the outline's points               *\/\n+    unsigned char*   tags;        \/* the points flags                   *\/\n+    unsigned short*  contours;    \/* the contour end points             *\/\n@@ -345,1 +356,1 @@\n-    int         flags;           \/* outline masks                      *\/\n+    int              flags;       \/* outline masks                      *\/\n@@ -353,2 +364,2 @@\n-#define FT_OUTLINE_CONTOURS_MAX  SHRT_MAX\n-#define FT_OUTLINE_POINTS_MAX    SHRT_MAX\n+#define FT_OUTLINE_CONTOURS_MAX  USHRT_MAX\n+#define FT_OUTLINE_POINTS_MAX    USHRT_MAX\n@@ -404,5 +415,5 @@\n-   *     This flag indicates that this outline contains overlapping contrours\n-   *     and the anti-aliased renderer should perform oversampling to\n-   *     mitigate possible artifacts.  This flag should _not_ be set for\n-   *     well designed glyphs without overlaps because it quadruples the\n-   *     rendering time.\n+   *     [Since 2.10.3] This flag indicates that this outline contains\n+   *     overlapping contours and the anti-aliased renderer should perform\n+   *     oversampling to mitigate possible artifacts.  This flag should _not_\n+   *     be set for well designed glyphs without overlaps because it quadruples\n+   *     the rendering time.\n@@ -431,2 +442,2 @@\n-   *   OpenType specification (in file `ttinst1.doc`) how simple drop-outs,\n-   *   smart drop-outs, and stubs are defined.\n+   *   [OpenType specification](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/tt_instructions#scantype)\n+   *   how simple drop-outs, smart drop-outs, and stubs are defined.\n@@ -698,5 +709,7 @@\n-#define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  \\\n-          value = ( ( (unsigned long)_x1 << 24 ) | \\\n-                    ( (unsigned long)_x2 << 16 ) | \\\n-                    ( (unsigned long)_x3 << 8  ) | \\\n-                      (unsigned long)_x4         )\n+\n+#define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )                         \\\n+          value = ( ( FT_STATIC_BYTE_CAST( unsigned long, _x1 ) << 24 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( unsigned long, _x2 ) << 16 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( unsigned long, _x3 ) << 8  ) | \\\n+                      FT_STATIC_BYTE_CAST( unsigned long, _x4 )         )\n+\n@@ -742,0 +755,4 @@\n+   *\n+   *   FT_GLYPH_FORMAT_SVG ::\n+   *     [Since 2.12] The glyph is represented by an SVG document in the\n+   *     'SVG~' table.\n@@ -750,1 +767,2 @@\n-    FT_IMAGE_TAG( FT_GLYPH_FORMAT_PLOTTER,   'p', 'l', 'o', 't' )\n+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_PLOTTER,   'p', 'l', 'o', 't' ),\n+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_SVG,       'S', 'V', 'G', ' ' )\n@@ -775,11 +793,0 @@\n-  \/**************************************************************************\n-   *\n-   * A raster is a scan converter, in charge of rendering an outline into a\n-   * bitmap.  This section contains the public API for rasters.\n-   *\n-   * Note that in FreeType 2, all rasters are now encapsulated within\n-   * specific modules called 'renderers'.  See `ftrender.h` for more details\n-   * on renderers.\n-   *\n-   *\/\n-\n@@ -799,1 +806,21 @@\n-   *   This section contains technical definitions.\n+   *   A raster or a rasterizer is a scan converter in charge of producing a\n+   *   pixel coverage bitmap that can be used as an alpha channel when\n+   *   compositing a glyph with a background.  FreeType comes with two\n+   *   rasterizers: bilevel `raster1` and anti-aliased `smooth` are two\n+   *   separate modules.  They are usually called from the high-level\n+   *   @FT_Load_Glyph or @FT_Render_Glyph functions and produce the entire\n+   *   coverage bitmap at once, while staying largely invisible to users.\n+   *\n+   *   Instead of working with complete coverage bitmaps, it is also possible\n+   *   to intercept consecutive pixel runs on the same scanline with the same\n+   *   coverage, called _spans_, and process them individually.  Only the\n+   *   `smooth` rasterizer permits this when calling @FT_Outline_Render with\n+   *   @FT_Raster_Params as described below.\n+   *\n+   *   Working with either complete bitmaps or spans it is important to think\n+   *   of them as colorless coverage objects suitable as alpha channels to\n+   *   blend arbitrary colors with a background.  For best results, it is\n+   *   recommended to use gamma correction, too.\n+   *\n+   *   This section also describes the public API needed to set up alternative\n+   *   @FT_Renderer modules.\n@@ -802,1 +829,0 @@\n-   *   FT_Raster\n@@ -805,1 +831,0 @@\n-   *\n@@ -809,0 +834,1 @@\n+   *   FT_Raster\n@@ -819,12 +845,0 @@\n-  \/**************************************************************************\n-   *\n-   * @type:\n-   *   FT_Raster\n-   *\n-   * @description:\n-   *   An opaque handle (pointer) to a raster object.  Each object can be\n-   *   used independently to convert an outline into a bitmap or pixmap.\n-   *\/\n-  typedef struct FT_RasterRec_*  FT_Raster;\n-\n-\n@@ -837,2 +851,2 @@\n-   *   A structure used to model a single span of gray pixels when rendering\n-   *   an anti-aliased bitmap.\n+   *   A structure to model a single span of consecutive pixels when\n+   *   rendering an anti-aliased bitmap.\n@@ -855,2 +869,2 @@\n-   *   The coverage value is always between 0 and 255.  If you want less gray\n-   *   values, the callback function has to reduce them.\n+   *   The anti-aliased rasterizer produces coverage values from 0 to 255,\n+   *   that is, from completely transparent to completely opaque.\n@@ -874,2 +888,2 @@\n-   *   to let client applications draw themselves the gray pixel spans on\n-   *   each scan line.\n+   *   to let client applications draw themselves the pixel spans on each\n+   *   scan line.\n@@ -891,2 +905,2 @@\n-   *   This callback allows client applications to directly render the gray\n-   *   spans of the anti-aliased bitmap to any kind of surfaces.\n+   *   This callback allows client applications to directly render the spans\n+   *   of the anti-aliased bitmap to any kind of surfaces.\n@@ -895,1 +909,2 @@\n-   *   background bitmap, and even perform translucency.\n+   *   background bitmap using alpha compositing.  It can also be used for\n+   *   oversampling and averaging.\n@@ -965,0 +980,5 @@\n+   *\n+   *   FT_RASTER_FLAG_SDF ::\n+   *     This flag is set to indicate that a signed distance field glyph\n+   *     image should be generated.  This is only used while rendering with\n+   *     the @FT_RENDER_MODE_SDF render mode.\n@@ -970,0 +990,1 @@\n+#define FT_RASTER_FLAG_SDF      0x8\n@@ -1050,0 +1071,17 @@\n+  \/**************************************************************************\n+   *\n+   * @type:\n+   *   FT_Raster\n+   *\n+   * @description:\n+   *   An opaque handle (pointer) to a raster object.  Each object can be\n+   *   used independently to convert an outline into a bitmap or pixmap.\n+   *\n+   * @note:\n+   *   In FreeType 2, all rasters are now encapsulated within specific\n+   *   @FT_Renderer modules and only used in their context.\n+   *\n+   *\/\n+  typedef struct FT_RasterRec_*  FT_Raster;\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftimage.h","additions":102,"deletions":64,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -216,3 +216,8 @@\n-   *   before accessing its data.  This is necessary because, in certain\n-   *   formats like TrueType, the metrics are stored in a different place\n-   *   from the glyph images proper.\n+   *   before accessing its data.  This allows for handling font types such\n+   *   as PCL~XL Format~1, Class~2 downloaded TrueType fonts, where the glyph\n+   *   metrics (`hmtx` and `vmtx` tables) are permitted to be omitted from\n+   *   the font, and the relevant metrics included in the header of the glyph\n+   *   outline data.  Importantly, this is not intended to allow custom glyph\n+   *   metrics (for example, Postscript Metrics dictionaries), because that\n+   *   conflicts with the requirements of outline hinting.  Such custom\n+   *   metrics must be handled separately, by the calling application.\n@@ -238,1 +243,1 @@\n-   *     The replacement glyph metrics in font units.\n+   *     The glyph metrics in font units.\n@@ -267,1 +272,1 @@\n-   *     provide overriding glyph metrics.\n+   *     require it.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftincrem.h","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n@@ -58,1 +58,1 @@\n-   *   subpixels coverages unfiltered can create severe color fringes\n+   *   subpixel coverages unfiltered can create severe color fringes\n@@ -61,4 +61,3 @@\n-   *   equally.\n-   *\n-   *   A good 5-tap FIR filter should be applied to subpixel coverages\n-   *   regardless of pixel boundaries and should have these properties:\n+   *   evenly.  Therefore, an equalizing 5-tap FIR filter should be applied\n+   *   to subpixel coverages regardless of pixel boundaries and should have\n+   *   these properties:\n@@ -87,1 +86,1 @@\n-   *   center.  In this case, each color channel is then rendered separately\n+   *   center.  In this case, each color channel can be rendered separately\n@@ -104,3 +103,3 @@\n-   *   As a result of ClearType filtering or Harmony rendering, the\n-   *   dimensions of LCD bitmaps can be either wider or taller than the\n-   *   dimensions of the corresponding outline with regard to the pixel grid.\n+   *   As a result of ClearType filtering or Harmony shifts, the resulting\n+   *   dimensions of LCD bitmaps can be slightly wider or taller than the\n+   *   dimensions the original outline with regard to the pixel grid.\n@@ -141,1 +140,1 @@\n-   *     with weights of [0x08 0x4D 0x56 0x4D 0x08] in 1\/256th units.\n+   *     with weights of [0x08 0x4D 0x56 0x4D 0x08] in 1\/256 units.\n@@ -145,1 +144,1 @@\n-   *     weights of [0x00 0x55 0x56 0x55 0x00] in 1\/256th units.\n+   *     weights of [0x00 0x55 0x56 0x55 0x00] in 1\/256 units.\n@@ -230,1 +229,1 @@\n-   *     uses them to specify the filter weights in 1\/256th units.\n+   *     uses them to specify the filter weights in 1\/256 units.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftlcdfil.h","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftlist.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/****************************************************************************\n+ *\n+ * ftlogging.h\n+ *\n+ *   Additional debugging APIs.\n+ *\n+ * Copyright (C) 2020-2024 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef FTLOGGING_H_\n+#define FTLOGGING_H_\n+\n+\n+#include <ft2build.h>\n+#include FT_CONFIG_CONFIG_H\n+\n+\n+FT_BEGIN_HEADER\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   debugging_apis\n+   *\n+   * @title:\n+   *   External Debugging APIs\n+   *\n+   * @abstract:\n+   *   Public APIs to control the `FT_DEBUG_LOGGING` macro.\n+   *\n+   * @description:\n+   *   This section contains the declarations of public functions that\n+   *   enables fine control of what the `FT_DEBUG_LOGGING` macro outputs.\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Trace_Set_Level\n+   *\n+   * @description:\n+   *   Change the levels of tracing components of FreeType at run time.\n+   *\n+   * @input:\n+   *   tracing_level ::\n+   *     New tracing value.\n+   *\n+   * @example:\n+   *   The following call makes FreeType trace everything but the 'memory'\n+   *   component.\n+   *\n+   *   ```\n+   *   FT_Trace_Set_Level( \"any:7 memory:0\" );\n+   *   ```\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Trace_Set_Level( const char*  tracing_level );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Trace_Set_Default_Level\n+   *\n+   * @description:\n+   *   Reset tracing value of FreeType's components to the default value\n+   *   (i.e., to the value of the `FT2_DEBUG` environment value or to NULL\n+   *   if `FT2_DEBUG` is not set).\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Trace_Set_Default_Level( void );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   FT_Custom_Log_Handler\n+   *\n+   * @description:\n+   *   A function typedef that is used to handle the logging of tracing and\n+   *   debug messages on a file system.\n+   *\n+   * @input:\n+   *   ft_component ::\n+   *     The name of `FT_COMPONENT` from which the current debug or error\n+   *     message is produced.\n+   *\n+   *   fmt ::\n+   *     Actual debug or tracing message.\n+   *\n+   *   args::\n+   *     Arguments of debug or tracing messages.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  typedef void\n+  (*FT_Custom_Log_Handler)( const char*  ft_component,\n+                            const char*  fmt,\n+                            va_list      args );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Set_Log_Handler\n+   *\n+   * @description:\n+   *   A function to set a custom log handler.\n+   *\n+   * @input:\n+   *   handler ::\n+   *     New logging function.\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Set_Log_Handler( FT_Custom_Log_Handler  handler );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Set_Default_Log_Handler\n+   *\n+   * @description:\n+   *   A function to undo the effect of @FT_Set_Log_Handler, resetting the\n+   *   log handler to FreeType's built-in version.\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Set_Default_Log_Handler( void );\n+\n+  \/* *\/\n+\n+\n+FT_END_HEADER\n+\n+#endif \/* FTLOGGING_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftlogging.h","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftmac.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -22,0 +22,1 @@\n+#include <freetype\/freetype.h>\n@@ -23,1 +24,5 @@\n-#include <freetype\/t1tables.h>\n+#ifdef FREETYPE_H\n+#error \"freetype.h of FreeType 1 has been loaded!\"\n+#error \"Please fix the directory search order for header files\"\n+#error \"so that freetype.h of FreeType 2 is found first.\"\n+#endif\n@@ -50,0 +55,24 @@\n+   *   For Adobe MM fonts, macro @FT_IS_SFNT returns false.  For GX and\n+   *   OpenType variation fonts, it returns true.\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   T1_MAX_MM_XXX\n+   *\n+   * @description:\n+   *   Multiple Masters limits as defined in their specifications.\n+   *\n+   * @values:\n+   *   T1_MAX_MM_AXIS ::\n+   *     The maximum number of Multiple Masters axes.\n+   *\n+   *   T1_MAX_MM_DESIGNS ::\n+   *     The maximum number of Multiple Masters designs.\n+   *\n+   *   T1_MAX_MM_MAP_POINTS ::\n+   *     The maximum number of elements in a design map.\n+   *\n@@ -51,0 +80,3 @@\n+#define T1_MAX_MM_AXIS         4\n+#define T1_MAX_MM_DESIGNS     16\n+#define T1_MAX_MM_MAP_POINTS  20\n@@ -153,1 +185,1 @@\n-   *   values are integers.\n+   *   values are whole numbers (i.e., the fractional part is zero).\n@@ -398,0 +430,4 @@\n+   *   The design coordinates are 16.16 fractional values for TrueType GX and\n+   *   OpenType variation fonts.  For Adobe MM fonts, the values are supposed\n+   *   to be whole numbers (i.e., the fractional part is zero).\n+   *\n@@ -440,0 +476,5 @@\n+   * @note:\n+   *   The design coordinates are 16.16 fractional values for TrueType GX and\n+   *   OpenType variation fonts.  For Adobe MM fonts, the values are whole\n+   *   numbers (i.e., the fractional part is zero).\n+   *\n@@ -471,3 +512,3 @@\n-   *     The design coordinates array (each element must be between 0 and 1.0\n-   *     for Adobe MM fonts, and between -1.0 and 1.0 for TrueType GX and\n-   *     OpenType variation fonts).\n+   *     The design coordinates array.  Each element is a 16.16 fractional\n+   *     value and must be between 0 and 1.0 for Adobe MM fonts, and between\n+   *     -1.0 and 1.0 for TrueType GX and OpenType variation fonts.\n@@ -518,1 +559,1 @@\n-   *     The normalized blend coordinates array.\n+   *     The normalized blend coordinates array (as 16.16 fractional values).\n@@ -593,1 +634,1 @@\n-   *   length of the weight vector to~16.\n+   *   length of the weight vector to 16~elements.\n@@ -595,2 +636,4 @@\n-   *   If `len` is zero and `weightvector` is `NULL`, the weight vector array\n-   *   is reset to the default values.\n+   *   If `len` is larger than zero, this function sets the\n+   *   @FT_FACE_FLAG_VARIATION bit in @FT_Face's `face_flags` field (i.e.,\n+   *   @FT_IS_VARIATION will return true).  If `len` is zero, this bit flag\n+   *   is unset and the weight vector array is reset to the default values.\n@@ -744,0 +787,39 @@\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Default_Named_Instance\n+   *\n+   * @description:\n+   *   Retrieve the index of the default named instance, to be used with\n+   *   @FT_Set_Named_Instance.\n+   *\n+   *   The default instance of a variation font is that instance for which\n+   *   the nth axis coordinate is equal to `axis[n].def` (as specified in the\n+   *   @FT_MM_Var structure), with~n covering all axes.\n+   *\n+   *   FreeType synthesizes a named instance for the default instance if the\n+   *   font does not contain such an entry.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the source face.\n+   *\n+   * @output:\n+   *   instance_index ::\n+   *     The index of the default named instance.\n+   *\n+   * @return:\n+   *   FreeType error code.  0~means success.\n+   *\n+   * @note:\n+   *   For Adobe MM fonts (which don't have named instances) this function\n+   *   always returns zero for `instance_index`.\n+   *\n+   * @since:\n+   *   2.13.1\n+   *\/\n+  FT_EXPORT( FT_Error )\n+  FT_Get_Default_Named_Instance( FT_Face   face,\n+                                 FT_UInt  *instance_index );\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftmm.h","additions":92,"deletions":10,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -48,2 +48,4 @@\n-   *   Modules can be added, upgraded, and removed at runtime.  Additionally,\n-   *   some module properties can be controlled also.\n+   *   Internal and external modules can be added, upgraded, and removed at\n+   *   runtime.  For example, an alternative renderer or proprietary font\n+   *   driver can be registered and prioritized.  Additionally, some module\n+   *   properties can also be controlled.\n@@ -51,1 +53,1 @@\n-   *   Here is a list of possible values of the `module_name` field in the\n+   *   Here is a list of existing values of the `module_name` field in the\n@@ -89,0 +91,1 @@\n+   *   FT_FACE_DRIVER_NAME\n@@ -331,0 +334,21 @@\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_FACE_DRIVER_NAME\n+   *\n+   * @description:\n+   *   A macro that retrieves the name of a font driver from a face object.\n+   *\n+   * @note:\n+   *   The font driver name is a valid `module_name` for @FT_Property_Set\n+   *   and @FT_Property_Get.  This is not the same as @FT_Get_Font_Format.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+#define FT_FACE_DRIVER_NAME( face )                                     \\\n+          ( ( *FT_REINTERPRET_CAST( FT_Module_Class**,                  \\\n+                                    ( face )->driver ) )->module_name )\n+\n+\n@@ -488,2 +512,1 @@\n-   *                         cff:no-stem-darkening=0 \\\n-   *                         autofitter:warping=1\n+   *                         cff:no-stem-darkening=0\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftmodapi.h","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -174,0 +174,1 @@\n+  FT_MODERRDEF( Sdf,      0x1700, \"Signed distance field raster module\" )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftmoderr.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -112,5 +112,7 @@\n-   *   A contour that contains a single point only is represented by a 'move\n-   *   to' operation followed by 'line to' to the same point.  In most cases,\n-   *   it is best to filter this out before using the outline for stroking\n-   *   purposes (otherwise it would result in a visible dot when round caps\n-   *   are used).\n+   *   Degenerate contours, segments, and Bezier arcs may be reported.  In\n+   *   most cases, it is best to filter these out before using the outline\n+   *   for stroking or other path modification purposes (which may cause\n+   *   degenerate segments to become non-degenerate and visible, like when\n+   *   stroke caps are used or the path is otherwise outset).  Some glyph\n+   *   outlines may contain deliberate degenerate single points for mark\n+   *   attachement.\n@@ -119,1 +121,1 @@\n-   *   (doing nothing, this is, not calling any emitter); if necessary, you\n+   *   (doing nothing, that is, not calling any emitter); if necessary, you\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftoutln.h","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n@@ -115,0 +115,15 @@\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_PARAM_TAG_IGNORE_SBIX\n+   *\n+   * @description:\n+   *   A tag for @FT_Parameter to make @FT_Open_Face ignore an 'sbix' table\n+   *   while loading a font.  Use this if @FT_FACE_FLAG_SBIX is set and you\n+   *   want to access the outline glyphs in the font.\n+   *\n+   *\/\n+#define FT_PARAM_TAG_IGNORE_SBIX \\\n+          FT_MAKE_TAG( 'i', 's', 'b', 'x' )\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftparams.h","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -161,1 +161,1 @@\n-    FT_Raster_Funcs*           raster_class;\n+    const FT_Raster_Funcs*     raster_class;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftrender.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftsizes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftsnames.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -296,1 +296,1 @@\n-   *     expressed as 16.16 fixed point value.\n+   *     expressed as 16.16 fixed-point value.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftstroke.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n@@ -71,1 +71,13 @@\n-  \/* Slant an outline glyph to the right by about 12 degrees. *\/\n+  \/* Precisely adjust the glyph weight either horizontally or vertically.  *\/\n+  \/* The `xdelta` and `ydelta` values are fractions of the face Em size    *\/\n+  \/* (in fixed-point format).  Considering that a regular face would have  *\/\n+  \/* stem widths on the order of 0.1 Em, a delta of 0.05 (0x0CCC) should   *\/\n+  \/* be very noticeable.  To increase or decrease the weight, use positive *\/\n+  \/* or negative values, respectively.                                     *\/\n+  FT_EXPORT( void )\n+  FT_GlyphSlot_AdjustWeight( FT_GlyphSlot  slot,\n+                             FT_Fixed      xdelta,\n+                             FT_Fixed      ydelta );\n+\n+\n+  \/* Slant an outline glyph to the right by about 12 degrees.              *\/\n@@ -75,0 +87,9 @@\n+  \/* Slant an outline glyph by a given sine of an angle.  You can apply    *\/\n+  \/* slant along either x- or y-axis by choosing a corresponding non-zero  *\/\n+  \/* argument.  If both slants are non-zero, some affine transformation    *\/\n+  \/* will result.                                                          *\/\n+  FT_EXPORT( void )\n+  FT_GlyphSlot_Slant( FT_GlyphSlot  slot,\n+                      FT_Fixed      xslant,\n+                      FT_Fixed      yslant );\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftsynth.h","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -232,1 +232,1 @@\n-   *     The offset of read in stream (always from start).\n+   *     The offset from the start of the stream to seek to.\n@@ -241,5 +241,3 @@\n-   *   The number of bytes effectively read by the stream.\n-   *\n-   * @note:\n-   *   This function might be called to perform a seek or skip operation with\n-   *   a `count` of~0.  A non-zero return value then indicates an error.\n+   *   If count >~0, return the number of bytes effectively read by the\n+   *   stream (after seeking to `offset`).  If count ==~0, return the status\n+   *   of the seek operation (non-zero indicates an error).\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ftsystem.h","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/fttrigon.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -48,1 +48,4 @@\n-   *   font-specific structures are defined in a different section.\n+   *   font-specific structures are defined in a different section.  Note\n+   *   that FreeType does not use floating-point data types.  Fractional\n+   *   values are represented by fixed-point integers, with lower bits\n+   *   storing the fractional part.\n@@ -416,1 +419,1 @@\n-    FT_Int          length;\n+    FT_UInt         length;\n@@ -482,1 +485,1 @@\n-   *   tables into an unsigned long, to be used within FreeType.\n+   *   tables into an `FT_Tag` type, to be used within FreeType.\n@@ -488,6 +491,5 @@\n-#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 ) \\\n-          (FT_Tag)                        \\\n-          ( ( (FT_ULong)_x1 << 24 ) |     \\\n-            ( (FT_ULong)_x2 << 16 ) |     \\\n-            ( (FT_ULong)_x3 <<  8 ) |     \\\n-              (FT_ULong)_x4         )\n+#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 )                  \\\n+          ( ( FT_STATIC_BYTE_CAST( FT_Tag, _x1 ) << 24 ) | \\\n+            ( FT_STATIC_BYTE_CAST( FT_Tag, _x2 ) << 16 ) | \\\n+            ( FT_STATIC_BYTE_CAST( FT_Tag, _x3 ) <<  8 ) | \\\n+              FT_STATIC_BYTE_CAST( FT_Tag, _x4 )         )\n@@ -591,1 +593,1 @@\n-#define FT_BOOL( x )  ( (FT_Bool)( (x) != 0 ) )\n+#define FT_BOOL( x )         FT_STATIC_CAST( FT_Bool, (x) != 0 )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/fttypes.h","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/autohint.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/cffotypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -251,4 +251,4 @@\n-    FT_Pos    blue_values[14];\n-    FT_Pos    other_blues[10];\n-    FT_Pos    family_blues[14];\n-    FT_Pos    family_other_blues[10];\n+    FT_Fixed  blue_values[14];\n+    FT_Fixed  other_blues[10];\n+    FT_Fixed  family_blues[14];\n+    FT_Fixed  family_other_blues[10];\n@@ -318,1 +318,1 @@\n-    \/* Blended values are stored as 5-byte fixed point values.            *\/\n+    \/* Blended values are stored as 5-byte fixed-point values.            *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/cfftypes.h","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020 by\n+ * Copyright (C) 2020-2024 by\n@@ -37,0 +37,16 @@\n+#endif\n+\n+  \/* Newer compilers warn for fall-through case statements. *\/\n+#ifndef FALL_THROUGH\n+#  if ( defined( __STDC_VERSION__ ) && __STDC_VERSION__ > 201710L ) || \\\n+      ( defined( __cplusplus ) && __cplusplus > 201402L )\n+#    define FALL_THROUGH  [[__fallthrough__]]\n+#  elif ( defined( __GNUC__ ) && __GNUC__ >= 7 )       || \\\n+        ( defined( __clang__ )                      &&    \\\n+          ( defined( __apple_build_version__ )            \\\n+              ? __apple_build_version__ >= 12000000       \\\n+              : __clang_major__ >= 10 ) )\n+#    define FALL_THROUGH  __attribute__(( __fallthrough__ ))\n+#  else\n+#    define FALL_THROUGH  ( (void)0 )\n+#  endif\n@@ -74,1 +90,7 @@\n-#ifdef _WIN64\n+#ifdef __UINTPTR_TYPE__\n+  \/*\n+   * GCC and Clang both provide a `__UINTPTR_TYPE__` that can be used to\n+   * avoid a dependency on `stdint.h`.\n+   *\/\n+#  define FT_UINT_TO_POINTER( x )  (void *)(__UINTPTR_TYPE__)(x)\n+#elif defined( _WIN64 )\n@@ -77,1 +99,1 @@\n-#define FT_UINT_TO_POINTER( x )  (void *)(unsigned __int64)(x)\n+#  define FT_UINT_TO_POINTER( x )  (void *)(unsigned __int64)(x)\n@@ -79,1 +101,1 @@\n-#define FT_UINT_TO_POINTER( x )  (void *)(unsigned long)(x)\n+#  define FT_UINT_TO_POINTER( x )  (void *)(unsigned long)(x)\n@@ -219,36 +241,37 @@\n-  \/* When compiling FreeType as a DLL or DSO with hidden visibility,   *\/\n-  \/* some systems\/compilers need a special attribute in front OR after *\/\n-  \/* the return type of function declarations.                         *\/\n-  \/*                                                                   *\/\n-  \/* Two macros are used within the FreeType source code to define     *\/\n-  \/* exported library functions: `FT_EXPORT` and `FT_EXPORT_DEF`.      *\/\n-  \/*                                                                   *\/\n-  \/* - `FT_EXPORT( return_type )`                                      *\/\n-  \/*                                                                   *\/\n-  \/*   is used in a function declaration, as in                        *\/\n-  \/*                                                                   *\/\n-  \/*   ```                                                             *\/\n-  \/*     FT_EXPORT( FT_Error )                                         *\/\n-  \/*     FT_Init_FreeType( FT_Library*  alibrary );                    *\/\n-  \/*   ```                                                             *\/\n-  \/*                                                                   *\/\n-  \/* - `FT_EXPORT_DEF( return_type )`                                  *\/\n-  \/*                                                                   *\/\n-  \/*   is used in a function definition, as in                         *\/\n-  \/*                                                                   *\/\n-  \/*   ```                                                             *\/\n-  \/*     FT_EXPORT_DEF( FT_Error )                                     *\/\n-  \/*     FT_Init_FreeType( FT_Library*  alibrary )                     *\/\n-  \/*     {                                                             *\/\n-  \/*       ... some code ...                                           *\/\n-  \/*       return FT_Err_Ok;                                           *\/\n-  \/*     }                                                             *\/\n-  \/*   ```                                                             *\/\n-  \/*                                                                   *\/\n-  \/* You can provide your own implementation of `FT_EXPORT` and        *\/\n-  \/* `FT_EXPORT_DEF` here if you want.                                 *\/\n-  \/*                                                                   *\/\n-  \/* To export a variable, use `FT_EXPORT_VAR`.                        *\/\n-  \/*                                                                   *\/\n-\n-  \/* See `freetype\/config\/compiler_macros.h` for the `FT_EXPORT` definition *\/\n+  \/*\n+   * When compiling FreeType as a DLL or DSO with hidden visibility,\n+   * some systems\/compilers need a special attribute in front OR after\n+   * the return type of function declarations.\n+   *\n+   * Two macros are used within the FreeType source code to define\n+   * exported library functions: `FT_EXPORT` and `FT_EXPORT_DEF`.\n+   *\n+   * - `FT_EXPORT( return_type )`\n+   *\n+   *   is used in a function declaration, as in\n+   *\n+   *   ```\n+   *     FT_EXPORT( FT_Error )\n+   *     FT_Init_FreeType( FT_Library*  alibrary );\n+   *   ```\n+   *\n+   * - `FT_EXPORT_DEF( return_type )`\n+   *\n+   *   is used in a function definition, as in\n+   *\n+   *   ```\n+   *     FT_EXPORT_DEF( FT_Error )\n+   *     FT_Init_FreeType( FT_Library*  alibrary )\n+   *     {\n+   *       ... some code ...\n+   *       return FT_Err_Ok;\n+   *     }\n+   *   ```\n+   *\n+   * You can provide your own implementation of `FT_EXPORT` and\n+   * `FT_EXPORT_DEF` here if you want.\n+   *\n+   * To export a variable, use `FT_EXPORT_VAR`.\n+   *\/\n+\n+  \/* See `freetype\/config\/public-macros.h` for the `FT_EXPORT` definition *\/\n@@ -257,29 +280,32 @@\n-  \/* The following macros are needed to compile the library with a   *\/\n-  \/* C++ compiler and with 16bit compilers.                          *\/\n-  \/*                                                                 *\/\n-\n-  \/* This is special.  Within C++, you must specify `extern \"C\"` for *\/\n-  \/* functions which are used via function pointers, and you also    *\/\n-  \/* must do that for structures which contain function pointers to  *\/\n-  \/* assure C linkage -- it's not possible to have (local) anonymous *\/\n-  \/* functions which are accessed by (global) function pointers.     *\/\n-  \/*                                                                 *\/\n-  \/*                                                                 *\/\n-  \/* FT_CALLBACK_DEF is used to _define_ a callback function,        *\/\n-  \/* located in the same source code file as the structure that uses *\/\n-  \/* it.                                                             *\/\n-  \/*                                                                 *\/\n-  \/* FT_BASE_CALLBACK and FT_BASE_CALLBACK_DEF are used to declare   *\/\n-  \/* and define a callback function, respectively, in a similar way  *\/\n-  \/* as FT_BASE and FT_BASE_DEF work.                                *\/\n-  \/*                                                                 *\/\n-  \/* FT_CALLBACK_TABLE is used to _declare_ a constant variable that *\/\n-  \/* contains pointers to callback functions.                        *\/\n-  \/*                                                                 *\/\n-  \/* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   *\/\n-  \/* that contains pointers to callback functions.                   *\/\n-  \/*                                                                 *\/\n-  \/*                                                                 *\/\n-  \/* Some 16bit compilers have to redefine these macros to insert    *\/\n-  \/* the infamous `_cdecl` or `__fastcall` declarations.             *\/\n-  \/*                                                                 *\/\n+  \/*\n+   * The following macros are needed to compile the library with a\n+   * C++ compiler and with 16bit compilers.\n+   *\/\n+\n+  \/*\n+   * This is special.  Within C++, you must specify `extern \"C\"` for\n+   * functions which are used via function pointers, and you also\n+   * must do that for structures which contain function pointers to\n+   * assure C linkage -- it's not possible to have (local) anonymous\n+   * functions which are accessed by (global) function pointers.\n+   *\n+   *\n+   * FT_CALLBACK_DEF is used to _define_ a callback function,\n+   * located in the same source code file as the structure that uses\n+   * it.  FT_COMPARE_DEF, in addition, ensures the `cdecl` calling\n+   * convention on x86, required by the C library function `qsort`.\n+   *\n+   * FT_BASE_CALLBACK and FT_BASE_CALLBACK_DEF are used to declare\n+   * and define a callback function, respectively, in a similar way\n+   * as FT_BASE and FT_BASE_DEF work.\n+   *\n+   * FT_CALLBACK_TABLE is used to _declare_ a constant variable that\n+   * contains pointers to callback functions.\n+   *\n+   * FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable\n+   * that contains pointers to callback functions.\n+   *\n+   *\n+   * Some 16bit compilers have to redefine these macros to insert\n+   * the infamous `_cdecl` or `__fastcall` declarations.\n+   *\/\n@@ -292,0 +318,10 @@\n+#if defined( __GNUC__ ) && defined( __i386__ )\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x ) __attribute__(( cdecl ))\n+#elif defined( _MSC_VER ) && defined( _M_IX86 )\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x ) __cdecl\n+#elif defined( __WATCOMC__ ) && __WATCOMC__ >= 1240\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x ) __watcall\n+#else\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x )\n+#endif\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/compiler-macros.h","additions":105,"deletions":69,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -281,0 +281,34 @@\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_MulAddFix\n+   *\n+   * @description:\n+   *   Compute `(s[0] * f[0] + s[1] * f[1] + ...) \/ 0x10000`, where `s[n]` is\n+   *   usually a 16.16 scalar.\n+   *\n+   * @input:\n+   *   s ::\n+   *     The array of scalars.\n+   *   f ::\n+   *     The array of factors.\n+   *   count ::\n+   *     The number of entries in the array.\n+   *\n+   * @return:\n+   *   The result of `(s[0] * f[0] + s[1] * f[1] + ...) \/ 0x10000`.\n+   *\n+   * @note:\n+   *   This function is currently used for the scaled delta computation of\n+   *   variation stores.  It internally uses 64-bit data types when\n+   *   available, otherwise it emulates 64-bit math by using 32-bit\n+   *   operations, which produce a correct result but most likely at a slower\n+   *   performance in comparison to the implementation base on `int64_t`.\n+   *\n+   *\/\n+  FT_BASE( FT_Int32 )\n+  FT_MulAddFix( FT_Fixed*  s,\n+                FT_Int32*  f,\n+                FT_UInt    count );\n+\n+\n@@ -301,1 +335,1 @@\n-   *   50 * abs(xx*yy - xy*yx) < xx^2 + xy^2 + yx^2 + yy^2\n+   *   32 * abs(xx*yy - xy*yx) < xx^2 + xy^2 + yx^2 + yy^2\n@@ -303,1 +337,1 @@\n-   * Value 50 is heuristic.\n+   * Value 32 is heuristic.\n@@ -362,2 +396,2 @@\n-#if defined( __GNUC__ )                                          && \\\n-    ( __GNUC__ > 3 || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 4 ) )\n+#if defined( __clang__ ) || ( defined( __GNUC__ )                &&  \\\n+    ( __GNUC__ > 3 || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 4 ) ) )\n@@ -373,1 +407,1 @@\n-#endif \/* __GNUC__ *\/\n+#endif\n@@ -375,0 +409,1 @@\n+#elif defined( _MSC_VER ) && _MSC_VER >= 1400\n@@ -376,1 +411,1 @@\n-#elif defined( _MSC_VER ) && ( _MSC_VER >= 1400 )\n+#if defined( _WIN32_WCE )\n@@ -378,1 +413,13 @@\n-#if FT_SIZEOF_INT == 4\n+#include <cmnintrin.h>\n+#pragma intrinsic( _CountLeadingZeros )\n+\n+#define FT_MSB( x )  ( 31 - _CountLeadingZeros( x ) )\n+\n+#elif defined( _M_ARM64 ) || defined( _M_ARM ) || defined( _M_ARM64EC )\n+\n+#include <intrin.h>\n+#pragma intrinsic( _CountLeadingZeros )\n+\n+#define FT_MSB( x )  ( 31 - _CountLeadingZeros( x ) )\n+\n+#elif defined( _M_IX86 ) || defined( _M_AMD64 ) || defined( _M_IA64 )\n@@ -394,1 +441,1 @@\n-#define FT_MSB( x )  ( FT_MSB_i386( x ) )\n+#define FT_MSB( x )  FT_MSB_i386( x )\n@@ -398,1 +445,20 @@\n-#endif \/* _MSC_VER *\/\n+#elif defined( __WATCOMC__ ) && defined( __386__ )\n+\n+  extern __inline FT_Int32\n+  FT_MSB_i386( FT_UInt32  x );\n+\n+#pragma aux FT_MSB_i386 =             \\\n+  \"bsr eax, eax\"                      \\\n+  __parm [__eax] __nomemory           \\\n+  __value [__eax]                     \\\n+  __modify __exact [__eax] __nomemory;\n+\n+#define FT_MSB( x )  FT_MSB_i386( x )\n+\n+#elif defined( __SunOS_5_11 )\n+\n+#include <string.h>\n+\n+#define FT_MSB( x )  ( fls( x ) - 1 )\n+\n+#elif defined( __DECC ) || defined( __DECCXX )\n@@ -400,0 +466,11 @@\n+#include <builtins.h>\n+\n+#define FT_MSB( x )  (FT_Int)( 63 - _leadz( x ) )\n+\n+#elif defined( _CRAYC )\n+\n+#include <intrinsics.h>\n+\n+#define FT_MSB( x )  (FT_Int)( 31 - _leadz32( x ) )\n+\n+#endif \/* FT_MSB macro definitions *\/\n@@ -403,0 +480,1 @@\n+\n@@ -420,2 +498,0 @@\n-#if 0\n-\n@@ -438,1 +514,2 @@\n-   *   This function is not very fast.\n+   *   This function is slow and should be avoided.  Consider @FT_Hypot or\n+   *   @FT_Vector_NormLen instead.\n@@ -440,4 +517,2 @@\n-  FT_BASE( FT_Int32 )\n-  FT_SqrtFixed( FT_Int32  x );\n-\n-#endif \/* 0 *\/\n+  FT_BASE( FT_UInt32 )\n+  FT_SqrtFixed( FT_UInt32  x );\n@@ -490,1 +565,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n@@ -501,1 +576,1 @@\n-#endif \/* FT_LONG64 *\/\n+#endif \/* FT_INT64 *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftcalc.h","additions":94,"deletions":19,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -34,0 +34,8 @@\n+#ifdef FT_DEBUG_LOGGING\n+#define DLG_STATIC\n+#include <dlg\/output.h>\n+#include <dlg\/dlg.h>\n+\n+#include <freetype\/ftlogging.h>\n+#endif \/* FT_DEBUG_LOGGING *\/\n+\n@@ -37,0 +45,7 @@\n+  \/* force the definition of FT_DEBUG_LEVEL_TRACE if FT_DEBUG_LOGGING is *\/\n+  \/* already defined.                                                    *\/\n+  \/*                                                                     *\/\n+#ifdef FT_DEBUG_LOGGING\n+#undef  FT_DEBUG_LEVEL_TRACE\n+#define FT_DEBUG_LEVEL_TRACE\n+#endif\n@@ -85,0 +100,3 @@\n+   * To get consistent logging output, there should be no newline character\n+   * (i.e., '\\n') or a single trailing one in the message string of\n+   * `FT_TRACEx` and `FT_ERROR`.\n@@ -87,1 +105,0 @@\n-#ifdef FT_DEBUG_LEVEL_TRACE\n@@ -89,3 +106,11 @@\n-  \/* we need two macros here to make cpp expand `FT_COMPONENT' *\/\n-#define FT_TRACE_COMP( x )   FT_TRACE_COMP_( x )\n-#define FT_TRACE_COMP_( x )  trace_ ## x\n+  \/*************************************************************************\n+   *\n+   * If FT_DEBUG_LOGGING is enabled, tracing messages are sent to dlg's API.\n+   * If FT_DEBUG_LOGGING is disabled, tracing messages are sent to\n+   * `FT_Message` (defined in ftdebug.c).\n+   *\/\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/* we need two macros to convert the names of `FT_COMPONENT` to a string *\/\n+#define FT_LOGGING_TAG( x )   FT_LOGGING_TAG_( x )\n+#define FT_LOGGING_TAG_( x )  #x\n@@ -93,1 +118,26 @@\n-#define FT_TRACE( level, varformat )                                       \\\n+  \/* we need two macros to convert the component and the trace level *\/\n+  \/* to a string that combines them                                  *\/\n+#define FT_LOGGING_TAGX( x, y )   FT_LOGGING_TAGX_( x, y )\n+#define FT_LOGGING_TAGX_( x, y )  #x \":\" #y\n+\n+\n+#define FT_LOG( level, varformat )                                         \\\n+          do                                                               \\\n+          {                                                                \\\n+            const char*  dlg_tag = FT_LOGGING_TAGX( FT_COMPONENT, level ); \\\n+                                                                           \\\n+                                                                           \\\n+            ft_add_tag( dlg_tag );                                         \\\n+            if ( ft_trace_levels[FT_TRACE_COMP( FT_COMPONENT )] >= level ) \\\n+            {                                                              \\\n+              if ( custom_output_handler != NULL )                         \\\n+                FT_Logging_Callback varformat;                             \\\n+              else                                                         \\\n+                dlg_trace varformat;                                       \\\n+            }                                                              \\\n+            ft_remove_tag( dlg_tag );                                      \\\n+          } while( 0 )\n+\n+#else \/* !FT_DEBUG_LOGGING *\/\n+\n+#define FT_LOG( level, varformat )                                         \\\n@@ -100,0 +150,11 @@\n+#endif \/* !FT_DEBUG_LOGGING *\/\n+\n+\n+#ifdef FT_DEBUG_LEVEL_TRACE\n+\n+  \/* we need two macros here to make cpp expand `FT_COMPONENT' *\/\n+#define FT_TRACE_COMP( x )   FT_TRACE_COMP_( x )\n+#define FT_TRACE_COMP_( x )  trace_ ## x\n+\n+#define FT_TRACE( level, varformat )  FT_LOG( level, varformat )\n+\n@@ -207,1 +268,26 @@\n-#define FT_ERROR( varformat )  FT_Message  varformat\n+  \/**************************************************************************\n+   *\n+   * If FT_DEBUG_LOGGING is enabled, error messages are sent to dlg's API.\n+   * If FT_DEBUG_LOGGING is disabled, error messages are sent to `FT_Message`\n+   * (defined in ftdebug.c).\n+   *\n+   *\/\n+#ifdef FT_DEBUG_LOGGING\n+\n+#define FT_ERROR( varformat )                                      \\\n+          do                                                       \\\n+          {                                                        \\\n+            const char*  dlg_tag = FT_LOGGING_TAG( FT_COMPONENT ); \\\n+                                                                   \\\n+                                                                   \\\n+            ft_add_tag( dlg_tag );                                 \\\n+            dlg_trace varformat;                                   \\\n+            ft_remove_tag( dlg_tag );                              \\\n+          } while ( 0 )\n+\n+#else \/* !FT_DEBUG_LOGGING *\/\n+\n+#define FT_ERROR( varformat )  FT_Message varformat\n+\n+#endif \/* !FT_DEBUG_LOGGING *\/\n+\n@@ -280,0 +366,71 @@\n+\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/**************************************************************************\n+   *\n+   * 'dlg' uses output handlers to control how and where log messages are\n+   * printed.  Therefore we need to define a default output handler for\n+   * FreeType.\n+   *\/\n+  FT_BASE( void )\n+  ft_log_handler( const struct dlg_origin*  origin,\n+                  const char*               string,\n+                  void*                     data );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * 1. `ft_default_log_handler` stores the function pointer that is used\n+   *    internally by FreeType to print logs to a file.\n+   *\n+   * 2. `custom_output_handler` stores the function pointer to the callback\n+   *    function provided by the user.\n+   *\n+   * It is defined in `ftdebug.c`.\n+   *\/\n+  extern dlg_handler            ft_default_log_handler;\n+  extern FT_Custom_Log_Handler  custom_output_handler;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * If FT_DEBUG_LOGGING macro is enabled, FreeType needs to initialize and\n+   * un-initialize `FILE*`.\n+   *\n+   * These functions are defined in `ftdebug.c`.\n+   *\/\n+  FT_BASE( void )\n+  ft_logging_init( void );\n+\n+  FT_BASE( void )\n+  ft_logging_deinit( void );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * For printing the name of `FT_COMPONENT` along with the actual log we\n+   * need to add a tag with the name of `FT_COMPONENT`.\n+   *\n+   * These functions are defined in `ftdebug.c`.\n+   *\/\n+  FT_BASE( void )\n+  ft_add_tag( const char*  tag );\n+\n+  FT_BASE( void )\n+  ft_remove_tag( const char*  tag );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * A function to print log data using a custom callback logging function\n+   * (which is set using `FT_Set_Log_Handler`).\n+   *\n+   * This function is defined in `ftdebug.c`.\n+   *\/\n+  FT_BASE( void )\n+  FT_Logging_Callback( const char*  fmt,\n+                       ... );\n+\n+#endif \/* FT_DEBUG_LOGGING *\/\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftdebug.h","additions":164,"deletions":7,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -160,0 +160,1 @@\n+   *\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftdrv.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -25,0 +25,1 @@\n+#include \"compiler-macros.h\"\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftgloadr.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -99,2 +99,2 @@\n-  FT_BASE( const char* )  _ft_debug_file;\n-  FT_BASE( long )         _ft_debug_lineno;\n+  FT_BASE( const char* )  ft_debug_file_;\n+  FT_BASE( long )         ft_debug_lineno_;\n@@ -102,2 +102,2 @@\n-#define FT_DEBUG_INNER( exp )  ( _ft_debug_file   = __FILE__, \\\n-                                 _ft_debug_lineno = __LINE__, \\\n+#define FT_DEBUG_INNER( exp )  ( ft_debug_file_   = __FILE__, \\\n+                                 ft_debug_lineno_ = __LINE__, \\\n@@ -106,2 +106,2 @@\n-#define FT_ASSIGNP_INNER( p, exp )  ( _ft_debug_file   = __FILE__, \\\n-                                      _ft_debug_lineno = __LINE__, \\\n+#define FT_ASSIGNP_INNER( p, exp )  ( ft_debug_file_   = __FILE__, \\\n+                                      ft_debug_lineno_ = __LINE__, \\\n@@ -347,2 +347,1 @@\n-#define FT_QNEW( ptr )                           \\\n-          FT_MEM_SET_ERROR( FT_MEM_QNEW( ptr ) )\n+#define FT_QNEW( ptr )  FT_MEM_SET_ERROR( FT_MEM_QNEW( ptr ) )\n@@ -350,2 +349,2 @@\n-#define FT_QNEW_ARRAY( ptr, count )                          \\\n-          FT_MEM_SET_ERROR( FT_MEM_NEW_ARRAY( ptr, count ) )\n+#define FT_QNEW_ARRAY( ptr, count )                           \\\n+          FT_MEM_SET_ERROR( FT_MEM_QNEW_ARRAY( ptr, count ) )\n@@ -353,2 +352,2 @@\n-#define FT_QRENEW_ARRAY( ptr, curcnt, newcnt )                          \\\n-          FT_MEM_SET_ERROR( FT_MEM_RENEW_ARRAY( ptr, curcnt, newcnt ) )\n+#define FT_QRENEW_ARRAY( ptr, curcnt, newcnt )                           \\\n+          FT_MEM_SET_ERROR( FT_MEM_QRENEW_ARRAY( ptr, curcnt, newcnt ) )\n@@ -375,2 +374,5 @@\n-#define FT_MEM_DUP( dst, address, size )                                    \\\n-          (dst) = ft_mem_dup( memory, (address), (FT_ULong)(size), &error )\n+#define FT_MEM_DUP( dst, address, size )                       \\\n+          FT_ASSIGNP_INNER( dst, ft_mem_dup( memory,           \\\n+                                             (address),        \\\n+                                             (FT_ULong)(size), \\\n+                                             &error ) )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftmemory.h","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/****************************************************************************\n+ *\n+ * ftmmtypes.h\n+ *\n+ *   OpenType Variations type definitions for internal use\n+ *   with the multi-masters service (specification).\n+ *\n+ * Copyright (C) 2022-2024 by\n+ * David Turner, Robert Wilhelm, Werner Lemberg, George Williams, and\n+ * Dominik Röttsches.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef FTMMTYPES_H_\n+#define FTMMTYPES_H_\n+\n+FT_BEGIN_HEADER\n+\n+\n+  typedef FT_Int32  FT_ItemVarDelta;\n+\n+  typedef struct  GX_ItemVarDataRec_\n+  {\n+    FT_UInt            itemCount;      \/* Number of delta sets per item.   *\/\n+    FT_UInt            regionIdxCount; \/* Number of region indices.        *\/\n+    FT_UInt*           regionIndices;  \/* Array of `regionCount` indices;  *\/\n+                                       \/* these index `varRegionList`.     *\/\n+    FT_Byte*           deltaSet;       \/* Array of `itemCount` deltas;     *\/\n+                                       \/* use `innerIndex` for this array. *\/\n+    FT_UShort          wordDeltaCount; \/* Number of the first 32-bit ints  *\/\n+                                       \/* or 16-bit ints of `deltaSet`     *\/\n+                                       \/* depending on `longWords`.        *\/\n+    FT_Bool            longWords;      \/* If true, `deltaSet` is a 32-bit  *\/\n+                                       \/* array followed by a 16-bit       *\/\n+                                       \/* array, otherwise a 16-bit array  *\/\n+                                       \/* followed by an 8-bit array.      *\/\n+  } GX_ItemVarDataRec, *GX_ItemVarData;\n+\n+\n+  \/* contribution of one axis to a region *\/\n+  typedef struct  GX_AxisCoordsRec_\n+  {\n+    FT_Fixed  startCoord;\n+    FT_Fixed  peakCoord;      \/* zero means no effect (factor = 1) *\/\n+    FT_Fixed  endCoord;\n+\n+  } GX_AxisCoordsRec, *GX_AxisCoords;\n+\n+\n+  typedef struct  GX_VarRegionRec_\n+  {\n+    GX_AxisCoords  axisList;               \/* array of axisCount records *\/\n+\n+  } GX_VarRegionRec, *GX_VarRegion;\n+\n+\n+  \/* item variation store *\/\n+  typedef struct  GX_ItemVarStoreRec_\n+  {\n+    FT_UInt         dataCount;\n+    GX_ItemVarData  varData;            \/* array of dataCount records;     *\/\n+                                        \/* use `outerIndex' for this array *\/\n+    FT_UShort     axisCount;\n+    FT_UInt       regionCount;          \/* total number of regions defined *\/\n+    GX_VarRegion  varRegionList;\n+\n+  } GX_ItemVarStoreRec, *GX_ItemVarStore;\n+\n+\n+  typedef struct  GX_DeltaSetIdxMapRec_\n+  {\n+    FT_ULong  mapCount;\n+    FT_UInt*  outerIndex;               \/* indices to item var data *\/\n+    FT_UInt*  innerIndex;               \/* indices to delta set     *\/\n+\n+  } GX_DeltaSetIdxMapRec, *GX_DeltaSetIdxMap;\n+\n+\n+FT_END_HEADER\n+\n+#endif \/* FTMMTYPES_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftmmtypes.h","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -421,1 +421,2 @@\n-#define FT_GLYPH_OWN_BITMAP  0x1U\n+#define FT_GLYPH_OWN_BITMAP    0x1U\n+#define FT_GLYPH_OWN_GZIP_SVG  0x2U\n@@ -606,6 +607,0 @@\n-#define FT_SIZE_FACE( x )     FT_SIZE( x )->face\n-#define FT_SLOT_FACE( x )     FT_SLOT( x )->face\n-\n-#define FT_FACE_SLOT( x )     FT_FACE( x )->glyph\n-#define FT_FACE_SIZE( x )     FT_FACE( x )->size\n-\n@@ -676,1 +671,1 @@\n-  FT_BASE( void )\n+  FT_BASE( FT_Error )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftobjs.h","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftpsprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftrfork.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftserv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -199,3 +199,3 @@\n-#define FT_PEEK_OFF3( p )  FT_INT32( FT_BYTE_U32( p, 0, 16 ) | \\\n-                                     FT_BYTE_U32( p, 1,  8 ) | \\\n-                                     FT_BYTE_U32( p, 2,  0 ) )\n+#define FT_PEEK_OFF3( p )  ( FT_INT32( FT_BYTE_U32( p, 0, 24 ) | \\\n+                                       FT_BYTE_U32( p, 1, 16 ) | \\\n+                                       FT_BYTE_U32( p, 2,  8 ) ) >> 8 )\n@@ -223,3 +223,3 @@\n-#define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_BYTE_U32( p, 2, 16 ) | \\\n-                                        FT_BYTE_U32( p, 1,  8 ) | \\\n-                                        FT_BYTE_U32( p, 0,  0 ) )\n+#define FT_PEEK_OFF3_LE( p )  ( FT_INT32( FT_BYTE_U32( p, 2, 24 ) | \\\n+                                          FT_BYTE_U32( p, 1, 16 ) | \\\n+                                          FT_BYTE_U32( p, 0,  8 ) ) >> 8 )\n@@ -241,2 +241,2 @@\n-#define FT_NEXT_SHORT( buffer )                                   \\\n-          ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )\n+#define FT_NEXT_SHORT( buffer )                        \\\n+          ( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) )\n@@ -244,2 +244,2 @@\n-#define FT_NEXT_USHORT( buffer )                                            \\\n-          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )\n+#define FT_NEXT_USHORT( buffer )                        \\\n+          ( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) )\n@@ -247,2 +247,2 @@\n-#define FT_NEXT_OFF3( buffer )                                  \\\n-          ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )\n+#define FT_NEXT_OFF3( buffer )                        \\\n+          ( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) )\n@@ -250,2 +250,2 @@\n-#define FT_NEXT_UOFF3( buffer )                                           \\\n-          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )\n+#define FT_NEXT_UOFF3( buffer )                        \\\n+          ( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) )\n@@ -253,2 +253,2 @@\n-#define FT_NEXT_LONG( buffer )                                  \\\n-          ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )\n+#define FT_NEXT_LONG( buffer )                        \\\n+          ( buffer += 4, FT_PEEK_LONG( buffer - 4 ) )\n@@ -256,2 +256,2 @@\n-#define FT_NEXT_ULONG( buffer )                                           \\\n-          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) ) )\n+#define FT_NEXT_ULONG( buffer )                        \\\n+          ( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) )\n@@ -260,2 +260,2 @@\n-#define FT_NEXT_SHORT_LE( buffer )                                   \\\n-          ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )\n+#define FT_NEXT_SHORT_LE( buffer )                        \\\n+          ( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) )\n@@ -263,2 +263,2 @@\n-#define FT_NEXT_USHORT_LE( buffer )                                            \\\n-          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )\n+#define FT_NEXT_USHORT_LE( buffer )                        \\\n+          ( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) )\n@@ -266,2 +266,2 @@\n-#define FT_NEXT_OFF3_LE( buffer )                                  \\\n-          ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )\n+#define FT_NEXT_OFF3_LE( buffer )                        \\\n+          ( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) )\n@@ -269,2 +269,2 @@\n-#define FT_NEXT_UOFF3_LE( buffer )                                           \\\n-          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )\n+#define FT_NEXT_UOFF3_LE( buffer )                        \\\n+          ( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) )\n@@ -272,2 +272,2 @@\n-#define FT_NEXT_LONG_LE( buffer )                                  \\\n-          ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )\n+#define FT_NEXT_LONG_LE( buffer )                        \\\n+          ( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) )\n@@ -275,2 +275,2 @@\n-#define FT_NEXT_ULONG_LE( buffer )                                           \\\n-          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )\n+#define FT_NEXT_ULONG_LE( buffer )                        \\\n+          ( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) )\n@@ -308,14 +308,13 @@\n-#define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )\n-#define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )\n-#define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Short )\n-#define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UShort )\n-#define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetUOffset, FT_Long )\n-#define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_ULong )\n-#define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Long )\n-#define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )\n-#define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )\n-\n-#define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Short )\n-#define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UShort )\n-#define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Long )\n-#define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_ULong )\n+#define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetByte, FT_Char )\n+#define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetByte, FT_Byte )\n+#define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Int16 )\n+#define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UInt16 )\n+#define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_UInt32 )\n+#define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Int32 )\n+#define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_UInt32 )\n+#define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_UInt32 )\n+\n+#define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Int16 )\n+#define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UInt16 )\n+#define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Int32 )\n+#define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_UInt32 )\n@@ -336,8 +335,7 @@\n-#define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )\n-#define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )\n-#define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Short, var )\n-#define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UShort, var )\n-#define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadUOffset, FT_Long, var )\n-#define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_ULong, var )\n-#define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Long, var )\n-#define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_ULong, var )\n+#define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadByte, FT_Byte, var )\n+#define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadByte, FT_Char, var )\n+#define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Int16, var )\n+#define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UInt16, var )\n+#define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_UInt32, var )\n+#define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Int32, var )\n+#define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_UInt32, var )\n@@ -345,4 +343,4 @@\n-#define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Short, var )\n-#define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UShort, var )\n-#define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Long, var )\n-#define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_ULong, var )\n+#define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Int16, var )\n+#define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UInt16, var )\n+#define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Int32, var )\n+#define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_UInt32, var )\n@@ -460,2 +458,2 @@\n-  FT_BASE( FT_Char )\n-  FT_Stream_GetChar( FT_Stream  stream );\n+  FT_BASE( FT_Byte )\n+  FT_Stream_GetByte( FT_Stream  stream );\n@@ -464,1 +462,1 @@\n-  FT_BASE( FT_UShort )\n+  FT_BASE( FT_UInt16 )\n@@ -468,1 +466,1 @@\n-  FT_BASE( FT_ULong )\n+  FT_BASE( FT_UInt32 )\n@@ -472,1 +470,1 @@\n-  FT_BASE( FT_ULong )\n+  FT_BASE( FT_UInt32 )\n@@ -476,1 +474,1 @@\n-  FT_BASE( FT_UShort )\n+  FT_BASE( FT_UInt16 )\n@@ -480,1 +478,1 @@\n-  FT_BASE( FT_ULong )\n+  FT_BASE( FT_UInt32 )\n@@ -485,2 +483,2 @@\n-  FT_BASE( FT_Char )\n-  FT_Stream_ReadChar( FT_Stream  stream,\n+  FT_BASE( FT_Byte )\n+  FT_Stream_ReadByte( FT_Stream  stream,\n@@ -490,1 +488,1 @@\n-  FT_BASE( FT_UShort )\n+  FT_BASE( FT_UInt16 )\n@@ -500,1 +498,1 @@\n-  FT_BASE( FT_ULong )\n+  FT_BASE( FT_UInt32 )\n@@ -505,1 +503,1 @@\n-  FT_BASE( FT_UShort )\n+  FT_BASE( FT_UInt16 )\n@@ -510,1 +508,1 @@\n-  FT_BASE( FT_ULong )\n+  FT_BASE( FT_UInt32 )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftstream.h","additions":68,"deletions":70,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -21,0 +21,5 @@\n+  \/* the maximum string length (if the argument to `FT_TRACE_DEF` *\/\n+  \/* gets used as a string) plus one charachter for ':' plus      *\/\n+  \/* another one for the trace level                              *\/\n+#define FT_MAX_TRACE_LEVEL_LENGTH  (9 + 1 + 1)\n+\n@@ -41,0 +46,3 @@\n+FT_TRACE_DEF( synth )     \/* bold\/slant synthesizer  (ftsynth.c)  *\/\n+\n+  \/* rasterizers *\/\n@@ -43,1 +51,0 @@\n-FT_TRACE_DEF( synth )     \/* bold\/slant synthesizer  (ftsynth.c)  *\/\n@@ -45,2 +52,5 @@\n-  \/* Cache sub-system *\/\n-FT_TRACE_DEF( cache )     \/* cache sub-system        (ftcache.c, etc.) *\/\n+  \/* ot-svg module *\/\n+FT_TRACE_DEF( otsvg )     \/* OT-SVG renderer         (ftsvg.c)    *\/\n+\n+  \/* cache sub-system *\/\n+FT_TRACE_DEF( cache )     \/* cache sub-system   (ftcache.c, etc.) *\/\n@@ -57,0 +67,2 @@\n+FT_TRACE_DEF( ttgpos )    \/* GPOS handler            (ttgpos.c)   *\/\n+FT_TRACE_DEF( ttsvg )     \/* OpenType SVG table      (ttsvg.c)    *\/\n@@ -80,0 +92,1 @@\n+FT_TRACE_DEF( afmparse )\n@@ -154,1 +167,0 @@\n-FT_TRACE_DEF( aflatin2 )\n@@ -156,1 +168,4 @@\n-FT_TRACE_DEF( afwarp )\n+\n+  \/* SDF components *\/\n+FT_TRACE_DEF( sdf )       \/* signed distance raster for outlines (ftsdf.c) *\/\n+FT_TRACE_DEF( bsdf )      \/* signed distance raster for bitmaps (ftbsdf.c) *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/fttrace.h","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/ftvalid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -135,3 +135,0 @@\n-   *   num_elems ::\n-   *     The current number of elements in table.\n-   *\n@@ -158,1 +155,0 @@\n-    FT_Int             num_elems;\n@@ -232,0 +228,1 @@\n+    T1_FIELD_LOCATION_NONE = 0,\n@@ -256,0 +253,1 @@\n+    FT_UInt             len;          \/* field identifier length        *\/\n@@ -280,0 +278,1 @@\n+            sizeof ( _ident ) - 1,                          \\\n@@ -281,1 +280,1 @@\n-            0,                                              \\\n+            NULL,                                           \\\n@@ -290,0 +289,1 @@\n+            sizeof ( _ident ) - 1,                      \\\n@@ -299,0 +299,1 @@\n+            sizeof ( _ident ) - 1,                               \\\n@@ -300,1 +301,1 @@\n-            0,                                                   \\\n+            NULL,                                                \\\n@@ -310,0 +311,1 @@\n+            sizeof ( _ident ) - 1,                                \\\n@@ -311,1 +313,1 @@\n-            0,                                                    \\\n+            NULL,                                                 \\\n@@ -361,0 +363,7 @@\n+#define T1_FIELD_ZERO                                         \\\n+          {                                                   \\\n+            0,                                                \\\n+            NULL, T1_FIELD_LOCATION_NONE, T1_FIELD_TYPE_NONE, \\\n+            NULL, 0, 0, 0, 0, 0                               \\\n+          }\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/psaux.h","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -297,1 +297,1 @@\n-   *   output, they are in 1\/64th of pixels.\n+   *   output, they are in 1\/64 of pixels.\n@@ -610,1 +610,1 @@\n-   *   output, they are in 1\/64th of pixels.\n+   *   output, they are in 1\/64 of pixels.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/pshints.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svcfftl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svgldict.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svgxval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2016-2020 by\n+ * Copyright (C) 2016-2024 by\n@@ -80,0 +80,3 @@\n+  typedef FT_Error\n+  (*FT_Size_Reset_Func)( FT_Size  size );\n+\n@@ -93,0 +96,1 @@\n+    FT_Size_Reset_Func       size_reset;\n@@ -104,1 +108,2 @@\n-                                                metrics_adjust_  ) \\\n+                                                metrics_adjust_,   \\\n+                                                size_reset_      ) \\\n@@ -114,1 +119,2 @@\n-    metrics_adjust_                                                \\\n+    metrics_adjust_,                                               \\\n+    size_reset_                                                    \\\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svmetric.h","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (C) 2003-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ * Copyright (C) 2003-2024 by\n+ * David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n@@ -22,0 +22,1 @@\n+#include <freetype\/ftmm.h>\n@@ -23,0 +24,1 @@\n+#include <freetype\/internal\/ftmmtypes.h>\n@@ -61,3 +63,3 @@\n-  (*FT_Set_MM_Blend_Func)( FT_Face   face,\n-                           FT_UInt   num_coords,\n-                           FT_Long*  coords );\n+  (*FT_Set_MM_Blend_Func)( FT_Face    face,\n+                           FT_UInt    num_coords,\n+                           FT_Fixed*  coords );\n@@ -71,2 +73,2 @@\n-  (*FT_Set_Instance_Func)( FT_Face  face,\n-                           FT_UInt  instance_index );\n+  (*FT_Set_Named_Instance_Func)( FT_Face  face,\n+                                 FT_UInt  instance_index );\n@@ -75,3 +77,7 @@\n-  (*FT_Get_MM_Blend_Func)( FT_Face   face,\n-                           FT_UInt   num_coords,\n-                           FT_Long*  coords );\n+  (*FT_Get_Default_Named_Instance_Func)( FT_Face   face,\n+                                         FT_UInt  *instance_index );\n+\n+  typedef FT_Error\n+  (*FT_Get_MM_Blend_Func)( FT_Face    face,\n+                           FT_UInt    num_coords,\n+                           FT_Fixed*  coords );\n@@ -87,1 +93,1 @@\n-  (*FT_Done_Blend_Func)( FT_Face );\n+  (*FT_Done_Blend_Func)( FT_Face  face );\n@@ -99,0 +105,29 @@\n+  typedef void\n+  (*FT_Construct_PS_Name_Func)( FT_Face  face );\n+\n+  typedef FT_Error\n+  (*FT_Var_Load_Delta_Set_Idx_Map_Func)( FT_Face            face,\n+                                         FT_ULong           offset,\n+                                         GX_DeltaSetIdxMap  map,\n+                                         GX_ItemVarStore    itemStore,\n+                                         FT_ULong           table_len );\n+\n+  typedef FT_Error\n+  (*FT_Var_Load_Item_Var_Store_Func)( FT_Face          face,\n+                                      FT_ULong         offset,\n+                                      GX_ItemVarStore  itemStore );\n+\n+  typedef FT_ItemVarDelta\n+  (*FT_Var_Get_Item_Delta_Func)( FT_Face          face,\n+                                 GX_ItemVarStore  itemStore,\n+                                 FT_UInt          outerIndex,\n+                                 FT_UInt          innerIndex );\n+\n+  typedef void\n+  (*FT_Var_Done_Item_Var_Store_Func)( FT_Face          face,\n+                                      GX_ItemVarStore  itemStore );\n+\n+  typedef void\n+  (*FT_Var_Done_Delta_Set_Idx_Map_Func)( FT_Face            face,\n+                                         GX_DeltaSetIdxMap  deltaSetIdxMap );\n+\n@@ -102,10 +137,11 @@\n-    FT_Get_MM_Func               get_mm;\n-    FT_Set_MM_Design_Func        set_mm_design;\n-    FT_Set_MM_Blend_Func         set_mm_blend;\n-    FT_Get_MM_Blend_Func         get_mm_blend;\n-    FT_Get_MM_Var_Func           get_mm_var;\n-    FT_Set_Var_Design_Func       set_var_design;\n-    FT_Get_Var_Design_Func       get_var_design;\n-    FT_Set_Instance_Func         set_instance;\n-    FT_Set_MM_WeightVector_Func  set_mm_weightvector;\n-    FT_Get_MM_WeightVector_Func  get_mm_weightvector;\n+    FT_Get_MM_Func                        get_mm;\n+    FT_Set_MM_Design_Func                 set_mm_design;\n+    FT_Set_MM_Blend_Func                  set_mm_blend;\n+    FT_Get_MM_Blend_Func                  get_mm_blend;\n+    FT_Get_MM_Var_Func                    get_mm_var;\n+    FT_Set_Var_Design_Func                set_var_design;\n+    FT_Get_Var_Design_Func                get_var_design;\n+    FT_Set_Named_Instance_Func            set_named_instance;\n+    FT_Get_Default_Named_Instance_Func    get_default_named_instance;\n+    FT_Set_MM_WeightVector_Func           set_mm_weightvector;\n+    FT_Get_MM_WeightVector_Func           get_mm_weightvector;\n@@ -114,2 +150,8 @@\n-    FT_Get_Var_Blend_Func  get_var_blend;\n-    FT_Done_Blend_Func     done_blend;\n+    FT_Construct_PS_Name_Func             construct_ps_name;\n+    FT_Var_Load_Delta_Set_Idx_Map_Func    load_delta_set_idx_map;\n+    FT_Var_Load_Item_Var_Store_Func       load_item_var_store;\n+    FT_Var_Get_Item_Delta_Func            get_item_delta;\n+    FT_Var_Done_Item_Var_Store_Func       done_item_var_store;\n+    FT_Var_Done_Delta_Set_Idx_Map_Func    done_delta_set_idx_map;\n+    FT_Get_Var_Blend_Func                 get_var_blend;\n+    FT_Done_Blend_Func                    done_blend;\n@@ -119,27 +161,43 @@\n-#define FT_DEFINE_SERVICE_MULTIMASTERSREC( class_,            \\\n-                                           get_mm_,           \\\n-                                           set_mm_design_,    \\\n-                                           set_mm_blend_,     \\\n-                                           get_mm_blend_,     \\\n-                                           get_mm_var_,       \\\n-                                           set_var_design_,   \\\n-                                           get_var_design_,   \\\n-                                           set_instance_,     \\\n-                                           set_weightvector_, \\\n-                                           get_weightvector_, \\\n-                                           get_var_blend_,    \\\n-                                           done_blend_ )      \\\n-  static const FT_Service_MultiMastersRec  class_ =           \\\n-  {                                                           \\\n-    get_mm_,                                                  \\\n-    set_mm_design_,                                           \\\n-    set_mm_blend_,                                            \\\n-    get_mm_blend_,                                            \\\n-    get_mm_var_,                                              \\\n-    set_var_design_,                                          \\\n-    get_var_design_,                                          \\\n-    set_instance_,                                            \\\n-    set_weightvector_,                                        \\\n-    get_weightvector_,                                        \\\n-    get_var_blend_,                                           \\\n-    done_blend_                                               \\\n+#define FT_DEFINE_SERVICE_MULTIMASTERSREC( class_,                      \\\n+                                           get_mm_,                     \\\n+                                           set_mm_design_,              \\\n+                                           set_mm_blend_,               \\\n+                                           get_mm_blend_,               \\\n+                                           get_mm_var_,                 \\\n+                                           set_var_design_,             \\\n+                                           get_var_design_,             \\\n+                                           set_named_instance_,         \\\n+                                           get_default_named_instance_, \\\n+                                           set_mm_weightvector_,        \\\n+                                           get_mm_weightvector_,        \\\n+                                                                        \\\n+                                           construct_ps_name_,          \\\n+                                           load_delta_set_idx_map_,     \\\n+                                           load_item_var_store_,        \\\n+                                           get_item_delta_,             \\\n+                                           done_item_var_store_,        \\\n+                                           done_delta_set_idx_map_,     \\\n+                                           get_var_blend_,              \\\n+                                           done_blend_ )                \\\n+  static const FT_Service_MultiMastersRec  class_ =                     \\\n+  {                                                                     \\\n+    get_mm_,                                                            \\\n+    set_mm_design_,                                                     \\\n+    set_mm_blend_,                                                      \\\n+    get_mm_blend_,                                                      \\\n+    get_mm_var_,                                                        \\\n+    set_var_design_,                                                    \\\n+    get_var_design_,                                                    \\\n+    set_named_instance_,                                                \\\n+    get_default_named_instance_,                                        \\\n+    set_mm_weightvector_,                                               \\\n+    get_mm_weightvector_,                                               \\\n+                                                                        \\\n+    construct_ps_name_,                                                 \\\n+    load_delta_set_idx_map_,                                            \\\n+    load_item_var_store_,                                               \\\n+    get_item_delta_,                                                    \\\n+    done_item_var_store_,                                               \\\n+    done_delta_set_idx_map_,                                            \\\n+    get_var_blend_,                                                     \\\n+    done_blend_                                                         \\\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svmm.h","additions":108,"deletions":50,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svotval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svpfr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svpostnm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2012-2020 by\n+ * Copyright (C) 2012-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -100,1 +100,1 @@\n-  typedef FT_UInt32\n+  typedef FT_UInt\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svpscmap.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svpsinfo.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svsfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svtteng.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svttglyf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/services\/svwinfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -314,0 +314,27 @@\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Load_Svg_Doc_Func\n+   *\n+   * @description:\n+   *   Scan the SVG document list to find the document containing the glyph\n+   *   that has the ID 'glyph*XXX*', where *XXX* is the value of\n+   *   `glyph_index` as a decimal integer.\n+   *\n+   * @inout:\n+   *   glyph ::\n+   *     The glyph slot from which pointers to the SVG document list is to be\n+   *     grabbed.  The results are stored back in the slot.\n+   *\n+   * @input:\n+   *   glyph_index ::\n+   *     The index of the glyph that is to be looked up.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\/\n+  typedef FT_Error\n+  (*TT_Load_Svg_Doc_Func)( FT_GlyphSlot  glyph,\n+                           FT_UInt       glyph_index );\n+\n+\n@@ -527,0 +554,164 @@\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Color_Glyph_Paint_Func\n+   *\n+   * @description:\n+   *   Find the root @FT_OpaquePaint object for a given glyph ID.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index the colored glyph layers are associated with.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The root @FT_OpaquePaint object.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If no color glyph is found, or the root\n+   *   paint could not be retrieved, value~0 gets returned.  In case of an\n+   *   error, value~0 is returned also.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Color_Glyph_Paint_Func )( TT_Face                   face,\n+                                      FT_UInt                   base_glyph,\n+                                      FT_Color_Root_Transform   root_transform,\n+                                      FT_OpaquePaint           *paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Color_Glyph_ClipBox_Func\n+   *\n+   * @description:\n+   *   Search for a 'COLR' v1 clip box for the specified `base_glyph` and\n+   *   fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information\n+   *   if one is found.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index for which to retrieve the clip box.\n+   *\n+   * @output:\n+   *   clip_box ::\n+   *     The clip box for the requested `base_glyph` if one is found.  The\n+   *     clip box is computed taking scale and transformations configured on\n+   *     the @FT_Face into account.  @FT_ClipBox contains @FT_Vector values\n+   *     in 26.6 format.\n+   *\n+   * @note:\n+   *     To retrieve the clip box in font units, reset scale to units-per-em\n+   *     and remove transforms configured using @FT_Set_Transform.\n+   *\n+   * @return:\n+   *   Value~1 if a ClipBox is found.  If no clip box is found or an\n+   *   error occured, value~0 is returned.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Color_Glyph_ClipBox_Func )( TT_Face      face,\n+                                        FT_UInt      base_glyph,\n+                                        FT_ClipBox*  clip_box );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Paint_Layers_Func\n+   *\n+   * @description:\n+   *   Access the layers of a `PaintColrLayers` table.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     The @FT_LayerIterator from an @FT_PaintColrLayers object, for which\n+   *     the layers are to be retrieved.  The internal state of the iterator\n+   *     is incremented after one call to this function for retrieving one\n+   *     layer.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The root @FT_OpaquePaint object referencing the actual paint table.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 gets returned when the paint\n+   *   object can not be retrieved or any other error occurs.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Paint_Layers_Func )( TT_Face            face,\n+                                 FT_LayerIterator*  iterator,\n+                                 FT_OpaquePaint    *paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Colorline_Stops_Func\n+   *\n+   * @description:\n+   *   Get the gradient and solid fill information for a given glyph.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     An @FT_ColorStopIterator object.  For the first call you should set\n+   *     `iterator->p` to `NULL`.  For all following calls, simply use the\n+   *     same object again.\n+   *\n+   * @output:\n+   *   color_stop ::\n+   *     Color index and alpha value for the retrieved color stop.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If there are no more color stops,\n+   *   value~0 gets returned.  In case of an error, value~0 is returned\n+   *   also.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Colorline_Stops_Func )( TT_Face                face,\n+                                    FT_ColorStop          *color_stop,\n+                                    FT_ColorStopIterator*  iterator );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Paint_Func\n+   *\n+   * @description:\n+   *   Get the paint details for a given @FT_OpaquePaint object.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   *   opaque_paint ::\n+   *     The @FT_OpaquePaint object.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     An @FT_COLR_Paint object holding the details on `opaque_paint`.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 if no details can be found for\n+   *   this paint or any other error occured.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Paint_Func )( TT_Face         face,\n+                          FT_OpaquePaint  opaque_paint,\n+                          FT_COLR_Paint  *paint );\n+\n+\n@@ -712,1 +903,1 @@\n-    TT_Loader_GotoTableFunc      goto_table;\n+    TT_Loader_GotoTableFunc  goto_table;\n@@ -714,4 +905,4 @@\n-    TT_Init_Face_Func            init_face;\n-    TT_Load_Face_Func            load_face;\n-    TT_Done_Face_Func            done_face;\n-    FT_Module_Requester          get_interface;\n+    TT_Init_Face_Func    init_face;\n+    TT_Load_Face_Func    load_face;\n+    TT_Done_Face_Func    done_face;\n+    FT_Module_Requester  get_interface;\n@@ -719,1 +910,1 @@\n-    TT_Load_Any_Func             load_any;\n+    TT_Load_Any_Func  load_any;\n@@ -723,6 +914,6 @@\n-    TT_Load_Table_Func           load_head;\n-    TT_Load_Metrics_Func         load_hhea;\n-    TT_Load_Table_Func           load_cmap;\n-    TT_Load_Table_Func           load_maxp;\n-    TT_Load_Table_Func           load_os2;\n-    TT_Load_Table_Func           load_post;\n+    TT_Load_Table_Func    load_head;\n+    TT_Load_Metrics_Func  load_hhea;\n+    TT_Load_Table_Func    load_cmap;\n+    TT_Load_Table_Func    load_maxp;\n+    TT_Load_Table_Func    load_os2;\n+    TT_Load_Table_Func    load_post;\n@@ -730,2 +921,2 @@\n-    TT_Load_Table_Func           load_name;\n-    TT_Free_Table_Func           free_name;\n+    TT_Load_Table_Func  load_name;\n+    TT_Free_Table_Func  free_name;\n@@ -734,1 +925,1 @@\n-    TT_Load_Table_Func           load_kern;\n+    TT_Load_Table_Func  load_kern;\n@@ -736,2 +927,3 @@\n-    TT_Load_Table_Func           load_gasp;\n-    TT_Load_Table_Func           load_pclt;\n+    TT_Load_Table_Func  load_gpos;\n+    TT_Load_Table_Func  load_gasp;\n+    TT_Load_Table_Func  load_pclt;\n@@ -741,1 +933,1 @@\n-    TT_Load_Table_Func           load_bhed;\n+    TT_Load_Table_Func  load_bhed;\n@@ -743,1 +935,1 @@\n-    TT_Load_SBit_Image_Func      load_sbit_image;\n+    TT_Load_SBit_Image_Func  load_sbit_image;\n@@ -746,2 +938,2 @@\n-    TT_Get_PS_Name_Func          get_psname;\n-    TT_Free_Table_Func           free_psnames;\n+    TT_Get_PS_Name_Func  get_psname;\n+    TT_Free_Table_Func   free_psnames;\n@@ -752,1 +944,1 @@\n-    TT_Face_GetKerningFunc       get_kerning;\n+    TT_Face_GetKerningFunc  get_kerning;\n@@ -756,0 +948,2 @@\n+    TT_Face_GetKerningFunc  get_gpos_kerning;\n+\n@@ -758,2 +952,2 @@\n-    TT_Load_Table_Func           load_font_dir;\n-    TT_Load_Metrics_Func         load_hmtx;\n+    TT_Load_Table_Func    load_font_dir;\n+    TT_Load_Metrics_Func  load_hmtx;\n@@ -761,2 +955,2 @@\n-    TT_Load_Table_Func           load_eblc;\n-    TT_Free_Table_Func           free_eblc;\n+    TT_Load_Table_Func  load_eblc;\n+    TT_Free_Table_Func  free_eblc;\n@@ -767,12 +961,22 @@\n-    TT_Load_Table_Func           load_cpal;\n-    TT_Load_Table_Func           load_colr;\n-    TT_Free_Table_Func           free_cpal;\n-    TT_Free_Table_Func           free_colr;\n-    TT_Set_Palette_Func          set_palette;\n-    TT_Get_Colr_Layer_Func       get_colr_layer;\n-    TT_Blend_Colr_Func           colr_blend;\n-\n-    TT_Get_Metrics_Func          get_metrics;\n-\n-    TT_Get_Name_Func             get_name;\n-    TT_Get_Name_ID_Func          get_name_id;\n+    TT_Load_Table_Func               load_cpal;\n+    TT_Load_Table_Func               load_colr;\n+    TT_Free_Table_Func               free_cpal;\n+    TT_Free_Table_Func               free_colr;\n+    TT_Set_Palette_Func              set_palette;\n+    TT_Get_Colr_Layer_Func           get_colr_layer;\n+    TT_Get_Color_Glyph_Paint_Func    get_colr_glyph_paint;\n+    TT_Get_Color_Glyph_ClipBox_Func  get_color_glyph_clipbox;\n+    TT_Get_Paint_Layers_Func         get_paint_layers;\n+    TT_Get_Colorline_Stops_Func      get_colorline_stops;\n+    TT_Get_Paint_Func                get_paint;\n+    TT_Blend_Colr_Func               colr_blend;\n+\n+    TT_Get_Metrics_Func  get_metrics;\n+\n+    TT_Get_Name_Func     get_name;\n+    TT_Get_Name_ID_Func  get_name_id;\n+\n+    \/* OpenType SVG Support *\/\n+    TT_Load_Table_Func    load_svg;\n+    TT_Free_Table_Func    free_svg;\n+    TT_Load_Svg_Doc_Func  load_svg_doc;\n@@ -804,0 +1008,1 @@\n+          load_gpos_,                    \\\n@@ -811,0 +1016,1 @@\n+          get_gpos_kerning_,             \\\n@@ -823,0 +1029,5 @@\n+          get_colr_glyph_paint_,         \\\n+          get_color_glyph_clipbox,       \\\n+          get_paint_layers_,             \\\n+          get_colorline_stops_,          \\\n+          get_paint_,                    \\\n@@ -826,1 +1037,4 @@\n-          get_name_id_ )                 \\\n+          get_name_id_,                  \\\n+          load_svg_,                     \\\n+          free_svg_,                     \\\n+          load_svg_doc_ )                \\\n@@ -844,0 +1058,1 @@\n+    load_gpos_,                          \\\n@@ -851,0 +1066,1 @@\n+    get_gpos_kerning_,                   \\\n@@ -863,0 +1079,5 @@\n+    get_colr_glyph_paint_,               \\\n+    get_color_glyph_clipbox,             \\\n+    get_paint_layers_,                   \\\n+    get_colorline_stops_,                \\\n+    get_paint_,                          \\\n@@ -866,1 +1087,4 @@\n-    get_name_id_                         \\\n+    get_name_id_,                        \\\n+    load_svg_,                           \\\n+    free_svg_,                           \\\n+    load_svg_doc_                        \\\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/sfnt.h","additions":265,"deletions":41,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/****************************************************************************\n+ *\n+ * svginterface.h\n+ *\n+ *   Interface of ot-svg module (specification only).\n+ *\n+ * Copyright (C) 2022-2024 by\n+ * David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef SVGINTERFACE_H_\n+#define SVGINTERFACE_H_\n+\n+#include <ft2build.h>\n+#include <freetype\/otsvg.h>\n+\n+\n+FT_BEGIN_HEADER\n+\n+  typedef FT_Error\n+  (*Preset_Bitmap_Func)( FT_Module     module,\n+                         FT_GlyphSlot  slot,\n+                         FT_Bool       cache );\n+\n+  typedef struct  SVG_Interface_\n+  {\n+    Preset_Bitmap_Func  preset_slot;\n+\n+  } SVG_Interface;\n+\n+  typedef SVG_Interface*  SVG_Service;\n+\n+FT_END_HEADER\n+\n+#endif \/* SVGINTERFACE_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/svginterface.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -24,1 +24,1 @@\n-#include <freetype\/t1tables.h>\n+#include <freetype\/ftmm.h>\n@@ -140,0 +140,48 @@\n+  \/* this structure is used to store the BlendDesignMap entry for an axis *\/\n+  typedef struct  PS_DesignMap_\n+  {\n+    FT_Byte    num_points;\n+    FT_Long*   design_points;\n+    FT_Fixed*  blend_points;\n+\n+  } PS_DesignMapRec, *PS_DesignMap;\n+\n+  \/* backward compatible definition *\/\n+  typedef PS_DesignMapRec  T1_DesignMap;\n+\n+\n+  typedef struct  PS_BlendRec_\n+  {\n+    FT_UInt          num_designs;\n+    FT_UInt          num_axis;\n+\n+    FT_String*       axis_names[T1_MAX_MM_AXIS];\n+    FT_Fixed*        design_pos[T1_MAX_MM_DESIGNS];\n+    PS_DesignMapRec  design_map[T1_MAX_MM_AXIS];\n+\n+    FT_Fixed*        weight_vector;\n+    FT_Fixed*        default_weight_vector;\n+\n+    PS_FontInfo      font_infos[T1_MAX_MM_DESIGNS + 1];\n+    PS_Private       privates  [T1_MAX_MM_DESIGNS + 1];\n+\n+    FT_ULong         blend_bitflags;\n+\n+    FT_BBox*         bboxes    [T1_MAX_MM_DESIGNS + 1];\n+\n+    \/* since 2.3.0 *\/\n+\n+    \/* undocumented, optional: the default design instance;   *\/\n+    \/* corresponds to default_weight_vector --                *\/\n+    \/* num_default_design_vector == 0 means it is not present *\/\n+    \/* in the font and associated metrics files               *\/\n+    FT_UInt          default_design_vector[T1_MAX_MM_DESIGNS];\n+    FT_UInt          num_default_design_vector;\n+\n+  } PS_BlendRec, *PS_Blend;\n+\n+\n+  \/* backward compatible definition *\/\n+  typedef PS_BlendRec  T1_Blend;\n+\n+\n@@ -175,2 +223,2 @@\n-    FT_Fixed       Ascender;\n-    FT_Fixed       Descender;\n+    FT_Fixed       Ascender;     \/* optional, mind the zero *\/\n+    FT_Fixed       Descender;    \/* optional, mind the zero *\/\n@@ -204,7 +252,7 @@\n-    FT_FaceRec      root;\n-    T1_FontRec      type1;\n-    const void*     psnames;\n-    const void*     psaux;\n-    const void*     afm_data;\n-    FT_CharMapRec   charmaprecs[2];\n-    FT_CharMap      charmaps[2];\n+    FT_FaceRec     root;\n+    T1_FontRec     type1;\n+    const void*    psnames;\n+    const void*    psaux;\n+    const void*    afm_data;\n+    FT_CharMapRec  charmaprecs[2];\n+    FT_CharMap     charmaps[2];\n@@ -213,1 +261,1 @@\n-    PS_Blend        blend;\n+    PS_Blend       blend;\n@@ -218,2 +266,2 @@\n-    FT_Int           ndv_idx;\n-    FT_Int           cdv_idx;\n+    FT_Int         ndv_idx;\n+    FT_Int         cdv_idx;\n@@ -223,2 +271,2 @@\n-    FT_UInt          len_buildchar;\n-    FT_Long*         buildchar;\n+    FT_UInt        len_buildchar;\n+    FT_Long*       buildchar;\n@@ -227,1 +275,1 @@\n-    const void*     pshinter;\n+    const void*    pshinter;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/t1types.h","additions":65,"deletions":17,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -27,0 +27,1 @@\n+#include \"freetype\/fttypes.h\"\n@@ -782,1 +783,1 @@\n-   *   TT_Post_20Rec\n+   *   TT_Post_NamesRec\n@@ -785,2 +786,1 @@\n-   *   Postscript names sub-table, format 2.0.  Stores the PS name of each\n-   *   glyph in the font face.\n+   *   Postscript names table, either format 2.0 or 2.5.\n@@ -789,0 +789,3 @@\n+   *   loaded ::\n+   *     A flag to indicate whether the PS names are loaded.\n+   *\n@@ -801,1 +804,1 @@\n-  typedef struct  TT_Post_20Rec_\n+  typedef struct  TT_Post_NamesRec_\n@@ -803,0 +806,1 @@\n+    FT_Bool     loaded;\n@@ -806,57 +810,1 @@\n-    FT_Char**   glyph_names;\n-\n-  } TT_Post_20Rec, *TT_Post_20;\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @struct:\n-   *   TT_Post_25Rec\n-   *\n-   * @description:\n-   *   Postscript names sub-table, format 2.5.  Stores the PS name of each\n-   *   glyph in the font face.\n-   *\n-   * @fields:\n-   *   num_glyphs ::\n-   *     The number of glyphs in the table.\n-   *\n-   *   offsets ::\n-   *     An array of signed offsets in a normal Mac Postscript name encoding.\n-   *\/\n-  typedef struct  TT_Post_25_\n-  {\n-    FT_UShort  num_glyphs;\n-    FT_Char*   offsets;\n-\n-  } TT_Post_25Rec, *TT_Post_25;\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @struct:\n-   *   TT_Post_NamesRec\n-   *\n-   * @description:\n-   *   Postscript names table, either format 2.0 or 2.5.\n-   *\n-   * @fields:\n-   *   loaded ::\n-   *     A flag to indicate whether the PS names are loaded.\n-   *\n-   *   format_20 ::\n-   *     The sub-table used for format 2.0.\n-   *\n-   *   format_25 ::\n-   *     The sub-table used for format 2.5.\n-   *\/\n-  typedef struct  TT_Post_NamesRec_\n-  {\n-    FT_Bool  loaded;\n-\n-    union\n-    {\n-      TT_Post_20Rec  format_20;\n-      TT_Post_25Rec  format_25;\n-\n-    } names;\n+    FT_Byte**   glyph_names;\n@@ -1256,2 +1204,3 @@\n-   *   var ::\n-   *     A pointer to the Metrics Variations service.\n+   *   tt_var ::\n+   *     A pointer to the Metrics Variations service for the \"truetype\"\n+   *     driver.\n@@ -1259,3 +1208,6 @@\n-   *   hdmx ::\n-   *     The face's horizontal device metrics ('hdmx' table).  This table is\n-   *     optional in TrueType\/OpenType fonts.\n+   *   face_var ::\n+   *     A pointer to the Metrics Variations service for this `TT_Face`'s\n+   *     driver.\n+   *\n+   *   psaux ::\n+   *     A pointer to the PostScript Auxiliary service.\n@@ -1367,0 +1319,6 @@\n+   *   var_default_named_instance ::\n+   *     The index of the default named instance.\n+   *\n+   *   non_var_style_name ::\n+   *     The non-variation style name, used as a backup.\n+   *\n@@ -1375,1 +1333,1 @@\n-   *     identical to the number of glyphs.  Ignored for Type 2 fonts.\n+   *     one more than the number of glyphs.  Ignored for Type 2 fonts.\n@@ -1393,2 +1351,2 @@\n-   *   hdmx_record_sizes ::\n-   *     An array holding the ppem sizes available in the 'hdmx' table.\n+   *   hdmx_records ::\n+   *     A array of pointers to the 'hdmx' table records sorted by ppem.\n@@ -1413,8 +1371,0 @@\n-   *   cpal ::\n-   *     A pointer to data related to the 'CPAL' table.  `NULL` if the table\n-   *     is not available.\n-   *\n-   *   colr ::\n-   *     A pointer to data related to the 'COLR' table.  `NULL` if the table\n-   *     is not available.\n-   *\n@@ -1448,8 +1398,0 @@\n-   *   sph_found_func_flags ::\n-   *     Flags identifying special bytecode functions (used by the v38\n-   *     implementation of the bytecode interpreter).\n-   *\n-   *   sph_compatibility_mode ::\n-   *     This flag is set if we are in ClearType backward compatibility mode\n-   *     (used by the v38 implementation of the bytecode interpreter).\n-   *\n@@ -1461,0 +1403,12 @@\n+   *\n+   *   cpal ::\n+   *     A pointer to data related to the 'CPAL' table.  `NULL` if the table\n+   *     is not available.\n+   *\n+   *   colr ::\n+   *     A pointer to data related to the 'COLR' table.  `NULL` if the table\n+   *     is not available.\n+   *\n+   *   svg ::\n+   *     A pointer to data related to the 'SVG' table.  `NULL` if the table\n+   *     is not available.\n@@ -1511,2 +1465,8 @@\n-    \/* used to handle the HVAR, VVAR, and MVAR OpenType tables         *\/\n-    void*                 var;\n+    \/* used to handle the HVAR, VVAR, and MVAR OpenType tables by the  *\/\n+    \/* \"truetype\" driver                                               *\/\n+    void*                 tt_var;\n+\n+    \/* a typeless pointer to the FT_Service_MetricsVariationsRec table *\/\n+    \/* used to handle the HVAR, VVAR, and MVAR OpenType tables by this *\/\n+    \/* TT_Face's driver                                                *\/\n+    void*                 face_var;             \/* since 2.13.1 *\/\n@@ -1594,0 +1554,3 @@\n+    FT_UInt               var_default_named_instance;  \/* since 2.13.1 *\/\n+\n+    const char*           non_var_style_name;  \/* since 2.13.1 *\/\n@@ -1601,1 +1564,1 @@\n-    FT_ULong              num_locations; \/* in broken TTF, gid > 0xFFFF *\/\n+    FT_ULong              num_locations; \/* up to 0xFFFF + 1 *\/\n@@ -1608,1 +1571,1 @@\n-    FT_Byte*              hdmx_record_sizes;\n+    FT_Byte**             hdmx_records;\n@@ -1622,0 +1585,5 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+    FT_Byte*              gpos_table;\n+    FT_Bool               gpos_kerning_available;\n+#endif\n+\n@@ -1630,7 +1598,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    \/* since 2.4.12 *\/\n-    FT_ULong              sph_found_func_flags; \/* special functions found *\/\n-                                                \/* for this face           *\/\n-    FT_Bool               sph_compatibility_mode;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -1647,0 +1608,3 @@\n+    \/* since 2.12 *\/\n+    void*                 svg;\n+\n@@ -1694,1 +1658,1 @@\n-    FT_Short    max_contours;\n+    FT_UShort   max_contours;\n@@ -1696,1 +1660,1 @@\n-    FT_Short    n_contours;  \/* number of contours          *\/\n+    FT_UShort   n_contours;  \/* number of contours          *\/\n@@ -1737,1 +1701,1 @@\n-    FT_Int           byte_len;\n+    FT_UInt          byte_len;\n@@ -1772,0 +1736,3 @@\n+    \/* since version 2.11.2 *\/\n+    FT_Byte*         widthp;\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/tttypes.h","additions":67,"deletions":100,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -95,1 +95,1 @@\n-    FT_ULong  Tag;           \/* table ID                  *\/\n+    FT_Tag    Tag;           \/* table ID                  *\/\n@@ -194,1 +194,1 @@\n-    FT_ULong  Tag;                \/* table file offset         *\/\n+    FT_Tag    Tag;                \/* table file offset         *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/internal\/wofftypes.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+\/****************************************************************************\n+ *\n+ * otsvg.h\n+ *\n+ *   Interface for OT-SVG support related things (specification).\n+ *\n+ * Copyright (C) 2022-2024 by\n+ * David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef OTSVG_H_\n+#define OTSVG_H_\n+\n+#include <freetype\/freetype.h>\n+\n+#ifdef FREETYPE_H\n+#error \"freetype.h of FreeType 1 has been loaded!\"\n+#error \"Please fix the directory search order for header files\"\n+#error \"so that freetype.h of FreeType 2 is found first.\"\n+#endif\n+\n+\n+FT_BEGIN_HEADER\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   svg_fonts\n+   *\n+   * @title:\n+   *   OpenType SVG Fonts\n+   *\n+   * @abstract:\n+   *   OT-SVG API between FreeType and an external SVG rendering library.\n+   *\n+   * @description:\n+   *   This section describes the four hooks necessary to render SVG\n+   *   'documents' that are contained in an OpenType font's 'SVG~' table.\n+   *\n+   *   For more information on the implementation, see our standard hooks\n+   *   based on 'librsvg' in the [FreeType Demo\n+   *   Programs](https:\/\/gitlab.freedesktop.org\/freetype\/freetype-demos)\n+   *   repository.\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Init_Func\n+   *\n+   * @description:\n+   *   A callback that is called when the first OT-SVG glyph is rendered in\n+   *   the lifetime of an @FT_Library object.  In a typical implementation,\n+   *   one would want to allocate a structure and point the `data_pointer`\n+   *   to it and perform any library initializations that might be needed.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef FT_Error\n+  (*SVG_Lib_Init_Func)( FT_Pointer  *data_pointer );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Free_Func\n+   *\n+   * @description:\n+   *   A callback that is called when the `ot-svg` module is being freed.\n+   *   It is only called if the init hook was called earlier.  This means\n+   *   that neither the init nor the free hook is called if no OT-SVG glyph\n+   *   is rendered.\n+   *\n+   *   In a typical implementation, one would want to free any state\n+   *   structure that was allocated in the init hook and perform any\n+   *   library-related closure that might be needed.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef void\n+  (*SVG_Lib_Free_Func)( FT_Pointer  *data_pointer );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Render_Func\n+   *\n+   * @description:\n+   *   A callback that is called to render an OT-SVG glyph.  This callback\n+   *   hook is called right after the preset hook @SVG_Lib_Preset_Slot_Func\n+   *   has been called with `cache` set to `TRUE`.  The data necessary to\n+   *   render is available through the handle @FT_SVG_Document, which is set\n+   *   in the `other` field of @FT_GlyphSlotRec.\n+   *\n+   *   The render hook is expected to render the SVG glyph to the bitmap\n+   *   buffer that is allocated already at `slot->bitmap.buffer`.  It also\n+   *   sets the `num_grays` value as well as `slot->format`.\n+   *\n+   * @input:\n+   *   slot ::\n+   *     The slot to render.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef FT_Error\n+  (*SVG_Lib_Render_Func)( FT_GlyphSlot  slot,\n+                          FT_Pointer   *data_pointer );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Preset_Slot_Func\n+   *\n+   * @description:\n+   *   A callback that is called to preset the glyph slot.  It is called from\n+   *   two places.\n+   *\n+   *   1. When `FT_Load_Glyph` needs to preset the glyph slot.\n+   *\n+   *   2. Right before the `svg` module calls the render callback hook.\n+   *\n+   *   When it is the former, the argument `cache` is set to `FALSE`.  When\n+   *   it is the latter, the argument `cache` is set to `TRUE`.  This\n+   *   distinction has been made because many calculations that are necessary\n+   *   for presetting a glyph slot are the same needed later for the render\n+   *   callback hook.  Thus, if `cache` is `TRUE`, the hook can _cache_ those\n+   *   calculations in a memory block referenced by the state pointer.\n+   *\n+   *   This hook is expected to preset the slot by setting parameters such as\n+   *   `bitmap_left`, `bitmap_top`, `width`, `rows`, `pitch`, and\n+   *   `pixel_mode`.  It is also expected to set all the metrics for the slot\n+   *   including the vertical advance if it is not already set.  Typically,\n+   *   fonts have horizontal advances but not vertical ones.  If those are\n+   *   available, they had already been set, otherwise they have to be\n+   *   estimated and set manually.  The hook must take into account the\n+   *   transformations that have been set, and translate the transformation\n+   *   matrices into the SVG coordinate system, as the original matrix is\n+   *   intended for the TTF\/CFF coordinate system.\n+   *\n+   * @input:\n+   *   slot ::\n+   *     The glyph slot that has the SVG document loaded.\n+   *\n+   *   cache ::\n+   *     See description.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef FT_Error\n+  (*SVG_Lib_Preset_Slot_Func)( FT_GlyphSlot  slot,\n+                               FT_Bool       cache,\n+                               FT_Pointer   *state );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   SVG_RendererHooks\n+   *\n+   * @description:\n+   *   A structure that stores the four hooks needed to render OT-SVG glyphs\n+   *   properly.  The structure is publicly used to set the hooks via the\n+   *   @svg-hooks driver property.\n+   *\n+   *   The behavior of each hook is described in its documentation.  One\n+   *   thing to note is that the preset hook and the render hook often need\n+   *   to do the same operations; therefore, it's better to cache the\n+   *   intermediate data in a state structure to avoid calculating it twice.\n+   *   For example, in the preset hook one can draw the glyph on a recorder\n+   *   surface and later create a bitmap surface from it in the render hook.\n+   *\n+   *   All four hooks must be non-NULL.\n+   *\n+   * @fields:\n+   *   init_svg ::\n+   *     The initialization hook.\n+   *\n+   *   free_svg ::\n+   *     The cleanup hook.\n+   *\n+   *   render_hook ::\n+   *     The render hook.\n+   *\n+   *   preset_slot ::\n+   *     The preset hook.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct SVG_RendererHooks_\n+  {\n+    SVG_Lib_Init_Func    init_svg;\n+    SVG_Lib_Free_Func    free_svg;\n+    SVG_Lib_Render_Func  render_svg;\n+\n+    SVG_Lib_Preset_Slot_Func  preset_slot;\n+\n+  } SVG_RendererHooks;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_SVG_DocumentRec\n+   *\n+   * @description:\n+   *   A structure that models one SVG document.\n+   *\n+   * @fields:\n+   *   svg_document ::\n+   *     A pointer to the SVG document.\n+   *\n+   *   svg_document_length ::\n+   *     The length of `svg_document`.\n+   *\n+   *   metrics ::\n+   *     A metrics object storing the size information.\n+   *\n+   *   units_per_EM ::\n+   *     The size of the EM square.\n+   *\n+   *   start_glyph_id ::\n+   *     The first glyph ID in the glyph range covered by this document.\n+   *\n+   *   end_glyph_id ::\n+   *     The last glyph ID in the glyph range covered by this document.\n+   *\n+   *   transform ::\n+   *     A 2x2 transformation matrix to apply to the glyph while rendering\n+   *     it.\n+   *\n+   *   delta ::\n+   *     The translation to apply to the glyph while rendering.\n+   *\n+   * @note:\n+   *   When an @FT_GlyphSlot object `slot` is passed down to a renderer, the\n+   *   renderer can only access the `metrics` and `units_per_EM` fields via\n+   *   `slot->face`.  However, when @FT_Glyph_To_Bitmap sets up a dummy\n+   *   object, it has no way to set a `face` object.  Thus, metrics\n+   *   information and `units_per_EM` (which is necessary for OT-SVG) has to\n+   *   be stored separately.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct  FT_SVG_DocumentRec_\n+  {\n+    FT_Byte*  svg_document;\n+    FT_ULong  svg_document_length;\n+\n+    FT_Size_Metrics  metrics;\n+    FT_UShort        units_per_EM;\n+\n+    FT_UShort  start_glyph_id;\n+    FT_UShort  end_glyph_id;\n+\n+    FT_Matrix  transform;\n+    FT_Vector  delta;\n+\n+  } FT_SVG_DocumentRec;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @type:\n+   *   FT_SVG_Document\n+   *\n+   * @description:\n+   *   A handle to an @FT_SVG_DocumentRec object.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct FT_SVG_DocumentRec_*  FT_SVG_Document;\n+\n+\n+FT_END_HEADER\n+\n+#endif \/* OTSVG_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/otsvg.h","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -272,58 +272,0 @@\n-  \/* maximum number of Multiple Masters designs, as defined in the spec *\/\n-#define T1_MAX_MM_DESIGNS     16\n-\n-  \/* maximum number of Multiple Masters axes, as defined in the spec *\/\n-#define T1_MAX_MM_AXIS        4\n-\n-  \/* maximum number of elements in a design map *\/\n-#define T1_MAX_MM_MAP_POINTS  20\n-\n-\n-  \/* this structure is used to store the BlendDesignMap entry for an axis *\/\n-  typedef struct  PS_DesignMap_\n-  {\n-    FT_Byte    num_points;\n-    FT_Long*   design_points;\n-    FT_Fixed*  blend_points;\n-\n-  } PS_DesignMapRec, *PS_DesignMap;\n-\n-  \/* backward compatible definition *\/\n-  typedef PS_DesignMapRec  T1_DesignMap;\n-\n-\n-  typedef struct  PS_BlendRec_\n-  {\n-    FT_UInt          num_designs;\n-    FT_UInt          num_axis;\n-\n-    FT_String*       axis_names[T1_MAX_MM_AXIS];\n-    FT_Fixed*        design_pos[T1_MAX_MM_DESIGNS];\n-    PS_DesignMapRec  design_map[T1_MAX_MM_AXIS];\n-\n-    FT_Fixed*        weight_vector;\n-    FT_Fixed*        default_weight_vector;\n-\n-    PS_FontInfo      font_infos[T1_MAX_MM_DESIGNS + 1];\n-    PS_Private       privates  [T1_MAX_MM_DESIGNS + 1];\n-\n-    FT_ULong         blend_bitflags;\n-\n-    FT_BBox*         bboxes    [T1_MAX_MM_DESIGNS + 1];\n-\n-    \/* since 2.3.0 *\/\n-\n-    \/* undocumented, optional: the default design instance;   *\/\n-    \/* corresponds to default_weight_vector --                *\/\n-    \/* num_default_design_vector == 0 means it is not present *\/\n-    \/* in the font and associated metrics files               *\/\n-    FT_UInt          default_design_vector[T1_MAX_MM_DESIGNS];\n-    FT_UInt          num_default_design_vector;\n-\n-  } PS_BlendRec, *PS_Blend;\n-\n-\n-  \/* backward compatible definition *\/\n-  typedef PS_BlendRec  T1_Blend;\n-\n-\n@@ -363,1 +305,1 @@\n-    FT_Int         sd_bytes;\n+    FT_UInt        sd_bytes;\n@@ -418,2 +360,2 @@\n-    FT_Int          fd_bytes;\n-    FT_Int          gd_bytes;\n+    FT_UInt         fd_bytes;\n+    FT_UInt         gd_bytes;\n@@ -422,1 +364,1 @@\n-    FT_Int          num_dicts;\n+    FT_UInt         num_dicts;\n@@ -456,1 +398,1 @@\n-   *    FT_Has_PS_Glyph_Names\n+   *   FT_Has_PS_Glyph_Names\n@@ -459,3 +401,3 @@\n-   *    Return true if a given face provides reliable PostScript glyph names.\n-   *    This is similar to using the @FT_HAS_GLYPH_NAMES macro, except that\n-   *    certain fonts (mostly TrueType) contain incorrect glyph name tables.\n+   *   Return true if a given face provides reliable PostScript glyph names.\n+   *   This is similar to using the @FT_HAS_GLYPH_NAMES macro, except that\n+   *   certain fonts (mostly TrueType) contain incorrect glyph name tables.\n@@ -463,2 +405,2 @@\n-   *    When this function returns true, the caller is sure that the glyph\n-   *    names returned by @FT_Get_Glyph_Name are reliable.\n+   *   When this function returns true, the caller is sure that the glyph\n+   *   names returned by @FT_Get_Glyph_Name are reliable.\n@@ -467,2 +409,2 @@\n-   *    face ::\n-   *      face handle\n+   *   face ::\n+   *     face handle\n@@ -471,1 +413,1 @@\n-   *    Boolean.  True if glyph names are reliable.\n+   *   Boolean.  True if glyph names are reliable.\n@@ -481,1 +423,1 @@\n-   *    FT_Get_PS_Font_Info\n+   *   FT_Get_PS_Font_Info\n@@ -484,2 +426,2 @@\n-   *    Retrieve the @PS_FontInfoRec structure corresponding to a given\n-   *    PostScript font.\n+   *   Retrieve the @PS_FontInfoRec structure corresponding to a given\n+   *   PostScript font.\n@@ -488,2 +430,2 @@\n-   *    face ::\n-   *      PostScript face handle.\n+   *   face ::\n+   *     PostScript face handle.\n@@ -492,2 +434,2 @@\n-   *    afont_info ::\n-   *      Output font info structure pointer.\n+   *   afont_info ::\n+   *     A pointer to a @PS_FontInfoRec object.\n@@ -496,1 +438,1 @@\n-   *    FreeType error code.  0~means success.\n+   *   FreeType error code.  0~means success.\n@@ -499,3 +441,7 @@\n-   *    String pointers within the @PS_FontInfoRec structure are owned by the\n-   *    face and don't need to be freed by the caller.  Missing entries in\n-   *    the font's FontInfo dictionary are represented by `NULL` pointers.\n+   *   String pointers within the @PS_FontInfoRec structure are owned by the\n+   *   face and don't need to be freed by the caller.  Missing entries in the\n+   *   font's FontInfo dictionary are represented by `NULL` pointers.\n+   *\n+   *   The following font formats support this feature: 'Type~1', 'Type~42',\n+   *   'CFF', 'CID~Type~1'.  For other font formats this function returns the\n+   *   `FT_Err_Invalid_Argument` error code.\n@@ -503,2 +449,8 @@\n-   *    If the font's format is not PostScript-based, this function will\n-   *    return the `FT_Err_Invalid_Argument` error code.\n+   * @example:\n+   *   ```\n+   *     PS_FontInfoRec  font_info;\n+   *\n+   *\n+   *     error = FT_Get_PS_Font_Info( face, &font_info );\n+   *     ...\n+   *   ```\n@@ -515,1 +467,1 @@\n-   *    FT_Get_PS_Font_Private\n+   *   FT_Get_PS_Font_Private\n@@ -518,2 +470,2 @@\n-   *    Retrieve the @PS_PrivateRec structure corresponding to a given\n-   *    PostScript font.\n+   *   Retrieve the @PS_PrivateRec structure corresponding to a given\n+   *   PostScript font.\n@@ -522,2 +474,2 @@\n-   *    face ::\n-   *      PostScript face handle.\n+   *   face ::\n+   *     PostScript face handle.\n@@ -526,2 +478,2 @@\n-   *    afont_private ::\n-   *      Output private dictionary structure pointer.\n+   *   afont_private ::\n+   *     A pointer to a @PS_PrivateRec object.\n@@ -530,1 +482,1 @@\n-   *    FreeType error code.  0~means success.\n+   *   FreeType error code.  0~means success.\n@@ -533,2 +485,6 @@\n-   *    The string pointers within the @PS_PrivateRec structure are owned by\n-   *    the face and don't need to be freed by the caller.\n+   *   The string pointers within the @PS_PrivateRec structure are owned by\n+   *   the face and don't need to be freed by the caller.\n+   *\n+   *   Only the 'Type~1' font format supports this feature.  For other font\n+   *   formats this function returns the `FT_Err_Invalid_Argument` error\n+   *   code.\n@@ -536,2 +492,8 @@\n-   *    If the font's format is not PostScript-based, this function returns\n-   *    the `FT_Err_Invalid_Argument` error code.\n+   * @example:\n+   *   ```\n+   *     PS_PrivateRec  font_private;\n+   *\n+   *\n+   *     error = FT_Get_PS_Font_Private( face, &font_private );\n+   *     ...\n+   *   ```\n@@ -696,1 +658,1 @@\n-   *    FT_Get_PS_Font_Value\n+   *   FT_Get_PS_Font_Value\n@@ -699,1 +661,1 @@\n-   *    Retrieve the value for the supplied key from a PostScript font.\n+   *   Retrieve the value for the supplied key from a PostScript font.\n@@ -702,2 +664,2 @@\n-   *    face ::\n-   *      PostScript face handle.\n+   *   face ::\n+   *     PostScript face handle.\n@@ -705,2 +667,2 @@\n-   *    key ::\n-   *      An enumeration value representing the dictionary key to retrieve.\n+   *   key ::\n+   *     An enumeration value representing the dictionary key to retrieve.\n@@ -708,2 +670,2 @@\n-   *    idx ::\n-   *      For array values, this specifies the index to be returned.\n+   *   idx ::\n+   *     For array values, this specifies the index to be returned.\n@@ -711,2 +673,2 @@\n-   *    value ::\n-   *      A pointer to memory into which to write the value.\n+   *   value ::\n+   *     A pointer to memory into which to write the value.\n@@ -714,2 +676,2 @@\n-   *    valen_len ::\n-   *      The size, in bytes, of the memory supplied for the value.\n+   *   valen_len ::\n+   *     The size, in bytes, of the memory supplied for the value.\n@@ -718,2 +680,2 @@\n-   *    value ::\n-   *      The value matching the above key, if it exists.\n+   *   value ::\n+   *     The value matching the above key, if it exists.\n@@ -722,2 +684,2 @@\n-   *    The amount of memory (in bytes) required to hold the requested value\n-   *    (if it exists, -1 otherwise).\n+   *   The amount of memory (in bytes) required to hold the requested value\n+   *   (if it exists, -1 otherwise).\n@@ -726,5 +688,5 @@\n-   *    The values returned are not pointers into the internal structures of\n-   *    the face, but are 'fresh' copies, so that the memory containing them\n-   *    belongs to the calling application.  This also enforces the\n-   *    'read-only' nature of these values, i.e., this function cannot be\n-   *    used to manipulate the face.\n+   *   The values returned are not pointers into the internal structures of\n+   *   the face, but are 'fresh' copies, so that the memory containing them\n+   *   belongs to the calling application.  This also enforces the\n+   *   'read-only' nature of these values, i.e., this function cannot be\n+   *   used to manipulate the face.\n@@ -732,2 +694,2 @@\n-   *    `value` is a void pointer because the values returned can be of\n-   *    various types.\n+   *   `value` is a void pointer because the values returned can be of\n+   *   various types.\n@@ -735,2 +697,2 @@\n-   *    If either `value` is `NULL` or `value_len` is too small, just the\n-   *    required memory size for the requested entry is returned.\n+   *   If either `value` is `NULL` or `value_len` is too small, just the\n+   *   required memory size for the requested entry is returned.\n@@ -738,4 +700,4 @@\n-   *    The `idx` parameter is used, not only to retrieve elements of, for\n-   *    example, the FontMatrix or FontBBox, but also to retrieve name keys\n-   *    from the CharStrings dictionary, and the charstrings themselves.  It\n-   *    is ignored for atomic values.\n+   *   The `idx` parameter is used, not only to retrieve elements of, for\n+   *   example, the FontMatrix or FontBBox, but also to retrieve name keys\n+   *   from the CharStrings dictionary, and the charstrings themselves.  It\n+   *   is ignored for atomic values.\n@@ -743,3 +705,3 @@\n-   *    `PS_DICT_BLUE_SCALE` returns a value that is scaled up by 1000.  To\n-   *    get the value as in the font stream, you need to divide by 65536000.0\n-   *    (to remove the FT_Fixed scale, and the x1000 scale).\n+   *   `PS_DICT_BLUE_SCALE` returns a value that is scaled up by 1000.  To\n+   *   get the value as in the font stream, you need to divide by 65536000.0\n+   *   (to remove the FT_Fixed scale, and the x1000 scale).\n@@ -747,4 +709,4 @@\n-   *    IMPORTANT: Only key\/value pairs read by the FreeType interpreter can\n-   *    be retrieved.  So, for example, PostScript procedures such as NP, ND,\n-   *    and RD are not available.  Arbitrary keys are, obviously, not be\n-   *    available either.\n+   *   IMPORTANT: Only key\/value pairs read by the FreeType interpreter can\n+   *   be retrieved.  So, for example, PostScript procedures such as NP, ND,\n+   *   and RD are not available.  Arbitrary keys are, obviously, not be\n+   *   available either.\n@@ -752,2 +714,2 @@\n-   *    If the font's format is not PostScript-based, this function returns\n-   *    the `FT_Err_Invalid_Argument` error code.\n+   *   If the font's format is not PostScript-based, this function returns\n+   *   the `FT_Err_Invalid_Argument` error code.\n@@ -756,1 +718,1 @@\n-   *    2.4.8\n+   *   2.4.8\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/t1tables.h","additions":98,"deletions":136,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -594,1 +594,1 @@\n-#define TT_MS_LANGID_KYRGYZ_KYRGYZSTAN \/* Cyrillic*\/   0x0440\n+#define TT_MS_LANGID_KYRGYZ_KYRGYZSTAN \/* Cyrillic *\/  0x0440\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/ttnameid.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -427,2 +427,2 @@\n-    FT_UShort  usLowerOpticalPointSize;       \/* in twips (1\/20th points) *\/\n-    FT_UShort  usUpperOpticalPointSize;       \/* in twips (1\/20th points) *\/\n+    FT_UShort  usLowerOpticalPointSize;       \/* in twips (1\/20 points) *\/\n+    FT_UShort  usUpperOpticalPointSize;       \/* in twips (1\/20 points) *\/\n@@ -841,2 +841,3 @@\n-   *   The format of `charmap`.  If `charmap` doesn't belong to an SFNT face,\n-   *   return -1.\n+   *   The format of `charmap`.  If `charmap` doesn't belong to an SFNT face\n+   *   (including the synthetic Unicode charmap sometimes created by\n+   *   FreeType), return -1.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/tttables.h","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -98,0 +98,1 @@\n+#define TTAG_SVG   FT_MAKE_TAG( 'S', 'V', 'G', ' ' )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/freetype\/tttags.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/include\/ft2build.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,285 +0,0 @@\n-\/****************************************************************************\n- *\n- * afangles.c\n- *\n- *   Routines used to compute vector angles with limited accuracy\n- *   and very high speed.  It also contains sorting routines (body).\n- *\n- * Copyright (C) 2003-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-#include \"aftypes.h\"\n-\n-\n-  \/*\n-   * We are not using `af_angle_atan' anymore, but we keep the source\n-   * code below just in case...\n-   *\/\n-\n-\n-#if 0\n-\n-\n-  \/*\n-   * The trick here is to realize that we don't need a very accurate angle\n-   * approximation.  We are going to use the result of `af_angle_atan' to\n-   * only compare the sign of angle differences, or check whether its\n-   * magnitude is very small.\n-   *\n-   * The approximation\n-   *\n-   *   dy * PI \/ (|dx|+|dy|)\n-   *\n-   * should be enough, and much faster to compute.\n-   *\/\n-  FT_LOCAL_DEF( AF_Angle )\n-  af_angle_atan( FT_Fixed  dx,\n-                 FT_Fixed  dy )\n-  {\n-    AF_Angle  angle;\n-    FT_Fixed  ax = dx;\n-    FT_Fixed  ay = dy;\n-\n-\n-    if ( ax < 0 )\n-      ax = -ax;\n-    if ( ay < 0 )\n-      ay = -ay;\n-\n-    ax += ay;\n-\n-    if ( ax == 0 )\n-      angle = 0;\n-    else\n-    {\n-      angle = ( AF_ANGLE_PI2 * dy ) \/ ( ax + ay );\n-      if ( dx < 0 )\n-      {\n-        if ( angle >= 0 )\n-          angle = AF_ANGLE_PI - angle;\n-        else\n-          angle = -AF_ANGLE_PI - angle;\n-      }\n-    }\n-\n-    return angle;\n-  }\n-\n-\n-#elif 0\n-\n-\n-  \/* the following table has been automatically generated with *\/\n-  \/* the `mather.py' Python script                             *\/\n-\n-#define AF_ATAN_BITS  8\n-\n-  static const FT_Byte  af_arctan[1L << AF_ATAN_BITS] =\n-  {\n-     0,  0,  1,  1,  1,  2,  2,  2,\n-     3,  3,  3,  3,  4,  4,  4,  5,\n-     5,  5,  6,  6,  6,  7,  7,  7,\n-     8,  8,  8,  9,  9,  9, 10, 10,\n-    10, 10, 11, 11, 11, 12, 12, 12,\n-    13, 13, 13, 14, 14, 14, 14, 15,\n-    15, 15, 16, 16, 16, 17, 17, 17,\n-    18, 18, 18, 18, 19, 19, 19, 20,\n-    20, 20, 21, 21, 21, 21, 22, 22,\n-    22, 23, 23, 23, 24, 24, 24, 24,\n-    25, 25, 25, 26, 26, 26, 26, 27,\n-    27, 27, 28, 28, 28, 28, 29, 29,\n-    29, 30, 30, 30, 30, 31, 31, 31,\n-    31, 32, 32, 32, 33, 33, 33, 33,\n-    34, 34, 34, 34, 35, 35, 35, 35,\n-    36, 36, 36, 36, 37, 37, 37, 38,\n-    38, 38, 38, 39, 39, 39, 39, 40,\n-    40, 40, 40, 41, 41, 41, 41, 42,\n-    42, 42, 42, 42, 43, 43, 43, 43,\n-    44, 44, 44, 44, 45, 45, 45, 45,\n-    46, 46, 46, 46, 46, 47, 47, 47,\n-    47, 48, 48, 48, 48, 48, 49, 49,\n-    49, 49, 50, 50, 50, 50, 50, 51,\n-    51, 51, 51, 51, 52, 52, 52, 52,\n-    52, 53, 53, 53, 53, 53, 54, 54,\n-    54, 54, 54, 55, 55, 55, 55, 55,\n-    56, 56, 56, 56, 56, 57, 57, 57,\n-    57, 57, 57, 58, 58, 58, 58, 58,\n-    59, 59, 59, 59, 59, 59, 60, 60,\n-    60, 60, 60, 61, 61, 61, 61, 61,\n-    61, 62, 62, 62, 62, 62, 62, 63,\n-    63, 63, 63, 63, 63, 64, 64, 64\n-  };\n-\n-\n-  FT_LOCAL_DEF( AF_Angle )\n-  af_angle_atan( FT_Fixed  dx,\n-                 FT_Fixed  dy )\n-  {\n-    AF_Angle  angle;\n-\n-\n-    \/* check trivial cases *\/\n-    if ( dy == 0 )\n-    {\n-      angle = 0;\n-      if ( dx < 0 )\n-        angle = AF_ANGLE_PI;\n-      return angle;\n-    }\n-    else if ( dx == 0 )\n-    {\n-      angle = AF_ANGLE_PI2;\n-      if ( dy < 0 )\n-        angle = -AF_ANGLE_PI2;\n-      return angle;\n-    }\n-\n-    angle = 0;\n-    if ( dx < 0 )\n-    {\n-      dx = -dx;\n-      dy = -dy;\n-      angle = AF_ANGLE_PI;\n-    }\n-\n-    if ( dy < 0 )\n-    {\n-      FT_Pos  tmp;\n-\n-\n-      tmp = dx;\n-      dx  = -dy;\n-      dy  = tmp;\n-      angle -= AF_ANGLE_PI2;\n-    }\n-\n-    if ( dx == 0 && dy == 0 )\n-      return 0;\n-\n-    if ( dx == dy )\n-      angle += AF_ANGLE_PI4;\n-    else if ( dx > dy )\n-      angle += af_arctan[FT_DivFix( dy, dx ) >> ( 16 - AF_ATAN_BITS )];\n-    else\n-      angle += AF_ANGLE_PI2 -\n-               af_arctan[FT_DivFix( dx, dy ) >> ( 16 - AF_ATAN_BITS )];\n-\n-    if ( angle > AF_ANGLE_PI )\n-      angle -= AF_ANGLE_2PI;\n-\n-    return angle;\n-  }\n-\n-\n-#endif \/* 0 *\/\n-\n-\n-  FT_LOCAL_DEF( void )\n-  af_sort_pos( FT_UInt  count,\n-               FT_Pos*  table )\n-  {\n-    FT_UInt  i, j;\n-    FT_Pos   swap;\n-\n-\n-    for ( i = 1; i < count; i++ )\n-    {\n-      for ( j = i; j > 0; j-- )\n-      {\n-        if ( table[j] >= table[j - 1] )\n-          break;\n-\n-        swap         = table[j];\n-        table[j]     = table[j - 1];\n-        table[j - 1] = swap;\n-      }\n-    }\n-  }\n-\n-\n-  FT_LOCAL_DEF( void )\n-  af_sort_and_quantize_widths( FT_UInt*  count,\n-                               AF_Width  table,\n-                               FT_Pos    threshold )\n-  {\n-    FT_UInt      i, j;\n-    FT_UInt      cur_idx;\n-    FT_Pos       cur_val;\n-    FT_Pos       sum;\n-    AF_WidthRec  swap;\n-\n-\n-    if ( *count == 1 )\n-      return;\n-\n-    \/* sort *\/\n-    for ( i = 1; i < *count; i++ )\n-    {\n-      for ( j = i; j > 0; j-- )\n-      {\n-        if ( table[j].org >= table[j - 1].org )\n-          break;\n-\n-        swap         = table[j];\n-        table[j]     = table[j - 1];\n-        table[j - 1] = swap;\n-      }\n-    }\n-\n-    cur_idx = 0;\n-    cur_val = table[cur_idx].org;\n-\n-    \/* compute and use mean values for clusters not larger than  *\/\n-    \/* `threshold'; this is very primitive and might not yield   *\/\n-    \/* the best result, but normally, using reference character  *\/\n-    \/* `o', `*count' is 2, so the code below is fully sufficient *\/\n-    for ( i = 1; i < *count; i++ )\n-    {\n-      if ( table[i].org - cur_val > threshold ||\n-           i == *count - 1                    )\n-      {\n-        sum = 0;\n-\n-        \/* fix loop for end of array *\/\n-        if ( table[i].org - cur_val <= threshold &&\n-             i == *count - 1                     )\n-          i++;\n-\n-        for ( j = cur_idx; j < i; j++ )\n-        {\n-          sum         += table[j].org;\n-          table[j].org = 0;\n-        }\n-        table[cur_idx].org = sum \/ (FT_Pos)j;\n-\n-        if ( i < *count - 1 )\n-        {\n-          cur_idx = i + 1;\n-          cur_val = table[cur_idx].org;\n-        }\n-      }\n-    }\n-\n-    cur_idx = 1;\n-\n-    \/* compress array to remove zero values *\/\n-    for ( i = 1; i < *count; i++ )\n-    {\n-      if ( table[i].org )\n-        table[cur_idx++] = table[i];\n-    }\n-\n-    *count = cur_idx;\n-  }\n-\n-\n-\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afangles.c","additions":0,"deletions":285,"binary":false,"changes":285,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-\/*\n- * afangles.h\n- *\n- * This is a dummy file, used to please the build system.  It is never\n- * included by the auto-fitter sources.\n- *\n- *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afangles.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.cin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-\/\/ Copyright (C) 2013-2020 by\n+\/\/ Copyright (C) 2013-2024 by\n@@ -92,1 +92,1 @@\n-  \/\/ guaranteed to have the same vertical position with joining (this is,\n+  \/\/ guaranteed to have the same vertical position with joining (that is,\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.dat","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afblue.hin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n@@ -40,5 +40,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-#include \"afwarp.h\"\n-#endif\n-\n-\n@@ -75,4 +70,2 @@\n-    FT_TRACE5(( \"\\n\"\n-                \"cjk standard widths computation (style `%s')\\n\"\n-                \"===================================================\\n\"\n-                \"\\n\",\n+    FT_TRACE5(( \"\\n\" ));\n+    FT_TRACE5(( \"cjk standard widths computation (style `%s')\\n\",\n@@ -80,0 +73,2 @@\n+    FT_TRACE5(( \"===================================================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -317,3 +312,3 @@\n-    FT_TRACE5(( \"cjk blue zones computation\\n\"\n-                \"==========================\\n\"\n-                \"\\n\" ));\n+    FT_TRACE5(( \"cjk blue zones computation\\n\" ));\n+    FT_TRACE5(( \"==========================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -425,2 +420,1 @@\n-          FT_Int  first = 0;\n-          FT_Int  last  = -1;\n+          FT_Int  pp, first, last;\n@@ -429,1 +423,2 @@\n-          for ( nn = 0; nn < outline.n_contours; first = last + 1, nn++ )\n+          last = -1;\n+          for ( nn = 0; nn < outline.n_contours; nn++ )\n@@ -431,4 +426,2 @@\n-            FT_Int  pp;\n-\n-\n-            last = outline.contours[nn];\n+            first = last + 1;\n+            last  = outline.contours[nn];\n@@ -558,3 +551,2 @@\n-      FT_TRACE5(( \"    -> reference = %ld\\n\"\n-                  \"       overshoot = %ld\\n\",\n-                  *blue_ref, *blue_shoot ));\n+      FT_TRACE5(( \"    -> reference = %ld\\n\", *blue_ref ));\n+      FT_TRACE5(( \"       overshoot = %ld\\n\", *blue_shoot ));\n@@ -578,2 +570,2 @@\n-    FT_Bool   started = 0, same_width = 1;\n-    FT_Fixed  advance = 0, old_advance = 0;\n+    FT_Bool  started = 0, same_width = 1;\n+    FT_Long  advance = 0, old_advance = 0;\n@@ -644,2 +636,2 @@\n-  af_cjk_metrics_init( AF_CJKMetrics  metrics,\n-                       FT_Face        face )\n+  af_cjk_metrics_init( AF_StyleMetrics  metrics_,  \/* AF_CJKMetrics *\/\n+                       FT_Face          face )\n@@ -647,1 +639,2 @@\n-    FT_CharMap  oldmap = face->charmap;\n+    AF_CJKMetrics  metrics = (AF_CJKMetrics)metrics_;\n+    FT_CharMap     oldmap  = face->charmap;\n@@ -659,1 +652,1 @@\n-    FT_Set_Charmap( face, oldmap );\n+    face->charmap = oldmap;\n@@ -746,3 +739,1 @@\n-        FT_TRACE5(( \">> active cjk blue zone %c%d[%ld\/%ld]:\\n\"\n-                    \"     ref:   cur=%.2f fit=%.2f\\n\"\n-                    \"     shoot: cur=%.2f fit=%.2f\\n\",\n+        FT_TRACE5(( \">> active cjk blue zone %c%d[%ld\/%ld]:\\n\",\n@@ -750,3 +741,7 @@\n-                    nn, blue->ref.org, blue->shoot.org,\n-                    blue->ref.cur \/ 64.0, blue->ref.fit \/ 64.0,\n-                    blue->shoot.cur \/ 64.0, blue->shoot.fit \/ 64.0 ));\n+                    nn, blue->ref.org, blue->shoot.org ));\n+        FT_TRACE5(( \"     ref:   cur=%.2f fit=%.2f\\n\",\n+                    (double)blue->ref.cur \/ 64,\n+                    (double)blue->ref.fit \/ 64 ));\n+        FT_TRACE5(( \"     shoot: cur=%.2f fit=%.2f\\n\",\n+                    (double)blue->shoot.cur \/ 64,\n+                    (double)blue->shoot.fit \/ 64 ));\n@@ -763,2 +758,2 @@\n-  af_cjk_metrics_scale( AF_CJKMetrics  metrics,\n-                        AF_Scaler      scaler )\n+  af_cjk_metrics_scale( AF_StyleMetrics  metrics_,   \/* AF_CJKMetrics *\/\n+                        AF_Scaler        scaler )\n@@ -766,0 +761,3 @@\n+    AF_CJKMetrics  metrics = (AF_CJKMetrics)metrics_;\n+\n+\n@@ -778,4 +776,4 @@\n-  FT_LOCAL_DEF( void )\n-  af_cjk_get_standard_widths( AF_CJKMetrics  metrics,\n-                              FT_Pos*        stdHW,\n-                              FT_Pos*        stdVW )\n+  FT_CALLBACK_DEF( void )\n+  af_cjk_get_standard_widths( AF_StyleMetrics  metrics_,  \/* AF_CJKMetrics *\/\n+                              FT_Pos*          stdHW,\n+                              FT_Pos*          stdVW )\n@@ -783,0 +781,3 @@\n+    AF_CJKMetrics  metrics = (AF_CJKMetrics)metrics_;\n+\n+\n@@ -852,1 +853,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -1014,1 +1015,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -1053,1 +1054,1 @@\n-      FT_Int   ee;\n+      FT_UInt  ee;\n@@ -1162,1 +1163,1 @@\n-      AF_Edge  edge_limit = edges + axis->num_edges;\n+      AF_Edge  edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -1300,1 +1301,1 @@\n-    AF_Edge       edge_limit = edge + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edge, axis->num_edges );\n@@ -1383,2 +1384,2 @@\n-  af_cjk_hints_init( AF_GlyphHints  hints,\n-                     AF_CJKMetrics  metrics )\n+  af_cjk_hints_init( AF_GlyphHints    hints,\n+                     AF_StyleMetrics  metrics_ )   \/* AF_CJKMetrics *\/\n@@ -1386,0 +1387,1 @@\n+    AF_CJKMetrics   metrics = (AF_CJKMetrics)metrics_;\n@@ -1404,5 +1406,0 @@\n-#if 0 \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )\n-      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;\n-#endif\n-\n@@ -1437,6 +1434,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    \/* get (global) warper flag *\/\n-    if ( !metrics->root.globals->module->warping )\n-      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;\n-#endif\n-\n@@ -1646,1 +1637,1 @@\n-    FT_TRACE5(( \"  CJKLINK: edge %ld @%d (opos=%.2f) linked to %.2f,\"\n+    FT_TRACE5(( \"  CJKLINK: edge %td @%d (opos=%.2f) linked to %.2f,\"\n@@ -1649,2 +1640,4 @@\n-                stem_edge->opos \/ 64.0, stem_edge->pos \/ 64.0,\n-                dist \/ 64.0, fitted_width \/ 64.0 ));\n+                (double)stem_edge->opos \/ 64,\n+                (double)stem_edge->pos \/ 64,\n+                (double)dist \/ 64,\n+                (double)fitted_width \/ 64 ));\n@@ -1818,1 +1811,1 @@\n-    AF_Edge       edge_limit = edges + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -1868,1 +1861,1 @@\n-        FT_TRACE5(( \"  CJKBLUE: edge %ld @%d (opos=%.2f) snapped to %.2f,\"\n+        FT_TRACE5(( \"  CJKBLUE: edge %td @%d (opos=%.2f) snapped to %.2f,\"\n@@ -1870,2 +1863,2 @@\n-                    edge1 - edges, edge1->fpos, edge1->opos \/ 64.0,\n-                    blue->fit \/ 64.0, edge1->pos \/ 64.0 ));\n+                    edge1 - edges, edge1->fpos, (double)edge1->opos \/ 64,\n+                    (double)blue->fit \/ 64, (double)edge1->pos \/ 64 ));\n@@ -1932,1 +1925,1 @@\n-        FT_TRACE5(( \"ASSERTION FAILED for edge %ld\\n\", edge2-edges ));\n+        FT_TRACE5(( \"ASSERTION FAILED for edge %td\\n\", edge2 - edges ));\n@@ -2044,2 +2037,2 @@\n-               ( edge->pos - edge->opos ) \/ 64.0,\n-               ( edge2->pos - edge2->opos ) \/ 64.0 );\n+               (double)( edge->pos - edge->opos ) \/ 64,\n+               (double)( edge2->pos - edge2->opos ) \/ 64 );\n@@ -2197,1 +2190,1 @@\n-    AF_Edge       edge_limit = edges + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -2284,4 +2277,4 @@\n-  af_cjk_hints_apply( FT_UInt        glyph_index,\n-                      AF_GlyphHints  hints,\n-                      FT_Outline*    outline,\n-                      AF_CJKMetrics  metrics )\n+  af_cjk_hints_apply( FT_UInt          glyph_index,\n+                      AF_GlyphHints    hints,\n+                      FT_Outline*      outline,\n+                      AF_StyleMetrics  metrics_ )   \/* AF_CJKMetrics *\/\n@@ -2289,0 +2282,2 @@\n+    AF_CJKMetrics  metrics = (AF_CJKMetrics)metrics_;\n+\n@@ -2325,19 +2320,0 @@\n-\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-        if ( dim == AF_DIMENSION_HORZ                                  &&\n-             metrics->root.scaler.render_mode == FT_RENDER_MODE_NORMAL &&\n-             AF_HINTS_DO_WARP( hints )                                 )\n-        {\n-          AF_WarperRec  warper;\n-          FT_Fixed      scale;\n-          FT_Pos        delta;\n-\n-\n-          af_warper_compute( &warper, hints, (AF_Dimension)dim,\n-                             &scale, &delta );\n-          af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,\n-                                    scale, delta );\n-          continue;\n-        }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afcjk.c","additions":69,"deletions":93,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n@@ -87,1 +87,1 @@\n-    AF_CJKBlueRec  blues[AF_BLUE_STRINGSET_MAX];\n+    AF_CJKBlueRec  blues[AF_BLUE_STRINGSET_MAX_LEN];\n@@ -106,2 +106,2 @@\n-  af_cjk_metrics_init( AF_CJKMetrics  metrics,\n-                       FT_Face        face );\n+  af_cjk_metrics_init( AF_StyleMetrics  metrics,\n+                       FT_Face          face );\n@@ -110,2 +110,2 @@\n-  af_cjk_metrics_scale( AF_CJKMetrics  metrics,\n-                        AF_Scaler      scaler );\n+  af_cjk_metrics_scale( AF_StyleMetrics  metrics,\n+                        AF_Scaler        scaler );\n@@ -114,2 +114,2 @@\n-  af_cjk_hints_init( AF_GlyphHints  hints,\n-                     AF_CJKMetrics  metrics );\n+  af_cjk_hints_init( AF_GlyphHints    hints,\n+                     AF_StyleMetrics  metrics );\n@@ -118,4 +118,4 @@\n-  af_cjk_hints_apply( FT_UInt        glyph_index,\n-                      AF_GlyphHints  hints,\n-                      FT_Outline*    outline,\n-                      AF_CJKMetrics  metrics );\n+  af_cjk_hints_apply( FT_UInt          glyph_index,\n+                      AF_GlyphHints    hints,\n+                      FT_Outline*      outline,\n+                      AF_StyleMetrics  metrics );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afcjk.h","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afcover.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afdummy.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afdummy.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/aferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -22,0 +22,1 @@\n+#include \"afws-decl.h\"\n@@ -35,5 +36,0 @@\n-  \/* get writing system specific header files *\/\n-#undef  WRITING_SYSTEM\n-#define WRITING_SYSTEM( ws, WS )  \/* empty *\/\n-#include \"afwrtsys.h\"\n-\n@@ -77,1 +73,1 @@\n-#include \"afwrtsys.h\"\n+#include \"afws-iter.h\"\n@@ -136,1 +132,2 @@\n-    FT_UInt     ss;\n+    FT_UShort   ss;\n+    FT_UShort   dflt        = 0xFFFFU; \/* a non-valid value *\/\n@@ -138,1 +135,0 @@\n-    FT_UInt     dflt        = ~0U; \/* a non-valid value *\/\n@@ -142,1 +138,1 @@\n-    for ( i = 0; i < (FT_UInt)globals->glyph_count; i++ )\n+    for ( i = 0; i < globals->glyph_count; i++ )\n@@ -175,2 +171,1 @@\n-        if ( (FT_UInt)style_class->script ==\n-             globals->module->default_script )\n+        if ( style_class->script == globals->module->default_script )\n@@ -190,1 +185,1 @@\n-               gindex < (FT_ULong)globals->glyph_count                    &&\n+               gindex < globals->glyph_count                              &&\n@@ -192,1 +187,1 @@\n-            gstyles[gindex] = (FT_UShort)ss;\n+            gstyles[gindex] = ss;\n@@ -201,1 +196,1 @@\n-            if ( gindex < (FT_ULong)globals->glyph_count                    &&\n+            if ( gindex < globals->glyph_count                              &&\n@@ -203,1 +198,1 @@\n-              gstyles[gindex] = (FT_UShort)ss;\n+              gstyles[gindex] = ss;\n@@ -218,3 +213,3 @@\n-          if ( gindex != 0                                          &&\n-               gindex < (FT_ULong)globals->glyph_count              &&\n-               ( gstyles[gindex] & AF_STYLE_MASK ) == (FT_UShort)ss )\n+          if ( gindex != 0                               &&\n+               gindex < globals->glyph_count             &&\n+               ( gstyles[gindex] & AF_STYLE_MASK ) == ss )\n@@ -230,2 +225,2 @@\n-            if ( gindex < (FT_ULong)globals->glyph_count              &&\n-                 ( gstyles[gindex] & AF_STYLE_MASK ) == (FT_UShort)ss )\n+            if ( gindex < globals->glyph_count             &&\n+                 ( gstyles[gindex] & AF_STYLE_MASK ) == ss )\n@@ -262,1 +257,1 @@\n-      if ( gindex != 0 && gindex < (FT_ULong)globals->glyph_count )\n+      if ( gindex != 0 && gindex < globals->glyph_count )\n@@ -273,1 +268,1 @@\n-      FT_Long  nn;\n+      FT_UInt  nn;\n@@ -288,4 +283,4 @@\n-    FT_TRACE4(( \"\\n\"\n-                \"style coverage\\n\"\n-                \"==============\\n\"\n-                \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"style coverage\\n\" ));\n+    FT_TRACE4(( \"==============\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -297,1 +292,1 @@\n-      FT_Long        idx;\n+      FT_UInt        idx;\n@@ -309,1 +304,1 @@\n-          FT_TRACE4(( \" %ld\", idx ));\n+          FT_TRACE4(( \" %d\", idx ));\n@@ -325,1 +320,1 @@\n-    FT_Set_Charmap( face, old_charmap );\n+    face->charmap = old_charmap;\n@@ -344,3 +339,3 @@\n-    if ( FT_ALLOC( globals,\n-                   sizeof ( *globals ) +\n-                     (FT_ULong)face->num_glyphs * sizeof ( FT_UShort ) ) )\n+    if ( FT_QALLOC( globals,\n+                    sizeof ( *globals ) +\n+                      (FT_ULong)face->num_glyphs * sizeof ( FT_UShort ) ) )\n@@ -349,0 +344,2 @@\n+    FT_ZERO( &globals->metrics );\n+\n@@ -350,1 +347,1 @@\n-    globals->glyph_count               = face->num_glyphs;\n+    globals->glyph_count               = (FT_UInt)face->num_glyphs;\n@@ -362,1 +359,1 @@\n-    globals->hb_font = hb_ft_font_create( face, NULL );\n+    globals->hb_font = hb_ft_font_create_( face, NULL );\n@@ -382,1 +379,1 @@\n-  af_face_globals_free( AF_FaceGlobals  globals )\n+  af_face_globals_free( void*  globals_ )\n@@ -384,0 +381,3 @@\n+    AF_FaceGlobals  globals = (AF_FaceGlobals)globals_;\n+\n+\n@@ -434,1 +434,1 @@\n-    if ( gindex >= (FT_ULong)globals->glyph_count )\n+    if ( gindex >= globals->glyph_count )\n@@ -481,0 +481,4 @@\n+            \/* IMPORTANT: Clear the error code, see\n+             * https:\/\/gitlab.freedesktop.org\/freetype\/freetype\/-\/issues\/1063\n+             *\/\n+            error = FT_Err_Ok;\n@@ -502,1 +506,1 @@\n-    if ( gindex < (FT_ULong)globals->glyph_count )\n+    if ( gindex < globals->glyph_count )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afglobal.c","additions":42,"deletions":38,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -108,1 +108,1 @@\n-    FT_Long          glyph_count;    \/* same as face->num_glyphs *\/\n+    FT_UInt          glyph_count;    \/* unsigned face->num_glyphs *\/\n@@ -159,1 +159,1 @@\n-  af_face_globals_free( AF_FaceGlobals  globals );\n+  af_face_globals_free( void*  globals );\n@@ -161,1 +161,1 @@\n-  FT_LOCAL_DEF( FT_Bool )\n+  FT_LOCAL( FT_Bool )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afglobal.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -35,0 +35,98 @@\n+  FT_LOCAL_DEF( void )\n+  af_sort_pos( FT_UInt  count,\n+               FT_Pos*  table )\n+  {\n+    FT_UInt  i, j;\n+    FT_Pos   swap;\n+\n+\n+    for ( i = 1; i < count; i++ )\n+    {\n+      for ( j = i; j > 0; j-- )\n+      {\n+        if ( table[j] >= table[j - 1] )\n+          break;\n+\n+        swap         = table[j];\n+        table[j]     = table[j - 1];\n+        table[j - 1] = swap;\n+      }\n+    }\n+  }\n+\n+\n+  FT_LOCAL_DEF( void )\n+  af_sort_and_quantize_widths( FT_UInt*  count,\n+                               AF_Width  table,\n+                               FT_Pos    threshold )\n+  {\n+    FT_UInt      i, j;\n+    FT_UInt      cur_idx;\n+    FT_Pos       cur_val;\n+    FT_Pos       sum;\n+    AF_WidthRec  swap;\n+\n+\n+    if ( *count == 1 )\n+      return;\n+\n+    \/* sort *\/\n+    for ( i = 1; i < *count; i++ )\n+    {\n+      for ( j = i; j > 0; j-- )\n+      {\n+        if ( table[j].org >= table[j - 1].org )\n+          break;\n+\n+        swap         = table[j];\n+        table[j]     = table[j - 1];\n+        table[j - 1] = swap;\n+      }\n+    }\n+\n+    cur_idx = 0;\n+    cur_val = table[cur_idx].org;\n+\n+    \/* compute and use mean values for clusters not larger than  *\/\n+    \/* `threshold'; this is very primitive and might not yield   *\/\n+    \/* the best result, but normally, using reference character  *\/\n+    \/* `o', `*count' is 2, so the code below is fully sufficient *\/\n+    for ( i = 1; i < *count; i++ )\n+    {\n+      if ( table[i].org - cur_val > threshold ||\n+           i == *count - 1                    )\n+      {\n+        sum = 0;\n+\n+        \/* fix loop for end of array *\/\n+        if ( table[i].org - cur_val <= threshold &&\n+             i == *count - 1                     )\n+          i++;\n+\n+        for ( j = cur_idx; j < i; j++ )\n+        {\n+          sum         += table[j].org;\n+          table[j].org = 0;\n+        }\n+        table[cur_idx].org = sum \/ (FT_Pos)j;\n+\n+        if ( i < *count - 1 )\n+        {\n+          cur_idx = i + 1;\n+          cur_val = table[cur_idx].org;\n+        }\n+      }\n+    }\n+\n+    cur_idx = 1;\n+\n+    \/* compress array to remove zero values *\/\n+    for ( i = 1; i < *count; i++ )\n+    {\n+      if ( table[i].org )\n+        table[cur_idx++] = table[i];\n+    }\n+\n+    *count = cur_idx;\n+  }\n+\n@@ -56,3 +154,3 @@\n-      FT_Int  old_max = axis->max_segments;\n-      FT_Int  new_max = old_max;\n-      FT_Int  big_max = (FT_Int)( FT_INT_MAX \/ sizeof ( *segment ) );\n+      FT_UInt  old_max = axis->max_segments;\n+      FT_UInt  new_max = old_max;\n+      FT_UInt  big_max = FT_INT_MAX \/ sizeof ( *segment );\n@@ -98,1 +196,1 @@\n-  FT_LOCAL( FT_Error )\n+  FT_LOCAL_DEF( FT_Error )\n@@ -121,3 +219,3 @@\n-      FT_Int  old_max = axis->max_edges;\n-      FT_Int  new_max = old_max;\n-      FT_Int  big_max = (FT_Int)( FT_INT_MAX \/ sizeof ( *edge ) );\n+      FT_UInt  old_max = axis->max_edges;\n+      FT_UInt  new_max = old_max;\n+      FT_UInt  big_max = FT_INT_MAX \/ sizeof ( *edge );\n@@ -225,2 +323,3 @@\n-  af_print_idx( char* p,\n-                int   idx )\n+  af_print_idx( char*   p,\n+                size_t  n,\n+                int     idx )\n@@ -235,1 +334,1 @@\n-      ft_sprintf( p, \"%d\", idx );\n+      ft_snprintf( p, n, \"%d\", idx );\n@@ -362,1 +461,1 @@\n-                af_print_idx( buf1,\n+                af_print_idx( buf1, 16,\n@@ -364,2 +463,2 @@\n-                af_print_idx( buf2, segment_idx_1 ),\n-                af_print_idx( buf3,\n+                af_print_idx( buf2, 16, segment_idx_1 ),\n+                af_print_idx( buf3, 16,\n@@ -367,1 +466,1 @@\n-                af_print_idx( buf4, segment_idx_0 ),\n+                af_print_idx( buf4, 16, segment_idx_0 ),\n@@ -376,17 +475,21 @@\n-                point->ox \/ 64.0,\n-                point->oy \/ 64.0,\n-                point->x \/ 64.0,\n-                point->y \/ 64.0,\n-\n-                af_print_idx( buf5, af_get_strong_edge_index( hints,\n-                                                              point->before,\n-                                                              1 ) ),\n-                af_print_idx( buf6, af_get_strong_edge_index( hints,\n-                                                              point->after,\n-                                                              1 ) ),\n-                af_print_idx( buf7, af_get_strong_edge_index( hints,\n-                                                              point->before,\n-                                                              0 ) ),\n-                af_print_idx( buf8, af_get_strong_edge_index( hints,\n-                                                              point->after,\n-                                                              0 ) ) ));\n+                (double)point->ox \/ 64,\n+                (double)point->oy \/ 64,\n+                (double)point->x \/ 64,\n+                (double)point->y \/ 64,\n+\n+                af_print_idx( buf5, 16,\n+                              af_get_strong_edge_index( hints,\n+                                                        point->before,\n+                                                        1 ) ),\n+                af_print_idx( buf6, 16,\n+                              af_get_strong_edge_index( hints,\n+                                                        point->after,\n+                                                        1 ) ),\n+                af_print_idx( buf7, 16,\n+                              af_get_strong_edge_index( hints,\n+                                                        point->before,\n+                                                        0 ) ),\n+                af_print_idx( buf8, 16,\n+                              af_get_strong_edge_index( hints,\n+                                                        point->after,\n+                                                        0 ) ) ));\n@@ -479,3 +582,6 @@\n-                  af_print_idx( buf1, AF_INDEX_NUM( seg->link, segments ) ),\n-                  af_print_idx( buf2, AF_INDEX_NUM( seg->serif, segments ) ),\n-                  af_print_idx( buf3, AF_INDEX_NUM( seg->edge, edges ) ),\n+                  af_print_idx( buf1, 16,\n+                                AF_INDEX_NUM( seg->link, segments ) ),\n+                  af_print_idx( buf2, 16,\n+                                AF_INDEX_NUM( seg->serif, segments ) ),\n+                  af_print_idx( buf3, 16,\n+                                AF_INDEX_NUM( seg->edge, edges ) ),\n@@ -502,1 +608,1 @@\n-                                   FT_Int*        num_segments )\n+                                   FT_UInt*       num_segments )\n@@ -528,1 +634,1 @@\n-                                     FT_Int         idx,\n+                                     FT_UInt        idx,\n@@ -545,1 +651,1 @@\n-    if ( idx < 0 || idx >= axis->num_segments )\n+    if ( idx >= axis->num_segments )\n@@ -597,2 +703,2 @@\n-                  65536.0 * 64.0 \/ hints->x_scale,\n-                  10.0 * hints->x_scale \/ 65536.0 \/ 64.0 ));\n+                  65536 * 64 \/ (double)hints->x_scale,\n+                  10 * (double)hints->x_scale \/ 65536 \/ 64 ));\n@@ -602,2 +708,2 @@\n-                  65536.0 * 64.0 \/ hints->y_scale,\n-                  10.0 * hints->y_scale \/ 65536.0 \/ 64.0 ));\n+                  65536 * 64 \/ (double)hints->y_scale,\n+                  10 * (double)hints->y_scale \/ 65536 \/ 64 ));\n@@ -619,1 +725,1 @@\n-                  (int)edge->opos \/ 64.0,\n+                  (double)(int)edge->opos \/ 64,\n@@ -621,2 +727,4 @@\n-                  af_print_idx( buf1, AF_INDEX_NUM( edge->link, edges ) ),\n-                  af_print_idx( buf2, AF_INDEX_NUM( edge->serif, edges ) ),\n+                  af_print_idx( buf1, 16,\n+                                AF_INDEX_NUM( edge->link, edges ) ),\n+                  af_print_idx( buf2, 16,\n+                                AF_INDEX_NUM( edge->serif, edges ) ),\n@@ -625,2 +733,2 @@\n-                  edge->opos \/ 64.0,\n-                  edge->pos \/ 64.0,\n+                  (double)edge->opos \/ 64,\n+                  (double)edge->pos \/ 64,\n@@ -767,1 +875,1 @@\n-    FT_UInt    old_max, new_max;\n+    FT_Int     old_max, new_max;\n@@ -784,2 +892,2 @@\n-    new_max = (FT_UInt)outline->n_contours;\n-    old_max = (FT_UInt)hints->max_contours;\n+    new_max = outline->n_contours;\n+    old_max = hints->max_contours;\n@@ -800,1 +908,1 @@\n-      new_max = ( new_max + 3 ) & ~3U; \/* round up to a multiple of 4 *\/\n+      new_max = ( new_max + 3 ) & ~3; \/* round up to a multiple of 4 *\/\n@@ -805,1 +913,1 @@\n-      hints->max_contours = (FT_Int)new_max;\n+      hints->max_contours = new_max;\n@@ -813,2 +921,2 @@\n-    new_max = (FT_UInt)( outline->n_points + 2 );\n-    old_max = (FT_UInt)hints->max_points;\n+    new_max = outline->n_points + 2;\n+    old_max = hints->max_points;\n@@ -829,1 +937,1 @@\n-      new_max = ( new_max + 2 + 7 ) & ~7U; \/* round up to a multiple of 8 *\/\n+      new_max = ( new_max + 2 + 7 ) & ~7; \/* round up to a multiple of 8 *\/\n@@ -834,1 +942,1 @@\n-      hints->max_points = (FT_Int)new_max;\n+      hints->max_points = new_max;\n@@ -858,3 +966,0 @@\n-    hints->xmin_delta = 0;\n-    hints->xmax_delta = 0;\n-\n@@ -877,2 +982,2 @@\n-        char*       tag           = outline->tags;\n-        FT_Short    endpoint      = outline->contours[0];\n+        FT_Byte*    tag           = outline->tags;\n+        FT_UShort   endpoint      = outline->contours[0];\n@@ -944,4 +1049,4 @@\n-        AF_Point*  contour       = hints->contours;\n-        AF_Point*  contour_limit = contour + hints->num_contours;\n-        short*     end           = outline->contours;\n-        short      idx           = 0;\n+        AF_Point*   contour       = hints->contours;\n+        AF_Point*   contour_limit = contour + hints->num_contours;\n+        FT_UShort*  end           = outline->contours;\n+        FT_Int      idx           = 0;\n@@ -953,1 +1058,1 @@\n-          idx        = (short)( end[0] + 1 );\n+          idx        = *end + 1;\n@@ -1190,1 +1295,1 @@\n-    char*       tag   = outline->tags;\n+    FT_Byte*    tag   = outline->tags;\n@@ -1224,1 +1329,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -1301,1 +1406,1 @@\n-    AF_Edge       edge_limit  = edges + axis->num_edges;\n+    AF_Edge       edge_limit  = FT_OFFSET( edges, axis->num_edges );\n@@ -1691,29 +1796,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-\n-  \/* Apply (small) warp scale and warp delta for given dimension. *\/\n-\n-  FT_LOCAL_DEF( void )\n-  af_glyph_hints_scale_dim( AF_GlyphHints  hints,\n-                            AF_Dimension   dim,\n-                            FT_Fixed       scale,\n-                            FT_Pos         delta )\n-  {\n-    AF_Point  points       = hints->points;\n-    AF_Point  points_limit = points + hints->num_points;\n-    AF_Point  point;\n-\n-\n-    if ( dim == AF_DIMENSION_HORZ )\n-    {\n-      for ( point = points; point < points_limit; point++ )\n-        point->x = FT_MulFix( point->fx, scale ) + delta;\n-    }\n-    else\n-    {\n-      for ( point = points; point < points_limit; point++ )\n-        point->y = FT_MulFix( point->fy, scale ) + delta;\n-    }\n-  }\n-\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afhints.c","additions":174,"deletions":98,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -24,2 +24,0 @@\n-#define xxAF_SORT_SEGMENTS\n-\n@@ -313,2 +311,2 @@\n-    FT_Int        num_segments; \/* number of used segments      *\/\n-    FT_Int        max_segments; \/* number of allocated segments *\/\n+    FT_UInt       num_segments; \/* number of used segments      *\/\n+    FT_UInt       max_segments; \/* number of allocated segments *\/\n@@ -316,3 +314,0 @@\n-#ifdef AF_SORT_SEGMENTS\n-    FT_Int        mid_segments;\n-#endif\n@@ -320,2 +315,2 @@\n-    FT_Int        num_edges;    \/* number of used edges      *\/\n-    FT_Int        max_edges;    \/* number of allocated edges *\/\n+    FT_UInt       num_edges;    \/* number of used edges      *\/\n+    FT_UInt       max_edges;    \/* number of allocated edges *\/\n@@ -365,3 +360,0 @@\n-    FT_Pos           xmin_delta;    \/* used for warping *\/\n-    FT_Pos           xmax_delta;\n-\n@@ -386,1 +378,1 @@\n-          ( !_af_debug_disable_horz_hints                            && \\\n+          ( !af_debug_disable_horz_hints_                            && \\\n@@ -390,1 +382,1 @@\n-          ( !_af_debug_disable_vert_hints                          && \\\n+          ( !af_debug_disable_vert_hints_                          && \\\n@@ -393,1 +385,1 @@\n-#define AF_HINTS_DO_BLUES( h )  ( !_af_debug_disable_blue_hints )\n+#define AF_HINTS_DO_BLUES( h )  ( !af_debug_disable_blue_hints_ )\n@@ -411,4 +403,0 @@\n-#define AF_HINTS_DO_WARP( h )                                  \\\n-          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_WARPER )\n-\n-\n@@ -462,8 +450,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-  FT_LOCAL( void )\n-  af_glyph_hints_scale_dim( AF_GlyphHints  hints,\n-                            AF_Dimension   dim,\n-                            FT_Fixed       scale,\n-                            FT_Pos         delta );\n-#endif\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afhints.h","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n@@ -30,5 +30,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-#include \"afwarp.h\"\n-#endif\n-\n-\n@@ -36,2 +31,2 @@\n-  af_indic_metrics_init( AF_CJKMetrics  metrics,\n-                         FT_Face        face )\n+  af_indic_metrics_init( AF_StyleMetrics  metrics_, \/* AF_CJKMetrics *\/\n+                         FT_Face          face )\n@@ -39,0 +34,3 @@\n+    AF_CJKMetrics  metrics = (AF_CJKMetrics)metrics_;\n+\n+\n@@ -57,2 +55,1 @@\n-    FT_Set_Charmap( face, oldmap );\n-\n+    face->charmap = oldmap;\n@@ -64,2 +61,2 @@\n-  af_indic_metrics_scale( AF_CJKMetrics  metrics,\n-                          AF_Scaler      scaler )\n+  af_indic_metrics_scale( AF_StyleMetrics  metrics,\n+                          AF_Scaler        scaler )\n@@ -73,2 +70,2 @@\n-  af_indic_hints_init( AF_GlyphHints  hints,\n-                       AF_CJKMetrics  metrics )\n+  af_indic_hints_init( AF_GlyphHints    hints,\n+                       AF_StyleMetrics  metrics )\n@@ -82,4 +79,4 @@\n-  af_indic_hints_apply( FT_UInt        glyph_index,\n-                        AF_GlyphHints  hints,\n-                        FT_Outline*    outline,\n-                        AF_CJKMetrics  metrics )\n+  af_indic_hints_apply( FT_UInt          glyph_index,\n+                        AF_GlyphHints    hints,\n+                        FT_Outline*      outline,\n+                        AF_StyleMetrics  metrics )\n@@ -96,3 +93,3 @@\n-  af_indic_get_standard_widths( AF_CJKMetrics  metrics,\n-                                FT_Pos*        stdHW,\n-                                FT_Pos*        stdVW )\n+  af_indic_get_standard_widths( AF_StyleMetrics  metrics_, \/* AF_CJKMetrics *\/\n+                                FT_Pos*          stdHW,\n+                                FT_Pos*          stdVW )\n@@ -100,0 +97,3 @@\n+    AF_CJKMetrics  metrics = (AF_CJKMetrics)metrics_;\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afindic.c","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afindic.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -27,5 +27,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-#include \"afwarp.h\"\n-#endif\n-\n-\n@@ -66,4 +61,2 @@\n-    FT_TRACE5(( \"\\n\"\n-                \"latin standard widths computation (style `%s')\\n\"\n-                \"=====================================================\\n\"\n-                \"\\n\",\n+    FT_TRACE5(( \"\\n\" ));\n+    FT_TRACE5(( \"latin standard widths computation (style `%s')\\n\",\n@@ -71,0 +64,2 @@\n+    FT_TRACE5(( \"=====================================================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -208,1 +203,1 @@\n-        limit = seg + axhints->num_segments;\n+        limit = FT_OFFSET( seg, axhints->num_segments );\n@@ -353,3 +348,3 @@\n-    FT_TRACE5(( \"latin blue zones computation\\n\"\n-                \"============================\\n\"\n-                \"\\n\" ));\n+    FT_TRACE5(( \"latin blue zones computation\\n\" ));\n+    FT_TRACE5(( \"============================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -504,0 +499,2 @@\n+          best_contour_first = -1;\n+          best_contour_last  = -1;\n@@ -505,2 +502,0 @@\n-          best_contour_first = 0;  \/* ditto *\/\n-          best_contour_last  = 0;  \/* ditto *\/\n@@ -510,2 +505,1 @@\n-            FT_Int  first = 0;\n-            FT_Int  last  = -1;\n+            FT_Int  pp, first, last;\n@@ -514,1 +508,2 @@\n-            for ( nn = 0; nn < outline.n_contours; first = last + 1, nn++ )\n+            last = -1;\n+            for ( nn = 0; nn < outline.n_contours; nn++ )\n@@ -516,5 +511,2 @@\n-              FT_Int  old_best_point = best_point;\n-              FT_Int  pp;\n-\n-\n-              last = outline.contours[nn];\n+              first = last + 1;\n+              last  = outline.contours[nn];\n@@ -559,1 +551,1 @@\n-              if ( best_point != old_best_point )\n+              if ( best_point > best_contour_last )\n@@ -979,3 +971,2 @@\n-      FT_TRACE5(( \"    -> reference = %ld\\n\"\n-                  \"       overshoot = %ld\\n\",\n-                  *blue_ref, *blue_shoot ));\n+      FT_TRACE5(( \"    -> reference = %ld\\n\", *blue_ref ));\n+      FT_TRACE5(( \"       overshoot = %ld\\n\", *blue_shoot ));\n@@ -993,1 +984,1 @@\n-      AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];\n+      AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN];\n@@ -1034,1 +1025,1 @@\n-                      \" adjusting %s %ld to %ld\\n\",\n+                      \" adjusting %s %td to %ld\\n\",\n@@ -1052,1 +1043,1 @@\n-      FT_Long  i;\n+      FT_UInt  i;\n@@ -1077,2 +1068,2 @@\n-    FT_Bool   started = 0, same_width = 1;\n-    FT_Fixed  advance = 0, old_advance = 0;\n+    FT_Bool  started = 0, same_width = 1;\n+    FT_Long  advance = 0, old_advance = 0;\n@@ -1143,1 +1134,1 @@\n-  af_latin_metrics_init( AF_LatinMetrics  metrics,\n+  af_latin_metrics_init( AF_StyleMetrics  metrics_,   \/* AF_LatinMetrics *\/\n@@ -1146,0 +1137,2 @@\n+    AF_LatinMetrics  metrics = (AF_LatinMetrics)metrics_;\n+\n@@ -1166,1 +1159,1 @@\n-    FT_Set_Charmap( face, oldmap );\n+    face->charmap = oldmap;\n@@ -1273,2 +1266,1 @@\n-            dist  = FT_ABS( FT_MulFix( max_height, new_scale - scale ) );\n-            dist &= ~127;\n+            dist  = FT_MulFix( max_height, new_scale - scale );\n@@ -1276,1 +1268,1 @@\n-            if ( dist == 0 )\n+            if ( -128 < dist && dist < 128 )\n@@ -1278,10 +1270,10 @@\n-              FT_TRACE5((\n-                \"af_latin_metrics_scale_dim:\"\n-                \" x height alignment (style `%s'):\\n\"\n-                \"                           \"\n-                \" vertical scaling changed from %.5f to %.5f (by %ld%%)\\n\"\n-                \"\\n\",\n-                af_style_names[metrics->root.style_class->style],\n-                scale \/ 65536.0,\n-                new_scale \/ 65536.0,\n-                ( fitted - scaled ) * 100 \/ scaled ));\n+              FT_TRACE5(( \"af_latin_metrics_scale_dim:\"\n+                          \" x height alignment (style `%s'):\\n\",\n+                          af_style_names[metrics->root.style_class->style] ));\n+              FT_TRACE5(( \"                           \"\n+                          \" vertical scaling changed\"\n+                          \" from %.5f to %.5f (by %ld%%)\\n\",\n+                          (double)scale \/ 65536,\n+                          (double)new_scale \/ 65536,\n+                          ( fitted - scaled ) * 100 \/ scaled ));\n+              FT_TRACE5(( \"\\n\" ));\n@@ -1294,7 +1286,6 @@\n-              FT_TRACE5((\n-                \"af_latin_metrics_scale_dim:\"\n-                \" x height alignment (style `%s'):\\n\"\n-                \"                           \"\n-                \" excessive vertical scaling abandoned\\n\"\n-                \"\\n\",\n-                af_style_names[metrics->root.style_class->style] ));\n+              FT_TRACE5(( \"af_latin_metrics_scale_dim:\"\n+                          \" x height alignment (style `%s'):\\n\",\n+                          af_style_names[metrics->root.style_class->style] ));\n+              FT_TRACE5(( \"                           \"\n+                          \" excessive vertical scaling abandoned\\n\" ));\n+              FT_TRACE5(( \"\\n\" ));\n@@ -1337,1 +1328,1 @@\n-                  width->cur \/ 64.0 ));\n+                  (double)width->cur \/ 64 ));\n@@ -1349,2 +1340,2 @@\n-      FT_TRACE5(( \"`%s' style is extra light (at current resolution)\\n\"\n-                  \"\\n\",\n+    {\n+      FT_TRACE5(( \"`%s' style is extra light (at current resolution)\\n\",\n@@ -1352,0 +1343,2 @@\n+      FT_TRACE5(( \"\\n\" ));\n+    }\n@@ -1476,2 +1469,1 @@\n-        FT_TRACE5(( \"  reference %d: %ld scaled to %.2f%s\\n\"\n-                    \"  overshoot %d: %ld scaled to %.2f%s\\n\",\n+        FT_TRACE5(( \"  reference %d: %ld scaled to %.2f%s\\n\",\n@@ -1480,1 +1472,1 @@\n-                    blue->ref.fit \/ 64.0,\n+                    (double)blue->ref.fit \/ 64,\n@@ -1482,1 +1474,2 @@\n-                                                           : \" (inactive)\",\n+                                                           : \" (inactive)\" ));\n+        FT_TRACE5(( \"  overshoot %d: %ld scaled to %.2f%s\\n\",\n@@ -1485,1 +1478,1 @@\n-                    blue->shoot.fit \/ 64.0,\n+                    (double)blue->shoot.fit \/ 64,\n@@ -1497,1 +1490,1 @@\n-  af_latin_metrics_scale( AF_LatinMetrics  metrics,\n+  af_latin_metrics_scale( AF_StyleMetrics  metrics_,   \/* AF_LatinMetrics *\/\n@@ -1500,0 +1493,3 @@\n+    AF_LatinMetrics  metrics = (AF_LatinMetrics)metrics_;\n+\n+\n@@ -1512,2 +1508,2 @@\n-  FT_LOCAL_DEF( void )\n-  af_latin_get_standard_widths( AF_LatinMetrics  metrics,\n+  FT_CALLBACK_DEF( void )\n+  af_latin_get_standard_widths( AF_StyleMetrics  metrics_, \/* AF_LatinMetrics *\/\n@@ -1517,0 +1513,3 @@\n+    AF_LatinMetrics  metrics = (AF_LatinMetrics)metrics_;\n+\n+\n@@ -1850,0 +1849,25 @@\n+          \/*\n+           * For efficiency, we restrict the number of segments to 1000,\n+           * which is a heuristic value: it is very unlikely that a glyph\n+           * with so many segments can be hinted in a sensible way.\n+           * Reasons:\n+           *\n+           * - The glyph has really 1000 segments; this implies that it has\n+           *   at least 2000 outline points.  Assuming 'normal' fonts that\n+           *   have superfluous points optimized away, viewing such a glyph\n+           *   only makes sense at large magnifications where hinting\n+           *   isn't applied anyway.\n+           *\n+           * - We have a broken glyph.  Hinting doesn't make sense in this\n+           *   case either.\n+           *\/\n+          if ( axis->num_segments > 1000 )\n+          {\n+            FT_TRACE0(( \"af_latin_hints_compute_segments:\"\n+                        \" more than 1000 segments in this glyph;\\n\" ));\n+            FT_TRACE0(( \"                                \"\n+                        \" hinting is suppressed\\n\" ));\n+            axis->num_segments = 0;\n+            return FT_Err_Ok;\n+          }\n+\n@@ -1972,1 +1996,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -2024,1 +2048,1 @@\n-          \/* (this is, how much they overlap)                          *\/\n+          \/* (that is, how much they overlap)                          *\/\n@@ -2092,1 +2116,1 @@\n-          seg1->link  = 0;\n+          seg1->link  = NULL;\n@@ -2117,1 +2141,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -2186,1 +2210,1 @@\n-      FT_Int   ee;\n+      FT_UInt  ee;\n@@ -2260,1 +2284,1 @@\n-      FT_Int   ee;\n+      FT_UInt  ee;\n@@ -2483,1 +2507,1 @@\n-    AF_Edge       edge_limit = edge + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edge, axis->num_edges );\n@@ -2593,1 +2617,1 @@\n-                       AF_LatinMetrics  metrics )\n+                       AF_StyleMetrics  metrics_ )   \/* AF_LatinMetrics *\/\n@@ -2595,0 +2619,2 @@\n+    AF_LatinMetrics  metrics = (AF_LatinMetrics)metrics_;\n+\n@@ -2614,5 +2640,0 @@\n-#if 0 \/* #ifdef AF_CONFIG_OPTION_USE_WARPER *\/\n-    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )\n-      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;\n-#endif\n-\n@@ -2656,6 +2677,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    \/* get (global) warper flag *\/\n-    if ( !metrics->root.globals->module->warping )\n-      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;\n-#endif\n-\n@@ -2947,1 +2962,1 @@\n-    FT_TRACE5(( \"  LINK: edge %ld (opos=%.2f) linked to %.2f,\"\n+    FT_TRACE5(( \"  LINK: edge %td (opos=%.2f) linked to %.2f,\"\n@@ -2949,2 +2964,3 @@\n-                stem_edge - hints->axis[dim].edges, stem_edge->opos \/ 64.0,\n-                stem_edge->pos \/ 64.0, dist \/ 64.0, fitted_width \/ 64.0 ));\n+                stem_edge - hints->axis[dim].edges,\n+                (double)stem_edge->opos \/ 64, (double)stem_edge->pos \/ 64,\n+                (double)dist \/ 64, (double)fitted_width \/ 64 ));\n@@ -2987,1 +3003,1 @@\n-    AF_Edge       edge_limit = edges + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -3071,4 +3087,5 @@\n-          FT_TRACE5(( \"  BLUE_ANCHOR: edge %ld (opos=%.2f) snapped to %.2f,\"\n-                      \" was %.2f (anchor=edge %ld)\\n\",\n-                      edge1 - edges, edge1->opos \/ 64.0, blue->fit \/ 64.0,\n-                      edge1->pos \/ 64.0, edge - edges ));\n+          FT_TRACE5(( \"  BLUE_ANCHOR: edge %td (opos=%.2f) snapped to %.2f,\"\n+                      \" was %.2f (anchor=edge %td)\\n\",\n+                      edge1 - edges,\n+                      (double)edge1->opos \/ 64, (double)blue->fit \/ 64,\n+                      (double)edge1->pos \/ 64, edge - edges ));\n@@ -3076,1 +3093,1 @@\n-          FT_TRACE5(( \"  BLUE: edge %ld (opos=%.2f) snapped to %.2f,\"\n+          FT_TRACE5(( \"  BLUE: edge %td (opos=%.2f) snapped to %.2f,\"\n@@ -3078,2 +3095,3 @@\n-                      edge1 - edges, edge1->opos \/ 64.0, blue->fit \/ 64.0,\n-                      edge1->pos \/ 64.0 ));\n+                      edge1 - edges,\n+                      (double)edge1->opos \/ 64, (double)blue->fit \/ 64,\n+                      (double)edge1->pos \/ 64 ));\n@@ -3125,1 +3143,1 @@\n-        FT_TRACE5(( \"  ASSERTION FAILED for edge %ld\\n\", edge2 - edges ));\n+        FT_TRACE5(( \"  ASSERTION FAILED for edge %td\\n\", edge2 - edges ));\n@@ -3193,1 +3211,1 @@\n-        FT_TRACE5(( \"  ANCHOR: edge %ld (opos=%.2f) and %ld (opos=%.2f)\"\n+        FT_TRACE5(( \"  ANCHOR: edge %td (opos=%.2f) and %td (opos=%.2f)\"\n@@ -3195,3 +3213,3 @@\n-                    edge - edges, edge->opos \/ 64.0,\n-                    edge2 - edges, edge2->opos \/ 64.0,\n-                    edge->pos \/ 64.0, edge2->pos \/ 64.0 ));\n+                    edge - edges, (double)edge->opos \/ 64,\n+                    edge2 - edges, (double)edge2->opos \/ 64,\n+                    (double)edge->pos \/ 64, (double)edge2->pos \/ 64 ));\n@@ -3222,3 +3240,3 @@\n-          FT_TRACE5(( \"  ADJUST: edge %ld (pos=%.2f) moved to %.2f\\n\",\n-                      edge - edges, edge->pos \/ 64.0,\n-                      ( edge2->pos - cur_len ) \/ 64.0 ));\n+          FT_TRACE5(( \"  ADJUST: edge %td (pos=%.2f) moved to %.2f\\n\",\n+                      edge - edges, (double)edge->pos \/ 64,\n+                      (double)( edge2->pos - cur_len ) \/ 64 ));\n@@ -3263,1 +3281,1 @@\n-          FT_TRACE5(( \"  STEM: edge %ld (opos=%.2f) linked to %ld (opos=%.2f)\"\n+          FT_TRACE5(( \"  STEM: edge %td (opos=%.2f) linked to %td (opos=%.2f)\"\n@@ -3265,3 +3283,3 @@\n-                      edge - edges, edge->opos \/ 64.0,\n-                      edge2 - edges, edge2->opos \/ 64.0,\n-                      edge->pos \/ 64.0, edge2->pos \/ 64.0 ));\n+                      edge - edges, (double)edge->opos \/ 64,\n+                      edge2 - edges, (double)edge2->opos \/ 64,\n+                      (double)edge->pos \/ 64, (double)edge2->pos \/ 64 ));\n@@ -3294,1 +3312,1 @@\n-          FT_TRACE5(( \"  STEM: edge %ld (opos=%.2f) linked to %ld (opos=%.2f)\"\n+          FT_TRACE5(( \"  STEM: edge %td (opos=%.2f) linked to %td (opos=%.2f)\"\n@@ -3296,3 +3314,3 @@\n-                      edge - edges, edge->opos \/ 64.0,\n-                      edge2 - edges, edge2->opos \/ 64.0,\n-                      edge->pos \/ 64.0, edge2->pos \/ 64.0 ));\n+                      edge - edges, (double)edge->opos \/ 64,\n+                      edge2 - edges, (double)edge2->opos \/ 64,\n+                      (double)edge->pos \/ 64, (double)edge2->pos \/ 64 ));\n@@ -3317,1 +3335,1 @@\n-            FT_TRACE5(( \"  BOUND: edge %ld (pos=%.2f) moved to %.2f\\n\",\n+            FT_TRACE5(( \"  BOUND: edge %td (pos=%.2f) moved to %.2f\\n\",\n@@ -3319,2 +3337,2 @@\n-                        edge->pos \/ 64.0,\n-                        edge[-1].pos \/ 64.0 ));\n+                        (double)edge->pos \/ 64,\n+                        (double)edge[-1].pos \/ 64 ));\n@@ -3419,1 +3437,1 @@\n-          FT_TRACE5(( \"  SERIF: edge %ld (opos=%.2f) serif to %ld (opos=%.2f)\"\n+          FT_TRACE5(( \"  SERIF: edge %td (opos=%.2f) serif to %td (opos=%.2f)\"\n@@ -3421,3 +3439,3 @@\n-                      edge - edges, edge->opos \/ 64.0,\n-                      edge->serif - edges, edge->serif->opos \/ 64.0,\n-                      edge->pos \/ 64.0 ));\n+                      edge - edges, (double)edge->opos \/ 64,\n+                      edge->serif - edges, (double)edge->serif->opos \/ 64,\n+                      (double)edge->pos \/ 64 ));\n@@ -3429,1 +3447,1 @@\n-          FT_TRACE5(( \"  SERIF_ANCHOR: edge %ld (opos=%.2f)\"\n+          FT_TRACE5(( \"  SERIF_ANCHOR: edge %td (opos=%.2f)\"\n@@ -3431,1 +3449,2 @@\n-                      edge-edges, edge->opos \/ 64.0, edge->pos \/ 64.0 ));\n+                      edge - edges,\n+                      (double)edge->opos \/ 64, (double)edge->pos \/ 64 ));\n@@ -3457,5 +3476,5 @@\n-            FT_TRACE5(( \"  SERIF_LINK1: edge %ld (opos=%.2f) snapped to %.2f\"\n-                        \" from %ld (opos=%.2f)\\n\",\n-                        edge - edges, edge->opos \/ 64.0,\n-                        edge->pos \/ 64.0,\n-                        before - edges, before->opos \/ 64.0 ));\n+            FT_TRACE5(( \"  SERIF_LINK1: edge %td (opos=%.2f) snapped to %.2f\"\n+                        \" from %td (opos=%.2f)\\n\",\n+                        edge - edges, (double)edge->opos \/ 64,\n+                        (double)edge->pos \/ 64,\n+                        before - edges, (double)before->opos \/ 64 ));\n@@ -3467,1 +3486,1 @@\n-            FT_TRACE5(( \"  SERIF_LINK2: edge %ld (opos=%.2f)\"\n+            FT_TRACE5(( \"  SERIF_LINK2: edge %td (opos=%.2f)\"\n@@ -3469,1 +3488,2 @@\n-                        edge - edges, edge->opos \/ 64.0, edge->pos \/ 64.0 ));\n+                        edge - edges,\n+                        (double)edge->opos \/ 64, (double)edge->pos \/ 64 ));\n@@ -3487,1 +3507,1 @@\n-            FT_TRACE5(( \"  BOUND: edge %ld (pos=%.2f) moved to %.2f\\n\",\n+            FT_TRACE5(( \"  BOUND: edge %td (pos=%.2f) moved to %.2f\\n\",\n@@ -3489,2 +3509,2 @@\n-                        edge->pos \/ 64.0,\n-                        edge[-1].pos \/ 64.0 ));\n+                        (double)edge->pos \/ 64,\n+                        (double)edge[-1].pos \/ 64 ));\n@@ -3508,1 +3528,1 @@\n-            FT_TRACE5(( \"  BOUND: edge %ld (pos=%.2f) moved to %.2f\\n\",\n+            FT_TRACE5(( \"  BOUND: edge %td (pos=%.2f) moved to %.2f\\n\",\n@@ -3510,2 +3530,2 @@\n-                        edge->pos \/ 64.0,\n-                        edge[1].pos \/ 64.0 ));\n+                        (double)edge->pos \/ 64,\n+                        (double)edge[1].pos \/ 64 ));\n@@ -3536,1 +3556,1 @@\n-                        AF_LatinMetrics  metrics )\n+                        AF_StyleMetrics  metrics_ )    \/* AF_LatinMetrics *\/\n@@ -3538,0 +3558,2 @@\n+    AF_LatinMetrics  metrics = (AF_LatinMetrics)metrics_;\n+\n@@ -3578,18 +3600,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-      if ( dim == AF_DIMENSION_HORZ                                  &&\n-           metrics->root.scaler.render_mode == FT_RENDER_MODE_NORMAL &&\n-           AF_HINTS_DO_WARP( hints )                                 )\n-      {\n-        AF_WarperRec  warper;\n-        FT_Fixed      scale;\n-        FT_Pos        delta;\n-\n-\n-        af_warper_compute( &warper, hints, (AF_Dimension)dim,\n-                           &scale, &delta );\n-        af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,\n-                                  scale, delta );\n-        continue;\n-      }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/aflatin.c","additions":157,"deletions":153,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -101,1 +101,1 @@\n-    AF_LatinBlueRec  blues[AF_BLUE_STRINGSET_MAX];\n+    AF_LatinBlueRec  blues[AF_BLUE_STRINGSET_MAX_LEN];\n@@ -119,1 +119,1 @@\n-  af_latin_metrics_init( AF_LatinMetrics  metrics,\n+  af_latin_metrics_init( AF_StyleMetrics  metrics,\n@@ -123,1 +123,1 @@\n-  af_latin_metrics_scale( AF_LatinMetrics  metrics,\n+  af_latin_metrics_scale( AF_StyleMetrics  metrics,\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/aflatin.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -58,4 +58,2 @@\n-        face->autohint.data =\n-          (FT_Pointer)loader->globals;\n-        face->autohint.finalizer =\n-          (FT_Generic_Finalizer)af_face_globals_free;\n+        face->autohint.data      = (FT_Pointer)loader->globals;\n+        face->autohint.finalizer = af_face_globals_free;\n@@ -108,1 +106,0 @@\n-    FT_Fixed  em_ratio = FT_DivFix( af_intToFixed( 1000 ), em_size );\n@@ -145,6 +142,5 @@\n-        af_intToFixed( af_loader_compute_darkening( loader,\n-                                                    face,\n-                                                    stdVW ) );\n-      darken_x = FT_DivFix( FT_MulFix( darken_by_font_units_x,\n-                                       size_metrics->x_scale ),\n-                            em_ratio );\n+         af_loader_compute_darkening( loader,\n+                                      face,\n+                                      stdVW ) ;\n+      darken_x = FT_MulFix( darken_by_font_units_x,\n+                            size_metrics->x_scale );\n@@ -164,6 +160,5 @@\n-        af_intToFixed( af_loader_compute_darkening( loader,\n-                                                    face,\n-                                                    stdHW ) );\n-      darken_y = FT_DivFix( FT_MulFix( darken_by_font_units_y,\n-                                       size_metrics->y_scale ),\n-                            em_ratio );\n+         af_loader_compute_darkening( loader,\n+                                      face,\n+                                      stdHW ) ;\n+      darken_y = FT_MulFix( darken_by_font_units_y,\n+                            size_metrics->y_scale );\n@@ -235,3 +230,0 @@\n-    if ( !size )\n-      return FT_THROW( Invalid_Size_Handle );\n-\n@@ -303,6 +295,0 @@\n-#ifdef FT_OPTION_AUTOFIT2\n-    \/* XXX: undocumented hook to activate the latin2 writing system. *\/\n-    if ( load_flags & ( 1UL << 20 ) )\n-      style_options = AF_STYLE_LTN2_DFLT;\n-#endif\n-\n@@ -485,2 +471,2 @@\n-          loader->pp1.x = FT_PIX_ROUND( pp1x + hints->xmin_delta );\n-          loader->pp2.x = FT_PIX_ROUND( pp2x + hints->xmax_delta );\n+          loader->pp1.x = FT_PIX_ROUND( pp1x );\n+          loader->pp2.x = FT_PIX_ROUND( pp2x );\n@@ -597,1 +583,1 @@\n-  FT_LOCAL_DEF( FT_Int32 )\n+  FT_LOCAL_DEF( FT_Fixed )\n@@ -716,1 +702,1 @@\n-    return af_fixedToInt( FT_DivFix( darken_amount, em_ratio ) );\n+    return FT_DivFix( darken_amount, em_ratio );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afloader.c","additions":17,"deletions":31,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -78,1 +78,1 @@\n-  FT_LOCAL_DEF( FT_Int32 )\n+  FT_LOCAL( FT_Fixed )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afloader.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -46,3 +46,3 @@\n-  int  _af_debug_disable_horz_hints;\n-  int  _af_debug_disable_vert_hints;\n-  int  _af_debug_disable_blue_hints;\n+  int  af_debug_disable_horz_hints_;\n+  int  af_debug_disable_vert_hints_;\n+  int  af_debug_disable_blue_hints_;\n@@ -51,1 +51,1 @@\n-  AF_GlyphHintsRec  _af_debug_hints_rec[1];\n+  static AF_GlyphHintsRec  af_debug_hints_rec_[1];\n@@ -53,1 +53,1 @@\n-  void*  _af_debug_hints = _af_debug_hints_rec;\n+  void*  af_debug_hints_ = af_debug_hints_rec_;\n@@ -92,4 +92,2 @@\n-        face->autohint.data =\n-          (FT_Pointer)globals;\n-        face->autohint.finalizer =\n-          (FT_Generic_Finalizer)af_face_globals_free;\n+        face->autohint.data      = (FT_Pointer)globals;\n+        face->autohint.finalizer = af_face_globals_free;\n@@ -122,2 +120,2 @@\n-      FT_UInt*  fallback_script;\n-      FT_UInt   ss;\n+      AF_Script*  fallback_script;\n+      FT_UInt     ss;\n@@ -131,1 +129,1 @@\n-      fallback_script = (FT_UInt*)value;\n+      fallback_script = (AF_Script*)value;\n@@ -141,2 +139,2 @@\n-        if ( (FT_UInt)style_class->script == *fallback_script &&\n-             style_class->coverage == AF_COVERAGE_DEFAULT     )\n+        if ( style_class->script   == *fallback_script    &&\n+             style_class->coverage == AF_COVERAGE_DEFAULT )\n@@ -151,1 +149,1 @@\n-        FT_TRACE0(( \"af_property_set: Invalid value %d for property `%s'\\n\",\n+        FT_TRACE2(( \"af_property_set: Invalid value %d for property `%s'\\n\",\n@@ -160,1 +158,1 @@\n-      FT_UInt*  default_script;\n+      AF_Script*  default_script;\n@@ -168,1 +166,1 @@\n-      default_script = (FT_UInt*)value;\n+      default_script = (AF_Script*)value;\n@@ -193,29 +191,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    else if ( !ft_strcmp( property_name, \"warping\" ) )\n-    {\n-#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES\n-      if ( value_is_string )\n-      {\n-        const char*  s = (const char*)value;\n-        long         w = ft_strtol( s, NULL, 10 );\n-\n-\n-        if ( w == 0 )\n-          module->warping = 0;\n-        else if ( w == 1 )\n-          module->warping = 1;\n-        else\n-          return FT_THROW( Invalid_Argument );\n-      }\n-      else\n-#endif\n-      {\n-        FT_Bool*  warping = (FT_Bool*)value;\n-\n-\n-        module->warping = *warping;\n-      }\n-\n-      return error;\n-    }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n@@ -310,1 +279,1 @@\n-    FT_TRACE0(( \"af_property_set: missing property `%s'\\n\",\n+    FT_TRACE2(( \"af_property_set: missing property `%s'\\n\",\n@@ -323,5 +292,0 @@\n-    FT_UInt    fallback_style = module->fallback_style;\n-    FT_UInt    default_script = module->default_script;\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    FT_Bool    warping        = module->warping;\n-#endif\n@@ -344,1 +308,1 @@\n-      FT_UInt*  val = (FT_UInt*)value;\n+      AF_Script*  val = (AF_Script*)value;\n@@ -346,1 +310,1 @@\n-      AF_StyleClass  style_class = af_style_classes[fallback_style];\n+      AF_StyleClass  style_class = af_style_classes[module->fallback_style];\n@@ -355,1 +319,1 @@\n-      FT_UInt*  val = (FT_UInt*)value;\n+      AF_Script*  val = (AF_Script*)value;\n@@ -358,1 +322,1 @@\n-      *val = default_script;\n+      *val = module->default_script;\n@@ -374,11 +338,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    else if ( !ft_strcmp( property_name, \"warping\" ) )\n-    {\n-      FT_Bool*  val = (FT_Bool*)value;\n-\n-\n-      *val = warping;\n-\n-      return error;\n-    }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n@@ -413,1 +366,1 @@\n-    FT_TRACE0(( \"af_property_get: missing property `%s'\\n\",\n+    FT_TRACE2(( \"af_property_get: missing property `%s'\\n\",\n@@ -422,2 +375,3 @@\n-    (FT_Properties_SetFunc)af_property_set,        \/* set_property *\/\n-    (FT_Properties_GetFunc)af_property_get )       \/* get_property *\/\n+    af_property_set,  \/* FT_Properties_SetFunc set_property *\/\n+    af_property_get   \/* FT_Properties_GetFunc get_property *\/\n+  )\n@@ -450,3 +404,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    module->warping           = 0;\n-#endif\n@@ -474,2 +425,2 @@\n-    if ( _af_debug_hints_rec->memory )\n-      af_glyph_hints_done( _af_debug_hints_rec );\n+    if ( af_debug_hints_rec_->memory )\n+      af_glyph_hints_done( af_debug_hints_rec_ );\n@@ -481,5 +432,5 @@\n-  af_autofitter_load_glyph( AF_Module     module,\n-                            FT_GlyphSlot  slot,\n-                            FT_Size       size,\n-                            FT_UInt       glyph_index,\n-                            FT_Int32      load_flags )\n+  af_autofitter_load_glyph( FT_AutoHinter  module_,\n+                            FT_GlyphSlot   slot,\n+                            FT_Size        size,\n+                            FT_UInt        glyph_index,\n+                            FT_Int32       load_flags )\n@@ -487,0 +438,2 @@\n+    AF_Module  module = (AF_Module)module_;\n+\n@@ -488,1 +441,1 @@\n-    FT_Memory  memory = module->root.library->memory;\n+    FT_Memory  memory = module->root.memory;\n@@ -494,1 +447,1 @@\n-    AF_GlyphHints  hints = _af_debug_hints_rec;\n+    AF_GlyphHints  hints = af_debug_hints_rec_;\n@@ -550,4 +503,4 @@\n-    NULL,                                                    \/* reset_face *\/\n-    NULL,                                              \/* get_global_hints *\/\n-    NULL,                                             \/* done_global_hints *\/\n-    (FT_AutoHinter_GlyphLoadFunc)af_autofitter_load_glyph    \/* load_glyph *\/\n+    NULL,                     \/* FT_AutoHinter_GlobalResetFunc reset_face        *\/\n+    NULL,                     \/* FT_AutoHinter_GlobalGetFunc   get_global_hints  *\/\n+    NULL,                     \/* FT_AutoHinter_GlobalDoneFunc  done_global_hints *\/\n+    af_autofitter_load_glyph  \/* FT_AutoHinter_GlyphLoadFunc   load_glyph        *\/\n@@ -568,3 +521,3 @@\n-    (FT_Module_Constructor)af_autofitter_init,  \/* module_init   *\/\n-    (FT_Module_Destructor) af_autofitter_done,  \/* module_done   *\/\n-    (FT_Module_Requester)  af_get_interface     \/* get_interface *\/\n+    af_autofitter_init,  \/* FT_Module_Constructor module_init   *\/\n+    af_autofitter_done,  \/* FT_Module_Destructor  module_done   *\/\n+    af_get_interface     \/* FT_Module_Requester   get_interface *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afmodule.c","additions":43,"deletions":90,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -39,4 +39,1 @@\n-    FT_UInt       default_script;\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    FT_Bool       warping;\n-#endif\n+    AF_Script     default_script;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afmodule.h","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afranges.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afranges.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afscript.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n@@ -135,3 +135,15 @@\n-    hb_ot_tags_from_script( script,\n-                            &script_tags[0],\n-                            &script_tags[1] );\n+    {\n+      unsigned int  tags_count = 3;\n+      hb_tag_t      tags[3];\n+\n+\n+      hb_ot_tags_from_script_and_language( script,\n+                                           HB_LANGUAGE_INVALID,\n+                                           &tags_count,\n+                                           tags,\n+                                           NULL,\n+                                           NULL );\n+      script_tags[0] = tags_count > 0 ? tags[0] : HB_TAG_NONE;\n+      script_tags[1] = tags_count > 1 ? tags[1] : HB_TAG_NONE;\n+      script_tags[2] = tags_count > 2 ? tags[2] : HB_TAG_NONE;\n+    }\n@@ -139,3 +151,2 @@\n-    \/* `hb_ot_tags_from_script' usually returns HB_OT_TAG_DEFAULT_SCRIPT *\/\n-    \/* as the second tag.  We change that to HB_TAG_NONE except for the  *\/\n-    \/* default script.                                                   *\/\n+    \/* If the second tag is HB_OT_TAG_DEFAULT_SCRIPT, change that to     *\/\n+    \/* HB_TAG_NONE except for the default script.                        *\/\n@@ -160,3 +171,0 @@\n-\n-      if ( script_tags[1] == HB_OT_TAG_DEFAULT_SCRIPT )\n-        script_tags[1] = HB_TAG_NONE;\n@@ -176,2 +184,1 @@\n-    FT_TRACE4(( \"GSUB lookups (style `%s'):\\n\"\n-                \" \",\n+    FT_TRACE4(( \"GSUB lookups (style `%s'):\\n\",\n@@ -179,0 +186,1 @@\n+    FT_TRACE4(( \" \" ));\n@@ -205,1 +213,2 @@\n-    FT_TRACE4(( \"\\n\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -208,2 +217,1 @@\n-    FT_TRACE4(( \"GPOS lookups (style `%s'):\\n\"\n-                \" \",\n+    FT_TRACE4(( \"GPOS lookups (style `%s'):\\n\",\n@@ -211,0 +219,1 @@\n+    FT_TRACE4(( \" \" ));\n@@ -245,1 +254,2 @@\n-    FT_TRACE4(( \"\\n\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -251,1 +261,1 @@\n-     * (this is, not a single character is covered), we skip this coverage.\n+     * (that is, not a single character is covered), we skip this coverage.\n@@ -306,1 +316,1 @@\n-     * glyphs are `real', this is, they have a zero vertical offset, but\n+     * glyphs are `real', that is, they have a zero vertical offset, but\n@@ -308,1 +318,1 @@\n-     * position (this is, the `sups' feature is present in both the GSUB and\n+     * position (that is, the `sups' feature is present in both the GSUB and\n@@ -356,2 +366,4 @@\n-        FT_TRACE4(( \"\\n\"\n-                    \"   \" ));\n+      {\n+        FT_TRACE4(( \"\\n\" ));\n+        FT_TRACE4(( \"   \" ));\n+      }\n@@ -379,3 +391,6 @@\n-      FT_TRACE4(( \"\\n\"\n-                  \"    (none)\" ));\n-    FT_TRACE4(( \"\\n\\n\" ));\n+    {\n+      FT_TRACE4(( \"\\n\" ));\n+      FT_TRACE4(( \"    (none)\" ));\n+    }\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afshaper.c","additions":39,"deletions":24,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n@@ -30,1 +30,1 @@\n-#include <hb-ft.h>\n+#include \"ft-hb.h\"\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afshaper.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n@@ -302,9 +302,0 @@\n-#ifdef FT_OPTION_AUTOFIT2\n-  STYLE( ltn2_dflt, LTN2_DFLT,\n-         \"Latin 2 default style\",\n-         AF_WRITING_SYSTEM_LATIN2,\n-         AF_SCRIPT_LATN,\n-         AF_BLUE_STRINGSET_LATN,\n-         AF_COVERAGE_DEFAULT )\n-#endif\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afstyles.h","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n@@ -60,4 +60,4 @@\n-extern int    _af_debug_disable_horz_hints;\n-extern int    _af_debug_disable_vert_hints;\n-extern int    _af_debug_disable_blue_hints;\n-extern void*  _af_debug_hints;\n+extern int    af_debug_disable_horz_hints_;\n+extern int    af_debug_disable_vert_hints_;\n+extern int    af_debug_disable_blue_hints_;\n+extern void*  af_debug_hints_;\n@@ -95,57 +95,0 @@\n-  \/*************************************************************************\/\n-  \/*************************************************************************\/\n-  \/*****                                                               *****\/\n-  \/*****                   A N G L E   T Y P E S                       *****\/\n-  \/*****                                                               *****\/\n-  \/*************************************************************************\/\n-  \/*************************************************************************\/\n-\n-  \/*\n-   * The auto-fitter doesn't need a very high angular accuracy;\n-   * this allows us to speed up some computations considerably with a\n-   * light Cordic algorithm (see afangles.c).\n-   *\/\n-\n-  typedef FT_Int  AF_Angle;\n-\n-\n-#define AF_ANGLE_PI   256\n-#define AF_ANGLE_2PI  ( AF_ANGLE_PI * 2 )\n-#define AF_ANGLE_PI2  ( AF_ANGLE_PI \/ 2 )\n-#define AF_ANGLE_PI4  ( AF_ANGLE_PI \/ 4 )\n-\n-\n-#if 0\n-  \/*\n-   * compute the angle of a given 2-D vector\n-   *\/\n-  FT_LOCAL( AF_Angle )\n-  af_angle_atan( FT_Pos  dx,\n-                 FT_Pos  dy );\n-\n-\n-  \/*\n-   * compute `angle2 - angle1'; the result is always within\n-   * the range [-AF_ANGLE_PI .. AF_ANGLE_PI - 1]\n-   *\/\n-  FT_LOCAL( AF_Angle )\n-  af_angle_diff( AF_Angle  angle1,\n-                 AF_Angle  angle2 );\n-#endif \/* 0 *\/\n-\n-\n-#define AF_ANGLE_DIFF( result, angle1, angle2 ) \\\n-  FT_BEGIN_STMNT                                \\\n-    AF_Angle  _delta = (angle2) - (angle1);     \\\n-                                                \\\n-                                                \\\n-    while ( _delta <= -AF_ANGLE_PI )            \\\n-      _delta += AF_ANGLE_2PI;                   \\\n-                                                \\\n-    while ( _delta > AF_ANGLE_PI )              \\\n-      _delta -= AF_ANGLE_2PI;                   \\\n-                                                \\\n-    result = _delta;                            \\\n-  FT_END_STMNT\n-\n-\n@@ -175,1 +118,0 @@\n-#define AF_SCALER_FLAG_NO_WARPER      8U \/* disable warper             *\/\n@@ -180,7 +122,7 @@\n-    FT_Face         face;        \/* source font face                        *\/\n-    FT_Fixed        x_scale;     \/* from font units to 1\/64th device pixels *\/\n-    FT_Fixed        y_scale;     \/* from font units to 1\/64th device pixels *\/\n-    FT_Pos          x_delta;     \/* in 1\/64th device pixels                 *\/\n-    FT_Pos          y_delta;     \/* in 1\/64th device pixels                 *\/\n-    FT_Render_Mode  render_mode; \/* monochrome, anti-aliased, LCD, etc.     *\/\n-    FT_UInt32       flags;       \/* additional control flags, see above     *\/\n+    FT_Face         face;        \/* source font face                      *\/\n+    FT_Fixed        x_scale;     \/* from font units to 1\/64 device pixels *\/\n+    FT_Fixed        y_scale;     \/* from font units to 1\/64 device pixels *\/\n+    FT_Pos          x_delta;     \/* in 1\/64 device pixels                 *\/\n+    FT_Pos          y_delta;     \/* in 1\/64 device pixels                 *\/\n+    FT_Render_Mode  render_mode; \/* monochrome, anti-aliased, LCD, etc.   *\/\n+    FT_UInt32       flags;       \/* additional control flags, see above   *\/\n@@ -259,1 +201,0 @@\n-#define AFWRTSYS_H_  \/* don't load header files *\/\n@@ -268,1 +209,1 @@\n-#include \"afwrtsys.h\"\n+#include \"afws-iter.h\"\n@@ -274,2 +215,0 @@\n-#undef  AFWRTSYS_H_\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/aftypes.h","additions":13,"deletions":74,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1,373 +0,0 @@\n-\/****************************************************************************\n- *\n- * afwarp.c\n- *\n- *   Auto-fitter warping algorithm (body).\n- *\n- * Copyright (C) 2006-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-  \/*\n-   * The idea of the warping code is to slightly scale and shift a glyph\n-   * within a single dimension so that as much of its segments are aligned\n-   * (more or less) on the grid.  To find out the optimal scaling and\n-   * shifting value, various parameter combinations are tried and scored.\n-   *\/\n-\n-#include \"afwarp.h\"\n-\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-\n-  \/**************************************************************************\n-   *\n-   * The macro FT_COMPONENT is used in trace mode.  It is an implicit\n-   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print\/log\n-   * messages during execution.\n-   *\/\n-#undef  FT_COMPONENT\n-#define FT_COMPONENT  afwarp\n-\n-\n-  \/* The weights cover the range 0\/64 - 63\/64 of a pixel.  Obviously, *\/\n-  \/* values around a half pixel (which means exactly between two grid *\/\n-  \/* lines) gets the worst weight.                                    *\/\n-#if 1\n-  static const AF_WarpScore\n-  af_warper_weights[64] =\n-  {\n-    35, 32, 30, 25, 20, 15, 12, 10,  5,  1,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0, -1, -2, -5, -8,-10,-10,-20,-20,-30,-30,\n-\n-   -30,-30,-20,-20,-10,-10, -8, -5, -2, -1,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0,  0,  1,  5, 10, 12, 15, 20, 25, 30, 32,\n-  };\n-#else\n-  static const AF_WarpScore\n-  af_warper_weights[64] =\n-  {\n-    30, 20, 10,  5,  4,  4,  3,  2,  1,  0,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0,  0, -1, -2, -2, -5, -5,-10,-10,-15,-20,\n-\n-   -20,-15,-15,-10,-10, -5, -5, -2, -2, -1,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  4,  5, 10, 20,\n-  };\n-#endif\n-\n-\n-  \/* Score segments for a given `scale' and `delta' in the range *\/\n-  \/* `xx1' to `xx2', and store the best result in `warper'.  If  *\/\n-  \/* the new best score is equal to the old one, prefer the      *\/\n-  \/* value with a smaller distortion (around `base_distort').    *\/\n-\n-  static void\n-  af_warper_compute_line_best( AF_Warper     warper,\n-                               FT_Fixed      scale,\n-                               FT_Pos        delta,\n-                               FT_Pos        xx1,\n-                               FT_Pos        xx2,\n-                               AF_WarpScore  base_distort,\n-                               AF_Segment    segments,\n-                               FT_Int        num_segments )\n-  {\n-    FT_Int        idx_min, idx_max, idx0;\n-    FT_Int        nn;\n-    AF_WarpScore  scores[65];\n-\n-\n-    for ( nn = 0; nn < 65; nn++ )\n-      scores[nn] = 0;\n-\n-    idx0 = xx1 - warper->t1;\n-\n-    \/* compute minimum and maximum indices *\/\n-    {\n-      FT_Pos  xx1min = warper->x1min;\n-      FT_Pos  xx1max = warper->x1max;\n-      FT_Pos  w      = xx2 - xx1;\n-\n-\n-      if ( xx1min + w < warper->x2min )\n-        xx1min = warper->x2min - w;\n-\n-      if ( xx1max + w > warper->x2max )\n-        xx1max = warper->x2max - w;\n-\n-      idx_min = xx1min - warper->t1;\n-      idx_max = xx1max - warper->t1;\n-\n-      if ( idx_min < 0 || idx_min > idx_max || idx_max > 64 )\n-      {\n-        FT_TRACE5(( \"invalid indices:\\n\"\n-                    \"  min=%d max=%d, xx1=%ld xx2=%ld,\\n\"\n-                    \"  x1min=%ld x1max=%ld, x2min=%ld x2max=%ld\\n\",\n-                    idx_min, idx_max, xx1, xx2,\n-                    warper->x1min, warper->x1max,\n-                    warper->x2min, warper->x2max ));\n-        return;\n-      }\n-    }\n-\n-    for ( nn = 0; nn < num_segments; nn++ )\n-    {\n-      FT_Pos  len = segments[nn].max_coord - segments[nn].min_coord;\n-      FT_Pos  y0  = FT_MulFix( segments[nn].pos, scale ) + delta;\n-      FT_Pos  y   = y0 + ( idx_min - idx0 );\n-      FT_Int  idx;\n-\n-\n-      \/* score the length of the segments for the given range *\/\n-      for ( idx = idx_min; idx <= idx_max; idx++, y++ )\n-        scores[idx] += af_warper_weights[y & 63] * len;\n-    }\n-\n-    \/* find best score *\/\n-    {\n-      FT_Int  idx;\n-\n-\n-      for ( idx = idx_min; idx <= idx_max; idx++ )\n-      {\n-        AF_WarpScore  score = scores[idx];\n-        AF_WarpScore  distort = base_distort + ( idx - idx0 );\n-\n-\n-        if ( score > warper->best_score         ||\n-             ( score == warper->best_score    &&\n-               distort < warper->best_distort ) )\n-        {\n-          warper->best_score   = score;\n-          warper->best_distort = distort;\n-          warper->best_scale   = scale;\n-          warper->best_delta   = delta + ( idx - idx0 );\n-        }\n-      }\n-    }\n-  }\n-\n-\n-  \/* Compute optimal scaling and delta values for a given glyph and *\/\n-  \/* dimension.                                                     *\/\n-\n-  FT_LOCAL_DEF( void )\n-  af_warper_compute( AF_Warper      warper,\n-                     AF_GlyphHints  hints,\n-                     AF_Dimension   dim,\n-                     FT_Fixed      *a_scale,\n-                     FT_Pos        *a_delta )\n-  {\n-    AF_AxisHints  axis;\n-    AF_Point      points;\n-\n-    FT_Fixed      org_scale;\n-    FT_Pos        org_delta;\n-\n-    FT_Int        nn, num_points, num_segments;\n-    FT_Int        X1, X2;\n-    FT_Int        w;\n-\n-    AF_WarpScore  base_distort;\n-    AF_Segment    segments;\n-\n-\n-    \/* get original scaling transformation *\/\n-    if ( dim == AF_DIMENSION_VERT )\n-    {\n-      org_scale = hints->y_scale;\n-      org_delta = hints->y_delta;\n-    }\n-    else\n-    {\n-      org_scale = hints->x_scale;\n-      org_delta = hints->x_delta;\n-    }\n-\n-    warper->best_scale   = org_scale;\n-    warper->best_delta   = org_delta;\n-    warper->best_score   = FT_INT_MIN;\n-    warper->best_distort = 0;\n-\n-    axis         = &hints->axis[dim];\n-    segments     = axis->segments;\n-    num_segments = axis->num_segments;\n-    points       = hints->points;\n-    num_points   = hints->num_points;\n-\n-    *a_scale = org_scale;\n-    *a_delta = org_delta;\n-\n-    \/* get X1 and X2, minimum and maximum in original coordinates *\/\n-    if ( num_segments < 1 )\n-      return;\n-\n-#if 1\n-    X1 = X2 = points[0].fx;\n-    for ( nn = 1; nn < num_points; nn++ )\n-    {\n-      FT_Int  X = points[nn].fx;\n-\n-\n-      if ( X < X1 )\n-        X1 = X;\n-      if ( X > X2 )\n-        X2 = X;\n-    }\n-#else\n-    X1 = X2 = segments[0].pos;\n-    for ( nn = 1; nn < num_segments; nn++ )\n-    {\n-      FT_Int  X = segments[nn].pos;\n-\n-\n-      if ( X < X1 )\n-        X1 = X;\n-      if ( X > X2 )\n-        X2 = X;\n-    }\n-#endif\n-\n-    if ( X1 >= X2 )\n-      return;\n-\n-    warper->x1 = FT_MulFix( X1, org_scale ) + org_delta;\n-    warper->x2 = FT_MulFix( X2, org_scale ) + org_delta;\n-\n-    warper->t1 = AF_WARPER_FLOOR( warper->x1 );\n-    warper->t2 = AF_WARPER_CEIL( warper->x2 );\n-\n-    \/* examine a half pixel wide range around the maximum coordinates *\/\n-    warper->x1min = warper->x1 & ~31;\n-    warper->x1max = warper->x1min + 32;\n-    warper->x2min = warper->x2 & ~31;\n-    warper->x2max = warper->x2min + 32;\n-\n-    if ( warper->x1max > warper->x2 )\n-      warper->x1max = warper->x2;\n-\n-    if ( warper->x2min < warper->x1 )\n-      warper->x2min = warper->x1;\n-\n-    warper->w0 = warper->x2 - warper->x1;\n-\n-    if ( warper->w0 <= 64 )\n-    {\n-      warper->x1max = warper->x1;\n-      warper->x2min = warper->x2;\n-    }\n-\n-    \/* examine (at most) a pixel wide range around the natural width *\/\n-    warper->wmin = warper->x2min - warper->x1max;\n-    warper->wmax = warper->x2max - warper->x1min;\n-\n-#if 1\n-    \/* some heuristics to reduce the number of widths to be examined *\/\n-    {\n-      int  margin = 16;\n-\n-\n-      if ( warper->w0 <= 128 )\n-      {\n-         margin = 8;\n-         if ( warper->w0 <= 96 )\n-           margin = 4;\n-      }\n-\n-      if ( warper->wmin < warper->w0 - margin )\n-        warper->wmin = warper->w0 - margin;\n-\n-      if ( warper->wmax > warper->w0 + margin )\n-        warper->wmax = warper->w0 + margin;\n-    }\n-\n-    if ( warper->wmin < warper->w0 * 3 \/ 4 )\n-      warper->wmin = warper->w0 * 3 \/ 4;\n-\n-    if ( warper->wmax > warper->w0 * 5 \/ 4 )\n-      warper->wmax = warper->w0 * 5 \/ 4;\n-#else\n-    \/* no scaling, just translation *\/\n-    warper->wmin = warper->wmax = warper->w0;\n-#endif\n-\n-    for ( w = warper->wmin; w <= warper->wmax; w++ )\n-    {\n-      FT_Fixed  new_scale;\n-      FT_Pos    new_delta;\n-      FT_Pos    xx1, xx2;\n-\n-\n-      \/* compute min and max positions for given width,       *\/\n-      \/* assuring that they stay within the coordinate ranges *\/\n-      xx1 = warper->x1;\n-      xx2 = warper->x2;\n-      if ( w >= warper->w0 )\n-      {\n-        xx1 -= w - warper->w0;\n-        if ( xx1 < warper->x1min )\n-        {\n-          xx2 += warper->x1min - xx1;\n-          xx1  = warper->x1min;\n-        }\n-      }\n-      else\n-      {\n-        xx1 -= w - warper->w0;\n-        if ( xx1 > warper->x1max )\n-        {\n-          xx2 -= xx1 - warper->x1max;\n-          xx1  = warper->x1max;\n-        }\n-      }\n-\n-      if ( xx1 < warper->x1 )\n-        base_distort = warper->x1 - xx1;\n-      else\n-        base_distort = xx1 - warper->x1;\n-\n-      if ( xx2 < warper->x2 )\n-        base_distort += warper->x2 - xx2;\n-      else\n-        base_distort += xx2 - warper->x2;\n-\n-      \/* give base distortion a greater weight while scoring *\/\n-      base_distort *= 10;\n-\n-      new_scale = org_scale + FT_DivFix( w - warper->w0, X2 - X1 );\n-      new_delta = xx1 - FT_MulFix( X1, new_scale );\n-\n-      af_warper_compute_line_best( warper, new_scale, new_delta, xx1, xx2,\n-                                   base_distort,\n-                                   segments, num_segments );\n-    }\n-\n-    {\n-      FT_Fixed  best_scale = warper->best_scale;\n-      FT_Pos    best_delta = warper->best_delta;\n-\n-\n-      hints->xmin_delta = FT_MulFix( X1, best_scale - org_scale )\n-                          + best_delta;\n-      hints->xmax_delta = FT_MulFix( X2, best_scale - org_scale )\n-                          + best_delta;\n-\n-      *a_scale = best_scale;\n-      *a_delta = best_delta;\n-    }\n-  }\n-\n-#else \/* !AF_CONFIG_OPTION_USE_WARPER *\/\n-\n-  \/* ANSI C doesn't like empty source files *\/\n-  typedef int  _af_warp_dummy;\n-\n-#endif \/* !AF_CONFIG_OPTION_USE_WARPER *\/\n-\n-\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afwarp.c","additions":0,"deletions":373,"binary":false,"changes":373,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/****************************************************************************\n- *\n- * afwarp.h\n- *\n- *   Auto-fitter warping algorithm (specification).\n- *\n- * Copyright (C) 2006-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-#ifndef AFWARP_H_\n-#define AFWARP_H_\n-\n-#include \"afhints.h\"\n-\n-FT_BEGIN_HEADER\n-\n-#define AF_WARPER_SCALE\n-\n-#define AF_WARPER_FLOOR( x )  ( (x) & ~FT_TYPEOF( x )63 )\n-#define AF_WARPER_CEIL( x )   AF_WARPER_FLOOR( (x) + 63 )\n-\n-\n-  typedef FT_Int32  AF_WarpScore;\n-\n-  typedef struct  AF_WarperRec_\n-  {\n-    FT_Pos        x1, x2;\n-    FT_Pos        t1, t2;\n-    FT_Pos        x1min, x1max;\n-    FT_Pos        x2min, x2max;\n-    FT_Pos        w0, wmin, wmax;\n-\n-    FT_Fixed      best_scale;\n-    FT_Pos        best_delta;\n-    AF_WarpScore  best_score;\n-    AF_WarpScore  best_distort;\n-\n-  } AF_WarperRec, *AF_Warper;\n-\n-\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-  FT_LOCAL( void )\n-  af_warper_compute( AF_Warper      warper,\n-                     AF_GlyphHints  hints,\n-                     AF_Dimension   dim,\n-                     FT_Fixed      *a_scale,\n-                     FT_Pos        *a_delta );\n-#endif\n-\n-\n-FT_END_HEADER\n-\n-\n-#endif \/* AFWARP_H_ *\/\n-\n-\n-\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afwarp.h","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/****************************************************************************\n- *\n- * afwrtsys.h\n- *\n- *   Auto-fitter writing systems (specification only).\n- *\n- * Copyright (C) 2013-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-#ifndef AFWRTSYS_H_\n-#define AFWRTSYS_H_\n-\n-  \/* Since preprocessor directives can't create other preprocessor *\/\n-  \/* directives, we have to include the header files manually.     *\/\n-\n-#include \"afdummy.h\"\n-#include \"aflatin.h\"\n-#include \"afcjk.h\"\n-#include \"afindic.h\"\n-#ifdef FT_OPTION_AUTOFIT2\n-#include \"aflatin2.h\"\n-#endif\n-\n-#endif \/* AFWRTSYS_H_ *\/\n-\n-\n-  \/* The following part can be included multiple times. *\/\n-  \/* Define `WRITING_SYSTEM' as needed.                 *\/\n-\n-\n-  \/* Add new writing systems here.  The arguments are the writing system *\/\n-  \/* name in lowercase and uppercase, respectively.                      *\/\n-\n-  WRITING_SYSTEM( dummy,  DUMMY  )\n-  WRITING_SYSTEM( latin,  LATIN  )\n-  WRITING_SYSTEM( cjk,    CJK    )\n-  WRITING_SYSTEM( indic,  INDIC  )\n-#ifdef FT_OPTION_AUTOFIT2\n-  WRITING_SYSTEM( latin2, LATIN2 )\n-#endif\n-\n-\n-\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afwrtsys.h","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -0,0 +1,33 @@\n+\/****************************************************************************\n+ *\n+ * afws-decl.h\n+ *\n+ *   Auto-fitter writing system declarations (specification only).\n+ *\n+ * Copyright (C) 2013-2024 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef AFWS_DECL_H_\n+#define AFWS_DECL_H_\n+\n+  \/* Since preprocessor directives can't create other preprocessor *\/\n+  \/* directives, we have to include the header files manually.     *\/\n+\n+#include \"afdummy.h\"\n+#include \"aflatin.h\"\n+#include \"afcjk.h\"\n+#include \"afindic.h\"\n+\n+#endif \/* AFWS_DECL_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afws-decl.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/****************************************************************************\n+ *\n+ * afws-iter.h\n+ *\n+ *   Auto-fitter writing systems iterator (specification only).\n+ *\n+ * Copyright (C) 2013-2024 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+  \/* This header may be included multiple times. *\/\n+  \/* Define `WRITING_SYSTEM' as needed.          *\/\n+\n+\n+  \/* Add new writing systems here.  The arguments are the writing system *\/\n+  \/* name in lowercase and uppercase, respectively.                      *\/\n+\n+  WRITING_SYSTEM( dummy, DUMMY )\n+  WRITING_SYSTEM( latin, LATIN )\n+  WRITING_SYSTEM( cjk,   CJK   )\n+  WRITING_SYSTEM( indic, INDIC )\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/autofit\/afws-iter.h","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2024 by\n@@ -26,1 +26,1 @@\n-  _ft_face_scale_advances( FT_Face    face,\n+  ft_face_scale_advances_( FT_Face    face,\n@@ -99,1 +99,1 @@\n-        return _ft_face_scale_advances( face, padvance, 1, flags );\n+        return ft_face_scale_advances_( face, padvance, 1, flags );\n@@ -145,1 +145,1 @@\n-        return _ft_face_scale_advances( face, padvances, count, flags );\n+        return ft_face_scale_advances_( face, padvances, count, flags );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftadvanc.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2024 by\n@@ -31,0 +31,1 @@\n+  FT_DECLARE_GLYPH( ft_svg_glyph_class )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftbase.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -85,3 +85,3 @@\n-  static int\n-  BBox_Move_To( FT_Vector*  to,\n-                TBBox_Rec*  user )\n+  FT_CALLBACK_DEF( int )\n+  BBox_Move_To( const FT_Vector*  to,\n+                void*             user_ )\n@@ -89,0 +89,3 @@\n+    TBBox_Rec*  user = (TBBox_Rec*)user_;\n+\n+\n@@ -119,3 +122,3 @@\n-  static int\n-  BBox_Line_To( FT_Vector*  to,\n-                TBBox_Rec*  user )\n+  FT_CALLBACK_DEF( int )\n+  BBox_Line_To( const FT_Vector*  to,\n+                void*             user_ )\n@@ -123,0 +126,3 @@\n+    TBBox_Rec*  user = (TBBox_Rec*)user_;\n+\n+\n@@ -208,4 +214,4 @@\n-  static int\n-  BBox_Conic_To( FT_Vector*  control,\n-                 FT_Vector*  to,\n-                 TBBox_Rec*  user )\n+  FT_CALLBACK_DEF( int )\n+  BBox_Conic_To( const FT_Vector*  control,\n+                 const FT_Vector*  to,\n+                 void*             user_ )\n@@ -213,0 +219,3 @@\n+    TBBox_Rec*  user = (TBBox_Rec*)user_;\n+\n+\n@@ -413,5 +422,5 @@\n-  static int\n-  BBox_Cubic_To( FT_Vector*  control1,\n-                 FT_Vector*  control2,\n-                 FT_Vector*  to,\n-                 TBBox_Rec*  user )\n+  FT_CALLBACK_DEF( int )\n+  BBox_Cubic_To( const FT_Vector*  control1,\n+                 const FT_Vector*  control2,\n+                 const FT_Vector*  to,\n+                 void*             user_ )\n@@ -419,0 +428,3 @@\n+    TBBox_Rec*  user = (TBBox_Rec*)user_;\n+\n+\n@@ -480,1 +492,1 @@\n-    if ( outline->n_points == 0 || outline->n_contours <= 0 )\n+    if ( outline->n_points == 0 || outline->n_contours == 0 )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftbbox.c","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n@@ -69,5 +69,2 @@\n-\n-    FT_Int    pitch;\n-    FT_ULong  size;\n-\n-    FT_Int  source_pitch_sign, target_pitch_sign;\n+    FT_Int     pitch;\n+    FT_Int     flip;\n@@ -85,2 +82,2 @@\n-    source_pitch_sign = source->pitch < 0 ? -1 : 1;\n-    target_pitch_sign = target->pitch < 0 ? -1 : 1;\n+    flip = ( source->pitch < 0 && target->pitch > 0 ) ||\n+           ( source->pitch > 0 && target->pitch < 0 );\n@@ -88,5 +85,7 @@\n-    if ( !source->buffer )\n-    {\n-      *target = *source;\n-      if ( source_pitch_sign != target_pitch_sign )\n-        target->pitch = -target->pitch;\n+    memory = library->memory;\n+    FT_FREE( target->buffer );\n+\n+    *target = *source;\n+\n+    if ( flip )\n+      target->pitch = -target->pitch;\n@@ -94,0 +93,1 @@\n+    if ( !source->buffer )\n@@ -95,1 +95,0 @@\n-    }\n@@ -97,1 +96,0 @@\n-    memory = library->memory;\n@@ -99,1 +97,0 @@\n-\n@@ -102,6 +99,0 @@\n-    size = (FT_ULong)pitch * source->rows;\n-\n-    if ( target->buffer )\n-    {\n-      FT_Int    target_pitch = target->pitch;\n-      FT_ULong  target_size;\n@@ -109,10 +100,1 @@\n-\n-      if ( target_pitch < 0 )\n-        target_pitch = -target_pitch;\n-      target_size = (FT_ULong)target_pitch * target->rows;\n-\n-      if ( target_size != size )\n-        (void)FT_QREALLOC( target->buffer, target_size, size );\n-    }\n-    else\n-      (void)FT_QALLOC( target->buffer, size );\n+    FT_MEM_QALLOC_MULT( target->buffer, target->rows, pitch );\n@@ -122,10 +104,1 @@\n-      unsigned char *p;\n-\n-\n-      p = target->buffer;\n-      *target = *source;\n-      target->buffer = p;\n-\n-      if ( source_pitch_sign == target_pitch_sign )\n-        FT_MEM_COPY( target->buffer, source->buffer, size );\n-      else\n+      if ( flip )\n@@ -149,0 +122,3 @@\n+      else\n+        FT_MEM_COPY( target->buffer, source->buffer,\n+                     (FT_Long)source->rows * pitch );\n@@ -483,1 +459,1 @@\n-     *   https:\/\/accessibility.kde.org\/hsl-adjusted.php\n+     *   http:\/\/www.brucelindbloom.com\/index.html?WorkingSpaceInfo.html#SideNotes\n@@ -491,3 +467,3 @@\n-    l = (  4732UL \/* 0.0722 * 65536 *\/ * bgra[0] * bgra[0] +\n-          46871UL \/* 0.7152 * 65536 *\/ * bgra[1] * bgra[1] +\n-          13933UL \/* 0.2126 * 65536 *\/ * bgra[2] * bgra[2] ) >> 16;\n+    l = (  4731UL \/* 0.072186 * 65536 *\/ * bgra[0] * bgra[0] +\n+          46868UL \/* 0.715158 * 65536 *\/ * bgra[1] * bgra[1] +\n+          13937UL \/* 0.212656 * 65536 *\/ * bgra[2] * bgra[2] ) >> 16;\n@@ -545,2 +521,3 @@\n-        FT_Int    pad, old_target_pitch, target_pitch;\n-        FT_ULong  old_size;\n+        FT_Int  width = (FT_Int)source->width;\n+        FT_Int  neg   = ( target->pitch == 0 && source->pitch < 0 ) ||\n+                          target->pitch  < 0;\n@@ -549,5 +526,1 @@\n-        old_target_pitch = target->pitch;\n-        if ( old_target_pitch < 0 )\n-          old_target_pitch = -old_target_pitch;\n-\n-        old_size = target->rows * (FT_UInt)old_target_pitch;\n+        FT_Bitmap_Done( library, target );\n@@ -559,2 +532,1 @@\n-        pad = 0;\n-        if ( alignment > 0 )\n+        if ( alignment )\n@@ -562,4 +534,1 @@\n-          pad = (FT_Int)source->width % alignment;\n-          if ( pad != 0 )\n-            pad = alignment - pad;\n-        }\n+          FT_Int  rem = width % alignment;\n@@ -567,1 +536,0 @@\n-        target_pitch = (FT_Int)source->width + pad;\n@@ -569,3 +537,4 @@\n-        if ( target_pitch > 0                                               &&\n-             (FT_ULong)target->rows > FT_ULONG_MAX \/ (FT_ULong)target_pitch )\n-          return FT_THROW( Invalid_Argument );\n+          if ( rem )\n+            width = alignment > 0 ? width - rem + alignment\n+                                  : width - rem - alignment;\n+        }\n@@ -573,2 +542,1 @@\n-        if ( FT_QREALLOC( target->buffer,\n-                          old_size, target->rows * (FT_UInt)target_pitch ) )\n+        if ( FT_QALLOC_MULT( target->buffer, target->rows, width ) )\n@@ -577,1 +545,1 @@\n-        target->pitch = target->pitch < 0 ? -target_pitch : target_pitch;\n+        target->pitch = neg ? -width : width;\n@@ -910,2 +878,2 @@\n-    FT_TRACE5(( \"FT_Bitmap_Blend:\\n\"\n-                \"  source bitmap: (%ld, %ld) -- (%ld, %ld); %d x %d\\n\",\n+    FT_TRACE5(( \"FT_Bitmap_Blend:\\n\" ));\n+    FT_TRACE5(( \"  source bitmap: (%ld, %ld) -- (%ld, %ld); %d x %d\\n\",\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftbitmap.c","additions":36,"deletions":68,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -48,1 +48,1 @@\n-#ifndef FT_LONG64\n+#ifndef FT_INT64\n@@ -57,1 +57,1 @@\n-#endif \/* !FT_LONG64 *\/\n+#endif \/* !FT_INT64 *\/\n@@ -72,7 +72,9 @@\n-#define FT_MOVE_SIGN( x, x_unsigned, s ) \\\n-  FT_BEGIN_STMNT                         \\\n-    if ( x < 0 )                         \\\n-    {                                    \\\n-      x_unsigned = 0U - (x_unsigned);    \\\n-      s          = -s;                   \\\n-    }                                    \\\n+#define FT_MOVE_SIGN( utype, x, x_unsigned, s ) \\\n+  FT_BEGIN_STMNT                                \\\n+    if ( x < 0 )                                \\\n+    {                                           \\\n+      x_unsigned = 0U - (utype)x;               \\\n+      s          = -s;                          \\\n+    }                                           \\\n+    else                                        \\\n+      x_unsigned = (utype)x;                    \\\n@@ -82,1 +84,1 @@\n-  \/* FT_LONG64 is defined.                                             *\/\n+  \/* FT_INT64 is defined.                                              *\/\n@@ -112,1 +114,1 @@\n-  FT_BASE_DEF ( FT_Int )\n+  FT_BASE_DEF( FT_Int )\n@@ -167,1 +169,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n@@ -182,7 +184,3 @@\n-    a = (FT_UInt64)a_;\n-    b = (FT_UInt64)b_;\n-    c = (FT_UInt64)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt64, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt64, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt64, c_, c, s );\n@@ -211,7 +209,3 @@\n-    a = (FT_UInt64)a_;\n-    b = (FT_UInt64)b_;\n-    c = (FT_UInt64)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt64, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt64, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt64, c_, c, s );\n@@ -260,5 +254,2 @@\n-    a = (FT_UInt64)a_;\n-    b = (FT_UInt64)b_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt64, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt64, b_, b, s );\n@@ -275,1 +266,1 @@\n-#else \/* !FT_LONG64 *\/\n+#else \/* !FT_INT64 *\/\n@@ -425,7 +416,3 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-    c = (FT_UInt32)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, c_, c, s );\n@@ -473,7 +460,3 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-    c = (FT_UInt32)c_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n-    FT_MOVE_SIGN( c_, c, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, c_, c, s );\n@@ -578,5 +561,2 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n@@ -617,5 +597,2 @@\n-    a = (FT_UInt32)a_;\n-    b = (FT_UInt32)b_;\n-\n-    FT_MOVE_SIGN( a_, a, s );\n-    FT_MOVE_SIGN( b_, b, s );\n+    FT_MOVE_SIGN( FT_UInt32, a_, a, s );\n+    FT_MOVE_SIGN( FT_UInt32, b_, b, s );\n@@ -654,1 +631,1 @@\n-#endif \/* !FT_LONG64 *\/\n+#endif \/* !FT_INT64 *\/\n@@ -752,5 +729,4 @@\n-    FT_Matrix  m;\n-    FT_Fixed   val[4];\n-    FT_Fixed   nonzero_minval, maxval;\n-    FT_Fixed   temp1, temp2;\n-    FT_UInt    i;\n+    FT_Fixed  xx, xy, yx, yy;\n+    FT_Fixed  val;\n+    FT_Int    shift;\n+    FT_ULong  temp1, temp2;\n@@ -762,12 +738,5 @@\n-    val[0] = FT_ABS( matrix->xx );\n-    val[1] = FT_ABS( matrix->xy );\n-    val[2] = FT_ABS( matrix->yx );\n-    val[3] = FT_ABS( matrix->yy );\n-\n-    \/*\n-     * To avoid overflow, we ensure that each value is not larger than\n-     *\n-     *   int(sqrt(2^31 \/ 4)) = 23170  ;\n-     *\n-     * we also check that no value becomes zero if we have to scale.\n-     *\/\n+    xx  = matrix->xx;\n+    xy  = matrix->xy;\n+    yx  = matrix->yx;\n+    yy  = matrix->yy;\n+    val = FT_ABS( xx ) | FT_ABS( xy ) | FT_ABS( yx ) | FT_ABS( yy );\n@@ -775,13 +744,2 @@\n-    maxval         = 0;\n-    nonzero_minval = FT_LONG_MAX;\n-\n-    for ( i = 0; i < 4; i++ )\n-    {\n-      if ( val[i] > maxval )\n-        maxval = val[i];\n-      if ( val[i] && val[i] < nonzero_minval )\n-        nonzero_minval = val[i];\n-    }\n-\n-    \/* we only handle 32bit values *\/\n-    if ( maxval > 0x7FFFFFFFL )\n+    \/* we only handle non-zero 32-bit values *\/\n+    if ( !val || val > 0x7FFFFFFFL )\n@@ -790,4 +748,2 @@\n-    if ( maxval > 23170 )\n-    {\n-      FT_Fixed  scale = FT_DivFix( maxval, 23170 );\n-\n+    \/* Scale matrix to avoid the temp1 overflow, which is *\/\n+    \/* more stringent than avoiding the temp2 overflow.   *\/\n@@ -795,2 +751,1 @@\n-      if ( !FT_DivFix( nonzero_minval, scale ) )\n-        return 0;    \/* value range too large *\/\n+    shift = FT_MSB( val ) - 12;\n@@ -798,4 +753,6 @@\n-      m.xx = FT_DivFix( matrix->xx, scale );\n-      m.xy = FT_DivFix( matrix->xy, scale );\n-      m.yx = FT_DivFix( matrix->yx, scale );\n-      m.yy = FT_DivFix( matrix->yy, scale );\n+    if ( shift > 0 )\n+    {\n+      xx >>= shift;\n+      xy >>= shift;\n+      yx >>= shift;\n+      yy >>= shift;\n@@ -803,2 +760,0 @@\n-    else\n-      m = *matrix;\n@@ -806,2 +761,3 @@\n-    temp1 = FT_ABS( m.xx * m.yy - m.xy * m.yx );\n-    temp2 = m.xx * m.xx + m.xy * m.xy + m.yx * m.yx + m.yy * m.yy;\n+    temp1 = 32U * (FT_ULong)FT_ABS( xx * yy - xy * yx );\n+    temp2 = (FT_ULong)( xx * xx ) + (FT_ULong)( xy * xy ) +\n+            (FT_ULong)( yx * yx ) + (FT_ULong)( yy * yy );\n@@ -809,2 +765,1 @@\n-    if ( temp1 == 0         ||\n-         temp2 \/ temp1 > 50 )\n+    if ( temp1 <= temp2 )\n@@ -854,5 +809,2 @@\n-    x = (FT_UInt32)x_;\n-    y = (FT_UInt32)y_;\n-\n-    FT_MOVE_SIGN( x_, x, sx );\n-    FT_MOVE_SIGN( y_, y, sy );\n+    FT_MOVE_SIGN( FT_UInt32, x_, x, sx );\n+    FT_MOVE_SIGN( FT_UInt32, y_, y, sy );\n@@ -938,2 +890,0 @@\n-#if 0\n-\n@@ -942,2 +892,2 @@\n-  FT_BASE_DEF( FT_Int32 )\n-  FT_SqrtFixed( FT_Int32  x )\n+  FT_BASE_DEF( FT_UInt32 )\n+  FT_SqrtFixed( FT_UInt32  v )\n@@ -945,3 +895,2 @@\n-    FT_UInt32  root, rem_hi, rem_lo, test_div;\n-    FT_Int     count;\n-\n+    if ( v == 0 )\n+      return 0;\n@@ -949,1 +898,1 @@\n-    root = 0;\n+#ifndef FT_INT64\n@@ -951,1 +900,6 @@\n-    if ( x > 0 )\n+    \/* Algorithm by Christophe Meessen (1993) with overflow fixed and     *\/\n+    \/* rounding added.  Any unsigned fixed 16.16 argument is acceptable.  *\/\n+    \/* However, this algorithm is slower than the Babylonian method with  *\/\n+    \/* a good initial guess.  We only use it for large 32-bit values when *\/\n+    \/* 64-bit computations are not desirable.                             *\/\n+    else if ( v > 0x10000U )\n@@ -953,3 +907,6 @@\n-      rem_hi = 0;\n-      rem_lo = (FT_UInt32)x;\n-      count  = 24;\n+      FT_UInt32  r = v >> 1;\n+      FT_UInt32  q = ( v & 1 ) << 15;\n+      FT_UInt32  b = 0x20000000;\n+      FT_UInt32  t;\n+\n+\n@@ -958,6 +915,2 @@\n-        rem_hi   = ( rem_hi << 2 ) | ( rem_lo >> 30 );\n-        rem_lo <<= 2;\n-        root   <<= 1;\n-        test_div = ( root << 1 ) + 1;\n-\n-        if ( rem_hi >= test_div )\n+        t = q + b;\n+        if ( r >= t )\n@@ -965,2 +918,2 @@\n-          rem_hi -= test_div;\n-          root   += 1;\n+          r -= t;\n+          q  = t + b;  \/* equivalent to q += 2*b *\/\n@@ -968,1 +921,6 @@\n-      } while ( --count );\n+        r <<= 1;\n+        b >>= 1;\n+\n+      } while ( b > 0x10 );  \/* exactly 25 cycles *\/\n+\n+      return ( q + 0x40 ) >> 7;\n@@ -970,0 +928,3 @@\n+    else\n+    {\n+      FT_UInt32  r = ( v << 16 ) - 1;\n@@ -971,2 +932,1 @@\n-    return (FT_Int32)root;\n-  }\n+#else \/* FT_INT64 *\/\n@@ -974,1 +934,21 @@\n-#endif \/* 0 *\/\n+    else\n+    {\n+      FT_UInt64  r = ( (FT_UInt64)v << 16 ) - 1;\n+\n+#endif \/* FT_INT64 *\/\n+\n+      FT_UInt32  q = 1 << ( ( 17 + FT_MSB( v ) ) >> 1 );\n+      FT_UInt32  t;\n+\n+\n+      \/* Babylonian method with rounded-up division *\/\n+      do\n+      {\n+        t = q;\n+        q = ( t + (FT_UInt32)( r \/ t ) + 1 ) >> 1;\n+\n+      } while ( q != t );  \/* less than 6 cycles *\/\n+\n+      return q;\n+    }\n+  }\n@@ -988,1 +968,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n@@ -1064,1 +1044,1 @@\n-    \/* vectors is `dominant', this is, much larger than the      *\/\n+    \/* vectors is `dominant', that is, much larger than the      *\/\n@@ -1088,0 +1068,58 @@\n+  FT_BASE_DEF( FT_Int32 )\n+  FT_MulAddFix( FT_Fixed*  s,\n+                FT_Int32*  f,\n+                FT_UInt    count )\n+  {\n+    FT_UInt   i;\n+    FT_Int64  temp;\n+\n+\n+#ifdef FT_INT64\n+    temp = 0;\n+\n+    for ( i = 0; i < count; ++i )\n+      temp += (FT_Int64)s[i] * f[i];\n+\n+    return (FT_Int32)( ( temp + 0x8000 ) >> 16 );\n+#else\n+    temp.hi = 0;\n+    temp.lo = 0;\n+\n+    for ( i = 0; i < count; ++i )\n+    {\n+      FT_Int64  multResult;\n+\n+      FT_Int     sign  = 1;\n+      FT_UInt32  carry = 0;\n+\n+      FT_UInt32  scalar;\n+      FT_UInt32  factor;\n+\n+\n+      FT_MOVE_SIGN( FT_UInt32, s[i], scalar, sign );\n+      FT_MOVE_SIGN( FT_UInt32, f[i], factor, sign );\n+\n+      ft_multo64( scalar, factor, &multResult );\n+\n+      if ( sign < 0 )\n+      {\n+        \/* Emulated `FT_Int64` negation. *\/\n+        carry = ( multResult.lo == 0 );\n+\n+        multResult.lo = ~multResult.lo + 1;\n+        multResult.hi = ~multResult.hi + carry;\n+      }\n+\n+      FT_Add64( &temp, &multResult, &temp );\n+    }\n+\n+    \/* Shift and round value. *\/\n+    return (FT_Int32)( ( ( temp.hi << 16 ) | ( temp.lo >> 16 ) )\n+                                     + ( 1 & ( temp.lo >> 15 ) ) );\n+\n+\n+#endif \/* !FT_INT64 *\/\n+\n+  }\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftcalc.c","additions":173,"deletions":135,"binary":false,"changes":308,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftcid.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/****************************************************************************\n+ *\n+ * ftcolor.c\n+ *\n+ *   FreeType's glyph color management (body).\n+ *\n+ * Copyright (C) 2018-2024 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#include <freetype\/internal\/ftdebug.h>\n+#include <freetype\/internal\/sfnt.h>\n+#include <freetype\/internal\/tttypes.h>\n+#include <freetype\/ftcolor.h>\n+\n+\n+#ifdef TT_CONFIG_OPTION_COLOR_LAYERS\n+\n+  static\n+  const FT_Palette_Data  null_palette_data = { 0, NULL, NULL, 0, NULL };\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Data_Get( FT_Face           face,\n+                       FT_Palette_Data  *apalette_data )\n+  {\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+    if ( !apalette_data)\n+      return FT_THROW( Invalid_Argument );\n+\n+    if ( FT_IS_SFNT( face ) )\n+      *apalette_data = ( (TT_Face)face )->palette_data;\n+    else\n+      *apalette_data = null_palette_data;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Select( FT_Face     face,\n+                     FT_UShort   palette_index,\n+                     FT_Color*  *apalette )\n+  {\n+    FT_Error  error;\n+\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+\n+    if ( !FT_IS_SFNT( face ) )\n+    {\n+      if ( apalette )\n+        *apalette = NULL;\n+\n+      return FT_Err_Ok;\n+    }\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    error = sfnt->set_palette( ttface, palette_index );\n+    if ( error )\n+      return error;\n+\n+    ttface->palette_index = palette_index;\n+\n+    if ( apalette )\n+      *apalette = ttface->palette;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\n+                                   FT_Color  foreground_color )\n+  {\n+    TT_Face  ttface;\n+\n+\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return FT_Err_Ok;\n+\n+    ttface = (TT_Face)face;\n+\n+    ttface->foreground_color      = foreground_color;\n+    ttface->have_foreground_color = 1;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+#else \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Data_Get( FT_Face           face,\n+                       FT_Palette_Data  *apalette_data )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( apalette_data );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Select( FT_Face     face,\n+                     FT_UShort   palette_index,\n+                     FT_Color*  *apalette )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( palette_index );\n+    FT_UNUSED( apalette );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\n+                                   FT_Color  foreground_color )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( foreground_color );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+#endif \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\n+\n+\n+\/* END *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftcolor.c","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -38,2 +38,2 @@\n-  FT_BASE_DEF( const char* )  _ft_debug_file   = NULL;\n-  FT_BASE_DEF( long )         _ft_debug_lineno = 0;\n+  FT_BASE_DEF( const char* )  ft_debug_file_   = NULL;\n+  FT_BASE_DEF( long )         ft_debug_lineno_ = 0;\n@@ -305,40 +305,0 @@\n-  static FT_MemTable\n-  ft_mem_table_new( FT_Memory  memory )\n-  {\n-    FT_MemTable  table;\n-\n-\n-    table = (FT_MemTable)memory->alloc( memory, sizeof ( *table ) );\n-    if ( !table )\n-      goto Exit;\n-\n-    FT_ZERO( table );\n-\n-    table->size  = FT_MEM_SIZE_MIN;\n-    table->nodes = 0;\n-\n-    table->memory = memory;\n-\n-    table->memory_user = memory->user;\n-\n-    table->alloc   = memory->alloc;\n-    table->realloc = memory->realloc;\n-    table->free    = memory->free;\n-\n-    table->buckets = (FT_MemNode *)\n-                       memory->alloc(\n-                         memory,\n-                         table->size * (FT_Long)sizeof ( FT_MemNode ) );\n-    if ( table->buckets )\n-      FT_ARRAY_ZERO( table->buckets, table->size );\n-    else\n-    {\n-      memory->free( memory, table );\n-      table = NULL;\n-    }\n-\n-  Exit:\n-    return table;\n-  }\n-\n-\n@@ -353,2 +313,0 @@\n-    FT_DumpMemory( table->memory );\n-\n@@ -416,2 +374,0 @@\n-    ft_mem_table_free( table, table );\n-\n@@ -462,2 +418,2 @@\n-    hash  = (FT_UInt32)(FT_PtrDist)(void*)_ft_debug_file +\n-              (FT_UInt32)( 5 * _ft_debug_lineno );\n+    hash  = (FT_UInt32)(FT_PtrDist)(void*)ft_debug_file_ +\n+              (FT_UInt32)( 5 * ft_debug_lineno_ );\n@@ -472,2 +428,2 @@\n-      if ( node->file_name == _ft_debug_file   &&\n-           node->line_no   == _ft_debug_lineno )\n+      if ( node->file_name == ft_debug_file_   &&\n+           node->line_no   == ft_debug_lineno_ )\n@@ -484,2 +440,2 @@\n-    node->file_name = _ft_debug_file;\n-    node->line_no   = _ft_debug_lineno;\n+    node->file_name = ft_debug_file_;\n+    node->line_no   = ft_debug_lineno_;\n@@ -542,1 +498,1 @@\n-            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );\n+            FT_FILENAME( ft_debug_file_ ), ft_debug_lineno_ );\n@@ -629,1 +585,1 @@\n-            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno,\n+            FT_FILENAME( ft_debug_file_ ), ft_debug_lineno_,\n@@ -651,2 +607,2 @@\n-          node->free_file_name = _ft_debug_file;\n-          node->free_line_no   = _ft_debug_lineno;\n+          node->free_file_name = ft_debug_file_;\n+          node->free_line_no   = ft_debug_lineno_;\n@@ -674,1 +630,1 @@\n-          FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );\n+          FT_FILENAME( ft_debug_file_ ), ft_debug_lineno_ );\n@@ -708,2 +664,2 @@\n-    _ft_debug_file   = \"<unknown>\";\n-    _ft_debug_lineno = 0;\n+    ft_debug_file_   = \"<unknown>\";\n+    ft_debug_lineno_ = 0;\n@@ -724,2 +680,2 @@\n-                          FT_FILENAME( _ft_debug_file ),\n-                          _ft_debug_lineno );\n+                          FT_FILENAME( ft_debug_file_ ),\n+                          ft_debug_lineno_ );\n@@ -734,2 +690,2 @@\n-    _ft_debug_file   = \"<unknown>\";\n-    _ft_debug_lineno = 0;\n+    ft_debug_file_   = \"<unknown>\";\n+    ft_debug_lineno_ = 0;\n@@ -750,2 +706,2 @@\n-    const char*  file_name = FT_FILENAME( _ft_debug_file );\n-    FT_Long      line_no   = _ft_debug_lineno;\n+    const char*  file_name = FT_FILENAME( ft_debug_file_ );\n+    FT_Long      line_no   = ft_debug_lineno_;\n@@ -814,2 +770,2 @@\n-    _ft_debug_file   = \"<unknown>\";\n-    _ft_debug_lineno = 0;\n+    ft_debug_file_   = \"<unknown>\";\n+    ft_debug_lineno_ = 0;\n@@ -824,1 +780,1 @@\n-  extern FT_Int\n+  extern void\n@@ -828,1 +784,0 @@\n-    FT_Int       result = 0;\n@@ -831,1 +786,6 @@\n-    if ( ft_getenv( \"FT2_DEBUG_MEMORY\" ) )\n+    if ( !ft_getenv( \"FT2_DEBUG_MEMORY\" ) )\n+      return;\n+\n+    table = (FT_MemTable)memory->alloc( memory, sizeof ( *table ) );\n+\n+    if ( table )\n@@ -833,2 +793,11 @@\n-      table = ft_mem_table_new( memory );\n-      if ( table )\n+      FT_ZERO( table );\n+\n+      table->memory      = memory;\n+      table->memory_user = memory->user;\n+      table->alloc       = memory->alloc;\n+      table->realloc     = memory->realloc;\n+      table->free        = memory->free;\n+\n+      ft_mem_table_resize( table );\n+\n+      if ( table->size )\n@@ -879,2 +848,0 @@\n-\n-        result = 1;\n@@ -882,0 +849,2 @@\n+      else\n+        memory->free( memory, table );\n@@ -883,1 +852,0 @@\n-    return result;\n@@ -890,1 +858,3 @@\n-    FT_MemTable  table = (FT_MemTable)memory->user;\n+    if ( memory->free == ft_mem_debug_free )\n+    {\n+      FT_MemTable  table = (FT_MemTable)memory->user;\n@@ -893,2 +863,4 @@\n-    if ( table )\n-    {\n+      FT_DumpMemory( memory );\n+\n+      ft_mem_table_destroy( table );\n+\n@@ -898,0 +870,1 @@\n+      memory->user    = table->memory_user;\n@@ -899,2 +872,1 @@\n-      ft_mem_table_destroy( table );\n-      memory->user = NULL;\n+      memory->free( memory, table );\n@@ -905,1 +877,1 @@\n-  static int\n+  FT_COMPARE_DEF( int )\n@@ -925,4 +897,1 @@\n-    FT_MemTable  table = (FT_MemTable)memory->user;\n-\n-\n-    if ( table )\n+    if ( memory->free == ft_mem_debug_free )\n@@ -930,0 +899,1 @@\n+      FT_MemTable    table = (FT_MemTable)memory->user;\n@@ -996,1 +966,1 @@\n-  typedef int  _debug_mem_dummy;\n+  typedef int  debug_mem_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftdbgmem.c","additions":57,"deletions":87,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -45,0 +45,1 @@\n+#include <freetype\/ftlogging.h>\n@@ -46,0 +47,45 @@\n+#include <freetype\/internal\/ftobjs.h>\n+\n+\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/**************************************************************************\n+   *\n+   * Variables used to control logging.\n+   *\n+   * 1. `ft_default_trace_level` stores the value of trace levels, which are\n+   *    provided to FreeType using the `FT2_DEBUG` environment variable.\n+   *\n+   * 2. `ft_fileptr` stores the `FILE*` handle.\n+   *\n+   * 3. `ft_component` is a string that holds the name of `FT_COMPONENT`.\n+   *\n+   * 4. The flag `ft_component_flag` prints the name of `FT_COMPONENT` along\n+   *    with the actual log message if set to true.\n+   *\n+   * 5. The flag `ft_timestamp_flag` prints time along with the actual log\n+   *    message if set to ture.\n+   *\n+   * 6. `ft_have_newline_char` is used to differentiate between a log\n+   *    message with and without a trailing newline character.\n+   *\n+   * 7. `ft_custom_trace_level` stores the custom trace level value, which\n+   *    is provided by the user at run-time.\n+   *\n+   * We use `static` to avoid 'unused variable' warnings.\n+   *\n+   *\/\n+  static const char*  ft_default_trace_level = NULL;\n+  static FILE*        ft_fileptr             = NULL;\n+  static const char*  ft_component           = NULL;\n+  static FT_Bool      ft_component_flag      = FALSE;\n+  static FT_Bool      ft_timestamp_flag      = FALSE;\n+  static FT_Bool      ft_have_newline_char   = TRUE;\n+  static const char*  ft_custom_trace_level  = NULL;\n+\n+  \/* declared in ftdebug.h *\/\n+\n+  dlg_handler            ft_default_log_handler = NULL;\n+  FT_Custom_Log_Handler  custom_output_handler  = NULL;\n+\n+#endif \/* FT_DEBUG_LOGGING *\/\n@@ -109,1 +155,0 @@\n-\n@@ -198,1 +243,2 @@\n-    const char*  ft2_debug = ft_getenv( \"FT2_DEBUG\" );\n+    const char*  ft2_debug = NULL;\n+\n@@ -200,0 +246,8 @@\n+#ifdef FT_DEBUG_LOGGING\n+    if ( ft_custom_trace_level != NULL )\n+      ft2_debug = ft_custom_trace_level;\n+    else\n+      ft2_debug = ft_default_trace_level;\n+#else\n+    ft2_debug = ft_getenv( \"FT2_DEBUG\" );\n+#endif\n@@ -213,0 +267,43 @@\n+#ifdef FT_DEBUG_LOGGING\n+\n+        \/* check extra arguments for logging *\/\n+        if ( *p == '-' )\n+        {\n+          const char*  r = ++p;\n+\n+\n+          if ( *r == 'v' )\n+          {\n+            const char*  s = ++r;\n+\n+\n+            ft_component_flag = TRUE;\n+\n+            if ( *s == 't' )\n+            {\n+              ft_timestamp_flag = TRUE;\n+              p++;\n+            }\n+\n+            p++;\n+          }\n+\n+          else if ( *r == 't' )\n+          {\n+            const char*  s = ++r;\n+\n+\n+            ft_timestamp_flag = TRUE;\n+\n+            if ( *s == 'v' )\n+            {\n+              ft_component_flag = TRUE;\n+              p++;\n+            }\n+\n+            p++;\n+          }\n+        }\n+\n+#endif \/* FT_DEBUG_LOGGING *\/\n+\n@@ -314,1 +411,0 @@\n-\n@@ -318,0 +414,230 @@\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/**************************************************************************\n+   *\n+   * Initialize and de-initialize 'dlg' library.\n+   *\n+   *\/\n+\n+  FT_BASE_DEF( void )\n+  ft_logging_init( void )\n+  {\n+    ft_default_log_handler = ft_log_handler;\n+    ft_default_trace_level = ft_getenv( \"FT2_DEBUG\" );\n+\n+    if ( ft_getenv( \"FT_LOGGING_FILE\" ) )\n+      ft_fileptr = ft_fopen( ft_getenv( \"FT_LOGGING_FILE\" ), \"w\" );\n+    else\n+      ft_fileptr = stderr;\n+\n+    ft_debug_init();\n+\n+    \/* Set the default output handler for 'dlg'. *\/\n+    dlg_set_handler( ft_default_log_handler, NULL );\n+  }\n+\n+\n+  FT_BASE_DEF( void )\n+  ft_logging_deinit( void )\n+  {\n+    if ( ft_fileptr != stderr )\n+      ft_fclose( ft_fileptr );\n+  }\n+\n+\n+  \/**************************************************************************\n+   *\n+   * An output log handler for FreeType.\n+   *\n+   *\/\n+  FT_BASE_DEF( void )\n+  ft_log_handler( const struct dlg_origin*  origin,\n+                  const char*               string,\n+                  void*                     data )\n+  {\n+    char         features_buf[128];\n+    char*        bufp = features_buf;\n+\n+    FT_UNUSED( data );\n+\n+\n+    if ( ft_have_newline_char )\n+    {\n+      const char*  features        = NULL;\n+      size_t       features_length = 0;\n+\n+\n+#define FEATURES_TIMESTAMP            \"[%h:%m] \"\n+#define FEATURES_COMPONENT            \"[%t] \"\n+#define FEATURES_TIMESTAMP_COMPONENT  \"[%h:%m %t] \"\n+\n+      if ( ft_timestamp_flag && ft_component_flag )\n+      {\n+        features        = FEATURES_TIMESTAMP_COMPONENT;\n+        features_length = sizeof ( FEATURES_TIMESTAMP_COMPONENT );\n+      }\n+      else if ( ft_timestamp_flag )\n+      {\n+        features        = FEATURES_TIMESTAMP;\n+        features_length = sizeof ( FEATURES_TIMESTAMP );\n+      }\n+      else if ( ft_component_flag )\n+      {\n+        features        = FEATURES_COMPONENT;\n+        features_length = sizeof ( FEATURES_COMPONENT );\n+      }\n+\n+      if ( ft_component_flag || ft_timestamp_flag )\n+      {\n+        ft_strncpy( features_buf, features, features_length );\n+        bufp += features_length - 1;\n+      }\n+\n+      if ( ft_component_flag )\n+      {\n+        size_t  tag_length = ft_strlen( *origin->tags );\n+        size_t  i;\n+\n+\n+        \/* To vertically align tracing messages we compensate the *\/\n+        \/* different FT_COMPONENT string lengths by inserting an  *\/\n+        \/* appropriate amount of space characters.                *\/\n+        for ( i = 0;\n+              i < FT_MAX_TRACE_LEVEL_LENGTH - tag_length;\n+              i++ )\n+          *bufp++ = ' ';\n+      }\n+    }\n+\n+    \/* Finally add the format string for the tracing message. *\/\n+    *bufp++ = '%';\n+    *bufp++ = 'c';\n+    *bufp   = '\\0';\n+\n+    dlg_generic_outputf_stream( ft_fileptr,\n+                                (const char*)features_buf,\n+                                origin,\n+                                string,\n+                                dlg_default_output_styles,\n+                                true );\n+\n+    if ( ft_strrchr( string, '\\n' ) )\n+      ft_have_newline_char = TRUE;\n+    else\n+      ft_have_newline_char = FALSE;\n+  }\n+\n+\n+  \/* documentation is in ftdebug.h *\/\n+  FT_BASE_DEF( void )\n+  ft_add_tag( const char*  tag )\n+  {\n+    ft_component = tag;\n+\n+    dlg_add_tag( tag, NULL );\n+  }\n+\n+\n+  \/* documentation is in ftdebug.h *\/\n+  FT_BASE_DEF( void )\n+  ft_remove_tag( const char*  tag )\n+  {\n+    dlg_remove_tag( tag, NULL );\n+  }\n+\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Level( const char*  level )\n+  {\n+    ft_component_flag     = FALSE;\n+    ft_timestamp_flag     = FALSE;\n+    ft_custom_trace_level = level;\n+\n+    ft_debug_init();\n+  }\n+\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Default_Level( void )\n+  {\n+    ft_component_flag     = FALSE;\n+    ft_timestamp_flag     = FALSE;\n+    ft_custom_trace_level = NULL;\n+\n+    ft_debug_init();\n+  }\n+\n+\n+  \/**************************************************************************\n+   *\n+   * Functions to handle a custom log handler.\n+   *\n+   *\/\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Log_Handler( FT_Custom_Log_Handler  handler )\n+  {\n+    custom_output_handler = handler;\n+  }\n+\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Default_Log_Handler( void )\n+  {\n+    custom_output_handler = NULL;\n+  }\n+\n+\n+  \/* documentation is in ftdebug.h *\/\n+  FT_BASE_DEF( void )\n+  FT_Logging_Callback( const char*  fmt,\n+                       ... )\n+  {\n+    va_list  ap;\n+\n+\n+    va_start( ap, fmt );\n+    custom_output_handler( ft_component, fmt, ap );\n+    va_end( ap );\n+  }\n+\n+#else \/* !FT_DEBUG_LOGGING *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Level( const char*  level )\n+  {\n+    FT_UNUSED( level );\n+  }\n+\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Default_Level( void )\n+  {\n+    \/* nothing *\/\n+  }\n+\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Log_Handler( FT_Custom_Log_Handler  handler )\n+  {\n+    FT_UNUSED( handler );\n+  }\n+\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Default_Log_Handler( void )\n+  {\n+    \/* nothing *\/\n+  }\n+\n+#endif \/* !FT_DEBUG_LOGGING *\/\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftdebug.c","additions":330,"deletions":4,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftfntfmt.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftfstype.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftgasp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -215,1 +215,1 @@\n-    FT_UInt      new_max, old_max;\n+    FT_UInt  new_max, old_max, min_new_max;\n@@ -220,1 +220,1 @@\n-      return error;\n+      goto Exit;\n@@ -229,1 +229,5 @@\n-      new_max = FT_PAD_CEIL( new_max, 8 );\n+      if ( new_max > FT_OUTLINE_POINTS_MAX )\n+      {\n+        error = FT_THROW( Array_Too_Large );\n+        goto Exit;\n+      }\n@@ -231,0 +235,4 @@\n+      min_new_max = old_max + ( old_max >> 1 );\n+      if ( new_max < min_new_max )\n+        new_max = min_new_max;\n+      new_max = FT_PAD_CEIL( new_max, 8 );\n@@ -232,1 +240,1 @@\n-        return FT_THROW( Array_Too_Large );\n+        new_max = FT_OUTLINE_POINTS_MAX;\n@@ -257,1 +265,1 @@\n-      return error;\n+      goto Exit;\n@@ -265,1 +273,5 @@\n-      new_max = FT_PAD_CEIL( new_max, 4 );\n+      if ( new_max > FT_OUTLINE_CONTOURS_MAX )\n+      {\n+        error = FT_THROW( Array_Too_Large );\n+        goto Exit;\n+      }\n@@ -267,0 +279,4 @@\n+      min_new_max = old_max + ( old_max >> 1 );\n+      if ( new_max < min_new_max )\n+        new_max = min_new_max;\n+      new_max = FT_PAD_CEIL( new_max, 4 );\n@@ -268,1 +284,1 @@\n-        return FT_THROW( Array_Too_Large );\n+        new_max = FT_OUTLINE_CONTOURS_MAX;\n@@ -342,6 +358,3 @@\n-    FT_GlyphLoad  base;\n-    FT_GlyphLoad  current;\n-\n-    FT_Int        n_curr_contours;\n-    FT_Int        n_base_points;\n-    FT_Int        n;\n+    FT_Outline*  base;\n+    FT_Outline*  current;\n+    FT_Int       n;\n@@ -353,5 +366,2 @@\n-    base    = &loader->base;\n-    current = &loader->current;\n-\n-    n_curr_contours = current->outline.n_contours;\n-    n_base_points   = base->outline.n_points;\n+    base    = &loader->base.outline;\n+    current = &loader->current.outline;\n@@ -359,4 +369,3 @@\n-    base->outline.n_points =\n-      (short)( base->outline.n_points + current->outline.n_points );\n-    base->outline.n_contours =\n-      (short)( base->outline.n_contours + current->outline.n_contours );\n+    \/* adjust contours count in newest outline *\/\n+    for ( n = 0; n < current->n_contours; n++ )\n+      current->contours[n] += base->n_points;\n@@ -364,1 +373,2 @@\n-    base->num_subglyphs += current->num_subglyphs;\n+    base->n_points   += current->n_points;\n+    base->n_contours += current->n_contours;\n@@ -366,4 +376,1 @@\n-    \/* adjust contours count in newest outline *\/\n-    for ( n = 0; n < n_curr_contours; n++ )\n-      current->outline.contours[n] =\n-        (short)( current->outline.contours[n] + n_base_points );\n+    loader->base.num_subglyphs += loader->current.num_subglyphs;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftgloadr.c","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -37,0 +37,1 @@\n+#include <freetype\/otsvg.h>\n@@ -280,0 +281,234 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+\n+  \/*************************************************************************\/\n+  \/*************************************************************************\/\n+  \/****                                                                 ****\/\n+  \/****   FT_SvgGlyph support                                           ****\/\n+  \/****                                                                 ****\/\n+  \/*************************************************************************\/\n+  \/*************************************************************************\/\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  ft_svg_glyph_init( FT_Glyph      svg_glyph,\n+                     FT_GlyphSlot  slot )\n+  {\n+    FT_ULong         doc_length;\n+    FT_SVG_Document  document;\n+    FT_SvgGlyph      glyph = (FT_SvgGlyph)svg_glyph;\n+\n+    FT_Error   error  = FT_Err_Ok;\n+    FT_Memory  memory = FT_GLYPH( glyph )->library->memory;\n+\n+\n+    if ( slot->format != FT_GLYPH_FORMAT_SVG )\n+    {\n+      error = FT_THROW( Invalid_Glyph_Format );\n+      goto Exit;\n+    }\n+\n+    if ( slot->other == NULL )\n+    {\n+      error = FT_THROW( Invalid_Slot_Handle );\n+      goto Exit;\n+    }\n+\n+    document = (FT_SVG_Document)slot->other;\n+\n+    if ( document->svg_document_length == 0 )\n+    {\n+      error = FT_THROW( Invalid_Slot_Handle );\n+      goto Exit;\n+    }\n+\n+    \/* allocate a new document *\/\n+    doc_length = document->svg_document_length;\n+    if ( FT_QALLOC( glyph->svg_document, doc_length ) )\n+      goto Exit;\n+    glyph->svg_document_length = doc_length;\n+\n+    glyph->glyph_index = slot->glyph_index;\n+\n+    glyph->metrics      = document->metrics;\n+    glyph->units_per_EM = document->units_per_EM;\n+\n+    glyph->start_glyph_id = document->start_glyph_id;\n+    glyph->end_glyph_id   = document->end_glyph_id;\n+\n+    glyph->transform = document->transform;\n+    glyph->delta     = document->delta;\n+\n+    \/* copy the document into glyph *\/\n+    FT_MEM_COPY( glyph->svg_document, document->svg_document, doc_length );\n+\n+  Exit:\n+    return error;\n+  }\n+\n+\n+  FT_CALLBACK_DEF( void )\n+  ft_svg_glyph_done( FT_Glyph  svg_glyph )\n+  {\n+    FT_SvgGlyph  glyph  = (FT_SvgGlyph)svg_glyph;\n+    FT_Memory    memory = svg_glyph->library->memory;\n+\n+\n+    \/* just free the memory *\/\n+    FT_FREE( glyph->svg_document );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  ft_svg_glyph_copy( FT_Glyph  svg_source,\n+                     FT_Glyph  svg_target )\n+  {\n+    FT_SvgGlyph  source = (FT_SvgGlyph)svg_source;\n+    FT_SvgGlyph  target = (FT_SvgGlyph)svg_target;\n+\n+    FT_Error   error  = FT_Err_Ok;\n+    FT_Memory  memory = FT_GLYPH( source )->library->memory;\n+\n+\n+    if ( svg_source->format != FT_GLYPH_FORMAT_SVG )\n+    {\n+      error = FT_THROW( Invalid_Glyph_Format );\n+      goto Exit;\n+    }\n+\n+    if ( source->svg_document_length == 0 )\n+    {\n+      error = FT_THROW( Invalid_Slot_Handle );\n+      goto Exit;\n+    }\n+\n+    target->glyph_index = source->glyph_index;\n+\n+    target->svg_document_length = source->svg_document_length;\n+\n+    target->metrics      = source->metrics;\n+    target->units_per_EM = source->units_per_EM;\n+\n+    target->start_glyph_id = source->start_glyph_id;\n+    target->end_glyph_id   = source->end_glyph_id;\n+\n+    target->transform = source->transform;\n+    target->delta     = source->delta;\n+\n+    \/* allocate space for the SVG document *\/\n+    if ( FT_QALLOC( target->svg_document, target->svg_document_length ) )\n+      goto Exit;\n+\n+    \/* copy the document *\/\n+    FT_MEM_COPY( target->svg_document,\n+                 source->svg_document,\n+                 target->svg_document_length );\n+\n+  Exit:\n+    return error;\n+  }\n+\n+\n+  FT_CALLBACK_DEF( void )\n+  ft_svg_glyph_transform( FT_Glyph          svg_glyph,\n+                          const FT_Matrix*  _matrix,\n+                          const FT_Vector*  _delta )\n+  {\n+    FT_SvgGlyph  glyph  = (FT_SvgGlyph)svg_glyph;\n+    FT_Matrix*   matrix = (FT_Matrix*)_matrix;\n+    FT_Vector*   delta  = (FT_Vector*)_delta;\n+\n+    FT_Matrix  tmp_matrix;\n+    FT_Vector  tmp_delta;\n+\n+    FT_Matrix  a, b;\n+    FT_Pos     x, y;\n+\n+\n+    if ( !matrix )\n+    {\n+      tmp_matrix.xx = 0x10000;\n+      tmp_matrix.xy = 0;\n+      tmp_matrix.yx = 0;\n+      tmp_matrix.yy = 0x10000;\n+\n+      matrix = &tmp_matrix;\n+    }\n+\n+    if ( !delta )\n+    {\n+      tmp_delta.x = 0;\n+      tmp_delta.y = 0;\n+\n+      delta = &tmp_delta;\n+    }\n+\n+    a = glyph->transform;\n+    b = *matrix;\n+    FT_Matrix_Multiply( &b, &a );\n+\n+    x = ADD_LONG( ADD_LONG( FT_MulFix( matrix->xx, glyph->delta.x ),\n+                            FT_MulFix( matrix->xy, glyph->delta.y ) ),\n+                  delta->x );\n+    y = ADD_LONG( ADD_LONG( FT_MulFix( matrix->yx, glyph->delta.x ),\n+                            FT_MulFix( matrix->yy, glyph->delta.y ) ),\n+                  delta->y );\n+\n+    glyph->delta.x = x;\n+    glyph->delta.y = y;\n+\n+    glyph->transform = a;\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  ft_svg_glyph_prepare( FT_Glyph      svg_glyph,\n+                        FT_GlyphSlot  slot )\n+  {\n+    FT_SvgGlyph  glyph = (FT_SvgGlyph)svg_glyph;\n+\n+    FT_Error   error  = FT_Err_Ok;\n+    FT_Memory  memory = svg_glyph->library->memory;\n+\n+    FT_SVG_Document  document = NULL;\n+\n+\n+    if ( FT_NEW( document ) )\n+      return error;\n+\n+    document->svg_document        = glyph->svg_document;\n+    document->svg_document_length = glyph->svg_document_length;\n+\n+    document->metrics      = glyph->metrics;\n+    document->units_per_EM = glyph->units_per_EM;\n+\n+    document->start_glyph_id = glyph->start_glyph_id;\n+    document->end_glyph_id   = glyph->end_glyph_id;\n+\n+    document->transform = glyph->transform;\n+    document->delta     = glyph->delta;\n+\n+    slot->format      = FT_GLYPH_FORMAT_SVG;\n+    slot->glyph_index = glyph->glyph_index;\n+    slot->other       = document;\n+\n+    return error;\n+  }\n+\n+\n+  FT_DEFINE_GLYPH(\n+    ft_svg_glyph_class,\n+\n+    sizeof ( FT_SvgGlyphRec ),\n+    FT_GLYPH_FORMAT_SVG,\n+\n+    ft_svg_glyph_init,      \/* FT_Glyph_InitFunc       glyph_init      *\/\n+    ft_svg_glyph_done,      \/* FT_Glyph_DoneFunc       glyph_done      *\/\n+    ft_svg_glyph_copy,      \/* FT_Glyph_CopyFunc       glyph_copy      *\/\n+    ft_svg_glyph_transform, \/* FT_Glyph_TransformFunc  glyph_transform *\/\n+    NULL,                   \/* FT_Glyph_GetBBoxFunc    glyph_bbox      *\/\n+    ft_svg_glyph_prepare    \/* FT_Glyph_PrepareFunc    glyph_prepare   *\/\n+  )\n+\n+#endif \/* FT_CONFIG_OPTION_SVG *\/\n+\n+\n@@ -380,0 +615,6 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    \/* if it is an SVG glyph *\/\n+    else if ( format == FT_GLYPH_FORMAT_SVG )\n+      clazz = &ft_svg_glyph_class;\n+#endif\n+\n@@ -444,0 +685,1 @@\n+    {\n@@ -445,0 +687,2 @@\n+      *aglyph = NULL;\n+    }\n@@ -456,3 +700,3 @@\n-  FT_Glyph_Transform( FT_Glyph    glyph,\n-                      FT_Matrix*  matrix,\n-                      FT_Vector*  delta )\n+  FT_Glyph_Transform( FT_Glyph          glyph,\n+                      const FT_Matrix*  matrix,\n+                      const FT_Vector*  delta )\n@@ -536,4 +780,4 @@\n-  FT_Glyph_To_Bitmap( FT_Glyph*       the_glyph,\n-                      FT_Render_Mode  render_mode,\n-                      FT_Vector*      origin,\n-                      FT_Bool         destroy )\n+  FT_Glyph_To_Bitmap( FT_Glyph*         the_glyph,\n+                      FT_Render_Mode    render_mode,\n+                      const FT_Vector*  origin,\n+                      FT_Bool           destroy )\n@@ -588,1 +832,1 @@\n-      FT_Glyph_Transform( glyph, 0, origin );\n+      FT_Glyph_Transform( glyph, NULL, origin );\n@@ -598,0 +842,10 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    if ( clazz == &ft_svg_glyph_class )\n+    {\n+      FT_Memory  memory = library->memory;\n+\n+\n+      FT_FREE( dummy.other );\n+    }\n+#endif\n+\n@@ -606,1 +860,1 @@\n-      FT_Glyph_Transform( glyph, 0, &v );\n+      FT_Glyph_Transform( glyph, NULL, &v );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftglyph.c","additions":264,"deletions":10,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-      if ( FT_NEW( nn ) )\n+      if ( FT_QNEW( nn ) )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/fthash.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -205,0 +205,4 @@\n+#ifdef FT_DEBUG_LOGGING\n+    ft_logging_init();\n+#endif\n+\n@@ -251,0 +255,4 @@\n+#ifdef FT_DEBUG_LOGGING\n+    ft_logging_deinit();\n+#endif\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftinit.c","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n@@ -35,1 +35,1 @@\n-  FT_BASE_DEF (void)\n+  FT_BASE_DEF( void )\n@@ -360,1 +360,1 @@\n-                             FT_Vector*  sub )\n+                             FT_Vector   sub[3] )\n@@ -371,1 +371,1 @@\n-  FT_BASE_DEF (void)\n+  FT_BASE_DEF( void )\n@@ -431,1 +431,1 @@\n-    return FT_THROW( Unimplemented_Feature );\n+    return FT_Err_Ok;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftlcdfil.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -70,0 +70,1 @@\n+#include <freetype\/internal\/ftdebug.h>\n@@ -108,1 +109,1 @@\n-#include FT_MAC_H\n+#include <freetype\/ftmac.h>\n@@ -317,1 +318,1 @@\n-    return ((FInfo *)(info.finderInfo))->fdType;\n+    return ( (FInfo *)( info.finderInfo ) )->fdType;\n@@ -465,1 +466,1 @@\n-          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n+          ft_memcpy( ps_name, names[0] + 1, ps_name_len );\n@@ -563,1 +564,1 @@\n-                                 buff, sizeof ( buff )  );\n+                                 buff, sizeof ( buff ) );\n@@ -634,1 +635,1 @@\n-    if ( FT_ALLOC( buffer, (FT_Long)total_size ) )\n+    if ( FT_QALLOC( buffer, (FT_Long)total_size ) )\n@@ -755,1 +756,1 @@\n-    if ( FT_ALLOC( sfnt_data, (FT_Long)sfnt_size ) )\n+    if ( FT_QALLOC( sfnt_data, (FT_Long)sfnt_size ) )\n@@ -814,0 +815,1 @@\n+    FT_Long        count;\n@@ -823,0 +825,1 @@\n+    res_index        = 1;\n@@ -824,1 +827,2 @@\n-    for ( res_index = 1; ; res_index++ )\n+    count            = face_index;\n+    while ( count >= 0 )\n@@ -836,2 +840,2 @@\n-      if ( 0 <= face_index && face_index < num_faces_in_fond && error )\n-        error = FT_New_Face_From_FOND( library, fond, face_index, aface );\n+      if ( count < num_faces_in_fond )\n+        error = FT_New_Face_From_FOND( library, fond, count, aface );\n@@ -839,1 +843,2 @@\n-      face_index -= num_faces_in_fond;\n+      res_index++;\n+      count -= num_faces_in_fond;\n@@ -843,0 +848,1 @@\n+\n@@ -844,1 +850,5 @@\n-      (*aface)->num_faces = num_faces_in_res;\n+    {\n+      (*aface)->num_faces  = num_faces_in_res;\n+      (*aface)->face_index = face_index;\n+    }\n+\n@@ -1084,1 +1094,1 @@\n-  typedef int  _ft_mac_dummy;\n+  typedef int  ft_mac_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftmac.c","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -188,0 +188,8 @@\n+\n+      if ( !error )\n+      {\n+        if ( num_coords )\n+          face->face_flags |= FT_FACE_FLAG_VARIATION;\n+        else\n+          face->face_flags &= ~FT_FACE_FLAG_VARIATION;\n+      }\n@@ -223,0 +231,8 @@\n+\n+      if ( !error )\n+      {\n+        if ( len )\n+          face->face_flags |= FT_FACE_FLAG_VARIATION;\n+        else\n+          face->face_flags &= ~FT_FACE_FLAG_VARIATION;\n+      }\n@@ -286,0 +302,24 @@\n+      if ( !error || error == -1 )\n+      {\n+        FT_Bool  is_variation_old = FT_IS_VARIATION( face );\n+\n+\n+        if ( num_coords )\n+          face->face_flags |= FT_FACE_FLAG_VARIATION;\n+        else\n+          face->face_flags &= ~FT_FACE_FLAG_VARIATION;\n+\n+        if ( service_mm->construct_ps_name )\n+        {\n+          if ( error == -1 )\n+          {\n+            \/* The PS name of a named instance and a non-named instance *\/\n+            \/* usually differs, even if the axis values are identical.  *\/\n+            if ( is_variation_old != FT_IS_VARIATION( face ) )\n+              service_mm->construct_ps_name( face );\n+          }\n+          else\n+            service_mm->construct_ps_name( face );\n+        }\n+      }\n+\n@@ -362,0 +402,24 @@\n+      if ( !error || error == -1 )\n+      {\n+        FT_Bool  is_variation_old = FT_IS_VARIATION( face );\n+\n+\n+        if ( num_coords )\n+          face->face_flags |= FT_FACE_FLAG_VARIATION;\n+        else\n+          face->face_flags &= ~FT_FACE_FLAG_VARIATION;\n+\n+        if ( service_mm->construct_ps_name )\n+        {\n+          if ( error == -1 )\n+          {\n+            \/* The PS name of a named instance and a non-named instance *\/\n+            \/* usually differs, even if the axis values are identical.  *\/\n+            if ( is_variation_old != FT_IS_VARIATION( face ) )\n+              service_mm->construct_ps_name( face );\n+          }\n+          else\n+            service_mm->construct_ps_name( face );\n+        }\n+      }\n+\n@@ -413,0 +477,24 @@\n+      if ( !error || error == -1 )\n+      {\n+        FT_Bool  is_variation_old = FT_IS_VARIATION( face );\n+\n+\n+        if ( num_coords )\n+          face->face_flags |= FT_FACE_FLAG_VARIATION;\n+        else\n+          face->face_flags &= ~FT_FACE_FLAG_VARIATION;\n+\n+        if ( service_mm->construct_ps_name )\n+        {\n+          if ( error == -1 )\n+          {\n+            \/* The PS name of a named instance and a non-named instance *\/\n+            \/* usually differs, even if the axis values are identical.  *\/\n+            if ( is_variation_old != FT_IS_VARIATION( face ) )\n+              service_mm->construct_ps_name( face );\n+          }\n+          else\n+            service_mm->construct_ps_name( face );\n+        }\n+      }\n+\n@@ -538,2 +626,29 @@\n-      if ( service_mm->set_instance )\n-        error = service_mm->set_instance( face, instance_index );\n+      if ( service_mm->set_named_instance )\n+        error = service_mm->set_named_instance( face, instance_index );\n+\n+      if ( !error || error == -1 )\n+      {\n+        FT_Bool  is_variation_old = FT_IS_VARIATION( face );\n+\n+\n+        face->face_flags &= ~FT_FACE_FLAG_VARIATION;\n+        face->face_index  = ( instance_index << 16 )        |\n+                            ( face->face_index & 0xFFFFL );\n+\n+        if ( service_mm->construct_ps_name )\n+        {\n+          if ( error == -1 )\n+          {\n+            \/* The PS name of a named instance and a non-named instance *\/\n+            \/* usually differs, even if the axis values are identical.  *\/\n+            if ( is_variation_old != FT_IS_VARIATION( face ) )\n+              service_mm->construct_ps_name( face );\n+          }\n+          else\n+            service_mm->construct_ps_name( face );\n+        }\n+      }\n+\n+      \/* internal error code -1 means `no change'; we can exit immediately *\/\n+      if ( error == -1 )\n+        return FT_Err_Ok;\n@@ -557,0 +672,18 @@\n+    return error;\n+  }\n+\n+\n+  \/* documentation is in ftmm.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Get_Default_Named_Instance( FT_Face   face,\n+                                 FT_UInt  *instance_index )\n+  {\n+    FT_Error  error;\n+\n+    FT_Service_MultiMasters  service_mm = NULL;\n+\n+\n+    \/* check of `face' delayed to `ft_face_get_mm_service' *\/\n+\n+    error = ft_face_get_mm_service( face, &service_mm );\n@@ -559,3 +692,6 @@\n-      face->face_index  = ( instance_index << 16 )        |\n-                          ( face->face_index & 0xFFFFL );\n-      face->face_flags &= ~FT_FACE_FLAG_VARIATION;\n+      \/* no error if `get_default_named_instance` is not available *\/\n+      if ( service_mm->get_default_named_instance )\n+        error = service_mm->get_default_named_instance( face,\n+                                                        instance_index );\n+      else\n+        error = FT_Err_Ok;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftmm.c","additions":142,"deletions":6,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -22,0 +22,1 @@\n+#include <freetype\/otsvg.h>\n@@ -30,0 +31,1 @@\n+#include <freetype\/internal\/svginterface.h>\n@@ -81,0 +83,3 @@\n+  \/* This array must stay in sync with the @FT_Pixel_Mode enumeration *\/\n+  \/* (in file `ftimage.h`).                                           *\/\n+\n@@ -90,1 +95,2 @@\n-    \"BGRA 32-bit color image bitmap\"\n+    \"BGRA 32-bit color image bitmap\",\n+    \"SDF 8-bit bitmap\"\n@@ -196,0 +202,1 @@\n+    FT_UInt    mode;\n@@ -207,0 +214,2 @@\n+    mode   = args->flags &\n+               ( FT_OPEN_MEMORY | FT_OPEN_STREAM | FT_OPEN_PATHNAME );\n@@ -208,6 +217,1 @@\n-    if ( FT_NEW( stream ) )\n-      goto Exit;\n-\n-    stream->memory = memory;\n-\n-    if ( args->flags & FT_OPEN_MEMORY )\n+    if ( mode == FT_OPEN_MEMORY )\n@@ -216,0 +220,3 @@\n+      if ( FT_NEW( stream ) )\n+        goto Exit;\n+\n@@ -219,0 +226,1 @@\n+      stream->memory = memory;\n@@ -223,1 +231,1 @@\n-    else if ( args->flags & FT_OPEN_PATHNAME )\n+    else if ( mode == FT_OPEN_PATHNAME )\n@@ -226,0 +234,4 @@\n+      if ( FT_NEW( stream ) )\n+        goto Exit;\n+\n+      stream->memory = memory;\n@@ -227,1 +239,2 @@\n-      stream->pathname.pointer = args->pathname;\n+      if ( error )\n+        FT_FREE( stream );\n@@ -229,1 +242,1 @@\n-    else if ( ( args->flags & FT_OPEN_STREAM ) && args->stream )\n+    else if ( ( mode == FT_OPEN_STREAM ) && args->stream )\n@@ -235,2 +248,3 @@\n-      FT_FREE( stream );\n-      stream = args->stream;\n+      stream         = args->stream;\n+      stream->memory = memory;\n+      error          = FT_Err_Ok;\n@@ -242,0 +256,1 @@\n+    {\n@@ -243,0 +258,3 @@\n+      if ( ( args->flags & FT_OPEN_STREAM ) && args->stream )\n+        FT_Stream_Close( args->stream );\n+    }\n@@ -244,6 +262,2 @@\n-    if ( error )\n-      FT_FREE( stream );\n-    else\n-      stream->memory = memory;  \/* just to be certain *\/\n-\n-    *astream = stream;\n+    if ( !error )\n+      *astream       = stream;\n@@ -319,0 +333,13 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    \/* if SVG table exists, allocate the space in `slot->other` *\/\n+    if ( slot->face->face_flags & FT_FACE_FLAG_SVG )\n+    {\n+      FT_SVG_Document  document = NULL;\n+\n+\n+      if ( FT_NEW( document ) )\n+        goto Exit;\n+      slot->other = document;\n+    }\n+#endif\n+\n@@ -363,1 +390,12 @@\n-    if ( slot->format != FT_GLYPH_FORMAT_OUTLINE )\n+    if ( slot->format == FT_GLYPH_FORMAT_SVG )\n+    {\n+      FT_Module    module;\n+      SVG_Service  svg_service;\n+\n+\n+      module      = FT_Get_Module( slot->library, \"ot-svg\" );\n+      svg_service = (SVG_Service)module->clazz->module_interface;\n+\n+      return (FT_Bool)svg_service->preset_slot( module, slot, FALSE );\n+    }\n+    else if ( slot->format != FT_GLYPH_FORMAT_OUTLINE )\n@@ -473,1 +511,1 @@\n-      \/* fall through *\/\n+      FALL_THROUGH;\n@@ -526,1 +564,1 @@\n-    (void)FT_ALLOC( slot->bitmap.buffer, size );\n+    FT_MEM_ALLOC( slot->bitmap.buffer, size );\n@@ -538,0 +576,2 @@\n+    slot->glyph_index = 0;\n+\n@@ -553,2 +593,21 @@\n-    slot->other         = NULL;\n-    slot->format        = FT_GLYPH_FORMAT_NONE;\n+\n+#ifndef FT_CONFIG_OPTION_SVG\n+    slot->other = NULL;\n+#else\n+    if ( !( slot->face->face_flags & FT_FACE_FLAG_SVG ) )\n+      slot->other = NULL;\n+    else\n+    {\n+      if ( slot->internal->flags & FT_GLYPH_OWN_GZIP_SVG )\n+      {\n+        FT_Memory        memory = slot->face->memory;\n+        FT_SVG_Document  doc    = (FT_SVG_Document)slot->other;\n+\n+\n+        FT_FREE( doc->svg_document );\n+        slot->internal->flags &= ~FT_GLYPH_OWN_GZIP_SVG;\n+      }\n+    }\n+#endif\n+\n+    slot->format = FT_GLYPH_FORMAT_NONE;\n@@ -558,0 +617,2 @@\n+    slot->advance.x         = 0;\n+    slot->advance.y         = 0;\n@@ -570,0 +631,18 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    if ( slot->face->face_flags & FT_FACE_FLAG_SVG )\n+    {\n+      \/* Free memory in case SVG was there.                          *\/\n+      \/* `slot->internal` might be NULL in out-of-memory situations. *\/\n+      if ( slot->internal && slot->internal->flags & FT_GLYPH_OWN_GZIP_SVG )\n+      {\n+        FT_SVG_Document  doc = (FT_SVG_Document)slot->other;\n+\n+\n+        FT_FREE( doc->svg_document );\n+\n+        slot->internal->flags &= ~FT_GLYPH_OWN_GZIP_SVG;\n+      }\n+\n+      FT_FREE( slot->other );\n+    }\n+#endif\n@@ -737,0 +816,23 @@\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Get_Transform( FT_Face     face,\n+                    FT_Matrix*  matrix,\n+                    FT_Vector*  delta )\n+  {\n+    FT_Face_Internal  internal;\n+\n+\n+    if ( !face )\n+      return;\n+\n+    internal = face->internal;\n+\n+    if ( matrix )\n+      *matrix = internal->transform_matrix;\n+\n+    if ( delta )\n+      *delta = internal->transform_delta;\n+  }\n+\n+\n@@ -822,0 +924,5 @@\n+    \/* undefined scale means no scale *\/\n+    if ( face->size->metrics.x_ppem == 0 ||\n+         face->size->metrics.y_ppem == 0 )\n+      load_flags |= FT_LOAD_NO_SCALE;\n+\n@@ -911,5 +1018,16 @@\n-      \/* try to load embedded bitmaps first if available            *\/\n-      \/*                                                            *\/\n-      \/* XXX: This is really a temporary hack that should disappear *\/\n-      \/*      promptly with FreeType 2.1!                           *\/\n-      \/*                                                            *\/\n+      \/* XXX: The use of the `FT_LOAD_XXX_ONLY` flags is not very *\/\n+      \/*      elegant.                                            *\/\n+\n+      \/* try to load SVG documents if available *\/\n+      if ( ( load_flags & FT_LOAD_NO_SVG ) == 0 &&\n+           FT_HAS_SVG( face )                   )\n+      {\n+        error = driver->clazz->load_glyph( slot, face->size,\n+                                           glyph_index,\n+                                           load_flags | FT_LOAD_SVG_ONLY );\n+\n+        if ( !error && slot->format == FT_GLYPH_FORMAT_SVG )\n+          goto Load_Ok;\n+      }\n+\n+      \/* try to load embedded bitmaps if available *\/\n@@ -1059,8 +1177,1 @@\n-    FT_TRACE5(( \"  x advance: %f\\n\", slot->advance.x \/ 64.0 ));\n-    FT_TRACE5(( \"  y advance: %f\\n\", slot->advance.y \/ 64.0 ));\n-    FT_TRACE5(( \"  linear x advance: %f\\n\",\n-                slot->linearHoriAdvance \/ 65536.0 ));\n-    FT_TRACE5(( \"  linear y advance: %f\\n\",\n-                slot->linearVertAdvance \/ 65536.0 ));\n-    FT_TRACE5(( \"\\n\" ));\n-    FT_TRACE5(( \"  bitmap %dx%d, %s (mode %d)\\n\",\n+    FT_TRACE5(( \"  bitmap %dx%d %s, %s (mode %d)\\n\",\n@@ -1069,0 +1180,6 @@\n+                slot->outline.points ?\n+                  slot->bitmap.buffer ? \"rendered\"\n+                                      : \"preset\"\n+                                     :\n+                  slot->internal->flags & FT_GLYPH_OWN_BITMAP ? \"owned\"\n+                                                              : \"unowned\",\n@@ -1072,0 +1189,6 @@\n+    FT_TRACE5(( \"  x advance: %f\\n\", (double)slot->advance.x \/ 64 ));\n+    FT_TRACE5(( \"  y advance: %f\\n\", (double)slot->advance.y \/ 64 ));\n+    FT_TRACE5(( \"  linear x advance: %f\\n\",\n+                (double)slot->linearHoriAdvance \/ 65536 ));\n+    FT_TRACE5(( \"  linear y advance: %f\\n\",\n+                (double)slot->linearVertAdvance \/ 65536 ));\n@@ -1078,2 +1201,2 @@\n-      FT_TRACE5(( \"    width:  %f\\n\", metrics->width  \/ 64.0 ));\n-      FT_TRACE5(( \"    height: %f\\n\", metrics->height \/ 64.0 ));\n+      FT_TRACE5(( \"    width:  %f\\n\", (double)metrics->width \/ 64 ));\n+      FT_TRACE5(( \"    height: %f\\n\", (double)metrics->height \/ 64 ));\n@@ -1081,3 +1204,6 @@\n-      FT_TRACE5(( \"    horiBearingX: %f\\n\", metrics->horiBearingX \/ 64.0 ));\n-      FT_TRACE5(( \"    horiBearingY: %f\\n\", metrics->horiBearingY \/ 64.0 ));\n-      FT_TRACE5(( \"    horiAdvance:  %f\\n\", metrics->horiAdvance  \/ 64.0 ));\n+      FT_TRACE5(( \"    horiBearingX: %f\\n\",\n+                  (double)metrics->horiBearingX \/ 64 ));\n+      FT_TRACE5(( \"    horiBearingY: %f\\n\",\n+                  (double)metrics->horiBearingY \/ 64 ));\n+      FT_TRACE5(( \"    horiAdvance:  %f\\n\",\n+                  (double)metrics->horiAdvance \/ 64 ));\n@@ -1085,3 +1211,6 @@\n-      FT_TRACE5(( \"    vertBearingX: %f\\n\", metrics->vertBearingX \/ 64.0 ));\n-      FT_TRACE5(( \"    vertBearingY: %f\\n\", metrics->vertBearingY \/ 64.0 ));\n-      FT_TRACE5(( \"    vertAdvance:  %f\\n\", metrics->vertAdvance  \/ 64.0 ));\n+      FT_TRACE5(( \"    vertBearingX: %f\\n\",\n+                  (double)metrics->vertBearingX \/ 64 ));\n+      FT_TRACE5(( \"    vertBearingY: %f\\n\",\n+                  (double)metrics->vertBearingY \/ 64 ));\n+      FT_TRACE5(( \"    vertAdvance:  %f\\n\",\n+                  (double)metrics->vertAdvance \/ 64 ));\n@@ -1120,2 +1249,2 @@\n-                FT_Size    size,\n-                FT_Driver  driver )\n+                void*      size_,\n+                void*      driver_ )\n@@ -1123,0 +1252,4 @@\n+    FT_Size    size   = (FT_Size)size_;\n+    FT_Driver  driver = (FT_Driver)driver_;\n+\n+\n@@ -1168,2 +1301,2 @@\n-                FT_Face    face,\n-                FT_Driver  driver )\n+                void*      face_,\n+                void*      driver_ )\n@@ -1171,1 +1304,3 @@\n-    FT_Driver_Class  clazz = driver->clazz;\n+    FT_Face          face   = (FT_Face)face_;\n+    FT_Driver        driver = (FT_Driver)driver_;\n+    FT_Driver_Class  clazz  = driver->clazz;\n@@ -1185,1 +1320,1 @@\n-                      (FT_List_Destructor)destroy_size,\n+                      destroy_size,\n@@ -1221,1 +1356,1 @@\n-                      (FT_List_Destructor)destroy_face,\n+                      destroy_face,\n@@ -1370,1 +1505,1 @@\n-             FT_Bool        external_stream,\n+             FT_Bool        *anexternal_stream,\n@@ -1396,1 +1531,1 @@\n-    if ( external_stream )\n+    if ( *anexternal_stream )\n@@ -1426,1 +1561,4 @@\n-    *astream = face->stream; \/* Stream may have been changed. *\/\n+    \/* Stream may have been changed. *\/\n+    *astream = face->stream;\n+    *anexternal_stream =\n+      ( face->face_flags & FT_FACE_FLAG_EXTERNAL_STREAM ) != 0;\n@@ -1550,1 +1688,1 @@\n-    FT_Memory  memory = stream->memory;\n+    FT_Memory  memory = (FT_Memory)stream->descriptor.pointer;\n@@ -1554,1 +1692,0 @@\n-\n@@ -1556,1 +1693,0 @@\n-    stream->base  = NULL;\n@@ -1558,0 +1694,1 @@\n+    FT_FREE( stream );\n@@ -1588,1 +1725,2 @@\n-    stream->close = close;\n+    stream->descriptor.pointer = memory;\n+    stream->close              = close;\n@@ -1609,1 +1747,0 @@\n-    FT_Stream     stream = NULL;\n@@ -1613,0 +1750,16 @@\n+    args.driver = NULL;\n+    args.flags  = 0;\n+\n+    if ( driver_name )\n+    {\n+      args.driver = FT_Get_Module( library, driver_name );\n+      if ( !args.driver )\n+      {\n+        FT_FREE( base );\n+        return FT_THROW( Missing_Module );\n+      }\n+\n+      args.flags = args.flags | FT_OPEN_DRIVER;\n+    }\n+\n+    \/* `memory_stream_close` also frees the stream object. *\/\n@@ -1617,1 +1770,1 @@\n-                               &stream );\n+                               &args.stream );\n@@ -1624,7 +1777,1 @@\n-    args.flags  = FT_OPEN_STREAM;\n-    args.stream = stream;\n-    if ( driver_name )\n-    {\n-      args.flags  = args.flags | FT_OPEN_DRIVER;\n-      args.driver = FT_Get_Module( library, driver_name );\n-    }\n+    args.flags |= FT_OPEN_STREAM;\n@@ -1642,15 +1789,1 @@\n-    error = ft_open_face_internal( library, &args, face_index, aface, 0 );\n-\n-    if ( !error )\n-      (*aface)->face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;\n-    else\n-#ifdef FT_MACINTOSH\n-      FT_Stream_Free( stream, 0 );\n-#else\n-    {\n-      FT_Stream_Close( stream );\n-      FT_FREE( stream );\n-    }\n-#endif\n-\n-    return error;\n+    return ft_open_face_internal( library, &args, face_index, aface, 0 );\n@@ -1785,1 +1918,1 @@\n-    if ( FT_ALLOC( sfnt_ps, (FT_Long)length ) )\n+    if ( FT_QALLOC( sfnt_ps, (FT_Long)length ) )\n@@ -1799,1 +1932,1 @@\n-                                   is_sfnt_cid ? \"cid\" : \"type1\",\n+                                   is_sfnt_cid ? \"t1cid\" : \"type1\",\n@@ -1895,1 +2028,1 @@\n-    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n+    if ( FT_QALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n@@ -1959,1 +2092,1 @@\n-                    i, pfb_data, pfb_lenpos ));\n+                    i, (void*)pfb_data, pfb_lenpos ));\n@@ -1974,1 +2107,1 @@\n-                    i, pfb_data, pfb_pos ));\n+                    i, (void*)pfb_data, pfb_pos ));\n@@ -1997,1 +2130,1 @@\n-                  i, rlen, pfb_data, pfb_pos ));\n+                  i, rlen, (void*)pfb_data, pfb_pos ));\n@@ -2060,1 +2193,1 @@\n-    FT_Long    rlen;\n+    FT_ULong   rlen;\n@@ -2075,1 +2208,1 @@\n-    if ( FT_READ_LONG( rlen ) )\n+    if ( FT_READ_ULONG( rlen ) )\n@@ -2077,1 +2210,1 @@\n-    if ( rlen < 1 )\n+    if ( !rlen )\n@@ -2079,1 +2212,1 @@\n-    if ( (FT_ULong)rlen > FT_MAC_RFORK_MAX_LEN )\n+    if ( rlen > FT_MAC_RFORK_MAX_LEN )\n@@ -2095,1 +2228,1 @@\n-    if ( FT_ALLOC( sfnt_data, rlen ) )\n+    if ( FT_QALLOC( sfnt_data, rlen ) )\n@@ -2097,2 +2230,3 @@\n-    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_data, (FT_ULong)rlen );\n-    if ( error ) {\n+    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_data, rlen );\n+    if ( error )\n+    {\n@@ -2106,1 +2240,1 @@\n-                                   (FT_ULong)rlen,\n+                                   rlen,\n@@ -2171,1 +2305,4 @@\n-        (*aface)->num_faces = count;\n+      {\n+        (*aface)->num_faces  = count;\n+        (*aface)->face_index = face_index_internal;\n+      }\n@@ -2410,0 +2547,10 @@\n+    \/* only use lower 31 bits together with sign bit *\/\n+    if ( face_index > 0 )\n+      face_index &= 0x7FFFFFFFL;\n+    else\n+    {\n+      face_index  = -face_index;\n+      face_index &= 0x7FFFFFFFL;\n+      face_index  = -face_index;\n+    }\n+\n@@ -2425,1 +2572,1 @@\n-    if ( ( !aface && face_index >= 0 ) || !args )\n+    if ( !args )\n@@ -2436,0 +2583,8 @@\n+    \/* Do this error check after `FT_Stream_New` to ensure that the *\/\n+    \/* 'close' callback is called.                                  *\/\n+    if ( !aface && face_index >= 0 )\n+    {\n+      error = FT_THROW( Invalid_Argument );\n+      goto Fail3;\n+    }\n+\n@@ -2457,1 +2612,1 @@\n-        error = open_face( driver, &stream, external_stream, face_index,\n+        error = open_face( driver, &stream, &external_stream, face_index,\n@@ -2493,1 +2648,1 @@\n-          error = open_face( driver, &stream, external_stream, face_index,\n+          error = open_face( driver, &stream, &external_stream, face_index,\n@@ -2569,1 +2724,1 @@\n-    if ( FT_NEW( node ) )\n+    if ( FT_QNEW( node ) )\n@@ -2684,2 +2839,1 @@\n-      FT_TRACE3(( \"FT_Open_Face: The font has %ld face%s\\n\"\n-                  \"              and %ld named instance%s for face %ld\\n\",\n+      FT_TRACE3(( \"FT_Open_Face: The font has %ld face%s\\n\",\n@@ -2687,1 +2841,2 @@\n-                  face->num_faces == 1 ? \"\" : \"s\",\n+                  face->num_faces == 1 ? \"\" : \"s\" ));\n+      FT_TRACE3(( \"              and %ld named instance%s for face %ld\\n\",\n@@ -2725,2 +2880,2 @@\n-  FT_Attach_Stream( FT_Face        face,\n-                    FT_Open_Args*  parameters )\n+  FT_Attach_Stream( FT_Face              face,\n+                    const FT_Open_Args*  parameters )\n@@ -2854,1 +3009,1 @@\n-    if ( FT_ALLOC( size, clazz->size_object_size ) || FT_NEW( node ) )\n+    if ( FT_ALLOC( size, clazz->size_object_size ) || FT_QNEW( node ) )\n@@ -3091,1 +3246,1 @@\n-  FT_BASE_DEF( void )\n+  FT_BASE_DEF( FT_Error )\n@@ -3095,0 +3250,2 @@\n+    FT_Error  error = FT_Err_Ok;\n+\n@@ -3149,1 +3306,1 @@\n-      if ( req->width )\n+      if ( req->height || !req->width )\n@@ -3151,3 +3308,1 @@\n-        metrics->x_scale = FT_DivFix( scaled_w, w );\n-\n-        if ( req->height )\n+        if ( h == 0 )\n@@ -3155,9 +3310,3 @@\n-          metrics->y_scale = FT_DivFix( scaled_h, h );\n-\n-          if ( req->type == FT_SIZE_REQUEST_TYPE_CELL )\n-          {\n-            if ( metrics->y_scale > metrics->x_scale )\n-              metrics->y_scale = metrics->x_scale;\n-            else\n-              metrics->x_scale = metrics->y_scale;\n-          }\n+          FT_ERROR(( \"FT_Request_Metrics: Divide by zero\\n\" ));\n+          error = FT_ERR( Divide_By_Zero );\n+          goto Exit;\n@@ -3165,1 +3314,7 @@\n-        else\n+\n+        metrics->y_scale = FT_DivFix( scaled_h, h );\n+      }\n+\n+      if ( req->width )\n+      {\n+        if ( w == 0 )\n@@ -3167,2 +3322,3 @@\n-          metrics->y_scale = metrics->x_scale;\n-          scaled_h = FT_MulDiv( scaled_w, h, w );\n+          FT_ERROR(( \"FT_Request_Metrics: Divide by zero\\n\" ));\n+          error = FT_ERR( Divide_By_Zero );\n+          goto Exit;\n@@ -3170,0 +3326,2 @@\n+\n+        metrics->x_scale = FT_DivFix( scaled_w, w );\n@@ -3173,1 +3331,1 @@\n-        metrics->x_scale = metrics->y_scale = FT_DivFix( scaled_h, h );\n+        metrics->x_scale = metrics->y_scale;\n@@ -3177,0 +3335,14 @@\n+      if ( !req->height )\n+      {\n+        metrics->y_scale = metrics->x_scale;\n+        scaled_h = FT_MulDiv( scaled_w, h, w );\n+      }\n+\n+      if ( req->type == FT_SIZE_REQUEST_TYPE_CELL )\n+      {\n+        if ( metrics->y_scale > metrics->x_scale )\n+          metrics->y_scale = metrics->x_scale;\n+        else\n+          metrics->x_scale = metrics->y_scale;\n+      }\n+\n@@ -3185,2 +3357,12 @@\n-      metrics->x_ppem = (FT_UShort)( ( scaled_w + 32 ) >> 6 );\n-      metrics->y_ppem = (FT_UShort)( ( scaled_h + 32 ) >> 6 );\n+      scaled_w = ( scaled_w + 32 ) >> 6;\n+      scaled_h = ( scaled_h + 32 ) >> 6;\n+      if ( scaled_w > (FT_Long)FT_USHORT_MAX ||\n+           scaled_h > (FT_Long)FT_USHORT_MAX )\n+      {\n+        FT_ERROR(( \"FT_Request_Metrics: Resulting ppem size too large\\n\" ));\n+        error = FT_ERR( Invalid_Pixel_Size );\n+        goto Exit;\n+      }\n+\n+      metrics->x_ppem = (FT_UShort)scaled_w;\n+      metrics->y_ppem = (FT_UShort)scaled_h;\n@@ -3196,0 +3378,3 @@\n+\n+  Exit:\n+    return error;\n@@ -3237,1 +3422,1 @@\n-                  metrics->x_scale, metrics->x_scale \/ 65536.0 ));\n+                  metrics->x_scale, (double)metrics->x_scale \/ 65536 ));\n@@ -3239,7 +3424,11 @@\n-                  metrics->y_scale, metrics->y_scale \/ 65536.0 ));\n-      FT_TRACE5(( \"  ascender: %f\\n\",    metrics->ascender \/ 64.0 ));\n-      FT_TRACE5(( \"  descender: %f\\n\",   metrics->descender \/ 64.0 ));\n-      FT_TRACE5(( \"  height: %f\\n\",      metrics->height \/ 64.0 ));\n-      FT_TRACE5(( \"  max advance: %f\\n\", metrics->max_advance \/ 64.0 ));\n-      FT_TRACE5(( \"  x ppem: %d\\n\",      metrics->x_ppem ));\n-      FT_TRACE5(( \"  y ppem: %d\\n\",      metrics->y_ppem ));\n+                  metrics->y_scale, (double)metrics->y_scale \/ 65536 ));\n+      FT_TRACE5(( \"  ascender: %f\\n\",\n+                  (double)metrics->ascender \/ 64 ));\n+      FT_TRACE5(( \"  descender: %f\\n\",\n+                  (double)metrics->descender \/ 64 ));\n+      FT_TRACE5(( \"  height: %f\\n\",\n+                  (double)metrics->height \/ 64 ));\n+      FT_TRACE5(( \"  max advance: %f\\n\",\n+                  (double)metrics->max_advance \/ 64 ));\n+      FT_TRACE5(( \"  x ppem: %d\\n\", metrics->x_ppem ));\n+      FT_TRACE5(( \"  y ppem: %d\\n\", metrics->y_ppem ));\n@@ -3259,1 +3448,1 @@\n-    FT_Error         error = FT_Err_Ok;\n+    FT_Error         error;\n@@ -3267,0 +3456,3 @@\n+    if ( !face->size )\n+      return FT_THROW( Invalid_Size_Handle );\n+\n@@ -3295,1 +3487,1 @@\n-        return error;\n+        goto Exit;\n@@ -3301,1 +3493,3 @@\n-      FT_Request_Metrics( face, req );\n+      error = FT_Request_Metrics( face, req );\n+      if ( error )\n+        goto Exit;\n@@ -3312,1 +3506,1 @@\n-                  metrics->x_scale, metrics->x_scale \/ 65536.0 ));\n+                  metrics->x_scale, (double)metrics->x_scale \/ 65536 ));\n@@ -3314,7 +3508,11 @@\n-                  metrics->y_scale, metrics->y_scale \/ 65536.0 ));\n-      FT_TRACE5(( \"  ascender: %f\\n\",    metrics->ascender \/ 64.0 ));\n-      FT_TRACE5(( \"  descender: %f\\n\",   metrics->descender \/ 64.0 ));\n-      FT_TRACE5(( \"  height: %f\\n\",      metrics->height \/ 64.0 ));\n-      FT_TRACE5(( \"  max advance: %f\\n\", metrics->max_advance \/ 64.0 ));\n-      FT_TRACE5(( \"  x ppem: %d\\n\",      metrics->x_ppem ));\n-      FT_TRACE5(( \"  y ppem: %d\\n\",      metrics->y_ppem ));\n+                  metrics->y_scale, (double)metrics->y_scale \/ 65536 ));\n+      FT_TRACE5(( \"  ascender: %f\\n\",\n+                  (double)metrics->ascender \/ 64 ));\n+      FT_TRACE5(( \"  descender: %f\\n\",\n+                  (double)metrics->descender \/ 64 ));\n+      FT_TRACE5(( \"  height: %f\\n\",\n+                  (double)metrics->height \/ 64 ));\n+      FT_TRACE5(( \"  max advance: %f\\n\",\n+                  (double)metrics->max_advance \/ 64 ));\n+      FT_TRACE5(( \"  x ppem: %d\\n\", metrics->x_ppem ));\n+      FT_TRACE5(( \"  y ppem: %d\\n\", metrics->y_ppem ));\n@@ -3324,0 +3522,1 @@\n+  Exit:\n@@ -3648,3 +3847,3 @@\n-          if ( FT_RENEW_ARRAY( face->charmaps,\n-                               face->num_charmaps,\n-                               face->num_charmaps - 1 ) )\n+          if ( FT_QRENEW_ARRAY( face->charmaps,\n+                                face->num_charmaps,\n+                                face->num_charmaps - 1 ) )\n@@ -3682,1 +3881,1 @@\n-    FT_Error   error = FT_Err_Ok;\n+    FT_Error   error;\n@@ -3707,3 +3906,3 @@\n-      if ( FT_RENEW_ARRAY( face->charmaps,\n-                           face->num_charmaps,\n-                           face->num_charmaps + 1 ) )\n+      if ( FT_QRENEW_ARRAY( face->charmaps,\n+                            face->num_charmaps,\n+                            face->num_charmaps + 1 ) )\n@@ -4403,1 +4602,1 @@\n-    if ( FT_NEW( node ) )\n+    if ( FT_QNEW( node ) )\n@@ -4415,2 +4614,1 @@\n-      if ( clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&\n-           clazz->raster_class->raster_new                )\n+      if ( clazz->raster_class && clazz->raster_class->raster_new )\n@@ -4426,0 +4624,5 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+      if ( clazz->glyph_format == FT_GLYPH_FORMAT_SVG )\n+        render->render = clazz->render_glyph;\n+#endif\n+\n@@ -4463,2 +4666,1 @@\n-      if ( render->clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&\n-           render->raster                                         )\n+      if ( render->raster )\n@@ -4559,3 +4761,0 @@\n-    case FT_GLYPH_FORMAT_BITMAP:   \/* already a bitmap, don't do anything *\/\n-      break;\n-\n@@ -4649,1 +4848,1 @@\n-        error = FT_ERR( Unimplemented_Feature );\n+        error = FT_ERR( Cannot_Render_Glyph );\n@@ -4665,0 +4864,5 @@\n+\n+        \/* it is not an error if we cannot render a bitmap glyph *\/\n+        if ( FT_ERR_EQ( error, Cannot_Render_Glyph ) &&\n+             slot->format == FT_GLYPH_FORMAT_BITMAP  )\n+          error = FT_Err_Ok;\n@@ -4737,1 +4941,2 @@\n-         ft_trace_levels[trace_checksum] >= 7 )\n+         ft_trace_levels[trace_checksum] >= 7 &&\n+         slot->bitmap.buffer                  )\n@@ -4740,2 +4945,1 @@\n-           slot->bitmap.width < 128U &&\n-           slot->bitmap.buffer       )\n+           slot->bitmap.width < 128U )\n@@ -5152,2 +5356,2 @@\n-      FT_ERROR(( \"%s: can't find module `%s'\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: can't find module `%s'\\n\",\n+                  func_name, module_name ));\n@@ -5160,2 +5364,2 @@\n-      FT_ERROR(( \"%s: module `%s' doesn't support properties\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: module `%s' doesn't support properties\\n\",\n+                  func_name, module_name ));\n@@ -5170,2 +5374,2 @@\n-      FT_ERROR(( \"%s: module `%s' doesn't support properties\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: module `%s' doesn't support properties\\n\",\n+                  func_name, module_name ));\n@@ -5184,2 +5388,2 @@\n-      FT_ERROR(( \"%s: property service of module `%s' is broken\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: property service of module `%s' is broken\\n\",\n+                  func_name, module_name ));\n@@ -5295,0 +5499,1 @@\n+#ifndef FT_DEBUG_LOGGING\n@@ -5298,1 +5503,2 @@\n-#endif\n+#endif \/* FT_DEBUG_LEVEL_ERROR *\/\n+#endif \/* !FT_DEBUG_LOGGING *\/\n@@ -5570,0 +5776,141 @@\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Color_Glyph_Paint( FT_Face                  face,\n+                            FT_UInt                  base_glyph,\n+                            FT_Color_Root_Transform  root_transform,\n+                            FT_OpaquePaint*          paint )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !paint )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_colr_glyph_paint )\n+      return sfnt->get_colr_glyph_paint( ttface,\n+                                         base_glyph,\n+                                         root_transform,\n+                                         paint );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Color_Glyph_ClipBox( FT_Face      face,\n+                              FT_UInt      base_glyph,\n+                              FT_ClipBox*  clip_box )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !clip_box )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_color_glyph_clipbox )\n+      return sfnt->get_color_glyph_clipbox( ttface,\n+                                            base_glyph,\n+                                            clip_box );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Paint_Layers( FT_Face            face,\n+                       FT_LayerIterator*  layer_iterator,\n+                       FT_OpaquePaint*    paint )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !paint || !layer_iterator )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_paint_layers )\n+      return sfnt->get_paint_layers( ttface, layer_iterator, paint );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Paint( FT_Face face,\n+                FT_OpaquePaint  opaque_paint,\n+                FT_COLR_Paint*  paint )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !paint )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_paint )\n+      return sfnt->get_paint( ttface, opaque_paint, paint );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Colorline_Stops ( FT_Face                face,\n+                           FT_ColorStop *         color_stop,\n+                           FT_ColorStopIterator  *iterator )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !color_stop || !iterator )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_colorline_stops )\n+      return sfnt->get_colorline_stops ( ttface, color_stop, iterator );\n+    else\n+      return 0;\n+  }\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftobjs.c","additions":522,"deletions":175,"binary":false,"changes":697,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -56,1 +56,1 @@\n-    char*       tags;\n+    FT_Byte*    tags;\n@@ -61,1 +61,3 @@\n-    FT_UInt  first;     \/* index of first point in contour *\/\n+    FT_Int   first;     \/* index of first point in contour *\/\n+    FT_Int   last;      \/* index of last point in contour  *\/\n+\n@@ -76,1 +78,0 @@\n-    first = 0;\n@@ -78,0 +79,1 @@\n+    last = -1;\n@@ -80,4 +82,1 @@\n-      FT_Int  last;  \/* index of last point in contour *\/\n-\n-\n-      FT_TRACE5(( \"FT_Outline_Decompose: Outline %d\\n\", n ));\n+      FT_TRACE5(( \"FT_Outline_Decompose: Contour %d\\n\", n ));\n@@ -85,2 +84,3 @@\n-      last = outline->contours[n];\n-      if ( last < 0 )\n+      first = last + 1;\n+      last  = outline->contours[n];\n+      if ( last < first )\n@@ -88,0 +88,1 @@\n+\n@@ -133,1 +134,1 @@\n-                  v_start.x \/ 64.0, v_start.y \/ 64.0 ));\n+                  (double)v_start.x \/ 64, (double)v_start.y \/ 64 ));\n@@ -155,1 +156,1 @@\n-                        vec.x \/ 64.0, vec.y \/ 64.0 ));\n+                        (double)vec.x \/ 64, (double)vec.y \/ 64 ));\n@@ -184,2 +185,4 @@\n-                          vec.x \/ 64.0, vec.y \/ 64.0,\n-                          v_control.x \/ 64.0, v_control.y \/ 64.0 ));\n+                          (double)vec.x \/ 64,\n+                          (double)vec.y \/ 64,\n+                          (double)v_control.x \/ 64,\n+                          (double)v_control.y \/ 64 ));\n@@ -200,2 +203,4 @@\n-                        v_middle.x \/ 64.0, v_middle.y \/ 64.0,\n-                        v_control.x \/ 64.0, v_control.y \/ 64.0 ));\n+                        (double)v_middle.x \/ 64,\n+                        (double)v_middle.y \/ 64,\n+                        (double)v_control.x \/ 64,\n+                        (double)v_control.y \/ 64 ));\n@@ -212,2 +217,4 @@\n-                      v_start.x \/ 64.0, v_start.y \/ 64.0,\n-                      v_control.x \/ 64.0, v_control.y \/ 64.0 ));\n+                      (double)v_start.x \/ 64,\n+                      (double)v_start.y \/ 64,\n+                      (double)v_control.x \/ 64,\n+                      (double)v_control.y \/ 64 ));\n@@ -245,3 +252,6 @@\n-                          vec.x \/ 64.0, vec.y \/ 64.0,\n-                          vec1.x \/ 64.0, vec1.y \/ 64.0,\n-                          vec2.x \/ 64.0, vec2.y \/ 64.0 ));\n+                          (double)vec.x \/ 64,\n+                          (double)vec.y \/ 64,\n+                          (double)vec1.x \/ 64,\n+                          (double)vec1.y \/ 64,\n+                          (double)vec2.x \/ 64,\n+                          (double)vec2.y \/ 64 ));\n@@ -256,3 +266,6 @@\n-                        v_start.x \/ 64.0, v_start.y \/ 64.0,\n-                        vec1.x \/ 64.0, vec1.y \/ 64.0,\n-                        vec2.x \/ 64.0, vec2.y \/ 64.0 ));\n+                        (double)v_start.x \/ 64,\n+                        (double)v_start.y \/ 64,\n+                        (double)vec1.x \/ 64,\n+                        (double)vec1.y \/ 64,\n+                        (double)vec2.x \/ 64,\n+                        (double)vec2.y \/ 64 ));\n@@ -267,1 +280,1 @@\n-                  v_start.x \/ 64.0, v_start.y \/ 64.0 ));\n+                  (double)v_start.x \/ 64, (double)v_start.y \/ 64 ));\n@@ -273,2 +286,0 @@\n-\n-      first = (FT_UInt)last + 1;\n@@ -324,2 +335,2 @@\n-    anoutline->n_points    = (FT_Short)numPoints;\n-    anoutline->n_contours  = (FT_Short)numContours;\n+    anoutline->n_points    = (FT_UShort)numPoints;\n+    anoutline->n_contours  = (FT_UShort)numContours;\n@@ -351,0 +362,2 @@\n+      FT_TRACE5(( \"FT_Outline_Check: contours = %d, points = %d\\n\",\n+                  n_contours, n_points ));\n@@ -356,1 +369,1 @@\n-      if ( n_points <= 0 || n_contours <= 0 )\n+      if ( n_points == 0 || n_contours == 0 )\n@@ -359,1 +372,1 @@\n-      end0 = end = -1;\n+      end0 = -1;\n@@ -371,1 +384,1 @@\n-      if ( end != n_points - 1 )\n+      if ( end0 != n_points - 1 )\n@@ -379,1 +392,1 @@\n-    return FT_THROW( Invalid_Argument );\n+    return FT_THROW( Invalid_Outline );\n@@ -541,2 +554,1 @@\n-    first = 0;\n-\n+    last = -1;\n@@ -545,0 +557,3 @@\n+      \/* keep the first contour point as is and swap points around it *\/\n+      \/* to guarantee that the cubic arches stay valid after reverse  *\/\n+      first = last + 2;\n@@ -566,2 +581,2 @@\n-        char*  p = outline->tags + first;\n-        char*  q = outline->tags + last;\n+        FT_Byte*  p = outline->tags + first;\n+        FT_Byte*  q = outline->tags + last;\n@@ -572,1 +587,1 @@\n-          char  swap;\n+          FT_Byte  swap;\n@@ -582,2 +597,0 @@\n-\n-      first = last + 1;\n@@ -932,1 +945,1 @@\n-    first = 0;\n+    last = -1;\n@@ -940,2 +953,3 @@\n-      l_in = 0;\n-      last = outline->contours[c];\n+      first = last + 1;\n+      last  = outline->contours[c];\n+      l_in  = 0;\n@@ -1028,2 +1042,0 @@\n-\n-      first = last + 1;\n@@ -1045,1 +1057,1 @@\n-    FT_Int      c, n, first;\n+    FT_Int      c, n, first, last;\n@@ -1077,1 +1089,1 @@\n-    first = 0;\n+    last = -1;\n@@ -1080,2 +1092,2 @@\n-      FT_Int  last = outline->contours[c];\n-\n+      first = last + 1;\n+      last  = outline->contours[c];\n@@ -1097,2 +1109,0 @@\n-\n-      first = last + 1;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftoutln.c","additions":61,"deletions":51,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftpatent.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n@@ -223,1 +223,1 @@\n-    FT_TRACE0(( \"ps_property_set: missing property `%s'\\n\",\n+    FT_TRACE2(( \"ps_property_set: missing property `%s'\\n\",\n@@ -278,1 +278,1 @@\n-    FT_TRACE0(( \"ps_property_get: missing property `%s'\\n\",\n+    FT_TRACE2(( \"ps_property_get: missing property `%s'\\n\",\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftpsprop.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n@@ -170,3 +170,3 @@\n-  static int\n-  ft_raccess_sort_ref_by_id( FT_RFork_Ref*  a,\n-                             FT_RFork_Ref*  b )\n+  FT_COMPARE_DEF( int )\n+  ft_raccess_sort_ref_by_id( const void*  a,\n+                             const void*  b )\n@@ -174,6 +174,1 @@\n-    if ( a->res_id < b->res_id )\n-      return -1;\n-    else if ( a->res_id > b->res_id )\n-      return 1;\n-    else\n-      return 0;\n+    return  ( (FT_RFork_Ref*)a )->res_id - ( (FT_RFork_Ref*)b )->res_id;\n@@ -259,1 +254,1 @@\n-        if ( FT_NEW_ARRAY( ref, *count ) )\n+        if ( FT_QNEW_ARRAY( ref, *count ) )\n@@ -297,2 +292,1 @@\n-                    ( int(*)(const void*,\n-                             const void*) )ft_raccess_sort_ref_by_id );\n+                    ft_raccess_sort_ref_by_id );\n@@ -308,1 +302,1 @@\n-        if ( FT_NEW_ARRAY( offsets_internal, *count ) )\n+        if ( FT_QNEW_ARRAY( offsets_internal, *count ) )\n@@ -411,11 +405,11 @@\n-  CONST_FT_RFORK_RULE_ARRAY_BEGIN(ft_raccess_guess_table,\n-                                  ft_raccess_guess_rec)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(apple_double,      apple_double)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(apple_single,      apple_single)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(darwin_ufs_export, darwin_ufs_export)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(darwin_newvfs,     darwin_newvfs)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(darwin_hfsplus,    darwin_hfsplus)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(vfat,              vfat)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(linux_cap,         linux_cap)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(linux_double,      linux_double)\n-  CONST_FT_RFORK_RULE_ARRAY_ENTRY(linux_netatalk,    linux_netatalk)\n+  CONST_FT_RFORK_RULE_ARRAY_BEGIN( ft_raccess_guess_table,\n+                                                      ft_raccess_guess_rec )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( apple_double,      apple_double )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( apple_single,      apple_single )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( darwin_ufs_export, darwin_ufs_export )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( darwin_newvfs,     darwin_newvfs )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( darwin_hfsplus,    darwin_hfsplus )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( vfat,              vfat )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( linux_cap,         linux_cap )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( linux_double,      linux_double )\n+  CONST_FT_RFORK_RULE_ARRAY_ENTRY( linux_netatalk,    linux_netatalk )\n@@ -611,1 +605,1 @@\n-    if ( FT_ALLOC( newpath, base_file_len + 6 ) )\n+    if ( FT_QALLOC( newpath, base_file_len + 6 ) )\n@@ -647,1 +641,1 @@\n-    if ( FT_ALLOC( newpath, base_file_len + 18 ) )\n+    if ( FT_QALLOC( newpath, base_file_len + 18 ) )\n@@ -877,3 +871,1 @@\n-    FT_Error     error = FT_Err_Ok;\n-\n-    FT_UNUSED( error );\n+    FT_Error     error;\n@@ -883,1 +875,1 @@\n-    if ( FT_ALLOC( new_name, new_length + 1 ) )\n+    if ( FT_QALLOC( new_name, new_length + 1 ) )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftrfork.c","additions":23,"deletions":31,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -68,1 +68,1 @@\n-          if ( FT_NEW_ARRAY  ( entry->string, entry->stringLength ) ||\n+          if ( FT_QNEW_ARRAY ( entry->string, entry->stringLength ) ||\n@@ -124,1 +124,1 @@\n-          if ( FT_NEW_ARRAY  ( entry->string, entry->stringLength ) ||\n+          if ( FT_QNEW_ARRAY ( entry->string, entry->stringLength ) ||\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftsnames.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n@@ -64,1 +64,1 @@\n-      if ( stream->read( stream, pos, 0, 0 ) )\n+      if ( stream->read( stream, pos, NULL, 0 ) )\n@@ -144,1 +144,3 @@\n-      FT_MEM_COPY( buffer, stream->base + pos, read_bytes );\n+      \/* Allow \"reading\" zero bytes without UB even if buffer is NULL *\/\n+      if ( count )\n+        FT_MEM_COPY( buffer, stream->base + pos, read_bytes );\n@@ -181,1 +183,3 @@\n-      FT_MEM_COPY( buffer, stream->base + stream->pos, read_bytes );\n+      \/* Allow \"reading\" zero bytes without UB even if buffer is NULL *\/\n+      if ( count )\n+        FT_MEM_COPY( buffer, stream->base + stream->pos, read_bytes );\n@@ -264,1 +268,1 @@\n-      \/* assume _ft_debug_file and _ft_debug_lineno are already set *\/\n+      \/* assume `ft_debug_file_` and `ft_debug_lineno_` are already set *\/\n@@ -350,2 +354,2 @@\n-  FT_BASE_DEF( FT_Char )\n-  FT_Stream_GetChar( FT_Stream  stream )\n+  FT_BASE_DEF( FT_Byte )\n+  FT_Stream_GetByte( FT_Stream  stream )\n@@ -353,1 +357,1 @@\n-    FT_Char  result;\n+    FT_Byte  result;\n@@ -360,1 +364,1 @@\n-      result = (FT_Char)*stream->cursor++;\n+      result = *stream->cursor++;\n@@ -366,1 +370,1 @@\n-  FT_BASE_DEF( FT_UShort )\n+  FT_BASE_DEF( FT_UInt16 )\n@@ -370,1 +374,1 @@\n-    FT_UShort  result;\n+    FT_UInt16  result;\n@@ -385,1 +389,1 @@\n-  FT_BASE_DEF( FT_UShort )\n+  FT_BASE_DEF( FT_UInt16 )\n@@ -389,1 +393,1 @@\n-    FT_UShort  result;\n+    FT_UInt16  result;\n@@ -404,1 +408,1 @@\n-  FT_BASE_DEF( FT_ULong )\n+  FT_BASE_DEF( FT_UInt32 )\n@@ -408,1 +412,1 @@\n-    FT_ULong  result;\n+    FT_UInt32 result;\n@@ -422,1 +426,1 @@\n-  FT_BASE_DEF( FT_ULong )\n+  FT_BASE_DEF( FT_UInt32 )\n@@ -426,1 +430,1 @@\n-    FT_ULong  result;\n+    FT_UInt32 result;\n@@ -440,1 +444,1 @@\n-  FT_BASE_DEF( FT_ULong )\n+  FT_BASE_DEF( FT_UInt32 )\n@@ -444,1 +448,1 @@\n-    FT_ULong  result;\n+    FT_UInt32 result;\n@@ -458,2 +462,2 @@\n-  FT_BASE_DEF( FT_Char )\n-  FT_Stream_ReadChar( FT_Stream  stream,\n+  FT_BASE_DEF( FT_Byte )\n+  FT_Stream_ReadByte( FT_Stream  stream,\n@@ -467,8 +471,1 @@\n-    *error = FT_Err_Ok;\n-\n-    if ( stream->read )\n-    {\n-      if ( stream->read( stream, stream->pos, &result, 1L ) != 1L )\n-        goto Fail;\n-    }\n-    else\n+    if ( stream->pos < stream->size )\n@@ -476,2 +473,5 @@\n-      if ( stream->pos < stream->size )\n-        result = stream->base[stream->pos];\n+      if ( stream->read )\n+      {\n+        if ( stream->read( stream, stream->pos, &result, 1L ) != 1L )\n+          goto Fail;\n+      }\n@@ -479,1 +479,1 @@\n-        goto Fail;\n+        result = stream->base[stream->pos];\n@@ -481,0 +481,3 @@\n+    else\n+      goto Fail;\n+\n@@ -483,1 +486,3 @@\n-    return (FT_Char)result;\n+    *error = FT_Err_Ok;\n+\n+    return result;\n@@ -487,1 +492,1 @@\n-    FT_ERROR(( \"FT_Stream_ReadChar:\"\n+    FT_ERROR(( \"FT_Stream_ReadByte:\"\n@@ -491,1 +496,1 @@\n-    return 0;\n+    return result;\n@@ -495,1 +500,1 @@\n-  FT_BASE_DEF( FT_UShort )\n+  FT_BASE_DEF( FT_UInt16 )\n@@ -500,2 +505,2 @@\n-    FT_Byte*   p      = 0;\n-    FT_UShort  result = 0;\n+    FT_Byte*   p;\n+    FT_UInt16  result = 0;\n@@ -506,2 +511,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -528,0 +531,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -536,1 +541,1 @@\n-    return 0;\n+    return result;\n@@ -540,1 +545,1 @@\n-  FT_BASE_DEF( FT_UShort )\n+  FT_BASE_DEF( FT_UInt16 )\n@@ -545,2 +550,2 @@\n-    FT_Byte*   p      = 0;\n-    FT_UShort  result = 0;\n+    FT_Byte*   p;\n+    FT_UInt16  result = 0;\n@@ -551,2 +556,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -573,0 +576,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -581,1 +586,1 @@\n-    return 0;\n+    return result;\n@@ -590,1 +595,1 @@\n-    FT_Byte*  p      = 0;\n+    FT_Byte*  p;\n@@ -596,2 +601,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -618,0 +621,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -626,1 +631,1 @@\n-    return 0;\n+    return result;\n@@ -630,1 +635,1 @@\n-  FT_BASE_DEF( FT_ULong )\n+  FT_BASE_DEF( FT_UInt32 )\n@@ -635,2 +640,2 @@\n-    FT_Byte*  p      = 0;\n-    FT_ULong  result = 0;\n+    FT_Byte*  p;\n+    FT_UInt32 result = 0;\n@@ -641,2 +646,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -663,0 +666,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -671,1 +676,1 @@\n-    return 0;\n+    return result;\n@@ -675,1 +680,1 @@\n-  FT_BASE_DEF( FT_ULong )\n+  FT_BASE_DEF( FT_UInt32 )\n@@ -680,2 +685,2 @@\n-    FT_Byte*  p      = 0;\n-    FT_ULong  result = 0;\n+    FT_Byte*  p;\n+    FT_UInt32 result = 0;\n@@ -686,2 +691,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -708,0 +711,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -716,1 +721,1 @@\n-    return 0;\n+    return result;\n@@ -761,1 +766,1 @@\n-          FT_UInt  len = fields->size;\n+          FT_Offset  len = fields->size;\n@@ -764,1 +769,1 @@\n-          if ( cursor + len > stream->limit )\n+          if ( len > (FT_Offset)( stream->limit - cursor ) )\n@@ -828,1 +833,1 @@\n-      \/* now, compute the signed value is necessary *\/\n+      \/* now, compute the signed value if necessary *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftstream.c","additions":71,"deletions":66,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -714,1 +714,1 @@\n-      FT_Byte*  write = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*  write = outline->tags + outline->n_points;\n@@ -730,4 +730,4 @@\n-      FT_UInt    count = border->num_points;\n-      FT_Byte*   tags  = border->tags;\n-      FT_Short*  write = outline->contours + outline->n_contours;\n-      FT_Short   idx   = (FT_Short)outline->n_points;\n+      FT_UInt     count = border->num_points;\n+      FT_Byte*    tags  = border->tags;\n+      FT_UShort*  write = outline->contours + outline->n_contours;\n+      FT_UShort   idx   = outline->n_points;\n@@ -746,1 +746,1 @@\n-    outline->n_points += (short)border->num_points;\n+    outline->n_points += (FT_UShort)border->num_points;\n@@ -977,1 +977,2 @@\n-    FT_Vector        sigma, delta;\n+    FT_Vector        sigma = { 0, 0 };\n+    FT_Vector        delta;\n@@ -1051,1 +1052,1 @@\n-      FT_Vector  sigma;\n+      FT_Vector  sigma = { 0, 0 };\n@@ -1531,1 +1532,2 @@\n-    stroker->center = *to;\n+    stroker->center      = *to;\n+    stroker->line_length = 0;\n@@ -1747,1 +1749,2 @@\n-    stroker->center = *to;\n+    stroker->center      = *to;\n+    stroker->line_length = 0;\n@@ -1900,4 +1903,0 @@\n-      FT_Angle  turn;\n-      FT_Int    inside_side;\n-\n-\n@@ -1905,2 +1904,2 @@\n-      if ( stroker->center.x != stroker->subpath_start.x ||\n-           stroker->center.y != stroker->subpath_start.y )\n+      if ( !FT_IS_SMALL( stroker->center.x - stroker->subpath_start.x ) ||\n+           !FT_IS_SMALL( stroker->center.y - stroker->subpath_start.y ) )\n@@ -1915,9 +1914,0 @@\n-      turn               = FT_Angle_Diff( stroker->angle_in,\n-                                          stroker->angle_out );\n-\n-      \/* no specific corner processing is required if the turn is 0 *\/\n-      if ( turn != 0 )\n-      {\n-        \/* when we turn to the right, the inside side is 0 *\/\n-        \/* otherwise, the inside side is 1 *\/\n-        inside_side = ( turn < 0 );\n@@ -1925,13 +1915,4 @@\n-        error = ft_stroker_inside( stroker,\n-                                   inside_side,\n-                                   stroker->subpath_line_length );\n-        if ( error )\n-          goto Exit;\n-\n-        \/* process the outside side *\/\n-        error = ft_stroker_outside( stroker,\n-                                    !inside_side,\n-                                    stroker->subpath_line_length );\n-        if ( error )\n-          goto Exit;\n-      }\n+      error = ft_stroker_process_corner( stroker,\n+                                         stroker->subpath_line_length );\n+      if ( error )\n+        goto Exit;\n@@ -2072,1 +2053,1 @@\n-    char*       tags;\n+    FT_Byte*    tags;\n@@ -2077,1 +2058,3 @@\n-    FT_UInt     first;     \/* index of first point in contour *\/\n+    FT_Int      first;     \/* index of first point in contour *\/\n+    FT_Int      last;      \/* index of last point in contour  *\/\n+\n@@ -2089,2 +2072,1 @@\n-    first = 0;\n-\n+    last = -1;\n@@ -2093,5 +2075,2 @@\n-      FT_UInt  last;  \/* index of last point in contour *\/\n-\n-\n-      last  = (FT_UInt)outline->contours[n];\n-      limit = outline->points + last;\n+      first = last + 1;\n+      last  = outline->contours[n];\n@@ -2101,2 +2080,0 @@\n-      {\n-        first = last + 1;\n@@ -2104,1 +2081,2 @@\n-      }\n+\n+      limit = outline->points + last;\n@@ -2253,2 +2231,0 @@\n-\n-      first = last + 1;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftstroke.c","additions":29,"deletions":53,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n@@ -48,0 +48,12 @@\n+  {\n+    \/* Value '0x0366A' corresponds to a shear angle of about 12 degrees. *\/\n+    FT_GlyphSlot_Slant( slot, 0x0366A, 0 );\n+  }\n+\n+\n+  \/* documentation is in ftsynth.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_GlyphSlot_Slant( FT_GlyphSlot  slot,\n+                      FT_Fixed      xslant,\n+                      FT_Fixed      yslant )\n@@ -64,3 +76,1 @@\n-    \/* For italic, simply apply a shear transform, with an angle *\/\n-    \/* of about 12 degrees.                                      *\/\n-\n+    \/* For italic, simply apply a shear transform *\/\n@@ -68,1 +78,1 @@\n-    transform.yx = 0x00000L;\n+    transform.yx = -yslant;\n@@ -70,1 +80,1 @@\n-    transform.xy = 0x0366AL;\n+    transform.xy = xslant;\n@@ -90,0 +100,9 @@\n+  {\n+    FT_GlyphSlot_AdjustWeight( slot, 0x0AAA, 0x0AAA );\n+  }\n+\n+\n+  FT_EXPORT_DEF( void )\n+  FT_GlyphSlot_AdjustWeight( FT_GlyphSlot  slot,\n+                             FT_Fixed      xdelta,\n+                             FT_Fixed      ydelta )\n@@ -92,1 +111,1 @@\n-    FT_Face     face;\n+    FT_Size     size;\n@@ -101,1 +120,1 @@\n-    face    = slot->face;\n+    size    = slot->face->size;\n@@ -107,4 +126,3 @@\n-    \/* some reasonable strength *\/\n-    xstr = FT_MulFix( face->units_per_EM,\n-                      face->size->metrics.y_scale ) \/ 24;\n-    ystr = xstr;\n+    \/* express deltas in pixels in 26.6 format *\/\n+    xstr = (FT_Pos)size->metrics.x_ppem * xdelta \/ 1024;\n+    ystr = (FT_Pos)size->metrics.y_ppem * ydelta \/ 1024;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftsynth.c","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -209,1 +209,1 @@\n-   *   The number of bytes actually read.  If `count' is zero (this is,\n+   *   The number of bytes actually read.  If `count' is zero (that is,\n@@ -222,1 +222,1 @@\n-    if ( !count && offset > stream->size )\n+    if ( offset > stream->size && !count )\n@@ -230,0 +230,5 @@\n+    \/* Avoid calling `fread` with `buffer=NULL` and `count=0`, *\/\n+    \/* which is undefined behaviour.                           *\/\n+    if ( !count )\n+      return 0;\n+\n@@ -278,1 +283,1 @@\n-    FT_TRACE1(( \" opened `%s' (%d bytes) successfully\\n\",\n+    FT_TRACE1(( \" opened `%s' (%ld bytes) successfully\\n\",\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftsystem.c","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -56,1 +56,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n@@ -79,1 +79,1 @@\n-#else \/* !FT_LONG64 *\/\n+#else \/* !FT_INT64 *\/\n@@ -128,1 +128,1 @@\n-#endif \/* !FT_LONG64 *\/\n+#endif \/* !FT_INT64 *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/fttrigon.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/fttype1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/base\/ftutil.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -35,2 +35,2 @@\n-  cff_cmap_encoding_init( CFF_CMapStd  cmap,\n-                          FT_Pointer   pointer )\n+  cff_cmap_encoding_init( FT_CMap     cmap,\n+                          FT_Pointer  pointer )\n@@ -38,0 +38,1 @@\n+    CFF_CMapStd   cffcmap  = (CFF_CMapStd)cmap;\n@@ -45,1 +46,1 @@\n-    cmap->gids  = encoding->codes;\n+    cffcmap->gids = encoding->codes;\n@@ -52,1 +53,1 @@\n-  cff_cmap_encoding_done( CFF_CMapStd  cmap )\n+  cff_cmap_encoding_done( FT_CMap  cmap )\n@@ -54,1 +55,4 @@\n-    cmap->gids  = NULL;\n+    CFF_CMapStd  cffcmap = (CFF_CMapStd)cmap;\n+\n+\n+    cffcmap->gids = NULL;\n@@ -59,2 +63,2 @@\n-  cff_cmap_encoding_char_index( CFF_CMapStd  cmap,\n-                                FT_UInt32    char_code )\n+  cff_cmap_encoding_char_index( FT_CMap    cmap,\n+                                FT_UInt32  char_code )\n@@ -62,1 +66,2 @@\n-    FT_UInt  result = 0;\n+    CFF_CMapStd  cffcmap = (CFF_CMapStd)cmap;\n+    FT_UInt      result  = 0;\n@@ -66,1 +71,1 @@\n-      result = cmap->gids[char_code];\n+      result = cffcmap->gids[char_code];\n@@ -72,3 +77,3 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  cff_cmap_encoding_char_next( CFF_CMapStd   cmap,\n-                               FT_UInt32    *pchar_code )\n+  FT_CALLBACK_DEF( FT_UInt )\n+  cff_cmap_encoding_char_next( FT_CMap     cmap,\n+                               FT_UInt32  *pchar_code )\n@@ -76,2 +81,3 @@\n-    FT_UInt    result    = 0;\n-    FT_UInt32  char_code = *pchar_code;\n+    CFF_CMapStd  cffcmap   = (CFF_CMapStd)cmap;\n+    FT_UInt      result    = 0;\n+    FT_UInt32    char_code = *pchar_code;\n@@ -80,3 +86,1 @@\n-    *pchar_code = 0;\n-\n-    if ( char_code < 255 )\n+    while ( char_code < 255 )\n@@ -84,4 +88,2 @@\n-      FT_UInt  code = (FT_UInt)(char_code + 1);\n-\n-\n-      for (;;)\n+      result = cffcmap->gids[++char_code];\n+      if ( result )\n@@ -89,11 +91,2 @@\n-        if ( code >= 256 )\n-          break;\n-\n-        result = cmap->gids[code];\n-        if ( result != 0 )\n-        {\n-          *pchar_code = code;\n-          break;\n-        }\n-\n-        code++;\n+        *pchar_code = char_code;\n+        break;\n@@ -102,0 +95,1 @@\n+\n@@ -133,1 +127,1 @@\n-  cff_sid_to_glyph_name( TT_Face  face,\n+  cff_sid_to_glyph_name( void*    face_,  \/* TT_Face *\/\n@@ -136,0 +130,1 @@\n+    TT_Face      face    = (TT_Face)face_;\n@@ -146,1 +141,1 @@\n-  cff_cmap_unicode_init( PS_Unicodes  unicodes,\n+  cff_cmap_unicode_init( FT_CMap      cmap,     \/* PS_Unicodes *\/\n@@ -149,5 +144,6 @@\n-    TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );\n-    FT_Memory           memory  = FT_FACE_MEMORY( face );\n-    CFF_Font            cff     = (CFF_Font)face->extra.data;\n-    CFF_Charset         charset = &cff->charset;\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)cff->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    TT_Face             face     = (TT_Face)FT_CMAP_FACE( cmap );\n+    FT_Memory           memory   = FT_FACE_MEMORY( face );\n+    CFF_Font            cff      = (CFF_Font)face->extra.data;\n+    CFF_Charset         charset  = &cff->charset;\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)cff->psnames;\n@@ -169,1 +165,1 @@\n-                                   (PS_GetGlyphNameFunc)&cff_sid_to_glyph_name,\n+                                   &cff_sid_to_glyph_name,\n@@ -176,1 +172,1 @@\n-  cff_cmap_unicode_done( PS_Unicodes  unicodes )\n+  cff_cmap_unicode_done( FT_CMap  cmap )    \/* PS_Unicodes *\/\n@@ -178,2 +174,3 @@\n-    FT_Face    face   = FT_CMAP_FACE( unicodes );\n-    FT_Memory  memory = FT_FACE_MEMORY( face );\n+    PS_Unicodes  unicodes = (PS_Unicodes)cmap;\n+    FT_Face      face     = FT_CMAP_FACE( cmap );\n+    FT_Memory    memory   = FT_FACE_MEMORY( face );\n@@ -188,2 +185,2 @@\n-  cff_cmap_unicode_char_index( PS_Unicodes  unicodes,\n-                               FT_UInt32    char_code )\n+  cff_cmap_unicode_char_index( FT_CMap    cmap,       \/* PS_Unicodes *\/\n+                               FT_UInt32  char_code )\n@@ -191,3 +188,4 @@\n-    TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );\n-    CFF_Font            cff     = (CFF_Font)face->extra.data;\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)cff->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    TT_Face             face     = (TT_Face)FT_CMAP_FACE( cmap );\n+    CFF_Font            cff      = (CFF_Font)face->extra.data;\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)cff->psnames;\n@@ -200,3 +198,3 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  cff_cmap_unicode_char_next( PS_Unicodes  unicodes,\n-                              FT_UInt32   *pchar_code )\n+  FT_CALLBACK_DEF( FT_UInt )\n+  cff_cmap_unicode_char_next( FT_CMap     cmap,        \/* PS_Unicodes *\/\n+                              FT_UInt32  *pchar_code )\n@@ -204,3 +202,4 @@\n-    TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );\n-    CFF_Font            cff     = (CFF_Font)face->extra.data;\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)cff->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    TT_Face             face     = (TT_Face)FT_CMAP_FACE( cmap );\n+    CFF_Font            cff      = (CFF_Font)face->extra.data;\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)cff->psnames;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffcmap.c","additions":54,"deletions":55,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (C) 1996-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ * Copyright (C) 1996-2024 by\n+ * David Turner, Robert Wilhelm, Werner Lemberg, and Dominik Röttsches.\n@@ -111,1 +111,1 @@\n-  cff_get_kerning( FT_Face     ttface,          \/* TT_Face *\/\n+  cff_get_kerning( FT_Face     face,          \/* CFF_Face *\/\n@@ -116,2 +116,2 @@\n-    TT_Face       face = (TT_Face)ttface;\n-    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+    CFF_Face      cffface = (CFF_Face)face;\n+    SFNT_Service  sfnt    = (SFNT_Service)cffface->sfnt;\n@@ -124,1 +124,1 @@\n-      kerning->x = sfnt->get_kerning( face, left_glyph, right_glyph );\n+      kerning->x = sfnt->get_kerning( cffface, left_glyph, right_glyph );\n@@ -161,2 +161,2 @@\n-  cff_glyph_load( FT_GlyphSlot  cffslot,      \/* CFF_GlyphSlot *\/\n-                  FT_Size       cffsize,      \/* CFF_Size      *\/\n+  cff_glyph_load( FT_GlyphSlot  slot,        \/* CFF_GlyphSlot *\/\n+                  FT_Size       size,        \/* CFF_Size      *\/\n@@ -167,2 +167,2 @@\n-    CFF_GlyphSlot  slot = (CFF_GlyphSlot)cffslot;\n-    CFF_Size       size = (CFF_Size)cffsize;\n+    CFF_GlyphSlot  cffslot = (CFF_GlyphSlot)slot;\n+    CFF_Size       cffsize = (CFF_Size)size;\n@@ -171,1 +171,1 @@\n-    if ( !slot )\n+    if ( !cffslot )\n@@ -177,1 +177,1 @@\n-    if ( !size )\n+    if ( !cffsize )\n@@ -187,1 +187,1 @@\n-      if ( cffsize->face != cffslot->face )\n+      if ( size->face != slot->face )\n@@ -192,1 +192,1 @@\n-    error = cff_slot_load( slot, size, glyph_index, load_flags );\n+    error = cff_slot_load( cffslot, cffsize, glyph_index, load_flags );\n@@ -219,1 +219,1 @@\n-      TT_Face   ttface = (TT_Face)face;\n+      CFF_Face  cffface = (CFF_Face)face;\n@@ -228,1 +228,1 @@\n-             !( ttface->variation_support & TT_FACE_FLAG_VAR_VADVANCE )  )\n+             !( cffface->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n@@ -236,1 +236,1 @@\n-        if ( !ttface->vertical_info )\n+        if ( !cffface->vertical_info )\n@@ -244,5 +244,5 @@\n-          ( (SFNT_Service)ttface->sfnt )->get_metrics( ttface,\n-                                                       1,\n-                                                       start + nn,\n-                                                       &dummy,\n-                                                       &ah );\n+          ( (SFNT_Service)cffface->sfnt )->get_metrics( cffface,\n+                                                        1,\n+                                                        start + nn,\n+                                                        &dummy,\n+                                                        &ah );\n@@ -262,1 +262,1 @@\n-             !( ttface->variation_support & TT_FACE_FLAG_VAR_HADVANCE )  )\n+             !( cffface->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n@@ -267,1 +267,1 @@\n-        if ( !ttface->horizontal.number_Of_HMetrics )\n+        if ( !cffface->horizontal.number_Of_HMetrics )\n@@ -275,5 +275,5 @@\n-          ( (SFNT_Service)ttface->sfnt )->get_metrics( ttface,\n-                                                       0,\n-                                                       start + nn,\n-                                                       &dummy,\n-                                                       &aw );\n+          ( (SFNT_Service)cffface->sfnt )->get_metrics( cffface,\n+                                                        0,\n+                                                        start + nn,\n+                                                        &dummy,\n+                                                        &aw );\n@@ -315,2 +315,2 @@\n-  static FT_Error\n-  cff_get_glyph_name( CFF_Face    face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_glyph_name( FT_Face     face,        \/* CFF_Face *\/\n@@ -321,1 +321,2 @@\n-    CFF_Font    font   = (CFF_Font)face->extra.data;\n+    CFF_Face    cffface = (CFF_Face)face;\n+    CFF_Font    font    = (CFF_Font)cffface->extra.data;\n@@ -341,4 +342,1 @@\n-        return service->get_name( FT_FACE( face ),\n-                                  glyph_index,\n-                                  buffer,\n-                                  buffer_max );\n+        return service->get_name( face, glyph_index, buffer, buffer_max );\n@@ -348,2 +346,2 @@\n-                   \" cannot get glyph name from a CFF2 font\\n\"\n-                   \"                   \"\n+                   \" cannot get glyph name from a CFF2 font\\n\" ));\n+        FT_ERROR(( \"                   \"\n@@ -359,2 +357,2 @@\n-                 \" cannot get glyph name from CFF & CEF fonts\\n\"\n-                 \"                   \"\n+                 \" cannot get glyph name from CFF & CEF fonts\\n\" ));\n+      FT_ERROR(( \"                   \"\n@@ -369,1 +367,1 @@\n-    \/* now, lookup the name itself *\/\n+    \/* now, look up the name itself *\/\n@@ -382,2 +380,2 @@\n-  static FT_UInt\n-  cff_get_name_index( CFF_Face          face,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  cff_get_name_index( FT_Face           face,        \/* CFF_Face *\/\n@@ -386,2 +384,3 @@\n-    CFF_Font            cff;\n-    CFF_Charset         charset;\n+    CFF_Face            cffface = (CFF_Face)face;\n+    CFF_Font            cff     = (CFF_Font)cffface->extra.data;\n+    CFF_Charset         charset = &cff->charset;\n@@ -394,3 +393,0 @@\n-    cff     = (CFF_FontRec *)face->extra.data;\n-    charset = &cff->charset;\n-\n@@ -411,1 +407,1 @@\n-        return service->name_index( FT_FACE( face ), glyph_name );\n+        return service->name_index( face, glyph_name );\n@@ -415,2 +411,2 @@\n-                   \" cannot get glyph index from a CFF2 font\\n\"\n-                   \"                   \"\n+                   \" cannot get glyph index from a CFF2 font\\n\" ));\n+        FT_ERROR(( \"                   \"\n@@ -449,2 +445,2 @@\n-    (FT_GlyphDict_GetNameFunc)  cff_get_glyph_name,      \/* get_name   *\/\n-    (FT_GlyphDict_NameIndexFunc)cff_get_name_index       \/* name_index *\/\n+    cff_get_glyph_name,  \/* FT_GlyphDict_GetNameFunc   get_name   *\/\n+    cff_get_name_index   \/* FT_GlyphDict_NameIndexFunc name_index *\/\n@@ -459,1 +455,1 @@\n-  static FT_Int\n+  FT_CALLBACK_DEF( FT_Int )\n@@ -466,2 +462,2 @@\n-  static FT_Error\n-  cff_ps_get_font_info( CFF_Face         face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_ps_get_font_info( FT_Face          face,        \/* CFF_Face *\/\n@@ -470,2 +466,3 @@\n-    CFF_Font  cff   = (CFF_Font)face->extra.data;\n-    FT_Error  error = FT_Err_Ok;\n+    CFF_Face  cffface = (CFF_Face)face;\n+    CFF_Font  cff     = (CFF_Font)cffface->extra.data;\n+    FT_Error  error   = FT_Err_Ok;\n@@ -474,0 +471,6 @@\n+    if ( cffface->is_cff2 )\n+    {\n+      error = FT_THROW( Invalid_Argument );\n+      goto Fail;\n+    }\n+\n@@ -477,2 +480,2 @@\n-      PS_FontInfoRec  *font_info = NULL;\n-      FT_Memory        memory    = face->root.memory;\n+      FT_Memory        memory    = FT_FACE_MEMORY( face );\n+      PS_FontInfoRec*  font_info = NULL;\n@@ -481,1 +484,1 @@\n-      if ( FT_ALLOC( font_info, sizeof ( *font_info ) ) )\n+      if ( FT_QNEW( font_info ) )\n@@ -510,2 +513,2 @@\n-  static FT_Error\n-  cff_ps_get_font_extra( CFF_Face          face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_ps_get_font_extra( FT_Face           face,         \/* CFF_Face *\/\n@@ -514,2 +517,3 @@\n-    CFF_Font  cff   = (CFF_Font)face->extra.data;\n-    FT_Error  error = FT_Err_Ok;\n+    CFF_Face  cffface = (CFF_Face)face;\n+    CFF_Font  cff     = (CFF_Font)cffface->extra.data;\n+    FT_Error  error   = FT_Err_Ok;\n@@ -518,1 +522,1 @@\n-    if ( cff && cff->font_extra == NULL )\n+    if ( cff && !cff->font_extra )\n@@ -521,0 +525,1 @@\n+      FT_Memory         memory     = FT_FACE_MEMORY( face );\n@@ -522,1 +527,0 @@\n-      FT_Memory         memory     = face->root.memory;\n@@ -526,1 +530,1 @@\n-      if ( FT_ALLOC( font_extra, sizeof ( *font_extra ) ) )\n+      if ( FT_QNEW( font_extra ) )\n@@ -591,3 +595,3 @@\n-    (PS_GetFontInfoFunc)   cff_ps_get_font_info,    \/* ps_get_font_info    *\/\n-    (PS_GetFontExtraFunc)  cff_ps_get_font_extra,   \/* ps_get_font_extra   *\/\n-    (PS_HasGlyphNamesFunc) cff_ps_has_glyph_names,  \/* ps_has_glyph_names  *\/\n+    cff_ps_get_font_info,    \/* PS_GetFontInfoFunc    ps_get_font_info    *\/\n+    cff_ps_get_font_extra,   \/* PS_GetFontExtraFunc   ps_get_font_extra   *\/\n+    cff_ps_has_glyph_names,  \/* PS_HasGlyphNamesFunc  ps_has_glyph_names  *\/\n@@ -595,1 +599,1 @@\n-    (PS_GetFontPrivateFunc)NULL,                    \/* ps_get_font_private *\/\n+    NULL,                    \/* PS_GetFontPrivateFunc ps_get_font_private *\/\n@@ -597,1 +601,1 @@\n-    (PS_GetFontValueFunc)  NULL                     \/* ps_get_font_value   *\/\n+    NULL                     \/* PS_GetFontValueFunc   ps_get_font_value   *\/\n@@ -606,2 +610,2 @@\n-  static const char*\n-  cff_get_ps_name( CFF_Face  face )\n+  FT_CALLBACK_DEF( const char* )\n+  cff_get_ps_name( FT_Face  face )    \/* CFF_Face *\/\n@@ -609,2 +613,3 @@\n-    CFF_Font      cff  = (CFF_Font)face->extra.data;\n-    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+    CFF_Face      cffface = (CFF_Face)face;\n+    CFF_Font      cff     = (CFF_Font)cffface->extra.data;\n+    SFNT_Service  sfnt    = (SFNT_Service)cffface->sfnt;\n@@ -616,1 +621,1 @@\n-    if ( FT_IS_SFNT( FT_FACE( face ) ) && sfnt )\n+    if ( FT_IS_SFNT( face ) && sfnt )\n@@ -628,1 +633,1 @@\n-        return service->get_ps_font_name( FT_FACE( face ) );\n+        return service->get_ps_font_name( face );\n@@ -631,1 +636,1 @@\n-    return (const char*)cff->font_name;\n+    return cff ? (const char*)cff->font_name : NULL;\n@@ -638,1 +643,1 @@\n-    (FT_PsName_GetFunc)cff_get_ps_name      \/* get_ps_font_name *\/\n+    cff_get_ps_name  \/* FT_PsName_GetFunc get_ps_font_name *\/\n@@ -652,1 +657,1 @@\n-  static FT_Error\n+  FT_CALLBACK_DEF( FT_Error )\n@@ -686,1 +691,1 @@\n-    (TT_CMap_Info_GetFunc)cff_get_cmap_info    \/* get_cmap_info *\/\n+    cff_get_cmap_info  \/* TT_CMap_Info_GetFunc get_cmap_info *\/\n@@ -694,2 +699,2 @@\n-  static FT_Error\n-  cff_get_ros( CFF_Face      face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_ros( FT_Face       face,        \/* FT_Face *\/\n@@ -700,2 +705,3 @@\n-    FT_Error  error = FT_Err_Ok;\n-    CFF_Font  cff   = (CFF_Font)face->extra.data;\n+    FT_Error  error   = FT_Err_Ok;\n+    CFF_Face  cffface = (CFF_Face)face;\n+    CFF_Font  cff     = (CFF_Font)cffface->extra.data;\n@@ -751,2 +757,2 @@\n-  static FT_Error\n-  cff_get_is_cid( CFF_Face  face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_is_cid( FT_Face   face,    \/* CFF_Face *\/\n@@ -755,2 +761,3 @@\n-    FT_Error  error = FT_Err_Ok;\n-    CFF_Font  cff   = (CFF_Font)face->extra.data;\n+    FT_Error  error   = FT_Err_Ok;\n+    CFF_Face  cffface = (CFF_Face)face;\n+    CFF_Font  cff     = (CFF_Font)cffface->extra.data;\n@@ -774,2 +781,2 @@\n-  static FT_Error\n-  cff_get_cid_from_glyph_index( CFF_Face  face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_cid_from_glyph_index( FT_Face   face,        \/* CFF_Face *\/\n@@ -779,2 +786,3 @@\n-    FT_Error  error = FT_Err_Ok;\n-    CFF_Font  cff;\n+    FT_Error  error   = FT_Err_Ok;\n+    CFF_Face  cffface = (CFF_Face)face;\n+    CFF_Font  cff     = (CFF_Font)cffface->extra.data;\n@@ -783,2 +791,0 @@\n-    cff = (CFF_Font)face->extra.data;\n-\n@@ -817,6 +823,6 @@\n-    (FT_CID_GetRegistryOrderingSupplementFunc)\n-      cff_get_ros,                             \/* get_ros                  *\/\n-    (FT_CID_GetIsInternallyCIDKeyedFunc)\n-      cff_get_is_cid,                          \/* get_is_cid               *\/\n-    (FT_CID_GetCIDFromGlyphIndexFunc)\n-      cff_get_cid_from_glyph_index             \/* get_cid_from_glyph_index *\/\n+    cff_get_ros,\n+      \/* FT_CID_GetRegistryOrderingSupplementFunc get_ros                  *\/\n+    cff_get_is_cid,\n+      \/* FT_CID_GetIsInternallyCIDKeyedFunc       get_is_cid               *\/\n+    cff_get_cid_from_glyph_index\n+      \/* FT_CID_GetCIDFromGlyphIndexFunc          get_cid_from_glyph_index *\/\n@@ -834,3 +840,3 @@\n-    (FT_Properties_SetFunc)ps_property_set,      \/* set_property *\/\n-    (FT_Properties_GetFunc)ps_property_get )     \/* get_property *\/\n-\n+    ps_property_set,  \/* FT_Properties_SetFunc set_property *\/\n+    ps_property_get   \/* FT_Properties_GetFunc get_property *\/\n+  )\n@@ -845,2 +851,2 @@\n-  static FT_Error\n-  cff_set_mm_blend( CFF_Face   face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_set_mm_blend( FT_Face    face,        \/* CFF_Face *\/\n@@ -850,1 +856,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -853,1 +860,1 @@\n-    return mm->set_mm_blend( FT_FACE( face ), num_coords, coords );\n+    return mm->set_mm_blend( face, num_coords, coords );\n@@ -857,2 +864,2 @@\n-  static FT_Error\n-  cff_get_mm_blend( CFF_Face   face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_mm_blend( FT_Face    face,       \/* CFF_Face *\/\n@@ -862,1 +869,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -865,1 +873,1 @@\n-    return mm->get_mm_blend( FT_FACE( face ), num_coords, coords );\n+    return mm->get_mm_blend( face, num_coords, coords );\n@@ -869,2 +877,2 @@\n-  static FT_Error\n-  cff_set_mm_weightvector( CFF_Face   face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_set_mm_weightvector( FT_Face    face,          \/* CFF_Face *\/\n@@ -874,1 +882,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -877,1 +886,1 @@\n-    return mm->set_mm_weightvector( FT_FACE( face ), len, weightvector );\n+    return mm->set_mm_weightvector( face, len, weightvector );\n@@ -881,2 +890,2 @@\n-  static FT_Error\n-  cff_get_mm_weightvector( CFF_Face   face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_mm_weightvector( FT_Face    face,          \/* CFF_Face *\/\n@@ -886,1 +895,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -889,1 +899,1 @@\n-    return mm->get_mm_weightvector( FT_FACE( face ), len, weightvector );\n+    return mm->get_mm_weightvector( face, len, weightvector );\n@@ -893,2 +903,13 @@\n-  static FT_Error\n-  cff_get_mm_var( CFF_Face     face,\n+  FT_CALLBACK_DEF( void )\n+  cff_construct_ps_name( FT_Face  face )  \/* CFF_Face *\/\n+  {\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n+\n+\n+    mm->construct_ps_name( face );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_mm_var( FT_Face      face,    \/* CFF_Face *\/\n@@ -897,1 +918,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -900,1 +922,1 @@\n-    return mm->get_mm_var( FT_FACE( face ), master );\n+    return mm->get_mm_var( face, master );\n@@ -904,2 +926,2 @@\n-  static FT_Error\n-  cff_set_var_design( CFF_Face   face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_set_var_design( FT_Face    face,       \/* CFF_Face *\/\n@@ -909,1 +931,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -912,1 +935,1 @@\n-    return mm->set_var_design( FT_FACE( face ), num_coords, coords );\n+    return mm->set_var_design( face, num_coords, coords );\n@@ -916,2 +939,2 @@\n-  static FT_Error\n-  cff_get_var_design( CFF_Face   face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_var_design( FT_Face    face,       \/* CFF_Face *\/\n@@ -921,1 +944,26 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n+\n+\n+    return mm->get_var_design( face, num_coords, coords );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_set_named_instance( FT_Face   face,            \/* CFF_Face *\/\n+                          FT_UInt   instance_index )\n+  {\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n+\n+\n+    return mm->set_named_instance( face, instance_index );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_get_default_named_instance( FT_Face   face,            \/* CFF_Face *\/\n+                                  FT_UInt  *instance_index )\n+  {\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -924,1 +972,1 @@\n-    return mm->get_var_design( FT_FACE( face ), num_coords, coords );\n+    return mm->get_default_named_instance( face, instance_index );\n@@ -928,3 +976,4 @@\n-  static FT_Error\n-  cff_set_instance( CFF_Face  face,\n-                    FT_UInt   instance_index )\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_load_item_variation_store( FT_Face          face,       \/* CFF_Face *\/\n+                                 FT_ULong         offset,\n+                                 GX_ItemVarStore  itemStore )\n@@ -932,1 +981,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -935,1 +985,1 @@\n-    return mm->set_instance( FT_FACE( face ), instance_index );\n+    return mm->load_item_var_store( face, offset, itemStore );\n@@ -939,0 +989,55 @@\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_load_delta_set_index_mapping( FT_Face            face,   \/* CFF_Face *\/\n+                                    FT_ULong           offset,\n+                                    GX_DeltaSetIdxMap  map,\n+                                    GX_ItemVarStore    itemStore,\n+                                    FT_ULong           table_len )\n+  {\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n+\n+\n+    return mm->load_delta_set_idx_map( face, offset, map,\n+                                       itemStore, table_len );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Int )\n+  cff_get_item_delta( FT_Face          face,        \/* CFF_Face *\/\n+                      GX_ItemVarStore  itemStore,\n+                      FT_UInt          outerIndex,\n+                      FT_UInt          innerIndex )\n+  {\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n+\n+\n+    return mm->get_item_delta( face, itemStore, outerIndex, innerIndex );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( void )\n+  cff_done_item_variation_store( FT_Face          face,       \/* CFF_Face *\/\n+                                 GX_ItemVarStore  itemStore )\n+  {\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n+\n+\n+    mm->done_item_var_store( face, itemStore );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( void )\n+  cff_done_delta_set_index_map( FT_Face            face,       \/* CFF_Face *\/\n+                                GX_DeltaSetIdxMap  deltaSetIdxMap )\n+  {\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n+\n+\n+    mm->done_delta_set_idx_map( face, deltaSetIdxMap );\n+  }\n+\n+\n+\n@@ -942,13 +1047,29 @@\n-    (FT_Get_MM_Func)             NULL,                    \/* get_mm              *\/\n-    (FT_Set_MM_Design_Func)      NULL,                    \/* set_mm_design       *\/\n-    (FT_Set_MM_Blend_Func)       cff_set_mm_blend,        \/* set_mm_blend        *\/\n-    (FT_Get_MM_Blend_Func)       cff_get_mm_blend,        \/* get_mm_blend        *\/\n-    (FT_Get_MM_Var_Func)         cff_get_mm_var,          \/* get_mm_var          *\/\n-    (FT_Set_Var_Design_Func)     cff_set_var_design,      \/* set_var_design      *\/\n-    (FT_Get_Var_Design_Func)     cff_get_var_design,      \/* get_var_design      *\/\n-    (FT_Set_Instance_Func)       cff_set_instance,        \/* set_instance        *\/\n-    (FT_Set_MM_WeightVector_Func)cff_set_mm_weightvector, \/* set_mm_weightvector *\/\n-    (FT_Get_MM_WeightVector_Func)cff_get_mm_weightvector, \/* get_mm_weightvector *\/\n-\n-    (FT_Get_Var_Blend_Func)      cff_get_var_blend,       \/* get_var_blend       *\/\n-    (FT_Done_Blend_Func)         cff_done_blend           \/* done_blend          *\/\n+    NULL,                \/* FT_Get_MM_Func         get_mm                     *\/\n+    NULL,                \/* FT_Set_MM_Design_Func  set_mm_design              *\/\n+    cff_set_mm_blend,    \/* FT_Set_MM_Blend_Func   set_mm_blend               *\/\n+    cff_get_mm_blend,    \/* FT_Get_MM_Blend_Func   get_mm_blend               *\/\n+    cff_get_mm_var,      \/* FT_Get_MM_Var_Func     get_mm_var                 *\/\n+    cff_set_var_design,  \/* FT_Set_Var_Design_Func set_var_design             *\/\n+    cff_get_var_design,  \/* FT_Get_Var_Design_Func get_var_design             *\/\n+    cff_set_named_instance,\n+             \/* FT_Set_Named_Instance_Func         set_named_instance         *\/\n+    cff_get_default_named_instance,\n+             \/* FT_Get_Default_Named_Instance_Func get_default_named_instance *\/\n+    cff_set_mm_weightvector,\n+             \/* FT_Set_MM_WeightVector_Func        set_mm_weightvector        *\/\n+    cff_get_mm_weightvector,\n+             \/* FT_Get_MM_WeightVector_Func        get_mm_weightvector        *\/\n+    cff_construct_ps_name,\n+             \/* FT_Construct_PS_Name_Func          construct_ps_name          *\/\n+    cff_load_delta_set_index_mapping,\n+             \/* FT_Var_Load_Delta_Set_Idx_Map_Func load_delta_set_idx_map     *\/\n+    cff_load_item_variation_store,\n+             \/* FT_Var_Load_Item_Var_Store_Func    load_item_variation_store  *\/\n+    cff_get_item_delta,\n+             \/* FT_Var_Get_Item_Delta_Func         get_item_delta             *\/\n+    cff_done_item_variation_store,\n+             \/* FT_Var_Done_Item_Var_Store_Func    done_item_variation_store  *\/\n+    cff_done_delta_set_index_map,\n+             \/* FT_Var_Done_Delta_Set_Idx_Map_Func done_delta_set_index_map   *\/\n+    cff_get_var_blend,   \/* FT_Get_Var_Blend_Func  get_var_blend              *\/\n+    cff_done_blend       \/* FT_Done_Blend_Func     done_blend                 *\/\n@@ -963,2 +1084,2 @@\n-  static FT_Error\n-  cff_hadvance_adjust( CFF_Face  face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cff_hadvance_adjust( FT_Face   face,    \/* CFF_Face *\/\n@@ -968,1 +1089,3 @@\n-    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n+    CFF_Face  cffface = (CFF_Face)face;\n+    FT_Service_MetricsVariations\n+              var     = (FT_Service_MetricsVariations)cffface->tt_var;\n@@ -971,1 +1094,1 @@\n-    return var->hadvance_adjust( FT_FACE( face ), gindex, avalue );\n+    return var->hadvance_adjust( face, gindex, avalue );\n@@ -975,2 +1098,2 @@\n-  static void\n-  cff_metrics_adjust( CFF_Face  face )\n+  FT_CALLBACK_DEF( void )\n+  cff_metrics_adjust( FT_Face  face )    \/* CFF_Face *\/\n@@ -978,1 +1101,3 @@\n-    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n+    CFF_Face  cffface = (CFF_Face)face;\n+    FT_Service_MetricsVariations\n+              var     = (FT_Service_MetricsVariations)cffface->tt_var;\n@@ -981,1 +1106,1 @@\n-    var->metrics_adjust( FT_FACE( face ) );\n+    var->metrics_adjust( face );\n@@ -988,3 +1113,3 @@\n-    (FT_HAdvance_Adjust_Func)cff_hadvance_adjust,    \/* hadvance_adjust *\/\n-    (FT_LSB_Adjust_Func)     NULL,                   \/* lsb_adjust      *\/\n-    (FT_RSB_Adjust_Func)     NULL,                   \/* rsb_adjust      *\/\n+    cff_hadvance_adjust,  \/* FT_HAdvance_Adjust_Func hadvance_adjust *\/\n+    NULL,                 \/* FT_LSB_Adjust_Func      lsb_adjust      *\/\n+    NULL,                 \/* FT_RSB_Adjust_Func      rsb_adjust      *\/\n@@ -992,4 +1117,4 @@\n-    (FT_VAdvance_Adjust_Func)NULL,                   \/* vadvance_adjust *\/\n-    (FT_TSB_Adjust_Func)     NULL,                   \/* tsb_adjust      *\/\n-    (FT_BSB_Adjust_Func)     NULL,                   \/* bsb_adjust      *\/\n-    (FT_VOrg_Adjust_Func)    NULL,                   \/* vorg_adjust     *\/\n+    NULL,                 \/* FT_VAdvance_Adjust_Func vadvance_adjust *\/\n+    NULL,                 \/* FT_TSB_Adjust_Func      tsb_adjust      *\/\n+    NULL,                 \/* FT_BSB_Adjust_Func      bsb_adjust      *\/\n+    NULL,                 \/* FT_VOrg_Adjust_Func     vorg_adjust     *\/\n@@ -997,1 +1122,2 @@\n-    (FT_Metrics_Adjust_Func) cff_metrics_adjust      \/* metrics_adjust  *\/\n+    cff_metrics_adjust,   \/* FT_Metrics_Adjust_Func  metrics_adjust  *\/\n+    NULL                  \/* FT_Size_Reset_Func      size_reset      *\/\n@@ -1010,5 +1136,5 @@\n-    (FT_Get_Standard_Encoding_Func)cff_get_standard_encoding,\n-    (FT_Load_Private_Dict_Func)    cff_load_private_dict,\n-    (FT_FD_Select_Get_Func)        cff_fd_select_get,\n-    (FT_Blend_Check_Vector_Func)   cff_blend_check_vector,\n-    (FT_Blend_Build_Vector_Func)   cff_blend_build_vector\n+    cff_get_standard_encoding,  \/* FT_Get_Standard_Encoding_Func get_standard_encoding *\/\n+    cff_load_private_dict,      \/* FT_Load_Private_Dict_Func     load_private_dict     *\/\n+    cff_fd_select_get,          \/* FT_FD_Select_Get_Func         fd_select_get         *\/\n+    cff_blend_check_vector,     \/* FT_Blend_Check_Vector_Func    blend_check_vector    *\/\n+    cff_blend_build_vector      \/* FT_Blend_Build_Vector_Func    blend_build_vector    *\/\n@@ -1030,2 +1156,1 @@\n-#if !defined FT_CONFIG_OPTION_NO_GLYPH_NAMES && \\\n-     defined TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+#if defined TT_CONFIG_OPTION_GX_VAR_SUPPORT\n@@ -1046,1 +1171,1 @@\n-#elif !defined FT_CONFIG_OPTION_NO_GLYPH_NAMES\n+#else\n@@ -1059,26 +1184,0 @@\n-#elif defined TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-  FT_DEFINE_SERVICEDESCREC9(\n-    cff_services,\n-\n-    FT_SERVICE_ID_FONT_FORMAT,          FT_FONT_FORMAT_CFF,\n-    FT_SERVICE_ID_MULTI_MASTERS,        &cff_service_multi_masters,\n-    FT_SERVICE_ID_METRICS_VARIATIONS,   &cff_service_metrics_var,\n-    FT_SERVICE_ID_POSTSCRIPT_INFO,      &cff_service_ps_info,\n-    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &cff_service_ps_name,\n-    FT_SERVICE_ID_TT_CMAP,              &cff_service_get_cmap_info,\n-    FT_SERVICE_ID_CID,                  &cff_service_cid_info,\n-    FT_SERVICE_ID_PROPERTIES,           &cff_service_properties,\n-    FT_SERVICE_ID_CFF_LOAD,             &cff_service_cff_load\n-  )\n-#else\n-  FT_DEFINE_SERVICEDESCREC7(\n-    cff_services,\n-\n-    FT_SERVICE_ID_FONT_FORMAT,          FT_FONT_FORMAT_CFF,\n-    FT_SERVICE_ID_POSTSCRIPT_INFO,      &cff_service_ps_info,\n-    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &cff_service_ps_name,\n-    FT_SERVICE_ID_TT_CMAP,              &cff_service_get_cmap_info,\n-    FT_SERVICE_ID_CID,                  &cff_service_cid_info,\n-    FT_SERVICE_ID_PROPERTIES,           &cff_service_properties,\n-    FT_SERVICE_ID_CFF_LOAD,             &cff_service_cff_load\n-  )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffdrivr.c","additions":301,"deletions":202,"binary":false,"changes":503,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffdrivr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cfferrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -32,0 +32,8 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+#define IS_DEFAULT_INSTANCE( _face )             \\\n+          ( !( FT_IS_NAMED_INSTANCE( _face ) ||  \\\n+               FT_IS_VARIATION( _face )      ) )\n+#else\n+#define IS_DEFAULT_INSTANCE( _face )  1\n+#endif\n+\n@@ -62,1 +70,1 @@\n-      *length  = (FT_ULong)data.length;\n+      *length  = data.length;\n@@ -70,1 +78,1 @@\n-      CFF_Font  cff = (CFF_Font)(face->extra.data);\n+      CFF_Font  cff = (CFF_Font)( face->extra.data );\n@@ -97,1 +105,1 @@\n-      data.length  = (FT_Int)length;\n+      data.length  = (FT_UInt)length;\n@@ -106,1 +114,1 @@\n-      CFF_Font  cff = (CFF_Font)(face->extra.data);\n+      CFF_Font  cff = (CFF_Font)( face->extra.data );\n@@ -258,2 +266,2 @@\n-           sfnt->load_eblc                         &&\n-           ( load_flags & FT_LOAD_NO_BITMAP ) == 0 )\n+           ( load_flags & FT_LOAD_NO_BITMAP ) == 0 &&\n+           IS_DEFAULT_INSTANCE( size->root.face )  )\n@@ -349,0 +357,69 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    \/* check for OT-SVG *\/\n+    if ( ( load_flags & FT_LOAD_NO_SVG ) == 0 &&\n+         ( load_flags & FT_LOAD_COLOR )       &&\n+         face->svg                            )\n+    {\n+      \/*\n+       * We load the SVG document and try to grab the advances from the\n+       * table.  For the bearings we rely on the presetting hook to do that.\n+       *\/\n+\n+      SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+\n+\n+      if ( size && (size->root.metrics.x_ppem < 1 ||\n+                    size->root.metrics.y_ppem < 1 ) )\n+      {\n+        error = FT_THROW( Invalid_Size_Handle );\n+        return error;\n+      }\n+\n+      FT_TRACE3(( \"Trying to load SVG glyph\\n\" ));\n+\n+      error = sfnt->load_svg_doc( (FT_GlyphSlot)glyph, glyph_index );\n+      if ( !error )\n+      {\n+        FT_Fixed  x_scale = size->root.metrics.x_scale;\n+        FT_Fixed  y_scale = size->root.metrics.y_scale;\n+\n+        FT_Short   dummy;\n+        FT_UShort  advanceX;\n+        FT_UShort  advanceY;\n+\n+\n+        FT_TRACE3(( \"Successfully loaded SVG glyph\\n\" ));\n+\n+        glyph->root.format = FT_GLYPH_FORMAT_SVG;\n+\n+        \/*\n+         * If horizontal or vertical advances are not present in the table,\n+         * this is a problem with the font since the standard requires them.\n+         * However, we are graceful and calculate the values by ourselves\n+         * for the vertical case.\n+         *\/\n+        sfnt->get_metrics( face,\n+                           FALSE,\n+                           glyph_index,\n+                           &dummy,\n+                           &advanceX );\n+        sfnt->get_metrics( face,\n+                           TRUE,\n+                           glyph_index,\n+                           &dummy,\n+                           &advanceY );\n+\n+        glyph->root.linearHoriAdvance = advanceX;\n+        glyph->root.linearVertAdvance = advanceY;\n+\n+        glyph->root.metrics.horiAdvance = FT_MulFix( advanceX, x_scale );\n+        glyph->root.metrics.vertAdvance = FT_MulFix( advanceY, y_scale );\n+\n+        return error;\n+      }\n+\n+      FT_TRACE3(( \"Failed to load SVG glyph\\n\" ));\n+    }\n+\n+#endif \/* FT_CONFIG_OPTION_SVG *\/\n+\n@@ -416,3 +493,2 @@\n-      \/* now load the unscaled outline *\/\n-      error = cff_get_glyph_data( face, glyph_index,\n-                                  &charstring, &charstring_len );\n+      \/* this function also checks for a valid subfont index *\/\n+      error = decoder_funcs->prepare( &decoder, size, glyph_index );\n@@ -422,1 +498,3 @@\n-      error = decoder_funcs->prepare( &decoder, size, glyph_index );\n+      \/* now load the unscaled outline *\/\n+      error = cff_get_glyph_data( face, glyph_index,\n+                                  &charstring, &charstring_len );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffgload.c","additions":89,"deletions":11,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -359,3 +359,3 @@\n-      if ( FT_NEW_ARRAY( idx->offsets, idx->count + 1 ) ||\n-           FT_STREAM_SEEK( idx->start + idx->hdr_size ) ||\n-           FT_FRAME_ENTER( data_size )                  )\n+      if ( FT_QNEW_ARRAY( idx->offsets, idx->count + 1 ) ||\n+           FT_STREAM_SEEK( idx->start + idx->hdr_size )  ||\n+           FT_FRAME_ENTER( data_size )                   )\n@@ -403,1 +403,1 @@\n-  \/* entries to C-style strings (this is, NULL-terminated).       *\/\n+  \/* entries to C-style strings (that is, null-terminated).       *\/\n@@ -430,1 +430,1 @@\n-         !FT_NEW_ARRAY( tbl, idx->count + 1 )          &&\n+         !FT_QNEW_ARRAY( tbl, idx->count + 1 )         &&\n@@ -625,1 +625,1 @@\n-    FT_String*  name = 0;\n+    FT_String*  name = NULL;\n@@ -637,1 +637,1 @@\n-    if ( !FT_ALLOC( name, byte_len + 1 ) )\n+    if ( !FT_QALLOC( name, byte_len + 1 ) )\n@@ -639,2 +639,1 @@\n-      if ( byte_len )\n-        FT_MEM_COPY( name, bytes, byte_len );\n+      FT_MEM_COPY( name, bytes, byte_len );\n@@ -775,2 +774,1 @@\n-      if ( (FT_UInt)( glyph_index - fdselect->cache_first ) <\n-                        fdselect->cache_count )\n+      if ( glyph_index - fdselect->cache_first < fdselect->cache_count )\n@@ -839,1 +837,0 @@\n-    FT_Long    j;\n@@ -857,3 +854,4 @@\n-    \/* behaviour of recent Acroread versions.                       *\/\n-    for ( j = (FT_Long)num_glyphs - 1; j >= 0; j-- )\n-      charset->cids[charset->sids[j]] = (FT_UShort)j;\n+    \/* behaviour of recent Acroread versions.  The loop stops when  *\/\n+    \/* the unsigned index wraps around after reaching zero.         *\/\n+    for ( i = num_glyphs - 1; i < num_glyphs; i-- )\n+      charset->cids[charset->sids[i]] = (FT_UShort)i;\n@@ -935,1 +933,1 @@\n-      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+      if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1021,2 +1019,2 @@\n-          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\"\n-                     \"predefined charset (Adobe ISO-Latin)\\n\" ));\n+          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\" ));\n+          FT_ERROR(( \"predefined charset (Adobe ISO-Latin)\\n\" ));\n@@ -1028,1 +1026,1 @@\n-        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+        if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1039,2 +1037,2 @@\n-          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\"\n-                     \"predefined charset (Adobe Expert)\\n\" ));\n+          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\" ));\n+          FT_ERROR(( \"predefined charset (Adobe Expert)\\n\" ));\n@@ -1046,1 +1044,1 @@\n-        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+        if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1057,2 +1055,2 @@\n-          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\"\n-                     \"predefined charset (Adobe Expert Subset)\\n\" ));\n+          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\" ));\n+          FT_ERROR(( \"predefined charset (Adobe Expert Subset)\\n\" ));\n@@ -1064,1 +1062,1 @@\n-        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+        if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1090,1 +1088,0 @@\n-      charset->sids   = 0;\n@@ -1144,0 +1141,2 @@\n+      FT_UInt   dataCount;\n+      FT_UInt   regionCount;\n@@ -1166,2 +1165,2 @@\n-      if ( FT_READ_ULONG( regionListOffset )   ||\n-           FT_READ_USHORT( vstore->dataCount ) )\n+      if ( FT_READ_ULONG( regionListOffset ) ||\n+           FT_READ_USHORT( dataCount )       )\n@@ -1172,1 +1171,1 @@\n-      if ( FT_NEW_ARRAY( dataOffsetArray, vstore->dataCount ) )\n+      if ( FT_QNEW_ARRAY( dataOffsetArray, dataCount ) )\n@@ -1175,1 +1174,1 @@\n-      for ( i = 0; i < vstore->dataCount; i++ )\n+      for ( i = 0; i < dataCount; i++ )\n@@ -1184,1 +1183,1 @@\n-           FT_READ_USHORT( vstore->regionCount )         )\n+           FT_READ_USHORT( regionCount )                 )\n@@ -1187,1 +1186,2 @@\n-      if ( FT_NEW_ARRAY( vstore->varRegionList, vstore->regionCount ) )\n+      vstore->regionCount = 0;\n+      if ( FT_QNEW_ARRAY( vstore->varRegionList, regionCount ) )\n@@ -1190,1 +1190,1 @@\n-      for ( i = 0; i < vstore->regionCount; i++ )\n+      for ( i = 0; i < regionCount; i++ )\n@@ -1195,1 +1195,1 @@\n-        if ( FT_NEW_ARRAY( region->axisList, vstore->axisCount ) )\n+        if ( FT_QNEW_ARRAY( region->axisList, vstore->axisCount ) )\n@@ -1198,0 +1198,3 @@\n+        \/* keep track of how many axisList to deallocate on error *\/\n+        vstore->regionCount++;\n+\n@@ -1202,1 +1205,1 @@\n-          FT_Int16  start14, peak14, end14;\n+          FT_Int  start, peak, end;\n@@ -1205,3 +1208,3 @@\n-          if ( FT_READ_SHORT( start14 ) ||\n-               FT_READ_SHORT( peak14 )  ||\n-               FT_READ_SHORT( end14 )   )\n+          if ( FT_READ_SHORT( start ) ||\n+               FT_READ_SHORT( peak )  ||\n+               FT_READ_SHORT( end )   )\n@@ -1210,3 +1213,7 @@\n-          axis->startCoord = FT_fdot14ToFixed( start14 );\n-          axis->peakCoord  = FT_fdot14ToFixed( peak14 );\n-          axis->endCoord   = FT_fdot14ToFixed( end14 );\n+          \/* immediately tag invalid ranges with special peak = 0 *\/\n+          if ( ( start < 0 && end > 0 ) || start > peak || peak > end )\n+            peak = 0;\n+\n+          axis->startCoord = FT_fdot14ToFixed( start );\n+          axis->peakCoord  = FT_fdot14ToFixed( peak );\n+          axis->endCoord   = FT_fdot14ToFixed( end );\n@@ -1217,1 +1224,2 @@\n-      if ( FT_NEW_ARRAY( vstore->varData, vstore->dataCount ) )\n+      vstore->dataCount = 0;\n+      if ( FT_QNEW_ARRAY( vstore->varData, dataCount ) )\n@@ -1220,1 +1228,1 @@\n-      for ( i = 0; i < vstore->dataCount; i++ )\n+      for ( i = 0; i < dataCount; i++ )\n@@ -1239,1 +1247,1 @@\n-        if ( FT_NEW_ARRAY( data->regionIndices, data->regionIdxCount ) )\n+        if ( FT_QNEW_ARRAY( data->regionIndices, data->regionIdxCount ) )\n@@ -1242,0 +1250,3 @@\n+        \/* keep track of how many regionIndices to deallocate on error *\/\n+        vstore->dataCount++;\n+\n@@ -1284,1 +1295,1 @@\n-  \/* Blend calculation is done in 16.16 fixed point.       *\/\n+  \/* Blend calculation is done in 16.16 fixed-point.       *\/\n@@ -1325,3 +1336,3 @@\n-      if ( FT_REALLOC( subFont->blend_stack,\n-                       subFont->blend_alloc,\n-                       subFont->blend_alloc + size ) )\n+      if ( FT_QREALLOC( subFont->blend_stack,\n+                        subFont->blend_alloc,\n+                        subFont->blend_alloc + size ) )\n@@ -1357,1 +1368,1 @@\n-      FT_UInt32        sum;\n+      FT_Fixed         sum;\n@@ -1361,1 +1372,1 @@\n-      sum = cff_parse_num( parser, &parser->stack[i + base] ) * 0x10000;\n+      sum = cff_parse_fixed( parser, &parser->stack[i + base] );\n@@ -1364,1 +1375,2 @@\n-        sum += cff_parse_num( parser, &parser->stack[delta++] ) * *weight++;\n+        sum += FT_MulFix( cff_parse_fixed( parser, &parser->stack[delta++] ),\n+                          *weight++ );\n@@ -1369,1 +1381,1 @@\n-      \/* Push blended result as Type 2 5-byte fixed point number.  This *\/\n+      \/* Push blended result as Type 2 5-byte fixed-point number.  This *\/\n@@ -1374,4 +1386,4 @@\n-      *subFont->blend_top++ = (FT_Byte)( sum >> 24 );\n-      *subFont->blend_top++ = (FT_Byte)( sum >> 16 );\n-      *subFont->blend_top++ = (FT_Byte)( sum >>  8 );\n-      *subFont->blend_top++ = (FT_Byte)sum;\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum >> 24 );\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum >> 16 );\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum >>  8 );\n+      *subFont->blend_top++ = (FT_Byte)( (FT_UInt32)sum );\n@@ -1440,3 +1452,1 @@\n-    if ( FT_REALLOC( blend->BV,\n-                     blend->lenBV * sizeof( *blend->BV ),\n-                     len * sizeof( *blend->BV ) ) )\n+    if ( FT_QRENEW_ARRAY( blend->BV, blend->lenBV, len ) )\n@@ -1459,4 +1469,2 @@\n-        FT_TRACE4(( \"   build blend vector len %d\\n\"\n-                    \"   [ %f \",\n-                    len,\n-                    blend->BV[master] \/ 65536.0 ));\n+        FT_TRACE4(( \"   build blend vector len %d\\n\", len ));\n+        FT_TRACE4(( \"   [ %f \", blend->BV[master] \/ 65536.0 ));\n@@ -1494,8 +1502,0 @@\n-        FT_Fixed         axisScalar;\n-\n-\n-        \/* compute the scalar contribution of this axis; *\/\n-        \/* ignore invalid ranges                         *\/\n-        if ( axis->startCoord > axis->peakCoord ||\n-             axis->peakCoord > axis->endCoord   )\n-          axisScalar = FT_FIXED_ONE;\n@@ -1503,4 +1503,0 @@\n-        else if ( axis->startCoord < 0 &&\n-                  axis->endCoord > 0   &&\n-                  axis->peakCoord != 0 )\n-          axisScalar = FT_FIXED_ONE;\n@@ -1508,3 +1504,5 @@\n-        \/* peak of 0 means ignore this axis *\/\n-        else if ( axis->peakCoord == 0 )\n-          axisScalar = FT_FIXED_ONE;\n+        \/* compute the scalar contribution of this axis *\/\n+        \/* with peak of 0 used for invalid axes         *\/\n+        if ( axis->peakCoord == NDV[j] ||\n+             axis->peakCoord == 0      )\n+          continue;\n@@ -1513,6 +1511,2 @@\n-        else if ( NDV[j] < axis->startCoord ||\n-                  NDV[j] > axis->endCoord   )\n-          axisScalar = 0;\n-\n-        \/* calculate a proportional factor *\/\n-        else\n+        else if ( NDV[j] <= axis->startCoord ||\n+                  NDV[j] >= axis->endCoord   )\n@@ -1520,8 +1514,2 @@\n-          if ( NDV[j] == axis->peakCoord )\n-            axisScalar = FT_FIXED_ONE;\n-          else if ( NDV[j] < axis->peakCoord )\n-            axisScalar = FT_DivFix( NDV[j] - axis->startCoord,\n-                                    axis->peakCoord - axis->startCoord );\n-          else\n-            axisScalar = FT_DivFix( axis->endCoord - NDV[j],\n-                                    axis->endCoord - axis->peakCoord );\n+          blend->BV[master] = 0;\n+          break;\n@@ -1530,2 +1518,9 @@\n-        \/* take product of all the axis scalars *\/\n-        blend->BV[master] = FT_MulFix( blend->BV[master], axisScalar );\n+        \/* adjust proportionally *\/\n+        else if ( NDV[j] < axis->peakCoord )\n+          blend->BV[master] = FT_MulDiv( blend->BV[master],\n+                                         NDV[j] - axis->startCoord,\n+                                         axis->peakCoord - axis->startCoord );\n+        else   \/* NDV[j] > axis->peakCoord ) *\/\n+          blend->BV[master] = FT_MulDiv( blend->BV[master],\n+                                         axis->endCoord - NDV[j],\n+                                         axis->endCoord - axis->peakCoord );\n@@ -1546,3 +1541,1 @@\n-      if ( FT_REALLOC( blend->lastNDV,\n-                       blend->lenNDV * sizeof ( *NDV ),\n-                       lenNDV * sizeof ( *NDV ) ) )\n+      if ( FT_QRENEW_ARRAY( blend->lastNDV, blend->lenNDV, lenNDV ) )\n@@ -1591,1 +1584,1 @@\n-  cff_get_var_blend( CFF_Face     face,\n+  cff_get_var_blend( FT_Face      face,             \/* CFF_Face *\/\n@@ -1597,1 +1590,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -1600,1 +1594,1 @@\n-    return mm->get_var_blend( FT_FACE( face ),\n+    return mm->get_var_blend( face,\n@@ -1609,1 +1603,1 @@\n-  cff_done_blend( CFF_Face  face )\n+  cff_done_blend( FT_Face  face )    \/* CFF_Face *\/\n@@ -1611,1 +1605,2 @@\n-    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+    CFF_Face                 cffface = (CFF_Face)face;\n+    FT_Service_MultiMasters  mm      = (FT_Service_MultiMasters)cffface->mm;\n@@ -1614,2 +1609,2 @@\n-    if (mm)\n-      mm->done_blend( FT_FACE( face ) );\n+    if ( mm )\n+      mm->done_blend( face );\n@@ -1652,7 +1647,0 @@\n-    \/* Zero out the code to gid\/sid mappings. *\/\n-    for ( j = 0; j < 256; j++ )\n-    {\n-      encoding->sids [j] = 0;\n-      encoding->codes[j] = 0;\n-    }\n-\n@@ -1673,0 +1661,4 @@\n+      \/* Zero out the code to gid\/sid mappings. *\/\n+      FT_ARRAY_ZERO( encoding->sids,  256 );\n+      FT_ARRAY_ZERO( encoding->codes, 256 );\n+\n@@ -1830,1 +1822,2 @@\n-        encoding->count = 0;\n+        encoding->offset = offset; \/* used in cff_face_init *\/\n+        encoding->count  = 0;\n@@ -2013,1 +2006,1 @@\n-                             &subfont->font_dict,\n+                             top,\n@@ -2366,2 +2359,2 @@\n-                   \" invalid CFF font with multiple subfonts\\n\"\n-                   \"              \"\n+                   \" invalid CFF font with multiple subfonts\\n\" ));\n+        FT_ERROR(( \"              \"\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffload.c","additions":109,"deletions":116,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -108,1 +108,1 @@\n-  cff_get_var_blend( CFF_Face     face,\n+  cff_get_var_blend( FT_Face      face,\n@@ -115,1 +115,1 @@\n-  cff_done_blend( CFF_Face  face );\n+  cff_done_blend( FT_Face  face );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffload.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -45,0 +45,2 @@\n+#define CFF_fixedToInt( x )                          \\\n+          ( (FT_Short)( ( (x) + 0x8000U ) >> 16 ) )\n@@ -72,2 +74,2 @@\n-    module = FT_Get_Module( size->root.face->driver->root.library,\n-                            \"pshinter\" );\n+    module = FT_Get_Module( font->library, \"pshinter\" );\n+\n@@ -127,1 +129,1 @@\n-      priv->blue_values[n] = (FT_Short)cpriv->blue_values[n];\n+      priv->blue_values[n] = CFF_fixedToInt( cpriv->blue_values[n] );\n@@ -131,1 +133,1 @@\n-      priv->other_blues[n] = (FT_Short)cpriv->other_blues[n];\n+      priv->other_blues[n] = CFF_fixedToInt( cpriv->other_blues[n] );\n@@ -135,1 +137,1 @@\n-      priv->family_blues[n] = (FT_Short)cpriv->family_blues[n];\n+      priv->family_blues[n] = CFF_fixedToInt( cpriv->family_blues[n] );\n@@ -139,1 +141,2 @@\n-      priv->family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];\n+      priv->family_other_blues[n] =\n+        CFF_fixedToInt( cpriv->family_other_blues[n] );\n@@ -185,2 +188,1 @@\n-    error = funcs->create( cffsize->face->memory, &priv,\n-                             &internal->topfont );\n+    error = funcs->create( memory, &priv, &internal->topfont );\n@@ -196,2 +198,1 @@\n-      error = funcs->create( cffsize->face->memory, &priv,\n-                               &internal->subfonts[i - 1] );\n+      error = funcs->create( memory, &priv, &internal->subfonts[i - 1] );\n@@ -286,0 +287,2 @@\n+    FT_Error  error;\n+\n@@ -307,1 +310,3 @@\n-    FT_Request_Metrics( size->face, req );\n+    error = FT_Request_Metrics( size->face, req );\n+    if ( error )\n+      goto Exit;\n@@ -348,1 +353,2 @@\n-    return FT_Err_Ok;\n+  Exit:\n+    return error;\n@@ -379,2 +385,1 @@\n-      module = FT_Get_Module( slot->face->driver->root.library,\n-                              \"pshinter\" );\n+      module = FT_Get_Module( slot->library, \"pshinter\" );\n@@ -409,3 +414,1 @@\n-    (void)FT_STRDUP( result, source );\n-\n-    FT_UNUSED( error );\n+    FT_MEM_STRDUP( result, source );\n@@ -424,3 +427,1 @@\n-    FT_Int32  idx             = 0;\n-    FT_Int32  length          = (FT_Int32)ft_strlen( name ) + 1;\n-    FT_Bool   continue_search = 1;\n+    FT_UInt32  i = 0, idx = 0;\n@@ -429,1 +430,8 @@\n-    while ( continue_search )\n+    \/* six ASCII uppercase letters followed by a plus sign *\/\n+    while ( 'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+            'A' <= name[i] && name[i++] <= 'Z' &&\n+                              name[i++] == '+' )\n@@ -431,18 +439,1 @@\n-      if ( length >= 7 && name[6] == '+' )\n-      {\n-        for ( idx = 0; idx < 6; idx++ )\n-        {\n-          \/* ASCII uppercase letters *\/\n-          if ( !( 'A' <= name[idx] && name[idx] <= 'Z' ) )\n-            continue_search = 0;\n-        }\n-\n-        if ( continue_search )\n-        {\n-          for ( idx = 7; idx < length; idx++ )\n-            name[idx - 7] = name[idx];\n-          length -= 7;\n-        }\n-      }\n-      else\n-        continue_search = 0;\n+      idx = i;\n@@ -450,0 +441,3 @@\n+\n+    if ( idx )\n+      FT_MEM_MOVE( name, name + idx, ft_strlen( name + idx ) + 1 );\n@@ -459,9 +453,2 @@\n-    FT_Int32  family_name_length, style_name_length;\n-\n-\n-    family_name_length = (FT_Int32)ft_strlen( family_name );\n-    style_name_length  = (FT_Int32)ft_strlen( style_name );\n-\n-    if ( family_name_length > style_name_length )\n-    {\n-      FT_Int  idx;\n+    FT_String*        f = family_name + ft_strlen( family_name );\n+    const FT_String*  s =  style_name + ft_strlen(  style_name );\n@@ -470,6 +457,4 @@\n-      for ( idx = 1; idx <= style_name_length; idx++ )\n-      {\n-        if ( family_name[family_name_length - idx] !=\n-             style_name[style_name_length - idx] )\n-          break;\n-      }\n+    \/* compare strings moving backwards *\/\n+    while ( s > style_name )\n+      if ( f == family_name || *--s != *--f )\n+        return;\n@@ -477,18 +462,5 @@\n-      if ( idx > style_name_length )\n-      {\n-        \/* family_name ends with style_name; remove it *\/\n-        idx = family_name_length - style_name_length - 1;\n-\n-        \/* also remove special characters     *\/\n-        \/* between real family name and style *\/\n-        while ( idx > 0                     &&\n-                ( family_name[idx] == '-' ||\n-                  family_name[idx] == ' ' ||\n-                  family_name[idx] == '_' ||\n-                  family_name[idx] == '+' ) )\n-          idx--;\n-\n-        if ( idx > 0 )\n-          family_name[idx + 1] = '\\0';\n-      }\n-    }\n+    \/* terminate and remove special characters *\/\n+    do\n+      *f = '\\0';\n+    while ( f-- > family_name                                    &&\n+            ( *f == '-' || *f == ' ' || *f == '_' || *f == '+' ) );\n@@ -662,2 +634,2 @@\n-                   \" cannot open CFF & CEF fonts\\n\"\n-                   \"              \"\n+                   \" cannot open CFF & CEF fonts\\n\" ));\n+        FT_ERROR(( \"              \"\n@@ -687,1 +659,1 @@\n-        \/* which may contain NULL bytes in the middle of the data, too. *\/\n+        \/* which may contain null bytes in the middle of the data, too. *\/\n@@ -693,1 +665,1 @@\n-          FT_PtrDist  s1len = s2 - s1 - 1; \/* without the final NULL byte *\/\n+          FT_PtrDist  s1len = s2 - s1 - 1; \/* without the final null byte *\/\n@@ -722,3 +694,0 @@\n-        FT_Service_MultiMasters       mm  = (FT_Service_MultiMasters)face->mm;\n-        FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n-\n@@ -728,3 +697,1 @@\n-        if ( FT_HAS_MULTIPLE_MASTERS( cffface ) &&\n-             mm                                 &&\n-             instance_index > 0                 )\n+        if ( FT_HAS_MULTIPLE_MASTERS( cffface ) )\n@@ -732,1 +699,1 @@\n-          error = mm->set_instance( cffface, instance_index );\n+          error = FT_Set_Named_Instance( cffface, instance_index );\n@@ -735,3 +702,0 @@\n-\n-          if ( var )\n-            var->metrics_adjust( cffface );\n@@ -1031,1 +995,0 @@\n-#ifndef FT_CONFIG_OPTION_NO_GLYPH_NAMES\n@@ -1036,1 +999,0 @@\n-#endif\n@@ -1052,1 +1014,1 @@\n-        FT_UInt        nn;\n+        FT_Int         nn;\n@@ -1056,1 +1018,1 @@\n-        for ( nn = 0; nn < (FT_UInt)cffface->num_charmaps; nn++ )\n+        for ( nn = 0; nn < cffface->num_charmaps; nn++ )\n@@ -1081,1 +1043,1 @@\n-        nn = (FT_UInt)cffface->num_charmaps;\n+        nn = cffface->num_charmaps;\n@@ -1092,1 +1054,1 @@\n-        if ( !cffface->charmap && nn != (FT_UInt)cffface->num_charmaps )\n+        if ( !cffface->charmap && nn != cffface->num_charmaps )\n@@ -1162,1 +1124,1 @@\n-    cff_done_blend( face );\n+    cff_done_blend( cffface );\n@@ -1177,3 +1139,0 @@\n-#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n-    driver->hinting_engine = FT_HINTING_FREETYPE;\n-#else\n@@ -1181,1 +1140,0 @@\n-#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffobjs.c","additions":56,"deletions":98,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -65,3 +65,1 @@\n-    if ( FT_NEW_ARRAY( parser->stack, stackSize ) )\n-    {\n-      FT_FREE( parser->stack );\n+    if ( FT_QNEW_ARRAY( parser->stack, stackSize ) )\n@@ -69,1 +67,0 @@\n-    }\n@@ -79,17 +76,0 @@\n-#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n-  static void\n-  finalize_t2_strings( FT_Memory  memory,\n-                       void*      data,\n-                       void*      user )\n-  {\n-    CFF_T2_String  t2 = (CFF_T2_String)data;\n-\n-\n-    FT_UNUSED( user );\n-\n-    memory->free( memory, t2->start );\n-    memory->free( memory, data );\n-  }\n-#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n-\n-\n@@ -105,4 +85,1 @@\n-    FT_List_Finalize( &parser->t2_strings,\n-                      finalize_t2_strings,\n-                      memory,\n-                      NULL );\n+    FT_List_Finalize( &parser->t2_strings, NULL, memory, NULL );\n@@ -113,44 +90,3 @@\n-  \/* Assuming `first >= last'. *\/\n-\n-  static FT_Error\n-  cff_parser_within_limits( CFF_Parser  parser,\n-                            FT_Byte*    first,\n-                            FT_Byte*    last )\n-  {\n-#ifndef CFF_CONFIG_OPTION_OLD_ENGINE\n-\n-    \/* Fast path for regular FreeType builds with the \"new\" engine; *\/\n-    \/*   `first >= parser->start' can be assumed.                   *\/\n-\n-    FT_UNUSED( first );\n-\n-    return last < parser->limit ? FT_Err_Ok : FT_THROW( Invalid_Argument );\n-\n-#else \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n-\n-    FT_ListNode  node;\n-\n-\n-    if ( first >= parser->start &&\n-         last  <  parser->limit )\n-      return FT_Err_Ok;\n-\n-    node = parser->t2_strings.head;\n-\n-    while ( node )\n-    {\n-      CFF_T2_String  t2 = (CFF_T2_String)node->data;\n-\n-\n-      if ( first >= t2->start &&\n-           last  <  t2->limit )\n-        return FT_Err_Ok;\n-\n-      node = node->next;\n-    }\n-\n-    return FT_THROW( Invalid_Argument );\n-\n-#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n-  }\n-\n+  \/* The parser limit checks in the next two functions are supposed *\/\n+  \/* to detect the immediate crossing of the stream boundary.  They *\/\n+  \/* shall not be triggered from the distant t2_strings buffers.    *\/\n@@ -160,2 +96,2 @@\n-  cff_parse_integer( CFF_Parser  parser,\n-                     FT_Byte*    start )\n+  cff_parse_integer( FT_Byte*  start,\n+                     FT_Byte*  limit )\n@@ -170,1 +106,1 @@\n-      if ( cff_parser_within_limits( parser, p, p + 1 ) )\n+      if ( p + 2 > limit && limit >= p )\n@@ -177,1 +113,1 @@\n-      if ( cff_parser_within_limits( parser, p, p + 3 ) )\n+      if ( p + 4 > limit && limit >= p )\n@@ -191,1 +127,1 @@\n-      if ( cff_parser_within_limits( parser, p, p ) )\n+      if ( p + 1 > limit && limit >= p )\n@@ -198,1 +134,1 @@\n-      if ( cff_parser_within_limits( parser, p, p ) )\n+      if ( p + 1 > limit && limit >= p )\n@@ -247,4 +183,4 @@\n-  cff_parse_real( CFF_Parser  parser,\n-                  FT_Byte*    start,\n-                  FT_Long     power_ten,\n-                  FT_Long*    scaling )\n+  cff_parse_real( FT_Byte*  start,\n+                  FT_Byte*  limit,\n+                  FT_Long   power_ten,\n+                  FT_Long*  scaling )\n@@ -285,1 +221,1 @@\n-        if ( cff_parser_within_limits( parser, p, p ) )\n+        if ( p + 1 > limit && limit >= p )\n@@ -322,1 +258,1 @@\n-          if ( cff_parser_within_limits( parser, p, p ) )\n+          if ( p + 1 > limit && limit >= p )\n@@ -361,1 +297,1 @@\n-          if ( cff_parser_within_limits( parser, p, p ) )\n+          if ( p + 1 > limit && limit >= p )\n@@ -528,1 +464,1 @@\n-      return cff_parse_real( parser, *d, 0, NULL ) >> 16;\n+      return cff_parse_real( *d, parser->limit, 0, NULL ) >> 16;\n@@ -533,1 +469,1 @@\n-      \/* 16.16 fixed point is used internally for CFF2 blend results. *\/\n+      \/* 16.16 fixed-point is used internally for CFF2 blend results. *\/\n@@ -554,1 +490,1 @@\n-      return cff_parse_integer( parser, *d );\n+      return cff_parse_integer( *d, parser->limit );\n@@ -565,1 +501,19 @@\n-      return cff_parse_real( parser, *d, scaling, NULL );\n+      return cff_parse_real( *d, parser->limit, scaling, NULL );\n+    else if ( **d == 255 )\n+    {\n+      FT_Fixed val = (FT_Int32)( ( ( (FT_UInt32)*( d[0] + 1 ) << 24 ) |\n+                                   ( (FT_UInt32)*( d[0] + 2 ) << 16 ) |\n+                                   ( (FT_UInt32)*( d[0] + 3 ) <<  8 ) |\n+                                     (FT_UInt32)*( d[0] + 4 )         ) );\n+\n+      if ( scaling )\n+      {\n+        if ( FT_ABS( val ) > power_ten_limits[scaling] )\n+        {\n+           FT_TRACE4(( \"!!!OVERFLOW:!!!\" ));\n+           return val > 0 ? 0x7FFFFFFFL : -0x7FFFFFFFL;\n+        }\n+        val *= power_tens[scaling];\n+      }\n+      return val;\n+    }\n@@ -568,1 +522,1 @@\n-      FT_Long  val = cff_parse_integer( parser, *d );\n+      FT_Long  val = cff_parse_integer( *d, parser->limit );\n@@ -573,1 +527,1 @@\n-        if ( FT_ABS( val ) > power_ten_limits[scaling] )\n+        if ( ( FT_ABS( val ) << 16 ) > power_ten_limits[scaling] )\n@@ -603,1 +557,1 @@\n-  static FT_Fixed\n+  FT_LOCAL_DEF( FT_Fixed )\n@@ -633,1 +587,1 @@\n-      return cff_parse_real( parser, *d, 0, scaling );\n+      return cff_parse_real( *d, parser->limit, 0, scaling );\n@@ -640,1 +594,1 @@\n-      number = cff_parse_integer( parser, d[0] );\n+      number = cff_parse_integer( *d, parser->limit );\n@@ -689,1 +643,1 @@\n-      \/* We expect a well-formed font matrix, this is, the matrix elements *\/\n+      \/* We expect a well-formed font matrix, that is, the matrix elements *\/\n@@ -716,3 +670,4 @@\n-                    \" strange scaling values (minimum %ld, maximum %ld),\\n\"\n-                    \"                      \"\n-                    \" using default matrix\\n\", min_scaling, max_scaling ));\n+                    \" strange scaling values (minimum %ld, maximum %ld),\\n\",\n+                    min_scaling, max_scaling ));\n+        FT_TRACE1(( \"                      \"\n+                    \" using default matrix\\n\" ));\n@@ -760,6 +715,6 @@\n-                  (double)matrix->xx \/ *upm \/ 65536,\n-                  (double)matrix->xy \/ *upm \/ 65536,\n-                  (double)matrix->yx \/ *upm \/ 65536,\n-                  (double)matrix->yy \/ *upm \/ 65536,\n-                  (double)offset->x  \/ *upm \/ 65536,\n-                  (double)offset->y  \/ *upm \/ 65536 ));\n+                  (double)matrix->xx \/ (double)*upm \/ 65536,\n+                  (double)matrix->xy \/ (double)*upm \/ 65536,\n+                  (double)matrix->yx \/ (double)*upm \/ 65536,\n+                  (double)matrix->yy \/ (double)*upm \/ 65536,\n+                  (double)offset->x  \/ (double)*upm \/ 65536,\n+                  (double)offset->y  \/ (double)*upm \/ 65536 ));\n@@ -1079,0 +1034,4 @@\n+#define CFF_FIELD_DELTA( code, name, max, id )                        \\\n+          CFF_FIELD_DELTA_KIND( code, name, max, id, cff_kind_delta )\n+#define CFF_FIELD_DELTA_FIXED( code, name, max, id )                        \\\n+          CFF_FIELD_DELTA_KIND( code, name, max, id, cff_kind_delta_fixed )\n@@ -1082,1 +1041,1 @@\n-#undef  CFF_FIELD_DELTA\n+#undef  CFF_FIELD_DELTA_KIND\n@@ -1112,1 +1071,1 @@\n-            0, 0, 0                       \\\n+            NULL, 0, 0                    \\\n@@ -1115,9 +1074,9 @@\n-#define CFF_FIELD_DELTA( code, name, max, id ) \\\n-          {                                    \\\n-            cff_kind_delta,                    \\\n-            code | CFFCODE,                    \\\n-            FT_FIELD_OFFSET( name ),           \\\n-            FT_FIELD_SIZE_DELTA( name ),       \\\n-            0,                                 \\\n-            max,                               \\\n-            FT_FIELD_OFFSET( num_ ## name )    \\\n+#define CFF_FIELD_DELTA_KIND( code, name, max, id, kind ) \\\n+          {                                               \\\n+            kind,                                         \\\n+            code | CFFCODE,                               \\\n+            FT_FIELD_OFFSET( name ),                      \\\n+            FT_FIELD_SIZE_DELTA( name ),                  \\\n+            NULL,                                         \\\n+            max,                                          \\\n+            FT_FIELD_OFFSET( num_ ## name )               \\\n@@ -1131,1 +1090,1 @@\n-    { 0, 0, 0, 0, 0, 0, 0 }\n+    { 0, 0, 0, 0, NULL, 0, 0 }\n@@ -1165,1 +1124,1 @@\n-            0, 0, 0,                      \\\n+            NULL, 0, 0,                   \\\n@@ -1169,10 +1128,10 @@\n-#define CFF_FIELD_DELTA( code, name, max, id ) \\\n-          {                                    \\\n-            cff_kind_delta,                    \\\n-            code | CFFCODE,                    \\\n-            FT_FIELD_OFFSET( name ),           \\\n-            FT_FIELD_SIZE_DELTA( name ),       \\\n-            0,                                 \\\n-            max,                               \\\n-            FT_FIELD_OFFSET( num_ ## name ),   \\\n-            id                                 \\\n+#define CFF_FIELD_DELTA_KIND( code, name, max, id, kind ) \\\n+          {                                               \\\n+            kind,                                         \\\n+            code | CFFCODE,                               \\\n+            FT_FIELD_OFFSET( name ),                      \\\n+            FT_FIELD_SIZE_DELTA( name ),                  \\\n+            NULL,                                         \\\n+            max,                                          \\\n+            FT_FIELD_OFFSET( num_ ## name ),              \\\n+            id                                            \\\n@@ -1186,1 +1145,1 @@\n-    { 0, 0, 0, 0, 0, 0, 0, 0 }\n+    { 0, 0, 0, 0, NULL, 0, 0, NULL }\n@@ -1266,5 +1225,2 @@\n-        FT_Fixed*      stack;\n-        FT_ListNode    node;\n-        CFF_T2_String  t2;\n-        FT_Fixed       t2_size;\n-        FT_Byte*       q;\n+        FT_Fixed*  stack;\n+        FT_Byte*   q = NULL;\n@@ -1311,0 +1267,4 @@\n+        \/* The maximum required size is 5 bytes per stack element.     *\/\n+        if ( FT_QALLOC( q, (FT_Long)( 2 * sizeof ( FT_ListNode ) ) +\n+                           5 * ( decoder.top - decoder.stack ) ) )\n+          goto Exit;\n@@ -1312,25 +1272,1 @@\n-        node = (FT_ListNode)memory->alloc( memory,\n-                                           sizeof ( FT_ListNodeRec ) );\n-        if ( !node )\n-          goto Out_Of_Memory_Error;\n-\n-        FT_List_Add( &parser->t2_strings, node );\n-\n-        t2 = (CFF_T2_String)memory->alloc( memory,\n-                                           sizeof ( CFF_T2_StringRec ) );\n-        if ( !t2 )\n-          goto Out_Of_Memory_Error;\n-\n-        node->data = t2;\n-\n-        \/* `5' is the conservative upper bound of required bytes per stack *\/\n-        \/* element.                                                        *\/\n-\n-        t2_size = 5 * ( decoder.top - decoder.stack );\n-\n-        q = (FT_Byte*)memory->alloc( memory, t2_size );\n-        if ( !q )\n-          goto Out_Of_Memory_Error;\n-\n-        t2->start = q;\n-        t2->limit = q + t2_size;\n+        FT_List_Add( &parser->t2_strings, (FT_ListNode)q );\n@@ -1338,1 +1274,1 @@\n-        stack = decoder.stack;\n+        q += 2 * sizeof ( FT_ListNode );\n@@ -1340,1 +1276,1 @@\n-        while ( stack < decoder.top )\n+        for ( stack = decoder.stack; stack < decoder.top; stack++ )\n@@ -1342,2 +1278,1 @@\n-          FT_ULong  num;\n-          FT_Bool   neg;\n+          FT_Long  num = *stack;\n@@ -1351,11 +1286,0 @@\n-          if ( *stack < 0 )\n-          {\n-            num = (FT_ULong)NEG_LONG( *stack );\n-            neg = 1;\n-          }\n-          else\n-          {\n-            num = (FT_ULong)*stack;\n-            neg = 0;\n-          }\n-\n@@ -1364,3 +1288,0 @@\n-            if ( neg )\n-              num = (FT_ULong)-num;\n-\n@@ -1368,4 +1289,4 @@\n-            *q++ = ( num & 0xFF000000U ) >> 24;\n-            *q++ = ( num & 0x00FF0000U ) >> 16;\n-            *q++ = ( num & 0x0000FF00U ) >>  8;\n-            *q++ =   num & 0x000000FFU;\n+            *q++ = (FT_Byte)( ( num >> 24 ) & 0xFF );\n+            *q++ = (FT_Byte)( ( num >> 16 ) & 0xFF );\n+            *q++ = (FT_Byte)( ( num >>  8 ) & 0xFF );\n+            *q++ = (FT_Byte)( ( num       ) & 0xFF );\n@@ -1377,1 +1298,3 @@\n-            if ( neg )\n+            if ( -107 <= num && num <= 107 )\n+              *q++ = (FT_Byte)( num + 139 );\n+            else if ( 108 <= num && num <= 1131 )\n@@ -1379,15 +1302,7 @@\n-              if ( num <= 107 )\n-                *q++ = (FT_Byte)( 139 - num );\n-              else if ( num <= 1131 )\n-              {\n-                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );\n-                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );\n-              }\n-              else\n-              {\n-                num = (FT_ULong)-num;\n-\n-                *q++ = 28;\n-                *q++ = (FT_Byte)( num >> 8 );\n-                *q++ = (FT_Byte)( num & 0xFF );\n-              }\n+              *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );\n+              *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );\n+            }\n+            else if ( -1131 <= num && num <= -108 )\n+            {\n+              *q++ = (FT_Byte)( ( ( -num - 108 ) >> 8 ) + 251 );\n+              *q++ = (FT_Byte)( ( -num - 108) & 0xFF );\n@@ -1397,13 +1312,3 @@\n-              if ( num <= 107 )\n-                *q++ = (FT_Byte)( num + 139 );\n-              else if ( num <= 1131 )\n-              {\n-                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );\n-                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );\n-              }\n-              else\n-              {\n-                *q++ = 28;\n-                *q++ = (FT_Byte)( num >> 8 );\n-                *q++ = (FT_Byte)( num & 0xFF );\n-              }\n+              *q++ = 28;\n+              *q++ = (FT_Byte)( num >> 8 );\n+              *q++ = (FT_Byte)( num & 0xFF );\n@@ -1412,2 +1317,0 @@\n-\n-          stack++;\n@@ -1460,1 +1363,2 @@\n-            if ( field->kind != cff_kind_delta && num_args < 1 )\n+            if ( field->kind != cff_kind_delta                       &&\n+                 field->kind != cff_kind_delta_fixed && num_args < 1 )\n@@ -1518,0 +1422,1 @@\n+                break;\n@@ -1574,0 +1479,32 @@\n+            case cff_kind_delta_fixed:\n+              {\n+                FT_Byte*   qcount = (FT_Byte*)parser->object +\n+                                      field->count_offset;\n+\n+                FT_Byte**  data = parser->stack;\n+\n+\n+                if ( num_args > field->array_max )\n+                  num_args = field->array_max;\n+\n+                FT_TRACE4(( \" [\" ));\n+\n+                \/* store count *\/\n+                *qcount = (FT_Byte)num_args;\n+\n+                val = 0;\n+                while ( num_args > 0 )\n+                {\n+                  val = ADD_LONG( val, cff_parse_fixed( parser, data++ ) );\n+                  *(FT_Long*)q = val;\n+\n+                  FT_TRACE4(( \" %f\\n\", (double)val \/ 65536 ));\n+\n+                  q += field->size;\n+                  num_args--;\n+                }\n+\n+                FT_TRACE4(( \"]\\n\" ));\n+              }\n+              break;\n+\n@@ -1599,6 +1536,0 @@\n-#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n-  Out_Of_Memory_Error:\n-    error = FT_THROW( Out_Of_Memory );\n-    goto Exit;\n-#endif\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffparse.c","additions":147,"deletions":216,"binary":false,"changes":363,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -79,0 +79,4 @@\n+  FT_LOCAL( FT_Fixed )\n+  cff_parse_fixed( CFF_Parser  parser,\n+                   FT_Byte**   d );\n+\n@@ -106,0 +110,1 @@\n+    cff_kind_delta_fixed,\n@@ -136,9 +141,0 @@\n-#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n-  typedef struct  CFF_T2_String_\n-  {\n-    FT_Byte*  start;\n-    FT_Byte*  limit;\n-\n-  } CFF_T2_StringRec, *CFF_T2_String;\n-#endif \/* CFF_CONFIG_OPTION_OLD_ENGINE *\/\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cffparse.h","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -83,20 +83,20 @@\n-  CFF_FIELD_DELTA     ( 6,     blue_values, 14,        \"BlueValues\" )\n-  CFF_FIELD_DELTA     ( 7,     other_blues, 10,        \"OtherBlues\" )\n-  CFF_FIELD_DELTA     ( 8,     family_blues, 14,       \"FamilyBlues\" )\n-  CFF_FIELD_DELTA     ( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n-  CFF_FIELD_FIXED_1000( 0x109, blue_scale,             \"BlueScale\" )\n-  CFF_FIELD_NUM       ( 0x10A, blue_shift,             \"BlueShift\" )\n-  CFF_FIELD_NUM       ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n-  CFF_FIELD_NUM       ( 10,    standard_width,         \"StdHW\" )\n-  CFF_FIELD_NUM       ( 11,    standard_height,        \"StdVW\" )\n-  CFF_FIELD_DELTA     ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n-  CFF_FIELD_DELTA     ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n-  CFF_FIELD_BOOL      ( 0x10E, force_bold,             \"ForceBold\" )\n-  CFF_FIELD_FIXED     ( 0x10F, force_bold_threshold,   \"ForceBoldThreshold\" )\n-  CFF_FIELD_NUM       ( 0x110, lenIV,                  \"lenIV\" )\n-  CFF_FIELD_NUM       ( 0x111, language_group,         \"LanguageGroup\" )\n-  CFF_FIELD_FIXED     ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n-  CFF_FIELD_NUM       ( 0x113, initial_random_seed,    \"initialRandomSeed\" )\n-  CFF_FIELD_NUM       ( 19,    local_subrs_offset,     \"Subrs\" )\n-  CFF_FIELD_NUM       ( 20,    default_width,          \"defaultWidthX\" )\n-  CFF_FIELD_NUM       ( 21,    nominal_width,          \"nominalWidthX\" )\n+  CFF_FIELD_DELTA_FIXED( 6,     blue_values, 14,        \"BlueValues\" )\n+  CFF_FIELD_DELTA_FIXED( 7,     other_blues, 10,        \"OtherBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 8,     family_blues, 14,       \"FamilyBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n+  CFF_FIELD_FIXED_1000 ( 0x109, blue_scale,             \"BlueScale\" )\n+  CFF_FIELD_NUM        ( 0x10A, blue_shift,             \"BlueShift\" )\n+  CFF_FIELD_NUM        ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n+  CFF_FIELD_NUM        ( 10,    standard_width,         \"StdHW\" )\n+  CFF_FIELD_NUM        ( 11,    standard_height,        \"StdVW\" )\n+  CFF_FIELD_DELTA      ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n+  CFF_FIELD_DELTA      ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n+  CFF_FIELD_BOOL       ( 0x10E, force_bold,             \"ForceBold\" )\n+  CFF_FIELD_FIXED      ( 0x10F, force_bold_threshold,   \"ForceBoldThreshold\" )\n+  CFF_FIELD_NUM        ( 0x110, lenIV,                  \"lenIV\" )\n+  CFF_FIELD_NUM        ( 0x111, language_group,         \"LanguageGroup\" )\n+  CFF_FIELD_FIXED      ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n+  CFF_FIELD_NUM        ( 0x113, initial_random_seed,    \"initialRandomSeed\" )\n+  CFF_FIELD_NUM        ( 19,    local_subrs_offset,     \"Subrs\" )\n+  CFF_FIELD_NUM        ( 20,    default_width,          \"defaultWidthX\" )\n+  CFF_FIELD_NUM        ( 21,    nominal_width,          \"nominalWidthX\" )\n@@ -132,16 +132,16 @@\n-  CFF_FIELD_DELTA     ( 6,     blue_values, 14,        \"BlueValues\" )\n-  CFF_FIELD_DELTA     ( 7,     other_blues, 10,        \"OtherBlues\" )\n-  CFF_FIELD_DELTA     ( 8,     family_blues, 14,       \"FamilyBlues\" )\n-  CFF_FIELD_DELTA     ( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n-  CFF_FIELD_FIXED_1000( 0x109, blue_scale,             \"BlueScale\" )\n-  CFF_FIELD_NUM       ( 0x10A, blue_shift,             \"BlueShift\" )\n-  CFF_FIELD_NUM       ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n-  CFF_FIELD_NUM       ( 10,    standard_width,         \"StdHW\" )\n-  CFF_FIELD_NUM       ( 11,    standard_height,        \"StdVW\" )\n-  CFF_FIELD_DELTA     ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n-  CFF_FIELD_DELTA     ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n-  CFF_FIELD_NUM       ( 0x111, language_group,         \"LanguageGroup\" )\n-  CFF_FIELD_FIXED     ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n-  CFF_FIELD_CALLBACK  ( 22,    vsindex,                \"vsindex\" )\n-  CFF_FIELD_BLEND     ( 23,                            \"blend\" )\n-  CFF_FIELD_NUM       ( 19,    local_subrs_offset,     \"Subrs\" )\n+  CFF_FIELD_DELTA_FIXED( 6,     blue_values, 14,        \"BlueValues\" )\n+  CFF_FIELD_DELTA_FIXED( 7,     other_blues, 10,        \"OtherBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 8,     family_blues, 14,       \"FamilyBlues\" )\n+  CFF_FIELD_DELTA_FIXED( 9,     family_other_blues, 10, \"FamilyOtherBlues\" )\n+  CFF_FIELD_FIXED_1000 ( 0x109, blue_scale,             \"BlueScale\" )\n+  CFF_FIELD_NUM        ( 0x10A, blue_shift,             \"BlueShift\" )\n+  CFF_FIELD_NUM        ( 0x10B, blue_fuzz,              \"BlueFuzz\" )\n+  CFF_FIELD_NUM        ( 10,    standard_width,         \"StdHW\" )\n+  CFF_FIELD_NUM        ( 11,    standard_height,        \"StdVW\" )\n+  CFF_FIELD_DELTA      ( 0x10C, snap_widths, 13,        \"StemSnapH\" )\n+  CFF_FIELD_DELTA      ( 0x10D, snap_heights, 13,       \"StemSnapV\" )\n+  CFF_FIELD_NUM        ( 0x111, language_group,         \"LanguageGroup\" )\n+  CFF_FIELD_FIXED      ( 0x112, expansion_factor,       \"ExpansionFactor\" )\n+  CFF_FIELD_CALLBACK   ( 22,    vsindex,                \"vsindex\" )\n+  CFF_FIELD_BLEND      ( 23,                            \"blend\" )\n+  CFF_FIELD_NUM        ( 19,    local_subrs_offset,     \"Subrs\" )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cff\/cfftoken.h","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/ciderrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -43,0 +43,111 @@\n+  \/*\n+   * A helper function to compute FD number (`fd_select`), the offset to the\n+   * head of the glyph data (`off1`), and the offset to the and of the glyph\n+   * data (`off2`).\n+   *\n+   * The number how many times `cid_get_offset` is invoked can be controlled\n+   * by the number of non-NULL arguments.  If `fd_select` is non-NULL but\n+   * `off1` and `off2` are NULL, `cid_get_offset` is invoked only for\n+   * `fd_select`; `off1` and `off2` are not validated.\n+   *\n+   *\/\n+  FT_LOCAL_DEF( FT_Error )\n+  cid_compute_fd_and_offsets( CID_Face   face,\n+                              FT_UInt    glyph_index,\n+                              FT_ULong*  fd_select_p,\n+                              FT_ULong*  off1_p,\n+                              FT_ULong*  off2_p )\n+  {\n+    FT_Error  error = FT_Err_Ok;\n+\n+    CID_FaceInfo  cid       = &face->cid;\n+    FT_Stream     stream    =  face->cid_stream;\n+    FT_UInt       entry_len = cid->fd_bytes + cid->gd_bytes;\n+\n+    FT_Byte*  p;\n+    FT_Bool   need_frame_exit = 0;\n+    FT_ULong  fd_select, off1, off2;\n+\n+\n+    \/* For ordinary fonts, read the CID font dictionary index *\/\n+    \/* and charstring offset from the CIDMap.                 *\/\n+\n+    if ( FT_STREAM_SEEK( cid->data_offset + cid->cidmap_offset +\n+                         glyph_index * entry_len )               ||\n+         FT_FRAME_ENTER( 2 * entry_len )                         )\n+      goto Exit;\n+\n+    need_frame_exit = 1;\n+\n+    p         = (FT_Byte*)stream->cursor;\n+    fd_select = cid_get_offset( &p, cid->fd_bytes );\n+    off1      = cid_get_offset( &p, cid->gd_bytes );\n+\n+    p    += cid->fd_bytes;\n+    off2  = cid_get_offset( &p, cid->gd_bytes );\n+\n+    if ( fd_select_p )\n+      *fd_select_p = fd_select;\n+    if ( off1_p )\n+      *off1_p = off1;\n+    if ( off2_p )\n+      *off2_p = off2;\n+\n+    if ( fd_select >= cid->num_dicts )\n+    {\n+      \/*\n+       * fd_select == 0xFF is often used to indicate that the CID\n+       * has no charstring to be rendered, similar to GID = 0xFFFF\n+       * in TrueType fonts.\n+       *\/\n+      if ( ( cid->fd_bytes == 1 && fd_select == 0xFFU   ) ||\n+           ( cid->fd_bytes == 2 && fd_select == 0xFFFFU ) )\n+      {\n+        FT_TRACE1(( \"cid_load_glyph: fail for glyph index %d:\\n\",\n+                    glyph_index ));\n+        FT_TRACE1(( \"                FD number %ld is the maximum\\n\",\n+                    fd_select ));\n+        FT_TRACE1(( \"                integer fitting into %d byte%s\\n\",\n+                    cid->fd_bytes, cid->fd_bytes == 1 ? \"\" : \"s\" ));\n+      }\n+      else\n+      {\n+        FT_TRACE0(( \"cid_load_glyph: fail for glyph index %d:\\n\",\n+                    glyph_index ));\n+        FT_TRACE0(( \"                FD number %ld is larger\\n\",\n+                    fd_select ));\n+        FT_TRACE0(( \"                than number of dictionaries (%d)\\n\",\n+                    cid->num_dicts ));\n+      }\n+\n+      error = FT_THROW( Invalid_Offset );\n+      goto Exit;\n+    }\n+    else if ( off2 > stream->size )\n+    {\n+      FT_TRACE0(( \"cid_load_glyph: fail for glyph index %d:\\n\",\n+                  glyph_index ));\n+      FT_TRACE0(( \"               end of the glyph data\\n\" ));\n+      FT_TRACE0(( \"               is beyond the data stream\\n\" ));\n+\n+      error = FT_THROW( Invalid_Offset );\n+      goto Exit;\n+    }\n+    else if ( off1 > off2 )\n+    {\n+      FT_TRACE0(( \"cid_load_glyph: fail for glyph index %d:\\n\",\n+                  glyph_index ));\n+      FT_TRACE0(( \"                the end position of glyph data\\n\" ));\n+      FT_TRACE0(( \"                is set before the start position\\n\" ));\n+\n+      error = FT_THROW( Invalid_Offset );\n+    }\n+\n+    Exit:\n+      if ( need_frame_exit )\n+        FT_FRAME_EXIT();\n+\n+    return error;\n+  }\n+\n+\n@@ -66,1 +177,1 @@\n-    FT_TRACE1(( \"cid_load_glyph: glyph index %d\\n\", glyph_index ));\n+    FT_TRACE1(( \"cid_load_glyph: glyph index %u\\n\", glyph_index ));\n@@ -79,1 +190,1 @@\n-      if ( error )\n+      if ( error || glyph_data.length < cid->fd_bytes )\n@@ -83,1 +194,1 @@\n-      fd_select = cid_get_offset( &p, (FT_Byte)cid->fd_bytes );\n+      fd_select = cid_get_offset( &p, cid->fd_bytes );\n@@ -85,6 +196,4 @@\n-      if ( glyph_data.length != 0 )\n-      {\n-        glyph_length = (FT_ULong)( glyph_data.length - cid->fd_bytes );\n-        (void)FT_ALLOC( charstring, glyph_length );\n-        if ( !error )\n-          ft_memcpy( charstring, glyph_data.pointer + cid->fd_bytes,\n+      glyph_length = glyph_data.length - cid->fd_bytes;\n+\n+      if ( !FT_QALLOC( charstring, glyph_length ) )\n+        FT_MEM_COPY( charstring, glyph_data.pointer + cid->fd_bytes,\n@@ -92,1 +201,0 @@\n-      }\n@@ -103,3 +211,0 @@\n-\n-    \/* For ordinary fonts read the CID font dictionary index *\/\n-    \/* and charstring offset from the CIDMap.                *\/\n@@ -107,1 +212,0 @@\n-      FT_UInt   entry_len = (FT_UInt)( cid->fd_bytes + cid->gd_bytes );\n@@ -111,18 +215,3 @@\n-      if ( FT_STREAM_SEEK( cid->data_offset + cid->cidmap_offset +\n-                           glyph_index * entry_len )               ||\n-           FT_FRAME_ENTER( 2 * entry_len )                         )\n-        goto Exit;\n-\n-      p         = (FT_Byte*)stream->cursor;\n-      fd_select = cid_get_offset( &p, (FT_Byte)cid->fd_bytes );\n-      off1      = cid_get_offset( &p, (FT_Byte)cid->gd_bytes );\n-      p        += cid->fd_bytes;\n-      off2      = cid_get_offset( &p, (FT_Byte)cid->gd_bytes );\n-      FT_FRAME_EXIT();\n-\n-      if ( fd_select >= (FT_ULong)cid->num_dicts ||\n-           off2 > stream->size                   ||\n-           off1 > off2                           )\n-      {\n-        FT_TRACE0(( \"cid_load_glyph: invalid glyph stream offsets\\n\" ));\n-        error = FT_THROW( Invalid_Offset );\n+      error = cid_compute_fd_and_offsets( face, glyph_index,\n+                                          &fd_select, &off1, &off2 );\n+      if ( error )\n@@ -130,1 +219,0 @@\n-      }\n@@ -133,5 +221,4 @@\n-      if ( glyph_length == 0 )\n-        goto Exit;\n-      if ( FT_ALLOC( charstring, glyph_length ) )\n-        goto Exit;\n-      if ( FT_STREAM_READ_AT( cid->data_offset + off1,\n+\n+      if ( glyph_length == 0                             ||\n+           FT_QALLOC( charstring, glyph_length )         ||\n+           FT_STREAM_READ_AT( cid->data_offset + off1,\n@@ -168,1 +255,3 @@\n-        FT_TRACE0(( \"cid_load_glyph: invalid glyph stream offsets\\n\" ));\n+        FT_TRACE0(( \"cid_load_glyph: fail for glyph_index=%d, \"\n+                    \"offset to the charstring is beyond glyph length\\n\",\n+                    glyph_index ));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidgload.c","additions":129,"deletions":40,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -45,0 +45,8 @@\n+  FT_LOCAL( FT_Error )\n+  cid_compute_fd_and_offsets( CID_Face   face,\n+                              FT_UInt    glyph_index,\n+                              FT_ULong*  fd_select_p,\n+                              FT_ULong*  off1_p,\n+                              FT_ULong*  off2_p );\n+\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidgload.h","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -44,1 +44,1 @@\n-                  FT_Byte    offsize )\n+                  FT_UInt    offsize )\n@@ -116,1 +116,1 @@\n-        if ( parser->num_dict < 0 || parser->num_dict >= cid->num_dicts )\n+        if ( parser->num_dict >= cid->num_dicts )\n@@ -158,2 +158,2 @@\n-  cid_parse_font_matrix( CID_Face     face,\n-                         CID_Parser*  parser )\n+  cid_parse_font_matrix( FT_Face  face,     \/* CID_Face *\/\n+                         void*    parser_ )\n@@ -161,0 +161,2 @@\n+    CID_Face      cidface = (CID_Face)face;\n+    CID_Parser*   parser  = (CID_Parser*)parser_;\n@@ -162,1 +164,0 @@\n-    FT_Face       root = (FT_Face)&face->root;\n@@ -167,1 +168,1 @@\n-    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n+    if ( parser->num_dict < cidface->cid.num_dicts )\n@@ -174,1 +175,1 @@\n-      dict   = face->cid.font_dicts + parser->num_dict;\n+      dict   = cidface->cid.font_dicts + parser->num_dict;\n@@ -207,1 +208,1 @@\n-        root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n+        face->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n@@ -240,2 +241,2 @@\n-  parse_fd_array( CID_Face     face,\n-                  CID_Parser*  parser )\n+  parse_fd_array( FT_Face  face,     \/* CID_Face *\/\n+                  void*    parser_ )\n@@ -243,5 +244,7 @@\n-    CID_FaceInfo  cid    = &face->cid;\n-    FT_Memory     memory = face->root.memory;\n-    FT_Stream     stream = parser->stream;\n-    FT_Error      error  = FT_Err_Ok;\n-    FT_Long       num_dicts;\n+    CID_Face      cidface = (CID_Face)face;\n+    CID_Parser*   parser  = (CID_Parser*)parser_;\n+    CID_FaceInfo  cid     = &cidface->cid;\n+    FT_Memory     memory  = FT_FACE_MEMORY( face );\n+    FT_Stream     stream  = parser->stream;\n+    FT_Error      error   = FT_Err_Ok;\n+    FT_Long       num_dicts, max_dicts;\n@@ -251,1 +254,1 @@\n-    if ( num_dicts < 0 )\n+    if ( num_dicts < 0 || num_dicts > FT_INT_MAX )\n@@ -275,1 +278,2 @@\n-    if ( (FT_ULong)num_dicts > stream->size \/ 100 )\n+    max_dicts = (FT_Long)( stream->size \/ 100 );\n+    if ( num_dicts > max_dicts )\n@@ -279,3 +283,2 @@\n-                  num_dicts,\n-                  stream->size \/ 100 ));\n-      num_dicts = (FT_Long)( stream->size \/ 100 );\n+                  num_dicts, max_dicts ));\n+      num_dicts = max_dicts;\n@@ -286,1 +289,1 @@\n-      FT_Int  n;\n+      FT_UInt  n;\n@@ -316,1 +319,1 @@\n-  \/* changed).  We simply copy the value.                         *\/\n+  \/* be thus changed).  We simply copy the value.                 *\/\n@@ -319,2 +322,2 @@\n-  parse_expansion_factor( CID_Face     face,\n-                          CID_Parser*  parser )\n+  parse_expansion_factor( FT_Face  face,    \/* CID_Face *\/\n+                          void*    parser_ )\n@@ -322,0 +325,2 @@\n+    CID_Face      cidface = (CID_Face)face;\n+    CID_Parser*   parser  = (CID_Parser*)parser_;\n@@ -325,1 +330,1 @@\n-    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n+    if ( parser->num_dict < cidface->cid.num_dicts )\n@@ -327,1 +332,1 @@\n-      dict = face->cid.font_dicts + parser->num_dict;\n+      dict = cidface->cid.font_dicts + parser->num_dict;\n@@ -344,2 +349,2 @@\n-  parse_font_name( CID_Face     face,\n-                   CID_Parser*  parser )\n+  parse_font_name( FT_Face  face,     \/* CID_Face *\/\n+                   void*    parser_ )\n@@ -348,1 +353,5 @@\n-    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n+    CID_Face      cidface = (CID_Face)face;\n+    CID_Parser*   parser  = (CID_Parser*)parser_;\n+\n+\n+    if ( parser->num_dict < cidface->cid.num_dicts )\n@@ -364,1 +373,1 @@\n-    FT_UNUSED( parser );\n+    FT_UNUSED( parser_ );\n@@ -382,1 +391,1 @@\n-    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }\n+    T1_FIELD_ZERO\n@@ -430,1 +439,1 @@\n-              FT_TRACE4(( \" FontDict %d\", parser->num_dict ));\n+              FT_TRACE4(( \" FontDict %u\", parser->num_dict ));\n@@ -463,1 +472,1 @@\n-            for (;;)\n+            while ( keyword->len )\n@@ -465,1 +474,1 @@\n-              FT_Byte*  name;\n+              FT_Byte*  name = (FT_Byte*)keyword->ident;\n@@ -468,6 +477,2 @@\n-              name = (FT_Byte*)keyword->ident;\n-              if ( !name )\n-                break;\n-\n-              if ( cur[0] == name[0]                     &&\n-                   len == ft_strlen( (const char*)name ) )\n+              if ( keyword->len == len              &&\n+                   ft_memcmp( cur, name, len ) == 0 )\n@@ -475,17 +480,7 @@\n-                FT_UInt  n;\n-\n-\n-                for ( n = 1; n < len; n++ )\n-                  if ( cur[n] != name[n] )\n-                    break;\n-\n-                if ( n >= len )\n-                {\n-                  \/* we found it - run the parsing callback *\/\n-                  parser->root.error = cid_load_keyword( face,\n-                                                         loader,\n-                                                         keyword );\n-                  if ( parser->root.error )\n-                    return parser->root.error;\n-                  break;\n-                }\n+                \/* we found it - run the parsing callback *\/\n+                parser->root.error = cid_load_keyword( face,\n+                                                       loader,\n+                                                       keyword );\n+                if ( parser->root.error )\n+                  return parser->root.error;\n+                break;\n@@ -493,0 +488,1 @@\n+\n@@ -520,1 +516,1 @@\n-    FT_Int         n;\n+    FT_UInt        n;\n@@ -555,1 +551,1 @@\n-        if ( FT_RENEW_ARRAY( offsets, max_offsets, new_max ) )\n+        if ( FT_QRENEW_ARRAY( offsets, max_offsets, new_max ) )\n@@ -562,2 +558,2 @@\n-      if ( FT_STREAM_SEEK( cid->data_offset + dict->subrmap_offset )     ||\n-           FT_FRAME_ENTER( ( num_subrs + 1 ) * (FT_UInt)dict->sd_bytes ) )\n+      if ( FT_STREAM_SEEK( cid->data_offset + dict->subrmap_offset ) ||\n+           FT_FRAME_ENTER( ( num_subrs + 1 ) * dict->sd_bytes )      )\n@@ -568,1 +564,1 @@\n-        offsets[count] = cid_get_offset( &p, (FT_Byte)dict->sd_bytes );\n+        offsets[count] = cid_get_offset( &p, dict->sd_bytes );\n@@ -592,2 +588,2 @@\n-      if ( FT_NEW_ARRAY( subr->code, num_subrs + 1 ) ||\n-           FT_ALLOC( subr->code[0], data_len )       )\n+      if ( FT_QNEW_ARRAY( subr->code, num_subrs + 1 ) ||\n+           FT_QALLOC( subr->code[0], data_len )       )\n@@ -597,1 +593,1 @@\n-           FT_STREAM_READ( subr->code[0], data_len )  )\n+           FT_STREAM_READ( subr->code[0], data_len )       )\n@@ -668,4 +664,5 @@\n-  cid_hex_to_binary( FT_Byte*  data,\n-                     FT_ULong  data_len,\n-                     FT_ULong  offset,\n-                     CID_Face  face )\n+  cid_hex_to_binary( FT_Byte*   data,\n+                     FT_ULong   data_len,\n+                     FT_ULong   offset,\n+                     CID_Face   face,\n+                     FT_ULong*  data_written )\n@@ -678,1 +675,1 @@\n-    FT_Byte   *d, *dlimit;\n+    FT_Byte   *d = data, *dlimit;\n@@ -687,1 +684,0 @@\n-    d      = data;\n@@ -761,0 +757,1 @@\n+    *data_written = (FT_ULong)( d - data );\n@@ -773,1 +770,1 @@\n-    FT_Int       n;\n+    FT_UInt      n;\n@@ -778,1 +775,0 @@\n-    FT_ULong  entry_len;\n@@ -806,2 +802,2 @@\n-        FT_TRACE0(( \"cid_face_open: adjusting length of binary data\\n\"\n-                    \"               (from %ld to %ld bytes)\\n\",\n+        FT_TRACE0(( \"cid_face_open: adjusting length of binary data\\n\" ));\n+        FT_TRACE0(( \"               (from %lu to %lu bytes)\\n\",\n@@ -815,1 +811,1 @@\n-      if ( FT_ALLOC( face->binary_data, parser->binary_length )    ||\n+      if ( FT_QALLOC( face->binary_data, parser->binary_length )   ||\n@@ -819,1 +815,2 @@\n-                                            face ) )               )\n+                                            face,\n+                                            &binary_length ) )     )\n@@ -823,1 +820,1 @@\n-                            face->binary_data, parser->binary_length );\n+                            face->binary_data, binary_length );\n@@ -834,1 +831,1 @@\n-    if ( cid->fd_bytes < 0 || cid->gd_bytes < 1 )\n+    if ( cid->gd_bytes == 0 )\n@@ -837,1 +834,1 @@\n-                 \" Invalid `FDBytes' or `GDBytes' value\\n\" ));\n+                 \" Invalid `GDBytes' value\\n\" ));\n@@ -846,2 +843,2 @@\n-                 \" Values of `FDBytes' or `GDBytes' larger than 4\\n\"\n-                 \"               \"\n+                 \" Values of `FDBytes' or `GDBytes' larger than 4\\n\" ));\n+      FT_ERROR(( \"               \"\n@@ -854,1 +851,18 @@\n-    entry_len     = (FT_ULong)( cid->fd_bytes + cid->gd_bytes );\n+\n+    if ( cid->cidmap_offset > binary_length )\n+    {\n+      FT_ERROR(( \"cid_face_open: Invalid `CIDMapOffset' value\\n\" ));\n+      error = FT_THROW( Invalid_File_Format );\n+      goto Exit;\n+    }\n+\n+    \/* the initial pre-check prevents the multiplication overflow *\/\n+    if ( cid->cid_count > FT_ULONG_MAX \/ 8                    ||\n+         cid->cid_count * ( cid->fd_bytes + cid->gd_bytes ) >\n+           binary_length - cid->cidmap_offset                 )\n+    {\n+      FT_ERROR(( \"cid_face_open: Invalid `CIDCount' value\\n\" ));\n+      error = FT_THROW( Invalid_File_Format );\n+      goto Exit;\n+    }\n+\n@@ -880,2 +894,1 @@\n-      if ( dict->sd_bytes < 0                        ||\n-           ( dict->num_subrs && dict->sd_bytes < 1 ) )\n+      if ( dict->num_subrs && dict->sd_bytes == 0 )\n@@ -904,5 +917,4 @@\n-      \/* `num_subrs' is scanned as a signed integer *\/\n-      if ( (FT_Int)dict->num_subrs < 0                                     ||\n-           ( dict->sd_bytes                                              &&\n-             dict->num_subrs > ( binary_length - dict->subrmap_offset ) \/\n-                                 (FT_UInt)dict->sd_bytes                 ) )\n+      \/* the initial pre-check prevents the multiplication overflow *\/\n+      if ( dict->num_subrs > FT_UINT_MAX \/ 4      ||\n+           dict->num_subrs * dict->sd_bytes >\n+             binary_length - dict->subrmap_offset )\n@@ -916,16 +928,0 @@\n-    if ( cid->cidmap_offset > binary_length )\n-    {\n-      FT_ERROR(( \"cid_face_open: Invalid `CIDMapOffset' value\\n\" ));\n-      error = FT_THROW( Invalid_File_Format );\n-      goto Exit;\n-    }\n-\n-    if ( entry_len                                            &&\n-         cid->cid_count >\n-           ( binary_length - cid->cidmap_offset ) \/ entry_len )\n-    {\n-      FT_ERROR(( \"cid_face_open: Invalid `CIDCount' value\\n\" ));\n-      error = FT_THROW( Invalid_File_Format );\n-      goto Exit;\n-    }\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidload.c","additions":103,"deletions":107,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -40,1 +40,1 @@\n-                  FT_Byte    offsize );\n+                  FT_UInt    offsize );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidload.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -72,2 +72,1 @@\n-      module = FT_Get_Module( slot->face->driver->root.library,\n-                              \"pshinter\" );\n+      module = FT_Get_Module( slot->library, \"pshinter\" );\n@@ -156,1 +155,1 @@\n-  FT_LOCAL( FT_Error )\n+  FT_LOCAL_DEF( FT_Error )\n@@ -160,0 +159,2 @@\n+    FT_Error  error;\n+\n@@ -163,1 +164,3 @@\n-    FT_Request_Metrics( size->face, req );\n+    error = FT_Request_Metrics( size->face, req );\n+    if ( error )\n+      goto Exit;\n@@ -173,1 +176,2 @@\n-    return FT_Err_Ok;\n+  Exit:\n+    return error;\n@@ -214,1 +218,1 @@\n-      FT_Int  n;\n+      FT_UInt  n;\n@@ -266,1 +270,2 @@\n-   *     The source font stream.\n+   *     Dummy argument for compatibility with the `FT_Face_InitFunc` API.\n+   *     Ignored.  The stream should be passed through `face->root.stream`.\n@@ -373,0 +378,8 @@\n+      \/*\n+       * For the sfnt-wrapped CID fonts for MacOS, currently,\n+       * its `cmap' tables are ignored, and the content in\n+       * its `CID ' table is treated the same as naked CID-keyed\n+       * font.  See ft_lookup_PS_in_sfnt_stream().\n+       *\/\n+      cidface->face_flags |= FT_FACE_FLAG_CID_KEYED;\n+\n@@ -482,3 +495,0 @@\n-#ifdef T1_CONFIG_OPTION_OLD_ENGINE\n-    driver->hinting_engine = FT_HINTING_FREETYPE;\n-#else\n@@ -486,1 +496,0 @@\n-#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidobjs.c","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -76,0 +76,3 @@\n+    {\n+      FT_TRACE2(( \"  not a CID-keyed font\\n\" ));\n+      error = FT_THROW( Unknown_File_Format );\n@@ -77,0 +80,1 @@\n+    }\n@@ -89,3 +93,5 @@\n-  Again:\n-    \/* now, read the rest of the file until we find *\/\n-    \/* `StartData' or `\/sfnts'                      *\/\n+    if ( !stream->read ) {\n+      \/* just parse memory-based streams *\/\n+      offset = stream->size;\n+    }\n+    else\n@@ -93,0 +99,3 @@\n+      \/* Find the last `StartData` or `\/sfnts`.  The parser requires *\/\n+      \/* contiguous memory; attempt to pin as little as necessary.   *\/\n+\n@@ -118,1 +127,2 @@\n-      for ( offset = FT_STREAM_POS(); ; offset += 256 )\n+      offset = 0;\n+      while ( 1 )\n@@ -126,1 +136,1 @@\n-        if ( FT_STREAM_READ( p, read_len ) )\n+        if ( read_len && FT_STREAM_READ( p, read_len ) )\n@@ -140,2 +150,2 @@\n-            offset += (FT_ULong)( p - buffer ) + STARTDATA_LEN + 1;\n-            goto Found;\n+            offset = FT_STREAM_POS() - read_len - read_offset\n+                     + (FT_ULong)( p - buffer ) + STARTDATA_LEN + 1;\n@@ -146,2 +156,2 @@\n-            offset += (FT_ULong)( p - buffer ) + SFNTS_LEN + 1;\n-            goto Found;\n+            offset = FT_STREAM_POS() - read_len - read_offset\n+                     + (FT_ULong)( p - buffer ) + SFNTS_LEN + 1;\n@@ -151,1 +161,1 @@\n-        if ( read_offset + read_len < STARTDATA_LEN )\n+        if ( read_offset + read_len <= STARTDATA_LEN )\n@@ -153,1 +163,4 @@\n-          FT_TRACE2(( \"cid_parser_new: no `StartData' keyword found\\n\" ));\n+          if ( offset )\n+            goto Found;\n+\n+          FT_TRACE2(( \"cid_parser_new: no `StartData` keyword found\\n\" ));\n@@ -170,3 +183,3 @@\n-    \/* We have found the start of the binary data or the `\/sfnts' token. *\/\n-    \/* Now rewind and extract the frame corresponding to this PostScript *\/\n-    \/* section.                                                          *\/\n+    \/* We have found an efficient range to look for the binary data or    *\/\n+    \/* `\/sfnts' token.  Now rewind and extract the frame corresponding to *\/\n+    \/* this PostScript section.                                           *\/\n@@ -184,1 +197,1 @@\n-    parser->num_dict       = -1;\n+    parser->num_dict       = FT_UINT_MAX;\n@@ -186,2 +199,2 @@\n-    \/* Finally, we check whether `StartData' or `\/sfnts' was real --  *\/\n-    \/* it could be in a comment or string.  We also get the arguments *\/\n+    \/* Find the first real `StartData' or `\/sfnts' -- the last one    *\/\n+    \/* could be in a comment or string.  We also get the arguments    *\/\n@@ -213,3 +226,3 @@\n-        if ( ft_strncmp( (char*)arg1, \"(Hex)\", 5 ) == 0 )\n-        {\n-          FT_Long  tmp = ft_strtol( (const char *)arg2, NULL, 10 );\n+        T1_TokenRec  type_token;\n+        FT_Long      binary_length;\n+        FT_ULong     found_offset;\n@@ -218,1 +231,8 @@\n-          if ( tmp < 0 )\n+        parser->root.cursor = arg1;\n+        cid_parser_to_token( parser, &type_token );\n+        if ( type_token.limit - type_token.start == 5              &&\n+             ft_memcmp( (char*)type_token.start, \"(Hex)\", 5 ) == 0 )\n+        {\n+          parser->root.cursor = arg2;\n+          binary_length = cid_parser_to_int( parser );\n+          if ( binary_length < 0 )\n@@ -224,1 +244,1 @@\n-            parser->binary_length = (FT_ULong)tmp;\n+            parser->binary_length = (FT_ULong)binary_length;\n@@ -227,0 +247,18 @@\n+        \/* set the real values for the parser, if different *\/\n+        found_offset = (FT_ULong)( cur - parser->postscript )\n+                       + STARTDATA_LEN + 1;\n+        if ( found_offset != offset )\n+        {\n+          FT_FRAME_RELEASE( parser->postscript );\n+\n+          ps_len = found_offset - base_offset;\n+          if ( FT_STREAM_SEEK( base_offset )                  ||\n+               FT_FRAME_EXTRACT( ps_len, parser->postscript ) )\n+            goto Exit;\n+\n+          parser->data_offset    = found_offset;\n+          parser->postscript_len = ps_len;\n+          parser->root.base      = parser->postscript;\n+          parser->root.cursor    = parser->postscript;\n+          parser->root.limit     = parser->root.cursor + ps_len;\n+        }\n@@ -244,5 +282,2 @@\n-    \/* we haven't found the correct `StartData'; go back and continue *\/\n-    \/* searching                                                      *\/\n-    FT_FRAME_RELEASE( parser->postscript );\n-    if ( !FT_STREAM_SEEK( offset ) )\n-      goto Again;\n+    FT_TRACE2(( \"cid_parser_new: no `StartData` token found\\n\" ));\n+    error = FT_THROW( Invalid_File_Format );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidparse.c","additions":63,"deletions":28,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -81,1 +81,1 @@\n-    FT_Int        num_dict;\n+    FT_UInt       num_dict;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidparse.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -51,2 +51,2 @@\n-  static const char*\n-  cid_get_postscript_name( CID_Face  face )\n+  FT_CALLBACK_DEF( const char* )\n+  cid_get_postscript_name( FT_Face  face )    \/* CID_Face *\/\n@@ -54,1 +54,2 @@\n-    const char*  result = face->cid.cid_font_name;\n+    CID_Face     cidface = (CID_Face)face;\n+    const char*  result  = cidface->cid.cid_font_name;\n@@ -75,2 +76,2 @@\n-  static FT_Error\n-  cid_ps_get_font_info( FT_Face          face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cid_ps_get_font_info( FT_Face          face,        \/* CID_Face *\/\n@@ -79,1 +80,1 @@\n-    *afont_info = ((CID_Face)face)->cid.font_info;\n+    *afont_info = ( (CID_Face)face )->cid.font_info;\n@@ -84,3 +85,4 @@\n-  static FT_Error\n-  cid_ps_get_font_extra( FT_Face          face,\n-                        PS_FontExtraRec*  afont_extra )\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  cid_ps_get_font_extra( FT_Face           face,         \/* CID_Face *\/\n+                         PS_FontExtraRec*  afont_extra )\n@@ -88,1 +90,1 @@\n-    *afont_extra = ((CID_Face)face)->font_extra;\n+    *afont_extra = ( (CID_Face)face )->font_extra;\n@@ -93,0 +95,1 @@\n+\n@@ -95,2 +98,2 @@\n-    (PS_GetFontInfoFunc)   cid_ps_get_font_info,   \/* ps_get_font_info    *\/\n-    (PS_GetFontExtraFunc)  cid_ps_get_font_extra,  \/* ps_get_font_extra   *\/\n+    cid_ps_get_font_info,   \/* PS_GetFontInfoFunc    ps_get_font_info    *\/\n+    cid_ps_get_font_extra,  \/* PS_GetFontExtraFunc   ps_get_font_extra   *\/\n@@ -98,1 +101,1 @@\n-    (PS_HasGlyphNamesFunc) NULL,                   \/* ps_has_glyph_names  *\/\n+    NULL,                   \/* PS_HasGlyphNamesFunc  ps_has_glyph_names  *\/\n@@ -100,1 +103,1 @@\n-    (PS_GetFontPrivateFunc)NULL,                   \/* ps_get_font_private *\/\n+    NULL,                   \/* PS_GetFontPrivateFunc ps_get_font_private *\/\n@@ -102,1 +105,1 @@\n-    (PS_GetFontValueFunc)  NULL                    \/* ps_get_font_value   *\/\n+    NULL                    \/* PS_GetFontValueFunc   ps_get_font_value   *\/\n@@ -110,2 +113,2 @@\n-  static FT_Error\n-  cid_get_ros( CID_Face      face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cid_get_ros( FT_Face       face,        \/* CID_Face *\/\n@@ -116,1 +119,2 @@\n-    CID_FaceInfo  cid = &face->cid;\n+    CID_Face      cidface = (CID_Face)face;\n+    CID_FaceInfo  cid     = &cidface->cid;\n@@ -132,2 +136,2 @@\n-  static FT_Error\n-  cid_get_is_cid( CID_Face  face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cid_get_is_cid( FT_Face   face,    \/* CID_Face *\/\n@@ -140,0 +144,6 @@\n+    \/*\n+     * XXX: If the ROS is Adobe-Identity-H or -V,\n+     * the font has no reliable information about\n+     * its glyph collection.  Should we not set\n+     * *is_cid in such cases?\n+     *\/\n@@ -141,1 +151,1 @@\n-      *is_cid = 1; \/* cid driver is only used for CID keyed fonts *\/\n+      *is_cid = 1;\n@@ -147,2 +157,2 @@\n-  static FT_Error\n-  cid_get_cid_from_glyph_index( CID_Face  face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  cid_get_cid_from_glyph_index( FT_Face   face,        \/* CID_Face *\/\n@@ -152,6 +162,16 @@\n-    FT_Error  error = FT_Err_Ok;\n-    FT_UNUSED( face );\n-\n-\n-    if ( cid )\n-      *cid = glyph_index; \/* identity mapping *\/\n+    FT_Error  error   = FT_Err_Ok;\n+    CID_Face  cidface = (CID_Face)face;\n+\n+\n+    \/*\n+     * Currently, FreeType does not support incrementally-defined, CID-keyed\n+     * fonts that store the glyph description data in a `\/GlyphDirectory`\n+     * array or dictionary.  Fonts loaded by the incremental loading feature\n+     * are thus not handled here.\n+     *\/\n+    error = cid_compute_fd_and_offsets( cidface, glyph_index,\n+                                        NULL, NULL, NULL );\n+    if ( error )\n+      *cid = 0;\n+    else\n+      *cid = glyph_index;\n@@ -165,6 +185,6 @@\n-    (FT_CID_GetRegistryOrderingSupplementFunc)\n-      cid_get_ros,                             \/* get_ros                  *\/\n-    (FT_CID_GetIsInternallyCIDKeyedFunc)\n-      cid_get_is_cid,                          \/* get_is_cid               *\/\n-    (FT_CID_GetCIDFromGlyphIndexFunc)\n-      cid_get_cid_from_glyph_index             \/* get_cid_from_glyph_index *\/\n+    cid_get_ros,\n+      \/* FT_CID_GetRegistryOrderingSupplementFunc get_ros                  *\/\n+    cid_get_is_cid,\n+      \/* FT_CID_GetIsInternallyCIDKeyedFunc       get_is_cid               *\/\n+    cid_get_cid_from_glyph_index\n+      \/* FT_CID_GetCIDFromGlyphIndexFunc          get_cid_from_glyph_index *\/\n@@ -182,3 +202,3 @@\n-    (FT_Properties_SetFunc)ps_property_set,      \/* set_property *\/\n-    (FT_Properties_GetFunc)ps_property_get )     \/* get_property *\/\n-\n+    ps_property_set,  \/* FT_Properties_SetFunc set_property *\/\n+    ps_property_get   \/* FT_Properties_GetFunc get_property *\/\n+  )\n@@ -212,1 +232,0 @@\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidriver.c","additions":59,"deletions":40,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/cid\/cidtoken.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n@@ -30,0 +30,10 @@\n+  \/**************************************************************************\n+   *\n+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit\n+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print\/log\n+   * messages during execution.\n+   *\/\n+#undef  FT_COMPONENT\n+#define FT_COMPONENT  afmparse\n+\n+\n@@ -556,1 +566,1 @@\n-  FT_LOCAL( void )\n+  FT_LOCAL_DEF( void )\n@@ -589,1 +599,2 @@\n-    AFM_FontInfo   fi = parser->FontInfo;\n+    AFM_FontInfo   fi     = parser->FontInfo;\n+    AFM_Stream     stream = parser->stream;\n@@ -591,4 +602,5 @@\n-    char*          key;\n-    FT_Offset      len;\n-    int            n = -1;\n-    FT_Int         tmp;\n+\n+    char*      key;\n+    FT_Offset  len;\n+    int        n = -1;\n+    FT_Int     tmp;\n@@ -601,0 +613,2 @@\n+    {\n+      FT_ERROR(( \"afm_parse_track_kern: invalid number of track kerns\\n\" ));\n@@ -602,0 +616,1 @@\n+    }\n@@ -604,0 +619,13 @@\n+    FT_TRACE3(( \"afm_parse_track_kern: %u track kern%s expected\\n\",\n+                fi->NumTrackKern,\n+                fi->NumTrackKern == 1 ? \"\" : \"s\" ));\n+\n+    \/* Rough sanity check: The minimum line length of the `TrackKern` *\/\n+    \/* command is 20 characters (including the EOL character).        *\/\n+    if ( (FT_ULong)( stream->limit - stream->cursor ) \/ 20 <\n+           fi->NumTrackKern )\n+    {\n+      FT_ERROR(( \"afm_parse_track_kern:\"\n+                 \" number of track kern entries exceeds stream size\\n\" ));\n+      goto Fail;\n+    }\n@@ -626,1 +654,4 @@\n-          goto Fail;\n+          {\n+            FT_ERROR(( \"afm_parse_track_kern: too many track kern data\\n\" ));\n+            goto Fail;\n+          }\n@@ -636,0 +667,4 @@\n+        {\n+          FT_ERROR(( \"afm_parse_track_kern:\"\n+                     \" insufficient number of parameters for entry %d\\n\",\n+                     n ));\n@@ -637,0 +672,1 @@\n+        }\n@@ -649,1 +685,13 @@\n-        fi->NumTrackKern = (FT_UInt)( n + 1 );\n+        tmp = n + 1;\n+        if ( (FT_UInt)tmp != fi->NumTrackKern )\n+        {\n+          FT_TRACE1(( \"afm_parse_track_kern: %s%d track kern entr%s seen\\n\",\n+                      tmp == 0 ? \"\" : \"only \",\n+                      tmp,\n+                      tmp == 1 ? \"y\" : \"ies\" ));\n+          fi->NumTrackKern = (FT_UInt)tmp;\n+        }\n+        else\n+          FT_TRACE3(( \"afm_parse_track_kern: %d track kern entr%s seen\\n\",\n+                      tmp,\n+                      tmp == 1 ? \"y\" : \"ies\" ));\n@@ -670,1 +718,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -693,1 +741,2 @@\n-    AFM_FontInfo  fi = parser->FontInfo;\n+    AFM_FontInfo  fi     = parser->FontInfo;\n+    AFM_Stream    stream = parser->stream;\n@@ -705,0 +754,2 @@\n+    {\n+      FT_ERROR(( \"afm_parse_kern_pairs: invalid number of kern pairs\\n\" ));\n@@ -706,0 +757,1 @@\n+    }\n@@ -708,0 +760,14 @@\n+    FT_TRACE3(( \"afm_parse_kern_pairs: %u kern pair%s expected\\n\",\n+                fi->NumKernPair,\n+                fi->NumKernPair == 1 ? \"\" : \"s\" ));\n+\n+    \/* Rough sanity check: The minimum line length of the `KP`,    *\/\n+    \/* `KPH`,`KPX`, and `KPY` commands is 10 characters (including *\/\n+    \/* the EOL character).                                         *\/\n+    if ( (FT_ULong)( stream->limit - stream->cursor ) \/ 10 <\n+           fi->NumKernPair )\n+    {\n+      FT_ERROR(( \"afm_parse_kern_pairs:\"\n+                 \" number of kern pairs exceeds stream size\\n\" ));\n+      goto Fail;\n+    }\n@@ -737,0 +803,2 @@\n+          {\n+            FT_ERROR(( \"afm_parse_kern_pairs: too many kern pairs\\n\" ));\n@@ -738,0 +806,1 @@\n+          }\n@@ -747,0 +816,4 @@\n+          {\n+            FT_ERROR(( \"afm_parse_kern_pairs:\"\n+                       \" insufficient number of parameters for entry %d\\n\",\n+                       n ));\n@@ -748,0 +821,1 @@\n+          }\n@@ -769,1 +843,14 @@\n-        fi->NumKernPair = (FT_UInt)( n + 1 );\n+        tmp = n + 1;\n+        if ( (FT_UInt)tmp != fi->NumKernPair )\n+        {\n+          FT_TRACE1(( \"afm_parse_kern_pairs: %s%d kern pair%s seen\\n\",\n+                      tmp == 0 ? \"\" : \"only \",\n+                      tmp,\n+                      tmp == 1 ? \"\" : \"s\" ));\n+          fi->NumKernPair = (FT_UInt)tmp;\n+        }\n+        else\n+          FT_TRACE3(( \"afm_parse_kern_pairs: %d kern pair%s seen\\n\",\n+                      tmp,\n+                      tmp == 1 ? \"\" : \"s\" ));\n+\n@@ -795,0 +882,3 @@\n+    int  have_trackkern = 0;\n+    int  have_kernpairs = 0;\n+\n@@ -801,0 +891,7 @@\n+        if ( have_trackkern )\n+        {\n+          FT_ERROR(( \"afm_parse_kern_data:\"\n+                     \" invalid second horizontal track kern section\\n\" ));\n+          goto Fail;\n+        }\n+\n@@ -804,0 +901,2 @@\n+\n+        have_trackkern = 1;\n@@ -808,0 +907,7 @@\n+        if ( have_kernpairs )\n+        {\n+          FT_ERROR(( \"afm_parse_kern_data:\"\n+                     \" invalid second horizontal kern pair section\\n\" ));\n+          goto Fail;\n+        }\n+\n@@ -811,0 +917,2 @@\n+\n+        have_kernpairs = 1;\n@@ -956,1 +1064,1 @@\n-        \/* fall through                      *\/\n+        FALL_THROUGH;\n@@ -981,1 +1089,1 @@\n-  typedef int  _afm_parse_dummy;\n+  typedef int  afm_parse_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/afmparse.c","additions":122,"deletions":14,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/afmparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n@@ -20,0 +20,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -251,1 +252,1 @@\n-      CFF_Font cff = (CFF_Font)(face->extra.data);\n+      CFF_Font cff = (CFF_Font)( face->extra.data );\n@@ -1755,1 +1756,1 @@\n-            args[0] = 46341;\n+            args[0] = 0xB504F4L;    \/* sqrt( 32768.0044 ) *\/\n@@ -1757,14 +1758,1 @@\n-          {\n-            FT_Fixed  root = args[0];\n-            FT_Fixed  new_root;\n-\n-\n-            for (;;)\n-            {\n-              new_root = ( root + FT_DivFix( args[0], root ) + 1 ) >> 1;\n-              if ( new_root == root )\n-                break;\n-              root = new_root;\n-            }\n-            args[0] = new_root;\n-          }\n+            args[0] = (FT_Fixed)FT_SqrtFixed( args[0] );\n@@ -1874,1 +1862,1 @@\n-            FT_Int    idx = (FT_Int)( args[1] >> 16 );\n+            FT_UInt   idx = (FT_UInt)( args[1] >> 16 );\n@@ -1883,1 +1871,1 @@\n-            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n+            if ( idx < CFF_MAX_TRANS_ELEMENTS )\n@@ -1890,1 +1878,1 @@\n-            FT_Int    idx = (FT_Int)( args[0] >> 16 );\n+            FT_UInt   idx = (FT_UInt)( args[0] >> 16 );\n@@ -1896,1 +1884,1 @@\n-            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n+            if ( idx < CFF_MAX_TRANS_ELEMENTS )\n@@ -1917,3 +1905,3 @@\n-            FT_Int  reg_idx = (FT_Int)args[0];\n-            FT_Int  idx     = (FT_Int)args[1];\n-            FT_Int  count   = (FT_Int)args[2];\n+            FT_UInt  reg_idx = (FT_UInt)args[0];\n+            FT_UInt  idx     = (FT_UInt)args[1];\n+            FT_UInt  count   = (FT_UInt)args[2];\n@@ -1927,3 +1915,3 @@\n-            if ( reg_idx >= 0 && reg_idx <= 2             &&\n-                 idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS &&\n-                 count >= 0 && count <= num_axes          )\n+            if ( reg_idx <= 2                 &&\n+                 idx < CFF_MAX_TRANS_ELEMENTS &&\n+                 count <= num_axes            )\n@@ -1931,1 +1919,1 @@\n-              FT_Int  end, i;\n+              FT_UInt  end, i;\n@@ -2156,1 +2144,1 @@\n-            FT_TRACE4(( \" callsubr (idx %d, entering level %d)\\n\",\n+            FT_TRACE4(( \" callsubr (idx %d, entering level %td)\\n\",\n@@ -2200,1 +2188,1 @@\n-            FT_TRACE4(( \" callgsubr (idx %d, entering level %d)\\n\",\n+            FT_TRACE4(( \" callgsubr (idx %d, entering level %td)\\n\",\n@@ -2239,1 +2227,1 @@\n-          FT_TRACE4(( \" return (leaving level %d)\\n\",\n+          FT_TRACE4(( \" return (leaving level %td)\\n\",\n@@ -2274,1 +2262,2 @@\n-    FT_TRACE4(( \"..end..\\n\\n\" ));\n+    FT_TRACE4(( \"..end..\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/cffdecode.c","additions":21,"deletions":32,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/cffdecode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-    arrstack->chunk     = 10;    \/* chunks of 10 items *\/\n@@ -113,1 +112,1 @@\n-      if ( !FT_REALLOC( arrstack->ptr, arrstack->totalSize, newSize ) )\n+      if ( !FT_QREALLOC( arrstack->ptr, arrstack->totalSize, newSize ) )\n@@ -219,1 +218,1 @@\n-      \/* grow the buffer by one chunk *\/\n+      \/* increase the buffer size *\/\n@@ -221,1 +220,1 @@\n-             arrstack, arrstack->allocated + arrstack->chunk ) )\n+             arrstack, arrstack->allocated * 2 + 16 ) )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psarrst.c","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-    size_t  chunk;          \/* allocation increment in items *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psarrst.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psauxerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psauxmod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psauxmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,8 +57,0 @@\n-  \/*\n-   * For blue values, the FreeType parser produces an array of integers,\n-   * while the Adobe CFF engine produces an array of fixed.\n-   * Define a macro to convert FreeType to fixed.\n-   *\/\n-#define cf2_blueToFixed( x )  cf2_intToFixed( x )\n-\n-\n@@ -81,4 +73,4 @@\n-    FT_Pos*  blueValues;\n-    FT_Pos*  otherBlues;\n-    FT_Pos*  familyBlues;\n-    FT_Pos*  familyOtherBlues;\n+    FT_Fixed*  blueValues;\n+    FT_Fixed*  otherBlues;\n+    FT_Fixed*  familyBlues;\n+    FT_Fixed*  familyOtherBlues;\n@@ -141,7 +133,7 @@\n-    if ( cf2_getLanguageGroup( decoder ) == 1                   &&\n-         ( numBlueValues == 0                                 ||\n-           ( numBlueValues == 4                             &&\n-             cf2_blueToFixed( blueValues[0] ) < emBoxBottom &&\n-             cf2_blueToFixed( blueValues[1] ) < emBoxBottom &&\n-             cf2_blueToFixed( blueValues[2] ) > emBoxTop    &&\n-             cf2_blueToFixed( blueValues[3] ) > emBoxTop    ) ) )\n+    if ( cf2_getLanguageGroup( decoder ) == 1     &&\n+         ( numBlueValues == 0                   ||\n+           ( numBlueValues == 4               &&\n+             blueValues[0] < emBoxBottom      &&\n+             blueValues[1] < emBoxBottom      &&\n+             blueValues[2] > emBoxTop         &&\n+             blueValues[3] > emBoxTop         ) ) )\n@@ -192,4 +184,2 @@\n-      blues->zone[blues->count].csBottomEdge =\n-        cf2_blueToFixed( blueValues[i] );\n-      blues->zone[blues->count].csTopEdge =\n-        cf2_blueToFixed( blueValues[i + 1] );\n+      blues->zone[blues->count].csBottomEdge = blueValues[i];\n+      blues->zone[blues->count].csTopEdge    = blueValues[i + 1];\n@@ -241,4 +231,2 @@\n-      blues->zone[blues->count].csBottomEdge =\n-        cf2_blueToFixed( otherBlues[i] );\n-      blues->zone[blues->count].csTopEdge =\n-        cf2_blueToFixed( otherBlues[i + 1] );\n+      blues->zone[blues->count].csBottomEdge = otherBlues[i];\n+      blues->zone[blues->count].csTopEdge    = otherBlues[i + 1];\n@@ -302,1 +290,1 @@\n-          flatFamilyEdge = cf2_blueToFixed( familyOtherBlues[j + 1] );\n+          flatFamilyEdge = familyOtherBlues[j + 1];\n@@ -320,1 +308,1 @@\n-          flatFamilyEdge = cf2_blueToFixed( familyBlues[1] );\n+          flatFamilyEdge = familyBlues[1];\n@@ -340,1 +328,1 @@\n-          flatFamilyEdge = cf2_blueToFixed( familyBlues[j] );\n+          flatFamilyEdge = familyBlues[j];\n@@ -509,1 +497,2 @@\n-                      blues->zone[i].dsFlatEdge - cf2_intToFixed( 1 ) );\n+                      SUB_INT32( blues->zone[i].dsFlatEdge,\n+                                 cf2_intToFixed( 1 ) ) );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psblues.c","additions":20,"deletions":31,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n@@ -538,1 +538,1 @@\n-        *buffer = (FT_Byte)(*buffer + c);\n+        *buffer = (FT_Byte)( *buffer + c );\n@@ -542,1 +542,1 @@\n-        *buffer = (FT_Byte)(c << 4);\n+        *buffer = (FT_Byte)( c << 4 );\n@@ -575,2 +575,2 @@\n-    if ( n > (FT_UInt)(limit - p) )\n-      n = (FT_UInt)(limit - p);\n+    if ( n > (FT_UInt)( limit - p ) )\n+      n = (FT_UInt)( limit - p );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psconv.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psconv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *   Adobe's code for Fixed Point Mathematics (specification only).\n+ *   Adobe's code for Fixed-Point Mathematics (specification only).\n@@ -46,1 +46,1 @@\n-  \/* rasterizer integer and fixed point arithmetic must be 32-bit *\/\n+  \/* rasterizer integer and fixed-point arithmetic must be 32-bit *\/\n@@ -49,1 +49,1 @@\n-  typedef FT_Int32   CF2_Frac;   \/* 2.30 fixed point *\/\n+  typedef FT_Int32   CF2_Frac;   \/* 2.30 fixed-point *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psfixed.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,2 +71,0 @@\n-    FT_ASSERT( unitsPerEm > 0 );\n-\n@@ -76,0 +74,1 @@\n+    FT_ASSERT( unitsPerEm > 0 );\n@@ -300,1 +299,0 @@\n-    FT_ASSERT( decoder->builder.face->units_per_EM );\n@@ -571,1 +569,1 @@\n-                     FT_Pos*     *data )\n+                     FT_Fixed*   *data )\n@@ -576,1 +574,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n@@ -584,1 +582,1 @@\n-                     FT_Pos*     *data )\n+                     FT_Fixed*   *data )\n@@ -589,1 +587,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n@@ -597,1 +595,1 @@\n-                      FT_Pos*     *data )\n+                      FT_Fixed*   *data )\n@@ -602,1 +600,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n@@ -610,1 +608,1 @@\n-                           FT_Pos*     *data )\n+                           FT_Fixed*   *data )\n@@ -615,1 +613,1 @@\n-    *data  = (FT_Pos*)\n+    *data  = (FT_Fixed*)\n@@ -745,1 +743,1 @@\n-      glyph_data.length  = (FT_Int)type1->charstrings_len[glyph_index];\n+      glyph_data.length  = type1->charstrings_len[glyph_index];\n@@ -751,1 +749,1 @@\n-      FT_ULong  charstring_len  = (FT_ULong)glyph_data.length;\n+      FT_ULong  charstring_len  = glyph_data.length;\n@@ -781,1 +779,1 @@\n-    data.length  = (FT_Int)( buf->end - buf->start );\n+    data.length  = (FT_UInt)( buf->end - buf->start );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psft.c","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-                     FT_Pos*     *data );\n+                     FT_Fixed*   *data );\n@@ -99,1 +99,1 @@\n-                     FT_Pos*     *data );\n+                     FT_Fixed*   *data );\n@@ -103,1 +103,1 @@\n-                      FT_Pos*     *data );\n+                      FT_Fixed*   *data );\n@@ -107,1 +107,1 @@\n-                           FT_Pos*     *data );\n+                           FT_Fixed*   *data );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psft.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  \/* a matrix of fixed point values *\/\n+  \/* a matrix of fixed-point values *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psglue.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-      FT_TRACE6(( \"  %3ld    %7.2f  %7.2f  %5d  %s%s%s%s\\n\",\n+      FT_TRACE6(( \"  %3zu    %7.2f  %7.2f  %5d  %s%s%s%s\\n\",\n@@ -415,0 +415,6 @@\n+      \/* final amount to move edge or edge pair *\/\n+      CF2_Fixed  move = 0;\n+\n+      CF2_Fixed  dsCoord_i;\n+      CF2_Fixed  dsCoord_j;\n+\n@@ -425,0 +431,3 @@\n+      dsCoord_i = hintmap->edge[i].dsCoord;\n+      dsCoord_j = hintmap->edge[j].dsCoord;\n+\n@@ -428,2 +437,2 @@\n-        CF2_Fixed  fracDown = cf2_fixedFraction( hintmap->edge[i].dsCoord );\n-        CF2_Fixed  fracUp   = cf2_fixedFraction( hintmap->edge[j].dsCoord );\n+        CF2_Fixed  fracDown = cf2_fixedFraction( dsCoord_i );\n+        CF2_Fixed  fracUp   = cf2_fixedFraction( dsCoord_j );\n@@ -446,3 +455,0 @@\n-        \/* final amount to move edge or edge pair *\/\n-        CF2_Fixed  move;\n-\n@@ -470,1 +476,1 @@\n-        if ( j >= hintmap->count - 1                ||\n+        if ( j >= hintmap->count - 1                         ||\n@@ -472,2 +478,1 @@\n-               ADD_INT32( hintmap->edge[j].dsCoord,\n-                          moveUp + upMinCounter )   )\n+               ADD_INT32( dsCoord_j, moveUp + upMinCounter ) )\n@@ -476,1 +481,1 @@\n-          if ( i == 0                                   ||\n+          if ( i == 0                                              ||\n@@ -478,2 +483,1 @@\n-                 ADD_INT32( hintmap->edge[i].dsCoord,\n-                            moveDown - downMinCounter ) )\n+                 ADD_INT32( dsCoord_i, moveDown - downMinCounter ) )\n@@ -490,1 +494,1 @@\n-          if ( i == 0                                   ||\n+          if ( i == 0                                              ||\n@@ -492,2 +496,1 @@\n-                 ADD_INT32( hintmap->edge[i].dsCoord,\n-                            moveDown - downMinCounter ) )\n+                 ADD_INT32( dsCoord_i, moveDown - downMinCounter ) )\n@@ -527,2 +530,1 @@\n-        hintmap->edge[i].dsCoord = ADD_INT32( hintmap->edge[i].dsCoord,\n-                                              move );\n+        hintmap->edge[i].dsCoord = ADD_INT32( dsCoord_i, move );\n@@ -530,2 +532,1 @@\n-          hintmap->edge[j].dsCoord = ADD_INT32( hintmap->edge[j].dsCoord,\n-                                                move );\n+          hintmap->edge[j].dsCoord = ADD_INT32( dsCoord_j, move );\n@@ -534,1 +535,3 @@\n-      \/* assert there are no overlaps in device space *\/\n+      \/* assert there are no overlaps in device space;     *\/\n+      \/* ignore tests if there was overflow (that is, if   *\/\n+      \/* operands have the same sign but the sum does not) *\/\n@@ -536,0 +539,2 @@\n+                 ( ( dsCoord_i ^ move ) >= 0                    &&\n+                   ( dsCoord_i ^ hintmap->edge[i].dsCoord ) < 0 )         ||\n@@ -538,0 +543,2 @@\n+                 ( ( dsCoord_j ^ move ) >= 0                    &&\n+                   ( dsCoord_j ^ hintmap->edge[j].dsCoord ) < 0 )     ||\n@@ -689,2 +696,4 @@\n-                       ADD_INT32( secondHintEdge->csCoord,\n-                                  firstHintEdge->csCoord ) \/ 2 );\n+                       ADD_INT32(\n+                         firstHintEdge->csCoord,\n+                         SUB_INT32 ( secondHintEdge->csCoord,\n+                                     firstHintEdge->csCoord ) \/ 2 ) );\n@@ -1025,4 +1034,11 @@\n-    FT_TRACE6(( \"%s\\n\", initialMap ? \"flags: [p]air [g]host [t]op\"\n-                                     \" [b]ottom [L]ocked [S]ynthetic\\n\"\n-                                     \"Initial hintmap\"\n-                                   : \"Hints:\" ));\n+#ifdef FT_DEBUG_LEVEL_TRACE\n+    if ( initialMap )\n+    {\n+      FT_TRACE6(( \"flags: [p]air [g]host [t]op\"\n+                  \" [b]ottom [L]ocked [S]ynthetic\\n\" ));\n+      FT_TRACE6(( \"Initial hintmap:\\n\" ));\n+    }\n+    else\n+      FT_TRACE6(( \"Hints:\\n\" ));\n+#endif\n+\n@@ -1043,1 +1059,1 @@\n-    FT_TRACE6(( \"(adjusted)\\n\" ));\n+    FT_TRACE6(( \"Hints adjusted:\\n\" ));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/pshints.c","additions":43,"deletions":27,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -431,0 +432,2 @@\n+    FT_TRACE6(( \" (\" ));\n+\n@@ -445,0 +448,2 @@\n+      FT_TRACE6(( \"%f \", (double)sum \/ 65536 ));\n+\n@@ -449,0 +454,2 @@\n+    FT_TRACE6(( \"blended)\\n\" ));\n+\n@@ -472,1 +479,1 @@\n-                          CF2_Buffer            buf,\n+                          const CF2_Buffer      buf,\n@@ -737,1 +744,1 @@\n-          FT_TRACE4(( \" blend\\n\" ));\n+          FT_TRACE4(( \" blend\" ));\n@@ -1343,3 +1350,3 @@\n-                        FT_ERROR((\n-                          \"cf2_interpT2CharString: (Type 1 seac)\"\n-                          \" glyph names table not available in this font\\n\" ));\n+                        FT_ERROR(( \"cf2_interpT2CharString:\\n\" ));\n+                        FT_ERROR(( \"  (Type 1 seac) glyph names table\"\n+                                   \" not available in this font\\n\" ));\n@@ -1371,3 +1378,3 @@\n-                      FT_ERROR((\n-                        \"cf2_interpT2CharString: (Type 1 seac)\"\n-                        \" invalid seac character code arguments\\n\" ));\n+                      FT_ERROR(( \"cf2_interpT2CharString:\\n\" ));\n+                      FT_ERROR(( \"  (Type 1 seac) invalid\"\n+                                 \" seac character code arguments\\n\" ));\n@@ -1673,1 +1680,7 @@\n-                    FT_ASSERT( (CF2_UInt)arg_cnt <= count );\n+                    if ( (CF2_UInt)arg_cnt > count )\n+                    {\n+                      FT_ERROR(( \"cf2_interpT2CharString (Type 1 mode):\"\n+                                 \" stack underflow\\n\" ));\n+                      lastError = FT_THROW( Invalid_Glyph_Format );\n+                      goto exit;\n+                    }\n@@ -1896,2 +1909,3 @@\n-                        FT_Int    idx;\n-                        PS_Blend  blend = decoder->blend;\n+                        FT_UInt   idx;\n+                        PS_Blend  blend         = decoder->blend;\n+                        FT_UInt   len_buildchar = decoder->len_buildchar;\n@@ -1903,1 +1917,1 @@\n-                        idx = cf2_stack_popInt( opStack );\n+                        idx = (FT_UInt)cf2_stack_popInt( opStack );\n@@ -1905,3 +1919,2 @@\n-                        if ( idx < 0                             ||\n-                             (FT_UInt)idx + blend->num_designs >\n-                               decoder->len_buildchar            )\n+                        if ( len_buildchar < blend->num_designs       ||\n+                             len_buildchar - blend->num_designs < idx )\n@@ -1910,4 +1923,5 @@\n-                        ft_memcpy( &decoder->buildchar[idx],\n-                                   blend->weight_vector,\n-                                   blend->num_designs *\n-                                   sizeof ( blend->weight_vector[0] ) );\n+                        if ( decoder->buildchar && blend->weight_vector )\n+                          ft_memcpy( &decoder->buildchar[idx],\n+                                     blend->weight_vector,\n+                                     blend->num_designs *\n+                                       sizeof ( blend->weight_vector[0] ) );\n@@ -2007,1 +2021,1 @@\n-                        CF2_Int   idx;\n+                        CF2_UInt  idx;\n@@ -2014,1 +2028,1 @@\n-                        idx = cf2_stack_popInt( opStack );\n+                        idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2016,2 +2030,1 @@\n-                        if ( idx < 0                                ||\n-                             (FT_UInt)idx >= decoder->len_buildchar )\n+                        if ( idx >= decoder->len_buildchar )\n@@ -2030,1 +2043,1 @@\n-                        CF2_Int   idx;\n+                        CF2_UInt  idx;\n@@ -2037,1 +2050,1 @@\n-                        idx = cf2_stack_popInt( opStack );\n+                        idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2039,2 +2052,1 @@\n-                        if ( idx < 0                                ||\n-                             (FT_UInt)idx >= decoder->len_buildchar )\n+                        if ( idx >= decoder->len_buildchar )\n@@ -2182,1 +2194,1 @@\n-                    CF2_Int       idx;\n+                    CF2_UInt      idx;\n@@ -2187,1 +2199,1 @@\n-                    idx = cf2_stack_popInt( opStack );\n+                    idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2190,1 +2202,1 @@\n-                    if ( idx >= 0 && idx < CF2_STORAGE_SIZE )\n+                    if ( idx < CF2_STORAGE_SIZE )\n@@ -2197,1 +2209,1 @@\n-                    CF2_Int  idx;\n+                    CF2_UInt  idx;\n@@ -2202,1 +2214,1 @@\n-                    idx = cf2_stack_popInt( opStack );\n+                    idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2204,1 +2216,1 @@\n-                    if ( idx >= 0 && idx < CF2_STORAGE_SIZE )\n+                    if ( idx < CF2_STORAGE_SIZE )\n@@ -2273,17 +2285,1 @@\n-                    {\n-                      \/* use a start value that doesn't make *\/\n-                      \/* the algorithm's addition overflow   *\/\n-                      FT_Fixed  root = arg < 10 ? arg : arg >> 1;\n-                      FT_Fixed  new_root;\n-\n-\n-                      \/* Babylonian method *\/\n-                      for (;;)\n-                      {\n-                        new_root = ( root + FT_DivFix( arg, root ) + 1 ) >> 1;\n-                        if ( new_root == root )\n-                          break;\n-                        root = new_root;\n-                      }\n-                      arg = new_root;\n-                    }\n+                      arg = (CF2_F16Dot16)FT_SqrtFixed( (FT_UInt32)arg );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psintrp.c","additions":46,"deletions":50,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-                          CF2_Buffer            charstring,\n+                          const CF2_Buffer      buf,\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psintrp.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -26,0 +26,1 @@\n+#include \"psft.h\"\n@@ -87,1 +88,0 @@\n-    table->num_elems = 0;\n@@ -102,17 +102,0 @@\n-  static void\n-  shift_elements( PS_Table  table,\n-                  FT_Byte*  old_base )\n-  {\n-    FT_PtrDist  delta  = table->block - old_base;\n-    FT_Byte**   offset = table->elements;\n-    FT_Byte**   limit  = offset + table->max_elems;\n-\n-\n-    for ( ; offset < limit; offset++ )\n-    {\n-      if ( offset[0] )\n-        offset[0] += delta;\n-    }\n-  }\n-\n-\n@@ -120,2 +103,2 @@\n-  reallocate_t1_table( PS_Table   table,\n-                       FT_Offset  new_size )\n+  ps_table_realloc( PS_Table   table,\n+                    FT_Offset  new_size )\n@@ -128,4 +111,2 @@\n-    \/* allocate new base block *\/\n-    if ( FT_ALLOC( table->block, new_size ) )\n-    {\n-      table->block = old_base;\n+    \/* (re)allocate the base block *\/\n+    if ( FT_REALLOC( table->block, table->capacity, new_size ) )\n@@ -133,1 +114,0 @@\n-    }\n@@ -135,2 +115,2 @@\n-    \/* copy elements and shift offsets *\/\n-    if ( old_base )\n+    \/* rebase offsets if necessary *\/\n+    if ( old_base && table->block != old_base )\n@@ -138,3 +118,9 @@\n-      FT_MEM_COPY( table->block, old_base, table->capacity );\n-      shift_elements( table, old_base );\n-      FT_FREE( old_base );\n+      FT_Byte**   offset = table->elements;\n+      FT_Byte**   limit  = offset + table->max_elems;\n+\n+\n+      for ( ; offset < limit; offset++ )\n+      {\n+        if ( *offset )\n+          *offset = table->block + ( *offset - old_base );\n+      }\n@@ -207,1 +193,1 @@\n-      error = reallocate_t1_table( table, new_size );\n+      error = ps_table_realloc( table, new_size );\n@@ -218,1 +204,3 @@\n-    FT_MEM_COPY( table->block + table->cursor, object, length );\n+    \/* length == 0 also implies a NULL destination, so skip the copy call *\/\n+    if ( length > 0 )\n+      FT_MEM_COPY( table->block + table->cursor, object, length );\n@@ -237,4 +225,0 @@\n-   *\n-   * @Note:\n-   *   This function does NOT release the heap's memory block.  It is up\n-   *   to the caller to clean it, or reference it in its own structures.\n@@ -245,18 +229,2 @@\n-    FT_Memory  memory = table->memory;\n-    FT_Error   error;\n-    FT_Byte*   old_base = table->block;\n-\n-\n-    \/* should never fail, because rec.cursor <= rec.size *\/\n-    if ( !old_base )\n-      return;\n-\n-    if ( FT_ALLOC( table->block, table->cursor ) )\n-      return;\n-    FT_MEM_COPY( table->block, old_base, table->cursor );\n-    shift_elements( table, old_base );\n-\n-    table->capacity = table->cursor;\n-    FT_FREE( old_base );\n-\n-    FT_UNUSED( error );\n+    \/* no problem if shrinking fails *\/\n+    ps_table_realloc( table, table->cursor );\n@@ -272,1 +240,1 @@\n-    if ( (FT_ULong)table->init == 0xDEADBEEFUL )\n+    if ( table->init == 0xDEADBEEFUL )\n@@ -555,1 +523,1 @@\n-      if ( cur + 1 < limit && *(cur + 1) == '<' )   \/* << *\/\n+      if ( cur + 1 < limit && *( cur + 1 ) == '<' ) \/* << *\/\n@@ -598,3 +566,1 @@\n-                 \" current token is `%c' which is self-delimiting\\n\"\n-                 \"                        \"\n-                 \" but invalid at this point\\n\",\n+                 \" current token is `%c' which is self-delimiting\\n\",\n@@ -602,0 +568,2 @@\n+      FT_ERROR(( \"                        \"\n+                 \" but invalid at this point\\n\" ));\n@@ -982,1 +950,1 @@\n-    if ( cur >= limit || FT_ALLOC( result, len + 1 ) )\n+    if ( cur >= limit || FT_QALLOC( result, len + 1 ) )\n@@ -1101,1 +1069,0 @@\n-      FT_String*  string = NULL;\n@@ -1151,2 +1118,3 @@\n-          FT_Memory  memory = parser->memory;\n-          FT_UInt    len    = (FT_UInt)( limit - cur );\n+          FT_Memory   memory = parser->memory;\n+          FT_UInt     len    = (FT_UInt)( limit - cur );\n+          FT_String*  string = NULL;\n@@ -1178,2 +1146,2 @@\n-                       \" expected a name or string\\n\"\n-                       \"                     \"\n+                       \" expected a name or string\\n\" ));\n+            FT_ERROR(( \"                     \"\n@@ -1193,1 +1161,0 @@\n-            *(FT_String**)q = NULL;\n@@ -1196,1 +1163,1 @@\n-          if ( FT_ALLOC( string, len + 1 ) )\n+          if ( FT_QALLOC( string, len + 1 ) )\n@@ -1251,1 +1218,1 @@\n-          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )\n+          if ( FT_QNEW_ARRAY( temp, max_objects * 4 ) )\n@@ -1261,3 +1228,1 @@\n-                         \" expected %d integer%s in the %s subarray\\n\"\n-                         \"                     \"\n-                         \" of \/FontBBox in the \/Blend dictionary\\n\",\n+                         \" expected %d integer%s in the %s subarray\\n\",\n@@ -1269,0 +1234,2 @@\n+              FT_ERROR(( \"                     \"\n+                         \" of \/FontBBox in the \/Blend dictionary\\n\" ));\n@@ -1663,1 +1630,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*    control = outline->tags   + outline->n_points;\n@@ -1716,2 +1683,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -1779,1 +1745,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;\n+      FT_Byte*    control = outline->tags   + outline->n_points - 1;\n@@ -1799,2 +1765,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -1938,1 +1903,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*    control = outline->tags   + outline->n_points;\n@@ -1998,2 +1963,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2058,1 +2022,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;\n+      FT_Byte*    control = outline->tags   + outline->n_points - 1;\n@@ -2078,2 +2042,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2227,1 +2190,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;\n+      FT_Byte*    control = outline->tags   + outline->n_points;\n@@ -2306,2 +2269,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2366,1 +2328,1 @@\n-      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;\n+      FT_Byte*    control = outline->tags   + outline->n_points - 1;\n@@ -2386,2 +2348,1 @@\n-        outline->contours[outline->n_contours - 1] =\n-          (short)( outline->n_points - 1 );\n+        outline->contours[outline->n_contours - 1] = outline->n_points - 1;\n@@ -2502,1 +2463,1 @@\n-      cpriv->blue_values[n] = (FT_Pos)priv->blue_values[n];\n+      cpriv->blue_values[n] = cf2_intToFixed( priv->blue_values[n] );\n@@ -2506,1 +2467,1 @@\n-      cpriv->other_blues[n] = (FT_Pos)priv->other_blues[n];\n+      cpriv->other_blues[n] = cf2_intToFixed( priv->other_blues[n] );\n@@ -2510,1 +2471,1 @@\n-      cpriv->family_blues[n] = (FT_Pos)priv->family_blues[n];\n+      cpriv->family_blues[n] = cf2_intToFixed( priv->family_blues[n] );\n@@ -2514,1 +2475,2 @@\n-      cpriv->family_other_blues[n] = (FT_Pos)priv->family_other_blues[n];\n+      cpriv->family_other_blues[n] =\n+        cf2_intToFixed( priv->family_other_blues[n] );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psobjs.c","additions":56,"deletions":94,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-    FT_Error  error = FT_Err_Ok;     \/* for FT_NEW *\/\n-\n+    FT_Error   error;        \/* for FT_QNEW *\/\n@@ -62,1 +61,1 @@\n-    if ( FT_NEW( stack ) )\n+    if ( FT_QNEW( stack ) )\n@@ -65,1 +64,0 @@\n-    \/* initialize the structure; FT_NEW zeroes it *\/\n@@ -70,1 +68,1 @@\n-    if ( FT_NEW_ARRAY( stack->buffer, stackSize ) )\n+    if ( FT_QNEW_ARRAY( stack->buffer, stackSize ) )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psstack.c","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-      CF2_Fixed  r;      \/* 16.16 fixed point *\/\n-      CF2_Frac   f;      \/* 2.30 fixed point (for font matrix) *\/\n+      CF2_Fixed  r;      \/* 16.16 fixed-point *\/\n+      CF2_Frac   f;      \/* 2.30 fixed-point (for font matrix) *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/psstack.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -53,1 +53,1 @@\n-  t1_cmap_std_done( T1_CMapStd  cmap )\n+  t1_cmap_std_done( FT_CMap  cmap_ )   \/* T1_CMapStd *\/\n@@ -55,0 +55,3 @@\n+    T1_CMapStd  cmap = (T1_CMapStd)cmap_;\n+\n+\n@@ -63,2 +66,2 @@\n-  t1_cmap_std_char_index( T1_CMapStd  cmap,\n-                          FT_UInt32   char_code )\n+  t1_cmap_std_char_index( FT_CMap    cmap,       \/* T1_CMapStd *\/\n+                          FT_UInt32  char_code )\n@@ -66,1 +69,2 @@\n-    FT_UInt  result = 0;\n+    T1_CMapStd  t1cmap = (T1_CMapStd)cmap;\n+    FT_UInt     result = 0;\n@@ -76,2 +80,2 @@\n-      code       = cmap->code_to_sid[char_code];\n-      glyph_name = cmap->sid_to_string( code );\n+      code       = t1cmap->code_to_sid[char_code];\n+      glyph_name = t1cmap->sid_to_string( code );\n@@ -80,1 +84,1 @@\n-      for ( n = 0; n < cmap->num_glyphs; n++ )\n+      for ( n = 0; n < t1cmap->num_glyphs; n++ )\n@@ -82,1 +86,1 @@\n-        const char* gname = cmap->glyph_names[n];\n+        const char* gname = t1cmap->glyph_names[n];\n@@ -98,3 +102,3 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  t1_cmap_std_char_next( T1_CMapStd   cmap,\n-                         FT_UInt32   *pchar_code )\n+  FT_CALLBACK_DEF( FT_UInt )\n+  t1_cmap_std_char_next( FT_CMap     cmap,\n+                         FT_UInt32  *pchar_code )\n@@ -123,1 +127,1 @@\n-  t1_cmap_standard_init( T1_CMapStd  cmap,\n+  t1_cmap_standard_init( FT_CMap     cmap,     \/* T1_CMapStd *\/\n@@ -126,0 +130,1 @@\n+    T1_CMapStd  t1cmap = (T1_CMapStd)cmap;\n@@ -129,1 +134,1 @@\n-    t1_cmap_std_init( cmap, 0 );\n+    t1_cmap_std_init( t1cmap, 0 );\n@@ -153,1 +158,1 @@\n-  t1_cmap_expert_init( T1_CMapStd  cmap,\n+  t1_cmap_expert_init( FT_CMap     cmap,     \/* T1_CMapStd *\/\n@@ -156,0 +161,1 @@\n+    T1_CMapStd  t1cmap = (T1_CMapStd)cmap;\n@@ -159,1 +165,1 @@\n-    t1_cmap_std_init( cmap, 1 );\n+    t1_cmap_std_init( t1cmap, 1 );\n@@ -191,2 +197,2 @@\n-  t1_cmap_custom_init( T1_CMapCustom  cmap,\n-                       FT_Pointer     pointer )\n+  t1_cmap_custom_init( FT_CMap     cmap,     \/* T1_CMapCustom *\/\n+                       FT_Pointer  pointer )\n@@ -194,2 +200,3 @@\n-    T1_Face      face     = (T1_Face)FT_CMAP_FACE( cmap );\n-    T1_Encoding  encoding = &face->type1.encoding;\n+    T1_CMapCustom  t1cmap   = (T1_CMapCustom)cmap;\n+    T1_Face        face     = (T1_Face)FT_CMAP_FACE( cmap );\n+    T1_Encoding    encoding = &face->type1.encoding;\n@@ -200,3 +207,3 @@\n-    cmap->first   = (FT_UInt)encoding->code_first;\n-    cmap->count   = (FT_UInt)encoding->code_last - cmap->first;\n-    cmap->indices = encoding->char_index;\n+    t1cmap->first   = (FT_UInt)encoding->code_first;\n+    t1cmap->count   = (FT_UInt)encoding->code_last - t1cmap->first;\n+    t1cmap->indices = encoding->char_index;\n@@ -204,1 +211,1 @@\n-    FT_ASSERT( cmap->indices );\n+    FT_ASSERT( t1cmap->indices );\n@@ -212,1 +219,1 @@\n-  t1_cmap_custom_done( T1_CMapCustom  cmap )\n+  t1_cmap_custom_done( FT_CMap  cmap )   \/* T1_CMapCustom *\/\n@@ -214,3 +221,6 @@\n-    cmap->indices = NULL;\n-    cmap->first   = 0;\n-    cmap->count   = 0;\n+    T1_CMapCustom  t1cmap = (T1_CMapCustom)cmap;\n+\n+\n+    t1cmap->indices = NULL;\n+    t1cmap->first   = 0;\n+    t1cmap->count   = 0;\n@@ -221,2 +231,2 @@\n-  t1_cmap_custom_char_index( T1_CMapCustom  cmap,\n-                             FT_UInt32      char_code )\n+  t1_cmap_custom_char_index( FT_CMap    cmap,       \/* T1_CMapCustom *\/\n+                             FT_UInt32  char_code )\n@@ -224,1 +234,2 @@\n-    FT_UInt    result = 0;\n+    T1_CMapCustom  t1cmap = (T1_CMapCustom)cmap;\n+    FT_UInt        result = 0;\n@@ -227,3 +238,3 @@\n-    if ( ( char_code >= cmap->first )                  &&\n-         ( char_code < ( cmap->first + cmap->count ) ) )\n-      result = cmap->indices[char_code];\n+    if ( char_code >= t1cmap->first                    &&\n+         char_code < ( t1cmap->first + t1cmap->count ) )\n+      result = t1cmap->indices[char_code];\n@@ -235,3 +246,3 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  t1_cmap_custom_char_next( T1_CMapCustom  cmap,\n-                            FT_UInt32     *pchar_code )\n+  FT_CALLBACK_DEF( FT_UInt )\n+  t1_cmap_custom_char_next( FT_CMap     cmap,        \/* T1_CMapCustom *\/\n+                            FT_UInt32  *pchar_code )\n@@ -239,2 +250,3 @@\n-    FT_UInt    result = 0;\n-    FT_UInt32  char_code = *pchar_code;\n+    T1_CMapCustom  t1cmap    = (T1_CMapCustom)cmap;\n+    FT_UInt        result    = 0;\n+    FT_UInt32      char_code = *pchar_code;\n@@ -245,2 +257,2 @@\n-    if ( char_code < cmap->first )\n-      char_code = cmap->first;\n+    if ( char_code < t1cmap->first )\n+      char_code = t1cmap->first;\n@@ -248,1 +260,1 @@\n-    for ( ; char_code < ( cmap->first + cmap->count ); char_code++ )\n+    for ( ; char_code < ( t1cmap->first + t1cmap->count ); char_code++ )\n@@ -250,1 +262,1 @@\n-      result = cmap->indices[char_code];\n+      result = t1cmap->indices[char_code];\n@@ -290,1 +302,1 @@\n-  psaux_get_glyph_name( T1_Face  face,\n+  psaux_get_glyph_name( void*    face_,\n@@ -293,0 +305,3 @@\n+    T1_Face  face = (T1_Face)face_;\n+\n+\n@@ -298,2 +313,2 @@\n-  t1_cmap_unicode_init( PS_Unicodes  unicodes,\n-                        FT_Pointer   pointer )\n+  t1_cmap_unicode_init( FT_CMap     cmap,     \/* PS_Unicodes *\/\n+                        FT_Pointer  pointer )\n@@ -301,3 +316,4 @@\n-    T1_Face             face    = (T1_Face)FT_CMAP_FACE( unicodes );\n-    FT_Memory           memory  = FT_FACE_MEMORY( face );\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    T1_Face             face     = (T1_Face)FT_CMAP_FACE( cmap );\n+    FT_Memory           memory   = FT_FACE_MEMORY( face );\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)face->psnames;\n@@ -314,1 +330,1 @@\n-                                   (PS_GetGlyphNameFunc)&psaux_get_glyph_name,\n+                                   &psaux_get_glyph_name,\n@@ -321,1 +337,1 @@\n-  t1_cmap_unicode_done( PS_Unicodes  unicodes )\n+  t1_cmap_unicode_done( FT_CMap  cmap )   \/* PS_Unicodes *\/\n@@ -323,2 +339,3 @@\n-    FT_Face    face   = FT_CMAP_FACE( unicodes );\n-    FT_Memory  memory = FT_FACE_MEMORY( face );\n+    PS_Unicodes  unicodes = (PS_Unicodes)cmap;\n+    FT_Face      face     = FT_CMAP_FACE( cmap );\n+    FT_Memory    memory   = FT_FACE_MEMORY( face );\n@@ -333,2 +350,2 @@\n-  t1_cmap_unicode_char_index( PS_Unicodes  unicodes,\n-                              FT_UInt32    char_code )\n+  t1_cmap_unicode_char_index( FT_CMap    cmap,       \/* PS_Unicodes *\/\n+                              FT_UInt32  char_code )\n@@ -336,2 +353,3 @@\n-    T1_Face             face    = (T1_Face)FT_CMAP_FACE( unicodes );\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    T1_Face             face     = (T1_Face)FT_CMAP_FACE( cmap );\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)face->psnames;\n@@ -344,3 +362,3 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  t1_cmap_unicode_char_next( PS_Unicodes  unicodes,\n-                             FT_UInt32   *pchar_code )\n+  FT_CALLBACK_DEF( FT_UInt )\n+  t1_cmap_unicode_char_next( FT_CMap     cmap,        \/* PS_Unicodes *\/\n+                             FT_UInt32  *pchar_code )\n@@ -348,2 +366,3 @@\n-    T1_Face             face    = (T1_Face)FT_CMAP_FACE( unicodes );\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    T1_Face             face     = (T1_Face)FT_CMAP_FACE( cmap );\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)face->psnames;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/t1cmap.c","additions":81,"deletions":62,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/t1cmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n@@ -30,0 +30,1 @@\n+\n@@ -31,1 +32,3 @@\n-#define Fix2Int( f )  ( (FT_Int)(FT_Short)( (f) >> 16 ) )\n+#define Fix2Int( f )   ( (FT_Int) (FT_Short)( (f) >> 16 ) )\n+#define Fix2UInt( f )  ( (FT_UInt)(FT_Short)( (f) >> 16 ) )\n+\n@@ -520,1 +523,1 @@\n-        FT_TRACE5(( \" (%d)\", decoder->top - decoder->stack ));\n+        FT_TRACE5(( \" (%td)\", decoder->top - decoder->stack ));\n@@ -1028,1 +1031,1 @@\n-            FT_Int    idx;\n+            FT_UInt   idx;\n@@ -1035,1 +1038,1 @@\n-            idx = Fix2Int( top[1] );\n+            idx = Fix2UInt( top[1] );\n@@ -1037,1 +1040,1 @@\n-            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )\n+            if ( idx >= decoder->len_buildchar )\n@@ -1049,1 +1052,1 @@\n-            FT_Int    idx;\n+            FT_UInt   idx;\n@@ -1056,1 +1059,1 @@\n-            idx = Fix2Int( top[0] );\n+            idx = Fix2UInt( top[0] );\n@@ -1058,1 +1061,1 @@\n-            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )\n+            if ( idx >= decoder->len_buildchar )\n@@ -1165,1 +1168,1 @@\n-                        \" (seen %d, expected %d)\\n\",\n+                        \" (seen %td, expected %d)\\n\",\n@@ -1167,1 +1170,1 @@\n-            break;\n+          break;\n@@ -1212,1 +1215,1 @@\n-              FT_TRACE4(( \"%d \", decoder->buildchar[i] ));\n+              FT_TRACE4(( \"%ld \", decoder->buildchar[i] ));\n@@ -1653,1 +1656,2 @@\n-    FT_TRACE4(( \"..end..\\n\\n\" ));\n+    FT_TRACE4(( \"..end..\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -2073,1 +2077,2 @@\n-    FT_TRACE4(( \"..end..\\n\\n\" ));\n+    FT_TRACE4(( \"..end..\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/t1decode.c","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psaux\/t1decode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -185,3 +185,3 @@\n-    if ( FT_NEW_ARRAY( table->sort,  2 * count     ) ||\n-         FT_NEW_ARRAY( table->hints,     count     ) ||\n-         FT_NEW_ARRAY( table->zones, 2 * count + 1 ) )\n+    if ( FT_QNEW_ARRAY( table->sort,  2 * count     ) ||\n+         FT_QNEW_ARRAY( table->hints,     count     ) ||\n+         FT_QNEW_ARRAY( table->zones, 2 * count + 1 ) )\n@@ -191,1 +191,1 @@\n-    table->sort_global = table->sort + count;\n+    table->sort_global = FT_OFFSET( table->sort, count );\n@@ -308,1 +308,1 @@\n-      FT_Int     i1, i2;\n+      FT_UInt    i1, i2;\n@@ -315,1 +315,1 @@\n-      for ( i1 = 1; i1 < (FT_Int)count; i1++ )\n+      for ( i1 = 1; i1 < count; i1++ )\n@@ -318,1 +318,2 @@\n-        for ( i2 = i1 - 1; i2 >= 0; i2-- )\n+        \/* this loop stops when i2 wraps around after reaching 0 *\/\n+        for ( i2 = i1 - 1; i2 < i1; i2-- )\n@@ -518,1 +519,1 @@\n-            \/* keep original relation between hints, this is, use the *\/\n+            \/* keep original relation between hints, that is, use the *\/\n@@ -872,1 +873,1 @@\n-#endif \/* DEBUG_HINTER*\/\n+#endif \/* DEBUG_HINTER *\/\n@@ -1052,1 +1053,1 @@\n-  static int\n+  static PSH_Dir\n@@ -1056,2 +1057,2 @@\n-    FT_Pos  ax, ay;\n-    int     result = PSH_DIR_NONE;\n+    FT_Pos   ax, ay;\n+    PSH_Dir  result = PSH_DIR_NONE;\n@@ -1120,1 +1121,1 @@\n-    char*       tags  = glyph->outline->tags;\n+    FT_Byte*    tags  = glyph->outline->tags;\n@@ -1169,2 +1170,2 @@\n-    if ( FT_NEW_ARRAY( glyph->points,   outline->n_points   ) ||\n-         FT_NEW_ARRAY( glyph->contours, outline->n_contours ) )\n+    if ( FT_QNEW_ARRAY( glyph->points,   outline->n_points   ) ||\n+         FT_QNEW_ARRAY( glyph->contours, outline->n_contours ) )\n@@ -1173,2 +1174,2 @@\n-    glyph->num_points   = (FT_UInt)outline->n_points;\n-    glyph->num_contours = (FT_UInt)outline->n_contours;\n+    glyph->num_points   = outline->n_points;\n+    glyph->num_contours = outline->n_contours;\n@@ -1188,1 +1189,1 @@\n-        next  = (FT_UInt)outline->contours[n] + 1;\n+        next  = outline->contours[n] + 1;\n@@ -1230,0 +1231,1 @@\n+        point->flags = 0;\n@@ -1231,1 +1233,1 @@\n-          point->flags = PSH_POINT_OFF;\n+          psh_point_set_off( point );\n@@ -1236,1 +1238,1 @@\n-        point->dir_in = (FT_Char)psh_compute_dir( dxi, dyi );\n+        point->dir_in = psh_compute_dir( dxi, dyi );\n@@ -1241,1 +1243,1 @@\n-        point->dir_out = (FT_Char)psh_compute_dir( dxo, dyo );\n+        point->dir_out = psh_compute_dir( dxo, dyo );\n@@ -1244,2 +1246,2 @@\n-        if ( point->flags & PSH_POINT_OFF )\n-          point->flags |= PSH_POINT_SMOOTH;\n+        if ( psh_point_is_off( point ) )\n+          psh_point_set_smooth( point );\n@@ -1251,1 +1253,1 @@\n-            point->flags |= PSH_POINT_SMOOTH;\n+            psh_point_set_smooth( point );\n@@ -1406,4 +1408,1 @@\n-  \/* major_dir is the direction for points on the bottom\/left of the stem; *\/\n-  \/* Points on the top\/right of the stem will have a direction of          *\/\n-  \/* -major_dir.                                                           *\/\n-\n+  \/* the min and max are based on contour orientation and fill rule *\/\n@@ -1415,1 +1414,1 @@\n-                                     FT_Int          major_dir )\n+                                     PSH_Dir         major_dir )\n@@ -1423,2 +1422,2 @@\n-      FT_Int  point_dir = 0;\n-      FT_Pos  org_u     = point->org_u;\n+      PSH_Dir  point_dir;\n+      FT_Pos   org_u = point->org_u;\n@@ -1430,5 +1429,2 @@\n-      if ( PSH_DIR_COMPARE( point->dir_in, major_dir ) )\n-        point_dir = point->dir_in;\n-\n-      else if ( PSH_DIR_COMPARE( point->dir_out, major_dir ) )\n-        point_dir = point->dir_out;\n+      point_dir =\n+        (PSH_Dir)( ( point->dir_in | point->dir_out ) & major_dir );\n@@ -1436,1 +1432,1 @@\n-      if ( point_dir )\n+      if ( point_dir & ( PSH_DIR_DOWN | PSH_DIR_RIGHT ) )\n@@ -1438,3 +1434,1 @@\n-        if ( point_dir == major_dir )\n-        {\n-          FT_UInt  nn;\n+        FT_UInt  nn;\n@@ -1443,4 +1437,4 @@\n-          for ( nn = 0; nn < num_hints; nn++ )\n-          {\n-            PSH_Hint  hint = sort[nn];\n-            FT_Pos    d    = org_u - hint->org_pos;\n+        for ( nn = 0; nn < num_hints; nn++ )\n+        {\n+          PSH_Hint  hint = sort[nn];\n+          FT_Pos    d    = org_u - hint->org_pos;\n@@ -1449,7 +1443,6 @@\n-            if ( d < threshold && -d < threshold )\n-            {\n-              psh_point_set_strong( point );\n-              point->flags2 |= PSH_POINT_EDGE_MIN;\n-              point->hint    = hint;\n-              break;\n-            }\n+          if ( d < threshold && -d < threshold )\n+          {\n+            psh_point_set_strong( point );\n+            point->flags2 |= PSH_POINT_EDGE_MIN;\n+            point->hint    = hint;\n+            break;\n@@ -1458,3 +1451,4 @@\n-        else if ( point_dir == -major_dir )\n-        {\n-          FT_UInt  nn;\n+      }\n+      else if ( point_dir & ( PSH_DIR_UP | PSH_DIR_LEFT ) )\n+      {\n+        FT_UInt  nn;\n@@ -1463,4 +1457,4 @@\n-          for ( nn = 0; nn < num_hints; nn++ )\n-          {\n-            PSH_Hint  hint = sort[nn];\n-            FT_Pos    d    = org_u - hint->org_pos - hint->org_len;\n+        for ( nn = 0; nn < num_hints; nn++ )\n+        {\n+          PSH_Hint  hint = sort[nn];\n+          FT_Pos    d    = org_u - hint->org_pos - hint->org_len;\n@@ -1469,7 +1463,6 @@\n-            if ( d < threshold && -d < threshold )\n-            {\n-              psh_point_set_strong( point );\n-              point->flags2 |= PSH_POINT_EDGE_MAX;\n-              point->hint    = hint;\n-              break;\n-            }\n+          if ( d < threshold && -d < threshold )\n+          {\n+            psh_point_set_strong( point );\n+            point->flags2 |= PSH_POINT_EDGE_MAX;\n+            point->hint    = hint;\n+            break;\n@@ -1558,2 +1551,3 @@\n-  \/* the maximum shift value in font units *\/\n-#define PSH_STRONG_THRESHOLD_MAXIMUM  30\n+  \/* the maximum shift value in font units tuned to distinguish *\/\n+  \/* between stems and serifs in URW+ font collection           *\/\n+#define PSH_STRONG_THRESHOLD_MAXIMUM  12\n@@ -1574,1 +1568,1 @@\n-    FT_Int          major_dir = ( dimension == 0 ) ? PSH_DIR_VERTICAL\n+    PSH_Dir         major_dir = ( dimension == 0 ) ? PSH_DIR_VERTICAL\n@@ -1659,2 +1653,2 @@\n-      if ( !PSH_DIR_COMPARE( point->dir_in,  PSH_DIR_HORIZONTAL ) &&\n-           !PSH_DIR_COMPARE( point->dir_out, PSH_DIR_HORIZONTAL ) )\n+      if ( !( point->dir_in  & PSH_DIR_HORIZONTAL ) &&\n+           !( point->dir_out & PSH_DIR_HORIZONTAL ) )\n@@ -1808,1 +1802,1 @@\n-      if ( FT_NEW_ARRAY( strongs, num_strongs ) )\n+      if ( FT_QNEW_ARRAY( strongs, num_strongs ) )\n@@ -2121,2 +2115,2 @@\n-      FT_Fixed  scaled;\n-      FT_Fixed  fitted;\n+      FT_Fixed  scaled = 0;\n+      FT_Fixed  fitted = 0;\n@@ -2127,2 +2121,5 @@\n-      scaled = FT_MulFix( globals->blues.normal_top.zones->org_ref, y_scale );\n-      fitted = FT_PIX_ROUND( scaled );\n+      if ( globals->blues.normal_top.count )\n+      {\n+        scaled = FT_MulFix( globals->blues.normal_top.zones->org_ref, y_scale );\n+        fitted = FT_PIX_ROUND( scaled );\n+      }\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshalgo.c","additions":73,"deletions":76,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -96,1 +96,1 @@\n-  enum\n+  typedef enum PSH_Dir_\n@@ -98,6 +98,7 @@\n-    PSH_DIR_NONE  =  4,\n-    PSH_DIR_UP    = -1,\n-    PSH_DIR_DOWN  =  1,\n-    PSH_DIR_LEFT  = -2,\n-    PSH_DIR_RIGHT =  2\n-  };\n+    PSH_DIR_NONE       = 0,\n+    PSH_DIR_UP         = 1,\n+    PSH_DIR_DOWN       = 2,\n+    PSH_DIR_VERTICAL   = 1 | 2,\n+    PSH_DIR_LEFT       = 4,\n+    PSH_DIR_RIGHT      = 8,\n+    PSH_DIR_HORIZONTAL = 4 | 8\n@@ -105,6 +106,1 @@\n-#define PSH_DIR_HORIZONTAL  2\n-#define PSH_DIR_VERTICAL    1\n-\n-#define PSH_DIR_COMPARE( d1, d2 )   ( (d1) == (d2) || (d1) == -(d2) )\n-#define PSH_DIR_IS_HORIZONTAL( d )  PSH_DIR_COMPARE( d, PSH_DIR_HORIZONTAL )\n-#define PSH_DIR_IS_VERTICAL( d )    PSH_DIR_COMPARE( d, PSH_DIR_VERTICAL )\n+  } PSH_Dir;\n@@ -163,2 +159,2 @@\n-    FT_Char      dir_in;\n-    FT_Char      dir_out;\n+    PSH_Dir      dir_in;\n+    PSH_Dir      dir_out;\n@@ -202,4 +198,0 @@\n-    FT_Bool            vertical;\n-    FT_Int             major_dir;\n-    FT_Int             minor_dir;\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshalgo.h","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -653,1 +653,1 @@\n-    if ( !FT_NEW( globals ) )\n+    if ( !FT_QNEW( globals ) )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshglob.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshglob.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -40,1 +40,1 @@\n-  ps_hinter_done( PS_Hinter_Module  module )\n+  ps_hinter_done( FT_Module  module_ )    \/* PS_Hinter_Module *\/\n@@ -42,0 +42,3 @@\n+    PS_Hinter_Module  module = (PS_Hinter_Module)module_;\n+\n+\n@@ -51,1 +54,1 @@\n-  ps_hinter_init( PS_Hinter_Module  module )\n+  ps_hinter_init( FT_Module  module_ )    \/* PS_Hinter_Module *\/\n@@ -53,0 +56,2 @@\n+    PS_Hinter_Module  module = (PS_Hinter_Module)module_;\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshmod.c","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshnterr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n@@ -66,1 +66,1 @@\n-    FT_Error  error   = FT_Err_Ok;\n+    FT_Error  error;\n@@ -69,7 +69,5 @@\n-    if ( new_max > old_max )\n-    {\n-      \/* try to grow the table *\/\n-      new_max = FT_PAD_CEIL( new_max, 8 );\n-      if ( !FT_RENEW_ARRAY( table->hints, old_max, new_max ) )\n-        table->max_hints = new_max;\n-    }\n+    \/* try to grow the table *\/\n+    new_max = FT_PAD_CEIL( new_max, 8 );\n+    if ( !FT_QRENEW_ARRAY( table->hints, old_max, new_max ) )\n+      table->max_hints = new_max;\n+\n@@ -93,1 +91,1 @@\n-    if ( count >= table->max_hints )\n+    if ( count > table->max_hints )\n@@ -100,4 +98,1 @@\n-    hint        = table->hints + count - 1;\n-    hint->pos   = 0;\n-    hint->len   = 0;\n-    hint->flags = 0;\n+    hint = table->hints + count - 1;  \/* initialized upstream *\/\n@@ -139,2 +134,2 @@\n-    FT_UInt   old_max = ( mask->max_bits + 7 ) >> 3;\n-    FT_UInt   new_max = ( count          + 7 ) >> 3;\n+    FT_UInt   old_max = mask->max_bits >> 3;\n+    FT_UInt   new_max = ( count + 7 ) >> 3;\n@@ -147,0 +142,1 @@\n+      \/* added bytes are zeroed here *\/\n@@ -157,1 +153,1 @@\n-                    FT_Int   idx )\n+                    FT_UInt  idx )\n@@ -159,1 +155,1 @@\n-    if ( (FT_UInt)idx >= mask->num_bits )\n+    if ( idx >= mask->num_bits )\n@@ -166,16 +162,0 @@\n-  \/* clear a given bit *\/\n-  static void\n-  ps_mask_clear_bit( PS_Mask  mask,\n-                     FT_UInt  idx )\n-  {\n-    FT_Byte*  p;\n-\n-\n-    if ( idx >= mask->num_bits )\n-      return;\n-\n-    p    = mask->bytes + ( idx >> 3 );\n-    p[0] = (FT_Byte)( p[0] & ~( 0x80 >> ( idx & 7 ) ) );\n-  }\n-\n-\n@@ -272,0 +252,4 @@\n+    \/* reused mask must be cleared *\/\n+    if ( mask->max_bits )\n+      FT_MEM_ZERO( mask->bytes, mask->max_bits >> 3 );\n+\n@@ -429,1 +413,1 @@\n-      FT_Int   delta;\n+      FT_UInt  delta;\n@@ -440,1 +424,1 @@\n-        \/* first bitset, and clear the highest bits                  *\/\n+        \/* first bitset                                              *\/\n@@ -447,2 +431,1 @@\n-          for ( pos = count1; pos < count2; pos++ )\n-            ps_mask_clear_bit( mask1, pos );\n+          mask1->num_bits = count2;\n@@ -470,1 +453,1 @@\n-      delta = (FT_Int)( table->num_masks - 1 - index2 );\n+      delta = table->num_masks - 1 - index2;\n@@ -479,1 +462,1 @@\n-                    (FT_UInt)delta * sizeof ( PS_MaskRec ) );\n+                    delta * sizeof ( PS_MaskRec ) );\n@@ -502,1 +485,1 @@\n-    FT_Int    index1, index2;\n+    FT_UInt   index1, index2;\n@@ -506,2 +489,2 @@\n-    \/* both loops go down to 0, thus FT_Int for index1 and index2 *\/\n-    for ( index1 = (FT_Int)table->num_masks - 1; index1 > 0; index1-- )\n+    \/* the loops stop when unsigned indices wrap around after 0 *\/\n+    for ( index1 = table->num_masks - 1; index1 < table->num_masks; index1-- )\n@@ -509,1 +492,1 @@\n-      for ( index2 = index1 - 1; index2 >= 0; index2-- )\n+      for ( index2 = index1 - 1; index2 < index1; index2-- )\n@@ -511,3 +494,1 @@\n-        if ( ps_mask_table_test_intersect( table,\n-                                           (FT_UInt)index1,\n-                                           (FT_UInt)index2 ) )\n+        if ( ps_mask_table_test_intersect( table, index1, index2 ) )\n@@ -515,4 +496,1 @@\n-          error = ps_mask_table_merge( table,\n-                                       (FT_UInt)index2,\n-                                       (FT_UInt)index1,\n-                                       memory );\n+          error = ps_mask_table_merge( table, index2, index1, memory );\n@@ -655,1 +633,1 @@\n-                           FT_Int       *aindex )\n+                           FT_UInt      *aindex )\n@@ -673,3 +651,0 @@\n-    if ( aindex )\n-      *aindex = -1;\n-\n@@ -712,1 +687,1 @@\n-        *aindex = (FT_Int)idx;\n+        *aindex = idx;\n@@ -723,3 +698,3 @@\n-                            FT_Int        hint1,\n-                            FT_Int        hint2,\n-                            FT_Int        hint3,\n+                            FT_UInt       hint1,\n+                            FT_UInt       hint2,\n+                            FT_UInt       hint3,\n@@ -752,6 +727,3 @@\n-    if ( hint1 >= 0 )\n-    {\n-      error = ps_mask_set_bit( counter, (FT_UInt)hint1, memory );\n-      if ( error )\n-        goto Exit;\n-    }\n+    error = ps_mask_set_bit( counter, hint1, memory );\n+    if ( error )\n+      goto Exit;\n@@ -759,6 +731,3 @@\n-    if ( hint2 >= 0 )\n-    {\n-      error = ps_mask_set_bit( counter, (FT_UInt)hint2, memory );\n-      if ( error )\n-        goto Exit;\n-    }\n+    error = ps_mask_set_bit( counter, hint2, memory );\n+    if ( error )\n+      goto Exit;\n@@ -766,6 +735,3 @@\n-    if ( hint3 >= 0 )\n-    {\n-      error = ps_mask_set_bit( counter, (FT_UInt)hint3, memory );\n-      if ( error )\n-        goto Exit;\n-    }\n+    error = ps_mask_set_bit( counter, hint3, memory );\n+    if ( error )\n+      goto Exit;\n@@ -802,1 +768,1 @@\n-  FT_LOCAL( void )\n+  FT_LOCAL_DEF( void )\n@@ -816,1 +782,1 @@\n-  FT_LOCAL( void )\n+  FT_LOCAL_DEF( void )\n@@ -843,1 +809,1 @@\n-                 FT_Long*  stems )\n+                 FT_Pos*   stems )\n@@ -888,1 +854,1 @@\n-  ps_hints_t1stem3( PS_Hints   hints,\n+  ps_hints_t1stem3( T1_Hints   hints_,    \/* PS_Hints *\/\n@@ -892,0 +858,1 @@\n+    PS_Hints  hints = (PS_Hints)hints_;\n@@ -900,1 +867,1 @@\n-      FT_Int        idx[3];\n+      FT_UInt       idx[3];\n@@ -951,1 +918,1 @@\n-  ps_hints_t1reset( PS_Hints  hints,\n+  ps_hints_t1reset( T1_Hints  hints_,     \/* PS_Hints *\/\n@@ -954,0 +921,1 @@\n+    PS_Hints  hints = (PS_Hints)hints_;\n@@ -990,1 +958,1 @@\n-  ps_hints_t2mask( PS_Hints        hints,\n+  ps_hints_t2mask( T2_Hints        hints_,    \/* PS_Hints *\/\n@@ -995,0 +963,1 @@\n+    PS_Hints  hints = (PS_Hints)hints_;\n@@ -1036,1 +1005,1 @@\n-  ps_hints_t2counter( PS_Hints        hints,\n+  ps_hints_t2counter( T2_Hints        hints_,    \/* PS_Hints *\/\n@@ -1040,0 +1009,1 @@\n+    PS_Hints  hints = (PS_Hints)hints_;\n@@ -1124,0 +1094,7 @@\n+  static FT_Error\n+  t1_hints_close( T1_Hints  hints,\n+                  FT_UInt   end_point )\n+  {\n+    return ps_hints_close( (PS_Hints)hints, end_point );\n+  }\n+\n@@ -1139,0 +1116,10 @@\n+  static FT_Error\n+  t1_hints_apply( T1_Hints        hints,\n+                  FT_Outline*     outline,\n+                  PSH_Globals     globals,\n+                  FT_Render_Mode  hint_mode )\n+  {\n+    return ps_hints_apply( (PS_Hints)hints, outline, globals, hint_mode );\n+  }\n+\n+\n@@ -1145,1 +1132,1 @@\n-    funcs->close = (T1_Hints_CloseFunc)   ps_hints_close;\n+    funcs->close = (T1_Hints_CloseFunc)   t1_hints_close;\n@@ -1149,1 +1136,1 @@\n-    funcs->apply = (T1_Hints_ApplyFunc)   ps_hints_apply;\n+    funcs->apply = (T1_Hints_ApplyFunc)   t1_hints_apply;\n@@ -1168,0 +1155,8 @@\n+  static FT_Error\n+  t2_hints_close( T2_Hints  hints,\n+                  FT_UInt   end_point )\n+  {\n+    return ps_hints_close( (PS_Hints)hints, end_point );\n+  }\n+\n+\n@@ -1205,0 +1200,10 @@\n+  static FT_Error\n+  t2_hints_apply( T2_Hints        hints,\n+                  FT_Outline*     outline,\n+                  PSH_Globals     globals,\n+                  FT_Render_Mode  hint_mode )\n+  {\n+    return ps_hints_apply( (PS_Hints)hints, outline, globals, hint_mode );\n+  }\n+\n+\n@@ -1210,6 +1215,6 @@\n-    funcs->open    = (T2_Hints_OpenFunc)   t2_hints_open;\n-    funcs->close   = (T2_Hints_CloseFunc)  ps_hints_close;\n-    funcs->stems   = (T2_Hints_StemsFunc)  t2_hints_stems;\n-    funcs->hintmask= (T2_Hints_MaskFunc)   ps_hints_t2mask;\n-    funcs->counter = (T2_Hints_CounterFunc)ps_hints_t2counter;\n-    funcs->apply   = (T2_Hints_ApplyFunc)  ps_hints_apply;\n+    funcs->open     = (T2_Hints_OpenFunc)   t2_hints_open;\n+    funcs->close    = (T2_Hints_CloseFunc)  t2_hints_close;\n+    funcs->stems    = (T2_Hints_StemsFunc)  t2_hints_stems;\n+    funcs->hintmask = (T2_Hints_MaskFunc)   ps_hints_t2mask;\n+    funcs->counter  = (T2_Hints_CounterFunc)ps_hints_t2counter;\n+    funcs->apply    = (T2_Hints_ApplyFunc)  t2_hints_apply;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshrec.c","additions":98,"deletions":93,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/pshinter\/pshrec.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -60,1 +60,1 @@\n-  static FT_UInt32\n+  FT_CALLBACK_DEF( FT_UInt32 )\n@@ -158,2 +158,3 @@\n-      const char*  p   = glyph_name;\n-      const char*  dot = NULL;\n+      FT_UInt32    value = 0;\n+      const char*  p     = glyph_name;\n+\n@@ -161,0 +162,2 @@\n+      for ( ; *p && *p != '.'; p++ )\n+        ;\n@@ -162,1 +165,3 @@\n-      for ( ; *p; p++ )\n+      \/* now look up the glyph in the Adobe Glyph List;      *\/\n+      \/* `.notdef', `.null' and the empty name are short cut *\/\n+      if ( p > glyph_name )\n@@ -164,5 +169,4 @@\n-        if ( *p == '.' && p > glyph_name )\n-        {\n-          dot = p;\n-          break;\n-        }\n+        value = (FT_UInt32)ft_get_adobe_glyph_index( glyph_name, p );\n+\n+        if ( *p == '.' )\n+          value |= (FT_UInt32)VARIANT_BIT;\n@@ -171,6 +175,1 @@\n-      \/* now look up the glyph in the Adobe Glyph List *\/\n-      if ( !dot )\n-        return (FT_UInt32)ft_get_adobe_glyph_index( glyph_name, p );\n-      else\n-        return (FT_UInt32)( ft_get_adobe_glyph_index( glyph_name, dot ) |\n-                            VARIANT_BIT );\n+      return value;\n@@ -182,1 +181,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -313,1 +312,1 @@\n-  static FT_Error\n+  FT_CALLBACK_DEF( FT_Error )\n@@ -329,1 +328,0 @@\n-    table->maps     = NULL;\n@@ -331,1 +329,1 @@\n-    if ( !FT_NEW_ARRAY( table->maps, num_glyphs + EXTRA_GLYPH_LIST_SIZE ) )\n+    if ( !FT_QNEW_ARRAY( table->maps, num_glyphs + EXTRA_GLYPH_LIST_SIZE ) )\n@@ -346,1 +344,1 @@\n-        if ( gname )\n+        if ( gname && *gname )\n@@ -394,3 +392,3 @@\n-          (void)FT_RENEW_ARRAY( table->maps,\n-                                num_glyphs + EXTRA_GLYPH_LIST_SIZE,\n-                                count );\n+          FT_MEM_QRENEW_ARRAY( table->maps,\n+                               num_glyphs + EXTRA_GLYPH_LIST_SIZE,\n+                               count );\n@@ -413,1 +411,1 @@\n-  static FT_UInt\n+  FT_CALLBACK_DEF( FT_UInt )\n@@ -417,1 +415,4 @@\n-    PS_UniMap  *min, *max, *mid, *result = NULL;\n+    PS_UniMap  *result = NULL;\n+    PS_UniMap  *min = table->maps;\n+    PS_UniMap  *max = min + table->num_maps;\n+    PS_UniMap  *mid = min + ( ( max - min ) >> 1 );\n@@ -421,5 +422,1 @@\n-\n-    min = table->maps;\n-    max = min + table->num_maps - 1;\n-\n-    while ( min <= max )\n+    while ( min < max )\n@@ -430,2 +427,0 @@\n-      mid = min + ( ( max - min ) >> 1 );\n-\n@@ -443,3 +438,0 @@\n-      if ( min == max )\n-        break;\n-\n@@ -449,1 +441,6 @@\n-        max = mid - 1;\n+        max = mid;\n+\n+      \/* reasonable prediction in a continuous block *\/\n+      mid += unicode - base_glyph;\n+      if ( mid >= max || mid < min )\n+        mid = min + ( ( max - min ) >> 1 );\n@@ -459,1 +456,1 @@\n-  static FT_UInt32\n+  FT_CALLBACK_DEF( FT_UInt )\n@@ -470,1 +467,1 @@\n-      FT_UInt     mid;\n+      FT_UInt     mid = min + ( ( max - min ) >> 1 );\n@@ -477,1 +474,0 @@\n-        mid = min + ( ( max - min ) >> 1 );\n@@ -495,0 +491,5 @@\n+\n+        \/* reasonable prediction in a continuous block *\/\n+        mid += char_code - base_glyph;\n+        if ( mid >= max || mid < min )\n+          mid = min + ( max - min ) \/ 2;\n@@ -520,1 +521,1 @@\n-  static const char*\n+  FT_CALLBACK_DEF( const char* )\n@@ -530,1 +531,1 @@\n-  static const char*\n+  FT_CALLBACK_DEF( const char* )\n@@ -545,4 +546,4 @@\n-    (PS_Unicode_ValueFunc)     ps_unicode_value,        \/* unicode_value         *\/\n-    (PS_Unicodes_InitFunc)     ps_unicodes_init,        \/* unicodes_init         *\/\n-    (PS_Unicodes_CharIndexFunc)ps_unicodes_char_index,  \/* unicodes_char_index   *\/\n-    (PS_Unicodes_CharNextFunc) ps_unicodes_char_next,   \/* unicodes_char_next    *\/\n+    ps_unicode_value,         \/* PS_Unicode_ValueFunc      unicode_value         *\/\n+    ps_unicodes_init,         \/* PS_Unicodes_InitFunc      unicodes_init         *\/\n+    ps_unicodes_char_index,   \/* PS_Unicodes_CharIndexFunc unicodes_char_index   *\/\n+    ps_unicodes_char_next,    \/* PS_Unicodes_CharNextFunc  unicodes_char_next    *\/\n@@ -550,2 +551,2 @@\n-    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,   \/* macintosh_name        *\/\n-    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings, \/* adobe_std_strings     *\/\n+    ps_get_macintosh_name,    \/* PS_Macintosh_NameFunc     macintosh_name        *\/\n+    ps_get_standard_strings,  \/* PS_Adobe_Std_StringsFunc  adobe_std_strings     *\/\n@@ -562,4 +563,4 @@\n-    NULL,                                               \/* unicode_value         *\/\n-    NULL,                                               \/* unicodes_init         *\/\n-    NULL,                                               \/* unicodes_char_index   *\/\n-    NULL,                                               \/* unicodes_char_next    *\/\n+    NULL,                     \/* PS_Unicode_ValueFunc      unicode_value         *\/\n+    NULL,                     \/* PS_Unicodes_InitFunc      unicodes_init         *\/\n+    NULL,                     \/* PS_Unicodes_CharIndexFunc unicodes_char_index   *\/\n+    NULL,                     \/* PS_Unicodes_CharNextFunc  unicodes_char_next    *\/\n@@ -567,2 +568,2 @@\n-    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,   \/* macintosh_name        *\/\n-    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings, \/* adobe_std_strings     *\/\n+    ps_get_macintosh_name,    \/* PS_Macintosh_NameFunc     macintosh_name        *\/\n+    ps_get_standard_strings,  \/* PS_Adobe_Std_StringsFunc  adobe_std_strings     *\/\n@@ -614,3 +615,3 @@\n-    (FT_Module_Constructor)NULL,                                       \/* module_init   *\/\n-    (FT_Module_Destructor) NULL,                                       \/* module_done   *\/\n-    (FT_Module_Requester)  PUT_PS_NAMES_SERVICE( psnames_get_service ) \/* get_interface *\/\n+    NULL,                                        \/* FT_Module_Constructor module_init   *\/\n+    NULL,                                        \/* FT_Module_Destructor  module_done   *\/\n+    PUT_PS_NAMES_SERVICE( psnames_get_service )  \/* FT_Module_Requester   get_interface *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psnames\/psmodule.c","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psnames\/psmodule.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psnames\/psnamerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/psnames\/pstables.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2024 by\n@@ -50,5 +50,2 @@\n-#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 ) \\\n-          ( ( (FT_ULong)_x1 << 24 ) |     \\\n-            ( (FT_ULong)_x2 << 16 ) |     \\\n-            ( (FT_ULong)_x3 <<  8 ) |     \\\n-              (FT_ULong)_x4         )\n+\n+#define FT_STATIC_BYTE_CAST( type, var )  (type)(FT_Byte)(var)\n@@ -98,21 +95,0 @@\n-  static FT_Long\n-  FT_MulDiv( FT_Long  a,\n-             FT_Long  b,\n-             FT_Long  c )\n-  {\n-    FT_Int   s;\n-    FT_Long  d;\n-\n-\n-    s = 1;\n-    if ( a < 0 ) { a = -a; s = -1; }\n-    if ( b < 0 ) { b = -b; s = -s; }\n-    if ( c < 0 ) { c = -c; s = -s; }\n-\n-    d = (FT_Long)( c > 0 ? ( (FT_Int64)a * b + ( c >> 1 ) ) \/ c\n-                         : 0x7FFFFFFFL );\n-\n-    return ( s > 0 ) ? d : -d;\n-  }\n-\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/raster\/ftmisc.h","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -66,2 +66,1 @@\n-#include <freetype\/internal\/ftcalc.h> \/* for FT_MulDiv and FT_MulDiv_No_Round *\/\n-#include <freetype\/ftoutln.h>         \/* for FT_Outline_Get_CBox              *\/\n+#include <freetype\/internal\/ftcalc.h> \/* for FT_MulDiv_No_Round *\/\n@@ -118,6 +117,6 @@\n-   *   Note that when all profiles have been generated, the function\n-   *   Finalize_Profile_Table() is used to record, for each profile, its\n-   *   bottom-most scanline as well as the scanline above its upmost\n-   *   boundary.  These positions are called `y-turns' because they (sort\n-   *   of) correspond to local extrema.  They are stored in a sorted list\n-   *   built from the top of the render pool as a downwards stack:\n+   *   Note that, for all generated profiles, the function End_Profile()\n+   *   is used to record all their bottom-most scanlines as well as the\n+   *   scanline above their upmost boundary.  These positions are called\n+   *   `y-turns' because they (sort of) correspond to local extrema.\n+   *   They are stored in a sorted list built from the top of the render\n+   *   pool as a downwards stack:\n@@ -139,1 +138,1 @@\n-   *   handles the situation properly.\n+   *   handles the situation by bisecting the job and restarting.\n@@ -152,3 +151,0 @@\n-  \/* define DEBUG_RASTER if you want to compile a debugging version *\/\n-\/* #define DEBUG_RASTER *\/\n-\n@@ -203,6 +199,7 @@\n-#define Raster_Err_None          0\n-#define Raster_Err_Not_Ini      -1\n-#define Raster_Err_Overflow     -2\n-#define Raster_Err_Neg_Height   -3\n-#define Raster_Err_Invalid      -4\n-#define Raster_Err_Unsupported  -5\n+#define Raster_Err_Ok                       0\n+#define Raster_Err_Invalid_Outline         -1\n+#define Raster_Err_Cannot_Render_Glyph     -2\n+#define Raster_Err_Invalid_Argument        -3\n+#define Raster_Err_Raster_Overflow         -4\n+#define Raster_Err_Raster_Uninitialized    -5\n+#define Raster_Err_Raster_Negative_Height  -6\n@@ -233,7 +230,0 @@\n-#define Raster_Err_None         FT_Err_Ok\n-#define Raster_Err_Not_Ini      Raster_Err_Raster_Uninitialized\n-#define Raster_Err_Overflow     Raster_Err_Raster_Overflow\n-#define Raster_Err_Neg_Height   Raster_Err_Raster_Negative_Height\n-#define Raster_Err_Invalid      Raster_Err_Invalid_Outline\n-#define Raster_Err_Unsupported  Raster_Err_Cannot_Render_Glyph\n-\n@@ -264,1 +254,0 @@\n-#define SMulDiv           FT_MulDiv\n@@ -317,10 +306,0 @@\n-\n-  typedef union  Alignment_\n-  {\n-    Long    l;\n-    void*   p;\n-    void  (*f)(void);\n-\n-  } Alignment, *PAlignment;\n-\n-\n@@ -339,0 +318,1 @@\n+#define Dropout           0x40U\n@@ -357,1 +337,0 @@\n-    FT_F26Dot6  X;           \/* current coordinate during sweep          *\/\n@@ -359,1 +338,6 @@\n-    PLong       offset;      \/* start of profile's data in render pool   *\/\n+    PProfile    next;        \/* next profile in same contour, used       *\/\n+                             \/* during drop-out control                  *\/\n+    Int         offset;      \/* bottom or currently scanned array index  *\/\n+    Int         height;      \/* profile's height in scanlines            *\/\n+    Int         start;       \/* profile's starting scanline, also use    *\/\n+                             \/* as activation counter                    *\/\n@@ -364,2 +348,1 @@\n-    Long        height;      \/* profile's height in scanlines            *\/\n-    Long        start;       \/* profile's starting scanline              *\/\n+                             \/* Bit 6: dropout detected                  *\/\n@@ -367,5 +350,3 @@\n-    Int         countL;      \/* number of lines to step before this      *\/\n-                             \/* profile becomes drawable                 *\/\n-\n-    PProfile    next;        \/* next profile in same contour, used       *\/\n-                             \/* during drop-out control                  *\/\n+    FT_F26Dot6  X;           \/* current coordinate during sweep          *\/\n+    Long        x[1];        \/* actually variable array of scanline      *\/\n+                             \/* intersections with `height` elements     *\/\n@@ -378,14 +359,0 @@\n-  \/* Simple record used to implement a stack of bands, required *\/\n-  \/* by the sub-banding mechanism                               *\/\n-  typedef struct  black_TBand_\n-  {\n-    Short  y_min;   \/* band's minimum *\/\n-    Short  y_max;   \/* band's maximum *\/\n-\n-  } black_TBand;\n-\n-\n-#define AlignProfileSize \\\n-  ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) \/ sizeof ( Long ) )\n-\n-\n@@ -429,2 +396,2 @@\n-  Function_Sweep_Init( RAS_ARGS Short*  min,\n-                                Short*  max );\n+  Function_Sweep_Init( RAS_ARGS Int  min,\n+                                Int  max );\n@@ -433,1 +400,1 @@\n-  Function_Sweep_Span( RAS_ARGS Short       y,\n+  Function_Sweep_Span( RAS_ARGS Int         y,\n@@ -435,3 +402,1 @@\n-                                FT_F26Dot6  x2,\n-                                PProfile    left,\n-                                PProfile    right );\n+                                FT_F26Dot6  x2 );\n@@ -463,2 +428,1 @@\n-  \/* To mimick Windows, symmetric cases break down indepenently of the  *\/\n-  \/* precision.                                                         *\/\n+  \/* To mimic Windows, symmetric cases do not depend on the precision.  *\/\n@@ -484,1 +448,0 @@\n-    Int         precision_jitter;\n@@ -493,6 +456,1 @@\n-    Int         numTurns;           \/* number of Y-turns in outline        *\/\n-\n-    TPoint*     arc;                \/* current Bezier arc pointer          *\/\n-\n-    UShort      bWidth;             \/* target bitmap width                 *\/\n-    PByte       bOrigin;            \/* target bitmap bottom-left origin    *\/\n+    Byte        dropOutControl;     \/* current drop_out control method     *\/\n@@ -504,0 +462,1 @@\n+    Int         numTurns;           \/* number of Y-turns in outline        *\/\n@@ -505,5 +464,0 @@\n-    Bool        fresh;              \/* signals a fresh new profile which   *\/\n-                                    \/* `start' field must be completed     *\/\n-    Bool        joint;              \/* signals that the last arc ended     *\/\n-                                    \/* exactly on a scanline.  Allows      *\/\n-                                    \/* removal of doublets                 *\/\n@@ -517,1 +471,0 @@\n-    FT_Bitmap   target;             \/* description of target bit\/pixmap    *\/\n@@ -520,2 +473,5 @@\n-    Long        traceOfs;           \/* current offset in target bitmap     *\/\n-    Short       traceIncr;          \/* sweep's increment in target bitmap  *\/\n+    Int         bTop;               \/* target bitmap max line  index       *\/\n+    Int         bRight;             \/* target bitmap rightmost index       *\/\n+    Int         bPitch;             \/* target bitmap pitch                 *\/\n+    PByte       bOrigin;            \/* target bitmap bottom-left origin    *\/\n+    PByte       bLine;              \/* target bitmap current line          *\/\n@@ -530,12 +486,0 @@\n-    Byte        dropOutControl;     \/* current drop_out control method     *\/\n-\n-    Bool        second_pass;        \/* indicates whether a horizontal pass *\/\n-                                    \/* should be performed to control      *\/\n-                                    \/* drop-out accurately when calling    *\/\n-                                    \/* Render_Glyph.                       *\/\n-\n-    TPoint      arcs[3 * MaxBezier + 1]; \/* The Bezier stack               *\/\n-\n-    black_TBand  band_stack[16];    \/* band stack used for sub-banding     *\/\n-    Int          band_top;          \/* band stack top                      *\/\n-\n@@ -599,8 +543,0 @@\n-     * `precision_jitter' is an epsilon threshold used in\n-     * `Vertical_Sweep_Span' to deal with small imperfections in the Bezier\n-     * decomposition (after all, we are working with approximations only);\n-     * it avoids switching on additional pixels which would cause artifacts\n-     * otherwise.\n-     *\n-     * The value of `precision_jitter' has been determined heuristically.\n-     *\n@@ -613,1 +549,0 @@\n-      ras.precision_jitter = 30;\n@@ -619,1 +554,0 @@\n-      ras.precision_jitter = 2;\n@@ -622,2 +556,0 @@\n-    FT_TRACE6(( \"Set_High_Precision(%s)\\n\", High ? \"true\" : \"false\" ));\n-\n@@ -630,0 +562,57 @@\n+  \/**************************************************************************\n+   *\n+   * @Function:\n+   *   Insert_Y_Turn\n+   *\n+   * @Description:\n+   *   Insert a salient into the sorted list placed on top of the render\n+   *   pool.\n+   *\n+   * @Input:\n+   *   New y scanline position.\n+   *\n+   * @Return:\n+   *   SUCCESS on success.  FAILURE in case of overflow.\n+   *\/\n+  static Bool\n+  Insert_Y_Turns( RAS_ARGS Int  y,\n+                           Int  top )\n+  {\n+    Int    n       = ras.numTurns;\n+    PLong  y_turns = ras.maxBuff;\n+\n+\n+    \/* update top value *\/\n+    if ( n == 0 || top > y_turns[n] )\n+      y_turns[n] = top;\n+\n+    \/* look for first y value that is <= *\/\n+    while ( n-- && y < y_turns[n] )\n+      ;\n+\n+    \/* if it is <, simply insert it, ignore if == *\/\n+    if ( n < 0 || y > y_turns[n] )\n+    {\n+      ras.maxBuff--;\n+      if ( ras.maxBuff <= ras.top )\n+      {\n+        ras.error = FT_THROW( Raster_Overflow );\n+        return FAILURE;\n+      }\n+\n+      do\n+      {\n+        Int  y2 = (Int)y_turns[n];\n+\n+\n+        y_turns[n] = y;\n+        y = y2;\n+      } while ( n-- >= 0 );\n+\n+      ras.numTurns++;\n+    }\n+\n+    return SUCCESS;\n+  }\n+\n+\n@@ -642,4 +631,0 @@\n-   *   overshoot ::\n-   *     Whether the profile's unrounded start position\n-   *     differs by at least a half pixel.\n-   *\n@@ -651,2 +636,1 @@\n-  New_Profile( RAS_ARGS TStates  aState,\n-                        Bool     overshoot )\n+  New_Profile( RAS_ARGS TStates  aState )\n@@ -654,1 +638,4 @@\n-    if ( !ras.fProfile )\n+    Long  e;\n+\n+\n+    if ( !ras.cProfile || ras.cProfile->height )\n@@ -657,3 +644,1 @@\n-      ras.fProfile  = ras.cProfile;\n-      ras.top      += AlignProfileSize;\n-    }\n+      ras.top       = ras.cProfile->x;\n@@ -661,4 +646,8 @@\n-    if ( ras.top >= ras.maxBuff )\n-    {\n-      ras.error = FT_THROW( Overflow );\n-      return FAILURE;\n+      if ( ras.top >= ras.maxBuff )\n+      {\n+        FT_TRACE1(( \"overflow in New_Profile\\n\" ));\n+        ras.error = FT_THROW( Raster_Overflow );\n+        return FAILURE;\n+      }\n+\n+      ras.cProfile->height = 0;\n@@ -667,5 +656,0 @@\n-    ras.cProfile->start  = 0;\n-    ras.cProfile->height = 0;\n-    ras.cProfile->offset = ras.top;\n-    ras.cProfile->link   = (PProfile)0;\n-    ras.cProfile->next   = (PProfile)0;\n@@ -678,1 +662,1 @@\n-      if ( overshoot )\n+      if ( IS_BOTTOM_OVERSHOOT( ras.lastY ) )\n@@ -681,1 +665,1 @@\n-      FT_TRACE6(( \"  new ascending profile = %p\\n\", (void *)ras.cProfile ));\n+      e = CEILING( ras.lastY );\n@@ -685,1 +669,1 @@\n-      if ( overshoot )\n+      if ( IS_TOP_OVERSHOOT( ras.lastY ) )\n@@ -687,1 +671,2 @@\n-      FT_TRACE6(( \"  new descending profile = %p\\n\", (void *)ras.cProfile ));\n+\n+      e = FLOOR( ras.lastY );\n@@ -692,1 +677,1 @@\n-      ras.error = FT_THROW( Invalid );\n+      ras.error = FT_THROW( Invalid_Outline );\n@@ -696,2 +681,12 @@\n-    if ( !ras.gProfile )\n-      ras.gProfile = ras.cProfile;\n+    if ( e > ras.maxY )\n+      e = ras.maxY;\n+    if ( e < ras.minY )\n+      e = ras.minY;\n+    ras.cProfile->start = (Int)TRUNC( e );\n+\n+    FT_TRACE7(( \"  new %s profile = %p, start = %d\\n\",\n+                aState == Ascending_State ? \"ascending\" : \"descending\",\n+                (void *)ras.cProfile, ras.cProfile->start ));\n+\n+    if ( ras.lastY == e )\n+      *ras.top++ = ras.lastX;\n@@ -700,2 +695,0 @@\n-    ras.fresh = TRUE;\n-    ras.joint = FALSE;\n@@ -713,6 +706,1 @@\n-   *   Finalize the current profile.\n-   *\n-   * @Input:\n-   *   overshoot ::\n-   *     Whether the profile's unrounded end position differs\n-   *     by at least a half pixel.\n+   *   Finalize the current profile and record y-turns.\n@@ -724,1 +712,1 @@\n-  End_Profile( RAS_ARGS Bool  overshoot )\n+  End_Profile( RAS_ARG )\n@@ -726,2 +714,3 @@\n-    Long  h;\n-\n+    PProfile  p = ras.cProfile;\n+    Int       h = (Int)( ras.top - p->x );\n+    Int       bottom, top;\n@@ -729,1 +718,0 @@\n-    h = (Long)( ras.top - ras.cProfile->offset );\n@@ -734,1 +722,1 @@\n-      ras.error = FT_THROW( Neg_Height );\n+      ras.error = FT_THROW( Raster_Negative_Height );\n@@ -740,1 +728,2 @@\n-      PProfile  oldProfile;\n+      FT_TRACE7(( \"  ending profile %p, start = %2d, height = %+3d\\n\",\n+                  (void *)p, p->start, p->flags & Flow_Up ? h : -h ));\n@@ -742,0 +731,1 @@\n+      p->height = h;\n@@ -743,2 +733,4 @@\n-      FT_TRACE6(( \"  ending profile %p, start = %ld, height = %ld\\n\",\n-                  (void *)ras.cProfile, ras.cProfile->start, h ));\n+      if ( p->flags & Flow_Up )\n+      {\n+        if ( IS_TOP_OVERSHOOT( ras.lastY ) )\n+          p->flags |= Overshoot_Top;\n@@ -746,2 +738,6 @@\n-      ras.cProfile->height = h;\n-      if ( overshoot )\n+        bottom    = p->start;\n+        top       = bottom + h;\n+        p->offset = 0;\n+        p->X      = p->x[0];\n+      }\n+      else\n@@ -749,4 +745,8 @@\n-        if ( ras.cProfile->flags & Flow_Up )\n-          ras.cProfile->flags |= Overshoot_Top;\n-        else\n-          ras.cProfile->flags |= Overshoot_Bottom;\n+        if ( IS_BOTTOM_OVERSHOOT( ras.lastY ) )\n+          p->flags |= Overshoot_Bottom;\n+\n+        top       = p->start + 1;\n+        bottom    = top - h;\n+        p->start  = bottom;\n+        p->offset = h - 1;\n+        p->X      = p->x[h - 1];\n@@ -755,2 +755,2 @@\n-      oldProfile   = ras.cProfile;\n-      ras.cProfile = (PProfile)ras.top;\n+      if ( Insert_Y_Turns( RAS_VARS bottom, top ) )\n+        return FAILURE;\n@@ -758,1 +758,2 @@\n-      ras.top += AlignProfileSize;\n+      if ( !ras.gProfile )\n+        ras.gProfile = p;\n@@ -760,2 +761,3 @@\n-      ras.cProfile->height = 0;\n-      ras.cProfile->offset = ras.top;\n+      \/* preliminary values to be finalized *\/\n+      p->next = ras.gProfile;\n+      p->link = (PProfile)ras.top;\n@@ -763,1 +765,0 @@\n-      oldProfile->next = ras.cProfile;\n@@ -767,65 +768,0 @@\n-    if ( ras.top >= ras.maxBuff )\n-    {\n-      FT_TRACE1(( \"overflow in End_Profile\\n\" ));\n-      ras.error = FT_THROW( Overflow );\n-      return FAILURE;\n-    }\n-\n-    ras.joint = FALSE;\n-\n-    return SUCCESS;\n-  }\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @Function:\n-   *   Insert_Y_Turn\n-   *\n-   * @Description:\n-   *   Insert a salient into the sorted list placed on top of the render\n-   *   pool.\n-   *\n-   * @Input:\n-   *   New y scanline position.\n-   *\n-   * @Return:\n-   *   SUCCESS on success.  FAILURE in case of overflow.\n-   *\/\n-  static Bool\n-  Insert_Y_Turn( RAS_ARGS Int  y )\n-  {\n-    PLong  y_turns;\n-    Int    n;\n-\n-\n-    n       = ras.numTurns - 1;\n-    y_turns = ras.sizeBuff - ras.numTurns;\n-\n-    \/* look for first y value that is <= *\/\n-    while ( n >= 0 && y < y_turns[n] )\n-      n--;\n-\n-    \/* if it is <, simply insert it, ignore if == *\/\n-    if ( n >= 0 && y > y_turns[n] )\n-      do\n-      {\n-        Int  y2 = (Int)y_turns[n];\n-\n-\n-        y_turns[n] = y;\n-        y = y2;\n-      } while ( --n >= 0 );\n-\n-    if ( n < 0 )\n-    {\n-      ras.maxBuff--;\n-      if ( ras.maxBuff <= ras.top )\n-      {\n-        ras.error = FT_THROW( Overflow );\n-        return FAILURE;\n-      }\n-      ras.numTurns++;\n-      ras.sizeBuff[-ras.numTurns] = y;\n-    }\n-\n@@ -843,3 +779,0 @@\n-   *\n-   * @Return:\n-   *   SUCCESS on success.  FAILURE in case of overflow.\n@@ -847,1 +780,1 @@\n-  static Bool\n+  static void\n@@ -850,2 +783,3 @@\n-    UShort    n;\n-    PProfile  p;\n+    UShort    n = ras.num_Profs;\n+    PProfile  p = ras.fProfile;\n+    PProfile  q;\n@@ -854,4 +788,2 @@\n-    n = ras.num_Profs;\n-    p = ras.fProfile;\n-\n-    if ( n > 1 && p )\n+    \/* there should be at least two profiles, up and down *\/\n+    while ( --n )\n@@ -859,22 +791,1 @@\n-      do\n-      {\n-        Int  bottom, top;\n-\n-\n-        if ( n > 1 )\n-          p->link = (PProfile)( p->offset + p->height );\n-        else\n-          p->link = NULL;\n-\n-        if ( p->flags & Flow_Up )\n-        {\n-          bottom = (Int)p->start;\n-          top    = (Int)( p->start + p->height - 1 );\n-        }\n-        else\n-        {\n-          bottom     = (Int)( p->start - p->height + 1 );\n-          top        = (Int)p->start;\n-          p->start   = bottom;\n-          p->offset += p->height - 1;\n-        }\n+      q = p->link;\n@@ -882,3 +793,3 @@\n-        if ( Insert_Y_Turn( RAS_VARS bottom )  ||\n-             Insert_Y_Turn( RAS_VARS top + 1 ) )\n-          return FAILURE;\n+      \/* fix the contour loop *\/\n+      if ( q->next == p->next )\n+        p->next = q;\n@@ -886,2 +797,1 @@\n-        p = p->link;\n-      } while ( --n );\n+      p = q;\n@@ -889,2 +799,0 @@\n-    else\n-      ras.fProfile = NULL;\n@@ -892,1 +800,2 @@\n-    return SUCCESS;\n+    \/* null-terminate *\/\n+    p->link = NULL;\n@@ -1022,3 +931,3 @@\n-    Long   Dx, Dy;\n-    Int    e1, e2, f1, f2, size;     \/* XXX: is `Short' sufficient? *\/\n-    Long   Ix, Rx, Ax;\n+    Long  e, e2, Dx, Dy;\n+    Long  Ix, Rx, Ax;\n+    Int   size;\n@@ -1029,4 +938,1 @@\n-    Dx = x2 - x1;\n-    Dy = y2 - y1;\n-\n-    if ( Dy <= 0 || y2 < miny || y1 > maxy )\n+    if ( y2 < miny || y1 > maxy )\n@@ -1035,25 +941,2 @@\n-    if ( y1 < miny )\n-    {\n-      \/* Take care: miny-y1 can be a very large value; we use     *\/\n-      \/*            a slow MulDiv function to avoid clipping bugs *\/\n-      x1 += SMulDiv( Dx, miny - y1, Dy );\n-      e1  = (Int)TRUNC( miny );\n-      f1  = 0;\n-    }\n-    else\n-    {\n-      e1 = (Int)TRUNC( y1 );\n-      f1 = (Int)FRAC( y1 );\n-    }\n-\n-    if ( y2 > maxy )\n-    {\n-      \/* x2 += FMulDiv( Dx, maxy - y2, Dy );  UNNECESSARY *\/\n-      e2  = (Int)TRUNC( maxy );\n-      f2  = 0;\n-    }\n-    else\n-    {\n-      e2 = (Int)TRUNC( y2 );\n-      f2 = (Int)FRAC( y2 );\n-    }\n+    e2 = y2 > maxy ? maxy : FLOOR( y2 );\n+    e  = y1 < miny ? miny : CEILING( y1 );\n@@ -1061,16 +944,2 @@\n-    if ( f1 > 0 )\n-    {\n-      if ( e1 == e2 )\n-        return SUCCESS;\n-      else\n-      {\n-        x1 += SMulDiv( Dx, ras.precision - f1, Dy );\n-        e1 += 1;\n-      }\n-    }\n-    else\n-      if ( ras.joint )\n-      {\n-        ras.top--;\n-        ras.joint = FALSE;\n-      }\n+    if ( y1 == e )\n+      e += ras.precision;\n@@ -1078,1 +947,2 @@\n-    ras.joint = (char)( f2 == 0 );\n+    if ( e2 < e )  \/* nothing to do *\/\n+      return SUCCESS;\n@@ -1080,5 +950,2 @@\n-    if ( ras.fresh )\n-    {\n-      ras.cProfile->start = e1;\n-      ras.fresh           = FALSE;\n-    }\n+    size = (Int)TRUNC( e2 - e ) + 1;\n+    top  = ras.top;\n@@ -1086,2 +953,1 @@\n-    size = e2 - e1 + 1;\n-    if ( ras.top + size >= ras.maxBuff )\n+    if ( top + size >= ras.maxBuff )\n@@ -1089,1 +955,1 @@\n-      ras.error = FT_THROW( Overflow );\n+      ras.error = FT_THROW( Raster_Overflow );\n@@ -1093,7 +959,4 @@\n-    if ( Dx > 0 )\n-    {\n-      Ix = SMulDiv_No_Round( ras.precision, Dx, Dy );\n-      Rx = ( ras.precision * Dx ) % Dy;\n-      Dx = 1;\n-    }\n-    else\n+    Dx = x2 - x1;\n+    Dy = y2 - y1;\n+\n+    if ( Dx == 0 )  \/* very easy *\/\n@@ -1101,3 +964,4 @@\n-      Ix = -SMulDiv_No_Round( ras.precision, -Dx, Dy );\n-      Rx = ( ras.precision * -Dx ) % Dy;\n-      Dx = -1;\n+      do\n+        *top++ = x1;\n+      while ( --size );\n+      goto Fin;\n@@ -1106,2 +970,3 @@\n-    Ax  = -Dy;\n-    top = ras.top;\n+    Ix     = SMulDiv_No_Round( e - y1, Dx, Dy );\n+    x1    += Ix;\n+    *top++ = x1;\n@@ -1109,1 +974,1 @@\n-    while ( size > 0 )\n+    if ( --size )\n@@ -1111,1 +976,11 @@\n-      *top++ = x1;\n+      Ax = Dx * ( e - y1 )    - Dy * Ix;  \/* remainder *\/\n+      Ix = FMulDiv( ras.precision, Dx, Dy );\n+      Rx = Dx * ras.precision - Dy * Ix;  \/* remainder *\/\n+      Dx = 1;\n+\n+      if ( x2 < x1 )\n+      {\n+        Ax = -Ax;\n+        Rx = -Rx;\n+        Dx = -Dx;\n+      }\n@@ -1113,3 +988,1 @@\n-      x1 += Ix;\n-      Ax += Rx;\n-      if ( Ax >= 0 )\n+      do\n@@ -1117,2 +990,8 @@\n-        Ax -= Dy;\n-        x1 += Dx;\n+        x1 += Ix;\n+        Ax += Rx;\n+        if ( Ax >= Dy )\n+        {\n+          Ax -= Dy;\n+          x1 += Dx;\n+        }\n+        *top++ = x1;\n@@ -1120,1 +999,1 @@\n-      size--;\n+      while ( --size );\n@@ -1123,0 +1002,1 @@\n+  Fin:\n@@ -1167,11 +1047,1 @@\n-    Bool  result, fresh;\n-\n-\n-    fresh  = ras.fresh;\n-\n-    result = Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );\n-\n-    if ( fresh && !ras.fresh )\n-      ras.cProfile->start = -ras.cProfile->start;\n-\n-    return result;\n+    return Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );\n@@ -1212,0 +1082,1 @@\n+                      TPoint*    arc,\n@@ -1216,2 +1087,2 @@\n-    Long   y1, y2, e, e2, e0;\n-    Short  f1;\n+    Long  y1, y2, e, e2, dy;\n+    Long  dx, x2;\n@@ -1219,4 +1090,1 @@\n-    TPoint*  arc;\n-    TPoint*  start_arc;\n-\n-    PLong top;\n+    PLong  top;\n@@ -1225,1 +1093,0 @@\n-    arc = ras.arc;\n@@ -1228,1 +1095,0 @@\n-    top = ras.top;\n@@ -1231,24 +1097,1 @@\n-      goto Fin;\n-\n-    e2 = FLOOR( y2 );\n-\n-    if ( e2 > maxy )\n-      e2 = maxy;\n-\n-    e0 = miny;\n-\n-    if ( y1 < miny )\n-      e = miny;\n-    else\n-    {\n-      e  = CEILING( y1 );\n-      f1 = (Short)( FRAC( y1 ) );\n-      e0 = e;\n-\n-      if ( f1 == 0 )\n-      {\n-        if ( ras.joint )\n-        {\n-          top--;\n-          ras.joint = FALSE;\n-        }\n+      return SUCCESS;\n@@ -1256,1 +1099,2 @@\n-        *top++ = arc[degree].x;\n+    e2 = y2 > maxy ? maxy : FLOOR( y2 );\n+    e  = y1 < miny ? miny : CEILING( y1 );\n@@ -1258,3 +1102,2 @@\n-        e += ras.precision;\n-      }\n-    }\n+    if ( y1 == e )\n+      e += ras.precision;\n@@ -1262,5 +1105,2 @@\n-    if ( ras.fresh )\n-    {\n-      ras.cProfile->start = TRUNC( e0 );\n-      ras.fresh = FALSE;\n-    }\n+    if ( e2 < e )  \/* nothing to do *\/\n+      return SUCCESS;\n@@ -1268,2 +1108,1 @@\n-    if ( e2 < e )\n-      goto Fin;\n+    top = ras.top;\n@@ -1273,2 +1112,1 @@\n-      ras.top   = top;\n-      ras.error = FT_THROW( Overflow );\n+      ras.error = FT_THROW( Raster_Overflow );\n@@ -1278,2 +1116,0 @@\n-    start_arc = arc;\n-\n@@ -1282,2 +1118,0 @@\n-      ras.joint = FALSE;\n-\n@@ -1285,0 +1119,1 @@\n+      x2 = arc[0].x;\n@@ -1288,2 +1123,7 @@\n-        y1 = arc[degree].y;\n-        if ( y2 - y1 >= ras.precision_step )\n+        dy = y2 - arc[degree].y;\n+        dx = x2 - arc[degree].x;\n+\n+        \/* split condition should be invariant of direction *\/\n+        if (  dy > ras.precision_step ||\n+              dx > ras.precision_step ||\n+             -dx > ras.precision_step )\n@@ -1296,2 +1136,2 @@\n-          *top++ = arc[degree].x + FMulDiv( arc[0].x - arc[degree].x,\n-                                            e - y1, y2 - y1 );\n+          *top++ = x2 - FMulDiv( y2 - e, dx, dy );\n+          e     += ras.precision;\n@@ -1299,1 +1139,0 @@\n-          e   += ras.precision;\n@@ -1306,4 +1145,2 @@\n-          ras.joint  = TRUE;\n-          *top++     = arc[0].x;\n-\n-          e += ras.precision;\n+          *top++ = x2;\n+          e     += ras.precision;\n@@ -1311,1 +1148,1 @@\n-        arc -= degree;\n+        arc   -= degree;\n@@ -1313,1 +1150,2 @@\n-    } while ( arc >= start_arc && e <= e2 );\n+    }\n+    while ( e <= e2 );\n@@ -1315,3 +1153,1 @@\n-  Fin:\n-    ras.top  = top;\n-    ras.arc -= degree;\n+    ras.top = top;\n@@ -1349,0 +1185,1 @@\n+                        TPoint*    arc,\n@@ -1353,2 +1190,1 @@\n-    TPoint*  arc = ras.arc;\n-    Bool     result, fresh;\n+    Bool  result;\n@@ -1363,6 +1199,1 @@\n-    fresh = ras.fresh;\n-\n-    result = Bezier_Up( RAS_VARS degree, splitter, -maxy, -miny );\n-\n-    if ( fresh && !ras.fresh )\n-      ras.cProfile->start = -ras.cProfile->start;\n+    result = Bezier_Up( RAS_VARS degree, arc, splitter, -maxy, -miny );\n@@ -1400,1 +1231,1 @@\n-    \/* First, detect a change of direction *\/\n+    TStates  state;\n@@ -1402,17 +1233,0 @@\n-    switch ( ras.state )\n-    {\n-    case Unknown_State:\n-      if ( y > ras.lastY )\n-      {\n-        if ( New_Profile( RAS_VARS Ascending_State,\n-                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )\n-          return FAILURE;\n-      }\n-      else\n-      {\n-        if ( y < ras.lastY )\n-          if ( New_Profile( RAS_VARS Descending_State,\n-                                     IS_TOP_OVERSHOOT( ras.lastY ) ) )\n-            return FAILURE;\n-      }\n-      break;\n@@ -1420,9 +1234,2 @@\n-    case Ascending_State:\n-      if ( y < ras.lastY )\n-      {\n-        if ( End_Profile( RAS_VARS IS_TOP_OVERSHOOT( ras.lastY ) ) ||\n-             New_Profile( RAS_VARS Descending_State,\n-                                   IS_TOP_OVERSHOOT( ras.lastY ) ) )\n-          return FAILURE;\n-      }\n-      break;\n+    if ( y == ras.lastY )\n+      goto Fin;\n@@ -1430,9 +1237,1 @@\n-    case Descending_State:\n-      if ( y > ras.lastY )\n-      {\n-        if ( End_Profile( RAS_VARS IS_BOTTOM_OVERSHOOT( ras.lastY ) ) ||\n-             New_Profile( RAS_VARS Ascending_State,\n-                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )\n-          return FAILURE;\n-      }\n-      break;\n+    \/* First, detect a change of direction *\/\n@@ -1440,2 +1239,12 @@\n-    default:\n-      ;\n+    state = ras.lastY < y ? Ascending_State : Descending_State;\n+\n+    if ( ras.state != state )\n+    {\n+      \/* finalize current profile if any *\/\n+      if ( ras.state != Unknown_State &&\n+           End_Profile( RAS_VAR )     )\n+        goto Fail;\n+\n+      \/* create a new profile *\/\n+      if ( New_Profile( RAS_VARS state ) )\n+        goto Fail;\n@@ -1446,1 +1255,1 @@\n-    switch ( ras.state )\n+    if ( state == Ascending_State )\n@@ -1448,1 +1257,0 @@\n-    case Ascending_State:\n@@ -1451,4 +1259,4 @@\n-        return FAILURE;\n-      break;\n-\n-    case Descending_State:\n+        goto Fail;\n+    }\n+    else\n+    {\n@@ -1457,5 +1265,1 @@\n-        return FAILURE;\n-      break;\n-\n-    default:\n-      ;\n+        goto Fail;\n@@ -1464,0 +1268,1 @@\n+  Fin:\n@@ -1466,1 +1271,0 @@\n-\n@@ -1468,0 +1272,3 @@\n+\n+  Fail:\n+    return FAILURE;\n@@ -1506,0 +1313,2 @@\n+    TPoint   arcs[2 * MaxBezier + 1]; \/* The Bezier stack           *\/\n+    TPoint*  arc;                     \/* current Bezier arc pointer *\/\n@@ -1508,7 +1317,7 @@\n-    ras.arc      = ras.arcs;\n-    ras.arc[2].x = ras.lastX;\n-    ras.arc[2].y = ras.lastY;\n-    ras.arc[1].x = cx;\n-    ras.arc[1].y = cy;\n-    ras.arc[0].x = x;\n-    ras.arc[0].y = y;\n+    arc      = arcs;\n+    arc[2].x = ras.lastX;\n+    arc[2].y = ras.lastY;\n+    arc[1].x = cx;\n+    arc[1].y = cy;\n+    arc[0].x = x;\n+    arc[0].y = y;\n@@ -1518,4 +1327,4 @@\n-      y1 = ras.arc[2].y;\n-      y2 = ras.arc[1].y;\n-      y3 = ras.arc[0].y;\n-      x3 = ras.arc[0].x;\n+      y1 = arc[2].y;\n+      y2 = arc[1].y;\n+      y3 = arc[0].y;\n+      x3 = arc[0].x;\n@@ -1536,1 +1345,1 @@\n-      if ( y2 < ymin || y2 > ymax )\n+      if ( y2 < FLOOR( ymin ) || y2 > CEILING( ymax ) )\n@@ -1539,2 +1348,2 @@\n-        Split_Conic( ras.arc );\n-        ras.arc += 2;\n+        Split_Conic( arc );\n+        arc += 2;\n@@ -1544,2 +1353,6 @@\n-        \/* this arc is flat, ignore it and pop it from the Bezier stack *\/\n-        ras.arc -= 2;\n+        \/* this arc is flat, advance position *\/\n+        \/* and pop it from the Bezier stack   *\/\n+        arc -= 2;\n+\n+        ras.lastX = x3;\n+        ras.lastY = y3;\n@@ -1554,5 +1367,0 @@\n-          Bool  o = ( state_bez == Ascending_State )\n-                      ? IS_BOTTOM_OVERSHOOT( y1 )\n-                      : IS_TOP_OVERSHOOT( y1 );\n-\n-\n@@ -1561,1 +1369,1 @@\n-               End_Profile( RAS_VARS o )  )\n+               End_Profile( RAS_VAR )     )\n@@ -1565,1 +1373,1 @@\n-          if ( New_Profile( RAS_VARS state_bez, o ) )\n+          if ( New_Profile( RAS_VARS state_bez ) )\n@@ -1572,1 +1380,2 @@\n-          if ( Bezier_Up( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Up( RAS_VARS 2, arc, Split_Conic,\n+                                   ras.minY, ras.maxY ) )\n@@ -1576,1 +1385,2 @@\n-          if ( Bezier_Down( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Down( RAS_VARS 2, arc, Split_Conic,\n+                                     ras.minY, ras.maxY ) )\n@@ -1578,1 +1388,1 @@\n-      }\n+        arc -= 2;\n@@ -1580,1 +1390,3 @@\n-    } while ( ras.arc >= ras.arcs );\n+        ras.lastX = x3;\n+        ras.lastY = y3;\n+      }\n@@ -1582,2 +1394,1 @@\n-    ras.lastX = x3;\n-    ras.lastY = y3;\n+    } while ( arc >= arcs );\n@@ -1635,0 +1446,2 @@\n+    TPoint   arcs[3 * MaxBezier + 1]; \/* The Bezier stack           *\/\n+    TPoint*  arc;                     \/* current Bezier arc pointer *\/\n@@ -1637,9 +1450,9 @@\n-    ras.arc      = ras.arcs;\n-    ras.arc[3].x = ras.lastX;\n-    ras.arc[3].y = ras.lastY;\n-    ras.arc[2].x = cx1;\n-    ras.arc[2].y = cy1;\n-    ras.arc[1].x = cx2;\n-    ras.arc[1].y = cy2;\n-    ras.arc[0].x = x;\n-    ras.arc[0].y = y;\n+    arc      = arcs;\n+    arc[3].x = ras.lastX;\n+    arc[3].y = ras.lastY;\n+    arc[2].x = cx1;\n+    arc[2].y = cy1;\n+    arc[1].x = cx2;\n+    arc[1].y = cy2;\n+    arc[0].x = x;\n+    arc[0].y = y;\n@@ -1649,5 +1462,5 @@\n-      y1 = ras.arc[3].y;\n-      y2 = ras.arc[2].y;\n-      y3 = ras.arc[1].y;\n-      y4 = ras.arc[0].y;\n-      x4 = ras.arc[0].x;\n+      y1 = arc[3].y;\n+      y2 = arc[2].y;\n+      y3 = arc[1].y;\n+      y4 = arc[0].y;\n+      x4 = arc[0].x;\n@@ -1679,1 +1492,1 @@\n-      if ( ymin2 < ymin1 || ymax2 > ymax1 )\n+      if ( ymin2 < FLOOR( ymin1 ) || ymax2 > CEILING( ymax1 ) )\n@@ -1682,2 +1495,2 @@\n-        Split_Cubic( ras.arc );\n-        ras.arc += 3;\n+        Split_Cubic( arc );\n+        arc += 3;\n@@ -1687,2 +1500,6 @@\n-        \/* this arc is flat, ignore it and pop it from the Bezier stack *\/\n-        ras.arc -= 3;\n+        \/* this arc is flat, advance position *\/\n+        \/* and pop it from the Bezier stack   *\/\n+        arc -= 3;\n+\n+        ras.lastX = x4;\n+        ras.lastY = y4;\n@@ -1692,1 +1509,1 @@\n-        state_bez = ( y1 <= y4 ) ? Ascending_State : Descending_State;\n+        state_bez = y1 < y4 ? Ascending_State : Descending_State;\n@@ -1697,5 +1514,0 @@\n-          Bool  o = ( state_bez == Ascending_State )\n-                      ? IS_BOTTOM_OVERSHOOT( y1 )\n-                      : IS_TOP_OVERSHOOT( y1 );\n-\n-\n@@ -1704,1 +1516,1 @@\n-               End_Profile( RAS_VARS o )  )\n+               End_Profile( RAS_VAR )     )\n@@ -1707,1 +1519,1 @@\n-          if ( New_Profile( RAS_VARS state_bez, o ) )\n+          if ( New_Profile( RAS_VARS state_bez ) )\n@@ -1714,1 +1526,2 @@\n-          if ( Bezier_Up( RAS_VARS 3, Split_Cubic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Up( RAS_VARS 3, arc, Split_Cubic,\n+                                   ras.minY, ras.maxY ) )\n@@ -1718,1 +1531,2 @@\n-          if ( Bezier_Down( RAS_VARS 3, Split_Cubic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Down( RAS_VARS 3, arc, Split_Cubic,\n+                                     ras.minY, ras.maxY ) )\n@@ -1720,1 +1534,1 @@\n-      }\n+        arc -= 3;\n@@ -1722,1 +1536,3 @@\n-    } while ( ras.arc >= ras.arcs );\n+        ras.lastX = x4;\n+        ras.lastY = y4;\n+      }\n@@ -1724,2 +1540,1 @@\n-    ras.lastX = x4;\n-    ras.lastY = y4;\n+    } while ( arc >= arcs );\n@@ -1768,0 +1583,5 @@\n+   *\n+   * @Note:\n+   *   Unlike FT_Outline_Decompose(), this function handles the scanmode\n+   *   dropout tags in the individual contours.  Therefore, it cannot be\n+   *   replaced.\n@@ -1770,3 +1590,3 @@\n-  Decompose_Curve( RAS_ARGS UShort  first,\n-                            UShort  last,\n-                            Int     flipped )\n+  Decompose_Curve( RAS_ARGS Int  first,\n+                            Int  last,\n+                            Int  flipped )\n@@ -1781,1 +1601,1 @@\n-    char*       tags;\n+    FT_Byte*    tags;\n@@ -1970,1 +1790,1 @@\n-    ras.error = FT_THROW( Invalid );\n+    ras.error = FT_THROW( Invalid_Outline );\n@@ -1997,2 +1817,2 @@\n-    Int   i;\n-    UInt  start;\n+    Int  i;\n+    Int  first, last;\n@@ -2002,6 +1822,1 @@\n-    ras.joint    = FALSE;\n-    ras.fresh    = FALSE;\n-\n-    ras.maxBuff  = ras.sizeBuff - AlignProfileSize;\n-\n-    ras.numTurns = 0;\n+    ras.cProfile = NULL;\n@@ -2009,3 +1824,2 @@\n-    ras.cProfile         = (PProfile)ras.top;\n-    ras.cProfile->offset = ras.top;\n-    ras.num_Profs        = 0;\n+    ras.top      = ras.buff;\n+    ras.maxBuff  = ras.sizeBuff - 1;  \/* top reserve *\/\n@@ -2013,1 +1827,2 @@\n-    start = 0;\n+    ras.numTurns  = 0;\n+    ras.num_Profs = 0;\n@@ -2015,0 +1830,1 @@\n+    last = -1;\n@@ -2017,4 +1833,0 @@\n-      PProfile  lastProfile;\n-      Bool      o;\n-\n-\n@@ -2024,3 +1836,4 @@\n-      if ( Decompose_Curve( RAS_VARS (UShort)start,\n-                                     (UShort)ras.outline.contours[i],\n-                                     flipped ) )\n+      first = last + 1;\n+      last  = ras.outline.contours[i];\n+\n+      if ( Decompose_Curve( RAS_VARS first, last, flipped ) )\n@@ -2029,1 +1842,4 @@\n-      start = (UShort)ras.outline.contours[i] + 1;\n+      \/* Note that ras.gProfile can stay nil if the contour was *\/\n+      \/* too small to be drawn or degenerate.                   *\/\n+      if ( !ras.gProfile )\n+        continue;\n@@ -2035,2 +1851,1 @@\n-        if ( ras.gProfile                        &&\n-             ( ras.gProfile->flags & Flow_Up ) ==\n+        if ( ( ras.gProfile->flags & Flow_Up ) ==\n@@ -2039,2 +1854,0 @@\n-        \/* Note that ras.gProfile can be nil if the contour was too small *\/\n-        \/* to be drawn.                                                   *\/\n@@ -2042,7 +1855,1 @@\n-      lastProfile = ras.cProfile;\n-      if ( ras.top != ras.cProfile->offset &&\n-           ( ras.cProfile->flags & Flow_Up ) )\n-        o = IS_TOP_OVERSHOOT( ras.lastY );\n-      else\n-        o = IS_BOTTOM_OVERSHOOT( ras.lastY );\n-      if ( End_Profile( RAS_VARS o ) )\n+      if ( End_Profile( RAS_VAR ) )\n@@ -2051,3 +1858,2 @@\n-      \/* close the `next profile in contour' linked list *\/\n-      if ( ras.gProfile )\n-        lastProfile->next = ras.gProfile;\n+      if ( !ras.fProfile )\n+        ras.fProfile = ras.gProfile;\n@@ -2056,2 +1862,2 @@\n-    if ( Finalize_Profile_Table( RAS_VAR ) )\n-      return FAILURE;\n+    if ( ras.fProfile )\n+      Finalize_Profile_Table( RAS_VAR );\n@@ -2059,1 +1865,1 @@\n-    return (Bool)( ras.top < ras.maxBuff ? SUCCESS : FAILURE );\n+    return SUCCESS;\n@@ -2072,13 +1878,0 @@\n-  \/**************************************************************************\n-   *\n-   * Init_Linked\n-   *\n-   *   Initializes an empty linked list.\n-   *\/\n-  static void\n-  Init_Linked( TProfileList*  l )\n-  {\n-    *l = NULL;\n-  }\n-\n-\n@@ -2089,1 +1882,1 @@\n-   *   Inserts a new profile in a linked list.\n+   *   Inserts a new profile in a linked list, sorted by coordinate.\n@@ -2103,1 +1896,1 @@\n-    while ( current )\n+    while ( current && current->X < x )\n@@ -2105,2 +1898,0 @@\n-      if ( x < current->X )\n-        break;\n@@ -2118,1 +1909,1 @@\n-   * DelOld\n+   * Increment\n@@ -2120,1 +1911,5 @@\n-   *   Removes an old profile from a linked list.\n+   *   Advances all profile in the list to the next scanline.  It also\n+   *   sorts the trace list in the unlikely case of profile crossing.\n+   *   The profiles are inserted in sorted order.  We might need a single\n+   *   swap to fix it when profiles (contours) cross.\n+   *   Bubble sort with immediate restart is good enough and simple.\n@@ -2123,2 +1918,2 @@\n-  DelOld( PProfileList  list,\n-          PProfile      profile )\n+  Increment( PProfileList  list,\n+             Int           flow )\n@@ -2126,2 +1921,1 @@\n-    PProfile  *old, current;\n-\n+    PProfile  *old, current, next;\n@@ -2129,2 +1923,0 @@\n-    old     = list;\n-    current = *old;\n@@ -2132,1 +1924,3 @@\n-    while ( current )\n+    \/* First, set the new X coordinates and remove exhausted profiles *\/\n+    old = list;\n+    while ( *old )\n@@ -2134,1 +1928,2 @@\n-      if ( current == profile )\n+      current = *old;\n+      if ( --current->height )\n@@ -2136,2 +1931,3 @@\n-        *old = current->link;\n-        return;\n+        current->offset += flow;\n+        current->X       = current->x[current->offset];\n+        old = &current->link;\n@@ -2139,32 +1935,2 @@\n-\n-      old     = &current->link;\n-      current = *old;\n-    }\n-\n-    \/* we should never get there, unless the profile was not part of *\/\n-    \/* the list.                                                     *\/\n-  }\n-\n-\n-  \/**************************************************************************\n-   *\n-   * Sort\n-   *\n-   *   Sorts a trace list.  In 95%, the list is already sorted.  We need\n-   *   an algorithm which is fast in this case.  Bubble sort is enough\n-   *   and simple.\n-   *\/\n-  static void\n-  Sort( PProfileList  list )\n-  {\n-    PProfile  *old, current, next;\n-\n-\n-    \/* First, set the new X coordinate of each profile *\/\n-    current = *list;\n-    while ( current )\n-    {\n-      current->X       = *current->offset;\n-      current->offset += ( current->flags & Flow_Up ) ? 1 : -1;\n-      current->height--;\n-      current = current->link;\n+      else\n+        *old = current->link;  \/* remove *\/\n@@ -2173,1 +1939,1 @@\n-    \/* Then sort them *\/\n+    \/* Then make sure the list remains sorted *\/\n@@ -2180,3 +1946,1 @@\n-    next = current->link;\n-\n-    while ( next )\n+    while ( current->link )\n@@ -2184,0 +1948,2 @@\n+      next = current->link;\n+\n@@ -2187,4 +1953,1 @@\n-        current = *old;\n-\n-        if ( !current )\n-          return;\n+        current = next;\n@@ -2198,0 +1961,1 @@\n+        \/* this is likely the only necessary swap -- restart *\/\n@@ -2201,2 +1965,0 @@\n-\n-      next = current->link;\n@@ -2217,2 +1979,2 @@\n-  Vertical_Sweep_Init( RAS_ARGS Short*  min,\n-                                Short*  max )\n+  Vertical_Sweep_Init( RAS_ARGS Int  min,\n+                                Int  max )\n@@ -2220,2 +1982,0 @@\n-    Long  pitch = ras.target.pitch;\n-\n@@ -2225,2 +1985,1 @@\n-    ras.traceIncr = (Short)-pitch;\n-    ras.traceOfs  = -*min * pitch;\n+    ras.bLine = ras.bOrigin - min * ras.bPitch;\n@@ -2231,1 +1990,1 @@\n-  Vertical_Sweep_Span( RAS_ARGS Short       y,\n+  Vertical_Sweep_Span( RAS_ARGS Int         y,\n@@ -2233,3 +1992,1 @@\n-                                FT_F26Dot6  x2,\n-                                PProfile    left,\n-                                PProfile    right )\n+                                FT_F26Dot6  x2 )\n@@ -2237,4 +1994,2 @@\n-    Long   e1, e2;\n-    Byte*  target;\n-\n-    Int  dropOutControl = left->flags & 7;\n+    Int  e1 = (Int)TRUNC( CEILING( x1 ) );\n+    Int  e2 = (Int)TRUNC(   FLOOR( x2 ) );\n@@ -2243,2 +1998,0 @@\n-    FT_UNUSED( left );\n-    FT_UNUSED( right );\n@@ -2247,3 +2000,1 @@\n-    \/* in high-precision mode, we need 12 digits after the comma to *\/\n-    \/* represent multiples of 1\/(1<<12) = 1\/4096                    *\/\n-    FT_TRACE7(( \"  y=%d x=[% .12f;% .12f]\",\n+    FT_TRACE7(( \"  y=%d x=[% .*f;% .*f]\",\n@@ -2251,17 +2002,2 @@\n-                x1 \/ (double)ras.precision,\n-                x2 \/ (double)ras.precision ));\n-\n-    \/* Drop-out control *\/\n-\n-    e1 = CEILING( x1 );\n-    e2 = FLOOR( x2 );\n-\n-    \/* take care of the special case where both the left *\/\n-    \/* and right contour lie exactly on pixel centers    *\/\n-    if ( dropOutControl != 2                             &&\n-         x2 - x1 - ras.precision <= ras.precision_jitter &&\n-         e1 != x1 && e2 != x2                            )\n-      e2 = e1;\n-\n-    e1 = TRUNC( e1 );\n-    e2 = TRUNC( e2 );\n+                ras.precision_bits, (double)x1 \/ (double)ras.precision,\n+                ras.precision_bits, (double)x2 \/ (double)ras.precision ));\n@@ -2269,1 +2005,1 @@\n-    if ( e2 >= 0 && e1 < ras.bWidth )\n+    if ( e2 >= 0 && e1 <= ras.bRight )\n@@ -2271,2 +2007,3 @@\n-      Int   c1, c2;\n-      Byte  f1, f2;\n+      PByte  target;\n+\n+      Int   c1, f1, c2, f2;\n@@ -2277,2 +2014,2 @@\n-      if ( e2 >= ras.bWidth )\n-        e2 = ras.bWidth - 1;\n+      if ( e2 > ras.bRight )\n+        e2 = ras.bRight;\n@@ -2280,1 +2017,1 @@\n-      FT_TRACE7(( \" -> x=[%ld;%ld]\", e1, e2 ));\n+      FT_TRACE7(( \" -> x=[%d;%d]\", e1, e2 ));\n@@ -2282,2 +2019,2 @@\n-      c1 = (Short)( e1 >> 3 );\n-      c2 = (Short)( e2 >> 3 );\n+      c1 = e1 >> 3;\n+      c2 = e2 >> 3;\n@@ -2285,2 +2022,2 @@\n-      f1 = (Byte)  ( 0xFF >> ( e1 & 7 ) );\n-      f2 = (Byte) ~( 0x7F >> ( e2 & 7 ) );\n+      f1 =  0xFF >> ( e1 & 7 );\n+      f2 = ~0x7F >> ( e2 & 7 );\n@@ -2288,1 +2025,1 @@\n-      target = ras.bOrigin + ras.traceOfs + c1;\n+      target = ras.bLine + c1;\n@@ -2299,1 +2036,1 @@\n-          *(++target) = 0xFF;\n+          *( ++target ) = 0xFF;\n@@ -2312,1 +2049,1 @@\n-  Vertical_Sweep_Drop( RAS_ARGS Short       y,\n+  Vertical_Sweep_Drop( RAS_ARGS Int         y,\n@@ -2314,3 +2051,1 @@\n-                                FT_F26Dot6  x2,\n-                                PProfile    left,\n-                                PProfile    right )\n+                                FT_F26Dot6  x2 )\n@@ -2318,101 +2053,3 @@\n-    Long   e1, e2, pxl;\n-    Short  c1, f1;\n-\n-\n-    FT_TRACE7(( \"  y=%d x=[% .12f;% .12f]\",\n-                y,\n-                x1 \/ (double)ras.precision,\n-                x2 \/ (double)ras.precision ));\n-\n-    \/* Drop-out control *\/\n-\n-    \/*   e2            x2                    x1           e1   *\/\n-    \/*                                                         *\/\n-    \/*                 ^                     |                 *\/\n-    \/*                 |                     |                 *\/\n-    \/*   +-------------+---------------------+------------+    *\/\n-    \/*                 |                     |                 *\/\n-    \/*                 |                     v                 *\/\n-    \/*                                                         *\/\n-    \/* pixel         contour              contour       pixel  *\/\n-    \/* center                                           center *\/\n-\n-    \/* drop-out mode    scan conversion rules (as defined in OpenType) *\/\n-    \/* --------------------------------------------------------------- *\/\n-    \/*  0                1, 2, 3                                       *\/\n-    \/*  1                1, 2, 4                                       *\/\n-    \/*  2                1, 2                                          *\/\n-    \/*  3                same as mode 2                                *\/\n-    \/*  4                1, 2, 5                                       *\/\n-    \/*  5                1, 2, 6                                       *\/\n-    \/*  6, 7             same as mode 2                                *\/\n-\n-    e1  = CEILING( x1 );\n-    e2  = FLOOR  ( x2 );\n-    pxl = e1;\n-\n-    if ( e1 > e2 )\n-    {\n-      Int  dropOutControl = left->flags & 7;\n-\n-\n-      if ( e1 == e2 + ras.precision )\n-      {\n-        switch ( dropOutControl )\n-        {\n-        case 0: \/* simple drop-outs including stubs *\/\n-          pxl = e2;\n-          break;\n-\n-        case 4: \/* smart drop-outs including stubs *\/\n-          pxl = SMART( x1, x2 );\n-          break;\n-\n-        case 1: \/* simple drop-outs excluding stubs *\/\n-        case 5: \/* smart drop-outs excluding stubs  *\/\n-\n-          \/* Drop-out Control Rules #4 and #6 *\/\n-\n-          \/* The specification neither provides an exact definition *\/\n-          \/* of a `stub' nor gives exact rules to exclude them.     *\/\n-          \/*                                                        *\/\n-          \/* Here the constraints we use to recognize a stub.       *\/\n-          \/*                                                        *\/\n-          \/*  upper stub:                                           *\/\n-          \/*                                                        *\/\n-          \/*   - P_Left and P_Right are in the same contour         *\/\n-          \/*   - P_Right is the successor of P_Left in that contour *\/\n-          \/*   - y is the top of P_Left and P_Right                 *\/\n-          \/*                                                        *\/\n-          \/*  lower stub:                                           *\/\n-          \/*                                                        *\/\n-          \/*   - P_Left and P_Right are in the same contour         *\/\n-          \/*   - P_Left is the successor of P_Right in that contour *\/\n-          \/*   - y is the bottom of P_Left                          *\/\n-          \/*                                                        *\/\n-          \/* We draw a stub if the following constraints are met.   *\/\n-          \/*                                                        *\/\n-          \/*   - for an upper or lower stub, there is top or bottom *\/\n-          \/*     overshoot, respectively                            *\/\n-          \/*   - the covered interval is greater or equal to a half *\/\n-          \/*     pixel                                              *\/\n-\n-          \/* upper stub test *\/\n-          if ( left->next == right                &&\n-               left->height <= 0                  &&\n-               !( left->flags & Overshoot_Top   &&\n-                  x2 - x1 >= ras.precision_half ) )\n-            goto Exit;\n-\n-          \/* lower stub test *\/\n-          if ( right->next == left                 &&\n-               left->start == y                    &&\n-               !( left->flags & Overshoot_Bottom &&\n-                  x2 - x1 >= ras.precision_half  ) )\n-            goto Exit;\n-\n-          if ( dropOutControl == 1 )\n-            pxl = e2;\n-          else\n-            pxl = SMART( x1, x2 );\n-          break;\n+    Int  e1 = (Int)TRUNC( x1 );\n+    Int  e2 = (Int)TRUNC( x2 );\n+    Int  c1, f1;\n@@ -2420,11 +2057,1 @@\n-        default: \/* modes 2, 3, 6, 7 *\/\n-          goto Exit;  \/* no drop-out control *\/\n-        }\n-\n-        \/* undocumented but confirmed: If the drop-out would result in a  *\/\n-        \/* pixel outside of the bounding box, use the pixel inside of the *\/\n-        \/* bounding box instead                                           *\/\n-        if ( pxl < 0 )\n-          pxl = e1;\n-        else if ( TRUNC( pxl ) >= ras.bWidth )\n-          pxl = e2;\n+    FT_UNUSED( y );\n@@ -2432,2 +2059,0 @@\n-        \/* check that the other pixel isn't set *\/\n-        e1 = ( pxl == e1 ) ? e2 : e1;\n@@ -2435,1 +2060,5 @@\n-        e1 = TRUNC( e1 );\n+    \/* undocumented but confirmed: If the drop-out would result in a  *\/\n+    \/* pixel outside of the bounding box, use the pixel inside of the *\/\n+    \/* bounding box instead                                           *\/\n+    if ( e1 < 0 || e1 > ras.bRight )\n+      e1 = e2;\n@@ -2437,2 +2066,5 @@\n-        c1 = (Short)( e1 >> 3 );\n-        f1 = (Short)( e1 &  7 );\n+    \/* otherwise check that the other pixel isn't set *\/\n+    else if ( e2 >=0 && e2 <= ras.bRight )\n+    {\n+      c1 = e2 >> 3;\n+      f1 = 0x80 >> ( e2 & 7 );\n@@ -2440,6 +2072,2 @@\n-        if ( e1 >= 0 && e1 < ras.bWidth                      &&\n-             ras.bOrigin[ras.traceOfs + c1] & ( 0x80 >> f1 ) )\n-          goto Exit;\n-      }\n-      else\n-        goto Exit;\n+      if ( ras.bLine[c1] & f1 )\n+        return;\n@@ -2448,3 +2076,1 @@\n-    e1 = TRUNC( pxl );\n-\n-    if ( e1 >= 0 && e1 < ras.bWidth )\n+    if ( e1 >= 0 && e1 <= ras.bRight )\n@@ -2452,1 +2078,2 @@\n-      FT_TRACE7(( \" -> x=%ld\", e1 ));\n+      c1 = e1 >> 3;\n+      f1 = 0x80 >> ( e1 & 7 );\n@@ -2454,2 +2081,2 @@\n-      c1 = (Short)( e1 >> 3 );\n-      f1 = (Short)( e1 & 7 );\n+      FT_TRACE7(( \"  y=%d x=%d%s\\n\", y, e1,\n+                  ras.bLine[c1] & f1 ? \" redundant\" : \"\" ));\n@@ -2457,1 +2084,1 @@\n-      ras.bOrigin[ras.traceOfs + c1] |= (char)( 0x80 >> f1 );\n+      ras.bLine[c1] |= f1;\n@@ -2459,3 +2086,0 @@\n-\n-  Exit:\n-    FT_TRACE7(( \" dropout=%d\\n\", left->flags & 7 ));\n@@ -2468,1 +2092,1 @@\n-    ras.traceOfs += ras.traceIncr;\n+    ras.bLine -= ras.bPitch;\n@@ -2482,2 +2106,2 @@\n-  Horizontal_Sweep_Init( RAS_ARGS Short*  min,\n-                                  Short*  max )\n+  Horizontal_Sweep_Init( RAS_ARGS Int  min,\n+                                  Int  max )\n@@ -2493,1 +2117,1 @@\n-  Horizontal_Sweep_Span( RAS_ARGS Short       y,\n+  Horizontal_Sweep_Span( RAS_ARGS Int         y,\n@@ -2495,3 +2119,1 @@\n-                                  FT_F26Dot6  x2,\n-                                  PProfile    left,\n-                                  PProfile    right )\n+                                  FT_F26Dot6  x2 )\n@@ -2499,4 +2121,2 @@\n-    Long  e1, e2;\n-\n-    FT_UNUSED( left );\n-    FT_UNUSED( right );\n+    Long  e1 = CEILING( x1 );\n+    Long  e2 =   FLOOR( x2 );\n@@ -2505,1 +2125,1 @@\n-    FT_TRACE7(( \"  x=%d y=[% .12f;% .12f]\",\n+    FT_TRACE7(( \"  x=%d y=[% .*f;% .*f]\",\n@@ -2507,2 +2127,2 @@\n-                x1 \/ (double)ras.precision,\n-                x2 \/ (double)ras.precision ));\n+                ras.precision_bits, (double)x1 \/ (double)ras.precision,\n+                ras.precision_bits, (double)x2 \/ (double)ras.precision ));\n@@ -2516,2 +2136,0 @@\n-    e1 = CEILING( x1 );\n-\n@@ -2522,1 +2140,1 @@\n-      if ( e1 >= 0 && (ULong)e1 < ras.target.rows )\n+      if ( e1 >= 0 && e1 <= ras.bTop )\n@@ -2524,1 +2142,1 @@\n-        Byte   f1;\n+        Int    f1;\n@@ -2528,2 +2146,2 @@\n-        bits = ras.bOrigin + ( y >> 3 ) - e1 * ras.target.pitch;\n-        f1   = (Byte)( 0x80 >> ( y & 7 ) );\n+        bits = ras.bOrigin + ( y >> 3 ) - e1 * ras.bPitch;\n+        f1   = 0x80 >> ( y & 7 );\n@@ -2538,2 +2156,0 @@\n-    e2 = FLOOR  ( x2 );\n-\n@@ -2544,1 +2160,1 @@\n-      if ( e2 >= 0 && (ULong)e2 < ras.target.rows )\n+      if ( e2 >= 0 && e2 <= ras.bTop )\n@@ -2546,1 +2162,1 @@\n-        Byte   f1;\n+        Int    f1;\n@@ -2550,2 +2166,2 @@\n-        bits = ras.bOrigin + ( y >> 3 ) - e2 * ras.target.pitch;\n-        f1   = (Byte)( 0x80 >> ( y & 7 ) );\n+        bits = ras.bOrigin + ( y >> 3 ) - e2 * ras.bPitch;\n+        f1   = 0x80 >> ( y & 7 );\n@@ -2565,1 +2181,1 @@\n-  Horizontal_Sweep_Drop( RAS_ARGS Short       y,\n+  Horizontal_Sweep_Drop( RAS_ARGS Int         y,\n@@ -2567,3 +2183,1 @@\n-                                  FT_F26Dot6  x2,\n-                                  PProfile    left,\n-                                  PProfile    right )\n+                                  FT_F26Dot6  x2 )\n@@ -2571,1 +2185,2 @@\n-    Long   e1, e2, pxl;\n+    Int    e1 = (Int)TRUNC( x1 );\n+    Int    e2 = (Int)TRUNC( x2 );\n@@ -2573,68 +2188,1 @@\n-    Byte   f1;\n-\n-\n-    FT_TRACE7(( \"  x=%d y=[% .12f;% .12f]\",\n-                y,\n-                x1 \/ (double)ras.precision,\n-                x2 \/ (double)ras.precision ));\n-\n-    \/* During the horizontal sweep, we only take care of drop-outs *\/\n-\n-    \/* e1     +       <-- pixel center *\/\n-    \/*        |                        *\/\n-    \/* x1  ---+-->    <-- contour      *\/\n-    \/*        |                        *\/\n-    \/*        |                        *\/\n-    \/* x2  <--+---    <-- contour      *\/\n-    \/*        |                        *\/\n-    \/*        |                        *\/\n-    \/* e2     +       <-- pixel center *\/\n-\n-    e1  = CEILING( x1 );\n-    e2  = FLOOR  ( x2 );\n-    pxl = e1;\n-\n-    if ( e1 > e2 )\n-    {\n-      Int  dropOutControl = left->flags & 7;\n-\n-\n-      if ( e1 == e2 + ras.precision )\n-      {\n-        switch ( dropOutControl )\n-        {\n-        case 0: \/* simple drop-outs including stubs *\/\n-          pxl = e2;\n-          break;\n-\n-        case 4: \/* smart drop-outs including stubs *\/\n-          pxl = SMART( x1, x2 );\n-          break;\n-\n-        case 1: \/* simple drop-outs excluding stubs *\/\n-        case 5: \/* smart drop-outs excluding stubs  *\/\n-          \/* see Vertical_Sweep_Drop for details *\/\n-\n-          \/* rightmost stub test *\/\n-          if ( left->next == right                &&\n-               left->height <= 0                  &&\n-               !( left->flags & Overshoot_Top   &&\n-                  x2 - x1 >= ras.precision_half ) )\n-            goto Exit;\n-\n-          \/* leftmost stub test *\/\n-          if ( right->next == left                 &&\n-               left->start == y                    &&\n-               !( left->flags & Overshoot_Bottom &&\n-                  x2 - x1 >= ras.precision_half  ) )\n-            goto Exit;\n-\n-          if ( dropOutControl == 1 )\n-            pxl = e2;\n-          else\n-            pxl = SMART( x1, x2 );\n-          break;\n-\n-        default: \/* modes 2, 3, 6, 7 *\/\n-          goto Exit;  \/* no drop-out control *\/\n-        }\n+    Int    f1;\n@@ -2642,7 +2190,0 @@\n-        \/* undocumented but confirmed: If the drop-out would result in a  *\/\n-        \/* pixel outside of the bounding box, use the pixel inside of the *\/\n-        \/* bounding box instead                                           *\/\n-        if ( pxl < 0 )\n-          pxl = e1;\n-        else if ( (ULong)( TRUNC( pxl ) ) >= ras.target.rows )\n-          pxl = e2;\n@@ -2650,2 +2191,5 @@\n-        \/* check that the other pixel isn't set *\/\n-        e1 = ( pxl == e1 ) ? e2 : e1;\n+    \/* undocumented but confirmed: If the drop-out would result in a  *\/\n+    \/* pixel outside of the bounding box, use the pixel inside of the *\/\n+    \/* bounding box instead                                           *\/\n+    if ( e1 < 0 || e1 > ras.bTop )\n+      e1 = e2;\n@@ -2653,4 +2197,5 @@\n-        e1 = TRUNC( e1 );\n-\n-        bits = ras.bOrigin + ( y >> 3 ) - e1 * ras.target.pitch;\n-        f1   = (Byte)( 0x80 >> ( y & 7 ) );\n+    \/* otherwise check that the other pixel isn't set *\/\n+    else if ( e2 >=0 && e2 <= ras.bTop )\n+    {\n+      bits = ras.bOrigin + ( y >> 3 ) - e2 * ras.bPitch;\n+      f1   = 0x80 >> ( y & 7 );\n@@ -2658,7 +2203,2 @@\n-        if ( e1 >= 0                     &&\n-             (ULong)e1 < ras.target.rows &&\n-             *bits & f1                  )\n-          goto Exit;\n-      }\n-      else\n-        goto Exit;\n+      if ( *bits & f1 )\n+        return;\n@@ -2667,3 +2207,1 @@\n-    e1 = TRUNC( pxl );\n-\n-    if ( e1 >= 0 && (ULong)e1 < ras.target.rows )\n+    if ( e1 >= 0 && e1 <= ras.bTop )\n@@ -2671,1 +2209,2 @@\n-      FT_TRACE7(( \" -> y=%ld\", e1 ));\n+      bits  = ras.bOrigin + ( y >> 3 ) - e1 * ras.bPitch;\n+      f1    = 0x80 >> ( y & 7 );\n@@ -2673,2 +2212,2 @@\n-      bits  = ras.bOrigin + ( y >> 3 ) - e1 * ras.target.pitch;\n-      f1    = (Byte)( 0x80 >> ( y & 7 ) );\n+      FT_TRACE7(( \"  x=%d y=%d%s\\n\", y, e1,\n+                  *bits & f1 ? \" redundant\" : \"\" ));\n@@ -2676,1 +2215,1 @@\n-      bits[0] |= f1;\n+      *bits |= f1;\n@@ -2678,3 +2217,0 @@\n-\n-  Exit:\n-    FT_TRACE7(( \" dropout=%d\\n\", left->flags & 7 ));\n@@ -2696,0 +2232,3 @@\n+   * Note that this routine is executed with the pool containing at least\n+   * two valid profiles (up and down) and two y-turns (top and bottom).\n+   *\n@@ -2698,1 +2237,1 @@\n-  static Bool\n+  static void\n@@ -2701,5 +2240,2 @@\n-    Short         y, y_change, y_height;\n-\n-    PProfile      P, Q, P_Left, P_Right;\n-\n-    Short         min_Y, max_Y, top, bottom, dropouts;\n+    Int           min_Y, max_Y, dropouts;\n+    Int           y, y_turn;\n@@ -2707,1 +2243,1 @@\n-    Long          x1, x2, xs, e1, e2;\n+    PProfile      *Q, P, P_Left, P_Right;\n@@ -2709,2 +2245,3 @@\n-    TProfileList  waiting;\n-    TProfileList  draw_left, draw_right;\n+    TProfileList  waiting    = ras.fProfile;\n+    TProfileList  draw_left  = NULL;\n+    TProfileList  draw_right = NULL;\n@@ -2713,1 +2250,1 @@\n-    \/* initialize empty linked lists *\/\n+    \/* use y_turns to set the drawing range *\/\n@@ -2715,35 +2252,2 @@\n-    Init_Linked( &waiting );\n-\n-    Init_Linked( &draw_left  );\n-    Init_Linked( &draw_right );\n-\n-    \/* first, compute min and max Y *\/\n-\n-    P     = ras.fProfile;\n-    max_Y = (Short)TRUNC( ras.minY );\n-    min_Y = (Short)TRUNC( ras.maxY );\n-\n-    while ( P )\n-    {\n-      Q = P->link;\n-\n-      bottom = (Short)P->start;\n-      top    = (Short)( P->start + P->height - 1 );\n-\n-      if ( min_Y > bottom )\n-        min_Y = bottom;\n-      if ( max_Y < top )\n-        max_Y = top;\n-\n-      P->X = 0;\n-      InsNew( &waiting, P );\n-\n-      P = Q;\n-    }\n-\n-    \/* check the Y-turns *\/\n-    if ( ras.numTurns == 0 )\n-    {\n-      ras.error = FT_THROW( Invalid );\n-      return FAILURE;\n-    }\n+    min_Y = (Int)ras.maxBuff[0];\n+    max_Y = (Int)ras.maxBuff[ras.numTurns] - 1;\n@@ -2753,11 +2257,1 @@\n-    ras.Proc_Sweep_Init( RAS_VARS &min_Y, &max_Y );\n-\n-    \/* then compute the distance of each profile from min_Y *\/\n-\n-    P = waiting;\n-\n-    while ( P )\n-    {\n-      P->countL = P->start - min_Y;\n-      P = P->link;\n-    }\n+    ras.Proc_Sweep_Init( RAS_VARS min_Y, max_Y );\n@@ -2767,8 +2261,1 @@\n-    y        = min_Y;\n-    y_height = 0;\n-\n-    if ( ras.numTurns > 0                     &&\n-         ras.sizeBuff[-ras.numTurns] == min_Y )\n-      ras.numTurns--;\n-\n-    while ( ras.numTurns > 0 )\n+    for ( y = min_Y; y <= max_Y; )\n@@ -2776,3 +2263,1 @@\n-      \/* check waiting list for new activations *\/\n-\n-      P = waiting;\n+      \/* check waiting list for new profile activations *\/\n@@ -2780,1 +2265,2 @@\n-      while ( P )\n+      Q = &waiting;\n+      while ( *Q )\n@@ -2782,3 +2268,2 @@\n-        Q = P->link;\n-        P->countL -= y_height;\n-        if ( P->countL == 0 )\n+        P = *Q;\n+        if ( P->start == y )\n@@ -2786,1 +2271,1 @@\n-          DelOld( &waiting, P );\n+          *Q = P->link;  \/* remove *\/\n@@ -2788,0 +2273,2 @@\n+          \/* each active list contains profiles with the same flow *\/\n+          \/* left and right are arbitrary, correspond to TrueType  *\/\n@@ -2793,2 +2280,2 @@\n-\n-        P = Q;\n+        else\n+          Q = &P->link;\n@@ -2797,4 +2284,1 @@\n-      \/* sort the drawing lists *\/\n-\n-      Sort( &draw_left );\n-      Sort( &draw_right );\n+      y_turn = (Int)*++ras.maxBuff;\n@@ -2802,4 +2286,1 @@\n-      y_change = (Short)ras.sizeBuff[-ras.numTurns--];\n-      y_height = (Short)( y_change - y );\n-\n-      while ( y < y_change )\n+      do\n@@ -2816,2 +2297,4 @@\n-          x1 = P_Left ->X;\n-          x2 = P_Right->X;\n+          Long  x1 = P_Left ->X;\n+          Long  x2 = P_Right->X;\n+          Long  xs;\n+\n@@ -2819,0 +2302,2 @@\n+          \/* TrueType should have x2 > x1, but can be opposite *\/\n+          \/* by mistake or in CFF\/Type1, fix it then           *\/\n@@ -2826,2 +2311,2 @@\n-          e1 = FLOOR( x1 );\n-          e2 = CEILING( x2 );\n+          if ( CEILING( x1 ) <= FLOOR( x2 ) )\n+            ras.Proc_Sweep_Span( RAS_VARS y, x1, x2 );\n@@ -2829,2 +2314,2 @@\n-          if ( x2 - x1 <= ras.precision &&\n-               e1 != x1 && e2 != x2     )\n+          \/* otherwise, bottom ceiling > top floor, it is a drop-out *\/\n+          else\n@@ -2832,1 +2317,50 @@\n-            if ( e1 > e2 || e2 == e1 + ras.precision )\n+            Int  dropOutControl = P_Left->flags & 7;\n+\n+\n+            \/* Drop-out control *\/\n+\n+            \/*   e2            x2                    x1           e1   *\/\n+            \/*                                                         *\/\n+            \/*                 ^                     |                 *\/\n+            \/*                 |                     |                 *\/\n+            \/*   +-------------+---------------------+------------+    *\/\n+            \/*                 |                     |                 *\/\n+            \/*                 |                     v                 *\/\n+            \/*                                                         *\/\n+            \/* pixel         contour              contour       pixel  *\/\n+            \/* center                                           center *\/\n+\n+            \/* drop-out mode   scan conversion rules (OpenType specs)  *\/\n+            \/* ------------------------------------------------------- *\/\n+            \/*  bit 0          exclude stubs if set                    *\/\n+            \/*  bit 1          ignore drop-outs if set                 *\/\n+            \/*  bit 2          smart rounding if set                   *\/\n+\n+            if ( dropOutControl & 2 )\n+              goto Next_Pair;\n+\n+            \/* The specification neither provides an exact definition *\/\n+            \/* of a `stub' nor gives exact rules to exclude them.     *\/\n+            \/*                                                        *\/\n+            \/* Here the constraints we use to recognize a stub.       *\/\n+            \/*                                                        *\/\n+            \/*  upper stub:                                           *\/\n+            \/*                                                        *\/\n+            \/*   - P_Left and P_Right are in the same contour         *\/\n+            \/*   - P_Right is the successor of P_Left in that contour *\/\n+            \/*   - y is the top of P_Left and P_Right                 *\/\n+            \/*                                                        *\/\n+            \/*  lower stub:                                           *\/\n+            \/*                                                        *\/\n+            \/*   - P_Left and P_Right are in the same contour         *\/\n+            \/*   - P_Left is the successor of P_Right in that contour *\/\n+            \/*   - y is the bottom of P_Left                          *\/\n+            \/*                                                        *\/\n+            \/* We draw a stub if the following constraints are met.   *\/\n+            \/*                                                        *\/\n+            \/*   - for an upper or lower stub, there is top or bottom *\/\n+            \/*     overshoot, respectively                            *\/\n+            \/*   - the covered interval is greater or equal to a half *\/\n+            \/*     pixel                                              *\/\n+\n+            if ( dropOutControl & 1 )\n@@ -2834,14 +2368,14 @@\n-              Int  dropOutControl = P_Left->flags & 7;\n-\n-\n-              if ( dropOutControl != 2 )\n-              {\n-                \/* a drop-out was detected *\/\n-\n-                P_Left ->X = x1;\n-                P_Right->X = x2;\n-\n-                \/* mark profile for drop-out processing *\/\n-                P_Left->countL = 1;\n-                dropouts++;\n-              }\n+              \/* upper stub test *\/\n+              if ( P_Left->height == 1                &&\n+                   P_Left->next == P_Right            &&\n+                   !( P_Left->flags & Overshoot_Top   &&\n+                      x2 - x1 >= ras.precision_half   ) )\n+                goto Next_Pair;\n+\n+              \/* lower stub test *\/\n+              if ( P_Left->offset == 0                 &&\n+                   P_Right->next == P_Left             &&\n+                   !( P_Left->flags & Overshoot_Bottom &&\n+                      x2 - x1 >= ras.precision_half    ) )\n+                goto Next_Pair;\n+            }\n@@ -2849,1 +2383,10 @@\n-              goto Skip_To_Next;\n+            \/* select the pixel to set and the other pixel *\/\n+            if ( dropOutControl & 4 )\n+            {\n+              x2 = SMART( x1, x2 );\n+              x1 = x1 > x2 ? x2 + ras.precision : x2 - ras.precision;\n+            }\n+            else\n+            {\n+              x2 = FLOOR  ( x2 );\n+              x1 = CEILING( x1 );\n@@ -2851,1 +2394,0 @@\n-          }\n@@ -2853,1 +2395,2 @@\n-          ras.Proc_Sweep_Span( RAS_VARS y, x1, x2, P_Left, P_Right );\n+            P_Left ->X = x2;\n+            P_Right->X = x1;\n@@ -2855,1 +2398,4 @@\n-        Skip_To_Next:\n+            \/* mark profile for drop-out processing *\/\n+            P_Left->flags |= Dropout;\n+            dropouts++;\n+          }\n@@ -2857,0 +2403,1 @@\n+        Next_Pair:\n@@ -2861,11 +2408,3 @@\n-        \/* handle drop-outs _after_ the span drawing --       *\/\n-        \/* drop-out processing has been moved out of the loop *\/\n-        \/* for performance tuning                             *\/\n-        if ( dropouts > 0 )\n-          goto Scan_DropOuts;\n-\n-      Next_Line:\n-\n-        ras.Proc_Sweep_Step( RAS_VAR );\n-\n-        y++;\n+        \/* handle drop-outs _after_ the span drawing *\/\n+        P_Left  = draw_left;\n+        P_Right = draw_right;\n@@ -2873,1 +2412,1 @@\n-        if ( y < y_change )\n+        while ( dropouts )\n@@ -2875,126 +2414,3 @@\n-          Sort( &draw_left  );\n-          Sort( &draw_right );\n-        }\n-      }\n-\n-      \/* now finalize the profiles that need it *\/\n-\n-      P = draw_left;\n-      while ( P )\n-      {\n-        Q = P->link;\n-        if ( P->height == 0 )\n-          DelOld( &draw_left, P );\n-        P = Q;\n-      }\n-\n-      P = draw_right;\n-      while ( P )\n-      {\n-        Q = P->link;\n-        if ( P->height == 0 )\n-          DelOld( &draw_right, P );\n-        P = Q;\n-      }\n-    }\n-\n-    \/* for gray-scaling, flush the bitmap scanline cache *\/\n-    while ( y <= max_Y )\n-    {\n-      ras.Proc_Sweep_Step( RAS_VAR );\n-      y++;\n-    }\n-\n-    return SUCCESS;\n-\n-  Scan_DropOuts:\n-\n-    P_Left  = draw_left;\n-    P_Right = draw_right;\n-\n-    while ( P_Left && P_Right )\n-    {\n-      if ( P_Left->countL )\n-      {\n-        P_Left->countL = 0;\n-#if 0\n-        dropouts--;  \/* -- this is useful when debugging only *\/\n-#endif\n-        ras.Proc_Sweep_Drop( RAS_VARS y,\n-                                      P_Left->X,\n-                                      P_Right->X,\n-                                      P_Left,\n-                                      P_Right );\n-      }\n-\n-      P_Left  = P_Left->link;\n-      P_Right = P_Right->link;\n-    }\n-\n-    goto Next_Line;\n-  }\n-\n-\n-#ifdef STANDALONE_\n-\n-  \/**************************************************************************\n-   *\n-   * The following functions should only compile in stand-alone mode,\n-   * i.e., when building this component without the rest of FreeType.\n-   *\n-   *\/\n-\n-  \/**************************************************************************\n-   *\n-   * @Function:\n-   *   FT_Outline_Get_CBox\n-   *\n-   * @Description:\n-   *   Return an outline's `control box'.  The control box encloses all\n-   *   the outline's points, including Bézier control points.  Though it\n-   *   coincides with the exact bounding box for most glyphs, it can be\n-   *   slightly larger in some situations (like when rotating an outline\n-   *   that contains Bézier outside arcs).\n-   *\n-   *   Computing the control box is very fast, while getting the bounding\n-   *   box can take much more time as it needs to walk over all segments\n-   *   and arcs in the outline.  To get the latter, you can use the\n-   *   `ftbbox' component, which is dedicated to this single task.\n-   *\n-   * @Input:\n-   *   outline ::\n-   *     A pointer to the source outline descriptor.\n-   *\n-   * @Output:\n-   *   acbox ::\n-   *     The outline's control box.\n-   *\n-   * @Note:\n-   *   See @FT_Glyph_Get_CBox for a discussion of tricky fonts.\n-   *\/\n-\n-  static void\n-  FT_Outline_Get_CBox( const FT_Outline*  outline,\n-                       FT_BBox           *acbox )\n-  {\n-    Long  xMin, yMin, xMax, yMax;\n-\n-\n-    if ( outline && acbox )\n-    {\n-      if ( outline->n_points == 0 )\n-      {\n-        xMin = 0;\n-        yMin = 0;\n-        xMax = 0;\n-        yMax = 0;\n-      }\n-      else\n-      {\n-        FT_Vector*  vec   = outline->points;\n-        FT_Vector*  limit = vec + outline->n_points;\n-\n-\n-        xMin = xMax = vec->x;\n-        yMin = yMax = vec->y;\n-        vec++;\n+          if ( P_Left->flags & Dropout )\n+          {\n+            ras.Proc_Sweep_Drop( RAS_VARS y, P_Left->X, P_Right->X );\n@@ -3002,3 +2418,3 @@\n-        for ( ; vec < limit; vec++ )\n-        {\n-          Long  x, y;\n+            P_Left->flags &= ~Dropout;\n+            dropouts--;\n+          }\n@@ -3006,0 +2422,3 @@\n+          P_Left  = P_Left->link;\n+          P_Right = P_Right->link;\n+        }\n@@ -3007,3 +2426,1 @@\n-          x = vec->x;\n-          if ( x < xMin ) xMin = x;\n-          if ( x > xMax ) xMax = x;\n+        ras.Proc_Sweep_Step( RAS_VAR );\n@@ -3011,4 +2428,2 @@\n-          y = vec->y;\n-          if ( y < yMin ) yMin = y;\n-          if ( y > yMax ) yMax = y;\n-        }\n+        Increment( &draw_left,   1 );\n+        Increment( &draw_right, -1 );\n@@ -3016,4 +2431,1 @@\n-      acbox->xMin = xMin;\n-      acbox->xMax = xMax;\n-      acbox->yMin = yMin;\n-      acbox->yMax = yMax;\n+      while ( ++y < y_turn );\n@@ -3023,2 +2435,0 @@\n-#endif \/* STANDALONE_ *\/\n-\n@@ -3042,1 +2452,3 @@\n-  Render_Single_Pass( RAS_ARGS Bool  flipped )\n+  Render_Single_Pass( RAS_ARGS Bool  flipped,\n+                               Int   y_min,\n+                               Int   y_max )\n@@ -3044,1 +2456,3 @@\n-    Short  i, j, k;\n+    Int  y_mid;\n+    Int  band_top = 0;\n+    Int  band_stack[32];  \/* enough to bisect 32-bit int bands *\/\n@@ -3047,4 +2461,3 @@\n-    while ( ras.band_top >= 0 )\n-    {\n-      ras.maxY = (Long)ras.band_stack[ras.band_top].y_max * ras.precision;\n-      ras.minY = (Long)ras.band_stack[ras.band_top].y_min * ras.precision;\n+    FT_TRACE6(( \"%s pass [%d..%d]\\n\",\n+                flipped ? \"Horizontal\" : \"Vertical\",\n+                y_min, y_max ));\n@@ -3052,1 +2465,4 @@\n-      ras.top = ras.buff;\n+    while ( 1 )\n+    {\n+      ras.minY = (Long)y_min * ras.precision;\n+      ras.maxY = (Long)y_max * ras.precision;\n@@ -3054,1 +2470,1 @@\n-      ras.error = Raster_Err_None;\n+      ras.error = Raster_Err_Ok;\n@@ -3058,4 +2474,2 @@\n-        if ( ras.error != Raster_Err_Overflow )\n-          return FAILURE;\n-\n-        ras.error = Raster_Err_None;\n+        if ( ras.error != Raster_Err_Raster_Overflow )\n+          return ras.error;\n@@ -3065,6 +2479,2 @@\n-#ifdef DEBUG_RASTER\n-        ClearBand( RAS_VARS TRUNC( ras.minY ), TRUNC( ras.maxY ) );\n-#endif\n-\n-        i = ras.band_stack[ras.band_top].y_min;\n-        j = ras.band_stack[ras.band_top].y_max;\n+        if ( y_min == y_max )\n+          return ras.error;  \/* still Raster_Overflow *\/\n@@ -3072,1 +2482,2 @@\n-        k = (Short)( ( i + j ) \/ 2 );\n+        FT_TRACE6(( \"band [%d..%d]: to be bisected\\n\",\n+                    y_min, y_max ));\n@@ -3074,10 +2485,1 @@\n-        if ( ras.band_top >= 7 || k < i )\n-        {\n-          ras.band_top = 0;\n-          ras.error    = FT_THROW( Invalid );\n-\n-          return ras.error;\n-        }\n-\n-        ras.band_stack[ras.band_top + 1].y_min = k;\n-        ras.band_stack[ras.band_top + 1].y_max = j;\n+        y_mid = ( y_min + y_max ) >> 1;\n@@ -3085,3 +2487,2 @@\n-        ras.band_stack[ras.band_top].y_max = (Short)( k - 1 );\n-\n-        ras.band_top++;\n+        band_stack[band_top++] = y_min;\n+        y_min                  = y_mid + 1;\n@@ -3091,0 +2492,4 @@\n+        FT_TRACE6(( \"band [%d..%d]: %hd profiles; %td bytes remaining\\n\",\n+                    y_min, y_max, ras.num_Profs,\n+                    (char*)ras.maxBuff - (char*)ras.top ));\n+\n@@ -3092,3 +2497,7 @@\n-          if ( Draw_Sweep( RAS_VAR ) )\n-             return ras.error;\n-        ras.band_top--;\n+          Draw_Sweep( RAS_VAR );\n+\n+        if ( --band_top < 0 )\n+          break;\n+\n+        y_max = y_min - 1;\n+        y_min = band_stack[band_top];\n@@ -3098,1 +2507,1 @@\n-    return SUCCESS;\n+    return Raster_Err_Ok;\n@@ -3117,0 +2526,1 @@\n+    Long      buffer[FT_MAX_BLACK_POOL];\n@@ -3119,0 +2529,3 @@\n+    ras.buff     = buffer;\n+    ras.sizeBuff = (&buffer)[1]; \/* Points to right after buffer. *\/\n+\n@@ -3122,0 +2535,2 @@\n+    ras.dropOutControl = 0;\n+\n@@ -3123,7 +2538,1 @@\n-      ras.dropOutControl = 2;\n-    else\n-    {\n-      if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )\n-        ras.dropOutControl = 4;\n-      else\n-        ras.dropOutControl = 0;\n+      ras.dropOutControl |= 2;\n@@ -3131,3 +2540,2 @@\n-      if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )\n-        ras.dropOutControl += 1;\n-    }\n+    if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )\n+      ras.dropOutControl |= 4;\n@@ -3135,2 +2543,2 @@\n-    ras.second_pass = (Bool)( !( ras.outline.flags      &\n-                                 FT_OUTLINE_SINGLE_PASS ) );\n+    if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )\n+      ras.dropOutControl |= 1;\n@@ -3138,2 +2546,2 @@\n-    \/* Vertical Sweep *\/\n-    FT_TRACE7(( \"Vertical pass (ftraster)\\n\" ));\n+    FT_TRACE6(( \"BW Raster: precision 1\/%d, dropout mode %d\\n\",\n+                ras.precision, ras.dropOutControl ));\n@@ -3141,0 +2549,1 @@\n+    \/* Vertical Sweep *\/\n@@ -3146,11 +2555,2 @@\n-    ras.band_top            = 0;\n-    ras.band_stack[0].y_min = 0;\n-    ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );\n-\n-    ras.bWidth  = (UShort)ras.target.width;\n-    ras.bOrigin = (Byte*)ras.target.buffer;\n-\n-    if ( ras.target.pitch > 0 )\n-      ras.bOrigin += (Long)( ras.target.rows - 1 ) * ras.target.pitch;\n-\n-    if ( ( error = Render_Single_Pass( RAS_VARS 0 ) ) != 0 )\n+    error = Render_Single_Pass( RAS_VARS 0, 0, ras.bTop );\n+    if ( error )\n@@ -3160,1 +2560,1 @@\n-    if ( ras.second_pass && ras.dropOutControl != 2 )\n+    if ( !( ras.outline.flags & FT_OUTLINE_SINGLE_PASS ) )\n@@ -3162,2 +2562,0 @@\n-      FT_TRACE7(( \"Horizontal pass (ftraster)\\n\" ));\n-\n@@ -3169,5 +2567,2 @@\n-      ras.band_top            = 0;\n-      ras.band_stack[0].y_min = 0;\n-      ras.band_stack[0].y_max = (Short)( ras.target.width - 1 );\n-\n-      if ( ( error = Render_Single_Pass( RAS_VARS 1 ) ) != 0 )\n+      error = Render_Single_Pass( RAS_VARS 1, 0, ras.bRight );\n+      if ( error )\n@@ -3177,8 +2572,1 @@\n-    return Raster_Err_None;\n-  }\n-\n-\n-  static void\n-  ft_black_init( black_PRaster  raster )\n-  {\n-    FT_UNUSED( raster );\n+    return Raster_Err_Ok;\n@@ -3205,1 +2593,0 @@\n-     ft_black_init( &the_raster );\n@@ -3223,2 +2610,2 @@\n-  ft_black_new( FT_Memory       memory,\n-                black_PRaster  *araster )\n+  ft_black_new( void*       memory_,    \/* FT_Memory     *\/\n+                FT_Raster  *araster_ )  \/* black_PRaster *\/\n@@ -3226,0 +2613,3 @@\n+    FT_Memory       memory = (FT_Memory)memory_;\n+    black_PRaster  *araster = (black_PRaster*)araster_;\n+\n@@ -3230,1 +2620,0 @@\n-    *araster = 0;\n@@ -3232,1 +2621,0 @@\n-    {\n@@ -3234,1 +2622,0 @@\n-      ft_black_init( raster );\n@@ -3236,2 +2623,1 @@\n-      *araster = raster;\n-    }\n+    *araster = raster;\n@@ -3244,1 +2630,1 @@\n-  ft_black_done( black_PRaster  raster )\n+  ft_black_done( FT_Raster  raster_ )   \/* black_PRaster *\/\n@@ -3246,1 +2632,2 @@\n-    FT_Memory  memory = (FT_Memory)raster->memory;\n+    black_PRaster  raster = (black_PRaster)raster_;\n+    FT_Memory      memory = (FT_Memory)raster->memory;\n@@ -3291,2 +2678,0 @@\n-    Long  buffer[FT_MAX_BLACK_POOL];\n-\n@@ -3295,1 +2680,1 @@\n-      return FT_THROW( Not_Ini );\n+      return FT_THROW( Raster_Uninitialized );\n@@ -3298,1 +2683,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Outline );\n@@ -3301,2 +2686,2 @@\n-    if ( outline->n_points == 0 || outline->n_contours <= 0 )\n-      return Raster_Err_None;\n+    if ( outline->n_points == 0 || outline->n_contours == 0 )\n+      return Raster_Err_Ok;\n@@ -3305,1 +2690,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Outline );\n@@ -3309,1 +2694,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Outline );\n@@ -3312,5 +2697,3 @@\n-    if ( params->flags & FT_RASTER_FLAG_DIRECT )\n-      return FT_THROW( Unsupported );\n-\n-    if ( params->flags & FT_RASTER_FLAG_AA )\n-      return FT_THROW( Unsupported );\n+    if ( params->flags & FT_RASTER_FLAG_DIRECT ||\n+         params->flags & FT_RASTER_FLAG_AA     )\n+      return FT_THROW( Cannot_Render_Glyph );\n@@ -3319,1 +2702,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Argument );\n@@ -3323,1 +2706,1 @@\n-      return Raster_Err_None;\n+      return Raster_Err_Ok;\n@@ -3326,1 +2709,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Argument );\n@@ -3329,1 +2712,0 @@\n-    ras.target  = *target_map;\n@@ -3331,2 +2713,7 @@\n-    ras.buff     = buffer;\n-    ras.sizeBuff = (&buffer)[1]; \/* Points to right after buffer. *\/\n+    ras.bTop    =   (Int)target_map->rows - 1;\n+    ras.bRight  =   (Int)target_map->width - 1;\n+    ras.bPitch  =   (Int)target_map->pitch;\n+    ras.bOrigin = (PByte)target_map->buffer;\n+\n+    if ( ras.bPitch > 0 )\n+      ras.bOrigin += ras.bTop * ras.bPitch;\n@@ -3343,5 +2730,5 @@\n-    (FT_Raster_New_Func)     ft_black_new,       \/* raster_new      *\/\n-    (FT_Raster_Reset_Func)   ft_black_reset,     \/* raster_reset    *\/\n-    (FT_Raster_Set_Mode_Func)ft_black_set_mode,  \/* raster_set_mode *\/\n-    (FT_Raster_Render_Func)  ft_black_render,    \/* raster_render   *\/\n-    (FT_Raster_Done_Func)    ft_black_done       \/* raster_done     *\/\n+    ft_black_new,       \/* FT_Raster_New_Func      raster_new      *\/\n+    ft_black_reset,     \/* FT_Raster_Reset_Func    raster_reset    *\/\n+    ft_black_set_mode,  \/* FT_Raster_Set_Mode_Func raster_set_mode *\/\n+    ft_black_render,    \/* FT_Raster_Render_Func   raster_render   *\/\n+    ft_black_done       \/* FT_Raster_Done_Func     raster_done     *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/raster\/ftraster.c","additions":723,"deletions":1336,"binary":false,"changes":2059,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/raster\/ftraster.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -30,1 +30,1 @@\n-  ft_raster1_init( FT_Renderer  render )\n+  ft_raster1_init( FT_Module  module )   \/* FT_Renderer *\/\n@@ -32,0 +32,3 @@\n+    FT_Renderer  render = (FT_Renderer)module;\n+\n+\n@@ -191,3 +194,3 @@\n-      (FT_Module_Constructor)ft_raster1_init,  \/* module_init   *\/\n-      (FT_Module_Destructor) NULL,             \/* module_done   *\/\n-      (FT_Module_Requester)  NULL,             \/* get_interface *\/\n+      ft_raster1_init,  \/* FT_Module_Constructor module_init   *\/\n+      NULL,             \/* FT_Module_Destructor  module_done   *\/\n+      NULL,             \/* FT_Module_Requester   get_interface *\/\n@@ -197,4 +200,4 @@\n-    (FT_Renderer_RenderFunc)   ft_raster1_render,     \/* render_glyph    *\/\n-    (FT_Renderer_TransformFunc)ft_raster1_transform,  \/* transform_glyph *\/\n-    (FT_Renderer_GetCBoxFunc)  ft_raster1_get_cbox,   \/* get_glyph_cbox  *\/\n-    (FT_Renderer_SetModeFunc)  ft_raster1_set_mode,   \/* set_mode        *\/\n+    ft_raster1_render,     \/* FT_Renderer_RenderFunc    render_glyph    *\/\n+    ft_raster1_transform,  \/* FT_Renderer_TransformFunc transform_glyph *\/\n+    ft_raster1_get_cbox,   \/* FT_Renderer_GetCBoxFunc   get_glyph_cbox  *\/\n+    ft_raster1_set_mode,   \/* FT_Renderer_SetModeFunc   set_mode        *\/\n@@ -202,1 +205,1 @@\n-    (FT_Raster_Funcs*)&ft_standard_raster             \/* raster_class    *\/\n+    &ft_standard_raster    \/* FT_Raster_Funcs*          raster_class    *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/raster\/ftrend1.c","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/raster\/ftrend1.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/raster\/rasterrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n@@ -242,1 +242,1 @@\n-      return;\n+      \/* return; (never reached) *\/\n@@ -273,1 +273,4 @@\n-    png_byte*  *rows = NULL; \/* pacify compiler *\/\n+\n+    \/* `rows` gets modified within a 'setjmp' scope; *\/\n+    \/* we thus need the `volatile` keyword.          *\/\n+    png_byte* *volatile  rows = NULL;\n@@ -367,1 +370,1 @@\n-    if ( png_get_valid(png, info, PNG_INFO_tRNS ) )\n+    if ( png_get_valid( png, info, PNG_INFO_tRNS ) )\n@@ -387,1 +390,1 @@\n-    png_read_update_info(png, info );\n+    png_read_update_info( png, info );\n@@ -406,3 +409,1 @@\n-    default:\n-      \/* Shouldn't happen, but fall through. *\/\n-\n+    default:  \/* Shouldn't happen, but ... *\/\n@@ -430,1 +431,1 @@\n-    if ( FT_NEW_ARRAY( rows, imgHeight ) )\n+    if ( FT_QNEW_ARRAY( rows, imgHeight ) )\n@@ -441,2 +442,0 @@\n-    FT_FREE( rows );\n-\n@@ -446,0 +445,2 @@\n+    \/* even if reading fails with longjmp, rows must be freed *\/\n+    FT_FREE( rows );\n@@ -456,1 +457,1 @@\n-  typedef int  _pngshim_dummy;\n+  typedef int  pngshim_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/pngshim.c","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/pngshim.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -39,0 +39,4 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+#include \"ttsvg.h\"\n+#endif\n+\n@@ -48,0 +52,4 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+#include \"ttgpos.h\"\n+#endif\n+\n@@ -78,2 +86,16 @@\n-  static void*\n-  get_sfnt_table( TT_Face      face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  sfnt_load_table( FT_Face    face,    \/* TT_Face *\/\n+                   FT_ULong   tag,\n+                   FT_Long    offset,\n+                   FT_Byte*   buffer,\n+                   FT_ULong*  length )\n+  {\n+    TT_Face  ttface = (TT_Face)face;\n+\n+\n+    return tt_face_load_any( ttface, tag, offset, buffer, length );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( void* )\n+  get_sfnt_table( FT_Face      face,  \/* TT_Face *\/\n@@ -82,0 +104,2 @@\n+    TT_Face  ttface = (TT_Face)face;\n+\n@@ -88,1 +112,1 @@\n-      table = &face->header;\n+      table = &ttface->header;\n@@ -92,1 +116,1 @@\n-      table = &face->horizontal;\n+      table = &ttface->horizontal;\n@@ -96,1 +120,1 @@\n-      table = face->vertical_info ? &face->vertical : NULL;\n+      table = ttface->vertical_info ? &ttface->vertical : NULL;\n@@ -100,1 +124,1 @@\n-      table = ( face->os2.version == 0xFFFFU ) ? NULL : &face->os2;\n+      table = ( ttface->os2.version == 0xFFFFU ) ? NULL : &ttface->os2;\n@@ -104,1 +128,1 @@\n-      table = &face->postscript;\n+      table = &ttface->postscript;\n@@ -108,1 +132,1 @@\n-      table = &face->max_profile;\n+      table = &ttface->max_profile;\n@@ -112,1 +136,1 @@\n-      table = face->pclt.Version ? &face->pclt : NULL;\n+      table = ttface->pclt.Version ? &ttface->pclt : NULL;\n@@ -123,2 +147,2 @@\n-  static FT_Error\n-  sfnt_table_info( TT_Face    face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  sfnt_table_info( FT_Face    face,    \/* TT_Face *\/\n@@ -130,0 +154,3 @@\n+    TT_Face  ttface = (TT_Face)face;\n+\n+\n@@ -134,1 +161,1 @@\n-      *length = face->num_tables;\n+      *length = ttface->num_tables;\n@@ -137,1 +164,1 @@\n-      if ( idx >= face->num_tables )\n+      if ( idx >= ttface->num_tables )\n@@ -140,3 +167,3 @@\n-      *tag    = face->dir_tables[idx].Tag;\n-      *offset = face->dir_tables[idx].Offset;\n-      *length = face->dir_tables[idx].Length;\n+      *tag    = ttface->dir_tables[idx].Tag;\n+      *offset = ttface->dir_tables[idx].Offset;\n+      *length = ttface->dir_tables[idx].Length;\n@@ -152,3 +179,3 @@\n-    (FT_SFNT_TableLoadFunc)tt_face_load_any,     \/* load_table *\/\n-    (FT_SFNT_TableGetFunc) get_sfnt_table,       \/* get_table  *\/\n-    (FT_SFNT_TableInfoFunc)sfnt_table_info       \/* table_info *\/\n+    sfnt_load_table,  \/* FT_SFNT_TableLoadFunc load_table *\/\n+    get_sfnt_table,   \/* FT_SFNT_TableGetFunc  get_table  *\/\n+    sfnt_table_info   \/* FT_SFNT_TableInfoFunc table_info *\/\n@@ -165,1 +192,1 @@\n-  static FT_Error\n+  FT_CALLBACK_DEF( FT_Error )\n@@ -183,1 +210,1 @@\n-  static FT_UInt\n+  FT_CALLBACK_DEF( FT_UInt )\n@@ -220,2 +247,2 @@\n-    (FT_GlyphDict_GetNameFunc)  sfnt_get_glyph_name,    \/* get_name   *\/\n-    (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index     \/* name_index *\/\n+    sfnt_get_glyph_name,  \/* FT_GlyphDict_GetNameFunc   get_name   *\/\n+    sfnt_get_name_index   \/* FT_GlyphDict_NameIndexFunc name_index *\/\n@@ -377,1 +404,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -380,1 +407,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -387,1 +414,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -391,1 +418,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -394,1 +421,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -397,1 +424,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -404,1 +431,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -408,1 +435,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -411,1 +438,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -414,1 +441,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -421,1 +448,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -425,1 +452,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -428,1 +455,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -431,1 +458,1 @@\n-        \/* fall through *\/\n+        FALL_THROUGH;\n@@ -494,1 +521,1 @@\n-    FT_Error  error = FT_Err_Ok;\n+    FT_Error  error;\n@@ -501,2 +528,0 @@\n-    FT_UNUSED( error );\n-\n@@ -504,1 +529,1 @@\n-    if ( FT_ALLOC( result, entry->stringLength \/ 2 + 1 ) )\n+    if ( FT_QALLOC( result, entry->stringLength \/ 2 + 1 ) )\n@@ -524,1 +549,1 @@\n-        break;\n+        continue;\n@@ -527,2 +552,1 @@\n-    if ( !len )\n-      *r = '\\0';\n+    *r = '\\0';\n@@ -532,1 +556,1 @@\n-    if ( !len )\n+    if ( r != result )\n@@ -553,1 +577,1 @@\n-    FT_Error  error = FT_Err_Ok;\n+    FT_Error  error;\n@@ -560,2 +584,0 @@\n-    FT_UNUSED( error );\n-\n@@ -563,1 +585,1 @@\n-    if ( FT_ALLOC( result, entry->stringLength + 1 ) )\n+    if ( FT_QALLOC( result, entry->stringLength + 1 ) )\n@@ -583,1 +605,1 @@\n-        break;\n+        continue;\n@@ -586,2 +608,1 @@\n-    if ( !len )\n-      *r = '\\0';\n+    *r = '\\0';\n@@ -591,1 +612,1 @@\n-    if ( !len )\n+    if ( r != result )\n@@ -605,1 +626,1 @@\n-  static FT_Bool\n+  FT_CALLBACK_DEF( FT_Bool )\n@@ -660,1 +681,1 @@\n-   * Find the shortest decimal representation of a 16.16 fixed point\n+   * Find the shortest decimal representation of a 16.16 fixed-point\n@@ -736,1 +757,1 @@\n-        verified this by iterating over all possible fixed point numbers.\n+        verified this by iterating over all possible fixed-point numbers.\n@@ -744,1 +765,1 @@\n-        also found by testing all possible fixed point values).\n+        also found by testing all possible fixed-point values).\n@@ -822,3 +843,3 @@\n-        \/* as a last resort we try the family name; note that this is *\/\n-        \/* not in the Adobe TechNote, but GX fonts (which predate the *\/\n-        \/* TechNote) benefit from this behaviour                      *\/\n+        \/* according to the 'name' documentation in the OpenType   *\/\n+        \/* specification the font family name is to be used if the *\/\n+        \/* typographic family name is missing, so let's do that    *\/\n@@ -856,0 +877,4 @@\n+        \/* XXX It probably makes sense to never let this fail *\/\n+        \/*     since an arbitrary prefix should work, too.    *\/\n+        \/*     On the other hand, it is very unlikely that    *\/\n+        \/*     we ever reach this code at all.                *\/\n@@ -871,2 +896,2 @@\n-                    \" Shortening variation PS name prefix\\n\"\n-                    \"                     \"\n+                    \" Shortening variation PS name prefix\\n\" ));\n+        FT_TRACE0(( \"                     \"\n@@ -923,2 +948,2 @@\n-                      \" can't construct named instance PS name;\\n\"\n-                      \"                     \"\n+                      \" can't construct named instance PS name;\\n\" ));\n+          FT_TRACE1(( \"                     \"\n@@ -931,2 +956,2 @@\n-        if ( FT_ALLOC( result, face->var_postscript_prefix_len +\n-                               1 + ft_strlen( subfamily_name ) + 1 ) )\n+        if ( FT_QALLOC( result, face->var_postscript_prefix_len +\n+                                1 + ft_strlen( subfamily_name ) + 1 ) )\n@@ -960,3 +985,3 @@\n-      if ( FT_ALLOC( result,\n-                     face->var_postscript_prefix_len +\n-                       num_coords * MAX_VALUE_DESCRIPTOR_LEN + 1 ) )\n+      if ( FT_QALLOC( result,\n+                      face->var_postscript_prefix_len +\n+                        num_coords * MAX_VALUE_DESCRIPTOR_LEN + 1 ) )\n@@ -996,0 +1021,1 @@\n+      *p++ = '\\0';\n@@ -1043,2 +1069,2 @@\n-  static const char*\n-  sfnt_get_ps_name( TT_Face  face )\n+  FT_CALLBACK_DEF( const char* )\n+  sfnt_get_ps_name( FT_Face  face )    \/* TT_Face *\/\n@@ -1046,0 +1072,2 @@\n+    TT_Face  ttface = (TT_Face)face;\n+\n@@ -1050,2 +1078,2 @@\n-    if ( face->postscript_name )\n-      return face->postscript_name;\n+    if ( ttface->postscript_name )\n+      return ttface->postscript_name;\n@@ -1054,3 +1082,3 @@\n-    if ( face->blend                                 &&\n-         ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||\n-           FT_IS_VARIATION( FT_FACE( face ) )      ) )\n+    if ( ttface->blend                    &&\n+         ( FT_IS_NAMED_INSTANCE( face ) ||\n+           FT_IS_VARIATION( face )      ) )\n@@ -1058,2 +1086,2 @@\n-      face->postscript_name = sfnt_get_var_ps_name( face );\n-      return face->postscript_name;\n+      ttface->postscript_name = sfnt_get_var_ps_name( ttface );\n+      return ttface->postscript_name;\n@@ -1065,1 +1093,1 @@\n-    found = sfnt_get_name_id( face, TT_NAME_ID_PS_NAME, &win, &apple );\n+    found = sfnt_get_name_id( ttface, TT_NAME_ID_PS_NAME, &win, &apple );\n@@ -1071,3 +1099,3 @@\n-      result = get_win_string( face->root.memory,\n-                               face->name_table.stream,\n-                               face->name_table.names + win,\n+      result = get_win_string( FT_FACE_MEMORY( face ),\n+                               ttface->name_table.stream,\n+                               ttface->name_table.names + win,\n@@ -1077,3 +1105,3 @@\n-      result = get_apple_string( face->root.memory,\n-                                 face->name_table.stream,\n-                                 face->name_table.names + apple,\n+      result = get_apple_string( FT_FACE_MEMORY( face ),\n+                                 ttface->name_table.stream,\n+                                 ttface->name_table.names + apple,\n@@ -1083,1 +1111,1 @@\n-    face->postscript_name = result;\n+    ttface->postscript_name = result;\n@@ -1092,1 +1120,1 @@\n-    (FT_PsName_GetFunc)sfnt_get_ps_name       \/* get_ps_font_name *\/\n+    sfnt_get_ps_name  \/* FT_PsName_GetFunc get_ps_font_name *\/\n@@ -1102,1 +1130,1 @@\n-    (TT_CMap_Info_GetFunc)tt_get_cmap_info    \/* get_cmap_info *\/\n+    tt_get_cmap_info  \/* TT_CMap_Info_GetFunc get_cmap_info *\/\n@@ -1109,1 +1137,1 @@\n-  sfnt_get_charset_id( TT_Face       face,\n+  sfnt_get_charset_id( FT_Face       face,\n@@ -1147,2 +1175,2 @@\n-    (FT_BDF_GetCharsetIdFunc)sfnt_get_charset_id,     \/* get_charset_id *\/\n-    (FT_BDF_GetPropertyFunc) tt_face_find_bdf_prop    \/* get_property   *\/\n+    sfnt_get_charset_id,   \/* FT_BDF_GetCharsetIdFunc get_charset_id *\/\n+    tt_face_find_bdf_prop  \/* FT_BDF_GetPropertyFunc  get_property   *\/\n@@ -1216,0 +1244,8 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+#define PUT_SVG_SUPPORT( a )  a\n+#else\n+#define PUT_SVG_SUPPORT( a )  NULL\n+#endif\n+\n+#define PUT_COLOR_LAYERS_V1( a )  PUT_COLOR_LAYERS( a )\n+\n@@ -1220,0 +1256,6 @@\n+#endif\n+\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+#define PUT_GPOS_KERNING( a )  a\n+#else\n+#define PUT_GPOS_KERNING( a )  NULL\n@@ -1245,0 +1287,2 @@\n+    PUT_GPOS_KERNING( tt_face_load_gpos ),\n+                            \/* TT_Load_Table_Func      load_gpos       *\/\n@@ -1263,0 +1307,3 @@\n+    PUT_GPOS_KERNING( tt_face_get_gpos_kerning ),\n+                           \/* TT_Face_GetKerningFunc  get_gpos_kerning *\/\n+\n@@ -1274,1 +1321,1 @@\n-                   \/* TT_Set_SBit_Strike_Func      set_sbit_strike     *\/\n+                  \/* TT_Set_SBit_Strike_Func      set_sbit_strike      *\/\n@@ -1276,1 +1323,1 @@\n-                   \/* TT_Load_Strike_Metrics_Func  load_strike_metrics *\/\n+                  \/* TT_Load_Strike_Metrics_Func  load_strike_metrics  *\/\n@@ -1290,0 +1337,12 @@\n+\n+    PUT_COLOR_LAYERS_V1( tt_face_get_colr_glyph_paint ),\n+              \/* TT_Get_Color_Glyph_Paint_Func    get_colr_glyph_paint *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_color_glyph_clipbox ),\n+              \/* TT_Get_Color_Glyph_ClipBox_Func  get_clipbox          *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_paint_layers ),\n+              \/* TT_Get_Paint_Layers_Func         get_paint_layers     *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_colorline_stops ),\n+              \/* TT_Get_Paint                     get_paint            *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_paint ),\n+              \/* TT_Get_Colorline_Stops_Func      get_colorline_stops  *\/\n+\n@@ -1296,1 +1355,8 @@\n-    sfnt_get_name_id        \/* TT_Get_Name_ID_Func     get_name_id     *\/\n+    sfnt_get_name_id,       \/* TT_Get_Name_ID_Func     get_name_id     *\/\n+\n+    PUT_SVG_SUPPORT( tt_face_load_svg ),\n+                            \/* TT_Load_Table_Func      load_svg        *\/\n+    PUT_SVG_SUPPORT( tt_face_free_svg ),\n+                            \/* TT_Free_Table_Func      free_svg        *\/\n+    PUT_SVG_SUPPORT( tt_face_load_svg_doc )\n+                            \/* TT_Load_Svg_Doc_Func    load_svg_doc    *\/\n@@ -1312,3 +1378,3 @@\n-    (FT_Module_Constructor)NULL,               \/* module_init   *\/\n-    (FT_Module_Destructor) NULL,               \/* module_done   *\/\n-    (FT_Module_Requester)  sfnt_get_interface  \/* get_interface *\/\n+    NULL,               \/* FT_Module_Constructor module_init   *\/\n+    NULL,               \/* FT_Module_Destructor  module_done   *\/\n+    sfnt_get_interface  \/* FT_Module_Requester   get_interface *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfdriver.c","additions":164,"deletions":98,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -43,0 +43,4 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+#include \"ttgpos.h\"\n+#endif\n+\n@@ -68,1 +72,1 @@\n-    if ( FT_NEW_ARRAY( string, len + 1 ) )\n+    if ( FT_QNEW_ARRAY( string, len + 1 ) )\n@@ -103,1 +107,1 @@\n-    if ( FT_NEW_ARRAY( string, len + 1 ) )\n+    if ( FT_QNEW_ARRAY( string, len + 1 ) )\n@@ -363,0 +367,5 @@\n+#ifndef FT_CONFIG_OPTION_USE_BROTLI\n+    FT_UNUSED( face_instance_index );\n+    FT_UNUSED( woff2_num_faces );\n+#endif\n+\n@@ -368,0 +377,2 @@\n+#if defined( FT_CONFIG_OPTION_USE_ZLIB )   || \\\n+    defined( FT_CONFIG_OPTION_USE_BROTLI )\n@@ -369,0 +380,2 @@\n+#endif\n+\n@@ -374,0 +387,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_ZLIB\n@@ -389,0 +403,1 @@\n+#endif\n@@ -390,0 +405,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n@@ -408,0 +424,1 @@\n+#endif\n@@ -449,1 +466,1 @@\n-      if ( FT_NEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) )\n+      if ( FT_QNEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) )\n@@ -467,1 +484,1 @@\n-      if ( FT_NEW( face->ttc_header.offsets ) )\n+      if ( FT_QNEW( face->ttc_header.offsets ) )\n@@ -524,1 +541,1 @@\n-    if ( !face->var )\n+    if ( !face->tt_var )\n@@ -531,3 +548,3 @@\n-      face->var = ft_module_get_service( tt_module,\n-                                         FT_SERVICE_ID_METRICS_VARIATIONS,\n-                                         0 );\n+      face->tt_var = ft_module_get_service( tt_module,\n+                                            FT_SERVICE_ID_METRICS_VARIATIONS,\n+                                            0 );\n@@ -535,0 +552,6 @@\n+\n+    if ( !face->face_var )\n+      face->face_var = ft_module_get_service(\n+                         &face->root.driver->root,\n+                         FT_SERVICE_ID_METRICS_VARIATIONS,\n+                         0 );\n@@ -556,1 +579,1 @@\n-    if ( face_instance_index < 0 )\n+    if ( face_instance_index < 0 && face_index > 0 )\n@@ -646,2 +669,2 @@\n-           !( FT_ALLOC( default_values, num_axes * 4 )  ||\n-              FT_ALLOC( instance_values, num_axes * 4 ) )      )\n+           !( FT_QALLOC(  default_values, num_axes * 4 ) ||\n+              FT_QALLOC( instance_values, num_axes * 4 ) )     )\n@@ -682,0 +705,3 @@\n+        \/* named instance indices start with value 1 *\/\n+        face->var_default_named_instance = i + 1;\n+\n@@ -774,1 +800,1 @@\n-    FT_Error      error;\n+    FT_Error  error;\n@@ -776,1 +802,1 @@\n-    FT_Error      psnames_error;\n+    FT_Error  psnames_error;\n@@ -778,7 +804,13 @@\n-    FT_Bool       has_outline;\n-    FT_Bool       is_apple_sbit;\n-    FT_Bool       is_apple_sbix;\n-    FT_Bool       has_CBLC;\n-    FT_Bool       has_CBDT;\n-    FT_Bool       ignore_typographic_family    = FALSE;\n-    FT_Bool       ignore_typographic_subfamily = FALSE;\n+\n+    FT_Bool  has_outline;\n+    FT_Bool  is_apple_sbit;\n+\n+    FT_Bool  has_CBLC;\n+    FT_Bool  has_CBDT;\n+    FT_Bool  has_EBLC;\n+    FT_Bool  has_bloc;\n+    FT_Bool  has_sbix;\n+\n+    FT_Bool  ignore_typographic_family    = FALSE;\n+    FT_Bool  ignore_typographic_subfamily = FALSE;\n+    FT_Bool  ignore_sbix                  = FALSE;\n@@ -803,0 +835,2 @@\n+        else if ( params[i].tag == FT_PARAM_TAG_IGNORE_SBIX )\n+          ignore_sbix = TRUE;\n@@ -823,1 +857,2 @@\n-    FT_TRACE2(( \"sfnt_load_face: %p\\n\\n\", (void *)face ));\n+    FT_TRACE2(( \"sfnt_load_face: %p\\n\", (void *)face ));\n+    FT_TRACE2(( \"\\n\" ));\n@@ -837,2 +872,6 @@\n-    is_apple_sbit = 0;\n-    is_apple_sbix = !face->goto_table( face, TTAG_sbix, stream, 0 );\n+    \/* check which sbit formats are present *\/\n+    has_CBLC = !face->goto_table( face, TTAG_CBLC, stream, 0 );\n+    has_CBDT = !face->goto_table( face, TTAG_CBDT, stream, 0 );\n+    has_EBLC = !face->goto_table( face, TTAG_EBLC, stream, 0 );\n+    has_bloc = !face->goto_table( face, TTAG_bloc, stream, 0 );\n+    has_sbix = !face->goto_table( face, TTAG_sbix, stream, 0 );\n@@ -840,5 +879,4 @@\n-    \/* Apple 'sbix' color bitmaps are rendered scaled and then the 'glyf'\n-     * outline rendered on top.  We don't support that yet, so just ignore\n-     * the 'glyf' outline and advertise it as a bitmap-only font. *\/\n-    if ( is_apple_sbix )\n-      has_outline = FALSE;\n+    is_apple_sbit = FALSE;\n+\n+    if ( ignore_sbix )\n+      has_sbix = FALSE;\n@@ -856,1 +894,1 @@\n-    if ( !is_apple_sbit || is_apple_sbix )\n+    if ( !is_apple_sbit || has_sbix )\n@@ -863,3 +901,0 @@\n-    has_CBLC = !face->goto_table( face, TTAG_CBLC, stream, 0 );\n-    has_CBDT = !face->goto_table( face, TTAG_CBDT, stream, 0 );\n-\n@@ -975,1 +1010,5 @@\n-    if ( sfnt->load_eblc )\n+    \/* TODO: Replace this clumsy check for all possible sbit tables     *\/\n+    \/*       with something better (for example, by passing a parameter *\/\n+    \/*       to suppress 'sbix' loading).                               *\/\n+    if ( sfnt->load_eblc                                  &&\n+         ( has_CBLC || has_EBLC || has_bloc || has_sbix ) )\n@@ -985,0 +1024,4 @@\n+    \/* OpenType-SVG glyph support *\/\n+    if ( sfnt->load_svg )\n+      LOAD_( svg );\n+\n@@ -990,0 +1033,4 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+    LOAD_( gpos );\n+#endif\n+\n@@ -1027,0 +1074,10 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+    {\n+      FT_Memory  memory = face->root.memory;\n+\n+\n+      if ( FT_STRDUP( face->non_var_style_name, face->root.style_name ) )\n+        goto Exit;\n+    }\n+#endif\n+\n@@ -1039,1 +1096,2 @@\n-           face->colr                                       )\n+           face->colr                                       ||\n+           face->svg                                        )\n@@ -1043,1 +1101,8 @@\n-        flags |= FT_FACE_FLAG_SCALABLE;   \/* scalable outlines *\/\n+      {\n+        \/* by default (and for backward compatibility) we handle *\/\n+        \/* fonts with an 'sbix' table as bitmap-only             *\/\n+        if ( has_sbix )\n+          flags |= FT_FACE_FLAG_SBIX;     \/* with 'sbix' bitmaps *\/\n+        else\n+          flags |= FT_FACE_FLAG_SCALABLE; \/* scalable outlines *\/\n+      }\n@@ -1065,1 +1130,5 @@\n-      if ( TT_FACE_HAS_KERNING( face ) )\n+      if ( TT_FACE_HAS_KERNING( face )\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+           || face->gpos_kerning_available\n+#endif\n+         )\n@@ -1072,7 +1141,1 @@\n-      {\n-        if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &&\n-             tt_face_lookup_table( face, TTAG_gvar ) != 0 )\n-          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n-        if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )\n-          flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n-      }\n+        flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;\n@@ -1152,1 +1215,2 @@\n-        if ( !has_unicode )\n+        if ( !has_unicode                                &&\n+             root->face_flags & FT_FACE_FLAG_GLYPH_NAMES )\n@@ -1154,1 +1218,1 @@\n-          FT_CharMapRec cmaprec;\n+          FT_CharMapRec  cmaprec;\n@@ -1191,1 +1255,1 @@\n-          FT_Memory        memory   = face->root.stream->memory;\n+          FT_Memory        memory   = face->root.memory;\n@@ -1210,1 +1274,1 @@\n-               FT_NEW_ARRAY( sbit_strike_map, count ) )\n+               FT_QNEW_ARRAY( sbit_strike_map, count ) )\n@@ -1239,1 +1303,1 @@\n-          (void)FT_RENEW_ARRAY( sbit_strike_map, count, bsize_idx );\n+          FT_MEM_QRENEW_ARRAY( sbit_strike_map, count, bsize_idx );\n@@ -1265,1 +1329,2 @@\n-      if ( FT_IS_SCALABLE( root ) )\n+      if ( FT_IS_SCALABLE( root ) ||\n+           FT_HAS_SBIX( root )    )\n@@ -1404,0 +1469,6 @@\n+\n+#ifdef FT_CONFIG_OPTION_SVG\n+      \/* free SVG data *\/\n+      if ( sfnt->free_svg )\n+        sfnt->free_svg( face );\n+#endif\n@@ -1414,0 +1485,5 @@\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+    \/* freeing the GPOS table *\/\n+    tt_face_done_gpos( face );\n+#endif\n+\n@@ -1463,0 +1539,1 @@\n+    FT_FREE( face->non_var_style_name );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfobjs.c","additions":127,"deletions":50,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -21,0 +21,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -26,0 +27,3 @@\n+#ifdef FT_CONFIG_OPTION_USE_ZLIB\n+\n+\n@@ -64,1 +68,0 @@\n-    stream->base  = NULL;\n@@ -69,1 +72,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -112,1 +115,1 @@\n-    FT_ULong        old_tag = 0;\n+    FT_Tag          old_tag = 0;\n@@ -150,0 +153,1 @@\n+         woff.num_tables >  0xFFFU                                ||\n@@ -163,2 +167,1 @@\n-    if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||\n-         FT_NEW( sfnt_stream )                         )\n+    if ( FT_QALLOC( sfnt, 12 ) || FT_NEW( sfnt_stream ) )\n@@ -171,11 +174,3 @@\n-      FT_UInt  searchRange, entrySelector, rangeShift, x;\n-\n-\n-      x             = woff.num_tables;\n-      entrySelector = 0;\n-      while ( x )\n-      {\n-        x            >>= 1;\n-        entrySelector += 1;\n-      }\n-      entrySelector--;\n+      FT_Int  entrySelector = FT_MSB( woff.num_tables );\n+      FT_Int  searchRange   = ( 1 << entrySelector ) * 16;\n+      FT_Int  rangeShift    = woff.num_tables * 16 - searchRange;\n@@ -183,2 +178,0 @@\n-      searchRange = ( 1 << entrySelector ) * 16;\n-      rangeShift  = woff.num_tables * 16 - searchRange;\n@@ -197,2 +190,2 @@\n-    if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||\n-         FT_NEW_ARRAY( indices, woff.num_tables ) )\n+    if ( FT_QNEW_ARRAY( tables, woff.num_tables )  ||\n+         FT_QNEW_ARRAY( indices, woff.num_tables ) )\n@@ -201,3 +194,3 @@\n-    FT_TRACE2(( \"\\n\"\n-                \"  tag    offset    compLen  origLen  checksum\\n\"\n-                \"  -------------------------------------------\\n\" ));\n+    FT_TRACE2(( \"\\n\" ));\n+    FT_TRACE2(( \"  tag    offset    compLen  origLen  checksum\\n\" ));\n+    FT_TRACE2(( \"  -------------------------------------------\\n\" ));\n@@ -329,3 +322,1 @@\n-    if ( FT_REALLOC( sfnt,\n-                     12 + woff.num_tables * 16UL,\n-                     woff.totalSfntSize ) )\n+    if ( FT_QREALLOC( sfnt, 12, woff.totalSfntSize ) )\n@@ -363,2 +354,0 @@\n-#ifdef FT_CONFIG_OPTION_USE_ZLIB\n-\n@@ -380,7 +369,0 @@\n-\n-#else \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n-\n-        error = FT_THROW( Unimplemented_Feature );\n-        goto Exit1;\n-\n-#endif \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n@@ -436,0 +418,7 @@\n+#else \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n+\n+  \/* ANSI C doesn't like empty source files *\/\n+  typedef int  sfwoff_dummy_;\n+\n+#endif \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfwoff.c","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -29,0 +29,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_ZLIB\n@@ -35,0 +36,2 @@\n+#endif\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfwoff.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2024 by\n@@ -21,0 +21,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -29,2 +30,0 @@\n-#endif\n-\n@@ -41,0 +40,2 @@\n+  \/* An arbitrary, heuristic size limit (67MByte) for expanded WOFF2 data. *\/\n+#define MAX_SFNT_SIZE  ( 1 << 26 )\n@@ -89,0 +90,2 @@\n+#define HAVE_OVERLAP_SIMPLE_BITMAP  0x1\n+\n@@ -99,1 +102,0 @@\n-    stream->base  = NULL;\n@@ -104,1 +106,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -111,2 +113,2 @@\n-    FT_ULong  tag1 = table1->Tag;\n-    FT_ULong  tag2 = table2->Tag;\n+    FT_Tag  tag1 = table1->Tag;\n+    FT_Tag  tag2 = table2->Tag;\n@@ -233,3 +235,3 @@\n-      if ( FT_REALLOC( dst,\n-                       (FT_ULong)( *dst_size ),\n-                       (FT_ULong)( *offset + size ) ) )\n+      if ( FT_QREALLOC( dst,\n+                        (FT_ULong)( *dst_size ),\n+                        (FT_ULong)( *offset + size ) ) )\n@@ -291,1 +293,1 @@\n-    FT_ULong  v;\n+    FT_Int    shift;\n@@ -295,4 +297,1 @@\n-      checksum += ( (FT_ULong)buf[i    ] << 24 ) |\n-                  ( (FT_ULong)buf[i + 1] << 16 ) |\n-                  ( (FT_ULong)buf[i + 2] <<  8 ) |\n-                  ( (FT_ULong)buf[i + 3] <<  0 );\n+      checksum += FT_NEXT_ULONG( buf );\n@@ -300,8 +299,3 @@\n-    \/* If size is not aligned to 4, treat as if it is padded with 0s. *\/\n-    if ( size != aligned_size )\n-    {\n-      v = 0;\n-      for ( i = aligned_size ; i < size; ++i )\n-        v |= (FT_ULong)buf[i] << ( 24 - 8 * ( i & 3 ) );\n-      checksum += v;\n-    }\n+    \/* remaining bytes can be shifted and added one at a time *\/\n+    for ( shift = 24; i < size; i++, shift -= 8 )\n+      checksum += (FT_UInt32)FT_NEXT_BYTE( buf ) << shift;\n@@ -319,2 +313,0 @@\n-#ifdef FT_CONFIG_OPTION_USE_BROTLI\n-\n@@ -341,7 +333,0 @@\n-\n-#else \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n-\n-    FT_ERROR(( \"woff2_decompress: Brotli support not available.\\n\" ));\n-    return FT_THROW( Unimplemented_Feature );\n-\n-#endif \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n@@ -354,1 +339,1 @@\n-              FT_ULong      tag )\n+              FT_Tag        tag )\n@@ -537,0 +522,1 @@\n+                FT_Bool            have_overlap,\n@@ -564,0 +550,3 @@\n+      if ( i == 0 && have_overlap )\n+        flag |= GLYF_OVERLAP_SIMPLE;\n+\n@@ -793,1 +782,1 @@\n-    if ( FT_NEW_ARRAY( loca_buf, loca_buf_size ) )\n+    if ( FT_QALLOC( loca_buf, loca_buf_size ) )\n@@ -848,0 +837,1 @@\n+    FT_UShort  option_flags;\n@@ -854,1 +844,0 @@\n-    FT_ULong   bitmap_length;\n@@ -857,0 +846,3 @@\n+    FT_ULong   bbox_bitmap_length;\n+    FT_ULong   overlap_bitmap_offset = 0;\n+    FT_ULong   overlap_bitmap_length = 0;\n@@ -869,1 +861,1 @@\n-    if ( FT_NEW_ARRAY( substreams, num_substreams ) )\n+    if ( FT_QNEW_ARRAY( substreams, num_substreams ) )\n@@ -872,1 +864,3 @@\n-    if ( FT_STREAM_SKIP( 4 ) )\n+    if ( FT_STREAM_SKIP( 2 ) )\n+      goto Fail;\n+    if ( FT_READ_USHORT( option_flags ) )\n@@ -879,2 +873,2 @@\n-    FT_TRACE4(( \"num_glyphs = %u; index_format = %u\\n\",\n-                num_glyphs, index_format ));\n+    FT_TRACE4(( \"option_flags = %u; num_glyphs = %u; index_format = %u\\n\",\n+                option_flags, num_glyphs, index_format ));\n@@ -893,1 +887,1 @@\n-    offset = ( 2 + num_substreams ) * 4;\n+    offset = 2 + 2 + 2 + 2 + ( num_substreams * 4 );\n@@ -916,1 +910,15 @@\n-    if ( FT_NEW_ARRAY( loca_values, num_glyphs + 1 ) )\n+    if ( option_flags & HAVE_OVERLAP_SIMPLE_BITMAP )\n+    {\n+      \/* Size of overlapBitmap = floor((numGlyphs + 7) \/ 8) *\/\n+      overlap_bitmap_length = ( num_glyphs + 7U ) >> 3;\n+      if ( overlap_bitmap_length > info->glyf_table->TransformLength - offset )\n+        goto Fail;\n+\n+      overlap_bitmap_offset = pos + offset;\n+\n+      FT_TRACE5(( \"  Overlap bitmap: offset = %lu; size = %lu;\\n\",\n+                  overlap_bitmap_offset, overlap_bitmap_length ));\n+      offset += overlap_bitmap_length;\n+    }\n+\n+    if ( FT_QNEW_ARRAY( loca_values, num_glyphs + 1 ) )\n@@ -923,2 +931,3 @@\n-    bitmap_length                   = ( ( num_glyphs + 31U ) >> 5 ) << 2;\n-    substreams[BBOX_STREAM].offset += bitmap_length;\n+    bbox_bitmap_length              = ( ( num_glyphs + 31U ) >> 5 ) << 2;\n+    \/* bboxStreamSize is the combined size of bboxBitmap and bboxStream. *\/\n+    substreams[BBOX_STREAM].offset += bbox_bitmap_length;\n@@ -927,1 +936,1 @@\n-    if ( FT_NEW_ARRAY( glyph_buf, glyph_buf_size ) )\n+    if ( FT_QALLOC( glyph_buf, glyph_buf_size ) )\n@@ -930,1 +939,1 @@\n-    if ( FT_NEW_ARRAY( info->x_mins, num_glyphs ) )\n+    if ( FT_QNEW_ARRAY( info->x_mins, num_glyphs ) )\n@@ -962,1 +971,1 @@\n-        FT_ULong   composite_size;\n+        FT_ULong   composite_size    = 0;\n@@ -988,1 +997,1 @@\n-          if ( FT_RENEW_ARRAY( glyph_buf, glyph_buf_size, size_needed ) )\n+          if ( FT_QREALLOC( glyph_buf, glyph_buf_size, size_needed ) )\n@@ -1040,2 +1049,5 @@\n-        FT_Byte*   flags_buf   = NULL;\n-        FT_Byte*   triplet_buf = NULL;\n+        FT_Bool    have_overlap  = FALSE;\n+        FT_Byte    overlap_bitmap;\n+        FT_ULong   overlap_offset;\n+        FT_Byte*   flags_buf     = NULL;\n+        FT_Byte*   triplet_buf   = NULL;\n@@ -1050,1 +1062,12 @@\n-        if ( FT_NEW_ARRAY( n_points_arr, n_contours ) )\n+        \/* Set `have_overlap`. *\/\n+        if ( overlap_bitmap_offset )\n+        {\n+          overlap_offset = overlap_bitmap_offset + ( i >> 3 );\n+          if ( FT_STREAM_SEEK( overlap_offset ) ||\n+               FT_READ_BYTE( overlap_bitmap )   )\n+            goto Fail;\n+          if ( overlap_bitmap & ( 0x80 >> ( i & 7 ) ) )\n+            have_overlap = TRUE;\n+        }\n+\n+        if ( FT_QNEW_ARRAY( n_points_arr, n_contours ) )\n@@ -1087,1 +1110,1 @@\n-        if ( FT_NEW_ARRAY( points, points_size ) )\n+        if ( FT_QNEW_ARRAY( points, points_size ) )\n@@ -1116,1 +1139,1 @@\n-          if ( FT_RENEW_ARRAY( glyph_buf, glyph_buf_size, size_needed ) )\n+          if ( FT_QREALLOC( glyph_buf, glyph_buf_size, size_needed ) )\n@@ -1170,0 +1193,1 @@\n+                           have_overlap,\n@@ -1200,2 +1224,1 @@\n-      if ( n_contours > 0 )\n-        info->x_mins[i] = (FT_Short)x_min;\n+      info->x_mins[i] = (FT_Short)x_min;\n@@ -1318,1 +1341,1 @@\n-    if ( FT_NEW_ARRAY( info->x_mins, num_glyphs ) )\n+    if ( FT_QNEW_ARRAY( info->x_mins, num_glyphs ) )\n@@ -1406,2 +1429,2 @@\n-    if ( FT_NEW_ARRAY( advance_widths, num_hmetrics ) ||\n-         FT_NEW_ARRAY( lsbs, num_glyphs )             )\n+    if ( FT_QNEW_ARRAY( advance_widths, num_hmetrics ) ||\n+         FT_QNEW_ARRAY( lsbs, num_glyphs )             )\n@@ -1458,1 +1481,1 @@\n-    if ( FT_NEW_ARRAY( hmtx_table, hmtx_table_size ) )\n+    if ( FT_QALLOC( hmtx_table, hmtx_table_size ) )\n@@ -1515,4 +1538,4 @@\n-    FT_Error   error       = FT_Err_Ok;\n-    FT_Stream  stream      = NULL;\n-    FT_Byte*   buf_cursor  = NULL;\n-    FT_Byte*   table_entry = NULL;\n+    FT_Error   error      = FT_Err_Ok;\n+    FT_Stream  stream     = NULL;\n+    FT_Byte*   buf_cursor = NULL;\n+    FT_Byte    table_entry[16];\n@@ -1559,4 +1582,0 @@\n-    \/* Create buffer for table entries. *\/\n-    if ( FT_NEW_ARRAY( table_entry, 16 ) )\n-      goto Fail;\n-\n@@ -1725,1 +1744,0 @@\n-    FT_FREE( table_entry );\n@@ -1738,1 +1756,0 @@\n-    FT_FREE( table_entry );\n@@ -1778,1 +1795,0 @@\n-    FT_Byte*   sfnt_header;\n@@ -1832,0 +1848,1 @@\n+         woff2.num_tables >  0xFFFU                                 ||\n@@ -1851,2 +1868,2 @@\n-    if ( FT_NEW_ARRAY( tables, woff2.num_tables )  ||\n-         FT_NEW_ARRAY( indices, woff2.num_tables ) )\n+    if ( FT_QNEW_ARRAY( tables, woff2.num_tables )  ||\n+         FT_QNEW_ARRAY( indices, woff2.num_tables ) )\n@@ -1855,5 +1872,4 @@\n-    FT_TRACE2((\n-      \"\\n\"\n-      \"  tag    flags    transform  origLen   transformLen   offset\\n\"\n-      \"  -----------------------------------------------------------\\n\" ));\n-   \/* \"  XXXX  XXXXXXXX  XXXXXXXX   XXXXXXXX    XXXXXXXX    XXXXXXXX\" *\/\n+    FT_TRACE2(( \"\\n\" ));\n+    FT_TRACE2(( \"  tag    flags    transform  origLen   transformLen   offset\\n\" ));\n+    FT_TRACE2(( \"  -----------------------------------------------------------\\n\" ));\n+             \/* \"  XXXX  XXXXXXXX  XXXXXXXX   XXXXXXXX    XXXXXXXX    XXXXXXXX\" *\/\n@@ -1924,0 +1940,1 @@\n+      table->flags      = flags;\n@@ -1927,1 +1944,1 @@\n-      table->flags      = flags;\n+      table->dst_offset = 0;\n@@ -1985,0 +2002,1 @@\n+      \/* pre-zero pointers within in case of failure *\/\n@@ -1998,1 +2016,1 @@\n-        if ( FT_NEW_ARRAY( ttc_font->table_indices, ttc_font->num_tables ) )\n+        if ( FT_QNEW_ARRAY( ttc_font->table_indices, ttc_font->num_tables ) )\n@@ -2079,1 +2097,1 @@\n-      file_offset = ROUND4(woff2.metaOffset + woff2.metaLength);\n+      file_offset = ROUND4( woff2.metaOffset + woff2.metaLength );\n@@ -2089,1 +2107,1 @@\n-      file_offset = ROUND4(woff2.privOffset + woff2.privLength);\n+      file_offset = ROUND4( woff2.privOffset + woff2.privLength );\n@@ -2101,1 +2119,1 @@\n-    if ( *face_instance_index < 0 )\n+    if ( *face_instance_index < 0 && face_index > 0 )\n@@ -2121,0 +2139,7 @@\n+      if ( ttc_font->num_tables == 0 || ttc_font->num_tables > 0xFFFU )\n+      {\n+        FT_ERROR(( \"woff2_open_font: invalid WOFF2 CollectionFontEntry\\n\" ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+\n@@ -2122,2 +2147,2 @@\n-      if ( FT_NEW_ARRAY( temp_indices,\n-                         ttc_font->num_tables ) )\n+      if ( FT_QNEW_ARRAY( temp_indices,\n+                          ttc_font->num_tables ) )\n@@ -2131,3 +2156,3 @@\n-      if ( FT_RENEW_ARRAY( indices,\n-                           woff2.num_tables,\n-                           ttc_font->num_tables ) )\n+      if ( FT_QRENEW_ARRAY( indices,\n+                            woff2.num_tables,\n+                            ttc_font->num_tables ) )\n@@ -2160,3 +2185,2 @@\n-      \/* Value 1<<26 = 67108864 is heuristic. *\/\n-      if (sfnt_size >= (1 << 26))\n-        sfnt_size = 1 << 26;\n+      if ( sfnt_size >= MAX_SFNT_SIZE )\n+        sfnt_size = MAX_SFNT_SIZE;\n@@ -2173,2 +2197,2 @@\n-    if ( FT_ALLOC( sfnt, sfnt_size ) ||\n-         FT_NEW( sfnt_stream )       )\n+    if ( FT_QALLOC( sfnt, sfnt_size ) ||\n+         FT_NEW( sfnt_stream )        )\n@@ -2177,5 +2201,0 @@\n-    sfnt_header = sfnt;\n-\n-    WRITE_ULONG( sfnt_header, woff2.flavor );\n-\n-    if ( woff2.num_tables )\n@@ -2183,2 +2202,1 @@\n-      FT_UInt  searchRange, entrySelector, rangeShift, x;\n-\n+      FT_Byte*  sfnt_header = sfnt;\n@@ -2186,8 +2204,3 @@\n-      x             = woff2.num_tables;\n-      entrySelector = 0;\n-      while ( x )\n-      {\n-        x            >>= 1;\n-        entrySelector += 1;\n-      }\n-      entrySelector--;\n+      FT_Int  entrySelector = FT_MSB( woff2.num_tables );\n+      FT_Int  searchRange   = ( 1 << entrySelector ) * 16;\n+      FT_Int  rangeShift    = woff2.num_tables * 16 - searchRange;\n@@ -2195,2 +2208,0 @@\n-      searchRange = ( 1 << entrySelector ) * 16;\n-      rangeShift  = ( woff2.num_tables * 16 ) - searchRange;\n@@ -2198,0 +2209,1 @@\n+      WRITE_ULONG ( sfnt_header, woff2.flavor );\n@@ -2212,0 +2224,19 @@\n+    \/* reject fonts that have multiple tables with the same tag *\/\n+    for ( nn = 1; nn < woff2.num_tables; nn++ )\n+    {\n+      FT_Tag  tag = indices[nn]->Tag;\n+\n+\n+      if ( tag == indices[nn - 1]->Tag )\n+      {\n+        FT_ERROR(( \"woff2_open_font:\"\n+                   \" multiple tables with tag `%c%c%c%c'.\\n\",\n+                   (FT_Char)( tag >> 24 ),\n+                   (FT_Char)( tag >> 16 ),\n+                   (FT_Char)( tag >> 8  ),\n+                   (FT_Char)( tag       ) ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+    }\n+\n@@ -2218,1 +2249,6 @@\n-    if ( woff2.uncompressed_size > sfnt_size )\n+    \/* We must not blindly trust `uncompressed_size` since its   *\/\n+    \/* value might be corrupted.  If it is too large, reject the *\/\n+    \/* font.  In other words, we don't accept a WOFF2 font that  *\/\n+    \/* expands to something larger than MAX_SFNT_SIZE.  If ever  *\/\n+    \/* necessary, this limit can be easily adjusted.             *\/\n+    if ( woff2.uncompressed_size > MAX_SFNT_SIZE )\n@@ -2220,2 +2256,2 @@\n-      FT_ERROR(( \"woff2_open_font: SFNT table lengths are too large.\\n\" ));\n-      error = FT_THROW( Invalid_Table );\n+      FT_ERROR(( \"Uncompressed font too large.\\n\" ));\n+      error = FT_THROW( Array_Too_Large );\n@@ -2226,2 +2262,2 @@\n-    if ( FT_ALLOC( uncompressed_buf, woff2.uncompressed_size ) ||\n-         FT_FRAME_ENTER( woff2.totalCompressedSize )           )\n+    if ( FT_QALLOC( uncompressed_buf, woff2.uncompressed_size ) ||\n+         FT_FRAME_ENTER( woff2.totalCompressedSize )            )\n@@ -2258,3 +2294,3 @@\n-      if ( FT_REALLOC( sfnt,\n-                       (FT_ULong)( sfnt_size ),\n-                       (FT_ULong)( woff2.actual_sfnt_size ) ) )\n+      if ( FT_QREALLOC( sfnt,\n+                        (FT_ULong)( sfnt_size ),\n+                        (FT_ULong)( woff2.actual_sfnt_size ) ) )\n@@ -2336,0 +2372,7 @@\n+#else \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n+  \/* ANSI C doesn't like empty source files *\/\n+  typedef int  sfwoff2_dummy_;\n+\n+#endif \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfwoff2.c","additions":159,"deletions":116,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2024 by\n@@ -29,0 +29,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n@@ -58,0 +59,1 @@\n+#define GLYF_OVERLAP_SIMPLE  1 << 6\n@@ -69,0 +71,1 @@\n+#endif \/* FT_CONFIG_OPTION_USE_BROTLI *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/sfwoff2.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n@@ -62,2 +62,2 @@\n-  tt_cmap_init( TT_CMap   cmap,\n-                FT_Byte*  table )\n+  tt_cmap_init( FT_CMap  cmap,    \/* TT_CMap *\/\n+                void*    table_ )\n@@ -65,1 +65,5 @@\n-    cmap->data = table;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  table  = (FT_Byte*)table_;\n+\n+\n+    ttcmap->data = table;\n@@ -131,1 +135,1 @@\n-  tt_cmap0_char_index( TT_CMap    cmap,\n+  tt_cmap0_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -134,1 +138,2 @@\n-    FT_Byte*  table = cmap->data;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  table  = ttcmap->data;\n@@ -141,2 +146,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap0_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap0_char_next( FT_CMap     cmap,        \/* TT_CMap *\/\n@@ -145,1 +150,2 @@\n-    FT_Byte*   table    = cmap->data;\n+    TT_CMap    ttcmap   = (TT_CMap)cmap;\n+    FT_Byte*   table    = ttcmap->data;\n@@ -168,1 +174,1 @@\n-  tt_cmap0_get_info( TT_CMap       cmap,\n+  tt_cmap0_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -171,1 +177,2 @@\n-    FT_Byte*  p = cmap->data + 4;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 4;\n@@ -456,1 +463,1 @@\n-  tt_cmap2_char_index( TT_CMap    cmap,\n+  tt_cmap2_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -459,1 +466,2 @@\n-    FT_Byte*  table   = cmap->data;\n+    TT_CMap   ttcmap  = (TT_CMap)cmap;\n+    FT_Byte*  table   = ttcmap->data;\n@@ -468,1 +476,1 @@\n-      FT_UInt   idx = (FT_UInt)(char_code & 0xFF);\n+      FT_UInt   idx = (FT_UInt)( char_code & 0xFF );\n@@ -494,2 +502,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap2_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap2_char_next( FT_CMap     cmap,       \/* TT_CMap *\/\n@@ -498,1 +506,2 @@\n-    FT_Byte*   table    = cmap->data;\n+    TT_CMap    ttcmap   = (TT_CMap)cmap;\n+    FT_Byte*   table    = ttcmap->data;\n@@ -582,1 +591,1 @@\n-  tt_cmap2_get_info( TT_CMap       cmap,\n+  tt_cmap2_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -585,1 +594,2 @@\n-    FT_Byte*  p = cmap->data + 4;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 4;\n@@ -709,2 +719,2 @@\n-  tt_cmap4_init( TT_CMap4  cmap,\n-                 FT_Byte*  table )\n+  tt_cmap4_init( FT_CMap  cmap,    \/* TT_CMap4 *\/\n+                 void*    table_ )\n@@ -712,0 +722,2 @@\n+    TT_CMap4  ttcmap = (TT_CMap4)cmap;\n+    FT_Byte*  table  = (FT_Byte*)table_;\n@@ -715,1 +727,1 @@\n-    cmap->cmap.data    = table;\n+    ttcmap->cmap.data = table;\n@@ -717,4 +729,4 @@\n-    p                  = table + 6;\n-    cmap->num_ranges   = FT_PEEK_USHORT( p ) >> 1;\n-    cmap->cur_charcode = (FT_UInt32)0xFFFFFFFFUL;\n-    cmap->cur_gindex   = 0;\n+    p                    = table + 6;\n+    ttcmap->num_ranges   = FT_PEEK_USHORT( p ) >> 1;\n+    ttcmap->cur_charcode = (FT_UInt32)0xFFFFFFFFUL;\n+    ttcmap->cur_gindex   = 0;\n@@ -758,1 +770,1 @@\n-        TT_Face   face  = (TT_Face)cmap->cmap.cmap.charmap.face;\n+        TT_Face   face  = (TT_Face)FT_CMAP_FACE( cmap );\n@@ -791,1 +803,1 @@\n-    TT_Face   face  = (TT_Face)cmap->cmap.cmap.charmap.face;\n+    TT_Face   face  = (TT_Face)FT_CMAP_FACE( cmap );\n@@ -797,3 +809,0 @@\n-    if ( cmap->cur_charcode >= 0xFFFFUL )\n-      goto Fail;\n-\n@@ -885,1 +894,0 @@\n-  Fail:\n@@ -919,0 +927,10 @@\n+    \/* it also happens that the `length' field is too small; *\/\n+    \/* this is easy to correct                               *\/\n+    if ( length < (FT_UInt)( valid->limit - table ) )\n+    {\n+      if ( valid->level >= FT_VALIDATE_PARANOID )\n+        FT_INVALID_DATA;\n+\n+      length = (FT_UInt)( valid->limit - table );\n+    }\n+\n@@ -1090,1 +1108,1 @@\n-    TT_Face   face  = (TT_Face)cmap->cmap.charmap.face;\n+    TT_Face   face  = (TT_Face)FT_CMAP_FACE( cmap );\n@@ -1097,1 +1115,1 @@\n-    FT_UInt32  charcode = *pcharcode;\n+    FT_UInt32  charcode = *pcharcode + next;\n@@ -1104,3 +1122,1 @@\n-    num_segs2 = FT_PAD_FLOOR( TT_PEEK_USHORT( p ), 2 );\n-\n-    num_segs = num_segs2 >> 1;\n+    num_segs = TT_PEEK_USHORT( p ) >> 1;\n@@ -1111,5 +1127,1 @@\n-    if ( next )\n-      charcode++;\n-\n-    if ( charcode > 0xFFFFU )\n-      return 0;\n+    num_segs2 = num_segs << 1;\n@@ -1225,1 +1237,1 @@\n-    TT_Face   face  = (TT_Face)cmap->cmap.charmap.face;\n+    TT_Face   face  = (TT_Face)FT_CMAP_FACE( cmap );\n@@ -1231,1 +1243,1 @@\n-    FT_UInt   charcode = (FT_UInt)*pcharcode;\n+    FT_UInt   charcode = (FT_UInt)*pcharcode + next;\n@@ -1237,1 +1249,1 @@\n-    num_segs2 = FT_PAD_FLOOR( TT_PEEK_USHORT( p ), 2 );\n+    num_segs = TT_PEEK_USHORT( p ) >> 1;\n@@ -1239,1 +1251,1 @@\n-    if ( !num_segs2 )\n+    if ( !num_segs )\n@@ -1242,8 +1254,1 @@\n-    num_segs = num_segs2 >> 1;\n-\n-    \/* make compiler happy *\/\n-    mid = num_segs;\n-    end = 0xFFFFU;\n-\n-    if ( next )\n-      charcode++;\n+    num_segs2 = num_segs << 1;\n@@ -1255,1 +1260,1 @@\n-    while ( min < max )\n+    do\n@@ -1438,0 +1443,1 @@\n+    while ( min < max );\n@@ -1447,6 +1453,2 @@\n-      if ( charcode > end )\n-      {\n-        mid++;\n-        if ( mid == num_segs )\n-          return 0;\n-      }\n+      if ( charcode > end && ++mid == num_segs )\n+        return 0;\n@@ -1467,1 +1469,0 @@\n-          cmap4->cur_charcode = charcode;\n@@ -1482,1 +1483,1 @@\n-  tt_cmap4_char_index( TT_CMap    cmap,\n+  tt_cmap4_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -1485,0 +1486,3 @@\n+    TT_CMap  ttcmap = (TT_CMap)cmap;\n+\n+\n@@ -1488,2 +1492,2 @@\n-    if ( cmap->flags & TT_CMAP_FLAG_UNSORTED )\n-      return tt_cmap4_char_map_linear( cmap, &char_code, 0 );\n+    if ( ttcmap->flags & TT_CMAP_FLAG_UNSORTED )\n+      return tt_cmap4_char_map_linear( ttcmap, &char_code, 0 );\n@@ -1491,1 +1495,1 @@\n-      return tt_cmap4_char_map_binary( cmap, &char_code, 0 );\n+      return tt_cmap4_char_map_binary( ttcmap, &char_code, 0 );\n@@ -1495,2 +1499,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap4_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap4_char_next( FT_CMap     cmap,        \/* TT_CMap *\/\n@@ -1499,0 +1503,1 @@\n+    TT_CMap  ttcmap = (TT_CMap)cmap;\n@@ -1505,2 +1510,2 @@\n-    if ( cmap->flags & TT_CMAP_FLAG_UNSORTED )\n-      gindex = tt_cmap4_char_map_linear( cmap, pchar_code, 1 );\n+    if ( ttcmap->flags & TT_CMAP_FLAG_UNSORTED )\n+      gindex = tt_cmap4_char_map_linear( ttcmap, pchar_code, 1 );\n@@ -1521,1 +1526,1 @@\n-        gindex = tt_cmap4_char_map_binary( cmap, pchar_code, 1 );\n+        gindex = tt_cmap4_char_map_binary( ttcmap, pchar_code, 1 );\n@@ -1529,1 +1534,1 @@\n-  tt_cmap4_get_info( TT_CMap       cmap,\n+  tt_cmap4_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -1532,1 +1537,2 @@\n-    FT_Byte*  p = cmap->data + 4;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 4;\n@@ -1633,1 +1639,1 @@\n-  tt_cmap6_char_index( TT_CMap    cmap,\n+  tt_cmap6_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -1636,1 +1642,2 @@\n-    FT_Byte*  table  = cmap->data;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  table  = ttcmap->data;\n@@ -1654,2 +1661,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap6_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap6_char_next( FT_CMap     cmap,        \/* TT_CMap *\/\n@@ -1658,1 +1665,2 @@\n-    FT_Byte*   table     = cmap->data;\n+    TT_CMap    ttcmap    = (TT_CMap)cmap;\n+    FT_Byte*   table     = ttcmap->data;\n@@ -1699,1 +1707,1 @@\n-  tt_cmap6_get_info( TT_CMap       cmap,\n+  tt_cmap6_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -1702,1 +1710,2 @@\n-    FT_Byte*  p = cmap->data + 4;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 4;\n@@ -1893,1 +1902,1 @@\n-  tt_cmap8_char_index( TT_CMap    cmap,\n+  tt_cmap8_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -1896,1 +1905,2 @@\n-    FT_Byte*   table      = cmap->data;\n+    TT_CMap    ttcmap     = (TT_CMap)cmap;\n+    FT_Byte*   table      = ttcmap->data;\n@@ -1925,2 +1935,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap8_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap8_char_next( FT_CMap     cmap,        \/* TT_CMap *\/\n@@ -1929,1 +1939,2 @@\n-    FT_Face    face       = cmap->cmap.charmap.face;\n+    TT_CMap    ttcmap     = (TT_CMap)cmap;\n+    FT_Face    face       = FT_CMAP_FACE( cmap );\n@@ -1933,1 +1944,1 @@\n-    FT_Byte*   table      = cmap->data;\n+    FT_Byte*   table      = ttcmap->data;\n@@ -1993,1 +2004,1 @@\n-  tt_cmap8_get_info( TT_CMap       cmap,\n+  tt_cmap8_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -1996,1 +2007,2 @@\n-    FT_Byte*  p = cmap->data + 8;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 8;\n@@ -2097,1 +2109,1 @@\n-  tt_cmap10_char_index( TT_CMap    cmap,\n+  tt_cmap10_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -2100,1 +2112,2 @@\n-    FT_Byte*   table  = cmap->data;\n+    TT_CMap    ttcmap = (TT_CMap)cmap;\n+    FT_Byte*   table  = ttcmap->data;\n@@ -2123,2 +2136,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap10_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap10_char_next( FT_CMap     cmap,        \/* TT_CMap *\/\n@@ -2127,1 +2140,2 @@\n-    FT_Byte*   table     = cmap->data;\n+    TT_CMap    ttcmap    = (TT_CMap)cmap;\n+    FT_Byte*   table     = ttcmap->data;\n@@ -2165,1 +2179,1 @@\n-  tt_cmap10_get_info( TT_CMap       cmap,\n+  tt_cmap10_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -2168,1 +2182,2 @@\n-    FT_Byte*  p = cmap->data + 8;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 8;\n@@ -2246,2 +2261,2 @@\n-  tt_cmap12_init( TT_CMap12  cmap,\n-                  FT_Byte*   table )\n+  tt_cmap12_init( FT_CMap  cmap,    \/* TT_CMap12 *\/\n+                  void*    table_ )\n@@ -2249,1 +2264,5 @@\n-    cmap->cmap.data  = table;\n+    TT_CMap12  ttcmap = (TT_CMap12)cmap;\n+    FT_Byte*   table  = (FT_Byte*)table_;\n+\n+\n+    ttcmap->cmap.data  = table;\n@@ -2251,2 +2270,2 @@\n-    table           += 12;\n-    cmap->num_groups = FT_PEEK_ULONG( table );\n+    table             += 12;\n+    ttcmap->num_groups = FT_PEEK_ULONG( table );\n@@ -2254,1 +2273,1 @@\n-    cmap->valid      = 0;\n+    ttcmap->valid      = 0;\n@@ -2324,1 +2343,1 @@\n-  tt_cmap12_next( TT_CMap12  cmap )\n+  tt_cmap12_next( FT_CMap  cmap )    \/* TT_CMap12 *\/\n@@ -2326,6 +2345,6 @@\n-    FT_Face   face = cmap->cmap.cmap.charmap.face;\n-    FT_Byte*  p;\n-    FT_ULong  start, end, start_id, char_code;\n-    FT_ULong  n;\n-    FT_UInt   gindex;\n-\n+    TT_CMap12  ttcmap = (TT_CMap12)cmap;\n+    FT_Face    face   = FT_CMAP_FACE( cmap );\n+    FT_Byte*   p;\n+    FT_ULong   start, end, start_id, char_code;\n+    FT_ULong   n;\n+    FT_UInt    gindex;\n@@ -2333,2 +2352,0 @@\n-    if ( cmap->cur_charcode >= 0xFFFFFFFFUL )\n-      goto Fail;\n@@ -2336,1 +2353,1 @@\n-    char_code = cmap->cur_charcode + 1;\n+    char_code = ttcmap->cur_charcode + 1;\n@@ -2338,1 +2355,1 @@\n-    for ( n = cmap->cur_group; n < cmap->num_groups; n++ )\n+    for ( n = ttcmap->cur_group; n < ttcmap->num_groups; n++ )\n@@ -2340,1 +2357,1 @@\n-      p        = cmap->cmap.data + 16 + 12 * n;\n+      p        = ttcmap->cmap.data + 16 + 12 * n;\n@@ -2372,3 +2389,3 @@\n-        cmap->cur_charcode = char_code;\n-        cmap->cur_gindex   = gindex;\n-        cmap->cur_group    = n;\n+        ttcmap->cur_charcode = char_code;\n+        ttcmap->cur_gindex   = gindex;\n+        ttcmap->cur_group    = n;\n@@ -2381,1 +2398,1 @@\n-    cmap->valid = 0;\n+    ttcmap->valid = 0;\n@@ -2393,1 +2410,1 @@\n-    FT_UInt32  char_code  = *pchar_code;\n+    FT_UInt32  char_code  = *pchar_code + next;\n@@ -2401,12 +2418,0 @@\n-    \/* make compiler happy *\/\n-    mid = num_groups;\n-    end = 0xFFFFFFFFUL;\n-\n-    if ( next )\n-    {\n-      if ( char_code >= 0xFFFFFFFFUL )\n-        return 0;\n-\n-      char_code++;\n-    }\n-\n@@ -2417,1 +2422,1 @@\n-    while ( min < max )\n+    do\n@@ -2441,0 +2446,1 @@\n+    while ( min < max );\n@@ -2444,1 +2450,1 @@\n-      FT_Face    face   = cmap->cmap.charmap.face;\n+      FT_Face    face   = FT_CMAP_FACE( cmap );\n@@ -2451,6 +2457,2 @@\n-      if ( char_code > end )\n-      {\n-        mid++;\n-        if ( mid == num_groups )\n-          return 0;\n-      }\n+      if ( char_code > end && ++mid == num_groups )\n+        return 0;\n@@ -2467,1 +2469,1 @@\n-        tt_cmap12_next( cmap12 );\n+        tt_cmap12_next( FT_CMAP( cmap12 ) );\n@@ -2483,1 +2485,1 @@\n-  tt_cmap12_char_index( TT_CMap    cmap,\n+  tt_cmap12_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -2486,1 +2488,1 @@\n-    return tt_cmap12_char_map_binary( cmap, &char_code, 0 );\n+    return tt_cmap12_char_map_binary( (TT_CMap)cmap, &char_code, 0 );\n@@ -2490,2 +2492,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap12_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap12_char_next( FT_CMap     cmap,        \/* TT_CMap12 *\/\n@@ -2498,0 +2500,3 @@\n+    if ( *pchar_code >= 0xFFFFFFFFUL )\n+      return 0;\n+\n@@ -2501,1 +2506,1 @@\n-      tt_cmap12_next( cmap12 );\n+      tt_cmap12_next( FT_CMAP( cmap12 ) );\n@@ -2511,1 +2516,1 @@\n-      gindex = tt_cmap12_char_map_binary( cmap, pchar_code, 1 );\n+      gindex = tt_cmap12_char_map_binary( (TT_CMap)cmap, pchar_code, 1 );\n@@ -2518,1 +2523,1 @@\n-  tt_cmap12_get_info( TT_CMap       cmap,\n+  tt_cmap12_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -2521,1 +2526,2 @@\n-    FT_Byte*  p = cmap->data + 8;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 8;\n@@ -2599,2 +2605,2 @@\n-  tt_cmap13_init( TT_CMap13  cmap,\n-                  FT_Byte*   table )\n+  tt_cmap13_init( FT_CMap  cmap,    \/* TT_CMap13 *\/\n+                  void*    table_ )\n@@ -2602,1 +2608,2 @@\n-    cmap->cmap.data  = table;\n+    TT_CMap13  ttcmap = (TT_CMap13)cmap;\n+    FT_Byte*   table  = (FT_Byte*)table_;\n@@ -2604,2 +2611,0 @@\n-    table           += 12;\n-    cmap->num_groups = FT_PEEK_ULONG( table );\n@@ -2607,1 +2612,6 @@\n-    cmap->valid      = 0;\n+    ttcmap->cmap.data  = table;\n+\n+    table             += 12;\n+    ttcmap->num_groups = FT_PEEK_ULONG( table );\n+\n+    ttcmap->valid      = 0;\n@@ -2672,1 +2682,1 @@\n-  tt_cmap13_next( TT_CMap13  cmap )\n+  tt_cmap13_next( FT_CMap  cmap )    \/* TT_CMap13 *\/\n@@ -2674,6 +2684,6 @@\n-    FT_Face   face = cmap->cmap.cmap.charmap.face;\n-    FT_Byte*  p;\n-    FT_ULong  start, end, glyph_id, char_code;\n-    FT_ULong  n;\n-    FT_UInt   gindex;\n-\n+    TT_CMap13  ttcmap = (TT_CMap13)cmap;\n+    FT_Face    face = FT_CMAP_FACE( cmap );\n+    FT_Byte*   p;\n+    FT_ULong   start, end, glyph_id, char_code;\n+    FT_ULong   n;\n+    FT_UInt    gindex;\n@@ -2681,2 +2691,0 @@\n-    if ( cmap->cur_charcode >= 0xFFFFFFFFUL )\n-      goto Fail;\n@@ -2684,1 +2692,1 @@\n-    char_code = cmap->cur_charcode + 1;\n+    char_code = ttcmap->cur_charcode + 1;\n@@ -2686,1 +2694,1 @@\n-    for ( n = cmap->cur_group; n < cmap->num_groups; n++ )\n+    for ( n = ttcmap->cur_group; n < ttcmap->num_groups; n++ )\n@@ -2688,1 +2696,1 @@\n-      p        = cmap->cmap.data + 16 + 12 * n;\n+      p        = ttcmap->cmap.data + 16 + 12 * n;\n@@ -2702,3 +2710,3 @@\n-          cmap->cur_charcode = char_code;\n-          cmap->cur_gindex   = gindex;\n-          cmap->cur_group    = n;\n+          ttcmap->cur_charcode = char_code;\n+          ttcmap->cur_gindex   = gindex;\n+          ttcmap->cur_group    = n;\n@@ -2711,2 +2719,1 @@\n-  Fail:\n-    cmap->valid = 0;\n+    ttcmap->valid = 0;\n@@ -2724,1 +2731,1 @@\n-    FT_UInt32  char_code  = *pchar_code;\n+    FT_UInt32  char_code  = *pchar_code + next;\n@@ -2732,12 +2739,0 @@\n-    \/* make compiler happy *\/\n-    mid = num_groups;\n-    end = 0xFFFFFFFFUL;\n-\n-    if ( next )\n-    {\n-      if ( char_code >= 0xFFFFFFFFUL )\n-        return 0;\n-\n-      char_code++;\n-    }\n-\n@@ -2748,1 +2743,1 @@\n-    while ( min < max )\n+    do\n@@ -2767,0 +2762,1 @@\n+    while ( min < max );\n@@ -2777,6 +2773,2 @@\n-      if ( char_code > end )\n-      {\n-        mid++;\n-        if ( mid == num_groups )\n-          return 0;\n-      }\n+      if ( char_code > end && ++mid == num_groups )\n+        return 0;\n@@ -2793,1 +2785,1 @@\n-        tt_cmap13_next( cmap13 );\n+        tt_cmap13_next( FT_CMAP( cmap13 ) );\n@@ -2809,1 +2801,1 @@\n-  tt_cmap13_char_index( TT_CMap    cmap,\n+  tt_cmap13_char_index( FT_CMap    cmap,       \/* TT_CMap *\/\n@@ -2812,1 +2804,1 @@\n-    return tt_cmap13_char_map_binary( cmap, &char_code, 0 );\n+    return tt_cmap13_char_map_binary( (TT_CMap)cmap, &char_code, 0 );\n@@ -2816,2 +2808,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap13_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap13_char_next( FT_CMap     cmap,        \/* TT_CMap13 *\/\n@@ -2824,0 +2816,3 @@\n+    if ( *pchar_code >= 0xFFFFFFFFUL )\n+      return 0;\n+\n@@ -2827,1 +2822,1 @@\n-      tt_cmap13_next( cmap13 );\n+      tt_cmap13_next( FT_CMAP( cmap13 ) );\n@@ -2837,1 +2832,1 @@\n-      gindex = tt_cmap13_char_map_binary( cmap, pchar_code, 1 );\n+      gindex = tt_cmap13_char_map_binary( (TT_CMap)cmap, pchar_code, 1 );\n@@ -2844,1 +2839,1 @@\n-  tt_cmap13_get_info( TT_CMap       cmap,\n+  tt_cmap13_get_info( FT_CharMap    cmap,       \/* TT_CMap *\/\n@@ -2847,1 +2842,2 @@\n-    FT_Byte*  p = cmap->data + 8;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = ttcmap->data + 8;\n@@ -2962,1 +2958,1 @@\n-  tt_cmap14_done( TT_CMap14  cmap )\n+  tt_cmap14_done( FT_CMap  cmap )    \/* TT_CMap14 *\/\n@@ -2964,1 +2960,2 @@\n-    FT_Memory  memory = cmap->memory;\n+    TT_CMap14  ttcmap = (TT_CMap14)cmap;\n+    FT_Memory  memory = ttcmap->memory;\n@@ -2967,3 +2964,3 @@\n-    cmap->max_results = 0;\n-    if ( memory && cmap->results )\n-      FT_FREE( cmap->results );\n+    ttcmap->max_results = 0;\n+    if ( memory && ttcmap->results )\n+      FT_FREE( ttcmap->results );\n@@ -2997,2 +2994,2 @@\n-  tt_cmap14_init( TT_CMap14  cmap,\n-                  FT_Byte*   table )\n+  tt_cmap14_init( FT_CMap  cmap,    \/* TT_CMap14 *\/\n+                  void*    table_ )\n@@ -3000,1 +2997,5 @@\n-    cmap->cmap.data = table;\n+    TT_CMap14  ttcmap = (TT_CMap14)cmap;\n+    FT_Byte*   table  = (FT_Byte*)table_;\n+\n+\n+    ttcmap->cmap.data = table;\n@@ -3002,4 +3003,4 @@\n-    table               += 6;\n-    cmap->num_selectors  = FT_PEEK_ULONG( table );\n-    cmap->max_results    = 0;\n-    cmap->results        = NULL;\n+    table                 += 6;\n+    ttcmap->num_selectors  = FT_PEEK_ULONG( table );\n+    ttcmap->max_results    = 0;\n+    ttcmap->results        = NULL;\n@@ -3135,1 +3136,1 @@\n-  tt_cmap14_char_index( TT_CMap    cmap,\n+  tt_cmap14_char_index( FT_CMap    cmap,\n@@ -3146,2 +3147,2 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap14_char_next( TT_CMap     cmap,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap14_char_next( FT_CMap     cmap,\n@@ -3159,1 +3160,1 @@\n-  tt_cmap14_get_info( TT_CMap       cmap,\n+  tt_cmap14_get_info( FT_CharMap    cmap,\n@@ -3273,2 +3274,2 @@\n-  tt_cmap14_char_var_index( TT_CMap    cmap,\n-                            TT_CMap    ucmap,\n+  tt_cmap14_char_var_index( FT_CMap    cmap,             \/* TT_CMap *\/\n+                            FT_CMap    ucmap,            \/* TT_CMap *\/\n@@ -3278,1 +3279,5 @@\n-    FT_Byte*  p = tt_cmap14_find_variant( cmap->data + 6, variantSelector );\n+    TT_CMap  ttcmap  = (TT_CMap)cmap;\n+    TT_CMap  ttucmap = (TT_CMap)ucmap;\n+\n+    FT_Byte*  p = tt_cmap14_find_variant( ttcmap->data + 6,\n+                                          variantSelector );\n@@ -3289,2 +3294,2 @@\n-    if ( defOff != 0                                                    &&\n-         tt_cmap14_char_map_def_binary( cmap->data + defOff, charcode ) )\n+    if ( defOff != 0                                                      &&\n+         tt_cmap14_char_map_def_binary( ttcmap->data + defOff, charcode ) )\n@@ -3294,1 +3299,1 @@\n-      return ucmap->cmap.clazz->char_index( &ucmap->cmap, charcode );\n+      return ttucmap->cmap.clazz->char_index( &ttucmap->cmap, charcode );\n@@ -3298,1 +3303,1 @@\n-      return tt_cmap14_char_map_nondef_binary( cmap->data + nondefOff,\n+      return tt_cmap14_char_map_nondef_binary( ttcmap->data + nondefOff,\n@@ -3306,1 +3311,1 @@\n-  tt_cmap14_char_var_isdefault( TT_CMap    cmap,\n+  tt_cmap14_char_var_isdefault( FT_CMap    cmap,             \/* TT_CMap *\/\n@@ -3310,1 +3315,3 @@\n-    FT_Byte*  p = tt_cmap14_find_variant( cmap->data + 6, variantSelector );\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte*  p      = tt_cmap14_find_variant( ttcmap->data + 6,\n+                                               variantSelector );\n@@ -3321,2 +3328,2 @@\n-    if ( defOff != 0                                                    &&\n-         tt_cmap14_char_map_def_binary( cmap->data + defOff, charcode ) )\n+    if ( defOff != 0                                                      &&\n+         tt_cmap14_char_map_def_binary( ttcmap->data + defOff, charcode ) )\n@@ -3325,3 +3332,3 @@\n-    if ( nondefOff != 0                                            &&\n-         tt_cmap14_char_map_nondef_binary( cmap->data + nondefOff,\n-                                           charcode ) != 0         )\n+    if ( nondefOff != 0                                              &&\n+         tt_cmap14_char_map_nondef_binary( ttcmap->data + nondefOff,\n+                                           charcode ) != 0           )\n@@ -3335,1 +3342,1 @@\n-  tt_cmap14_variants( TT_CMap    cmap,\n+  tt_cmap14_variants( FT_CMap    cmap,    \/* TT_CMap14 *\/\n@@ -3338,0 +3345,1 @@\n+    TT_CMap     ttcmap = (TT_CMap)cmap;\n@@ -3340,1 +3348,1 @@\n-    FT_Byte*    p      = cmap->data + 10;\n+    FT_Byte*    p      = ttcmap->data + 10;\n@@ -3361,1 +3369,1 @@\n-  tt_cmap14_char_variants( TT_CMap    cmap,\n+  tt_cmap14_char_variants( FT_CMap    cmap,      \/* TT_CMap14 *\/\n@@ -3365,1 +3373,2 @@\n-    TT_CMap14   cmap14 = (TT_CMap14)  cmap;\n+    TT_CMap     ttcmap = (TT_CMap)cmap;\n+    TT_CMap14   cmap14 = (TT_CMap14)cmap;\n@@ -3367,1 +3376,1 @@\n-    FT_Byte*    p      = cmap->data + 10;\n+    FT_Byte*    p      = ttcmap->data + 10;\n@@ -3381,6 +3390,6 @@\n-      if ( ( defOff != 0                                               &&\n-             tt_cmap14_char_map_def_binary( cmap->data + defOff,\n-                                            charCode )                 ) ||\n-           ( nondefOff != 0                                            &&\n-             tt_cmap14_char_map_nondef_binary( cmap->data + nondefOff,\n-                                               charCode ) != 0         ) )\n+      if ( ( defOff != 0                                                 &&\n+             tt_cmap14_char_map_def_binary( ttcmap->data + defOff,\n+                                            charCode )                   ) ||\n+           ( nondefOff != 0                                              &&\n+             tt_cmap14_char_map_nondef_binary( ttcmap->data + nondefOff,\n+                                               charCode ) != 0           ) )\n@@ -3482,1 +3491,1 @@\n-  tt_cmap14_variant_chars( TT_CMap    cmap,\n+  tt_cmap14_variant_chars( FT_CMap    cmap,             \/* TT_CMap *\/\n@@ -3486,5 +3495,6 @@\n-    FT_Byte    *p  = tt_cmap14_find_variant( cmap->data + 6,\n-                                             variantSelector );\n-    FT_Int      i;\n-    FT_ULong    defOff;\n-    FT_ULong    nondefOff;\n+    TT_CMap   ttcmap = (TT_CMap)cmap;\n+    FT_Byte  *p      = tt_cmap14_find_variant( ttcmap->data + 6,\n+                                               variantSelector );\n+    FT_Int    i;\n+    FT_ULong  defOff;\n+    FT_ULong  nondefOff;\n@@ -3503,1 +3513,1 @@\n-      return tt_cmap14_get_nondef_chars( cmap, cmap->data + nondefOff,\n+      return tt_cmap14_get_nondef_chars( ttcmap, ttcmap->data + nondefOff,\n@@ -3506,1 +3516,1 @@\n-      return tt_cmap14_get_def_chars( cmap, cmap->data + defOff,\n+      return tt_cmap14_get_def_chars( ttcmap, ttcmap->data + defOff,\n@@ -3512,1 +3522,1 @@\n-      TT_CMap14  cmap14 = (TT_CMap14) cmap;\n+      TT_CMap14  cmap14 = (TT_CMap14)cmap;\n@@ -3524,2 +3534,2 @@\n-      p  = cmap->data + nondefOff;\n-      dp = cmap->data + defOff;\n+      p  = ttcmap->data + nondefOff;\n+      dp = ttcmap->data + defOff;\n@@ -3532,1 +3542,1 @@\n-        return tt_cmap14_get_def_chars( cmap, cmap->data + defOff,\n+        return tt_cmap14_get_def_chars( ttcmap, ttcmap->data + defOff,\n@@ -3535,1 +3545,1 @@\n-        return tt_cmap14_get_nondef_chars( cmap, cmap->data + nondefOff,\n+        return tt_cmap14_get_nondef_chars( ttcmap, ttcmap->data + nondefOff,\n@@ -3657,1 +3667,1 @@\n-  tt_get_glyph_name( TT_Face  face,\n+  tt_get_glyph_name( void*    face_,   \/* TT_Face *\/\n@@ -3660,0 +3670,1 @@\n+    TT_Face     face   = (TT_Face)face_;\n@@ -3670,2 +3681,2 @@\n-  tt_cmap_unicode_init( PS_Unicodes  unicodes,\n-                        FT_Pointer   pointer )\n+  tt_cmap_unicode_init( FT_CMap     cmap,     \/* PS_Unicodes *\/\n+                        FT_Pointer  pointer )\n@@ -3673,3 +3684,4 @@\n-    TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );\n-    FT_Memory           memory  = FT_FACE_MEMORY( face );\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    TT_Face             face     = (TT_Face)FT_CMAP_FACE( cmap );\n+    FT_Memory           memory   = FT_FACE_MEMORY( face );\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)face->psnames;\n@@ -3686,1 +3698,1 @@\n-                                   (PS_GetGlyphNameFunc)&tt_get_glyph_name,\n+                                   &tt_get_glyph_name,\n@@ -3693,1 +3705,1 @@\n-  tt_cmap_unicode_done( PS_Unicodes  unicodes )\n+  tt_cmap_unicode_done( FT_CMap  cmap )    \/* PS_Unicodes *\/\n@@ -3695,2 +3707,3 @@\n-    FT_Face    face   = FT_CMAP_FACE( unicodes );\n-    FT_Memory  memory = FT_FACE_MEMORY( face );\n+    PS_Unicodes  unicodes = (PS_Unicodes)cmap;\n+    FT_Face      face     = FT_CMAP_FACE( cmap );\n+    FT_Memory    memory   = FT_FACE_MEMORY( face );\n@@ -3705,2 +3718,2 @@\n-  tt_cmap_unicode_char_index( PS_Unicodes  unicodes,\n-                              FT_UInt32    char_code )\n+  tt_cmap_unicode_char_index( FT_CMap    cmap,       \/* PS_Unicodes *\/\n+                              FT_UInt32  char_code )\n@@ -3708,2 +3721,3 @@\n-    TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    TT_Face             face     = (TT_Face)FT_CMAP_FACE( cmap );\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)face->psnames;\n@@ -3716,3 +3730,3 @@\n-  FT_CALLBACK_DEF( FT_UInt32 )\n-  tt_cmap_unicode_char_next( PS_Unicodes  unicodes,\n-                             FT_UInt32   *pchar_code )\n+  FT_CALLBACK_DEF( FT_UInt )\n+  tt_cmap_unicode_char_next( FT_CMap     cmap,        \/* PS_Unicodes *\/\n+                             FT_UInt32  *pchar_code )\n@@ -3720,2 +3734,3 @@\n-    TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );\n-    FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face->psnames;\n+    PS_Unicodes         unicodes = (PS_Unicodes)cmap;\n+    TT_Face             face     = (TT_Face)FT_CMAP_FACE( cmap );\n+    FT_Service_PsCMaps  psnames  = (FT_Service_PsCMaps)face->psnames;\n@@ -3872,1 +3887,1 @@\n-  FT_LOCAL( FT_Error )\n+  FT_LOCAL_DEF( FT_Error )\n@@ -3876,1 +3891,1 @@\n-    FT_CMap        cmap  = (FT_CMap)charmap;\n+    FT_CMap        cmap  = FT_CMAP( charmap );\n@@ -3879,0 +3894,1 @@\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcmap.c","additions":290,"deletions":274,"binary":false,"changes":564,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2009-2020 by\n+ * Copyright (C) 2009-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcmapc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (C) 2018-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ * Copyright (C) 2018-2024 by\n+ * David Turner, Robert Wilhelm, Dominik Röttsches, and Werner Lemberg.\n@@ -30,0 +30,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -34,0 +35,1 @@\n+#include <freetype\/config\/integer-types.h>\n@@ -35,0 +37,3 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+#include <freetype\/internal\/services\/svmm.h>\n+#endif\n@@ -42,6 +47,46 @@\n-#define BASE_GLYPH_SIZE            6U\n-#define LAYER_SIZE                 4U\n-#define COLR_HEADER_SIZE          14U\n-\n-\n-  typedef struct BaseGlyphRecord_\n+#define BASE_GLYPH_SIZE                   6U\n+#define BASE_GLYPH_PAINT_RECORD_SIZE      6U\n+#define LAYER_V1_LIST_PAINT_OFFSET_SIZE   4U\n+#define LAYER_V1_LIST_NUM_LAYERS_SIZE     4U\n+#define COLOR_STOP_SIZE                   6U\n+#define VAR_IDX_BASE_SIZE                 4U\n+#define LAYER_SIZE                        4U\n+\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr#colr-header *\/\n+\/* 3 * uint16 + 2 * Offset32 *\/\n+#define COLRV0_HEADER_SIZE               14U\n+\/* COLRV0_HEADER_SIZE + 5 * Offset32 *\/\n+#define COLRV1_HEADER_SIZE               34U\n+\n+\n+#define ENSURE_READ_BYTES( byte_size )                             \\\n+  if ( p < colr->paints_start_v1                                || \\\n+       p > (FT_Byte*)colr->table + colr->table_size - byte_size )  \\\n+    return 0\n+\n+\n+  typedef enum  FT_PaintFormat_Internal_\n+  {\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SOLID                = 3,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_LINEAR_GRADIENT      = 5,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_RADIAL_GRADIENT      = 7,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SWEEP_GRADIENT       = 9,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSFORM            = 13,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSLATE            = 15,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE                = 17,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER             = 18,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER         = 19,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM            = 20,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM        = 21,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER     = 22,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER = 23,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE               = 25,\n+    FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER            = 26,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER        = 27,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW                 = 29,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER              = 30,\n+    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER          = 31,\n+\n+  } FT_PaintFormat_Internal;\n+\n+\n+  typedef struct  BaseGlyphRecord_\n@@ -56,1 +101,10 @@\n-  typedef struct Colr_\n+  typedef struct  BaseGlyphV1Record_\n+  {\n+    FT_UShort  gid;\n+    \/* Offset from start of BaseGlyphV1List, i.e., from base_glyphs_v1. *\/\n+    FT_ULong   paint_offset;\n+\n+  } BaseGlyphV1Record;\n+\n+\n+  typedef struct  Colr_\n@@ -65,1 +119,23 @@\n-    \/* The memory which backs up the `COLR' table. *\/\n+    FT_ULong  num_base_glyphs_v1;\n+    \/* Points at beginning of BaseGlyphV1List. *\/\n+    FT_Byte*  base_glyphs_v1;\n+\n+    FT_ULong  num_layers_v1;\n+    FT_Byte*  layers_v1;\n+\n+    FT_Byte*  clip_list;\n+\n+    \/*\n+     * Paint tables start at the minimum of the end of the LayerList and the\n+     * end of the BaseGlyphList.  Record this location in a field here for\n+     * safety checks when accessing paint tables.\n+     *\/\n+    FT_Byte*  paints_start_v1;\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+    \/* Item Variation Store for variable 'COLR' v1. *\/\n+    GX_ItemVarStoreRec    var_store;\n+    GX_DeltaSetIdxMapRec  delta_set_idx_map;\n+#endif\n+\n+    \/* The memory that backs up the `COLR' table. *\/\n@@ -91,0 +167,2 @@\n+    \/* Needed for reading array lengths in referenced tables. *\/\n+    FT_Byte*  p1    = NULL;\n@@ -95,0 +173,2 @@\n+    FT_ULong  base_glyphs_offset_v1, num_base_glyphs_v1;\n+    FT_ULong  layer_offset_v1, num_layers_v1, clip_list_offset;\n@@ -96,0 +176,3 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+    FT_ULong  colr_offset_in_stream;\n+#endif\n@@ -106,2 +189,6 @@\n-    if ( table_size < COLR_HEADER_SIZE )\n-      goto InvalidTable;\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+    colr_offset_in_stream = FT_STREAM_POS();\n+#endif\n+\n+    if ( table_size < COLRV0_HEADER_SIZE )\n+      goto NoColr;\n@@ -118,1 +205,1 @@\n-    if ( colr->version != 0 )\n+    if ( colr->version != 0 && colr->version != 1 )\n@@ -124,1 +211,1 @@\n-    if ( base_glyph_offset >= table_size )\n+    if ( table_size <= base_glyph_offset )\n@@ -126,2 +213,2 @@\n-    if ( colr->num_base_glyphs * BASE_GLYPH_SIZE >\n-           table_size - base_glyph_offset )\n+    if ( ( table_size - base_glyph_offset ) \/ BASE_GLYPH_SIZE\n+             < colr->num_base_glyphs )\n@@ -133,1 +220,1 @@\n-    if ( layer_offset >= table_size )\n+    if ( table_size <= layer_offset )\n@@ -135,1 +222,2 @@\n-    if ( colr->num_layers * LAYER_SIZE > table_size - layer_offset )\n+    if ( ( table_size - layer_offset ) \/ LAYER_SIZE\n+             < colr->num_layers )\n@@ -138,0 +226,125 @@\n+    if ( colr->version == 1 )\n+    {\n+      if ( table_size < COLRV1_HEADER_SIZE )\n+        goto InvalidTable;\n+\n+      base_glyphs_offset_v1 = FT_NEXT_ULONG( p );\n+\n+      if ( table_size - 4 <= base_glyphs_offset_v1 )\n+        goto InvalidTable;\n+\n+      p1                 = (FT_Byte*)( table + base_glyphs_offset_v1 );\n+      num_base_glyphs_v1 = FT_PEEK_ULONG( p1 );\n+\n+      if ( ( table_size - base_glyphs_offset_v1 ) \/ BASE_GLYPH_PAINT_RECORD_SIZE\n+               < num_base_glyphs_v1 )\n+        goto InvalidTable;\n+\n+      colr->num_base_glyphs_v1 = num_base_glyphs_v1;\n+      colr->base_glyphs_v1     = p1;\n+\n+      layer_offset_v1 = FT_NEXT_ULONG( p );\n+\n+      if ( table_size <= layer_offset_v1 )\n+        goto InvalidTable;\n+\n+      if ( layer_offset_v1 )\n+      {\n+        if ( table_size - 4 <= layer_offset_v1 )\n+          goto InvalidTable;\n+\n+        p1            = (FT_Byte*)( table + layer_offset_v1 );\n+        num_layers_v1 = FT_PEEK_ULONG( p1 );\n+\n+        if ( ( table_size - layer_offset_v1 ) \/ LAYER_V1_LIST_PAINT_OFFSET_SIZE\n+                < num_layers_v1 )\n+          goto InvalidTable;\n+\n+        colr->num_layers_v1 = num_layers_v1;\n+        colr->layers_v1     = p1;\n+\n+        colr->paints_start_v1 =\n+            FT_MIN( colr->base_glyphs_v1 +\n+                    colr->num_base_glyphs_v1 * BASE_GLYPH_PAINT_RECORD_SIZE,\n+                    colr->layers_v1 +\n+                    colr->num_layers_v1 * LAYER_V1_LIST_PAINT_OFFSET_SIZE );\n+      }\n+      else\n+      {\n+        colr->num_layers_v1   = 0;\n+        colr->layers_v1       = 0;\n+        colr->paints_start_v1 =\n+          colr->base_glyphs_v1 +\n+          colr->num_base_glyphs_v1 * BASE_GLYPH_PAINT_RECORD_SIZE;\n+      }\n+\n+      clip_list_offset = FT_NEXT_ULONG( p );\n+\n+      if ( table_size <= clip_list_offset )\n+        goto InvalidTable;\n+\n+      if ( clip_list_offset )\n+        colr->clip_list = (FT_Byte*)( table + clip_list_offset );\n+      else\n+        colr->clip_list = 0;\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      colr->var_store.dataCount     = 0;\n+      colr->var_store.varData       = NULL;\n+      colr->var_store.axisCount     = 0;\n+      colr->var_store.regionCount   = 0;\n+      colr->var_store.varRegionList = 0;\n+\n+      colr->delta_set_idx_map.mapCount   = 0;\n+      colr->delta_set_idx_map.outerIndex = NULL;\n+      colr->delta_set_idx_map.innerIndex = NULL;\n+\n+      if ( face->variation_support & TT_FACE_FLAG_VAR_FVAR )\n+      {\n+        FT_ULong  var_idx_map_offset, var_store_offset;\n+\n+        FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+\n+\n+        var_idx_map_offset = FT_NEXT_ULONG( p );\n+\n+        if ( var_idx_map_offset >= table_size )\n+          goto InvalidTable;\n+\n+        var_store_offset = FT_NEXT_ULONG( p );\n+        if ( table_size <= var_store_offset )\n+          goto InvalidTable;\n+\n+        if ( var_store_offset )\n+        {\n+          \/* If variation info has not been initialized yet, try doing so, *\/\n+          \/* otherwise loading the variation store will fail as it         *\/\n+          \/* requires access to `blend` for checking the number of axes.   *\/\n+          if ( !face->blend )\n+            if ( mm->get_mm_var( FT_FACE( face ), NULL ) )\n+              goto InvalidTable;\n+\n+          \/* Try loading `VarIdxMap` and `VarStore`. *\/\n+          error = mm->load_item_var_store(\n+                    FT_FACE( face ),\n+                    colr_offset_in_stream + var_store_offset,\n+                    &colr->var_store );\n+          if ( error != FT_Err_Ok )\n+            goto InvalidTable;\n+        }\n+\n+        if ( colr->var_store.axisCount && var_idx_map_offset )\n+        {\n+          error = mm->load_delta_set_idx_map(\n+                    FT_FACE( face ),\n+                    colr_offset_in_stream + var_idx_map_offset,\n+                    &colr->delta_set_idx_map,\n+                    &colr->var_store,\n+                    table_size );\n+          if ( error != FT_Err_Ok )\n+            goto InvalidTable;\n+        }\n+      }\n+#endif \/* TT_CONFIG_OPTION_GX_VAR_SUPPORT *\/\n+    }\n+\n@@ -148,0 +361,12 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+    {\n+      FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+\n+\n+      mm->done_delta_set_idx_map( FT_FACE( face ),\n+                                  &colr->delta_set_idx_map );\n+      mm->done_item_var_store( FT_FACE( face ),\n+                               &colr->var_store );\n+    }\n+#endif\n+\n@@ -169,0 +394,11 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      {\n+        FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+\n+\n+        mm->done_delta_set_idx_map( FT_FACE( face ),\n+                                    &colr->delta_set_idx_map );\n+        mm->done_item_var_store( FT_FACE( face ),\n+                                 &colr->var_store );\n+      }\n+#endif\n@@ -177,1 +413,1 @@\n-                          FT_Int            num_base_glyph,\n+                          FT_UInt           num_base_glyph,\n@@ -181,2 +417,2 @@\n-    FT_Int  min = 0;\n-    FT_Int  max = num_base_glyph - 1;\n+    FT_UInt  min = 0;\n+    FT_UInt  max = num_base_glyph;\n@@ -185,1 +421,1 @@\n-    while ( min <= max )\n+    while ( min < max )\n@@ -187,1 +423,1 @@\n-      FT_Int    mid = min + ( max - min ) \/ 2;\n+      FT_UInt   mid = min + ( max - min ) \/ 2;\n@@ -196,1 +432,1 @@\n-        max = mid - 1;\n+        max = mid;\n@@ -251,1 +487,3 @@\n-    if ( iterator->layer >= iterator->num_layers )\n+    if ( iterator->layer >= iterator->num_layers                     ||\n+         iterator->p < colr->layers                                  ||\n+         iterator->p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n@@ -268,0 +506,1235 @@\n+  static FT_Bool\n+  read_color_line( Colr*          colr,\n+                   FT_Byte*       color_line_p,\n+                   FT_ColorLine*  colorline,\n+                   FT_Bool        read_variable )\n+  {\n+    FT_Byte*        p = color_line_p;\n+    FT_PaintExtend  paint_extend;\n+\n+\n+    ENSURE_READ_BYTES( 3 );\n+\n+    paint_extend = (FT_PaintExtend)FT_NEXT_BYTE( p );\n+    if ( paint_extend > FT_COLR_PAINT_EXTEND_REFLECT )\n+      return 0;\n+\n+    colorline->extend = paint_extend;\n+\n+    colorline->color_stop_iterator.num_color_stops    = FT_NEXT_USHORT( p );\n+    colorline->color_stop_iterator.p                  = p;\n+    colorline->color_stop_iterator.current_color_stop = 0;\n+    colorline->color_stop_iterator.read_variable      = read_variable;\n+\n+    return 1;\n+  }\n+\n+\n+  \/*\n+   * Read a paint offset for `FT_Paint*` objects that have them and check\n+   * whether it is within reasonable limits within the font and the COLR\n+   * table.\n+   *\n+   * Return 1 on success, 0 on failure.\n+   *\/\n+  static FT_Bool\n+  get_child_table_pointer ( Colr*      colr,\n+                            FT_Byte*   paint_base,\n+                            FT_Byte**  p,\n+                            FT_Byte**  child_table_pointer )\n+  {\n+    FT_UInt32  paint_offset;\n+    FT_Byte*   child_table_p;\n+\n+\n+    if ( !child_table_pointer )\n+      return 0;\n+\n+    if ( *p < colr->paints_start_v1                            ||\n+         *p > (FT_Byte*)colr->table + colr->table_size - 1 - 3 )\n+      return 0;\n+\n+    paint_offset = FT_NEXT_UOFF3( *p );\n+    if ( !paint_offset )\n+      return 0;\n+\n+    child_table_p = (FT_Byte*)( paint_base + paint_offset );\n+\n+    if ( child_table_p < colr->paints_start_v1                         ||\n+         child_table_p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    *child_table_pointer = child_table_p;\n+    return 1;\n+  }\n+\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+\n+  static FT_Bool\n+  get_deltas_for_var_index_base ( TT_Face           face,\n+                                  Colr*             colr,\n+                                  FT_ULong          var_index_base,\n+                                  FT_UInt           num_deltas,\n+                                  FT_ItemVarDelta*  deltas )\n+  {\n+    FT_UInt   outer_index    = 0;\n+    FT_UInt   inner_index    = 0;\n+    FT_ULong  loop_var_index = var_index_base;\n+\n+    FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;\n+\n+    FT_UInt  i = 0;\n+\n+\n+    if ( var_index_base == 0xFFFFFFFF )\n+    {\n+      for ( i = 0; i < num_deltas; ++i )\n+        deltas[i] = 0;\n+      return 1;\n+    }\n+\n+    for ( i = 0; i < num_deltas; ++i )\n+    {\n+      loop_var_index = var_index_base + i;\n+\n+      if ( colr->delta_set_idx_map.innerIndex )\n+      {\n+        if ( loop_var_index >= colr->delta_set_idx_map.mapCount )\n+          loop_var_index = colr->delta_set_idx_map.mapCount - 1;\n+\n+        outer_index = colr->delta_set_idx_map.outerIndex[loop_var_index];\n+        inner_index = colr->delta_set_idx_map.innerIndex[loop_var_index];\n+      }\n+      else\n+      {\n+        outer_index = 0;\n+        inner_index = loop_var_index;\n+      }\n+\n+      deltas[i] = mm->get_item_delta( FT_FACE( face ), &colr->var_store,\n+                                      outer_index, inner_index );\n+    }\n+\n+    return 1;\n+  }\n+\n+#endif \/* TT_CONFIG_OPTION_GX_VAR_SUPPORT *\/\n+\n+\n+  static FT_Bool\n+  read_paint( TT_Face         face,\n+              Colr*           colr,\n+              FT_Byte*        p,\n+              FT_COLR_Paint*  apaint )\n+  {\n+    FT_Byte*  paint_base    = p;\n+    FT_Byte*  child_table_p = NULL;\n+    FT_Bool   do_read_var   = FALSE;\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+    FT_ULong         var_index_base = 0;\n+    \/* Longest varIndexBase offset is 5 in the spec. *\/\n+    FT_ItemVarDelta  item_deltas[6] = { 0, 0, 0, 0, 0, 0 };\n+#else\n+    FT_UNUSED( face );\n+#endif\n+\n+\n+    if ( !p || !colr || !colr->table )\n+      return 0;\n+\n+    \/* The last byte of the 'COLR' table is at 'size-1'; subtract 1 of    *\/\n+    \/* that to account for the expected format byte we are going to read. *\/\n+    if ( p < colr->paints_start_v1                        ||\n+         p > (FT_Byte*)colr->table + colr->table_size - 2 )\n+      return 0;\n+\n+    apaint->format = (FT_PaintFormat)FT_NEXT_BYTE( p );\n+\n+    if ( apaint->format >= FT_COLR_PAINT_FORMAT_MAX )\n+      return 0;\n+\n+    if ( apaint->format == FT_COLR_PAINTFORMAT_COLR_LAYERS )\n+    {\n+      \/* Initialize layer iterator\/ *\/\n+      FT_Byte    num_layers;\n+      FT_UInt32  first_layer_index;\n+\n+\n+      ENSURE_READ_BYTES( 5 );\n+      num_layers = FT_NEXT_BYTE( p );\n+      if ( num_layers > colr->num_layers_v1 )\n+        return 0;\n+\n+      first_layer_index = FT_NEXT_ULONG( p );\n+      if ( first_layer_index + num_layers > colr->num_layers_v1 )\n+        return 0;\n+\n+      apaint->u.colr_layers.layer_iterator.num_layers = num_layers;\n+      apaint->u.colr_layers.layer_iterator.layer      = 0;\n+      \/* TODO: Check whether pointer is outside colr? *\/\n+      apaint->u.colr_layers.layer_iterator.p =\n+        colr->layers_v1 +\n+        LAYER_V1_LIST_NUM_LAYERS_SIZE +\n+        LAYER_V1_LIST_PAINT_OFFSET_SIZE * first_layer_index;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SOLID ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                 FT_COLR_PAINTFORMAT_INTERNAL_VAR_SOLID   )\n+    {\n+      ENSURE_READ_BYTES( 4 );\n+      apaint->u.solid.color.palette_index = FT_NEXT_USHORT( p );\n+      apaint->u.solid.color.alpha         = FT_NEXT_SHORT( p );\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+              FT_COLR_PAINTFORMAT_INTERNAL_VAR_SOLID )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG( p );\n+\n+        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 1,\n+                                             item_deltas ) )\n+          return 0;\n+\n+        apaint->u.solid.color.alpha += (FT_F2Dot14)item_deltas[0];\n+      }\n+#endif\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_SOLID;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_COLR_GLYPH )\n+    {\n+      ENSURE_READ_BYTES(2);\n+      apaint->u.colr_glyph.glyphID = FT_NEXT_USHORT( p );\n+\n+      return 1;\n+    }\n+\n+    \/*\n+     * Grouped below here are all paint formats that have an offset to a\n+     * child paint table as the first entry (for example, a color line or a\n+     * child paint table).  Retrieve that and determine whether that paint\n+     * offset is valid first.\n+     *\/\n+\n+    if ( !get_child_table_pointer( colr, paint_base, &p, &child_table_p ) )\n+      return 0;\n+\n+    if ( apaint->format == FT_COLR_PAINTFORMAT_LINEAR_GRADIENT      ||\n+         ( do_read_var =\n+             ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_LINEAR_GRADIENT ) ) )\n+    {\n+      if ( !read_color_line( colr,\n+                             child_table_p,\n+                             &apaint->u.linear_gradient.colorline,\n+                             do_read_var ) )\n+        return 0;\n+\n+      \/*\n+       * In order to support variations expose these as FT_Fixed 16.16\n+       * values so that we can support fractional values after\n+       * interpolation.\n+       *\/\n+      ENSURE_READ_BYTES( 12 );\n+      apaint->u.linear_gradient.p0.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p0.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p1.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p1.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p2.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p2.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( do_read_var )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG ( p );\n+\n+        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 6,\n+                                             item_deltas ) )\n+          return 0;\n+\n+        apaint->u.linear_gradient.p0.x += INT_TO_FIXED( item_deltas[0] );\n+        apaint->u.linear_gradient.p0.y += INT_TO_FIXED( item_deltas[1] );\n+        apaint->u.linear_gradient.p1.x += INT_TO_FIXED( item_deltas[2] );\n+        apaint->u.linear_gradient.p1.y += INT_TO_FIXED( item_deltas[3] );\n+        apaint->u.linear_gradient.p2.x += INT_TO_FIXED( item_deltas[4] );\n+        apaint->u.linear_gradient.p2.y += INT_TO_FIXED( item_deltas[5] );\n+      }\n+#endif\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_LINEAR_GRADIENT;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_RADIAL_GRADIENT      ||\n+              ( do_read_var =\n+                  ( (FT_PaintFormat_Internal)apaint->format ==\n+                    FT_COLR_PAINTFORMAT_INTERNAL_VAR_RADIAL_GRADIENT ) ) )\n+    {\n+      FT_Pos  tmp;\n+\n+\n+      if ( !read_color_line( colr,\n+                             child_table_p,\n+                             &apaint->u.radial_gradient.colorline,\n+                             do_read_var ) )\n+        return 0;\n+\n+\n+      \/* In the OpenType specification, `r0` and `r1` are defined as   *\/\n+      \/* `UFWORD`.  Since FreeType doesn't have a corresponding 16.16  *\/\n+      \/* format we convert to `FWORD` and replace negative values with *\/\n+      \/* (32bit) `FT_INT_MAX`.                                         *\/\n+\n+      ENSURE_READ_BYTES( 12 );\n+\n+      apaint->u.radial_gradient.c0.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.c0.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      tmp                          = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.r0 = tmp < 0 ? FT_INT_MAX : tmp;\n+\n+      apaint->u.radial_gradient.c1.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.c1.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      tmp                          = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.r1 = tmp < 0 ? FT_INT_MAX : tmp;\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( do_read_var )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG ( p );\n+\n+        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 6,\n+                                             item_deltas ) )\n+          return 0;\n+\n+        apaint->u.radial_gradient.c0.x += INT_TO_FIXED( item_deltas[0] );\n+        apaint->u.radial_gradient.c0.y += INT_TO_FIXED( item_deltas[1] );\n+\n+        \/\/ TODO: Anything to be done about UFWORD deltas here?\n+        apaint->u.radial_gradient.r0 += INT_TO_FIXED( item_deltas[2] );\n+\n+        apaint->u.radial_gradient.c1.x += INT_TO_FIXED( item_deltas[3] );\n+        apaint->u.radial_gradient.c1.y += INT_TO_FIXED( item_deltas[4] );\n+\n+        apaint->u.radial_gradient.r1 += INT_TO_FIXED( item_deltas[5] );\n+      }\n+#endif\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_RADIAL_GRADIENT;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SWEEP_GRADIENT      ||\n+              ( do_read_var =\n+                  ( (FT_PaintFormat_Internal)apaint->format ==\n+                    FT_COLR_PAINTFORMAT_INTERNAL_VAR_SWEEP_GRADIENT ) ) )\n+    {\n+      if ( !read_color_line( colr,\n+                             child_table_p,\n+                             &apaint->u.sweep_gradient.colorline,\n+                             do_read_var) )\n+        return 0;\n+\n+      ENSURE_READ_BYTES( 8 );\n+\n+      apaint->u.sweep_gradient.center.x =\n+          INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.sweep_gradient.center.y =\n+          INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      apaint->u.sweep_gradient.start_angle =\n+          F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.sweep_gradient.end_angle =\n+          F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( do_read_var )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG ( p );\n+\n+        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n+                                             item_deltas ) )\n+          return 0;\n+\n+        \/\/ TODO: Handle overflow?\n+        apaint->u.sweep_gradient.center.x += INT_TO_FIXED( item_deltas[0] );\n+        apaint->u.sweep_gradient.center.y += INT_TO_FIXED( item_deltas[1] );\n+\n+        apaint->u.sweep_gradient.start_angle +=\n+          F2DOT14_TO_FIXED( item_deltas[2] );\n+        apaint->u.sweep_gradient.end_angle +=\n+          F2DOT14_TO_FIXED( item_deltas[3] );\n+      }\n+#endif\n+      apaint->format = FT_COLR_PAINTFORMAT_SWEEP_GRADIENT;\n+\n+      return 1;\n+    }\n+\n+    if ( apaint->format == FT_COLR_PAINTFORMAT_GLYPH )\n+    {\n+      ENSURE_READ_BYTES( 2 );\n+      apaint->u.glyph.paint.p                     = child_table_p;\n+      apaint->u.glyph.paint.insert_root_transform = 0;\n+      apaint->u.glyph.glyphID                     = FT_NEXT_USHORT( p );\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSFORM ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSFORM    )\n+    {\n+      apaint->u.transform.paint.p                     = child_table_p;\n+      apaint->u.transform.paint.insert_root_transform = 0;\n+\n+      if ( !get_child_table_pointer( colr, paint_base, &p, &child_table_p ) )\n+         return 0;\n+\n+      p = child_table_p;\n+\n+      \/*\n+       * The following matrix coefficients are encoded as\n+       * OpenType 16.16 fixed-point values.\n+       *\/\n+      ENSURE_READ_BYTES( 24 );\n+      apaint->u.transform.affine.xx = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.yx = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.xy = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.yy = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.dx = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.dy = FT_NEXT_LONG( p );\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSFORM )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG( p );\n+\n+        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 6,\n+                                             item_deltas ) )\n+          return 0;\n+\n+        apaint->u.transform.affine.xx += (FT_Fixed)item_deltas[0];\n+        apaint->u.transform.affine.yx += (FT_Fixed)item_deltas[1];\n+        apaint->u.transform.affine.xy += (FT_Fixed)item_deltas[2];\n+        apaint->u.transform.affine.yy += (FT_Fixed)item_deltas[3];\n+        apaint->u.transform.affine.dx += (FT_Fixed)item_deltas[4];\n+        apaint->u.transform.affine.dy += (FT_Fixed)item_deltas[5];\n+      }\n+#endif\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_TRANSFORM;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSLATE ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSLATE    )\n+    {\n+      apaint->u.translate.paint.p                     = child_table_p;\n+      apaint->u.translate.paint.insert_root_transform = 0;\n+\n+      ENSURE_READ_BYTES( 4 );\n+      apaint->u.translate.dx = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.translate.dy = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_TRANSLATE )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG( p );\n+\n+        if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 2,\n+                                             item_deltas ) )\n+          return 0;\n+\n+        apaint->u.translate.dx += INT_TO_FIXED( item_deltas[0] );\n+        apaint->u.translate.dy += INT_TO_FIXED( item_deltas[1] );\n+      }\n+#endif\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_TRANSLATE;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format >= FT_COLR_PAINTFORMAT_SCALE             &&\n+              (FT_PaintFormat_Internal)apaint->format <=\n+                FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n+    {\n+      apaint->u.scale.paint.p                     = child_table_p;\n+      apaint->u.scale.paint.insert_root_transform = 0;\n+\n+      \/* All scale paints get at least one scale value. *\/\n+      ENSURE_READ_BYTES( 2 );\n+      apaint->u.scale.scale_x = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      \/* Non-uniform ones read an extra y value. *\/\n+      if ( apaint->format == FT_COLR_PAINTFORMAT_SCALE     ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE        ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER     ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER )\n+      {\n+        ENSURE_READ_BYTES( 2 );\n+        apaint->u.scale.scale_y = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      }\n+      else\n+        apaint->u.scale.scale_y = apaint->u.scale.scale_x;\n+\n+      \/* Scale paints that have a center read center coordinates, *\/\n+      \/* otherwise the center is (0,0).                           *\/\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER             ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER         ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER     ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        apaint->u.scale.center_x = INT_TO_FIXED( FT_NEXT_SHORT ( p ) );\n+        apaint->u.scale.center_y = INT_TO_FIXED( FT_NEXT_SHORT ( p ) );\n+      }\n+      else\n+      {\n+        apaint->u.scale.center_x = 0;\n+        apaint->u.scale.center_y = 0;\n+      }\n+\n+      \/* Base values set, now handle variations. *\/\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE                ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER         ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM        ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG( p );\n+\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE )\n+        {\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 2,\n+                                               item_deltas ) )\n+            return 0;\n+\n+          apaint->u.scale.scale_x += F2DOT14_TO_FIXED( item_deltas[0] );\n+          apaint->u.scale.scale_y += F2DOT14_TO_FIXED( item_deltas[1] );\n+        }\n+\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_CENTER )\n+        {\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n+                                               item_deltas ) )\n+            return 0;\n+\n+          apaint->u.scale.scale_x  += F2DOT14_TO_FIXED( item_deltas[0] );\n+          apaint->u.scale.scale_y  += F2DOT14_TO_FIXED( item_deltas[1] );\n+          apaint->u.scale.center_x += INT_TO_FIXED( item_deltas[2] );\n+          apaint->u.scale.center_y += INT_TO_FIXED( item_deltas[3] );\n+        }\n+\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM )\n+        {\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 1,\n+                                               item_deltas ) )\n+            return 0;\n+\n+          apaint->u.scale.scale_x += F2DOT14_TO_FIXED( item_deltas[0] );\n+          apaint->u.scale.scale_y += F2DOT14_TO_FIXED( item_deltas[0] );\n+        }\n+\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SCALE_UNIFORM_CENTER )\n+        {\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 3,\n+                                               item_deltas ) )\n+            return 0;\n+\n+          apaint->u.scale.scale_x  += F2DOT14_TO_FIXED( item_deltas[0] );\n+          apaint->u.scale.scale_y  += F2DOT14_TO_FIXED( item_deltas[0] );\n+          apaint->u.scale.center_x += INT_TO_FIXED( item_deltas[1] );\n+          apaint->u.scale.center_y += INT_TO_FIXED( item_deltas[2] );\n+        }\n+      }\n+#endif\n+\n+      \/* FT 'COLR' v1 API output format always returns fully defined *\/\n+      \/* structs; we thus set the format to the public API value.    *\/\n+      apaint->format = FT_COLR_PAINTFORMAT_SCALE;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_ROTATE     ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER     ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE        ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n+    {\n+      apaint->u.rotate.paint.p                     = child_table_p;\n+      apaint->u.rotate.paint.insert_root_transform = 0;\n+\n+      ENSURE_READ_BYTES( 2 );\n+      apaint->u.rotate.angle = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER     ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        apaint->u.rotate.center_x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+        apaint->u.rotate.center_y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      }\n+      else\n+      {\n+        apaint->u.rotate.center_x = 0;\n+        apaint->u.rotate.center_y = 0;\n+      }\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE        ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n+      {\n+        FT_UInt  num_deltas = 0;\n+\n+\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG( p );\n+\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE_CENTER )\n+          num_deltas = 3;\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_ROTATE )\n+          num_deltas = 1;\n+\n+        if ( num_deltas > 0 )\n+        {\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base,\n+                                               num_deltas, item_deltas ) )\n+            return 0;\n+\n+          apaint->u.rotate.angle += F2DOT14_TO_FIXED( item_deltas[0] );\n+\n+          if ( num_deltas == 3 )\n+          {\n+            apaint->u.rotate.center_x += INT_TO_FIXED( item_deltas[1] );\n+            apaint->u.rotate.center_y += INT_TO_FIXED( item_deltas[2] );\n+          }\n+        }\n+      }\n+#endif\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_ROTATE;\n+\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SKEW     ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW        ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER     ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n+    {\n+      apaint->u.skew.paint.p                     = child_table_p;\n+      apaint->u.skew.paint.insert_root_transform = 0;\n+\n+      ENSURE_READ_BYTES( 4 );\n+      apaint->u.skew.x_skew_angle = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.skew.y_skew_angle = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER     ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        apaint->u.skew.center_x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+        apaint->u.skew.center_y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      }\n+      else\n+      {\n+        apaint->u.skew.center_x = 0;\n+        apaint->u.skew.center_y = 0;\n+      }\n+\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW        ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n+      {\n+        ENSURE_READ_BYTES( 4 );\n+        var_index_base = FT_NEXT_ULONG( p );\n+\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW )\n+        {\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 2,\n+                                               item_deltas ) )\n+            return 0;\n+\n+          apaint->u.skew.x_skew_angle += F2DOT14_TO_FIXED( item_deltas[0] );\n+          apaint->u.skew.y_skew_angle += F2DOT14_TO_FIXED( item_deltas[1] );\n+        }\n+\n+        if ( (FT_PaintFormat_Internal)apaint->format ==\n+               FT_COLR_PAINTFORMAT_INTERNAL_VAR_SKEW_CENTER )\n+        {\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n+                                               item_deltas ) )\n+            return 0;\n+\n+          apaint->u.skew.x_skew_angle += F2DOT14_TO_FIXED( item_deltas[0] );\n+          apaint->u.skew.y_skew_angle += F2DOT14_TO_FIXED( item_deltas[1] );\n+          apaint->u.skew.center_x     += INT_TO_FIXED( item_deltas[2] );\n+          apaint->u.skew.center_y     += INT_TO_FIXED( item_deltas[3] );\n+        }\n+      }\n+#endif\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_SKEW;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_COMPOSITE )\n+    {\n+      FT_UInt  composite_mode;\n+\n+\n+      apaint->u.composite.source_paint.p                     = child_table_p;\n+      apaint->u.composite.source_paint.insert_root_transform = 0;\n+\n+      ENSURE_READ_BYTES( 1 );\n+      composite_mode = FT_NEXT_BYTE( p );\n+      if ( composite_mode >= FT_COLR_COMPOSITE_MAX )\n+        return 0;\n+\n+      apaint->u.composite.composite_mode = (FT_Composite_Mode)composite_mode;\n+\n+      if ( !get_child_table_pointer( colr, paint_base, &p, &child_table_p ) )\n+         return 0;\n+\n+      apaint->u.composite.backdrop_paint.p =\n+        child_table_p;\n+      apaint->u.composite.backdrop_paint.insert_root_transform =\n+        0;\n+\n+      return 1;\n+    }\n+\n+    return 0;\n+  }\n+\n+\n+  static FT_Bool\n+  find_base_glyph_v1_record( FT_Byte *           base_glyph_begin,\n+                             FT_UInt             num_base_glyph,\n+                             FT_UInt             glyph_id,\n+                             BaseGlyphV1Record  *record )\n+  {\n+    FT_UInt  min = 0;\n+    FT_UInt  max = num_base_glyph;\n+\n+\n+    while ( min < max )\n+    {\n+      FT_UInt    mid = min + ( max - min ) \/ 2;\n+      FT_UShort  gid;\n+\n+      \/*\n+       * `base_glyph_begin` is the beginning of `BaseGlyphV1List`;\n+       * skip `numBaseGlyphV1Records` by adding 4 to start binary search\n+       * in the array of `BaseGlyphV1Record`.\n+       *\/\n+      FT_Byte  *p = base_glyph_begin + 4 + mid * BASE_GLYPH_PAINT_RECORD_SIZE;\n+\n+      gid = FT_NEXT_USHORT( p );\n+\n+      if ( gid < glyph_id )\n+        min = mid + 1;\n+      else if (gid > glyph_id )\n+        max = mid;\n+      else\n+      {\n+        record->gid          = gid;\n+        record->paint_offset = FT_NEXT_ULONG ( p );\n+        return 1;\n+      }\n+    }\n+\n+    return 0;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_colr_glyph_paint( TT_Face                  face,\n+                                FT_UInt                  base_glyph,\n+                                FT_Color_Root_Transform  root_transform,\n+                                FT_OpaquePaint*          opaque_paint )\n+  {\n+    Colr*              colr = (Colr*)face->colr;\n+    BaseGlyphV1Record  base_glyph_v1_record;\n+    FT_Byte*           p;\n+\n+    if ( !colr || !colr->table )\n+      return 0;\n+\n+    if ( colr->version < 1 || !colr->num_base_glyphs_v1 ||\n+         !colr->base_glyphs_v1 )\n+      return 0;\n+\n+    if ( opaque_paint->p )\n+      return 0;\n+\n+    if ( !find_base_glyph_v1_record( colr->base_glyphs_v1,\n+                                     colr->num_base_glyphs_v1,\n+                                     base_glyph,\n+                                     &base_glyph_v1_record ) )\n+      return 0;\n+\n+    if ( !base_glyph_v1_record.paint_offset                   ||\n+         base_glyph_v1_record.paint_offset > colr->table_size )\n+      return 0;\n+\n+    p = (FT_Byte*)( colr->base_glyphs_v1 +\n+                    base_glyph_v1_record.paint_offset );\n+    if ( p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    opaque_paint->p = p;\n+\n+    if ( root_transform == FT_COLOR_INCLUDE_ROOT_TRANSFORM )\n+      opaque_paint->insert_root_transform = 1;\n+    else\n+      opaque_paint->insert_root_transform = 0;\n+\n+    return 1;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_color_glyph_clipbox( TT_Face      face,\n+                                   FT_UInt      base_glyph,\n+                                   FT_ClipBox*  clip_box )\n+  {\n+    Colr*  colr;\n+\n+    FT_Byte  *p, *p1, *clip_base, *limit;\n+\n+    FT_Byte    clip_list_format;\n+    FT_ULong   num_clip_boxes, i;\n+    FT_UShort  gid_start, gid_end;\n+    FT_UInt32  clip_box_offset;\n+    FT_Byte    format;\n+\n+    const FT_Byte  num_corners = 4;\n+    FT_Vector      corners[4];\n+    FT_Byte        j;\n+    FT_BBox        font_clip_box;\n+\n+\n+    colr = (Colr*)face->colr;\n+    if ( !colr )\n+      return 0;\n+\n+    if ( !colr->clip_list )\n+      return 0;\n+\n+    p = colr->clip_list;\n+\n+    \/* Limit points to the first byte after the end of the color table.    *\/\n+    \/* Thus, in subsequent limit checks below we need to check whether the *\/\n+    \/* read pointer is strictly greater than a position offset by certain  *\/\n+    \/* field sizes to the left of that position.                           *\/\n+    limit = (FT_Byte*)colr->table + colr->table_size;\n+\n+    \/* Check whether we can extract one `uint8` and one `uint32`. *\/\n+    if ( p > limit - ( 1 + 4 ) )\n+      return 0;\n+\n+    clip_base        = p;\n+    clip_list_format = FT_NEXT_BYTE ( p );\n+\n+    \/* Format byte used here to be able to upgrade ClipList for >16bit *\/\n+    \/* glyph ids; for now we can expect it to be 1.                    *\/\n+    if ( !( clip_list_format == 1 ) )\n+      return 0;\n+\n+    num_clip_boxes = FT_NEXT_ULONG( p );\n+\n+    \/* Check whether we can extract two `uint16` and one `Offset24`, *\/\n+    \/* `num_clip_boxes` times.                                       *\/\n+    if ( colr->table_size \/ ( 2 + 2 + 3 ) < num_clip_boxes ||\n+         p > limit - ( 2 + 2 + 3 ) * num_clip_boxes        )\n+      return 0;\n+\n+    for ( i = 0; i < num_clip_boxes; ++i )\n+    {\n+      gid_start       = FT_NEXT_USHORT( p );\n+      gid_end         = FT_NEXT_USHORT( p );\n+      clip_box_offset = FT_NEXT_UOFF3( p );\n+\n+      if ( base_glyph >= gid_start && base_glyph <= gid_end )\n+      {\n+        p1 = (FT_Byte*)( clip_base + clip_box_offset );\n+\n+        \/* Check whether we can extract one `uint8`. *\/\n+        if ( p1 > limit - 1 )\n+          return 0;\n+\n+        format = FT_NEXT_BYTE( p1 );\n+\n+        if ( format > 2 )\n+          return 0;\n+\n+        \/* Check whether we can extract four `FWORD`. *\/\n+        if ( p1 > limit - ( 2 + 2 + 2 + 2 ) )\n+          return 0;\n+\n+        \/* `face->root.size->metrics.x_scale` and `y_scale` are factors   *\/\n+        \/* that scale a font unit value in integers to a 26.6 fixed value *\/\n+        \/* according to the requested size, see for example               *\/\n+        \/* `ft_recompute_scaled_metrics`.                                 *\/\n+        font_clip_box.xMin = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.x_scale );\n+        font_clip_box.yMin = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.y_scale );\n+        font_clip_box.xMax = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.x_scale );\n+        font_clip_box.yMax = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.y_scale );\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+        if ( format == 2 )\n+        {\n+          FT_ULong         var_index_base = 0;\n+          \/* varIndexBase offset for clipbox is 3 at most. *\/\n+          FT_ItemVarDelta  item_deltas[4] = { 0, 0, 0, 0 };\n+\n+\n+          \/* Check whether we can extract a 32-bit varIndexBase now. *\/\n+          if ( p1 > limit - 4 )\n+            return 0;\n+\n+          var_index_base = FT_NEXT_ULONG( p1 );\n+\n+          if ( !get_deltas_for_var_index_base( face, colr, var_index_base, 4,\n+                                               item_deltas ) )\n+            return 0;\n+\n+          font_clip_box.xMin +=\n+            FT_MulFix( item_deltas[0], face->root.size->metrics.x_scale );\n+          font_clip_box.yMin +=\n+            FT_MulFix( item_deltas[1], face->root.size->metrics.y_scale );\n+          font_clip_box.xMax +=\n+            FT_MulFix( item_deltas[2], face->root.size->metrics.x_scale );\n+          font_clip_box.yMax +=\n+            FT_MulFix( item_deltas[3], face->root.size->metrics.y_scale );\n+        }\n+#endif\n+\n+        \/* Make 4 corner points (xMin, yMin), (xMax, yMax) and transform *\/\n+        \/* them.  If we we would only transform two corner points and    *\/\n+        \/* span a rectangle based on those, the rectangle may become too *\/\n+        \/* small to cover the glyph.                                     *\/\n+        corners[0].x = font_clip_box.xMin;\n+        corners[1].x = font_clip_box.xMin;\n+        corners[2].x = font_clip_box.xMax;\n+        corners[3].x = font_clip_box.xMax;\n+\n+        corners[0].y = font_clip_box.yMin;\n+        corners[1].y = font_clip_box.yMax;\n+        corners[2].y = font_clip_box.yMax;\n+        corners[3].y = font_clip_box.yMin;\n+\n+        for ( j = 0; j < num_corners; ++j )\n+        {\n+          if ( face->root.internal->transform_flags & 1 )\n+            FT_Vector_Transform( &corners[j],\n+                                 &face->root.internal->transform_matrix );\n+\n+          if ( face->root.internal->transform_flags & 2 )\n+          {\n+            corners[j].x += face->root.internal->transform_delta.x;\n+            corners[j].y += face->root.internal->transform_delta.y;\n+          }\n+        }\n+\n+        clip_box->bottom_left  = corners[0];\n+        clip_box->top_left     = corners[1];\n+        clip_box->top_right    = corners[2];\n+        clip_box->bottom_right = corners[3];\n+\n+        return 1;\n+      }\n+    }\n+\n+    return 0;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_paint_layers( TT_Face            face,\n+                            FT_LayerIterator*  iterator,\n+                            FT_OpaquePaint*    opaque_paint )\n+  {\n+    FT_Byte*   p             = NULL;\n+    FT_Byte*   p_first_layer = NULL;\n+    FT_Byte*   p_paint       = NULL;\n+    FT_UInt32  paint_offset;\n+\n+    Colr*  colr;\n+\n+\n+    if ( iterator->layer == iterator->num_layers )\n+      return 0;\n+\n+    colr = (Colr*)face->colr;\n+    if ( !colr )\n+      return 0;\n+\n+    \/*\n+     * We have an iterator pointing at a paint offset as part of the\n+     * `paintOffset` array in `LayerV1List`.\n+     *\/\n+    p = iterator->p;\n+\n+    \/*\n+     * Do a cursor sanity check of the iterator.  Counting backwards from\n+     * where it stands, we need to end up at a position after the beginning\n+     * of the `LayerV1List` table and not after the end of the\n+     * `LayerV1List`.\n+     *\/\n+    p_first_layer = p -\n+                      iterator->layer * LAYER_V1_LIST_PAINT_OFFSET_SIZE -\n+                      LAYER_V1_LIST_NUM_LAYERS_SIZE;\n+    if ( p_first_layer < (FT_Byte*)colr->layers_v1 )\n+      return 0;\n+    if ( p_first_layer >= (FT_Byte*)(\n+           colr->layers_v1 + LAYER_V1_LIST_NUM_LAYERS_SIZE +\n+           colr->num_layers_v1 * LAYER_V1_LIST_PAINT_OFFSET_SIZE ) )\n+      return 0;\n+\n+    \/*\n+     * Before reading, ensure that `p` is within 'COLR' v1 and we can read a\n+     * 4-byte ULONG.\n+     *\/\n+    if ( p < colr->layers_v1                              ||\n+         p > (FT_Byte*)colr->table + colr->table_size - 4 )\n+      return 0;\n+\n+    paint_offset =\n+      FT_NEXT_ULONG( p );\n+    opaque_paint->insert_root_transform =\n+      0;\n+\n+    p_paint = (FT_Byte*)( colr->layers_v1 + paint_offset );\n+\n+    if ( p_paint < colr->paints_start_v1                         ||\n+         p_paint >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    opaque_paint->p = p_paint;\n+\n+    iterator->p = p;\n+\n+    iterator->layer++;\n+\n+    return 1;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_colorline_stops( TT_Face                face,\n+                               FT_ColorStop*          color_stop,\n+                               FT_ColorStopIterator  *iterator )\n+  {\n+    Colr*  colr = (Colr*)face->colr;\n+\n+    FT_Byte*  p;\n+    FT_ULong  var_index_base;\n+    FT_Byte*  last_entry_p = NULL;\n+    FT_UInt   entry_size   = COLOR_STOP_SIZE;\n+\n+\n+    if ( !colr || !colr->table || !iterator )\n+      return 0;\n+\n+    if ( iterator->current_color_stop >= iterator->num_color_stops )\n+      return 0;\n+\n+    if ( iterator->read_variable )\n+      entry_size += VAR_IDX_BASE_SIZE;\n+\n+    \/* Calculate the start pointer for the last to-be-read (Var)ColorStop *\/\n+    \/* and check whether we can read a full (Var)ColorStop at that        *\/\n+    \/* position by comparing it to the position that is the size of one   *\/\n+    \/* (Var)ColorStop before the end of the 'COLR' table.                 *\/\n+    last_entry_p =\n+      iterator->p + ( iterator->num_color_stops - 1 -\n+                      iterator->current_color_stop ) * entry_size;\n+    if ( iterator->p < colr->paints_start_v1          ||\n+         last_entry_p > (FT_Byte*)colr->table +\n+                        colr->table_size - entry_size )\n+      return 0;\n+\n+    \/* Iterator points at first `ColorStop` of `ColorLine`. *\/\n+    p = iterator->p;\n+\n+    color_stop->stop_offset = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+    color_stop->color.palette_index = FT_NEXT_USHORT( p );\n+\n+    color_stop->color.alpha = FT_NEXT_SHORT( p );\n+\n+    if ( iterator->read_variable )\n+    {\n+      \/* Pointer p needs to be advanced independently of whether we intend *\/\n+      \/* to take variable deltas into account or not.  Otherwise iteration *\/\n+      \/* would fail due to wrong offsets.                                  *\/\n+      var_index_base = FT_NEXT_ULONG( p );\n+\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+      {\n+        FT_Int  item_deltas[2];\n+\n+\n+        if ( !get_deltas_for_var_index_base( face, colr,\n+                                             var_index_base,\n+                                             2,\n+                                             item_deltas ) )\n+          return 0;\n+\n+        color_stop->stop_offset += F2DOT14_TO_FIXED( item_deltas[0] );\n+        color_stop->color.alpha += (FT_F2Dot14)item_deltas[1];\n+      }\n+#else\n+      FT_UNUSED( var_index_base );\n+#endif\n+    }\n+\n+    iterator->p = p;\n+    iterator->current_color_stop++;\n+\n+    return 1;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_paint( TT_Face         face,\n+                     FT_OpaquePaint  opaque_paint,\n+                     FT_COLR_Paint*  paint )\n+  {\n+    Colr*           colr = (Colr*)face->colr;\n+    FT_OpaquePaint  next_paint;\n+    FT_Matrix       ft_root_scale;\n+\n+    if ( !colr || !colr->base_glyphs_v1 || !colr->table )\n+      return 0;\n+\n+    if ( opaque_paint.insert_root_transform )\n+    {\n+      \/* 'COLR' v1 glyph information is returned in unscaled coordinates,\n+       * i.e., `FT_Size` is not applied or multiplied into the values.  When\n+       * client applications draw color glyphs, they can request to include\n+       * a top-level transform, which includes the active `x_scale` and\n+       * `y_scale` information for scaling the glyph, as well the additional\n+       * transform and translate configured through `FT_Set_Transform`.\n+       * This allows client applications to apply this top-level transform\n+       * to the graphics context first and only once, then have gradient and\n+       * contour scaling applied correctly when performing the additional\n+       * drawing operations for subsequenct paints.  Prepare this initial\n+       * transform here.\n+       *\/\n+      paint->format = FT_COLR_PAINTFORMAT_TRANSFORM;\n+\n+      next_paint.p                     = opaque_paint.p;\n+      next_paint.insert_root_transform = 0;\n+      paint->u.transform.paint         = next_paint;\n+\n+      \/* `x_scale` and `y_scale` are in 26.6 format, representing the scale\n+       * factor to get from font units to requested size.  However, expected\n+       * return values are in 16.16, so we shift accordingly with rounding.\n+       *\/\n+      ft_root_scale.xx = ( face->root.size->metrics.x_scale + 32 ) >> 6;\n+      ft_root_scale.xy = 0;\n+      ft_root_scale.yx = 0;\n+      ft_root_scale.yy = ( face->root.size->metrics.y_scale + 32 ) >> 6;\n+\n+      if ( face->root.internal->transform_flags & 1 )\n+        FT_Matrix_Multiply( &face->root.internal->transform_matrix,\n+                            &ft_root_scale );\n+\n+      paint->u.transform.affine.xx = ft_root_scale.xx;\n+      paint->u.transform.affine.xy = ft_root_scale.xy;\n+      paint->u.transform.affine.yx = ft_root_scale.yx;\n+      paint->u.transform.affine.yy = ft_root_scale.yy;\n+\n+      \/* The translation is specified in 26.6 format and, according to the\n+       * documentation of `FT_Set_Translate`, is performed on the character\n+       * size given in the last call to `FT_Set_Char_Size`.  The\n+       * 'PaintTransform' paint table's `FT_Affine23` format expects\n+       * values in 16.16 format, thus we need to shift by 10 bits.\n+       *\/\n+      if ( face->root.internal->transform_flags & 2 )\n+      {\n+        paint->u.transform.affine.dx =\n+          face->root.internal->transform_delta.x * ( 1 << 10 );\n+        paint->u.transform.affine.dy =\n+          face->root.internal->transform_delta.y * ( 1 << 10 );\n+      }\n+      else\n+      {\n+        paint->u.transform.affine.dx = 0;\n+        paint->u.transform.affine.dy = 0;\n+      }\n+\n+      return 1;\n+    }\n+\n+    return read_paint( face, colr, opaque_paint.p, paint );\n+  }\n+\n+\n@@ -446,1 +1919,1 @@\n-  typedef int  _tt_colr_dummy;\n+  typedef int  tt_colr_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcolr.c","additions":1499,"deletions":26,"binary":false,"changes":1525,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2024 by\n@@ -45,0 +45,26 @@\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_colr_glyph_paint( TT_Face                  face,\n+                                FT_UInt                  base_glyph,\n+                                FT_Color_Root_Transform  root_transform,\n+                                FT_OpaquePaint*          paint );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_color_glyph_clipbox( TT_Face      face,\n+                                   FT_UInt      base_glyph,\n+                                   FT_ClipBox*  clip_box );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_paint_layers( TT_Face            face,\n+                            FT_LayerIterator*  iterator,\n+                            FT_OpaquePaint*    paint );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_colorline_stops( TT_Face                face,\n+                               FT_ColorStop*          color_stop,\n+                               FT_ColorStopIterator*  iterator );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_paint( TT_Face         face,\n+                     FT_OpaquePaint  opaque_paint,\n+                     FT_COLR_Paint*  paint );\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcolr.h","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2024 by\n@@ -306,1 +306,1 @@\n-  typedef int  _tt_cpal_dummy;\n+  typedef int  tt_cpal_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcpal.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttcpal.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -97,1 +97,1 @@\n-      p += 2; \/* skip version *\/\n+      p       += 2; \/* skip version *\/\n@@ -147,1 +147,1 @@\n-          if ( cur_pair <= old_pair )\n+          if ( cur_pair < old_pair )\n@@ -190,4 +190,2 @@\n-    FT_Int    result = 0;\n-    FT_UInt   count, mask;\n-    FT_Byte*  p       = face->kern_table;\n-    FT_Byte*  p_limit = p + face->kern_table_size;\n+    FT_Int   result = 0;\n+    FT_UInt  count, mask;\n@@ -195,0 +193,9 @@\n+    FT_Byte*  p;\n+    FT_Byte*  p_limit;\n+\n+\n+    if ( !face->kern_table )\n+      return result;\n+\n+    p       = face->kern_table;\n+    p_limit = p + face->kern_table_size;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttkern.c","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -208,1 +208,0 @@\n-        nn--;\n@@ -210,1 +209,1 @@\n-                    \" can read only %d table%s in font (instead of %d)\\n\",\n+                    \" can read only %hu table%s in font (instead of %hu)\\n\",\n@@ -220,1 +219,1 @@\n-        FT_TRACE2(( \"check_table_dir: table entry %d invalid\\n\", nn ));\n+        FT_TRACE2(( \"check_table_dir: table entry %hu invalid\\n\", nn ));\n@@ -235,1 +234,1 @@\n-          FT_TRACE2(( \"check_table_dir: table entry %d invalid\\n\", nn ));\n+          FT_TRACE2(( \"check_table_dir: table entry %hu invalid\\n\", nn ));\n@@ -384,1 +383,1 @@\n-    FT_TRACE2(( \"-- Number of tables: %10u\\n\",    sfnt.num_tables ));\n+    FT_TRACE2(( \"-- Number of tables: %10hu\\n\",   sfnt.num_tables ));\n@@ -419,3 +418,3 @@\n-    FT_TRACE2(( \"\\n\"\n-                \"  tag    offset    length   checksum\\n\"\n-                \"  ----------------------------------\\n\" ));\n+    FT_TRACE2(( \"\\n\" ));\n+    FT_TRACE2(( \"  tag    offset    length   checksum\\n\" ));\n+    FT_TRACE2(( \"  ----------------------------------\\n\" ));\n@@ -508,1 +507,9 @@\n-    FT_TRACE2(( \"table directory loaded\\n\\n\" ));\n+    if ( !valid_entries )\n+    {\n+      FT_TRACE2(( \"tt_face_load_font_dir: no valid tables found\\n\" ));\n+      error = FT_THROW( Unknown_File_Format );\n+      goto Exit;\n+    }\n+\n+    FT_TRACE2(( \"table directory loaded\\n\" ));\n+    FT_TRACE2(( \"\\n\" ));\n@@ -674,2 +681,2 @@\n-    FT_TRACE3(( \"Units per EM: %4u\\n\", header->Units_Per_EM ));\n-    FT_TRACE3(( \"IndexToLoc:   %4d\\n\", header->Index_To_Loc_Format ));\n+    FT_TRACE3(( \"Units per EM: %4hu\\n\", header->Units_Per_EM ));\n+    FT_TRACE3(( \"IndexToLoc:   %4hd\\n\", header->Index_To_Loc_Format ));\n@@ -797,2 +804,2 @@\n-                    \" too much twilight points in `maxp' table;\\n\"\n-                    \"                  \"\n+                    \" too much twilight points in `maxp' table;\\n\" ));\n+        FT_TRACE0(( \"                  \"\n@@ -805,1 +812,1 @@\n-    FT_TRACE3(( \"numGlyphs: %u\\n\", maxProfile->numGlyphs ));\n+    FT_TRACE3(( \"numGlyphs: %hu\\n\", maxProfile->numGlyphs ));\n@@ -839,0 +846,2 @@\n+    TT_Name       names    = NULL;\n+    TT_LangTag    langTags = NULL;\n@@ -919,2 +928,2 @@\n-      if ( FT_NEW_ARRAY( table->langTags, table->numLangTagRecords ) ||\n-           FT_FRAME_ENTER( table->numLangTagRecords * 4 )            )\n+      if ( FT_QNEW_ARRAY( langTags, table->numLangTagRecords ) ||\n+           FT_FRAME_ENTER( table->numLangTagRecords * 4 )      )\n@@ -925,1 +934,1 @@\n-        TT_LangTag  entry = table->langTags;\n+        TT_LangTag  entry = langTags;\n@@ -941,0 +950,3 @@\n+\n+          \/* mark the string as not yet loaded *\/\n+          entry->string = NULL;\n@@ -942,0 +954,3 @@\n+\n+        table->langTags = langTags;\n+        langTags        = NULL;\n@@ -950,2 +965,2 @@\n-    if ( FT_NEW_ARRAY( table->names, table->numNameRecords ) ||\n-         FT_FRAME_ENTER( table->numNameRecords * 12 )        )\n+    if ( FT_QNEW_ARRAY( names, table->numNameRecords ) ||\n+         FT_FRAME_ENTER( table->numNameRecords * 12 )  )\n@@ -956,1 +971,1 @@\n-      TT_Name  entry = table->names;\n+      TT_Name  entry = names;\n@@ -958,0 +973,1 @@\n+      FT_UInt  valid = 0;\n@@ -990,0 +1006,4 @@\n+        \/* mark the string as not yet converted *\/\n+        entry->string = NULL;\n+\n+        valid++;\n@@ -994,5 +1014,6 @@\n-      count = (FT_UInt)( entry - table->names );\n-      (void)FT_RENEW_ARRAY( table->names,\n-                            table->numNameRecords,\n-                            count );\n-      table->numNameRecords = count;\n+      FT_MEM_QRENEW_ARRAY( names,\n+                           table->numNameRecords,\n+                           valid );\n+      table->names          = names;\n+      names                 = NULL;\n+      table->numNameRecords = valid;\n@@ -1007,0 +1028,2 @@\n+    FT_FREE( names );\n+    FT_FREE( langTags );\n@@ -1026,1 +1049,1 @@\n-    FT_Memory     memory = face->root.driver->root.memory;\n+    FT_Memory     memory = face->root.memory;\n@@ -1252,5 +1275,5 @@\n-    FT_TRACE3(( \"sTypoAscender:  %4d\\n\",   os2->sTypoAscender ));\n-    FT_TRACE3(( \"sTypoDescender: %4d\\n\",   os2->sTypoDescender ));\n-    FT_TRACE3(( \"usWinAscent:    %4u\\n\",   os2->usWinAscent ));\n-    FT_TRACE3(( \"usWinDescent:   %4u\\n\",   os2->usWinDescent ));\n-    FT_TRACE3(( \"fsSelection:    0x%2x\\n\", os2->fsSelection ));\n+    FT_TRACE3(( \"sTypoAscender:  %4hd\\n\",   os2->sTypoAscender ));\n+    FT_TRACE3(( \"sTypoDescender: %4hd\\n\",   os2->sTypoDescender ));\n+    FT_TRACE3(( \"usWinAscent:    %4hu\\n\",   os2->usWinAscent ));\n+    FT_TRACE3(( \"usWinDescent:   %4hu\\n\",   os2->usWinDescent ));\n+    FT_TRACE3(( \"fsSelection:    0x%2hx\\n\", os2->fsSelection ));\n@@ -1314,0 +1337,6 @@\n+    if ( post->FormatType != 0x00030000L &&\n+         post->FormatType != 0x00025000L &&\n+         post->FormatType != 0x00020000L &&\n+         post->FormatType != 0x00010000L )\n+      return FT_THROW( Invalid_Post_Table_Format );\n+\n@@ -1413,2 +1442,2 @@\n-    FT_UInt        j,num_ranges;\n-    TT_GaspRange   gaspranges = NULL;\n+    FT_UShort      j, num_ranges;\n+    TT_GaspRange   gasp_ranges = NULL;\n@@ -1425,2 +1454,2 @@\n-    face->gasp.version   = FT_GET_USHORT();\n-    face->gasp.numRanges = FT_GET_USHORT();\n+    face->gasp.version = FT_GET_USHORT();\n+    num_ranges         = FT_GET_USHORT();\n@@ -1438,2 +1467,1 @@\n-    num_ranges = face->gasp.numRanges;\n-    FT_TRACE3(( \"numRanges: %u\\n\", num_ranges ));\n+    FT_TRACE3(( \"numRanges: %hu\\n\", num_ranges ));\n@@ -1441,2 +1469,2 @@\n-    if ( FT_QNEW_ARRAY( face->gasp.gaspRanges, num_ranges ) ||\n-         FT_FRAME_ENTER( num_ranges * 4L )                  )\n+    if ( FT_QNEW_ARRAY( gasp_ranges, num_ranges ) ||\n+         FT_FRAME_ENTER( num_ranges * 4L )        )\n@@ -1445,2 +1473,0 @@\n-    gaspranges = face->gasp.gaspRanges;\n-\n@@ -1449,2 +1475,2 @@\n-      gaspranges[j].maxPPEM  = FT_GET_USHORT();\n-      gaspranges[j].gaspFlag = FT_GET_USHORT();\n+      gasp_ranges[j].maxPPEM  = FT_GET_USHORT();\n+      gasp_ranges[j].gaspFlag = FT_GET_USHORT();\n@@ -1452,1 +1478,1 @@\n-      FT_TRACE3(( \"gaspRange %d: rangeMaxPPEM %5d, rangeGaspBehavior 0x%x\\n\",\n+      FT_TRACE3(( \"gaspRange %hu: rangeMaxPPEM %5hu, rangeGaspBehavior 0x%hx\\n\",\n@@ -1454,2 +1480,2 @@\n-                  gaspranges[j].maxPPEM,\n-                  gaspranges[j].gaspFlag ));\n+                  gasp_ranges[j].maxPPEM,\n+                  gasp_ranges[j].gaspFlag ));\n@@ -1458,0 +1484,4 @@\n+    face->gasp.gaspRanges = gasp_ranges;\n+    gasp_ranges           = NULL;\n+    face->gasp.numRanges  = num_ranges;\n+\n@@ -1461,0 +1491,1 @@\n+    FT_FREE( gasp_ranges );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttload.c","additions":78,"deletions":47,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n@@ -242,1 +242,1 @@\n-      (FT_Service_MetricsVariations)face->var;\n+      (FT_Service_MetricsVariations)face->tt_var;\n@@ -309,1 +309,1 @@\n-    if ( var )\n+    if ( var && face->blend )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttmtx.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttmtx.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -61,1 +61,1 @@\n-#else \/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n+#else \/* !FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n@@ -155,1 +155,1 @@\n-#endif \/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n+#endif \/* !FT_CONFIG_OPTION_POSTSCRIPT_NAMES *\/\n@@ -159,3 +159,4 @@\n-  load_format_20( TT_Face    face,\n-                  FT_Stream  stream,\n-                  FT_ULong   post_limit )\n+  load_format_20( TT_Post_Names  names,\n+                  FT_Stream      stream,\n+                  FT_UShort      num_glyphs,\n+                  FT_ULong       post_len )\n@@ -166,2 +167,2 @@\n-    FT_Int      num_glyphs;\n-    FT_UShort   num_names;\n+    FT_UShort   n;\n+    FT_UShort   num_names = 0;\n@@ -170,1 +171,2 @@\n-    FT_Char**   name_strings  = NULL;\n+    FT_Byte**   name_strings  = NULL;\n+    FT_Byte*    q;\n@@ -173,10 +175,1 @@\n-    if ( FT_READ_USHORT( num_glyphs ) )\n-      goto Exit;\n-\n-    \/* UNDOCUMENTED!  The number of glyphs in this table can be smaller *\/\n-    \/* than the value in the maxp table (cf. cyberbit.ttf).             *\/\n-\n-    \/* There already exist fonts which have more than 32768 glyph names *\/\n-    \/* in this table, so the test for this threshold has been dropped.  *\/\n-\n-    if ( num_glyphs > face->max_profile.numGlyphs )\n+    if ( (FT_ULong)num_glyphs * 2 > post_len )\n@@ -188,11 +181,4 @@\n-    \/* load the indices *\/\n-    {\n-      FT_Int  n;\n-\n-\n-      if ( FT_NEW_ARRAY ( glyph_indices, num_glyphs ) ||\n-           FT_FRAME_ENTER( num_glyphs * 2L )          )\n-        goto Fail;\n-\n-      for ( n = 0; n < num_glyphs; n++ )\n-        glyph_indices[n] = FT_GET_USHORT();\n+    \/* load the indices and note their maximum *\/\n+    if ( FT_QNEW_ARRAY( glyph_indices, num_glyphs ) ||\n+         FT_FRAME_ENTER( num_glyphs * 2 )           )\n+      goto Fail;\n@@ -200,2 +186,1 @@\n-      FT_FRAME_EXIT();\n-    }\n+    q = (FT_Byte*)stream->cursor;\n@@ -203,1 +188,1 @@\n-    \/* compute number of names stored in table *\/\n+    for ( n = 0; n < num_glyphs; n++ )\n@@ -205,1 +190,1 @@\n-      FT_Int  n;\n+      FT_UShort  idx = FT_NEXT_USHORT( q );\n@@ -208,1 +193,2 @@\n-      num_names = 0;\n+      if ( idx > num_names )\n+        num_names = idx;\n@@ -210,3 +196,2 @@\n-      for ( n = 0; n < num_glyphs; n++ )\n-      {\n-        FT_Int  idx;\n+      glyph_indices[n] = idx;\n+    }\n@@ -214,0 +199,1 @@\n+    FT_FRAME_EXIT();\n@@ -215,9 +201,2 @@\n-        idx = glyph_indices[n];\n-        if ( idx >= 258 )\n-        {\n-          idx -= 257;\n-          if ( idx > num_names )\n-            num_names = (FT_UShort)idx;\n-        }\n-      }\n-    }\n+    \/* compute number of names stored in the table *\/\n+    num_names = num_names > 257 ? num_names - 257 : 0;\n@@ -226,0 +205,1 @@\n+    if ( num_names )\n@@ -227,2 +207,2 @@\n-      FT_UShort  n;\n-\n+      FT_Byte*   p;\n+      FT_Byte*   p_end;\n@@ -230,6 +210,0 @@\n-      if ( FT_NEW_ARRAY( name_strings, num_names ) )\n-        goto Fail;\n-\n-      for ( n = 0; n < num_names; n++ )\n-      {\n-        FT_UInt  len;\n@@ -237,0 +211,1 @@\n+      post_len -= (FT_ULong)num_glyphs * 2;\n@@ -238,6 +213,3 @@\n-        if ( FT_STREAM_POS() >= post_limit )\n-          break;\n-        else\n-        {\n-          FT_TRACE6(( \"load_format_20: %ld byte left in post table\\n\",\n-                      post_limit - FT_STREAM_POS() ));\n+      if ( FT_QALLOC( name_strings, num_names * sizeof ( FT_Byte* ) +\n+                                    post_len + 1 ) )\n+        goto Fail;\n@@ -245,3 +217,3 @@\n-          if ( FT_READ_BYTE( len ) )\n-            goto Fail1;\n-        }\n+      p = (FT_Byte*)( name_strings + num_names );\n+      if ( FT_STREAM_READ( p, post_len ) )\n+        goto Fail;\n@@ -249,4 +221,1 @@\n-        if ( len > post_limit                   ||\n-             FT_STREAM_POS() > post_limit - len )\n-        {\n-          FT_Int  d = (FT_Int)post_limit - (FT_Int)FT_STREAM_POS();\n+      p_end = p + post_len;\n@@ -254,0 +223,4 @@\n+      \/* convert from Pascal- to C-strings and set pointers *\/\n+      for ( n = 0; p < p_end && n < num_names; n++ )\n+      {\n+        FT_UInt  len = *p;\n@@ -255,6 +228,0 @@\n-          FT_ERROR(( \"load_format_20:\"\n-                     \" exceeding string length (%d),\"\n-                     \" truncating at end of post table (%d byte left)\\n\",\n-                     len, d ));\n-          len = (FT_UInt)FT_MAX( 0, d );\n-        }\n@@ -262,3 +229,3 @@\n-        if ( FT_NEW_ARRAY( name_strings[n], len + 1 ) ||\n-             FT_STREAM_READ( name_strings[n], len   ) )\n-          goto Fail1;\n+        \/* names in the Adobe Glyph List are shorter than 40 characters *\/\n+        if ( len >= 40U )\n+          FT_TRACE4(( \"load_format_20: unusual %u-char name found\\n\", len ));\n@@ -266,1 +233,3 @@\n-        name_strings[n][len] = '\\0';\n+        *p++            = 0;\n+        name_strings[n] = p;\n+        p              += len;\n@@ -268,0 +237,1 @@\n+      *p_end = 0;\n@@ -269,0 +239,1 @@\n+      \/* deal with missing or insufficient string data *\/\n@@ -271,4 +242,3 @@\n-        FT_ERROR(( \"load_format_20:\"\n-                   \" all entries in post table are already parsed,\"\n-                   \" using NULL names for gid %d - %d\\n\",\n-                    n, num_names - 1 ));\n+        FT_TRACE4(( \"load_format_20: %hu PostScript names are truncated\\n\",\n+                    (FT_UShort)( num_names - n ) ));\n+\n@@ -276,4 +246,1 @@\n-          if ( FT_NEW_ARRAY( name_strings[n], 1 ) )\n-            goto Fail1;\n-          else\n-            name_strings[n][0] = '\\0';\n+          name_strings[n] = p_end;\n@@ -284,3 +251,4 @@\n-    {\n-      TT_Post_20  table = &face->postscript_names.names.format_20;\n-\n+    names->num_glyphs    = num_glyphs;\n+    names->num_names     = num_names;\n+    names->glyph_indices = glyph_indices;\n+    names->glyph_names   = name_strings;\n@@ -288,5 +256,0 @@\n-      table->num_glyphs    = (FT_UShort)num_glyphs;\n-      table->num_names     = (FT_UShort)num_names;\n-      table->glyph_indices = glyph_indices;\n-      table->glyph_names   = name_strings;\n-    }\n@@ -295,9 +258,0 @@\n-  Fail1:\n-    {\n-      FT_UShort  n;\n-\n-\n-      for ( n = 0; n < num_names; n++ )\n-        FT_FREE( name_strings[n] );\n-    }\n-\n@@ -314,3 +268,4 @@\n-  load_format_25( TT_Face    face,\n-                  FT_Stream  stream,\n-                  FT_ULong   post_limit )\n+  load_format_25( TT_Post_Names  names,\n+                  FT_Stream      stream,\n+                  FT_UShort      num_glyphs,\n+                  FT_ULong       post_len )\n@@ -321,5 +276,3 @@\n-    FT_Int     num_glyphs;\n-    FT_Char*   offset_table = NULL;\n-\n-    FT_UNUSED( post_limit );\n-\n+    FT_UShort   n;\n+    FT_UShort*  glyph_indices = NULL;\n+    FT_Byte*    q;\n@@ -327,2 +280,0 @@\n-    if ( FT_READ_USHORT( num_glyphs ) )\n-      goto Exit;\n@@ -330,4 +281,3 @@\n-    \/* check the number of glyphs *\/\n-    if ( num_glyphs > face->max_profile.numGlyphs ||\n-         num_glyphs > 258                         ||\n-         num_glyphs < 1                           )\n+    \/* check the number of glyphs, including the theoretical limit *\/\n+    if ( num_glyphs > post_len  ||\n+         num_glyphs > 258 + 128 )\n@@ -339,2 +289,3 @@\n-    if ( FT_NEW_ARRAY( offset_table, num_glyphs )   ||\n-         FT_STREAM_READ( offset_table, num_glyphs ) )\n+    \/* load the indices and check their Mac range *\/\n+    if ( FT_QNEW_ARRAY( glyph_indices, num_glyphs ) ||\n+         FT_FRAME_ENTER( num_glyphs )               )\n@@ -343,3 +294,1 @@\n-    \/* now check the offset table *\/\n-    {\n-      FT_Int  n;\n+    q = (FT_Byte*)stream->cursor;\n@@ -347,0 +296,3 @@\n+    for ( n = 0; n < num_glyphs; n++ )\n+    {\n+      FT_Int  idx = n + FT_NEXT_CHAR( q );\n@@ -348,3 +300,0 @@\n-      for ( n = 0; n < num_glyphs; n++ )\n-      {\n-        FT_Long  idx = (FT_Long)n + offset_table[n];\n@@ -352,0 +301,2 @@\n+      if ( idx < 0 || idx > 257 )\n+        idx = 0;\n@@ -353,6 +304,1 @@\n-        if ( idx < 0 || idx > num_glyphs )\n-        {\n-          error = FT_THROW( Invalid_File_Format );\n-          goto Fail;\n-        }\n-      }\n+      glyph_indices[n] = (FT_UShort)idx;\n@@ -361,4 +307,1 @@\n-    \/* OK, set table fields and exit successfully *\/\n-    {\n-      TT_Post_25  table = &face->postscript_names.names.format_25;\n-\n+    FT_FRAME_EXIT();\n@@ -366,3 +309,3 @@\n-      table->num_glyphs = (FT_UShort)num_glyphs;\n-      table->offsets    = offset_table;\n-    }\n+    \/* OK, set table fields and exit successfully *\/\n+    names->num_glyphs    = num_glyphs;\n+    names->glyph_indices = glyph_indices;\n@@ -373,1 +316,1 @@\n-    FT_FREE( offset_table );\n+    FT_FREE( glyph_indices );\n@@ -383,3 +326,3 @@\n-    FT_Stream  stream;\n-    FT_Error   error;\n-    FT_Fixed   format;\n+    FT_Error   error = FT_Err_Ok;\n+    FT_Stream  stream = face->root.stream;\n+    FT_Fixed   format = face->postscript.FormatType;\n@@ -387,1 +330,1 @@\n-    FT_ULong   post_limit;\n+    FT_UShort  num_glyphs;\n@@ -390,3 +333,0 @@\n-    \/* get a stream for the face's resource *\/\n-    stream = face->root.stream;\n-\n@@ -398,6 +338,7 @@\n-    post_limit = FT_STREAM_POS() + post_len;\n-\n-    format = face->postscript.FormatType;\n-\n-    \/* go to beginning of subtable *\/\n-    if ( FT_STREAM_SKIP( 32 ) )\n+    \/* UNDOCUMENTED!  The number of glyphs in this table can be smaller *\/\n+    \/* than the value in the maxp table (cf. cyberbit.ttf).             *\/\n+    if ( post_len < 34                            ||\n+         FT_STREAM_SKIP( 32 )                     ||\n+         FT_READ_USHORT( num_glyphs )             ||\n+         num_glyphs > face->max_profile.numGlyphs ||\n+         num_glyphs == 0 )\n@@ -406,1 +347,1 @@\n-    \/* now read postscript table *\/\n+    \/* now read postscript names data *\/\n@@ -408,1 +349,2 @@\n-      error = load_format_20( face, stream, post_limit );\n+      error = load_format_20( &face->postscript_names, stream,\n+                              num_glyphs, post_len - 34 );\n@@ -410,5 +352,2 @@\n-      error = load_format_25( face, stream, post_limit );\n-    else\n-      error = FT_THROW( Invalid_File_Format );\n-\n-    face->postscript_names.loaded = 1;\n+      error = load_format_25( &face->postscript_names, stream,\n+                              num_glyphs, post_len - 34 );\n@@ -417,0 +356,1 @@\n+    face->postscript_names.loaded = 1;  \/* even if failed *\/\n@@ -426,1 +366,0 @@\n-    FT_Fixed       format;\n@@ -429,1 +368,1 @@\n-    if ( names->loaded )\n+    if ( names->num_glyphs )\n@@ -431,21 +370,3 @@\n-      format = face->postscript.FormatType;\n-\n-      if ( format == 0x00020000L )\n-      {\n-        TT_Post_20  table = &names->names.format_20;\n-        FT_UShort   n;\n-\n-\n-        FT_FREE( table->glyph_indices );\n-        table->num_glyphs = 0;\n-\n-        for ( n = 0; n < table->num_names; n++ )\n-          FT_FREE( table->glyph_names[n] );\n-\n-        FT_FREE( table->glyph_names );\n-        table->num_names = 0;\n-      }\n-      else if ( format == 0x00025000L )\n-      {\n-        TT_Post_25  table = &names->names.format_25;\n-\n+      FT_FREE( names->glyph_indices );\n+      names->num_glyphs = 0;\n+    }\n@@ -453,3 +374,4 @@\n-        FT_FREE( table->offsets );\n-        table->num_glyphs = 0;\n-      }\n+    if ( names->num_names )\n+    {\n+      FT_FREE( names->glyph_names );\n+      names->num_names = 0;\n@@ -457,0 +379,1 @@\n+\n@@ -492,1 +415,0 @@\n-    TT_Post_Names  names;\n@@ -512,2 +434,0 @@\n-    names = &face->postscript_names;\n-\n@@ -519,1 +439,2 @@\n-    if ( format == 0x00010000L )\n+    if ( format == 0x00020000L ||\n+         format == 0x00025000L )\n@@ -521,6 +442,1 @@\n-      if ( idx < 258 )                    \/* paranoid checking *\/\n-        *PSname = MAC_NAME( idx );\n-    }\n-    else if ( format == 0x00020000L )\n-    {\n-      TT_Post_20  table = &names->names.format_20;\n+      TT_Post_Names  names = &face->postscript_names;\n@@ -536,1 +452,1 @@\n-      if ( idx < (FT_UInt)table->num_glyphs )\n+      if ( idx < (FT_UInt)names->num_glyphs )\n@@ -538,1 +454,1 @@\n-        FT_UShort  name_index = table->glyph_indices[idx];\n+        FT_UShort  name_index = names->glyph_indices[idx];\n@@ -543,2 +459,2 @@\n-        else\n-          *PSname = (FT_String*)table->glyph_names[name_index - 258];\n+        else  \/* only for version 2.0 *\/\n+          *PSname = (FT_String*)names->glyph_names[name_index - 258];\n@@ -547,11 +463,0 @@\n-    else if ( format == 0x00025000L )\n-    {\n-      TT_Post_25  table = &names->names.format_25;\n-\n-\n-      if ( !names->loaded )\n-      {\n-        error = load_post_names( face );\n-        if ( error )\n-          goto End;\n-      }\n@@ -559,3 +464,4 @@\n-      if ( idx < (FT_UInt)table->num_glyphs )    \/* paranoid checking *\/\n-        *PSname = MAC_NAME( (FT_Int)idx + table->offsets[idx] );\n-    }\n+    \/* version 1.0 is only valid with 258 glyphs *\/\n+    else if ( format == 0x00010000L              &&\n+              face->max_profile.numGlyphs == 258 )\n+      *PSname = MAC_NAME( idx );\n@@ -566,0 +472,1 @@\n+    \/* post format errors ignored *\/\n@@ -572,1 +479,1 @@\n-  typedef int  _tt_post_dummy;\n+  typedef int  tt_post_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttpost.c","additions":121,"deletions":214,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttpost.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2024 by\n@@ -175,2 +175,0 @@\n-        \/* we currently don't support bit 1; however, it is better to *\/\n-        \/* draw at least something...                                 *\/\n@@ -178,4 +176,1 @@\n-          FT_TRACE1(( \"tt_face_load_sbit_strikes:\"\n-                      \" sbix overlay not supported yet\\n\"\n-                      \"                          \"\n-                      \" expect bad rendering results\\n\" ));\n+          face->root.face_flags |= FT_FACE_FLAG_SBIX_OVERLAY;\n@@ -243,2 +238,2 @@\n-                  \" no embedded bitmap data table found;\\n\"\n-                  \"                          \"\n+                  \" no embedded bitmap data table found;\\n\" ));\n+      FT_TRACE2(( \"                          \"\n@@ -348,2 +343,2 @@\n-                        \" sanitizing invalid ascender and descender\\n\"\n-                        \"                            \"\n+                        \" sanitizing invalid ascender and descender\\n\" ));\n+            FT_TRACE2(( \"                            \"\n@@ -377,2 +372,2 @@\n-                      \" sanitizing invalid height value\\n\"\n-                      \"                            \"\n+                      \" sanitizing invalid height value\\n\" ));\n+          FT_TRACE2(( \"                            \"\n@@ -393,2 +388,1 @@\n-        metrics->x_scale = FT_MulDiv( metrics->x_ppem,\n-                                      64 * 0x10000,\n+        metrics->x_scale = FT_DivFix( metrics->x_ppem * 64,\n@@ -396,2 +390,1 @@\n-        metrics->y_scale = FT_MulDiv( metrics->y_ppem,\n-                                      64 * 0x10000,\n+        metrics->y_scale = FT_DivFix( metrics->y_ppem * 64,\n@@ -407,1 +400,1 @@\n-        FT_UShort       upem, ppem, resolution;\n+        FT_UShort       ppem, resolution;\n@@ -409,1 +402,1 @@\n-        FT_Pos          ppem_; \/* to reduce casts *\/\n+        FT_Fixed        scale;\n@@ -432,3 +425,0 @@\n-        upem = face->header.Units_Per_EM;\n-        hori = &face->horizontal;\n-\n@@ -438,1 +428,2 @@\n-        ppem_ = (FT_Pos)ppem;\n+        scale = FT_DivFix( ppem * 64, face->header.Units_Per_EM );\n+        hori  = &face->horizontal;\n@@ -440,9 +431,6 @@\n-        metrics->ascender =\n-          FT_MulDiv( hori->Ascender, ppem_ * 64, upem );\n-        metrics->descender =\n-          FT_MulDiv( hori->Descender, ppem_ * 64, upem );\n-        metrics->height =\n-          FT_MulDiv( hori->Ascender - hori->Descender + hori->Line_Gap,\n-                     ppem_ * 64, upem );\n-        metrics->max_advance =\n-          FT_MulDiv( hori->advance_Width_Max, ppem_ * 64, upem );\n+        metrics->ascender    = FT_MulFix( hori->Ascender, scale );\n+        metrics->descender   = FT_MulFix( hori->Descender, scale );\n+        metrics->height      =\n+          FT_MulFix( hori->Ascender - hori->Descender + hori->Line_Gap,\n+                     scale );\n+        metrics->max_advance = FT_MulFix( hori->advance_Width_Max, scale );\n@@ -452,6 +440,2 @@\n-        metrics->x_scale = FT_MulDiv( metrics->x_ppem,\n-                                      64 * 0x10000,\n-                                      face->header.Units_Per_EM );\n-        metrics->y_scale = FT_MulDiv( metrics->y_ppem,\n-                                      64 * 0x10000,\n-                                      face->header.Units_Per_EM );\n+        metrics->x_scale = scale;\n+        metrics->y_scale = scale;\n@@ -729,0 +713,3 @@\n+    if ( !line )\n+      goto Exit;\n+\n@@ -1209,1 +1196,1 @@\n-        \/* fall-through *\/\n+        FALL_THROUGH;\n@@ -1576,1 +1563,1 @@\n-      FT_Short   abearing;\n+      FT_Short   abearing; \/* not used here *\/\n@@ -1583,1 +1570,5 @@\n-      metrics->horiBearingY = (FT_Short)( -originOffsetY + metrics->height );\n+      metrics->vertBearingX = (FT_Short)originOffsetX;\n+\n+      metrics->horiBearingY = (FT_Short)( originOffsetY + metrics->height );\n+      metrics->vertBearingY = (FT_Short)originOffsetY;\n+\n@@ -1587,0 +1578,13 @@\n+\n+      if ( face->vertical_info )\n+        tt_face_get_metrics( face, TRUE, glyph_index, &abearing, &aadvance );\n+      else if ( face->os2.version != 0xFFFFU )\n+        aadvance = (FT_UShort)FT_ABS( face->os2.sTypoAscender -\n+                                      face->os2.sTypoDescender );\n+      else\n+        aadvance = (FT_UShort)FT_ABS( face->horizontal.Ascender -\n+                                      face->horizontal.Descender );\n+\n+      metrics->vertAdvance  = (FT_UShort)( aadvance *\n+                                           face->root.size->metrics.x_ppem \/\n+                                           face->header.Units_Per_EM );\n@@ -1592,1 +1596,1 @@\n-  FT_LOCAL( FT_Error )\n+  FT_LOCAL_DEF( FT_Error )\n@@ -1676,1 +1680,1 @@\n-  typedef int  _tt_sbit_dummy;\n+  typedef int  tt_sbit_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttsbit.c","additions":47,"deletions":43,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/ttsbit.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2024 by\n@@ -20,0 +20,3 @@\n+\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n+\n@@ -31,1 +34,1 @@\n-  FT_LOCAL_DEF( FT_ULong )\n+  FT_LOCAL_DEF( FT_Tag )\n@@ -34,1 +37,1 @@\n-    const FT_ULong  known_tags[63] =\n+    static const FT_Tag  known_tags[63] =\n@@ -108,0 +111,7 @@\n+#else \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n+  \/* ANSI C doesn't like empty source files *\/\n+  typedef int  woff2tags_dummy_;\n+\n+#endif \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/woff2tags.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *   WOFFF2 Font table tags (specification).\n+ *   WOFF2 Font table tags (specification).\n@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2024 by\n@@ -29,0 +29,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n@@ -30,1 +31,1 @@\n-  FT_LOCAL( FT_ULong )\n+  FT_LOCAL( FT_Tag )\n@@ -33,0 +34,1 @@\n+#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/sfnt\/woff2tags.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n@@ -152,8 +152,4 @@\n-#define ADD_LONG( a, b )                                    \\\n-          (long)( (unsigned long)(a) + (unsigned long)(b) )\n-#define SUB_LONG( a, b )                                    \\\n-          (long)( (unsigned long)(a) - (unsigned long)(b) )\n-#define MUL_LONG( a, b )                                    \\\n-          (long)( (unsigned long)(a) * (unsigned long)(b) )\n-#define NEG_LONG( a )                                       \\\n-          (long)( -(unsigned long)(a) )\n+#define ADD_INT( a, b )                                  \\\n+          (int)( (unsigned int)(a) + (unsigned int)(b) )\n+\n+#define FT_STATIC_BYTE_CAST( type, var )  (type)(unsigned char)(var)\n@@ -171,4 +167,5 @@\n-#define ErrRaster_Invalid_Mode      -2\n-#define ErrRaster_Invalid_Outline   -1\n-#define ErrRaster_Invalid_Argument  -3\n-#define ErrRaster_Memory_Overflow   -4\n+#define Smooth_Err_Ok                    0\n+#define Smooth_Err_Invalid_Outline      -1\n+#define Smooth_Err_Cannot_Render_Glyph  -2\n+#define Smooth_Err_Invalid_Argument     -3\n+#define Smooth_Err_Raster_Overflow      -4\n@@ -232,5 +229,5 @@\n-#define FT_THROW( e )                               \\\n-          ( FT_Throw( FT_ERR_CAT( ErrRaster_, e ),  \\\n-                      __LINE__,                     \\\n-                      __FILE__ )                  | \\\n-            FT_ERR_CAT( ErrRaster_, e )           )\n+#define FT_THROW( e )                                \\\n+          ( FT_Throw( FT_ERR_CAT( Smooth_Err_, e ),  \\\n+                      __LINE__,                      \\\n+                      __FILE__ )                   | \\\n+            FT_ERR_CAT( Smooth_Err_, e )           )\n@@ -243,2 +240,1 @@\n-#define FT_THROW( e )   FT_ERR_CAT( ErrRaster_, e )\n-\n+#define FT_THROW( e )   FT_ERR_CAT( Smooth_Err_, e )\n@@ -249,0 +245,4 @@\n+#define FT_Trace_Enable()   do { } while ( 0 )  \/* nothing *\/\n+#define FT_Trace_Disable()  do { } while ( 0 )  \/* nothing *\/\n+\n+\n@@ -281,0 +281,2 @@\n+#include <ft2build.h>\n+#include FT_CONFIG_CONFIG_H\n@@ -289,4 +291,0 @@\n-#define Smooth_Err_Invalid_Mode     Smooth_Err_Cannot_Render_Glyph\n-#define Smooth_Err_Memory_Overflow  Smooth_Err_Out_Of_Memory\n-#define ErrRaster_Memory_Overflow   Smooth_Err_Out_Of_Memory\n-\n@@ -338,0 +336,1 @@\n+#undef TRUNC\n@@ -339,0 +338,1 @@\n+#undef FRACT\n@@ -365,1 +365,1 @@\n-#ifdef  __arm__\n+#if defined( __GNUC__ ) && __GNUC__ < 7 && defined( __arm__ )\n@@ -385,8 +385,52 @@\n-  \/* These macros speed up repetitive divisions by replacing them *\/\n-  \/* with multiplications and right shifts.                       *\/\n-#define FT_UDIVPREP( c, b )                                        \\\n-  long  b ## _r = c ? (long)( FT_ULONG_MAX >> PIXEL_BITS ) \/ ( b ) \\\n-                    : 0\n-#define FT_UDIV( a, b )                                                \\\n-  (TCoord)( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) >>   \\\n-            ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )\n+  \/* Calculating coverages for a slanted line requires a division each *\/\n+  \/* time the line crosses from cell to cell.  These macros speed up   *\/\n+  \/* the repetitive divisions by replacing them with multiplications   *\/\n+  \/* and right shifts so that at most two divisions are performed for  *\/\n+  \/* each slanted line.  Nevertheless, these divisions are noticeable  *\/\n+  \/* in the overall performance because flattened curves produce a     *\/\n+  \/* very large number of slanted lines.                               *\/\n+  \/*                                                                   *\/\n+  \/* The division results here are always within ONE_PIXEL.  Therefore *\/\n+  \/* the shift magnitude should be at least PIXEL_BITS wider than the  *\/\n+  \/* divisors to provide sufficient accuracy of the multiply-shift.    *\/\n+  \/* It should not exceed (64 - PIXEL_BITS) to prevent overflowing and *\/\n+  \/* leave enough room for 64-bit unsigned multiplication however.     *\/\n+#define FT_UDIVPREP( c, b )                                \\\n+  FT_Int64  b ## _r = c ? (FT_Int64)0xFFFFFFFF \/ ( b ) : 0\n+#define FT_UDIV( a, b )                                           \\\n+  (TCoord)( ( (FT_UInt64)( a ) * (FT_UInt64)( b ## _r ) ) >> 32 )\n+\n+\n+  \/* Scale area and apply fill rule to calculate the coverage byte. *\/\n+  \/* The top fill bit is used for the non-zero rule. The eighth     *\/\n+  \/* fill bit is used for the even-odd rule.  The higher coverage   *\/\n+  \/* bytes are either clamped for the non-zero-rule or discarded    *\/\n+  \/* later for the even-odd rule.                                   *\/\n+#define FT_FILL_RULE( coverage, area, fill )                \\\n+  FT_BEGIN_STMNT                                            \\\n+    coverage = (int)( area >> ( PIXEL_BITS * 2 + 1 - 8 ) ); \\\n+    if ( coverage & fill )                                  \\\n+      coverage = ~coverage;                                 \\\n+    if ( coverage > 255 && fill & INT_MIN )                 \\\n+      coverage = 255;                                       \\\n+  FT_END_STMNT\n+\n+\n+  \/* It is faster to write small spans byte-by-byte than calling     *\/\n+  \/* `memset'.  This is mainly due to the cost of the function call. *\/\n+#define FT_GRAY_SET( d, s, count )                   \\\n+  FT_BEGIN_STMNT                                     \\\n+    unsigned char* q = d;                            \\\n+    switch ( count )                                 \\\n+    {                                                \\\n+      case 7: *q++ = (unsigned char)s; FALL_THROUGH; \\\n+      case 6: *q++ = (unsigned char)s; FALL_THROUGH; \\\n+      case 5: *q++ = (unsigned char)s; FALL_THROUGH; \\\n+      case 4: *q++ = (unsigned char)s; FALL_THROUGH; \\\n+      case 3: *q++ = (unsigned char)s; FALL_THROUGH; \\\n+      case 2: *q++ = (unsigned char)s; FALL_THROUGH; \\\n+      case 1: *q   = (unsigned char)s; FALL_THROUGH; \\\n+      case 0: break;                                 \\\n+      default: FT_MEM_SET( d, s, count );            \\\n+    }                                                \\\n+  FT_END_STMNT\n@@ -435,1 +479,1 @@\n-#define FT_MAX_GRAY_SPANS  10\n+#define FT_MAX_GRAY_SPANS  16\n@@ -448,1 +492,1 @@\n-    ft_jmp_buf  jump_buffer;\n+    FT_BBox     cbox;\n@@ -450,2 +494,1 @@\n-    TCoord  ex, ey;\n-    TCoord  min_ex, max_ex;\n+    TCoord  min_ex, max_ex;  \/* min and max integer pixel coordinates *\/\n@@ -453,0 +496,1 @@\n+    TCoord  count_ey;        \/* same as (max_ey - min_ey) *\/\n@@ -454,3 +498,3 @@\n-    TArea   area;\n-    TCoord  cover;\n-    int     invalid;\n+    PCell       cell;        \/* current cell                             *\/\n+    PCell       cell_free;   \/* call allocation next free slot           *\/\n+    PCell       cell_null;   \/* last cell, used as dumpster and limit    *\/\n@@ -458,4 +502,2 @@\n-    PCell*      ycells;\n-    PCell       cells;\n-    FT_PtrDist  max_cells;\n-    FT_PtrDist  num_cells;\n+    PCell*      ycells;      \/* array of cell linked-lists; one per      *\/\n+                             \/* vertical coordinate in the current band  *\/\n@@ -463,1 +505,1 @@\n-    TPos    x,  y;\n+    TPos        x,  y;       \/* last point position *\/\n@@ -465,2 +507,2 @@\n-    FT_Outline  outline;\n-    TPixmap     target;\n+    FT_Outline  outline;     \/* input outline *\/\n+    TPixmap     target;      \/* target pixmap *\/\n@@ -470,2 +512,2 @@\n-    FT_Span              spans[FT_MAX_GRAY_SPANS];\n-    int                  num_spans;\n+\n+    ft_jmp_buf  jump_buffer;\n@@ -479,1 +521,0 @@\n-\n@@ -486,0 +527,9 @@\n+  \/* The |x| value of the null cell.  Must be the largest possible *\/\n+  \/* integer value stored in a `TCell.x` field.                    *\/\n+#define CELL_MAX_X_VALUE    INT_MAX\n+\n+\n+#define FT_INTEGRATE( ras, a, b )                                       \\\n+          ras.cell->cover = ADD_INT( ras.cell->cover, a ),              \\\n+          ras.cell->area  = ADD_INT( ras.cell->area, (a) * (TArea)(b) )\n+\n@@ -489,1 +539,1 @@\n-    void*         memory;\n+    void*  memory;\n@@ -511,1 +561,1 @@\n-      for ( ; cell != NULL; cell = cell->next )\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n@@ -523,1 +573,1 @@\n-   * Record the current cell in the linked list.\n+   * Set the current cell to a new position.\n@@ -526,1 +576,2 @@\n-  gray_record_cell( RAS_ARG )\n+  gray_set_cell( RAS_ARG_ TCoord  ex,\n+                          TCoord  ey )\n@@ -528,3 +579,9 @@\n-    PCell  *pcell, cell;\n-    TCoord  x = ras.ex;\n-\n+    \/* Move the cell pointer to a new position in the linked list. We use  *\/\n+    \/* a dumpster null cell for everything outside of the clipping region  *\/\n+    \/* during the render phase.  This means that:                          *\/\n+    \/*                                                                     *\/\n+    \/* . the new vertical position must be within min_ey..max_ey-1.        *\/\n+    \/* . the new horizontal position must be strictly less than max_ex     *\/\n+    \/*                                                                     *\/\n+    \/* Note that if a cell is to the left of the clipping region, it is    *\/\n+    \/* actually set to the (min_ex-1) horizontal position.                 *\/\n@@ -532,5 +589,1 @@\n-    pcell = &ras.ycells[ras.ey - ras.min_ey];\n-    while ( ( cell = *pcell ) )\n-    {\n-      if ( cell->x > x )\n-        break;\n+    TCoord  ey_index = ey - ras.min_ey;\n@@ -538,2 +591,0 @@\n-      if ( cell->x == x )\n-        goto Found;\n@@ -541,2 +592,6 @@\n-      pcell = &cell->next;\n-    }\n+    if ( ey_index < 0 || ey_index >= ras.count_ey || ex >= ras.max_ex )\n+      ras.cell = ras.cell_null;\n+    else\n+    {\n+      PCell*  pcell = ras.ycells + ey_index;\n+      PCell   cell;\n@@ -544,2 +599,0 @@\n-    if ( ras.num_cells >= ras.max_cells )\n-      ft_longjmp( ras.jump_buffer, 1 );\n@@ -547,5 +600,1 @@\n-    \/* insert new cell *\/\n-    cell        = ras.cells + ras.num_cells++;\n-    cell->x     = x;\n-    cell->area  = ras.area;\n-    cell->cover = ras.cover;\n+      ex = FT_MAX( ex, ras.min_ex - 1 );\n@@ -553,2 +602,3 @@\n-    cell->next  = *pcell;\n-    *pcell      = cell;\n+      while ( 1 )\n+      {\n+        cell = *pcell;\n@@ -556,1 +606,2 @@\n-    return;\n+        if ( cell->x > ex )\n+          break;\n@@ -558,5 +609,2 @@\n-  Found:\n-    \/* update old cell *\/\n-    cell->area  += ras.area;\n-    cell->cover += ras.cover;\n-  }\n+        if ( cell->x == ex )\n+          goto Found;\n@@ -564,0 +612,2 @@\n+        pcell = &cell->next;\n+      }\n@@ -565,17 +615,4 @@\n-  \/**************************************************************************\n-   *\n-   * Set the current cell to a new position.\n-   *\/\n-  static void\n-  gray_set_cell( RAS_ARG_ TCoord  ex,\n-                          TCoord  ey )\n-  {\n-    \/* Move the cell pointer to a new position.  We set the `invalid'      *\/\n-    \/* flag to indicate that the cell isn't part of those we're interested *\/\n-    \/* in during the render phase.  This means that:                       *\/\n-    \/*                                                                     *\/\n-    \/* . the new vertical position must be within min_ey..max_ey-1.        *\/\n-    \/* . the new horizontal position must be strictly less than max_ex     *\/\n-    \/*                                                                     *\/\n-    \/* Note that if a cell is to the left of the clipping region, it is    *\/\n-    \/* actually set to the (min_ex-1) horizontal position.                 *\/\n+      \/* insert new cell *\/\n+      cell = ras.cell_free++;\n+      if ( cell >= ras.cell_null )\n+        ft_longjmp( ras.jump_buffer, 1 );\n@@ -583,3 +620,3 @@\n-    \/* record the current one if it is valid and substantial *\/\n-    if ( !ras.invalid && ( ras.area || ras.cover ) )\n-      gray_record_cell( RAS_VAR );\n+      cell->x     = ex;\n+      cell->area  = 0;\n+      cell->cover = 0;\n@@ -587,4 +624,2 @@\n-    ras.area  = 0;\n-    ras.cover = 0;\n-    ras.ex    = FT_MAX( ex, ras.min_ex - 1 );\n-    ras.ey    = ey;\n+      cell->next  = *pcell;\n+      *pcell      = cell;\n@@ -592,2 +627,3 @@\n-    ras.invalid = ( ey >= ras.max_ey || ey < ras.min_ey ||\n-                    ex >= ras.max_ex );\n+    Found:\n+      ras.cell = cell;\n+    }\n@@ -597,1 +633,1 @@\n-#ifndef FT_LONG64\n+#ifndef FT_INT64\n@@ -625,2 +661,2 @@\n-    fx1   = FRACT( x1 );\n-    fx2   = FRACT( x2 );\n+    fx1 = FRACT( x1 );\n+    fx2 = FRACT( x2 );\n@@ -658,4 +694,3 @@\n-    ras.area  += (TArea)( ( fx1 + first ) * delta );\n-    ras.cover += delta;\n-    y1        += delta;\n-    ex1       += incr;\n+    FT_INTEGRATE( ras, delta, fx1 + first );\n+    y1  += delta;\n+    ex1 += incr;\n@@ -682,4 +717,3 @@\n-        ras.area  += (TArea)( ONE_PIXEL * delta );\n-        ras.cover += delta;\n-        y1        += delta;\n-        ex1       += incr;\n+        FT_INTEGRATE( ras, delta, ONE_PIXEL );\n+        y1  += delta;\n+        ex1 += incr;\n@@ -693,4 +727,1 @@\n-    dy = y2 - y1;\n-\n-    ras.area  += (TArea)( ( fx1 + fx2 ) * dy );\n-    ras.cover += dy;\n+    FT_INTEGRATE( ras, y2 - y1, fx1 + fx2 );\n@@ -739,1 +770,0 @@\n-      TArea   area;\n@@ -753,4 +783,3 @@\n-      delta      = first - fy1;\n-      ras.area  += (TArea)two_fx * delta;\n-      ras.cover += delta;\n-      ey1       += incr;\n+      delta = first - fy1;\n+      FT_INTEGRATE( ras, delta, two_fx);\n+      ey1 += incr;\n@@ -761,1 +790,0 @@\n-      area  = (TArea)two_fx * delta;\n@@ -764,3 +792,2 @@\n-        ras.area  += area;\n-        ras.cover += delta;\n-        ey1       += incr;\n+        FT_INTEGRATE( ras, delta, two_fx);\n+        ey1 += incr;\n@@ -771,3 +798,2 @@\n-      delta      = fy2 - ONE_PIXEL + first;\n-      ras.area  += (TArea)two_fx * delta;\n-      ras.cover += delta;\n+      delta = fy2 - ONE_PIXEL + first;\n+      FT_INTEGRATE( ras, delta, two_fx);\n@@ -886,2 +912,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * fx1 * 2;\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 * 2 );\n@@ -896,2 +921,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * fx1 * 2;\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 * 2 );\n@@ -905,1 +929,1 @@\n-      TPos  prod = dx * (TPos)fy1 - dy * (TPos)fx1;\n+      FT_Int64  prod = dx * (FT_Int64)fy1 - dy * (FT_Int64)fx1;\n@@ -915,2 +939,2 @@\n-        if      ( prod                                   <= 0 &&\n-                  prod - dx * ONE_PIXEL                  >  0 ) \/* left *\/\n+        if      ( prod - dx * ONE_PIXEL                  >  0 &&\n+                  prod                                   <= 0 ) \/* left *\/\n@@ -921,2 +945,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -927,2 +950,2 @@\n-        else if ( prod - dx * ONE_PIXEL                  <= 0 &&\n-                  prod - dx * ONE_PIXEL + dy * ONE_PIXEL >  0 ) \/* up *\/\n+        else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL >  0 &&\n+                  prod - dx * ONE_PIXEL                  <= 0 ) \/* up *\/\n@@ -933,2 +956,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -939,2 +961,2 @@\n-        else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL <= 0 &&\n-                  prod                  + dy * ONE_PIXEL >= 0 ) \/* right *\/\n+        else if ( prod                  + dy * ONE_PIXEL >= 0 &&\n+                  prod - dx * ONE_PIXEL + dy * ONE_PIXEL <= 0 ) \/* right *\/\n@@ -945,2 +967,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -951,2 +972,2 @@\n-        else \/* ( prod                  + dy * ONE_PIXEL <  0 &&\n-                  prod                                   >  0 )    down *\/\n+        else \/* ( prod                                   >  0 &&\n+                  prod                  + dy * ONE_PIXEL <  0 )    down *\/\n@@ -957,2 +978,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -965,0 +985,1 @@\n+\n@@ -971,2 +992,1 @@\n-    ras.cover += ( fy2 - fy1 );\n-    ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+    FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -975,2 +995,2 @@\n-    ras.x       = to_x;\n-    ras.y       = to_y;\n+    ras.x = to_x;\n+    ras.y = to_y;\n@@ -981,0 +1001,149 @@\n+  \/*\n+   * For now, the code that uses DDA to render conic curves requires\n+   * `FT_Int64` to be defined.  See for example\n+   *    https:\/\/gitlab.freedesktop.org\/freetype\/freetype\/-\/issues\/1071.\n+   *\/\n+\n+#ifdef FT_INT64\n+\n+#define LEFT_SHIFT( a, b )  (FT_Int64)( (FT_UInt64)(a) << (b) )\n+\n+\n+  static void\n+  gray_render_conic( RAS_ARG_ const FT_Vector*  control,\n+                              const FT_Vector*  to )\n+  {\n+    FT_Vector  p0, p1, p2;\n+    TPos       ax, ay, bx, by, dx, dy;\n+    int        shift;\n+\n+    FT_Int64  rx, ry;\n+    FT_Int64  qx, qy;\n+    FT_Int64  px, py;\n+\n+    FT_UInt  count;\n+\n+\n+    p0.x = ras.x;\n+    p0.y = ras.y;\n+    p1.x = UPSCALE( control->x );\n+    p1.y = UPSCALE( control->y );\n+    p2.x = UPSCALE( to->x );\n+    p2.y = UPSCALE( to->y );\n+\n+    \/* short-cut the arc that crosses the current band *\/\n+    if ( ( TRUNC( p0.y ) >= ras.max_ey &&\n+           TRUNC( p1.y ) >= ras.max_ey &&\n+           TRUNC( p2.y ) >= ras.max_ey ) ||\n+         ( TRUNC( p0.y ) <  ras.min_ey &&\n+           TRUNC( p1.y ) <  ras.min_ey &&\n+           TRUNC( p2.y ) <  ras.min_ey ) )\n+    {\n+      ras.x = p2.x;\n+      ras.y = p2.y;\n+      return;\n+    }\n+\n+    bx = p1.x - p0.x;\n+    by = p1.y - p0.y;\n+    ax = p2.x - p1.x - bx;  \/* p0.x + p2.x - 2 * p1.x *\/\n+    ay = p2.y - p1.y - by;  \/* p0.y + p2.y - 2 * p1.y *\/\n+\n+    dx = FT_ABS( ax );\n+    dy = FT_ABS( ay );\n+    if ( dx < dy )\n+      dx = dy;\n+\n+    if ( dx <= ONE_PIXEL \/ 4 )\n+    {\n+      gray_render_line( RAS_VAR_ p2.x, p2.y );\n+      return;\n+    }\n+\n+    \/* We can calculate the number of necessary segments because    *\/\n+    \/* each bisection predictably reduces deviation exactly 4-fold. *\/\n+    \/* Even 32-bit deviation would vanish after 16 bisections.      *\/\n+    shift = 16;\n+    do\n+    {\n+      dx >>= 2;\n+      shift--;\n+\n+    } while ( dx > ONE_PIXEL \/ 4 );\n+    count = 0x10000U >> shift;\n+\n+    \/*\n+     * The (P0,P1,P2) arc equation, for t in [0,1] range:\n+     *\n+     * P(t) = P0*(1-t)^2 + P1*2*t*(1-t) + P2*t^2\n+     *\n+     * P(t) = P0 + 2*(P1-P0)*t + (P0+P2-2*P1)*t^2\n+     *      = P0 + 2*B*t + A*t^2\n+     *\n+     *    for A = P0 + P2 - 2*P1\n+     *    and B = P1 - P0\n+     *\n+     * Let's consider the difference when advancing by a small\n+     * parameter h:\n+     *\n+     *    Q(h,t) = P(t+h) - P(t) = 2*B*h + A*h^2 + 2*A*h*t\n+     *\n+     * And then its own difference:\n+     *\n+     *    R(h,t) = Q(h,t+h) - Q(h,t) = 2*A*h*h = R (constant)\n+     *\n+     * Since R is always a constant, it is possible to compute\n+     * successive positions with:\n+     *\n+     *     P = P0\n+     *     Q = Q(h,0) = 2*B*h + A*h*h\n+     *     R = 2*A*h*h\n+     *\n+     *   loop:\n+     *     P += Q\n+     *     Q += R\n+     *     EMIT(P)\n+     *\n+     * To ensure accurate results, perform computations on 64-bit\n+     * values, after scaling them by 2^32.\n+     *\n+     *           h = 1 \/ 2^N\n+     *\n+     *     R << 32 = 2 * A << (32 - N - N)\n+     *             = A << (33 - 2*N)\n+     *\n+     *     Q << 32 = (2 * B << (32 - N)) + (A << (32 - N - N))\n+     *             = (B << (33 - N)) + (A << (32 - 2*N))\n+     *\/\n+\n+    rx = LEFT_SHIFT( ax, shift + shift );\n+    ry = LEFT_SHIFT( ay, shift + shift );\n+\n+    qx = LEFT_SHIFT( bx, shift + 17 ) + rx;\n+    qy = LEFT_SHIFT( by, shift + 17 ) + ry;\n+\n+    rx *= 2;\n+    ry *= 2;\n+\n+    px = LEFT_SHIFT( p0.x, 32 );\n+    py = LEFT_SHIFT( p0.y, 32 );\n+\n+    do\n+    {\n+      px += qx;\n+      py += qy;\n+      qx += rx;\n+      qy += ry;\n+\n+      gray_render_line( RAS_VAR_ (FT_Pos)( px >> 32 ),\n+                                 (FT_Pos)( py >> 32 ) );\n+    } while ( --count );\n+  }\n+\n+#else  \/* !FT_INT64 *\/\n+\n+  \/*\n+   * Note that multiple attempts to speed up the function below\n+   * with SSE2 intrinsics, using various data layouts, have turned\n+   * out to be slower than the non-SIMD code below.\n+   *\/\n@@ -1010,1 +1179,1 @@\n-    int         draw, split;\n+    int         draw;\n@@ -1053,1 +1222,3 @@\n-      split = draw & ( -draw );  \/* isolate the rightmost 1-bit *\/\n+      int  split = draw & ( -draw );  \/* isolate the rightmost 1-bit *\/\n+\n+\n@@ -1066,0 +1237,2 @@\n+#endif  \/* !FT_INT64 *\/\n+\n@@ -1067,0 +1240,8 @@\n+  \/*\n+   * For cubic Bézier, binary splits are still faster than DDA\n+   * because the splits are adaptive to how quickly each sub-arc\n+   * approaches their chord trisection points.\n+   *\n+   * It might be useful to experiment with SSE2 to speed up\n+   * `gray_split_cubic`, though.\n+   *\/\n@@ -1160,1 +1341,1 @@\n-                gray_PWorker      worker )\n+                void*             worker_ )  \/* gray_PWorker *\/\n@@ -1162,0 +1343,2 @@\n+    gray_PWorker  worker = (gray_PWorker)worker_;\n+\n@@ -1179,1 +1362,1 @@\n-                gray_PWorker      worker )\n+                void*             worker_ )   \/* gray_PWorker *\/\n@@ -1181,0 +1364,3 @@\n+    gray_PWorker  worker = (gray_PWorker)worker_;\n+\n+\n@@ -1189,1 +1375,1 @@\n-                 gray_PWorker      worker )\n+                 void*             worker_ )   \/* gray_PWorker *\/\n@@ -1191,0 +1377,3 @@\n+    gray_PWorker  worker = (gray_PWorker)worker_;\n+\n+\n@@ -1200,12 +1389,1 @@\n-                 gray_PWorker      worker )\n-  {\n-    gray_render_cubic( RAS_VAR_ control1, control2, to );\n-    return 0;\n-  }\n-\n-\n-  static void\n-  gray_hline( RAS_ARG_ TCoord  x,\n-                       TCoord  y,\n-                       TArea   coverage,\n-                       TCoord  acount )\n+                 void*             worker_ )   \/* gray_PWorker *\/\n@@ -1213,23 +1391,1 @@\n-    \/* scale the coverage from 0..(ONE_PIXEL*ONE_PIXEL*2) to 0..256  *\/\n-    coverage >>= PIXEL_BITS * 2 + 1 - 8;\n-\n-    \/* compute the line's coverage depending on the outline fill rule *\/\n-    if ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL )\n-    {\n-      coverage &= 511;\n-\n-      if ( coverage >= 256 )\n-        coverage = 511 - coverage;\n-    }\n-    else  \/* default non-zero winding rule *\/\n-    {\n-      if ( coverage < 0 )\n-        coverage = ~coverage;  \/* the same as -coverage - 1 *\/\n-\n-      if ( coverage >= 256 )\n-        coverage = 255;\n-    }\n-\n-    if ( ras.num_spans >= 0 )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n-    {\n-      FT_Span*  span = ras.spans + ras.num_spans++;\n+    gray_PWorker  worker = (gray_PWorker)worker_;\n@@ -1238,91 +1394,2 @@\n-      span->x        = (short)x;\n-      span->len      = (unsigned short)acount;\n-      span->coverage = (unsigned char)coverage;\n-\n-      if ( ras.num_spans == FT_MAX_GRAY_SPANS )\n-      {\n-        \/* flush the span buffer and reset the count *\/\n-        ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );\n-        ras.num_spans = 0;\n-      }\n-    }\n-    else\n-    {\n-      unsigned char*  q = ras.target.origin - ras.target.pitch * y + x;\n-      unsigned char   c = (unsigned char)coverage;\n-\n-\n-      \/* For small-spans it is faster to do it by ourselves than\n-       * calling `memset'.  This is mainly due to the cost of the\n-       * function call.\n-       *\/\n-      switch ( acount )\n-      {\n-      case 7:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 6:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 5:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 4:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 3:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 2:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 1:\n-        *q = c;\n-        \/* fall through *\/\n-      case 0:\n-        break;\n-      default:\n-        FT_MEM_SET( q, c, acount );\n-      }\n-    }\n-  }\n-\n-\n-  static void\n-  gray_sweep( RAS_ARG )\n-  {\n-    int  y;\n-\n-\n-    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n-    {\n-      PCell   cell  = ras.ycells[y - ras.min_ey];\n-      TCoord  x     = ras.min_ex;\n-      TArea   cover = 0;\n-      TArea   area;\n-\n-\n-      for ( ; cell != NULL; cell = cell->next )\n-      {\n-        if ( cover != 0 && cell->x > x )\n-          gray_hline( RAS_VAR_ x, y, cover, cell->x - x );\n-\n-        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n-        area   = cover - cell->area;\n-\n-        if ( area != 0 && cell->x >= ras.min_ex )\n-          gray_hline( RAS_VAR_ cell->x, y, area, 1 );\n-\n-        x = cell->x + 1;\n-      }\n-\n-      if ( cover != 0 )\n-        gray_hline( RAS_VAR_ x, y, cover, ras.max_ex - x );\n-\n-      if ( ras.num_spans > 0 )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n-      {\n-        \/* flush the span buffer and reset the count *\/\n-        ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );\n-        ras.num_spans = 0;\n-      }\n-    }\n+    gray_render_cubic( RAS_VAR_ control1, control2, to );\n+    return 0;\n@@ -1391,0 +1458,2 @@\n+    int   last;      \/* index of last point in contour  *\/\n+\n@@ -1405,1 +1474,0 @@\n-    first = 0;\n@@ -1407,0 +1475,1 @@\n+    last = -1;\n@@ -1409,4 +1478,1 @@\n-      int  last;  \/* index of last point in contour *\/\n-\n-\n-      FT_TRACE5(( \"FT_Outline_Decompose: Outline %d\\n\", n ));\n+      FT_TRACE5(( \"FT_Outline_Decompose: Contour %d\\n\", n ));\n@@ -1414,0 +1480,1 @@\n+      first = last + 1;\n@@ -1415,1 +1482,1 @@\n-      if ( last < 0 )\n+      if ( last < first )\n@@ -1417,0 +1484,1 @@\n+\n@@ -1599,1 +1667,1 @@\n-   Close:\n+    Close:\n@@ -1602,2 +1670,0 @@\n-\n-      first = last + 1;\n@@ -1607,1 +1673,1 @@\n-    return 0;\n+    return Smooth_Err_Ok;\n@@ -1634,1 +1700,1 @@\n-  gray_convert_glyph_inner( RAS_ARG,\n+  gray_convert_glyph_inner( RAS_ARG_\n@@ -1637,1 +1703,1 @@\n-    int  error;\n+    volatile int  error;\n@@ -1648,4 +1714,1 @@\n-      if ( !ras.invalid )\n-        gray_record_cell( RAS_VAR );\n-\n-      FT_TRACE7(( \"band [%d..%d]: %ld cell%s\\n\",\n+      FT_TRACE7(( \"band [%d..%d]: %td cell%s remaining\\n\",\n@@ -1654,2 +1717,2 @@\n-                  ras.num_cells,\n-                  ras.num_cells == 1 ? \"\" : \"s\" ));\n+                  ras.cell_null - ras.cell_free,\n+                  ras.cell_null - ras.cell_free == 1 ? \"\" : \"s\" ));\n@@ -1659,1 +1722,1 @@\n-      error = FT_THROW( Memory_Overflow );\n+      error = FT_THROW( Raster_Overflow );\n@@ -1669,0 +1732,133 @@\n+  static void\n+  gray_sweep( RAS_ARG )\n+  {\n+    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n+                                                                 : INT_MIN;\n+    int  coverage;\n+    int  y;\n+\n+\n+    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n+    {\n+      PCell   cell  = ras.ycells[y - ras.min_ey];\n+      TCoord  x     = ras.min_ex;\n+      TArea   cover = 0;\n+\n+      unsigned char*  line = ras.target.origin - ras.target.pitch * y;\n+\n+\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n+      {\n+        TArea  area;\n+\n+\n+        if ( cover != 0 && cell->x > x )\n+        {\n+          FT_FILL_RULE( coverage, cover, fill );\n+          FT_GRAY_SET( line + x, coverage, cell->x - x );\n+        }\n+\n+        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n+        area   = cover - cell->area;\n+\n+        if ( area != 0 && cell->x >= ras.min_ex )\n+        {\n+          FT_FILL_RULE( coverage, area, fill );\n+          line[cell->x] = (unsigned char)coverage;\n+        }\n+\n+        x = cell->x + 1;\n+      }\n+\n+      if ( cover != 0 )  \/* only if cropped *\/\n+      {\n+        FT_FILL_RULE( coverage, cover, fill );\n+        FT_GRAY_SET( line + x, coverage, ras.max_ex - x );\n+      }\n+    }\n+  }\n+\n+\n+  static void\n+  gray_sweep_direct( RAS_ARG )\n+  {\n+    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n+                                                                 : INT_MIN;\n+    int  coverage;\n+    int  y;\n+\n+    FT_Span  span[FT_MAX_GRAY_SPANS];\n+    int      n = 0;\n+\n+\n+    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n+    {\n+      PCell   cell  = ras.ycells[y - ras.min_ey];\n+      TCoord  x     = ras.min_ex;\n+      TArea   cover = 0;\n+\n+\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n+      {\n+        TArea  area;\n+\n+\n+        if ( cover != 0 && cell->x > x )\n+        {\n+          FT_FILL_RULE( coverage, cover, fill );\n+\n+          span[n].coverage = (unsigned char)coverage;\n+          span[n].x        = (short)x;\n+          span[n].len      = (unsigned short)( cell->x - x );\n+\n+          if ( ++n == FT_MAX_GRAY_SPANS )\n+          {\n+            \/* flush the span buffer and reset the count *\/\n+            ras.render_span( y, n, span, ras.render_span_data );\n+            n = 0;\n+          }\n+        }\n+\n+        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n+        area   = cover - cell->area;\n+\n+        if ( area != 0 && cell->x >= ras.min_ex )\n+        {\n+          FT_FILL_RULE( coverage, area, fill );\n+\n+          span[n].coverage = (unsigned char)coverage;\n+          span[n].x        = (short)cell->x;\n+          span[n].len      = 1;\n+\n+          if ( ++n == FT_MAX_GRAY_SPANS )\n+          {\n+            \/* flush the span buffer and reset the count *\/\n+            ras.render_span( y, n, span, ras.render_span_data );\n+            n = 0;\n+          }\n+        }\n+\n+        x = cell->x + 1;\n+      }\n+\n+      if ( cover != 0 )  \/* only if cropped *\/\n+      {\n+        FT_FILL_RULE( coverage, cover, fill );\n+\n+        span[n].coverage = (unsigned char)coverage;\n+        span[n].x        = (short)x;\n+        span[n].len      = (unsigned short)( ras.max_ex - x );\n+\n+        ++n;\n+      }\n+\n+      if ( n )\n+      {\n+        \/* flush the span buffer and reset the count *\/\n+        ras.render_span( y, n, span, ras.render_span_data );\n+        n = 0;\n+      }\n+    }\n+  }\n+\n+\n@@ -1672,3 +1868,0 @@\n-    const TCoord  yMin = ras.min_ey;\n-    const TCoord  yMax = ras.max_ey;\n-\n@@ -1676,1 +1869,1 @@\n-    size_t   height = (size_t)( yMax - yMin );\n+    size_t   height = (size_t)( ras.cbox.yMax - ras.cbox.yMin );\n@@ -1685,0 +1878,7 @@\n+    \/* Initialize the null cell at the end of the poll. *\/\n+    ras.cell_null        = buffer + FT_MAX_GRAY_POOL - 1;\n+    ras.cell_null->x     = CELL_MAX_X_VALUE;\n+    ras.cell_null->area  = 0;\n+    ras.cell_null->cover = 0;\n+    ras.cell_null->next  = NULL;\n+\n@@ -1686,0 +1886,2 @@\n+    ras.ycells     = (PCell*)buffer;\n+\n@@ -1693,8 +1895,1 @@\n-    \/* memory management *\/\n-    n = ( height * sizeof ( PCell ) + sizeof ( TCell ) - 1 ) \/ sizeof ( TCell );\n-\n-    ras.cells     = buffer + n;\n-    ras.max_cells = (FT_PtrDist)( FT_MAX_GRAY_POOL - n );\n-    ras.ycells    = (PCell*)buffer;\n-\n-    for ( y = yMin; y < yMax; )\n+    for ( y = ras.cbox.yMin; y < ras.cbox.yMax; )\n@@ -1704,1 +1899,3 @@\n-      ras.max_ey = FT_MIN( y, yMax );\n+      ras.max_ey = FT_MIN( y, ras.cbox.yMax );\n+\n+      ras.count_ey = ras.max_ey - ras.min_ey;\n@@ -1707,2 +1904,2 @@\n-      band[1] = ras.min_ey;\n-      band[0] = ras.max_ey;\n+      band[1] = ras.cbox.xMin;\n+      band[0] = ras.cbox.xMax;\n@@ -1712,1 +1909,1 @@\n-        TCoord  width = band[0] - band[1];\n+        TCoord  i;\n@@ -1716,1 +1913,2 @@\n-        FT_MEM_ZERO( ras.ycells, height * sizeof ( PCell ) );\n+        ras.min_ex = band[1];\n+        ras.max_ex = band[0];\n@@ -1718,4 +1916,3 @@\n-        ras.num_cells = 0;\n-        ras.invalid   = 1;\n-        ras.min_ey    = band[1];\n-        ras.max_ey    = band[0];\n+        \/* memory management: zero out and skip ycells *\/\n+        for ( i = 0; i < ras.count_ey; ++i )\n+          ras.ycells[i] = ras.cell_null;\n@@ -1723,1 +1920,7 @@\n-        error     = gray_convert_glyph_inner( RAS_VAR, continued );\n+        n = ( (size_t)ras.count_ey * sizeof ( PCell ) + sizeof ( TCell ) - 1 )\n+              \/ sizeof ( TCell );\n+\n+        ras.cell_free = buffer + n;\n+        ras.cell      = ras.cell_null;\n+\n+        error     = gray_convert_glyph_inner( RAS_VAR_ continued );\n@@ -1728,1 +1931,4 @@\n-          gray_sweep( RAS_VAR );\n+          if ( ras.render_span )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n+            gray_sweep_direct( RAS_VAR );\n+          else\n+            gray_sweep( RAS_VAR );\n@@ -1732,2 +1938,2 @@\n-        else if ( error != ErrRaster_Memory_Overflow )\n-          return 1;\n+        else if ( error != Smooth_Err_Raster_Overflow )\n+          return error;\n@@ -1736,1 +1942,1 @@\n-        width >>= 1;\n+        i = ( band[0] - band[1] ) >> 1;\n@@ -1739,1 +1945,1 @@\n-        if ( width == 0 )\n+        if ( i == 0 )\n@@ -1742,1 +1948,1 @@\n-          return 1;\n+          return FT_THROW( Raster_Overflow );\n@@ -1747,1 +1953,1 @@\n-        band[0] += width;\n+        band[0] += i;\n@@ -1751,1 +1957,1 @@\n-    return 0;\n+    return Smooth_Err_Ok;\n@@ -1772,1 +1978,1 @@\n-      return FT_THROW( Invalid_Mode );\n+      return FT_THROW( Cannot_Render_Glyph );\n@@ -1778,2 +1984,2 @@\n-    if ( outline->n_points == 0 || outline->n_contours <= 0 )\n-      return 0;\n+    if ( outline->n_points == 0 || outline->n_contours == 0 )\n+      return Smooth_Err_Ok;\n@@ -1793,1 +1999,1 @@\n-        return 0;\n+        return Smooth_Err_Ok;\n@@ -1797,1 +2003,0 @@\n-      ras.num_spans        = 0;\n@@ -1799,4 +2004,1 @@\n-      ras.min_ex = params->clip_box.xMin;\n-      ras.min_ey = params->clip_box.yMin;\n-      ras.max_ex = params->clip_box.xMax;\n-      ras.max_ey = params->clip_box.yMax;\n+      ras.cbox = params->clip_box;\n@@ -1812,1 +2014,1 @@\n-        return 0;\n+        return Smooth_Err_Ok;\n@@ -1827,1 +2029,0 @@\n-      ras.num_spans        = -1;  \/* invalid *\/\n@@ -1829,4 +2030,4 @@\n-      ras.min_ex = 0;\n-      ras.min_ey = 0;\n-      ras.max_ex = (FT_Pos)target_map->width;\n-      ras.max_ey = (FT_Pos)target_map->rows;\n+      ras.cbox.xMin = 0;\n+      ras.cbox.yMin = 0;\n+      ras.cbox.xMax = (FT_Pos)target_map->width;\n+      ras.cbox.yMax = (FT_Pos)target_map->rows;\n@@ -1836,2 +2037,2 @@\n-    if ( ras.max_ex <= ras.min_ex || ras.max_ey <= ras.min_ey )\n-      return 0;\n+    if ( ras.cbox.xMin >= ras.cbox.xMax || ras.cbox.yMin >= ras.cbox.yMax )\n+      return Smooth_Err_Ok;\n@@ -1874,2 +2075,2 @@\n-  gray_raster_new( FT_Memory   memory,\n-                   FT_Raster*  araster )\n+  gray_raster_new( void*       memory_,\n+                   FT_Raster*  araster_ )\n@@ -1877,0 +2078,3 @@\n+    FT_Memory      memory  = (FT_Memory)memory_;\n+    gray_PRaster*  araster = (gray_PRaster*)araster_;\n+\n@@ -1881,3 +2085,1 @@\n-    *araster = 0;\n-    if ( !FT_ALLOC( raster, sizeof ( gray_TRaster ) ) )\n-    {\n+    if ( !FT_NEW( raster ) )\n@@ -1885,2 +2087,2 @@\n-      *araster       = (FT_Raster)raster;\n-    }\n+\n+    *araster = raster;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/smooth\/ftgrays.c","additions":565,"deletions":363,"binary":false,"changes":928,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/smooth\/ftgrays.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/smooth\/ftsmerrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2024 by\n@@ -90,1 +90,1 @@\n-  ft_smooth_init( FT_Renderer  render )\n+  ft_smooth_init( FT_Module  module )   \/* FT_Renderer *\/\n@@ -92,0 +92,2 @@\n+    FT_Renderer  render = (FT_Renderer)module;\n+\n@@ -114,1 +116,1 @@\n-                       TOrigin*        target )\n+                       void*           target_ )   \/* TOrigin* *\/\n@@ -116,0 +118,2 @@\n+    TOrigin*  target = (TOrigin*)target_;\n+\n@@ -144,1 +148,1 @@\n-    params.gray_spans = (FT_SpanFunc)ft_smooth_lcd_spans;\n+    params.gray_spans = ft_smooth_lcd_spans;\n@@ -259,1 +263,1 @@\n-  ft_smooth_init( FT_Renderer  render )\n+  ft_smooth_init( FT_Module  module )   \/* FT_Renderer *\/\n@@ -261,0 +265,3 @@\n+    FT_Renderer  render = (FT_Renderer)module;\n+\n+\n@@ -343,1 +350,1 @@\n-                           TOrigin*        target )\n+                           void*           target_ )\n@@ -345,0 +352,3 @@\n+    TOrigin*  target = (TOrigin*)target_;\n+\n+\n@@ -389,1 +399,1 @@\n-    params.gray_spans = (FT_SpanFunc)ft_smooth_overlap_spans;\n+    params.gray_spans = ft_smooth_overlap_spans;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/smooth\/ftsmooth.c","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/smooth\/ftsmooth.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -60,1 +60,1 @@\n-  static FT_Error\n+  FT_CALLBACK_DEF( FT_Error )\n@@ -96,4 +96,8 @@\n-      if ( interpreter_version == TT_INTERPRETER_VERSION_35\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-           || interpreter_version == TT_INTERPRETER_VERSION_38\n-#endif\n+      switch ( interpreter_version )\n+      {\n+      case TT_INTERPRETER_VERSION_35:\n+        driver->interpreter_version = TT_INTERPRETER_VERSION_35;\n+        break;\n+\n+      case TT_INTERPRETER_VERSION_38:\n+      case TT_INTERPRETER_VERSION_40:\n@@ -101,1 +105,2 @@\n-           || interpreter_version == TT_INTERPRETER_VERSION_40\n+        driver->interpreter_version = TT_INTERPRETER_VERSION_40;\n+      break;\n@@ -103,3 +108,2 @@\n-         )\n-        driver->interpreter_version = interpreter_version;\n-      else\n+\n+      default:\n@@ -107,0 +111,1 @@\n+      }\n@@ -111,1 +116,1 @@\n-    FT_TRACE0(( \"tt_property_set: missing property `%s'\\n\",\n+    FT_TRACE2(( \"tt_property_set: missing property `%s'\\n\",\n@@ -117,1 +122,1 @@\n-  static FT_Error\n+  FT_CALLBACK_DEF( FT_Error )\n@@ -120,1 +125,1 @@\n-                   const void*  value )\n+                   void*        value )\n@@ -138,1 +143,1 @@\n-    FT_TRACE0(( \"tt_property_get: missing property `%s'\\n\",\n+    FT_TRACE2(( \"tt_property_get: missing property `%s'\\n\",\n@@ -147,2 +152,2 @@\n-    (FT_Properties_SetFunc)tt_property_set,     \/* set_property *\/\n-    (FT_Properties_GetFunc)tt_property_get      \/* get_property *\/\n+    tt_property_set,  \/* FT_Properties_SetFunc set_property *\/\n+    tt_property_get   \/* FT_Properties_GetFunc get_property *\/\n@@ -201,2 +206,2 @@\n-  static FT_Error\n-  tt_get_kerning( FT_Face     ttface,          \/* TT_Face *\/\n+  FT_CALLBACK_DEF( FT_Error )\n+  tt_get_kerning( FT_Face     face,        \/* TT_Face *\/\n@@ -207,2 +212,2 @@\n-    TT_Face       face = (TT_Face)ttface;\n-    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+    TT_Face       ttface = (TT_Face)face;\n+    SFNT_Service  sfnt   = (SFNT_Service)ttface->sfnt;\n@@ -215,1 +220,14 @@\n-      kerning->x = sfnt->get_kerning( face, left_glyph, right_glyph );\n+    {\n+      \/* Use 'kern' table if available since that can be faster; otherwise *\/\n+      \/* use GPOS kerning pairs if available.                              *\/\n+      if ( ttface->kern_avail_bits != 0 )\n+        kerning->x = sfnt->get_kerning( ttface,\n+                                        left_glyph,\n+                                        right_glyph );\n+#ifdef TT_CONFIG_OPTION_GPOS_KERNING\n+      else if ( ttface->gpos_kerning_available )\n+        kerning->x = sfnt->get_gpos_kerning( ttface,\n+                                             left_glyph,\n+                                             right_glyph );\n+#endif\n+    }\n@@ -221,2 +239,2 @@\n-  static FT_Error\n-  tt_get_advances( FT_Face    ttface,\n+  FT_CALLBACK_DEF( FT_Error )\n+  tt_get_advances( FT_Face    face,      \/* TT_Face *\/\n@@ -229,1 +247,1 @@\n-    TT_Face  face = (TT_Face)ttface;\n+    TT_Face  ttface = (TT_Face)face;\n@@ -238,2 +256,2 @@\n-      if ( ( FT_IS_NAMED_INSTANCE( ttface ) || FT_IS_VARIATION( ttface ) ) &&\n-           !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE )        )\n+      if ( ( FT_IS_NAMED_INSTANCE( face ) || FT_IS_VARIATION( face ) ) &&\n+           !( ttface->variation_support & TT_FACE_FLAG_VAR_VADVANCE )  )\n@@ -250,1 +268,1 @@\n-        TT_Get_VMetrics( face, start + nn, 0, &tsb, &ah );\n+        TT_Get_VMetrics( ttface, start + nn, 0, &tsb, &ah );\n@@ -258,2 +276,2 @@\n-      if ( ( FT_IS_NAMED_INSTANCE( ttface ) || FT_IS_VARIATION( ttface ) ) &&\n-           !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE )        )\n+      if ( ( FT_IS_NAMED_INSTANCE( face ) || FT_IS_VARIATION( face ) ) &&\n+           !( ttface->variation_support & TT_FACE_FLAG_VAR_HADVANCE )  )\n@@ -269,1 +287,1 @@\n-        TT_Get_HMetrics( face, start + nn, &lsb, &aw );\n+        TT_Get_HMetrics( ttface, start + nn, &lsb, &aw );\n@@ -293,1 +311,1 @@\n-  static FT_Error\n+  FT_CALLBACK_DEF( FT_Error )\n@@ -309,1 +327,1 @@\n-      tt_size_reset( ttsize, 0 ); \/* ignore return value *\/\n+      tt_size_reset( ttsize ); \/* ignore return value *\/\n@@ -330,1 +348,1 @@\n-  static FT_Error\n+  FT_CALLBACK_DEF( FT_Error )\n@@ -357,1 +375,10 @@\n-    FT_Request_Metrics( size->face, req );\n+    {\n+      FT_Error  err = FT_Request_Metrics( size->face, req );\n+\n+\n+      if ( err )\n+      {\n+        error = err;\n+        goto Exit;\n+      }\n+    }\n@@ -361,1 +388,1 @@\n-      error = tt_size_reset( ttsize, 0 );\n+      error = tt_size_reset( ttsize );\n@@ -385,0 +412,1 @@\n+  Exit:\n@@ -419,3 +447,3 @@\n-  static FT_Error\n-  tt_glyph_load( FT_GlyphSlot  ttslot,      \/* TT_GlyphSlot *\/\n-                 FT_Size       ttsize,      \/* TT_Size      *\/\n+  FT_CALLBACK_DEF( FT_Error )\n+  tt_glyph_load( FT_GlyphSlot  slot,        \/* TT_GlyphSlot *\/\n+                 FT_Size       size,        \/* TT_Size      *\/\n@@ -425,3 +453,3 @@\n-    TT_GlyphSlot  slot = (TT_GlyphSlot)ttslot;\n-    TT_Size       size = (TT_Size)ttsize;\n-    FT_Face       face = ttslot->face;\n+    TT_GlyphSlot  ttslot = (TT_GlyphSlot)slot;\n+    TT_Size       ttsize = (TT_Size)size;\n+    FT_Face       face   = ttslot->face;\n@@ -469,3 +497,3 @@\n-    size->metrics = ( load_flags & FT_LOAD_NO_HINTING )\n-                      ? &ttsize->metrics\n-                      : &size->hinted_metrics;\n+    ttsize->metrics = ( load_flags & FT_LOAD_NO_HINTING )\n+                        ? &size->metrics\n+                        : &ttsize->hinted_metrics;\n@@ -474,1 +502,1 @@\n-    error = TT_Load_Glyph( size, slot, glyph_index, load_flags );\n+    error = TT_Load_Glyph( ttsize, ttslot, glyph_index, load_flags );\n@@ -500,13 +528,25 @@\n-    (FT_Get_MM_Func)             NULL,                  \/* get_mm              *\/\n-    (FT_Set_MM_Design_Func)      NULL,                  \/* set_mm_design       *\/\n-    (FT_Set_MM_Blend_Func)       TT_Set_MM_Blend,       \/* set_mm_blend        *\/\n-    (FT_Get_MM_Blend_Func)       TT_Get_MM_Blend,       \/* get_mm_blend        *\/\n-    (FT_Get_MM_Var_Func)         TT_Get_MM_Var,         \/* get_mm_var          *\/\n-    (FT_Set_Var_Design_Func)     TT_Set_Var_Design,     \/* set_var_design      *\/\n-    (FT_Get_Var_Design_Func)     TT_Get_Var_Design,     \/* get_var_design      *\/\n-    (FT_Set_Instance_Func)       TT_Set_Named_Instance, \/* set_instance        *\/\n-    (FT_Set_MM_WeightVector_Func)NULL,                  \/* set_mm_weightvector *\/\n-    (FT_Get_MM_WeightVector_Func)NULL,                  \/* get_mm_weightvector *\/\n-\n-    (FT_Get_Var_Blend_Func)      tt_get_var_blend,      \/* get_var_blend       *\/\n-    (FT_Done_Blend_Func)         tt_done_blend          \/* done_blend          *\/\n+    NULL,                  \/* FT_Get_MM_Func              get_mm                     *\/\n+    NULL,                  \/* FT_Set_MM_Design_Func       set_mm_design              *\/\n+    TT_Set_MM_Blend,       \/* FT_Set_MM_Blend_Func        set_mm_blend               *\/\n+    TT_Get_MM_Blend,       \/* FT_Get_MM_Blend_Func        get_mm_blend               *\/\n+    TT_Get_MM_Var,         \/* FT_Get_MM_Var_Func          get_mm_var                 *\/\n+    TT_Set_Var_Design,     \/* FT_Set_Var_Design_Func      set_var_design             *\/\n+    TT_Get_Var_Design,     \/* FT_Get_Var_Design_Func      get_var_design             *\/\n+    TT_Set_Named_Instance, \/* FT_Set_Named_Instance_Func  set_named_instance         *\/\n+    TT_Get_Default_Named_Instance,\n+                    \/* FT_Get_Default_Named_Instance_Func get_default_named_instance *\/\n+    NULL,                  \/* FT_Set_MM_WeightVector_Func set_mm_weightvector        *\/\n+    NULL,                  \/* FT_Get_MM_WeightVector_Func get_mm_weightvector        *\/\n+\n+    tt_construct_ps_name,  \/* FT_Construct_PS_Name_Func   construct_ps_name          *\/\n+    tt_var_load_delta_set_index_mapping,\n+                    \/* FT_Var_Load_Delta_Set_Idx_Map_Func load_delta_set_idx_map     *\/\n+    tt_var_load_item_variation_store,\n+                    \/* FT_Var_Load_Item_Var_Store_Func    load_item_variation_store  *\/\n+    tt_var_get_item_delta, \/* FT_Var_Get_Item_Delta_Func  get_item_delta             *\/\n+    tt_var_done_item_variation_store,\n+                    \/* FT_Var_Done_Item_Var_Store_Func    done_item_variation_store  *\/\n+    tt_var_done_delta_set_index_map,\n+                    \/* FT_Var_Done_Delta_Set_Idx_Map_Func done_delta_set_index_map   *\/\n+    tt_get_var_blend,      \/* FT_Get_Var_Blend_Func       get_var_blend              *\/\n+    tt_done_blend          \/* FT_Done_Blend_Func          done_blend                 *\/\n@@ -518,3 +558,3 @@\n-    (FT_HAdvance_Adjust_Func)tt_hadvance_adjust,     \/* hadvance_adjust *\/\n-    (FT_LSB_Adjust_Func)     NULL,                   \/* lsb_adjust      *\/\n-    (FT_RSB_Adjust_Func)     NULL,                   \/* rsb_adjust      *\/\n+    tt_hadvance_adjust,   \/* FT_HAdvance_Adjust_Func hadvance_adjust *\/\n+    NULL,                 \/* FT_LSB_Adjust_Func      lsb_adjust      *\/\n+    NULL,                 \/* FT_RSB_Adjust_Func      rsb_adjust      *\/\n@@ -522,4 +562,4 @@\n-    (FT_VAdvance_Adjust_Func)tt_vadvance_adjust,     \/* vadvance_adjust *\/\n-    (FT_TSB_Adjust_Func)     NULL,                   \/* tsb_adjust      *\/\n-    (FT_BSB_Adjust_Func)     NULL,                   \/* bsb_adjust      *\/\n-    (FT_VOrg_Adjust_Func)    NULL,                   \/* vorg_adjust     *\/\n+    tt_vadvance_adjust,   \/* FT_VAdvance_Adjust_Func vadvance_adjust *\/\n+    NULL,                 \/* FT_TSB_Adjust_Func      tsb_adjust      *\/\n+    NULL,                 \/* FT_BSB_Adjust_Func      bsb_adjust      *\/\n+    NULL,                 \/* FT_VOrg_Adjust_Func     vorg_adjust     *\/\n@@ -527,1 +567,2 @@\n-    (FT_Metrics_Adjust_Func) tt_apply_mvar           \/* metrics_adjust  *\/\n+    tt_apply_mvar,        \/* FT_Metrics_Adjust_Func  metrics_adjust  *\/\n+    tt_size_reset_height  \/* FT_Size_Reset_Func      size_reset      *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttdriver.c","additions":107,"deletions":66,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/tterrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -38,1 +38,0 @@\n-#include \"ttsubpix.h\"\n@@ -155,3 +154,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );\n-#endif\n@@ -186,15 +182,5 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&\n-         loader->exec                                             )\n-    {\n-      loader->exec->sph_tweak_flags = 0;\n-\n-      \/* This may not be the right place for this, but it works...  *\/\n-      \/* Note that we have to unconditionally load the tweaks since *\/\n-      \/* it is possible that glyphs individually switch ClearType's *\/\n-      \/* backward compatibility mode on and off.                    *\/\n-      sph_set_tweaks( loader, glyph_index );\n-    }\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-    if ( !loader->linear_def )\n+#ifdef FT_CONFIG_OPTION_INCREMENTAL\n+    \/* With the incremental interface, these values are set by  *\/\n+    \/* a call to `tt_get_metrics_incremental'.                  *\/\n+    if ( face->root.internal->incremental_interface == NULL )\n+#endif\n@@ -202,2 +188,5 @@\n-      loader->linear_def = 1;\n-      loader->linear     = advance_width;\n+      if ( !loader->linear_def )\n+      {\n+        loader->linear_def = 1;\n+        loader->linear     = advance_width;\n+      }\n@@ -213,2 +202,2 @@\n-  tt_get_metrics_incr_overrides( TT_Loader  loader,\n-                                 FT_UInt    glyph_index )\n+  tt_get_metrics_incremental( TT_Loader  loader,\n+                              FT_UInt    glyph_index )\n@@ -358,0 +347,1 @@\n+    FT_Outline*     outline    = &gloader->current.outline;\n@@ -359,2 +349,0 @@\n-    FT_Outline*     outline;\n-    FT_UShort       n_ins;\n@@ -362,0 +350,1 @@\n+    FT_UShort       n_ins;\n@@ -367,2 +356,2 @@\n-    FT_Short        *cont, *cont_limit, prev_cont;\n-    FT_Int          xy_size = 0;\n+    FT_UShort       *cont, *cont_limit;\n+    FT_Int          last;\n@@ -376,4 +365,0 @@\n-    \/* reading the contours' endpoints & number of points *\/\n-    cont       = gloader->current.outline.contours;\n-    cont_limit = cont + n_contours;\n-\n@@ -381,1 +366,1 @@\n-    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )\n+    if ( n_contours >= 0xFFF || p + 2 * n_contours + 2 > limit )\n@@ -384,7 +369,3 @@\n-    prev_cont = FT_NEXT_SHORT( p );\n-\n-    if ( n_contours > 0 )\n-      cont[0] = prev_cont;\n-\n-    if ( prev_cont < 0 )\n-      goto Invalid_Outline;\n+    \/* reading the contours' endpoints & number of points *\/\n+    cont       = outline->contours;\n+    cont_limit = cont + n_contours;\n@@ -392,1 +373,2 @@\n-    for ( cont++; cont < cont_limit; cont++ )\n+    last = -1;\n+    for ( ; cont < cont_limit; cont++ )\n@@ -394,8 +376,1 @@\n-      cont[0] = FT_NEXT_SHORT( p );\n-      if ( cont[0] <= prev_cont )\n-      {\n-        \/* unordered contours: this is invalid *\/\n-        goto Invalid_Outline;\n-      }\n-      prev_cont = cont[0];\n-    }\n+      *cont = FT_NEXT_USHORT( p );\n@@ -403,5 +378,1 @@\n-    n_points = 0;\n-    if ( n_contours > 0 )\n-    {\n-      n_points = cont[-1] + 1;\n-      if ( n_points < 0 )\n+      if ( *cont <= last )\n@@ -409,0 +380,2 @@\n+\n+      last = *cont;\n@@ -411,0 +384,2 @@\n+    n_points = last + 1;\n+\n@@ -418,7 +393,1 @@\n-    \/* reading the bytecode instructions *\/\n-    load->glyph->control_len  = 0;\n-    load->glyph->control_data = NULL;\n-\n-    if ( p + 2 > limit )\n-      goto Invalid_Outline;\n-\n+    \/* space checked above *\/\n@@ -429,0 +398,8 @@\n+    \/* check instructions size *\/\n+    if ( p + n_ins > limit )\n+    {\n+      FT_TRACE1(( \"TT_Load_Simple_Glyph: excessive instruction count\\n\" ));\n+      error = FT_THROW( Too_Many_Hints );\n+      goto Fail;\n+    }\n+\n@@ -433,1 +410,2 @@\n-      FT_ULong  tmp;\n+      TT_ExecContext  exec = load->exec;\n+      FT_Memory       memory = exec->memory;\n@@ -436,7 +414,3 @@\n-      \/* check instructions size *\/\n-      if ( ( limit - p ) < n_ins )\n-      {\n-        FT_TRACE1(( \"TT_Load_Simple_Glyph: instruction count mismatch\\n\" ));\n-        error = FT_THROW( Too_Many_Hints );\n-        goto Fail;\n-      }\n+      if ( exec->glyphSize )\n+        FT_FREE( exec->glyphIns );\n+      exec->glyphSize = 0;\n@@ -445,16 +419,1 @@\n-      \/* and thus update the bytecode array size by ourselves       *\/\n-\n-      tmp   = load->exec->glyphSize;\n-      error = Update_Max( load->exec->memory,\n-                          &tmp,\n-                          sizeof ( FT_Byte ),\n-                          (void*)&load->exec->glyphIns,\n-                          n_ins );\n-\n-      load->exec->glyphSize = (FT_UShort)tmp;\n-      if ( error )\n-        return error;\n-\n-      load->glyph->control_len  = n_ins;\n-      load->glyph->control_data = load->exec->glyphIns;\n-\n+      \/* and thus allocate the bytecode array size by ourselves     *\/\n@@ -462,1 +421,6 @@\n-        FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );\n+      {\n+        if ( FT_DUP( exec->glyphIns, p, n_ins ) )\n+          return error;\n+\n+        exec->glyphSize  = n_ins;\n+      }\n@@ -469,2 +433,0 @@\n-    outline = &gloader->current.outline;\n-\n@@ -472,1 +434,1 @@\n-    flag       = (FT_Byte*)outline->tags;\n+    flag       = outline->tags;\n@@ -505,1 +467,1 @@\n-    flag      = (FT_Byte*)outline->tags;\n+    flag      = outline->tags;\n@@ -508,3 +470,0 @@\n-    if ( p + xy_size > limit )\n-      goto Invalid_Outline;\n-\n@@ -540,1 +499,1 @@\n-    vec       = gloader->current.outline.points;\n+    vec       = outline->points;\n@@ -542,1 +501,1 @@\n-    flag      = (FT_Byte*)outline->tags;\n+    flag      = outline->tags;\n@@ -575,2 +534,2 @@\n-    outline->n_points   = (FT_Short)n_points;\n-    outline->n_contours = (FT_Short)n_contours;\n+    outline->n_points   = (FT_UShort)n_points;\n+    outline->n_contours = (FT_UShort)n_contours;\n@@ -733,1 +692,1 @@\n-                      subglyph->transform.xx \/ 65536.0 ));\n+                      (double)subglyph->transform.xx \/ 65536 ));\n@@ -736,2 +695,2 @@\n-                      subglyph->transform.xx \/ 65536.0,\n-                      subglyph->transform.yy \/ 65536.0 ));\n+                      (double)subglyph->transform.xx \/ 65536,\n+                      (double)subglyph->transform.yy \/ 65536 ));\n@@ -739,6 +698,8 @@\n-          FT_TRACE7(( \"      scaling: xx=%f, yx=%f\\n\"\n-                      \"               xy=%f, yy=%f\\n\",\n-                      subglyph->transform.xx \/ 65536.0,\n-                      subglyph->transform.yx \/ 65536.0,\n-                      subglyph->transform.xy \/ 65536.0,\n-                      subglyph->transform.yy \/ 65536.0 ));\n+        {\n+          FT_TRACE7(( \"      scaling: xx=%f, yx=%f\\n\",\n+                      (double)subglyph->transform.xx \/ 65536,\n+                      (double)subglyph->transform.yx \/ 65536 ));\n+          FT_TRACE7(( \"               xy=%f, yy=%f\\n\",\n+                      (double)subglyph->transform.xy \/ 65536,\n+                      (double)subglyph->transform.yy \/ 65536 ));\n+        }\n@@ -795,4 +756,2 @@\n-    zone->n_points    = (FT_UShort)load->outline.n_points -\n-                          (FT_UShort)start_point;\n-    zone->n_contours  = load->outline.n_contours -\n-                          (FT_Short)start_contour;\n+    zone->n_points    = load->outline.n_points + 4 - (FT_UShort)start_point;\n+    zone->n_contours  = load->outline.n_contours - (FT_UShort)start_contour;\n@@ -802,2 +761,2 @@\n-    zone->tags        = (FT_Byte*)load->outline.tags + start_point;\n-    zone->contours    = (FT_UShort*)load->outline.contours + start_contour;\n+    zone->tags        = load->outline.tags + start_point;\n+    zone->contours    = load->outline.contours + start_contour;\n@@ -821,2 +780,1 @@\n-#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \\\n-    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n@@ -830,1 +788,2 @@\n-    FT_Long       n_ins;\n+    TT_ExecContext  exec  = loader->exec;\n+    FT_Long         n_ins = exec->glyphSize;\n@@ -837,2 +796,0 @@\n-    n_ins = loader->glyph->control_len;\n-\n@@ -844,1 +801,1 @@\n-    loader->exec->GS = loader->size->GS;\n+    exec->GS = loader->size->GS;\n@@ -850,2 +807,2 @@\n-      loader->exec->metrics.x_scale = 1 << 16;\n-      loader->exec->metrics.y_scale = 1 << 16;\n+      exec->metrics.x_scale = 1 << 16;\n+      exec->metrics.y_scale = 1 << 16;\n@@ -857,2 +814,2 @@\n-      loader->exec->metrics.x_scale = loader->size->metrics->x_scale;\n-      loader->exec->metrics.y_scale = loader->size->metrics->y_scale;\n+      exec->metrics.x_scale = loader->size->metrics->x_scale;\n+      exec->metrics.y_scale = loader->size->metrics->y_scale;\n@@ -878,3 +835,0 @@\n-      FT_GlyphLoader  gloader         = loader->gloader;\n-      FT_Outline      current_outline = gloader->current.outline;\n-\n@@ -882,2 +836,1 @@\n-      TT_Set_CodeRange( loader->exec, tt_coderange_glyph,\n-                        loader->exec->glyphIns, n_ins );\n+      TT_Set_CodeRange( exec, tt_coderange_glyph, exec->glyphIns, n_ins );\n@@ -885,2 +838,2 @@\n-      loader->exec->is_composite = is_composite;\n-      loader->exec->pts          = *zone;\n+      exec->is_composite = is_composite;\n+      exec->pts          = *zone;\n@@ -888,2 +841,2 @@\n-      error = TT_Run_Context( loader->exec );\n-      if ( error && loader->exec->pedantic_hinting )\n+      error = TT_Run_Context( exec );\n+      if ( error && exec->pedantic_hinting )\n@@ -893,2 +846,2 @@\n-      current_outline.tags[0] |=\n-        ( loader->exec->GS.scan_type << 5 ) | FT_CURVE_TAG_HAS_SCANMODE;\n+      loader->gloader->current.outline.tags[0] |=\n+        ( exec->GS.scan_type << 5 ) | FT_CURVE_TAG_HAS_SCANMODE;\n@@ -899,1 +852,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n@@ -903,8 +855,1 @@\n-    if ( !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&\n-            loader->exec->backward_compatibility ) )\n-    {\n-#endif\n-      loader->pp1 = zone->cur[zone->n_points - 4];\n-      loader->pp2 = zone->cur[zone->n_points - 3];\n-      loader->pp3 = zone->cur[zone->n_points - 2];\n-      loader->pp4 = zone->cur[zone->n_points - 1];\n+\n@@ -912,1 +857,3 @@\n-    }\n+    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&\n+         exec->backward_compatibility )\n+      return FT_Err_Ok;\n@@ -915,10 +862,4 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )\n-    {\n-      if ( loader->exec->sph_tweak_flags & SPH_TWEAK_DEEMBOLDEN )\n-        FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );\n-\n-      else if ( loader->exec->sph_tweak_flags & SPH_TWEAK_EMBOLDEN )\n-        FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );\n-    }\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n+    loader->pp1 = zone->cur[zone->n_points - 4];\n+    loader->pp2 = zone->cur[zone->n_points - 3];\n+    loader->pp3 = zone->cur[zone->n_points - 2];\n+    loader->pp4 = zone->cur[zone->n_points - 1];\n@@ -943,4 +884,4 @@\n-    FT_GlyphLoader  gloader = loader->gloader;\n-    FT_Error        error   = FT_Err_Ok;\n-    FT_Outline*     outline;\n-    FT_Int          n_points;\n+    FT_Error        error    = FT_Err_Ok;\n+    FT_GlyphLoader  gloader  = loader->gloader;\n+    FT_Outline*     outline  = &gloader->current.outline;\n+    FT_Int          n_points = outline->n_points;\n@@ -954,3 +895,0 @@\n-    outline  = &gloader->current.outline;\n-    n_points = outline->n_points;\n-\n@@ -958,1 +896,0 @@\n-\n@@ -964,5 +901,0 @@\n-    outline->tags[n_points    ] = 0;\n-    outline->tags[n_points + 1] = 0;\n-    outline->tags[n_points + 2] = 0;\n-    outline->tags[n_points + 3] = 0;\n-\n@@ -975,1 +907,1 @@\n-      if ( FT_NEW_ARRAY( unrounded, n_points ) )\n+      if ( FT_QNEW_ARRAY( unrounded, n_points ) )\n@@ -979,2 +911,1 @@\n-      error = TT_Vary_Apply_Glyph_Deltas( loader->face,\n-                                          loader->glyph_index,\n+      error = TT_Vary_Apply_Glyph_Deltas( loader,\n@@ -982,15 +913,1 @@\n-                                          unrounded,\n-                                          (FT_UInt)n_points );\n-\n-      \/* recalculate linear horizontal and vertical advances *\/\n-      \/* if we don't have HVAR and VVAR, respectively        *\/\n-\n-      \/* XXX: change all FreeType modules to store `linear' and `vadvance' *\/\n-      \/*      in 26.6 format before the `base' module scales them to 16.16 *\/\n-      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n-        loader->linear = FT_PIX_ROUND( unrounded[n_points - 3].x -\n-                                       unrounded[n_points - 4].x ) \/ 64;\n-      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n-        loader->vadvance = FT_PIX_ROUND( unrounded[n_points - 1].x -\n-                                         unrounded[n_points - 2].x ) \/ 64;\n-\n+                                          unrounded );\n@@ -1008,1 +925,1 @@\n-                     loader->zone.n_points + 4 );\n+                     loader->zone.n_points );\n@@ -1012,10 +929,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      TT_Face    face   = loader->face;\n-      TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );\n-\n-      FT_String*  family         = face->root.family_name;\n-      FT_UInt     ppem           = loader->size->metrics->x_ppem;\n-      FT_String*  style          = face->root.style_name;\n-      FT_UInt     x_scale_factor = 1000;\n-#endif\n-\n@@ -1031,46 +938,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )\n-      {\n-        \/* scale, but only if enabled and only if TT hinting is being used *\/\n-        if ( IS_HINTED( loader->load_flags ) )\n-          x_scale_factor = sph_test_tweak_x_scaling( face,\n-                                                     family,\n-                                                     ppem,\n-                                                     style,\n-                                                     loader->glyph_index );\n-        \/* scale the glyph *\/\n-        if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 ||\n-             x_scale_factor != 1000                         )\n-        {\n-          x_scale = FT_MulDiv( loader->size->metrics->x_scale,\n-                               (FT_Long)x_scale_factor, 1000 );\n-          y_scale = loader->size->metrics->y_scale;\n-\n-          \/* compensate for any scaling by de\/emboldening; *\/\n-          \/* the amount was determined via experimentation *\/\n-          if ( x_scale_factor != 1000 && ppem > 11 )\n-          {\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-            FT_Vector*  orig_points = outline->points;\n-\n-\n-            if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )\n-              outline->points = unrounded;\n-#endif\n-            FT_Outline_EmboldenXY( outline,\n-                                   FT_MulFix( 1280 * ppem,\n-                                              1000 - x_scale_factor ),\n-                                   0 );\n-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n-            if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )\n-              outline->points = orig_points;\n-#endif\n-          }\n-          do_scale = TRUE;\n-        }\n-      }\n-      else\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -1098,2 +959,2 @@\n-            vec->x = ( FT_MulFix( u->x, x_scale ) + 32 ) >> 6;\n-            vec->y = ( FT_MulFix( u->y, y_scale ) + 32 ) >> 6;\n+            vec->x = ADD_LONG( FT_MulFix( u->x, x_scale ), 32 ) >> 6;\n+            vec->y = ADD_LONG( FT_MulFix( u->y, y_scale ), 32 ) >> 6;\n@@ -1150,3 +1011,0 @@\n-    {\n-      loader->zone.n_points += 4;\n-\n@@ -1154,1 +1012,0 @@\n-    }\n@@ -1189,1 +1046,1 @@\n-                         (short)num_base_points;\n+                         (FT_UShort)num_base_points;\n@@ -1202,1 +1059,1 @@\n-      FT_UInt     num_points = (FT_UInt)gloader->base.outline.n_points;\n+      FT_UInt     num_points = gloader->base.outline.n_points;\n@@ -1222,2 +1079,2 @@\n-      x = p1->x - p2->x;\n-      y = p1->y - p2->y;\n+      x = SUB_LONG( p1->x, p2->x );\n+      y = SUB_LONG( p1->y, p2->y );\n@@ -1349,1 +1206,3 @@\n-    FT_Outline*  outline;\n+    FT_Outline*  outline = &loader->gloader->base.outline;\n+    FT_Stream    stream = loader->stream;\n+    FT_UShort    n_ins;\n@@ -1353,2 +1212,0 @@\n-    outline = &loader->gloader->base.outline;\n-\n@@ -1367,5 +1224,0 @@\n-    outline->tags[outline->n_points    ] = 0;\n-    outline->tags[outline->n_points + 1] = 0;\n-    outline->tags[outline->n_points + 2] = 0;\n-    outline->tags[outline->n_points + 3] = 0;\n-\n@@ -1375,3 +1227,2 @@\n-      FT_Stream  stream = loader->stream;\n-      FT_UShort  n_ins, max_ins;\n-      FT_ULong   tmp;\n+      TT_ExecContext  exec = loader->exec;\n+      FT_Memory       memory = exec->memory;\n@@ -1380,0 +1231,4 @@\n+      if ( exec->glyphSize )\n+        FT_FREE( exec->glyphIns );\n+      exec->glyphSize = 0;\n+\n@@ -1386,15 +1241,1 @@\n-      FT_TRACE5(( \"  Instructions size = %d\\n\", n_ins ));\n-\n-      \/* check it *\/\n-      max_ins = loader->face->max_profile.maxSizeOfInstructions;\n-      if ( n_ins > max_ins )\n-      {\n-        \/* don't trust `maxSizeOfInstructions'; *\/\n-        \/* only do a rough safety check         *\/\n-        if ( (FT_Int)n_ins > loader->byte_len )\n-        {\n-          FT_TRACE1(( \"TT_Process_Composite_Glyph:\"\n-                      \" too many instructions (%d) for glyph with length %d\\n\",\n-                      n_ins, loader->byte_len ));\n-          return FT_THROW( Too_Many_Hints );\n-        }\n+      FT_TRACE5(( \"  Instructions size = %hu\\n\", n_ins ));\n@@ -1402,6 +1243,2 @@\n-        tmp   = loader->exec->glyphSize;\n-        error = Update_Max( loader->exec->memory,\n-                            &tmp,\n-                            sizeof ( FT_Byte ),\n-                            (void*)&loader->exec->glyphIns,\n-                            n_ins );\n+      if ( !n_ins )\n+        return FT_Err_Ok;\n@@ -1409,3 +1246,8 @@\n-        loader->exec->glyphSize = (FT_UShort)tmp;\n-        if ( error )\n-          return error;\n+      \/* don't trust `maxSizeOfInstructions'; *\/\n+      \/* only do a rough safety check         *\/\n+      if ( n_ins > loader->byte_len )\n+      {\n+        FT_TRACE1(( \"TT_Process_Composite_Glyph:\"\n+                    \" too many instructions (%hu) for glyph with length %u\\n\",\n+                    n_ins, loader->byte_len ));\n+        return FT_THROW( Too_Many_Hints );\n@@ -1413,2 +1255,0 @@\n-      else if ( n_ins == 0 )\n-        return FT_Err_Ok;\n@@ -1416,1 +1256,2 @@\n-      if ( FT_STREAM_READ( loader->exec->glyphIns, n_ins ) )\n+      if ( FT_QNEW_ARRAY( exec->glyphIns, n_ins )  ||\n+           FT_STREAM_READ( exec->glyphIns, n_ins ) )\n@@ -1419,2 +1260,1 @@\n-      loader->glyph->control_data = loader->exec->glyphIns;\n-      loader->glyph->control_len  = n_ins;\n+      exec->glyphSize = n_ins;\n@@ -1430,1 +1270,1 @@\n-    for ( i = 0; i < loader->zone.n_points; i++ )\n+    for ( i = 0; i < loader->zone.n_points - 4U; i++ )\n@@ -1433,2 +1273,0 @@\n-    loader->zone.n_points += 4;\n-\n@@ -1526,30 +1364,0 @@\n-    FT_Bool  subpixel_hinting = 0;\n-    FT_Bool  grayscale        = 0;\n-    FT_Bool  use_aw_2         = 0;\n-\n-#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING\n-    TT_Driver driver = (TT_Driver)FT_FACE_DRIVER( loader->face );\n-#endif\n-\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )\n-    {\n-      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting\n-                                      : 0;\n-      grayscale        = loader->exec ? loader->exec->grayscale\n-                                      : 0;\n-    }\n-#endif\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )\n-    {\n-      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting_lean\n-                                      : 0;\n-      grayscale        = loader->exec ? loader->exec->grayscale_cleartype\n-                                      : 0;\n-    }\n-#endif\n-\n-    use_aw_2 = FT_BOOL( subpixel_hinting && grayscale );\n-\n@@ -1561,1 +1369,1 @@\n-    loader->pp3.x = use_aw_2 ? loader->advance \/ 2 : 0;\n+    loader->pp3.x = 0;\n@@ -1563,1 +1371,1 @@\n-    loader->pp4.x = use_aw_2 ? loader->advance \/ 2 : 0;\n+    loader->pp4.x = 0;\n@@ -1565,0 +1373,16 @@\n+\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+    {\n+      TT_Driver driver = (TT_Driver)FT_FACE_DRIVER( loader->face );\n+\n+\n+      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&\n+           loader->exec                                             &&\n+           loader->exec->subpixel_hinting_lean                      &&\n+           loader->exec->grayscale_cleartype                        )\n+      {\n+        loader->pp3.x = loader->advance \/ 2;\n+        loader->pp4.x = loader->advance \/ 2;\n+      }\n+    }\n+#endif\n@@ -1680,1 +1504,1 @@\n-                            (FT_ULong)glyph_data.length );\n+                            glyph_data.length );\n@@ -1687,0 +1511,2 @@\n+    {\n+      FT_ULong  len;\n@@ -1688,2 +1514,5 @@\n-      offset = tt_face_get_location( face, glyph_index,\n-                                     (FT_UInt*)&loader->byte_len );\n+\n+      offset = tt_face_get_location( FT_FACE( face ), glyph_index, &len );\n+\n+      loader->byte_len = (FT_UInt)len;\n+    }\n@@ -1708,1 +1537,1 @@\n-                                        (FT_UInt)loader->byte_len );\n+                                        loader->byte_len );\n@@ -1742,4 +1571,0 @@\n-      \/* must initialize points before (possibly) overriding *\/\n-      \/* glyph metrics from the incremental interface        *\/\n-      tt_loader_set_pp( loader );\n-\n@@ -1747,1 +1572,1 @@\n-      tt_get_metrics_incr_overrides( loader, glyph_index );\n+      tt_get_metrics_incremental( loader, glyph_index );\n@@ -1749,0 +1574,2 @@\n+      tt_loader_set_pp( loader );\n+\n@@ -1758,2 +1585,0 @@\n-        char        tags[4]     = { 1, 1, 1, 1 };\n-        short       contours[4] = { 0, 1, 2, 3 };\n@@ -1766,9 +1591,4 @@\n-        points[0].x = loader->pp1.x;\n-        points[0].y = loader->pp1.y;\n-        points[1].x = loader->pp2.x;\n-        points[1].y = loader->pp2.y;\n-\n-        points[2].x = loader->pp3.x;\n-        points[2].y = loader->pp3.y;\n-        points[3].x = loader->pp4.x;\n-        points[3].y = loader->pp4.y;\n+        points[0] = loader->pp1;\n+        points[1] = loader->pp2;\n+        points[2] = loader->pp3;\n+        points[3] = loader->pp4;\n@@ -1776,2 +1596,2 @@\n-        outline.n_points   = 4;\n-        outline.n_contours = 4;\n+        outline.n_points   = 0;\n+        outline.n_contours = 0;\n@@ -1779,2 +1599,2 @@\n-        outline.tags       = tags;\n-        outline.contours   = contours;\n+        outline.tags       = NULL;\n+        outline.contours   = NULL;\n@@ -1783,2 +1603,1 @@\n-        error = TT_Vary_Apply_Glyph_Deltas( loader->face,\n-                                            glyph_index,\n+        error = TT_Vary_Apply_Glyph_Deltas( loader,\n@@ -1786,2 +1605,1 @@\n-                                            unrounded,\n-                                            (FT_UInt)outline.n_points );\n+                                            unrounded );\n@@ -1790,19 +1608,0 @@\n-\n-        loader->pp1.x = points[0].x;\n-        loader->pp1.y = points[0].y;\n-        loader->pp2.x = points[1].x;\n-        loader->pp2.y = points[1].y;\n-\n-        loader->pp3.x = points[2].x;\n-        loader->pp3.y = points[2].y;\n-        loader->pp4.x = points[3].x;\n-        loader->pp4.y = points[3].y;\n-\n-        \/* recalculate linear horizontal and vertical advances *\/\n-        \/* if we don't have HVAR and VVAR, respectively        *\/\n-        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n-          loader->linear = FT_PIX_ROUND( unrounded[1].x -\n-                                         unrounded[0].x ) \/ 64;\n-        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n-          loader->vadvance = FT_PIX_ROUND( unrounded[3].x -\n-                                           unrounded[2].x ) \/ 64;\n@@ -1831,4 +1630,0 @@\n-    \/* must initialize phantom points before (possibly) overriding *\/\n-    \/* glyph metrics from the incremental interface                *\/\n-    tt_loader_set_pp( loader );\n-\n@@ -1836,1 +1631,1 @@\n-    tt_get_metrics_incr_overrides( loader, glyph_index );\n+    tt_get_metrics_incremental( loader, glyph_index );\n@@ -1838,0 +1633,2 @@\n+    tt_loader_set_pp( loader );\n+\n@@ -1847,1 +1644,1 @@\n-                                      (FT_UInt)loader->byte_len - 10 );\n+                                      loader->byte_len - 10 );\n@@ -1901,1 +1698,1 @@\n-        node2->data = (void*)FT_ULONG_MAX;\n+        node2->data = (void*)-1;\n@@ -1918,1 +1715,1 @@\n-        if ( FT_NEW( node ) )\n+        if ( FT_QNEW( node ) )\n@@ -1924,2 +1721,2 @@\n-      start_point   = (FT_UInt)gloader->base.outline.n_points;\n-      start_contour = (FT_UInt)gloader->base.outline.n_contours;\n+      start_point   = gloader->base.outline.n_points;\n+      start_contour = gloader->base.outline.n_contours;\n@@ -1944,1 +1741,1 @@\n-        short        i, limit;\n+        FT_UShort    i, limit;\n@@ -1947,4 +1744,1 @@\n-        FT_Outline  outline;\n-        FT_Vector*  points    = NULL;\n-        char*       tags      = NULL;\n-        short*      contours  = NULL;\n+        FT_Outline  outline = { 0, 0, NULL, NULL, NULL, 0 };\n@@ -1954,1 +1748,1 @@\n-        limit = (short)gloader->current.num_subglyphs;\n+        limit = (FT_UShort)gloader->current.num_subglyphs;\n@@ -1958,11 +1752,4 @@\n-        outline.n_points   = (short)( gloader->current.num_subglyphs + 4 );\n-        outline.n_contours = outline.n_points;\n-\n-        outline.points   = NULL;\n-        outline.tags     = NULL;\n-        outline.contours = NULL;\n-\n-        if ( FT_NEW_ARRAY( points, outline.n_points )    ||\n-             FT_NEW_ARRAY( tags, outline.n_points )      ||\n-             FT_NEW_ARRAY( contours, outline.n_points )  ||\n-             FT_NEW_ARRAY( unrounded, outline.n_points ) )\n+        if ( FT_QNEW_ARRAY( outline.points, limit + 4 ) ||\n+             FT_QNEW_ARRAY( outline.tags, limit )       ||\n+             FT_QNEW_ARRAY( outline.contours, limit )   ||\n+             FT_QNEW_ARRAY( unrounded, limit + 4 )      )\n@@ -1971,0 +1758,2 @@\n+        outline.n_contours = outline.n_points = limit;\n+\n@@ -1978,4 +1767,4 @@\n-          points[i].x = subglyph->arg1;\n-          points[i].y = subglyph->arg2;\n-          tags[i]     = 1;\n-          contours[i] = i;\n+          outline.points[i].x = subglyph->arg1;\n+          outline.points[i].y = subglyph->arg2;\n+          outline.tags[i]     = ON_CURVE_POINT;\n+          outline.contours[i] = i;\n@@ -1984,26 +1773,4 @@\n-        points[i].x = loader->pp1.x;\n-        points[i].y = loader->pp1.y;\n-        tags[i]     = 1;\n-        contours[i] = i;\n-\n-        i++;\n-        points[i].x = loader->pp2.x;\n-        points[i].y = loader->pp2.y;\n-        tags[i]     = 1;\n-        contours[i] = i;\n-\n-        i++;\n-        points[i].x = loader->pp3.x;\n-        points[i].y = loader->pp3.y;\n-        tags[i]     = 1;\n-        contours[i] = i;\n-\n-        i++;\n-        points[i].x = loader->pp4.x;\n-        points[i].y = loader->pp4.y;\n-        tags[i]     = 1;\n-        contours[i] = i;\n-\n-        outline.points   = points;\n-        outline.tags     = tags;\n-        outline.contours = contours;\n+        outline.points[i++] = loader->pp1;\n+        outline.points[i++] = loader->pp2;\n+        outline.points[i++] = loader->pp3;\n+        outline.points[i  ] = loader->pp4;\n@@ -2013,6 +1780,3 @@\n-        if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(\n-                             face,\n-                             glyph_index,\n-                             &outline,\n-                             unrounded,\n-                             (FT_UInt)outline.n_points ) ) )\n+        if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas( loader,\n+                                                       &outline,\n+                                                       unrounded ) ) )\n@@ -2027,2 +1791,2 @@\n-            subglyph->arg1 = (FT_Int16)points[i].x;\n-            subglyph->arg2 = (FT_Int16)points[i].y;\n+            subglyph->arg1 = (FT_Int16)outline.points[i].x;\n+            subglyph->arg2 = (FT_Int16)outline.points[i].y;\n@@ -2032,21 +1796,0 @@\n-        loader->pp1.x = points[i + 0].x;\n-        loader->pp1.y = points[i + 0].y;\n-        loader->pp2.x = points[i + 1].x;\n-        loader->pp2.y = points[i + 1].y;\n-\n-        loader->pp3.x = points[i + 2].x;\n-        loader->pp3.y = points[i + 2].y;\n-        loader->pp4.x = points[i + 3].x;\n-        loader->pp4.y = points[i + 3].y;\n-\n-        \/* recalculate linear horizontal and vertical advances *\/\n-        \/* if we don't have HVAR and VVAR, respectively        *\/\n-        if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n-          loader->linear =\n-            FT_PIX_ROUND( unrounded[outline.n_points - 3].x -\n-                          unrounded[outline.n_points - 4].x ) \/ 64;\n-        if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n-          loader->vadvance =\n-            FT_PIX_ROUND( unrounded[outline.n_points - 1].x -\n-                          unrounded[outline.n_points - 2].x ) \/ 64;\n-\n@@ -2103,1 +1846,1 @@\n-        FT_Int       old_byte_len   = loader->byte_len;\n+        FT_UInt      old_byte_len   = loader->byte_len;\n@@ -2131,1 +1874,1 @@\n-          num_base_points = (FT_UInt)gloader->base.outline.n_points;\n+          num_base_points = gloader->base.outline.n_points;\n@@ -2155,1 +1898,1 @@\n-          num_points = (FT_UInt)gloader->base.outline.n_points;\n+          num_points = gloader->base.outline.n_points;\n@@ -2228,6 +1971,3 @@\n-    TT_Face    face   = loader->face;\n-#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \\\n-    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );\n-#endif\n-\n+    TT_Face       face  = loader->face;\n+    TT_Size       size  = loader->size;\n+    TT_GlyphSlot  glyph = loader->glyph;\n@@ -2236,2 +1976,0 @@\n-    TT_GlyphSlot  glyph = loader->glyph;\n-    TT_Size       size  = loader->size;\n@@ -2255,47 +1993,4 @@\n-    glyph->metrics.horiAdvance  = SUB_LONG(loader->pp2.x, loader->pp1.x);\n-\n-    \/* Adjust advance width to the value contained in the hdmx table   *\/\n-    \/* unless FT_LOAD_COMPUTE_METRICS is set or backward compatibility *\/\n-    \/* mode of the v40 interpreter is active.  See `ttinterp.h' for    *\/\n-    \/* details on backward compatibility mode.                         *\/\n-    if (\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-         !( driver->interpreter_version == TT_INTERPRETER_VERSION_40  &&\n-            ( loader->exec && loader->exec->backward_compatibility  ) ) &&\n-#endif\n-         !face->postscript.isFixedPitch                                 &&\n-         IS_HINTED( loader->load_flags )                                &&\n-         !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )              )\n-    {\n-      FT_Byte*  widthp;\n-\n-\n-      widthp = tt_face_get_device_metrics( face,\n-                                           size->metrics->x_ppem,\n-                                           glyph_index );\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )\n-      {\n-        FT_Bool  ignore_x_mode;\n-\n-\n-        ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=\n-                                 FT_RENDER_MODE_MONO );\n-\n-        if ( widthp                                                   &&\n-             ( ( ignore_x_mode && loader->exec->compatible_widths ) ||\n-                !ignore_x_mode                                      ||\n-                SPH_OPTION_BITMAP_WIDTHS                            ) )\n-          glyph->metrics.horiAdvance = *widthp * 64;\n-      }\n-      else\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-      {\n-        if ( widthp )\n-          glyph->metrics.horiAdvance = *widthp * 64;\n-      }\n-    }\n+    if ( loader->widthp )\n+      glyph->metrics.horiAdvance = loader->widthp[glyph_index] * 64;\n+    else\n+      glyph->metrics.horiAdvance = SUB_LONG( loader->pp2.x, loader->pp1.x );\n@@ -2418,3 +2113,3 @@\n-    TT_Face             face;\n-    SFNT_Service        sfnt;\n-    FT_Stream           stream;\n+    TT_Face             face   = (TT_Face)glyph->face;\n+    SFNT_Service        sfnt   = (SFNT_Service)face->sfnt;\n+    FT_Stream           stream = face->root.stream;\n@@ -2425,4 +2120,0 @@\n-    face   = (TT_Face)glyph->face;\n-    sfnt   = (SFNT_Service)face->sfnt;\n-    stream = face->root.stream;\n-\n@@ -2479,2 +2170,2 @@\n-    TT_Face    face;\n-    FT_Stream  stream;\n+    TT_Face    face   = (TT_Face)glyph->face;\n+    FT_Stream  stream = face->root.stream;\n@@ -2485,3 +2176,2 @@\n-#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \\\n-    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( (TT_Face)glyph->face );\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+    TT_Driver  driver   = (TT_Driver)FT_FACE_DRIVER( glyph->face );\n@@ -2492,3 +2182,0 @@\n-    face   = (TT_Face)glyph->face;\n-    stream = face->root.stream;\n-\n@@ -2509,14 +2196,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      FT_Bool  subpixel_hinting = FALSE;\n-\n-#if 0\n-      \/* not used yet *\/\n-      FT_Bool  compatible_widths;\n-      FT_Bool  symmetrical_smoothing;\n-      FT_Bool  bgr;\n-      FT_Bool  vertical_lcd;\n-      FT_Bool  subpixel_positioned;\n-      FT_Bool  gray_cleartype;\n-#endif\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -2542,0 +2215,3 @@\n+      grayscale = FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n+                             FT_RENDER_MODE_MONO             );\n+\n@@ -2558,0 +2234,1 @@\n+        grayscale = FT_BOOL( grayscale && !subpixel_hinting_lean );\n@@ -2567,69 +2244,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )\n-      {\n-        subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                                      FT_RENDER_MODE_MONO               )  &&\n-                                    SPH_OPTION_SET_SUBPIXEL                );\n-\n-        if ( subpixel_hinting )\n-          grayscale = FALSE;\n-        else if ( SPH_OPTION_SET_GRAYSCALE )\n-        {\n-          grayscale        = TRUE;\n-          subpixel_hinting = FALSE;\n-        }\n-        else\n-          grayscale = FALSE;\n-\n-        if ( FT_IS_TRICKY( glyph->face ) )\n-          subpixel_hinting = FALSE;\n-\n-        exec->ignore_x_mode      = subpixel_hinting || grayscale;\n-        exec->rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;\n-        if ( exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )\n-          exec->rasterizer_version = TT_INTERPRETER_VERSION_35;\n-\n-#if 1\n-        exec->compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;\n-        exec->symmetrical_smoothing = TRUE;\n-        exec->bgr                   = FALSE;\n-        exec->vertical_lcd          = FALSE;\n-        exec->subpixel_positioned   = TRUE;\n-        exec->gray_cleartype        = FALSE;\n-#else \/* 0 *\/\n-        exec->compatible_widths =\n-          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                   TT_LOAD_COMPATIBLE_WIDTHS );\n-        exec->symmetrical_smoothing =\n-          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                   TT_LOAD_SYMMETRICAL_SMOOTHING );\n-        exec->bgr =\n-          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                   TT_LOAD_BGR );\n-        exec->vertical_lcd =\n-          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                   TT_LOAD_VERTICAL_LCD );\n-        exec->subpixel_positioned =\n-          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                   TT_LOAD_SUBPIXEL_POSITIONED );\n-        exec->gray_cleartype =\n-          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                   TT_LOAD_GRAY_CLEARTYPE );\n-#endif \/* 0 *\/\n-\n-      }\n-      else\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )\n-        grayscale = FT_BOOL( !subpixel_hinting_lean               &&\n-                             FT_LOAD_TARGET_MODE( load_flags ) !=\n-                               FT_RENDER_MODE_MONO                );\n-      else\n-#endif\n-        grayscale = FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=\n-                               FT_RENDER_MODE_MONO             );\n-\n@@ -2640,3 +2248,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )\n@@ -2644,28 +2249,0 @@\n-        \/* a change from mono to subpixel rendering (and vice versa) *\/\n-        \/* requires a re-execution of the CVT program                *\/\n-        if ( subpixel_hinting != exec->subpixel_hinting )\n-        {\n-          FT_TRACE4(( \"tt_loader_init: subpixel hinting change,\"\n-                      \" re-executing `prep' table\\n\" ));\n-\n-          exec->subpixel_hinting = subpixel_hinting;\n-          reexecute              = TRUE;\n-        }\n-\n-        \/* a change from mono to grayscale rendering (and vice versa) *\/\n-        \/* requires a re-execution of the CVT program                 *\/\n-        if ( grayscale != exec->grayscale )\n-        {\n-          FT_TRACE4(( \"tt_loader_init: grayscale hinting change,\"\n-                      \" re-executing `prep' table\\n\" ));\n-\n-          exec->grayscale = grayscale;\n-          reexecute       = TRUE;\n-        }\n-      }\n-      else\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-      {\n-\n@@ -2716,0 +2293,3 @@\n+        error = TT_Load_Context( exec, face, size );\n+        if ( error )\n+          return error;\n@@ -2726,7 +2306,21 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      \/* check whether we have a font hinted for ClearType --           *\/\n-      \/* note that this flag can also be modified in a glyph's bytecode *\/\n-      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&\n-           exec->GS.instruct_control & 4                            )\n-        exec->ignore_x_mode = 0;\n-#endif\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+      \/*\n+       * Toggle backward compatibility according to what font wants, except\n+       * when\n+       *\n+       * 1) we have a `tricky' font that heavily relies on the interpreter to\n+       *    render glyphs correctly, for example DFKai-SB, or\n+       * 2) FT_RENDER_MODE_MONO (i.e, monochrome rendering) is requested.\n+       *\n+       * In those cases, backward compatibility needs to be turned off to get\n+       * correct rendering.  The rendering is then completely up to the\n+       * font's programming.\n+       *\n+       *\/\n+      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&\n+           subpixel_hinting_lean                                    &&\n+           !FT_IS_TRICKY( glyph->face )                             )\n+        exec->backward_compatibility = !( exec->GS.instruct_control & 4 );\n+      else\n+        exec->backward_compatibility = FALSE;\n+#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL *\/\n@@ -2737,0 +2331,17 @@\n+\n+      \/* Use the hdmx table if any unless FT_LOAD_COMPUTE_METRICS *\/\n+      \/* is set or backward compatibility mode of the v38 or v40  *\/\n+      \/* interpreters is active.  See `ttinterp.h' for details on *\/\n+      \/* backward compatibility mode.                             *\/\n+      if ( IS_HINTED( loader->load_flags )                                &&\n+           !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )              &&\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+           !( driver->interpreter_version == TT_INTERPRETER_VERSION_40  &&\n+              exec->backward_compatibility                              ) &&\n+#endif\n+           !face->postscript.isFixedPitch                                 )\n+      {\n+        loader->widthp = size->widthp;\n+      }\n+      else\n+        loader->widthp = NULL;\n@@ -2784,1 +2395,1 @@\n-   * @Input:\n+   * @InOut:\n@@ -2789,0 +2400,1 @@\n+   * @Input:\n@@ -2812,0 +2424,1 @@\n+    TT_Face       face = (TT_Face)glyph->face;\n@@ -2836,2 +2449,0 @@\n-          TT_Face  face = (TT_Face)glyph->face;\n-\n@@ -2893,1 +2504,2 @@\n-        if ( FT_IS_SCALABLE( glyph->face ) )\n+        if ( FT_IS_SCALABLE( glyph->face ) ||\n+             FT_HAS_SBIX( glyph->face )    )\n@@ -2902,0 +2514,29 @@\n+          \/* Bitmaps from the 'sbix' table need special treatment:  *\/\n+          \/* if there is a glyph contour, the bitmap origin must be *\/\n+          \/* shifted to be relative to the lower left corner of the *\/\n+          \/* glyph bounding box, also taking the left-side bearing  *\/\n+          \/* (or top bearing) into account.                         *\/\n+          if ( face->sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX &&\n+               loader.n_contours > 0                            )\n+          {\n+            FT_Int  bitmap_left;\n+            FT_Int  bitmap_top;\n+\n+\n+            if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )\n+            {\n+              \/* This is a guess, since Apple's CoreText engine doesn't *\/\n+              \/* really do vertical typesetting.                        *\/\n+              bitmap_left = loader.bbox.xMin;\n+              bitmap_top  = loader.top_bearing;\n+            }\n+            else\n+            {\n+              bitmap_left = loader.left_bearing;\n+              bitmap_top  = loader.bbox.yMin;\n+            }\n+\n+            glyph->bitmap_left += FT_MulFix( bitmap_left, x_scale ) >> 6;\n+            glyph->bitmap_top  += FT_MulFix( bitmap_top,  y_scale ) >> 6;\n+          }\n+\n@@ -2916,0 +2557,6 @@\n+    if ( load_flags & FT_LOAD_SBITS_ONLY )\n+    {\n+      error = FT_THROW( Invalid_Argument );\n+      goto Exit;\n+    }\n+\n@@ -2925,1 +2572,53 @@\n-    if ( load_flags & FT_LOAD_SBITS_ONLY )\n+#ifdef FT_CONFIG_OPTION_SVG\n+\n+    \/* check for OT-SVG *\/\n+    if ( ( load_flags & FT_LOAD_NO_SVG ) == 0 &&\n+         ( load_flags & FT_LOAD_COLOR )       &&\n+         face->svg                            )\n+    {\n+      SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+\n+\n+      FT_TRACE3(( \"Trying to load SVG glyph\\n\" ));\n+\n+      error = sfnt->load_svg_doc( glyph, glyph_index );\n+      if ( !error )\n+      {\n+        FT_Fixed  x_scale = size->root.metrics.x_scale;\n+        FT_Fixed  y_scale = size->root.metrics.y_scale;\n+\n+        FT_Short   leftBearing;\n+        FT_Short   topBearing;\n+        FT_UShort  advanceX;\n+        FT_UShort  advanceY;\n+\n+\n+        FT_TRACE3(( \"Successfully loaded SVG glyph\\n\" ));\n+\n+        glyph->format = FT_GLYPH_FORMAT_SVG;\n+\n+        sfnt->get_metrics( face,\n+                           FALSE,\n+                           glyph_index,\n+                           &leftBearing,\n+                           &advanceX );\n+        sfnt->get_metrics( face,\n+                           TRUE,\n+                           glyph_index,\n+                           &topBearing,\n+                           &advanceY );\n+\n+        glyph->linearHoriAdvance = advanceX;\n+        glyph->linearVertAdvance = advanceY;\n+\n+        glyph->metrics.horiAdvance = FT_MulFix( advanceX, x_scale );\n+        glyph->metrics.vertAdvance = FT_MulFix( advanceY, y_scale );\n+\n+        return error;\n+      }\n+\n+      FT_TRACE3(( \"Failed to load SVG glyph\\n\" ));\n+    }\n+\n+    \/* return immediately if we only want SVG glyphs *\/\n+    if ( load_flags & FT_LOAD_SVG_ONLY )\n@@ -2931,0 +2630,2 @@\n+#endif \/* FT_CONFIG_OPTION_SVG *\/\n+\n@@ -2935,0 +2636,9 @@\n+    \/* done if we are only interested in the `hdmx` advance *\/\n+    if ( load_flags & FT_LOAD_ADVANCE_ONLY         &&\n+         !( load_flags & FT_LOAD_VERTICAL_LAYOUT ) &&\n+         loader.widthp                             )\n+    {\n+      glyph->metrics.horiAdvance = loader.widthp[glyph_index] * 64;\n+      goto Done;\n+    }\n+\n@@ -2965,0 +2675,3 @@\n+        glyph->control_data = loader.exec->glyphIns;\n+        glyph->control_len  = loader.exec->glyphSize;\n+\n@@ -3006,1 +2719,1 @@\n-    FT_TRACE1(( \"  subglyphs = %u, contours = %hd, points = %hd,\"\n+    FT_TRACE1(( \"  subglyphs = %u, contours = %hu, points = %hu,\"\n@@ -3013,0 +2726,1 @@\n+  Done:\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttgload.c","additions":373,"deletions":659,"binary":false,"changes":1032,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n@@ -45,0 +45,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -47,0 +48,1 @@\n+#include <freetype\/internal\/services\/svmetric.h>\n@@ -130,3 +132,0 @@\n-   *   size ::\n-   *     The size of the table holding the data.\n-   *\n@@ -145,1 +144,0 @@\n-                           FT_ULong   size,\n@@ -150,1 +148,1 @@\n-    FT_UInt    runcnt;\n+    FT_UInt    runcnt, cnt;\n@@ -153,0 +151,1 @@\n+    FT_Byte*   p;\n@@ -154,3 +153,1 @@\n-    FT_Error   error  = FT_Err_Ok;\n-\n-    FT_UNUSED( error );\n+    FT_Error   error;\n@@ -172,3 +169,1 @@\n-    if ( n > size )\n-    {\n-      FT_TRACE1(( \"ft_var_readpackedpoints: number of points too large\\n\" ));\n+    if ( FT_QNEW_ARRAY( points, n ) )\n@@ -176,9 +171,0 @@\n-    }\n-\n-    \/* in the nested loops below we increase `i' twice; *\/\n-    \/* it is faster to simply allocate one more slot    *\/\n-    \/* than to add another test within the loop         *\/\n-    if ( FT_NEW_ARRAY( points, n + 1 ) )\n-      return NULL;\n-\n-    *point_cnt = n;\n@@ -186,0 +172,1 @@\n+    p     = stream->cursor;\n@@ -190,1 +177,11 @@\n-      runcnt = FT_GET_BYTE();\n+      if ( p >= stream->limit )\n+        goto Fail;\n+\n+      runcnt = FT_NEXT_BYTE( p );\n+      cnt    = runcnt & GX_PT_POINT_RUN_COUNT_MASK;\n+\n+      \/* first point not included in run count *\/\n+      cnt++;\n+      if ( cnt > n - i )\n+        cnt = n - i;\n+\n@@ -193,3 +190,2 @@\n-        runcnt     &= GX_PT_POINT_RUN_COUNT_MASK;\n-        first      += FT_GET_USHORT();\n-        points[i++] = first;\n+        if ( 2 * cnt > (FT_UInt)( stream->limit - p ) )\n+          goto Fail;\n@@ -197,2 +193,1 @@\n-        \/* first point not included in run count *\/\n-        for ( j = 0; j < runcnt; j++ )\n+        for ( j = 0; j < cnt; j++ )\n@@ -200,1 +195,1 @@\n-          first      += FT_GET_USHORT();\n+          first      += FT_NEXT_USHORT( p );\n@@ -202,2 +197,0 @@\n-          if ( i >= n )\n-            break;\n@@ -208,2 +201,2 @@\n-        first      += FT_GET_BYTE();\n-        points[i++] = first;\n+        if ( cnt > (FT_UInt)( stream->limit - p ) )\n+          goto Fail;\n@@ -211,1 +204,1 @@\n-        for ( j = 0; j < runcnt; j++ )\n+        for ( j = 0; j < cnt; j++ )\n@@ -213,1 +206,1 @@\n-          first      += FT_GET_BYTE();\n+          first      += FT_NEXT_BYTE( p );\n@@ -215,2 +208,0 @@\n-          if ( i >= n )\n-            break;\n@@ -221,0 +212,4 @@\n+    stream->cursor = p;\n+\n+    *point_cnt = n;\n+\n@@ -222,0 +217,6 @@\n+\n+  Fail:\n+    FT_TRACE1(( \"ft_var_readpackedpoints: invalid table\\n\" ));\n+\n+    FT_FREE( points );\n+    return NULL;\n@@ -243,3 +244,0 @@\n-   *   size ::\n-   *     The size of the table holding the data.\n-   *\n@@ -261,1 +259,0 @@\n-                           FT_ULong   size,\n@@ -267,0 +264,1 @@\n+    FT_Byte*   p;\n@@ -268,4 +266,1 @@\n-    FT_Error   error  = FT_Err_Ok;\n-\n-    FT_UNUSED( error );\n-\n+    FT_Error   error;\n@@ -273,5 +268,0 @@\n-    if ( delta_cnt > size )\n-    {\n-      FT_TRACE1(( \"ft_var_readpackeddeltas: number of points too large\\n\" ));\n-      return NULL;\n-    }\n@@ -279,1 +269,1 @@\n-    if ( FT_NEW_ARRAY( deltas, delta_cnt ) )\n+    if ( FT_QNEW_ARRAY( deltas, delta_cnt ) )\n@@ -282,0 +272,1 @@\n+    p = stream->cursor;\n@@ -285,1 +276,4 @@\n-      runcnt = FT_GET_BYTE();\n+      if ( p >= stream->limit )\n+        goto Fail;\n+\n+      runcnt = FT_NEXT_BYTE( p );\n@@ -288,0 +282,5 @@\n+      \/* first point not included in run count *\/\n+      cnt++;\n+      if ( cnt > delta_cnt - i )\n+        cnt = delta_cnt - i;\n+\n@@ -290,2 +289,1 @@\n-        \/* `runcnt' zeroes get added *\/\n-        for ( j = 0; j <= cnt && i < delta_cnt; j++ )\n+        for ( j = 0; j < cnt; j++ )\n@@ -296,3 +294,5 @@\n-        \/* `runcnt' shorts from the stack *\/\n-        for ( j = 0; j <= cnt && i < delta_cnt; j++ )\n-          deltas[i++] = FT_intToFixed( FT_GET_SHORT() );\n+        if ( 2 * cnt > (FT_UInt)( stream->limit - p ) )\n+          goto Fail;\n+\n+        for ( j = 0; j < cnt; j++ )\n+          deltas[i++] = FT_intToFixed( FT_NEXT_SHORT( p ) );\n@@ -302,4 +302,2 @@\n-        \/* `runcnt' signed bytes from the stack *\/\n-        for ( j = 0; j <= cnt && i < delta_cnt; j++ )\n-          deltas[i++] = FT_intToFixed( FT_GET_CHAR() );\n-      }\n+        if ( cnt > (FT_UInt)( stream->limit - p ) )\n+          goto Fail;\n@@ -307,5 +305,2 @@\n-      if ( j <= cnt )\n-      {\n-        \/* bad format *\/\n-        FT_FREE( deltas );\n-        return NULL;\n+        for ( j = 0; j < cnt; j++ )\n+          deltas[i++] = FT_intToFixed( FT_NEXT_CHAR( p ) );\n@@ -315,0 +310,2 @@\n+    stream->cursor = p;\n+\n@@ -316,0 +313,6 @@\n+\n+  Fail:\n+    FT_TRACE1(( \"ft_var_readpackeddeltas: invalid table\\n\" ));\n+\n+    FT_FREE( deltas );\n+    return NULL;\n@@ -335,2 +338,5 @@\n-    FT_Stream       stream = FT_FACE_STREAM( face );\n-    FT_Memory       memory = stream->memory;\n+    FT_Error   error;\n+    FT_Stream  stream = FT_FACE_STREAM( face );\n+    FT_Memory  memory = stream->memory;\n+    FT_Int     i, j;\n+\n@@ -339,5 +345,5 @@\n-    FT_Error        error = FT_Err_Ok;\n-    FT_Long         version;\n-    FT_Long         axisCount;\n-    FT_Int          i, j;\n-    FT_ULong        table_len;\n+    GX_AVarTable    table;\n+\n+    FT_Long   version;\n+    FT_Long   axisCount;\n+    FT_ULong  table_len;\n@@ -345,1 +351,5 @@\n-    FT_UNUSED( error );\n+#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n+    FT_ULong  table_offset;\n+    FT_ULong  store_offset;\n+    FT_ULong  axisMap_offset;\n+#endif\n@@ -358,0 +368,4 @@\n+#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n+    table_offset = FT_STREAM_POS();\n+#endif\n+\n@@ -364,1 +378,5 @@\n-    if ( version != 0x00010000L )\n+    if ( version != 0x00010000L\n+#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n+         && version != 0x00020000L\n+#endif\n+       )\n@@ -374,2 +392,3 @@\n-      FT_TRACE2(( \"ft_var_load_avar: number of axes in `avar' and `fvar'\\n\"\n-                  \"                  table are different\\n\" ));\n+      FT_TRACE2(( \"ft_var_load_avar:\"\n+                  \" number of axes in `avar' and `fvar'\\n\" ));\n+      FT_TRACE2(( \"                  table are different\\n\" ));\n@@ -379,1 +398,5 @@\n-    if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )\n+    if ( FT_NEW( blend->avar_table ) )\n+      goto Exit;\n+    table = blend->avar_table;\n+\n+    if ( FT_QNEW_ARRAY( table->avar_segment, axisCount ) )\n@@ -382,1 +405,1 @@\n-    segment = &blend->avar_segment[0];\n+    segment = &table->avar_segment[0];\n@@ -388,2 +411,2 @@\n-      if ( (FT_ULong)segment->pairCount * 4 > table_len                ||\n-           FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )\n+      if ( (FT_ULong)segment->pairCount * 4 > table_len                 ||\n+           FT_QNEW_ARRAY( segment->correspondence, segment->pairCount ) )\n@@ -395,1 +418,1 @@\n-          FT_FREE( blend->avar_segment[j].correspondence );\n+          FT_FREE( table->avar_segment[j].correspondence );\n@@ -397,2 +420,1 @@\n-        FT_FREE( blend->avar_segment );\n-        blend->avar_segment = NULL;\n+        FT_FREE( table->avar_segment );\n@@ -410,2 +432,2 @@\n-                    segment->correspondence[j].fromCoord \/ 65536.0,\n-                    segment->correspondence[j].toCoord \/ 65536.0 ));\n+                    (double)segment->correspondence[j].fromCoord \/ 65536,\n+                    (double)segment->correspondence[j].toCoord \/ 65536 ));\n@@ -417,0 +439,31 @@\n+#ifndef TT_CONFIG_OPTION_NO_BORING_EXPANSION\n+    if ( version < 0x00020000L )\n+      goto Exit;\n+\n+    axisMap_offset = FT_GET_ULONG();\n+    store_offset   = FT_GET_ULONG();\n+\n+    if ( store_offset )\n+    {\n+      error = tt_var_load_item_variation_store(\n+                FT_FACE( face ),\n+                table_offset + store_offset,\n+                &table->itemStore );\n+      if ( error )\n+        goto Exit;\n+    }\n+\n+    if ( axisMap_offset )\n+    {\n+      error = tt_var_load_delta_set_index_mapping(\n+                FT_FACE( face ),\n+                table_offset + axisMap_offset,\n+                &table->axisMap,\n+                &table->itemStore,\n+                table_len );\n+      if ( error )\n+        goto Exit;\n+    }\n+#endif\n+\n+\n@@ -422,2 +475,2 @@\n-  static FT_Error\n-  ft_var_load_item_variation_store( TT_Face          face,\n+  FT_LOCAL_DEF( FT_Error )\n+  tt_var_load_item_variation_store( FT_Face          face,      \/* TT_Face *\/\n@@ -427,0 +480,1 @@\n+    TT_Face    ttface = (TT_Face)face;\n@@ -433,2 +487,0 @@\n-    FT_UInt    i, j, k;\n-    FT_UInt    shortDeltaCount;\n@@ -436,2 +488,6 @@\n-    GX_Blend        blend = face->blend;\n-    GX_ItemVarData  varData;\n+    FT_UInt    data_count;\n+    FT_UShort  axis_count;\n+    FT_UInt    region_count;\n+\n+    FT_UInt  i, j;\n+    FT_Bool  long_words;\n@@ -439,0 +495,1 @@\n+    GX_Blend   blend           = ttface->blend;\n@@ -448,1 +505,1 @@\n-      FT_TRACE2(( \"ft_var_load_item_variation_store: bad store format %d\\n\",\n+      FT_TRACE2(( \"tt_var_load_item_variation_store: bad store format %d\\n\",\n@@ -455,2 +512,2 @@\n-    if ( FT_READ_ULONG( region_offset )         ||\n-         FT_READ_USHORT( itemStore->dataCount ) )\n+    if ( FT_READ_ULONG( region_offset ) ||\n+         FT_READ_USHORT( data_count )   )\n@@ -460,1 +517,1 @@\n-    if ( !itemStore->dataCount )\n+    if ( !data_count )\n@@ -462,1 +519,1 @@\n-      FT_TRACE2(( \"ft_var_load_item_variation_store: missing varData\\n\" ));\n+      FT_TRACE2(( \"tt_var_load_item_variation_store: missing varData\\n\" ));\n@@ -469,1 +526,1 @@\n-    if ( FT_NEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )\n+    if ( FT_QNEW_ARRAY( dataOffsetArray, data_count ) )\n@@ -472,1 +529,1 @@\n-    for ( i = 0; i < itemStore->dataCount; i++ )\n+    for ( i = 0; i < data_count; i++ )\n@@ -482,2 +539,2 @@\n-    if ( FT_READ_USHORT( itemStore->axisCount )   ||\n-         FT_READ_USHORT( itemStore->regionCount ) )\n+    if ( FT_READ_USHORT( axis_count )   ||\n+         FT_READ_USHORT( region_count ) )\n@@ -486,1 +543,1 @@\n-    if ( itemStore->axisCount != (FT_Long)blend->mmvar->num_axis )\n+    if ( axis_count != (FT_Long)blend->mmvar->num_axis )\n@@ -488,3 +545,3 @@\n-      FT_TRACE2(( \"ft_var_load_item_variation_store:\"\n-                  \" number of axes in item variation store\\n\"\n-                  \"                                 \"\n+      FT_TRACE2(( \"tt_var_load_item_variation_store:\"\n+                  \" number of axes in item variation store\\n\" ));\n+      FT_TRACE2(( \"                                 \"\n@@ -495,0 +552,1 @@\n+    itemStore->axisCount = axis_count;\n@@ -496,1 +554,6 @@\n-    if ( FT_NEW_ARRAY( itemStore->varRegionList, itemStore->regionCount ) )\n+    \/* new constraint in OpenType 1.8.4 *\/\n+    if ( region_count >= 32768U )\n+    {\n+      FT_TRACE2(( \"tt_var_load_item_variation_store:\"\n+                  \" too many variation region tables\\n\" ));\n+      error = FT_THROW( Invalid_Table );\n@@ -498,0 +561,5 @@\n+    }\n+\n+    if ( FT_NEW_ARRAY( itemStore->varRegionList, region_count ) )\n+      goto Exit;\n+    itemStore->regionCount = region_count;\n@@ -504,2 +572,1 @@\n-      if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList,\n-                         itemStore->axisCount ) )\n+      if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList, axis_count ) )\n@@ -512,1 +579,1 @@\n-        FT_Short  start, peak, end;\n+        FT_Int  start, peak, end;\n@@ -520,0 +587,4 @@\n+        \/* immediately tag invalid ranges with special peak = 0 *\/\n+        if ( ( start < 0 && end > 0 ) || start > peak || peak > end )\n+          peak = 0;\n+\n@@ -529,1 +600,1 @@\n-    if ( FT_NEW_ARRAY( itemStore->varData, itemStore->dataCount ) )\n+    if ( FT_NEW_ARRAY( itemStore->varData, data_count ) )\n@@ -531,0 +602,1 @@\n+    itemStore->dataCount = data_count;\n@@ -532,1 +604,1 @@\n-    for ( i = 0; i < itemStore->dataCount; i++ )\n+    for ( i = 0; i < data_count; i++ )\n@@ -534,1 +606,7 @@\n-      varData = &itemStore->varData[i];\n+      GX_ItemVarData  varData = &itemStore->varData[i];\n+\n+      FT_UInt    item_count;\n+      FT_UShort  word_delta_count;\n+      FT_UInt    region_idx_count;\n+      FT_UInt    per_region_size;\n+\n@@ -539,3 +617,3 @@\n-      if ( FT_READ_USHORT( varData->itemCount )      ||\n-           FT_READ_USHORT( shortDeltaCount )         ||\n-           FT_READ_USHORT( varData->regionIdxCount ) )\n+      if ( FT_READ_USHORT( item_count )       ||\n+           FT_READ_USHORT( word_delta_count ) ||\n+           FT_READ_USHORT( region_idx_count ) )\n@@ -544,0 +622,3 @@\n+      long_words        = !!( word_delta_count & 0x8000 );\n+      word_delta_count &= 0x7FFF;\n+\n@@ -545,1 +626,1 @@\n-      if ( shortDeltaCount > varData->regionIdxCount )\n+      if ( word_delta_count > region_idx_count )\n@@ -548,2 +629,2 @@\n-                    shortDeltaCount,\n-                    varData->regionIdxCount ));\n+                    word_delta_count,\n+                    region_idx_count ));\n@@ -554,1 +635,1 @@\n-      if ( varData->regionIdxCount > itemStore->regionCount )\n+      if ( region_idx_count > itemStore->regionCount )\n@@ -557,1 +638,1 @@\n-                    varData->regionIdxCount,\n+                    region_idx_count,\n@@ -564,2 +645,1 @@\n-      if ( FT_NEW_ARRAY( varData->regionIndices,\n-                         varData->regionIdxCount ) )\n+      if ( FT_NEW_ARRAY( varData->regionIndices, region_idx_count ) )\n@@ -567,0 +647,3 @@\n+      varData->regionIdxCount = region_idx_count;\n+      varData->wordDeltaCount = word_delta_count;\n+      varData->longWords      = long_words;\n@@ -582,8 +665,3 @@\n-      \/* Parse delta set.                                                *\/\n-      \/*                                                                 *\/\n-      \/* On input, deltas are (shortDeltaCount + regionIdxCount) bytes   *\/\n-      \/* each; on output, deltas are expanded to `regionIdxCount' shorts *\/\n-      \/* each.                                                           *\/\n-      if ( FT_NEW_ARRAY( varData->deltaSet,\n-                         varData->regionIdxCount * varData->itemCount ) )\n-        goto Exit;\n+      per_region_size = word_delta_count + region_idx_count;\n+      if ( long_words )\n+        per_region_size *= 2;\n@@ -591,3 +669,5 @@\n-      \/* the delta set is stored as a 2-dimensional array of shorts; *\/\n-      \/* sign-extend signed bytes to signed shorts                   *\/\n-      for ( j = 0; j < varData->itemCount * varData->regionIdxCount; )\n+      if ( FT_NEW_ARRAY( varData->deltaSet, per_region_size * item_count ) )\n+        goto Exit;\n+      if ( FT_Stream_Read( stream,\n+                           varData->deltaSet,\n+                           per_region_size * item_count ) )\n@@ -595,23 +675,3 @@\n-        for ( k = 0; k < shortDeltaCount; k++, j++ )\n-        {\n-          \/* read the short deltas *\/\n-          FT_Short  delta;\n-\n-\n-          if ( FT_READ_SHORT( delta ) )\n-            goto Exit;\n-\n-          varData->deltaSet[j] = delta;\n-        }\n-\n-        for ( ; k < varData->regionIdxCount; k++, j++ )\n-        {\n-          \/* read the (signed) byte deltas *\/\n-          FT_Char  delta;\n-\n-\n-          if ( FT_READ_CHAR( delta ) )\n-            goto Exit;\n-\n-          varData->deltaSet[j] = delta;\n-        }\n+        FT_TRACE2(( \"deltaSet read failed.\" ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n@@ -619,0 +679,2 @@\n+\n+      varData->itemCount = item_count;\n@@ -628,2 +690,2 @@\n-  static FT_Error\n-  ft_var_load_delta_set_index_mapping( TT_Face            face,\n+  FT_LOCAL_DEF( FT_Error )\n+  tt_var_load_delta_set_index_mapping( FT_Face            face, \/* TT_Face *\/\n@@ -632,1 +694,2 @@\n-                                       GX_ItemVarStore    itemStore )\n+                                       GX_ItemVarStore    itemStore,\n+                                       FT_ULong           table_len )\n@@ -637,1 +700,1 @@\n-    FT_Error   error;\n+    FT_Error  error;\n@@ -639,5 +702,7 @@\n-    FT_UShort  format;\n-    FT_UInt    entrySize;\n-    FT_UInt    innerBitCount;\n-    FT_UInt    innerIndexMask;\n-    FT_UInt    i, j;\n+    FT_Byte   format;\n+    FT_Byte   entryFormat;\n+    FT_UInt   entrySize;\n+    FT_UInt   innerBitCount;\n+    FT_UInt   innerIndexMask;\n+    FT_ULong  i;\n+    FT_UInt   j;\n@@ -646,3 +711,3 @@\n-    if ( FT_STREAM_SEEK( offset )        ||\n-         FT_READ_USHORT( format )        ||\n-         FT_READ_USHORT( map->mapCount ) )\n+    if ( FT_STREAM_SEEK( offset )    ||\n+         FT_READ_BYTE( format )      ||\n+         FT_READ_BYTE( entryFormat ) )\n@@ -651,1 +716,11 @@\n-    if ( format & 0xFFC0 )\n+    if ( format == 0 )\n+    {\n+      if ( FT_READ_USHORT( map->mapCount ) )\n+        goto Exit;\n+    }\n+    else if ( format == 1 ) \/* new in OpenType 1.9 *\/\n+    {\n+      if ( FT_READ_ULONG( map->mapCount ) )\n+        goto Exit;\n+    }\n+    else\n@@ -658,0 +733,7 @@\n+    if ( entryFormat & 0xC0 )\n+    {\n+      FT_TRACE2(( \"bad entry format %d\\n\", format ));\n+      error = FT_THROW( Invalid_Table );\n+      goto Exit;\n+    }\n+\n@@ -659,2 +741,2 @@\n-    entrySize      = ( ( format & 0x0030 ) >> 4 ) + 1;\n-    innerBitCount  = ( format & 0x000F ) + 1;\n+    entrySize      = ( ( entryFormat & 0x30 ) >> 4 ) + 1;\n+    innerBitCount  = ( entryFormat & 0x0F ) + 1;\n@@ -663,0 +745,9 @@\n+    \/* rough sanity check *\/\n+    if ( map->mapCount * entrySize > table_len )\n+    {\n+      FT_TRACE1(( \"tt_var_load_delta_set_index_mapping:\"\n+                  \" invalid number of delta-set index mappings\\n\" ));\n+      error = FT_THROW( Invalid_Table );\n+      goto Exit;\n+    }\n+\n@@ -687,0 +778,10 @@\n+      \/* new in OpenType 1.8.4 *\/\n+      if ( mapData == 0xFFFFFFFFUL )\n+      {\n+        \/* no variation data for this item *\/\n+        map->outerIndex[i] = 0xFFFFU;\n+        map->innerIndex[i] = 0xFFFFU;\n+\n+        continue;\n+      }\n+\n@@ -691,1 +792,1 @@\n-        FT_TRACE2(( \"outerIndex[%d] == %d out of range\\n\",\n+        FT_TRACE2(( \"outerIndex[%ld] == %d out of range\\n\",\n@@ -704,1 +805,1 @@\n-        FT_TRACE2(( \"innerIndex[%d] == %d out of range\\n\",\n+        FT_TRACE2(( \"innerIndex[%ld] == %d out of range\\n\",\n@@ -816,2 +917,2 @@\n-    error = ft_var_load_item_variation_store(\n-              face,\n+    error = tt_var_load_item_variation_store(\n+              FT_FACE( face ),\n@@ -825,2 +926,2 @@\n-      error = ft_var_load_delta_set_index_mapping(\n-                face,\n+      error = tt_var_load_delta_set_index_mapping(\n+                FT_FACE( face ),\n@@ -829,1 +930,2 @@\n-                &table->itemStore );\n+                &table->itemStore,\n+                table_len );\n@@ -866,2 +968,2 @@\n-  static FT_Int\n-  ft_var_get_item_delta( TT_Face          face,\n+  FT_LOCAL_DEF( FT_ItemVarDelta )\n+  tt_var_get_item_delta( FT_Face          face,        \/* TT_Face *\/\n@@ -872,2 +974,16 @@\n-    GX_ItemVarData  varData;\n-    FT_Short*       deltaSet;\n+    TT_Face    ttface = (TT_Face)face;\n+    FT_Stream  stream = FT_FACE_STREAM( face );\n+    FT_Memory  memory = stream->memory;\n+    FT_Error   error  = FT_Err_Ok;\n+\n+    GX_ItemVarData    varData;\n+    FT_ItemVarDelta*  deltaSet = NULL;\n+    FT_ItemVarDelta   deltaSetStack[16];\n+\n+    FT_Fixed*  scalars = NULL;\n+    FT_Fixed   scalarsStack[16];\n+\n+    FT_UInt          master, j;\n+    FT_ItemVarDelta  returnValue = 0;\n+    FT_UInt          per_region_size;\n+    FT_Byte*         bytes;\n@@ -875,4 +991,0 @@\n-    FT_UInt   master, j;\n-    FT_Fixed  netAdjustment = 0;     \/* accumulated adjustment *\/\n-    FT_Fixed  scaledDelta;\n-    FT_Fixed  delta;\n@@ -880,0 +992,7 @@\n+    if ( !ttface->blend || !ttface->blend->normalizedcoords )\n+      return 0;\n+\n+    \/* OpenType 1.8.4+: No variation data for this item *\/\n+    \/* as indices have special value 0xFFFF.            *\/\n+    if ( outerIndex == 0xFFFF && innerIndex == 0xFFFF )\n+      return 0;\n@@ -884,2 +1003,48 @@\n-    varData  = &itemStore->varData[outerIndex];\n-    deltaSet = &varData->deltaSet[varData->regionIdxCount * innerIndex];\n+    if ( outerIndex >= itemStore->dataCount )\n+      return 0; \/* Out of range. *\/\n+\n+    varData = &itemStore->varData[outerIndex];\n+\n+    if ( innerIndex >= varData->itemCount )\n+      return 0; \/* Out of range. *\/\n+\n+    if ( varData->regionIdxCount == 0 )\n+      return 0; \/* Avoid \"applying zero offset to null pointer\". *\/\n+\n+    if ( varData->regionIdxCount < 16 )\n+    {\n+      deltaSet = deltaSetStack;\n+      scalars  = scalarsStack;\n+    }\n+    else\n+    {\n+      if ( FT_QNEW_ARRAY( deltaSet, varData->regionIdxCount ) )\n+        goto Exit;\n+      if ( FT_QNEW_ARRAY( scalars, varData->regionIdxCount ) )\n+        goto Exit;\n+    }\n+\n+    \/* Parse delta set.                                            *\/\n+    \/*                                                             *\/\n+    \/* Deltas are (word_delta_count + region_idx_count) bytes each *\/\n+    \/* if `longWords` isn't set, and twice as much otherwise.      *\/\n+    per_region_size = varData->wordDeltaCount + varData->regionIdxCount;\n+    if ( varData->longWords )\n+      per_region_size *= 2;\n+\n+    bytes = varData->deltaSet + per_region_size * innerIndex;\n+\n+    if ( varData->longWords )\n+    {\n+      for ( master = 0; master < varData->wordDeltaCount; master++ )\n+        deltaSet[master] = FT_NEXT_LONG( bytes );\n+      for ( ; master < varData->regionIdxCount; master++ )\n+        deltaSet[master] = FT_NEXT_SHORT( bytes );\n+    }\n+    else\n+    {\n+      for ( master = 0; master < varData->wordDeltaCount; master++ )\n+        deltaSet[master] = FT_NEXT_SHORT( bytes );\n+      for ( ; master < varData->regionIdxCount; master++ )\n+        deltaSet[master] = FT_NEXT_CHAR( bytes );\n+    }\n@@ -899,5 +1064,1 @@\n-        \/* compute the scalar contribution of this axis; *\/\n-        \/* ignore invalid ranges                         *\/\n-        if ( axis->startCoord > axis->peakCoord ||\n-             axis->peakCoord > axis->endCoord   )\n-          continue;\n+        FT_Fixed  ncv = ttface->blend->normalizedcoords[j];\n@@ -905,4 +1066,0 @@\n-        else if ( axis->startCoord < 0 &&\n-                  axis->endCoord > 0   &&\n-                  axis->peakCoord != 0 )\n-          continue;\n@@ -910,5 +1067,4 @@\n-        \/* peak of 0 means ignore this axis *\/\n-        else if ( axis->peakCoord == 0 )\n-          continue;\n-\n-        else if ( face->blend->normalizedcoords[j] == axis->peakCoord )\n+        \/* compute the scalar contribution of this axis *\/\n+        \/* with peak of 0 used for invalid axes         *\/\n+        if ( axis->peakCoord == ncv ||\n+             axis->peakCoord == 0   )\n@@ -918,2 +1074,2 @@\n-        else if ( face->blend->normalizedcoords[j] <= axis->startCoord ||\n-                  face->blend->normalizedcoords[j] >= axis->endCoord   )\n+        else if ( ncv <= axis->startCoord ||\n+                  ncv >= axis->endCoord   )\n@@ -926,11 +1082,8 @@\n-        else if ( face->blend->normalizedcoords[j] < axis->peakCoord )\n-          scalar =\n-            FT_MulDiv( scalar,\n-                       face->blend->normalizedcoords[j] - axis->startCoord,\n-                       axis->peakCoord - axis->startCoord );\n-        else\n-          scalar =\n-            FT_MulDiv( scalar,\n-                       axis->endCoord - face->blend->normalizedcoords[j],\n-                       axis->endCoord - axis->peakCoord );\n-      } \/* per-axis loop *\/\n+        else if ( ncv < axis->peakCoord )\n+          scalar = FT_MulDiv( scalar,\n+                              ncv - axis->startCoord,\n+                              axis->peakCoord - axis->startCoord );\n+        else   \/* ncv > axis->peakCoord *\/\n+          scalar = FT_MulDiv( scalar,\n+                              axis->endCoord - ncv,\n+                              axis->endCoord - axis->peakCoord );\n@@ -938,3 +1091,1 @@\n-      \/* get the scaled delta for this region *\/\n-      delta       = FT_intToFixed( deltaSet[master] );\n-      scaledDelta = FT_MulFix( scalar, delta );\n+      } \/* per-axis loop *\/\n@@ -942,2 +1093,1 @@\n-      \/* accumulate the adjustments from each region *\/\n-      netAdjustment = netAdjustment + scaledDelta;\n+      scalars[master] = scalar;\n@@ -947,1 +1097,24 @@\n-    return FT_fixedToInt( netAdjustment );\n+\n+    \/* Compute the scaled delta for this region.\n+     *\n+     * From: https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/otvarcommonformats#item-variation-store-header-and-item-variation-data-subtables:\n+     *\n+     *   `Fixed` is a 32-bit (16.16) type and, in the general case, requires\n+     *   32-bit deltas.  As described above, the `DeltaSet` record can\n+     *   accommodate deltas that are, logically, either 16-bit or 32-bit.\n+     *   When scaled deltas are applied to `Fixed` values, the `Fixed` value\n+     *   is treated like a 32-bit integer.\n+     *\n+     * `FT_MulAddFix` internally uses 64-bit precision; it thus can handle\n+     * deltas ranging from small 8-bit to large 32-bit values that are\n+     * applied to 16.16 `FT_Fixed` \/ OpenType `Fixed` values.\n+     *\/\n+    returnValue = FT_MulAddFix( scalars, deltaSet, varData->regionIdxCount );\n+\n+  Exit:\n+    if ( scalars != scalarsStack )\n+      FT_FREE( scalars );\n+    if ( deltaSet != deltaSetStack )\n+      FT_FREE( deltaSet );\n+\n+    return returnValue;\n@@ -1040,3 +1213,0 @@\n-      GX_ItemVarData  varData;\n-\n-\n@@ -1046,8 +1216,0 @@\n-\n-      varData = &table->itemStore.varData[outerIndex];\n-      if ( gindex >= varData->itemCount )\n-      {\n-        FT_TRACE2(( \"gindex %d out of range\\n\", gindex ));\n-        error = FT_THROW( Invalid_Argument );\n-        goto Exit;\n-      }\n@@ -1056,1 +1218,1 @@\n-    delta = ft_var_get_item_delta( face,\n+    delta = tt_var_get_item_delta( FT_FACE( face ),\n@@ -1061,8 +1223,11 @@\n-    FT_TRACE5(( \"%s value %d adjusted by %d unit%s (%s)\\n\",\n-                vertical ? \"vertical height\" : \"horizontal width\",\n-                *avalue,\n-                delta,\n-                delta == 1 ? \"\" : \"s\",\n-                vertical ? \"VVAR\" : \"HVAR\" ));\n-\n-    *avalue += delta;\n+    if ( delta )\n+    {\n+      FT_TRACE5(( \"%s value %d adjusted by %d unit%s (%s)\\n\",\n+                  vertical ? \"vertical height\" : \"horizontal width\",\n+                  *avalue,\n+                  delta,\n+                  delta == 1 ? \"\" : \"s\",\n+                  vertical ? \"VVAR\" : \"HVAR\" ));\n+\n+      *avalue = ADD_INT( *avalue, delta );\n+    }\n@@ -1076,1 +1241,1 @@\n-  tt_hadvance_adjust( TT_Face  face,\n+  tt_hadvance_adjust( FT_Face  face,    \/* TT_Face *\/\n@@ -1080,1 +1245,1 @@\n-    return tt_hvadvance_adjust( face, gindex, avalue, 0 );\n+    return tt_hvadvance_adjust( (TT_Face)face, gindex, avalue, 0 );\n@@ -1085,1 +1250,1 @@\n-  tt_vadvance_adjust( TT_Face  face,\n+  tt_vadvance_adjust( FT_Face  face,    \/* TT_Face *\/\n@@ -1089,1 +1254,1 @@\n-    return tt_hvadvance_adjust( face, gindex, avalue, 1 );\n+    return tt_hvadvance_adjust( (TT_Face)face, gindex, avalue, 1 );\n@@ -1235,2 +1400,2 @@\n-    error = ft_var_load_item_variation_store(\n-              face,\n+    error = tt_var_load_item_variation_store(\n+              FT_FACE( face ),\n@@ -1251,1 +1416,1 @@\n-    limit     = value + blend->mvar_table->valueCount;\n+    limit     = FT_OFFSET( value, blend->mvar_table->valueCount );\n@@ -1260,0 +1425,7 @@\n+      \/* new in OpenType 1.8.4 *\/\n+      if ( value->outerIndex == 0xFFFFU && value->innerIndex == 0xFFFFU )\n+      {\n+        \/* no variation data for this item *\/\n+        continue;\n+      }\n+\n@@ -1277,1 +1449,1 @@\n-    limit = value + blend->mvar_table->valueCount;\n+    limit = FT_OFFSET( value, blend->mvar_table->valueCount );\n@@ -1302,1 +1474,1 @@\n-  tt_size_reset_iterator( FT_ListNode  node,\n+  ft_size_reset_iterator( FT_ListNode  node,\n@@ -1305,1 +1477,2 @@\n-    TT_Size  size = (TT_Size)node->data;\n+    FT_Size                       size = (FT_Size)node->data;\n+    FT_Service_MetricsVariations  var  = (FT_Service_MetricsVariations)user;\n@@ -1307,1 +1480,0 @@\n-    FT_UNUSED( user );\n@@ -1309,2 +1481,1 @@\n-\n-    tt_size_reset( size, 1 );\n+    var->size_reset( size );\n@@ -1329,1 +1500,1 @@\n-  tt_apply_mvar( TT_Face  face )\n+  tt_apply_mvar( FT_Face  face )  \/* TT_Face *\/\n@@ -1331,1 +1502,3 @@\n-    GX_Blend  blend = face->blend;\n+    TT_Face  ttface = (TT_Face)face;\n+\n+    GX_Blend  blend = ttface->blend;\n@@ -1333,0 +1506,1 @@\n+\n@@ -1338,1 +1512,1 @@\n-    if ( !( face->variation_support & TT_FACE_FLAG_VAR_MVAR ) )\n+    if ( !( ttface->variation_support & TT_FACE_FLAG_VAR_MVAR ) )\n@@ -1342,1 +1516,1 @@\n-    limit = value + blend->mvar_table->valueCount;\n+    limit = FT_OFFSET( value, blend->mvar_table->valueCount );\n@@ -1346,1 +1520,1 @@\n-      FT_Short*  p = ft_var_get_value_pointer( face, value->tag );\n+      FT_Short*  p = ft_var_get_value_pointer( ttface, value->tag );\n@@ -1350,1 +1524,1 @@\n-      delta = ft_var_get_item_delta( face,\n+      delta = tt_var_get_item_delta( face,\n@@ -1355,1 +1529,1 @@\n-      if ( p )\n+      if ( p && delta )\n@@ -1383,1 +1557,2 @@\n-      FT_Face  root = &face->root;\n+      FT_Service_MetricsVariations  var =\n+        (FT_Service_MetricsVariations)ttface->face_var;\n@@ -1411,2 +1586,2 @@\n-      FT_Short  current_line_gap = root->height - root->ascender +\n-                                   root->descender;\n+      FT_Short  current_line_gap = face->height - face->ascender +\n+                                   face->descender;\n@@ -1415,3 +1590,3 @@\n-      root->ascender  = root->ascender + mvar_hasc_delta;\n-      root->descender = root->descender + mvar_hdsc_delta;\n-      root->height    = root->ascender - root->descender +\n+      face->ascender  = face->ascender + mvar_hasc_delta;\n+      face->descender = face->descender + mvar_hdsc_delta;\n+      face->height    = face->ascender - face->descender +\n@@ -1420,3 +1595,3 @@\n-      root->underline_position  = face->postscript.underlinePosition -\n-                                  face->postscript.underlineThickness \/ 2;\n-      root->underline_thickness = face->postscript.underlineThickness;\n+      face->underline_position  = ttface->postscript.underlinePosition -\n+                                  ttface->postscript.underlineThickness \/ 2;\n+      face->underline_thickness = ttface->postscript.underlineThickness;\n@@ -1424,5 +1599,6 @@\n-      \/* iterate over all FT_Size objects and call `tt_size_reset' *\/\n-      \/* to propagate the metrics changes                          *\/\n-      FT_List_Iterate( &root->sizes_list,\n-                       tt_size_reset_iterator,\n-                       NULL );\n+      \/* iterate over all FT_Size objects and call `var->size_reset' *\/\n+      \/* to propagate the metrics changes                            *\/\n+      if ( var && var->size_reset )\n+        FT_List_Iterate( &face->sizes_list,\n+                         ft_size_reset_iterator,\n+                         (void*)var );\n@@ -1518,2 +1694,3 @@\n-      FT_TRACE1(( \"ft_var_load_gvar: number of axes in `gvar' and `cvar'\\n\"\n-                  \"                  table are different\\n\" ));\n+      FT_TRACE1(( \"ft_var_load_gvar:\"\n+                  \" number of axes in `gvar' and `cvar'\\n\" ));\n+      FT_TRACE1(( \"                  table are different\\n\" ));\n@@ -1561,1 +1738,1 @@\n-    if ( FT_NEW_ARRAY( blend->glyphoffsets, gvar_head.glyphCount + 1 ) )\n+    if ( FT_QNEW_ARRAY( blend->glyphoffsets, gvar_head.glyphCount + 1 ) )\n@@ -1640,2 +1817,2 @@\n-      if ( FT_NEW_ARRAY( blend->tuplecoords,\n-                         gvar_head.axisCount * gvar_head.globalCoordCount ) )\n+      if ( FT_QNEW_ARRAY( blend->tuplecoords,\n+                          gvar_head.axisCount * gvar_head.globalCoordCount ) )\n@@ -1652,1 +1829,1 @@\n-            blend->tuplecoords[i * gvar_head.axisCount + j] \/ 65536.0 ));\n+            (double)blend->tuplecoords[i * gvar_head.axisCount + j] \/ 65536 ));\n@@ -1722,2 +1899,4 @@\n-      FT_TRACE6(( \"    axis %d coordinate %.5f:\\n\",\n-                  i, blend->normalizedcoords[i] \/ 65536.0 ));\n+      FT_Fixed  ncv = blend->normalizedcoords[i];\n+\n+\n+      FT_TRACE6(( \"    axis %d coordinate %.5f:\\n\", i, (double)ncv \/ 65536 ));\n@@ -1730,1 +1909,1 @@\n-      if ( tuple_coords[i] == 0 )\n+      if ( tuple_coords[i] == ncv )\n@@ -1732,1 +1911,3 @@\n-        FT_TRACE6(( \"      tuple coordinate is zero, ignore\\n\" ));\n+        FT_TRACE6(( \"      tuple coordinate %.5f fits perfectly\\n\",\n+                    (double)tuple_coords[i] \/ 65536 ));\n+        \/* `apply' does not change *\/\n@@ -1736,8 +1917,1 @@\n-      if ( blend->normalizedcoords[i] == 0 )\n-      {\n-        FT_TRACE6(( \"      axis coordinate is zero, stop\\n\" ));\n-        apply = 0;\n-        break;\n-      }\n-\n-      if ( blend->normalizedcoords[i] == tuple_coords[i] )\n+      if ( tuple_coords[i] == 0 )\n@@ -1745,3 +1919,1 @@\n-        FT_TRACE6(( \"      tuple coordinate %.5f fits perfectly\\n\",\n-                    tuple_coords[i] \/ 65536.0 ));\n-        \/* `apply' does not change *\/\n+        FT_TRACE6(( \"      tuple coordinate is zero, ignore\\n\" ));\n@@ -1755,2 +1927,8 @@\n-        if ( blend->normalizedcoords[i] < FT_MIN( 0, tuple_coords[i] ) ||\n-             blend->normalizedcoords[i] > FT_MAX( 0, tuple_coords[i] ) )\n+        if ( ( tuple_coords[i] > ncv && ncv > 0 ) ||\n+             ( tuple_coords[i] < ncv && ncv < 0 ) )\n+        {\n+          FT_TRACE6(( \"      tuple coordinate %.5f fits\\n\",\n+                      (double)tuple_coords[i] \/ 65536 ));\n+          apply = FT_MulDiv( apply, ncv, tuple_coords[i] );\n+        }\n+        else\n@@ -1759,1 +1937,1 @@\n-                      tuple_coords[i] \/ 65536.0 ));\n+                      (double)tuple_coords[i] \/ 65536 ));\n@@ -1763,6 +1941,0 @@\n-\n-        FT_TRACE6(( \"      tuple coordinate %.5f fits\\n\",\n-                    tuple_coords[i] \/ 65536.0 ));\n-        apply = FT_MulDiv( apply,\n-                           blend->normalizedcoords[i],\n-                           tuple_coords[i] );\n@@ -1774,2 +1946,2 @@\n-        if ( blend->normalizedcoords[i] <= im_start_coords[i] ||\n-             blend->normalizedcoords[i] >= im_end_coords[i]   )\n+        if ( ncv <= im_start_coords[i] ||\n+             ncv >= im_end_coords[i]   )\n@@ -1779,2 +1951,2 @@\n-                      im_start_coords[i] \/ 65536.0,\n-                      im_end_coords[i] \/ 65536.0 ));\n+                      (double)im_start_coords[i] \/ 65536,\n+                      (double)im_end_coords[i] \/ 65536 ));\n@@ -1786,3 +1958,3 @@\n-                    im_start_coords[i] \/ 65536.0,\n-                    im_end_coords[i] \/ 65536.0 ));\n-        if ( blend->normalizedcoords[i] < tuple_coords[i] )\n+                    (double)im_start_coords[i] \/ 65536,\n+                    (double)im_end_coords[i] \/ 65536 ));\n+        if ( ncv < tuple_coords[i] )\n@@ -1790,1 +1962,1 @@\n-                             blend->normalizedcoords[i] - im_start_coords[i],\n+                             ncv - im_start_coords[i],\n@@ -1792,1 +1964,1 @@\n-        else\n+        else \/* ncv > tuple_coords[i] *\/\n@@ -1794,1 +1966,1 @@\n-                             im_end_coords[i] - blend->normalizedcoords[i],\n+                             im_end_coords[i] - ncv,\n@@ -1799,1 +1971,1 @@\n-    FT_TRACE6(( \"    apply factor is %.5f\\n\", apply \/ 65536.0 ));\n+    FT_TRACE6(( \"    apply factor is %.5f\\n\", (double)apply \/ 65536 ));\n@@ -1813,0 +1985,4 @@\n+    FT_Error   error  = FT_Err_Ok;\n+    FT_Memory  memory = face->root.memory;\n+    FT_UInt    i, j;\n+\n@@ -1815,1 +1991,0 @@\n-    FT_UInt         i, j;\n@@ -1819,0 +1994,3 @@\n+    FT_Fixed*  new_normalized = NULL;\n+    FT_Fixed*  old_normalized;\n+\n@@ -1841,1 +2019,1 @@\n-      FT_TRACE5(( \"    %d: %.5f\\n\", i, coord \/ 65536.0 ));\n+      FT_TRACE5(( \"    %d: %.5f\\n\", i, (double)coord \/ 65536 ));\n@@ -1844,11 +2022,6 @@\n-        FT_TRACE1((\n-          \"ft_var_to_normalized: design coordinate %.5f\\n\"\n-          \"                      is out of range [%.5f;%.5f]; clamping\\n\",\n-          coord \/ 65536.0,\n-          a->minimum \/ 65536.0,\n-          a->maximum \/ 65536.0 ));\n-\n-        if ( coord > a->maximum )\n-          coord = a->maximum;\n-        else\n-          coord = a->minimum;\n+        FT_TRACE1(( \"ft_var_to_normalized: design coordinate %.5f\\n\",\n+                    (double)coord \/ 65536 ));\n+        FT_TRACE1(( \"                      is out of range [%.5f;%.5f];\"\n+                    \" clamping\\n\",\n+                    (double)a->minimum \/ 65536,\n+                    (double)a->maximum \/ 65536 ));\n@@ -1857,5 +2030,3 @@\n-      if ( coord < a->def )\n-        normalized[i] = -FT_DivFix( SUB_LONG( coord, a->def ),\n-                                    SUB_LONG( a->minimum, a->def ) );\n-      else if ( coord > a->def )\n-        normalized[i] = FT_DivFix( SUB_LONG( coord, a->def ),\n+      if ( coord > a->def )\n+        normalized[i] = coord >= a->maximum ?  0x10000L :\n+                        FT_DivFix( SUB_LONG( coord, a->def ),\n@@ -1863,0 +2034,4 @@\n+      else if ( coord < a->def )\n+        normalized[i] = coord <= a->minimum ? -0x10000L :\n+                        FT_DivFix( SUB_LONG( coord, a->def ),\n+                                   SUB_LONG( a->def, a->minimum ) );\n@@ -1872,1 +2047,1 @@\n-    if ( blend->avar_segment )\n+    if ( blend->avar_table )\n@@ -1874,0 +2049,3 @@\n+      GX_AVarTable  table = blend->avar_table;\n+\n+\n@@ -1877,2 +2055,1 @@\n-      av = blend->avar_segment;\n-      for ( i = 0; i < mmvar->num_axis; i++, av++ )\n+      if ( table->avar_segment )\n@@ -1880,1 +2057,3 @@\n-        for ( j = 1; j < (FT_UInt)av->pairCount; j++ )\n+        av = table->avar_segment;\n+\n+        for ( i = 0; i < mmvar->num_axis; i++, av++ )\n@@ -1882,1 +2061,1 @@\n-          if ( normalized[i] < av->correspondence[j].fromCoord )\n+          for ( j = 1; j < (FT_UInt)av->pairCount; j++ )\n@@ -1884,1 +2063,16 @@\n-            FT_TRACE5(( \"  %.5f\\n\", normalized[i] \/ 65536.0 ));\n+            if ( normalized[i] < av->correspondence[j].fromCoord )\n+            {\n+              FT_TRACE5(( \"  %.5f\\n\", (double)normalized[i] \/ 65536 ));\n+\n+              normalized[i] =\n+                FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,\n+                           av->correspondence[j].toCoord -\n+                             av->correspondence[j - 1].toCoord,\n+                           av->correspondence[j].fromCoord -\n+                             av->correspondence[j - 1].fromCoord ) +\n+                av->correspondence[j - 1].toCoord;\n+              break;\n+            }\n+          }\n+        }\n+      }\n@@ -1886,8 +2080,28 @@\n-            normalized[i] =\n-              FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,\n-                         av->correspondence[j].toCoord -\n-                           av->correspondence[j - 1].toCoord,\n-                         av->correspondence[j].fromCoord -\n-                           av->correspondence[j - 1].fromCoord ) +\n-              av->correspondence[j - 1].toCoord;\n-            break;\n+      if ( table->itemStore.varData )\n+      {\n+        if ( FT_QNEW_ARRAY( new_normalized, mmvar->num_axis ) )\n+          return;\n+\n+        \/* Install our half-normalized coordinates for the next *\/\n+        \/* Item Variation Store to work with.                   *\/\n+        old_normalized                = face->blend->normalizedcoords;\n+        face->blend->normalizedcoords = normalized;\n+\n+        for ( i = 0; i < mmvar->num_axis; i++ )\n+        {\n+          FT_Fixed  v          = normalized[i];\n+          FT_UInt   innerIndex = i;\n+          FT_UInt   outerIndex = 0;\n+          FT_Int    delta;\n+\n+\n+          if ( table->axisMap.innerIndex )\n+          {\n+            FT_UInt  idx = i;\n+\n+\n+            if ( idx >= table->axisMap.mapCount )\n+              idx = table->axisMap.mapCount - 1;\n+\n+            outerIndex = table->axisMap.outerIndex[idx];\n+            innerIndex = table->axisMap.innerIndex[idx];\n@@ -1895,0 +2109,14 @@\n+\n+          delta = tt_var_get_item_delta( FT_FACE( face ),\n+                                         &table->itemStore,\n+                                         outerIndex,\n+                                         innerIndex );\n+\n+          \/* Convert delta in F2DOT14 to 16.16 before adding. *\/\n+          v += MUL_INT( delta, 4 );\n+\n+          \/* Clamp value to range [-1, 1]. *\/\n+          v = v >=  0x10000L ?  0x10000 : v;\n+          v = v <= -0x10000L ? -0x10000 : v;\n+\n+          new_normalized[i] = v;\n@@ -1896,0 +2124,9 @@\n+\n+        for ( i = 0; i < mmvar->num_axis; i++ )\n+        {\n+          normalized[i] = new_normalized[i];\n+        }\n+\n+        face->blend->normalizedcoords = old_normalized;\n+\n+        FT_FREE( new_normalized );\n@@ -1933,1 +2170,1 @@\n-    if ( blend->avar_segment )\n+    if ( blend->avar_table && blend->avar_table->avar_segment )\n@@ -1935,1 +2172,1 @@\n-      GX_AVarSegment  av = blend->avar_segment;\n+      GX_AVarSegment  av = blend->avar_table->avar_segment;\n@@ -1955,1 +2192,1 @@\n-            FT_TRACE5(( \"  %.5f\\n\", design[i] \/ 65536.0 ));\n+            FT_TRACE5(( \"  %.5f\\n\", (double)design[i] \/ 65536 ));\n@@ -2036,1 +2273,1 @@\n-  TT_Get_MM_Var( TT_Face      face,\n+  TT_Get_MM_Var( FT_Face      face,    \/* TT_Face *\/\n@@ -2039,2 +2276,3 @@\n-    FT_Stream            stream     = face->root.stream;\n-    FT_Memory            memory     = face->root.memory;\n+    TT_Face              ttface     = (TT_Face)face;\n+    FT_Stream            stream     = FT_FACE_STREAM( face );\n+    FT_Memory            memory     = FT_FACE_MEMORY( face );\n@@ -2052,1 +2290,1 @@\n-    GX_FVar_Head         fvar_head;\n+    GX_FVar_Head         fvar_head  = { 0, 0, 0, 0, 0, 0 };\n@@ -2100,0 +2338,5 @@\n+    \/* `num_instances` holds the number of all named instances including  *\/\n+    \/* the default instance, which might be missing in the table of named *\/\n+    \/* instances (in 'fvar').  This value is validated in `sfobjs.c` and  *\/\n+    \/* may be reset to 0 if consistency checks fail.                      *\/\n+    num_instances = (FT_UInt)face->style_flags >> 16;\n@@ -2104,1 +2347,1 @@\n-    need_init = !face->blend;\n+    need_init = !ttface->blend;\n@@ -2110,6 +2353,1 @@\n-      \/* both `fvar' and `gvar' must be present *\/\n-      if ( FT_SET_ERROR( face->goto_table( face, TTAG_gvar,\n-                                           stream, &table_len ) ) )\n-      {\n-        \/* CFF2 is an alternate to gvar here *\/\n-        if ( FT_SET_ERROR( face->goto_table( face, TTAG_CFF2,\n+      if ( FT_SET_ERROR( ttface->goto_table( ttface, TTAG_fvar,\n@@ -2117,9 +2355,0 @@\n-        {\n-          FT_TRACE1(( \"\\n\"\n-                      \"TT_Get_MM_Var: `gvar' or `CFF2' table is missing\\n\" ));\n-          goto Exit;\n-        }\n-      }\n-\n-      if ( FT_SET_ERROR( face->goto_table( face, TTAG_fvar,\n-                                           stream, &table_len ) ) )\n@@ -2138,0 +2367,11 @@\n+      \/* If `num_instances` is larger, synthetization of the default  *\/\n+      \/* instance is required.  If `num_instances` is smaller,        *\/\n+      \/* however, the value has been reset to 0 in `sfnt_init_face`   *\/\n+      \/* (in `sfobjs.c`); in this case we have underallocated `mmvar` *\/\n+      \/* structs.                                                     *\/\n+      if ( num_instances < fvar_head.instanceCount )\n+      {\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+\n@@ -2147,1 +2387,1 @@\n-      if ( FT_NEW( face->blend ) )\n+      if ( FT_NEW( ttface->blend ) )\n@@ -2150,2 +2390,2 @@\n-      num_axes              = fvar_head.axisCount;\n-      face->blend->num_axis = num_axes;\n+      num_axes                = fvar_head.axisCount;\n+      ttface->blend->num_axis = num_axes;\n@@ -2154,6 +2394,1 @@\n-      num_axes = face->blend->num_axis;\n-\n-    \/* `num_instances' holds the number of all named instances, *\/\n-    \/* including the default instance which might be missing    *\/\n-    \/* in fvar's table of named instances                       *\/\n-    num_instances = (FT_UInt)face->root.style_flags >> 16;\n+      num_axes = ttface->blend->num_axis;\n@@ -2188,8 +2423,8 @@\n-      face->blend->mmvar_len = mmvar_size       +\n-                               axis_flags_size  +\n-                               axis_size        +\n-                               namedstyle_size  +\n-                               next_coords_size +\n-                               next_name_size;\n-\n-      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n+      ttface->blend->mmvar_len = mmvar_size       +\n+                                 axis_flags_size  +\n+                                 axis_size        +\n+                                 namedstyle_size  +\n+                                 next_coords_size +\n+                                 next_name_size;\n+\n+      if ( FT_ALLOC( mmvar, ttface->blend->mmvar_len ) )\n@@ -2197,1 +2432,1 @@\n-      face->blend->mmvar = mmvar;\n+      ttface->blend->mmvar = mmvar;\n@@ -2288,3 +2523,3 @@\n-                    a->minimum \/ 65536.0,\n-                    a->def \/ 65536.0,\n-                    a->maximum \/ 65536.0,\n+                    (double)a->minimum \/ 65536,\n+                    (double)a->def \/ 65536,\n+                    (double)a->maximum \/ 65536,\n@@ -2303,1 +2538,1 @@\n-      if ( FT_NEW_ARRAY( face->blend->normalized_stylecoords,\n+      if ( FT_NEW_ARRAY( ttface->blend->normalized_stylecoords,\n@@ -2307,1 +2542,1 @@\n-      if ( fvar_head.instanceCount && !face->blend->avar_loaded )\n+      if ( fvar_head.instanceCount && !ttface->blend->avar_loaded )\n@@ -2312,1 +2547,1 @@\n-        ft_var_load_avar( face );\n+        ft_var_load_avar( ttface );\n@@ -2318,1 +2553,1 @@\n-      FT_TRACE5(( \"%d instance%s\\n\",\n+      FT_TRACE5(( \"%d named instance%s\\n\",\n@@ -2323,1 +2558,1 @@\n-      nsc = face->blend->normalized_stylecoords;\n+      nsc = ttface->blend->normalized_stylecoords;\n@@ -2346,1 +2581,1 @@\n-          SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+          SFNT_Service  sfnt = (SFNT_Service)ttface->sfnt;\n@@ -2358,1 +2593,1 @@\n-            (void)sfnt->get_name( face,\n+            (void)sfnt->get_name( ttface,\n@@ -2367,1 +2602,1 @@\n-            (void)sfnt->get_name( face,\n+            (void)sfnt->get_name( ttface,\n@@ -2376,1 +2611,1 @@\n-          FT_TRACE5(( \"  instance %d (%s%s%s, %s%s%s)\\n\",\n+          FT_TRACE5(( \"  named instance %d (%s%s%s, %s%s%s)\\n\",\n@@ -2390,1 +2625,1 @@\n-        ft_var_to_normalized( face, num_axes, ns->coords, nsc );\n+        ft_var_to_normalized( ttface, num_axes, ns->coords, nsc );\n@@ -2398,1 +2633,1 @@\n-        SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n+        SFNT_Service  sfnt = (SFNT_Service)ttface->sfnt;\n@@ -2404,3 +2639,5 @@\n-        \/* the default instance is missing in array the   *\/\n-        \/* of named instances; try to synthesize an entry *\/\n-        found = sfnt->get_name_id( face,\n+        \/* The default instance is missing in array the    *\/\n+        \/* of named instances; try to synthesize an entry. *\/\n+        \/* If this fails, `default_named_instance` remains *\/\n+        \/* at value zero, which doesn't do any harm.       *\/\n+        found = sfnt->get_name_id( ttface,\n@@ -2414,1 +2651,1 @@\n-          found = sfnt->get_name_id( face,\n+          found = sfnt->get_name_id( ttface,\n@@ -2424,1 +2661,1 @@\n-          found = sfnt->get_name_id( face,\n+          found = sfnt->get_name_id( ttface,\n@@ -2433,0 +2670,3 @@\n+            \/* named instance indices start with value 1 *\/\n+            ttface->var_default_named_instance = num_instances;\n+\n@@ -2446,1 +2686,1 @@\n-      ft_var_load_mvar( face );\n+      ft_var_load_mvar( ttface );\n@@ -2456,1 +2696,1 @@\n-      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n+      if ( FT_DUP( mmvar, ttface->blend->mmvar, ttface->blend->mmvar_len ) )\n@@ -2458,1 +2698,0 @@\n-      FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );\n@@ -2491,0 +2730,2 @@\n+        else if ( a->tag == TTAG_ital )\n+          a->name = (char*)\"Italic\";\n@@ -2532,1 +2773,1 @@\n-      if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )\n+      if ( FT_SET_ERROR( TT_Get_MM_Var( FT_FACE( face ), NULL ) ) )\n@@ -2547,2 +2788,2 @@\n-    FT_TRACE5(( \"TT_Set_MM_Blend:\\n\"\n-                \"  normalized design coordinates:\\n\" ));\n+    FT_TRACE5(( \"TT_Set_MM_Blend:\\n\" ));\n+    FT_TRACE5(( \"  normalized design coordinates:\\n\" ));\n@@ -2552,1 +2793,1 @@\n-      FT_TRACE5(( \"    %.5f\\n\", coords[i] \/ 65536.0 ));\n+      FT_TRACE5(( \"    %.5f\\n\", (double)coords[i] \/ 65536 ));\n@@ -2555,3 +2796,3 @@\n-        FT_TRACE1(( \"TT_Set_MM_Blend: normalized design coordinate %.5f\\n\"\n-                    \"                 is out of range [-1;1]\\n\",\n-                    coords[i] \/ 65536.0 ));\n+        FT_TRACE1(( \"TT_Set_MM_Blend: normalized design coordinate %.5f\\n\",\n+                    (double)coords[i] \/ 65536 ));\n+        FT_TRACE1(( \"                 is out of range [-1;1]\\n\" ));\n@@ -2566,1 +2807,7 @@\n-      if ( FT_SET_ERROR( ft_var_load_gvar( face ) ) )\n+    {\n+      \/* While a missing 'gvar' table is acceptable, for example for *\/\n+      \/* fonts that only vary metrics information or 'COLR' v1       *\/\n+      \/* `PaintVar*` tables, an incorrect SFNT table offset or size  *\/\n+      \/* for 'gvar', or an inconsistent 'gvar' table is not.         *\/\n+      error = ft_var_load_gvar( face );\n+      if ( error != FT_Err_Table_Missing && error != FT_Err_Ok )\n@@ -2568,0 +2815,2 @@\n+      error = FT_Err_Ok;\n+    }\n@@ -2609,1 +2858,1 @@\n-      if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )\n+      if ( !have_diff )\n@@ -2611,1 +2860,3 @@\n-        FT_UInt  instance_index = (FT_UInt)face->root.face_index >> 16;\n+        if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )\n+        {\n+          FT_UInt  instance_index = (FT_UInt)face->root.face_index >> 16;\n@@ -2614,4 +2865,4 @@\n-        c = blend->normalizedcoords + i;\n-        n = blend->normalized_stylecoords            +\n-            ( instance_index - 1 ) * mmvar->num_axis +\n-            i;\n+          c = blend->normalizedcoords + i;\n+          n = blend->normalized_stylecoords            +\n+              ( instance_index - 1 ) * mmvar->num_axis +\n+              i;\n@@ -2619,10 +2870,11 @@\n-        for ( j = i; j < mmvar->num_axis; j++, n++, c++ )\n-          if ( *c != *n )\n-            have_diff = 1;\n-      }\n-      else\n-      {\n-        c = blend->normalizedcoords + i;\n-        for ( j = i; j < mmvar->num_axis; j++, c++ )\n-          if ( *c != 0 )\n-            have_diff = 1;\n+          for ( j = i; j < mmvar->num_axis; j++, n++, c++ )\n+            if ( *c != *n )\n+              have_diff = 1;\n+        }\n+        else\n+        {\n+          c = blend->normalizedcoords + i;\n+          for ( j = i; j < mmvar->num_axis; j++, c++ )\n+            if ( *c != 0 )\n+              have_diff = 1;\n+        }\n@@ -2655,3 +2907,4 @@\n-    FT_MEM_COPY( blend->normalizedcoords,\n-                 coords,\n-                 num_coords * sizeof ( FT_Fixed ) );\n+    if ( coords )\n+      FT_MEM_COPY( blend->normalizedcoords,\n+                   coords,\n+                   num_coords * sizeof ( FT_Fixed ) );\n@@ -2675,1 +2928,0 @@\n-        face->cvt = NULL;\n@@ -2692,4 +2944,0 @@\n-    \/* enforce recomputation of the PostScript name; *\/\n-    FT_FREE( face->postscript_name );\n-    face->postscript_name = NULL;\n-\n@@ -2727,1 +2975,2 @@\n-   *   FreeType error code.  0 means success.\n+   *   FreeType error code.  0 means success, -1 means success and unchanged\n+   *   axis values.\n@@ -2730,1 +2979,1 @@\n-  TT_Set_MM_Blend( TT_Face    face,\n+  TT_Set_MM_Blend( FT_Face    face,       \/* TT_Face *\/\n@@ -2734,13 +2983,1 @@\n-    FT_Error  error;\n-\n-\n-    error = tt_set_mm_blend( face, num_coords, coords, 1 );\n-    if ( error )\n-      return error;\n-\n-    if ( num_coords )\n-      face->root.face_flags |= FT_FACE_FLAG_VARIATION;\n-    else\n-      face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;\n-\n-    return FT_Err_Ok;\n+    return tt_set_mm_blend( (TT_Face)face, num_coords, coords, 1 );\n@@ -2774,1 +3011,2 @@\n-   *   FreeType error code.  0 means success.\n+   *   FreeType error code.  0 means success, -1 means success and unchanged\n+   *   axis values.\n@@ -2777,1 +3015,1 @@\n-  TT_Get_MM_Blend( TT_Face    face,\n+  TT_Get_MM_Blend( FT_Face    face,       \/* TT_Face *\/\n@@ -2781,0 +3019,2 @@\n+    TT_Face  ttface = (TT_Face)face;\n+\n@@ -2786,1 +3026,1 @@\n-    if ( !face->blend )\n+    if ( !ttface->blend )\n@@ -2792,1 +3032,1 @@\n-    blend = face->blend;\n+    blend = ttface->blend;\n@@ -2798,1 +3038,1 @@\n-      if ( FT_SET_ERROR( tt_set_mm_blend( face, 0, NULL, 1 ) ) )\n+      if ( FT_SET_ERROR( tt_set_mm_blend( ttface, 0, NULL, 1 ) ) )\n@@ -2811,1 +3051,1 @@\n-    if ( face->doblend )\n+    if ( ttface->doblend )\n@@ -2858,1 +3098,1 @@\n-  TT_Set_Var_Design( TT_Face    face,\n+  TT_Set_Var_Design( FT_Face    face,       \/* TT_Face *\/\n@@ -2862,0 +3102,1 @@\n+    TT_Face     ttface = (TT_Face)face;\n@@ -2866,1 +3107,1 @@\n-    FT_Memory   memory = face->root.memory;\n+    FT_Memory   memory = FT_FACE_MEMORY( face );\n@@ -2875,1 +3116,1 @@\n-    if ( !face->blend )\n+    if ( !ttface->blend )\n@@ -2881,1 +3122,1 @@\n-    blend = face->blend;\n+    blend = ttface->blend;\n@@ -2909,1 +3150,1 @@\n-    if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )\n+    if ( FT_IS_NAMED_INSTANCE( face ) )\n@@ -2915,1 +3156,1 @@\n-      instance_index = (FT_UInt)face->root.face_index >> 16;\n+      instance_index = (FT_UInt)face->face_index >> 16;\n@@ -2952,2 +3193,2 @@\n-    if ( !face->blend->avar_loaded )\n-      ft_var_load_avar( face );\n+    if ( !ttface->blend->avar_loaded )\n+      ft_var_load_avar( ttface );\n@@ -2955,3 +3196,3 @@\n-    FT_TRACE5(( \"TT_Set_Var_Design:\\n\"\n-                \"  normalized design coordinates:\\n\" ));\n-    ft_var_to_normalized( face, num_coords, blend->coords, normalized );\n+    FT_TRACE5(( \"TT_Set_Var_Design:\\n\" ));\n+    FT_TRACE5(( \"  normalized design coordinates:\\n\" ));\n+    ft_var_to_normalized( ttface, num_coords, blend->coords, normalized );\n@@ -2959,1 +3200,1 @@\n-    error = tt_set_mm_blend( face, mmvar->num_axis, normalized, 0 );\n+    error = tt_set_mm_blend( ttface, mmvar->num_axis, normalized, 0 );\n@@ -2963,5 +3204,0 @@\n-    if ( num_coords )\n-      face->root.face_flags |= FT_FACE_FLAG_VARIATION;\n-    else\n-      face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;\n-\n@@ -3000,1 +3236,1 @@\n-  TT_Get_Var_Design( TT_Face    face,\n+  TT_Get_Var_Design( FT_Face    face,       \/* TT_Face *\/\n@@ -3004,1 +3240,2 @@\n-    FT_Error  error = FT_Err_Ok;\n+    TT_Face   ttface = (TT_Face)face;\n+    FT_Error  error  = FT_Err_Ok;\n@@ -3009,1 +3246,1 @@\n-    if ( !face->blend )\n+    if ( !ttface->blend )\n@@ -3015,1 +3252,1 @@\n-    blend = face->blend;\n+    blend = ttface->blend;\n@@ -3021,1 +3258,1 @@\n-      if ( FT_SET_ERROR( tt_set_mm_blend( face, 0, NULL, 1 ) ) )\n+      if ( FT_SET_ERROR( tt_set_mm_blend( ttface, 0, NULL, 1 ) ) )\n@@ -3034,1 +3271,1 @@\n-    if ( face->doblend )\n+    if ( ttface->doblend )\n@@ -3070,1 +3307,2 @@\n-   *   FreeType error code.  0~means success.\n+   *   FreeType error code.  0~means success, -1 means success and unchanged\n+   *   axis values.\n@@ -3073,1 +3311,1 @@\n-  TT_Set_Named_Instance( TT_Face  face,\n+  TT_Set_Named_Instance( FT_Face  face,            \/* TT_Face *\/\n@@ -3076,0 +3314,1 @@\n+    TT_Face     ttface = (TT_Face)face;\n@@ -3080,0 +3319,2 @@\n+    FT_Memory  memory = FT_FACE_MEMORY( face );\n+\n@@ -3083,1 +3324,1 @@\n-    if ( !face->blend )\n+    if ( !ttface->blend )\n@@ -3089,1 +3330,1 @@\n-    blend = face->blend;\n+    blend = ttface->blend;\n@@ -3092,1 +3333,1 @@\n-    num_instances = (FT_UInt)face->root.style_flags >> 16;\n+    num_instances = (FT_UInt)face->style_flags >> 16;\n@@ -3103,2 +3344,1 @@\n-      FT_Memory     memory = face->root.memory;\n-      SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;\n+      SFNT_Service  sfnt = (SFNT_Service)ttface->sfnt;\n@@ -3112,1 +3352,1 @@\n-      error = sfnt->get_name( face,\n+      error = sfnt->get_name( ttface,\n@@ -3119,2 +3359,2 @@\n-      FT_FREE( face->root.style_name );\n-      face->root.style_name = style_name;\n+      FT_FREE( face->style_name );\n+      face->style_name = style_name;\n@@ -3126,7 +3366,0 @@\n-      if ( error )\n-      {\n-        \/* internal error code -1 means `no change' *\/\n-        if ( error == -1 )\n-          error = FT_Err_Ok;\n-        goto Exit;\n-      }\n@@ -3135,0 +3368,5 @@\n+    {\n+      \/* restore non-VF style name *\/\n+      FT_FREE( face->style_name );\n+      if ( FT_STRDUP( face->style_name, ttface->non_var_style_name ) )\n+        goto Exit;\n@@ -3136,0 +3374,1 @@\n+    }\n@@ -3137,3 +3376,39 @@\n-    face->root.face_index  = ( instance_index << 16 )             |\n-                             ( face->root.face_index & 0xFFFFL );\n-    face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;\n+  Exit:\n+    return error;\n+  }\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @Function:\n+   *   TT_Get_Default_Named_Instance\n+   *\n+   * @Description:\n+   *   Get the default named instance.\n+   *\n+   * @Input:\n+   *   face ::\n+   *     A handle to the source face.\n+   *\n+   * @Output:\n+   *   instance_index ::\n+   *     The default named instance index.\n+   *\n+   * @Return:\n+   *   FreeType error code.  0~means success.\n+   *\/\n+  FT_LOCAL_DEF( FT_Error )\n+  TT_Get_Default_Named_Instance( FT_Face   face,\n+                                 FT_UInt  *instance_index )\n+  {\n+    TT_Face   ttface = (TT_Face)face;\n+    FT_Error  error  = FT_Err_Ok;\n+\n+\n+    if ( !ttface->blend )\n+    {\n+      if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )\n+        goto Exit;\n+    }\n+\n+    *instance_index = ttface->var_default_named_instance;\n@@ -3146,0 +3421,14 @@\n+  \/* This function triggers (lazy) recomputation of the `postscript_name` *\/\n+  \/* field in `TT_Face`.                                                  *\/\n+\n+  FT_LOCAL_DEF( void )\n+  tt_construct_ps_name( FT_Face  face )\n+  {\n+    TT_Face    ttface = (TT_Face)face;\n+    FT_Memory  memory = FT_FACE_MEMORY( face );\n+\n+\n+    FT_FREE( ttface->postscript_name );\n+  }\n+\n+\n@@ -3155,0 +3444,2 @@\n+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n+\n@@ -3169,0 +3460,3 @@\n+#endif \/* TT_CONFIG_OPTION_BYTECODE_INTERPRETER *\/\n+\n+\n@@ -3197,0 +3491,2 @@\n+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n+\n@@ -3211,3 +3507,4 @@\n-    FT_Fixed*  tuple_coords    = NULL;\n-    FT_Fixed*  im_start_coords = NULL;\n-    FT_Fixed*  im_end_coords   = NULL;\n+    FT_Fixed*  peak_coords = NULL;\n+    FT_Fixed*  tuple_coords;\n+    FT_Fixed*  im_start_coords;\n+    FT_Fixed*  im_end_coords;\n@@ -3232,4 +3529,4 @@\n-      FT_TRACE2(( \"\\n\"\n-                  \"tt_face_vary_cvt: no blend specified\\n\" ));\n-      error = FT_Err_Ok;\n-      goto Exit;\n+      FT_TRACE2(( \"\\n\" ));\n+      FT_TRACE2(( \"tt_face_vary_cvt: no blend specified\\n\" ));\n+\n+      return FT_Err_Ok;\n@@ -3240,4 +3537,4 @@\n-      FT_TRACE2(( \"\\n\"\n-                  \"tt_face_vary_cvt: no `cvt ' table\\n\" ));\n-      error = FT_Err_Ok;\n-      goto Exit;\n+      FT_TRACE2(( \"\\n\" ));\n+      FT_TRACE2(( \"tt_face_vary_cvt: no `cvt ' table\\n\" ));\n+\n+      return FT_Err_Ok;\n@@ -3251,2 +3548,1 @@\n-      error = FT_Err_Ok;\n-      goto Exit;\n+      return FT_Err_Ok;\n@@ -3256,4 +3552,1 @@\n-    {\n-      error = FT_Err_Ok;\n-      goto Exit;\n-    }\n+      return FT_Err_Ok;\n@@ -3272,5 +3565,0 @@\n-    if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||\n-         FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||\n-         FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )\n-      goto FExit;\n-\n@@ -3299,3 +3587,2 @@\n-      sharedpoints = ft_var_readpackedpoints( stream,\n-                                              table_len,\n-                                              &spoint_count );\n+      sharedpoints = ft_var_readpackedpoints( stream, &spoint_count );\n+\n@@ -3312,2 +3599,6 @@\n-    if ( FT_NEW_ARRAY( cvt_deltas, face->cvt_size ) )\n-      goto FExit;\n+    if ( FT_QNEW_ARRAY( peak_coords, 3 * blend->num_axis ) ||\n+         FT_NEW_ARRAY( cvt_deltas, face->cvt_size )        )\n+      goto Exit;\n+\n+    im_start_coords = peak_coords + blend->num_axis;\n+    im_end_coords = im_start_coords + blend->num_axis;\n@@ -3330,1 +3621,2 @@\n-          tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+          peak_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+        tuple_coords = peak_coords;\n@@ -3332,1 +3624,4 @@\n-      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )\n+      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) < blend->tuplecount )\n+        tuple_coords = blend->tuplecoords +\n+            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis;\n+      else\n@@ -3338,18 +3633,1 @@\n-        goto FExit;\n-      }\n-      else\n-      {\n-        if ( !blend->tuplecoords )\n-        {\n-          FT_TRACE2(( \"tt_face_vary_cvt:\"\n-                      \" no valid tuple coordinates available\\n\" ));\n-\n-          error = FT_THROW( Invalid_Table );\n-          goto FExit;\n-        }\n-\n-        FT_MEM_COPY(\n-          tuple_coords,\n-          blend->tuplecoords +\n-            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis,\n-          blend->num_axis * sizeof ( FT_Fixed ) );\n+        goto Exit;\n@@ -3384,3 +3662,1 @@\n-        localpoints = ft_var_readpackedpoints( stream,\n-                                               table_len,\n-                                               &point_count );\n+        localpoints = ft_var_readpackedpoints( stream, &point_count );\n@@ -3391,0 +3667,1 @@\n+        localpoints = NULL;\n@@ -3396,1 +3673,0 @@\n-                                        table_len,\n@@ -3400,3 +3676,1 @@\n-      if ( !points                                                        ||\n-           !deltas                                                        ||\n-           ( localpoints == ALL_POINTS && point_count != face->cvt_size ) )\n+      if ( !points || !deltas )\n@@ -3428,4 +3702,4 @@\n-                        ( FT_fdot6ToFixed( face->cvt[j] ) +\n-                          old_cvt_delta ) \/ 65536.0,\n-                        ( FT_fdot6ToFixed( face->cvt[j] ) +\n-                          cvt_deltas[j] ) \/ 65536.0 ));\n+                        (double)( FT_fdot6ToFixed( face->cvt[j] ) +\n+                                    old_cvt_delta ) \/ 65536,\n+                        (double)( FT_fdot6ToFixed( face->cvt[j] ) +\n+                                    cvt_deltas[j] ) \/ 65536 ));\n@@ -3470,4 +3744,4 @@\n-                        ( FT_fdot6ToFixed( face->cvt[pindex] ) +\n-                          old_cvt_delta ) \/ 65536.0,\n-                        ( FT_fdot6ToFixed( face->cvt[pindex] ) +\n-                          cvt_deltas[pindex] ) \/ 65536.0 ));\n+                        (double)( FT_fdot6ToFixed( face->cvt[pindex] ) +\n+                                    old_cvt_delta ) \/ 65536,\n+                        (double)( FT_fdot6ToFixed( face->cvt[pindex] ) +\n+                                    cvt_deltas[pindex] ) \/ 65536 ));\n@@ -3499,2 +3773,5 @@\n-  FExit:\n-    FT_FRAME_EXIT();\n+    \/* Iterate over all `FT_Size` objects and set `cvt_ready` to -1 *\/\n+    \/* to trigger rescaling of all CVT values.                      *\/\n+    FT_List_Iterate( &root->sizes_list,\n+                     tt_cvt_ready_iterator,\n+                     NULL );\n@@ -3505,3 +3782,0 @@\n-    FT_FREE( tuple_coords );\n-    FT_FREE( im_start_coords );\n-    FT_FREE( im_end_coords );\n@@ -3509,0 +3783,1 @@\n+    FT_FREE( peak_coords );\n@@ -3510,5 +3785,2 @@\n-    \/* iterate over all FT_Size objects and set `cvt_ready' to -1 *\/\n-    \/* to trigger rescaling of all CVT values                     *\/\n-    FT_List_Iterate( &root->sizes_list,\n-                     tt_cvt_ready_iterator,\n-                     NULL );\n+  FExit:\n+    FT_FRAME_EXIT();\n@@ -3517,0 +3789,10 @@\n+\n+#else \/* !TT_CONFIG_OPTION_BYTECODE_INTERPRETER *\/\n+\n+    FT_UNUSED( face );\n+    FT_UNUSED( stream );\n+\n+    return FT_Err_Ok;\n+\n+#endif \/* !TT_CONFIG_OPTION_BYTECODE_INTERPRETER *\/\n+\n@@ -3728,11 +4010,0 @@\n-   * @Input:\n-   *   face ::\n-   *     A handle to the target face object.\n-   *\n-   *   glyph_index ::\n-   *     The index of the glyph being modified.\n-   *\n-   *   n_points ::\n-   *     The number of the points in the glyph, including\n-   *     phantom points.\n-   *\n@@ -3740,0 +4011,3 @@\n+   *   loader ::\n+   *     A handle to the loader object.\n+   *\n@@ -3741,1 +4015,1 @@\n-   *     The outline to change.\n+   *     The outline to change, with appended phantom points.\n@@ -3752,2 +4026,1 @@\n-  TT_Vary_Apply_Glyph_Deltas( TT_Face      face,\n-                              FT_UInt      glyph_index,\n+  TT_Vary_Apply_Glyph_Deltas( TT_Loader    loader,\n@@ -3755,2 +4028,1 @@\n-                              FT_Vector*   unrounded,\n-                              FT_UInt      n_points )\n+                              FT_Vector*   unrounded )\n@@ -3759,2 +4031,5 @@\n-    FT_Stream  stream = face->root.stream;\n-    FT_Memory  memory = stream->memory;\n+    TT_Face    face        = loader->face;\n+    FT_Stream  stream      = face->root.stream;\n+    FT_Memory  memory      = stream->memory;\n+    FT_UInt    glyph_index = loader->glyph_index;\n+    FT_UInt    n_points    = (FT_UInt)outline->n_points + 4;\n@@ -3775,3 +4050,4 @@\n-    FT_Fixed*  tuple_coords    = NULL;\n-    FT_Fixed*  im_start_coords = NULL;\n-    FT_Fixed*  im_end_coords   = NULL;\n+    FT_Fixed*  peak_coords = NULL;\n+    FT_Fixed*  tuple_coords;\n+    FT_Fixed*  im_start_coords;\n+    FT_Fixed*  im_end_coords;\n@@ -3812,5 +4088,0 @@\n-    if ( FT_NEW_ARRAY( points_org, n_points ) ||\n-         FT_NEW_ARRAY( points_out, n_points ) ||\n-         FT_NEW_ARRAY( has_delta, n_points )  )\n-      goto Fail1;\n-\n@@ -3822,1 +4093,1 @@\n-      goto Fail1;\n+      return error;\n@@ -3828,5 +4099,0 @@\n-    if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||\n-         FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||\n-         FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )\n-      goto Fail2;\n-\n@@ -3844,1 +4110,1 @@\n-      goto Fail2;\n+      goto FExit;\n@@ -3855,3 +4121,2 @@\n-      sharedpoints = ft_var_readpackedpoints( stream,\n-                                              blend->gvar_size,\n-                                              &spoint_count );\n+      sharedpoints = ft_var_readpackedpoints( stream, &spoint_count );\n+\n@@ -3868,3 +4133,10 @@\n-    if ( FT_NEW_ARRAY( point_deltas_x, n_points ) ||\n-         FT_NEW_ARRAY( point_deltas_y, n_points ) )\n-      goto Fail3;\n+    if ( FT_QNEW_ARRAY( peak_coords, 3 * blend->num_axis ) ||\n+         FT_NEW_ARRAY( point_deltas_x, 2 * n_points )      ||\n+         FT_QNEW_ARRAY( points_org, n_points )             ||\n+         FT_QNEW_ARRAY( points_out, n_points )             ||\n+         FT_QNEW_ARRAY( has_delta, n_points )              )\n+      goto Exit;\n+\n+    im_start_coords = peak_coords + blend->num_axis;\n+    im_end_coords   = im_start_coords + blend->num_axis;\n+    point_deltas_y  = point_deltas_x + n_points;\n@@ -3893,1 +4165,2 @@\n-          tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+          peak_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );\n+        tuple_coords = peak_coords;\n@@ -3895,1 +4168,4 @@\n-      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )\n+      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) < blend->tuplecount )\n+        tuple_coords = blend->tuplecoords +\n+            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis;\n+      else\n@@ -3901,1 +4177,1 @@\n-        goto Fail3;\n+        goto Exit;\n@@ -3903,6 +4179,0 @@\n-      else\n-        FT_MEM_COPY(\n-          tuple_coords,\n-          blend->tuplecoords +\n-            ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis,\n-          blend->num_axis * sizeof ( FT_Fixed ) );\n@@ -3936,3 +4206,1 @@\n-        localpoints = ft_var_readpackedpoints( stream,\n-                                               blend->gvar_size,\n-                                               &point_count );\n+        localpoints = ft_var_readpackedpoints( stream, &point_count );\n@@ -3948,1 +4216,0 @@\n-                                          blend->gvar_size,\n@@ -3952,1 +4219,0 @@\n-                                          blend->gvar_size,\n@@ -3978,30 +4244,2 @@\n-          if ( j < n_points - 4 )\n-          {\n-            point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-            point_deltas_y[j] = old_point_delta_y + point_delta_y;\n-          }\n-          else\n-          {\n-            \/* To avoid double adjustment of advance width or height, *\/\n-            \/* adjust phantom points only if there is no HVAR or VVAR *\/\n-            \/* support, respectively.                                 *\/\n-            if ( j == ( n_points - 4 )        &&\n-                 !( face->variation_support &\n-                    TT_FACE_FLAG_VAR_LSB    ) )\n-              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-\n-            else if ( j == ( n_points - 3 )          &&\n-                      !( face->variation_support   &\n-                         TT_FACE_FLAG_VAR_HADVANCE ) )\n-              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-\n-            else if ( j == ( n_points - 2 )        &&\n-                      !( face->variation_support &\n-                         TT_FACE_FLAG_VAR_TSB    ) )\n-              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n-\n-            else if ( j == ( n_points - 1 )          &&\n-                      !( face->variation_support   &\n-                         TT_FACE_FLAG_VAR_VADVANCE ) )\n-              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n-          }\n+          point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+          point_deltas_y[j] = old_point_delta_y + point_delta_y;\n@@ -4014,8 +4252,8 @@\n-                        ( FT_intToFixed( outline->points[j].x ) +\n-                          old_point_delta_x ) \/ 65536.0,\n-                        ( FT_intToFixed( outline->points[j].y ) +\n-                          old_point_delta_y ) \/ 65536.0,\n-                        ( FT_intToFixed( outline->points[j].x ) +\n-                          point_deltas_x[j] ) \/ 65536.0,\n-                        ( FT_intToFixed( outline->points[j].y ) +\n-                          point_deltas_y[j] ) \/ 65536.0 ));\n+                        (double)( FT_intToFixed( outline->points[j].x ) +\n+                                    old_point_delta_x ) \/ 65536,\n+                        (double)( FT_intToFixed( outline->points[j].y ) +\n+                                    old_point_delta_y ) \/ 65536,\n+                        (double)( FT_intToFixed( outline->points[j].x ) +\n+                                    point_deltas_x[j] ) \/ 65536,\n+                        (double)( FT_intToFixed( outline->points[j].y ) +\n+                                    point_deltas_y[j] ) \/ 65536 ));\n@@ -4080,30 +4318,2 @@\n-          if ( j < n_points - 4 )\n-          {\n-            point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-            point_deltas_y[j] = old_point_delta_y + point_delta_y;\n-          }\n-          else\n-          {\n-            \/* To avoid double adjustment of advance width or height, *\/\n-            \/* adjust phantom points only if there is no HVAR or VVAR *\/\n-            \/* support, respectively.                                 *\/\n-            if ( j == ( n_points - 4 )        &&\n-                 !( face->variation_support &\n-                    TT_FACE_FLAG_VAR_LSB    ) )\n-              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-\n-            else if ( j == ( n_points - 3 )          &&\n-                      !( face->variation_support   &\n-                         TT_FACE_FLAG_VAR_HADVANCE ) )\n-              point_deltas_x[j] = old_point_delta_x + point_delta_x;\n-\n-            else if ( j == ( n_points - 2 )        &&\n-                      !( face->variation_support &\n-                         TT_FACE_FLAG_VAR_TSB    ) )\n-              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n-\n-            else if ( j == ( n_points - 1 )          &&\n-                      !( face->variation_support   &\n-                         TT_FACE_FLAG_VAR_VADVANCE ) )\n-              point_deltas_y[j] = old_point_delta_y + point_delta_y;\n-          }\n+          point_deltas_x[j] = old_point_delta_x + point_delta_x;\n+          point_deltas_y[j] = old_point_delta_y + point_delta_y;\n@@ -4116,8 +4326,8 @@\n-                        ( FT_intToFixed( outline->points[j].x ) +\n-                          old_point_delta_x ) \/ 65536.0,\n-                        ( FT_intToFixed( outline->points[j].y ) +\n-                          old_point_delta_y ) \/ 65536.0,\n-                        ( FT_intToFixed( outline->points[j].x ) +\n-                          point_deltas_x[j] ) \/ 65536.0,\n-                        ( FT_intToFixed( outline->points[j].y ) +\n-                          point_deltas_y[j] ) \/ 65536.0 ));\n+                        (double)( FT_intToFixed( outline->points[j].x ) +\n+                                    old_point_delta_x ) \/ 65536,\n+                        (double)( FT_intToFixed( outline->points[j].y ) +\n+                                    old_point_delta_y ) \/ 65536,\n+                        (double)( FT_intToFixed( outline->points[j].x ) +\n+                                    point_deltas_x[j] ) \/ 65536,\n+                        (double)( FT_intToFixed( outline->points[j].y ) +\n+                                    point_deltas_y[j] ) \/ 65536 ));\n@@ -4147,0 +4357,18 @@\n+    \/* To avoid double adjustment of advance width or height, *\/\n+    \/* do not move phantom points if there is HVAR or VVAR    *\/\n+    \/* support, respectively.                                 *\/\n+    if ( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE )\n+    {\n+      point_deltas_x[n_points - 4] = 0;\n+      point_deltas_y[n_points - 4] = 0;\n+      point_deltas_x[n_points - 3] = 0;\n+      point_deltas_y[n_points - 3] = 0;\n+    }\n+    if ( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE )\n+    {\n+      point_deltas_x[n_points - 2] = 0;\n+      point_deltas_y[n_points - 2] = 0;\n+      point_deltas_x[n_points - 1] = 0;\n+      point_deltas_y[n_points - 1] = 0;\n+    }\n+\n@@ -4156,3 +4384,17 @@\n-  Fail3:\n-    FT_FREE( point_deltas_x );\n-    FT_FREE( point_deltas_y );\n+    \/* To avoid double adjustment of advance width or height, *\/\n+    \/* adjust phantom points only if there is no HVAR or VVAR *\/\n+    \/* support, respectively.                                 *\/\n+    if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )\n+    {\n+      loader->pp1      = outline->points[n_points - 4];\n+      loader->pp2      = outline->points[n_points - 3];\n+      loader->linear   = FT_PIX_ROUND( unrounded[n_points - 3].x -\n+                                       unrounded[n_points - 4].x ) \/ 64;\n+    }\n+    if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )\n+    {\n+      loader->pp3      = outline->points[n_points - 2];\n+      loader->pp4      = outline->points[n_points - 1];\n+      loader->vadvance = FT_PIX_ROUND( unrounded[n_points - 1].y -\n+                                       unrounded[n_points - 2].y ) \/ 64;\n+    }\n@@ -4160,1 +4402,1 @@\n-  Fail2:\n+  Exit:\n@@ -4163,7 +4405,0 @@\n-    FT_FREE( tuple_coords );\n-    FT_FREE( im_start_coords );\n-    FT_FREE( im_end_coords );\n-\n-    FT_FRAME_EXIT();\n-\n-  Fail1:\n@@ -4173,0 +4408,5 @@\n+    FT_FREE( peak_coords );\n+    FT_FREE( point_deltas_x );\n+\n+  FExit:\n+    FT_FRAME_EXIT();\n@@ -4189,1 +4429,1 @@\n-  tt_get_var_blend( TT_Face      face,\n+  tt_get_var_blend( FT_Face      face,             \/* TT_Face *\/\n@@ -4195,1 +4435,4 @@\n-    if ( face->blend )\n+    TT_Face  ttface = (TT_Face)face;\n+\n+\n+    if ( ttface->blend )\n@@ -4198,1 +4441,1 @@\n-        *num_coords       = face->blend->num_axis;\n+        *num_coords       = ttface->blend->num_axis;\n@@ -4200,1 +4443,1 @@\n-        *coords           = face->blend->coords;\n+        *coords           = ttface->blend->coords;\n@@ -4202,1 +4445,1 @@\n-        *normalizedcoords = face->blend->normalizedcoords;\n+        *normalizedcoords = ttface->blend->normalizedcoords;\n@@ -4204,1 +4447,1 @@\n-        *mm_var           = face->blend->mmvar;\n+        *mm_var           = ttface->blend->mmvar;\n@@ -4220,2 +4463,2 @@\n-  static void\n-  ft_var_done_item_variation_store( TT_Face          face,\n+  FT_LOCAL_DEF( void )\n+  tt_var_done_item_variation_store( FT_Face          face,\n@@ -4249,0 +4492,12 @@\n+  FT_LOCAL_DEF( void )\n+  tt_var_done_delta_set_index_map( FT_Face            face,\n+                                   GX_DeltaSetIdxMap  deltaSetIdxMap )\n+  {\n+    FT_Memory  memory = FT_FACE_MEMORY( face );\n+\n+\n+    FT_FREE( deltaSetIdxMap->innerIndex );\n+    FT_FREE( deltaSetIdxMap->outerIndex );\n+  }\n+\n+\n@@ -4258,1 +4513,1 @@\n-  tt_done_blend( TT_Face  face )\n+  tt_done_blend( FT_Face  face )\n@@ -4260,0 +4515,1 @@\n+    TT_Face    ttface = (TT_Face)face;\n@@ -4261,1 +4517,1 @@\n-    GX_Blend   blend  = face->blend;\n+    GX_Blend   blend  = ttface->blend;\n@@ -4277,1 +4533,1 @@\n-      if ( blend->avar_segment )\n+      if ( blend->avar_table )\n@@ -4279,3 +4535,14 @@\n-        for ( i = 0; i < num_axes; i++ )\n-          FT_FREE( blend->avar_segment[i].correspondence );\n-        FT_FREE( blend->avar_segment );\n+        if ( blend->avar_table->avar_segment )\n+        {\n+          for ( i = 0; i < num_axes; i++ )\n+            FT_FREE( blend->avar_table->avar_segment[i].correspondence );\n+          FT_FREE( blend->avar_table->avar_segment );\n+        }\n+\n+        tt_var_done_item_variation_store( face,\n+                                          &blend->avar_table->itemStore );\n+\n+        tt_var_done_delta_set_index_map( face,\n+                                         &blend->avar_table->axisMap );\n+\n+        FT_FREE( blend->avar_table );\n@@ -4286,1 +4553,1 @@\n-        ft_var_done_item_variation_store( face,\n+        tt_var_done_item_variation_store( face,\n@@ -4289,2 +4556,2 @@\n-        FT_FREE( blend->hvar_table->widthMap.innerIndex );\n-        FT_FREE( blend->hvar_table->widthMap.outerIndex );\n+        tt_var_done_delta_set_index_map( face,\n+                                         &blend->hvar_table->widthMap );\n@@ -4296,1 +4563,1 @@\n-        ft_var_done_item_variation_store( face,\n+        tt_var_done_item_variation_store( face,\n@@ -4299,2 +4566,2 @@\n-        FT_FREE( blend->vvar_table->widthMap.innerIndex );\n-        FT_FREE( blend->vvar_table->widthMap.outerIndex );\n+        tt_var_done_delta_set_index_map( face,\n+                                         &blend->vvar_table->widthMap );\n@@ -4306,1 +4573,1 @@\n-        ft_var_done_item_variation_store( face,\n+        tt_var_done_item_variation_store( face,\n@@ -4322,1 +4589,1 @@\n-  typedef int  _tt_gxvar_dummy;\n+  typedef int  tt_gxvar_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttgxvar.c","additions":1007,"deletions":740,"binary":false,"changes":1747,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2024 by\n@@ -23,0 +23,1 @@\n+#include <freetype\/internal\/ftmmtypes.h>\n@@ -65,43 +66,9 @@\n-  typedef struct  GX_ItemVarDataRec_\n-  {\n-    FT_UInt    itemCount;      \/* number of delta sets per item         *\/\n-    FT_UInt    regionIdxCount; \/* number of region indices in this data *\/\n-    FT_UInt*   regionIndices;  \/* array of `regionCount' indices;       *\/\n-                               \/* these index `varRegionList'           *\/\n-    FT_Short*  deltaSet;       \/* array of `itemCount' deltas           *\/\n-                               \/* use `innerIndex' for this array       *\/\n-\n-  } GX_ItemVarDataRec, *GX_ItemVarData;\n-\n-\n-  \/* contribution of one axis to a region *\/\n-  typedef struct  GX_AxisCoordsRec_\n-  {\n-    FT_Fixed  startCoord;\n-    FT_Fixed  peakCoord;      \/* zero means no effect (factor = 1) *\/\n-    FT_Fixed  endCoord;\n-\n-  } GX_AxisCoordsRec, *GX_AxisCoords;\n-\n-\n-  typedef struct  GX_VarRegionRec_\n-  {\n-    GX_AxisCoords  axisList;               \/* array of axisCount records *\/\n-\n-  } GX_VarRegionRec, *GX_VarRegion;\n-\n-\n-  \/* item variation store *\/\n-  typedef struct  GX_ItemVarStoreRec_\n-  {\n-    FT_UInt         dataCount;\n-    GX_ItemVarData  varData;            \/* array of dataCount records;     *\/\n-                                        \/* use `outerIndex' for this array *\/\n-    FT_UShort     axisCount;\n-    FT_UInt       regionCount;          \/* total number of regions defined *\/\n-    GX_VarRegion  varRegionList;\n-\n-  } GX_ItemVarStoreRec, *GX_ItemVarStore;\n-\n-\n-  typedef struct  GX_DeltaSetIdxMapRec_\n+  \/**************************************************************************\n+   *\n+   * @Struct:\n+   *   GX_AVarTableRec\n+   *\n+   * @Description:\n+   *   Data from the `avar' table.\n+   *\/\n+  typedef struct  GX_AVarTableRec_\n@@ -109,3 +76,3 @@\n-    FT_UInt   mapCount;\n-    FT_UInt*  outerIndex;             \/* indices to item var data *\/\n-    FT_UInt*  innerIndex;             \/* indices to delta set     *\/\n+    GX_AVarSegment        avar_segment;   \/* avar_segment[num_axis] *\/\n+    GX_ItemVarStoreRec    itemStore;      \/* Item Variation Store   *\/\n+    GX_DeltaSetIdxMapRec  axisMap;        \/* Axis Mapping           *\/\n@@ -113,1 +80,1 @@\n-  } GX_DeltaSetIdxMapRec, *GX_DeltaSetIdxMap;\n+  } GX_AVarTableRec, *GX_AVarTable;\n@@ -248,1 +215,1 @@\n-   *   avar_segment ::\n+   *   avar_table ::\n@@ -313,1 +280,1 @@\n-    GX_AVarSegment  avar_segment;                \/* avar_segment[num_axis] *\/\n+    GX_AVarTable    avar_table;\n@@ -379,0 +346,1 @@\n+#define TTAG_ital  FT_MAKE_TAG( 'i', 't', 'a', 'l' )\n@@ -382,1 +350,1 @@\n-  TT_Set_MM_Blend( TT_Face    face,\n+  TT_Set_MM_Blend( FT_Face    face,\n@@ -387,1 +355,1 @@\n-  TT_Get_MM_Blend( TT_Face    face,\n+  TT_Get_MM_Blend( FT_Face    face,\n@@ -392,1 +360,1 @@\n-  TT_Set_Var_Design( TT_Face    face,\n+  TT_Set_Var_Design( FT_Face    face,\n@@ -397,1 +365,1 @@\n-  TT_Get_MM_Var( TT_Face      face,\n+  TT_Get_MM_Var( FT_Face      face,\n@@ -401,1 +369,1 @@\n-  TT_Get_Var_Design( TT_Face    face,\n+  TT_Get_Var_Design( FT_Face    face,\n@@ -406,1 +374,1 @@\n-  TT_Set_Named_Instance( TT_Face  face,\n+  TT_Set_Named_Instance( FT_Face  face,\n@@ -409,0 +377,7 @@\n+  FT_LOCAL( FT_Error )\n+  TT_Get_Default_Named_Instance( FT_Face   face,\n+                                 FT_UInt  *instance_index );\n+\n+  FT_LOCAL( void )\n+  tt_construct_ps_name( FT_Face  face );\n+\n@@ -415,2 +390,1 @@\n-  TT_Vary_Apply_Glyph_Deltas( TT_Face      face,\n-                              FT_UInt      glyph_index,\n+  TT_Vary_Apply_Glyph_Deltas( TT_Loader    loader,\n@@ -418,2 +392,1 @@\n-                              FT_Vector*   unrounded,\n-                              FT_UInt      n_points );\n+                              FT_Vector*   unrounded );\n@@ -422,1 +395,1 @@\n-  tt_hadvance_adjust( TT_Face  face,\n+  tt_hadvance_adjust( FT_Face  face,\n@@ -427,1 +400,1 @@\n-  tt_vadvance_adjust( TT_Face  face,\n+  tt_vadvance_adjust( FT_Face  face,\n@@ -432,1 +405,28 @@\n-  tt_apply_mvar( TT_Face  face );\n+  tt_apply_mvar( FT_Face  face );\n+\n+  FT_LOCAL( FT_Error )\n+  tt_var_load_item_variation_store( FT_Face          face,\n+                                    FT_ULong         offset,\n+                                    GX_ItemVarStore  itemStore );\n+\n+  FT_LOCAL( FT_Error )\n+  tt_var_load_delta_set_index_mapping( FT_Face            face,\n+                                       FT_ULong           offset,\n+                                       GX_DeltaSetIdxMap  map,\n+                                       GX_ItemVarStore    itemStore,\n+                                       FT_ULong           table_len );\n+\n+  FT_LOCAL( FT_ItemVarDelta )\n+  tt_var_get_item_delta( FT_Face          face,\n+                         GX_ItemVarStore  itemStore,\n+                         FT_UInt          outerIndex,\n+                         FT_UInt          innerIndex );\n+\n+  FT_LOCAL( void )\n+  tt_var_done_item_variation_store( FT_Face          face,\n+                                    GX_ItemVarStore  itemStore );\n+\n+  FT_LOCAL( void )\n+  tt_var_done_delta_set_index_map( FT_Face            face,\n+                                   GX_DeltaSetIdxMap  deltaSetIdxMap );\n+\n@@ -435,1 +435,1 @@\n-  tt_get_var_blend( TT_Face      face,\n+  tt_get_var_blend( FT_Face      face,\n@@ -442,1 +442,1 @@\n-  tt_done_blend( TT_Face  face );\n+  tt_done_blend( FT_Face  face );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttgxvar.h","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -32,1 +32,0 @@\n-#include \"ttsubpix.h\"\n@@ -55,6 +54,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-#define SUBPIXEL_HINTING_INFINALITY                                          \\\n-          ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \\\n-            TT_INTERPRETER_VERSION_38 )\n-#endif\n-\n@@ -254,0 +247,8 @@\n+    \/* free glyf cvt working area *\/\n+    FT_FREE( exec->glyfCvt );\n+    exec->glyfCvtSize = 0;\n+\n+    \/* free glyf storage working area *\/\n+    FT_FREE( exec->glyfStorage );\n+    exec->glyfStoreSize = 0;\n+\n@@ -270,109 +271,0 @@\n-  \/**************************************************************************\n-   *\n-   * @Function:\n-   *   Init_Context\n-   *\n-   * @Description:\n-   *   Initializes a context object.\n-   *\n-   * @Input:\n-   *   memory ::\n-   *     A handle to the parent memory object.\n-   *\n-   * @InOut:\n-   *   exec ::\n-   *     A handle to the target execution context.\n-   *\n-   * @Return:\n-   *   FreeType error code.  0 means success.\n-   *\/\n-  static FT_Error\n-  Init_Context( TT_ExecContext  exec,\n-                FT_Memory       memory )\n-  {\n-    FT_Error  error;\n-\n-\n-    FT_TRACE1(( \"Init_Context: new object at %p\\n\", (void *)exec ));\n-\n-    exec->memory   = memory;\n-    exec->callSize = 32;\n-\n-    if ( FT_NEW_ARRAY( exec->callStack, exec->callSize ) )\n-      goto Fail_Memory;\n-\n-    \/* all values in the context are set to 0 already, but this is *\/\n-    \/* here as a remainder                                         *\/\n-    exec->maxPoints   = 0;\n-    exec->maxContours = 0;\n-\n-    exec->stackSize = 0;\n-    exec->glyphSize = 0;\n-\n-    exec->stack    = NULL;\n-    exec->glyphIns = NULL;\n-\n-    exec->face = NULL;\n-    exec->size = NULL;\n-\n-    return FT_Err_Ok;\n-\n-  Fail_Memory:\n-    FT_ERROR(( \"Init_Context: not enough memory for %p\\n\", (void *)exec ));\n-    TT_Done_Context( exec );\n-\n-    return error;\n- }\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @Function:\n-   *   Update_Max\n-   *\n-   * @Description:\n-   *   Checks the size of a buffer and reallocates it if necessary.\n-   *\n-   * @Input:\n-   *   memory ::\n-   *     A handle to the parent memory object.\n-   *\n-   *   multiplier ::\n-   *     The size in bytes of each element in the buffer.\n-   *\n-   *   new_max ::\n-   *     The new capacity (size) of the buffer.\n-   *\n-   * @InOut:\n-   *   size ::\n-   *     The address of the buffer's current size expressed\n-   *     in elements.\n-   *\n-   *   buff ::\n-   *     The address of the buffer base pointer.\n-   *\n-   * @Return:\n-   *   FreeType error code.  0 means success.\n-   *\/\n-  FT_LOCAL_DEF( FT_Error )\n-  Update_Max( FT_Memory  memory,\n-              FT_ULong*  size,\n-              FT_ULong   multiplier,\n-              void*      _pbuff,\n-              FT_ULong   new_max )\n-  {\n-    FT_Error  error;\n-    void**    pbuff = (void**)_pbuff;\n-\n-\n-    if ( *size < new_max )\n-    {\n-      if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )\n-        return error;\n-      *size = new_max;\n-    }\n-\n-    return FT_Err_Ok;\n-  }\n-\n-\n@@ -403,0 +295,2 @@\n+   *\n+   *   Note that not all members of `TT_ExecContext` get initialized.\n@@ -410,1 +304,0 @@\n-    FT_ULong        tmp;\n@@ -413,0 +306,1 @@\n+    FT_Memory       memory = exec->memory;\n@@ -457,8 +351,3 @@\n-    tmp = (FT_ULong)exec->stackSize;\n-    error = Update_Max( exec->memory,\n-                        &tmp,\n-                        sizeof ( FT_F26Dot6 ),\n-                        (void*)&exec->stack,\n-                        maxp->maxStackElements + 32 );\n-    exec->stackSize = (FT_Long)tmp;\n-    if ( error )\n+    if ( FT_QRENEW_ARRAY( exec->stack,\n+                          exec->stackSize,\n+                          maxp->maxStackElements + 32 ) )\n@@ -466,0 +355,1 @@\n+    exec->stackSize = maxp->maxStackElements + 32;\n@@ -467,9 +357,3 @@\n-    tmp = exec->glyphSize;\n-    error = Update_Max( exec->memory,\n-                        &tmp,\n-                        sizeof ( FT_Byte ),\n-                        (void*)&exec->glyphIns,\n-                        maxp->maxSizeOfInstructions );\n-    exec->glyphSize = (FT_UShort)tmp;\n-    if ( error )\n-      return error;\n+    \/* free previous glyph code range *\/\n+    FT_FREE( exec->glyphIns );\n+    exec->glyphSize = 0;\n@@ -612,1 +496,1 @@\n-    \/* allocate object *\/\n+    \/* allocate object and zero everything inside *\/\n@@ -616,4 +500,3 @@\n-    \/* initialize it; in case of error this deallocates `exec' too *\/\n-    error = Init_Context( exec, memory );\n-    if ( error )\n-      goto Fail;\n+    \/* create callStack here, other allocations delayed *\/\n+    exec->memory   = memory;\n+    exec->callSize = 32;\n@@ -621,1 +504,2 @@\n-    return exec;\n+    if ( FT_QNEW_ARRAY( exec->callStack, exec->callSize ) )\n+      FT_FREE( exec );\n@@ -624,1 +508,1 @@\n-    return NULL;\n+    return exec;\n@@ -1575,0 +1459,22 @@\n+  static void\n+  Modify_CVT_Check( TT_ExecContext  exc )\n+  {\n+    if ( exc->iniRange == tt_coderange_glyph &&\n+         exc->cvt != exc->glyfCvt            )\n+    {\n+      FT_Memory  memory = exc->memory;\n+      FT_Error   error;\n+\n+\n+      FT_MEM_QRENEW_ARRAY( exc->glyfCvt, exc->glyfCvtSize, exc->cvtSize );\n+      exc->error = error;\n+      if ( error )\n+        return;\n+\n+      exc->glyfCvtSize = exc->cvtSize;\n+      FT_ARRAY_COPY( exc->glyfCvt, exc->cvt, exc->glyfCvtSize );\n+      exc->cvt = exc->glyfCvt;\n+    }\n+  }\n+\n+\n@@ -1580,0 +1486,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -1589,0 +1499,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -1598,0 +1512,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -1607,0 +1525,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -1759,11 +1681,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY                            &&\n-           ( !exc->ignore_x_mode                                ||\n-             ( exc->sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVE ) ) )\n-        zone->cur[point].x = ADD_LONG( zone->cur[point].x,\n-                                       FT_MulDiv( distance,\n-                                                  v,\n-                                                  exc->F_dot_P ) );\n-      else\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -1875,6 +1786,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY && !exc->ignore_x_mode )\n-      zone->cur[point].x = ADD_LONG( zone->cur[point].x, distance );\n-    else\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -3084,22 +2989,1 @@\n-    {\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      \/* subpixel hinting - avoid Typeman Dstroke and *\/\n-      \/* IStroke and Vacuform rounds                  *\/\n-      if ( SUBPIXEL_HINTING_INFINALITY                 &&\n-           exc->ignore_x_mode                          &&\n-           ( ( I == 24                             &&\n-               ( exc->face->sph_found_func_flags &\n-                 ( SPH_FDEF_SPACING_1 |\n-                   SPH_FDEF_SPACING_2 )          ) ) ||\n-             ( I == 22                      &&\n-               ( exc->sph_in_func_flags   &\n-                 SPH_FDEF_TYPEMAN_STROKES ) )        ||\n-             ( I == 8                              &&\n-               ( exc->face->sph_found_func_flags &\n-                 SPH_FDEF_VACUFORM_ROUND_1       ) &&\n-               exc->iup_called                     ) ) )\n-        args[0] = 0;\n-      else\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-        args[0] = exc->storage[I];\n-    }\n+      args[0] = exc->storage[I];\n@@ -3128,0 +3012,20 @@\n+    {\n+      if ( exc->iniRange == tt_coderange_glyph &&\n+           exc->storage != exc->glyfStorage    )\n+      {\n+        FT_Memory  memory = exc->memory;\n+        FT_Error   error;\n+\n+\n+        FT_MEM_QRENEW_ARRAY( exc->glyfStorage,\n+                             exc->glyfStoreSize,\n+                             exc->storeSize );\n+        exc->error  = error;\n+        if ( error )\n+          return;\n+\n+        exc->glyfStoreSize = exc->storeSize;\n+        FT_ARRAY_COPY( exc->glyfStorage, exc->storage, exc->glyfStoreSize );\n+        exc->storage = exc->glyfStorage;\n+      }\n+\n@@ -3129,0 +3033,1 @@\n+    }\n@@ -3528,1 +3433,1 @@\n-    exc->IP += args[0];\n+    exc->IP = ADD_LONG( exc->IP, args[0] );\n@@ -3598,100 +3503,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    \/* arguments to opcodes are skipped by `SKIP_Code' *\/\n-    FT_Byte    opcode_pattern[9][12] = {\n-                 \/* #0 inline delta function 1 *\/\n-                 {\n-                   0x4B, \/* PPEM    *\/\n-                   0x53, \/* GTEQ    *\/\n-                   0x23, \/* SWAP    *\/\n-                   0x4B, \/* PPEM    *\/\n-                   0x51, \/* LTEQ    *\/\n-                   0x5A, \/* AND     *\/\n-                   0x58, \/* IF      *\/\n-                   0x38, \/*   SHPIX *\/\n-                   0x1B, \/* ELSE    *\/\n-                   0x21, \/*   POP   *\/\n-                   0x21, \/*   POP   *\/\n-                   0x59  \/* EIF     *\/\n-                 },\n-                 \/* #1 inline delta function 2 *\/\n-                 {\n-                   0x4B, \/* PPEM    *\/\n-                   0x54, \/* EQ      *\/\n-                   0x58, \/* IF      *\/\n-                   0x38, \/*   SHPIX *\/\n-                   0x1B, \/* ELSE    *\/\n-                   0x21, \/*   POP   *\/\n-                   0x21, \/*   POP   *\/\n-                   0x59  \/* EIF     *\/\n-                 },\n-                 \/* #2 diagonal stroke function *\/\n-                 {\n-                   0x20, \/* DUP     *\/\n-                   0x20, \/* DUP     *\/\n-                   0xB0, \/* PUSHB_1 *\/\n-                         \/*   1     *\/\n-                   0x60, \/* ADD     *\/\n-                   0x46, \/* GC_cur  *\/\n-                   0xB0, \/* PUSHB_1 *\/\n-                         \/*   64    *\/\n-                   0x23, \/* SWAP    *\/\n-                   0x42  \/* WS      *\/\n-                 },\n-                 \/* #3 VacuFormRound function *\/\n-                 {\n-                   0x45, \/* RCVT    *\/\n-                   0x23, \/* SWAP    *\/\n-                   0x46, \/* GC_cur  *\/\n-                   0x60, \/* ADD     *\/\n-                   0x20, \/* DUP     *\/\n-                   0xB0  \/* PUSHB_1 *\/\n-                         \/*   38    *\/\n-                 },\n-                 \/* #4 TTFautohint bytecode (old) *\/\n-                 {\n-                   0x20, \/* DUP     *\/\n-                   0x64, \/* ABS     *\/\n-                   0xB0, \/* PUSHB_1 *\/\n-                         \/*   32    *\/\n-                   0x60, \/* ADD     *\/\n-                   0x66, \/* FLOOR   *\/\n-                   0x23, \/* SWAP    *\/\n-                   0xB0  \/* PUSHB_1 *\/\n-                 },\n-                 \/* #5 spacing function 1 *\/\n-                 {\n-                   0x01, \/* SVTCA_x *\/\n-                   0xB0, \/* PUSHB_1 *\/\n-                         \/*   24    *\/\n-                   0x43, \/* RS      *\/\n-                   0x58  \/* IF      *\/\n-                 },\n-                 \/* #6 spacing function 2 *\/\n-                 {\n-                   0x01, \/* SVTCA_x *\/\n-                   0x18, \/* RTG     *\/\n-                   0xB0, \/* PUSHB_1 *\/\n-                         \/*   24    *\/\n-                   0x43, \/* RS      *\/\n-                   0x58  \/* IF      *\/\n-                 },\n-                 \/* #7 TypeMan Talk DiagEndCtrl function *\/\n-                 {\n-                   0x01, \/* SVTCA_x *\/\n-                   0x20, \/* DUP     *\/\n-                   0xB0, \/* PUSHB_1 *\/\n-                         \/*   3     *\/\n-                   0x25, \/* CINDEX  *\/\n-                 },\n-                 \/* #8 TypeMan Talk Align *\/\n-                 {\n-                   0x06, \/* SPVTL   *\/\n-                   0x7D, \/* RDTG    *\/\n-                 },\n-               };\n-    FT_UShort  opcode_patterns   = 9;\n-    FT_UShort  opcode_pointer[9] = {  0, 0, 0, 0, 0, 0, 0, 0, 0 };\n-    FT_UShort  opcode_size[9]    = { 12, 8, 8, 6, 7, 4, 5, 4, 2 };\n-    FT_UShort  i;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -3700,1 +3505,1 @@\n-    if ( exc->curRange == tt_coderange_glyph )\n+    if ( exc->iniRange == tt_coderange_glyph )\n@@ -3742,2 +3547,0 @@\n-    rec->inline_delta   = FALSE;\n-    rec->sph_fdef_flags = 0x0000;\n@@ -3748,7 +3551,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    \/* We don't know for sure these are typeman functions, *\/\n-    \/* however they are only active when RS 22 is called   *\/\n-    if ( n >= 64 && n <= 66 )\n-      rec->sph_fdef_flags |= SPH_FDEF_TYPEMAN_STROKES;\n-#endif\n-\n@@ -3760,112 +3556,0 @@\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-      if ( SUBPIXEL_HINTING_INFINALITY )\n-      {\n-        for ( i = 0; i < opcode_patterns; i++ )\n-        {\n-          if ( opcode_pointer[i] < opcode_size[i]                  &&\n-               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )\n-          {\n-            opcode_pointer[i] += 1;\n-\n-            if ( opcode_pointer[i] == opcode_size[i] )\n-            {\n-              FT_TRACE6(( \"sph: Function %d, opcode ptrn: %d, %s %s\\n\",\n-                          i, n,\n-                          exc->face->root.family_name,\n-                          exc->face->root.style_name ));\n-\n-              switch ( i )\n-              {\n-              case 0:\n-                rec->sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_1;\n-                exc->face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_1;\n-                break;\n-\n-              case 1:\n-                rec->sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_2;\n-                exc->face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_2;\n-                break;\n-\n-              case 2:\n-                switch ( n )\n-                {\n-                  \/* needs to be implemented still *\/\n-                case 58:\n-                  rec->sph_fdef_flags             |= SPH_FDEF_DIAGONAL_STROKE;\n-                  exc->face->sph_found_func_flags |= SPH_FDEF_DIAGONAL_STROKE;\n-                }\n-                break;\n-\n-              case 3:\n-                switch ( n )\n-                {\n-                case 0:\n-                  rec->sph_fdef_flags             |= SPH_FDEF_VACUFORM_ROUND_1;\n-                  exc->face->sph_found_func_flags |= SPH_FDEF_VACUFORM_ROUND_1;\n-                }\n-                break;\n-\n-              case 4:\n-                \/* probably not necessary to detect anymore *\/\n-                rec->sph_fdef_flags             |= SPH_FDEF_TTFAUTOHINT_1;\n-                exc->face->sph_found_func_flags |= SPH_FDEF_TTFAUTOHINT_1;\n-                break;\n-\n-              case 5:\n-                switch ( n )\n-                {\n-                case 0:\n-                case 1:\n-                case 2:\n-                case 4:\n-                case 7:\n-                case 8:\n-                  rec->sph_fdef_flags             |= SPH_FDEF_SPACING_1;\n-                  exc->face->sph_found_func_flags |= SPH_FDEF_SPACING_1;\n-                }\n-                break;\n-\n-              case 6:\n-                switch ( n )\n-                {\n-                case 0:\n-                case 1:\n-                case 2:\n-                case 4:\n-                case 7:\n-                case 8:\n-                  rec->sph_fdef_flags             |= SPH_FDEF_SPACING_2;\n-                  exc->face->sph_found_func_flags |= SPH_FDEF_SPACING_2;\n-                }\n-                break;\n-\n-               case 7:\n-                 rec->sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;\n-                 exc->face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;\n-                 break;\n-\n-               case 8:\n-#if 0\n-                 rec->sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;\n-                 exc->face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;\n-#endif\n-                 break;\n-              }\n-              opcode_pointer[i] = 0;\n-            }\n-          }\n-\n-          else\n-            opcode_pointer[i] = 0;\n-        }\n-\n-        \/* Set sph_compatibility_mode only when deltas are detected *\/\n-        exc->face->sph_compatibility_mode =\n-          ( ( exc->face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_1 ) |\n-            ( exc->face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_2 ) );\n-      }\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -3899,4 +3583,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    exc->sph_in_func_flags = 0x0000;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -3990,11 +3670,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY                                    &&\n-         exc->ignore_x_mode                                             &&\n-         ( ( exc->iup_called                                        &&\n-             ( exc->sph_tweak_flags & SPH_TWEAK_NO_CALL_AFTER_IUP ) ) ||\n-           ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 )        ) )\n-      goto Fail;\n-    else\n-      exc->sph_in_func_flags = def->sph_fdef_flags;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -4078,9 +3747,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY                         &&\n-         exc->ignore_x_mode                                  &&\n-         ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 ) )\n-      goto Fail;\n-    else\n-      exc->sph_in_func_flags = def->sph_fdef_flags;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -4136,1 +3796,1 @@\n-    if ( exc->curRange == tt_coderange_glyph )\n+    if ( exc->iniRange == tt_coderange_glyph )\n@@ -4365,1 +4025,1 @@\n-      C = B;   \/* counter clockwise rotation *\/\n+      C = B;   \/* counter-clockwise rotation *\/\n@@ -4992,8 +4652,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    \/* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow *\/\n-    if ( SUBPIXEL_HINTING_INFINALITY &&\n-         exc->ignore_x_mode          &&\n-         FT_ABS( D ) == 64           )\n-      D += 1;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -5053,1 +4705,1 @@\n-      C = B;   \/* counter clockwise rotation *\/\n+      C = B;   \/* counter-clockwise rotation *\/\n@@ -5077,1 +4729,1 @@\n-      C = B;   \/* counter clockwise rotation *\/\n+      C = B;   \/* counter-clockwise rotation *\/\n@@ -5251,4 +4903,2 @@\n-    exc->GS.instruct_control &= ~(FT_Byte)Kf;\n-    exc->GS.instruct_control |= (FT_Byte)L;\n-\n-    if ( K == 3 )\n+    \/* INSTCTRL should only be used in the CVT program *\/\n+    if ( exc->iniRange == tt_coderange_cvt )\n@@ -5256,6 +4906,3 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      \/* INSTCTRL modifying flag 3 also has an effect *\/\n-      \/* outside of the CVT program                   *\/\n-      if ( SUBPIXEL_HINTING_INFINALITY )\n-        exc->ignore_x_mode = FT_BOOL( L == 4 );\n-#endif\n+      exc->GS.instruct_control &= ~(FT_Byte)Kf;\n+      exc->GS.instruct_control |= (FT_Byte)L;\n+    }\n@@ -5263,0 +4910,3 @@\n+    \/* except to change the subpixel flags temporarily *\/\n+    else if ( exc->iniRange == tt_coderange_glyph && K == 3 )\n+    {\n@@ -5271,0 +4921,2 @@\n+    else if ( exc->pedantic_hinting )\n+      exc->error = FT_THROW( Invalid_Reference );\n@@ -5592,6 +5244,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      \/* doesn't follow Cleartype spec but produces better result *\/\n-      if ( SUBPIXEL_HINTING_INFINALITY && exc->ignore_x_mode )\n-        Move_Zp2_Point( exc, point, 0, dy, TRUE );\n-      else\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n@@ -5627,1 +5273,1 @@\n-    FT_Short         contour, bounds;\n+    FT_UShort        contour, bounds;\n@@ -5631,1 +5277,1 @@\n-    contour = (FT_Short)args[0];\n+    contour = (FT_UShort)args[0];\n@@ -5647,2 +5293,1 @@\n-      start = (FT_UShort)( exc->zp2.contours[contour - 1] + 1 -\n-                           exc->zp2.first_point );\n+      start = exc->zp2.contours[contour - 1] + 1 - exc->zp2.first_point;\n@@ -5654,2 +5299,1 @@\n-      limit = (FT_UShort)( exc->zp2.contours[contour] -\n-                           exc->zp2.first_point + 1 );\n+      limit = exc->zp2.contours[contour] + 1 - exc->zp2.first_point;\n@@ -5698,1 +5342,1 @@\n-      limit = (FT_UShort)exc->zp2.n_points;\n+      limit = exc->zp2.n_points;\n@@ -5700,1 +5344,1 @@\n-      limit = (FT_UShort)( exc->zp2.contours[exc->zp2.n_contours - 1] + 1 );\n+      limit = exc->zp2.contours[exc->zp2.n_contours - 1] + 1;\n@@ -5758,70 +5402,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY &&\n-           exc->ignore_x_mode          )\n-      {\n-        FT_Int  B1, B2;\n-\n-\n-        \/*  If not using ignore_x_mode rendering, allow ZP2 move.        *\/\n-        \/*  If inline deltas aren't allowed, skip ZP2 move.              *\/\n-        \/*  If using ignore_x_mode rendering, allow ZP2 point move if:   *\/\n-        \/*   - freedom vector is y and sph_compatibility_mode is off     *\/\n-        \/*   - the glyph is composite and the move is in the Y direction *\/\n-        \/*   - the glyph is specifically set to allow SHPIX moves        *\/\n-        \/*   - the move is on a previously Y-touched point               *\/\n-\n-        \/* save point for later comparison *\/\n-        B1 = exc->zp2.cur[point].y;\n-\n-        if ( exc->face->sph_compatibility_mode )\n-        {\n-          if ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )\n-            dy = FT_PIX_ROUND( B1 + dy ) - B1;\n-\n-          \/* skip post-iup deltas *\/\n-          if ( exc->iup_called                                          &&\n-               ( ( exc->sph_in_func_flags & SPH_FDEF_INLINE_DELTA_1 ) ||\n-                 ( exc->sph_in_func_flags & SPH_FDEF_INLINE_DELTA_2 ) ) )\n-            goto Skip;\n-\n-          if ( !( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) &&\n-                ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||\n-                  ( exc->zp2.tags[point] & FT_CURVE_TAG_TOUCH_Y )    ||\n-                  ( exc->sph_tweak_flags & SPH_TWEAK_DO_SHPIX )      )  )\n-            Move_Zp2_Point( exc, point, 0, dy, TRUE );\n-\n-          \/* save new point *\/\n-          if ( exc->GS.freeVector.y != 0 )\n-          {\n-            B2 = exc->zp2.cur[point].y;\n-\n-            \/* reverse any disallowed moves *\/\n-            if ( ( B1 & 63 ) == 0 &&\n-                 ( B2 & 63 ) != 0 &&\n-                 B1 != B2         )\n-              Move_Zp2_Point( exc, point, 0, NEG_LONG( dy ), TRUE );\n-          }\n-        }\n-        else if ( exc->GS.freeVector.y != 0 )\n-        {\n-          Move_Zp2_Point( exc, point, dx, dy, TRUE );\n-\n-          \/* save new point *\/\n-          B2 = exc->zp2.cur[point].y;\n-\n-          \/* reverse any disallowed moves *\/\n-          if ( ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&\n-               ( B1 & 63 ) != 0                                           &&\n-               ( B2 & 63 ) != 0                                           &&\n-               B1 != B2                                                   )\n-            Move_Zp2_Point( exc,\n-                            point,\n-                            NEG_LONG( dx ),\n-                            NEG_LONG( dy ),\n-                            TRUE );\n-        }\n-        else if ( exc->sph_in_func_flags & SPH_FDEF_TYPEMAN_DIAGENDCTRL )\n-          Move_Zp2_Point( exc, point, dx, dy, TRUE );\n-      }\n-      else\n-#endif\n@@ -5847,3 +5421,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    Skip:\n-#endif\n@@ -5894,22 +5465,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    \/* subpixel hinting - make MSIRP respect CVT cut-in; *\/\n-    if ( SUBPIXEL_HINTING_INFINALITY &&\n-         exc->ignore_x_mode          &&\n-         exc->GS.freeVector.x != 0   )\n-    {\n-      FT_F26Dot6  control_value_cutin = exc->GS.control_value_cutin;\n-      FT_F26Dot6  delta;\n-\n-\n-      if ( !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )\n-        control_value_cutin = 0;\n-\n-      delta = SUB_LONG( distance, args[1] );\n-      if ( delta < 0 )\n-        delta = NEG_LONG( delta );\n-\n-      if ( delta >= control_value_cutin )\n-        distance = args[1];\n-    }\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -5956,8 +5505,1 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY &&\n-           exc->ignore_x_mode          &&\n-           exc->GS.freeVector.x != 0   )\n-        distance = SUB_LONG( Round_None( exc, cur_dist, 3 ), cur_dist );\n-      else\n-#endif\n-        distance = SUB_LONG( exc->func_round( exc, cur_dist, 3 ), cur_dist );\n+      distance = SUB_LONG( exc->func_round( exc, cur_dist, 3 ), cur_dist );\n@@ -6026,8 +5568,1 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      \/* Only adjust if not in sph_compatibility_mode or ignore_x_mode. *\/\n-      \/* Determined via experimentation and may be incorrect...         *\/\n-      if ( !( SUBPIXEL_HINTING_INFINALITY           &&\n-              ( exc->ignore_x_mode                &&\n-                exc->face->sph_compatibility_mode ) ) )\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-        exc->zp0.org[point].x = TT_MulFix14( distance,\n+      exc->zp0.org[point].x = TT_MulFix14( distance,\n@@ -6039,8 +5574,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY                    &&\n-         exc->ignore_x_mode                             &&\n-         ( exc->sph_tweak_flags & SPH_TWEAK_MIAP_HACK ) &&\n-         distance > 0                                   &&\n-         exc->GS.freeVector.y != 0                      )\n-      distance = 0;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n@@ -6056,9 +5583,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY                        &&\n-           exc->ignore_x_mode                                 &&\n-           exc->GS.freeVector.x != 0                          &&\n-           exc->GS.freeVector.y == 0                          &&\n-           !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )\n-        control_value_cutin = 0;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -6072,8 +5590,1 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY &&\n-           exc->ignore_x_mode          &&\n-           exc->GS.freeVector.x != 0   )\n-        distance = Round_None( exc, distance, 3 );\n-      else\n-#endif\n-        distance = exc->func_round( exc, distance, 3 );\n+      distance = exc->func_round( exc, distance, 3 );\n@@ -6172,8 +5683,1 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY &&\n-           exc->ignore_x_mode          &&\n-           exc->GS.freeVector.x != 0   )\n-        distance = Round_None( exc, org_dist, exc->opcode & 3 );\n-      else\n-#endif\n-        distance = exc->func_round( exc, org_dist, exc->opcode & 3 );\n+      distance = exc->func_round( exc, org_dist, exc->opcode & 3 );\n@@ -6191,8 +5695,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY                        &&\n-           exc->ignore_x_mode                                 &&\n-           exc->GS.freeVector.x != 0                          &&\n-           !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )\n-        minimum_distance = 0;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -6341,33 +5837,0 @@\n-    {\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      \/* do cvt cut-in always in MIRP for sph *\/\n-      if ( SUBPIXEL_HINTING_INFINALITY  &&\n-           exc->ignore_x_mode           &&\n-           exc->GS.gep0 == exc->GS.gep1 )\n-      {\n-        FT_F26Dot6  control_value_cutin = exc->GS.control_value_cutin;\n-\n-\n-        if ( exc->GS.freeVector.x != 0                          &&\n-             !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )\n-          control_value_cutin = 0;\n-\n-        if ( exc->GS.freeVector.y != 0                                 &&\n-             ( exc->sph_tweak_flags & SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )\n-        {\n-          if ( cur_dist < -64 )\n-            cvt_dist -= 16;\n-          else if ( cur_dist > 64 && cur_dist < 84 )\n-            cvt_dist += 32;\n-        }\n-\n-        delta = SUB_LONG( cvt_dist, org_dist );\n-        if ( delta < 0 )\n-          delta = NEG_LONG( delta );\n-\n-        if ( delta > control_value_cutin )\n-          cvt_dist = org_dist;\n-      }\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -6375,1 +5838,0 @@\n-    }\n@@ -6384,8 +5846,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-      if ( SUBPIXEL_HINTING_INFINALITY                        &&\n-           exc->ignore_x_mode                                 &&\n-           exc->GS.freeVector.x != 0                          &&\n-           !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )\n-        minimum_distance = 0;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -6404,45 +5858,4 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY &&\n-         exc->ignore_x_mode          &&\n-         exc->GS.freeVector.y != 0   )\n-    {\n-      FT_Int   B1, B2;\n-\n-\n-      B1 = exc->zp1.cur[point].y;\n-\n-      \/* Round moves if necessary *\/\n-      if ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )\n-        distance = FT_PIX_ROUND( B1 + distance - cur_dist ) - B1 + cur_dist;\n-\n-      if ( ( exc->opcode & 16 ) == 0                               &&\n-           ( exc->opcode & 8 ) == 0                                &&\n-           ( exc->sph_tweak_flags & SPH_TWEAK_COURIER_NEW_2_HACK ) )\n-        distance += 64;\n-\n-      exc->func_move( exc,\n-                      &exc->zp1,\n-                      point,\n-                      SUB_LONG( distance, cur_dist ) );\n-\n-      B2 = exc->zp1.cur[point].y;\n-\n-      \/* Reverse move if necessary *\/\n-      if ( ( exc->face->sph_compatibility_mode &&\n-             ( B1 & 63 ) == 0                  &&\n-             ( B2 & 63 ) != 0                  )                          ||\n-           ( ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&\n-             ( B1 & 63 ) != 0                                           &&\n-             ( B2 & 63 ) != 0                                           ) )\n-        exc->func_move( exc,\n-                        &exc->zp1,\n-                        point,\n-                        SUB_LONG( cur_dist, distance ) );\n-    }\n-    else\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-      exc->func_move( exc,\n-                      &exc->zp1,\n-                      point,\n-                      SUB_LONG( distance, cur_dist ) );\n+    exc->func_move( exc,\n+                    &exc->zp1,\n+                    point,\n+                    SUB_LONG( distance, cur_dist ) );\n@@ -6473,11 +5886,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY                               &&\n-         exc->ignore_x_mode                                        &&\n-         exc->iup_called                                           &&\n-         ( exc->sph_tweak_flags & SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )\n-    {\n-      exc->error = FT_THROW( Invalid_Reference );\n-      goto Fail;\n-    }\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -6858,1 +6260,1 @@\n-  _iup_worker_shift( IUP_Worker  worker,\n+  iup_worker_shift_( IUP_Worker  worker,\n@@ -6880,1 +6282,1 @@\n-  _iup_worker_interpolate( IUP_Worker  worker,\n+  iup_worker_interpolate_( IUP_Worker  worker,\n@@ -7042,10 +6444,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY &&\n-         exc->ignore_x_mode          )\n-    {\n-      exc->iup_called = TRUE;\n-      if ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_IUP )\n-        return;\n-    }\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -7074,1 +6466,1 @@\n-            _iup_worker_interpolate( &V,\n+            iup_worker_interpolate_( &V,\n@@ -7086,1 +6478,1 @@\n-          _iup_worker_shift( &V, first_point, end_point, cur_touched );\n+          iup_worker_shift_( &V, first_point, end_point, cur_touched );\n@@ -7089,1 +6481,1 @@\n-          _iup_worker_interpolate( &V,\n+          iup_worker_interpolate_( &V,\n@@ -7096,1 +6488,1 @@\n-            _iup_worker_interpolate( &V,\n+            iup_worker_interpolate_( &V,\n@@ -7124,8 +6516,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    if ( SUBPIXEL_HINTING_INFINALITY                              &&\n-         exc->ignore_x_mode                                       &&\n-         exc->iup_called                                          &&\n-         ( exc->sph_tweak_flags & SPH_TWEAK_NO_DELTAP_AFTER_IUP ) )\n-      goto Fail;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -7184,1 +6568,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n@@ -7186,1 +6569,5 @@\n-          if ( SUBPIXEL_HINTING_INFINALITY )\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+          \/* See `ttinterp.h' for details on backward compatibility *\/\n+          \/* mode.                                                  *\/\n+          if ( SUBPIXEL_HINTING_MINIMAL    &&\n+               exc->backward_compatibility )\n@@ -7188,11 +6575,3 @@\n-            \/*\n-             * Allow delta move if\n-             *\n-             * - not using ignore_x_mode rendering,\n-             * - glyph is specifically set to allow it, or\n-             * - glyph is composite and freedom vector is not in subpixel\n-             *   direction.\n-             *\/\n-            if ( !exc->ignore_x_mode                                   ||\n-                 ( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_DO_DELTAP ) ||\n-                 ( exc->is_composite && exc->GS.freeVector.y != 0 )    )\n+            if ( !( exc->iupx_called && exc->iupy_called )              &&\n+                 ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||\n+                   ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y )        ) )\n@@ -7200,44 +6579,0 @@\n-\n-            \/* Otherwise, apply subpixel hinting and compatibility mode *\/\n-            \/* rules, always skipping deltas in subpixel direction.     *\/\n-            else if ( exc->ignore_x_mode && exc->GS.freeVector.y != 0 )\n-            {\n-              FT_UShort  B1, B2;\n-\n-\n-              \/* save the y value of the point now; compare after move *\/\n-              B1 = (FT_UShort)exc->zp0.cur[A].y;\n-\n-              \/* Standard subpixel hinting: Allow y move for y-touched *\/\n-              \/* points.  This messes up DejaVu ...                    *\/\n-              if ( !exc->face->sph_compatibility_mode          &&\n-                   ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )\n-                exc->func_move( exc, &exc->zp0, A, B );\n-\n-              \/* compatibility mode *\/\n-              else if ( exc->face->sph_compatibility_mode                        &&\n-                        !( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )\n-              {\n-                if ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )\n-                  B = FT_PIX_ROUND( B1 + B ) - B1;\n-\n-                \/* Allow delta move if using sph_compatibility_mode,   *\/\n-                \/* IUP has not been called, and point is touched on Y. *\/\n-                if ( !exc->iup_called                            &&\n-                     ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )\n-                  exc->func_move( exc, &exc->zp0, A, B );\n-              }\n-\n-              B2 = (FT_UShort)exc->zp0.cur[A].y;\n-\n-              \/* Reverse this move if it results in a disallowed move *\/\n-              if ( exc->GS.freeVector.y != 0                          &&\n-                   ( ( exc->face->sph_compatibility_mode          &&\n-                       ( B1 & 63 ) == 0                           &&\n-                       ( B2 & 63 ) != 0                           ) ||\n-                     ( ( exc->sph_tweak_flags                   &\n-                         SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES_DELTAP ) &&\n-                       ( B1 & 63 ) != 0                           &&\n-                       ( B2 & 63 ) != 0                           ) ) )\n-                exc->func_move( exc, &exc->zp0, A, NEG_LONG( B ) );\n-            }\n@@ -7246,16 +6581,0 @@\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-          {\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-            \/* See `ttinterp.h' for details on backward compatibility *\/\n-            \/* mode.                                                  *\/\n-            if ( SUBPIXEL_HINTING_MINIMAL    &&\n-                 exc->backward_compatibility )\n-            {\n-              if ( !( exc->iupx_called && exc->iupy_called )              &&\n-                   ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||\n-                     ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y )        ) )\n-                exc->func_move( exc, &exc->zp0, A, B );\n-            }\n-            else\n@@ -7263,2 +6582,1 @@\n-              exc->func_move( exc, &exc->zp0, A, B );\n-          }\n+            exc->func_move( exc, &exc->zp0, A, B );\n@@ -7367,8 +6685,0 @@\n-   *\n-   * XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May\n-   *      2015) not documented in the OpenType specification.\n-   *\n-   *      Selector bit 11 is incorrectly described as bit 8, while the\n-   *      real meaning of bit 8 (vertical LCD subpixels) stays\n-   *      undocumented.  The same mistake can be found in Greg Hitchcock's\n-   *      whitepaper.\n@@ -7386,25 +6696,2 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    \/*********************************\n-     * RASTERIZER VERSION\n-     * Selector Bit:  0\n-     * Return Bit(s): 0-7\n-     *\/\n-    if ( SUBPIXEL_HINTING_INFINALITY &&\n-         ( args[0] & 1 ) != 0        &&\n-         exc->subpixel_hinting       )\n-    {\n-      if ( exc->ignore_x_mode )\n-      {\n-        \/* if in ClearType backward compatibility mode,         *\/\n-        \/* we sometimes change the TrueType version dynamically *\/\n-        K = exc->rasterizer_version;\n-        FT_TRACE6(( \"Setting rasterizer version %d\\n\",\n-                    exc->rasterizer_version ));\n-      }\n-      else\n-        K = TT_INTERPRETER_VERSION_38;\n-    }\n-    else\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-      if ( ( args[0] & 1 ) != 0 )\n-        K = driver->interpreter_version;\n+    if ( ( args[0] & 1 ) != 0 )\n+      K = driver->interpreter_version;\n@@ -7433,2 +6720,0 @@\n-     *\n-     * XXX: UNDOCUMENTED!\n@@ -7509,83 +6794,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-    if ( SUBPIXEL_HINTING_INFINALITY                          &&\n-         exc->rasterizer_version >= TT_INTERPRETER_VERSION_35 )\n-    {\n-\n-      if ( exc->rasterizer_version >= 37 )\n-      {\n-        \/*********************************\n-         * HINTING FOR SUBPIXEL\n-         * Selector Bit:  6\n-         * Return Bit(s): 13\n-         *\/\n-        if ( ( args[0] & 64 ) != 0 && exc->subpixel_hinting )\n-          K |= 1 << 13;\n-\n-        \/*********************************\n-         * COMPATIBLE WIDTHS ENABLED\n-         * Selector Bit:  7\n-         * Return Bit(s): 14\n-         *\n-         * Functionality still needs to be added\n-         *\/\n-        if ( ( args[0] & 128 ) != 0 && exc->compatible_widths )\n-          K |= 1 << 14;\n-\n-        \/*********************************\n-         * VERTICAL LCD SUBPIXELS?\n-         * Selector Bit:  8\n-         * Return Bit(s): 15\n-         *\n-         * Functionality still needs to be added\n-         *\/\n-        if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd )\n-          K |= 1 << 15;\n-\n-        \/*********************************\n-         * HINTING FOR BGR?\n-         * Selector Bit:  9\n-         * Return Bit(s): 16\n-         *\n-         * Functionality still needs to be added\n-         *\/\n-        if ( ( args[0] & 512 ) != 0 && exc->bgr )\n-          K |= 1 << 16;\n-\n-        if ( exc->rasterizer_version >= 38 )\n-        {\n-          \/*********************************\n-           * SUBPIXEL POSITIONED?\n-           * Selector Bit:  10\n-           * Return Bit(s): 17\n-           *\n-           * Functionality still needs to be added\n-           *\/\n-          if ( ( args[0] & 1024 ) != 0 && exc->subpixel_positioned )\n-            K |= 1 << 17;\n-\n-          \/*********************************\n-           * SYMMETRICAL SMOOTHING\n-           * Selector Bit:  11\n-           * Return Bit(s): 18\n-           *\n-           * Functionality still needs to be added\n-           *\/\n-          if ( ( args[0] & 2048 ) != 0 && exc->symmetrical_smoothing )\n-            K |= 1 << 18;\n-\n-          \/*********************************\n-           * GRAY CLEARTYPE\n-           * Selector Bit:  12\n-           * Return Bit(s): 19\n-           *\n-           * Functionality still needs to be added\n-           *\/\n-          if ( ( args[0] & 4096 ) != 0 && exc->gray_cleartype )\n-            K |= 1 << 19;\n-        }\n-      }\n-    }\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -7726,1 +6928,1 @@\n-  TT_RunIns( TT_ExecContext  exc )\n+  TT_RunIns( void*  exec )\n@@ -7728,0 +6930,2 @@\n+    TT_ExecContext  exc = (TT_ExecContext)exec;\n+\n@@ -7732,42 +6936,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    FT_Byte    opcode_pattern[1][2] = {\n-                  \/* #8 TypeMan Talk Align *\/\n-                  {\n-                    0x06, \/* SPVTL   *\/\n-                    0x7D, \/* RDTG    *\/\n-                  },\n-                };\n-    FT_UShort  opcode_patterns   = 1;\n-    FT_UShort  opcode_pointer[1] = { 0 };\n-    FT_UShort  opcode_size[1]    = { 1 };\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    exc->iup_called = FALSE;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-    \/*\n-     * Toggle backward compatibility according to what font wants, except\n-     * when\n-     *\n-     * 1) we have a `tricky' font that heavily relies on the interpreter to\n-     *    render glyphs correctly, for example DFKai-SB, or\n-     * 2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.\n-     *\n-     * In those cases, backward compatibility needs to be turned off to get\n-     * correct rendering.  The rendering is then completely up to the\n-     * font's programming.\n-     *\n-     *\/\n-    if ( SUBPIXEL_HINTING_MINIMAL          &&\n-         exc->subpixel_hinting_lean        &&\n-         !FT_IS_TRICKY( &exc->face->root ) )\n-      exc->backward_compatibility = !( exc->GS.instruct_control & 4 );\n-    else\n-      exc->backward_compatibility = FALSE;\n-\n-    exc->iupx_called = FALSE;\n-    exc->iupy_called = FALSE;\n-#endif\n@@ -7784,2 +6946,2 @@\n-      FT_TRACE5(( \"TT_RunIns: Resetting number of twilight points\\n\"\n-                  \"           from %d to the more reasonable value %ld\\n\",\n+      FT_TRACE5(( \"TT_RunIns: Resetting number of twilight points\\n\" ));\n+      FT_TRACE5(( \"           from %d to the more reasonable value %ld\\n\",\n@@ -7845,0 +7007,2 @@\n+    exc->iniRange    = exc->curRange;\n+\n@@ -7848,0 +7012,6 @@\n+    \/* These flags cancel execution of some opcodes after IUP is called *\/\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+    exc->iupx_called = FALSE;\n+    exc->iupy_called = FALSE;\n+#endif\n+\n@@ -7853,0 +7023,1 @@\n+      if ( ft_trace_levels[trace_ttinterp] >= 6 )\n@@ -7910,1 +7081,1 @@\n-        \/* this is, calling any of the GX API functions on the current *\/\n+        \/* that is, calling any of the GX API functions on the current *\/\n@@ -7931,33 +7102,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-      if ( SUBPIXEL_HINTING_INFINALITY )\n-      {\n-        for ( i = 0; i < opcode_patterns; i++ )\n-        {\n-          if ( opcode_pointer[i] < opcode_size[i]                  &&\n-               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )\n-          {\n-            opcode_pointer[i] += 1;\n-\n-            if ( opcode_pointer[i] == opcode_size[i] )\n-            {\n-              FT_TRACE6(( \"sph: opcode ptrn: %d, %s %s\\n\",\n-                          i,\n-                          exc->face->root.family_name,\n-                          exc->face->root.style_name ));\n-\n-              switch ( i )\n-              {\n-              case 0:\n-                break;\n-              }\n-              opcode_pointer[i] = 0;\n-            }\n-          }\n-          else\n-            opcode_pointer[i] = 0;\n-        }\n-      }\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -8470,1 +7608,1 @@\n-          \/* this is, calling any of the GX API functions on the current *\/\n+          \/* that is, calling any of the GX API functions on the current *\/\n@@ -8570,1 +7708,4 @@\n-        return FT_THROW( Execution_Too_Long );\n+      {\n+        exc->error = FT_THROW( Execution_Too_Long );\n+        goto LErrorLabel_;\n+      }\n@@ -8589,0 +7730,1 @@\n+\n@@ -8604,1 +7746,1 @@\n-  typedef int  _tt_interp_dummy;\n+  typedef int  tt_interp_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttinterp.c","additions":155,"deletions":1013,"binary":false,"changes":1168,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -101,42 +101,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-  \/**************************************************************************\n-   *\n-   * These structures define rules used to tweak subpixel hinting for\n-   * various fonts.  \"\", 0, \"\", NULL value indicates to match any value.\n-   *\/\n-\n-#define SPH_MAX_NAME_SIZE      32\n-#define SPH_MAX_CLASS_MEMBERS  100\n-\n-  typedef struct  SPH_TweakRule_\n-  {\n-    const char      family[SPH_MAX_NAME_SIZE];\n-    const FT_UInt   ppem;\n-    const char      style[SPH_MAX_NAME_SIZE];\n-    const FT_ULong  glyph;\n-\n-  } SPH_TweakRule;\n-\n-\n-  typedef struct  SPH_ScaleRule_\n-  {\n-    const char      family[SPH_MAX_NAME_SIZE];\n-    const FT_UInt   ppem;\n-    const char      style[SPH_MAX_NAME_SIZE];\n-    const FT_ULong  glyph;\n-    const FT_ULong  scale;\n-\n-  } SPH_ScaleRule;\n-\n-\n-  typedef struct  SPH_Font_Class_\n-  {\n-    const char  name[SPH_MAX_NAME_SIZE];\n-    const char  member[SPH_MAX_CLASS_MEMBERS][SPH_MAX_NAME_SIZE];\n-\n-  } SPH_Font_Class;\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-\n@@ -147,0 +105,3 @@\n+   *\n+   * Members that are initialized by `TT_Load_Context` are marked with '!'.\n+   * Members that are initialized by `TT_Run_Context` are marked with '@'.\n@@ -150,2 +111,2 @@\n-    TT_Face            face;\n-    TT_Size            size;\n+    TT_Face            face;       \/* ! *\/\n+    TT_Size            size;       \/* ! *\/\n@@ -158,1 +119,1 @@\n-    FT_Long            top;        \/* top of exec. stack   *\/\n+    FT_Long            top;        \/* @ top of exec. stack *\/\n@@ -160,2 +121,2 @@\n-    FT_Long            stackSize;  \/* size of exec. stack  *\/\n-    FT_Long*           stack;      \/* current exec. stack  *\/\n+    FT_Long            stackSize;  \/* ! size of exec. stack *\/\n+    FT_Long*           stack;      \/* ! current exec. stack *\/\n@@ -164,1 +125,1 @@\n-    FT_Long            new_top;    \/* new top after exec.  *\/\n+    FT_Long            new_top;    \/* new top after exec. *\/\n@@ -166,5 +127,5 @@\n-    TT_GlyphZoneRec    zp0,        \/* zone records *\/\n-                       zp1,\n-                       zp2,\n-                       pts,\n-                       twilight;\n+    TT_GlyphZoneRec    zp0,        \/* @! zone records *\/\n+                       zp1,        \/* @!              *\/\n+                       zp2,        \/* @!              *\/\n+                       pts,        \/*  !              *\/\n+                       twilight;   \/*  !              *\/\n@@ -172,3 +133,3 @@\n-    FT_Long            pointSize;  \/* in 26.6 format *\/\n-    FT_Size_Metrics    metrics;\n-    TT_Size_Metrics    tt_metrics; \/* size metrics *\/\n+    FT_Long            pointSize;  \/* ! in 26.6 format *\/\n+    FT_Size_Metrics    metrics;    \/* !                *\/\n+    TT_Size_Metrics    tt_metrics; \/* ! size metrics   *\/\n@@ -176,1 +137,1 @@\n-    TT_GraphicsState   GS;         \/* current graphics state *\/\n+    TT_GraphicsState   GS;         \/* !@ current graphics state *\/\n@@ -178,0 +139,1 @@\n+    FT_Int             iniRange;  \/* initial code range number   *\/\n@@ -188,2 +150,4 @@\n-    FT_ULong           cvtSize;\n-    FT_Long*           cvt;\n+    FT_ULong           cvtSize;   \/* ! *\/\n+    FT_Long*           cvt;       \/* ! *\/\n+    FT_ULong           glyfCvtSize;\n+    FT_Long*           glyfCvt;   \/* cvt working copy for glyph *\/\n@@ -191,2 +155,2 @@\n-    FT_UInt            glyphSize; \/* glyph instructions buffer size *\/\n-    FT_Byte*           glyphIns;  \/* glyph instructions buffer *\/\n+    FT_UInt            glyphSize; \/* ! glyph instructions buffer size *\/\n+    FT_Byte*           glyphIns;  \/* ! glyph instructions buffer      *\/\n@@ -194,3 +158,3 @@\n-    FT_UInt            numFDefs;  \/* number of function defs         *\/\n-    FT_UInt            maxFDefs;  \/* maximum number of function defs *\/\n-    TT_DefArray        FDefs;     \/* table of FDefs entries          *\/\n+    FT_UInt            numFDefs;  \/* ! number of function defs         *\/\n+    FT_UInt            maxFDefs;  \/* ! maximum number of function defs *\/\n+    TT_DefArray        FDefs;     \/*   table of FDefs entries          *\/\n@@ -198,3 +162,3 @@\n-    FT_UInt            numIDefs;  \/* number of instruction defs *\/\n-    FT_UInt            maxIDefs;  \/* maximum number of ins defs *\/\n-    TT_DefArray        IDefs;     \/* table of IDefs entries     *\/\n+    FT_UInt            numIDefs;  \/* ! number of instruction defs *\/\n+    FT_UInt            maxIDefs;  \/* ! maximum number of ins defs *\/\n+    TT_DefArray        IDefs;     \/*   table of IDefs entries     *\/\n@@ -202,2 +166,2 @@\n-    FT_UInt            maxFunc;   \/* maximum function index     *\/\n-    FT_UInt            maxIns;    \/* maximum instruction index  *\/\n+    FT_UInt            maxFunc;   \/* ! maximum function index    *\/\n+    FT_UInt            maxIns;    \/* ! maximum instruction index *\/\n@@ -205,3 +169,3 @@\n-    FT_Int             callTop,    \/* top of call stack during execution *\/\n-                       callSize;   \/* size of call stack *\/\n-    TT_CallStack       callStack;  \/* call stack *\/\n+    FT_Int             callTop,    \/* @ top of call stack during execution *\/\n+                       callSize;   \/*   size of call stack                 *\/\n+    TT_CallStack       callStack;  \/*   call stack                         *\/\n@@ -213,2 +177,2 @@\n-    TT_CodeRangeTable  codeRangeTable;  \/* table of valid code ranges *\/\n-                                        \/* useful for the debugger   *\/\n+    TT_CodeRangeTable  codeRangeTable;  \/* ! table of valid code ranges *\/\n+                                        \/*   useful for the debugger    *\/\n@@ -216,2 +180,4 @@\n-    FT_UShort          storeSize;  \/* size of current storage *\/\n-    FT_Long*           storage;    \/* storage area            *\/\n+    FT_UShort          storeSize;    \/* ! size of current storage *\/\n+    FT_Long*           storage;      \/* ! storage area            *\/\n+    FT_UShort          glyfStoreSize;\n+    FT_Long*           glyfStorage;  \/* storage working copy for glyph *\/\n@@ -223,2 +189,2 @@\n-    FT_Bool            instruction_trap; \/* If `True', the interpreter will *\/\n-                                         \/* exit after each instruction     *\/\n+    FT_Bool            instruction_trap; \/* ! If `True', the interpreter   *\/\n+                                         \/*   exits after each instruction *\/\n@@ -241,1 +207,1 @@\n-    TT_Move_Func       func_move;      \/* current point move function *\/\n+    TT_Move_Func       func_move;      \/* current point move function     *\/\n@@ -394,32 +360,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    TT_Round_Func      func_round_sphn;   \/* subpixel rounding function *\/\n-\n-    FT_Bool            subpixel_hinting;  \/* Using subpixel hinting?       *\/\n-    FT_Bool            ignore_x_mode;     \/* Standard rendering mode for   *\/\n-                                          \/* subpixel hinting.  On if gray *\/\n-                                          \/* or subpixel hinting is on.    *\/\n-\n-    \/* The following 6 aren't fully implemented but here for MS rasterizer *\/\n-    \/* compatibility.                                                      *\/\n-    FT_Bool            compatible_widths;     \/* compatible widths?        *\/\n-    FT_Bool            symmetrical_smoothing; \/* symmetrical_smoothing?    *\/\n-    FT_Bool            bgr;                   \/* bgr instead of rgb?       *\/\n-    FT_Bool            vertical_lcd;          \/* long side of LCD subpixel *\/\n-                                              \/* rectangles is horizontal  *\/\n-    FT_Bool            subpixel_positioned;   \/* subpixel positioned       *\/\n-                                              \/* (DirectWrite ClearType)?  *\/\n-    FT_Bool            gray_cleartype;        \/* ClearType hinting but     *\/\n-                                              \/* grayscale rendering       *\/\n-\n-    FT_Int             rasterizer_version;    \/* MS rasterizer version     *\/\n-\n-    FT_Bool            iup_called;            \/* IUP called for glyph?     *\/\n-\n-    FT_ULong           sph_tweak_flags;       \/* flags to control          *\/\n-                                              \/* hint tweaks               *\/\n-\n-    FT_ULong           sph_in_func_flags;     \/* flags to indicate if in   *\/\n-                                              \/* special functions         *\/\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n@@ -455,8 +389,0 @@\n-\n-\n-  FT_LOCAL( FT_Error )\n-  Update_Max( FT_Memory  memory,\n-              FT_ULong*  size,\n-              FT_ULong   multiplier,\n-              void*      _pbuff,\n-              FT_ULong   new_max );\n@@ -472,3 +398,2 @@\n-   *   Queries the face context for a given font.  Note that there is\n-   *   now a _single_ execution context in the TrueType driver which is\n-   *   shared among faces.\n+   *   Create a `TT_ExecContext`.  Note that there is now an execution\n+   *   context per `TT_Size` that is not shared among faces.\n@@ -477,2 +402,2 @@\n-   *   face ::\n-   *     A handle to the source face object.\n+   *   driver ::\n+   *     A handle to the driver, used for memory allocation.\n@@ -481,1 +406,1 @@\n-   *   A handle to the execution context.  Initialized for `face'.\n+   *   A handle to a new empty execution context.\n@@ -532,1 +457,1 @@\n-  TT_RunIns( TT_ExecContext  exec );\n+  TT_RunIns( void*  exec );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttinterp.h","additions":52,"deletions":127,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -118,1 +118,1 @@\n-                    FT_Short      maxContours,\n+                    FT_UShort     maxContours,\n@@ -143,1 +143,27 @@\n-#endif \/* TT_USE_BYTECODE_INTERPRETER *\/\n+\n+\n+  \/*\n+   * Fonts embedded in PDFs are made unique by prepending randomization\n+   * prefixes to their names: as defined in Section 5.5.3, 'Font Subsets',\n+   * of the PDF Reference, they consist of 6 uppercase letters followed by\n+   * the `+` sign.  For safety, we do not skip prefixes violating this rule.\n+   *\/\n+\n+  static const FT_String*\n+  tt_skip_pdffont_random_tag( const FT_String*  name )\n+  {\n+    if ( ft_isupper( name[0] ) &&\n+         ft_isupper( name[1] ) &&\n+         ft_isupper( name[2] ) &&\n+         ft_isupper( name[3] ) &&\n+         ft_isupper( name[4] ) &&\n+         ft_isupper( name[5] ) &&\n+              '+' == name[6]   &&\n+                     name[7]   )\n+    {\n+      FT_TRACE7(( \"name without randomization tag: %s\\n\", name + 7 ));\n+      return name + 7;\n+    }\n+\n+    return name;\n+  }\n@@ -154,1 +180,1 @@\n-#define TRICK_NAMES_COUNT           26\n+#define TRICK_NAMES_COUNT           20\n@@ -174,1 +200,3 @@\n-      \"DFHei-Md-HK-BF\",     \/* maybe DynaLab Inc. *\/\n+      \"DFHei\",              \/* DynaLab Inc. 1992-1995 [DFHei-Bd-WIN-HK-BF] *\/\n+                            \/* covers \"DFHei-Md-HK-BF\", maybe DynaLab Inc. *\/\n+\n@@ -179,2 +207,1 @@\n-      \"DFKaiShu\",\n-      \"DFKaiShu-Md-HK-BF\",  \/* maybe DynaLab Inc. *\/\n+      \"DFKaiShu\",           \/* covers \"DFKaiShu-Md-HK-BF\", maybe DynaLab Inc. *\/\n@@ -182,1 +209,4 @@\n-      \"DFMing-Bd-HK-BF\",    \/* maybe DynaLab Inc. *\/\n+\n+      \"DFMing\",             \/* DynaLab Inc. 1992-1995 [DFMing-Md-WIN-HK-BF] *\/\n+                            \/* covers \"DFMing-Bd-HK-BF\", maybe DynaLab Inc. *\/\n+\n@@ -185,5 +215,7 @@\n-      \"DLCHayMedium\",       \/* dftt-b5.ttf; version 1.00, 1993 *\/\n-      \"DLCHayBold\",         \/* dftt-b7.ttf; version 1.00, 1993 *\/\n-      \"DLCKaiMedium\",       \/* dftt-k5.ttf; version 1.00, 1992 *\/\n-      \"DLCLiShu\",           \/* dftt-l5.ttf; version 1.00, 1992 *\/\n-      \"DLCRoundBold\",       \/* dftt-r7.ttf; version 1.00, 1993 *\/\n+                            \/* covers following *\/\n+                            \/* \"DLCHayMedium\", dftt-b5.ttf; version 1.00, 1993 *\/\n+                            \/* \"DLCHayBold\",   dftt-b7.ttf; version 1.00, 1993 *\/\n+                            \/* \"DLCKaiMedium\", dftt-k5.ttf; version 1.00, 1992 *\/\n+                            \/* \"DLCLiShu\",     dftt-l5.ttf; version 1.00, 1992 *\/\n+                            \/* \"DLCRoundBold\", dftt-r7.ttf; version 1.00, 1993 *\/\n+\n@@ -202,0 +234,1 @@\n+    const FT_String*  name_without_tag;\n@@ -204,0 +237,1 @@\n+    name_without_tag = tt_skip_pdffont_random_tag( name );\n@@ -205,1 +239,1 @@\n-      if ( ft_strstr( name, trick_names[nn] ) )\n+      if ( ft_strstr( name_without_tag, trick_names[nn] ) )\n@@ -225,1 +259,2 @@\n-    FT_UInt    i;\n+    FT_Byte*   p;\n+    FT_Int     shift;\n@@ -231,0 +266,2 @@\n+    p = (FT_Byte*)stream->cursor;\n+\n@@ -232,1 +269,1 @@\n-      checksum += (FT_UInt32)FT_GET_ULONG();\n+      checksum += FT_NEXT_ULONG( p );\n@@ -234,2 +271,2 @@\n-    for ( i = 3; length > 0; length--, i-- )\n-      checksum += (FT_UInt32)FT_GET_BYTE() << ( i * 8 );\n+    for ( shift = 24; length > 0; length--, shift -=8 )\n+      checksum += (FT_UInt32)FT_NEXT_BYTE( p ) << shift;\n@@ -280,1 +317,1 @@\n-#define TRICK_SFNT_IDS_NUM_FACES  29\n+#define TRICK_SFNT_IDS_NUM_FACES  31\n@@ -283,1 +320,2 @@\n-                                       [TRICK_SFNT_IDS_PER_FACE] = {\n+                                       [TRICK_SFNT_IDS_PER_FACE] =\n+    {\n@@ -433,0 +471,10 @@\n+      },\n+        { \/* DFHei-Bd-WIN-HK-BF, issue #1087 *\/\n+        { 0x1269EB58UL, 0x00000350UL }, \/* cvt  *\/\n+        { 0x5CD5957AUL, 0x00006A4EUL }, \/* fpgm *\/\n+        { 0xF758323AUL, 0x00000380UL }  \/* prep *\/\n+      },\n+        { \/* DFMing-Md-WIN-HK-BF, issue #1087 *\/\n+        { 0x122FEB0BUL, 0x00000350UL }, \/* cvt  *\/\n+        { 0x7F10919AUL, 0x000070A9UL }, \/* fpgm *\/\n+        { 0x7CD7E7B7UL, 0x0000025CUL }  \/* prep *\/\n@@ -513,0 +561,3 @@\n+    {\n+      FT_TRACE3(( \"found as a tricky font\"\n+                  \" by its family name: %s\\n\", face->family_name ));\n@@ -514,0 +565,1 @@\n+    }\n@@ -519,0 +571,3 @@\n+    {\n+      FT_TRACE3(( \"found as a tricky font\"\n+                  \" by its cvt\/fpgm\/prep table checksum\\n\" ));\n@@ -520,0 +575,1 @@\n+    }\n@@ -524,0 +580,2 @@\n+#endif \/* TT_USE_BYTECODE_INTERPRETER *\/\n+\n@@ -532,1 +590,1 @@\n-    FT_UInt   asize;\n+    FT_ULong  asize;\n@@ -540,1 +598,1 @@\n-      tt_face_get_location( face, i, &asize );\n+      tt_face_get_location( ttface, i, &asize );\n@@ -669,0 +727,1 @@\n+#ifdef TT_USE_BYTECODE_INTERPRETER\n@@ -671,0 +730,1 @@\n+#endif\n@@ -676,1 +736,2 @@\n-    if ( FT_IS_SCALABLE( ttface ) )\n+    if ( FT_IS_SCALABLE( ttface ) ||\n+         FT_HAS_SBIX( ttface )    )\n@@ -715,2 +776,2 @@\n-                      \" Only the `.notdef' glyph has an outline.\\n\"\n-                      \"             \"\n+                      \" Only the `.notdef' glyph has an outline.\\n\" ));\n+          FT_TRACE5(( \"             \"\n@@ -725,1 +786,0 @@\n-\n@@ -730,2 +790,1 @@\n-      if ( FT_HAS_MULTIPLE_MASTERS( ttface ) &&\n-           instance_index > 0                )\n+      if ( FT_HAS_MULTIPLE_MASTERS( ttface ) )\n@@ -733,1 +792,1 @@\n-        error = TT_Set_Named_Instance( face, instance_index );\n+        error = FT_Set_Named_Instance( ttface, instance_index );\n@@ -736,2 +795,0 @@\n-\n-        tt_apply_mvar( face );\n@@ -740,1 +797,0 @@\n-\n@@ -806,1 +862,1 @@\n-    tt_done_blend( face );\n+    tt_done_blend( ttface );\n@@ -941,3 +997,0 @@\n-    \/* unscaled CVT values are already stored in 26.6 format *\/\n-    FT_Fixed  scale = size->ttmetrics.scale >> 6;\n-\n@@ -950,1 +1003,4 @@\n-      size->cvt[i] = FT_MulFix( face->cvt[i], scale );\n+      \/* Unscaled CVT values are already stored in 26.6 format.            *\/\n+      \/* Note that this scaling operation is very sensitive to rounding;   *\/\n+      \/* the integer division by 64 must be applied to the first argument. *\/\n+      size->cvt[i] = FT_MulFix( face->cvt[i] \/ 64, size->ttmetrics.scale );\n@@ -952,1 +1008,1 @@\n-                  i, face->cvt[i] \/ 64.0, size->cvt[i] \/ 64.0 ));\n+                  i, (double)face->cvt[i] \/ 64, (double)size->cvt[i] \/ 64 ));\n@@ -1193,1 +1249,1 @@\n-      FT_UInt  i;\n+      FT_UShort  i;\n@@ -1197,1 +1253,1 @@\n-      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )\n+      for ( i = 0; i < size->twilight.n_points; i++ )\n@@ -1206,1 +1262,1 @@\n-      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )\n+      for ( i = 0; i < size->storage_size; i++ )\n@@ -1286,1 +1342,1 @@\n-   *   tt_size_reset\n+   *   tt_size_reset_height\n@@ -1289,2 +1345,3 @@\n-   *   Reset a TrueType size when resolutions and character dimensions\n-   *   have been changed.\n+   *   Recompute a TrueType size's ascender, descender, and height\n+   *   when resolutions and character dimensions have been changed.\n+   *   Used for variation fonts as an iterator function.\n@@ -1293,7 +1350,5 @@\n-   *   size ::\n-   *     A handle to the target size object.\n-   *\n-   *   only_height ::\n-   *     Only recompute ascender, descender, and height;\n-   *     this flag is used for variation fonts where\n-   *     `tt_size_reset' is used as an iterator function.\n+   *   ft_size ::\n+   *     A handle to the target TT_Size object. This function will be called\n+   *     through a `FT_Size_Reset_Func` pointer which takes `FT_Size`. This\n+   *     function must take `FT_Size` as a result. The passed `FT_Size` is\n+   *     expected to point to a `TT_Size`.\n@@ -1302,2 +1357,1 @@\n-  tt_size_reset( TT_Size  size,\n-                 FT_Bool  only_height )\n+  tt_size_reset_height( FT_Size  ft_size )\n@@ -1305,9 +1359,3 @@\n-    TT_Face           face;\n-    FT_Size_Metrics*  size_metrics;\n-\n-\n-    face = (TT_Face)size->root.face;\n-\n-    \/* nothing to do for CFF2 *\/\n-    if ( face->is_cff2 )\n-      return FT_Err_Ok;\n+    TT_Size           size         = (TT_Size)ft_size;\n+    TT_Face           face         = (TT_Face)size->root.face;\n+    FT_Size_Metrics*  size_metrics = &size->hinted_metrics;\n@@ -1317,2 +1365,0 @@\n-    size_metrics = &size->hinted_metrics;\n-\n@@ -1345,6 +1391,28 @@\n-    if ( only_height )\n-    {\n-      \/* we must not recompute the scaling values here since       *\/\n-      \/* `tt_size_reset' was already called (with only_height = 0) *\/\n-      return FT_Err_Ok;\n-    }\n+    return FT_Err_Ok;\n+  }\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @Function:\n+   *   tt_size_reset\n+   *\n+   * @Description:\n+   *   Reset a TrueType size when resolutions and character dimensions\n+   *   have been changed.\n+   *\n+   * @Input:\n+   *   size ::\n+   *     A handle to the target size object.\n+   *\/\n+  FT_LOCAL_DEF( FT_Error )\n+  tt_size_reset( TT_Size  size )\n+  {\n+    FT_Error          error;\n+    TT_Face           face         = (TT_Face)size->root.face;\n+    FT_Size_Metrics*  size_metrics = &size->hinted_metrics;\n+\n+\n+    error = tt_size_reset_height( (FT_Size)size );\n+    if ( error )\n+      return error;\n@@ -1384,0 +1452,2 @@\n+    size->widthp = tt_face_get_device_metrics( face, size_metrics->x_ppem, 0 );\n+\n@@ -1418,3 +1488,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    driver->interpreter_version = TT_INTERPRETER_VERSION_38;\n-#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttobjs.c","additions":140,"deletions":73,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -108,1 +108,1 @@\n-                    FT_Short      maxContours,\n+                    FT_UShort     maxContours,\n@@ -165,2 +165,0 @@\n-    FT_Bool   inline_delta;   \/* is function that defines inline delta? *\/\n-    FT_ULong  sph_fdef_flags; \/* flags to identify special functions    *\/\n@@ -285,0 +283,2 @@\n+    FT_Byte*           widthp;          \/* glyph widths from the hdmx table *\/\n+\n@@ -392,2 +392,4 @@\n-  tt_size_reset( TT_Size  size,\n-                 FT_Bool  only_height );\n+  tt_size_reset_height( FT_Size  size );\n+\n+  FT_LOCAL( FT_Error )\n+  tt_size_reset( TT_Size  size );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttobjs.h","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -101,3 +101,1 @@\n-    if ( face->header.Index_To_Loc_Format != 0 )\n-    {\n-      shift = 2;\n+    shift = face->header.Index_To_Loc_Format != 0 ? 2 : 1;\n@@ -105,8 +103,1 @@\n-      if ( table_len >= 0x40000L )\n-      {\n-        FT_TRACE2(( \"table too large\\n\" ));\n-        table_len = 0x3FFFFL;\n-      }\n-      face->num_locations = table_len >> shift;\n-    }\n-    else\n+    if ( table_len > 0x10000UL << shift )\n@@ -114,8 +105,2 @@\n-      shift = 1;\n-\n-      if ( table_len >= 0x20000L )\n-      {\n-        FT_TRACE2(( \"table too large\\n\" ));\n-        table_len = 0x1FFFFL;\n-      }\n-      face->num_locations = table_len >> shift;\n+      FT_TRACE2(( \"table too large\\n\" ));\n+      table_len = 0x10000UL << shift;\n@@ -124,0 +109,2 @@\n+    face->num_locations = table_len >> shift;\n+\n@@ -130,1 +117,1 @@\n-      if ( face->num_locations <= (FT_ULong)face->root.num_glyphs )\n+      if ( face->num_locations < (FT_ULong)face->root.num_glyphs + 1 )\n@@ -196,3 +183,3 @@\n-  tt_face_get_location( TT_Face   face,\n-                        FT_UInt   gindex,\n-                        FT_UInt  *asize )\n+  tt_face_get_location( FT_Face    face,   \/* TT_Face *\/\n+                        FT_UInt    gindex,\n+                        FT_ULong  *asize )\n@@ -200,0 +187,1 @@\n+    TT_Face   ttface = (TT_Face)face;\n@@ -207,1 +195,1 @@\n-    if ( gindex < face->num_locations )\n+    if ( gindex < ttface->num_locations )\n@@ -209,1 +197,1 @@\n-      if ( face->header.Index_To_Loc_Format != 0 )\n+      if ( ttface->header.Index_To_Loc_Format != 0 )\n@@ -211,2 +199,2 @@\n-        p       = face->glyph_locations + gindex * 4;\n-        p_limit = face->glyph_locations + face->num_locations * 4;\n+        p       = ttface->glyph_locations + gindex * 4;\n+        p_limit = ttface->glyph_locations + ttface->num_locations * 4;\n@@ -222,2 +210,2 @@\n-        p       = face->glyph_locations + gindex * 2;\n-        p_limit = face->glyph_locations + face->num_locations * 2;\n+        p       = ttface->glyph_locations + gindex * 2;\n+        p_limit = ttface->glyph_locations + ttface->num_locations * 2;\n@@ -237,1 +225,1 @@\n-    if ( pos1 > face->glyf_len )\n+    if ( pos1 > ttface->glyf_len )\n@@ -240,2 +228,3 @@\n-                  \" too large offset (0x%08lx) found for glyph index %d,\\n\"\n-                  \"                     \"\n+                  \" too large offset (0x%08lx) found for glyph index %d,\\n\",\n+                  pos1, gindex ));\n+      FT_TRACE1(( \"                     \"\n@@ -243,1 +232,1 @@\n-                  pos1, gindex, face->glyf_len ));\n+                  ttface->glyf_len ));\n@@ -248,1 +237,1 @@\n-    if ( pos2 > face->glyf_len )\n+    if ( pos2 > ttface->glyf_len )\n@@ -251,1 +240,1 @@\n-      if ( gindex == face->num_locations - 2 )\n+      if ( gindex == ttface->num_locations - 2 )\n@@ -254,2 +243,3 @@\n-                    \" too large size (%ld bytes) found for glyph index %d,\\n\"\n-                    \"                     \"\n+                    \" too large size (%ld bytes) found for glyph index %d,\\n\",\n+                    pos2 - pos1, gindex ));\n+        FT_TRACE1(( \"                     \"\n@@ -257,2 +247,2 @@\n-                    pos2 - pos1, gindex, face->glyf_len - pos1 ));\n-        pos2 = face->glyf_len;\n+                    ttface->glyf_len - pos1 ));\n+        pos2 = ttface->glyf_len;\n@@ -263,2 +253,3 @@\n-                    \" too large offset (0x%08lx) found for glyph index %d,\\n\"\n-                    \"                     \"\n+                    \" too large offset (0x%08lx) found for glyph index %d,\\n\",\n+                    pos2, gindex + 1 ));\n+        FT_TRACE1(( \"                     \"\n@@ -266,1 +257,1 @@\n-                    pos2, gindex + 1, face->glyf_len ));\n+                    ttface->glyf_len ));\n@@ -281,1 +272,1 @@\n-      *asize = (FT_UInt)( pos2 - pos1 );\n+      *asize = (FT_ULong)( pos2 - pos1 );\n@@ -283,1 +274,1 @@\n-      *asize = (FT_UInt)( face->glyf_len - pos1 );\n+      *asize = (FT_ULong)( ttface->glyf_len - pos1 );\n@@ -347,1 +338,1 @@\n-    if ( FT_NEW_ARRAY( face->cvt, face->cvt_size ) )\n+    if ( FT_QNEW_ARRAY( face->cvt, face->cvt_size ) )\n@@ -511,0 +502,8 @@\n+  FT_COMPARE_DEF( int )\n+  compare_ppem( const void*  a,\n+                const void*  b )\n+  {\n+    return **(FT_Byte**)a - **(FT_Byte**)b;\n+  }\n+\n+\n@@ -560,6 +559,0 @@\n-    \/* The maximum number of bytes in an hdmx device record is the *\/\n-    \/* maximum number of glyphs + 2; this is 0xFFFF + 2, thus      *\/\n-    \/* explaining why `record_size' is a long (which we read as    *\/\n-    \/* unsigned long for convenience).  In practice, two bytes are *\/\n-    \/* sufficient to hold the size value.                          *\/\n-    \/*                                                             *\/\n@@ -574,0 +567,2 @@\n+    FT_TRACE2(( \"Hdmx \" ));\n+\n@@ -575,4 +570,9 @@\n-    if ( num_records > 255              ||\n-         ( num_records > 0            &&\n-           ( record_size > 0x10001L ||\n-             record_size < 4        ) ) )\n+    if ( num_records > 255 || num_records == 0 )\n+    {\n+      FT_TRACE2(( \"with unreasonable %u records rejected\\n\", num_records ));\n+      goto Fail;\n+    }\n+\n+    \/* Out-of-spec tables are rejected.  The record size must be *\/\n+    \/* equal to the number of glyphs + 2 + 32-bit padding.       *\/\n+    if ( (FT_Long)record_size != ( ( face->root.num_glyphs + 2 + 3 ) & ~3 ) )\n@@ -580,1 +580,3 @@\n-      error = FT_THROW( Invalid_File_Format );\n+      FT_TRACE2(( \"with record size off by %ld bytes rejected\\n\",\n+                  (FT_Long)record_size -\n+                    ( ( face->root.num_glyphs + 2 + 3 ) & ~3 ) ));\n@@ -584,1 +586,1 @@\n-    if ( FT_NEW_ARRAY( face->hdmx_record_sizes, num_records ) )\n+    if ( FT_QNEW_ARRAY( face->hdmx_records, num_records ) )\n@@ -591,3 +593,2 @@\n-\n-      face->hdmx_record_sizes[nn] = p[0];\n-      p                          += record_size;\n+      face->hdmx_records[nn] = p;\n+      p                     += record_size;\n@@ -596,0 +597,4 @@\n+    \/* The records must be already sorted by ppem but it does not *\/\n+    \/* hurt to make sure so that the binary search works later.   *\/\n+    ft_qsort( face->hdmx_records, nn, sizeof ( FT_Byte* ), compare_ppem );\n+\n@@ -600,0 +605,2 @@\n+    FT_TRACE2(( \"%ux%lu loaded\\n\", num_records, record_size ));\n+\n@@ -617,1 +624,1 @@\n-    FT_FREE( face->hdmx_record_sizes );\n+    FT_FREE( face->hdmx_records );\n@@ -625,1 +632,2 @@\n-   * in the font's `hdmx' table (if any).\n+   * in the font's `hdmx' table (if any).  The records must be sorted for\n+   * the binary search to work properly.\n@@ -632,4 +640,5 @@\n-    FT_UInt   nn;\n-    FT_Byte*  result      = NULL;\n-    FT_ULong  record_size = face->hdmx_record_size;\n-    FT_Byte*  record      = FT_OFFSET( face->hdmx_table, 8 );\n+    FT_UInt   min    = 0;\n+    FT_UInt   max    = face->hdmx_record_count;\n+    FT_UInt   mid;\n+    FT_Byte*  result = NULL;\n+\n@@ -637,0 +646,3 @@\n+    while ( min < max )\n+    {\n+      mid = ( min + max ) >> 1;\n@@ -638,2 +650,5 @@\n-    for ( nn = 0; nn < face->hdmx_record_count; nn++ )\n-      if ( face->hdmx_record_sizes[nn] == ppem )\n+      if ( face->hdmx_records[mid][0] > ppem )\n+        max = mid;\n+      else if ( face->hdmx_records[mid][0] < ppem )\n+        min = mid + 1;\n+      else\n@@ -641,3 +656,1 @@\n-        gindex += 2;\n-        if ( gindex < record_size )\n-          result = record + nn * record_size + gindex;\n+        result = face->hdmx_records[mid] + 2 + gindex;\n@@ -646,0 +659,1 @@\n+    }\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttpload.c","additions":86,"deletions":72,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -34,3 +34,3 @@\n-  tt_face_get_location( TT_Face   face,\n-                        FT_UInt   gindex,\n-                        FT_UInt  *asize );\n+  tt_face_get_location( FT_Face    face,\n+                        FT_UInt    gindex,\n+                        FT_ULong  *asize );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttpload.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2010-2020 by\n+ * Copyright (C) 2010-2023 by\n@@ -318,1 +318,1 @@\n-    \/* fix vwxyz thinness*\/\n+    \/* fix vwxyz thinness *\/\n@@ -894,1 +894,1 @@\n-    loader->exec->sph_tweak_flags |= SPH_TWEAK_##x;\n+    loader->exec->sph_tweak_flags |= SPH_TWEAK_##x\n@@ -899,1 +899,1 @@\n-    loader->exec->sph_tweak_flags &= ~SPH_TWEAK_##x;\n+    loader->exec->sph_tweak_flags &= ~SPH_TWEAK_##x\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttsubpix.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2010-2020 by\n+ * Copyright (C) 2010-2023 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/truetype\/ttsubpix.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -86,1 +86,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -181,1 +181,0 @@\n-    charmap    = NULL;\n@@ -189,3 +188,1 @@\n-        error = FT_Set_Charmap( t1_face, charmap );\n-        if ( error )\n-          goto Exit;\n+        t1_face->charmap = charmap;\n@@ -206,1 +203,1 @@\n-      kp->x = (FT_Int)FT_PEEK_SHORT_LE(p + 2);\n+      kp->x = (FT_Int)FT_PEEK_SHORT_LE( p + 2 );\n@@ -212,4 +209,1 @@\n-    if ( oldcharmap )\n-      error = FT_Set_Charmap( t1_face, oldcharmap );\n-    if ( error )\n-      goto Exit;\n+    t1_face->charmap = oldcharmap;\n@@ -305,3 +299,8 @@\n-      \/* no `U' suffix here to 0x8000! *\/\n-      t1_face->ascender  = (FT_Short)( ( fi->Ascender  + 0x8000 ) >> 16 );\n-      t1_face->descender = (FT_Short)( ( fi->Descender + 0x8000 ) >> 16 );\n+      \/* ascender and descender are optional and could both be zero *\/\n+      \/* check if values are meaningful before overriding defaults  *\/\n+      if ( fi->Ascender > fi->Descender )\n+      {\n+        \/* no `U' suffix here to 0x8000! *\/\n+        t1_face->ascender  = (FT_Short)( ( fi->Ascender  + 0x8000 ) >> 16 );\n+        t1_face->descender = (FT_Short)( ( fi->Descender + 0x8000 ) >> 16 );\n+      }\n@@ -409,1 +408,1 @@\n-  typedef int  _t1_afm_dummy;\n+  typedef int  t1_afm_dummy_;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1afm.c","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1afm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -59,2 +59,2 @@\n-  static FT_Error\n-  t1_get_glyph_name( T1_Face     face,\n+  FT_CALLBACK_DEF( FT_Error )\n+  t1_get_glyph_name( FT_Face     face,        \/* T1_Face *\/\n@@ -65,1 +65,4 @@\n-    FT_STRCPYN( buffer, face->type1.glyph_names[glyph_index], buffer_max );\n+    T1_Face  t1face = (T1_Face)face;\n+\n+\n+    FT_STRCPYN( buffer, t1face->type1.glyph_names[glyph_index], buffer_max );\n@@ -71,2 +74,2 @@\n-  static FT_UInt\n-  t1_get_name_index( T1_Face           face,\n+  FT_CALLBACK_DEF( FT_UInt )\n+  t1_get_name_index( FT_Face           face,        \/* T1_Face *\/\n@@ -75,1 +78,2 @@\n-    FT_Int  i;\n+    T1_Face  t1face = (T1_Face)face;\n+    FT_Int   i;\n@@ -78,1 +82,1 @@\n-    for ( i = 0; i < face->type1.num_glyphs; i++ )\n+    for ( i = 0; i < t1face->type1.num_glyphs; i++ )\n@@ -80,1 +84,1 @@\n-      FT_String*  gname = face->type1.glyph_names[i];\n+      FT_String*  gname = t1face->type1.glyph_names[i];\n@@ -93,2 +97,2 @@\n-    (FT_GlyphDict_GetNameFunc)  t1_get_glyph_name,    \/* get_name   *\/\n-    (FT_GlyphDict_NameIndexFunc)t1_get_name_index     \/* name_index *\/\n+    t1_get_glyph_name,  \/* FT_GlyphDict_GetNameFunc   get_name   *\/\n+    t1_get_name_index   \/* FT_GlyphDict_NameIndexFunc name_index *\/\n@@ -104,1 +108,1 @@\n-  t1_get_ps_name( T1_Face  face )\n+  t1_get_ps_name( FT_Face  face )    \/* T1_Face *\/\n@@ -106,1 +110,4 @@\n-    return (const char*) face->type1.font_name;\n+    T1_Face  t1face = (T1_Face)face;\n+\n+\n+    return (const char*) t1face->type1.font_name;\n@@ -124,13 +131,22 @@\n-    (FT_Get_MM_Func)             T1_Get_Multi_Master,    \/* get_mm              *\/\n-    (FT_Set_MM_Design_Func)      T1_Set_MM_Design,       \/* set_mm_design       *\/\n-    (FT_Set_MM_Blend_Func)       T1_Set_MM_Blend,        \/* set_mm_blend        *\/\n-    (FT_Get_MM_Blend_Func)       T1_Get_MM_Blend,        \/* get_mm_blend        *\/\n-    (FT_Get_MM_Var_Func)         T1_Get_MM_Var,          \/* get_mm_var          *\/\n-    (FT_Set_Var_Design_Func)     T1_Set_Var_Design,      \/* set_var_design      *\/\n-    (FT_Get_Var_Design_Func)     T1_Get_Var_Design,      \/* get_var_design      *\/\n-    (FT_Set_Instance_Func)       T1_Reset_MM_Blend,      \/* set_instance        *\/\n-    (FT_Set_MM_WeightVector_Func)T1_Set_MM_WeightVector, \/* set_mm_weightvector *\/\n-    (FT_Get_MM_WeightVector_Func)T1_Get_MM_WeightVector, \/* get_mm_weightvector *\/\n-\n-    (FT_Get_Var_Blend_Func)      NULL,                   \/* get_var_blend       *\/\n-    (FT_Done_Blend_Func)         T1_Done_Blend           \/* done_blend          *\/\n+    T1_Get_Multi_Master,    \/* FT_Get_MM_Func             get_mm             *\/\n+    T1_Set_MM_Design,       \/* FT_Set_MM_Design_Func      set_mm_design      *\/\n+    T1_Set_MM_Blend,        \/* FT_Set_MM_Blend_Func       set_mm_blend       *\/\n+    T1_Get_MM_Blend,        \/* FT_Get_MM_Blend_Func       get_mm_blend       *\/\n+    T1_Get_MM_Var,          \/* FT_Get_MM_Var_Func         get_mm_var         *\/\n+    T1_Set_Var_Design,      \/* FT_Set_Var_Design_Func     set_var_design     *\/\n+    T1_Get_Var_Design,      \/* FT_Get_Var_Design_Func     get_var_design     *\/\n+    T1_Reset_MM_Blend,      \/* FT_Set_Named_Instance_Func set_named_instance *\/\n+    NULL,   \/* FT_Get_Default_Named_Instance_Func get_default_named_instance *\/\n+    T1_Set_MM_WeightVector,\n+            \/* FT_Set_MM_WeightVector_Func        set_mm_weightvector        *\/\n+    T1_Get_MM_WeightVector,\n+            \/* FT_Get_MM_WeightVector_Func        get_mm_weightvector        *\/\n+\n+    NULL,   \/* FT_Construct_PS_Name_Func          construct_ps_name          *\/\n+    NULL,   \/* FT_Var_Load_Delta_Set_Idx_Map_Func load_delta_set_idx_map     *\/\n+    NULL,   \/* FT_Var_Load_Item_Var_Store_Func    load_item_variation_store  *\/\n+    NULL,   \/* FT_Var_Get_Item_Delta_Func         get_item_delta             *\/\n+    NULL,   \/* FT_Var_Done_Item_Var_Store_Func    done_item_variation_store  *\/\n+    NULL,   \/* FT_Var_Done_Delta_Set_Idx_Map_Func done_delta_set_index_map   *\/\n+    NULL,           \/* FT_Get_Var_Blend_Func      get_var_blend              *\/\n+    T1_Done_Blend   \/* FT_Done_Blend_Func         done_blend                 *\/\n@@ -299,1 +315,0 @@\n-        {\n@@ -301,2 +316,0 @@\n-          ((FT_Char *)value)[retval - 1] = (FT_Char)'\\0';\n-        }\n@@ -331,1 +344,0 @@\n-        {\n@@ -333,3 +345,1 @@\n-                     retval - 1 );\n-          ((FT_Char *)value)[retval - 1] = (FT_Char)'\\0';\n-        }\n+                     retval );\n@@ -624,5 +634,5 @@\n-    (PS_GetFontInfoFunc)   t1_ps_get_font_info,    \/* ps_get_font_info    *\/\n-    (PS_GetFontExtraFunc)  t1_ps_get_font_extra,   \/* ps_get_font_extra   *\/\n-    (PS_HasGlyphNamesFunc) t1_ps_has_glyph_names,  \/* ps_has_glyph_names  *\/\n-    (PS_GetFontPrivateFunc)t1_ps_get_font_private, \/* ps_get_font_private *\/\n-    (PS_GetFontValueFunc)  t1_ps_get_font_value,   \/* ps_get_font_value   *\/\n+    t1_ps_get_font_info,     \/* PS_GetFontInfoFunc    ps_get_font_info    *\/\n+    t1_ps_get_font_extra,    \/* PS_GetFontExtraFunc   ps_get_font_extra   *\/\n+    t1_ps_has_glyph_names,   \/* PS_HasGlyphNamesFunc  ps_has_glyph_names  *\/\n+    t1_ps_get_font_private,  \/* PS_GetFontPrivateFunc ps_get_font_private *\/\n+    t1_ps_get_font_value,    \/* PS_GetFontValueFunc   ps_get_font_value   *\/\n@@ -648,3 +658,3 @@\n-    (FT_Properties_SetFunc)ps_property_set,      \/* set_property *\/\n-    (FT_Properties_GetFunc)ps_property_get )     \/* get_property *\/\n-\n+    ps_property_set,  \/* FT_Properties_SetFunc set_property *\/\n+    ps_property_get   \/* FT_Properties_GetFunc get_property *\/\n+  )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1driver.c","additions":51,"deletions":41,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1driver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1errors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -82,1 +82,1 @@\n-      char_string->length  = (FT_Int)type1->charstrings_len[glyph_index];\n+      char_string->length  = type1->charstrings_len[glyph_index];\n@@ -267,1 +267,1 @@\n-                *max_advance \/ 65536.0 ));\n+                (double)*max_advance \/ 65536 ));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1gload.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1gload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -76,1 +76,2 @@\n-#define IS_INCREMENTAL  FT_BOOL( face->root.internal->incremental_interface )\n+#define IS_INCREMENTAL  \\\n+          FT_BOOL( FT_FACE( face )->internal->incremental_interface )\n@@ -120,0 +121,3 @@\n+      blend->weight_vector             = NULL;\n+      blend->default_weight_vector     = NULL;\n+      blend->design_pos[0]             = NULL;\n@@ -133,4 +137,3 @@\n-        if ( FT_NEW_ARRAY( blend->font_infos[1], num_designs     ) ||\n-             FT_NEW_ARRAY( blend->privates  [1], num_designs     ) ||\n-             FT_NEW_ARRAY( blend->bboxes    [1], num_designs     ) ||\n-             FT_NEW_ARRAY( blend->weight_vector, num_designs * 2 ) )\n+        if ( FT_NEW_ARRAY( blend->font_infos[1], num_designs ) ||\n+             FT_NEW_ARRAY( blend->privates  [1], num_designs ) ||\n+             FT_NEW_ARRAY( blend->bboxes    [1], num_designs ) )\n@@ -139,2 +142,0 @@\n-        blend->default_weight_vector = blend->weight_vector + num_designs;\n-\n@@ -167,15 +168,0 @@\n-    \/* allocate the blend design pos table if needed *\/\n-    num_designs = blend->num_designs;\n-    num_axis    = blend->num_axis;\n-    if ( num_designs && num_axis && blend->design_pos[0] == 0 )\n-    {\n-      FT_UInt  n;\n-\n-\n-      if ( FT_NEW_ARRAY( blend->design_pos[0], num_designs * num_axis ) )\n-        goto Exit;\n-\n-      for ( n = 1; n < num_designs; n++ )\n-        blend->design_pos[n] = blend->design_pos[0] + num_axis * n;\n-    }\n-\n@@ -192,1 +178,1 @@\n-  T1_Get_Multi_Master( T1_Face           face,\n+  T1_Get_Multi_Master( FT_Face           face,    \/* T1_Face *\/\n@@ -195,1 +181,2 @@\n-    PS_Blend  blend = face->blend;\n+    T1_Face   t1face = (T1_Face)face;\n+    PS_Blend  blend  = t1face->blend;\n@@ -243,5 +230,6 @@\n-        return INT_TO_FIXED( axismap->design_points[j - 1] ) +\n-               ( axismap->design_points[j] - axismap->design_points[j - 1] ) *\n-               FT_DivFix( ncv - axismap->blend_points[j - 1],\n-                          axismap->blend_points[j] -\n-                            axismap->blend_points[j - 1] );\n+        return INT_TO_FIXED( axismap->design_points[j - 1] +\n+                               FT_MulDiv( ncv - axismap->blend_points[j - 1],\n+                                          axismap->design_points[j] -\n+                                            axismap->design_points[j - 1],\n+                                          axismap->blend_points[j] -\n+                                            axismap->blend_points[j - 1] ) );\n@@ -302,1 +290,1 @@\n-  T1_Get_MM_Var( T1_Face      face,\n+  T1_Get_MM_Var( FT_Face      face,    \/* T1_Face *\/\n@@ -305,2 +293,3 @@\n-    FT_Memory        memory = face->root.memory;\n-    FT_MM_Var       *mmvar = NULL;\n+    T1_Face          t1face = (T1_Face)face;\n+    FT_Memory        memory = FT_FACE_MEMORY( face );\n+    FT_MM_Var       *mmvar  = NULL;\n@@ -311,1 +300,1 @@\n-    PS_Blend         blend = face->blend;\n+    PS_Blend         blend  = t1face->blend;\n@@ -337,3 +326,3 @@\n-    if ( FT_ALLOC( mmvar, mmvar_size +\n-                          axis_flags_size +\n-                          axis_size ) )\n+    if ( FT_QALLOC( mmvar, mmvar_size +\n+                           axis_flags_size +\n+                           axis_size ) )\n@@ -350,2 +339,1 @@\n-    for ( i = 0; i < mmaster.num_axis; i++ )\n-      axis_flags[i] = 0;\n+    FT_ARRAY_ZERO( axis_flags, mmaster.num_axis );\n@@ -373,0 +361,4 @@\n+      else if ( ft_strcmp( mmvar->axis[i].name, \"Slant\" ) == 0 )\n+        mmvar->axis[i].tag = FT_MAKE_TAG( 's', 'l', 'n', 't' );\n+      else if ( ft_strcmp( mmvar->axis[i].name, \"Italic\" ) == 0 )\n+        mmvar->axis[i].tag = FT_MAKE_TAG( 'i', 't', 'a', 'l' );\n@@ -452,1 +444,1 @@\n-  T1_Set_MM_Blend( T1_Face    face,\n+  T1_Set_MM_Blend( FT_Face    face,       \/* T1_Face *\/\n@@ -456,13 +448,1 @@\n-    FT_Error  error;\n-\n-\n-    error = t1_set_mm_blend( face, num_coords, coords );\n-    if ( error )\n-      return error;\n-\n-    if ( num_coords )\n-      face->root.face_flags |= FT_FACE_FLAG_VARIATION;\n-    else\n-      face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;\n-\n-    return FT_Err_Ok;\n+    return t1_set_mm_blend( (T1_Face)face, num_coords, coords );\n@@ -473,1 +453,1 @@\n-  T1_Get_MM_Blend( T1_Face    face,\n+  T1_Get_MM_Blend( FT_Face    face,       \/* T1_Face *\/\n@@ -477,1 +457,2 @@\n-    PS_Blend  blend = face->blend;\n+    T1_Face   t1face = (T1_Face)face;\n+    PS_Blend  blend  = t1face->blend;\n@@ -508,1 +489,1 @@\n-  T1_Set_MM_WeightVector( T1_Face    face,\n+  T1_Set_MM_WeightVector( FT_Face    face,          \/* T1_Face *\/\n@@ -512,1 +493,2 @@\n-    PS_Blend  blend = face->blend;\n+    T1_Face   t1face = (T1_Face)face;\n+    PS_Blend  blend  = t1face->blend;\n@@ -536,5 +518,0 @@\n-\n-      if ( len )\n-        face->root.face_flags |= FT_FACE_FLAG_VARIATION;\n-      else\n-        face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;\n@@ -548,1 +525,1 @@\n-  T1_Get_MM_WeightVector( T1_Face    face,\n+  T1_Get_MM_WeightVector( FT_Face    face,          \/* T1_Face *\/\n@@ -552,1 +529,2 @@\n-    PS_Blend  blend = face->blend;\n+    T1_Face   t1face = (T1_Face)face;\n+    PS_Blend  blend  = t1face->blend;\n@@ -577,1 +555,1 @@\n-  T1_Set_MM_Design( T1_Face   face,\n+  T1_Set_MM_Design( FT_Face   face,       \/* T1_Face *\/\n@@ -581,0 +559,1 @@\n+    T1_Face   t1face = (T1_Face)face;\n@@ -582,2 +561,2 @@\n-    PS_Blend  blend = face->blend;\n-    FT_UInt   n, p;\n+    PS_Blend  blend  = t1face->blend;\n+    FT_UInt   n;\n@@ -602,1 +581,1 @@\n-      FT_Int        before  = -1, after = -1;\n+      FT_Int        p, before  = -1, after = -1;\n@@ -611,1 +590,1 @@\n-      for ( p = 0; p < (FT_UInt)map->num_points; p++ )\n+      for ( p = 0; p < (FT_Int)map->num_points; p++ )\n@@ -625,1 +604,1 @@\n-          after = (FT_Int)p;\n+          after = p;\n@@ -629,1 +608,1 @@\n-        before = (FT_Int)p;\n+        before = p;\n@@ -648,1 +627,1 @@\n-    error = t1_set_mm_blend( face, blend->num_axis, final_blends );\n+    error = t1_set_mm_blend( t1face, blend->num_axis, final_blends );\n@@ -652,5 +631,0 @@\n-    if ( num_coords )\n-      face->root.face_flags |= FT_FACE_FLAG_VARIATION;\n-    else\n-      face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;\n-\n@@ -664,1 +638,1 @@\n-  T1_Reset_MM_Blend( T1_Face  face,\n+  T1_Reset_MM_Blend( FT_Face  face,\n@@ -679,1 +653,1 @@\n-  T1_Set_Var_Design( T1_Face    face,\n+  T1_Set_Var_Design( FT_Face    face,       \/* T1_Face *\/\n@@ -698,1 +672,1 @@\n-  T1_Get_Var_Design( T1_Face    face,\n+  T1_Get_Var_Design( FT_Face    face,       \/* T1_Face *\/\n@@ -702,1 +676,2 @@\n-    PS_Blend  blend = face->blend;\n+    T1_Face   t1face = (T1_Face)face;\n+    PS_Blend  blend  = t1face->blend;\n@@ -734,1 +709,1 @@\n-  T1_Done_Blend( T1_Face  face )\n+  T1_Done_Blend( FT_Face  face )    \/* T1_Face *\/\n@@ -736,2 +711,3 @@\n-    FT_Memory  memory = face->root.memory;\n-    PS_Blend   blend  = face->blend;\n+    T1_Face    t1face = (T1_Face)face;\n+    FT_Memory  memory = FT_FACE_MEMORY( face );\n+    PS_Blend   blend  = t1face->blend;\n@@ -778,0 +754,1 @@\n+        FT_FREE( dmap->blend_points );\n@@ -782,1 +759,1 @@\n-      FT_FREE( face->blend );\n+      FT_FREE( t1face->blend );\n@@ -788,2 +765,2 @@\n-  parse_blend_axis_types( T1_Face    face,\n-                          T1_Loader  loader )\n+  parse_blend_axis_types( FT_Face  face,     \/* T1_Face *\/\n+                          void*    loader_ )\n@@ -791,0 +768,2 @@\n+    T1_Face      t1face = (T1_Face)face;\n+    T1_Loader    loader = (T1_Loader)loader_;\n@@ -793,1 +772,1 @@\n-    FT_Error     error = FT_Err_Ok;\n+    FT_Error     error  = FT_Err_Ok;\n@@ -795,1 +774,1 @@\n-    FT_Memory    memory;\n+    FT_Memory    memory = FT_FACE_MEMORY( face );\n@@ -815,1 +794,1 @@\n-    error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );\n+    error = t1_allocate_blend( t1face, 0, (FT_UInt)num_axis );\n@@ -821,2 +800,1 @@\n-    blend  = face->blend;\n-    memory = face->root.memory;\n+    blend = t1face->blend;\n@@ -854,1 +832,1 @@\n-      if ( FT_ALLOC( blend->axis_names[n], len + 1 ) )\n+      if ( FT_QALLOC( blend->axis_names[n], len + 1 ) )\n@@ -870,2 +848,2 @@\n-  parse_blend_design_positions( T1_Face    face,\n-                                T1_Loader  loader )\n+  parse_blend_design_positions( FT_Face  face,     \/* T1_Face *\/\n+                                void*    loader_ )\n@@ -873,0 +851,2 @@\n+    T1_Face      t1face   = (T1_Face)face;\n+    T1_Loader    loader   = (T1_Loader)loader_;\n@@ -875,2 +855,5 @@\n-    FT_Int       num_axis;\n-    T1_Parser    parser = &loader->parser;\n+    FT_Int       num_axis = 0; \/* make compiler happy *\/\n+    T1_Parser    parser   = &loader->parser;\n+    FT_Memory    memory   = FT_FACE_MEMORY( face );\n+    FT_Error     error    = FT_Err_Ok;\n+    FT_Fixed*    design_pos[T1_MAX_MM_DESIGNS];\n@@ -878,2 +861,0 @@\n-    FT_Error     error = FT_Err_Ok;\n-    PS_Blend     blend;\n@@ -881,0 +862,1 @@\n+    design_pos[0] = NULL;\n@@ -902,1 +884,2 @@\n-      FT_Int    n;\n+      FT_Int    n, nn;\n+      PS_Blend  blend;\n@@ -905,3 +888,0 @@\n-      blend    = face->blend;\n-      num_axis = 0;  \/* make compiler happy *\/\n-\n@@ -935,1 +915,1 @@\n-          error = t1_allocate_blend( face,\n+          error = t1_allocate_blend( t1face,\n@@ -940,1 +920,7 @@\n-          blend = face->blend;\n+\n+          \/* allocate a blend design pos table *\/\n+          if ( FT_QNEW_ARRAY( design_pos[0], num_designs * num_axis ) )\n+            goto Exit;\n+\n+          for ( nn = 1; nn < num_designs; nn++ )\n+            design_pos[nn] = design_pos[0] + num_axis * nn;\n@@ -958,2 +944,2 @@\n-          blend->design_pos[n][axis] = T1_ToFixed( parser, 0 );\n-          FT_TRACE4(( \" %f\", (double)blend->design_pos[n][axis] \/ 65536 ));\n+          design_pos[n][axis] = T1_ToFixed( parser, 0 );\n+          FT_TRACE4(( \" %f\", (double)design_pos[n][axis] \/ 65536 ));\n@@ -968,0 +954,11 @@\n+\n+      \/* a valid BlendDesignPosition has been parsed *\/\n+      blend = t1face->blend;\n+      if ( blend->design_pos[0] )\n+        FT_FREE( blend->design_pos[0] );\n+\n+      for ( n = 0; n < num_designs; n++ )\n+      {\n+        blend->design_pos[n] = design_pos[n];\n+        design_pos[n]        = NULL;\n+      }\n@@ -971,0 +968,1 @@\n+    FT_FREE( design_pos[0] );\n@@ -976,2 +974,2 @@\n-  parse_blend_design_map( T1_Face    face,\n-                          T1_Loader  loader )\n+  parse_blend_design_map( FT_Face  face,     \/* T1_Face *\/\n+                          void*    loader_ )\n@@ -979,0 +977,2 @@\n+    T1_Face      t1face = (T1_Face)face;\n+    T1_Loader    loader = (T1_Loader)loader_;\n@@ -986,1 +986,1 @@\n-    FT_Memory    memory = face->root.memory;\n+    FT_Memory    memory = FT_FACE_MEMORY( face );\n@@ -1007,1 +1007,1 @@\n-    error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );\n+    error = t1_allocate_blend( t1face, 0, (FT_UInt)num_axis );\n@@ -1010,1 +1010,1 @@\n-    blend = face->blend;\n+    blend = t1face->blend;\n@@ -1047,1 +1047,2 @@\n-      if ( FT_NEW_ARRAY( map->design_points, num_points * 2 ) )\n+      if ( FT_QNEW_ARRAY( map->design_points, num_points ) ||\n+           FT_QNEW_ARRAY( map->blend_points,  num_points ) )\n@@ -1049,1 +1050,0 @@\n-      map->blend_points = map->design_points + num_points;\n@@ -1085,2 +1085,2 @@\n-  parse_weight_vector( T1_Face    face,\n-                       T1_Loader  loader )\n+  parse_weight_vector( FT_Face  face,     \/* T1_Face *\/\n+                       void*    loader_ )\n@@ -1088,0 +1088,2 @@\n+    T1_Face      t1face = (T1_Face)face;\n+    T1_Loader    loader = (T1_Loader)loader_;\n@@ -1091,0 +1093,1 @@\n+    FT_Memory    memory = FT_FACE_MEMORY( face );\n@@ -1092,1 +1095,1 @@\n-    PS_Blend     blend  = face->blend;\n+    PS_Blend     blend  = t1face->blend;\n@@ -1117,1 +1120,1 @@\n-      error = t1_allocate_blend( face, (FT_UInt)num_designs, 0 );\n+      error = t1_allocate_blend( t1face, (FT_UInt)num_designs, 0 );\n@@ -1120,1 +1123,1 @@\n-      blend = face->blend;\n+      blend = t1face->blend;\n@@ -1125,2 +1128,2 @@\n-                 \" \/BlendDesignPosition and \/WeightVector have\\n\"\n-                 \"                    \"\n+                 \" \/BlendDesignPosition and \/WeightVector have\\n\" ));\n+      FT_ERROR(( \"                    \"\n@@ -1132,0 +1135,6 @@\n+    if ( !blend->weight_vector )\n+      if ( FT_QNEW_ARRAY( blend->weight_vector, num_designs * 2 ) )\n+        goto Exit;\n+\n+    blend->default_weight_vector = blend->weight_vector + num_designs;\n+\n@@ -1162,2 +1171,2 @@\n-  parse_buildchar( T1_Face    face,\n-                   T1_Loader  loader )\n+  parse_buildchar( FT_Face  face,     \/* T1_Face *\/\n+                   void*    loader_ )\n@@ -1165,2 +1174,6 @@\n-    face->len_buildchar = (FT_UInt)T1_ToFixedArray( &loader->parser,\n-                                                    0, NULL, 0 );\n+    T1_Face    t1face = (T1_Face)face;\n+    T1_Loader  loader = (T1_Loader)loader_;\n+\n+\n+    t1face->len_buildchar = (FT_UInt)T1_ToFixedArray( &loader->parser,\n+                                                      0, NULL, 0 );\n@@ -1174,1 +1187,1 @@\n-      for ( i = 0; i < face->len_buildchar; i++ )\n+      for ( i = 0; i < t1face->len_buildchar; i++ )\n@@ -1310,2 +1323,1 @@\n-                  \" which is not valid at this point\\n\"\n-                  \"                 (probably due to missing keywords)\\n\",\n+                  \" which is not valid at this point\\n\",\n@@ -1313,0 +1325,1 @@\n+      FT_TRACE1(( \"                 (probably due to missing keywords)\\n\" ));\n@@ -1324,2 +1337,2 @@\n-  parse_private( T1_Face    face,\n-                 T1_Loader  loader )\n+  parse_private( FT_Face  face,\n+                 void*    loader_ )\n@@ -1327,0 +1340,1 @@\n+    T1_Loader  loader = (T1_Loader)loader_;\n@@ -1390,2 +1404,2 @@\n-  t1_parse_font_matrix( T1_Face    face,\n-                        T1_Loader  loader )\n+  t1_parse_font_matrix( FT_Face  face,     \/* T1_Face *\/\n+                        void*    loader_ )\n@@ -1393,0 +1407,2 @@\n+    T1_Face     t1face = (T1_Face)face;\n+    T1_Loader   loader = (T1_Loader)loader_;\n@@ -1394,3 +1410,2 @@\n-    FT_Matrix*  matrix = &face->type1.font_matrix;\n-    FT_Vector*  offset = &face->type1.font_offset;\n-    FT_Face     root   = (FT_Face)&face->root;\n+    FT_Matrix*  matrix = &t1face->type1.font_matrix;\n+    FT_Vector*  offset = &t1face->type1.font_offset;\n@@ -1432,1 +1447,1 @@\n-      root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n+      face->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n@@ -1460,2 +1475,2 @@\n-  parse_encoding( T1_Face    face,\n-                  T1_Loader  loader )\n+  parse_encoding( FT_Face  face,     \/* T1_Face *\/\n+                  void*    loader_ )\n@@ -1463,0 +1478,2 @@\n+    T1_Face    t1face = (T1_Face)face;\n+    T1_Loader  loader = (T1_Loader)loader_;\n@@ -1467,1 +1484,1 @@\n-    PSAux_Service  psaux = (PSAux_Service)face->psaux;\n+    PSAux_Service  psaux = (PSAux_Service)t1face->psaux;\n@@ -1483,1 +1500,1 @@\n-      T1_Encoding  encode          = &face->type1.encoding;\n+      T1_Encoding  encode          = &t1face->type1.encoding;\n@@ -1523,2 +1540,2 @@\n-      if ( FT_NEW_ARRAY( encode->char_index, array_size )     ||\n-           FT_NEW_ARRAY( encode->char_name,  array_size )     ||\n+      if ( FT_QNEW_ARRAY( encode->char_index, array_size )    ||\n+           FT_QNEW_ARRAY( encode->char_name,  array_size )    ||\n@@ -1665,1 +1682,1 @@\n-      face->type1.encoding_type = T1_ENCODING_TYPE_ARRAY;\n+      t1face->type1.encoding_type = T1_ENCODING_TYPE_ARRAY;\n@@ -1676,1 +1693,1 @@\n-        face->type1.encoding_type = T1_ENCODING_TYPE_STANDARD;\n+        t1face->type1.encoding_type = T1_ENCODING_TYPE_STANDARD;\n@@ -1683,1 +1700,1 @@\n-        face->type1.encoding_type = T1_ENCODING_TYPE_EXPERT;\n+        t1face->type1.encoding_type = T1_ENCODING_TYPE_EXPERT;\n@@ -1690,1 +1707,1 @@\n-        face->type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;\n+        t1face->type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;\n@@ -1704,2 +1721,2 @@\n-  parse_subrs( T1_Face    face,\n-               T1_Loader  loader )\n+  parse_subrs( FT_Face  face,     \/* T1_Face *\/\n+               void*    loader_ )\n@@ -1707,0 +1724,2 @@\n+    T1_Face    t1face = (T1_Face)face;\n+    T1_Loader  loader = (T1_Loader)loader_;\n@@ -1714,1 +1733,1 @@\n-    PSAux_Service  psaux = (PSAux_Service)face->psaux;\n+    PSAux_Service  psaux = (PSAux_Service)t1face->psaux;\n@@ -1758,1 +1777,1 @@\n-                  \" (from %d to %ld)\\n\",\n+                  \" (from %d to %zu)\\n\",\n@@ -1765,1 +1784,1 @@\n-        if ( FT_NEW( loader->subrs_hash ) )\n+        if ( FT_QNEW( loader->subrs_hash ) )\n@@ -1846,1 +1865,1 @@\n-      if ( face->type1.private_dict.lenIV >= 0 )\n+      if ( t1face->type1.private_dict.lenIV >= 0 )\n@@ -1854,1 +1873,1 @@\n-        if ( size < (FT_ULong)face->type1.private_dict.lenIV )\n+        if ( size < (FT_ULong)t1face->type1.private_dict.lenIV )\n@@ -1861,1 +1880,1 @@\n-        if ( FT_ALLOC( temp, size ) )\n+        if ( FT_DUP( temp, base, size ) )\n@@ -1863,1 +1882,0 @@\n-        FT_MEM_COPY( temp, base, size );\n@@ -1865,3 +1883,5 @@\n-        size -= (FT_ULong)face->type1.private_dict.lenIV;\n-        error = T1_Add_Table( table, (FT_Int)idx,\n-                              temp + face->type1.private_dict.lenIV, size );\n+        size -= (FT_ULong)t1face->type1.private_dict.lenIV;\n+        error = T1_Add_Table( table,\n+                              (FT_Int)idx,\n+                              temp + t1face->type1.private_dict.lenIV,\n+                              size );\n@@ -1899,2 +1919,2 @@\n-  parse_charstrings( T1_Face    face,\n-                     T1_Loader  loader )\n+  parse_charstrings( FT_Face  face,     \/* T1_Face *\/\n+                     void*    loader_ )\n@@ -1902,0 +1922,2 @@\n+    T1_Face        t1face       = (T1_Face)face;\n+    T1_Loader      loader       = (T1_Loader)loader_;\n@@ -1909,1 +1931,1 @@\n-    PSAux_Service  psaux        = (PSAux_Service)face->psaux;\n+    PSAux_Service  psaux        = (PSAux_Service)t1face->psaux;\n@@ -1929,1 +1951,1 @@\n-                  \" (from %d to %ld)\\n\",\n+                  \" (from %d to %zu)\\n\",\n@@ -2050,1 +2072,1 @@\n-        if ( *cur == '.'                                              &&\n+        if ( *cur == '.'                                                &&\n@@ -2052,1 +2074,1 @@\n-                        (const char*)(name_table->elements[n]) ) == 0 )\n+                        (const char*)( name_table->elements[n] ) ) == 0 )\n@@ -2058,1 +2080,1 @@\n-        if ( face->type1.private_dict.lenIV >= 0 &&\n+        if ( t1face->type1.private_dict.lenIV >= 0 &&\n@@ -2064,1 +2086,1 @@\n-          if ( size <= (FT_ULong)face->type1.private_dict.lenIV )\n+          if ( size <= (FT_ULong)t1face->type1.private_dict.lenIV )\n@@ -2071,1 +2093,1 @@\n-          if ( FT_ALLOC( temp, size ) )\n+          if ( FT_DUP( temp, base, size ) )\n@@ -2073,1 +2095,0 @@\n-          FT_MEM_COPY( temp, base, size );\n@@ -2075,3 +2096,5 @@\n-          size -= (FT_ULong)face->type1.private_dict.lenIV;\n-          error = T1_Add_Table( code_table, n,\n-                                temp + face->type1.private_dict.lenIV, size );\n+          size -= (FT_ULong)t1face->type1.private_dict.lenIV;\n+          error = T1_Add_Table( code_table,\n+                                n,\n+                                temp + t1face->type1.private_dict.lenIV,\n+                                size );\n@@ -2263,1 +2286,1 @@\n-    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }\n+    T1_FIELD_ZERO\n@@ -2324,2 +2347,2 @@\n-      else if ( *cur == 'R' && cur + 6 < limit && *(cur + 1) == 'D' &&\n-                have_integer )\n+      else if ( *cur == 'R' && cur + 6 < limit && *( cur + 1 ) == 'D' &&\n+                have_integer                                          )\n@@ -2337,2 +2360,2 @@\n-      else if ( *cur == '-' && cur + 6 < limit && *(cur + 1) == '|' &&\n-                have_integer )\n+      else if ( *cur == '-' && cur + 6 < limit && *( cur + 1 ) == '|' &&\n+                have_integer                                          )\n@@ -2371,1 +2394,1 @@\n-          for (;;)\n+          while ( keyword->len )\n@@ -2373,1 +2396,1 @@\n-            FT_Byte*  name;\n+            FT_Byte*  name = (FT_Byte*)keyword->ident;\n@@ -2376,7 +2399,2 @@\n-            name = (FT_Byte*)keyword->ident;\n-            if ( !name )\n-              break;\n-\n-            if ( cur[0] == name[0]                      &&\n-                 len == ft_strlen( (const char *)name ) &&\n-                 ft_memcmp( cur, name, len ) == 0       )\n+            if ( keyword->len == len              &&\n+                 ft_memcmp( cur, name, len ) == 0 )\n@@ -2559,1 +2577,1 @@\n-      T1_Done_Blend( face );\n+      T1_Done_Blend( FT_FACE( face ) );\n@@ -2579,1 +2597,9 @@\n-      T1_Done_Blend( face );\n+      T1_Done_Blend( FT_FACE( face ) );\n+\n+    \/* the font may have no valid WeightVector *\/\n+    if ( face->blend && !face->blend->weight_vector )\n+      T1_Done_Blend( FT_FACE( face ) );\n+\n+    \/* the font may have no valid BlendDesignPositions *\/\n+    if ( face->blend && !face->blend->design_pos[0] )\n+      T1_Done_Blend( FT_FACE( face ) );\n@@ -2581,1 +2607,1 @@\n-    \/* another safety check *\/\n+    \/* the font may have no valid BlendDesignMap *\/\n@@ -2590,1 +2616,1 @@\n-          T1_Done_Blend( face );\n+          T1_Done_Blend( FT_FACE( face ) );\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1load.c","additions":215,"deletions":189,"binary":false,"changes":404,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -69,1 +69,1 @@\n-  T1_Get_Multi_Master( T1_Face           face,\n+  T1_Get_Multi_Master( FT_Face           face,\n@@ -73,1 +73,1 @@\n-  T1_Get_MM_Var( T1_Face      face,\n+  T1_Get_MM_Var( FT_Face      face,\n@@ -77,1 +77,1 @@\n-  T1_Set_MM_Blend( T1_Face    face,\n+  T1_Set_MM_Blend( FT_Face    face,\n@@ -82,1 +82,1 @@\n-  T1_Get_MM_Blend( T1_Face    face,\n+  T1_Get_MM_Blend( FT_Face    face,\n@@ -87,1 +87,1 @@\n-  T1_Set_MM_Design( T1_Face   face,\n+  T1_Set_MM_Design( FT_Face   face,\n@@ -92,1 +92,1 @@\n-  T1_Reset_MM_Blend( T1_Face  face,\n+  T1_Reset_MM_Blend( FT_Face  face,\n@@ -96,1 +96,1 @@\n-  T1_Get_Var_Design( T1_Face    face,\n+  T1_Get_Var_Design( FT_Face    face,\n@@ -101,1 +101,1 @@\n-  T1_Set_Var_Design( T1_Face    face,\n+  T1_Set_Var_Design( FT_Face    face,\n@@ -106,1 +106,1 @@\n-  T1_Done_Blend( T1_Face  face );\n+  T1_Done_Blend( FT_Face  face );\n@@ -109,1 +109,1 @@\n-  T1_Set_MM_WeightVector( T1_Face    face,\n+  T1_Set_MM_WeightVector( FT_Face    face,\n@@ -114,1 +114,1 @@\n-  T1_Get_MM_WeightVector( T1_Face    face,\n+  T1_Get_MM_WeightVector( FT_Face    face,\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1load.h","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -119,0 +119,2 @@\n+    FT_Error  error;\n+\n@@ -123,1 +125,3 @@\n-    FT_Request_Metrics( size->root.face, req );\n+    error = FT_Request_Metrics( size->root.face, req );\n+    if ( error )\n+      goto Exit;\n@@ -131,1 +135,2 @@\n-    return FT_Err_Ok;\n+  Exit:\n+    return error;\n@@ -144,1 +149,3 @@\n-    slot->internal->glyph_hints = NULL;\n+    \/* `slot->internal` might be NULL in out-of-memory situations. *\/\n+    if ( slot->internal )\n+      slot->internal->glyph_hints = NULL;\n@@ -163,2 +170,1 @@\n-      module = FT_Get_Module( slot->face->driver->root.library,\n-                              \"pshinter\" );\n+      module = FT_Get_Module( slot->library, \"pshinter\" );\n@@ -220,1 +226,0 @@\n-      face->buildchar     = NULL;\n@@ -224,1 +229,1 @@\n-    T1_Done_Blend( face );\n+    T1_Done_Blend( t1face );\n@@ -287,1 +292,2 @@\n-   *     input stream where to load font data.\n+   *     Dummy argument for compatibility with the `FT_Face_InitFunc` API.\n+   *     Ignored.  The stream should be passed through `face->root.stream`.\n@@ -601,3 +607,0 @@\n-#ifdef T1_CONFIG_OPTION_OLD_ENGINE\n-    driver->hinting_engine = FT_HINTING_FREETYPE;\n-#else\n@@ -605,1 +608,0 @@\n-#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1objs.c","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1objs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n@@ -224,1 +224,1 @@\n-      if ( FT_ALLOC( parser->base_dict, size )       ||\n+      if ( FT_QALLOC( parser->base_dict, size )      ||\n@@ -305,2 +305,2 @@\n-      if ( FT_STREAM_SEEK( start_pos )                           ||\n-           FT_ALLOC( parser->private_dict, parser->private_len ) )\n+      if ( FT_STREAM_SEEK( start_pos )                            ||\n+           FT_QALLOC( parser->private_dict, parser->private_len ) )\n@@ -333,1 +333,3 @@\n-      \/* first of all, look at the `eexec' keyword *\/\n+      \/* First look for the `eexec' keyword. Ensure `eexec' is real -- *\/\n+      \/* it could be in a comment or string (as e.g. in u003043t.gsf   *\/\n+      \/* from ghostscript).                                            *\/\n@@ -340,26 +342,0 @@\n-    Again:\n-      for (;;)\n-      {\n-        if ( cur[0] == 'e'   &&\n-             cur + 9 < limit )      \/* 9 = 5 letters for `eexec' + *\/\n-                                    \/* whitespace + 4 chars        *\/\n-        {\n-          if ( cur[1] == 'e' &&\n-               cur[2] == 'x' &&\n-               cur[3] == 'e' &&\n-               cur[4] == 'c' )\n-            break;\n-        }\n-        cur++;\n-        if ( cur >= limit )\n-        {\n-          FT_ERROR(( \"T1_Get_Private_Dict:\"\n-                     \" could not find `eexec' keyword\\n\" ));\n-          error = FT_THROW( Invalid_File_Format );\n-          goto Exit;\n-        }\n-      }\n-\n-      \/* check whether `eexec' was real -- it could be in a comment *\/\n-      \/* or string (as e.g. in u003043t.gsf from ghostscript)       *\/\n-\n@@ -367,2 +343,1 @@\n-      \/* set limit to `eexec' + whitespace + 4 characters *\/\n-      parser->root.limit  = cur + 10;\n+      parser->root.limit  = parser->base_dict + parser->base_len;\n@@ -375,2 +350,2 @@\n-        if ( cur[0] == 'e'   &&\n-             cur + 5 < limit )\n+        \/* 9 = 5 letters for `eexec' + whitespace + 4 chars *\/\n+        if ( cur[0] == 'e' && cur + 9 < limit )\n@@ -392,15 +367,3 @@\n-      \/* we haven't found the correct `eexec'; go back and continue *\/\n-      \/* searching                                                  *\/\n-\n-      cur   = limit;\n-      limit = parser->base_dict + parser->base_len;\n-\n-      if ( cur >= limit )\n-      {\n-        FT_ERROR(( \"T1_Get_Private_Dict:\"\n-                   \" premature end in private dictionary\\n\" ));\n-        error = FT_THROW( Invalid_File_Format );\n-        goto Exit;\n-      }\n-\n-      goto Again;\n+      FT_ERROR(( \"T1_Get_Private_Dict: could not find `eexec' keyword\\n\" ));\n+      error = FT_THROW( Invalid_File_Format );\n+      goto Exit;\n@@ -453,1 +416,1 @@\n-        if ( FT_ALLOC( parser->private_dict, size + 1 ) )\n+        if ( FT_QALLOC( parser->private_dict, size + 1 ) )\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1parse.c","additions":14,"deletions":51,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1parse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2024 by\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libfreetype\/src\/type1\/t1tokens.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}