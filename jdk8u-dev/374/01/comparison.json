{"files":[{"patch":"@@ -35,0 +35,12 @@\n+DirtyCardQueue::DirtyCardQueue(DirtyCardQueueSet* qset, bool permanent) :\n+  \/\/ Dirty card queues are always active, so we create them with their\n+  \/\/ active field set to true.\n+  PtrQueue(qset, permanent, true \/* active *\/)\n+{ }\n+\n+DirtyCardQueue::~DirtyCardQueue() {\n+  if (!is_permanent()) {\n+    flush();\n+  }\n+}\n+\n@@ -43,1 +55,3 @@\n-    if (res && consume) _index = _sz;\n+    if (res && consume) {\n+      _index = _sz;\n+    }\n@@ -54,3 +68,3 @@\n-  for (size_t i = index; i < sz; i += oopSize) {\n-    int ind = byte_index_to_index((int)i);\n-    jbyte* card_ptr = (jbyte*)buf[ind];\n+  size_t limit = byte_index_to_index(sz);\n+  for (size_t i = byte_index_to_index(index); i < limit; ++i) {\n+    jbyte* card_ptr = static_cast<jbyte*>(buf[i]);\n@@ -60,2 +74,6 @@\n-      if (consume) buf[ind] = NULL;\n-      if (!cl->do_card_ptr(card_ptr, worker_i)) return false;\n+      if (consume) {\n+        buf[i] = NULL;\n+      }\n+      if (!cl->do_card_ptr(card_ptr, worker_i)) {\n+        return false;\n+      }\n@@ -74,1 +92,1 @@\n-  _shared_dirty_card_queue(this, true \/*perm*\/),\n+  _shared_dirty_card_queue(this, true \/* permanent *\/),\n@@ -86,1 +104,3 @@\n-void DirtyCardQueueSet::initialize(CardTableEntryClosure* cl, Monitor* cbl_mon, Mutex* fl_lock,\n+void DirtyCardQueueSet::initialize(CardTableEntryClosure* cl,\n+                                   Monitor* cbl_mon,\n+                                   Mutex* fl_lock,\n@@ -89,1 +109,2 @@\n-                                   Mutex* lock, PtrQueueSet* fl_owner) {\n+                                   Mutex* lock,\n+                                   DirtyCardQueueSet* fl_owner) {\n@@ -91,2 +112,5 @@\n-  PtrQueueSet::initialize(cbl_mon, fl_lock, process_completed_threshold,\n-                          max_completed_queue, fl_owner);\n+  PtrQueueSet::initialize(cbl_mon,\n+                          fl_lock,\n+                          process_completed_threshold,\n+                          max_completed_queue,\n+                          fl_owner);\n@@ -106,1 +130,1 @@\n-  for(JavaThread* t = Threads::first(); t; t = t->next()) {\n+  for (JavaThread* t = Threads::first(); t; t = t->next()) {\n@@ -163,2 +187,1 @@\n-BufferNode*\n-DirtyCardQueueSet::get_completed_buffer(int stop_at) {\n+BufferNode* DirtyCardQueueSet::get_completed_buffer(int stop_at) {\n@@ -181,1 +204,1 @@\n-  debug_only(assert_completed_buffer_list_len_correct_locked());\n+  DEBUG_ONLY(assert_completed_buffer_list_len_correct_locked());\n@@ -185,2 +208,1 @@\n-bool DirtyCardQueueSet::\n-apply_closure_to_completed_buffer_helper(CardTableEntryClosure* cl,\n+bool DirtyCardQueueSet::apply_closure_to_completed_buffer_helper(CardTableEntryClosure* cl,\n@@ -262,1 +284,1 @@\n-    debug_only(assert_completed_buffer_list_len_correct_locked());\n+    DEBUG_ONLY(assert_completed_buffer_list_len_correct_locked());\n@@ -294,1 +316,1 @@\n-      void **buf = t->dirty_card_queue().get_buf();\n+      void **buf = dcq.get_buf();\n@@ -296,2 +318,3 @@\n-      for (size_t i = 0; i < t->dirty_card_queue().get_index(); i += oopSize) {\n-        buf[PtrQueue::byte_index_to_index((int)i)] = NULL;\n+      size_t limit = dcq.byte_index_to_index(dcq.get_index());\n+      for (size_t i = 0; i < limit; ++i) {\n+        buf[i] = NULL;\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/dirtyCardQueue.cpp","additions":44,"deletions":21,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class DirtyCardQueueSet;\n@@ -45,4 +46,1 @@\n-  DirtyCardQueue(PtrQueueSet* qset_, bool perm = false) :\n-    \/\/ Dirty card queues are always active, so we create them with their\n-    \/\/ active field set to true.\n-    PtrQueue(qset_, perm, true \/* active *\/) { }\n+  DirtyCardQueue(DirtyCardQueueSet* qset, bool permanent = false);\n@@ -52,1 +50,1 @@\n-  ~DirtyCardQueue() { if (!is_permanent()) flush(); }\n+  ~DirtyCardQueue();\n@@ -75,1 +73,0 @@\n-  void set_buf(void **buf) {_buf = buf;}\n@@ -104,1 +101,3 @@\n-  void initialize(CardTableEntryClosure* cl, Monitor* cbl_mon, Mutex* fl_lock,\n+  void initialize(CardTableEntryClosure* cl,\n+                  Monitor* cbl_mon,\n+                  Mutex* fl_lock,\n@@ -107,1 +106,2 @@\n-                  Mutex* lock, PtrQueueSet* fl_owner = NULL);\n+                  Mutex* lock,\n+                  DirtyCardQueueSet* fl_owner = NULL);\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/dirtyCardQueue.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-PtrQueue::PtrQueue(PtrQueueSet* qset, bool perm, bool active) :\n+PtrQueue::PtrQueue(PtrQueueSet* qset, bool permanent, bool active) :\n@@ -35,1 +35,1 @@\n-  _perm(perm), _lock(NULL)\n+  _permanent(permanent), _lock(NULL)\n@@ -39,1 +39,1 @@\n-  assert(_perm || (_buf == NULL), \"queue must be flushed before delete\");\n+  assert(_permanent || (_buf == NULL), \"queue must be flushed before delete\");\n@@ -43,1 +43,1 @@\n-  if (!_perm && _buf != NULL) {\n+  if (!_permanent && _buf != NULL) {\n@@ -49,2 +49,3 @@\n-      for (size_t i = 0; i < _index; i += oopSize) {\n-        _buf[byte_index_to_index((int)i)] = NULL;\n+      size_t limit = byte_index_to_index(_index);\n+      for (size_t i = 0; i < limit; ++i) {\n+        _buf[i] = NULL;\n@@ -69,2 +70,2 @@\n-  _index -= oopSize;\n-  _buf[byte_index_to_index((int)_index)] = ptr;\n+  _index -= sizeof(void*);\n+  _buf[byte_index_to_index(_index)] = ptr;\n@@ -103,0 +104,20 @@\n+PtrQueueSet::~PtrQueueSet() {\n+  \/\/ There are presently only a couple (derived) instances ever\n+  \/\/ created, and they are permanent, so no harm currently done by\n+  \/\/ doing nothing here.\n+}\n+\n+void PtrQueueSet::initialize(Monitor* cbl_mon,\n+                             Mutex* fl_lock,\n+                             int process_completed_threshold,\n+                             int max_completed_queue,\n+                             PtrQueueSet *fl_owner) {\n+  _max_completed_queue = max_completed_queue;\n+  _process_completed_threshold = process_completed_threshold;\n+  _completed_queue_padding = 0;\n+  assert(cbl_mon != NULL && fl_lock != NULL, \"Init order issue?\");\n+  _cbl_mon = cbl_mon;\n+  _fl_lock = fl_lock;\n+  _fl_owner = (fl_owner != NULL) ? fl_owner : this;\n+}\n+\n@@ -237,1 +258,1 @@\n-  debug_only(assert_completed_buffer_list_len_correct_locked());\n+  DEBUG_ONLY(assert_completed_buffer_list_len_correct_locked());\n@@ -262,1 +283,1 @@\n-  _sz = sz * oopSize;\n+  _sz = sz * sizeof(void*);\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/ptrQueue.cpp","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -43,1 +43,4 @@\n-protected:\n+  \/\/ Noncopyable - not defined.\n+  PtrQueue(const PtrQueue&);\n+  PtrQueue& operator=(const PtrQueue&);\n+\n@@ -45,1 +48,1 @@\n-  PtrQueueSet* _qset;\n+  PtrQueueSet* const _qset;\n@@ -50,0 +53,6 @@\n+  \/\/ If true, the queue is permanent, and doesn't need to deallocate\n+  \/\/ its buffer in the destructor (since that obtains a lock which may not\n+  \/\/ be legally locked by then.\n+  const bool _permanent;\n+\n+protected:\n@@ -52,1 +61,1 @@\n-  \/\/ The index at which an object was last enqueued.  Starts at \"_sz\"\n+  \/\/ The (byte) index at which an object was last enqueued.  Starts at \"_sz\"\n@@ -56,1 +65,1 @@\n-  \/\/ The size of the buffer.\n+  \/\/ The (byte) size of the buffer.\n@@ -59,5 +68,0 @@\n-  \/\/ If true, the queue is permanent, and doesn't need to deallocate\n-  \/\/ its buffer in the destructor (since that obtains a lock which may not\n-  \/\/ be legally locked by then.\n-  bool _perm;\n-\n@@ -68,1 +72,1 @@\n-  bool is_permanent() const { return _perm; }\n+  bool is_permanent() const { return _permanent; }\n@@ -73,1 +77,0 @@\n-public:\n@@ -76,1 +79,1 @@\n-  PtrQueue(PtrQueueSet* qset, bool perm = false, bool active = false);\n+  PtrQueue(PtrQueueSet* qset, bool permanent  = false, bool active = false);\n@@ -81,0 +84,2 @@\n+public:\n+\n@@ -132,7 +137,3 @@\n-  static int byte_index_to_index(int ind) {\n-    assert((ind % oopSize) == 0, \"Invariant.\");\n-    return ind \/ oopSize;\n-  }\n-\n-  static int index_to_byte_index(int byte_ind) {\n-    return byte_ind * oopSize;\n+  static size_t byte_index_to_index(size_t ind) {\n+    assert((ind % sizeof(void*)) == 0, \"Invariant.\");\n+    return ind \/ sizeof(void*);\n@@ -249,1 +250,0 @@\n-public:\n@@ -252,0 +252,1 @@\n+  ~PtrQueueSet();\n@@ -255,1 +256,2 @@\n-  void initialize(Monitor* cbl_mon, Mutex* fl_lock,\n+  void initialize(Monitor* cbl_mon,\n+                  Mutex* fl_lock,\n@@ -258,9 +260,3 @@\n-                  PtrQueueSet *fl_owner = NULL) {\n-    _max_completed_queue = max_completed_queue;\n-    _process_completed_threshold = process_completed_threshold;\n-    _completed_queue_padding = 0;\n-    assert(cbl_mon != NULL && fl_lock != NULL, \"Init order issue?\");\n-    _cbl_mon = cbl_mon;\n-    _fl_lock = fl_lock;\n-    _fl_owner = (fl_owner != NULL) ? fl_owner : this;\n-  }\n+                  PtrQueueSet *fl_owner = NULL);\n+\n+public:\n@@ -268,1 +264,1 @@\n-  \/\/ Return an empty oop array of size _sz (required to be non-zero).\n+  \/\/ Return an empty array of size _sz (required to be non-zero).\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/ptrQueue.hpp","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -38,0 +38,9 @@\n+ObjPtrQueue::ObjPtrQueue(SATBMarkQueueSet* qset, bool permanent) :\n+  \/\/ SATB queues are only active during marking cycles. We create\n+  \/\/ them with their active field set to false. If a thread is\n+  \/\/ created during a cycle and its SATB queue needs to be activated\n+  \/\/ before the thread starts running, we'll need to set its active\n+  \/\/ field to true. This is done in JavaThread::initialize_queues().\n+  PtrQueue(qset, permanent, false \/* active *\/)\n+{ }\n+\n@@ -104,1 +113,0 @@\n-  size_t sz = _sz;\n@@ -112,1 +120,1 @@\n-  debug_only(size_t entries = 0; size_t retained = 0;)\n+  DEBUG_ONLY(size_t entries = 0; size_t retained = 0;)\n@@ -114,2 +122,4 @@\n-  size_t i = sz;\n-  size_t new_index = sz;\n+  assert(_index <= _sz, \"invariant\");\n+  void** limit = &buf[byte_index_to_index(_index)];\n+  void** src = &buf[byte_index_to_index(_sz)];\n+  void** dst = src;\n@@ -117,6 +127,4 @@\n-  while (i > _index) {\n-    assert(i > 0, \"we should have at least one more entry to process\");\n-    i -= oopSize;\n-    debug_only(entries += 1;)\n-    void** p = &buf[byte_index_to_index((int) i)];\n-    void* entry = *p;\n+  while (limit < src) {\n+    DEBUG_ONLY(entries += 1;)\n+    --src;\n+    void* entry = *src;\n@@ -127,1 +135,1 @@\n-    *p = NULL;\n+    *src = NULL;\n@@ -130,11 +138,4 @@\n-      assert(new_index > 0, \"we should not have already filled up the buffer\");\n-      new_index -= oopSize;\n-      assert(new_index >= i,\n-             \"new_index should never be below i, as we alwaysr compact 'up'\");\n-      void** new_p = &buf[byte_index_to_index((int) new_index)];\n-      assert(new_p >= p, \"the destination location should never be below \"\n-             \"the source as we always compact 'up'\");\n-      assert(*new_p == NULL,\n-             \"we should have already cleared the destination location\");\n-      *new_p = entry;\n-      debug_only(retained += 1;)\n+      --dst;\n+      assert(*dst == NULL, \"filtering destination should be clear\");\n+      *dst = entry;\n+      DEBUG_ONLY(retained += 1;);\n@@ -143,0 +144,1 @@\n+  size_t new_index = pointer_delta(dst, buf, 1);\n@@ -145,1 +147,1 @@\n-  size_t entries_calc = (sz - _index) \/ oopSize;\n+  size_t entries_calc = (_sz - _index) \/ sizeof(void*);\n@@ -148,1 +150,1 @@\n-  size_t retained_calc = (sz - new_index) \/ oopSize;\n+  size_t retained_calc = (_sz - new_index) \/ sizeof(void*);\n@@ -175,5 +177,2 @@\n-  size_t sz = _sz;\n-  size_t all_entries = sz \/ oopSize;\n-  size_t retained_entries = (sz - _index) \/ oopSize;\n-  size_t perc = retained_entries * 100 \/ all_entries;\n-  bool should_enqueue = perc > (size_t) G1SATBBufferEnqueueingThresholdPercent;\n+  size_t percent_used = ((_sz - _index) * 100) \/ _sz;\n+  bool should_enqueue = percent_used > G1SATBBufferEnqueueingThresholdPercent;\n@@ -190,2 +189,2 @@\n-    cl->do_buffer(_buf + byte_index_to_index((int)_index),\n-                  byte_index_to_index((int)(_sz - _index)));\n+    cl->do_buffer(_buf + byte_index_to_index(_index),\n+                  byte_index_to_index(_sz - _index));\n@@ -217,1 +216,1 @@\n-  _shared_satb_queue(this, true \/*perm*\/) { }\n+  _shared_satb_queue(this, true \/* permanent *\/) { }\n@@ -304,1 +303,1 @@\n-    size_t limit = ObjPtrQueue::byte_index_to_index((int)_sz);\n+    size_t limit = ObjPtrQueue::byte_index_to_index(_sz);\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/satbQueue.cpp","additions":32,"deletions":33,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -53,7 +53,1 @@\n-  ObjPtrQueue(PtrQueueSet* qset, bool perm = false) :\n-    \/\/ SATB queues are only active during marking cycles. We create\n-    \/\/ them with their active field set to false. If a thread is\n-    \/\/ created during a cycle and its SATB queue needs to be activated\n-    \/\/ before the thread starts running, we'll need to set its active\n-    \/\/ field to true. This is done in JavaThread::initialize_queues().\n-    PtrQueue(qset, perm, false \/* active *\/) { }\n+  ObjPtrQueue(SATBMarkQueueSet* qset, bool permanent = false);\n","filename":"hotspot\/src\/share\/vm\/gc_implementation\/g1\/satbQueue.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test TestPtrQueueSize.java\n+* @key gc\n+* @bug 6899049\n+* @summary Test size of PtrQueue; used by dirtyCardQueue and satbQueue\n+* @library \/testlibrary\n+*\/\n+\n+import com.oracle.java.testlibrary.ProcessTools;\n+import com.oracle.java.testlibrary.OutputAnalyzer;\n+\n+ public class TestPtrQueueSize {\n+    public static void main(String[] args) throws Exception {\n+\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                              \"-XX:G1SATBBufferSize=716M\",\n+                                                              \"-Xms1024m\",\n+                                                              \"-Xmx2048m\",\n+                                                              SystemGCTest.class.getName());\n+\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+    System.out.println(\"Output:\\n\" + output.getOutput());\n+\n+    output.shouldHaveExitValue(0);\n+  }\n+\n+  static class SystemGCTest {\n+    public static void main(String [] args) {\n+      for (int i = 0; i < 500; ++i) {\n+        byte[] bArray = new byte[1024*1024];\n+      }\n+    }\n+  }\n+ }\n","filename":"hotspot\/test\/gc\/g1\/TestPtrQueueSize.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}