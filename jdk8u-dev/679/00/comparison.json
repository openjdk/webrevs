{"files":[{"patch":"@@ -1728,1 +1728,1 @@\n-%% This notice is provided with respect to Little CMS 2.15, which may be\n+%% This notice is provided with respect to Little CMS 2.16, which may be\n@@ -1733,1 +1733,1 @@\n-README.1ST file information\n+MIT License\n@@ -1735,6 +1735,1 @@\n-LittleCMS core is released under MIT License\n-\n----------------------------------\n-\n-Little CMS\n-Copyright (c) 1998-2023 Marti Maria Saguer\n+Copyright (C) 1998-2023 Marti Maria Saguer\n@@ -1743,6 +1738,5 @@\n-a copy of this software and associated documentation files (the\n-\"Software\"), to deal in the Software without restriction, including\n-without limitation the rights to use, copy, modify, merge, publish,\n-distribute, sublicense, and\/or sell copies of the Software, and to\n-permit persons to whom the Software is furnished to do so, subject\n-to the following conditions:\n+a copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following conditions:\n@@ -1750,2 +1744,2 @@\n-The above copyright notice and this permission notice shall be\n-included in all copies or substantial portions of the Software.\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n@@ -1754,6 +1748,6 @@\n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n+THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n@@ -1775,1 +1769,0 @@\n-\n@@ -1819,0 +1812,1 @@\n+Diogo Teles Sant'Anna\n","filename":"THIRD_PARTY_README","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-void ComputeIncrementsForChunky(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForChunky(cmsUInt32Number Format,\n@@ -448,1 +448,1 @@\n-           return;\n+           return FALSE;\n@@ -485,0 +485,2 @@\n+\n+       return TRUE;\n@@ -491,1 +493,1 @@\n-void ComputeIncrementsForPlanar(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForPlanar(cmsUInt32Number Format,\n@@ -505,1 +507,1 @@\n-           return;\n+           return FALSE;\n@@ -541,0 +543,2 @@\n+\n+       return TRUE;\n@@ -547,1 +551,1 @@\n-void  ComputeComponentIncrements(cmsUInt32Number Format,\n+cmsBool ComputeComponentIncrements(cmsUInt32Number Format,\n@@ -554,1 +558,1 @@\n-              ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n@@ -557,1 +561,1 @@\n-              ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n@@ -562,2 +566,0 @@\n-\n-\n@@ -598,2 +600,4 @@\n-    ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements);\n-    ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements);\n+    if (!ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements))\n+        return;\n+    if (!ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements))\n+        return;\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsalpha.c","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        \/\/ Keywords\n+        \/\/ IT8 symbols\n@@ -98,1 +98,13 @@\n-        SINCLUDE\n+        SINCLUDE,\n+\n+        \/\/ Cube symbols\n+\n+        SDOMAIN_MAX,\n+        SDOMAIN_MIN,\n+        S_LUT1D_SIZE,\n+        S_LUT1D_INPUT_RANGE,\n+        S_LUT3D_SIZE,\n+        S_LUT3D_INPUT_RANGE,\n+        S_LUT_IN_VIDEO_RANGE,\n+        S_LUT_OUT_VIDEO_RANGE,\n+        STITLE\n@@ -181,0 +193,4 @@\n+        \/\/ Partser type\n+        cmsBool        IsCUBE;\n+\n+        \/\/ Tables\n@@ -240,2 +256,2 @@\n-\/\/ The keyword->symbol translation table. Sorting is required.\n-static const KEYWORD TabKeys[] = {\n+\/\/ The keyword->symbol translation tables. Sorting is required.\n+static const KEYWORD TabKeysIT8[] = {\n@@ -254,1 +270,19 @@\n-#define NUMKEYS (sizeof(TabKeys)\/sizeof(KEYWORD))\n+#define NUMKEYS_IT8 (sizeof(TabKeysIT8)\/sizeof(KEYWORD))\n+\n+static const KEYWORD TabKeysCUBE[] = {\n+\n+        {\"DOMAIN_MAX\",             SDOMAIN_MAX },\n+        {\"DOMAIN_MIN\",             SDOMAIN_MIN },\n+        {\"LUT_1D_SIZE\",            S_LUT1D_SIZE },\n+        {\"LUT_1D_INPUT_RANGE\",     S_LUT1D_INPUT_RANGE },\n+        {\"LUT_3D_SIZE\",            S_LUT3D_SIZE },\n+        {\"LUT_3D_INPUT_RANGE\",     S_LUT3D_INPUT_RANGE },\n+        {\"LUT_IN_VIDEO_RANGE\",     S_LUT_IN_VIDEO_RANGE },\n+        {\"LUT_OUT_VIDEO_RANGE\",    S_LUT_OUT_VIDEO_RANGE },\n+        {\"TITLE\",                  STITLE }\n+\n+};\n+\n+#define NUMKEYS_CUBE (sizeof(TabKeysCUBE)\/sizeof(KEYWORD))\n+\n+\n@@ -458,1 +492,1 @@\n-    return (c == ' ') || (c == '\\t') ;\n+    return (c == ' ') || (c == '\\t');\n@@ -479,1 +513,1 @@\n-     return !isdigit(c) && ismiddle(c);\n+     return c != '-' && !isdigit(c) && ismiddle(c);\n@@ -518,1 +552,1 @@\n-        strncpy(buffer, relPath, MaxLen);\n+        memcpy(buffer, relPath, MaxLen);\n@@ -524,1 +558,1 @@\n-    strncpy(buffer, basePath, MaxLen);\n+    memcpy(buffer, basePath, MaxLen);\n@@ -606,1 +640,1 @@\n-SYMBOL BinSrchKey(const char *id)\n+SYMBOL BinSrchKey(const char *id, int NumKeys, const KEYWORD* TabKeys)\n@@ -609,1 +643,1 @@\n-    int r = NUMKEYS;\n+    int r = NumKeys;\n@@ -779,1 +813,1 @@\n-\/\/ Reads a string, special case to avoid infinite resursion on .include\n+\/\/ Reads a string, special case to avoid infinite recursion on .include\n@@ -836,1 +870,3 @@\n-            key = BinSrchKey(StringPtr(it8->id));\n+            key = BinSrchKey(StringPtr(it8->id),\n+                    it8->IsCUBE ? NUMKEYS_CUBE : NUMKEYS_IT8,\n+                    it8->IsCUBE ? TabKeysCUBE : TabKeysIT8);\n@@ -945,0 +981,1 @@\n+                    StringClear(it8->id);\n@@ -974,1 +1011,1 @@\n-            if (it8 ->ch == '\\n')\n+            if (it8->ch == '\\n')\n@@ -1295,1 +1332,6 @@\n-        \/\/     return SynError(it8, \"duplicate key <%s>\", Key);\n+        if (cmsstrcasecmp(Key, \"NUMBER_OF_FIELDS\") == 0 ||\n+            cmsstrcasecmp(Key, \"NUMBER_OF_SETS\") == 0) {\n+\n+            SynError(it8, \"duplicate key <%s>\", Key);\n+            return NULL;\n+        }\n@@ -1416,0 +1458,2 @@\n+    it8->IsCUBE = FALSE;\n+\n@@ -1697,1 +1741,1 @@\n-    if (nSet >= nPatches || nField >= nSamples)\n+    if (nSet < 0 || nSet >= nPatches || nField < 0 || nField >= nSamples)\n@@ -1882,1 +1926,1 @@\n-       for (i = 0; i < nSamples; i++) {\n+       if (nSamples <= t->nSamples) {\n@@ -1884,3 +1928,6 @@\n-              WriteStr(fp, t->DataFormat[i]);\n-              WriteStr(fp, ((i == (nSamples-1)) ? \"\\n\" : \"\\t\"));\n-          }\n+           for (i = 0; i < nSamples; i++) {\n+\n+               WriteStr(fp, t->DataFormat[i]);\n+               WriteStr(fp, ((i == (nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+           }\n+       }\n@@ -1896,1 +1943,1 @@\n-       int  i, j;\n+       int  i, j, nPatches;\n@@ -1903,1 +1950,1 @@\n-       t->nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n+       nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n@@ -1905,1 +1952,1 @@\n-       for (i = 0; i < t-> nPatches; i++) {\n+       if (nPatches <= t->nPatches) {\n@@ -1907,1 +1954,1 @@\n-              WriteStr(fp, \" \");\n+           for (i = 0; i < nPatches; i++) {\n@@ -1909,1 +1956,1 @@\n-              for (j = 0; j < t->nSamples; j++) {\n+               WriteStr(fp, \" \");\n@@ -1911,1 +1958,1 @@\n-                     char *ptr = t->Data[i*t->nSamples+j];\n+               for (j = 0; j < t->nSamples; j++) {\n@@ -1913,3 +1960,1 @@\n-                     if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n-                     else {\n-                         \/\/ If value contains whitespace, enclose within quote\n+                   char* ptr = t->Data[i * t->nSamples + j];\n@@ -1917,1 +1962,3 @@\n-                         if (strchr(ptr, ' ') != NULL) {\n+                   if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n+                   else {\n+                       \/\/ If value contains whitespace, enclose within quote\n@@ -1919,7 +1966,1 @@\n-                             WriteStr(fp, \"\\\"\");\n-                             WriteStr(fp, ptr);\n-                             WriteStr(fp, \"\\\"\");\n-                         }\n-                         else\n-                            WriteStr(fp, ptr);\n-                     }\n+                       if (strchr(ptr, ' ') != NULL) {\n@@ -1927,2 +1968,11 @@\n-                     WriteStr(fp, ((j == (t->nSamples-1)) ? \"\\n\" : \"\\t\"));\n-              }\n+                           WriteStr(fp, \"\\\"\");\n+                           WriteStr(fp, ptr);\n+                           WriteStr(fp, \"\\\"\");\n+                       }\n+                       else\n+                           WriteStr(fp, ptr);\n+                   }\n+\n+                   WriteStr(fp, ((j == (t->nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+               }\n+           }\n@@ -1949,4 +1999,14 @@\n-            cmsIT8SetTable(hIT8, i);\n-            WriteHeader(it8, &sd);\n-            WriteDataFormat(&sd, it8);\n-            WriteData(&sd, it8);\n+        TABLE* t;\n+\n+        if (cmsIT8SetTable(hIT8, i) < 0) goto Error;\n+\n+        \/**\n+        * Check for wrong data\n+        *\/\n+        t = GetTable(it8);\n+        if (t->Data == NULL) goto Error;\n+        if (t->DataFormat == NULL) goto Error;\n+\n+        WriteHeader(it8, &sd);\n+        WriteDataFormat(&sd, it8);\n+        WriteData(&sd, it8);\n@@ -1956,1 +2016,0 @@\n-\n@@ -1958,0 +2017,5 @@\n+\n+Error:\n+    fclose(sd.stream);\n+    return FALSE;\n+\n@@ -2334,1 +2398,1 @@\n-    cmsUInt32Number nOldTable = it8 ->nTable;\n+    cmsUInt32Number nOldTable = it8->nTable;\n@@ -2336,1 +2400,1 @@\n-    for (j=0; j < it8 ->TablesCount; j++) {\n+    for (j = 0; j < it8->TablesCount; j++) {\n@@ -2338,1 +2402,1 @@\n-    TABLE* t = it8 ->Tab + j;\n+        TABLE* t = it8->Tab + j;\n@@ -2340,2 +2404,2 @@\n-    t -> SampleID = 0;\n-    it8 ->nTable = j;\n+        t->SampleID = 0;\n+        it8->nTable = j;\n@@ -2343,6 +2407,6 @@\n-    for (idField = 0; idField < t -> nSamples; idField++)\n-    {\n-        if (t ->DataFormat == NULL){\n-            SynError(it8, \"Undefined DATA_FORMAT\");\n-            return;\n-        }\n+        for (idField = 0; idField < t->nSamples; idField++)\n+        {\n+            if (t->DataFormat == NULL) {\n+                SynError(it8, \"Undefined DATA_FORMAT\");\n+                return;\n+            }\n@@ -2350,2 +2414,2 @@\n-        Fld = t->DataFormat[idField];\n-        if (!Fld) continue;\n+            Fld = t->DataFormat[idField];\n+            if (!Fld) continue;\n@@ -2354,1 +2418,1 @@\n-        if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n+            if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n@@ -2356,2 +2420,2 @@\n-            t -> SampleID = idField;\n-        }\n+                t->SampleID = idField;\n+            }\n@@ -2359,1 +2423,1 @@\n-        \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n+            \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n@@ -2361,1 +2425,1 @@\n-        if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n+            if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n@@ -2363,2 +2427,2 @@\n-            \/\/ Search for table references...\n-            for (i = 0; i < t->nPatches; i++) {\n+                \/\/ Search for table references...\n+                for (i = 0; i < t->nPatches; i++) {\n@@ -2366,1 +2430,1 @@\n-                char* Label = GetData(it8, i, idField);\n+                    char* Label = GetData(it8, i, idField);\n@@ -2368,1 +2432,1 @@\n-                if (Label) {\n+                    if (Label) {\n@@ -2370,1 +2434,1 @@\n-                    cmsUInt32Number k;\n+                        cmsUInt32Number k;\n@@ -2372,2 +2436,2 @@\n-                    \/\/ This is the label, search for a table containing\n-                    \/\/ this property\n+                        \/\/ This is the label, search for a table containing\n+                        \/\/ this property\n@@ -2375,1 +2439,1 @@\n-                    for (k = 0; k < it8->TablesCount; k++) {\n+                        for (k = 0; k < it8->TablesCount; k++) {\n@@ -2377,2 +2441,2 @@\n-                        TABLE* Table = it8->Tab + k;\n-                        KEYVALUE* p;\n+                            TABLE* Table = it8->Tab + k;\n+                            KEYVALUE* p;\n@@ -2380,1 +2444,1 @@\n-                        if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n+                            if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n@@ -2382,2 +2446,2 @@\n-                            \/\/ Available, keep type and table\n-                            char Buffer[256];\n+                                \/\/ Available, keep type and table\n+                                char Buffer[256];\n@@ -2385,2 +2449,2 @@\n-                            char* Type = p->Value;\n-                            int  nTable = (int)k;\n+                                char* Type = p->Value;\n+                                int  nTable = (int)k;\n@@ -2388,1 +2452,1 @@\n-                            snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n+                                snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n@@ -2390,1 +2454,2 @@\n-                            SetData(it8, i, idField, Buffer);\n+                                SetData(it8, i, idField, Buffer);\n+                            }\n@@ -2393,2 +2458,0 @@\n-\n-\n@@ -2396,1 +2459,0 @@\n-\n@@ -2398,2 +2460,0 @@\n-\n-\n@@ -2401,2 +2461,0 @@\n-\n-    }\n@@ -2405,1 +2463,1 @@\n-    it8 ->nTable = nOldTable;\n+    it8->nTable = nOldTable;\n@@ -2496,1 +2554,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2508,1 +2566,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2605,8 +2663,2 @@\n-        Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n-        if (Props != NULL) {\n-\n-                \/\/ Pass#2 - Fill pointers\n-                n = 0;\n-                for (p = t->HeaderList; p != NULL; p = p->Next) {\n-                        Props[n++] = p->Keyword;\n-                }\n+    Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n+    if (Props != NULL) {\n@@ -2614,0 +2666,4 @@\n+        \/\/ Pass#2 - Fill pointers\n+        n = 0;\n+        for (p = t->HeaderList; p != NULL; p = p->Next) {\n+            Props[n++] = p->Keyword;\n@@ -2615,1 +2671,3 @@\n-        *PropertyNames = Props;\n+\n+    }\n+    *PropertyNames = Props;\n@@ -2975,0 +3033,233 @@\n+\n+static\n+cmsBool ReadNumbers(cmsIT8* cube, int n, cmsFloat64Number* arr)\n+{\n+    int i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (cube->sy == SINUM)\n+            arr[i] = cube->inum;\n+        else\n+            if (cube->sy == SDNUM)\n+                arr[i] = cube->dnum;\n+            else\n+                return SynError(cube, \"Number expected\");\n+\n+        InSymbol(cube);\n+    }\n+\n+    return CheckEOLN(cube);\n+}\n+\n+static\n+cmsBool ParseCube(cmsIT8* cube, cmsStage** Shaper, cmsStage** CLUT, char title[])\n+{\n+    cmsFloat64Number domain_min[3] = { 0, 0, 0 };\n+    cmsFloat64Number domain_max[3] = { 1.0, 1.0, 1.0 };\n+    cmsFloat64Number check_0_1[2] = { 0, 1.0 };\n+    int shaper_size = 0;\n+    int lut_size = 0;\n+    int i;\n+\n+    InSymbol(cube);\n+\n+    while (cube->sy != SEOF) {\n+        switch (cube->sy)\n+        {\n+        \/\/ Set profile description\n+        case STITLE:\n+            InSymbol(cube);\n+            if (!Check(cube, SSTRING, \"Title string expected\")) return FALSE;\n+            memcpy(title, StringPtr(cube->str), MAXSTR);\n+            title[MAXSTR - 1] = 0;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Define domain\n+        case SDOMAIN_MIN:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_min)) return FALSE;\n+            break;\n+\n+        case SDOMAIN_MAX:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_max)) return FALSE;\n+            break;\n+\n+        \/\/ Define shaper\n+        case S_LUT1D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"Shaper size expected\")) return FALSE;\n+            shaper_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Deefine CLUT\n+        case S_LUT3D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"LUT size expected\")) return FALSE;\n+            lut_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Range. If present, has to be 0..1.0\n+        case S_LUT1D_INPUT_RANGE:\n+        case S_LUT3D_INPUT_RANGE:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 2, check_0_1)) return FALSE;\n+            if (check_0_1[0] != 0 || check_0_1[1] != 1.0) {\n+                return SynError(cube, \"Unsupported format\");\n+            }\n+            break;\n+\n+        case SEOLN:\n+            InSymbol(cube);\n+            break;\n+\n+        default:\n+        case S_LUT_IN_VIDEO_RANGE:\n+        case S_LUT_OUT_VIDEO_RANGE:\n+            return SynError(cube, \"Unsupported format\");\n+\n+            \/\/ Read and create tables\n+        case SINUM:\n+        case SDNUM:\n+\n+            if (shaper_size > 0) {\n+\n+                cmsToneCurve* curves[3];\n+                cmsFloat32Number* shapers = (cmsFloat32Number*)_cmsMalloc(cube->ContextID, 3 * shaper_size * sizeof(cmsFloat32Number));\n+                if (shapers == NULL) return FALSE;\n+\n+                for (i = 0; i < shaper_size; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    shapers[i + 0]               = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    shapers[i + 1 * shaper_size] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    shapers[i + 2 * shaper_size] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                for (i = 0; i < 3; i++) {\n+\n+                    curves[i] = cmsBuildTabulatedToneCurveFloat(cube->ContextID, shaper_size,\n+                        &shapers[i * shaper_size]);\n+                    if (curves[i] == NULL) return FALSE;\n+                }\n+\n+                *Shaper = cmsStageAllocToneCurves(cube->ContextID, 3, curves);\n+\n+                cmsFreeToneCurveTriple(curves);\n+            }\n+\n+            if (lut_size > 0) {\n+\n+                int nodes = lut_size * lut_size * lut_size;\n+\n+                cmsFloat32Number* lut_table = _cmsMalloc(cube->ContextID, nodes * 3 * sizeof(cmsFloat32Number));\n+                if (lut_table == NULL) return FALSE;\n+\n+                for (i = 0; i < nodes; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    lut_table[i * 3 + 2] = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    lut_table[i * 3 + 1] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    lut_table[i * 3 + 0] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                *CLUT = cmsStageAllocCLutFloat(cube->ContextID, lut_size, 3, 3, lut_table);\n+                _cmsFree(cube->ContextID, lut_table);\n+            }\n+\n+            if (!Check(cube, SEOF, \"Extra symbols found in file\")) return FALSE;\n+        }\n+    }\n+\n+    return TRUE;\n+}\n+\n+\/\/ Share the parser to read .cube format and create RGB devicelink profiles\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName)\n+{\n+    cmsHPROFILE hProfile = NULL;\n+    cmsIT8* cube = NULL;\n+    cmsPipeline* Pipeline = NULL;\n+    cmsStage* CLUT = NULL;\n+    cmsStage* Shaper = NULL;\n+    cmsMLU* DescriptionMLU = NULL;\n+    char title[MAXSTR];\n+\n+    _cmsAssert(cFileName != NULL);\n+\n+    cube = (cmsIT8*) cmsIT8Alloc(ContextID);\n+    if (!cube) return NULL;\n+\n+    cube->IsCUBE = TRUE;\n+    cube->FileStack[0]->Stream = fopen(cFileName, \"rt\");\n+\n+    if (!cube->FileStack[0]->Stream) goto Done;\n+\n+    strncpy(cube->FileStack[0]->FileName, cFileName, cmsMAX_PATH - 1);\n+    cube->FileStack[0]->FileName[cmsMAX_PATH - 1] = 0;\n+\n+    if (!ParseCube(cube, &Shaper, &CLUT, title)) goto Done;\n+\n+    \/\/ Success on parsing, let's create the profile\n+    hProfile = cmsCreateProfilePlaceholder(ContextID);\n+    if (!hProfile) goto Done;\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigLinkClass);\n+    cmsSetColorSpace(hProfile,  cmsSigRgbData);\n+    cmsSetPCS(hProfile,         cmsSigRgbData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_PERCEPTUAL);\n+\n+    \/\/ Creates a Pipeline to hold CLUT and shaper\n+    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);\n+    if (Pipeline == NULL) goto Done;\n+\n+    \/\/ Populates the pipeline\n+    if (Shaper != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Shaper))\n+            goto Done;\n+    }\n+\n+    if (CLUT != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT))\n+            goto Done;\n+    }\n+\n+    \/\/ Propagate the description. We put no copyright because we know\n+    \/\/ nothing on the copyrighted state of the .cube\n+    DescriptionMLU = cmsMLUalloc(ContextID, 1);\n+    if (!cmsMLUsetUTF8(DescriptionMLU, cmsNoLanguage, cmsNoCountry, title)) goto Done;\n+\n+    \/\/ Flush the tags\n+    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag, DescriptionMLU)) goto Done;\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, (void*)Pipeline)) goto Done;\n+\n+Done:\n+\n+    if (DescriptionMLU != NULL)\n+        cmsMLUfree(DescriptionMLU);\n+\n+    if (Pipeline != NULL)\n+        cmsPipelineFree(Pipeline);\n+\n+    cmsIT8Free((cmsHANDLE) cube);\n+\n+    return hProfile;\n+}\n+\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName)\n+{\n+    return cmsCreateDeviceLinkFromCubeFileTHR(NULL, cFileName);\n+}\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmscgats.c","additions":389,"deletions":98,"binary":false,"changes":487,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-    void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n+void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n@@ -747,0 +747,10 @@\n+\n+\/\/ Check whatever the profile is a CMYK->CMYK devicelink\n+static\n+cmsBool is_cmyk_devicelink(cmsHPROFILE hProfile)\n+{\n+    return cmsGetDeviceClass(hProfile) == cmsSigLinkClass &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData;\n+}\n+\n@@ -779,1 +789,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -781,3 +792,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -785,0 +794,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -787,0 +798,1 @@\n+\n@@ -803,1 +815,1 @@\n-                                     preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -815,1 +827,1 @@\n-                                    preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -1005,1 +1017,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -1007,3 +1020,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -1011,0 +1022,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -1180,2 +1193,1 @@\n-\n-    for (nIntents=0, pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n+    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n@@ -1194,1 +1206,1 @@\n-    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n+    for (pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n@@ -1206,0 +1218,1 @@\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmscnvrt.c","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-\/\/ amount of memoy that can be reclaimed. This is mostly as a safety feature to prevent\n+\/\/ amount of memory that can be reclaimed. This is mostly as a safety feature to prevent\n@@ -124,1 +124,2 @@\n-    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  \/\/ Never allow over maximum\n+    \/\/ Never allow 0 or over maximum\n+    if (size == 0 || size > MAX_MEMORY_FOR_ALLOC) return NULL;\n@@ -266,1 +267,1 @@\n-    \/\/ context internal data should be malloce'd by using those functions.\n+    \/\/ context internal data should be malloc'ed by using those functions.\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmserr.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -332,0 +332,4 @@\n+    for (i=0; i < nSegments; i++) {\n+        if (p ->Segments && p ->Segments[i].SampledPoints) _cmsFree(ContextID, p ->Segments[i].SampledPoints);\n+        if (p ->SegInterp && p ->SegInterp[i]) _cmsFree(ContextID, p ->SegInterp[i]);\n+    }\n@@ -625,4 +629,10 @@\n-        if (e < 0)\n-            Val = Params[3];\n-        else\n-            Val = pow(e, Params[0]) + Params[3];\n+        \/\/ On gamma 1.0, don't clamp\n+        if (Params[0] == 1.0) {\n+            Val = e + Params[3];\n+        }\n+        else {\n+            if (e < 0)\n+                Val = Params[3];\n+            else\n+                Val = pow(e, Params[0]) + Params[3];\n+        }\n@@ -1523,0 +1533,1 @@\n+\/\/ Retrieve segments on tone curves\n@@ -1524,3 +1535,1 @@\n-\/\/ Retrieve parameters on one-segment tone curves\n-\n-cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t)\n+const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t)\n@@ -1530,2 +1539,2 @@\n-    if (t->nSegments != 1) return NULL;\n-    return t->Segments[0].Params;\n+    if (n < 0 || n >= (cmsInt32Number) t->nSegments) return NULL;\n+    return t->Segments + n;\n@@ -1533,0 +1542,1 @@\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsgamma.c","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-    \/\/ Assume in-gamut by default.\n+    \/\/ Assume in-gamut by default. NEVER READ, USED FOR DEBUG PURPOSES.\n@@ -628,1 +628,1 @@\n-\/\/ The algorithm obtains Y from a syntetical gray R=G=B. Then least squares fitting is used to estimate gamma.\n+\/\/ The algorithm obtains Y from a synthetical gray R=G=B. Then least squares fitting is used to estimate gamma.\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsgmt.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -563,0 +563,14 @@\n+    \/\/ Set default CMM (that's me!)\n+    Icc ->CMM = lcmsSignature;\n+\n+    \/\/ Set default creator\n+    \/\/ Created by LittleCMS (that's me!)\n+    Icc ->creator = lcmsSignature;\n+\n+    \/\/ Set default platform\n+#ifdef CMS_IS_WINDOWS_\n+    Icc ->platform = cmsSigMicrosoft;\n+#else\n+    Icc ->platform = cmsSigMacintosh;\n+#endif\n+\n@@ -816,0 +830,1 @@\n+    Icc -> CMM             = _cmsAdjustEndianess32(Header.cmmId);\n@@ -821,0 +836,1 @@\n+    Icc -> platform        = (cmsPlatformSignature)_cmsAdjustEndianess32(Header.platform);\n@@ -925,1 +941,1 @@\n-    Header.cmmId       = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.cmmId       = _cmsAdjustEndianess32(Icc ->CMM);\n@@ -937,5 +953,1 @@\n-#ifdef CMS_IS_WINDOWS_\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMicrosoft);\n-#else\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMacintosh);\n-#endif\n+    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(Icc -> platform);\n@@ -957,2 +969,1 @@\n-    \/\/ Created by LittleCMS (that's me!)\n-    Header.creator      = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.creator      = _cmsAdjustEndianess32(Icc ->creator);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsio0.c","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -610,1 +610,1 @@\n-\/\/ Create an output MPE LUT from agiven profile. Version mismatches are handled here\n+\/\/ Create an output MPE LUT from a given profile. Version mismatches are handled here\n@@ -1059,0 +1059,10 @@\n+\n+cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                          const char LanguageCode[3], const char CountryCode[3],\n+                                                          char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const cmsMLU* mlu = GetInfo(hProfile, Info);\n+    if (mlu == NULL) return 0;\n+\n+    return cmsMLUgetUTF8(mlu, LanguageCode, CountryCode, Buffer, BufferSize);\n+}\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsio1.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -507,0 +507,3 @@\n+    \/\/ Again, prevent overflow\n+    if (rv > UINT_MAX \/ 15) return 0;\n+\n@@ -846,1 +849,7 @@\n-    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data;\n+    _cmsStageCLutData* clut;\n+\n+    if (mpe == NULL) return FALSE;\n+\n+    clut = (_cmsStageCLutData*)mpe->Data;\n+\n+    if (clut == NULL) return FALSE;\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmslut.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -232,0 +232,36 @@\n+}\n+\n+\n+\/\/ Convert from UTF8 to wchar, returns len.\n+static\n+cmsUInt32Number decodeUTF8(wchar_t* out, const char* in)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+\n+    while (*in)\n+    {\n+        cmsUInt8Number ch = (cmsUInt8Number) *in;\n+\n+        if (ch <= 0x7f)\n+        {\n+            codepoint = ch;\n+        }\n+        else if (ch <= 0xbf)\n+        {\n+            codepoint = (codepoint << 6) | (ch & 0x3f);\n+        }\n+        else if (ch <= 0xdf)\n+        {\n+            codepoint = ch & 0x1f;\n+        }\n+        else if (ch <= 0xef)\n+        {\n+            codepoint = ch & 0x0f;\n+        }\n+        else\n+        {\n+            codepoint = ch & 0x07;\n+        }\n+\n+        in++;\n@@ -233,0 +269,92 @@\n+        if (((*in & 0xc0) != 0x80) && (codepoint <= 0x10ffff))\n+        {\n+            if (sizeof(wchar_t) > 2)\n+            {\n+                if (out) *out++ = (wchar_t) codepoint;\n+                size++;\n+            }\n+            else\n+                if (codepoint > 0xffff)\n+                {\n+                    if (out)\n+                    {\n+                        *out++ = (wchar_t)(0xd800 + (codepoint >> 10));\n+                        *out++ = (wchar_t)(0xdc00 + (codepoint & 0x03ff));\n+                        size += 2;\n+                    }\n+                }\n+                else\n+                    if (codepoint < 0xd800 || codepoint >= 0xe000)\n+                    {\n+                        if (out) *out++ = (wchar_t) codepoint;\n+                        size++;\n+                    }\n+        }\n+    }\n+\n+    return size;\n+}\n+\n+\/\/ Convert from wchar_t to UTF8\n+static\n+cmsUInt32Number encodeUTF8(char* out, const wchar_t* in, cmsUInt32Number max_wchars, cmsUInt32Number max_chars)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+    cmsUInt32Number len_w = 0;\n+\n+    while (*in && len_w < max_wchars)\n+    {\n+        if (*in >= 0xd800 && *in <= 0xdbff)\n+            codepoint = ((*in - 0xd800) << 10) + 0x10000;\n+        else\n+        {\n+            if (*in >= 0xdc00 && *in <= 0xdfff)\n+                codepoint |= *in - 0xdc00;\n+            else\n+                codepoint = *in;\n+\n+            if (codepoint <= 0x7f)\n+            {\n+                if (out && (size + 1 < max_chars)) *out++ = (char)codepoint;\n+                size++;\n+            }\n+\n+            else if (codepoint <= 0x7ff)\n+            {\n+                if (out && (max_chars > 0) && (size + 2 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xc0 | ((codepoint >> 6) & 0x1f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 2;\n+            }\n+            else if (codepoint <= 0xffff)\n+            {\n+                if (out && (max_chars > 0) && (size + 3 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xe0 | ((codepoint >> 12) & 0x0f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 3;\n+            }\n+            else\n+            {\n+                if (out && (max_chars > 0) && (size + 4 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xf0 | ((codepoint >> 18) & 0x07));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 12) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 4;\n+            }\n+\n+            codepoint = 0;\n+        }\n+\n+        in++; len_w++;\n+    }\n+\n+    return size;\n@@ -239,1 +367,1 @@\n-    cmsUInt32Number i, len = (cmsUInt32Number) strlen(ASCIIString);\n+    cmsUInt32Number i, len = (cmsUInt32Number)strlen(ASCIIString);\n@@ -242,1 +370,1 @@\n-    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Lang = strTo16(LanguageCode);\n@@ -250,1 +378,2 @@\n-        len = 1;\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n@@ -253,1 +382,1 @@\n-    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, len,  sizeof(wchar_t));\n+    WStr = (wchar_t*)_cmsCalloc(mlu->ContextID, len, sizeof(wchar_t));\n@@ -256,2 +385,2 @@\n-    for (i=0; i < len; i++)\n-        WStr[i] = (wchar_t) ASCIIString[i];\n+    for (i = 0; i < len; i++)\n+        WStr[i] = (wchar_t)ASCIIString[i];\n@@ -259,1 +388,1 @@\n-    rc = AddMLUBlock(mlu, len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+    rc = AddMLUBlock(mlu, len * sizeof(wchar_t), WStr, Lang, Cntry);\n@@ -261,1 +390,1 @@\n-    _cmsFree(mlu ->ContextID, WStr);\n+    _cmsFree(mlu->ContextID, WStr);\n@@ -266,0 +395,33 @@\n+\/\/ Add an UTF8 entry. Do not add any \\0 termination (ICC1v43_2010-12.pdf page 61)\n+\/\/ In the case the user explicitly sets an empty string, we force a \\0\n+cmsBool CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu, const char LanguageCode[3], const char CountryCode[3], const char* UTF8String)\n+{\n+    cmsUInt32Number UTF8len;\n+    wchar_t* WStr;\n+    cmsBool  rc;\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    if (mlu == NULL) return FALSE;\n+\n+    if (*UTF8String == '\\0')\n+    {\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n+    }\n+\n+    \/\/ Len excluding terminator 0\n+    UTF8len = decodeUTF8(NULL, UTF8String);\n+\n+    \/\/ Get space for dest\n+    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, UTF8len,  sizeof(wchar_t));\n+    if (WStr == NULL) return FALSE;\n+\n+    decodeUTF8(WStr, UTF8String);\n+\n+    rc = AddMLUBlock(mlu, UTF8len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+\n+    _cmsFree(mlu ->ContextID, WStr);\n+    return rc;\n+}\n+\n@@ -404,1 +566,1 @@\n-    return(wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n+    return (wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n@@ -442,2 +604,4 @@\n-        if (Wide[i] == 0)\n-            Buffer[i] = 0;\n+        wchar_t wc = Wide[i];\n+\n+        if (wc < 0xff)\n+            Buffer[i] = (char)wc;\n@@ -445,1 +609,1 @@\n-            Buffer[i] = (char) Wide[i];\n+            Buffer[i] = '?';\n@@ -453,0 +617,40 @@\n+\n+\/\/ Obtain a UTF8 representation of the wide string. Setting buffer to NULL returns the len\n+cmsUInt32Number CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                       const char LanguageCode[3], const char CountryCode[3],\n+                                       char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const wchar_t *Wide;\n+    cmsUInt32Number  StrLen = 0;\n+    cmsUInt32Number UTF8len;\n+\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    \/\/ Sanitize\n+    if (mlu == NULL) return 0;\n+\n+    \/\/ Get WideChar\n+    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n+    if (Wide == NULL) return 0;\n+\n+    UTF8len = encodeUTF8(NULL, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ Maybe we want only to know the len?\n+    if (Buffer == NULL) return UTF8len + 1; \/\/ Note the zero at the end\n+\n+    \/\/ No buffer size means no data\n+    if (BufferSize <= 0) return 0;\n+\n+    \/\/ Some clipping may be required\n+    if (BufferSize < UTF8len + 1)\n+        UTF8len = BufferSize - 1;\n+\n+    \/\/ Process it\n+    encodeUTF8(Buffer, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ We put a termination \"\\0\"\n+    Buffer[UTF8len] = 0;\n+    return UTF8len + 1;\n+}\n+\n@@ -473,2 +677,2 @@\n-  \/\/ No buffer size means no data\n-    if (BufferSize <= 0) return 0;\n+    \/\/ Invalid buffer size means no data\n+    if (BufferSize < sizeof(wchar_t)) return 0;\n@@ -478,1 +682,1 @@\n-        StrLen = BufferSize - + sizeof(wchar_t);\n+        StrLen = BufferSize - sizeof(wchar_t);\n@@ -846,4 +1050,11 @@\n-    for (i=0; i < pseq ->n; i++) {\n-        if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n-        if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n-        if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+    if (pseq == NULL)\n+        return;\n+\n+    if (pseq ->seq != NULL) {\n+        for (i=0; i < pseq ->n; i++) {\n+            if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n+            if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n+            if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+        }\n+\n+        _cmsFree(pseq ->ContextID, pseq ->seq);\n@@ -852,1 +1063,0 @@\n-    if (pseq ->seq != NULL) _cmsFree(pseq ->ContextID, pseq ->seq);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsnamed.c","additions":230,"deletions":20,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+\n@@ -1145,1 +1146,4 @@\n-            Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        {\n+            if (Trans[t]->Table16 != NULL)\n+                Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        }\n@@ -1152,1 +1156,1 @@\n-    \/\/ Check for validity\n+    \/\/ Check for validity. lIsLinear is here for debug purposes\n@@ -1756,0 +1760,2 @@\n+                     if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3) return FALSE;\n+\n@@ -1800,1 +1806,1 @@\n-        \/\/ the cache that with the pixel handling\n+        \/\/ the cache than with the pixel handling\n@@ -1957,1 +1963,1 @@\n-        if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n+            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsopt.c","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2983,0 +2983,102 @@\n+static\n+cmsUInt8Number* PackBytesFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt8Number* swap1 = (cmsUInt8Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt8Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv =  FROM_16_TO_8(_cmsQuickSaturateWord(v));\n+\n+        if (Planar)\n+            ((cmsUInt8Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt8Number*)output)[i + start] = vv;\n+    }\n+\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt8Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt8Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt8Number);\n+}\n+\n+static\n+cmsUInt8Number* PackWordsFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt16Number* swap1 = (cmsUInt16Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt16Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv = _cmsQuickSaturateWord(v);\n+\n+        if (Planar)\n+            ((cmsUInt16Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt16Number*)output)[i + start] = vv;\n+    }\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt16Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt16Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt16Number);\n+}\n+\n+\n@@ -3146,0 +3248,71 @@\n+static\n+cmsUInt8Number* PackEncodedBytesLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncoded(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        output[0]        = wlab[0] >> 8;\n+        output[Stride]   = wlab[1] >> 8;\n+        output[Stride*2] = wlab[2] >> 8;\n+\n+        return output + 1;\n+    }\n+    else {\n+\n+        output[0] = wlab[0] >> 8;\n+        output[1] = wlab[1] >> 8;\n+        output[2] = wlab[2] >> 8;\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat));\n+    }\n+}\n+\n+static\n+cmsUInt8Number* PackEncodedWordsLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncodedV2(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        ((cmsUInt16Number*) output)[0]        = wlab[0];\n+        ((cmsUInt16Number*) output)[Stride]   = wlab[1];\n+        ((cmsUInt16Number*) output)[Stride*2] = wlab[2];\n+\n+        return output + sizeof(cmsUInt16Number);\n+    }\n+    else {\n+\n+         ((cmsUInt16Number*) output)[0] = wlab[0];\n+         ((cmsUInt16Number*) output)[1] = wlab[1];\n+         ((cmsUInt16Number*) output)[2] = wlab[2];\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat)) * sizeof(cmsUInt16Number);\n+    }\n+}\n+\n+\n@@ -3679,0 +3852,3 @@\n+    {     TYPE_LabV2_8,                                                ANYPLANAR|ANYEXTRA,   PackEncodedBytesLabV2FromFloat},\n+    {     TYPE_LabV2_16,                                               ANYPLANAR|ANYEXTRA,   PackEncodedWordsLabV2FromFloat},\n+\n@@ -3683,0 +3859,7 @@\n+\n+    {     BYTES_SH(2), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackWordsFromFloat },\n+\n+    {     BYTES_SH(1), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackBytesFromFloat },\n+\n@@ -3893,1 +4076,1 @@\n-    cmsUInt32Number nOutputChans = cmsChannelsOf(ColorSpace);\n+    cmsInt32Number  nOutputChans = cmsChannelsOfColorSpace(ColorSpace);\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmspack.c","additions":184,"deletions":1,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -396,6 +396,1 @@\n-       cmsUInt8Number  msb, lsb;\n-\n-       lsb = (cmsUInt8Number) (fixed8 & 0xff);\n-       msb = (cmsUInt8Number) (((cmsUInt16Number) fixed8 >> 8) & 0xff);\n-\n-       return (cmsFloat64Number) ((cmsFloat64Number) msb + ((cmsFloat64Number) lsb \/ 256.0));\n+    return fixed8 \/ 256.0;\n@@ -413,13 +408,1 @@\n-    cmsFloat64Number floater, sign, mid;\n-    int Whole, FracPart;\n-\n-    sign  = (fix32 < 0 ? -1 : 1);\n-    fix32 = abs(fix32);\n-\n-    Whole     = (cmsUInt16Number)(fix32 >> 16) & 0xffff;\n-    FracPart  = (cmsUInt16Number)(fix32 & 0xffff);\n-\n-    mid     = (cmsFloat64Number) FracPart \/ 65536.0;\n-    floater = (cmsFloat64Number) Whole + mid;\n-\n-    return sign * floater;\n+    return fix32 \/ 65536.0;\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsplugin.c","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -463,6 +463,0 @@\n-static\n-void EmitSafeGuardBegin(cmsIOHANDLER* m, const char* name)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Save previous definition of %s on the operand stack\\n\", name);\n-    _cmsIOPrintf(m, \"currentdict \/%s known { \/%s load } { null } ifelse\\n\", name, name);\n-}\n@@ -470,10 +464,0 @@\n-static\n-void EmitSafeGuardEnd(cmsIOHANDLER* m, const char* name, int depth)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Restore previous definition of %s\\n\", name);\n-    if (depth > 1) {\n-        \/\/ cycle topmost items on the stack to bring the previous definition to the front\n-        _cmsIOPrintf(m, \"%d -1 roll \", depth);\n-    }\n-    _cmsIOPrintf(m, \"dup null eq { pop currentdict \/%s undef } { \/%s exch def } ifelse\\n\", name, name);\n-}\n@@ -484,1 +468,1 @@\n-void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table, const char* name)\n+void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table)\n@@ -489,1 +473,6 @@\n-    if (Table == NULL) return; \/\/ Error\n+    \/**\n+    * On error, empty tables or lienar assume gamma 1.0\n+    *\/\n+    if (Table == NULL ||\n+        Table->nEntries <= 0 ||\n+        cmsIsToneCurveLinear(Table)) {\n@@ -491,1 +480,3 @@\n-    if (Table ->nEntries <= 0) return;  \/\/ Empty table\n+        _cmsIOPrintf(m, \"{ 1 } bind \");\n+        return;\n+    }\n@@ -493,2 +484,0 @@\n-    \/\/ Suppress whole if identity\n-    if (cmsIsToneCurveLinear(Table)) return;\n@@ -499,1 +488,1 @@\n-            _cmsIOPrintf(m, \"\/%s { %g exp } bind def\\n\", name, gamma);\n+            _cmsIOPrintf(m, \"{ %g exp } bind \", gamma);\n@@ -503,2 +492,11 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammatable\");\n-    _cmsIOPrintf(m, \"\/lcms2gammatable [\");\n+    _cmsIOPrintf(m, \"{ \");\n+\n+    \/\/ Bounds check\n+    EmitRangeCheck(m);\n+\n+    \/\/ Emit intepolation code\n+\n+    \/\/ PostScript code                      Stack\n+    \/\/ ===============                      ========================\n+                                            \/\/ v\n+    _cmsIOPrintf(m, \" [\");\n@@ -512,1 +510,1 @@\n-    _cmsIOPrintf(m, \"] def\\n\");\n+    _cmsIOPrintf(m, \"] \");                        \/\/ v tab\n@@ -514,12 +512,0 @@\n-\n-    \/\/ Emit interpolation code\n-\n-    \/\/ PostScript code                            Stack\n-    \/\/ ===============                            ========================\n-                                                  \/\/ v\n-    _cmsIOPrintf(m, \"\/%s {\\n  \", name);\n-\n-    \/\/ Bounds check\n-    EmitRangeCheck(m);\n-\n-    _cmsIOPrintf(m, \"\\n  \/\/lcms2gammatable \");    \/\/ v tab\n@@ -552,3 +538,1 @@\n-    _cmsIOPrintf(m, \"} bind def\\n\");\n-\n-    EmitSafeGuardEnd(m, \"lcms2gammatable\", 1);\n+    _cmsIOPrintf(m, \" } bind \");\n@@ -571,1 +555,1 @@\n-void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[], const char* nameprefix)\n+void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[])\n@@ -574,1 +558,1 @@\n-    static char buffer[2048];\n+\n@@ -582,1 +566,1 @@\n-            _cmsIOPrintf(m, \"\/%s%d \/%s%d load def\\n\", nameprefix, i, nameprefix, i-1);\n+            _cmsIOPrintf(m, \"dup \");\n@@ -585,3 +569,1 @@\n-            snprintf(buffer, sizeof(buffer), \"%s%d\", nameprefix, (int) i);\n-        buffer[sizeof(buffer)-1] = '\\0';\n-            Emit1Gamma(m, g[i], buffer);\n+            Emit1Gamma(m, g[i]);\n@@ -711,1 +693,1 @@\n-    _cmsIOPrintf(m, \"[\");\n+    if (sc.Pipeline != NULL && sc.Pipeline->Params != NULL) {\n@@ -713,2 +695,1 @@\n-    for (i=0; i < sc.Pipeline->Params->nInputs; i++)\n-        _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n+        _cmsIOPrintf(m, \"[\");\n@@ -716,1 +697,2 @@\n-    _cmsIOPrintf(m, \" [\\n\");\n+        for (i = 0; i < sc.Pipeline->Params->nInputs; i++)\n+            _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n@@ -718,1 +700,1 @@\n-    cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*) &sc, SAMPLER_INSPECT);\n+        _cmsIOPrintf(m, \" [\\n\");\n@@ -720,3 +702,6 @@\n-    _cmsIOPrintf(m, PostMin);\n-    _cmsIOPrintf(m, PostMaj);\n-    _cmsIOPrintf(m, \"] \");\n+        cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*)&sc, SAMPLER_INSPECT);\n+\n+        _cmsIOPrintf(m, PostMin);\n+        _cmsIOPrintf(m, PostMaj);\n+        _cmsIOPrintf(m, \"] \");\n+    }\n@@ -736,2 +721,3 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc\");\n-    Emit1Gamma(m, Curve, \"lcms2gammaproc\");\n+    _cmsIOPrintf(m, \"\/DecodeA \");\n+\n+    Emit1Gamma(m, Curve);\n@@ -739,2 +725,1 @@\n-    _cmsIOPrintf(m, \"\/DecodeA \/lcms2gammaproc load\\n\");\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc\", 3);\n+    _cmsIOPrintf(m, \" \\n\");\n@@ -764,0 +749,3 @@\n+    _cmsIOPrintf(m, \"\/DecodeABC [ \");\n+\n+    EmitNGamma(m, 3, CurveSet);\n@@ -765,8 +753,0 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc0\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc1\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc2\");\n-    EmitNGamma(m, 3, CurveSet, \"lcms2gammaproc\");\n-    _cmsIOPrintf(m, \"\/DecodeABC [\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc0 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc1 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc2 load\\n\");\n@@ -774,3 +754,0 @@\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc2\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc1\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc0\", 3);\n@@ -808,1 +785,1 @@\n-    const char* PreMin, * PostMin;\n+    const char* PreMin, *PostMin;\n@@ -810,2 +787,0 @@\n-    int i, numchans;\n-    static char buffer[2048];\n@@ -840,13 +815,2 @@\n-        numchans = (int) cmsStageOutputChannels(mpe);\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardBegin(m, buffer);\n-        }\n-        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe), \"lcms2gammaproc\");\n-        _cmsIOPrintf(m, \"\/DecodeDEF [\\n\");\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"  \/lcms2gammaproc%d load\\n\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            _cmsIOPrintf(m, buffer);\n-        }\n+        _cmsIOPrintf(m, \"\/DecodeDEF [ \");\n+        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe));\n@@ -854,5 +818,0 @@\n-        for (i = numchans - 1; i >= 0; --i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardEnd(m, buffer, 3);\n-        }\n@@ -860,1 +819,1 @@\n-        mpe = mpe->Next;\n+        mpe = mpe ->Next;\n@@ -865,3 +824,3 @@\n-        _cmsIOPrintf(m, \"\/Table \");\n-        WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature)0);\n-        _cmsIOPrintf(m, \"]\\n\");\n+            _cmsIOPrintf(m, \"\/Table \");\n+            WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature) 0);\n+            _cmsIOPrintf(m, \"]\\n\");\n@@ -1027,3 +986,3 @@\n-            rc = EmitCIEBasedABC(m, (cmsFloat64Number *)&Mat,\n-                _cmsStageGetPtrToCurveSet(Shaper),\n-                &BlackPointAdaptedToD50);\n+            rc = EmitCIEBasedABC(m,  (cmsFloat64Number *) &Mat,\n+                                _cmsStageGetPtrToCurveSet(Shaper),\n+                                 &BlackPointAdaptedToD50);\n@@ -1056,0 +1015,2 @@\n+    cmsCloseProfile(hLab);\n+\n@@ -1059,1 +1020,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1068,1 +1032,0 @@\n-\n@@ -1083,2 +1046,0 @@\n-\n-\n@@ -1088,1 +1049,0 @@\n-    cmsCloseProfile(hLab);\n@@ -1342,1 +1302,1 @@\n-\n+    cmsStage* first;\n@@ -1369,1 +1329,0 @@\n-\n@@ -1377,2 +1336,4 @@\n-    if (DeviceLink == NULL) return 0;\n-\n+    if (DeviceLink == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1380,1 +1341,1 @@\n-    \/\/ We need a CLUT\n+     \/\/ We need a CLUT\n@@ -1407,2 +1368,4 @@\n-\n-    WriteCLUT(m, cmsPipelineGetPtrToFirstStage(DeviceLink), \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    first = cmsPipelineGetPtrToFirstStage(DeviceLink);\n+    if (first != NULL) {\n+        WriteCLUT(m, first, \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    }\n@@ -1417,1 +1380,0 @@\n-\n@@ -1480,1 +1442,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsps2.c","additions":76,"deletions":111,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    \/\/ Force it to be neutral, check for inconsistences\n+    \/\/ Force it to be neutral, check for inconsistencies\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmssamp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additons\n+\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additions\n@@ -957,0 +957,1 @@\n+    wchar_t* UnicodeString = NULL;\n@@ -976,1 +977,1 @@\n-    mlu = cmsMLUalloc(self ->ContextID, 1);\n+    mlu = cmsMLUalloc(self ->ContextID, 2);\n@@ -1001,1 +1002,11 @@\n-    if (SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+    if (UnicodeCount == 0 || SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+\n+    UnicodeString = (wchar_t*)_cmsMallocZero(self->ContextID, (UnicodeCount + 1) * sizeof(wchar_t));\n+    if (UnicodeString == NULL) goto Done;\n+\n+    if (!_cmsReadWCharArray(io, UnicodeCount, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n+    }\n+\n+    UnicodeString[UnicodeCount] = 0;\n@@ -1003,2 +1014,3 @@\n-    for (i=0; i < UnicodeCount; i++) {\n-        if (!io ->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) goto Done;\n+    if (!cmsMLUsetWide(mlu, cmsV2Unicode, cmsV2Unicode, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n@@ -1006,0 +1018,4 @@\n+\n+    _cmsFree(self->ContextID, (void*)UnicodeString);\n+    UnicodeString = NULL;\n+\n@@ -1009,1 +1025,1 @@\n-    \/\/ data that stricttly required. We need to skip it as this type may come\n+    \/\/ data that strictly required. We need to skip it as this type may come\n@@ -1029,0 +1045,1 @@\n+    if (UnicodeString)  _cmsFree(self->ContextID, (void*)UnicodeString);\n@@ -1081,1 +1098,1 @@\n-        cmsMLUgetWide(mlu,  cmsNoLanguage, cmsNoCountry,  Wide, len * sizeof(wchar_t));\n+        cmsMLUgetWide(mlu,  cmsV2Unicode,  cmsV2Unicode,  Wide, len * sizeof(wchar_t));\n@@ -1580,2 +1597,0 @@\n-        NumOfWchar = 0;\n-\n@@ -1943,1 +1958,1 @@\n-cmsBool  Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+cmsBool Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n@@ -1956,0 +1971,6 @@\n+\n+    if (mpe == NULL) {  \/\/ Should never be empty. Corrupted?\n+        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"empty LUT8 is not supported\");\n+        return FALSE;\n+    }\n+\n@@ -2697,2 +2718,2 @@\n-        if ((Curves[i] ->nSegments == 0)||\n-            ((Curves[i]->nSegments == 2) && (Curves[i] ->Segments[1].Type == 0)) )\n+        if ((Curves[i] ->nSegments == 0) ||                                         \/\/ 16 bits tabulated\n+            ((Curves[i]->nSegments == 3) && (Curves[i] ->Segments[1].Type == 0)) )  \/\/ Floating-point tabulated\n@@ -4462,2 +4483,2 @@\n-    if (InputChans == 0) goto Error;\n-    if (OutputChans == 0) goto Error;\n+    if (InputChans == 0 || InputChans >= cmsMAXCHANNELS) goto Error;\n+    if (OutputChans == 0 || OutputChans >= cmsMAXCHANNELS) goto Error;\n@@ -5253,1 +5274,2 @@\n-    e ->Offsets[i] = Before - BaseOffset;\n+    if (e->Offsets != NULL)\n+        e ->Offsets[i] = Before - BaseOffset;\n@@ -5257,1 +5279,2 @@\n-    e ->Sizes[i] = io ->Tell(io) - Before;\n+    if (e->Sizes != NULL)\n+        e ->Sizes[i] = io ->Tell(io) - Before;\n@@ -5502,0 +5525,210 @@\n+\n+\/\/ ********************************************************************************\n+\/\/ Microsoft's MHC2 Type support\n+\/\/ ********************************************************************************\n+\n+static\n+void SetIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    XYZ2XYZmatrix[0][0] = 1.0; XYZ2XYZmatrix[0][1] = 0.0; XYZ2XYZmatrix[0][2] = 0.0; XYZ2XYZmatrix[0][3] = 0.0;\n+    XYZ2XYZmatrix[1][0] = 0.0; XYZ2XYZmatrix[1][1] = 1.0; XYZ2XYZmatrix[1][2] = 0.0; XYZ2XYZmatrix[1][3] = 0.0;\n+    XYZ2XYZmatrix[2][0] = 0.0; XYZ2XYZmatrix[2][1] = 0.0; XYZ2XYZmatrix[2][2] = 1.0; XYZ2XYZmatrix[2][3] = 0.0;\n+}\n+\n+static\n+cmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)\n+{\n+    return fabs(b - a) < (1.0 \/ 65535.0);\n+}\n+\n+cmsBool IsIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    cmsFloat64Number Identity[3][4];\n+    int i, j;\n+\n+    SetIdentity(Identity);\n+\n+    for (i = 0; i < 3; i++)\n+        for (j = 0; j < 4; j++)\n+            if (!CloseEnough(XYZ2XYZmatrix[i][j], Identity[i][j])) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void Type_MHC2_Free(struct _cms_typehandler_struct* self, void* Ptr)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+\n+    if (mhc2->RedCurve != NULL) _cmsFree(self->ContextID, mhc2->RedCurve);\n+    if (mhc2->GreenCurve != NULL) _cmsFree(self->ContextID, mhc2->GreenCurve);\n+    if (mhc2->BlueCurve != NULL) _cmsFree(self->ContextID, mhc2->BlueCurve);\n+\n+    _cmsFree(self->ContextID, Ptr);\n+}\n+\n+void* Type_MHC2_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n+{\n+    cmsMHC2Type* mhc2 = _cmsDupMem(self->ContextID, Ptr, sizeof(cmsMHC2Type));\n+\n+    mhc2->RedCurve = _cmsDupMem(self->ContextID,   mhc2->RedCurve, mhc2->CurveEntries*sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = _cmsDupMem(self->ContextID, mhc2->GreenCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = _cmsDupMem(self->ContextID,  mhc2->BlueCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL) {\n+\n+        Type_MHC2_Free(self, mhc2);\n+        return NULL;\n+    }\n+\n+    return mhc2;\n+\n+    cmsUNUSED_PARAMETER(n);\n+}\n+\n+\n+static\n+cmsBool WriteDoubles(cmsIOHANDLER* io, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsWrite15Fixed16Number(io, *Values++)) return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static\n+cmsBool Type_MHC2_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number TablesOffsetPos;\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, mhc2->CurveEntries)) return FALSE;\n+\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->MinLuminance)) return FALSE;\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->PeakLuminance)) return FALSE;\n+\n+    TablesOffsetPos = io->Tell(io);\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Matrix\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve R\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve G\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve B\n+\n+\n+    if (IsIdentity(mhc2->XYZ2XYZmatrix))\n+    {\n+        MatrixOffset = 0;\n+    }\n+    else\n+    {\n+        MatrixOffset = io->Tell(io) - BaseOffset;\n+        if (!WriteDoubles(io, 3 * 4, &mhc2->XYZ2XYZmatrix[0][0])) return FALSE;\n+    }\n+\n+    OffsetRedTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->RedCurve)) return FALSE;\n+    OffsetGreenTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->GreenCurve)) return FALSE;\n+    OffsetBlueTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->BlueCurve)) return FALSE;\n+\n+    if (!io->Seek(io, TablesOffsetPos)) return FALSE;\n+\n+    if (!_cmsWriteUInt32Number(io, MatrixOffset)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetRedTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetGreenTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetBlueTable)) return FALSE;\n+\n+    return TRUE;\n+\n+    cmsUNUSED_PARAMETER(self);\n+    cmsUNUSED_PARAMETER(nItems);\n+}\n+\n+\n+static\n+cmsBool ReadDoublesAt(cmsIOHANDLER* io, cmsUInt32Number At, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number CurrentPos = io->Tell(io);\n+    cmsUInt32Number i;\n+\n+    if (!io->Seek(io, At)) return FALSE;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsRead15Fixed16Number(io, Values++)) return FALSE;\n+    }\n+\n+    if (!io->Seek(io, CurrentPos)) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void* Type_MHC2_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n+{\n+    cmsMHC2Type* mhc2 = NULL;\n+\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n+\n+    mhc2 = (cmsMHC2Type*)_cmsCalloc(self->ContextID, 1, sizeof(cmsMHC2Type));\n+    if (mhc2 == NULL) return NULL;\n+\n+    if (!_cmsReadUInt32Number(io,    &mhc2->CurveEntries)) goto Error;\n+\n+    if (mhc2->CurveEntries > 4096) goto Error;\n+\n+    mhc2->RedCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL)  goto Error;\n+\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->MinLuminance)) goto Error;\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->PeakLuminance)) goto Error;\n+\n+    if (!_cmsReadUInt32Number(io, &MatrixOffset)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetRedTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetGreenTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetBlueTable)) goto Error;\n+\n+    if (MatrixOffset == 0)\n+        SetIdentity(mhc2->XYZ2XYZmatrix);\n+    else\n+    {\n+        if (!ReadDoublesAt(io, BaseOffset + MatrixOffset, 3*4, &mhc2->XYZ2XYZmatrix[0][0])) goto Error;\n+    }\n+\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetRedTable, mhc2->CurveEntries, mhc2->RedCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetGreenTable, mhc2->CurveEntries, mhc2->GreenCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetBlueTable, mhc2->CurveEntries, mhc2->BlueCurve)) goto Error;\n+\n+    \/\/ Success\n+    *nItems = 1;\n+    return mhc2;\n+\n+Error:\n+    Type_MHC2_Free(self, mhc2);\n+    return NULL;\n+\n+    cmsUNUSED_PARAMETER(SizeOfTag);\n+}\n+\n+\n+\n@@ -5541,1 +5774,2 @@\n-{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),                NULL }\n+{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),               (_cmsTagTypeLinkedList*) &SupportedTagTypes[32] },\n+{TYPE_HANDLER(cmsSigMHC2Type,                  MHC2),                NULL }\n@@ -5737,1 +5971,2 @@\n-    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, NULL}\n+    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, &SupportedTags[65]},\n+    { cmsSigMHC2Tag,                { 1, 1, { cmsSigMHC2Type },              NULL}, NULL}\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmstypes.c","additions":253,"deletions":18,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -438,2 +438,2 @@\n-        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 0..400\");\n-        if (Limit < 0) Limit = 0;\n+        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 1..400\");\n+        if (Limit < 1) Limit = 1;\n@@ -441,1 +441,0 @@\n-\n@@ -704,0 +703,121 @@\n+\/**\n+* Oklab colorspace profile (experimental)\n+*\n+* This virtual profile cannot be saved as an ICC file\n+*\/\n+cmsHPROFILE cmsCreate_OkLabProfile(cmsContext ctx)\n+{\n+    cmsStage* XYZPCS = _cmsStageNormalizeFromXyzFloat(ctx);\n+    cmsStage* PCSXYZ = _cmsStageNormalizeToXyzFloat(ctx);\n+\n+    const double M_D65_D50[] =\n+    {\n+       1.047886, 0.022919, -0.050216,\n+       0.029582, 0.990484, -0.017079,\n+      -0.009252, 0.015073,  0.751678\n+    };\n+\n+    const double M_D50_D65[] =\n+    {\n+         0.955512609517083, -0.023073214184645,  0.063308961782107,\n+        -0.028324949364887,  1.009942432477107,  0.021054814890112,\n+         0.012328875695483, -0.020535835374141,  1.330713916450354\n+    };\n+\n+    cmsStage* D65toD50 = cmsStageAllocMatrix(ctx, 3, 3, M_D65_D50, NULL);\n+    cmsStage* D50toD65 = cmsStageAllocMatrix(ctx, 3, 3, M_D50_D65, NULL);\n+\n+    const double M_D65_LMS[] =\n+    {\n+        0.8189330101, 0.3618667424, -0.1288597137,\n+        0.0329845436, 0.9293118715,  0.0361456387,\n+        0.0482003018, 0.2643662691,  0.6338517070\n+    };\n+\n+    const double M_LMS_D65[] =\n+    {\n+        1.227013851103521, -0.557799980651822,  0.281256148966468,\n+       -0.040580178423281,  1.112256869616830, -0.071676678665601,\n+       -0.076381284505707, -0.421481978418013,  1.586163220440795\n+    };\n+\n+    cmsStage* D65toLMS = cmsStageAllocMatrix(ctx, 3, 3, M_D65_LMS, NULL);\n+    cmsStage* LMStoD65 = cmsStageAllocMatrix(ctx, 3, 3, M_LMS_D65, NULL);\n+\n+    cmsToneCurve* CubeRoot = cmsBuildGamma(ctx, 1.0 \/ 3.0);\n+    cmsToneCurve* Cube     = cmsBuildGamma(ctx,  3.0);\n+\n+    cmsToneCurve* Roots[3] = { CubeRoot, CubeRoot, CubeRoot };\n+    cmsToneCurve* Cubes[3] = { Cube, Cube, Cube };\n+\n+    cmsStage* NonLinearityFw = cmsStageAllocToneCurves(ctx, 3, Roots);\n+    cmsStage* NonLinearityRv = cmsStageAllocToneCurves(ctx, 3, Cubes);\n+\n+    const double M_LMSprime_OkLab[] =\n+    {\n+        0.2104542553,  0.7936177850, -0.0040720468,\n+        1.9779984951, -2.4285922050,  0.4505937099,\n+        0.0259040371,  0.7827717662, -0.8086757660\n+    };\n+\n+    const double M_OkLab_LMSprime[] =\n+    {\n+        0.999999998450520,  0.396337792173768,  0.215803758060759,\n+        1.000000008881761, -0.105561342323656, -0.063854174771706,\n+        1.000000054672411, -0.089484182094966, -1.291485537864092\n+    };\n+\n+    cmsStage* LMSprime_OkLab = cmsStageAllocMatrix(ctx, 3, 3, M_LMSprime_OkLab, NULL);\n+    cmsStage* OkLab_LMSprime = cmsStageAllocMatrix(ctx, 3, 3, M_OkLab_LMSprime, NULL);\n+\n+    cmsPipeline* AToB = cmsPipelineAlloc(ctx, 3, 3);\n+    cmsPipeline* BToA = cmsPipelineAlloc(ctx, 3, 3);\n+\n+    cmsHPROFILE hProfile = cmsCreateProfilePlaceholder(ctx);\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n+    cmsSetColorSpace(hProfile, cmsSig3colorData);\n+    cmsSetPCS(hProfile, cmsSigXYZData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_RELATIVE_COLORIMETRIC);\n+\n+    \/**\n+    * Conversion PCS (XYZ\/D50) to OkLab\n+    *\/\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, PCSXYZ)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D50toD65)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D65toLMS)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, NonLinearityFw)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, LMSprime_OkLab)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA)) goto error;\n+\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, OkLab_LMSprime)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, NonLinearityRv)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, LMStoD65)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, D65toD50)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, XYZPCS)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, AToB)) goto error;\n+\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+\n+    return hProfile;\n+\n+error:\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+    cmsCloseProfile(hProfile);\n+\n+    return NULL;\n+\n+}\n@@ -1063,1 +1183,1 @@\n-        if (n > Tab ->nTypes) return FALSE;\n+        if (n >= Tab ->nTypes) return FALSE;\n@@ -1094,3 +1214,3 @@\n-        cmsUInt32Number FrmIn, FrmOut;\n-        cmsInt32Number ChansIn, ChansOut;\n-        int ColorSpaceBitsIn, ColorSpaceBitsOut;\n+    cmsUInt32Number FrmIn, FrmOut;\n+    cmsInt32Number ChansIn, ChansOut;\n+    int ColorSpaceBitsIn, ColorSpaceBitsOut;\n@@ -1107,0 +1227,3 @@\n+    \/\/ Check if the pipeline holding is valid\n+    if (xform -> Lut == NULL) return NULL;\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsvirt.c","additions":130,"deletions":7,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-    if (_cmsFormatterIsFloat(*OutputFormat)) {\n+    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) {\n@@ -1021,0 +1021,13 @@\n+    \/**\n+    * Check consistency for alpha channel copy\n+    *\/\n+    if (*dwFlags & cmsFLAGS_COPY_ALPHA)\n+    {\n+        if (T_EXTRA(*InputFormat) != T_EXTRA(*OutputFormat))\n+        {\n+            cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, \"Mismatched alpha channels\");\n+            cmsDeleteTransform(p);\n+            return NULL;\n+        }\n+    }\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/cmsxform.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-\/\/ Version 2.15\n+\/\/ Version 2.16\n@@ -108,0 +108,3 @@\n+#       if __cplusplus >= 201703L\n+#            define CMS_NO_REGISTER_KEYWORD 1\n+#       endif\n@@ -113,1 +116,1 @@\n-#define LCMS_VERSION        2150\n+#define LCMS_VERSION        2160\n@@ -357,1 +360,2 @@\n-    cmsSigXYZType                           = 0x58595A20   \/\/ 'XYZ '\n+    cmsSigXYZType                           = 0x58595A20,  \/\/ 'XYZ '\n+    cmsSigMHC2Type                          = 0x4D484332   \/\/ 'MHC2'\n@@ -435,1 +439,2 @@\n-    cmsSigArgyllArtsTag                     = 0x61727473   \/\/ 'arts'\n+    cmsSigArgyllArtsTag                     = 0x61727473,  \/\/ 'arts'\n+    cmsSigMHC2Tag                           = 0x4D484332   \/\/ 'MHC2'\n@@ -980,0 +985,1 @@\n+#define TYPE_OKLAB_DBL        (FLOAT_SH(1)|COLORSPACE_SH(PT_MCH3)|CHANNELS_SH(3)|BYTES_SH(0))\n@@ -1080,0 +1086,13 @@\n+typedef struct {\n+    cmsUInt32Number   CurveEntries;\n+    cmsFloat64Number* RedCurve;\n+    cmsFloat64Number* GreenCurve;\n+    cmsFloat64Number* BlueCurve;\n+\n+    cmsFloat64Number  MinLuminance;         \/\/ ST.2086 min luminance in nits\n+    cmsFloat64Number  PeakLuminance;        \/\/ ST.2086 peak luminance in nits\n+\n+    cmsFloat64Number XYZ2XYZmatrix[3][4];\n+\n+} cmsMHC2Type;\n+\n@@ -1252,1 +1271,2 @@\n-CMSAPI cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t);\n+\n+CMSAPI const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t);\n@@ -1346,2 +1366,5 @@\n-#define  cmsNoLanguage \"\\0\\0\"\n-#define  cmsNoCountry  \"\\0\\0\"\n+#define  cmsNoLanguage    \"\\0\\0\"\n+#define  cmsNoCountry     \"\\0\\0\"\n+\n+\/\/ Special language\/country to retrieve unicode field for description in V2 profiles. Use with care.\n+#define  cmsV2Unicode     \"\\xff\\xff\"\n@@ -1359,0 +1382,3 @@\n+CMSAPI cmsBool           CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu,\n+                                                  const char LanguageCode[3], const char CountryCode[3],\n+                                                  const char* UTF8String);\n@@ -1367,0 +1393,4 @@\n+CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                                 const char LanguageCode[3], const char CountryCode[3],\n+                                                 char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1591,0 +1621,4 @@\n+CMSAPI cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                            const char LanguageCode[3], const char CountryCode[3],\n+                                                            char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1653,0 +1687,3 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName);\n+\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName);\n@@ -1665,0 +1702,2 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreate_OkLabProfile(cmsContext ctx);\n+\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/lcms2.h","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+#          pragma warning(disable : 4127)\n@@ -548,1 +549,1 @@\n-    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is hold in the suballocator.\n+    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is held in the suballocator.\n@@ -842,0 +843,3 @@\n+    \/\/ Color management module identification\n+    cmsUInt32Number          CMM;\n+\n@@ -849,0 +853,1 @@\n+    cmsPlatformSignature     platform;\n","filename":"jdk\/src\/share\/native\/sun\/java2d\/cmm\/lcms\/lcms2_internal.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}